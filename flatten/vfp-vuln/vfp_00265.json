{
    "vfp_id": "vfp_00265",
    "project_name": "Mitosis - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Missing unstake-amount validation",
            "description": "The _requestUnstake function in the ValidatorStaking contract does not validate that the unstaking amount is less than or equal to the user's staked balance, only checking that it meets a minimum threshold. This is a critical coding mistake because the underlying checkpointing system uses unchecked arithmetic, which allows underflows. An attacker can exploit this by attempting to unstake more than their balance, causing an underflow in the _opSub function due to the unchecked block. This would result in an artificially inflated balance being subtracted, effectively allowing the attacker to withdraw far more tokens than they should be entitled to. The impact is severe, as it could allow malicious users to drain the entire vault, affecting all users' funds.\n",
            "severity": "Critical",
            "location": [
                "protocol/src/hub/staking/ValidatorStaking.sol"
            ],
            "files": [
                "f18b1965c3d5816e422edb206efe598f0fb39899/protocol/src/hub/validator/ValidatorStaking.sol"
            ]
        }
    ],
    "affected_files": {
        "ValidatorStaking.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { SafeCast } from '@oz/utils/math/SafeCast.sol';\nimport { ReentrancyGuardTransient } from '@oz/utils/ReentrancyGuardTransient.sol';\nimport { Checkpoints } from '@oz/utils/structs/Checkpoints.sol';\nimport { Time } from '@oz/utils/types/Time.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { SafeTransferLib } from '@solady/utils/SafeTransferLib.sol';\n\nimport { IValidatorManager } from '../../interfaces/hub/validator/IValidatorManager.sol';\nimport { IValidatorStaking } from '../../interfaces/hub/validator/IValidatorStaking.sol';\nimport { IValidatorStakingHub } from '../../interfaces/hub/validator/IValidatorStakingHub.sol';\nimport { ERC7201Utils } from '../../lib/ERC7201Utils.sol';\nimport { LibQueue } from '../../lib/LibQueue.sol';\nimport { StdError } from '../../lib/StdError.sol';\n\ncontract ValidatorStakingStorageV1 {\n  using ERC7201Utils for string;\n\n  struct StorageV1 {\n    // configs\n    uint48 unstakeCooldown;\n    uint48 redelegationCooldown;\n    uint256 minStakingAmount;\n    uint256 minUnstakingAmount;\n    // states\n    Checkpoints.Trace208 totalStaked;\n    Checkpoints.Trace208 totalUnstaking;\n    mapping(address staker => LibQueue.Trace208OffsetQueue) unstakeQueue;\n    mapping(address staker => Checkpoints.Trace208) stakerTotal;\n    mapping(address valAddr => Checkpoints.Trace208) validatorTotal;\n    mapping(address valAddr => mapping(address staker => Checkpoints.Trace208)) staked;\n    mapping(address staker => mapping(address valAddr => uint256)) lastRedelegationTime;\n  }\n\n  string private constant _NAMESPACE = 'mitosis.storage.ValidatorStaking.v1';\n  bytes32 private immutable _slot = _NAMESPACE.storageSlot();\n\n  function _getStorageV1() internal view returns (StorageV1 storage $) {\n    bytes32 slot = _slot;\n    // slither-disable-next-line assembly\n    assembly {\n      $.slot := slot\n    }\n  }\n}\n\ncontract ValidatorStaking is\n  IValidatorStaking,\n  ValidatorStakingStorageV1,\n  Ownable2StepUpgradeable,\n  ReentrancyGuardTransient,\n  UUPSUpgradeable\n{\n  using SafeCast for uint256;\n  using SafeTransferLib for address;\n  using Checkpoints for Checkpoints.Trace208;\n  using LibQueue for LibQueue.Trace208OffsetQueue;\n\n  address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  address private immutable _baseAsset;\n  IValidatorManager private immutable _manager;\n  IValidatorStakingHub private immutable _hub;\n\n  constructor(address baseAsset_, IValidatorManager manager_, IValidatorStakingHub hub_) {\n    _baseAsset = baseAsset_ == address(0) ? NATIVE_TOKEN : baseAsset_;\n    _manager = manager_;\n    _hub = hub_;\n\n    _disableInitializers();\n  }\n\n  function initialize(\n    address initialOwner,\n    uint256 initialMinStakingAmount,\n    uint256 initialMinUnstakingAmount,\n    uint48 unstakeCooldown_,\n    uint48 redelegationCooldown_\n  ) public virtual initializer {\n    __Ownable_init(initialOwner);\n    __Ownable2Step_init();\n    __UUPSUpgradeable_init();\n\n    StorageV1 storage $ = _getStorageV1();\n    _setMinStakingAmount($, initialMinStakingAmount);\n    _setMinUnstakingAmount($, initialMinUnstakingAmount);\n    _setUnstakeCooldown($, unstakeCooldown_);\n    _setRedelegationCooldown($, redelegationCooldown_);\n  }\n\n  // ===================================== VIEW FUNCTIONS ===================================== //\n\n  /// @inheritdoc IValidatorStaking\n  function baseAsset() external view returns (address) {\n    return _baseAsset;\n  }\n\n  function manager() external view returns (IValidatorManager) {\n    return _manager;\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function hub() external view returns (IValidatorStakingHub) {\n    return _hub;\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function totalStaked(uint48 timestamp) external view virtual returns (uint256) {\n    return _getStorageV1().totalStaked.upperLookupRecent(timestamp);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function totalUnstaking(uint48 timestamp) external view virtual returns (uint256) {\n    return _getStorageV1().totalUnstaking.upperLookupRecent(timestamp);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function staked(address valAddr, address staker, uint48 timestamp) external view virtual returns (uint256) {\n    return _getStorageV1().staked[valAddr][staker].upperLookupRecent(timestamp);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function stakerTotal(address staker, uint48 timestamp) public view virtual returns (uint256) {\n    return _getStorageV1().stakerTotal[staker].upperLookupRecent(timestamp);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function validatorTotal(address valAddr, uint48 timestamp) external view virtual returns (uint256) {\n    return _getStorageV1().validatorTotal[valAddr].upperLookupRecent(timestamp);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function unstaking(address staker, uint48 timestamp) public view virtual returns (uint256, uint256) {\n    StorageV1 storage $ = _getStorageV1();\n    return $.unstakeQueue[staker].pending(timestamp - $.unstakeCooldown);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function unstakingQueueOffset(address staker) external view returns (uint256) {\n    return _getStorageV1().unstakeQueue[staker].offset();\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function unstakingQueueSize(address staker) external view returns (uint256) {\n    return _getStorageV1().unstakeQueue[staker].size();\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function unstakingQueueRequestByIndex(address staker, uint32 pos) external view returns (uint48, uint208) {\n    return _getStorageV1().unstakeQueue[staker].itemAt(pos);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function unstakingQueueRequestByTime(address staker, uint48 time) external view returns (uint48, uint208) {\n    return _getStorageV1().unstakeQueue[staker].recentItemAt(time);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function minStakingAmount() external view virtual returns (uint256) {\n    return _getStorageV1().minStakingAmount;\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function minUnstakingAmount() external view virtual returns (uint256) {\n    return _getStorageV1().minUnstakingAmount;\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function unstakeCooldown() external view virtual returns (uint48) {\n    return _getStorageV1().unstakeCooldown;\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function redelegationCooldown() external view virtual returns (uint48) {\n    return _getStorageV1().redelegationCooldown;\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function lastRedelegationTime(address staker, address valAddr) external view virtual returns (uint256) {\n    return _getStorageV1().lastRedelegationTime[staker][valAddr];\n  }\n\n  // ===================================== MUTATIVE FUNCTIONS ===================================== //\n\n  /// @inheritdoc IValidatorStaking\n  function stake(address valAddr, address recipient, uint256 amount) external payable returns (uint256) {\n    return _stake(_getStorageV1(), valAddr, _msgSender(), recipient, amount);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function requestUnstake(address valAddr, address receiver, uint256 amount) external returns (uint256) {\n    return _requestUnstake(_getStorageV1(), valAddr, _msgSender(), receiver, amount);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function claimUnstake(address receiver) external nonReentrant returns (uint256) {\n    return _claimUnstake(_getStorageV1(), receiver);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function redelegate(address fromValAddr, address toValAddr, uint256 amount) external returns (uint256) {\n    return _redelegate(_getStorageV1(), _msgSender(), fromValAddr, toValAddr, amount);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function setMinStakingAmount(uint256 minAmount) external onlyOwner {\n    _setMinStakingAmount(_getStorageV1(), minAmount);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function setMinUnstakingAmount(uint256 minAmount) external onlyOwner {\n    _setMinUnstakingAmount(_getStorageV1(), minAmount);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function setUnstakeCooldown(uint48 unstakeCooldown_) external onlyOwner {\n    _setUnstakeCooldown(_getStorageV1(), unstakeCooldown_);\n  }\n\n  /// @inheritdoc IValidatorStaking\n  function setRedelegationCooldown(uint48 redelegationCooldown_) external onlyOwner {\n    _setRedelegationCooldown(_getStorageV1(), redelegationCooldown_);\n  }\n\n  // ===================================== INTERNAL FUNCTIONS ===================================== //\n\n  function _assertUnstakeAmountCondition(StorageV1 storage $, address valAddr, address staker, uint256 amount)\n    internal\n    view\n  {\n    uint256 currentStaked = $.staked[valAddr][staker].latest();\n    uint256 minUnstaking = $.minUnstakingAmount;\n\n    if (amount != currentStaked) {\n      require(amount >= minUnstaking, IValidatorStaking__InsufficientMinimumAmount(minUnstaking));\n    }\n  }\n\n  function _stake(StorageV1 storage $, address valAddr, address payer, address recipient, uint256 amount)\n    internal\n    virtual\n    returns (uint256)\n  {\n    require(amount > 0, StdError.ZeroAmount());\n    require(amount >= $.minStakingAmount, IValidatorStaking__InsufficientMinimumAmount($.minStakingAmount));\n\n    require(_baseAsset != NATIVE_TOKEN || msg.value == amount, StdError.InvalidParameter('amount'));\n    require(recipient != address(0), StdError.InvalidParameter('recipient'));\n    require(_manager.isValidator(valAddr), IValidatorStaking__NotValidator(valAddr));\n\n    // If the base asset is not native, we need to transfer from the sender to the contract\n    if (_baseAsset != NATIVE_TOKEN) _baseAsset.safeTransferFrom(payer, address(this), amount);\n\n    uint48 now_ = Time.timestamp();\n\n    // apply to state\n    {\n      uint208 amount208 = amount.toUint208();\n      _push($.totalStaked, now_, amount208, _opAdd);\n      _storeStake($, now_, valAddr, recipient, amount208);\n    }\n\n    _hub.notifyStake(valAddr, recipient, amount);\n\n    emit Staked(valAddr, payer, recipient, amount);\n\n    return amount;\n  }\n\n  function _requestUnstake(StorageV1 storage $, address valAddr, address payer, address recipient, uint256 amount)\n    internal\n    virtual\n    returns (uint256)\n  {\n    require(amount > 0, StdError.ZeroAmount());\n    require(_manager.isValidator(valAddr), IValidatorStaking__NotValidator(valAddr));\n\n    _assertUnstakeAmountCondition($, valAddr, payer, amount);\n\n    uint48 now_ = Time.timestamp();\n    uint208 amount208 = amount.toUint208();\n    uint256 reqId = $.unstakeQueue[recipient].append(now_, amount208);\n\n    // apply to state\n    {\n      _push($.totalStaked, now_, amount208, _opSub);\n      _push($.totalUnstaking, now_, amount208, _opAdd);\n      _storeUnstake($, now_, valAddr, payer, amount208);\n    }\n\n    _hub.notifyUnstake(valAddr, payer, amount);\n\n    emit UnstakeRequested(valAddr, payer, recipient, amount, reqId);\n\n    return reqId;\n  }\n\n  function _claimUnstake(StorageV1 storage $, address receiver) internal virtual returns (uint256) {\n    LibQueue.Trace208OffsetQueue storage queue = $.unstakeQueue[receiver];\n\n    uint48 now_ = Time.timestamp();\n    (uint32 reqIdFrom, uint32 reqIdTo) = queue.solveByKey(now_ - $.unstakeCooldown);\n    uint256 claimed;\n    {\n      uint256 fromValue = reqIdFrom == 0 ? 0 : queue.valueAt(reqIdFrom - 1);\n      uint256 toValue = queue.valueAt(reqIdTo - 1);\n      claimed = toValue - fromValue;\n    }\n\n    if (_baseAsset == NATIVE_TOKEN) receiver.safeTransferETH(claimed);\n    else _baseAsset.safeTransfer(receiver, claimed);\n\n    // apply to state\n    _push($.totalUnstaking, now_, claimed.toUint208(), _opSub);\n\n    emit UnstakeClaimed(receiver, claimed, reqIdFrom, reqIdTo);\n\n    return claimed;\n  }\n\n  function _checkRedelegationCooldown(StorageV1 storage $, uint48 now_, address delegator, address valAddr)\n    internal\n    view\n  {\n    uint256 lastRedelegationTime_ = $.lastRedelegationTime[delegator][valAddr];\n\n    if (lastRedelegationTime_ > 0) {\n      uint48 cooldown = $.redelegationCooldown;\n      uint48 lasttime = lastRedelegationTime_.toUint48();\n      require(\n        now_ >= lasttime + cooldown, //\n        IValidatorStaking__CooldownNotPassed(lasttime, now_, (lasttime + cooldown) - now_)\n      );\n    }\n  }\n\n  function _redelegate(StorageV1 storage $, address delegator, address fromValAddr, address toValAddr, uint256 amount)\n    internal\n    virtual\n    returns (uint256)\n  {\n    require(amount > 0, StdError.ZeroAmount());\n    require(fromValAddr != toValAddr, IValidatorStaking__RedelegateToSameValidator(fromValAddr));\n\n    _assertUnstakeAmountCondition($, fromValAddr, delegator, amount);\n\n    require(_manager.isValidator(fromValAddr), IValidatorStaking__NotValidator(fromValAddr));\n    require(_manager.isValidator(toValAddr), IValidatorStaking__NotValidator(toValAddr));\n\n    uint48 now_ = Time.timestamp();\n\n    _checkRedelegationCooldown($, now_, delegator, fromValAddr);\n    _checkRedelegationCooldown($, now_, delegator, toValAddr);\n\n    $.lastRedelegationTime[delegator][fromValAddr] = now_;\n    $.lastRedelegationTime[delegator][toValAddr] = now_;\n\n    // apply to state\n    {\n      uint208 amount208 = amount.toUint208();\n      _storeUnstake($, now_, fromValAddr, delegator, amount208);\n      _storeStake($, now_, toValAddr, delegator, amount208);\n    }\n\n    _hub.notifyRedelegation(fromValAddr, toValAddr, delegator, amount);\n\n    emit Redelegated(fromValAddr, toValAddr, delegator, amount);\n\n    return amount;\n  }\n\n  function _storeStake(StorageV1 storage $, uint48 now_, address valAddr, address staker, uint208 amount)\n    internal\n    virtual\n  {\n    _push($.staked[valAddr][staker], now_, amount, _opAdd);\n    _push($.stakerTotal[staker], now_, amount, _opAdd);\n    _push($.validatorTotal[valAddr], now_, amount, _opAdd);\n  }\n\n  function _storeUnstake(StorageV1 storage $, uint48 now_, address valAddr, address staker, uint208 amount)\n    internal\n    virtual\n  {\n    _push($.staked[valAddr][staker], now_, amount, _opSub);\n    _push($.stakerTotal[staker], now_, amount, _opSub);\n    _push($.validatorTotal[valAddr], now_, amount, _opSub);\n  }\n\n  function _push(\n    Checkpoints.Trace208 storage $,\n    uint48 time,\n    uint208 amount,\n    function (uint208,uint208) pure returns (uint208) op\n  ) private {\n    $.push(time, op($.latest(), amount));\n  }\n\n  function _opSub(uint208 x, uint208 y) private pure returns (uint208) {\n    unchecked {\n      return x - y;\n    }\n  }\n\n  function _opAdd(uint208 x, uint208 y) private pure returns (uint208) {\n    unchecked {\n      return x + y;\n    }\n  }\n\n  // ========== ADMIN ACTIONS ========== //\n\n  function _setMinStakingAmount(StorageV1 storage $, uint256 minAmount) internal virtual {\n    uint256 previous = $.minStakingAmount;\n    $.minStakingAmount = minAmount;\n    emit MinimumStakingAmountSet(previous, minAmount);\n  }\n\n  function _setMinUnstakingAmount(StorageV1 storage $, uint256 minAmount) internal virtual {\n    uint256 previous = $.minUnstakingAmount;\n    $.minUnstakingAmount = minAmount;\n    emit MinimumUnstakingAmountSet(previous, minAmount);\n  }\n\n  function _setUnstakeCooldown(StorageV1 storage $, uint48 unstakeCooldown_) internal virtual {\n    require(unstakeCooldown_ > 0, StdError.InvalidParameter('unstakeCooldown'));\n\n    $.unstakeCooldown = unstakeCooldown_;\n\n    emit UnstakeCooldownUpdated(unstakeCooldown_);\n  }\n\n  function _setRedelegationCooldown(StorageV1 storage $, uint48 redelegationCooldown_) internal virtual {\n    require(redelegationCooldown_ > 0, StdError.InvalidParameter('redelegationCooldown'));\n\n    $.redelegationCooldown = redelegationCooldown_;\n\n    emit RedelegationCooldownUpdated(redelegationCooldown_);\n  }\n\n  //============ UUPS ============ //\n\n  function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    }
}