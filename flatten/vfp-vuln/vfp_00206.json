{
    "vfp_id": "vfp_00206",
    "project_name": "cantina_stryke_aug2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Users can exercise other user's options",
            "description": "The exerciseOption function in ExerciseOptionFirewall.sol performs ownership and validation checks using the top-level optionId parameter but uses settleParams.optionId for the actual settlement. There is no validation ensuring these two IDs are identical, allowing a malicious user to pass a different optionId in the settleParams struct. The root cause is the lack of an explicit equality check between the two IDs. An attacker who owns any option can force the settlement of another user's option by setting settleParams.optionId to the victim's option ID. This leads to premature exercise of the victim's option, potentially destroying its time value and preventing the rightful owner from exercising it later under better conditions. The impact includes economic loss for option holders due to forced early exercise and loss of optionality, undermining user trust in the protocol's authorization model.\n",
            "severity": "Medium",
            "location": [
                "ExerciseOptionFirewall.sol#L71-L84"
            ],
            "files": [
                "contracts/src/periphery/firewalls/ExerciseOptionFirewall.sol"
            ]
        }
    ],
    "affected_files": {
        "ExerciseOptionFirewall.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {EIP712} from \"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\";\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {IV3Pool} from \"../../interfaces/handlers/V3/IV3Pool.sol\";\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\nimport {IOptionMarketOTMFE} from \"../../interfaces/apps/options/IOptionMarketOTMFE.sol\";\nimport {ISwapper} from \"../../interfaces/ISwapper.sol\";\n\ncontract ExerciseOptionFirewall is Multicall, Ownable, EIP712 {\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    mapping(address => bool) public whitelistedExecutors;\n    mapping(address => bool) public whitelistedMarkets;\n\n    error NotWhitelistedMarket();\n    error NotWhitelistedExecutor();\n    error ArrayLenMismatch();\n    error NotOwner();\n    error OptionExpired();\n    error InvalidSignature();\n    error InvalidDeadline();\n    error InvalidTick();\n    error InvalidSqrtPriceX96();\n    error OptionNotExpired();\n\n    struct RangeCheckData {\n        address user;\n        address pool;\n        address market;\n        int24 minTickLower;\n        int24 maxTickUpper;\n        uint160 minSqrtPriceX96;\n        uint160 maxSqrtPriceX96;\n        uint256 deadline;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct PoolData {\n        uint160 sqrtPriceX96;\n        int24 tick;\n    }\n\n    bytes32 private constant RANGE_CHECK_TYPEHASH = keccak256(\n        \"RangeCheck(address user,address pool,int24 minTickLower,int24 maxTickUpper,uint160 minSqrtPriceX96,uint160 maxSprtPriceX96,uint256 deadline)\"\n    );\n\n    constructor(address _signer) EIP712(\"ExerciseOptionFirewall\", \"1\") Ownable(msg.sender) {\n        whitelistedExecutors[_signer] = true;\n    }\n\n    function updateWhitelistedExecutor(address executor, bool isWhitelisted) external onlyOwner {\n        whitelistedExecutors[executor] = isWhitelisted;\n    }\n\n    function updateWhitelistedMarket(address market, bool isWhitelisted) external onlyOwner {\n        whitelistedMarkets[market] = isWhitelisted;\n    }\n\n    function exerciseOption(\n        IOptionMarketOTMFE market,\n        uint256 optionId,\n        IOptionMarketOTMFE.SettleOptionParams memory settleParams,\n        RangeCheckData[] calldata rangeCheckData,\n        Signature[] calldata signature\n    ) external returns (IOptionMarketOTMFE.AssetsCache memory) {\n        if (!whitelistedMarkets[address(market)]) {\n            revert NotWhitelistedMarket();\n        }\n\n        if (market.ownerOf(optionId) != msg.sender) {\n            revert NotOwner();\n        }\n\n        IOptionMarketOTMFE.OptionData memory oData = market.opData(optionId);\n\n        if (oData.opTickArrayLen != rangeCheckData.length) {\n            revert ArrayLenMismatch();\n        }\n\n        for (uint256 i; i < oData.opTickArrayLen; i++) {\n            _checkRange(market, market.opTickMap(optionId, i), rangeCheckData[i], signature[i]);\n        }\n\n        (IOptionMarketOTMFE.AssetsCache memory ac) = market.settleOption(settleParams);\n\n        if (ac.isSettle) {\n            revert OptionExpired();\n        }\n\n        if (ac.totalProfit > 0) {\n            IERC20(address(ac.assetToGet)).safeTransfer(market.ownerOf(settleParams.optionId), ac.totalProfit);\n        }\n\n        return ac;\n    }\n\n    function settleOption(\n        IOptionMarketOTMFE market,\n        uint256 optionId,\n        IOptionMarketOTMFE.SettleOptionParams memory settleParams\n    ) external returns (IOptionMarketOTMFE.AssetsCache memory) {\n        if (!whitelistedMarkets[address(market)]) {\n            revert NotWhitelistedMarket();\n        }\n\n        if (!whitelistedExecutors[msg.sender]) {\n            revert NotWhitelistedExecutor();\n        }\n\n        (IOptionMarketOTMFE.AssetsCache memory ac) = market.settleOption(settleParams);\n\n        if (!ac.isSettle) revert OptionNotExpired();\n\n        if (ac.totalProfit > 0) {\n            IERC20(address(ac.assetToGet)).safeTransfer(market.ownerOf(settleParams.optionId), ac.totalProfit);\n        }\n\n        return ac;\n    }\n\n    function _checkRange(\n        IOptionMarketOTMFE market,\n        IOptionMarketOTMFE.OptionTicks memory optionTicks,\n        RangeCheckData calldata rangeCheckData,\n        Signature calldata signature\n    ) internal view {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                RANGE_CHECK_TYPEHASH,\n                msg.sender,\n                address(optionTicks.pool),\n                address(market),\n                rangeCheckData.minTickLower,\n                rangeCheckData.maxTickUpper,\n                rangeCheckData.minSqrtPriceX96,\n                rangeCheckData.maxSqrtPriceX96,\n                rangeCheckData.deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        if (!whitelistedExecutors[hash.recover(signature.v, signature.r, signature.s)]) {\n            revert InvalidSignature();\n        }\n\n        if (rangeCheckData.deadline < block.timestamp) {\n            revert InvalidDeadline();\n        }\n\n        PoolData memory poolData;\n        (, bytes memory result) = address(optionTicks.pool).staticcall(abi.encodeWithSignature(\"slot0()\"));\n        (poolData.sqrtPriceX96, poolData.tick) = abi.decode(result, (uint160, int24));\n\n        if (poolData.tick < rangeCheckData.minTickLower || poolData.tick > rangeCheckData.maxTickUpper) {\n            revert InvalidTick();\n        }\n\n        if (\n            poolData.sqrtPriceX96 < rangeCheckData.minSqrtPriceX96\n                || poolData.sqrtPriceX96 > rangeCheckData.maxSqrtPriceX96\n        ) revert InvalidSqrtPriceX96();\n    }\n\n    function hashTypedDataV4(bytes32 structHash) public view returns (bytes32) {\n        return _hashTypedDataV4(structHash);\n    }\n\n    function getRangeCheckTypehash() public pure returns (bytes32) {\n        return RANGE_CHECK_TYPEHASH;\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    }
}