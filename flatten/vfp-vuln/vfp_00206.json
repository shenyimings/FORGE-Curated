{
    "vfp_id": "vfp_00206",
    "project_name": "2025.01.31 - Final - Perennial V2 Update 4 Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Anyone can steal all funds from the market due to incorrect health accounting for pending pnl from difference of intent price and market price when multiple intents are used.",
            "description": "This vulnerability allows an attacker to exploit the incorrect handling of pending PnL in account health calculations when multiple signed intents are used. The system only accounts for the PnL adjustment of the current intent during health checks, ignoring all other pending intents for the same account. This enables an attacker to submit multiple intents that individually appear to maintain sufficient collateral, but collectively result in a highly negative collateral position. The root cause lies in the `InvariantLib.validate` function, which only considers the `newGuarantee.priceAdjustment` for the current intent and fails to aggregate adjustments from all pending guarantees. An attacker can exploit this by repeatedly submitting identical intents from one account while using another to execute them, thereby inflating their effective position without triggering a health check failure. Upon settlement, the victim account ends up with negative collateral while the attacker's account gains equivalent profit, allowing the attacker to withdraw all funds from the market, resulting in a total loss of market collateral.\n",
            "severity": "High",
            "location": [
                "InvariantLib.sol::validate#L71",
                "packages/core/contracts/libs/InvariantLib.sol",
                "packages/core/contracts/types/Guarantee.sol"
            ],
            "files": [
                "perennial-v2/packages/core/contracts/libs/InvariantLib.sol",
                "perennial-v2/packages/core/contracts/types/Guarantee.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "InvariantLib uses current position for margin check allowing to withdraw collateral while the position decrease is only pending and can cause unexpected immediate user liquidation.",
            "description": "This issue arises from the inconsistent use of position data in margin and maintenance checks within `InvariantLib.validate`. During a normal update, the function uses `currentPosition` for the margin check, which reflects the expected position after pending updates. However, during liquidation (when protected = true), it uses `latestPosition`, which is based on the last committed price. This discrepancy allows a user to reduce their position and withdraw collateral based on the pending (current) position, even though the actual (latest) position remains unchanged until settlement. As a result, after withdrawal, the account may become immediately liquidatable because the maintenance check uses the outdated `latestPosition`. The root cause is the incorrect use of `currentPosition` in the margined check and the mismatch between normal update and liquidation logic. An attacker can exploit this by reducing their position and withdrawing all collateral, then immediately liquidating their own account, potentially profiting from liquidation fees while leaving the system in bad debt. This leads to unfair liquidations and potential loss of user funds, or even a self-liquidation attack to extract liquidation fees at the expense of the market.\n",
            "severity": "High",
            "location": [
                "InvariantLib.sol::validate#L87-L93",
                "InvariantLib.sol::validate#L124-L128",
                "packages/core/contracts/libs/InvariantLib.sol"
            ],
            "files": [
                "perennial-v2/packages/core/contracts/libs/InvariantLib.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Intent orders are guaranteed to execute, but fees from these orders are not accounted in collateral, allowing user to withdraw all collateral ignoring these pending fees.",
            "description": "This vulnerability stems from the fact that intent orders are guaranteed to execute (invalidation = 0), but the associated trading fees are not applied to the user's collateral until after the epoch price is committed. This creates a window where a user can open and close a position via intent orders, withdraw all their collateral (since fees are not yet deducted), and then, after the price is committed, have the fees applied to an account with zero collateral, resulting in bad debt. The root cause is the delay in fee application, handled in `CheckpointLib.advance`, combined with the ability to fully close a position even when the opening is still pending, as allowed by `InvariantLib`. An attacker can exploit this by using multiple accounts to generate and execute paired intent orders (open and close), withdraw all collateral immediately, and then claim referral fees once the epoch settles. Since the fees become bad debt, the market loses funds while the attacker profits from the claimed fees. This can be executed in a single transaction using flash loans, enabling the attacker to drain the entire market balance over repeated iterations.\n",
            "severity": "High",
            "location": [
                "CheckpointLib.sol::advance#L84-L92",
                "InvariantLib.sol::validate#L35-L38",
                "packages/core/contracts/libs/CheckpointLib.sol",
                "packages/core/contracts/libs/InvariantLib.sol"
            ],
            "files": [
                "perennial-v2/packages/core/contracts/libs/CheckpointLib.sol",
                "perennial-v2/packages/core/contracts/libs/InvariantLib.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "When account is liquidated (protected), liquidator can increase account's position to any value up to 2**62 - 1 breaking all market accounting and stealing all market funds.",
            "description": "This critical flaw allows a liquidator to arbitrarily increase a liquidated account's position during liquidation, bypassing all position and collateral checks. The vulnerability exists because the only condition enforced during liquidation is that `pending.negative == latestPosition.magnitude`, which is satisfied when a user has fully closed their position (pending close). Once this condition is met, the liquidator can increase the position to the maximum value (2^62 - 1) without any restrictions. The root cause is the removal of the previous check that enforced position reduction during liquidation, leaving only the pending negative check, which does not prevent position inflation. An attacker can exploit this by opening a small position, closing it (making it pending), and then liquidating it with a massive position increase. After the price is committed, a small price change generates enormous PnL, which the attacker can withdraw entirely from the market. This completely breaks market accounting and allows the attacker to steal all market funds.\n",
            "severity": "High",
            "location": [
                "InvariantLib.sol::validate#L121",
                "packages/core/contracts/libs/InvariantLib.sol"
            ],
            "files": [
                "perennial-v2/packages/core/contracts/libs/InvariantLib.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Inconsistent Collateral Accounting for Pending Intents During Liquidation",
            "description": "This vulnerability arises when accounts use signed intents to trade, as the profit or loss from the intent price difference is not accounted for during liquidation checks. The root cause is that InvariantLib.validate only considers the current collateral and does not include the guaranteed PnL from pending intents when assessing margin requirements. As a result, an account that is effectively healthy due to pending profit may be unfairly liquidated, or an unhealthy account with pending losses may avoid liquidation because the loss is not deducted. The attack path involves a user creating a favorable intent (e.g., closing a position at a better price), then being liquidated despite having sufficient effective collateral, or conversely, delaying liquidation by having a pending loss. The impact includes unfair liquidations, user fund loss (up to 6.7% in the example), and potential manipulation of the liquidation system.\n",
            "severity": "Medium",
            "location": [
                "InvariantLib.sol::validate#127",
                "InvariantLib.sol#L92"
            ],
            "files": [
                "perennial-v2/packages/core/contracts/libs/InvariantLib.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Liquidations Blocked Due to Over-Close Validation on Pending Intent Orders",
            "description": "The vulnerability prevents timely liquidations when a user's pending close amount exceeds their latest position size. The root cause is an incorrect validation in InvariantLib that applies the same over-close check to liquidation orders as to regular orders, even though liquidation orders cannot reduce pending negative positions. Since liquidation orders are always non-intent (invalidation != 0), they must satisfy the condition that pending close does not exceed the latest position, which becomes impossible if the pending close is already too large. The attack path involves a user creating a sequence of intent orders that result in a pending close greater than the latest position, after which no liquidation can succeed until a settlement occurs. The impact is delayed liquidations, potential accumulation of bad debt, and systemic risk to the market, as undercollateralized positions remain open longer than they should.\n",
            "severity": "Medium",
            "location": [
                "InvariantLib.sol#L118-L122"
            ],
            "files": [
                "perennial-v2/packages/core/contracts/libs/InvariantLib.sol"
            ]
        }
    ],
    "affected_files": {
        "Guarantee.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Order } from \"./Order.sol\";\n\n/// @dev Guarantee type\nstruct Guarantee {\n    /// @dev The quantity of guarantees that that will be exempt from the settlement fee\n    uint256 orders;\n\n    /// @dev The notional of the magnitude with the price override (local only)\n    Fixed6 notional;\n\n    /// @dev The long open guarantee size\n    UFixed6 longPos;\n\n    /// @dev The long close guarantee size\n    UFixed6 longNeg;\n\n    /// @dev The short open guarantee size\n    UFixed6 shortPos;\n\n    /// @dev The short close guarantee size\n    UFixed6 shortNeg;\n\n    /// @dev The magnitude of the guarantee that be exempt from the trade fee\n    UFixed6 takerFee;\n\n    /// @dev The order referral fee multiplied by the size applicable to the referral\n    UFixed6 orderReferral;\n\n    /// @dev The solver portion of the order referral fee multiplied by the size applicable to the referral (local only)\n    UFixed6 solverReferral;\n}\nusing GuaranteeLib for Guarantee global;\nstruct GuaranteeStorageGlobal { uint256 slot0; uint256 slot1; }\nusing GuaranteeStorageGlobalLib for GuaranteeStorageGlobal global;\nstruct GuaranteeStorageLocal { uint256 slot0; uint256 slot1; uint256 slot2; }\nusing GuaranteeStorageLocalLib for GuaranteeStorageLocal global;\n\n/// @title Guarantee\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for an account's update guarantee\nlibrary GuaranteeLib {\n    /// @notice Prepares the next guarantee from the current guarantee\n    /// @param self The guarantee object to update\n    function next(Guarantee memory self) internal pure  {\n        self.orders = 0;\n        (self.notional, self.takerFee, self.orderReferral, self.solverReferral) =\n            (Fixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n        (self.longPos, self.longNeg, self.shortPos, self.shortNeg) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Creates a new guarantee from an order\n    /// @param order The order to create the guarantee from\n    /// @param priceOverride The price override\n    /// @param solverReferralFee The the percentage of the subtractive fee to take as a solver referral fee\n    /// @param chargeTradeFee Whether the order will still be charged the trade fee\n    /// @return newGuarantee The resulting guarantee\n    function from(\n        Order memory order,\n        Fixed6 priceOverride,\n        UFixed6 solverReferralFee,\n        bool chargeTradeFee\n    ) internal pure returns (Guarantee memory newGuarantee) {\n        newGuarantee.orders = order.orders;\n\n        (newGuarantee.longPos, newGuarantee.longNeg, newGuarantee.shortPos, newGuarantee.shortNeg) =\n            (order.longPos, order.longNeg, order.shortPos, order.shortNeg);\n        newGuarantee.takerFee = chargeTradeFee ? UFixed6Lib.ZERO : order.takerTotal();\n\n        newGuarantee.notional = taker(newGuarantee).mul(priceOverride);\n        newGuarantee.orderReferral = order.takerReferral;\n        newGuarantee.solverReferral = order.takerReferral.mul(solverReferralFee);\n    }\n\n    /// @notice Returns the positive side of the taker position of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The positive side of the taker position of the guarantee\n    function takerPos(Guarantee memory self) internal pure returns (UFixed6) {\n        return self.longPos.add(self.shortNeg);\n    }\n\n    /// @notice Returns the negative side of the taker position of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The negative side of the taker position of the guarantee\n    function takerNeg(Guarantee memory self) internal pure returns (UFixed6) {\n        return self.longNeg.add(self.shortPos);\n    }\n\n    /// @notice Returns the taker delta of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The taker delta of the guarantee\n    function taker(Guarantee memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(takerPos(self)).sub(Fixed6Lib.from(takerNeg(self)));\n    }\n\n    /// @notice Returns the total taker delta of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The total taker delta of the guarantee\n    function takerTotal(Guarantee memory self) internal pure returns (UFixed6) {\n        return takerPos(self).add(takerNeg(self));\n    }\n\n    /// @notice Returns whether the guarantee is empty\n    /// @param self The guarantee object to check\n    /// @return Whether the guarantee is empty\n    function isEmpty(Guarantee memory self) internal pure returns (bool) {\n        return takerTotal(self).isZero();\n    }\n\n    /// @notice Returns the collateral adjusted due to the price override\n    /// @param self The guarantee object to check\n    /// @param price The oracle price to compare to the price override\n    /// @return The collateral adjusted due to the price override\n    function priceAdjustment(Guarantee memory self, Fixed6 price) internal pure returns (Fixed6) {\n        return self.taker().mul(price).sub(self.notional);\n    }\n\n    /// @notice Returns the price deviation of the guarantee from the oracle price\n    /// @dev The price deviation is the difference between the prices over the closest price to zero\n    ///      Only supports new guarantees for updates, does not work for aggregated guarantees (local / global)\n    /// @param self The guarantee object to check\n    /// @param price The oracle price to compare\n    /// @return The price deviation of the guarantee from the oracle price\n    function priceDeviation(Guarantee memory self, Fixed6 price) internal pure returns (UFixed6) {\n        if (takerTotal(self).isZero()) return UFixed6Lib.ZERO;\n\n        Fixed6 guaranteePrice = self.notional.div(taker(self));\n        return guaranteePrice.sub(price).abs().unsafeDiv(guaranteePrice.abs().min(price.abs()));\n    }\n\n    /// @notice Updates the current global guarantee with a new local guarantee\n    /// @param self The guarantee object to update\n    /// @param guarantee The new guarantee\n    function add(Guarantee memory self, Guarantee memory guarantee) internal pure {\n        self.orders = self.orders + guarantee.orders;\n        (self.notional, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.notional.add(guarantee.notional),\n            self.longPos.add(guarantee.longPos),\n            self.longNeg.add(guarantee.longNeg),\n            self.shortPos.add(guarantee.shortPos),\n            self.shortNeg.add(guarantee.shortNeg)\n        );\n        (self.takerFee, self.orderReferral, self.solverReferral) = (\n            self.takerFee.add(guarantee.takerFee),\n            self.orderReferral.add(guarantee.orderReferral),\n            self.solverReferral.add(guarantee.solverReferral)\n        );\n    }\n}\n\n/// @dev Manually encodes and decodes the global Guarantee struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGuaranteeGlobal {\n///         /* slot 0 */\n///         uint32 orders;\n///         uint64 takerFee;\n///         uint64 orderReferral;\n///\n///         /* slot 1 */\n///         uint64 longPos;\n///         uint64 longNeg;\n///         uint64 shortPos;\n///         uint64 shortNeg;\n///     }\n///\nlibrary GuaranteeStorageGlobalLib {\n    function read(GuaranteeStorageGlobal storage self) internal view returns (Guarantee memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Guarantee(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            Fixed6Lib.ZERO,\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6Lib.ZERO\n        );\n    }\n\n    function store(GuaranteeStorageGlobal storage self, Guarantee memory newValue) external {\n        GuaranteeStorageLib.validate(newValue);\n\n        uint256 encoded0 =\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.orderReferral) << (256 - 64)) >> (256 - 32 - 64 - 64);\n\n        uint256 encode1 =\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encode1)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Guarantee struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGuaranteeLocal {\n///         /* slot 0 */\n///         uint32 orders;\n///         int64 notional;\n///         uint64 takerFee;\n///\n///         /* slot 1 */\n///         uint64 longPos;\n///         uint64 longNeg;\n///         uint64 shortPos;\n///         uint64 shortNeg;\n///\n///         /* slot 2 */\n///         uint64 orderReferral;\n///         uint64 solverReferral;\n///     }\n///\nlibrary GuaranteeStorageLocalLib {\n    function read(GuaranteeStorageLocal storage self) internal view returns (Guarantee memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return Guarantee(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot2 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot2 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(GuaranteeStorageLocal storage self, Guarantee memory newValue) external {\n        GuaranteeStorageLib.validate(newValue);\n\n        if (newValue.notional.gt(Fixed6.wrap(type(int64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.notional.lt(Fixed6.wrap(type(int64).min))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.solverReferral.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\n            uint256(Fixed6.unwrap(newValue.notional) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 32 - 64 - 64);\n        uint256 encode1 =\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\n        uint256 encode2 =\n            uint256(UFixed6.unwrap(newValue.orderReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.solverReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encode1)\n            sstore(add(self.slot, 2), encode2)\n        }\n    }\n}\n\nlibrary GuaranteeStorageLib {\n    // sig: 0xfd030f36\n    error GuaranteeStorageInvalidError();\n\n    function validate(Guarantee memory newValue) internal pure {\n        if (newValue.orders > type(uint32).max) revert GuaranteeStorageInvalidError();\n        if (newValue.longPos.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.longNeg.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.shortPos.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.shortNeg.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.takerFee.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.orderReferral.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n    }\n}",
        "CheckpointLib.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Accumulator6 } from \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { IMarket } from \"../interfaces/IMarket.sol\";\nimport { Position } from \"../types/Position.sol\";\nimport { Order } from \"../types/Order.sol\";\nimport { Version } from \"../types/Version.sol\";\nimport { Checkpoint } from \"../types/Checkpoint.sol\";\nimport { Guarantee } from \"../types/Guarantee.sol\";\n\nstruct CheckpointAccumulationResponse {\n    /// @dev Total Collateral change due to collateral, price override, and trade fee and offset\n    Fixed6 collateral;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 solverFee;\n}\n\nstruct CheckpointAccumulationResult {\n    /// @dev Total Collateral change due to pnl, funding, and interest from the previous position to the next position\n    Fixed6 collateral;\n\n    /// @dev Collateral change from the difference between the price override and underlying market price\n    Fixed6 priceOverride;\n\n    /// @dev Trade fee accumulated for this checkpoint\n    UFixed6 tradeFee;\n\n    /// @dev Trade price impact accumulated for this checkpoint\n    Fixed6 offset;\n\n    /// @dev Settlement fee charged for this checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 solverFee;\n}\n\n/// @title CheckpointLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the local order accumulation\nlibrary CheckpointLib {\n    /// @notice Accumulate pnl and fees from the latest position to next position\n    /// @param order The next order\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next latest version\n    /// @return next The next checkpoint\n    /// @return response The accumulated pnl and fees\n    function accumulate(\n        IMarket.Context memory context,\n        IMarket.SettlementContext memory settlementContext,\n        uint256 orderId,\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) external returns (Checkpoint memory next, CheckpointAccumulationResponse memory) {\n        CheckpointAccumulationResult memory result;\n\n        // accumulate\n        result.collateral = _accumulateCollateral(context.latestPositionLocal, fromVersion, toVersion);\n        result.priceOverride = _accumulatePriceOverride(guarantee, toVersion);\n        (result.tradeFee, result.subtractiveFee, result.solverFee) = _accumulateFee(order, guarantee, toVersion);\n        result.offset = _accumulateOffset(order, guarantee, toVersion);\n        result.settlementFee = _accumulateSettlementFee(order, guarantee, toVersion);\n        result.liquidationFee = _accumulateLiquidationFee(order, toVersion);\n\n        // update checkpoint\n        next.collateral = settlementContext.latestCheckpoint.collateral\n            .sub(settlementContext.latestCheckpoint.tradeFee)                       // trade fee processed post settlement\n            .sub(Fixed6Lib.from(settlementContext.latestCheckpoint.settlementFee)); // settlement / liquidation fee processed post settlement\n        next.collateral = next.collateral\n            .add(settlementContext.latestCheckpoint.transfer)                       // deposit / withdrawal processed post settlement\n            .add(result.collateral)                                                 // incorporate collateral change at this settlement\n            .add(result.priceOverride);                                             // incorporate price override pnl at this settlement\n        next.transfer = order.collateral;\n        next.tradeFee = Fixed6Lib.from(result.tradeFee).add(result.offset);\n        next.settlementFee = result.settlementFee.add(result.liquidationFee);\n\n        emit IMarket.AccountPositionProcessed(context.account, orderId, order, result);\n\n        return (next, _response(result));\n    }\n\n    /// @notice Converts the accumulation result into a response\n    /// @param result The accumulation result\n    /// @return response The accumulation response\n    function _response(\n        CheckpointAccumulationResult memory result\n    ) private pure returns (CheckpointAccumulationResponse memory response) {\n        response.collateral = result.collateral\n            .add(result.priceOverride)\n            .sub(Fixed6Lib.from(result.tradeFee))\n            .sub(result.offset)\n            .sub(Fixed6Lib.from(result.settlementFee));\n        response.liquidationFee = result.liquidationFee;\n        response.subtractiveFee = result.subtractiveFee;\n        response.solverFee = result.solverFee;\n    }\n\n    /// @notice Accumulate pnl, funding, and interest from the latest position to next position\n    /// @param fromPosition The previous latest position\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next version\n    function _accumulateCollateral(\n        Position memory fromPosition,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\n    }\n\n    /// @notice Accumulate trade fees for the next position\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateFee(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (UFixed6 tradeFee, UFixed6 subtractiveFee, UFixed6 solverFee) {\n        UFixed6 takerTotal = order.takerTotal().sub(guarantee.takerFee);\n\n        // accumulate total trade fees on maker and taker orders\n        UFixed6 makerFee = Fixed6Lib.ZERO\n            .sub(toVersion.makerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .abs();\n        UFixed6 takerFee = Fixed6Lib.ZERO\n            .sub(toVersion.takerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), takerTotal))\n            .abs();\n\n        // compute portion of trade fees that are subtractive\n        UFixed6 makerSubtractiveFee = order.makerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            makerFee.muldiv(order.makerReferral, order.makerTotal());\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(order.takerReferral, takerTotal);\n\n        // compute portion of subtractive fees that are solver fees\n        solverFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(guarantee.solverReferral, takerTotal); // guarantee.solverReferral is instantiated as a subset of order.takerReferral\n\n        tradeFee = makerFee.add(takerFee);\n        subtractiveFee = makerSubtractiveFee.add(takerSubtractiveFee).sub(solverFee);\n    }\n\n    /// @notice Accumulate price offset for the next position\n    /// @dev This includes adjustment for linear, proportional, and adiabatic order fees\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateOffset(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        (UFixed6 takerPos, UFixed6 takerNeg) =\n            (order.takerPos().sub(guarantee.takerPos()), order.takerNeg().sub(guarantee.takerNeg()));\n\n        return Fixed6Lib.ZERO\n            .sub(toVersion.makerOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .sub(toVersion.takerPosOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerPos))\n            .sub(toVersion.takerNegOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerNeg));\n    }\n\n\n    /// @notice Accumulate settlement fees for the next position\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateSettlementFee(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        uint256 orders = order.orders - guarantee.orders;\n\n        return toVersion.settlementFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.from(orders)).abs();\n    }\n\n    /// @notice Accumulate liquidation fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateLiquidationFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        if (!order.protected()) return UFixed6Lib.ZERO;\n        return toVersion.liquidationFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.ONE).abs();\n    }\n\n    /// @notice Accumulate price override pnl for the next position\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulatePriceOverride(\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return guarantee.priceAdjustment(toVersion.price);\n    }\n}\n",
        "InvariantLib.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { IMarket } from \"../interfaces/IMarket.sol\";\nimport { PositionLib } from \"../types/Position.sol\";\nimport { Order } from \"../types/Order.sol\";\nimport { Guarantee } from \"../types/Guarantee.sol\";\n\n/// @title InvariantLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the system invariant\nlibrary InvariantLib {\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param newOrder The order to verify the invariant for\n    /// @param newGuarantee The guarantee to verify the invariant for\n    function validate(\n        IMarket.Context memory context,\n        IMarket.UpdateContext memory updateContext,\n        Order memory newOrder,\n        Guarantee memory newGuarantee\n    ) external {\n        // emit created event first due to early return\n        emit IMarket.OrderCreated(\n            context.account,\n            newOrder,\n            newGuarantee,\n            updateContext.liquidator,\n            updateContext.orderReferrer,\n            updateContext.guaranteeReferrer\n        );\n\n        if (\n            context.pendingLocal.invalidation != 0 &&                              // pending orders are partially invalidatable\n            context.pendingLocal.neg().gt(context.latestPositionLocal.magnitude()) // total pending close is greater than latest position\n        ) revert IMarket.MarketOverCloseError();\n\n        if (newOrder.protected() && !_validateProtection(context, newOrder))\n            revert IMarket.MarketInvalidProtectionError();\n\n        if (\n            !(context.latestPositionLocal.magnitude().isZero() && context.pendingLocal.isEmpty()) &&    // sender has no position\n            !(newOrder.isEmpty() && newOrder.collateral.gte(Fixed6Lib.ZERO)) &&                         // sender is depositing zero or more into account, without position change\n            (\n                !context.latestOracleVersion.valid ||\n                context.currentTimestamp - context.latestOracleVersion.timestamp >= context.riskParameter.staleAfter\n            )                                                                                           // price is not stale\n        ) revert IMarket.MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert IMarket.MarketClosedError();\n\n        if (\n            updateContext.currentPositionGlobal.maker.gt(context.riskParameter.makerLimit) &&\n            newOrder.increasesMaker()\n        ) revert IMarket.MarketMakerOverLimitError();\n\n        if (!updateContext.currentPositionLocal.singleSided()) revert IMarket.MarketNotSingleSidedError();\n\n        if (\n            (!context.latestPositionLocal.maker.isZero() && !updateContext.currentPositionLocal.skew().isZero()) ||\n            (!context.latestPositionLocal.skew().isZero() && !updateContext.currentPositionLocal.maker.isZero())\n        ) revert IMarket.MarketNotSingleSidedError();\n\n        if (context.pendingLocal.invalidation != 0 && context.pendingLocal.crossesZero())\n            revert IMarket.MarketNotSingleSidedError();\n\n        if (newGuarantee.priceDeviation(context.latestOracleVersion.price).gt(context.marketParameter.maxPriceDeviation))\n            revert IMarket.MarketIntentPriceDeviationError();\n\n        if (newOrder.protected()) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            !updateContext.signer &&                                            // sender is relaying the account's signed intention\n            !updateContext.operator &&                                          // sender is operator approved for account\n            !(newOrder.isEmpty() && newOrder.collateral.gte(Fixed6Lib.ZERO))    // sender is depositing zero or more into account, without position change\n        ) revert IMarket.MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert IMarket.MarketExceedsPendingIdLimitError();\n\n        if (\n            !PositionLib.margined(\n                updateContext.currentPositionLocal.magnitude(),\n                context.latestOracleVersion,\n                context.riskParameter,\n                updateContext.collateralization,\n                context.local.collateral.add(newGuarantee.priceAdjustment(context.latestOracleVersion.price)) // apply price override adjustment from intent if present\n            )\n        ) revert IMarket.MarketInsufficientMarginError();\n\n        if (\n            context.pendingLocal.protected() && // total pending position is protected\n            !newOrder.protected()               // protection did not occur in this order (semphore already handles double-protection case)\n        ) revert IMarket.MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.decreasesEfficiency(updateContext.currentPositionGlobal) &&\n            updateContext.currentPositionGlobal.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert IMarket.MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            updateContext.currentPositionGlobal.socialized() &&\n            newOrder.decreasesLiquidity(updateContext.currentPositionGlobal)\n        ) revert IMarket.MarketInsufficientLiquidityError();\n\n        if (context.local.collateral.lt(Fixed6Lib.ZERO))\n            revert IMarket.MarketInsufficientCollateralError();\n    }\n\n    function _validateProtection(IMarket.Context memory context, Order memory newOrder) private pure returns (bool) {\n        if (context.pendingLocal.crossesZero()) {\n            if (!newOrder.isEmpty()) return false; // pending zero-cross, liquidate (lock) with no-op order\n        } else {\n            if (!context.pendingLocal.neg().eq(context.latestPositionLocal.magnitude())) return false; // no pending zero-cross, liquidate with full close\n        }\n\n        if (context.latestPositionLocal.maintained(\n            context.latestOracleVersion,\n            context.riskParameter,\n            context.local.collateral\n        )) return false; // latest position is properly maintained\n\n        if (!newOrder.collateral.eq(Fixed6Lib.ZERO)) return false; // the order is modifying collateral\n\n        return true;\n    }\n}\n"
    }
}