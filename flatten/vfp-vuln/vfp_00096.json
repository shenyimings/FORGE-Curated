{
    "vfp_id": "vfp_00096",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Reverting Proposals Lock Cross-Chain Governance",
            "description": "The CrossChainMultisig uses Address.functionCall() to execute proposals, which bubbles up reverts. If a proposal succeeds on Ethereum Mainnet but reverts on another chain, that chain's governance becomes permanently stuck because it cannot skip the failed proposal. This allows a single failing call to lock cross-chain governance. The impact is a complete denial of service to governance on non-mainnet chains, preventing any future updates and endangering system liveness.\n",
            "severity": "High",
            "location": [
                "CrossChainMultisig.sol"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Batching disableRecoveryMode Can Be Problematic",
            "description": "The disableRecoveryMode() function can be included in a batch with other transactions. If any transaction in the batch fails, the entire batch reverts, leaving the system in recovery mode indefinitely. This removes the ability to exit recovery safely. Attackers could craft a failing batch containing disableRecoveryMode to permanently trap the system in recovery. The impact is a denial of service to normal governance operations across chains.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig.sol::disableRecoveryMode"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Recovery Mode Message Replay",
            "description": "Recovery mode messages do not include the target chain ID in their signature scope, allowing a recovery message signed for one chain (e.g., Chain A) to be replayed on another chain (e.g., Chain B). This could force Chain B into recovery mode without authorization. Attackers could exploit this to block governance on newly deployed chains. The impact is cross-chain governance manipulation and potential freezing of operations on new deployments.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig.sol::enableRecoveryMode"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ],
                "3": [
                    "CWE-325"
                ]
            },
            "title": "Dynamic Types Must Be Hashed for EIP712",
            "description": "In CrossChainMultisig.hashProposal(), the call data (of type bytes) is not hashed before being included in the EIP-712 digest, violating the EIP-712 specification which requires dynamic types to be hashed. This could lead to signature malleability or incorrect hash computation. Attackers could exploit this to craft proposals with manipulated calldata hashes, potentially leading to unauthorized execution. The impact is compromised integrity of signed proposals.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig.sol::hashProposal"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Threshold Not Enforced When Removing Signer",
            "description": "The CrossChainMultisig allows removal of a signer without ensuring that the remaining signers meet the threshold required to execute proposals.\nCause: No validation is performed during signer removal to confirm that the threshold can still be met.\nExploitation: A malicious or mistaken removal of a signer could drop the number of signers below the threshold.\nImpact: If the threshold cannot be met, governance proposals become unexecutable, effectively freezing the multisig and halting governance operations.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig::removeSigner"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        }
    ],
    "affected_files": {
        "CrossChainMultisig.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SignedProposal, CrossChainCall} from \"../interfaces/ICrossChainMultisig.sol\";\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\n\nimport {LibString} from \"@solady/utils/LibString.sol\";\nimport {EIP712Mainnet} from \"../helpers/EIP712Mainnet.sol\";\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ICrossChainMultisig} from \"../interfaces/ICrossChainMultisig.sol\";\n\nimport {AP_CROSS_CHAIN_MULTISIG} from \"../libraries/ContractLiterals.sol\";\n\ncontract CrossChainMultisig is EIP712Mainnet, Ownable, ReentrancyGuard, ICrossChainMultisig {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using LibString for bytes32;\n    using LibString for string;\n    using LibString for uint256;\n\n    /// @notice Meta info about contract type & version\n    uint256 public constant override version = 3_10;\n    bytes32 public constant override contractType = AP_CROSS_CHAIN_MULTISIG;\n\n    // EIP-712 type hash for Proposal only\n    bytes32 public constant CROSS_CHAIN_CALL_TYPEHASH =\n        keccak256(\"CrossChainCall(uint256 chainId,address target,bytes callData)\");\n    bytes32 public constant PROPOSAL_TYPEHASH = keccak256(\"Proposal(string name,bytes32 proposalHash,bytes32 prevHash)\");\n\n    uint8 public confirmationThreshold;\n\n    bytes32 public lastProposalHash;\n\n    EnumerableSet.AddressSet internal _signers;\n\n    bytes32[] internal _executedProposalHashes;\n\n    mapping(bytes32 => EnumerableSet.Bytes32Set) internal _connectedProposalHashes;\n    mapping(bytes32 => SignedProposal) internal _signedProposals;\n\n    modifier onlyOnMainnet() {\n        if (block.chainid != 1) revert CantBeExecutedOnCurrentChainException();\n        _;\n    }\n\n    modifier onlyOnNotMainnet() {\n        if (block.chainid == 1) revert CantBeExecutedOnCurrentChainException();\n        _;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert OnlySelfException();\n        _;\n    }\n\n    // It's deployed with the same set of parameters on all chains, so it's qddress should be the same\n    // @param: initialSigners - Array of initial signers\n    // @param: _confirmationThreshold - Confirmation threshold\n    // @param: _owner - Owner of the contract. used on Mainnet only, however, it should be same on all chains\n    // to make CREATE2 address the same on all chains\n    constructor(address[] memory initialSigners, uint8 _confirmationThreshold, address _owner)\n        EIP712Mainnet(contractType.fromSmallString(), version.toString())\n        Ownable()\n    {\n        uint256 len = initialSigners.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            _addSigner(initialSigners[i]); // U:[SM-1]\n        }\n\n        _setConfirmationThreshold(_confirmationThreshold); // U:[SM-1]\n        _transferOwnership(_owner); // U:[SM-1]\n    }\n\n    // @dev: Submit a new proposal\n    // Executed by Gearbox DAO on Mainnet\n    // @param: calls - Array of CrossChainCall structs\n    // @param: prevHash - Hash of the previous proposal (zero if first proposal)\n    function submitProposal(string calldata name, CrossChainCall[] calldata calls, bytes32 prevHash)\n        external\n        onlyOwner\n        onlyOnMainnet\n        nonReentrant\n    {\n        _verifyProposal({calls: calls, prevHash: prevHash});\n\n        bytes32 proposalHash = hashProposal({name: name, calls: calls, prevHash: prevHash});\n\n        // Copy proposal to storage\n        SignedProposal storage signedProposal = _signedProposals[proposalHash];\n\n        uint256 len = calls.length;\n        for (uint256 i = 0; i < len; ++i) {\n            signedProposal.calls.push(calls[i]);\n        }\n        signedProposal.prevHash = prevHash;\n        signedProposal.name = name;\n\n        _connectedProposalHashes[lastProposalHash].add(proposalHash);\n\n        emit SubmitProposal(proposalHash);\n    }\n\n    // @dev: Sign a proposal\n    // Executed by any signer to make cross-chain distribution possible\n    // @param: proposalHash - Hash of the proposal to sign\n    // @param: signature - Signature of the proposal\n    function signProposal(bytes32 proposalHash, bytes calldata signature) external onlyOnMainnet nonReentrant {\n        SignedProposal storage signedProposal = _signedProposals[proposalHash];\n        if (signedProposal.prevHash != lastProposalHash) {\n            revert InvalidPrevHashException();\n        }\n        bytes32 digest =\n            _hashTypedDataV4(computeSignProposalHash(signedProposal.name, proposalHash, signedProposal.prevHash));\n\n        address signer = ECDSA.recover(digest, signature);\n        if (!_signers.contains(signer)) revert SignerDoesNotExistException();\n\n        signedProposal.signatures.push(signature);\n\n        uint256 validSignatures = _verifySignatures({signatures: signedProposal.signatures, digest: digest});\n\n        emit SignProposal(proposalHash, signer);\n\n        if (validSignatures >= confirmationThreshold) {\n            _verifyProposal({calls: signedProposal.calls, prevHash: signedProposal.prevHash});\n            _executeProposal({calls: signedProposal.calls, proposalHash: proposalHash});\n        }\n    }\n\n    // @dev: Execute a proposal on other chain permissionlessly\n    function executeProposal(SignedProposal calldata signedProposal) external onlyOnNotMainnet nonReentrant {\n        bytes32 proposalHash = hashProposal(signedProposal.name, signedProposal.calls, signedProposal.prevHash);\n\n        // Check proposal is valid\n        _verifyProposal({calls: signedProposal.calls, prevHash: signedProposal.prevHash});\n\n        bytes32 digest =\n            _hashTypedDataV4(computeSignProposalHash(signedProposal.name, proposalHash, signedProposal.prevHash));\n\n        // Check if enough signatures are valid\n        uint256 validSignatures = _verifySignatures({signatures: signedProposal.signatures, digest: digest});\n        if (validSignatures < confirmationThreshold) revert NotEnoughSignaturesException();\n\n        _executeProposal({calls: signedProposal.calls, proposalHash: proposalHash});\n    }\n\n    function _verifyProposal(CrossChainCall[] memory calls, bytes32 prevHash) internal view {\n        if (prevHash != lastProposalHash) revert InvalidPrevHashException();\n        if (calls.length == 0) revert NoCallsInProposalException();\n\n        uint256 len = calls.length;\n        for (uint256 i = 0; i < len; ++i) {\n            CrossChainCall memory call = calls[i];\n            if (call.chainId != 0 && call.target == address(this)) {\n                revert InconsistentSelfCallOnOtherChainException();\n            }\n        }\n    }\n\n    function _verifySignatures(bytes[] memory signatures, bytes32 digest)\n        internal\n        view\n        returns (uint256 validSignatures)\n    {\n        address[] memory proposalSigners = new address[](signatures.length);\n        // Check for duplicate signatures\n        uint256 len = signatures.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            address signer = ECDSA.recover(digest, signatures[i]);\n\n            // It's not reverted to avoid the case, when 2 proposals are submitted\n            // and the first one is about removing a signer. The signer could add his signature\n            // to the second proposal (it's still possible) and lock the system forever\n            if (_signers.contains(signer)) {\n                validSignatures++;\n            }\n            for (uint256 j = 0; j < i; ++j) {\n                if (proposalSigners[j] == signer) {\n                    revert AlreadySignedException();\n                }\n            }\n            proposalSigners[i] = signer;\n        }\n    }\n\n    // @dev: Execute proposal calls and update state\n    // @param: calls - Array of cross-chain calls to execute\n    // @param: proposalHash - Hash of the proposal being executed\n    function _executeProposal(CrossChainCall[] memory calls, bytes32 proposalHash) internal {\n        // Execute each call in the proposal\n        uint256 len = calls.length;\n        for (uint256 i = 0; i < len; ++i) {\n            CrossChainCall memory call = calls[i];\n            uint256 chainId = call.chainId;\n\n            if (chainId == 0 || chainId == block.chainid) {\n                // QUESTION: add try{} catch{} to achieve 100% execution\n                Address.functionCall(call.target, call.callData, \"Call execution failed\");\n            }\n        }\n\n        _executedProposalHashes.push(proposalHash);\n        lastProposalHash = proposalHash;\n\n        emit ExecuteProposal(proposalHash);\n    }\n\n    //\n    // MULTISIG CONFIGURATION FUNCTIONS\n    //\n\n    // @notice: Add a new signer to the multisig\n    // @param: newSigner - Address of the new signer\n    function addSigner(address newSigner) external onlySelf {\n        _addSigner(newSigner);\n    }\n\n    function _addSigner(address newSigner) internal {\n        if (!_signers.add(newSigner)) revert SignerAlreadyExistsException();\n        emit AddSigner(newSigner);\n    }\n\n    // @notice: Remove a signer from the multisig\n    // @param: signer - Address of the signer to remove\n    function removeSigner(address signer) external onlySelf {\n        if (!_signers.remove(signer)) revert SignerDoesNotExistException();\n        emit RemoveSigner(signer);\n    }\n\n    // @notice: Set the confirmation threshold for the multisig\n    // @param: newConfirmationThreshold - New confirmation threshold\n    function setConfirmationThreshold(uint8 newConfirmationThreshold) external onlySelf {\n        _setConfirmationThreshold(newConfirmationThreshold);\n    }\n\n    function _setConfirmationThreshold(uint8 newConfirmationThreshold) internal {\n        if (newConfirmationThreshold == 0 || newConfirmationThreshold > _signers.length()) {\n            revert InvalidConfirmationThresholdValueException();\n        }\n        confirmationThreshold = newConfirmationThreshold; // U:[SM-1]\n        emit SetConfirmationThreshold(newConfirmationThreshold); // U:[SM-1]\n    }\n\n    //\n    // HELPERS\n    //\n    function hashProposal(string calldata name, CrossChainCall[] calldata calls, bytes32 prevHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory callsHash = new bytes32[](calls.length);\n        uint256 len = calls.length;\n        for (uint256 i = 0; i < len; ++i) {\n            CrossChainCall memory call = calls[i];\n            callsHash[i] = keccak256(abi.encode(CROSS_CHAIN_CALL_TYPEHASH, call.chainId, call.target, call.callData));\n        }\n\n        return keccak256(abi.encode(keccak256(bytes(name)), keccak256(abi.encodePacked(callsHash)), prevHash));\n    }\n\n    function computeSignProposalHash(string memory name, bytes32 proposalHash, bytes32 prevHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(PROPOSAL_TYPEHASH, keccak256(bytes(name)), proposalHash, prevHash));\n    }\n\n    //\n    // GETTERS\n    //\n    function getCurrentProposalHashes() external view returns (bytes32[] memory) {\n        return _connectedProposalHashes[lastProposalHash].values();\n    }\n\n    function getCurrentProposals() external view returns (SignedProposal[] memory result) {\n        uint256 len = _connectedProposalHashes[lastProposalHash].length();\n        result = new SignedProposal[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            result[i] = _signedProposals[_connectedProposalHashes[lastProposalHash].at(i)];\n        }\n    }\n\n    function getSigners() external view returns (address[] memory) {\n        return _signers.values();\n    }\n\n    function getExecutedProposals() external view returns (SignedProposal[] memory result) {\n        uint256 len = _executedProposalHashes.length;\n        result = new SignedProposal[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            result[i] = _signedProposals[_executedProposalHashes[i]];\n        }\n    }\n\n    function getProposal(bytes32 proposalHash) external view returns (SignedProposal memory result) {\n        return _signedProposals[proposalHash];\n    }\n\n    function getExecutedProposalHashes() external view returns (bytes32[] memory) {\n        return _executedProposalHashes;\n    }\n\n    function isSigner(address account) external view returns (bool) {\n        return _signers.contains(account);\n    }\n\n    function getSignedProposal(bytes32 proposalHash) external view returns (SignedProposal memory) {\n        return _signedProposals[proposalHash];\n    }\n\n    function domainSeparatorV4() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    }
}