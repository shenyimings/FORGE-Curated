{
    "vfp_id": "vfp_00113",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "Inconsistent balance tracking in vault creates DoS for asset borrowing",
            "description": "The Vault contract uses inconsistent accounting methods: some functions rely on totalSupplies while others use direct balanceOf checks. The burn function reduces totalSupplies without validating against actual token balances, allowing totalSupplies to drop below totalBorrows. This violates the invariant that total supply must be >= total borrows. The root cause is the lack of synchronization between accounting variables and real token balances. An attacker can exploit this by transferring tokens directly to the vault and then burning more than the accounted supply, creating a negative available balance. The impact is a system-wide denial of service for borrowing that specific asset, even if physical tokens are available.\n",
            "severity": "High",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::burn#111-124",
                "contracts/vault/Vault.sol::availableBalance#206-209",
                "contracts/lendingPool/libraries/ViewLogic.sol::maxBorrowable#83-91",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ]
            },
            "title": "Unsafe asset removal without borrow validation",
            "description": "The removeAsset function in VaultLogic allows removing an asset from the vault's list without checking if there are outstanding borrows. This can lead to a state where borrowers cannot repay loans because the asset is no longer recognized by the system. The root cause is the absence of a pre-removal validation check for totalBorrows. An admin or attacker with access could remove an asset with active loans, rendering repayment functions ineffective. The impact is that borrowers' funds become locked, they cannot clear their debt, and the system enters an inconsistent state.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::removeAsset#192-208",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title Vault for storing the backing for cTokens\n/// @author kexley, @capLabs\n/// @notice Tokens are supplied by cToken minters and borrowed by covered agents\n/// @dev Supplies, borrows and utilization rates are tracked. Interest rates should be computed and\n/// charged on the external contracts, only the principle amount is counted on this contract.\nlibrary VaultLogic {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Timestamp is past the deadline\n    error PastDeadline();\n\n    /// @dev Amount out is less than required\n    error Slippage(address asset, uint256 amountOut, uint256 minAmountOut);\n\n    /// @dev Amount out is 0\n    error InvalidAmount();\n\n    /// @dev Paused assets cannot be supplied or borrowed\n    error AssetPaused(address asset);\n\n    /// @dev Only whitelisted assets can be supplied or borrowed\n    error AssetNotSupported(address asset);\n\n    /// @dev Asset is already listed\n    error AssetAlreadySupported(address asset);\n\n    /// @dev Asset has supplies\n    error AssetHasSupplies(address asset);\n\n    /// @dev Only non-supported assets can be rescued\n    error AssetNotRescuable(address asset);\n\n    /// @dev Invalid min amounts out as they dont match the number of assets\n    error InvalidMinAmountsOut();\n\n    /// @dev Insufficient reserves\n    error InsufficientReserves(address asset, uint256 balanceBefore, uint256 amount);\n\n    /// @dev Cap token minted\n    event Mint(\n        address indexed minter,\n        address receiver,\n        address indexed asset,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 fee\n    );\n\n    /// @dev Cap token burned\n    event Burn(\n        address indexed burner,\n        address receiver,\n        address indexed asset,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 fee\n    );\n\n    /// @dev Cap token redeemed\n    event Redeem(address indexed redeemer, address receiver, uint256 amountIn, uint256[] amountsOut, uint256[] fees);\n\n    /// @dev Borrow made\n    event Borrow(address indexed borrower, address indexed asset, uint256 amount);\n\n    /// @dev Repayment made\n    event Repay(address indexed repayer, address indexed asset, uint256 amount);\n\n    /// @dev Add asset\n    event AddAsset(address asset);\n\n    /// @dev Remove asset\n    event RemoveAsset(address asset);\n\n    /// @dev Asset paused\n    event PauseAsset(address asset);\n\n    /// @dev Asset unpaused\n    event UnpauseAsset(address asset);\n\n    /// @dev Rescue unsupported ERC20 tokens\n    event RescueERC20(address asset, address receiver);\n\n    /// @dev Modifier to only allow supplies and borrows when not paused\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    modifier whenNotPaused(IVault.VaultStorage storage $, address _asset) {\n        _whenNotPaused($, _asset);\n        _;\n    }\n\n    /// @dev Modifier to update the utilization index\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    modifier updateIndex(IVault.VaultStorage storage $, address _asset) {\n        _updateIndex($, _asset);\n        _;\n    }\n\n    /// @notice Mint the cap token using an asset\n    /// @dev This contract must have approval to move asset from msg.sender\n    /// @param $ Vault storage pointer\n    /// @param params Mint parameters\n    function mint(IVault.VaultStorage storage $, IVault.MintBurnParams memory params)\n        external\n        whenNotPaused($, params.asset)\n        updateIndex($, params.asset)\n    {\n        if (params.deadline < block.timestamp) revert PastDeadline();\n        if (params.amountOut < params.minAmountOut) {\n            revert Slippage(address(this), params.amountOut, params.minAmountOut);\n        }\n        if (params.amountOut == 0) revert InvalidAmount();\n\n        $.totalSupplies[params.asset] += params.amountIn;\n\n        IERC20(params.asset).safeTransferFrom(msg.sender, address(this), params.amountIn);\n\n        emit Mint(msg.sender, params.receiver, params.asset, params.amountIn, params.amountOut, params.fee);\n    }\n\n    /// @notice Burn the cap token for an asset\n    /// @dev Can only withdraw up to the amount remaining on this contract\n    /// @param $ Vault storage pointer\n    /// @param params Burn parameters\n    function burn(IVault.VaultStorage storage $, IVault.MintBurnParams memory params)\n        external\n        updateIndex($, params.asset)\n    {\n        if (params.deadline < block.timestamp) revert PastDeadline();\n        if (params.amountOut < params.minAmountOut) {\n            revert Slippage(params.asset, params.amountOut, params.minAmountOut);\n        }\n        if (params.amountOut == 0) revert InvalidAmount();\n\n        _verifyBalance($, params.asset, params.amountOut);\n\n        $.totalSupplies[params.asset] -= params.amountOut + params.fee;\n\n        IERC20(params.asset).safeTransfer(params.receiver, params.amountOut);\n        IERC20(params.asset).safeTransfer($.insuranceFund, params.fee);\n\n        emit Burn(msg.sender, params.receiver, params.asset, params.amountIn, params.amountOut, params.fee);\n    }\n\n    /// @notice Redeem the Cap token for a bundle of assets\n    /// @dev Can only withdraw up to the amount remaining on this contract\n    /// @param $ Vault storage pointer\n    /// @param params Redeem parameters\n    function redeem(IVault.VaultStorage storage $, IVault.RedeemParams memory params) external {\n        if (params.amountsOut.length != params.minAmountsOut.length) revert InvalidMinAmountsOut();\n        if (params.deadline < block.timestamp) revert PastDeadline();\n\n        uint256 length = $.assets.length();\n        for (uint256 i; i < length; ++i) {\n            address asset = $.assets.at(i);\n            if (params.amountsOut[i] < params.minAmountsOut[i]) {\n                revert Slippage(asset, params.amountsOut[i], params.minAmountsOut[i]);\n            }\n            if (params.amountsOut[i] == 0) revert InvalidAmount();\n            _verifyBalance($, asset, params.amountsOut[i]);\n            _updateIndex($, asset);\n            $.totalSupplies[asset] -= params.amountsOut[i] + params.fees[i];\n            IERC20(asset).safeTransfer(params.receiver, params.amountsOut[i]);\n            IERC20(asset).safeTransfer($.insuranceFund, params.fees[i]);\n        }\n\n        emit Redeem(msg.sender, params.receiver, params.amountIn, params.amountsOut, params.fees);\n    }\n\n    /// @notice Borrow an asset\n    /// @dev Whitelisted agents can borrow any amount, LTV is handled by Agent contracts\n    /// @param $ Vault storage pointer\n    /// @param params Borrow parameters\n    function borrow(IVault.VaultStorage storage $, IVault.BorrowParams memory params)\n        external\n        whenNotPaused($, params.asset)\n        updateIndex($, params.asset)\n    {\n        _verifyBalance($, params.asset, params.amount);\n\n        $.totalBorrows[params.asset] += params.amount;\n        IERC20(params.asset).safeTransfer(params.receiver, params.amount);\n\n        emit Borrow(msg.sender, params.asset, params.amount);\n    }\n\n    /// @notice Repay an asset\n    /// @param $ Vault storage pointer\n    /// @param params Repay parameters\n    function repay(IVault.VaultStorage storage $, IVault.RepayParams memory params)\n        external\n        updateIndex($, params.asset)\n    {\n        $.totalBorrows[params.asset] -= params.amount;\n        IERC20(params.asset).safeTransferFrom(msg.sender, address(this), params.amount);\n\n        emit Repay(msg.sender, params.asset, params.amount);\n    }\n\n    /// @notice Add an asset to the vault list\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function addAsset(IVault.VaultStorage storage $, address _asset) external {\n        if (!$.assets.add(_asset)) revert AssetNotSupported(_asset);\n        emit AddAsset(_asset);\n    }\n\n    /// @notice Remove an asset from the vault list\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function removeAsset(IVault.VaultStorage storage $, address _asset) external {\n        if ($.totalSupplies[_asset] > 0) revert AssetHasSupplies(_asset);\n        if (!$.assets.remove(_asset)) revert AssetNotSupported(_asset);\n        emit RemoveAsset(_asset);\n    }\n\n    /// @notice Pause an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function pause(IVault.VaultStorage storage $, address _asset) external {\n        $.paused[_asset] = true;\n        emit PauseAsset(_asset);\n    }\n\n    /// @notice Unpause an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function unpause(IVault.VaultStorage storage $, address _asset) external {\n        $.paused[_asset] = false;\n        emit UnpauseAsset(_asset);\n    }\n\n    /// @notice Rescue an unsupported asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset to rescue\n    /// @param _receiver Receiver of the rescue\n    function rescueERC20(IVault.VaultStorage storage $, address _asset, address _receiver) external {\n        if (_listed($, _asset)) revert AssetNotRescuable(_asset);\n        IERC20(_asset).safeTransfer(_receiver, IERC20(_asset).balanceOf(address(this)));\n        emit RescueERC20(_asset, _receiver);\n    }\n\n    /// @notice Calculate the available balance of an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    /// @return balance Available balance\n    function availableBalance(IVault.VaultStorage storage $, address _asset) public view returns (uint256 balance) {\n        balance = $.totalSupplies[_asset] - $.totalBorrows[_asset];\n    }\n\n    /// @notice Calculate the utilization ratio of an asset\n    /// @dev Returns the ratio of borrowed assets to total supply, scaled to ray (1e27)\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    /// @return ratio Utilization ratio in ray (1e27)\n    function utilization(IVault.VaultStorage storage $, address _asset) public view returns (uint256 ratio) {\n        ratio = $.totalSupplies[_asset] != 0 ? $.totalBorrows[_asset] * 1e27 / $.totalSupplies[_asset] : 0;\n    }\n\n    /// @notice Up to date cumulative utilization index of an asset\n    /// @dev Utilization and index are both scaled in ray (1e27)\n    /// @param $ Vault storage pointer\n    /// @param _asset Utilized asset\n    /// @return index Utilization ratio index in ray (1e27)\n    function currentUtilizationIndex(IVault.VaultStorage storage $, address _asset)\n        external\n        view\n        returns (uint256 index)\n    {\n        index = $.utilizationIndex[_asset] + (utilization($, _asset) * (block.timestamp - $.lastUpdate[_asset]));\n    }\n\n    /// @notice Validate that an asset is listed\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset to check\n    /// @return isListed Asset is listed or not\n    function _listed(IVault.VaultStorage storage $, address _asset) internal view returns (bool isListed) {\n        isListed = $.assets.contains(_asset);\n    }\n\n    /// @notice Verify that an asset has enough balance\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    /// @param _amount Amount to verify\n    function _verifyBalance(IVault.VaultStorage storage $, address _asset, uint256 _amount) internal view {\n        uint256 balance = availableBalance($, _asset);\n        if (balance < _amount) {\n            revert InsufficientReserves(_asset, balance, _amount);\n        }\n    }\n\n    /// @dev Only allow supplies and borrows when not paused\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function _whenNotPaused(IVault.VaultStorage storage $, address _asset) private view {\n        if ($.paused[_asset]) revert AssetPaused(_asset);\n    }\n\n    /// @dev Update the cumulative utilization index of an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Utilized asset\n    function _updateIndex(IVault.VaultStorage storage $, address _asset) internal {\n        if (!_listed($, _asset)) revert AssetNotSupported(_asset);\n        $.utilizationIndex[_asset] += utilization($, _asset) * (block.timestamp - $.lastUpdate[_asset]);\n        $.lastUpdate[_asset] = block.timestamp;\n    }\n}\n"
    }
}