{
    "vfp_id": "vfp_00113",
    "project_name": "Jovay Rollup Contracts Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Unclear L1 Message Queue Logic",
            "description": "The `L1Mailbox` contract contains ambiguous and inconsistent logic for handling the message queue. The `popMsgs` function has `popFront()` commented out, so messages are never removed from the queue. Meanwhile, `getMsg` relies on `lastestQueueIndex` and `stableRollingHash`, which becomes outdated because it is never updated after messages are processed.\n\nThe root cause is incomplete refactoring: the team changed from a popping model to an index-tracking model but failed to fully update all related functions and remove dead code. The `setLastQueueIndex` function exists for upgrades but is not integrated into normal operation, creating state desynchronization risks.\n\nAn attacker could exploit this by triggering edge cases where `getMsg` returns incorrect rolling hashes, potentially leading to invalid message inclusion in batches or verification failures. Relayers may submit inconsistent data, and upgrades could introduce hard-to-predict behavior.\n\nThe impact includes potential DoS due to verification mismatches, incorrect message processing, and operational fragility during upgrades. While the mainnet deployment avoids some issues due to clean state, the code remains fragile and error-prone.\n",
            "severity": "Medium",
            "location": [
                "L1Mailbox.sol::getMsg#204-215",
                "L1Mailbox.sol::popMsgs#242",
                "L1Mailbox.sol::setLastQueueIndex#220-222"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-408"
                ]
            },
            "title": "Missing Gas Bounds and Fee Accounting in `L2Mailbox`",
            "description": "The `L2Mailbox.sendMsg` function uses the `gasLimit` parameter to calculate fees but does not enforce any minimum or maximum bounds. Users can set `gasLimit` to zero and avoid paying any fee while still generating valid withdrawal messages that relayers must process.\n\nAdditionally, the fee calculation does not account for the size of the `msg_` data, which can be arbitrarily large and increase blob storage costs. There is also no fee tracking mechanism (e.g., a balance variable) or withdrawal function for collected fees, leading to unaccounted funds.\n\nThe root cause is incomplete fee design: while `L1Mailbox` includes fee accounting, `L2Mailbox` was designed to set `baseFee` to zero, effectively disabling fees. However, this creates a gap in economic security, especially if ZK proofs are enabled in the future.\n\nAn attacker could spam the system with zero-fee, high-data messages, forcing relayers to bear the cost of blob submissions and proof verification. This could make operation economically unviable.\n\nThe impact includes potential DoS via spam, unfair cost distribution, and lack of transparency in fee handling. Although currently mitigated by zero fees, the design is fragile and not future-proof.\n",
            "severity": "Medium",
            "location": [
                "L2Mailbox.sol::sendMsg#43-75",
                "L1Mailbox.sol::sendMsg#105-106",
                "L2ETHBridge.sol::withdraw#21"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L2/core/L2Mailbox.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unsafe ETH and Token Handling in the Bridge Contracts",
            "description": "The L1Mailbox contract inherits a receive() function from MailBoxBase, allowing direct ETH transfers to it, which can result in permanently locked funds as users may mistakenly send ETH instead of using the proper deposit function. Similarly, on L2, users can send native tokens directly to L2Mailbox instead of calling withdraw, creating confusion and risk. Additionally, functions like relayMsgWithProof are marked payable despite not requiring ETH, increasing the risk of accidental and useless ETH transfers. The root cause is poor UX design and lack of protective measures against direct fund transfers. An attacker or mistaken user could send ETH directly to the contract, leading to loss of funds. The impact includes user fund loss and reduced trust in the bridge mechanism.\n",
            "severity": "Medium",
            "location": [
                "L1ETHBridge.sol::deposit#16-27",
                "L1Mailbox.sol::receive#96",
                "MailBoxBase.sol::receive#96",
                "L2ETHBridge.sol::withdraw#21-31",
                "L1BridgeProof.sol::relayMsgWithProof#8-15"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L2/core/L2Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ETHBridge.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Invalid Gas Limit Configuration Can Disable Deposits",
            "description": "The sendMsg function in L1Mailbox requires the user-provided gasLimit_ to be strictly less than l2GasLimit and greater than or equal to l2FinalizeDepositGasUsed. However, the setter functions allow l2GasLimit and l2FinalizeDepositGasUsed to be set equal, which would make it impossible to satisfy the strict inequality, thereby blocking all deposits. The root cause is insufficient validation in the setter functions, which only ensure l2GasLimit is not strictly less than l2FinalizeDepositGasUsed but allow equality. A malicious or mistaken owner could set these values equal, either intentionally or accidentally. The impact is a complete halt of deposit functionality, resulting in a denial of service for the entire bridge.\n",
            "severity": "Medium",
            "location": [
                "L1Mailbox.sol::sendMsg#105-106",
                "L1Mailbox.sol::setL2GasLimit#173-180",
                "L1Mailbox.sol::setL2FinalizeDepositGasUsed#185-192"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing Zero-Address Checks",
            "description": "Several functions across the codebase fail to validate that address parameters are not the zero address before assigning them to state variables or using them in critical operations. This includes functions in L1Mailbox, Rollup, L2ERC20Bridge, L2ETHBridge, L2CoinBase, and ERC20Token. The root cause is the omission of require(_addr != address(0)) checks. A mistaken or malicious caller could set critical addresses to zero, which may result in loss of control, inability to recover funds, or breaking contract functionality (e.g., sending funds to the burn address). The impact includes permanent loss of access, denial of service, and potential fund loss due to irreversible operations.\n",
            "severity": "Medium",
            "location": [
                "L1Mailbox.sol#147",
                "L1Mailbox.sol#156",
                "L1Mailbox.sol#166",
                "Rollup.sol#107",
                "L2ERC20Bridge.sol#72",
                "L2ETHBridge.sol#45",
                "L2CoinBase.sol#21",
                "L2Mailbox.sol#117",
                "ERC20Token.sol#38"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol"
            ]
        }
    ],
    "affected_files": {
        "L1Mailbox.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IL1Mailbox.sol\";\nimport \"../interfaces/IRollup.sol\";\nimport \"../../common/MailBoxBase.sol\";\nimport \"../libraries/verifier/WithdrawTrieVerifier.sol\";\nimport \"../interfaces/IL1MailQueue.sol\";\nimport \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\n\ncontract L1Mailbox is MailBoxBase, IL1Mailbox, IL1MailQueue {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    event SetL2GasLimit(uint256 oldGasLimit, uint256 newGasLimit);\n\n    event SetL2FinalizeDepositGasUsed(uint256 oldL2FinalizeDepositGasUsed, uint256 newL2FinalizeDepositGasUsed);\n\n    // double ended msg queue\n    // begin is next finalize msg\n    // end + 1 is next append msg\n    DoubleEndedQueue.Bytes32Deque private msgQueue;\n\n    bytes32 public stableRollingHash;\n\n    // next pending msg index\n    uint256 public pendingQueueIndex;\n\n    // init with 0;\n    uint256 public nextFinalizeQueueIndex;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The gaslimit of L2, deposit gas limit must less than this value.\n    uint256 public l2GasLimit;\n\n    uint256 public feeBalance;\n\n    address public withdrawer;\n\n    uint256 public l2FinalizeDepositGasUsed;\n\n    uint256 public lastestQueueIndex;\n\n    modifier onlyRollup() {\n        require(msg.sender == rollup, \"Only callable by the Rollup\");\n        _;\n    }\n\n    modifier onlyWithdrawer() {\n        require(msg.sender == withdrawer, \"Only callable by the withdrawer\");\n        _;\n    }\n\n    constructor(){\n        _disableInitializers();\n    }\n\n    /**\n     * Contract initialization\n     * @param rollup_ rollup contract address\n     * @param owner_ contract owner address\n     * @param baseFee_ base fee\n     */\n    function initialize(address rollup_, address owner_, uint256 baseFee_, uint256 _l2GasLimit, uint256 _l2FinalizeDepositGasUsed) external initializer {\n        if (rollup_ == address(0) || owner_ == address(0)) {\n            revert InvalidInitAddress();\n        }\n\n        if (_l2GasLimit < _l2FinalizeDepositGasUsed) {\n            revert InvalidL2GasLimit();\n        }\n        __MailBox_init();\n\n        rollup = rollup_;\n        baseFee = baseFee_;\n        l2GasLimit = _l2GasLimit;\n        l2FinalizeDepositGasUsed = _l2FinalizeDepositGasUsed;\n        _transferOwnership(owner_);\n    }\n\n    function setRollup(address rollup_) external whenPaused onlyOwner {\n        require(rollup_ != address(0), \"Invalid rollup address\");\n        rollup = rollup_;\n    }\n\n    function setWithdrawer(address _withdrawer) external onlyOwner {\n        require(_withdrawer != address(0), \"Invalid withdrawer address\");\n        withdrawer = _withdrawer;\n    }\n\n    function sendMsg(\n        address target_,\n        uint256 value_,\n        bytes calldata msg_,\n        uint256 gasLimit_,\n        address refundAddress_\n    ) external payable override onlyBridge whenNotPaused nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 nonce_ = nextMsgIndex();\n        bytes memory data_ = _encodeCall(_msgSender(), target_, value_, nonce_, msg_);\n\n        // Calculate the fee and leave it in the MailBox contract\n        uint256 fee_ = estimateMsgFee(gasLimit_);\n        require(gasLimit_ < l2GasLimit, \"gasLimit must less than L2 config\");\n        require(gasLimit_ >= l2FinalizeDepositGasUsed, \"gas limit must be bigger than or equal to the tx_fee of finalize deposit on Jovay\");\n        require(msg.value >= fee_ + value_, \"Insufficient msg.value\");\n\n        bytes32 hash_ = keccak256(data_);\n        // normally this won't happen, since each message has different nonce, but just in case.\n        _sendMsgCheck(hash_);\n\n        // append message to L1MailQueue\n        _appendMsg(_getRollingHash(hash_));\n\n        emit SentMsg(_msgSender(), target_, value_, nonce_, data_, gasLimit_, hash_);\n\n        // refund fee to `refundAddress_`\n        unchecked {\n            uint256 refund_ = msg.value - fee_ - value_;\n            if (refund_ > 0) {\n                (bool success_,) = refundAddress_.call{value : refund_}(\"\");\n                require(success_, \"Failed to refund the fee\");\n            }\n        }\n        feeBalance += fee_;\n    }\n\n    /**\n     * Send L2 message to L1, need to verify the validity of the message through proof,\n     * if valid, execute the corresponding message in L1 bridge contract\n     * @param sender_; sender L2 bridge contract address\n     * @param target_; message receiver L1 bridge contract address\n     * @param value_; native token transfer amount\n     * @param nonce_; message nonce value\n     * @param msg_; message content sent to target_ execution\n     * @param proof_; proof information used to prove the validity of the message\n     */\n    function relayMsgWithProof(\n        address sender_,\n        address target_,\n        uint256 value_,\n        uint256 nonce_,\n        bytes memory msg_,\n        L2MsgProof memory proof_\n    ) external payable whenNotPaused nonReentrant {\n        require(sender_ == IBridge(target_).toBridge(), \"Invalid sender\");\n        bytes32 hash_ = keccak256(_encodeCall(sender_, target_, value_, nonce_, msg_));\n\n        bytes32 msgRoot_ = IRollup(rollup).getL2MsgRoot(proof_.batchIndex);\n        require(\n            WithdrawTrieVerifier.verifyMerkleProof(msgRoot_, hash_, nonce_, proof_.merkleProof),\n            \"Invalid proof\"\n        );\n\n        (bool success,) = target_.call{value : value_}(msg_);\n        require(success, \"RelayMsg Failed\");\n        _receiveMsgCheck(hash_);\n        emit RelayedMsg(hash_, nonce_);\n    }\n\n    function withdrawDepositFee(address _target, uint256 _amount) external onlyWithdrawer whenNotPaused {\n        require(_target.code.length == 0, \"INVALID_PARAMETER: withdraw target must be eoa\");\n        require(_amount <= feeBalance, \"INVALID_PARAMETER : withdraw amount must smaller than or equal to fee in mailbox\");\n        feeBalance -= _amount;\n        (bool success,) = _target.call{value : _amount}(\"\");\n        require(success, \"INTERNAL_ERROR : withdraw fee Failed\");\n    }\n\n    /**\n     * @notice Set new L2 Gas limit for deposit\n     */\n    function setL2GasLimit(uint256 _l2GasLimit) external onlyOwner {\n        if (l2FinalizeDepositGasUsed > _l2GasLimit) {\n            revert SetL2GasLimitSmallerThanGasUsed();\n        }\n        uint256 oldL2GasLimit = l2GasLimit;\n        l2GasLimit = _l2GasLimit;\n        emit SetL2GasLimit(oldL2GasLimit, _l2GasLimit);\n    }\n\n    /**\n     * @notice Set new L2 Gas used for finalize deposit\n     */\n    function setL2FinalizeDepositGasUsed(uint256 _l2FinalizeDepositGasUsed) external onlyOwner {\n        if (_l2FinalizeDepositGasUsed > l2GasLimit) {\n            revert SetL2FinalizeDepositGasUsedBiggerThanGasLimit();\n        }\n        uint256 oldL2FinalizeDepositGasUsed = l2FinalizeDepositGasUsed;\n        l2FinalizeDepositGasUsed = _l2FinalizeDepositGasUsed;\n        emit SetL2FinalizeDepositGasUsed(oldL2FinalizeDepositGasUsed, _l2FinalizeDepositGasUsed);\n    }\n\n    /**\n     * @notice Returns next message index\n     */\n    function nextMsgIndex() public view override returns (uint256) {\n        return pendingQueueIndex;\n    }\n\n    /**\n     * @notice Returns message at index\n     */\n    function getMsg(uint256 _l1MsgCount) external view override returns (bytes32) {\n        if (_l1MsgCount == 0) {\n            return bytes32(0);\n        }\n        // totalIndex - 1 == index; index >= nextFinalizeQueueIndex or index = nextFinalizeQueueIndex - 1;\n        require(_l1MsgCount >= lastestQueueIndex, \"used msg must bigger than lastestQueueIndex\");\n        require(_l1MsgCount - 1 < pendingQueueIndex, \"used msg must smaller than next pending\");\n        if (_l1MsgCount < lastestQueueIndex + 1) {\n            return stableRollingHash;\n        }\n        return msgQueue.at(_l1MsgCount - lastestQueueIndex - 1);\n    }\n\n    /**\n      * @notice set lastest queue index  called when pause\n     */\n    function setLastQueueIndex() external whenPaused onlyOwner {\n        lastestQueueIndex = nextFinalizeQueueIndex;\n    }\n\n    /**\n     * @notice Appends message to queue\n     */\n    function _appendMsg(bytes32 msg_) internal override {\n        msgQueue.pushBack(msg_);\n        pendingQueueIndex++;\n        emit AppendMsg(pendingQueueIndex, msg_);\n    }\n\n    /**\n     * @notice Pops messages from queue\n     */\n    function popMsgs(uint256 _l1MsgCount) external onlyRollup whenNotPaused {\n        // l1MsgCount - 1 = index < pendingQueueIndex\n        require(_l1MsgCount < pendingQueueIndex + 1, \"finalize index must smaller than pendingQueueIndex\");\n        require(_l1MsgCount >= nextFinalizeQueueIndex, \"finalize index must smaller than or equal to l1MsgCount\");\n        nextFinalizeQueueIndex = _l1MsgCount;\n//        while (nextFinalizeQueueIndex < _l1MsgCount) {\n//            stableRollingHash = msgQueue.popFront();\n//            nextFinalizeQueueIndex++;\n//        }\n        emit PopMsgs(nextFinalizeQueueIndex);\n    }\n\n}\n",
        "L2Mailbox.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {AppendOnlyMerkleTree} from \"../libraries/common/AppendOnlyMerkleTree.sol\";\nimport \"../interfaces/IL2Mailbox.sol\";\nimport \"../interfaces/IL2MailQueue.sol\";\nimport \"../../common/MailBoxBase.sol\";\n\ncontract L2Mailbox is AppendOnlyMerkleTree, MailBoxBase, IL2Mailbox, IL2MailQueue {\n    /// @notice The address of L1MailBox contract.\n    address public l1MailBox;\n\n    mapping(bytes32 => bool) public receiveMsgStatus;\n\n    constructor(){\n        _disableInitializers();\n    }\n\n    /**\n     * Contract initialization\n     * @param l1MailBox_ L1MailBox contract address\n     * @param owner_ Contract owner address\n     * @param baseFee_ Message sender token transfer amount\n     */\n    function initialize(address l1MailBox_, address owner_, uint256 baseFee_) external initializer {\n        if (l1MailBox_ == address(0) || owner_ == address(0)) {\n            revert InvalidInitAddress();\n        }\n        require(_nextMsgIndex == 0, \"msg index is not 0\");\n        __MailBox_init();\n\n        l1MailBox = l1MailBox_;\n        baseFee = baseFee_;\n        _transferOwnership(owner_);\n        _initializeMerkleTree();\n    }\n\n    function setL1MailBox(address l1MailBox_) whenPaused external onlyOwner {\n        require(l1MailBox_ != address(0), \"Invalid address\");\n        l1MailBox = l1MailBox_;\n    }\n\n    function sendMsg(\n        address target_,\n        uint256 value_,\n        bytes calldata msg_,\n        uint256 gasLimit_,\n        address refundAddress_\n    ) external payable override onlyBridge whenNotPaused nonReentrant {\n\n        // compute the actual cross domain message calldata.\n        uint256 nonce_ = _nextMsgIndex;\n        bytes memory data_ = _encodeCall(_msgSender(), target_, value_, nonce_, msg_);\n\n        // Calculate the fee and keep it in the MailBox contract\n        uint256 fee_ = estimateMsgFee(gasLimit_);\n        require(msg.value >= fee_ + value_, \"Insufficient msg.value\");\n\n        bytes32 hash_ = keccak256(data_);\n        // normally this won't happen, since each message has different nonce, but just in case.\n        _sendMsgCheck(hash_);\n        // append message to L2MailQueue\n        _appendMsg(hash_);\n\n        emit SentMsg(_msgSender(), target_, value_, nonce_, msg_, gasLimit_, hash_);\n\n        // refund fee to `refundAddress_`\n        unchecked {\n            uint256 refund_ = msg.value - fee_ - value_;\n            if (refund_ > 0) {\n                (bool success_,) = refundAddress_.call{value : refund_}(\"\");\n                require(success_, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /**\n     * Send L1 message to current L2 through Relayer\n     * @param sender_ sender L1 bridge contract address\n     * @param target_ message receiver current L2 bridge contract address\n     * @param value_ native token transfer amount\n     * @param nonce_ message queue nonce\n     * @param msg_ message content sent to target_ execution\n     */\n    function relayMsg(\n        address sender_,\n        address target_,\n        uint256 value_,\n        uint256 nonce_,\n        bytes calldata msg_\n    ) external override whenNotPaused nonReentrant {\n        // here l1MailBox will be set as L2Relayer 0x5100000000000000000000000000000000000000\n        require(_msgSender() == l1MailBox, \"Caller is not L1Mailbox\");\n\n        bytes32 hash_ = keccak256(_encodeCall(sender_, target_, value_, nonce_, msg_));\n        bytes32 rollinghash = _getRollingHash(hash_);\n        emit RollingHash(rollinghash);\n        _receiveMsgCheck(hash_);\n        (bool success,) = target_.call{value : value_}(msg_);\n        if (success) {\n            _receiveMsgSuccess(hash_);\n            emit FinalizeDepositETHSuccess(hash_, nonce_);\n        } else {\n            _receiveMsgFailed(hash_);\n            emit FinalizeDepositETHFailed(hash_, nonce_);\n        }\n        emit RelayedMsg(hash_, nonce_);\n    }\n\n    function claimAmount(\n        address refundAddress_,\n        uint256 amount_,\n        uint256 nonce_,\n        bytes32 msgHash_\n    ) external override onlyBridge whenNotPaused nonReentrant {\n        _checkMsgClaimValid(msgHash_);\n        (bool success,) = refundAddress_.call{value : amount_}(\"\");\n        require(success, \"claim amount failed when transfer to refund\");\n        _finalizeClaimMsg(msgHash_);\n\n        emit ClaimMsg(msgHash_, nonce_);\n    }\n\n    /**\n     * @dev Appends a message to the queue.\n     */\n    function _appendMsg(bytes32 msgHash) internal override {\n        (uint256 currentNonce,) = _appendMsgHash(msgHash);\n        // We can use the event to compute the merkle tree locally.\n        emit AppendMsg(currentNonce, msgHash);\n    }\n\n    function msgRoot() external view returns (bytes32) {\n        return _msgRoot;\n    }\n\n    function _receiveMsgFailed(bytes32 hash_) internal {\n        receiveMsgStatus[hash_] = false;\n    }\n\n    function _receiveMsgSuccess(bytes32 hash_) internal {\n        receiveMsgStatus[hash_] = true;\n    }\n\n    function _checkMsgClaimValid(bytes32 hash_) internal view {\n        _msgExistCheck(hash_);\n        require(!receiveMsgStatus[hash_], \"ClaimMsg : L2 msg must exec failed before\");\n    }\n\n    function _finalizeClaimMsg(bytes32 hash_) internal {\n        _msgExistCheck(hash_);\n        require(!receiveMsgStatus[hash_], \"ClaimMsg : L2 msg must exec failed before\");\n        receiveMsgStatus[hash_] = true;\n    }\n\n}\n",
        "L1ETHBridge.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./interfaces/IL1ETHBridge.sol\";\nimport \"../interfaces/IL1Mailbox.sol\";\nimport \"../../L2/bridge/interfaces/IL2ETHBridge.sol\";\nimport \"./L1BridgeProof.sol\";\n\ncontract L1ETHBridge is L1BridgeProof, IL1ETHBridge {\n    using AddressUpgradeable for address;\n    uint256 public balance;\n\n    function deposit(address to_, uint256 amount_, uint256 gasLimit_, bytes memory msg_) external payable override nonReentrant whenNotPaused {\n        require(amount_ > 0, \"deposit zero eth\");\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address sender_ = _msgSender();\n\n        // 2. Generate message passed to L1Mailbox.\n        bytes memory message_ = abi.encodeCall(IL2ETHBridge.finalizeDeposit, (sender_, to_, amount_, msg_));\n        balance += amount_;\n        mailBoxCall(abi.encodeCall(IMailBoxBase.sendMsg, (toBridge, amount_, message_, gasLimit_, sender_)));\n\n        emit DepositETH(sender_, to_, amount_, msg_);\n    }\n\n    function finalizeWithdraw(address sender_, address to_, uint256 amount_, bytes memory msg_) external payable override nonReentrant onlyMailBox whenNotPaused {\n        require(msg.value == amount_, \"msg.value mismatch\");\n        require(balance >= amount_, \"balance too low\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        balance -= amount_;\n        (bool success_, ) = to_.call{value: amount_}(\"\");\n        require(success_, \"ETH transfer failed\");\n// TODO : add call msg with withdraw\n//        _doCallback(to_, msg_);\n\n        emit FinalizeWithdrawETH(sender_, to_, amount_, msg_);\n    }\n}\n"
    }
}