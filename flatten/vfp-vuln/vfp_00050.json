{
    "vfp_id": "vfp_00050",
    "project_name": "cantina_liminal_oct2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-179"
                ]
            },
            "title": "Unsafe Type Conversion for Refund Recipient Can Lead to Funds Lost to 0xdead Address",
            "description": "In the lzCompose function's catch block, the logic to determine the refund recipient contains an unsafe type conversion. The code extracts a bytes32 value (extractedRecipient) and checks if it is non-zero before converting it to an address. However, a bytes32 value can be non-zero while its lower 20 bytes (used for address conversion) are zero, resulting in address(0). This causes refunded assets to be sent to LayerZero's null address (0xdead), leading to permanent loss of funds.\nThe root cause is validating the bytes32 value before conversion instead of validating the resulting address after conversion.\nAn attacker could craft a malicious payload where the upper bytes of the bytes32 are non-zero but the lower 20 bytes are zero, triggering the vulnerability.\nThe impact is permanent loss of user funds during cross-chain refund operations, reducing recoverability of assets in failure scenarios.\n",
            "severity": "Medium",
            "location": [
                "VaultComposerBase.sol#L101-L105"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultComposerBase.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultComposerBase.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {IOAppCore} from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol\";\nimport {ILayerZeroEndpointV2} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title VaultComposerBase - Multi-Asset Vault Composer Base\n * @notice Minimal base contract for cross-chain vault operations\n */\nabstract contract VaultComposerBase is IOAppComposer, ReentrancyGuardUpgradeable {\n    using OFTComposeMsgCodec for bytes;\n    using OFTComposeMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    address public SHARE_OFT;\n    address public SHARE_ERC20;\n    address public ENDPOINT;\n    uint32 public VAULT_EID;\n\n    // Events\n    event Sent(bytes32 indexed guid);\n    event Refunded(bytes32 indexed guid);\n    event CrossChainDeposit(address indexed asset, address indexed depositor, address indexed shareRecipient, uint32 srcEid, uint256 dstEid, uint256 amount, uint256 shares);\n    event CrossChainRedemption(address indexed redeemer, address indexed assetRecipient, uint32 srcEid, uint256 dstEid, uint256 shares, uint256 assets);\n    event NativeRefunded(address indexed recipient, uint256 amount);\n    event AssetRefunded(address indexed asset, address indexed from, address indexed to, uint256 amount, uint32 dstEid);\n    event DustRefunded(address indexed asset, address indexed recipient, uint256 amount);\n\n    // Errors\n    error OnlyEndpoint(address caller);\n    error ShareOFTNotAdapter(address shareOFT);\n    error InvalidSendParam();\n    error InsufficientMsgValue();\n    error Slippage(uint256 actual, uint256 minimum);\n    error UnauthorizedOFTSender(address sender);\n    error InvalidSourceChain(uint32 srcEid);\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.VaultComposerBase.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0x6c0f4739f9b140a9470c9589ba863e64a556e1c02777b0938a3c35b5956b9000;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __VaultComposerBase_init(address _shareOFT) internal onlyInitializing {\n        SHARE_OFT = _shareOFT;\n        SHARE_ERC20 = IOFT(SHARE_OFT).token();\n        ENDPOINT = address(IOAppCore(SHARE_OFT).endpoint());\n        VAULT_EID = ILayerZeroEndpointV2(ENDPOINT).eid();\n\n        __ReentrancyGuard_init();\n\n        if (!IOFT(SHARE_OFT).approvalRequired()) {\n            revert ShareOFTNotAdapter(SHARE_OFT);\n        }\n    }\n\n    function lzCompose(address _composeSender, bytes32 _guid, bytes calldata _message, address, bytes calldata)\n        public\n        payable\n        virtual\n        override\n    {\n        if (msg.sender != ENDPOINT) revert OnlyEndpoint(msg.sender);\n\n        // Verify that the OFT calling lzCompose is in our approved list\n        // This prevents arbitrary malicious OFTs from triggering compose actions\n        if (!_isApprovedOFT(_composeSender)) {\n            revert UnauthorizedOFTSender(_composeSender);\n        }\n\n        // Verify that messages from this OFT are only accepted from configured source chains\n        // This prevents messages from unauthorized chains even if the OFT is approved\n        {\n            bytes32 expectedPeer = _getRemotePeer(_composeSender, _message.srcEid());\n            if (expectedPeer == bytes32(0)) {\n                revert InvalidSourceChain(_message.srcEid());\n            }\n        }\n\n        bytes32 composeFrom = _message.composeFrom();\n        uint256 amount = _message.amountLD();\n        bytes memory composeMsg = _message.composeMsg();\n        uint32 srcEid = _message.srcEid();\n\n        try this.handleCompose{value: msg.value}(_composeSender, composeFrom, _guid, composeMsg, amount, srcEid) {\n            emit Sent(_guid);\n        } catch (bytes memory _err) {\n            if (bytes4(_err) == InsufficientMsgValue.selector) {\n                assembly {\n                    revert(add(32, _err), mload(_err))\n                }\n            }\n            _handleRefund(_composeSender, _message, composeFrom, composeMsg, amount);\n            emit Refunded(_guid);\n        }\n    }\n\n    function handleCompose(\n        address _oftIn,\n        bytes32 _composeFrom,\n        bytes32 _guid,\n        bytes memory _composeMsg,\n        uint256 _amount,\n        uint32 _srcEid\n    ) public payable virtual;\n\n    /**\n     * @notice Handle refund logic by extracting recipients from compose message\n     * Assets are returned to composeFrom on the ORIGIN chain (for multi-hop support)\n     * Native fees are returned to feeRefundRecipient on this chain\n     * Useful if using a wallet contract on the source chain.\n     * The wallet contract must receive the tokens, but may not\n     * exist on the hub chain, so trying to refund them the fees\n     * on the hub chain would be a mistake.\n     */\n    function _handleRefund(\n        address _composeSender,\n        bytes calldata _message,\n        bytes32 _composeFrom,\n        bytes memory _composeMsg,\n        uint256 _amount\n    ) internal virtual {\n        // Assets ALWAYS go back to composeFrom on origin chain\n        address assetRecipient = _composeFrom.bytes32ToAddress();\n\n        // Fees default to composeFrom but can be overridden\n        address feeRecipient = _composeFrom.bytes32ToAddress();\n\n        (uint8 action, bytes memory params) = abi.decode(_composeMsg, (uint8, bytes));\n\n        // Extract fee refund recipient and originEid (ignore receiver since assets always go to composeFrom)\n        (, bytes32 extractedFeeRecipient, uint32 originEid) = _decodeReceivers(action, params);\n\n        address feeRecipientAddr = extractedFeeRecipient.bytes32ToAddress();\n        if (feeRecipientAddr != address(0)) {\n            feeRecipient = feeRecipientAddr;\n        }\n\n        // Use originEid if provided, otherwise fallback to srcEid for single-hop scenarios\n        uint32 refundEid = originEid != 0 ? originEid : _message.srcEid();\n\n        _refund(_composeSender, _message, _amount, assetRecipient, feeRecipient, refundEid);\n    }\n\n    function _send(address _oft, SendParam memory _sendParam, address _refundAddress) internal virtual {\n        if (_sendParam.to == bytes32(0) || _sendParam.amountLD == 0) revert InvalidSendParam();\n\n        MessagingFee memory fee = IOFT(_oft).quoteSend(_sendParam, false);\n        if (msg.value < fee.nativeFee) revert InsufficientMsgValue();\n\n        IOFT(_oft).send{value: fee.nativeFee}(_sendParam, fee, _refundAddress);\n\n        // Refund excess native\n        if (msg.value > fee.nativeFee) {\n            uint256 refundAmount = msg.value - fee.nativeFee;\n            payable(_refundAddress).transfer(refundAmount);\n            emit NativeRefunded(_refundAddress, refundAmount);\n        }\n    }\n\n    function _refund(\n        address _oft,\n        bytes calldata /* _message */,\n        uint256 _amount,\n        address _assetRecipient,\n        address _feeRecipient,\n        uint32 _refundEid\n    ) internal virtual {\n        SendParam memory refundParam = SendParam({\n            dstEid: _refundEid,  // Use originEid for multi-hop support\n            to: bytes32(uint256(uint160(_assetRecipient))),  // Assets go to receiver on origin chain\n            amountLD: _amount,\n            minAmountLD: 0,\n            extraOptions: \"\",\n            composeMsg: \"\",\n            oftCmd: \"\"\n        });\n\n        // Assets are sent to _assetRecipient on origin chain\n        // Excess native fees are refunded to _feeRecipient on this chain\n        IOFT(_oft).send{value: msg.value}(refundParam, MessagingFee(msg.value, 0), _feeRecipient);\n\n        address asset = IOFT(_oft).token();\n        emit AssetRefunded(asset, address(this), _assetRecipient, _amount, _refundEid);\n    }\n\n    function _assertSlippage(uint256 _amount, uint256 _minAmount) internal pure {\n        if (_amount < _minAmount) revert Slippage(_amount, _minAmount);\n    }\n\n    /**\n     * @notice Internal helper to decode receivers and originEid from compose params\n     * @dev Used in try-catch pattern to extract asset receiver, fee refund recipient, and origin chain ID\n     * @param _action The action type (1=deposit, 2=redeem, 3=withdraw)\n     * @param _params The encoded parameters\n     * @return receiver The receiver address where assets should be delivered on this chain (bytes32(0) if not provided)\n     * @return feeRefundRecipient The fee refund recipient address on this chain (bytes32(0) if not provided)\n     * @return originEid The origin chain ID for multi-hop refunds\n     */\n    function _decodeReceivers(uint8 _action, bytes memory _params)\n        internal\n        pure\n        returns (bytes32 receiver, bytes32 feeRefundRecipient, uint32 originEid)\n    {\n        if (_action == 1) {\n            // ACTION_DEPOSIT_ASSET: (address targetAsset, bytes32 receiver, SendParam, uint256 minMsgValue, bytes32 feeRefundRecipient, uint32 originEid)\n            (, receiver, , , feeRefundRecipient, originEid) = abi.decode(_params, (address, bytes32, SendParam, uint256, bytes32, uint32));\n        } else if (_action == 2) {\n            // ACTION_REDEEM_SHARES: (address receiver, SendParam, uint256 minMsgValue, uint256 minAssets, bytes32 feeRefundRecipient, uint32 originEid)\n            address receiverAddr;\n            (receiverAddr, , , , feeRefundRecipient, originEid) = abi.decode(_params, (address, SendParam, uint256, uint256, bytes32, uint32));\n            receiver = bytes32(uint256(uint160(receiverAddr)));\n        }\n        // Returns (bytes32(0), bytes32(0), 0) for unknown actions\n    }\n\n    /**\n     * @notice Check if an OFT is approved to send compose messages\n     * @dev Must be implemented by derived contracts\n     * @param _oft The OFT address to check\n     * @return bool True if the OFT is approved\n     */\n    function _isApprovedOFT(address _oft) internal view virtual returns (bool);\n\n    /**\n     * @notice Get the expected remote peer for an OFT on a specific source chain\n     * @dev Must be implemented by derived contracts\n     * @param _oft The OFT address\n     * @param _srcEid The source endpoint ID\n     * @return bytes32 The expected peer address (bytes32(0) if not configured)\n     */\n    function _getRemotePeer(address _oft, uint32 _srcEid) internal view virtual returns (bytes32);\n}"
    }
}