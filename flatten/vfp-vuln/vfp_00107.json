{
    "vfp_id": "vfp_00107",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Oracle update front-running allows extraction of value from vaults",
            "description": "The protocol's minting and burning functions are vulnerable to oracle sandwiching attacks due to the use of current oracle prices without protection against timing manipulation. The root cause is the lack of safeguards such as fees, TWAPs, or circuit breakers around oracle updates. An attacker can monitor pending Chainlink oracle updates and front-run them by depositing assets before the price update and withdrawing after, profiting from the price difference. For example, when the USDC price drops, the attacker deposits at the old price and withdraws at the new, higher effective rate, extracting value from the protocol. The impact is a direct loss of funds from the protocol treasury proportional to the size of the oracle update, exploiting natural market movements rather than oracle manipulation, which undermines the economic integrity of the system.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/Vault.sol",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/oracle/Oracle.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "Inconsistent balance tracking in vault creates DoS for asset borrowing",
            "description": "The Vault contract uses inconsistent accounting methods: some functions rely on totalSupplies while others use direct balanceOf checks. The burn function reduces totalSupplies without validating against actual token balances, allowing totalSupplies to drop below totalBorrows. This violates the invariant that total supply must be >= total borrows. The root cause is the lack of synchronization between accounting variables and real token balances. An attacker can exploit this by transferring tokens directly to the vault and then burning more than the accounted supply, creating a negative available balance. The impact is a system-wide denial of service for borrowing that specific asset, even if physical tokens are available.\n",
            "severity": "High",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::burn#111-124",
                "contracts/vault/Vault.sol::availableBalance#206-209",
                "contracts/lendingPool/libraries/ViewLogic.sol::maxBorrowable#83-91",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/lendingPool/libraries/ViewLogic.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ]
            },
            "title": "Unsafe asset removal without borrow validation",
            "description": "The removeAsset function in VaultLogic allows removing an asset from the vault's list without checking if there are outstanding borrows. This can lead to a state where borrowers cannot repay loans because the asset is no longer recognized by the system. The root cause is the absence of a pre-removal validation check for totalBorrows. An admin or attacker with access could remove an asset with active loans, rendering repayment functions ineffective. The impact is that borrowers' funds become locked, they cannot clear their debt, and the system enters an inconsistent state.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::removeAsset#192-208",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        }
    ],
    "affected_files": {
        "ViewLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IDebtToken } from \"../../interfaces/IDebtToken.sol\";\nimport { IDelegation } from \"../../interfaces/IDelegation.sol\";\n\nimport { ILender } from \"../../interfaces/ILender.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { AgentConfiguration } from \"./configuration/AgentConfiguration.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title View Logic\n/// @author kexley, @capLabs\n/// @notice View functions to see the state of an agent's health\nlibrary ViewLogic {\n    using AgentConfiguration for ILender.AgentConfigurationMap;\n\n    /// @notice Calculate the agent data\n    /// @param $ Lender storage\n    /// @param _agent Agent address\n    /// @return totalDelegation Total delegation of an agent in USD, encoded with 8 decimals\n    /// @return totalDebt Total debt of an agent in USD, encoded with 8 decimals\n    /// @return ltv Loan to value ratio, encoded in ray (1e27)\n    /// @return liquidationThreshold Liquidation ratio of an agent, encoded in ray (1e27)\n    /// @return health Health status of an agent, encoded in ray (1e27)\n    function agent(ILender.LenderStorage storage $, address _agent)\n        public\n        view\n        returns (uint256 totalDelegation, uint256 totalDebt, uint256 ltv, uint256 liquidationThreshold, uint256 health)\n    {\n        totalDelegation = IDelegation($.delegation).coverage(_agent);\n        liquidationThreshold = IDelegation($.delegation).liquidationThreshold(_agent);\n\n        for (uint256 i; i < $.reservesCount; ++i) {\n            if (!$.agentConfig[_agent].isBorrowing(i)) {\n                continue;\n            }\n\n            address asset = $.reservesList[i];\n            (uint256 assetPrice,) = IOracle($.oracle).getPrice(asset);\n            if (assetPrice == 0) continue;\n\n            totalDebt += (\n                IERC20($.reservesData[asset].principalDebtToken).balanceOf(_agent)\n                    + IERC20($.reservesData[asset].interestDebtToken).balanceOf(_agent)\n                    + IERC20($.reservesData[asset].restakerDebtToken).balanceOf(_agent)\n            ) * assetPrice / (10 ** $.reservesData[asset].decimals);\n        }\n\n        ltv = totalDelegation == 0 ? 0 : (totalDebt * 1e27) / totalDelegation;\n        health = totalDebt == 0 ? type(uint256).max : (totalDelegation * liquidationThreshold) / totalDebt;\n    }\n\n    /// @notice Calculate the maximum amount that can be borrowed for a given asset\n    /// @param $ Lender storage\n    /// @param _agent Agent address\n    /// @param _asset Asset to borrow\n    /// @return maxBorrowableAmount Maximum amount that can be borrowed in asset decimals\n    function maxBorrowable(ILender.LenderStorage storage $, address _agent, address _asset)\n        external\n        view\n        returns (uint256 maxBorrowableAmount)\n    {\n        (uint256 totalDelegation, uint256 totalDebt,,, uint256 health) = agent($, _agent);\n\n        // health is below liquidation threshold, no borrowing allowed\n        if (health < 1e27) return 0;\n\n        uint256 ltv = IDelegation($.delegation).ltv(_agent);\n        uint256 borrowCapacity = totalDelegation * ltv / 1e27;\n\n        //  already at or above borrow capacity\n        if (totalDebt >= borrowCapacity) return 0;\n\n        // Calculate remaining borrow capacity in USD (8 decimals)\n        uint256 remainingCapacity = borrowCapacity - totalDebt;\n\n        // Convert to asset amount using price and decimals\n        (uint256 assetPrice,) = IOracle($.oracle).getPrice(_asset);\n        if (assetPrice == 0) return 0;\n\n        uint256 assetDecimals = $.reservesData[_asset].decimals;\n        maxBorrowableAmount = remainingCapacity * (10 ** assetDecimals) / assetPrice;\n\n        // Get total available assets using the vault's availableBalance function\n        uint256 totalAvailable = IVault($.reservesData[_asset].vault).availableBalance(_asset);\n\n        // Limit maxBorrowableAmount by total available assets\n        if (totalAvailable < maxBorrowableAmount) {\n            maxBorrowableAmount = totalAvailable;\n        }\n    }\n\n    /// @notice Calculate the maximum amount that can be liquidated for a given asset\n    /// @param $ Lender storage\n    /// @param _agent Agent address\n    /// @param _asset Asset to liquidate\n    /// @return maxLiquidatableAmount Maximum amount that can be liquidated in asset decimals\n    function maxLiquidatable(ILender.LenderStorage storage $, address _agent, address _asset)\n        external\n        view\n        returns (uint256 maxLiquidatableAmount)\n    {\n        (uint256 totalDelegation, uint256 totalDebt,, uint256 liquidationThreshold, uint256 health) = agent($, _agent);\n        if (health >= 1e27) return 0;\n\n        (uint256 assetPrice,) = IOracle($.oracle).getPrice(_asset);\n        if (assetPrice == 0) return 0;\n\n        uint256 decPow = 10 ** $.reservesData[_asset].decimals;\n        uint256 a = ($.targetHealth * totalDebt);\n        uint256 b = (totalDelegation * liquidationThreshold);\n        uint256 c = ($.targetHealth - liquidationThreshold);\n        uint256 d = assetPrice;\n        uint256 e = b > a ? 0 : (a - b);\n        uint256 f = (c * d);\n        uint256 g = e * decPow;\n\n        maxLiquidatableAmount = g / f;\n    }\n\n    /// @notice Get the current debt balances for an agent for a specific asset\n    /// @param $ Lender storage\n    /// @param _agent Agent address to check debt for\n    /// @param _asset Asset to check debt for\n    /// @return principalDebt Principal debt amount in asset decimals\n    /// @return interestDebt Interest debt amount in asset decimals\n    /// @return restakerDebt Restaker debt amount in asset decimals\n    function debt(ILender.LenderStorage storage $, address _agent, address _asset)\n        external\n        view\n        returns (uint256 principalDebt, uint256 interestDebt, uint256 restakerDebt)\n    {\n        ILender.ReserveData memory reserve = $.reservesData[_asset];\n        principalDebt = IERC20(reserve.principalDebtToken).balanceOf(_agent);\n        restakerDebt = IERC20(reserve.restakerDebtToken).balanceOf(_agent);\n        interestDebt = IERC20(reserve.interestDebtToken).balanceOf(_agent);\n    }\n}\n",
        "VaultLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Vault for storing the backing for cTokens\n/// @author kexley, @capLabs\n/// @notice Tokens are supplied by cToken minters and borrowed by covered agents\n/// @dev Supplies, borrows and utilization rates are tracked. Interest rates should be computed and\n/// charged on the external contracts, only the principle amount is counted on this contract.\nlibrary VaultLogic {\n    using SafeERC20 for IERC20;\n\n    /// @dev Timestamp is past the deadline\n    error PastDeadline();\n\n    /// @dev Amount out is less than required\n    error Slippage(address asset, uint256 amountOut, uint256 minAmountOut);\n\n    /// @dev Paused assets cannot be supplied or borrowed\n    error AssetPaused(address asset);\n\n    /// @dev Only whitelisted assets can be supplied or borrowed\n    error AssetNotSupported(address asset);\n\n    /// @dev Asset is already listed\n    error AssetAlreadySupported(address asset);\n\n    /// @dev Only non-supported assets can be rescued\n    error AssetNotRescuable(address asset);\n\n    /// @dev Invalid min amounts out as they dont match the number of assets\n    error InvalidMinAmountsOut();\n\n    /// @dev Insufficient reserves\n    error InsufficientReserves(address asset, uint256 balanceBefore, uint256 amount);\n\n    /// @dev Cap token minted\n    event Mint(address indexed minter, address receiver, address indexed asset, uint256 amountIn, uint256 amountOut);\n\n    /// @dev Cap token burned\n    event Burn(address indexed burner, address receiver, address indexed asset, uint256 amountIn, uint256 amountOut);\n\n    /// @dev Cap token redeemed\n    event Redeem(address indexed redeemer, address receiver, uint256 amountIn, uint256[] amountsOut);\n\n    /// @dev Borrow made\n    event Borrow(address indexed borrower, address indexed asset, uint256 amount);\n\n    /// @dev Repayment made\n    event Repay(address indexed repayer, address indexed asset, uint256 amount);\n\n    /// @dev Add asset\n    event AddAsset(address asset);\n\n    /// @dev Remove asset\n    event RemoveAsset(address asset);\n\n    /// @dev Asset paused\n    event PauseAsset(address asset);\n\n    /// @dev Asset unpaused\n    event UnpauseAsset(address asset);\n\n    /// @dev Rescue unsupported ERC20 tokens\n    event RescueERC20(address asset, address receiver);\n\n    /// @dev Modifier to only allow supplies and borrows when not paused\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    modifier whenNotPaused(IVault.VaultStorage storage $, address _asset) {\n        _whenNotPaused($, _asset);\n        _;\n    }\n\n    /// @dev Modifier to update the utilization index\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    modifier updateIndex(IVault.VaultStorage storage $, address _asset) {\n        _updateIndex($, _asset);\n        _;\n    }\n\n    /// @notice Mint the cap token using an asset\n    /// @dev This contract must have approval to move asset from msg.sender\n    /// @param $ Vault storage pointer\n    /// @param params Mint parameters\n    function mint(IVault.VaultStorage storage $, IVault.MintBurnParams memory params)\n        external\n        whenNotPaused($, params.asset)\n        updateIndex($, params.asset)\n    {\n        if (params.deadline < block.timestamp) revert PastDeadline();\n        if (params.amountOut < params.minAmountOut) {\n            revert Slippage(address(this), params.amountOut, params.minAmountOut);\n        }\n\n        $.totalSupplies[params.asset] += params.amountIn;\n\n        IERC20(params.asset).safeTransferFrom(msg.sender, address(this), params.amountIn);\n\n        emit Mint(msg.sender, params.receiver, params.asset, params.amountIn, params.amountOut);\n    }\n\n    /// @notice Burn the cap token for an asset\n    /// @dev Can only withdraw up to the amount remaining on this contract\n    /// @param $ Vault storage pointer\n    /// @param params Burn parameters\n    function burn(IVault.VaultStorage storage $, IVault.MintBurnParams memory params)\n        external\n        updateIndex($, params.asset)\n    {\n        if (params.deadline < block.timestamp) revert PastDeadline();\n        if (params.amountOut < params.minAmountOut) {\n            revert Slippage(params.asset, params.amountOut, params.minAmountOut);\n        }\n\n        $.totalSupplies[params.asset] -= params.amountOut;\n\n        IERC20(params.asset).safeTransfer(params.receiver, params.amountOut);\n\n        emit Burn(msg.sender, params.receiver, params.asset, params.amountIn, params.amountOut);\n    }\n\n    /// @notice Redeem the Cap token for a bundle of assets\n    /// @dev Can only withdraw up to the amount remaining on this contract\n    /// @param $ Vault storage pointer\n    /// @param params Redeem parameters\n    function redeem(IVault.VaultStorage storage $, IVault.RedeemParams memory params) external {\n        if (params.amountsOut.length != $.assets.length) revert InvalidMinAmountsOut();\n        if (params.deadline < block.timestamp) revert PastDeadline();\n\n        address[] memory cachedAssets = $.assets;\n        for (uint256 i; i < cachedAssets.length; ++i) {\n            if (params.amountsOut[i] < params.minAmountsOut[i]) {\n                revert Slippage(cachedAssets[i], params.amountsOut[i], params.minAmountsOut[i]);\n            }\n            _updateIndex($, cachedAssets[i]);\n            $.totalSupplies[cachedAssets[i]] -= params.amountsOut[i];\n            IERC20(cachedAssets[i]).safeTransfer(params.receiver, params.amountsOut[i]);\n        }\n\n        emit Redeem(msg.sender, params.receiver, params.amountIn, params.amountsOut);\n    }\n\n    /// @notice Borrow an asset\n    /// @dev Whitelisted agents can borrow any amount, LTV is handled by Agent contracts\n    /// @param $ Vault storage pointer\n    /// @param params Borrow parameters\n    function borrow(IVault.VaultStorage storage $, IVault.BorrowParams memory params)\n        external\n        whenNotPaused($, params.asset)\n        updateIndex($, params.asset)\n    {\n        uint256 balanceBefore = IERC20(params.asset).balanceOf(address(this));\n        if (balanceBefore < params.amount) revert InsufficientReserves(params.asset, balanceBefore, params.amount);\n\n        $.totalBorrows[params.asset] += params.amount;\n        IERC20(params.asset).safeTransfer(params.receiver, params.amount);\n\n        emit Borrow(msg.sender, params.asset, params.amount);\n    }\n\n    /// @notice Repay an asset\n    /// @param $ Vault storage pointer\n    /// @param params Repay parameters\n    function repay(IVault.VaultStorage storage $, IVault.RepayParams memory params)\n        external\n        updateIndex($, params.asset)\n    {\n        $.totalBorrows[params.asset] -= params.amount;\n        IERC20(params.asset).safeTransferFrom(msg.sender, address(this), params.amount);\n\n        emit Repay(msg.sender, params.asset, params.amount);\n    }\n\n    /// @notice Add an asset to the vault list\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function addAsset(IVault.VaultStorage storage $, address _asset) external {\n        if (_listed($, _asset)) revert AssetAlreadySupported(_asset);\n\n        $.assets.push(_asset);\n        emit AddAsset(_asset);\n    }\n\n    /// @notice Remove an asset from the vault list\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function removeAsset(IVault.VaultStorage storage $, address _asset) external {\n        address[] memory cachedAssets = $.assets;\n        uint256 length = cachedAssets.length;\n        bool removed;\n        for (uint256 i; i < length; ++i) {\n            if (_asset == cachedAssets[i]) {\n                $.assets[i] = cachedAssets[length - 1];\n                $.assets.pop();\n                removed = true;\n                break;\n            }\n        }\n\n        if (!removed) revert AssetNotSupported(_asset);\n\n        emit RemoveAsset(_asset);\n    }\n\n    /// @notice Pause an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function pause(IVault.VaultStorage storage $, address _asset) external {\n        $.paused[_asset] = true;\n        emit PauseAsset(_asset);\n    }\n\n    /// @notice Unpause an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function unpause(IVault.VaultStorage storage $, address _asset) external {\n        $.paused[_asset] = false;\n        emit UnpauseAsset(_asset);\n    }\n\n    /// @notice Rescue an unsupported asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset to rescue\n    /// @param _receiver Receiver of the rescue\n    function rescueERC20(IVault.VaultStorage storage $, address _asset, address _receiver) external {\n        if (_listed($, _asset)) revert AssetNotRescuable(_asset);\n        IERC20(_asset).safeTransfer(_receiver, IERC20(_asset).balanceOf(address(this)));\n        emit RescueERC20(_asset, _receiver);\n    }\n\n    /// @notice Calculate the utilization ratio of an asset\n    /// @dev Returns the ratio of borrowed assets to total supply, scaled to ray (1e27)\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    /// @return ratio Utilization ratio in ray (1e27)\n    function utilization(IVault.VaultStorage storage $, address _asset) public view returns (uint256 ratio) {\n        ratio = $.totalSupplies[_asset] != 0 ? $.totalBorrows[_asset] * 1e27 / $.totalSupplies[_asset] : 0;\n    }\n\n    /// @notice Up to date cumulative utilization index of an asset\n    /// @dev Utilization and index are both scaled in ray (1e27)\n    /// @param $ Vault storage pointer\n    /// @param _asset Utilized asset\n    /// @return index Utilization ratio index in ray (1e27)\n    function currentUtilizationIndex(IVault.VaultStorage storage $, address _asset)\n        external\n        view\n        returns (uint256 index)\n    {\n        index = $.utilizationIndex[_asset] + (utilization($, _asset) * (block.timestamp - $.lastUpdate[_asset]));\n    }\n\n    /// @notice Validate that an asset is listed\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset to check\n    /// @return isListed Asset is listed or not\n    function _listed(IVault.VaultStorage storage $, address _asset) internal view returns (bool isListed) {\n        address[] memory cachedAssets = $.assets;\n        uint256 length = cachedAssets.length;\n        for (uint256 i; i < length; ++i) {\n            if (_asset == cachedAssets[i]) {\n                isListed = true;\n                break;\n            }\n        }\n    }\n\n    /// @dev Only allow supplies and borrows when not paused\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function _whenNotPaused(IVault.VaultStorage storage $, address _asset) private view {\n        if ($.paused[_asset]) revert AssetPaused(_asset);\n    }\n\n    /// @dev Update the cumulative utilization index of an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Utilized asset\n    function _updateIndex(IVault.VaultStorage storage $, address _asset) internal {\n        if (!_listed($, _asset)) revert AssetNotSupported(_asset);\n        $.utilizationIndex[_asset] += utilization($, _asset) * (block.timestamp - $.lastUpdate[_asset]);\n        $.lastUpdate[_asset] = block.timestamp;\n    }\n}\n",
        "Oracle.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { PriceOracle } from \"./PriceOracle.sol\";\nimport { RateOracle } from \"./RateOracle.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Oracle\n/// @author kexley, @capLabs\n/// @notice Price and Rate oracles are unified\ncontract Oracle is IOracle, UUPSUpgradeable, Access, PriceOracle, RateOracle {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the oracle with the access control\n    /// @param _accessControl Access control\n    /// @param _staleness Staleness period in seconds for asset prices\n    function initialize(address _accessControl, uint256 _staleness) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        __PriceOracle_init_unchained(_staleness);\n        __RateOracle_init_unchained();\n    }\n\n    /// @dev Only admin is allowed to upgrade implementation\n    function _authorizeUpgrade(address) internal view override checkAccess(bytes4(0)) { }\n}\n",
        "Vault.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { VaultStorageUtils } from \"../storage/VaultStorageUtils.sol\";\nimport { FractionalReserve } from \"./FractionalReserve.sol\";\nimport { Minter } from \"./Minter.sol\";\nimport { VaultLogic } from \"./libraries/VaultLogic.sol\";\nimport { ERC20PermitUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\n\n/// @title Vault for storing the backing for cTokens\n/// @author kexley, @capLabs\n/// @notice Tokens are supplied by cToken minters and borrowed by covered agents\n/// @dev Supplies, borrows and utilization rates are tracked. Interest rates should be computed and\n/// charged on the external contracts, only the principle amount is counted on this contract.\ncontract Vault is IVault, ERC20PermitUpgradeable, Access, Minter, FractionalReserve, VaultStorageUtils {\n    /// @dev Initialize the assets\n    /// @param _name Name of the cap token\n    /// @param _symbol Symbol of the cap token\n    /// @param _accessControl Access control address\n    /// @param _feeAuction Fee auction address\n    /// @param _oracle Oracle address\n    /// @param _assets Asset addresses\n    function __Vault_init(\n        string memory _name,\n        string memory _symbol,\n        address _accessControl,\n        address _feeAuction,\n        address _oracle,\n        address[] calldata _assets\n    ) internal onlyInitializing {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        __Access_init(_accessControl);\n        __FractionalReserve_init_unchained(_feeAuction);\n        __Minter_init_unchained(_oracle);\n        __Vault_init_unchained(_assets);\n    }\n\n    /// @dev Initialize unchained\n    /// @param _assets Asset addresses\n    function __Vault_init_unchained(address[] calldata _assets) internal onlyInitializing {\n        getVaultStorage().assets = _assets;\n    }\n\n    /// @notice Mint the cap token using an asset\n    /// @dev This contract must have approval to move asset from msg.sender\n    /// @param _asset Whitelisted asset to deposit\n    /// @param _amountIn Amount of asset to use in the minting\n    /// @param _minAmountOut Minimum amount to mint\n    /// @param _receiver Receiver of the minting\n    /// @param _deadline Deadline of the tx\n    function mint(address _asset, uint256 _amountIn, uint256 _minAmountOut, address _receiver, uint256 _deadline)\n        external\n        returns (uint256 amountOut)\n    {\n        amountOut = getMintAmount(_asset, _amountIn);\n        VaultLogic.mint(\n            getVaultStorage(),\n            MintBurnParams({\n                asset: _asset,\n                amountIn: _amountIn,\n                amountOut: amountOut,\n                minAmountOut: _minAmountOut,\n                receiver: _receiver,\n                deadline: _deadline\n            })\n        );\n        _mint(_receiver, amountOut);\n    }\n\n    /// @notice Burn the cap token for an asset\n    /// @dev Asset is withdrawn from the reserve or divested from the underlying vault\n    /// @param _asset Asset to withdraw\n    /// @param _amountIn Amount of cap token to burn\n    /// @param _minAmountOut Minimum amount out to receive\n    /// @param _receiver Receiver of the withdrawal\n    /// @param _deadline Deadline of the tx\n    function burn(address _asset, uint256 _amountIn, uint256 _minAmountOut, address _receiver, uint256 _deadline)\n        external\n        returns (uint256 amountOut)\n    {\n        amountOut = getBurnAmount(_asset, _amountIn);\n        divest(_asset, amountOut);\n        VaultLogic.burn(\n            getVaultStorage(),\n            MintBurnParams({\n                asset: _asset,\n                amountIn: _amountIn,\n                amountOut: amountOut,\n                minAmountOut: _minAmountOut,\n                receiver: _receiver,\n                deadline: _deadline\n            })\n        );\n        _burn(msg.sender, _amountIn);\n    }\n\n    /// @notice Redeem the Cap token for a bundle of assets\n    /// @dev Assets are withdrawn from the reserve or divested from the underlying vault\n    /// @param _amountIn Amount of Cap token to burn\n    /// @param _minAmountsOut Minimum amounts of assets to withdraw\n    /// @param _receiver Receiver of the withdrawal\n    /// @param _deadline Deadline of the tx\n    /// @return amountsOut Amount of assets withdrawn\n    function redeem(uint256 _amountIn, uint256[] calldata _minAmountsOut, address _receiver, uint256 _deadline)\n        external\n        returns (uint256[] memory amountsOut)\n    {\n        amountsOut = getRedeemAmount(_amountIn);\n        divestMany(assets(), amountsOut);\n        VaultLogic.redeem(\n            getVaultStorage(),\n            RedeemParams({\n                amountIn: _amountIn,\n                amountsOut: amountsOut,\n                minAmountsOut: _minAmountsOut,\n                receiver: _receiver,\n                deadline: _deadline\n            })\n        );\n        _burn(msg.sender, _amountIn);\n    }\n\n    /// @notice Borrow an asset\n    /// @dev Whitelisted agents can borrow any amount, LTV is handled by Agent contracts\n    /// @param _asset Asset to borrow\n    /// @param _amount Amount of asset to borrow\n    /// @param _receiver Receiver of the borrow\n    function borrow(address _asset, uint256 _amount, address _receiver) external checkAccess(this.borrow.selector) {\n        divest(_asset, _amount);\n        VaultLogic.borrow(getVaultStorage(), BorrowParams({ asset: _asset, amount: _amount, receiver: _receiver }));\n    }\n\n    /// @notice Repay an asset\n    /// @param _asset Asset to repay\n    /// @param _amount Amount of asset to repay\n    function repay(address _asset, uint256 _amount) external checkAccess(this.repay.selector) {\n        VaultLogic.repay(getVaultStorage(), RepayParams({ asset: _asset, amount: _amount }));\n    }\n\n    /// @notice Add an asset to the vault list\n    /// @param _asset Asset address\n    function addAsset(address _asset) external checkAccess(this.addAsset.selector) {\n        VaultLogic.addAsset(getVaultStorage(), _asset);\n    }\n\n    /// @notice Remove an asset from the vault list\n    /// @param _asset Asset address\n    function removeAsset(address _asset) external checkAccess(this.removeAsset.selector) {\n        VaultLogic.removeAsset(getVaultStorage(), _asset);\n    }\n\n    /// @notice Pause an asset\n    /// @param _asset Asset address\n    function pause(address _asset) external checkAccess(this.pause.selector) {\n        VaultLogic.pause(getVaultStorage(), _asset);\n    }\n\n    /// @notice Unpause an asset\n    /// @param _asset Asset address\n    function unpause(address _asset) external checkAccess(this.unpause.selector) {\n        VaultLogic.unpause(getVaultStorage(), _asset);\n    }\n\n    /// @notice Rescue an unsupported asset\n    /// @param _asset Asset to rescue\n    /// @param _receiver Receiver of the rescue\n    function rescueERC20(address _asset, address _receiver) external checkAccess(this.rescueERC20.selector) {\n        VaultLogic.rescueERC20(getVaultStorage(), _asset, _receiver);\n    }\n\n    /// @notice Get the list of assets supported by the vault\n    /// @return assetList List of assets\n    function assets() public view returns (address[] memory assetList) {\n        assetList = getVaultStorage().assets;\n    }\n\n    /// @notice Get the total supplies of an asset\n    /// @param _asset Asset address\n    /// @return totalSupply Total supply\n    function totalSupplies(address _asset) external view returns (uint256 totalSupply) {\n        totalSupply = getVaultStorage().totalSupplies[_asset];\n    }\n\n    /// @notice Get the total borrows of an asset\n    /// @param _asset Asset address\n    /// @return totalBorrow Total borrow\n    function totalBorrows(address _asset) external view returns (uint256 totalBorrow) {\n        totalBorrow = getVaultStorage().totalBorrows[_asset];\n    }\n\n    /// @notice Get the pause state of an asset\n    /// @param _asset Asset address\n    /// @return isPaused Pause state\n    function paused(address _asset) external view returns (bool isPaused) {\n        isPaused = getVaultStorage().paused[_asset];\n    }\n\n    /// @notice Available balance to borrow\n    /// @param _asset Asset to borrow\n    /// @return amount Amount available\n    function availableBalance(address _asset) external view returns (uint256 amount) {\n        VaultStorage storage $ = getVaultStorage();\n        amount = $.totalSupplies[_asset] - $.totalBorrows[_asset];\n    }\n\n    /// @notice Utilization rate of an asset\n    /// @dev Utilization scaled by 1e27\n    /// @param _asset Utilized asset\n    /// @return ratio Utilization ratio\n    function utilization(address _asset) external view returns (uint256 ratio) {\n        ratio = VaultLogic.utilization(getVaultStorage(), _asset);\n    }\n\n    /// @notice Up to date cumulative utilization index of an asset\n    /// @dev Utilization scaled by 1e27\n    /// @param _asset Utilized asset\n    /// @return index Utilization ratio index\n    function currentUtilizationIndex(address _asset) external view returns (uint256 index) {\n        index = VaultLogic.currentUtilizationIndex(getVaultStorage(), _asset);\n    }\n}\n"
    }
}