{
    "vfp_id": "vfp_00077",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of approval reset on buffer allows anyone to drain the Vault",
            "description": "The lack of approval reset after the call to deposit allows a malicious wrapper contract to steal the Vault’s funds. When wrapping tokens, the _wrapWithBuffer function allows the wrapped token contract to transfer the underlying tokens via ERC20 approval. However, since the approval is not reset to zero after the deposit call, a malicious wrapper contract can retain the approval and later withdraw the Vault's funds after it has been locked. This vulnerability arises from improper handling of ERC20 approvals and trust in external contracts without proper safeguards. An attacker can exploit this by creating a malicious wrapper that does nothing during deposit, thereby preserving the approval, and later directly transferring the tokens out. The impact is critical as it allows an attacker to drain all of the Vault’s tokens for any underlying asset.\n",
            "severity": "High",
            "location": [
                "Vault.sol::deposit#1169-1172",
                "Vault.sol::erc4626BufferWrapOrUnwrap",
                "https://github.com/balancer/balancer-v3-monorepo/pull/855"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-454"
                ]
            },
            "title": "Vault can be drained by updating the buffer underlying token",
            "description": "A malicious user can drain the Vault by manipulating the underlying token of a buffer. The erc4626BufferWrapOrUnwrap function allows wrapping via uninitialized buffers, and the addLiquidityToBuffer function does not prevent changes to the underlying token. An attacker can first wrap a worthless token into a buffer, then change the underlying token to a valuable one (e.g., DAI), and withdraw the full balance of that token. The root cause is the lack of a check ensuring that a buffer must be explicitly initialized before interaction and that the underlying token cannot be changed after initialization. Exploitation involves creating a malicious wrapper token, inflating buffer balances with a worthless token, switching the underlying token, and withdrawing the real assets. The impact is high, as it allows complete draining of any token in the Vault.\n",
            "severity": "High",
            "location": [
                "Vault.sol::erc4626BufferWrapOrUnwrap#1054-1108",
                "Vault.sol::_wrapWithBuffer#1117-1238",
                "VaultAdmin.sol::addLiquidityToBuffer#415-465",
                "https://github.com/balancer/balancer-v3-monorepo/pull/881"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        }
    ],
    "affected_files": {
        "Vault.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IVaultExtension } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultExtension.sol\";\nimport { IVaultMain } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultMain.sol\";\nimport { IBasePool } from \"@balancer-labs/v3-interfaces/contracts/vault/IBasePool.sol\";\nimport { IHooks } from \"@balancer-labs/v3-interfaces/contracts/vault/IHooks.sol\";\nimport { IPoolLiquidity } from \"@balancer-labs/v3-interfaces/contracts/vault/IPoolLiquidity.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { EVMCallModeHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/EVMCallModeHelpers.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { CastingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/CastingHelpers.sol\";\nimport { InputHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/InputHelpers.sol\";\nimport {\n    TransientStorageHelpers\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/TransientStorageHelpers.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { BasePoolMath } from \"@balancer-labs/v3-solidity-utils/contracts/math/BasePoolMath.sol\";\nimport { StorageSlotExtension } from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/StorageSlotExtension.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\nimport { BufferHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/BufferHelpers.sol\";\n\nimport { VaultStateLib, VaultStateBits } from \"./lib/VaultStateLib.sol\";\nimport { PoolConfigLib } from \"./lib/PoolConfigLib.sol\";\nimport { HooksConfigLib } from \"./lib/HooksConfigLib.sol\";\nimport { PoolDataLib } from \"./lib/PoolDataLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\ncontract Vault is IVaultMain, VaultCommon, Proxy {\n    using PackedTokenBalance for bytes32;\n    using BufferHelpers for bytes32;\n    using InputHelpers for uint256;\n    using FixedPoint for *;\n    using Address for *;\n    using CastingHelpers for uint256[];\n    using SafeERC20 for IERC20;\n    using PoolConfigLib for PoolConfigBits;\n    using HooksConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using ScalingHelpers for *;\n    using TransientStorageHelpers for *;\n    using StorageSlotExtension for *;\n    using PoolDataLib for PoolData;\n\n    IVaultExtension private immutable _vaultExtension;\n\n    constructor(IVaultExtension vaultExtension, IAuthorizer authorizer, IProtocolFeeController protocolFeeController) {\n        if (address(vaultExtension.vault()) != address(this)) {\n            revert WrongVaultExtensionDeployment();\n        }\n\n        if (address(protocolFeeController.vault()) != address(this)) {\n            revert WrongProtocolFeeControllerDeployment();\n        }\n\n        _vaultExtension = vaultExtension;\n        _protocolFeeController = protocolFeeController;\n\n        _vaultPauseWindowEndTime = IVaultAdmin(address(vaultExtension)).getPauseWindowEndTime();\n        _vaultBufferPeriodDuration = IVaultAdmin(address(vaultExtension)).getBufferPeriodDuration();\n        _vaultBufferPeriodEndTime = IVaultAdmin(address(vaultExtension)).getBufferPeriodEndTime();\n\n        _authorizer = authorizer;\n    }\n\n    /*******************************************************************************\n                              Transient Accounting\n    *******************************************************************************/\n\n    /**\n     * @dev This modifier is used for functions that temporarily modify the token deltas\n     * of the Vault, but expect to revert or settle balances by the end of their execution.\n     * It works by ensuring that the balances are properly settled by the time the last\n     * operation is executed.\n     *\n     * This is useful for functions like `unlock`, which perform arbitrary external calls:\n     * we can keep track of temporary deltas changes, and make sure they are settled by the\n     * time the external call is complete.\n     */\n    modifier transient() {\n        bool isUnlockedBefore = _isUnlocked().tload();\n\n        if (isUnlockedBefore == false) {\n            _isUnlocked().tstore(true);\n        }\n\n        // The caller does everything here and has to settle all outstanding balances\n        _;\n\n        if (isUnlockedBefore == false) {\n            if (_nonZeroDeltaCount().tload() != 0) {\n                revert BalanceNotSettled();\n            }\n\n            _isUnlocked().tstore(false);\n        }\n    }\n\n    /// @inheritdoc IVaultMain\n    function unlock(bytes calldata data) external transient returns (bytes memory result) {\n        return (msg.sender).functionCall(data);\n    }\n\n    /// @inheritdoc IVaultMain\n    function settle(IERC20 token, uint256 amountHint) external nonReentrant onlyWhenUnlocked returns (uint256 credit) {\n        uint256 reservesBefore = _reservesOf[token];\n        uint256 currentReserves = token.balanceOf(address(this));\n        _reservesOf[token] = currentReserves;\n        credit = currentReserves - reservesBefore;\n\n        // If the given hint is equal or greater to the reserve difference, we just take the actual reserve difference\n        // as the paid amount; the actual balance of the tokens in the vault is what matters here.\n        if (credit > amountHint) {\n            // If the difference in reserves is higher than the amount claimed to be paid by the caller, there was some\n            // leftover that had been sent to the vault beforehand, which was not incorporated into the reserves.\n            // In that case, we simply discard the leftover by considering the given hint as the amount paid.\n            // In turn, this gives the caller credit for the given amount hint, which is what the caller is expecting.\n            credit = amountHint;\n        }\n\n        _supplyCredit(token, credit);\n    }\n\n    /// @inheritdoc IVaultMain\n    function sendTo(IERC20 token, address to, uint256 amount) external nonReentrant onlyWhenUnlocked {\n        _takeDebt(token, amount);\n        _reservesOf[token] -= amount;\n\n        token.safeTransfer(to, amount);\n    }\n\n    /*******************************************************************************\n                                    Pool Operations\n    *******************************************************************************/\n\n    // The Vault performs all upscaling and downscaling (due to token decimals, rates, etc.), so that the pools\n    // don't have to. However, scaling inevitably leads to rounding errors, so we take great care to ensure that\n    // any rounding errors favor the Vault. An important invariant of the system is that there is no repeatable\n    // path where tokensOut > tokensIn.\n    //\n    // In general, this means rounding up any values entering the Vault, and rounding down any values leaving\n    // the Vault, so that external users either pay a little extra or receive a little less in the case of a\n    // rounding error.\n    //\n    // However, it's not always straightforward to determine the correct rounding direction, given the presence\n    // and complexity of intermediate steps. An \"amountIn\" sounds like it should be rounded up: but only if that\n    // is the amount actually being transferred. If instead it is an amount sent to the pool math, where rounding\n    // up would result in a *higher* calculated amount out, that would favor the user instead of the Vault. So in\n    // that case, amountIn should be rounded down.\n    //\n    // See comments justifying the rounding direction in each case.\n    //\n    // This reasoning applies to Weighted Pool math, and is likely to apply to others as well, but of course\n    // it's possible a new pool type might not conform. Duplicate the tests for new pool types (e.g., Stable Math).\n    // Also, the final code should ensure that we are not relying entirely on the rounding directions here,\n    // but have enough additional layers (e.g., minimum amounts, buffer wei on all transfers) to guarantee safety,\n    // even if it turns out these directions are incorrect for a new pool type.\n\n    /*******************************************************************************\n                                          Swaps\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function swap(\n        SwapParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256 amountCalculated, uint256 amountIn, uint256 amountOut)\n    {\n        _ensureUnpaused(params.pool);\n\n        if (params.amountGivenRaw == 0) {\n            revert AmountGivenZero();\n        }\n\n        if (params.tokenIn == params.tokenOut) {\n            revert CannotSwapSameToken();\n        }\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the swap hooks are reentrant and could do anything, including\n        // change these balances, we cannot defer settlement until `_swap`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances`, `_aggregateFeeAmounts`\n        // in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_DOWN);\n\n        // State is fully populated here, and shall not be modified at a lower level.\n        SwapState memory state = _loadSwapState(params, poolData);\n\n        PoolSwapParams memory swapParams = _buildPoolSwapParams(params, state, poolData);\n\n        if (poolData.poolConfigBits.shouldCallBeforeSwap()) {\n            HooksConfigLib.callBeforeSwapHook(swapParams, params.pool, _hooksContracts[params.pool]);\n\n            // The call to `onBeforeSwap` could potentially update token rates and balances.\n            // We update `poolData.tokenRates`, `poolData.rawBalances` and `poolData.balancesLiveScaled18`\n            // to ensure the `onSwap` and `onComputeDynamicSwapFeePercentage` are called with the current values.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_DOWN);\n\n            // Also update amountGivenScaled18, as it will now be used in the swap, and the rates might have changed.\n            state.amountGivenScaled18 = _computeAmountGivenScaled18(params, poolData, state);\n\n            swapParams = _buildPoolSwapParams(params, state, poolData);\n        }\n\n        _ensureValidTradeAmount(state.amountGivenScaled18);\n\n        // Note that this must be called *after* the before hook, to guarantee that the swap params are the same\n        // as those passed to the main operation.\n        //\n        // At this point, the static swap fee percentage is loaded in the swap state as the default, to be used\n        // unless the pool has a dynamic swap fee. It is also passed into the hook, to support common cases\n        // where the dynamic fee computation logic uses it.\n        if (poolData.poolConfigBits.shouldCallComputeDynamicSwapFee()) {\n            (bool dynamicSwapFeeCalculated, uint256 dynamicSwapFee) = HooksConfigLib.callComputeDynamicSwapFeeHook(\n                swapParams,\n                params.pool,\n                state.swapFeePercentage,\n                _hooksContracts[params.pool]\n            );\n\n            if (dynamicSwapFeeCalculated) {\n                state.swapFeePercentage = dynamicSwapFee;\n            }\n        }\n\n        // Non-reentrant call that updates accounting.\n        // The following side-effects are important to note:\n        // PoolData balancesRaw and balancesLiveScaled18 are adjusted for swap amounts and fees inside of _swap.\n        uint256 amountCalculatedScaled18;\n        (amountCalculated, amountCalculatedScaled18, amountIn, amountOut) = _swap(params, state, poolData, swapParams);\n\n        _ensureValidTradeAmount(amountCalculatedScaled18);\n\n        // The new amount calculated is 'amountCalculated + delta'. If the underlying hook fails, or limits are\n        // violated, `onAfterSwap` will revert. Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterSwap()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountCalculated = poolData.poolConfigBits.callAfterSwapHook(\n                amountCalculatedScaled18,\n                amountCalculated,\n                msg.sender,\n                params,\n                state,\n                poolData,\n                hooksContract\n            );\n        }\n\n        if (params.kind == SwapKind.EXACT_IN) {\n            amountOut = amountCalculated;\n        } else {\n            amountIn = amountCalculated;\n        }\n    }\n\n    function _loadSwapState(\n        SwapParams memory params,\n        PoolData memory poolData\n    ) private pure returns (SwapState memory state) {\n        state.indexIn = _findTokenIndex(poolData.tokens, params.tokenIn);\n        state.indexOut = _findTokenIndex(poolData.tokens, params.tokenOut);\n\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        state.amountGivenScaled18 = _computeAmountGivenScaled18(params, poolData, state);\n        state.swapFeePercentage = poolData.poolConfigBits.getStaticSwapFeePercentage();\n    }\n\n    function _buildPoolSwapParams(\n        SwapParams memory params,\n        SwapState memory state,\n        PoolData memory poolData\n    ) internal view returns (PoolSwapParams memory) {\n        // Uses msg.sender as the router (the contract that called the vault)\n        return\n            PoolSwapParams({\n                kind: params.kind,\n                amountGivenScaled18: state.amountGivenScaled18,\n                balancesScaled18: poolData.balancesLiveScaled18,\n                indexIn: state.indexIn,\n                indexOut: state.indexOut,\n                router: msg.sender,\n                userData: params.userData\n            });\n    }\n\n    /**\n     * @dev Preconditions: decimalScalingFactors and tokenRates in `poolData` must be current.\n     * Uses amountGivenRaw and kind from `params`.\n     */\n    function _computeAmountGivenScaled18(\n        SwapParams memory params,\n        PoolData memory poolData,\n        SwapState memory state\n    ) private pure returns (uint256) {\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        return\n            params.kind == SwapKind.EXACT_IN\n                ? params.amountGivenRaw.toScaled18ApplyRateRoundDown(\n                    poolData.decimalScalingFactors[state.indexIn],\n                    poolData.tokenRates[state.indexIn]\n                )\n                : params.amountGivenRaw.toScaled18ApplyRateRoundUp(\n                    poolData.decimalScalingFactors[state.indexOut],\n                    poolData.tokenRates[state.indexOut]\n                );\n    }\n\n    struct SwapInternalLocals {\n        uint256 swapFeeAmountScaled18;\n        uint256 swapFeeIndex;\n        IERC20 swapFeeToken;\n        uint256 balanceInIncrement;\n        uint256 balanceOutDecrement;\n        uint256 swapFeeAmountRaw;\n    }\n\n    /**\n     * @dev Main non-reentrant portion of the swap, which calls the pool hook and updates accounting. `vaultSwapParams`\n     * are passed to the pool's `onSwap` hook.\n     *\n     * Preconditions: complete `SwapParams`, `SwapState`, and `PoolData`.\n     * Side effects: mutates balancesRaw and balancesLiveScaled18 in `poolData`.\n     * Updates `_aggregateFeeAmounts`, and `_poolTokenBalances` in storage.\n     * Emits Swap event.\n     */\n    function _swap(\n        SwapParams memory params,\n        SwapState memory state,\n        PoolData memory poolData,\n        PoolSwapParams memory swapParams\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256 amountCalculatedRaw,\n            uint256 amountCalculatedScaled18,\n            uint256 amountInRaw,\n            uint256 amountOutRaw\n        )\n    {\n        SwapInternalLocals memory locals;\n\n        // Perform the swap request hook and compute the new balances for 'token in' and 'token out' after the swap.\n        amountCalculatedScaled18 = IBasePool(params.pool).onSwap(swapParams);\n\n        // Note that balances are kept in memory, and are not fully computed until the `setPoolBalances` below.\n        // Intervening code cannot read balances from storage, as they are temporarily out-of-sync here. This function\n        // is nonReentrant, to guard against read-only reentrancy issues.\n\n        // (1) and (2): get raw amounts and check limits.\n        if (params.kind == SwapKind.EXACT_IN) {\n            // Swap fee is always a percentage of the amountCalculated. On ExactIn, subtract it from the calculated\n            // amountOut. Round up to avoid losses during precision loss.\n            locals.swapFeeAmountScaled18 = amountCalculatedScaled18.mulUp(state.swapFeePercentage);\n\n            // Need to update `amountCalculatedScaled18` for the onAfterSwap hook.\n            amountCalculatedScaled18 -= locals.swapFeeAmountScaled18;\n\n            // For `ExactIn` the amount calculated is leaving the Vault, so we round down.\n            amountCalculatedRaw = amountCalculatedScaled18.toRawUndoRateRoundDown(\n                poolData.decimalScalingFactors[state.indexOut],\n                poolData.tokenRates[state.indexOut]\n            );\n\n            (amountInRaw, amountOutRaw) = (params.amountGivenRaw, amountCalculatedRaw);\n\n            if (amountOutRaw < params.limitRaw) {\n                revert SwapLimit(amountOutRaw, params.limitRaw);\n            }\n        } else {\n            // To ensure symmetry with EXACT_IN, the swap fee used by ExactOut is\n            // `amountCalculated * fee% / (100% - fee%)`. Add it to the calculated amountIn. Round up to avoid losses\n            // during precision loss.\n            locals.swapFeeAmountScaled18 = amountCalculatedScaled18.mulDivUp(\n                state.swapFeePercentage,\n                state.swapFeePercentage.complement()\n            );\n\n            amountCalculatedScaled18 += locals.swapFeeAmountScaled18;\n\n            // For `ExactOut` the amount calculated is entering the Vault, so we round up.\n            amountCalculatedRaw = amountCalculatedScaled18.toRawUndoRateRoundUp(\n                poolData.decimalScalingFactors[state.indexIn],\n                poolData.tokenRates[state.indexIn]\n            );\n\n            (amountInRaw, amountOutRaw) = (amountCalculatedRaw, params.amountGivenRaw);\n\n            if (amountInRaw > params.limitRaw) {\n                revert SwapLimit(amountInRaw, params.limitRaw);\n            }\n        }\n\n        // 3) Deltas: debit for token in, credit for token out.\n        _takeDebt(params.tokenIn, amountInRaw);\n        _supplyCredit(params.tokenOut, amountOutRaw);\n\n        // 4) Compute and charge protocol and creator fees.\n        (locals.swapFeeIndex, locals.swapFeeToken) = params.kind == SwapKind.EXACT_IN\n            ? (state.indexOut, params.tokenOut)\n            : (state.indexIn, params.tokenIn);\n\n        // Note that protocol fee storage is updated before balance storage, as the final raw balances need to take\n        // the fees into account.\n        uint256 totalFeesRaw = _computeAndChargeAggregateSwapFees(\n            poolData,\n            locals.swapFeeAmountScaled18,\n            params.pool,\n            locals.swapFeeToken,\n            locals.swapFeeIndex\n        );\n\n        // 5) Pool balances: raw and live.\n        //\n        // Adjust for raw swap amounts and total fees on the calculated end.\n        // So that fees are always subtracted from pool balances:\n        // For ExactIn, we increase the tokenIn balance by `amountIn`, and decrease the tokenOut balance by the\n        // (`amountOut` + fees).\n        // For ExactOut, we increase the tokenInBalance by (`amountIn` - fees), and decrease the tokenOut balance by\n        // `amountOut`.\n        (locals.balanceInIncrement, locals.balanceOutDecrement) = params.kind == SwapKind.EXACT_IN\n            ? (amountInRaw, amountOutRaw + totalFeesRaw)\n            : (amountInRaw - totalFeesRaw, amountOutRaw);\n\n        poolData.updateRawAndLiveBalance(\n            state.indexIn,\n            poolData.balancesRaw[state.indexIn] + locals.balanceInIncrement,\n            Rounding.ROUND_UP\n        );\n        poolData.updateRawAndLiveBalance(\n            state.indexOut,\n            poolData.balancesRaw[state.indexOut] - locals.balanceOutDecrement,\n            Rounding.ROUND_DOWN\n        );\n\n        // 6) Store pool balances, raw and live (only index in and out).\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[params.pool];\n        poolBalances[state.indexIn] = PackedTokenBalance.toPackedBalance(\n            poolData.balancesRaw[state.indexIn],\n            poolData.balancesLiveScaled18[state.indexIn]\n        );\n        poolBalances[state.indexOut] = PackedTokenBalance.toPackedBalance(\n            poolData.balancesRaw[state.indexOut],\n            poolData.balancesLiveScaled18[state.indexOut]\n        );\n\n        // 7) Off-chain events.\n        // Since the swapFeeAmountScaled18 (derived from scaling up either the amountGiven or amountCalculated)\n        // also contains the rate, undo it when converting to raw.\n        locals.swapFeeAmountRaw = locals.swapFeeAmountScaled18.toRawUndoRateRoundDown(\n            poolData.decimalScalingFactors[locals.swapFeeIndex],\n            poolData.tokenRates[locals.swapFeeIndex]\n        );\n\n        emit Swap(\n            params.pool,\n            params.tokenIn,\n            params.tokenOut,\n            amountInRaw,\n            amountOutRaw,\n            state.swapFeePercentage,\n            locals.swapFeeAmountRaw,\n            locals.swapFeeToken\n        );\n    }\n\n    /***************************************************************************\n                                   Add Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function addLiquidity(\n        AddLiquidityParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData)\n    {\n        // Round balances up when adding liquidity:\n        // If proportional, higher balances = higher proportional amountsIn, favoring the pool.\n        // If unbalanced, higher balances = lower invariant ratio with fees.\n        // bptOut = supply * (ratio - 1), so lower ratio = less bptOut, favoring the pool.\n\n        _ensureUnpaused(params.pool);\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the add liquidity hooks are reentrant and could do anything,\n        // including change these balances, we cannot defer settlement until `_addLiquidity`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances`, and\n        // `_aggregateFeeAmounts` in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_UP);\n        InputHelpers.ensureInputLengthMatch(poolData.tokens.length, params.maxAmountsIn.length);\n\n        // Amounts are entering pool math, so round down.\n        // Introducing `maxAmountsInScaled18` here and passing it through to _addLiquidity is not ideal,\n        // but it avoids the even worse options of mutating amountsIn inside AddLiquidityParams,\n        // or cluttering the AddLiquidityParams interface by adding amountsInScaled18.\n        uint256[] memory maxAmountsInScaled18 = params.maxAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        if (poolData.poolConfigBits.shouldCallBeforeAddLiquidity()) {\n            HooksConfigLib.callBeforeAddLiquidityHook(\n                msg.sender,\n                maxAmountsInScaled18,\n                params,\n                poolData,\n                _hooksContracts[params.pool]\n            );\n            // The hook might have altered the balances, so we need to read them again to ensure that the data\n            // are fresh moving forward. We also need to upscale (adding liquidity, so round up) again.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_UP);\n\n            // Also update maxAmountsInScaled18, as the rates might have changed.\n            maxAmountsInScaled18 = params.maxAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, and the final balances\n        // are computed. This function is non-reentrant, as it performs the accounting updates.\n        //\n        // Note that poolData is mutated to update the Raw and Live balances, so they are accurate when passed\n        // into the AfterAddLiquidity hook.\n        //\n        // `amountsInScaled18` will be overwritten in the custom case, so we need to pass it back and forth to\n        // encapsulate that logic in `_addLiquidity`.\n        uint256[] memory amountsInScaled18;\n        (amountsIn, amountsInScaled18, bptAmountOut, returnData) = _addLiquidity(\n            poolData,\n            params,\n            maxAmountsInScaled18\n        );\n\n        // AmountsIn can be changed by onAfterAddLiquidity if the hook charges fees or gives discounts.\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterAddLiquidity()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountsIn = poolData.poolConfigBits.callAfterAddLiquidityHook(\n                msg.sender,\n                amountsInScaled18,\n                amountsIn,\n                bptAmountOut,\n                params,\n                poolData,\n                hooksContract\n            );\n        }\n    }\n\n    // Avoid \"stack too deep\" - without polluting the Add/RemoveLiquidity params interface.\n    struct LiquidityLocals {\n        uint256 numTokens;\n        uint256 totalFeesRaw;\n        uint256 tokenIndex;\n    }\n\n    /**\n     * @dev Calls the appropriate pool hook and calculates the required inputs and outputs for the operation\n     * considering the given kind, and updates the vault's internal accounting. This includes:\n     * - Setting pool balances\n     * - Taking debt from the liquidity provider\n     * - Minting pool tokens\n     * - Emitting events\n     *\n     * It is non-reentrant, as it performs external calls and updates the vault's state accordingly.\n     */\n    function _addLiquidity(\n        PoolData memory poolData,\n        AddLiquidityParams memory params,\n        uint256[] memory maxAmountsInScaled18\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256[] memory amountsInRaw,\n            uint256[] memory amountsInScaled18,\n            uint256 bptAmountOut,\n            bytes memory returnData\n        )\n    {\n        LiquidityLocals memory locals;\n        locals.numTokens = poolData.tokens.length;\n        uint256[] memory swapFeeAmountsScaled18;\n\n        if (params.kind == AddLiquidityKind.PROPORTIONAL) {\n            bptAmountOut = params.minBptAmountOut;\n            // Initializes the swapFeeAmountsScaled18 empty array (no swap fees on proportional add liquidity).\n            swapFeeAmountsScaled18 = new uint256[](locals.numTokens);\n\n            amountsInScaled18 = BasePoolMath.computeProportionalAmountsIn(\n                poolData.balancesLiveScaled18,\n                _totalSupply(params.pool),\n                bptAmountOut\n            );\n        } else if (params.kind == AddLiquidityKind.DONATION) {\n            poolData.poolConfigBits.requireDonationEnabled();\n\n            swapFeeAmountsScaled18 = new uint256[](maxAmountsInScaled18.length);\n            bptAmountOut = 0;\n            amountsInScaled18 = maxAmountsInScaled18;\n        } else if (params.kind == AddLiquidityKind.UNBALANCED) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n\n            amountsInScaled18 = maxAmountsInScaled18;\n            (bptAmountOut, swapFeeAmountsScaled18) = BasePoolMath.computeAddLiquidityUnbalanced(\n                poolData.balancesLiveScaled18,\n                maxAmountsInScaled18,\n                _totalSupply(params.pool),\n                poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                IBasePool(params.pool)\n            );\n        } else if (params.kind == AddLiquidityKind.SINGLE_TOKEN_EXACT_OUT) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n\n            bptAmountOut = params.minBptAmountOut;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(maxAmountsInScaled18);\n\n            amountsInScaled18 = maxAmountsInScaled18;\n            (amountsInScaled18[locals.tokenIndex], swapFeeAmountsScaled18) = BasePoolMath\n                .computeAddLiquiditySingleTokenExactOut(\n                    poolData.balancesLiveScaled18,\n                    locals.tokenIndex,\n                    bptAmountOut,\n                    _totalSupply(params.pool),\n                    poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                    IBasePool(params.pool)\n                );\n        } else if (params.kind == AddLiquidityKind.CUSTOM) {\n            poolData.poolConfigBits.requireAddCustomLiquidityEnabled();\n\n            // Uses msg.sender as the router (the contract that called the vault).\n            (amountsInScaled18, bptAmountOut, swapFeeAmountsScaled18, returnData) = IPoolLiquidity(params.pool)\n                .onAddLiquidityCustom(\n                    msg.sender,\n                    maxAmountsInScaled18,\n                    params.minBptAmountOut,\n                    poolData.balancesLiveScaled18,\n                    params.userData\n                );\n        } else {\n            revert InvalidAddLiquidityKind();\n        }\n\n        // At this point we have the calculated BPT amount.\n        if (bptAmountOut < params.minBptAmountOut) {\n            revert BptAmountOutBelowMin(bptAmountOut, params.minBptAmountOut);\n        }\n\n        _ensureValidTradeAmount(bptAmountOut);\n\n        amountsInRaw = new uint256[](locals.numTokens);\n\n        for (uint256 i = 0; i < locals.numTokens; ++i) {\n            uint256 amountInRaw;\n\n            // 1) Calculate raw amount in.\n            {\n                uint256 amountInScaled18 = amountsInScaled18[i];\n                _ensureValidTradeAmount(amountInScaled18);\n\n                // amountsInRaw are amounts actually entering the Pool, so we round up.\n                // Do not mutate in place yet, as we need them scaled for the `onAfterAddLiquidity` hook.\n                amountInRaw = amountInScaled18.toRawUndoRateRoundUp(\n                    poolData.decimalScalingFactors[i],\n                    poolData.tokenRates[i]\n                );\n\n                amountsInRaw[i] = amountInRaw;\n            }\n\n            IERC20 token = poolData.tokens[i];\n\n            // 2) Check limits for raw amounts.\n            if (amountInRaw > params.maxAmountsIn[i]) {\n                revert AmountInAboveMax(token, amountInRaw, params.maxAmountsIn[i]);\n            }\n\n            // 3) Deltas: Debit of token[i] for amountInRaw.\n            _takeDebt(token, amountInRaw);\n\n            // 4) Compute and charge protocol and creator fees.\n            locals.totalFeesRaw = _computeAndChargeAggregateSwapFees(\n                poolData,\n                swapFeeAmountsScaled18[i],\n                params.pool,\n                token,\n                i\n            );\n\n            // 5) Pool balances: raw and live.\n            // We need regular balances to complete the accounting, and the upscaled balances\n            // to use in the `after` hook later on.\n\n            // A pool's token balance increases by amounts in after adding liquidity, minus fees.\n            poolData.updateRawAndLiveBalance(\n                i,\n                poolData.balancesRaw[i] + amountInRaw - locals.totalFeesRaw,\n                Rounding.ROUND_UP\n            );\n        }\n\n        // 6) Store pool balances, raw and live.\n        _writePoolBalancesToStorage(params.pool, poolData);\n\n        // 7) BPT supply adjustment.\n        // When adding liquidity, we must mint tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        _mint(address(params.pool), params.to, bptAmountOut);\n\n        // 8) Off-chain events.\n        emit PoolBalanceChanged(params.pool, params.to, amountsInRaw.unsafeCastToInt256(true));\n    }\n\n    /***************************************************************************\n                                 Remove Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function removeLiquidity(\n        RemoveLiquidityParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData)\n    {\n        // Round down when removing liquidity:\n        // If proportional, lower balances = lower proportional amountsOut, favoring the pool.\n        // If unbalanced, lower balances = lower invariant ratio without fees.\n        // bptIn = supply * (1 - ratio), so lower ratio = more bptIn, favoring the pool.\n        _ensureUnpaused(params.pool);\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the swap hooks are reentrant and could do anything, including\n        // change these balances, we cannot defer settlement until `_removeLiquidity`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances` and\n        // `_aggregateFeeAmounts in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_DOWN);\n        InputHelpers.ensureInputLengthMatch(poolData.tokens.length, params.minAmountsOut.length);\n\n        // Amounts are entering pool math; higher amounts would burn more BPT, so round up to favor the pool.\n        // Do not mutate minAmountsOut, so that we can directly compare the raw limits later, without potentially\n        // losing precision by scaling up and then down.\n        uint256[] memory minAmountsOutScaled18 = params.minAmountsOut.copyToScaled18ApplyRateRoundUpArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallBeforeRemoveLiquidity()) {\n            HooksConfigLib.callBeforeRemoveLiquidityHook(\n                minAmountsOutScaled18,\n                msg.sender,\n                params,\n                poolData,\n                _hooksContracts[params.pool]\n            );\n\n            // The hook might alter the balances, so we need to read them again to ensure that the data is\n            // fresh moving forward.\n            // We also need to upscale (removing liquidity, so round down) again.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_DOWN);\n\n            // Also update minAmountsOutScaled18, as the rates might have changed.\n            minAmountsOutScaled18 = params.minAmountsOut.copyToScaled18ApplyRateRoundUpArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, and the final balances\n        // are computed. This function is non-reentrant, as it performs the accounting updates.\n        //\n        // Note that poolData is mutated to update the Raw and Live balances, so they are accurate when passed\n        // into the AfterRemoveLiquidity hook.\n        uint256[] memory amountsOutScaled18;\n        (bptAmountIn, amountsOut, amountsOutScaled18, returnData) = _removeLiquidity(\n            poolData,\n            params,\n            minAmountsOutScaled18\n        );\n\n        // AmountsOut can be changed by onAfterRemoveLiquidity if the hook charges fees or gives discounts.\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterRemoveLiquidity()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountsOut = poolData.poolConfigBits.callAfterRemoveLiquidityHook(\n                msg.sender,\n                amountsOutScaled18,\n                amountsOut,\n                bptAmountIn,\n                params,\n                poolData,\n                hooksContract\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the appropriate pool hook and calculates the required inputs and outputs for the operation\n     * considering the given kind, and updates the vault's internal accounting. This includes:\n     * - Setting pool balances\n     * - Supplying credit to the liquidity provider\n     * - Burning pool tokens\n     * - Emitting events\n     *\n     * It is non-reentrant, as it performs external calls and updates the vault's state accordingly.\n     */\n    function _removeLiquidity(\n        PoolData memory poolData,\n        RemoveLiquidityParams memory params,\n        uint256[] memory minAmountsOutScaled18\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOutRaw,\n            uint256[] memory amountsOutScaled18,\n            bytes memory returnData\n        )\n    {\n        LiquidityLocals memory locals;\n        locals.numTokens = poolData.tokens.length;\n        uint256[] memory swapFeeAmountsScaled18;\n\n        if (params.kind == RemoveLiquidityKind.PROPORTIONAL) {\n            bptAmountIn = params.maxBptAmountIn;\n            swapFeeAmountsScaled18 = new uint256[](locals.numTokens);\n            amountsOutScaled18 = BasePoolMath.computeProportionalAmountsOut(\n                poolData.balancesLiveScaled18,\n                _totalSupply(params.pool),\n                bptAmountIn\n            );\n        } else if (params.kind == RemoveLiquidityKind.SINGLE_TOKEN_EXACT_IN) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n            bptAmountIn = params.maxBptAmountIn;\n            amountsOutScaled18 = minAmountsOutScaled18;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(params.minAmountsOut);\n\n            (amountsOutScaled18[locals.tokenIndex], swapFeeAmountsScaled18) = BasePoolMath\n                .computeRemoveLiquiditySingleTokenExactIn(\n                    poolData.balancesLiveScaled18,\n                    locals.tokenIndex,\n                    bptAmountIn,\n                    _totalSupply(params.pool),\n                    poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                    IBasePool(params.pool)\n                );\n        } else if (params.kind == RemoveLiquidityKind.SINGLE_TOKEN_EXACT_OUT) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n            amountsOutScaled18 = minAmountsOutScaled18;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(params.minAmountsOut);\n\n            (bptAmountIn, swapFeeAmountsScaled18) = BasePoolMath.computeRemoveLiquiditySingleTokenExactOut(\n                poolData.balancesLiveScaled18,\n                locals.tokenIndex,\n                amountsOutScaled18[locals.tokenIndex],\n                _totalSupply(params.pool),\n                poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                IBasePool(params.pool)\n            );\n        } else if (params.kind == RemoveLiquidityKind.CUSTOM) {\n            poolData.poolConfigBits.requireRemoveCustomLiquidityEnabled();\n            // Uses msg.sender as the router (the contract that called the vault)\n            (bptAmountIn, amountsOutScaled18, swapFeeAmountsScaled18, returnData) = IPoolLiquidity(params.pool)\n                .onRemoveLiquidityCustom(\n                    msg.sender,\n                    params.maxBptAmountIn,\n                    minAmountsOutScaled18,\n                    poolData.balancesLiveScaled18,\n                    params.userData\n                );\n        } else {\n            revert InvalidRemoveLiquidityKind();\n        }\n\n        if (bptAmountIn > params.maxBptAmountIn) {\n            revert BptAmountInAboveMax(bptAmountIn, params.maxBptAmountIn);\n        }\n\n        _ensureValidTradeAmount(bptAmountIn);\n\n        amountsOutRaw = new uint256[](locals.numTokens);\n\n        for (uint256 i = 0; i < locals.numTokens; ++i) {\n            uint256 amountOutRaw;\n\n            // 1) Calculate raw amount out.\n            {\n                uint256 amountOutScaled18 = amountsOutScaled18[i];\n                _ensureValidTradeAmount(amountOutScaled18);\n\n                // amountsOut are amounts exiting the Pool, so we round down.\n                // Do not mutate in place yet, as we need them scaled for the `onAfterRemoveLiquidity` hook.\n                amountOutRaw = amountOutScaled18.toRawUndoRateRoundDown(\n                    poolData.decimalScalingFactors[i],\n                    poolData.tokenRates[i]\n                );\n            }\n\n            amountsOutRaw[i] = amountOutRaw;\n\n            IERC20 token = poolData.tokens[i];\n            // 2) Check limits for raw amounts.\n            if (amountOutRaw < params.minAmountsOut[i]) {\n                revert AmountOutBelowMin(token, amountOutRaw, params.minAmountsOut[i]);\n            }\n\n            // 3) Deltas: Credit token[i] for amountOutRaw.\n            _supplyCredit(token, amountOutRaw);\n\n            // 4) Compute and charge protocol and creator fees.\n            locals.totalFeesRaw = _computeAndChargeAggregateSwapFees(\n                poolData,\n                swapFeeAmountsScaled18[i],\n                params.pool,\n                token,\n                i\n            );\n\n            // 5) Pool balances: raw and live.\n            // We need regular balances to complete the accounting, and the upscaled balances\n            // to use in the `after` hook later on.\n\n            // A Pool's token balance always decreases after an exit\n            // (potentially by 0). Also adjust by protocol and pool creator fees.\n            poolData.updateRawAndLiveBalance(\n                i,\n                poolData.balancesRaw[i] - (amountOutRaw + locals.totalFeesRaw),\n                Rounding.ROUND_DOWN\n            );\n        }\n\n        // 6) Store pool balances, raw and live.\n        _writePoolBalancesToStorage(params.pool, poolData);\n\n        // 7) BPT supply adjustment.\n        // Uses msg.sender as the router (the contract that called the vault).\n        _spendAllowance(address(params.pool), params.from, msg.sender, bptAmountIn);\n\n        if (_isQueryContext()) {\n            // Increase `from` balance to ensure the burn function succeeds.\n            _queryModeBalanceIncrease(params.pool, params.from, bptAmountIn);\n        }\n        // When removing liquidity, we must burn tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Burning will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _burn(address(params.pool), params.from, bptAmountIn);\n\n        // 8) Off-chain events\n        emit PoolBalanceChanged(\n            params.pool,\n            params.from,\n            // We can unsafely cast to int256 because balances are stored as uint128 (see PackedTokenBalance).\n            amountsOutRaw.unsafeCastToInt256(false)\n        );\n    }\n\n    /**\n     * @dev Preconditions: poolConfigBits, decimalScalingFactors, tokenRates in `poolData`.\n     * Side effects: updates `_aggregateFeeAmounts` storage.\n     * Note that this computes the aggregate total of the protocol fees and stores it, without emitting any events.\n     * Splitting the fees and event emission occur during fee collection.\n     * Should only be called in a non-reentrant context.\n     *\n     * @return totalFeesRaw Sum of protocol and pool creator fees raw\n     */\n    function _computeAndChargeAggregateSwapFees(\n        PoolData memory poolData,\n        uint256 swapFeeAmountScaled18,\n        address pool,\n        IERC20 token,\n        uint256 index\n    ) internal returns (uint256 totalFeesRaw) {\n        uint256 aggregateSwapFeePercentage = poolData.poolConfigBits.getAggregateSwapFeePercentage();\n        // If swapFeeAmount equals zero, no need to charge anything.\n        if (\n            swapFeeAmountScaled18 > 0 &&\n            aggregateSwapFeePercentage > 0 &&\n            poolData.poolConfigBits.isPoolInRecoveryMode() == false\n        ) {\n            uint256 aggregateSwapFeeAmountScaled18 = swapFeeAmountScaled18.mulUp(aggregateSwapFeePercentage);\n\n            // Ensure we can never charge more than the total swap fee.\n            if (aggregateSwapFeeAmountScaled18 > swapFeeAmountScaled18) {\n                revert ProtocolFeesExceedTotalCollected();\n            }\n\n            totalFeesRaw = aggregateSwapFeeAmountScaled18.toRawUndoRateRoundDown(\n                poolData.decimalScalingFactors[index],\n                poolData.tokenRates[index]\n            );\n\n            // Both Swap and Yield fees are stored together in a PackedTokenBalance.\n            // We have designated \"Raw\" the derived half for Swap fee storage.\n            bytes32 currentPackedBalance = _aggregateFeeAmounts[pool][token];\n            _aggregateFeeAmounts[pool][token] = currentPackedBalance.setBalanceRaw(\n                currentPackedBalance.getBalanceRaw() + totalFeesRaw\n            );\n        }\n    }\n\n    /*******************************************************************************\n                                    Pool Information\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getPoolTokenCountAndIndexOfToken(\n        address pool,\n        IERC20 token\n    ) external view withRegisteredPool(pool) returns (uint256, uint256) {\n        IERC20[] memory poolTokens = _poolTokens[pool];\n\n        uint256 index = _findTokenIndex(poolTokens, token);\n\n        return (poolTokens.length, index);\n    }\n\n    /*******************************************************************************\n                             Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function erc4626BufferWrapOrUnwrap(\n        BufferWrapOrUnwrapParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 amountCalculatedRaw, uint256 amountInRaw, uint256 amountOutRaw)\n    {\n        IERC20 underlyingToken = IERC20(params.wrappedToken.asset());\n\n        address bufferAsset = _bufferAssets[params.wrappedToken];\n\n        if (bufferAsset != address(0) && bufferAsset != address(underlyingToken)) {\n            // Asset was changed since the first addLiquidityToBuffer call.\n            revert WrongWrappedTokenAsset(address(params.wrappedToken));\n        }\n\n        if (params.amountGivenRaw < _MINIMUM_WRAP_AMOUNT) {\n            // If amount given is too small, rounding issues can be introduced that favors the user and can drain\n            // the buffer. _MINIMUM_WRAP_AMOUNT prevents it. Most tokens have protections against it already, this\n            // is just an extra layer of security.\n            revert WrapAmountTooSmall(address(params.wrappedToken));\n        }\n\n        if (params.direction == WrappingDirection.UNWRAP) {\n            (amountInRaw, amountOutRaw) = _unwrapWithBuffer(\n                params.kind,\n                underlyingToken,\n                params.wrappedToken,\n                params.amountGivenRaw\n            );\n            emit Unwrap(params.wrappedToken, underlyingToken, amountInRaw, amountOutRaw);\n        } else {\n            (amountInRaw, amountOutRaw) = _wrapWithBuffer(\n                params.kind,\n                underlyingToken,\n                params.wrappedToken,\n                params.amountGivenRaw\n            );\n            emit Wrap(underlyingToken, params.wrappedToken, amountInRaw, amountOutRaw);\n        }\n\n        if (params.kind == SwapKind.EXACT_IN) {\n            if (amountOutRaw < params.limitRaw) {\n                revert SwapLimit(amountOutRaw, params.limitRaw);\n            }\n            amountCalculatedRaw = amountOutRaw;\n        } else {\n            if (amountInRaw > params.limitRaw) {\n                revert SwapLimit(amountInRaw, params.limitRaw);\n            }\n            amountCalculatedRaw = amountInRaw;\n        }\n    }\n\n    /**\n     * @dev If the buffer has enough liquidity, it uses the internal ERC4626 buffer to perform the wrap\n     * operation without any external calls. If not, it wraps the assets needed to fulfill the trade + the surplus\n     * of assets in the buffer, so that the buffer is rebalanced at the end of the operation.\n     *\n     * Updates `_reservesOf` and token deltas in storage.\n     */\n    function _wrapWithBuffer(\n        SwapKind kind,\n        IERC20 underlyingToken,\n        IERC4626 wrappedToken,\n        uint256 amountGiven\n    ) private returns (uint256 amountInUnderlying, uint256 amountOutWrapped) {\n        // When wrapping and in query mode, the vault needs to have enough reserves of underlying token to do the\n        // wrap operation. If the vault does not have enough tokens to do the actual wrap, use ERC4626 preview.\n        bool isQueryContext = _isQueryContext();\n\n        if (kind == SwapKind.EXACT_IN) {\n            if (isQueryContext) {\n                return (amountGiven, wrappedToken.previewDeposit(amountGiven));\n            }\n            // EXACT_IN wrap, so AmountGiven is underlying amount.\n            (amountInUnderlying, amountOutWrapped) = (amountGiven, wrappedToken.convertToShares(amountGiven));\n        } else {\n            if (isQueryContext) {\n                return (wrappedToken.previewMint(amountGiven), amountGiven);\n            }\n            // EXACT_OUT wrap, so AmountGiven is wrapped amount.\n            (amountInUnderlying, amountOutWrapped) = (wrappedToken.convertToAssets(amountGiven), amountGiven);\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (bufferBalances.getBalanceDerived() >= amountOutWrapped) {\n            // The buffer has enough liquidity to facilitate the wrap without making an external call.\n            uint256 newDerivedBalance;\n            unchecked {\n                // We have verified above that this is safe to do unchecked.\n                newDerivedBalance = bufferBalances.getBalanceDerived() - amountOutWrapped;\n            }\n\n            bufferBalances = PackedTokenBalance.toPackedBalance(\n                bufferBalances.getBalanceRaw() + amountInUnderlying,\n                newDerivedBalance\n            );\n            _bufferTokenBalances[wrappedToken] = bufferBalances;\n        } else {\n            // The buffer does not have enough liquidity to facilitate the wrap without making an external call.\n            // We wrap the user's tokens via an external call and additionally rebalance the buffer if it has a\n            // surplus of underlying tokens.\n\n            // Gets the amount of underlying to wrap in order to rebalance the buffer.\n            uint256 bufferUnderlyingSurplus = bufferBalances.getBufferUnderlyingSurplus(wrappedToken);\n            uint256 bufferWrappedSurplus;\n\n            if (kind == SwapKind.EXACT_IN) {\n                // The amount of underlying tokens to deposit is the necessary amount to fulfill the trade\n                // (amountInUnderlying), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferUnderlyingSurplus).\n                uint256 amountToDeposit = amountInUnderlying + bufferUnderlyingSurplus;\n                underlyingToken.forceApprove(address(wrappedToken), amountToDeposit);\n                // EXACT_IN requires the exact amount of underlying tokens to be deposited, so deposit is called.\n                wrappedToken.deposit(amountToDeposit, address(this));\n            } else {\n                if (bufferUnderlyingSurplus > 0) {\n                    bufferWrappedSurplus = wrappedToken.convertToShares(bufferUnderlyingSurplus);\n                }\n\n                // The mint operation returns exactly `vaultWrappedDelta` shares. To do so, it withdraws underlying\n                // from the vault and returns the shares. So, the vault needs to approve the transfer of underlying\n                // tokens to the wrapper.\n                // Add 2 because mint can consume up to 2 wei more tokens than we anticipated.\n                underlyingToken.forceApprove(address(wrappedToken), amountInUnderlying + bufferUnderlyingSurplus + 2);\n\n                // EXACT_OUT requires the exact amount of wrapped tokens to be returned, so mint is called.\n                wrappedToken.mint(amountOutWrapped + bufferWrappedSurplus, address(this));\n\n                // Remove approval, in case mint consumed less tokens than we approved, due to convert error.\n                underlyingToken.forceApprove(address(wrappedToken), 0);\n            }\n\n            // ERC4626 output should not be trusted, so it's a good practice to measure the amount of\n            // deposited and returned tokens.\n            (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) = _updateReservesAfterWrapping(\n                underlyingToken,\n                IERC20(wrappedToken)\n            );\n\n            // Only updates buffer balances if buffer has a surplus of underlying tokens.\n            if (bufferUnderlyingSurplus > 0) {\n                if (kind == SwapKind.EXACT_IN) {\n                    // amountInUnderlying is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultUnderlyingDelta should be absorbed by the buffer.\n                    bufferUnderlyingSurplus = vaultUnderlyingDelta - amountInUnderlying;\n                    // Since bufferUnderlyingSurplus was wrapped, the final amountOut needs to discount the wrapped\n                    // amount that will stay in the buffer. Refresh `bufferWrappedSurplus` after external calls on the\n                    // wrapped token.\n                    bufferWrappedSurplus = wrappedToken.convertToShares(bufferUnderlyingSurplus);\n                    amountOutWrapped = vaultWrappedDelta - bufferWrappedSurplus;\n                } else {\n                    // If buffer has an underlying surplus, it wraps the surplus + amountIn, so the final amountIn needs\n                    // to be discounted for that.\n                    amountInUnderlying = vaultUnderlyingDelta - bufferUnderlyingSurplus;\n                    // amountOutWrapped is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultWrappedDelta should be absorbed by the buffer.\n                    bufferWrappedSurplus = vaultWrappedDelta - amountOutWrapped;\n                }\n\n                // In a wrap operation, the underlying balance of the buffer will decrease and the wrapped balance will\n                // increase. To decrease underlying balance, we get the delta amount that was deposited\n                // (vaultUnderlyingDelta) and discounts the amount needed in the wrapping operation\n                // (amountInUnderlying). Same logic applies to wrapped balances.\n                //\n                // Note: bufferUnderlyingSurplus = vaultUnderlyingDelta - amountInUnderlying\n                //       bufferWrappedSurplus = vaultWrappedDelta - amountOutWrapped\n                bufferBalances = PackedTokenBalance.toPackedBalance(\n                    bufferBalances.getBalanceRaw() - bufferUnderlyingSurplus,\n                    bufferBalances.getBalanceDerived() + bufferWrappedSurplus\n                );\n                _bufferTokenBalances[wrappedToken] = bufferBalances;\n            } else {\n                amountInUnderlying = vaultUnderlyingDelta;\n                amountOutWrapped = vaultWrappedDelta;\n            }\n        }\n\n        _takeDebt(underlyingToken, amountInUnderlying);\n        _supplyCredit(wrappedToken, amountOutWrapped);\n    }\n\n    /**\n     * @dev If the buffer has enough liquidity, it uses the internal ERC4626 buffer to perform the unwrap\n     * operation without any external calls. If not, it unwraps the assets needed to fulfill the trade + the surplus\n     * of assets in the buffer, so that the buffer is rebalanced at the end of the operation.\n     *\n     * Updates `_reservesOf` and token deltas in storage.\n     */\n    function _unwrapWithBuffer(\n        SwapKind kind,\n        IERC20 underlyingToken,\n        IERC4626 wrappedToken,\n        uint256 amountGiven\n    ) private returns (uint256 amountInWrapped, uint256 amountOutUnderlying) {\n        bool isQueryContext = _isQueryContext();\n\n        if (kind == SwapKind.EXACT_IN) {\n            if (isQueryContext) {\n                return (amountGiven, wrappedToken.previewRedeem(amountGiven));\n            }\n            // EXACT_IN unwrap, so AmountGiven is wrapped amount.\n            (amountOutUnderlying, amountInWrapped) = (wrappedToken.convertToAssets(amountGiven), amountGiven);\n        } else {\n            if (isQueryContext) {\n                return (wrappedToken.previewWithdraw(amountGiven), amountGiven);\n            }\n            // EXACT_OUT unwrap, so AmountGiven is underlying amount.\n            (amountOutUnderlying, amountInWrapped) = (amountGiven, wrappedToken.convertToShares(amountGiven));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (bufferBalances.getBalanceRaw() >= amountOutUnderlying) {\n            // The buffer has enough liquidity to facilitate the wrap without making an external call.\n            uint256 newRawBalance;\n            unchecked {\n                // We have verified above that this is safe to do unchecked.\n                newRawBalance = bufferBalances.getBalanceRaw() - amountOutUnderlying;\n            }\n            bufferBalances = PackedTokenBalance.toPackedBalance(\n                newRawBalance,\n                bufferBalances.getBalanceDerived() + amountInWrapped\n            );\n            _bufferTokenBalances[wrappedToken] = bufferBalances;\n        } else {\n            // The buffer does not have enough liquidity to facilitate the unwrap without making an external call.\n            // We unwrap the user's tokens via an external call and additionally rebalance the buffer if it has a\n            // surplus of underlying tokens.\n\n            // Gets the amount of wrapped tokens to unwrap in order to rebalance the buffer.\n            uint256 bufferWrappedSurplus = bufferBalances.getBufferWrappedSurplus(wrappedToken);\n            uint256 bufferUnderlyingSurplus;\n\n            if (kind == SwapKind.EXACT_IN) {\n                // EXACT_IN requires the exact amount of wrapped tokens to be unwrapped, so redeem is called\n                // The amount of wrapped tokens to redeem is the necessary amount to fulfill the trade\n                // (amountInWrapped), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferWrappedSurplus).\n                wrappedToken.redeem(amountInWrapped + bufferWrappedSurplus, address(this), address(this));\n            } else {\n                // EXACT_OUT requires the exact amount of underlying tokens to be returned, so withdraw is called.\n                // The amount of underlying tokens to withdraw is the necessary amount to fulfill the trade\n                // (amountOutUnderlying), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferUnderlyingSurplus).\n                if (bufferWrappedSurplus > 0) {\n                    bufferUnderlyingSurplus = wrappedToken.convertToAssets(bufferWrappedSurplus);\n                }\n                wrappedToken.withdraw(amountOutUnderlying + bufferUnderlyingSurplus, address(this), address(this));\n            }\n\n            // ERC4626 output should not be trusted, so it's a good practice to measure the amount of\n            // deposited and returned tokens.\n            (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) = _updateReservesAfterWrapping(\n                underlyingToken,\n                IERC20(wrappedToken)\n            );\n\n            // Only updates buffer balances if buffer has a surplus of wrapped tokens.\n            if (bufferWrappedSurplus > 0) {\n                if (kind == SwapKind.EXACT_IN) {\n                    // amountInWrapped is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultWrappedDelta should be absorbed by the buffer.\n                    bufferWrappedSurplus = vaultWrappedDelta - amountInWrapped;\n                    // Since bufferWrappedSurplus was unwrapped, the final amountOut needs to discount the underlying\n                    // amount that will stay in the buffer. Refresh `bufferUnderlyingSurplus` after external calls\n                    // on the wrapped token.\n                    bufferUnderlyingSurplus = wrappedToken.convertToAssets(bufferWrappedSurplus);\n                    amountOutUnderlying = vaultUnderlyingDelta - bufferUnderlyingSurplus;\n                } else {\n                    // If buffer has a wrapped surplus, it unwraps surplus + amountIn, so the final amountIn needs to\n                    // be discounted for that.\n                    amountInWrapped = vaultWrappedDelta - bufferWrappedSurplus;\n                    // amountOutUnderlying is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultUnderlyingDelta should be absorbed by the buffer.\n                    bufferUnderlyingSurplus = vaultUnderlyingDelta - amountOutUnderlying;\n                }\n\n                // In an unwrap operation, the underlying balance of the buffer will increase and the wrapped balance\n                // will decrease. To increase the underlying balance, we get the delta amount that was withdrawn\n                // (vaultUnderlyingDelta) and discount the amount expected in the unwrapping operation\n                // (amountOutUnderlying). The same logic applies to wrapped balances.\n                //\n                // Note: bufferUnderlyingSurplus = vaultUnderlyingDelta - amountOutUnderlying\n                //       bufferWrappedSurplus = vaultWrappedDelta - amountInWrapped\n                bufferBalances = PackedTokenBalance.toPackedBalance(\n                    bufferBalances.getBalanceRaw() + bufferUnderlyingSurplus,\n                    bufferBalances.getBalanceDerived() - bufferWrappedSurplus\n                );\n                _bufferTokenBalances[wrappedToken] = bufferBalances;\n            } else {\n                amountOutUnderlying = vaultUnderlyingDelta;\n                amountInWrapped = vaultWrappedDelta;\n            }\n        }\n\n        _takeDebt(wrappedToken, amountInWrapped);\n        _supplyCredit(underlyingToken, amountOutUnderlying);\n    }\n\n    function _isQueryContext() internal view returns (bool) {\n        return EVMCallModeHelpers.isStaticCall() && _vaultStateBits.isQueryDisabled() == false;\n    }\n\n    /**\n     * @dev Updates reserves for underlying and wrapped tokens after wrap/unwrap operation:\n     * - updates `_reservesOf`\n     * - returns the delta underlying and wrapped tokens that were deposited/withdrawn from vault reserves\n     */\n    function _updateReservesAfterWrapping(\n        IERC20 underlyingToken,\n        IERC20 wrappedToken\n    ) internal returns (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) {\n        uint256 vaultUnderlyingBefore = _reservesOf[underlyingToken];\n        uint256 vaultUnderlyingAfter = underlyingToken.balanceOf(address(this));\n        _reservesOf[underlyingToken] = vaultUnderlyingAfter;\n\n        uint256 vaultWrappedBefore = _reservesOf[wrappedToken];\n        uint256 vaultWrappedAfter = wrappedToken.balanceOf(address(this));\n        _reservesOf[wrappedToken] = vaultWrappedAfter;\n\n        if (vaultUnderlyingBefore > vaultUnderlyingAfter) {\n            // Wrap\n            // Since deposit takes underlying tokens from the vault, the actual underlying tokens deposited is\n            // underlyingBefore - underlyingAfter\n            // checked against underflow: vaultUnderlyingBefore > vaultUnderlyingAfter in `if` clause.\n            unchecked {\n                vaultUnderlyingDelta = vaultUnderlyingBefore - vaultUnderlyingAfter;\n            }\n            // Since deposit puts wrapped tokens into the vault, the actual wrapped minted is\n            // wrappedAfter - wrappedBefore.\n            vaultWrappedDelta = vaultWrappedAfter - vaultWrappedBefore;\n        } else {\n            // Unwrap\n            // Since withdraw puts underlying tokens into the vault, the actual underlying token amount withdrawn is\n            // assetsAfter - assetsBefore.\n            // checked against underflow: vaultUnderlyingAfter > vaultUnderlyingBefore in `else` clause.\n            unchecked {\n                vaultUnderlyingDelta = vaultUnderlyingAfter - vaultUnderlyingBefore;\n            }\n            // Since withdraw takes wrapped tokens from the vault, the actual wrapped token amount burned is\n            // wrappedBefore - wrappedAfter.\n            vaultWrappedDelta = vaultWrappedBefore - vaultWrappedAfter;\n        }\n    }\n\n    // Minimum swap amount (applied to scaled18 values), enforced as a security measure to block potential\n    // exploitation of rounding errors.\n    function _ensureValidTradeAmount(uint256 tradeAmount) private pure {\n        if (tradeAmount != 0 && tradeAmount < _MINIMUM_TRADE_AMOUNT) {\n            revert TradeAmountTooSmall();\n        }\n    }\n\n    /*******************************************************************************\n                                    Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getAuthorizer() external view returns (IAuthorizer) {\n        return _authorizer;\n    }\n\n    /*******************************************************************************\n                                     Default handlers\n    *******************************************************************************/\n\n    receive() external payable {\n        revert CannotReceiveEth();\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Override proxy implementation of `fallback` to disallow incoming ETH transfers.\n     * This function actually returns whatever the Vault Extension does when handling the request.\n     */\n    fallback() external payable override {\n        if (msg.value > 0) {\n            revert CannotReceiveEth();\n        }\n\n        _fallback();\n    }\n\n    /*******************************************************************************\n                                     Miscellaneous\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getVaultExtension() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Returns Vault Extension, where fallback requests are forwarded.\n     */\n    function _implementation() internal view override returns (address) {\n        return address(_vaultExtension);\n    }\n}\n"
    }
}