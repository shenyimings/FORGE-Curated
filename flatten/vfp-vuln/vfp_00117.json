{
    "vfp_id": "vfp_00117",
    "project_name": "Morpheus - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "withdraw functionality will not work with the Aave strategy",
            "description": "The vulnerability arises in the `DepositPool.sol` contract during the withdrawal process, where the contract checks the available `depositToken` balance in the `Distributor` before allowing a withdrawal. However, when the strategy is set to AAVE, all deposited tokens are supplied to Aave via `AaveIPool.supply`, leaving zero balance of `depositToken` in the `Distributor` contract. Since there is no mechanism in the `Distributor` to withdraw funds back from Aave before the balance check, the `depositToken` balance remains zero, causing the withdrawal amount to be capped at zero. This results in users being unable to withdraw their funds when using the Aave strategy. An attacker could exploit this by depositing into a pool using the Aave strategy and then attempting to withdraw, only to find their funds stuck indefinitely. The impact is critical as it leads to permanent loss of user funds due to inability to withdraw.\n",
            "severity": "Critical",
            "location": [
                "DepositPool.sol#L455",
                "Distributor.sol#L273-L275"
            ],
            "files": [
                "SmartContracts/contracts/capital-protocol/DepositPool.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Attackers can potentially halt staking in some deposit pools",
            "description": "The `stake` function in `DepositPool.sol` lacks a reentrancy guard, and it performs an external call to `safeTransferFrom` before updating internal accounting. If the deposited token implements a callback (e.g., via a malicious contract or reentrant-friendly token), an attacker can reenter the `stake` function during the transfer. During this reentrant call, the `_getCurrentPoolRate` function calculates rewards based on the difference between the current distributed rewards and the previously recorded value. Because the state has not yet been updated in the original call, the same reward delta is calculated again, leading to double incrementing of `distributedRewards`. This causes the internal accounting to exceed the actual distributed amount from the `Distributor`, making subsequent calls to `_getCurrentPoolRate` revert due to negative reward calculations. The cause is the absence of reentrancy protection and improper state update ordering. An attacker can exploit this by crafting a reentrant token or contract to trigger the double-counting, ultimately bricking the staking functionality for the affected pool. The impact is medium, as it results in a denial-of-service for staking, though it may affect only specific pools.\n",
            "severity": "Medium",
            "location": [
                "DepositPool.sol"
            ],
            "files": [
                "SmartContracts/contracts/capital-protocol/DepositPool.sol"
            ]
        }
    ],
    "affected_files": {
        "DepositPool.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {PRECISION} from \"@solarity/solidity-lib/utils/Globals.sol\";\n\nimport {IDepositPool, IERC165} from \"../interfaces/capital-protocol/IDepositPool.sol\";\nimport {IRewardPool} from \"../interfaces/capital-protocol/IRewardPool.sol\";\nimport {IDistributor} from \"../interfaces/capital-protocol/IDistributor.sol\";\n\nimport {LockMultiplierMath} from \"../libs/LockMultiplierMath.sol\";\nimport {ReferrerLib} from \"../libs/ReferrerLib.sol\";\n\ncontract DepositPool is IDepositPool, OwnableUpgradeable, UUPSUpgradeable {\n    using SafeERC20 for IERC20;\n    using ReferrerLib for ReferrerData;\n    using ReferrerLib for ReferrerTier[];\n\n    uint128 constant DECIMAL = 1e18;\n\n    bool public isNotUpgradeable;\n\n    /** @dev Main stake token for the contract */\n    address public depositToken;\n\n    /**\n     * @dev `L1SenderV2` contract address\n     * v7 update, moved to the `Distributor` contract.\n     */\n    address public unusedStorage0;\n\n    /**\n     * @dev Contain information about reward pools. Removed in `DepositPool`,\n     * v6 update, moved to the `RewardPool` contract.\n     */\n    Pool[] public unusedStorage1;\n\n    /** @dev Contain internal data about the reward pools, necessary for calculations */\n    mapping(uint256 => RewardPoolData) public rewardPoolsData;\n\n    /** @dev Contain internal data about the users deposits, necessary for calculations */\n    mapping(address => mapping(uint256 => UserData)) public usersData;\n\n    /** @dev Contain total real deposited amount for `depositToken` */\n    uint256 public totalDepositedInPublicPools;\n\n    /**\n     * @dev UPGRADE. `DistributionV4` storage updates, add pool limits.\n     * Removed in `DepositPool`, v6 update, moved to `rewardPoolsProtocolDetails`\n     */\n    mapping(uint256 => RewardPoolLimits) public unusedStorage2;\n\n    /** @dev UPGRADE `DistributionV5` storage updates, add referrers. */\n    mapping(uint256 => ReferrerTier[]) public referrerTiers;\n    mapping(address => mapping(uint256 => ReferrerData)) public referrersData;\n    /** @dev UPGRADE `DistributionV5` end. */\n\n    /** @dev UPGRADE `DistributionV6` storage updates, add addresses allowed to claim. Add whitelisted claim receivers. */\n    mapping(uint256 => mapping(address => mapping(address => bool))) public claimSender;\n    mapping(uint256 => mapping(address => address)) public claimReceiver;\n    /** @dev UPGRADE `DistributionV6` end. */\n\n    /** @dev UPGRADE `DepositPool`, v7. Storage updates, add few deposit pools. */\n    /** @dev This flag determines whether the migration has been completed. */\n    bool public isMigrationOver;\n\n    /** @dev `Distributor` contract address. */\n    address public distributor;\n\n    /** @dev Contain information about rewards pools needed for this contract. */\n    mapping(uint256 => RewardPoolProtocolDetails) public rewardPoolsProtocolDetails;\n    /** @dev UPGRADE `DepositPool`, v7 end. */\n\n    /**********************************************************************************************/\n    /*** Init, IERC165                                                                          ***/\n    /**********************************************************************************************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function DepositPool_init(address depositToken_, address distributor_) external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        depositToken = depositToken_;\n        setDistributor(distributor_);\n    }\n\n    function supportsInterface(bytes4 interfaceId_) external pure returns (bool) {\n        return interfaceId_ == type(IDepositPool).interfaceId || interfaceId_ == type(IERC165).interfaceId;\n    }\n\n    /**********************************************************************************************/\n    /*** Global contract management functionality for the contract `owner()`                    ***/\n    /**********************************************************************************************/\n\n    function setDistributor(address value_) public onlyOwner {\n        require(IERC165(value_).supportsInterface(type(IDistributor).interfaceId), \"DR: invalid distributor address\");\n\n        if (distributor != address(0)) {\n            IERC20(depositToken).approve(distributor, 0);\n        }\n        IERC20(depositToken).approve(value_, type(uint256).max);\n\n        distributor = value_;\n\n        emit DistributorSet(value_);\n    }\n\n    function setRewardPoolProtocolDetails(\n        uint256 rewardPoolIndex_,\n        uint128 withdrawLockPeriodAfterStake_,\n        uint128 claimLockPeriodAfterStake_,\n        uint128 claimLockPeriodAfterClaim_,\n        uint256 minimalStake_\n    ) public onlyOwner {\n        RewardPoolProtocolDetails storage rewardPoolProtocolDetails = rewardPoolsProtocolDetails[rewardPoolIndex_];\n\n        rewardPoolProtocolDetails.withdrawLockPeriodAfterStake = withdrawLockPeriodAfterStake_;\n        rewardPoolProtocolDetails.claimLockPeriodAfterStake = claimLockPeriodAfterStake_;\n        rewardPoolProtocolDetails.claimLockPeriodAfterClaim = claimLockPeriodAfterClaim_;\n        rewardPoolProtocolDetails.minimalStake = minimalStake_;\n\n        emit RewardPoolsDataSet(\n            rewardPoolIndex_,\n            withdrawLockPeriodAfterStake_,\n            claimLockPeriodAfterStake_,\n            claimLockPeriodAfterClaim_,\n            minimalStake_\n        );\n    }\n\n    function migrate(uint256 rewardPoolIndex_) external onlyOwner {\n        require(!isMigrationOver, \"DS: the migration is over\");\n        if (totalDepositedInPublicPools == 0) {\n            isMigrationOver = true;\n            emit Migrated(rewardPoolIndex_);\n\n            return;\n        }\n\n        IRewardPool rewardPool_ = IRewardPool(IDistributor(distributor).rewardPool());\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n        rewardPool_.onlyPublicRewardPool(rewardPoolIndex_);\n\n        // Transfer yield to prevent the reward loss\n        uint256 remainder_ = IERC20(depositToken).balanceOf(address(this)) - totalDepositedInPublicPools;\n        require(remainder_ > 0, \"DS: yield for token is zero\");\n        IERC20(depositToken).transfer(distributor, remainder_);\n\n        IDistributor(distributor).supply(rewardPoolIndex_, totalDepositedInPublicPools);\n\n        isMigrationOver = true;\n\n        emit Migrated(rewardPoolIndex_);\n    }\n\n    function editReferrerTiers(uint256 rewardPoolIndex_, ReferrerTier[] calldata referrerTiers_) external onlyOwner {\n        IRewardPool rewardPool_ = IRewardPool(IDistributor(distributor).rewardPool());\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n\n        delete referrerTiers[rewardPoolIndex_];\n\n        uint256 lastAmount_;\n        uint256 lastMultiplier_;\n        for (uint256 i = 0; i < referrerTiers_.length; i++) {\n            uint256 amount_ = referrerTiers_[i].amount;\n            uint256 multiplier_ = referrerTiers_[i].multiplier;\n\n            if (i != 0) {\n                require(amount_ > lastAmount_, \"DS: invalid referrer tiers (1)\");\n                require(multiplier_ > lastMultiplier_, \"DS: invalid referrer tiers (2)\");\n            }\n\n            referrerTiers[rewardPoolIndex_].push(referrerTiers_[i]);\n\n            lastAmount_ = amount_;\n            lastMultiplier_ = multiplier_;\n        }\n\n        emit ReferrerTiersEdited(rewardPoolIndex_, referrerTiers_);\n    }\n\n    function manageUsersInPrivateRewardPool(\n        uint256 rewardPoolIndex_,\n        address[] calldata users_,\n        uint256[] calldata amounts_,\n        uint128[] calldata claimLockEnds_,\n        address[] calldata referrers_\n    ) external onlyOwner {\n        IRewardPool rewardPool_ = IRewardPool(IDistributor(distributor).rewardPool());\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n        rewardPool_.onlyNotPublicRewardPool(rewardPoolIndex_);\n\n        require(users_.length == amounts_.length, \"DS: invalid length\");\n        require(users_.length == claimLockEnds_.length, \"DS: invalid length\");\n        require(users_.length == referrers_.length, \"DS: invalid length\");\n\n        IDistributor(distributor).distributeRewards(rewardPoolIndex_);\n        (uint256 currentPoolRate_, uint256 rewards_) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        // Update `rewardPoolsProtocolDetails`\n        rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards += rewards_;\n\n        for (uint256 i; i < users_.length; ++i) {\n            uint256 deposited_ = usersData[users_[i]][rewardPoolIndex_].deposited;\n\n            if (deposited_ <= amounts_[i]) {\n                _stake(\n                    users_[i],\n                    rewardPoolIndex_,\n                    amounts_[i] - deposited_,\n                    currentPoolRate_,\n                    claimLockEnds_[i],\n                    referrers_[i]\n                );\n            } else {\n                _withdraw(users_[i], rewardPoolIndex_, deposited_ - amounts_[i], currentPoolRate_);\n            }\n        }\n    }\n\n    /**********************************************************************************************/\n    /*** Stake, claim, withdraw, lock management                                                ***/\n    /**********************************************************************************************/\n\n    function setClaimSender(\n        uint256 rewardPoolIndex_,\n        address[] calldata senders_,\n        bool[] calldata isAllowed_\n    ) external {\n        IRewardPool(IDistributor(distributor).rewardPool()).onlyExistedRewardPool(rewardPoolIndex_);\n        require(senders_.length == isAllowed_.length, \"DS: invalid array length\");\n\n        for (uint256 i = 0; i < senders_.length; ++i) {\n            claimSender[rewardPoolIndex_][_msgSender()][senders_[i]] = isAllowed_[i];\n\n            emit ClaimSenderSet(rewardPoolIndex_, _msgSender(), senders_[i], isAllowed_[i]);\n        }\n    }\n\n    function setClaimReceiver(uint256 rewardPoolIndex_, address receiver_) external {\n        IRewardPool(IDistributor(distributor).rewardPool()).onlyExistedRewardPool(rewardPoolIndex_);\n\n        claimReceiver[rewardPoolIndex_][_msgSender()] = receiver_;\n\n        emit ClaimReceiverSet(rewardPoolIndex_, _msgSender(), receiver_);\n    }\n\n    function stake(uint256 rewardPoolIndex_, uint256 amount_, uint128 claimLockEnd_, address referrer_) external {\n        IRewardPool rewardPool_ = IRewardPool(IDistributor(distributor).rewardPool());\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n        rewardPool_.onlyPublicRewardPool(rewardPoolIndex_);\n\n        IDistributor(distributor).distributeRewards(rewardPoolIndex_);\n        (uint256 currentPoolRate_, uint256 rewards_) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        _stake(_msgSender(), rewardPoolIndex_, amount_, currentPoolRate_, claimLockEnd_, referrer_);\n\n        // Update `rewardPoolsProtocolDetails`\n        rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards += rewards_;\n    }\n\n    function withdraw(uint256 rewardPoolIndex_, uint256 amount_) external {\n        IRewardPool rewardPool_ = IRewardPool(IDistributor(distributor).rewardPool());\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n        rewardPool_.onlyPublicRewardPool(rewardPoolIndex_);\n\n        IDistributor(distributor).distributeRewards(rewardPoolIndex_);\n\n        (uint256 currentPoolRate_, uint256 rewards_) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        _withdraw(_msgSender(), rewardPoolIndex_, amount_, currentPoolRate_);\n\n        // Update `rewardPoolsProtocolDetails`\n        rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards += rewards_;\n    }\n\n    function claim(uint256 rewardPoolIndex_, address receiver_) external payable {\n        _claim(rewardPoolIndex_, _msgSender(), receiver_);\n    }\n\n    function claimFor(uint256 rewardPoolIndex_, address staker_, address receiver_) external payable {\n        if (claimReceiver[rewardPoolIndex_][staker_] != address(0)) {\n            receiver_ = claimReceiver[rewardPoolIndex_][staker_];\n        } else {\n            require(claimSender[rewardPoolIndex_][staker_][_msgSender()], \"DS: invalid caller\");\n        }\n\n        _claim(rewardPoolIndex_, staker_, receiver_);\n    }\n\n    function claimReferrerTier(uint256 rewardPoolIndex_, address receiver_) external payable {\n        _claimReferrerTier(rewardPoolIndex_, _msgSender(), receiver_);\n    }\n\n    function claimReferrerTierFor(uint256 rewardPoolIndex_, address referrer_, address receiver_) external payable {\n        require(claimSender[rewardPoolIndex_][referrer_][_msgSender()], \"DS: invalid caller\");\n\n        _claimReferrerTier(rewardPoolIndex_, referrer_, receiver_);\n    }\n\n    function lockClaim(uint256 rewardPoolIndex_, uint128 claimLockEnd_) external {\n        require(isMigrationOver == true, \"DS: migration isn't over\");\n        IRewardPool(IDistributor(distributor).rewardPool()).onlyExistedRewardPool(rewardPoolIndex_);\n\n        require(claimLockEnd_ > block.timestamp, \"DS: invalid lock end value (1)\");\n\n        IDistributor(distributor).distributeRewards(rewardPoolIndex_);\n\n        address user_ = _msgSender();\n        (uint256 currentPoolRate_, uint256 rewards_) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n        UserData storage userData = usersData[user_][rewardPoolIndex_];\n\n        require(userData.deposited > 0, \"DS: user isn't staked\");\n        require(claimLockEnd_ > userData.claimLockEnd, \"DS: invalid lock end value (2)\");\n\n        userData.pendingRewards = _getCurrentUserReward(currentPoolRate_, userData);\n\n        uint128 claimLockStart_ = userData.claimLockStart > 0 ? userData.claimLockStart : uint128(block.timestamp);\n        uint256 multiplier_ = _getUserTotalMultiplier(claimLockStart_, claimLockEnd_, userData.referrer);\n        uint256 virtualDeposited_ = (userData.deposited * multiplier_) / PRECISION;\n\n        if (userData.virtualDeposited == 0) {\n            userData.virtualDeposited = userData.deposited;\n        }\n\n        // Update `rewardPoolData`\n        rewardPoolData.lastUpdate = uint128(block.timestamp);\n        rewardPoolData.rate = currentPoolRate_;\n        rewardPoolData.totalVirtualDeposited =\n            rewardPoolData.totalVirtualDeposited +\n            virtualDeposited_ -\n            userData.virtualDeposited;\n\n        // Update `userData`\n        userData.rate = currentPoolRate_;\n        userData.virtualDeposited = virtualDeposited_;\n        userData.claimLockStart = claimLockStart_;\n        userData.claimLockEnd = claimLockEnd_;\n        // Update `rewardPoolsProtocolDetails`\n        rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards += rewards_;\n\n        emit UserClaimLocked(rewardPoolIndex_, user_, claimLockStart_, claimLockEnd_);\n    }\n\n    function _stake(\n        address user_,\n        uint256 rewardPoolIndex_,\n        uint256 amount_,\n        uint256 currentPoolRate_,\n        uint128 claimLockEnd_,\n        address referrer_\n    ) private {\n        require(isMigrationOver == true, \"DS: migration isn't over\");\n\n        RewardPoolProtocolDetails storage rewardPoolProtocolDetails = rewardPoolsProtocolDetails[rewardPoolIndex_];\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n        UserData storage userData = usersData[user_][rewardPoolIndex_];\n\n        if (claimLockEnd_ == 0) {\n            claimLockEnd_ = userData.claimLockEnd > block.timestamp ? userData.claimLockEnd : uint128(block.timestamp);\n        }\n        require(claimLockEnd_ >= userData.claimLockEnd, \"DS: invalid claim lock end\");\n\n        if (referrer_ == address(0)) {\n            referrer_ = userData.referrer;\n        }\n\n        if (IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolPublic(rewardPoolIndex_)) {\n            require(amount_ > 0, \"DS: nothing to stake\");\n\n            // https://docs.lido.fi/guides/lido-tokens-integration-guide/#steth-internals-share-mechanics\n            uint256 balanceBefore_ = IERC20(depositToken).balanceOf(address(this));\n            IERC20(depositToken).safeTransferFrom(_msgSender(), address(this), amount_);\n            uint256 balanceAfter_ = IERC20(depositToken).balanceOf(address(this));\n\n            amount_ = balanceAfter_ - balanceBefore_;\n\n            IDistributor(distributor).supply(rewardPoolIndex_, amount_);\n\n            require(userData.deposited + amount_ >= rewardPoolProtocolDetails.minimalStake, \"DS: amount too low\");\n\n            totalDepositedInPublicPools += amount_;\n        }\n\n        userData.pendingRewards = _getCurrentUserReward(currentPoolRate_, userData);\n\n        uint256 deposited_ = userData.deposited + amount_;\n        uint256 multiplier_ = _getUserTotalMultiplier(uint128(block.timestamp), claimLockEnd_, referrer_);\n        uint256 virtualDeposited_ = (deposited_ * multiplier_) / PRECISION;\n\n        if (userData.virtualDeposited == 0) {\n            userData.virtualDeposited = userData.deposited;\n        }\n\n        _applyReferrerTier(\n            user_,\n            rewardPoolIndex_,\n            currentPoolRate_,\n            userData.deposited,\n            deposited_,\n            userData.referrer,\n            referrer_\n        );\n\n        // Update `poolData`\n        rewardPoolData.lastUpdate = uint128(block.timestamp);\n        rewardPoolData.rate = currentPoolRate_;\n        rewardPoolData.totalVirtualDeposited =\n            rewardPoolData.totalVirtualDeposited +\n            virtualDeposited_ -\n            userData.virtualDeposited;\n\n        // Update `userData\n        userData.lastStake = uint128(block.timestamp);\n        userData.rate = currentPoolRate_;\n        userData.deposited = deposited_;\n        userData.virtualDeposited = virtualDeposited_;\n        userData.claimLockStart = uint128(block.timestamp);\n        userData.claimLockEnd = claimLockEnd_;\n        userData.referrer = referrer_;\n\n        emit UserStaked(rewardPoolIndex_, user_, amount_);\n        emit UserClaimLocked(rewardPoolIndex_, user_, uint128(block.timestamp), claimLockEnd_);\n    }\n\n    function _withdraw(address user_, uint256 rewardPoolIndex_, uint256 amount_, uint256 currentPoolRate_) private {\n        require(isMigrationOver == true, \"DS: migration isn't over\");\n\n        RewardPoolProtocolDetails storage rewardPoolProtocolDetails = rewardPoolsProtocolDetails[rewardPoolIndex_];\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n        UserData storage userData = usersData[user_][rewardPoolIndex_];\n\n        uint256 deposited_ = userData.deposited;\n        require(deposited_ > 0, \"DS: user isn't staked\");\n\n        if (amount_ > deposited_) {\n            amount_ = deposited_;\n        }\n\n        uint256 newDeposited_;\n        if (IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolPublic(rewardPoolIndex_)) {\n            require(\n                block.timestamp > userData.lastStake + rewardPoolProtocolDetails.withdrawLockPeriodAfterStake,\n                \"DS: pool withdraw is locked\"\n            );\n\n            uint256 depositTokenContractBalance_ = IERC20(depositToken).balanceOf(distributor);\n            if (amount_ > depositTokenContractBalance_) {\n                amount_ = depositTokenContractBalance_;\n            }\n\n            newDeposited_ = deposited_ - amount_;\n\n            require(amount_ > 0, \"DS: nothing to withdraw\");\n            require(\n                newDeposited_ >= rewardPoolProtocolDetails.minimalStake ||\n                    newDeposited_ == 0 ||\n                    depositTokenContractBalance_ == amount_,\n                \"DS: invalid withdraw amount\"\n            );\n        } else {\n            newDeposited_ = deposited_ - amount_;\n        }\n\n        userData.pendingRewards = _getCurrentUserReward(currentPoolRate_, userData);\n\n        uint256 multiplier_ = _getUserTotalMultiplier(\n            uint128(block.timestamp),\n            userData.claimLockEnd,\n            userData.referrer\n        );\n        uint256 virtualDeposited_ = (newDeposited_ * multiplier_) / PRECISION;\n\n        if (userData.virtualDeposited == 0) {\n            userData.virtualDeposited = userData.deposited;\n        }\n\n        _applyReferrerTier(\n            user_,\n            rewardPoolIndex_,\n            currentPoolRate_,\n            deposited_,\n            newDeposited_,\n            userData.referrer,\n            userData.referrer\n        );\n\n        // Update pool data\n        rewardPoolData.lastUpdate = uint128(block.timestamp);\n        rewardPoolData.rate = currentPoolRate_;\n        rewardPoolData.totalVirtualDeposited =\n            rewardPoolData.totalVirtualDeposited +\n            virtualDeposited_ -\n            userData.virtualDeposited;\n\n        // Update user data\n        userData.rate = currentPoolRate_;\n        userData.deposited = newDeposited_;\n        userData.virtualDeposited = virtualDeposited_;\n        userData.claimLockStart = uint128(block.timestamp);\n\n        if (IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolPublic(rewardPoolIndex_)) {\n            totalDepositedInPublicPools -= amount_;\n\n            IDistributor(distributor).withdraw(rewardPoolIndex_, amount_);\n            IERC20(depositToken).safeTransfer(user_, amount_);\n        }\n\n        emit UserWithdrawn(rewardPoolIndex_, user_, amount_);\n    }\n\n    function _claim(uint256 rewardPoolIndex_, address user_, address receiver_) private {\n        require(isMigrationOver == true, \"DS: migration isn't over\");\n        IRewardPool(IDistributor(distributor).rewardPool()).onlyExistedRewardPool(rewardPoolIndex_);\n\n        UserData storage userData = usersData[user_][rewardPoolIndex_];\n\n        require(\n            block.timestamp >\n                userData.lastStake + rewardPoolsProtocolDetails[rewardPoolIndex_].claimLockPeriodAfterStake,\n            \"DS: pool claim is locked (S)\"\n        );\n        require(\n            block.timestamp >\n                userData.lastClaim + rewardPoolsProtocolDetails[rewardPoolIndex_].claimLockPeriodAfterClaim,\n            \"DS: pool claim is locked (C)\"\n        );\n        require(block.timestamp > userData.claimLockEnd, \"DS: user claim is locked\");\n\n        IDistributor(distributor).distributeRewards(rewardPoolIndex_);\n\n        (uint256 currentPoolRate_, uint256 rewards_) = _getCurrentPoolRate(rewardPoolIndex_);\n        uint256 pendingRewards_ = _getCurrentUserReward(currentPoolRate_, userData);\n        require(pendingRewards_ > 0, \"DS: nothing to claim\");\n\n        uint256 deposited_ = userData.deposited;\n\n        uint256 multiplier_ = _getUserTotalMultiplier(0, 0, userData.referrer);\n        uint256 virtualDeposited_ = (deposited_ * multiplier_) / PRECISION;\n\n        if (userData.virtualDeposited == 0) {\n            userData.virtualDeposited = userData.deposited;\n        }\n\n        // Update `rewardPoolData`\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n        rewardPoolData.lastUpdate = uint128(block.timestamp);\n        rewardPoolData.rate = currentPoolRate_;\n        rewardPoolData.totalVirtualDeposited =\n            rewardPoolData.totalVirtualDeposited +\n            virtualDeposited_ -\n            userData.virtualDeposited;\n\n        // Update `userData`\n        userData.rate = currentPoolRate_;\n        userData.pendingRewards = 0;\n        userData.virtualDeposited = virtualDeposited_;\n        userData.claimLockStart = 0;\n        userData.claimLockEnd = 0;\n        userData.lastClaim = uint128(block.timestamp);\n        // Update `rewardPoolsProtocolDetails`\n        rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards += rewards_;\n\n        // Transfer rewards\n        IDistributor(distributor).sendMintMessage{value: msg.value}(\n            rewardPoolIndex_,\n            receiver_,\n            pendingRewards_,\n            _msgSender()\n        );\n\n        emit UserClaimed(rewardPoolIndex_, user_, receiver_, pendingRewards_);\n    }\n\n    function _claimReferrerTier(uint256 rewardPoolIndex_, address referrer_, address receiver_) private {\n        require(isMigrationOver == true, \"DS: migration isn't over\");\n\n        IRewardPool(IDistributor(distributor).rewardPool()).onlyExistedRewardPool(rewardPoolIndex_);\n        IDistributor(distributor).distributeRewards(rewardPoolIndex_);\n\n        (uint256 currentPoolRate_, uint256 rewards_) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        RewardPoolProtocolDetails storage rewardPoolProtocolDetails = rewardPoolsProtocolDetails[rewardPoolIndex_];\n        ReferrerData storage referrerData = referrersData[referrer_][rewardPoolIndex_];\n\n        require(\n            block.timestamp > referrerData.lastClaim + rewardPoolProtocolDetails.claimLockPeriodAfterClaim,\n            \"DS: pool claim is locked (C)\"\n        );\n\n        uint256 pendingRewards_ = ReferrerLib.claimReferrerTier(referrerData, currentPoolRate_);\n\n        // Update `rewardPoolData`\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n        rewardPoolData.lastUpdate = uint128(block.timestamp);\n        rewardPoolData.rate = currentPoolRate_;\n\n        // Update `rewardPoolsProtocolDetails`\n        rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards += rewards_;\n\n        // Transfer rewards\n        IDistributor(distributor).sendMintMessage{value: msg.value}(\n            rewardPoolIndex_,\n            receiver_,\n            pendingRewards_,\n            _msgSender()\n        );\n\n        emit ReferrerClaimed(rewardPoolIndex_, referrer_, receiver_, pendingRewards_);\n    }\n\n    function _applyReferrerTier(\n        address user_,\n        uint256 rewardPoolIndex_,\n        uint256 currentPoolRate_,\n        uint256 oldDeposited_,\n        uint256 newDeposited_,\n        address oldReferrer_,\n        address newReferrer_\n    ) private {\n        if (newReferrer_ == address(0)) {\n            // we assume that referrer can't be removed, only changed\n            return;\n        }\n\n        ReferrerData storage newReferrerData = referrersData[newReferrer_][rewardPoolIndex_];\n\n        uint256 oldVirtualAmountStaked;\n        uint256 newVirtualAmountStaked;\n\n        if (oldReferrer_ == address(0)) {\n            oldVirtualAmountStaked = newReferrerData.virtualAmountStaked;\n\n            newReferrerData.applyReferrerTier(referrerTiers[rewardPoolIndex_], 0, newDeposited_, currentPoolRate_);\n            newVirtualAmountStaked = newReferrerData.virtualAmountStaked;\n\n            emit UserReferred(rewardPoolIndex_, user_, newReferrer_, newDeposited_);\n        } else if (oldReferrer_ == newReferrer_) {\n            oldVirtualAmountStaked = newReferrerData.virtualAmountStaked;\n\n            newReferrerData.applyReferrerTier(\n                referrerTiers[rewardPoolIndex_],\n                oldDeposited_,\n                newDeposited_,\n                currentPoolRate_\n            );\n            newVirtualAmountStaked = newReferrerData.virtualAmountStaked;\n\n            emit UserReferred(rewardPoolIndex_, user_, newReferrer_, newDeposited_);\n        } else {\n            ReferrerData storage oldReferrerData = referrersData[oldReferrer_][rewardPoolIndex_];\n\n            oldVirtualAmountStaked = oldReferrerData.virtualAmountStaked + newReferrerData.virtualAmountStaked;\n\n            oldReferrerData.applyReferrerTier(referrerTiers[rewardPoolIndex_], oldDeposited_, 0, currentPoolRate_);\n            newReferrerData.applyReferrerTier(referrerTiers[rewardPoolIndex_], 0, newDeposited_, currentPoolRate_);\n            newVirtualAmountStaked = oldReferrerData.virtualAmountStaked + newReferrerData.virtualAmountStaked;\n\n            emit UserReferred(rewardPoolIndex_, user_, oldReferrer_, 0);\n            emit UserReferred(rewardPoolIndex_, user_, newReferrer_, newDeposited_);\n        }\n\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n        rewardPoolData.totalVirtualDeposited =\n            rewardPoolData.totalVirtualDeposited +\n            newVirtualAmountStaked -\n            oldVirtualAmountStaked;\n    }\n\n    /**********************************************************************************************/\n    /*** Functionality for rewards calculations + getters                                       ***/\n    /**********************************************************************************************/\n\n    function getLatestUserReward(uint256 rewardPoolIndex_, address user_) public view returns (uint256) {\n        if (!IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolExist(rewardPoolIndex_)) {\n            return 0;\n        }\n\n        UserData storage userData = usersData[user_][rewardPoolIndex_];\n        (uint256 currentPoolRate_, ) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        return _getCurrentUserReward(currentPoolRate_, userData);\n    }\n\n    function getLatestReferrerReward(uint256 rewardPoolIndex_, address user_) public view returns (uint256) {\n        if (!IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolExist(rewardPoolIndex_)) {\n            return 0;\n        }\n\n        (uint256 currentPoolRate_, ) = _getCurrentPoolRate(rewardPoolIndex_);\n\n        return referrersData[user_][rewardPoolIndex_].getCurrentReferrerReward(currentPoolRate_);\n    }\n\n    function _getCurrentUserReward(uint256 currentPoolRate_, UserData memory userData_) private pure returns (uint256) {\n        uint256 deposited_ = userData_.virtualDeposited == 0 ? userData_.deposited : userData_.virtualDeposited;\n\n        uint256 newRewards_ = ((currentPoolRate_ - userData_.rate) * deposited_) / PRECISION;\n\n        return userData_.pendingRewards + newRewards_;\n    }\n\n    function _getCurrentPoolRate(uint256 rewardPoolIndex_) private view returns (uint256, uint256) {\n        RewardPoolData storage rewardPoolData = rewardPoolsData[rewardPoolIndex_];\n\n        uint256 rewards_ = IDistributor(distributor).getDistributedRewards(rewardPoolIndex_, address(this)) -\n            rewardPoolsProtocolDetails[rewardPoolIndex_].distributedRewards;\n\n        if (rewardPoolData.totalVirtualDeposited == 0) {\n            return (rewardPoolData.rate, rewards_);\n        }\n\n        uint256 rate_ = rewardPoolData.rate + (rewards_ * PRECISION) / rewardPoolData.totalVirtualDeposited;\n\n        return (rate_, rewards_);\n    }\n\n    /**********************************************************************************************/\n    /*** Functionality for multipliers, getters                                                 ***/\n    /**********************************************************************************************/\n\n    function getCurrentUserMultiplier(uint256 rewardPoolIndex_, address user_) public view returns (uint256) {\n        if (!IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolExist(rewardPoolIndex_)) {\n            return PRECISION;\n        }\n\n        UserData storage userData = usersData[user_][rewardPoolIndex_];\n\n        return _getUserTotalMultiplier(userData.claimLockStart, userData.claimLockEnd, userData.referrer);\n    }\n\n    function getReferrerMultiplier(uint256 rewardPoolIndex_, address referrer_) public view returns (uint256) {\n        if (!IRewardPool(IDistributor(distributor).rewardPool()).isRewardPoolExist(rewardPoolIndex_)) {\n            return 0;\n        }\n\n        ReferrerData storage referrerData = referrersData[referrer_][rewardPoolIndex_];\n        if (referrerData.amountStaked == 0) {\n            return 0;\n        }\n\n        return (referrerData.virtualAmountStaked * PRECISION) / referrerData.amountStaked;\n    }\n\n    function _getUserTotalMultiplier(\n        uint128 claimLockStart_,\n        uint128 claimLockEnd_,\n        address referrer_\n    ) internal pure returns (uint256) {\n        return\n            LockMultiplierMath.getLockPeriodMultiplier(claimLockStart_, claimLockEnd_) +\n            ReferrerLib.getReferralMultiplier(referrer_) -\n            PRECISION;\n    }\n\n    /**********************************************************************************************/\n    /*** UUPS                                                                                   ***/\n    /**********************************************************************************************/\n\n    function removeUpgradeability() external onlyOwner {\n        isNotUpgradeable = true;\n    }\n\n    function version() external pure returns (uint256) {\n        return 7;\n    }\n\n    function _authorizeUpgrade(address) internal view override onlyOwner {\n        require(!isNotUpgradeable, \"DS: upgrade isn't available\");\n    }\n}\n"
    }
}