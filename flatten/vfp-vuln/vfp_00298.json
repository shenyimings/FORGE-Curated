{
    "vfp_id": "vfp_00298",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Pools Can Be Subject to Price Manipulation Leading to Early Liquidations or Arbitrage",
            "description": "The protocol's price oracle uses a combination of Chainlink's `anchorPrice` and spot prices from multiple on-chain DEX pools to derive `minPrice` and `maxPrice`. These are used in critical operations such as liquidation and redemption. However, the system allows manipulation if any single pool's spot price deviates by exactly 1% from the `anchorPrice`, at which point it bypasses the deviation check and is accepted. An attacker can manipulate a low-TLV pool (e.g., WETH/USDC Uniswap V2) to force `minPrice` down, triggering premature liquidations for profit, or manipulate `maxPrice` to create arbitrage during redemption. The root cause is the aggregation logic that collapses multiple spot prices into a single `minPrice` and `maxPrice`, making the system vulnerable to a single point of failure. This negates the intended resilience from diversification. The impact includes potential loss of user funds due to forced liquidations and unfair arbitrage, undermining the protocol's economic security.\n",
            "severity": "Medium",
            "location": [
                "LSDPriceOracleBase.sol::getPrice#85-99",
                "StETHPriceOracle.sol::getPrice#36-43",
                "BasePool.sol::operate#92",
                "BasePool.sol::rebalance#250",
                "BasePool.sol::liquidate#388",
                "BasePool.sol::redeem#196"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/LSDPriceOracleBase.sol"
            ]
        }
    ],
    "affected_files": {
        "LSDPriceOracleBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { SpotPriceOracleBase } from \"./SpotPriceOracleBase.sol\";\n\nimport { IPriceOracle } from \"./interfaces/IPriceOracle.sol\";\nimport { ITwapOracle } from \"./interfaces/ITwapOracle.sol\";\n\nabstract contract LSDPriceOracleBase is SpotPriceOracleBase, IPriceOracle {\n  /*************\n   * Constants *\n   *************/\n\n  /// @notice The Chainlink ETH/USD price feed.\n  /// @dev See comments of `_readSpotPriceByChainlink` for more details.\n  bytes32 public immutable Chainlink_ETH_USD_Spot;\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @dev The encodings for ETH/USD spot sources.\n  bytes private onchainSpotEncodings_ETHUSD;\n\n  /// @dev The encodings for LSD/ETH spot sources.\n  bytes private onchainSpotEncodings_LSDETH;\n\n  /// @dev The encodings for LSD/USD spot sources.\n  bytes private onchainSpotEncodings_LSDUSD;\n\n  /// @notice The value of maximum price deviation, multiplied by 1e18.\n  uint256 public maxPriceDeviation;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(bytes32 _Chainlink_ETH_USD_Spot) {\n    Chainlink_ETH_USD_Spot = _Chainlink_ETH_USD_Spot;\n\n    _updateMaxPriceDeviation(1e16); // 1%\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Return the ETH/USD spot price.\n  /// @return chainlinkPrice The spot price from Chainlink price feed.\n  /// @return minPrice The minimum spot price among all available sources.\n  /// @return maxPrice The maximum spot price among all available sources.\n  function getETHUSDSpotPrice() external view returns (uint256 chainlinkPrice, uint256 minPrice, uint256 maxPrice) {\n    (chainlinkPrice, minPrice, maxPrice) = _getETHUSDSpotPrice();\n  }\n\n  /// @notice Return the ETH/USD spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getETHUSDSpotPrices() external view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_ETHUSD);\n  }\n\n  /// @notice Return the LSD/ETH spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getLSDETHSpotPrices() public view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_LSDETH);\n  }\n\n  /// @notice Return the LSD/ETH spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getLSDUSDSpotPrices() public view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_LSDUSD);\n  }\n\n  /// @notice Return the LSD/USD anchor price, the price that is hard to manipulate in single tx.\n  /// @return price The anchor price, multiplied by 1e18.\n  function getLSDUSDAnchorPrice() external view returns (uint256 price) {\n    price = _getLSDUSDAnchorPrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  /// @dev The price is valid iff |maxPrice-minPrice|/minPrice < maxPriceDeviation\n  function getPrice() public view override returns (uint256 anchorPrice, uint256 minPrice, uint256 maxPrice) {\n    anchorPrice = _getLSDUSDAnchorPrice();\n    (minPrice, maxPrice) = _getLSDMinMaxPrice(anchorPrice);\n\n    uint256 cachedMaxPriceDeviation = maxPriceDeviation; // gas saving\n    // use anchor price when the price deviation between anchor price and min price exceed threshold\n    if ((anchorPrice - minPrice) * PRECISION > cachedMaxPriceDeviation * minPrice) {\n      minPrice = anchorPrice;\n    }\n\n    // use anchor price when the price deviation between anchor price and max price exceed threshold\n    if ((maxPrice - anchorPrice) * PRECISION > cachedMaxPriceDeviation * anchorPrice) {\n      maxPrice = anchorPrice;\n    }\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getExchangePrice() public view returns (uint256) {\n    (, uint256 price, ) = getPrice();\n    return price;\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getLiquidatePrice() external view returns (uint256) {\n    return getExchangePrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getRedeemPrice() external view returns (uint256) {\n    (, , uint256 price) = getPrice();\n    return price;\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the on-chain spot encodings.\n  /// @param encodings The encodings to update. See `_getSpotPriceByEncoding` for more details.\n  /// @param spotType The type of the encodings.\n  function updateOnchainSpotEncodings(bytes memory encodings, uint256 spotType) external onlyOwner {\n    // validate encoding\n    uint256[] memory prices = _getSpotPriceByEncoding(encodings);\n\n    if (spotType == 0) {\n      onchainSpotEncodings_ETHUSD = encodings;\n      if (prices.length == 0) revert ErrorInvalidEncodings();\n    } else if (spotType == 1) {\n      onchainSpotEncodings_LSDETH = encodings;\n    } else if (spotType == 2) {\n      onchainSpotEncodings_LSDUSD = encodings;\n    }\n  }\n\n  /// @notice Update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function updateMaxPriceDeviation(uint256 newMaxPriceDeviation) external onlyOwner {\n    _updateMaxPriceDeviation(newMaxPriceDeviation);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function _updateMaxPriceDeviation(uint256 newMaxPriceDeviation) private {\n    uint256 oldMaxPriceDeviation = maxPriceDeviation;\n    if (oldMaxPriceDeviation == newMaxPriceDeviation) {\n      revert ErrorParameterUnchanged();\n    }\n\n    maxPriceDeviation = newMaxPriceDeviation;\n\n    emit UpdateMaxPriceDeviation(oldMaxPriceDeviation, newMaxPriceDeviation);\n  }\n\n  /// @dev Internal function to calculate the ETH/USD spot price.\n  /// @return chainlinkPrice The spot price from Chainlink price feed, multiplied by 1e18.\n  /// @return minPrice The minimum spot price among all available sources, multiplied by 1e18.\n  /// @return maxPrice The maximum spot price among all available sources, multiplied by 1e18.\n  function _getETHUSDSpotPrice() internal view returns (uint256 chainlinkPrice, uint256 minPrice, uint256 maxPrice) {\n    chainlinkPrice = _readSpotPriceByChainlink(Chainlink_ETH_USD_Spot);\n    uint256[] memory prices = _getSpotPriceByEncoding(onchainSpotEncodings_ETHUSD);\n    minPrice = maxPrice = chainlinkPrice;\n    for (uint256 i = 0; i < prices.length; i++) {\n      if (prices[i] > maxPrice) maxPrice = prices[i];\n      if (prices[i] < minPrice) minPrice = prices[i];\n    }\n  }\n\n  /// @dev Internal function to return the min/max LSD/USD prices.\n  /// @param anchorPrice The LSD/USD anchor price, multiplied by 1e18.\n  /// @return minPrice The minimum price among all available sources (including twap), multiplied by 1e18.\n  /// @return maxPrice The maximum price among all available sources (including twap), multiplied by 1e18.\n  function _getLSDMinMaxPrice(uint256 anchorPrice) internal view returns (uint256 minPrice, uint256 maxPrice) {\n    minPrice = maxPrice = anchorPrice;\n    (, uint256 minETHUSDPrice, uint256 maxETHUSDPrice) = _getETHUSDSpotPrice();\n    uint256[] memory LSD_ETH_prices = getLSDETHSpotPrices();\n    uint256[] memory LSD_USD_prices = getLSDUSDSpotPrices();\n\n    uint256 length = LSD_ETH_prices.length;\n    uint256 LSD_ETH_minPrice = type(uint256).max;\n    uint256 LSD_ETH_maxPrice;\n    unchecked {\n      for (uint256 i = 0; i < length; i++) {\n        uint256 price = LSD_ETH_prices[i];\n        if (price > LSD_ETH_maxPrice) LSD_ETH_maxPrice = price;\n        if (price < LSD_ETH_minPrice) LSD_ETH_minPrice = price;\n      }\n      if (LSD_ETH_maxPrice != 0) {\n        minPrice = Math.min(minPrice, (LSD_ETH_minPrice * minETHUSDPrice) / PRECISION);\n        maxPrice = Math.max(maxPrice, (LSD_ETH_maxPrice * maxETHUSDPrice) / PRECISION);\n      }\n\n      length = LSD_USD_prices.length;\n      for (uint256 i = 0; i < length; i++) {\n        uint256 price = LSD_USD_prices[i];\n        if (price > maxPrice) maxPrice = price;\n        if (price < minPrice) minPrice = price;\n      }\n    }\n  }\n\n  /// @dev Internal function to return the LSD/USD anchor price.\n  /// @return price The anchor price of LSD/USD, multiplied by 1e18.\n  function _getLSDUSDAnchorPrice() internal view virtual returns (uint256 price);\n}\n"
    }
}