{
    "vfp_id": "vfp_00298",
    "project_name": "Oxorio SAMM Module Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Front-Running Can Lead to Multisig Wallet DoS",
            "description": "The `executeTransaction` and `executeTransactionReturnData` functions in the SAMM contract do not restrict the caller, allowing any external party to invoke them. An attacker can observe a relayer's transaction in the mempool and front-run it with a modified gas amount. By carefully choosing the gas limit, the attacker can cause the forwarded call to revert due to insufficient gas while still allowing the outer transaction to succeed (thanks to EIP-150's gas stipend rules). This results in the SAMM contract's nonce being incremented, which invalidates the original relayer's transaction. The exploitation does not require special privileges and relies only on mempool monitoring and faster transaction submission. The impact is a denial-of-service on the multisig functionality, discarding the off-chain coordination and proof generation effort, and blocking legitimate transaction execution until a new proof is generated.\n",
            "severity": "High",
            "location": [
                "samm-contracts/src/SAMM.sol#167",
                "samm-contracts/src/SAMM.sol#194",
                "samm-contracts/src/SAMM.sol#443",
                "samm-contracts/src/SAMM.sol#435"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        }
    ],
    "affected_files": {
        "SAMM.sol": "// SPDX-License-Identifier: GPL-3\n/**\n *     Safe Anonymization Mail Module\n *     Copyright (C) 2024 OXORIO-FZCO\n *\n *     This program is free software: you can redistribute it and/or modify\n *     it under the terms of the GNU General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n *\n *     This program is distributed in the hope that it will be useful,\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *     GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.23;\n\n// Contracts\nimport {Singleton} from \"./Safe/common/Singleton.sol\";\nimport {HonkVerifier as Verifier1024} from \"./utils/Verifier1024.sol\";\nimport {HonkVerifier as Verifier2048} from \"./utils/Verifier2048.sol\";\n\n// Libs\nimport {PubSignalsConstructor} from \"./libraries/PubSignalsConstructor.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Interfaces\nimport {ISAMM} from \"./interfaces/ISAMM.sol\";\nimport {ISafe} from \"./Safe/interfaces/ISafe.sol\";\nimport {IDKIMRegistry} from \"./interfaces/IDKIMRegistry.sol\";\n\n/// @title Safe Anonymization Mail Module\n/// @author Vladimir Kumalagov (@KumaCrypto, @dry914)\n/// @notice This contract is a module for Safe Wallet (Gnosis Safe), aiming to provide anonymity for users.\n/// It allows users to execute transactions for a specified Safe without revealing the addresses of the members who voted to execute the transaction.\n/// @dev This contract should be used as a singleton. And proxy contracts must use delegatecall to use the contract logic.\ncontract SAMM is Singleton, ISAMM {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    ///////////////////////\n    //Immutable Variables//\n    ///////////////////////\n\n    // Verifiers from repository: https://github.com/oxor-io/samm-circuits\n    Verifier1024 private immutable VERIFIER1024 = new Verifier1024();\n    Verifier2048 private immutable VERIFIER2048 = new Verifier2048();\n\n    //////////////////////\n    // State Variables  //\n    //////////////////////\n    ISafe private s_safe;\n    // The value of type(uint64).max is large enough to hold the maximum possible amount of proofs.\n    uint64 private s_threshold;\n    // Relayer email address\n    string private s_relayer;\n    // The root of the Merkle tree from the addresses of all SAM members (using Poseidon)\n    uint256 private s_membersRoot;\n    uint256 private s_nonce;\n    IDKIMRegistry private s_dkimRegistry;\n\n    // A whitelist of contract addresses and function signatures\n    // with which the SAMM module can interact on behalf of the Safe multisig\n    EnumerableSet.Bytes32Set private s_allowedTxs; // abi.encodePacked(bytes20(address),bytes4(signature))\n\n    // A limit on the amount of ETH that can be transferred\n    // to a single (address,signature) in the whitelist.\n    mapping(bytes32 => uint256) private s_allowance;\n\n    //////////////////////////////\n    // Functions - Constructor  //\n    //////////////////////////////\n    constructor() {\n        // To lock the singleton contract so no one can call setup.\n        s_threshold = 1;\n    }\n\n    ///////////////////////////\n    // Functions - External  //\n    ///////////////////////////\n\n    /**\n     * @notice Initializes the contract.\n     * @dev This method can only be called once.\n     * If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * Revert in case:\n     *  - The contract has already been initialized.\n     *  - One of the passed parameters is 0.\n     * @param safe The address of the Safe.\n     * @param membersRoot The Merkle root of participant addresses.\n     * @param threshold The minimum number of proofs required to execute a transaction.\n     * @param relayer The email address of Relayer.\n     * @param dkimRegistry The DKIM pubkeys registry contract address.\n     * @param txAllowances List of [address, selector] pairs which are initialy allowed.\n     */\n    function setup(\n        address safe,\n        uint256 membersRoot,\n        uint64 threshold,\n        string calldata relayer,\n        address dkimRegistry,\n        TxAllowance[] calldata txAllowances\n    ) external {\n        if (s_threshold != 0) {\n            revert SAMM__alreadyInitialized();\n        }\n\n        // Parameters validation block\n        {\n            if (safe == address(0)) {\n                revert SAMM__safeIsZero();\n            }\n\n            if (membersRoot == 0) {\n                revert SAMM__rootIsZero();\n            }\n\n            if (threshold == 0) {\n                revert SAMM__thresholdIsZero();\n            }\n\n            if (bytes(relayer).length == 0) {\n                revert SAMM__emptyRelayer();\n            }\n\n            if (dkimRegistry == address(0)) {\n                revert SAMM__dkimRegistryIsZero();\n            }\n        }\n\n        bytes32 txId;\n        for (uint256 i; i < txAllowances.length; i++) {\n            if (txAllowances[i].to == safe || txAllowances[i].to == address(0)) {\n                revert SAMM__toIsWrong();\n            }\n            txId = bytes32(abi.encodePacked(bytes20(txAllowances[i].to), txAllowances[i].selector));\n            s_allowedTxs.add(txId);\n            s_allowance[txId] = txAllowances[i].amount;\n        }\n\n        s_safe = ISafe(safe);\n        s_membersRoot = membersRoot;\n        s_threshold = threshold;\n        s_relayer = relayer;\n        s_dkimRegistry = IDKIMRegistry(dkimRegistry);\n\n        emit Setup(msg.sender, safe, membersRoot, threshold, relayer, dkimRegistry);\n    }\n\n    /**\n     * @notice Executes a transaction with zk proofs without returning data.\n     * @dev Revert in case:\n     *          - Not enough proofs provided (threshold > hash approval amount + amount of provided proofs).\n     *          - Contract not initialized.\n     *          - One of the proof commits has already been used.\n     *          - One of the proof is invalid.\n     * @param to The target address to be called by safe.\n     * @param value The value in wei to be sent.\n     * @param data The data payload of the transaction.\n     * @param operation The type of operation (CALL, DELEGATECALL).\n     * @param proofs An array of zk proofs.\n     * @param deadline The deadline before which transaction should be executed.\n     * @return success A boolean indicating whether the transaction was successful.\n     */\n    function executeTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        Proof[] calldata proofs,\n        uint256 deadline\n    ) external returns (bool success) {\n        (success,) = _executeTransaction(to, value, data, operation, proofs, deadline);\n    }\n\n    /**\n     * @notice Executes a transaction with zk proofs and returns the returned by the transaction execution.\n     * @dev Revert in case:\n     *          - Not enough proofs provided (threshold > hash approval amount + amount of provided proofs).\n     *          - Contract not initialized.\n     *          - One of the proof commits has already been used.\n     *          - One of the proof is invalid.\n     * @param to The target address to be called by safe.\n     * @param value The value in wei to be sent.\n     * @param data The data payload of the transaction.\n     * @param operation The type of operation (CALL, DELEGATECALL).\n     * @param proofs An array of zk proofs.\n     * @param deadline The deadline before which transaction should be executed.\n     * @return success A boolean indicating whether the transaction was successful.\n     * @return returnData The data returned by the transaction execution.\n     */\n    function executeTransactionReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        Proof[] calldata proofs,\n        uint256 deadline\n    ) external returns (bool success, bytes memory returnData) {\n        (success, returnData) = _executeTransaction(to, value, data, operation, proofs, deadline);\n    }\n\n    /**\n     * @notice Updates threshold parameter.\n     * @param threshold The new threshold value.\n     */\n    function setThreshold(uint64 threshold) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (threshold == 0) {\n            revert SAMM__thresholdIsZero();\n        }\n\n        s_threshold = threshold;\n\n        emit ThresholdIsChanged(threshold);\n    }\n\n    /**\n     * @notice Updates members root parameter.\n     * @param membersRoot The new members' root value.\n     */\n    function setMembersRoot(uint256 membersRoot) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (membersRoot == 0) {\n            revert SAMM__rootIsZero();\n        }\n\n        s_membersRoot = membersRoot;\n\n        emit MembersRootIsChanged(membersRoot);\n    }\n\n    /**\n     * @notice Updates DKIM registry parameter.\n     * @param dkimRegistry The new DKIM registry address.\n     */\n    function setDKIMRegistry(address dkimRegistry) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (dkimRegistry == address(0)) {\n            revert SAMM__dkimRegistryIsZero();\n        }\n\n        s_dkimRegistry = IDKIMRegistry(dkimRegistry);\n\n        emit DKIMRegistryIsChanged(dkimRegistry);\n    }\n\n    /**\n     * @notice Updates relayer email address parameter.\n     * @param relayer The new relayer email address.\n     */\n    function setRelayer(string calldata relayer) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (bytes(relayer).length == 0) {\n            revert SAMM__emptyRelayer();\n        }\n\n        if (bytes(relayer).length > 124) {\n            revert SAMM__longRelayer();\n        }\n\n        s_relayer = relayer;\n\n        emit RelayerIsChanged(relayer);\n    }\n\n    /**\n     * @notice Updates list of allowed transactions.\n     * @param txAllowance TxAllowance structure of new transaction.\n     * @param isAllowed Boolean: 1 if the transaction is allowed, 0 if the transaction is not allowed anymore.\n     */\n    function setTxAllowed(TxAllowance calldata txAllowance, bool isAllowed) external {\n        address _safe = address(s_safe);\n        if (msg.sender != _safe) {\n            revert SAMM__notSafe();\n        }\n        if (txAllowance.to == _safe || txAllowance.to == address(0)) {\n            revert SAMM__toIsWrong();\n        }\n        bool success;\n        bytes32 txId = bytes32(abi.encodePacked(bytes20(txAllowance.to), txAllowance.selector));\n        if (isAllowed) {\n            success = s_allowedTxs.add(txId);\n            s_allowance[txId] = txAllowance.amount;\n        } else {\n            success = s_allowedTxs.remove(txId);\n            s_allowance[txId] = 0;\n        }\n        if (!success) revert SAMM__noChanges();\n        emit TxAllowanceChanged(txId, txAllowance.amount, isAllowed);\n    }\n\n    /**\n     * @notice Updates allowance mapping.\n     * @param txId Transaction id for which allowance is changing.\n     * @param amount The new allowance value.\n     */\n    function changeAllowance(bytes32 txId, uint256 amount) external {\n        address _safe = address(s_safe);\n        if (msg.sender != _safe) {\n            revert SAMM__notSafe();\n        }\n        if (!s_allowedTxs.contains(txId)) {\n            revert SAMM__txIsNotAllowed();\n        }\n        if (amount == s_allowance[txId]) {\n            revert SAMM__noChanges();\n        }\n        s_allowance[txId] = amount;\n        emit AllowanceChanged(txId, amount);\n    }\n\n    //////////////////////////////\n    // Functions  -   View      //\n    //////////////////////////////\n\n    /// @notice Retrieves the address of the Safe associated with this module.\n    /// @return safe The address of the associated Safe.\n    function getSafe() external view returns (address safe) {\n        return address(s_safe);\n    }\n\n    /// @notice Retrieves the current members root.\n    /// @return root The Merkle root of participant addresses.\n    function getMembersRoot() external view returns (uint256 root) {\n        return s_membersRoot;\n    }\n\n    /// @notice Retrieves the threshold number of proofs required for transaction execution.\n    /// @return threshold The current threshold value.\n    function getThreshold() external view returns (uint64 threshold) {\n        return s_threshold;\n    }\n\n    /// @notice Retrieves the relayer email address.\n    /// @return relayer The current relayer email address.\n    function getRelayer() external view returns (string memory relayer) {\n        return s_relayer;\n    }\n\n    /// @notice Retrieves the address of DKIMRegistry.\n    /// @return dkimRegistry The current DKIMRegistry address.\n    function getDKIMRegistry() external view returns (address dkimRegistry) {\n        return address(s_dkimRegistry);\n    }\n\n    /// @notice Retrieves the current nonce value.\n    /// @return nonce The current nonce.\n    function getNonce() external view returns (uint256 nonce) {\n        return s_nonce;\n    }\n\n    /// @notice Retrieves the current list of allowed transactions.\n    /// @return List of allowed transactions.\n    function getAllowedTxs() external view returns (TxAllowance[] memory) {\n        bytes32[] memory allowedTxs = s_allowedTxs.values();\n        TxAllowance[] memory txAllowances = new TxAllowance[](allowedTxs.length);\n\n        address to;\n        bytes4 selector;\n        uint256 amount;\n        for (uint256 i; i < allowedTxs.length; i++) {\n            // decode allowedTxs storage\n            to = address(bytes20(allowedTxs[i]));\n            selector = bytes4(allowedTxs[i] << 160);\n            amount = s_allowance[allowedTxs[i]];\n            txAllowances[i] = TxAllowance(to, selector, amount);\n        }\n        return txAllowances;\n    }\n\n    /**\n     * @notice Generates a message hash based on transaction parameters.\n     * @param to The target address to be called by safe.\n     * @param value The value in wei of the transaction.\n     * @param data The data payload of the transaction.\n     * @param operation The type of operation (CALL, DELEGATECALL).\n     * @param nonce The nonce to be used for the transaction.\n     * @param deadline The deadline before which transaction should be executed.\n     * @return msgHash The resulting message hash.\n     */\n    function getMessageHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        uint256 nonce,\n        uint256 deadline\n    ) external view returns (bytes32 msgHash) {\n        return PubSignalsConstructor.getMsgHash(to, value, data, operation, nonce, deadline);\n    }\n\n    //////////////////////////////\n    //   Functions - Private    //\n    //////////////////////////////\n    function _executeTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        Proof[] calldata proofs,\n        uint256 deadline\n    ) private returns (bool success, bytes memory returnData) {\n        uint256 root = s_membersRoot;\n\n        // Check root to prevent calls when contract is not initialized.\n        if (root == 0) {\n            revert SAMM__rootIsZero();\n        }\n\n        // Check execution deadline.\n        if (block.timestamp > deadline) {\n            revert SAMM__deadlineIsPast();\n        }\n\n        // Check tx allowance\n        _checkTxAllowance(to, value, data);\n\n        // pubSignals = [root, relayer, relayer_len, msg_hash, pubkey_mod, redc_params]\n        bytes32[] memory pubSignals =\n            PubSignalsConstructor.getPubSignals(root, s_relayer, to, value, data, operation, s_nonce++, deadline);\n\n        if (s_threshold > proofs.length) {\n            revert SAMM__notEnoughProofs(proofs.length, s_threshold);\n        }\n\n        _checkNProofs(proofs, pubSignals);\n\n        return s_safe.execTransactionFromModuleReturnData(to, value, data, operation);\n    }\n\n    function _checkTxAllowance(address to, uint256 value, bytes memory data) private view {\n        bytes4 selector;\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n        bytes32 txId = bytes32(abi.encodePacked(bytes20(to), selector));\n        if (!s_allowedTxs.contains(txId)) {\n            revert SAMM__txIsNotAllowed();\n        }\n        if (s_allowance[txId] < value) {\n            revert SAMM__allowanceIsNotEnough();\n        }\n    }\n\n    function _checkNProofs(Proof[] calldata proofs, bytes32[] memory pubSignals) private {\n        uint256 proofsLength = proofs.length;\n\n        for (uint256 i; i < proofsLength; i++) {\n            Proof memory currentProof = proofs[i];\n\n            // check DKIM public key\n            bool isValid = s_dkimRegistry.isDKIMPublicKeyHashValid(currentProof.domain, currentProof.pubkeyHash);\n            if (!isValid) {\n                revert SAMM__DKIMPublicKeyVerificationFailed(i);\n            }\n\n            // Commit must be uniq, because it is a hash(userEmail, msgHash)\n            for (uint256 j; j < i; j++) {\n                if (proofs[j].commit == currentProof.commit) {\n                    revert SAMM__commitAlreadyUsed(i);\n                }\n            }\n\n            pubSignals[170] = bytes32(currentProof.commit);\n            pubSignals[171] = currentProof.pubkeyHash;\n            bool result;\n            if (currentProof.is2048sig) {\n                result = VERIFIER2048.verify({proof: currentProof.proof, publicInputs: pubSignals});\n            } else {\n                result = VERIFIER1024.verify({proof: currentProof.proof, publicInputs: pubSignals});\n            }\n\n            if (!result) {\n                revert SAMM__proofVerificationFailed(i);\n            }\n        }\n    }\n}\n"
    }
}