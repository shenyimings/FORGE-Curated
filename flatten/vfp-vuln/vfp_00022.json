{
    "vfp_id": "vfp_00022",
    "project_name": "2025-01-bacon-labs-bunniv2-securityreview.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Rebalance mechanism access control can be bypassed",
            "description": "The BunniZone's validate function only checks the fulfiller's address (msg.sender) against a whitelist or the am-AMM manager, but does not validate the order's pre- and post-hooks. This allows an attacker to create a fake order with arbitrary hooks.\n\nThe cause is insufficient validation in the BunniZone contract. It trusts that the order's hooks are legitimate based only on the fulfiller's identity, not the order's integrity. Additionally, the BunniHook's isValidSignature function only checks poolId and hash, not the full order structure.\n\nAn attacker can create a fake order with a valid poolId and hash but insert malicious hooks, such as a call to permit2 to transfer tokens from the BunniHook contract. Since the signature validation passes and the fulfiller is whitelisted or is the manager, the order executes.\n\nThe impact is severe: an attacker can drain any token balance from the BunniHook contract for pools with active rebalance orders by inserting permit2 transfer calls, leading to complete loss of funds.\n",
            "severity": "High",
            "location": [
                "src/BunniHook.sol",
                "src/lib/BunniHookLogic.sol",
                "flood-contracts/master/src/FloodPlain.sol#L55-L78",
                "src/BunniZone.sol#L41-L54",
                "src/lib/BunniHookLogic.sol#L733-L743",
                "src/BunniHook.sol#L120-L131"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/BunniZone.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/BunniHook.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniHookLogic.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Pools can be drained via the rebalance mechanism by selectively executing the rebalanceOrderPreHook and the rebalanceOrderPostHook",
            "description": "The rebalance mechanism allows pre- and post-hooks to be executed independently, enabling an attacker to execute a valid pre-hook (which pulls tokens into BunniHook) and then a malicious post-hook (which sends them to an attacker-controlled address).\n\nThe cause is the lack of atomicity and state tracking between pre- and post-hook execution. While each hook validates its own arguments, there is no mechanism to ensure they are executed as a pair or in sequence.\n\nAn attacker can create a fake order that includes a legitimate pool's pre-hook and a malicious pool's post-hook. After the pre-hook increases the BunniHook's balance, the post-hook can drain those tokens to the attacker.\n\nThe impact is complete loss of funds for any pool with an active rebalance order, as the attacker can repeatedly drain tokens until the pool is empty.\n",
            "severity": "High",
            "location": [
                "src/BunniHook.sol",
                "src/lib/BunniHookLogic.sol",
                "flood-contracts/master/src/FloodPlain.sol#L55-L78",
                "flood-contracts/master/src/lib/Hooks.sol#L9-L27",
                "src/lib/BunniHookLogic.sol#L696-L714",
                "src/BunniHook.sol#L429-L438",
                "src/BunniHook.sol#L465-L474"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/BunniHook.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Excess liquidity can be inflated to create arbitrarily large rebalance orders",
            "description": "The calculation of excess liquidity used in rebalance orders is vulnerable to inflation through manipulation of internal accounting variables. This occurs because the system does not properly validate or cap the computed excess amount.\n\nThe root cause is the lack of safeguards against manipulation of liquidity inputs used in rebalance calculations. An attacker could manipulate pool state or hook interactions to report inflated excess liquidity, enabling the creation of disproportionately large rebalance orders.\n\nAn attacker could exploit this by inflating the perceived excess liquidity in a pool, possibly through temporary imbalances or flash loan attacks, to trigger a large rebalance order that benefits the attacker.\n\nThe impact could include significant misallocation of assets, loss of funds for LPs, or manipulation of pool state. This could result in the pool being drained of assets when the order is settled.\n",
            "severity": "High",
            "location": [
                "src/lib/BunniHookLogic.sol",
                "src/lib/BunniHubLogic.sol"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniHookLogic.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniHubLogic.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Users can gain free tokens through the BunniSwap swap functionality",
            "description": "Due to a flaw in the swap calculation logic, users can receive positive output tokens even when providing zero input. This is caused by incorrect handling of edge cases in the swap math, particularly when amountSpecified is nonzero but effectively zero due to rounding. An attacker could exploit this to generate tokens from nothing, leading to inflation and direct loss of value from the pool. This is a high-severity issue as it enables unlimited minting of tokens.\n\nThe computeSwap function in the BunniSwapMath library allows users to receive a nonzero amount of output tokens even when the effective input amount is zero. This occurs due to improper handling of amountSpecified in the swap logic, particularly when negative values are used to indicate ExactIn swaps. The function fails to enforce that a nonzero output must require a corresponding nonzero input. As a result, users can manipulate the swap parameters to extract tokens without providing equivalent input, leading to free token minting. This undermines the economic model of the protocol and could lead to significant loss of liquidity.\n",
            "severity": "High",
            "location": [
                "src/lib/BunniSwapMath.sol#101-104",
                "src/lib/BunniSwapMath.sol#49-78"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniSwapMath.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Users can gain tokens during round-trip swaps",
            "description": "The system allows users to perform round-trip swaps (e.g., token A to B and back to A) and end up with more tokens than they started with. This indicates a violation of economic invariants and is caused by asymmetric rounding or incorrect fee accounting. Attackers can repeatedly execute such swaps to extract value from the pool, leading to significant fund depletion over time. This is a high-severity vulnerability due to its profit-driven exploitability.\n\nDue to an incorrect implementation in the _computeSwap function, users can gain tokens by performing round-trip swaps (e.g., swapping token0 for token1 and back). The issue arises because the updatedTick variable is not properly initialized when certain conditions are skipped in the control flow, leading to inconsistent state updates. This causes the return amounts in reverse swaps to exceed the original input, effectively allowing arbitrage at the protocol's expense. The root cause lies in missing tick initialization logic, which results in inaccurate price and liquidity calculations. This can be exploited repeatedly to drain pool reserves.\n",
            "severity": "High",
            "location": [
                "src/lib/BunniSwapMath.sol#228-302"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniSwapMath.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Manipulation of Rebalance Orders via Just-in-Time Liquidity",
            "description": "The Bunni v2 protocol allows for autonomous rebalancing of pool liquidity based on shifts in the Liquidity Density Function (LDF). The rebalance mechanism is triggered when the estimated liquidity of the two tokens in a pool diverges beyond a configured threshold. The amount of liquidity is calculated using token balances and their respective densities. However, the system allows liquidity to be added or removed only in proportion to current balances, which includes any excess liquidity, thereby preserving the imbalance ratio.\n\nThe root cause of the vulnerability lies in the fact that the rebalance order calculation uses the current pool balances, which can be temporarily inflated by just-in-time liquidity deposits. A malicious fulfiller can deposit a large amount of liquidity just before a rebalance is triggered, causing the rebalance order to be based on artificially inflated balances. After the order is created, the attacker can withdraw their liquidity and then fulfill the order themselves, profiting from the slippage tolerance.\n\nAn attacker can exploit this by monitoring pools for LDF shifts that will trigger rebalances, depositing liquidity to skew the balance, triggering the rebalance via a small swap, withdrawing their liquidity, and then fulfilling the order. This allows them to extract excess profit at the expense of the pool's balance, leaving it in a severely unbalanced state.\n\nThe impact includes financial gain for the attacker, potential loss of value for legitimate liquidity providers, and degradation of pool efficiency. In extreme cases, the pool could become unusable due to extreme imbalance, leading to denial of service for legitimate users.\n",
            "severity": "High",
            "location": [
                "src/lib/QueryLDF.sol#L72-L84",
                "src/lib/BunniHookLogic.sol#L618-L623",
                "src/lib/BunniHubLogic.sol#L226-L312",
                "src/lib/BunniHookLogic.sol#L652-L672"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/QueryLDF.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniHookLogic.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniHubLogic.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Users can gain free tokens through the BunniSwap swap functionality",
            "description": "This vulnerability allows users to potentially gain free tokens during swap operations due to incorrect handling of idle pool balances and cumulative amount calculations. The root cause lies in the complex interaction between the swap logic, liquidity density functions (LDFs), and rebalance mechanics, where an attacker could exploit miscalculations in token outputs. Exploitation would involve crafting specific swap inputs that take advantage of unaccounted idle liquidity or incorrect cumulative values returned by LDFs. The impact could include unauthorized minting of tokens, leading to economic loss and undermining the integrity of the protocol.\n",
            "severity": "High",
            "location": [
                "BunniSwapMath.sol::computeSwap",
                "LibUniformDistribution.sol::cumulativeAmount0",
                "BunniHookLogic.sol::beforeSwap"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniSwapMath.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/LibUniformDistribution.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniHookLogic.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Users can gain tokens during round-trip swaps",
            "description": "This issue enables users to profit from round-trip swaps by receiving more tokens than they initially deposited, indicating a potential imbalance in the swap calculation logic. The cause stems from inconsistencies in how input and output amounts are computed across forward and reverse swap paths, possibly due to rounding errors or incorrect state updates. An attacker could exploit this by performing a sequence of swaps (e.g., token A to B, then back to A) and extracting excess tokens. The impact includes loss of funds from the pool and potential manipulation of market prices.\n",
            "severity": "High",
            "location": [
                "BunniSwapMath.sol::computeSwap",
                "BunniHub.sol::swap"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniSwapMath.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "BunniSwap swap functionality can cause panics during the swap",
            "description": "The swap functionality is susceptible to arithmetic panics (e.g., underflow) under certain edge cases, which could disrupt normal operation. Although the fix attempts to mitigate this by returning zero instead of reverting on underflow, the change introduces uncertainty about correctness in edge cases. The root cause is insufficient safeguards around arithmetic operations in the computeSwap function. Exploitation could involve submitting crafted inputs that trigger underflow conditions, potentially leading to incorrect state transitions or denial of service. The impact includes unreliable swap execution and potential loss of user funds if calculations are incorrect.\n",
            "severity": "High",
            "location": [
                "BunniSwapMath.sol::computeSwap",
                "BunniSwapMath.sol::computeSwapStep"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/BunniSwapMath.sol"
            ]
        }
    ],
    "affected_files": {
        "BunniHook.sol": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {AmAmm} from \"biddog/AmAmm.sol\";\n\nimport \"flood-contracts/src/interfaces/IZone.sol\";\nimport \"flood-contracts/src/interfaces/IFloodPlain.sol\";\n\nimport {IERC1271} from \"permit2/src/interfaces/IERC1271.sol\";\n\nimport {WETH} from \"solady/tokens/WETH.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport \"./lib/Math.sol\";\nimport \"./base/Errors.sol\";\nimport \"./base/Constants.sol\";\nimport \"./lib/AmAmmPayload.sol\";\nimport \"./base/SharedStructs.sol\";\nimport \"./interfaces/IBunniHook.sol\";\nimport {Oracle} from \"./lib/Oracle.sol\";\nimport {Ownable} from \"./base/Ownable.sol\";\nimport {BaseHook} from \"./base/BaseHook.sol\";\nimport {IBunniHub} from \"./interfaces/IBunniHub.sol\";\nimport {BunniSwapMath} from \"./lib/BunniSwapMath.sol\";\nimport {BunniHookLogic} from \"./lib/BunniHookLogic.sol\";\nimport {ReentrancyGuard} from \"./base/ReentrancyGuard.sol\";\n\n/// @title BunniHook\n/// @author zefram.eth\n/// @notice Uniswap v4 hook responsible for handling swaps on Bunni. Implements auto-rebalancing\n/// executed via FloodPlain. Uses am-AMM to recapture LVR & MEV.\ncontract BunniHook is BaseHook, Ownable, IBunniHook, ReentrancyGuard, AmAmm {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for *;\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using Oracle for Oracle.Observation[MAX_CARDINALITY];\n\n    /// -----------------------------------------------------------------------\n    /// Immutable args\n    /// -----------------------------------------------------------------------\n\n    WETH internal immutable weth;\n    IBunniHub internal immutable hub;\n    address internal immutable permit2;\n    IFloodPlain internal immutable floodPlain;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @dev Contains mappings used by both BunniHook and BunniLogic. Makes passing\n    /// mappings to BunniHookLogic easier & cheaper.\n    HookStorage internal s;\n\n    /// @notice The poolwise amAmmEnabled override. Top precedence.\n    mapping(PoolId => BoolOverride) internal amAmmEnabledOverride;\n\n    /// @notice Used for computing the hook fee amount. Fee taken is `amount * swapFee / 1e6 * hookFeesModifier / 1e6`.\n    uint32 internal hookFeeModifier;\n\n    /// @notice Used for computing the referral reward amount. Reward is `hookFee * referralRewardModifier / 1e6`.\n    uint32 internal referralRewardModifier;\n\n    /// @notice The FloodZone contract used in rebalance orders.\n    IZone internal floodZone;\n\n    /// @notice Enables/disables am-AMM globally. Takes precedence over amAmmEnabled in hookParams, overriden by amAmmEnabledOverride.\n    BoolOverride internal globalAmAmmEnabledOverride;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        IPoolManager poolManager_,\n        IBunniHub hub_,\n        IFloodPlain floodPlain_,\n        WETH weth_,\n        IZone floodZone_,\n        address owner_,\n        uint32 hookFeeModifier_,\n        uint32 referralRewardModifier_\n    ) BaseHook(poolManager_) {\n        if (hookFeeModifier_ > MODIFIER_BASE || referralRewardModifier_ > MODIFIER_BASE) {\n            revert BunniHook__InvalidModifier();\n        }\n\n        hub = hub_;\n        floodPlain = floodPlain_;\n        permit2 = address(floodPlain_.PERMIT2());\n        weth = weth_;\n\n        hookFeeModifier = hookFeeModifier_;\n        referralRewardModifier = referralRewardModifier_;\n        floodZone = floodZone_;\n\n        _initializeOwner(owner_);\n        poolManager_.setOperator(address(hub_), true);\n\n        emit SetModifiers(hookFeeModifier_, referralRewardModifier_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// EIP-1271 compliance\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC1271\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        override\n        returns (bytes4 magicValue)\n    {\n        // verify rebalance order\n        PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to store the pool id\n        if (s.rebalanceOrderHash[id] == hash) {\n            return this.isValidSignature.selector;\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function increaseCardinalityNext(PoolKey calldata key, uint32 cardinalityNext)\n        public\n        override\n        returns (uint32 cardinalityNextOld, uint32 cardinalityNextNew)\n    {\n        PoolId id = key.toId();\n\n        ObservationState storage state = s.states[id];\n\n        cardinalityNextOld = state.cardinalityNext;\n        cardinalityNextNew = s.observations[id].grow(cardinalityNextOld, cardinalityNext);\n        state.cardinalityNext = cardinalityNextNew;\n    }\n\n    receive() external payable {}\n\n    /// -----------------------------------------------------------------------\n    /// Uniswap lock callback\n    /// -----------------------------------------------------------------------\n\n    enum HookUnlockCallbackType {\n        REBALANCE_PREHOOK,\n        REBALANCE_POSTHOOK,\n        CLAIM_FEES\n    }\n\n    /// @inheritdoc IUnlockCallback\n    function unlockCallback(bytes calldata data) external override poolManagerOnly returns (bytes memory) {\n        // decode input\n        (HookUnlockCallbackType t, bytes memory callbackData) = abi.decode(data, (HookUnlockCallbackType, bytes));\n\n        if (t == HookUnlockCallbackType.REBALANCE_PREHOOK) {\n            _rebalancePrehookCallback(callbackData);\n        } else if (t == HookUnlockCallbackType.REBALANCE_POSTHOOK) {\n            _rebalancePosthookCallback(callbackData);\n        } else if (t == HookUnlockCallbackType.CLAIM_FEES) {\n            _claimFees(callbackData);\n        }\n        return bytes(\"\");\n    }\n\n    /// @dev Calls hub.hookHandleSwap to pull the rebalance swap input tokens from BunniHub.\n    /// Then burns PoolManager claim tokens and takes the underlying tokens from PoolManager.\n    /// Used while executing rebalance orders.\n    function _rebalancePrehookCallback(bytes memory callbackData) internal {\n        // decode data\n        (Currency currency, uint256 amount, PoolKey memory key, bool zeroForOne) =\n            abi.decode(callbackData, (Currency, uint256, PoolKey, bool));\n\n        // pull claim tokens from BunniHub\n        hub.hookHandleSwap({key: key, zeroForOne: zeroForOne, inputAmount: 0, outputAmount: amount});\n\n        // burn and take\n        poolManager.burn(address(this), currency.toId(), amount);\n        poolManager.take(currency, address(this), amount);\n    }\n\n    /// @dev Settles tokens sent to PoolManager and mints the corresponding claim tokens.\n    /// Then calls hub.hookHandleSwap to update pool balances with rebalance swap output.\n    /// Used while executing rebalance orders.\n    function _rebalancePosthookCallback(bytes memory callbackData) internal {\n        // decode data\n        (Currency currency, uint256 amount, PoolKey memory key, bool zeroForOne) =\n            abi.decode(callbackData, (Currency, uint256, PoolKey, bool));\n\n        // settle and mint\n        uint256 paid = poolManager.settle{value: currency.isNative() ? amount : 0}();\n        poolManager.mint(address(this), currency.toId(), paid);\n\n        // push claim tokens to BunniHub\n        hub.hookHandleSwap({key: key, zeroForOne: zeroForOne, inputAmount: paid, outputAmount: 0});\n    }\n\n    /// @dev Claims protocol fees earned and sends it to the recipient.\n    function _claimFees(bytes memory callbackData) internal {\n        // decode data\n        (Currency[] memory currencyList, address recipient) = abi.decode(callbackData, (Currency[], address));\n\n        // claim protocol fees\n        for (uint256 i; i < currencyList.length; i++) {\n            Currency currency = currencyList[i];\n            // can claim balance - am-AMM accrued fees\n            uint256 balance = poolManager.balanceOf(address(this), currency.toId()) - _totalFees[currency];\n            if (balance != 0) {\n                poolManager.burn(address(this), currency.toId(), balance);\n                poolManager.take(currency, recipient, balance);\n            }\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// BunniHub functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function updateLdfState(PoolId id, bytes32 newState) external override {\n        if (msg.sender != address(hub)) revert BunniHook__Unauthorized();\n\n        s.ldfStates[id] = newState;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function claimProtocolFees(Currency[] calldata currencyList, address recipient) external override onlyOwner {\n        poolManager.unlock(abi.encode(HookUnlockCallbackType.CLAIM_FEES, abi.encode(currencyList, recipient)));\n    }\n\n    /// @inheritdoc IBunniHook\n    function setZone(IZone zone) external onlyOwner {\n        floodZone = zone;\n        emit SetZone(zone);\n    }\n\n    /// @inheritdoc IBunniHook\n    function setModifiers(uint32 newHookFeeModifier, uint32 newReferralRewardModifier) external onlyOwner {\n        if (newHookFeeModifier > MODIFIER_BASE || newReferralRewardModifier > MODIFIER_BASE) {\n            revert BunniHook__InvalidModifier();\n        }\n\n        hookFeeModifier = newHookFeeModifier;\n        referralRewardModifier = newReferralRewardModifier;\n\n        emit SetModifiers(newHookFeeModifier, newReferralRewardModifier);\n    }\n\n    /// @inheritdoc IBunniHook\n    function setAmAmmEnabledOverride(PoolId id, BoolOverride boolOverride) external onlyOwner {\n        amAmmEnabledOverride[id] = boolOverride;\n        emit SetAmAmmEnabledOverride(id, boolOverride);\n    }\n\n    /// @inheritdoc IBunniHook\n    function setGlobalAmAmmEnabledOverride(BoolOverride boolOverride) external onlyOwner {\n        globalAmAmmEnabledOverride = boolOverride;\n        emit SetGlobalAmAmmEnabledOverride(boolOverride);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function getObservation(PoolKey calldata key, uint256 index)\n        external\n        view\n        override\n        returns (Oracle.Observation memory observation)\n    {\n        observation = s.observations[key.toId()][index];\n    }\n\n    /// @inheritdoc IBunniHook\n    function getState(PoolKey calldata key) external view override returns (ObservationState memory state) {\n        state = s.states[key.toId()];\n    }\n\n    /// @inheritdoc IBunniHook\n    function observe(PoolKey calldata key, uint32[] calldata secondsAgos)\n        external\n        view\n        override\n        returns (int56[] memory tickCumulatives)\n    {\n        PoolId id = key.toId();\n        ObservationState memory state = s.states[id];\n        Slot0 memory slot0 = s.slot0s[id];\n\n        return s.observations[id].observe(\n            state.intermediateObservation,\n            uint32(block.timestamp),\n            secondsAgos,\n            slot0.tick,\n            state.index,\n            state.cardinality\n        );\n    }\n\n    /// @inheritdoc IBunniHook\n    function isValidParams(bytes calldata hookParams) external pure override returns (bool) {\n        DecodedHookParams memory p = BunniHookLogic.decodeHookParams(hookParams);\n        unchecked {\n            return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n                && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax || p.feeTwapSecondsAgo != 0)\n                && (p.surgeFee < SWAP_FEE_BASE)\n                && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) * uint256(p.vaultSurgeThreshold1) != 0)\n                && (\n                    (\n                        p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 && p.rebalanceTwapSecondsAgo == 0\n                            && p.rebalanceOrderTTL == 0\n                    )\n                        || (\n                            p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0 && p.rebalanceTwapSecondsAgo != 0\n                                && p.rebalanceOrderTTL != 0\n                        )\n                ) && (p.oracleMinInterval != 0);\n        }\n    }\n\n    /// @inheritdoc IBunniHook\n    function getAmAmmEnabled(PoolId id) external view override returns (bool) {\n        return _amAmmEnabled(id);\n    }\n\n    /// @inheritdoc IBunniHook\n    function ldfStates(PoolId id) external view returns (bytes32) {\n        return s.ldfStates[id];\n    }\n\n    /// @inheritdoc IBunniHook\n    function slot0s(PoolId id)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint32 lastSwapTimestamp, uint32 lastSurgeTimestamp)\n    {\n        Slot0 memory slot0 = s.slot0s[id];\n        return (slot0.sqrtPriceX96, slot0.tick, slot0.lastSwapTimestamp, slot0.lastSurgeTimestamp);\n    }\n\n    /// @inheritdoc IBunniHook\n    function vaultSharePricesAtLastSwap(PoolId id)\n        external\n        view\n        returns (bool initialized, uint120 sharePrice0, uint120 sharePrice1)\n    {\n        VaultSharePrices memory prices = s.vaultSharePricesAtLastSwap[id];\n        return (prices.initialized, prices.sharePrice0, prices.sharePrice1);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Hooks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBaseHook\n    function afterInitialize(\n        address caller,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData\n    ) external override(BaseHook, IBaseHook) poolManagerOnly returns (bytes4) {\n        BunniHookLogic.afterInitialize(s, caller, key, sqrtPriceX96, tick, hookData, hub);\n        return BunniHook.afterInitialize.selector;\n    }\n\n    /// @inheritdoc IBaseHook\n    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)\n        external\n        override(BaseHook, IBaseHook)\n        poolManagerOnly\n        nonReentrant\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        (\n            bool useAmAmmFee,\n            address amAmmManager,\n            Currency amAmmFeeCurrency,\n            uint256 amAmmFeeAmount,\n            BeforeSwapDelta beforeSwapDelta\n        ) = BunniHookLogic.beforeSwap(\n            s,\n            BunniHookLogic.Env({\n                hookFeeModifier: hookFeeModifier,\n                referralRewardModifier: referralRewardModifier,\n                floodZone: floodZone,\n                hub: hub,\n                poolManager: poolManager,\n                floodPlain: floodPlain,\n                weth: weth,\n                permit2: permit2\n            }),\n            sender,\n            key,\n            params\n        );\n\n        // accrue swap fee to the am-AMM manager if present\n        if (useAmAmmFee) {\n            _accrueFees(amAmmManager, amAmmFeeCurrency, amAmmFeeAmount);\n        }\n\n        return (BunniHook.beforeSwap.selector, beforeSwapDelta, 0);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Rebalancing functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function rebalanceOrderPreHook(RebalanceOrderHookArgs calldata hookArgs) external override nonReentrant {\n        // verify call came from Flood\n        if (msg.sender != address(floodPlain)) {\n            revert BunniHook__Unauthorized();\n        }\n\n        // ensure args can be trusted\n        if (keccak256(abi.encode(hookArgs)) != s.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n            revert BunniHook__InvalidRebalanceOrderHookArgs();\n        }\n\n        RebalanceOrderPreHookArgs calldata args = hookArgs.preHookArgs;\n\n        // pull input tokens from BunniHub to BunniHook\n        // received in the form of PoolManager claim tokens\n        // then unwrap claim tokens\n        poolManager.unlock(\n            abi.encode(\n                HookUnlockCallbackType.REBALANCE_PREHOOK,\n                abi.encode(args.currency, args.amount, hookArgs.key, hookArgs.key.currency1 == args.currency)\n            )\n        );\n\n        // ensure we have exactly args.amount tokens\n        if (args.currency.balanceOfSelf() != args.amount) {\n            revert BunniHook__PrehookPostConditionFailed();\n        }\n\n        // wrap native ETH input to WETH\n        // we're implicitly trusting the WETH contract won't charge a fee which is OK in practice\n        if (args.currency.isNative()) {\n            weth.deposit{value: args.amount}();\n        }\n    }\n\n    /// @inheritdoc IBunniHook\n    function rebalanceOrderPostHook(RebalanceOrderHookArgs calldata hookArgs) external override nonReentrant {\n        // verify call came from Flood\n        if (msg.sender != address(floodPlain)) {\n            revert BunniHook__Unauthorized();\n        }\n\n        // ensure args can be trusted\n        if (keccak256(abi.encode(hookArgs)) != s.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n            revert BunniHook__InvalidRebalanceOrderHookArgs();\n        }\n\n        // invalidate the rebalance order hash\n        // don't delete the deadline to maintain a min rebalance interval\n        PoolId id = hookArgs.key.toId();\n        delete s.rebalanceOrderHash[id];\n        delete s.rebalanceOrderHookArgsHash[id];\n\n        // surge fee should be applied after the rebalance has been executed\n        // since totalLiquidity will be increased\n        // no need to check surgeFeeAutostartThreshold since we just increased the liquidity in this tx\n        // so block.timestamp is the exact time when the surge should occur\n        s.slot0s[id].lastSwapTimestamp = uint32(block.timestamp);\n        s.slot0s[id].lastSurgeTimestamp = uint32(block.timestamp);\n\n        RebalanceOrderPostHookArgs calldata args = hookArgs.postHookArgs;\n\n        uint256 orderOutputAmount;\n        if (args.currency.isNative()) {\n            // unwrap WETH output to native ETH\n            orderOutputAmount = weth.balanceOf(address(this));\n            weth.withdraw(orderOutputAmount);\n        } else {\n            orderOutputAmount = args.currency.balanceOfSelf();\n        }\n\n        // posthook should wrap output tokens as claim tokens and push it from BunniHook to BunniHub and update pool balances\n        poolManager.sync(args.currency);\n        if (!args.currency.isNative()) {\n            Currency.unwrap(args.currency).safeTransfer(address(poolManager), orderOutputAmount);\n        }\n        poolManager.unlock(\n            abi.encode(\n                HookUnlockCallbackType.REBALANCE_POSTHOOK,\n                abi.encode(args.currency, orderOutputAmount, hookArgs.key, hookArgs.key.currency0 == args.currency)\n            )\n        );\n    }\n\n    /// -----------------------------------------------------------------------\n    /// AmAmm support\n    /// -----------------------------------------------------------------------\n\n    /// @dev precedence is poolOverride > globalOverride > poolEnabled\n    function _amAmmEnabled(PoolId id) internal view virtual override returns (bool) {\n        BoolOverride poolOverride = amAmmEnabledOverride[id];\n\n        if (poolOverride != BoolOverride.UNSET) return poolOverride == BoolOverride.TRUE;\n\n        BoolOverride globalOverride = globalAmAmmEnabledOverride;\n\n        if (globalOverride != BoolOverride.UNSET) return globalOverride == BoolOverride.TRUE;\n\n        bytes memory hookParams = hub.hookParams(id);\n        bytes32 firstWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            firstWord := mload(add(hookParams, 32))\n        }\n        bool poolEnabled = uint8(bytes1(firstWord << 248)) != 0;\n        return poolEnabled;\n    }\n\n    function _payloadIsValid(PoolId id, bytes7 payload) internal view virtual override returns (bool) {\n        // use feeMax from hookParams\n        bytes memory hookParams = hub.hookParams(id);\n        bytes32 firstWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            firstWord := mload(add(hookParams, 32))\n        }\n        uint24 maxSwapFee = uint24(bytes3(firstWord << 24));\n\n        // payload is valid if swapFee0For1 and swapFee1For0 are at most maxSwapFee\n        (uint24 swapFee0For1, uint24 swapFee1For0,) = decodeAmAmmPayload(payload);\n        return swapFee0For1 <= maxSwapFee && swapFee1For0 <= maxSwapFee;\n    }\n\n    function _burnBidToken(PoolId id, uint256 amount) internal virtual override {\n        hub.bunniTokenOfPool(id).burn(amount);\n    }\n\n    function _pullBidToken(PoolId id, address from, uint256 amount) internal virtual override {\n        hub.bunniTokenOfPool(id).transferFrom(from, address(this), amount);\n    }\n\n    function _pushBidToken(PoolId id, address to, uint256 amount) internal virtual override {\n        hub.bunniTokenOfPool(id).transfer(to, amount);\n    }\n\n    function _transferFeeToken(Currency currency, address to, uint256 amount) internal virtual override {\n        poolManager.transfer(to, currency.toId(), amount);\n    }\n}\n",
        "BunniSwapMath.sol": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {console2} from \"forge-std/console2.sol\";\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {IPoolManager, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./Math.sol\";\nimport \"../base/Errors.sol\";\nimport \"../base/Constants.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {queryLDF} from \"./QueryLDF.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\nlibrary BunniSwapMath {\n    using TickMath for int24;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n    struct BunniComputeSwapInput {\n        PoolKey key;\n        uint256 totalLiquidity;\n        uint256 liquidityDensityOfRoundedTickX96;\n        uint256 totalDensity0X96;\n        uint256 totalDensity1X96;\n        uint160 sqrtPriceX96;\n        int24 currentTick;\n        ILiquidityDensityFunction liquidityDensityFunction;\n        int24 arithmeticMeanTick;\n        bytes32 ldfParams;\n        bytes32 ldfState;\n        IPoolManager.SwapParams swapParams;\n    }\n\n    /// @notice Computes the result of a swap given the input parameters\n    /// @param input The input parameters for the swap\n    /// @param balance0 The balance of token0 in the pool\n    /// @param balance1 The balance of token1 in the pool\n    /// @return updatedSqrtPriceX96 The updated sqrt price after the swap\n    /// @return updatedTick The updated tick after the swap\n    /// @return inputAmount The input amount of the swap\n    /// @return outputAmount The output amount of the swap\n    function computeSwap(BunniComputeSwapInput calldata input, uint256 balance0, uint256 balance1)\n        external\n        view\n        returns (uint160 updatedSqrtPriceX96, int24 updatedTick, uint256 inputAmount, uint256 outputAmount)\n    {\n        uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n        int256 amountSpecified = input.swapParams.amountSpecified;\n        if (amountSpecified > 0 && uint256(amountSpecified) > outputTokenBalance) {\n            // exact output swap where the requested output amount exceeds the output token balance\n            // change swap to an exact output swap where the output amount is the output token balance\n            amountSpecified = outputTokenBalance.toInt256();\n        }\n\n        // compute first pass result\n        (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input, amountSpecified);\n\n        // ensure that the output amount is lte the output token balance\n        if (outputAmount > outputTokenBalance) {\n            // exactly output the output token's balance\n            // need to recompute swap\n            amountSpecified = outputTokenBalance.toInt256();\n            (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input, amountSpecified);\n\n            if (outputAmount > outputTokenBalance) {\n                // somehow the output amount is still greater than the balance due to rounding errors\n                // just set outputAmount to the balance\n                outputAmount = outputTokenBalance;\n            }\n        }\n    }\n\n    function _computeSwap(BunniComputeSwapInput calldata input, int256 amountSpecified)\n        private\n        view\n        returns (uint160 updatedSqrtPriceX96, int24 updatedTick, uint256 inputAmount, uint256 outputAmount)\n    {\n        // bound sqrtPriceLimit so that we never end up at an invalid rounded tick\n        uint160 sqrtPriceLimitX96 = input.swapParams.sqrtPriceLimitX96;\n        {\n            (uint160 minSqrtPrice, uint160 maxSqrtPrice) = (\n                TickMath.minUsableTick(input.key.tickSpacing).getSqrtPriceAtTick(),\n                TickMath.maxUsableTick(input.key.tickSpacing).getSqrtPriceAtTick()\n            );\n            if (\n                (input.swapParams.zeroForOne && sqrtPriceLimitX96 < minSqrtPrice)\n                    || (!input.swapParams.zeroForOne && sqrtPriceLimitX96 >= maxSqrtPrice)\n            ) {\n                sqrtPriceLimitX96 = input.swapParams.zeroForOne ? minSqrtPrice : maxSqrtPrice - 1;\n            }\n        }\n\n        // initialize input and output amounts based on initial info\n        bool exactIn = amountSpecified < 0;\n        inputAmount = exactIn ? uint256(-amountSpecified) : 0;\n        outputAmount = exactIn ? 0 : uint256(amountSpecified);\n        bool zeroForOne = input.swapParams.zeroForOne;\n\n        // compute updated current tick liquidity\n        uint256 updatedRoundedTickLiquidity = (input.totalLiquidity * input.liquidityDensityOfRoundedTickX96) >> 96;\n\n        // handle the special case when we don't cross rounded ticks\n        if (updatedRoundedTickLiquidity != 0) {\n            // compute the resulting sqrt price assuming no rounded tick is crossed\n            (int24 roundedTick, int24 nextRoundedTick) = roundTick(input.currentTick, input.key.tickSpacing);\n            int24 tickNext = zeroForOne ? roundedTick : nextRoundedTick;\n            uint160 sqrtPriceNextX96 = TickMath.getSqrtPriceAtTick(tickNext);\n            int256 amountSpecifiedRemaining = amountSpecified;\n            (uint160 naiveSwapResultSqrtPriceX96, uint256 naiveSwapAmountIn, uint256 naiveSwapAmountOut) = SwapMath\n                .computeSwapStep({\n                sqrtPriceCurrentX96: input.sqrtPriceX96,\n                sqrtPriceTargetX96: SwapMath.getSqrtPriceTarget(zeroForOne, sqrtPriceNextX96, sqrtPriceLimitX96),\n                liquidity: updatedRoundedTickLiquidity,\n                amountRemaining: amountSpecifiedRemaining\n            });\n            if (!exactIn) {\n                unchecked {\n                    amountSpecifiedRemaining -= naiveSwapAmountOut.toInt256();\n                }\n            } else {\n                // safe because we test that amountSpecified > amountIn in SwapMath\n                unchecked {\n                    amountSpecifiedRemaining += naiveSwapAmountIn.toInt256();\n                }\n            }\n            if (\n                amountSpecifiedRemaining == 0 || naiveSwapResultSqrtPriceX96 == sqrtPriceLimitX96\n                    || (zeroForOne && naiveSwapResultSqrtPriceX96 > sqrtPriceNextX96)\n                    || (!zeroForOne && naiveSwapResultSqrtPriceX96 < sqrtPriceNextX96)\n            ) {\n                // swap doesn't cross rounded tick\n                if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n                    // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n                    unchecked {\n                        // cannot cast a bool to an int24 in Solidity\n                        int24 _zeroForOne;\n                        assembly {\n                            _zeroForOne := zeroForOne\n                        }\n                        updatedTick = tickNext - _zeroForOne;\n                    }\n                } else if (naiveSwapResultSqrtPriceX96 != input.sqrtPriceX96) {\n                    // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                    updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n                }\n\n                // early return\n                return (naiveSwapResultSqrtPriceX96, updatedTick, naiveSwapAmountIn, naiveSwapAmountOut);\n            }\n        }\n\n        // swap crosses rounded tick\n        // need to use LDF to compute the swap\n        (uint256 currentActiveBalance0, uint256 currentActiveBalance1) = (\n            input.totalDensity0X96.fullMulDiv(input.totalLiquidity, Q96),\n            input.totalDensity1X96.fullMulDiv(input.totalLiquidity, Q96)\n        );\n\n        // compute updated sqrt ratio & tick\n        {\n            uint256 inverseCumulativeAmountFnInput;\n            if (exactIn) {\n                // exact input swap\n                inverseCumulativeAmountFnInput =\n                    zeroForOne ? currentActiveBalance0 + inputAmount : currentActiveBalance1 + inputAmount;\n            } else {\n                // exact output swap\n                inverseCumulativeAmountFnInput = zeroForOne\n                    ? currentActiveBalance1 - FixedPointMathLib.min(outputAmount, currentActiveBalance1)\n                    : currentActiveBalance0 - FixedPointMathLib.min(outputAmount, currentActiveBalance0);\n            }\n\n            (bool success, int24 updatedRoundedTick, uint256 cumulativeAmount, uint256 swapLiquidity) = input\n                .liquidityDensityFunction\n                .computeSwap(\n                input.key,\n                inverseCumulativeAmountFnInput,\n                input.totalLiquidity,\n                zeroForOne,\n                exactIn,\n                input.arithmeticMeanTick,\n                input.currentTick,\n                input.ldfParams,\n                input.ldfState\n            );\n\n            if (success && swapLiquidity != 0) {\n                // use Uniswap math to compute updated sqrt price\n                uint160 startSqrtPriceX96 = TickMath.getSqrtPriceAtTick(updatedRoundedTick);\n                bool partialSwapZeroForOne = (exactIn == zeroForOne);\n                int24 tickNext = partialSwapZeroForOne\n                    ? updatedRoundedTick - input.key.tickSpacing\n                    : updatedRoundedTick + input.key.tickSpacing;\n                uint160 sqrtPriceNextX96 = TickMath.getSqrtPriceAtTick(tickNext);\n\n                // handle the case where sqrtPriceLimitX96 has already been reached\n                // naiveSwapResultSqrtPriceX96 will be between startSqrtPriceX96 and sqrtPriceNextX96\n                // leastChangeSqrtPriceX96 is the sqrt price bound closest to the initial sqrt price before this swap\n                // if it already exceeds the sqrt price limit, we should use the fallback swap logic\n                uint160 leastChangeSqrtPriceX96 = exactIn ? startSqrtPriceX96 : sqrtPriceNextX96;\n                if (\n                    (zeroForOne && sqrtPriceLimitX96 <= leastChangeSqrtPriceX96)\n                        || (!zeroForOne && sqrtPriceLimitX96 >= leastChangeSqrtPriceX96)\n                ) {\n                    int256 amountSpecifiedRemaining = -(inverseCumulativeAmountFnInput - cumulativeAmount).toInt256();\n                    (uint160 naiveSwapResultSqrtPriceX96, uint256 naiveSwapAmountIn, uint256 naiveSwapAmountOut) =\n                    SwapMath.computeSwapStep({\n                        sqrtPriceCurrentX96: startSqrtPriceX96,\n                        // sqrtPriceLimitX96 is only meaningful if the partial swap and the overall swap are in the same direction\n                        // which is when exactIn is true\n                        sqrtPriceTargetX96: exactIn\n                            ? SwapMath.getSqrtPriceTarget(partialSwapZeroForOne, sqrtPriceNextX96, sqrtPriceLimitX96)\n                            : sqrtPriceNextX96,\n                        liquidity: swapLiquidity,\n                        amountRemaining: amountSpecifiedRemaining\n                    });\n                    // safe because we test that amountSpecified > amountIn in SwapMath\n                    unchecked {\n                        amountSpecifiedRemaining += naiveSwapAmountIn.toInt256();\n                    }\n                    if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n                        // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n                        unchecked {\n                            // cannot cast a bool to an int24 in Solidity\n                            int24 _zeroForOne;\n                            assembly {\n                                _zeroForOne := zeroForOne\n                            }\n                            updatedTick = tickNext - _zeroForOne;\n                        }\n                    } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n                        // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                        updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n                    }\n\n                    updatedSqrtPriceX96 = naiveSwapResultSqrtPriceX96;\n\n                    // compute input and output token amounts\n                    if (exactIn) {\n                        (inputAmount, outputAmount) = zeroForOne\n                            ? (\n                                naiveSwapAmountIn + cumulativeAmount - currentActiveBalance0,\n                                currentActiveBalance1 + naiveSwapAmountOut\n                                    - input.liquidityDensityFunction.cumulativeAmount1(\n                                        input.key,\n                                        updatedRoundedTick - input.key.tickSpacing,\n                                        input.totalLiquidity,\n                                        input.arithmeticMeanTick,\n                                        updatedTick,\n                                        input.ldfParams,\n                                        input.ldfState\n                                    )\n                            )\n                            : (\n                                naiveSwapAmountIn + cumulativeAmount - currentActiveBalance1,\n                                currentActiveBalance0 + naiveSwapAmountOut\n                                    - input.liquidityDensityFunction.cumulativeAmount0(\n                                        input.key,\n                                        updatedRoundedTick,\n                                        input.totalLiquidity,\n                                        input.arithmeticMeanTick,\n                                        updatedTick,\n                                        input.ldfParams,\n                                        input.ldfState\n                                    )\n                            );\n                    } else {\n                        (inputAmount, outputAmount) = zeroForOne\n                            ? (\n                                input.liquidityDensityFunction.cumulativeAmount0(\n                                    input.key,\n                                    updatedRoundedTick,\n                                    input.totalLiquidity,\n                                    input.arithmeticMeanTick,\n                                    updatedTick,\n                                    input.ldfParams,\n                                    input.ldfState\n                                ) - naiveSwapAmountOut - currentActiveBalance0,\n                                currentActiveBalance1 - naiveSwapAmountIn - cumulativeAmount\n                            )\n                            : (\n                                input.liquidityDensityFunction.cumulativeAmount1(\n                                    input.key,\n                                    updatedRoundedTick - input.key.tickSpacing,\n                                    input.totalLiquidity,\n                                    input.arithmeticMeanTick,\n                                    updatedTick,\n                                    input.ldfParams,\n                                    input.ldfState\n                                ) - naiveSwapAmountOut - currentActiveBalance1,\n                                currentActiveBalance0 - naiveSwapAmountIn - cumulativeAmount\n                            );\n                    }\n\n                    return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n                }\n            }\n\n            // liquidity is insufficient to handle all of the input/output tokens\n            // or the sqrt price limit has been reached\n            updatedSqrtPriceX96 = sqrtPriceLimitX96;\n            updatedTick = TickMath.getTickAtSqrtPrice(sqrtPriceLimitX96);\n\n            (, uint256 totalDensity0X96, uint256 totalDensity1X96,,,) = queryLDF({\n                key: input.key,\n                sqrtPriceX96: updatedSqrtPriceX96,\n                tick: updatedTick,\n                arithmeticMeanTick: input.arithmeticMeanTick,\n                ldf: input.liquidityDensityFunction,\n                ldfParams: input.ldfParams,\n                ldfState: input.ldfState,\n                balance0: 0,\n                balance1: 0\n            });\n            (uint256 updatedActiveBalance0, uint256 updatedActiveBalance1) = (\n                totalDensity0X96.fullMulDivUp(input.totalLiquidity, Q96),\n                totalDensity1X96.fullMulDivUp(input.totalLiquidity, Q96)\n            );\n            (inputAmount, outputAmount) = zeroForOne\n                ? (\n                    updatedActiveBalance0 - currentActiveBalance0,\n                    currentActiveBalance1 < updatedActiveBalance1 ? 0 : currentActiveBalance1 - updatedActiveBalance1\n                )\n                : (\n                    updatedActiveBalance1 - currentActiveBalance1,\n                    currentActiveBalance0 < updatedActiveBalance0 ? 0 : currentActiveBalance0 - updatedActiveBalance0\n                );\n\n            if (exactIn) {\n                uint256 inputAmountSpecified = uint256(-amountSpecified);\n                if (inputAmount > inputAmountSpecified && inputAmount < inputAmountSpecified + 3) {\n                    // if it's an exact input swap and inputAmount is greater than the specified input amount by 1 or 2 wei,\n                    // round down to the specified input amount to avoid reverts. this assumes that it's not feasible to\n                    // extract significant value from the pool if each swap can at most extract 2 wei.\n                    inputAmount = inputAmountSpecified;\n                }\n            }\n        }\n    }\n}\n",
        "BunniZone.sol": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"flood-contracts/src/interfaces/IZone.sol\";\nimport \"flood-contracts/src/interfaces/IFloodPlain.sol\";\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/src/types/PoolId.sol\";\n\nimport {IAmAmm} from \"biddog/interfaces/IAmAmm.sol\";\n\nimport {Ownable} from \"./base/Ownable.sol\";\nimport {IBunniHook} from \"./interfaces/IBunniHook.sol\";\nimport {IBunniZone} from \"./interfaces/IBunniZone.sol\";\n\ncontract BunniZone is IBunniZone, Ownable {\n    using PoolIdLibrary for PoolKey;\n\n    mapping(address => bool) public isWhitelisted;\n\n    constructor(address initialOwner) {\n        _initializeOwner(initialOwner);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    function setIsWhitelisted(address account, bool isWhitelisted_) external onlyOwner {\n        isWhitelisted[account] = isWhitelisted_;\n        emit SetIsWhitelisted(account, isWhitelisted_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Flood IZone compliance\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IZone\n    /// @dev Only allows whitelisted fulfillers and am-AMM manager of the pool to fulfill orders.\n    function validate(IFloodPlain.Order calldata order, address fulfiller) external view returns (bool) {\n        // extract PoolKey from order's preHooks\n        IBunniHook.RebalanceOrderHookArgs memory hookArgs =\n            abi.decode(order.preHooks[0].data[4:], (IBunniHook.RebalanceOrderHookArgs));\n        PoolKey memory key = hookArgs.key;\n        PoolId id = key.toId();\n\n        // query the hook for the am-AMM manager\n        IAmAmm amAmm = IAmAmm(address(key.hooks));\n        IAmAmm.Bid memory topBid = amAmm.getTopBid(id);\n\n        // allow fulfiller if they are whitelisted or if they are the am-AMM manager\n        return isWhitelisted[fulfiller] || topBid.manager == fulfiller;\n    }\n\n    /// @inheritdoc IZone\n    function fee(IFloodPlain.Order calldata, address) external pure returns (IZone.FeeInfo memory) {\n        return IZone.FeeInfo(address(0), 0);\n    }\n}\n",
        "QueryLDF.sol": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.19;\n\nimport \"forge-std/console2.sol\";\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {roundTick} from \"./Math.sol\";\nimport {Q96} from \"../base/Constants.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\nusing FixedPointMathLib for uint256;\n\n/// @notice Queries the liquidity density function for the given pool and tick\n/// @param key The pool key\n/// @param sqrtPriceX96 The current sqrt price of the pool\n/// @param tick The current tick of the pool\n/// @param arithmeticMeanTick The TWAP oracle value\n/// @param ldf The liquidity density function\n/// @param ldfParams The parameters for the liquidity density function\n/// @param ldfState The current state of the liquidity density function\n/// @param balance0 The balance of token0 in the pool\n/// @param balance1 The balance of token1 in the pool\n/// @return totalLiquidity The total liquidity in the pool\n/// @return totalDensity0X96 The total density of token0 in the pool, scaled by Q96\n/// @return totalDensity1X96 The total density of token1 in the pool, scaled by Q96\n/// @return liquidityDensityOfRoundedTickX96 The liquidity density of the rounded tick, scaled by Q96\n/// @return newLdfState The new state of the liquidity density function\n/// @return shouldSurge Whether the pool should surge\nfunction queryLDF(\n    PoolKey memory key,\n    uint160 sqrtPriceX96,\n    int24 tick,\n    int24 arithmeticMeanTick,\n    ILiquidityDensityFunction ldf,\n    bytes32 ldfParams,\n    bytes32 ldfState,\n    uint256 balance0,\n    uint256 balance1\n)\n    view\n    returns (\n        uint256 totalLiquidity,\n        uint256 totalDensity0X96,\n        uint256 totalDensity1X96,\n        uint256 liquidityDensityOfRoundedTickX96,\n        bytes32 newLdfState,\n        bool shouldSurge\n    )\n{\n    (int24 roundedTick, int24 nextRoundedTick) = roundTick(tick, key.tickSpacing);\n    (uint160 roundedTickSqrtRatio, uint160 nextRoundedTickSqrtRatio) =\n        (TickMath.getSqrtPriceAtTick(roundedTick), TickMath.getSqrtPriceAtTick(nextRoundedTick));\n    uint256 density0RightOfRoundedTickX96;\n    uint256 density1LeftOfRoundedTickX96;\n    (\n        liquidityDensityOfRoundedTickX96,\n        density0RightOfRoundedTickX96,\n        density1LeftOfRoundedTickX96,\n        newLdfState,\n        shouldSurge\n    ) = ldf.query(key, roundedTick, arithmeticMeanTick, tick, ldfParams, ldfState);\n\n    (uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) = LiquidityAmounts.getAmountsForLiquidity(\n        sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio, uint128(liquidityDensityOfRoundedTickX96), false\n    );\n    totalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\n    totalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\n    uint256 totalLiquidityEstimate0 =\n        (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96, totalDensity0X96);\n    uint256 totalLiquidityEstimate1 =\n        (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96, totalDensity1X96);\n    if (totalLiquidityEstimate0 == 0) {\n        totalLiquidity = totalLiquidityEstimate1;\n    } else if (totalLiquidityEstimate1 == 0) {\n        totalLiquidity = totalLiquidityEstimate0;\n    } else {\n        totalLiquidity = FixedPointMathLib.min(totalLiquidityEstimate0, totalLiquidityEstimate1);\n    }\n}\n",
        "BunniHubLogic.sol": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.19;\n\nimport {console2} from \"forge-std/console2.sol\";\n\nimport {IAmAmm} from \"biddog/interfaces/IAmAmm.sol\";\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {LibMulticaller} from \"multicaller/LibMulticaller.sol\";\n\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\n\nimport \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport \"@uniswap/v4-core/src/libraries/SqrtPriceMath.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency, CurrencyLibrary} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IPoolManager, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {SSTORE2} from \"solady/utils/SSTORE2.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {WETH} from \"solady/tokens/WETH.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./Math.sol\";\nimport \"./QueryTWAP.sol\";\nimport \"./VaultMath.sol\";\nimport \"../base/Errors.sol\";\nimport \"../base/Constants.sol\";\nimport \"../types/PoolState.sol\";\nimport \"../base/SharedStructs.sol\";\nimport \"../interfaces/IBunniHub.sol\";\nimport {BunniHub} from \"../BunniHub.sol\";\nimport {HookletLib} from \"./HookletLib.sol\";\nimport {queryLDF} from \"../lib/QueryLDF.sol\";\nimport {BunniToken} from \"../BunniToken.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IHooklet} from \"../interfaces/IHooklet.sol\";\nimport {IBunniHook} from \"../interfaces/IBunniHook.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {IBunniToken} from \"../interfaces/IBunniToken.sol\";\nimport {AdditionalCurrencyLibrary} from \"./AdditionalCurrencyLib.sol\";\n\nlibrary BunniHubLogic {\n    using SSTORE2 for bytes;\n    using SSTORE2 for address;\n    using SafeCastLib for int256;\n    using SafeCastLib for uint256;\n    using HookletLib for IHooklet;\n    using PoolIdLibrary for PoolKey;\n    using SafeTransferLib for address;\n    using CurrencyLibrary for Currency;\n    using FixedPointMathLib for uint128;\n    using FixedPointMathLib for uint256;\n    using ClonesWithImmutableArgs for address;\n    using AdditionalCurrencyLibrary for Currency;\n\n    struct Env {\n        WETH weth;\n        IPermit2 permit2;\n        IPoolManager poolManager;\n        IBunniToken bunniTokenImplementation;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Deposit\n    /// -----------------------------------------------------------------------\n\n    function deposit(HubStorage storage s, Env calldata env, IBunniHub.DepositParams calldata params)\n        external\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n        PoolId poolId = params.poolKey.toId();\n        PoolState memory state = getPoolState(s, poolId);\n\n        /// -----------------------------------------------------------------------\n        /// Hooklet call\n        /// -----------------------------------------------------------------------\n\n        state.hooklet.hookletBeforeDeposit(msgSender, params);\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        IBunniHook hook = IBunniHook(address(params.poolKey.hooks));\n        (uint160 sqrtPriceX96, int24 currentTick,,) = hook.slot0s(poolId);\n        hook.updateStateMachine(poolId); // trigger am-AMM state machine update to avoid sandwiching rent burns\n\n        DepositLogicReturnData memory depositReturnData = _depositLogic(\n            DepositLogicInputData({\n                state: state,\n                params: params,\n                poolId: poolId,\n                currentTick: currentTick,\n                sqrtPriceX96: sqrtPriceX96\n            })\n        );\n        uint256 reserveAmount0 = depositReturnData.reserveAmount0;\n        uint256 reserveAmount1 = depositReturnData.reserveAmount1;\n        amount0 = depositReturnData.amount0;\n        amount1 = depositReturnData.amount1;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // update raw balances\n        (uint256 rawAmount0, uint256 rawAmount1) = (\n            address(state.vault0) != address(0) ? amount0 - reserveAmount0 : amount0,\n            address(state.vault1) != address(0) ? amount1 - reserveAmount1 : amount1\n        );\n        (rawAmount0, rawAmount1) = abi.decode(\n            env.poolManager.unlock(\n                abi.encode(\n                    BunniHub.UnlockCallbackType.DEPOSIT,\n                    abi.encode(\n                        BunniHub.DepositCallbackInputData({\n                            user: msgSender,\n                            poolKey: params.poolKey,\n                            msgValue: msg.value,\n                            rawAmount0: rawAmount0,\n                            rawAmount1: rawAmount1\n                        })\n                    )\n                )\n            ),\n            (uint256, uint256)\n        );\n\n        // update reserves\n        if (address(state.vault0) != address(0) && reserveAmount0 != 0) {\n            (uint256 reserveChange, uint256 reserveChangeInUnderlying) = _depositVaultReserve(\n                env, reserveAmount0, params.poolKey.currency0, state.vault0, msgSender, params.vaultFee0\n            );\n            s.reserve0[poolId] = state.reserve0 + reserveChange;\n\n            // use actual withdrawable value to handle vaults with withdrawal fees\n            reserveAmount0 = reserveChangeInUnderlying;\n        }\n        if (address(state.vault1) != address(0) && reserveAmount1 != 0) {\n            (uint256 reserveChange, uint256 reserveChangeInUnderlying) = _depositVaultReserve(\n                env, reserveAmount1, params.poolKey.currency1, state.vault1, msgSender, params.vaultFee1\n            );\n            s.reserve1[poolId] = state.reserve1 + reserveChange;\n\n            // use actual withdrawable value to handle vaults with withdrawal fees\n            reserveAmount1 = reserveChangeInUnderlying;\n        }\n\n        // mint shares using actual token amounts\n        shares = _mintShares(\n            state.bunniToken,\n            params.recipient,\n            address(state.vault0) != address(0) ? rawAmount0 + reserveAmount0 : rawAmount0,\n            depositReturnData.balance0,\n            address(state.vault1) != address(0) ? rawAmount1 + reserveAmount1 : rawAmount1,\n            depositReturnData.balance1,\n            params.referrer\n        );\n\n        if (amount0 < params.amount0Min || amount1 < params.amount1Min) {\n            revert BunniHub__SlippageTooHigh();\n        }\n\n        // refund excess ETH\n        if (params.poolKey.currency0.isNative()) {\n            if (address(this).balance != 0) {\n                params.refundRecipient.safeTransferETH(\n                    FixedPointMathLib.min(address(this).balance, msg.value - amount0)\n                );\n            }\n        } else if (params.poolKey.currency1.isNative()) {\n            if (address(this).balance != 0) {\n                params.refundRecipient.safeTransferETH(\n                    FixedPointMathLib.min(address(this).balance, msg.value - amount1)\n                );\n            }\n        }\n\n        // emit event\n        emit IBunniHub.Deposit(msgSender, params.recipient, poolId, amount0, amount1, shares);\n\n        /// -----------------------------------------------------------------------\n        /// Hooklet call\n        /// -----------------------------------------------------------------------\n\n        state.hooklet.hookletAfterDeposit(\n            msgSender, params, IHooklet.DepositReturnData({shares: shares, amount0: amount0, amount1: amount1})\n        );\n    }\n\n    struct DepositLogicInputData {\n        PoolState state;\n        IBunniHub.DepositParams params;\n        PoolId poolId;\n        int24 currentTick;\n        uint160 sqrtPriceX96;\n    }\n\n    struct DepositLogicReturnData {\n        uint256 reserveAmount0;\n        uint256 reserveAmount1;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 balance0;\n        uint256 balance1;\n    }\n\n    /// @dev Separated to avoid stack too deep error\n    function _depositLogic(DepositLogicInputData memory inputData)\n        private\n        returns (DepositLogicReturnData memory returnData)\n    {\n        // query existing assets\n        // assets = urrent tick tokens + reserve tokens + pool credits\n        (uint256 reserveBalance0, uint256 reserveBalance1) = (\n            getReservesInUnderlying(inputData.state.reserve0, inputData.state.vault0),\n            getReservesInUnderlying(inputData.state.reserve1, inputData.state.vault1)\n        );\n        (returnData.balance0, returnData.balance1) =\n            (inputData.state.rawBalance0 + reserveBalance0, inputData.state.rawBalance1 + reserveBalance1);\n\n        // update TWAP oracle and optionally observe\n        bool requiresLDF = returnData.balance0 == 0 && returnData.balance1 == 0;\n\n        if (requiresLDF) {\n            // use LDF to initialize token proportions\n\n            // compute total liquidity & token densities\n            bool useTwap = inputData.state.twapSecondsAgo != 0;\n            int24 arithmeticMeanTick =\n                useTwap ? queryTwap(inputData.params.poolKey, inputData.state.twapSecondsAgo) : int24(0);\n            IBunniHook hook = IBunniHook(address(inputData.params.poolKey.hooks));\n            bytes32 ldfState = inputData.state.statefulLdf ? hook.ldfStates(inputData.poolId) : bytes32(0);\n            (uint256 totalLiquidity, uint256 totalDensity0X96, uint256 totalDensity1X96,, bytes32 newLdfState,) =\n            queryLDF({\n                key: inputData.params.poolKey,\n                sqrtPriceX96: inputData.sqrtPriceX96,\n                tick: inputData.currentTick,\n                arithmeticMeanTick: arithmeticMeanTick,\n                ldf: inputData.state.liquidityDensityFunction,\n                ldfParams: inputData.state.ldfParams,\n                ldfState: ldfState,\n                balance0: inputData.params.amount0Desired, // use amount0Desired since we're initializing liquidity\n                balance1: inputData.params.amount1Desired // use amount1Desired since we're initializing liquidity\n            });\n            if (inputData.state.statefulLdf) hook.updateLdfState(inputData.poolId, newLdfState);\n\n            // compute token amounts to add\n            (returnData.amount0, returnData.amount1) =\n                (totalLiquidity.mulDivUp(totalDensity0X96, Q96), totalLiquidity.mulDivUp(totalDensity1X96, Q96));\n\n            // sanity check against desired amounts\n            // the amounts can exceed the desired amounts due to math errors\n            if (\n                returnData.amount0 > inputData.params.amount0Desired\n                    || returnData.amount1 > inputData.params.amount1Desired\n            ) {\n                // scale down amounts and take minimum\n                if (returnData.amount0 == 0) {\n                    returnData.amount1 = inputData.params.amount1Desired;\n                } else if (returnData.amount1 == 0) {\n                    returnData.amount0 = inputData.params.amount0Desired;\n                } else {\n                    // both are non-zero\n                    (returnData.amount0, returnData.amount1) = (\n                        FixedPointMathLib.min(\n                            inputData.params.amount0Desired,\n                            returnData.amount0.mulDiv(inputData.params.amount1Desired, returnData.amount1)\n                        ),\n                        FixedPointMathLib.min(\n                            inputData.params.amount1Desired,\n                            returnData.amount1.mulDiv(inputData.params.amount0Desired, returnData.amount0)\n                        )\n                    );\n                }\n            }\n\n            // update token amounts to deposit into vaults\n            (returnData.reserveAmount0, returnData.reserveAmount1) = (\n                returnData.amount0\n                    - returnData.amount0.mulDiv(inputData.state.targetRawTokenRatio0, RAW_TOKEN_RATIO_BASE),\n                returnData.amount1\n                    - returnData.amount1.mulDiv(inputData.state.targetRawTokenRatio1, RAW_TOKEN_RATIO_BASE)\n            );\n        } else {\n            // already initialized liquidity shape\n            // simply add tokens at the current ratio\n            // need to update: reserveAmount0, reserveAmount1, amount0, amount1\n\n            // compute amount0 and amount1 such that the ratio is the same as the current ratio\n            uint256 amount0Desired = inputData.params.amount0Desired;\n            uint256 amount1Desired = inputData.params.amount1Desired;\n            uint256 balance0 = returnData.balance0;\n            uint256 balance1 = returnData.balance1;\n\n            returnData.amount0 = balance1 == 0\n                ? amount0Desired\n                : FixedPointMathLib.min(amount0Desired, amount1Desired.mulDiv(balance0, balance1));\n            returnData.amount1 = balance0 == 0\n                ? amount1Desired\n                : FixedPointMathLib.min(amount1Desired, amount0Desired.mulDiv(balance1, balance0));\n\n            returnData.reserveAmount0 = balance0 == 0 ? 0 : returnData.amount0.mulDiv(reserveBalance0, balance0);\n            returnData.reserveAmount1 = balance1 == 0 ? 0 : returnData.amount1.mulDiv(reserveBalance1, balance1);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Withdraw\n    /// -----------------------------------------------------------------------\n\n    function queueWithdraw(HubStorage storage s, IBunniHub.QueueWithdrawParams calldata params) external {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        PoolId id = params.poolKey.toId();\n        IBunniToken bunniToken = _getBunniTokenOfPool(s, id);\n        if (address(bunniToken) == address(0)) revert BunniHub__BunniTokenNotInitialized();\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // update queued withdrawal\n        // any existing queued amount simply uses the updated delay\n        // use unchecked to get unlockTimestamp to overflow back to 0 if overflow occurs\n        // which is fine since we only care about relative time\n        unchecked {\n            s.queuedWithdrawals[id][msgSender] = QueuedWithdrawal({\n                shareAmount: params.shares,\n                unlockTimestamp: uint56(block.timestamp) + WITHDRAW_DELAY\n            });\n        }\n\n        emit IBunniHub.QueueWithdraw(msgSender, id, params.shares);\n    }\n\n    function withdraw(HubStorage storage s, Env calldata env, IBunniHub.WithdrawParams calldata params)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        if (params.shares == 0) revert BunniHub__ZeroInput();\n\n        PoolId poolId = params.poolKey.toId();\n        PoolState memory state = getPoolState(s, poolId);\n        IBunniHook hook = IBunniHook(address(params.poolKey.hooks));\n\n        IAmAmm.Bid memory topBid = hook.getTopBidWrite(poolId);\n        if (hook.getAmAmmEnabled(poolId) && topBid.manager != address(0) && !params.useQueuedWithdrawal) {\n            revert BunniHub__NeedToUseQueuedWithdrawal();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Hooklet call\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n        state.hooklet.hookletBeforeWithdraw(msgSender, params);\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        uint256 currentTotalSupply = state.bunniToken.totalSupply();\n        uint256 shares;\n\n        // burn shares\n        if (params.useQueuedWithdrawal) {\n            // use queued withdrawal\n            // need to withdraw the full queued amount\n            QueuedWithdrawal memory queued = s.queuedWithdrawals[poolId][msgSender];\n            if (queued.shareAmount == 0 || queued.unlockTimestamp == 0) revert BunniHub__QueuedWithdrawalNonexistent();\n            if (block.timestamp < queued.unlockTimestamp) revert BunniHub__QueuedWithdrawalNotReady();\n            if (queued.unlockTimestamp + WITHDRAW_GRACE_PERIOD < block.timestamp) revert BunniHub__GracePeriodExpired();\n            shares = queued.shareAmount;\n            s.queuedWithdrawals[poolId][msgSender].shareAmount = 0; // don't delete the struct to save gas later\n        } else {\n            shares = params.shares;\n        }\n        state.bunniToken.burn(msgSender, shares);\n        // at this point of execution we know shares <= currentTotalSupply\n        // since otherwise the burn() call would've reverted\n\n        // compute token amount to withdraw and the component amounts\n        uint256 reserveAmount0 =\n            getReservesInUnderlying(state.reserve0.mulDiv(shares, currentTotalSupply), state.vault0);\n        uint256 reserveAmount1 =\n            getReservesInUnderlying(state.reserve1.mulDiv(shares, currentTotalSupply), state.vault1);\n        uint256 rawAmount0 = state.rawBalance0.mulDiv(shares, currentTotalSupply);\n        uint256 rawAmount1 = state.rawBalance1.mulDiv(shares, currentTotalSupply);\n        amount0 = reserveAmount0 + rawAmount0;\n        amount1 = reserveAmount1 + rawAmount1;\n\n        if (amount0 < params.amount0Min || amount1 < params.amount1Min) {\n            revert BunniHub__SlippageTooHigh();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // withdraw reserve tokens\n        if (address(state.vault0) != address(0) && reserveAmount0 != 0) {\n            // vault used\n            // withdraw reserves\n            uint256 reserveChange = _withdrawVaultReserve(\n                reserveAmount0, params.poolKey.currency0, state.vault0, params.recipient, env.weth\n            );\n            s.reserve0[poolId] = state.reserve0 - reserveChange;\n        }\n        if (address(state.vault1) != address(0) && reserveAmount1 != 0) {\n            // vault used\n            // withdraw from reserves\n            uint256 reserveChange = _withdrawVaultReserve(\n                reserveAmount1, params.poolKey.currency1, state.vault1, params.recipient, env.weth\n            );\n            s.reserve1[poolId] = state.reserve1 - reserveChange;\n        }\n\n        // withdraw raw tokens\n        env.poolManager.unlock(\n            abi.encode(\n                BunniHub.UnlockCallbackType.WITHDRAW,\n                abi.encode(params.recipient, params.poolKey, rawAmount0, rawAmount1)\n            )\n        );\n\n        emit IBunniHub.Withdraw(msgSender, params.recipient, poolId, amount0, amount1, shares);\n\n        /// -----------------------------------------------------------------------\n        /// Hooklet call\n        /// -----------------------------------------------------------------------\n\n        state.hooklet.hookletAfterWithdraw(\n            msgSender, params, IHooklet.WithdrawReturnData({amount0: amount0, amount1: amount1})\n        );\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Deploy Bunni Token\n    /// -----------------------------------------------------------------------\n\n    function deployBunniToken(HubStorage storage s, Env calldata env, IBunniHub.DeployBunniTokenParams calldata params)\n        external\n        returns (IBunniToken token, PoolKey memory key)\n    {\n        /// -----------------------------------------------------------------------\n        /// Verification\n        /// -----------------------------------------------------------------------\n\n        // each Uniswap v4 pool corresponds to a single BunniToken\n        // since Univ4 pool key is deterministic based on poolKey, we use dynamic fee so that the lower 20 bits of `poolKey.fee` is used\n        // as nonce to differentiate the BunniTokens\n        // each \"subspace\" has its own nonce that's incremented whenever a BunniToken is deployed with the same tokens & tick spacing & hooks\n        // nonce can be at most 1e6 after which the deployment will fail\n        bytes32 bunniSubspace =\n            keccak256(abi.encode(params.currency0, params.currency1, params.tickSpacing, params.hooks));\n        uint24 nonce_ = s.nonce[bunniSubspace];\n        if (nonce_ > MAX_NONCE) revert BunniHub__MaxNonceReached();\n\n        // ensure LDF params are valid\n        key = PoolKey({\n            currency0: params.currency0,\n            currency1: params.currency1,\n            fee: nonce_,\n            tickSpacing: params.tickSpacing,\n            hooks: IHooks(address(params.hooks))\n        });\n        if (address(params.liquidityDensityFunction) == address(0)) revert BunniHub__LDFCannotBeZero();\n        if (!params.liquidityDensityFunction.isValidParams(key, params.twapSecondsAgo, params.ldfParams)) {\n            revert BunniHub__InvalidLDFParams();\n        }\n\n        // ensure hook params are valid\n        if (address(params.hooks) == address(0)) revert BunniHub__HookCannotBeZero();\n        if (!params.hooks.isValidParams(params.hookParams)) revert BunniHub__InvalidHookParams();\n\n        // validate vaults\n        _validateVault(params.vault0, params.currency0, env.weth);\n        _validateVault(params.vault1, params.currency1, env.weth);\n\n        // validate raw token ratio bounds\n        if (\n            (\n                address(params.vault0) != address(0)\n                    && !(\n                        (params.minRawTokenRatio0 <= params.targetRawTokenRatio0)\n                            && (params.targetRawTokenRatio0 <= params.maxRawTokenRatio0)\n                            && (params.maxRawTokenRatio0 <= RAW_TOKEN_RATIO_BASE)\n                    )\n            )\n                || (\n                    address(params.vault1) != address(0)\n                        && !(\n                            (params.minRawTokenRatio1 <= params.targetRawTokenRatio1)\n                                && (params.targetRawTokenRatio1 <= params.maxRawTokenRatio1)\n                                && (params.maxRawTokenRatio1 <= RAW_TOKEN_RATIO_BASE)\n                        )\n                )\n        ) {\n            revert BunniHub__InvalidRawTokenRatioBounds();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Hooklet call\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n        params.hooklet.hookletBeforeInitialize(msgSender, params);\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // deploy BunniToken\n        token = IBunniToken(\n            address(env.bunniTokenImplementation).clone3({\n                data: abi.encodePacked(\n                    address(this), params.currency0, params.currency1, params.name, params.symbol, env.poolManager\n                ),\n                salt: keccak256(abi.encodePacked(msgSender, params.salt)) // hash sender into salt to prevent griefing via frontrunning\n            })\n        );\n        token.initialize(params.owner, params.metadataURI);\n\n        PoolId poolId = key.toId();\n        s.poolIdOfBunniToken[token] = poolId;\n\n        // increment nonce\n        s.nonce[bunniSubspace] = nonce_ + 1;\n\n        // set immutable params\n        bytes memory immutableParams = abi.encodePacked(\n            params.liquidityDensityFunction,\n            token,\n            params.twapSecondsAgo,\n            params.ldfParams,\n            params.vault0,\n            params.vault1,\n            params.statefulLdf,\n            params.minRawTokenRatio0,\n            params.targetRawTokenRatio0,\n            params.maxRawTokenRatio0,\n            params.minRawTokenRatio1,\n            params.targetRawTokenRatio1,\n            params.maxRawTokenRatio1\n        );\n        immutableParams = bytes.concat(\n            immutableParams, abi.encodePacked(params.hooklet, params.hookParams.length.toUint16(), params.hookParams)\n        );\n        s.poolState[poolId].immutableParamsPointer = immutableParams.write();\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // initialize Uniswap v4 pool\n        env.poolManager.initialize(key, params.sqrtPriceX96, abi.encode(params.twapSecondsAgo, params.hookParams));\n\n        emit IBunniHub.NewBunni(token, poolId);\n\n        /// -----------------------------------------------------------------------\n        /// Hooklet call\n        /// -----------------------------------------------------------------------\n\n        params.hooklet.hookletAfterInitialize(\n            msgSender, params, IHooklet.InitializeReturnData({bunniToken: token, key: key})\n        );\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Utilities\n    /// -----------------------------------------------------------------------\n\n    /// @notice Mints share tokens to the recipient based on the amount of liquidity added.\n    /// @param shareToken The BunniToken to mint\n    /// @param recipient The recipient of the share tokens\n    /// @param addedAmount0 The amount of token0 added to the pool\n    /// @param existingAmount0 The existing amount of token0 in the pool\n    /// @param addedAmount1 The amount of token1 added to the pool\n    /// @param existingAmount1 The existing amount of token1 in the pool\n    /// @param referrer The referrer of the liquidity provider\n    /// @return shares The amount of share tokens minted to the sender.\n    function _mintShares(\n        IBunniToken shareToken,\n        address recipient,\n        uint256 addedAmount0,\n        uint256 existingAmount0,\n        uint256 addedAmount1,\n        uint256 existingAmount1,\n        uint24 referrer\n    ) internal returns (uint256 shares) {\n        uint256 existingShareSupply = shareToken.totalSupply();\n        if (existingShareSupply == 0) {\n            // no existing shares, just give WAD\n            shares = WAD - MIN_INITIAL_SHARES;\n            // prevent first staker from stealing funds of subsequent stakers\n            // see https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens\n            shareToken.mint(address(0), MIN_INITIAL_SHARES, 0);\n        } else {\n            // given that the position may become single-sided, we need to handle the case where one of the existingAmount values is zero\n            if (existingAmount0 == 0 && existingAmount1 == 0) revert BunniHub__ZeroSharesMinted();\n            shares = FixedPointMathLib.min(\n                existingAmount0 == 0 ? type(uint256).max : existingShareSupply.mulDiv(addedAmount0, existingAmount0),\n                existingAmount1 == 0 ? type(uint256).max : existingShareSupply.mulDiv(addedAmount1, existingAmount1)\n            );\n            if (shares == 0) revert BunniHub__ZeroSharesMinted();\n        }\n\n        // mint shares to sender\n        shareToken.mint(recipient, shares, referrer);\n    }\n\n    /// @dev Deposits tokens into a vault.\n    /// @param env The environment vars.\n    /// @param amount The amount to deposit.\n    /// @param currency The currency to deposit.\n    /// @param vault The vault to deposit into.\n    /// @param user The user to deposit tokens from.\n    /// @param vaultFee The vault's withdrawal fee, in 18 decimals.\n    /// @return reserveChange The change in reserve balance.\n    /// @return reserveChangeInUnderlying The change in reserve balance in underlying tokens.\n    function _depositVaultReserve(\n        Env calldata env,\n        uint256 amount,\n        Currency currency,\n        ERC4626 vault,\n        address user,\n        uint256 vaultFee\n    ) internal returns (uint256 reserveChange, uint256 reserveChangeInUnderlying) {\n        // use the pre-fee amount to ensure `amount` is the amount of tokens\n        // that we'll be able to withdraw from the vault\n        // it's safe to rely on the user provided fee value here\n        // since if user provides fee=0 when it's actually not the amount of bunni shares minted goes down\n        // and if user provide fee!=0 when the fee is some other value (0 or non-zero) the validation will revert\n        uint256 postFeeAmount = amount; // cache amount to use for validation later\n        amount = amount.divWadUp(WAD - vaultFee);\n\n        IERC20 token;\n        if (currency.isNative()) {\n            // wrap ETH\n            // no need to pull tokens from user since WETH is already in the contract\n            env.weth.deposit{value: amount}();\n            token = IERC20(address(env.weth));\n        } else {\n            // normal ERC20\n            token = IERC20(Currency.unwrap(currency));\n            env.permit2.transferFrom(user, address(this), amount.toUint160(), address(token));\n        }\n\n        // do vault deposit\n        address(token).safeApproveWithRetry(address(vault), amount);\n        reserveChange = vault.deposit(amount, address(this));\n        reserveChangeInUnderlying = vault.previewRedeem(reserveChange);\n\n        // validate vault fee value\n        if (\n            vaultFee != 0 && dist(reserveChangeInUnderlying, postFeeAmount) > 1 // avoid reverting from normal rounding error\n                && percentDelta(reserveChangeInUnderlying, postFeeAmount) > MAX_VAULT_FEE_ERROR\n        ) {\n            revert BunniHub__VaultFeeIncorrect();\n        }\n    }\n\n    /// @dev Withdraws tokens from a vault.\n    /// @param amount The amount to withdraw.\n    /// @param currency The currency to withdraw.\n    /// @param vault The vault to withdraw from.\n    /// @param user The user to withdraw tokens to.\n    /// @param weth The WETH contract.\n    /// @return reserveChange The change in reserve balance.\n    function _withdrawVaultReserve(uint256 amount, Currency currency, ERC4626 vault, address user, WETH weth)\n        internal\n        returns (uint256 reserveChange)\n    {\n        if (currency.isNative()) {\n            // withdraw WETH from vault to address(this)\n            reserveChange = vault.withdraw(amount, address(this), address(this));\n\n            // burn WETH for ETH\n            weth.withdraw(amount);\n\n            // transfer ETH to user\n            user.safeTransferETH(amount);\n        } else {\n            // normal ERC20\n            reserveChange = vault.withdraw(amount, user, address(this));\n        }\n    }\n\n    function _validateVault(ERC4626 vault, Currency currency, WETH weth) internal view {\n        // if vault is set, make sure the vault asset matches the currency\n        // if the currency is ETH, the vault asset must be WETH\n        if (address(vault) != address(0)) {\n            bool isNative = currency.isNative();\n            address vaultAsset = address(vault.asset());\n            if ((isNative && vaultAsset != address(weth)) || (!isNative && vaultAsset != Currency.unwrap(currency))) {\n                revert BunniHub__VaultAssetMismatch();\n            }\n        }\n    }\n\n    function _getBunniTokenOfPool(HubStorage storage s, PoolId poolId) internal view returns (IBunniToken bunniToken) {\n        address ptr = s.poolState[poolId].immutableParamsPointer;\n        if (ptr == address(0)) return IBunniToken(address(0));\n        bytes memory rawValue = ptr.read({start: 20, end: 40});\n        bunniToken = IBunniToken(address(bytes20(rawValue)));\n    }\n}\n",
        "BunniHookLogic.sol": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.19;\n\nimport \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {SqrtPriceMath} from \"@uniswap/v4-core/src/libraries/SqrtPriceMath.sol\";\n\nimport \"flood-contracts/src/interfaces/IZone.sol\";\nimport \"flood-contracts/src/interfaces/IFloodPlain.sol\";\nimport \"flood-contracts/src/interfaces/IOnChainOrders.sol\";\n\nimport {IEIP712} from \"permit2/src/interfaces/IEIP712.sol\";\n\nimport {WETH} from \"solady/tokens/WETH.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./Math.sol\";\nimport \"./FeeMath.sol\";\nimport \"./VaultMath.sol\";\nimport \"./AmAmmPayload.sol\";\nimport \"../base/Errors.sol\";\nimport \"../base/Constants.sol\";\nimport \"../types/PoolState.sol\";\nimport \"../base/SharedStructs.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport \"../interfaces/IBunniHook.sol\";\nimport {queryLDF} from \"./QueryLDF.sol\";\nimport {BunniHook} from \"../BunniHook.sol\";\nimport {HookletLib} from \"./HookletLib.sol\";\nimport {BunniSwapMath} from \"./BunniSwapMath.sol\";\nimport {IHooklet} from \"../interfaces/IHooklet.sol\";\nimport {IBunniHub} from \"../interfaces/IBunniHub.sol\";\nimport {OrderHashMemory} from \"./OrderHashMemory.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\n\n/// @title BunniHookLogic\n/// @notice Split from BunniHook to reduce contract size below the Spurious Dragon limit\nlibrary BunniHookLogic {\n    using TickMath for *;\n    using SafeCastLib for *;\n    using SafeTransferLib for *;\n    using FixedPointMathLib for *;\n    using HookletLib for IHooklet;\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using Oracle for Oracle.Observation[MAX_CARDINALITY];\n\n    /// -----------------------------------------------------------------------\n    /// Structs\n    /// -----------------------------------------------------------------------\n\n    struct Env {\n        uint32 hookFeeModifier;\n        uint32 referralRewardModifier;\n        IBunniHub hub;\n        IPoolManager poolManager;\n        IFloodPlain floodPlain;\n        IZone floodZone;\n        WETH weth;\n        address permit2;\n    }\n\n    struct RebalanceInput {\n        PoolId id;\n        PoolKey key;\n        int24 updatedTick;\n        uint160 updatedSqrtPriceX96;\n        int24 arithmeticMeanTick;\n        bytes32 newLdfState;\n        DecodedHookParams hookParams;\n        Oracle.Observation updatedIntermediate;\n        uint32 updatedIndex;\n        uint32 updatedCardinality;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    function afterInitialize(\n        HookStorage storage s,\n        address caller,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData,\n        IBunniHub hub\n    ) external {\n        if (caller != address(hub)) revert BunniHook__Unauthorized(); // prevents non-BunniHub contracts from initializing a pool using this hook\n        PoolId id = key.toId();\n\n        // initialize slot0\n        s.slot0s[id] = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            lastSwapTimestamp: uint32(block.timestamp),\n            lastSurgeTimestamp: 0\n        });\n\n        // initialize first observation to be dated in the past\n        // so that we can immediately start querying the oracle\n        (uint24 twapSecondsAgo, bytes memory hookParams) = abi.decode(hookData, (uint24, bytes));\n        DecodedHookParams memory hookParamsDecoded = _decodeParams(hookParams);\n        uint32 maxTwapSecondsAgo = uint32(\n            FixedPointMathLib.max(\n                FixedPointMathLib.max(twapSecondsAgo, hookParamsDecoded.feeTwapSecondsAgo),\n                hookParamsDecoded.rebalanceTwapSecondsAgo\n            )\n        );\n        (s.states[id].intermediateObservation, s.states[id].cardinality, s.states[id].cardinalityNext) =\n            s.observations[id].initialize(uint32(block.timestamp - maxTwapSecondsAgo), tick);\n\n        // increase cardinality target based on maxTwapSecondsAgo\n        uint32 cardinalityNext =\n            (maxTwapSecondsAgo + (hookParamsDecoded.oracleMinInterval >> 1)) / hookParamsDecoded.oracleMinInterval + 1; // round up + 1\n        if (cardinalityNext > 1) {\n            uint32 cardinalityNextNew = s.observations[id].grow(1, cardinalityNext);\n            s.states[id].cardinalityNext = cardinalityNextNew;\n        }\n    }\n\n    function beforeSwap(\n        HookStorage storage s,\n        Env calldata env,\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params\n    )\n        external\n        returns (\n            bool useAmAmmFee,\n            address amAmmManager,\n            Currency amAmmFeeCurrency,\n            uint256 amAmmFeeAmount,\n            BeforeSwapDelta beforeSwapDelta\n        )\n    {\n        // skip 0 amount swaps\n        if (params.amountSpecified == 0) {\n            return (false, address(0), Currency.wrap(address(0)), 0, BeforeSwapDeltaLibrary.ZERO_DELTA);\n        }\n\n        // get pool state\n        PoolId id = key.toId();\n        Slot0 memory slot0 = s.slot0s[id];\n        PoolState memory bunniState = env.hub.poolState(id);\n\n        // hooklet call\n        (bool feeOverridden, uint24 feeOverride, bool priceOverridden, uint160 sqrtPriceX96Override) =\n            bunniState.hooklet.hookletBeforeSwap(sender, key, params);\n\n        // override price if needed\n        if (priceOverridden) {\n            slot0.sqrtPriceX96 = sqrtPriceX96Override;\n            slot0.tick = sqrtPriceX96Override.getTickAtSqrtPrice();\n        }\n\n        // ensure swap makes sense\n        if (\n            slot0.sqrtPriceX96 == 0\n                || (\n                    params.zeroForOne\n                        && (\n                            params.sqrtPriceLimitX96 >= slot0.sqrtPriceX96\n                                || params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_PRICE\n                        )\n                )\n                || (\n                    !params.zeroForOne\n                        && (\n                            params.sqrtPriceLimitX96 <= slot0.sqrtPriceX96\n                                || params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_PRICE\n                        )\n                ) || params.amountSpecified > type(int128).max || params.amountSpecified < type(int128).min\n        ) {\n            revert BunniHook__InvalidSwap();\n        }\n\n        // decode hook params\n        DecodedHookParams memory hookParams = _decodeParams(bunniState.hookParams);\n\n        // update TWAP oracle\n        // do it before we fetch the arithmeticMeanTick\n        // which doesn't change the result but gives us updated index and cardinality\n        (Oracle.Observation memory updatedIntermediate, uint32 updatedIndex, uint32 updatedCardinality) =\n            _updateOracle(s, id, slot0.tick, hookParams.oracleMinInterval);\n\n        // get TWAP values\n        int24 arithmeticMeanTick = bunniState.twapSecondsAgo != 0\n            ? _getTwap(s, id, slot0.tick, bunniState.twapSecondsAgo, updatedIntermediate, updatedIndex, updatedCardinality)\n            : int24(0);\n        int24 feeMeanTick = (\n            !feeOverridden && !hookParams.amAmmEnabled && hookParams.feeMin != hookParams.feeMax\n                && hookParams.feeQuadraticMultiplier != 0\n        )\n            ? _getTwap(\n                s, id, slot0.tick, hookParams.feeTwapSecondsAgo, updatedIntermediate, updatedIndex, updatedCardinality\n            )\n            : int24(0);\n\n        // compute total token balances\n        (uint256 reserveBalance0, uint256 reserveBalance1) = (\n            getReservesInUnderlying(bunniState.reserve0, bunniState.vault0),\n            getReservesInUnderlying(bunniState.reserve1, bunniState.vault1)\n        );\n        (uint256 balance0, uint256 balance1) =\n            (bunniState.rawBalance0 + reserveBalance0, bunniState.rawBalance1 + reserveBalance1);\n\n        // query the LDF to get total liquidity and token densities\n        bytes32 ldfState = bunniState.statefulLdf ? s.ldfStates[id] : bytes32(0);\n        (\n            uint256 totalLiquidity,\n            uint256 totalDensity0X96,\n            uint256 totalDensity1X96,\n            uint256 liquidityDensityOfRoundedTickX96,\n            bytes32 newLdfState,\n            bool shouldSurge\n        ) = queryLDF({\n            key: key,\n            sqrtPriceX96: slot0.sqrtPriceX96,\n            tick: slot0.tick,\n            arithmeticMeanTick: arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: ldfState,\n            balance0: balance0,\n            balance1: balance1\n        });\n        if (bunniState.statefulLdf) s.ldfStates[id] = newLdfState;\n\n        // check surge based on vault share prices\n        shouldSurge =\n            shouldSurge || _shouldSurgeFromVaults(s, id, bunniState, hookParams, reserveBalance0, reserveBalance1);\n\n        // compute swap result\n        (uint160 updatedSqrtPriceX96, int24 updatedTick, uint256 inputAmount, uint256 outputAmount) = BunniSwapMath\n            .computeSwap({\n            input: BunniSwapMath.BunniComputeSwapInput({\n                key: key,\n                totalLiquidity: totalLiquidity,\n                liquidityDensityOfRoundedTickX96: liquidityDensityOfRoundedTickX96,\n                totalDensity0X96: totalDensity0X96,\n                totalDensity1X96: totalDensity1X96,\n                sqrtPriceX96: slot0.sqrtPriceX96,\n                currentTick: slot0.tick,\n                liquidityDensityFunction: bunniState.liquidityDensityFunction,\n                arithmeticMeanTick: arithmeticMeanTick,\n                ldfParams: bunniState.ldfParams,\n                ldfState: ldfState,\n                swapParams: params\n            }),\n            balance0: balance0,\n            balance1: balance1\n        });\n\n        // ensure swap never moves price in the opposite direction\n        if (\n            (params.zeroForOne && updatedSqrtPriceX96 > slot0.sqrtPriceX96)\n                || (!params.zeroForOne && updatedSqrtPriceX96 < slot0.sqrtPriceX96)\n        ) {\n            revert BunniHook__InvalidSwap();\n        }\n\n        // update slot0\n        uint32 lastSurgeTimestamp = slot0.lastSurgeTimestamp;\n        if (shouldSurge) {\n            // use unchecked so that if uint32 overflows we wrap around\n            // overflows are ok since we only look at differences\n            unchecked {\n                uint32 timeSinceLastSwap = uint32(block.timestamp) - slot0.lastSwapTimestamp;\n                // if more than `surgeFeeAutostartThreshold` seconds has passed since the last swap,\n                // we pretend that the surge started at `slot0.lastSwapTimestamp + surgeFeeAutostartThreshold`\n                // so that the pool never gets stuck with a high fee\n                lastSurgeTimestamp = timeSinceLastSwap >= hookParams.surgeFeeAutostartThreshold\n                    ? slot0.lastSwapTimestamp + hookParams.surgeFeeAutostartThreshold\n                    : uint32(block.timestamp);\n            }\n        }\n        s.slot0s[id] = Slot0({\n            sqrtPriceX96: updatedSqrtPriceX96,\n            tick: updatedTick,\n            lastSwapTimestamp: uint32(block.timestamp),\n            lastSurgeTimestamp: lastSurgeTimestamp\n        });\n\n        // update am-AMM state\n        uint24 amAmmSwapFee;\n        bool amAmmEnableSurgeFee;\n        if (hookParams.amAmmEnabled) {\n            bytes7 payload;\n            IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n            (amAmmManager, payload) = (topBid.manager, topBid.payload);\n            uint24 swapFee0For1;\n            uint24 swapFee1For0;\n            (swapFee0For1, swapFee1For0, amAmmEnableSurgeFee) = decodeAmAmmPayload(payload);\n            amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n        }\n\n        // charge swap fee\n        // precedence:\n        // 1) am-AMM fee\n        // 2) hooklet override fee\n        // 3) dynamic fee\n        (Currency inputToken, Currency outputToken) =\n            params.zeroForOne ? (key.currency0, key.currency1) : (key.currency1, key.currency0);\n        uint24 swapFee;\n        uint256 swapFeeAmount;\n        bool exactIn = params.amountSpecified < 0;\n        useAmAmmFee = hookParams.amAmmEnabled && amAmmManager != address(0);\n        swapFee = useAmAmmFee\n            ? (\n                amAmmEnableSurgeFee\n                    ? uint24(\n                        FixedPointMathLib.max(\n                            amAmmSwapFee, computeSurgeFee(lastSurgeTimestamp, hookParams.surgeFee, hookParams.surgeFeeHalfLife)\n                        )\n                    )\n                    : amAmmSwapFee\n            )\n            : (\n                feeOverridden\n                    ? feeOverride\n                    : computeDynamicSwapFee(\n                        updatedSqrtPriceX96,\n                        feeMeanTick,\n                        lastSurgeTimestamp,\n                        hookParams.feeMin,\n                        hookParams.feeMax,\n                        hookParams.feeQuadraticMultiplier,\n                        hookParams.surgeFee,\n                        hookParams.surgeFeeHalfLife\n                    )\n            );\n        uint256 hookFeesAmount;\n        uint256 hookHandleSwapInputAmount;\n        uint256 hookHandleSwapOutoutAmount;\n        if (exactIn) {\n            // decrease output amount\n            swapFeeAmount = outputAmount.mulDivUp(swapFee, SWAP_FEE_BASE);\n            (amAmmFeeCurrency, amAmmFeeAmount) = (outputToken, swapFeeAmount);\n\n            // take hook fees from swap fee\n            hookFeesAmount = swapFeeAmount.mulDivUp(env.hookFeeModifier, MODIFIER_BASE);\n            swapFeeAmount -= hookFeesAmount;\n\n            // modify output amount with fees\n            outputAmount -= swapFeeAmount + hookFeesAmount;\n\n            // return beforeSwapDelta\n            // take in max(amountSpecified, inputAmount) such that if amountSpecified is greater we just happily accept it\n            int256 actualInputAmount = FixedPointMathLib.max(-params.amountSpecified, inputAmount.toInt256());\n            inputAmount = uint256(actualInputAmount);\n            beforeSwapDelta = toBeforeSwapDelta({\n                deltaSpecified: actualInputAmount.toInt128(),\n                deltaUnspecified: -outputAmount.toInt256().toInt128()\n            });\n\n            // if am-AMM is used, the swap fee needs to be taken from BunniHub, else it stays in BunniHub with the LPs\n            (hookHandleSwapInputAmount, hookHandleSwapOutoutAmount) = (\n                inputAmount, useAmAmmFee ? outputAmount + swapFeeAmount + hookFeesAmount : outputAmount + hookFeesAmount\n            );\n        } else {\n            // increase input amount\n            // need to modify fee rate to maintain the same average price as exactIn case\n            // in / (out * (1 - fee)) = in * (1 + fee') / out => fee' = fee / (1 - fee)\n            swapFeeAmount = inputAmount.mulDivUp(swapFee, SWAP_FEE_BASE - swapFee);\n            (amAmmFeeCurrency, amAmmFeeAmount) = (inputToken, swapFeeAmount);\n\n            // take hook fees from swap fee\n            hookFeesAmount = swapFeeAmount.mulDivUp(env.hookFeeModifier, MODIFIER_BASE);\n            swapFeeAmount -= hookFeesAmount;\n\n            // modify input amount with fees\n            inputAmount += swapFeeAmount + hookFeesAmount;\n\n            // return beforeSwapDelta\n            // give out min(amountSpecified, outputAmount) such that if amountSpecified is greater we only give outputAmount and let the tx revert\n            int256 actualOutputAmount = FixedPointMathLib.min(params.amountSpecified, outputAmount.toInt256());\n            outputAmount = uint256(actualOutputAmount);\n            beforeSwapDelta = toBeforeSwapDelta({\n                deltaSpecified: -actualOutputAmount.toInt128(),\n                deltaUnspecified: inputAmount.toInt256().toInt128()\n            });\n\n            // if am-AMM is not used, the swap fee needs to be sent to BunniHub to the LPs, else it stays in BunniHook with the am-AMM manager\n            (hookHandleSwapInputAmount, hookHandleSwapOutoutAmount) = (\n                useAmAmmFee ? inputAmount - swapFeeAmount - hookFeesAmount : inputAmount - hookFeesAmount, outputAmount\n            );\n        }\n\n        // take input by minting claim tokens to hook\n        env.poolManager.mint(address(this), inputToken.toId(), inputAmount);\n\n        // call hub to handle swap\n        // - pull input claim tokens from hook\n        // - push output tokens to pool manager and mint claim tokens to hook\n        // - update raw token balances\n        env.hub.hookHandleSwap(key, params.zeroForOne, hookHandleSwapInputAmount, hookHandleSwapOutoutAmount);\n\n        // burn output claim tokens\n        env.poolManager.burn(address(this), outputToken.toId(), outputAmount);\n\n        // distribute part of hookFees to referrers\n        if (hookFeesAmount != 0) {\n            uint256 referrerRewardAmount = hookFeesAmount.mulDiv(env.referralRewardModifier, MODIFIER_BASE);\n            if (referrerRewardAmount != 0) {\n                if (!env.poolManager.isOperator(address(this), address(bunniState.bunniToken))) {\n                    env.poolManager.setOperator(address(bunniState.bunniToken), true);\n                }\n                bool isToken0 = exactIn != params.zeroForOne;\n                bunniState.bunniToken.distributeReferralRewards(isToken0, referrerRewardAmount);\n            }\n        }\n\n        // emit swap event\n        emit IBunniHook.Swap(\n            id,\n            sender,\n            params.zeroForOne,\n            inputAmount,\n            outputAmount,\n            updatedSqrtPriceX96,\n            updatedTick,\n            swapFee,\n            totalLiquidity\n        );\n\n        // we should rebalance if:\n        // - rebalanceThreshold != 0, i.e. rebalancing is enabled\n        // - shouldSurge == true, since tokens can only go out of balance due to shifting or vault returns\n        // - the deadline of the last rebalance order has passed\n        if (hookParams.rebalanceThreshold != 0 && shouldSurge && block.timestamp > s.rebalanceOrderDeadline[id]) {\n            _rebalance(\n                s,\n                env,\n                RebalanceInput({\n                    id: id,\n                    key: key,\n                    updatedTick: updatedTick,\n                    updatedSqrtPriceX96: updatedSqrtPriceX96,\n                    arithmeticMeanTick: arithmeticMeanTick,\n                    newLdfState: newLdfState,\n                    hookParams: hookParams,\n                    updatedIntermediate: updatedIntermediate,\n                    updatedIndex: updatedIndex,\n                    updatedCardinality: updatedCardinality\n                })\n            );\n        }\n\n        // hooklet call\n        if (bunniState.hooklet.hasPermission(HookletLib.AFTER_SWAP_FLAG)) {\n            bunniState.hooklet.hookletAfterSwap(\n                sender,\n                key,\n                params,\n                IHooklet.SwapReturnData({\n                    updatedSqrtPriceX96: updatedSqrtPriceX96,\n                    updatedTick: updatedTick,\n                    inputAmount: inputAmount,\n                    outputAmount: outputAmount,\n                    swapFee: swapFee,\n                    totalLiquidity: totalLiquidity\n                })\n            );\n        }\n    }\n\n    function decodeHookParams(bytes calldata hookParams) external pure returns (DecodedHookParams memory p) {\n        return _decodeParams(hookParams);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal utility functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Checks if the pool should surge based on the vault share price changes since the last swap.\n    /// Also updates vaultSharePricesAtLastSwap.\n    function _shouldSurgeFromVaults(\n        HookStorage storage s,\n        PoolId id,\n        PoolState memory bunniState,\n        DecodedHookParams memory hookParams,\n        uint256 reserveBalance0,\n        uint256 reserveBalance1\n    ) private returns (bool shouldSurge) {\n        if (address(bunniState.vault0) != address(0) && address(bunniState.vault1) != address(0)) {\n            // only surge if both vaults are set because otherwise total liquidity won't automatically increase\n            // so there's no risk of being sandwiched\n\n            // compute share prices\n            VaultSharePrices memory sharePrices = VaultSharePrices({\n                initialized: true,\n                sharePrice0: bunniState.reserve0 == 0 ? 0 : reserveBalance0.mulDivUp(WAD, bunniState.reserve0).toUint120(),\n                sharePrice1: bunniState.reserve1 == 0 ? 0 : reserveBalance1.mulDivUp(WAD, bunniState.reserve1).toUint120()\n            });\n\n            // compare with share prices at last swap to see if we need to apply the surge fee\n            VaultSharePrices memory prevSharePrices = s.vaultSharePricesAtLastSwap[id];\n            if (\n                prevSharePrices.initialized\n                    && (\n                        dist(sharePrices.sharePrice0, prevSharePrices.sharePrice0)\n                            >= prevSharePrices.sharePrice0 / hookParams.vaultSurgeThreshold0\n                            || dist(sharePrices.sharePrice1, prevSharePrices.sharePrice1)\n                                >= prevSharePrices.sharePrice1 / hookParams.vaultSurgeThreshold1\n                    )\n            ) {\n                // surge fee is applied if the share price has increased by more than 1 / vaultSurgeThreshold\n                shouldSurge = true;\n            }\n\n            // update share prices at last swap\n            if (\n                !prevSharePrices.initialized || sharePrices.sharePrice0 != prevSharePrices.sharePrice0\n                    || sharePrices.sharePrice1 != prevSharePrices.sharePrice1\n            ) {\n                s.vaultSharePricesAtLastSwap[id] = sharePrices;\n            }\n        }\n    }\n\n    /// @dev Creates a rebalance order on FloodPlain.\n    function _rebalance(HookStorage storage s, Env calldata env, RebalanceInput memory input) internal {\n        // compute rebalance params\n        (bool success, Currency inputToken, Currency outputToken, uint256 inputAmount, uint256 outputAmount) =\n            _computeRebalanceParams(s, env, input);\n        if (!success) return;\n\n        // create rebalance order\n        _createRebalanceOrder(\n            s,\n            env,\n            input.id,\n            input.key,\n            input.hookParams.rebalanceOrderTTL,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount\n        );\n    }\n\n    function _computeRebalanceParams(HookStorage storage s, Env calldata env, RebalanceInput memory input)\n        internal\n        view\n        returns (bool success, Currency inputToken, Currency outputToken, uint256 inputAmount, uint256 outputAmount)\n    {\n        // compute the ratio (excessLiquidity / totalLiquidity)\n        // excessLiquidity is the minimum amount of liquidity that can be supported by the excess tokens\n\n        // load fresh state\n        PoolState memory bunniState = env.hub.poolState(input.id);\n\n        // get fresh token balances\n        (uint256 balance0, uint256 balance1) = (\n            bunniState.rawBalance0 + getReservesInUnderlying(bunniState.reserve0, bunniState.vault0),\n            bunniState.rawBalance1 + getReservesInUnderlying(bunniState.reserve1, bunniState.vault1)\n        );\n\n        // compute total liquidity and densities\n        (uint256 totalLiquidity, uint256 totalDensity0X96, uint256 totalDensity1X96,,,) = queryLDF({\n            key: input.key,\n            sqrtPriceX96: input.updatedSqrtPriceX96,\n            tick: input.updatedTick,\n            arithmeticMeanTick: input.arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: input.newLdfState,\n            balance0: balance0,\n            balance1: balance1\n        });\n\n        // compute active balance, which is the balance implied by the total liquidity & the LDF\n        (uint256 currentActiveBalance0, uint256 currentActiveBalance1) =\n            (totalDensity0X96.fullMulDiv(totalLiquidity, Q96), totalDensity1X96.fullMulDiv(totalLiquidity, Q96));\n\n        // compute excess liquidity if there's any\n        (int24 minUsableTick, int24 maxUsableTick) = (\n            TickMath.minUsableTick(input.key.tickSpacing),\n            TickMath.maxUsableTick(input.key.tickSpacing) - input.key.tickSpacing\n        );\n        uint256 excessLiquidity0 = balance0 > currentActiveBalance0\n            ? (balance0 - currentActiveBalance0).divWad(\n                bunniState.liquidityDensityFunction.cumulativeAmount0(\n                    input.key,\n                    minUsableTick,\n                    WAD,\n                    input.arithmeticMeanTick,\n                    input.updatedTick,\n                    bunniState.ldfParams,\n                    input.newLdfState\n                )\n            )\n            : 0;\n        uint256 excessLiquidity1 = balance1 > currentActiveBalance1\n            ? (balance1 - currentActiveBalance1).divWad(\n                bunniState.liquidityDensityFunction.cumulativeAmount1(\n                    input.key,\n                    maxUsableTick,\n                    WAD,\n                    input.arithmeticMeanTick,\n                    input.updatedTick,\n                    bunniState.ldfParams,\n                    input.newLdfState\n                )\n            )\n            : 0;\n\n        // should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\n        bool shouldRebalance0 =\n            excessLiquidity0 != 0 && excessLiquidity0 >= totalLiquidity / input.hookParams.rebalanceThreshold;\n        bool shouldRebalance1 =\n            excessLiquidity1 != 0 && excessLiquidity1 >= totalLiquidity / input.hookParams.rebalanceThreshold;\n        if (!shouldRebalance0 && !shouldRebalance1) return (false, inputToken, outputToken, inputAmount, outputAmount);\n\n        // compute target token densities of the excess liquidity after rebalancing\n        // this is done by querying the LDF using a TWAP as the spot price to prevent manipulation\n        int24 rebalanceSpotPriceTick = _getTwap(\n            s,\n            input.id,\n            input.updatedTick,\n            input.hookParams.rebalanceTwapSecondsAgo,\n            input.updatedIntermediate,\n            input.updatedIndex,\n            input.updatedCardinality\n        );\n        uint160 rebalanceSpotPriceSqrtRatioX96 = TickMath.getSqrtPriceAtTick(rebalanceSpotPriceTick);\n        // reusing totalDensity0X96 and totalDensity1X96 to store the token densities of the excess liquidity\n        // after rebalancing\n        (, totalDensity0X96, totalDensity1X96,,,) = queryLDF({\n            key: input.key,\n            sqrtPriceX96: rebalanceSpotPriceSqrtRatioX96,\n            tick: rebalanceSpotPriceTick,\n            arithmeticMeanTick: input.arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: input.newLdfState,\n            balance0: 0,\n            balance1: 0\n        });\n\n        // decide which token will be rebalanced (i.e., sold into the other token)\n        bool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 || excessLiquidity0 > excessLiquidity1);\n\n        // compute target amounts (i.e. the token amounts of the excess liquidity)\n        uint256 excessLiquidity = willRebalanceToken0 ? excessLiquidity0 : excessLiquidity1;\n        uint256 targetAmount0 = excessLiquidity.fullMulDiv(totalDensity0X96, Q96);\n        uint256 targetAmount1 = excessLiquidity.fullMulDiv(totalDensity1X96, Q96);\n\n        // determine input & output\n        (inputToken, outputToken) = willRebalanceToken0\n            ? (input.key.currency0, input.key.currency1)\n            : (input.key.currency1, input.key.currency0);\n        uint256 inputTokenExcessBalance =\n            willRebalanceToken0 ? balance0 - currentActiveBalance0 : balance1 - currentActiveBalance1;\n        uint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\n        uint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\n        if (inputTokenExcessBalance < inputTokenTarget) {\n            // should never happen\n            return (false, inputToken, outputToken, inputAmount, outputAmount);\n        }\n        inputAmount = inputTokenExcessBalance - inputTokenTarget;\n        outputAmount = outputTokenTarget.mulDivUp(1e5 - input.hookParams.rebalanceMaxSlippage, 1e5);\n\n        success = true;\n    }\n\n    function _createRebalanceOrder(\n        HookStorage storage s,\n        Env calldata env,\n        PoolId id,\n        PoolKey memory key,\n        uint16 rebalanceOrderTTL,\n        Currency inputToken,\n        Currency outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount\n    ) internal {\n        // create Flood order\n        ERC20 inputERC20Token = inputToken.isNative() ? env.weth : ERC20(Currency.unwrap(inputToken));\n        ERC20 outputERC20Token = outputToken.isNative() ? env.weth : ERC20(Currency.unwrap(outputToken));\n        IFloodPlain.Item[] memory offer = new IFloodPlain.Item[](1);\n        offer[0] = IFloodPlain.Item({token: address(inputERC20Token), amount: inputAmount});\n        IFloodPlain.Item memory consideration =\n            IFloodPlain.Item({token: address(outputERC20Token), amount: outputAmount});\n\n        IBunniHook.RebalanceOrderHookArgs memory hookArgs = IBunniHook.RebalanceOrderHookArgs({\n            key: key,\n            preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount: inputAmount}),\n            postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n        });\n\n        // prehook should pull input tokens from BunniHub to BunniHook and update pool balances\n        IFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\n        preHooks[0] = IFloodPlain.Hook({\n            target: address(this),\n            data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n        });\n\n        // posthook should push output tokens from BunniHook to BunniHub and update pool balances\n        IFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\n        postHooks[0] = IFloodPlain.Hook({\n            target: address(this),\n            data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n        });\n\n        IFloodPlain.Order memory order = IFloodPlain.Order({\n            offerer: address(this),\n            zone: address(env.floodZone),\n            recipient: address(this),\n            offer: offer,\n            consideration: consideration,\n            deadline: block.timestamp + rebalanceOrderTTL,\n            nonce: block.number,\n            preHooks: preHooks,\n            postHooks: postHooks\n        });\n\n        // record order for verification later\n        s.rebalanceOrderHash[id] = _newOrderHash(order, env);\n        s.rebalanceOrderDeadline[id] = order.deadline;\n        s.rebalanceOrderHookArgsHash[id] = keccak256(abi.encode(hookArgs));\n\n        // approve input token to permit2\n        if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n            address(inputERC20Token).safeApproveWithRetry(env.permit2, type(uint256).max);\n        }\n\n        // etch order so fillers can pick it up\n        // use PoolId as signature to enable isValidSignature() to find the correct order hash\n        IOnChainOrders(address(env.floodPlain)).etchOrder(\n            IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n        );\n    }\n\n    function _getTwap(\n        HookStorage storage s,\n        PoolId id,\n        int24 currentTick,\n        uint32 twapSecondsAgo,\n        Oracle.Observation memory updatedIntermediate,\n        uint32 updatedIndex,\n        uint32 updatedCardinality\n    ) internal view returns (int24 arithmeticMeanTick) {\n        (int56 tickCumulative0, int56 tickCumulative1) = s.observations[id].observeDouble(\n            updatedIntermediate,\n            uint32(block.timestamp),\n            twapSecondsAgo,\n            0,\n            currentTick,\n            updatedIndex,\n            updatedCardinality\n        );\n        int56 tickCumulativesDelta = tickCumulative1 - tickCumulative0;\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(twapSecondsAgo)));\n    }\n\n    function _updateOracle(HookStorage storage s, PoolId id, int24 tick, uint32 oracleMinInterval)\n        internal\n        returns (Oracle.Observation memory updatedIntermediate, uint32 updatedIndex, uint32 updatedCardinality)\n    {\n        IBunniHook.ObservationState memory state = s.states[id];\n        (updatedIntermediate, updatedIndex, updatedCardinality) = s.observations[id].write(\n            state.intermediateObservation,\n            state.index,\n            uint32(block.timestamp),\n            tick,\n            state.cardinality,\n            state.cardinalityNext,\n            oracleMinInterval\n        );\n        (s.states[id].intermediateObservation, s.states[id].index, s.states[id].cardinality) =\n            (updatedIntermediate, updatedIndex, updatedCardinality);\n    }\n\n    /// @dev The hash that Permit2 uses when verifying the order's signature.\n    /// See https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/SignatureTransfer.sol#L65\n    /// Always calls permit2 for the domain separator to maintain cross-chain replay protection in the event of a fork\n    function _newOrderHash(IFloodPlain.Order memory order, Env calldata env) internal view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                IEIP712(env.permit2).DOMAIN_SEPARATOR(),\n                OrderHashMemory.hashAsWitness(order, address(env.floodPlain))\n            )\n        );\n    }\n\n    /// @dev Decodes hookParams into params used by this hook\n    /// @param hookParams The hook params raw bytes\n    /// @return p The decoded params struct\n    function _decodeParams(bytes memory hookParams) internal pure returns (DecodedHookParams memory p) {\n        // | feeMin - 3 bytes | feeMax - 3 bytes | feeQuadraticMultiplier - 3 bytes | feeTwapSecondsAgo - 3 bytes | surgeFee - 3 bytes | surgeFeeHalfLife - 2 bytes | surgeFeeAutostartThreshold - 2 bytes | vaultSurgeThreshold0 - 2 bytes | vaultSurgeThreshold1 - 2 bytes | rebalanceThreshold - 2 bytes | rebalanceMaxSlippage - 2 bytes | rebalanceTwapSecondsAgo - 2 bytes | rebalanceOrderTTL - 2 bytes | amAmmEnabled - 1 byte |\n        bytes32 firstWord;\n        // | oracleMinInterval - 4 bytes |\n        bytes32 secondWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            firstWord := mload(add(hookParams, 32))\n            secondWord := mload(add(hookParams, 64))\n        }\n        p.feeMin = uint24(bytes3(firstWord));\n        p.feeMax = uint24(bytes3(firstWord << 24));\n        p.feeQuadraticMultiplier = uint24(bytes3(firstWord << 48));\n        p.feeTwapSecondsAgo = uint24(bytes3(firstWord << 72));\n        p.surgeFee = uint24(bytes3(firstWord << 96));\n        p.surgeFeeHalfLife = uint16(bytes2(firstWord << 120));\n        p.surgeFeeAutostartThreshold = uint16(bytes2(firstWord << 136));\n        p.vaultSurgeThreshold0 = uint16(bytes2(firstWord << 152));\n        p.vaultSurgeThreshold1 = uint16(bytes2(firstWord << 168));\n        p.rebalanceThreshold = uint16(bytes2(firstWord << 184));\n        p.rebalanceMaxSlippage = uint16(bytes2(firstWord << 200));\n        p.rebalanceTwapSecondsAgo = uint16(bytes2(firstWord << 216));\n        p.rebalanceOrderTTL = uint16(bytes2(firstWord << 232));\n        p.amAmmEnabled = uint8(bytes1(firstWord << 248)) != 0;\n        p.oracleMinInterval = uint32(bytes4(secondWord));\n    }\n}\n"
    }
}