{
    "vfp_id": "vfp_00150",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "AgentFactoryV3::initFromBondingCurve() sets application proposer to the wrong address",
            "description": "The AgentFactoryV3::initFromBondingCurve() function sets the application proposer to msg.sender, which in the context of Bonding::_openTradingOnUniswap() is the Bonding.sol contract itself, not the original user who launched the agent. This misassignment causes the sAgentToken (representing staked LP tokens) to be sent to the Bonding contract instead of the creator. As a result, the legitimate creator loses voting rights in the AgentDAO and cannot retrieve the LP tokens when they unlock. The root cause is incorrect use of msg.sender without forwarding the original caller's address. This can be exploited to disenfranchise the agent creator. The impact is loss of governance rights and permanent loss of access to staked liquidity.\n",
            "severity": "High",
            "location": [
                "AgentFactoryV3.sol"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentFactoryV3.sol"
            ]
        }
    ],
    "affected_files": {
        "AgentFactoryV3.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"./IAgentFactoryV3.sol\";\nimport \"./IAgentToken.sol\";\nimport \"./IAgentVeToken.sol\";\nimport \"./IAgentDAO.sol\";\nimport \"./IAgentNft.sol\";\nimport \"../libs/IERC6551Registry.sol\";\n\ncontract AgentFactoryV3 is\n    IAgentFactoryV3,\n    Initializable,\n    AccessControl,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 private _nextId;\n    address public tokenImplementation;\n    address public daoImplementation;\n    address public nft;\n    address public tbaRegistry; // Token bound account\n    uint256 public applicationThreshold;\n\n    address[] public allTokens;\n    address[] public allDAOs;\n\n    address public assetToken; // Base currency\n    uint256 public maturityDuration; // Staking duration in seconds for initial LP. eg: 10years\n\n    bytes32 public constant WITHDRAW_ROLE = keccak256(\"WITHDRAW_ROLE\"); // Able to withdraw and execute applications\n\n    event NewPersona(\n        uint256 virtualId,\n        address token,\n        address dao,\n        address tba,\n        address veToken,\n        address lp\n    );\n    event NewApplication(uint256 id);\n\n    enum ApplicationStatus {\n        Active,\n        Executed,\n        Withdrawn\n    }\n\n    struct Application {\n        string name;\n        string symbol;\n        string tokenURI;\n        ApplicationStatus status;\n        uint256 withdrawableAmount;\n        address proposer;\n        uint8[] cores;\n        uint256 proposalEndBlock;\n        uint256 virtualId;\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n    }\n\n    mapping(uint256 => Application) private _applications;\n\n    address public gov; // Deprecated in v2, execution of application does not require DAO decision anymore\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Only DAO can execute proposal\");\n        _;\n    }\n\n    event ApplicationThresholdUpdated(uint256 newThreshold);\n    event GovUpdated(address newGov);\n    event ImplContractsUpdated(address token, address dao);\n\n    address private _vault; // Vault to hold all Virtual NFTs\n\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"cannot reenter\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    ///////////////////////////////////////////////////////////////\n    // V2 Storage\n    ///////////////////////////////////////////////////////////////\n    address[] public allTradingTokens;\n    address private _uniswapRouter;\n    address public veTokenImplementation;\n    address private _minter; // Unused\n    address private _tokenAdmin;\n    address public defaultDelegatee;\n\n    // Default agent token params\n    bytes private _tokenSupplyParams;\n    bytes private _tokenTaxParams;\n    uint16 private _tokenMultiplier; // Unused\n\n    bytes32 public constant BONDING_ROLE = keccak256(\"BONDING_ROLE\");\n\n    ///////////////////////////////////////////////////////////////\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address tokenImplementation_,\n        address veTokenImplementation_,\n        address daoImplementation_,\n        address tbaRegistry_,\n        address assetToken_,\n        address nft_,\n        uint256 applicationThreshold_,\n        address vault_,\n        uint256 nextId_\n    ) public initializer {\n        __Pausable_init();\n\n        tokenImplementation = tokenImplementation_;\n        veTokenImplementation = veTokenImplementation_;\n        daoImplementation = daoImplementation_;\n        assetToken = assetToken_;\n        tbaRegistry = tbaRegistry_;\n        nft = nft_;\n        applicationThreshold = applicationThreshold_;\n        _nextId = nextId_;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _vault = vault_;\n    }\n\n    function getApplication(\n        uint256 proposalId\n    ) public view returns (Application memory) {\n        return _applications[proposalId];\n    }\n\n    function proposeAgent(\n        string memory name,\n        string memory symbol,\n        string memory tokenURI,\n        uint8[] memory cores,\n        bytes32 tbaSalt,\n        address tbaImplementation,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold\n    ) public whenNotPaused returns (uint256) {\n        address sender = _msgSender();\n        require(\n            IERC20(assetToken).balanceOf(sender) >= applicationThreshold,\n            \"Insufficient asset token\"\n        );\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >=\n                applicationThreshold,\n            \"Insufficient asset token allowance\"\n        );\n        require(cores.length > 0, \"Cores must be provided\");\n\n        IERC20(assetToken).safeTransferFrom(\n            sender,\n            address(this),\n            applicationThreshold\n        );\n\n        uint256 id = _nextId++;\n        uint256 proposalEndBlock = block.number; // No longer required in v2\n        Application memory application = Application(\n            name,\n            symbol,\n            tokenURI,\n            ApplicationStatus.Active,\n            applicationThreshold,\n            sender,\n            cores,\n            proposalEndBlock,\n            0,\n            tbaSalt,\n            tbaImplementation,\n            daoVotingPeriod,\n            daoThreshold\n        );\n        _applications[id] = application;\n        emit NewApplication(id);\n\n        return id;\n    }\n\n    function withdraw(uint256 id) public noReentrant {\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        require(\n            application.status == ApplicationStatus.Active,\n            \"Application is not active\"\n        );\n\n        require(\n            block.number > application.proposalEndBlock,\n            \"Application is not matured yet\"\n        );\n\n        uint256 withdrawableAmount = application.withdrawableAmount;\n\n        application.withdrawableAmount = 0;\n        application.status = ApplicationStatus.Withdrawn;\n\n        IERC20(assetToken).safeTransfer(\n            application.proposer,\n            withdrawableAmount\n        );\n    }\n\n    function _executeApplication(\n        uint256 id,\n        bool canStake,\n        bytes memory tokenSupplyParams_\n    ) internal {\n        require(\n            _applications[id].status == ApplicationStatus.Active,\n            \"Application is not active\"\n        );\n\n        require(_tokenAdmin != address(0), \"Token admin not set\");\n\n        Application storage application = _applications[id];\n\n        uint256 initialAmount = application.withdrawableAmount;\n        application.withdrawableAmount = 0;\n        application.status = ApplicationStatus.Executed;\n\n        // C1\n        address token = _createNewAgentToken(\n            application.name,\n            application.symbol,\n            tokenSupplyParams_\n        );\n\n        // C2\n        address lp = IAgentToken(token).liquidityPools()[0];\n        IERC20(assetToken).safeTransfer(token, initialAmount);\n        IAgentToken(token).addInitialLiquidity(address(this));\n\n        // C3\n        address veToken = _createNewAgentVeToken(\n            string.concat(\"Staked \", application.name),\n            string.concat(\"s\", application.symbol),\n            lp,\n            application.proposer,\n            canStake\n        );\n\n        // C4\n        string memory daoName = string.concat(application.name, \" DAO\");\n        address payable dao = payable(\n            _createNewDAO(\n                daoName,\n                IVotes(veToken),\n                application.daoVotingPeriod,\n                application.daoThreshold\n            )\n        );\n\n        // C5\n        uint256 virtualId = IAgentNft(nft).nextVirtualId();\n        IAgentNft(nft).mint(\n            virtualId,\n            _vault,\n            application.tokenURI,\n            dao,\n            application.proposer,\n            application.cores,\n            lp,\n            token\n        );\n        application.virtualId = virtualId;\n\n        // C6\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        address tbaAddress = IERC6551Registry(tbaRegistry).createAccount(\n            application.tbaImplementation,\n            application.tbaSalt,\n            chainId,\n            nft,\n            virtualId\n        );\n        IAgentNft(nft).setTBA(virtualId, tbaAddress);\n\n        // C7\n        IERC20(lp).approve(veToken, type(uint256).max);\n        IAgentVeToken(veToken).stake(\n            IERC20(lp).balanceOf(address(this)),\n            application.proposer,\n            defaultDelegatee\n        );\n\n        emit NewPersona(virtualId, token, dao, tbaAddress, veToken, lp);\n    }\n\n    function executeApplication(uint256 id, bool canStake) public noReentrant {\n        // This will bootstrap an Agent with following components:\n        // C1: Agent Token\n        // C2: LP Pool + Initial liquidity\n        // C3: Agent veToken\n        // C4: Agent DAO\n        // C5: Agent NFT\n        // C6: TBA\n        // C7: Stake liquidity token to get veToken\n\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        _executeApplication(id, canStake, _tokenSupplyParams);\n    }\n\n    function _createNewDAO(\n        string memory name,\n        IVotes token,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold\n    ) internal returns (address instance) {\n        instance = Clones.clone(daoImplementation);\n        IAgentDAO(instance).initialize(\n            name,\n            token,\n            nft,\n            daoThreshold,\n            daoVotingPeriod\n        );\n\n        allDAOs.push(instance);\n        return instance;\n    }\n\n    function _createNewAgentToken(\n        string memory name,\n        string memory symbol,\n        bytes memory tokenSupplyParams_\n    ) internal returns (address instance) {\n        instance = Clones.clone(tokenImplementation);\n        IAgentToken(instance).initialize(\n            [_tokenAdmin, _uniswapRouter, assetToken],\n            abi.encode(name, symbol),\n            tokenSupplyParams_,\n            _tokenTaxParams\n        );\n\n        allTradingTokens.push(instance);\n        return instance;\n    }\n\n    function _createNewAgentVeToken(\n        string memory name,\n        string memory symbol,\n        address stakingAsset,\n        address founder,\n        bool canStake\n    ) internal returns (address instance) {\n        instance = Clones.clone(veTokenImplementation);\n        IAgentVeToken(instance).initialize(\n            name,\n            symbol,\n            founder,\n            stakingAsset,\n            block.timestamp + maturityDuration,\n            address(nft),\n            canStake\n        );\n\n        allTokens.push(instance);\n        return instance;\n    }\n\n    function totalAgents() public view returns (uint256) {\n        return allTokens.length;\n    }\n\n    function setApplicationThreshold(\n        uint256 newThreshold\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        applicationThreshold = newThreshold;\n        emit ApplicationThresholdUpdated(newThreshold);\n    }\n\n    function setVault(address newVault) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _vault = newVault;\n    }\n\n    function setImplementations(\n        address token,\n        address veToken,\n        address dao\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        tokenImplementation = token;\n        daoImplementation = dao;\n        veTokenImplementation = veToken;\n    }\n\n    function setMaturityDuration(\n        uint256 newDuration\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        maturityDuration = newDuration;\n    }\n\n    function setUniswapRouter(\n        address router\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _uniswapRouter = router;\n    }\n\n    function setTokenAdmin(\n        address newTokenAdmin\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenAdmin = newTokenAdmin;\n    }\n\n    function setTokenSupplyParams(\n        uint256 maxSupply,\n        uint256 lpSupply,\n        uint256 vaultSupply,\n        uint256 maxTokensPerWallet,\n        uint256 maxTokensPerTxn,\n        uint256 botProtectionDurationInSeconds,\n        address vault\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenSupplyParams = abi.encode(\n            maxSupply,\n            lpSupply,\n            vaultSupply,\n            maxTokensPerWallet,\n            maxTokensPerTxn,\n            botProtectionDurationInSeconds,\n            vault\n        );\n    }\n\n    function setTokenTaxParams(\n        uint256 projectBuyTaxBasisPoints,\n        uint256 projectSellTaxBasisPoints,\n        uint256 taxSwapThresholdBasisPoints,\n        address projectTaxRecipient\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenTaxParams = abi.encode(\n            projectBuyTaxBasisPoints,\n            projectSellTaxBasisPoints,\n            taxSwapThresholdBasisPoints,\n            projectTaxRecipient\n        );\n    }\n\n    function setAssetToken(\n        address newToken\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        assetToken = newToken;\n    }\n\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (address sender)\n    {\n        sender = ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ContextUpgradeable._msgData();\n    }\n\n    function initFromBondingCurve(\n        string memory name,\n        string memory symbol,\n        uint8[] memory cores,\n        bytes32 tbaSalt,\n        address tbaImplementation,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold,\n        uint256 applicationThreshold_\n    ) public whenNotPaused onlyRole(BONDING_ROLE) returns (uint256) {\n        address sender = _msgSender();\n        require(\n            IERC20(assetToken).balanceOf(sender) >= applicationThreshold_,\n            \"Insufficient asset token\"\n        );\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >=\n                applicationThreshold_,\n            \"Insufficient asset token allowance\"\n        );\n        require(cores.length > 0, \"Cores must be provided\");\n\n        IERC20(assetToken).safeTransferFrom(\n            sender,\n            address(this),\n            applicationThreshold_\n        );\n\n        uint256 id = _nextId++;\n        uint256 proposalEndBlock = block.number; // No longer required in v2\n        Application memory application = Application(\n            name,\n            symbol,\n            \"\",\n            ApplicationStatus.Active,\n            applicationThreshold_,\n            sender,\n            cores,\n            proposalEndBlock,\n            0,\n            tbaSalt,\n            tbaImplementation,\n            daoVotingPeriod,\n            daoThreshold\n        );\n        _applications[id] = application;\n        emit NewApplication(id);\n\n        return id;\n    }\n\n    function executeBondingCurveApplication(\n        uint256 id,\n        uint256 totalSupply,\n        uint256 lpSupply,\n        address vault\n    ) public onlyRole(BONDING_ROLE) noReentrant returns (address) {\n        bytes memory tokenSupplyParams = abi.encode(\n            totalSupply,\n            lpSupply,\n            totalSupply - lpSupply,\n            totalSupply,\n            totalSupply,\n            0,\n            vault\n        );\n\n        _executeApplication(id, true, tokenSupplyParams);\n\n        Application memory application = _applications[id];\n\n        return IAgentNft(nft).virtualInfo(application.virtualId).token;\n    }\n\n    function setDefaultDelegatee(\n        address newDelegatee\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        defaultDelegatee = newDelegatee;\n    }\n}\n"
    }
}