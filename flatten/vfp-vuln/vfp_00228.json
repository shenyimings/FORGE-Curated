{
    "vfp_id": "vfp_00228",
    "project_name": "Zenith Audit Report - Stream Protocol.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Using tokens with 18 decimals leads to significant loss of funds when bridging across chains",
            "description": "1.  **Description:** The vulnerability involves incorrect handling of tokens with 18 decimal places during cross-chain bridging operations.\n2.  **Cause:** The system does not properly normalize or convert decimal differences between tokens, leading to miscalculations.\n3.  **Exploitation:** An attacker could deposit a high-decimal token and trigger a bridge operation, causing a disproportionate withdrawal on the destination chain.\n4.  **Impact:** Users may suffer significant loss of funds due to incorrect amount calculations during cross-chain transfers.\n",
            "severity": "Critical",
            "location": [
                "StableWrapper.sol",
                "StreamVault.sol"
            ],
            "files": [
                "contracts/src/StableWrapper.sol"
            ]
        }
    ],
    "affected_files": {
        "StableWrapper.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IStableWrapper} from \"./interfaces/IStableWrapper.sol\";\nimport {OFT} from \"@layerzerolabs/oft-evm/contracts/OFT.sol\";\n\n/**\n * @title StableWrapper\n * @notice A token wrapper that allows users to obtain tokens needed to deposit into a StreamVault.\n * @notice Users receive a Stream token that maps 1:1 to the asset deposited.\n * @notice Initiated withdrawals can be completed after the epoch has passed.\n */\ncontract StableWrapper is OFT, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // #############################################\n    // STATE\n    // #############################################\n\n    /// @notice The asset that the wrapper is wrapping\n    address public asset;\n\n    /// @notice The current epoch number\n    uint32 public currentEpoch;\n\n    /// @notice Whether the wrapper allows independence.\n    /// If false, autostaking is enabled.\n    bool public allowIndependence;\n\n    /// @notice The number of decimals for the underlying asset\n    /// and the wrapped token\n    uint8 public underlyingDecimals;\n\n    /// @notice The address of the keeper\n    address public keeper;\n\n    /// @notice Stores the user's pending withdrawals\n    mapping(address => WithdrawalReceipt) public withdrawalReceipts;\n\n    /// @notice The amount of assets that have been withdrawn\n    uint256 public withdrawalAmountForEpoch;\n\n    /// @notice The amount of assets that have been deposited\n    uint256 public depositAmountForEpoch;\n\n    // #############################################\n    // STRUCTS\n    // #############################################\n\n    /**\n     * @notice Struct representing a withdrawal receipt\n     * @dev Uses packed storage with uint224 for amount and uint32 for epoch\n     * @param amount The amount of tokens requested for withdrawal\n     * @param epoch The epoch during which the withdrawal was initiated\n     */\n    struct WithdrawalReceipt {\n        uint224 amount;\n        uint32 epoch;\n    }\n\n    // #############################################\n    // EVENTS\n    // #############################################\n\n    event Deposit(address indexed from, address indexed to, uint256 amount);\n\n    event DepositToVault(address indexed user, uint256 amount);\n\n    event WithdrawalInitiated(\n        address indexed user,\n        uint224 amount,\n        uint32 epoch\n    );\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    event WithdrawalsProcessed(uint256 withdrawalAmount, uint256 balance, uint32 epoch);\n\n    event AssetTransferred(address indexed to, uint256 amount);\n\n    event PermissionedMint(address indexed to, uint256 amount);\n\n    event PermissionedBurn(address indexed from, uint256 amount);\n\n    event AllowIndependenceSet(bool allowIndependence);\n\n    event KeeperSet(address keeper);\n\n    // #############################################\n    // ERRORS\n    // #############################################\n\n    error IndependenceNotAllowed();\n\n    error AmountMustBeGreaterThanZero();\n\n    error AddressMustBeNonZero();\n\n    error InsufficientBalance();\n\n    error NotKeeper();\n\n    error CannotCompleteWithdrawalInSameEpoch();\n\n    // #############################################\n    // MODIFIERS\n    // #############################################\n\n    /**\n     * @dev Throws if called by any account other than the keeper\n     */\n    modifier onlyKeeper() {\n        if (msg.sender != keeper) revert NotKeeper();\n        _;\n    }\n\n    // #############################################\n    // CONSTRUCTOR & INITIALIZATION\n    // #############################################\n\n    /**\n     * @notice Initializes the contract\n     * @param _asset is the address of the asset to wrap\n     * @param _name is the name of the wrapped ERC-20\n     * @param _symbol is the symbol of the wrapped ERC-20\n     * @param _keeper is the address of the keeper\n     * @param _lzEndpoint is the address of the LayerZero endpoint\n     * @param _delegate is the address of the delegate\n     */\n    constructor(\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _underlyingDecimals,\n        address _keeper,\n        address _lzEndpoint,\n        address _delegate\n    ) OFT(_name, _symbol, _lzEndpoint, _delegate) Ownable(msg.sender) {\n        if (_asset == address(0)) revert AddressMustBeNonZero();\n        if (_keeper == address(0)) revert AddressMustBeNonZero();\n        asset = _asset;\n        currentEpoch = 1;\n        allowIndependence = false;\n        keeper = _keeper;\n        underlyingDecimals = _underlyingDecimals;\n    }\n\n    // #############################################\n    // DEPOSIT\n    // #############################################\n\n    /**\n     * @notice Deposits assets from a specified address and mints equivalent tokens\n     * @param to Address to transfer assets to\n     * @param amount Amount of assets to deposit\n     */\n    function deposit(address to, uint256 amount) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        _mint(to, amount);\n\n        depositAmountForEpoch += amount;\n\n        emit Deposit(msg.sender, to, amount);\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /**\n     * @notice Deposits assets and mints equivalent tokens to the vault\n     * @param amount Amount of assets to deposit\n     */\n    function depositToVault(\n        address from,\n        uint256 amount\n    ) external nonReentrant onlyKeeper {\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        _mint(keeper, amount);\n\n        depositAmountForEpoch += amount;\n\n        emit DepositToVault(from, amount);\n\n        IERC20(asset).safeTransferFrom(from, address(this), amount);\n    }\n\n    // #############################################\n    // WITHDRAWAL\n    // #############################################\n\n    /**\n     * @notice Burns tokens and creates withdrawal receipt\n     * @param amount Amount of tokens to burn for withdrawal\n     */\n    function initiateWithdrawal(uint224 amount) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (balanceOf(msg.sender) < amount) revert InsufficientBalance();\n\n        _burn(msg.sender, amount);\n\n        uint224 currentAmount = withdrawalReceipts[msg.sender].amount;\n\n        withdrawalReceipts[msg.sender] = WithdrawalReceipt({\n            amount: currentAmount + amount,\n            epoch: currentEpoch\n        });\n\n        withdrawalAmountForEpoch += amount;\n\n        emit WithdrawalInitiated(msg.sender, amount, currentEpoch);\n    }\n\n    /**\n     * @notice Burns tokens and creates withdrawal receipt for a specified address\n     * @param from Address to burn tokens from and create withdrawal receipt for\n     * @param amount Amount of tokens to burn for withdrawal\n     */\n    function initiateWithdrawalFromVault(\n        address from,\n        uint224 amount\n    ) external nonReentrant onlyKeeper {\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        _burn(address(this), amount);\n\n        uint224 currentAmount = withdrawalReceipts[from].amount;\n\n        withdrawalReceipts[from] = WithdrawalReceipt({\n            amount: currentAmount + amount,\n            epoch: currentEpoch\n        });\n\n        withdrawalAmountForEpoch += amount;\n\n        emit WithdrawalInitiated(from, amount, currentEpoch);\n    }\n\n    /**\n     * @notice Complete withdrawal if epoch has passed\n     * @param to Address to transfer assets to\n     */\n    function completeWithdrawal(address to) external nonReentrant {\n        WithdrawalReceipt memory receipt = withdrawalReceipts[msg.sender];\n\n        if (receipt.amount == 0) revert AmountMustBeGreaterThanZero();\n        if (receipt.epoch >= currentEpoch)\n            revert CannotCompleteWithdrawalInSameEpoch();\n\n        delete withdrawalReceipts[msg.sender];\n\n        // Cast uint224 to uint256 explicitly for the transfer\n        uint256 amountToTransfer = uint256(receipt.amount);\n\n        emit Withdrawn(to, amountToTransfer);\n\n        IERC20(asset).safeTransfer(to, amountToTransfer);\n    }\n\n    // #############################################\n    // MINT & BURN\n    // #############################################\n\n    /**\n     * @notice Allows owner to mint tokens to a specified address\n     * @param to Address to mint tokens to\n     * @param amount Amount of tokens to mint\n     */\n    function permissionedMint(address to, uint256 amount) external onlyKeeper {\n        _mint(to, amount);\n        emit PermissionedMint(to, amount);\n    }\n\n    /**\n     * @notice Allows owner to burn tokens from a specified address\n     * @param from Address to burn tokens from\n     * @param amount Amount of tokens to burn\n     */\n    function permissionedBurn(\n        address from,\n        uint256 amount\n    ) external onlyKeeper {\n        _burn(from, amount);\n        emit PermissionedBurn(from, amount);\n    }\n\n    // #############################################\n    // PROTOCOL CONTROL\n    // #############################################\n\n    /**\n     * @notice Processes the withdrawal for the current epoch\n     */\n    function processWithdrawals() external onlyOwner nonReentrant {\n\n        if (withdrawalAmountForEpoch > depositAmountForEpoch) {\n            IERC20(asset).safeTransferFrom(owner(), address(this), withdrawalAmountForEpoch - depositAmountForEpoch);\n        } else if (withdrawalAmountForEpoch < depositAmountForEpoch) {\n            IERC20(asset).safeTransfer(owner(), depositAmountForEpoch - withdrawalAmountForEpoch);\n        }\n\n        emit WithdrawalsProcessed(withdrawalAmountForEpoch, depositAmountForEpoch, currentEpoch);\n\n        currentEpoch += 1;\n        withdrawalAmountForEpoch = 0;\n        depositAmountForEpoch = 0;\n    }\n\n    /**\n     * @notice Allows owner to transfer assets to specified address\n     * @param to Address to transfer assets to\n     * @param amount Amount of assets to transfer\n     * @param _token Address of the token to transfer\n     */\n    function transferAsset(\n        address to,\n        uint256 amount,\n        address _token\n    ) external onlyOwner {\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        emit AssetTransferred(to, amount);\n\n        IERC20(_token).safeTransfer(to, amount);\n    }\n\n    // #############################################\n    // SETTERS\n    // #############################################\n\n    /**\n     * @notice Allows keeper to set the keeper address\n     * @param _keeper New keeper address\n     */\n    function setKeeper(address _keeper) external onlyOwner {\n        if (_keeper == address(0)) revert AddressMustBeNonZero();\n        keeper = _keeper;\n        emit KeeperSet(_keeper);\n    }\n\n    /**\n     * @notice Allows owner to set allowIndependence\n     * @param _allowIndependence New allowIndependence value\n     */\n    function setAllowIndependence(bool _allowIndependence) external onlyOwner {\n        allowIndependence = _allowIndependence;\n        emit AllowIndependenceSet(_allowIndependence);\n    }\n\n    /**\n     * @notice Allows keeper to set the asset address\n     * @param _asset New asset address\n     */\n    function setAsset(address _asset) external onlyOwner {\n        if (_asset == address(0)) revert AddressMustBeNonZero();\n        asset = _asset;\n    }\n\n    // #############################################\n    // GETTERS\n    // #############################################\n\n    /**\n     * @notice modify the token decimals\n     */\n    function setDecimals(uint8 _newDecimals) public onlyOwner {\n        underlyingDecimals = _newDecimals;\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return underlyingDecimals;\n    }\n\n    /**\n     * @notice Returns the shared token decimals for OFT\n     */\n    function sharedDecimals() public view virtual override returns (uint8) {\n        return decimals();\n    }\n}\n"
    }
}