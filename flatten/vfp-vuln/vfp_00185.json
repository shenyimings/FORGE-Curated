{
    "vfp_id": "vfp_00185",
    "project_name": "Uniswap Hooks Library Milestone 1 Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Dynamic After Swap Fees May Not Work as Intended",
            "description": "The DynamicAfterFee contract only applies its fee logic to exact-input swaps, allowing users to avoid the fee entirely by using exact-output swaps. Additionally, the `targetDelta` is reset after each swap and lacks a built-in mechanism for updating, making it vulnerable to front-running.\n\nThe root cause is the lack of fee enforcement on exact-output swaps and the absence of a secure, documented method to update `targetDelta`. An attacker can front-run a legitimate swap with a tiny exact-input swap, setting the `targetDelta` to a high value, causing the next user's entire output to be taken as a fee.\n\nThis can be exploited by front-running transactions to either avoid fees or steal value from subsequent swaps. The impact includes loss of user funds due to unexpected fee deductions and reduced trust in the fee mechanism, undermining the intended economic model.\n",
            "severity": "Medium",
            "location": [
                "DynamicAfterFee.sol::afterSwap#48-49",
                "DynamicAfterFee.sol#56",
                "DynamicAfterFee.sol#59-74"
            ],
            "files": [
                "uniswap-hooks/src/fee/BaseDynamicAfterFee.sol"
            ]
        }
    ],
    "affected_files": {
        "BaseDynamicAfterFee.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/fee/BaseDynamicAfterFee.sol)\n\npragma solidity ^0.8.24;\n\nimport {BaseHook} from \"src/base/BaseHook.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {CurrencySettler} from \"src/utils/CurrencySettler.sol\";\n\n/**\n * @dev Base implementation for dynamic fees applied after swaps.\n *\n * In order to use this hook, the inheriting contract must define the {_getTargetOutput} and\n * {_afterSwapHandler} functions. The {_getTargetOutput} function returns the target output to\n * apply to the swap depending on the given apply flag. The {_afterSwapHandler} function is called\n * after the target output is applied to the swap and currency amount is received.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseDynamicAfterFee is BaseHook {\n    using SafeCast for uint256;\n    using CurrencySettler for Currency;\n\n    uint256 internal _targetOutput;\n\n    bool internal _applyTargetOutput;\n\n    /**\n     * @dev Target output exceeds swap amount.\n     */\n    error TargetOutputExceeds();\n\n    /**\n     * @dev Set the `PoolManager` address.\n     */\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    /**\n     * @dev Sets the target output and apply flag to be used in the `afterSwap` hook.\n     *\n     * NOTE: The target output is reset to 0 in the `afterSwap` hook regardless of the apply flag.\n     */\n    function _beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) internal virtual override returns (bytes4, BeforeSwapDelta, uint24) {\n        // Get the target output and apply flag\n        (uint256 targetOutput, bool applyTargetOutput) = _getTargetOutput(sender, key, params, hookData);\n\n        // Set the target output and apply flag, overriding any previous values.\n        _applyTargetOutput = applyTargetOutput;\n        _targetOutput = targetOutput;\n\n        return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    /**\n     * @dev Apply the target output to the unspecified currency of the swap using fees.\n     * The fees are minted as ERC-6909 tokens, which can then be redeemed in the\n     * {_afterSwapHandler} function. Note that if the underlying unspecified currency\n     * is native, the implementing contract must ensure that it can receive native tokens\n     * when redeeming.\n     *\n     * NOTE: The target output is reset to 0, both when the apply flag is set to `false`\n     * and when set to `true`.\n     */\n    function _afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata\n    ) internal virtual override returns (bytes4, int128) {\n        uint256 targetOutput = _targetOutput;\n\n        // Reset storage target output to 0 and use one stored in memory\n        _targetOutput = 0;\n\n        // Skip if target output is not active\n        if (!_applyTargetOutput) {\n            return (this.afterSwap.selector, 0);\n        }\n\n        // Fee defined in the unspecified currency of the swap\n        (Currency unspecified, int128 unspecifiedAmount) = (params.amountSpecified < 0 == params.zeroForOne)\n            ? (key.currency1, delta.amount1())\n            : (key.currency0, delta.amount0());\n\n        // If fee is on output, get the absolute output amount\n        if (unspecifiedAmount < 0) unspecifiedAmount = -unspecifiedAmount;\n\n        // Revert if the target output exceeds the swap amount\n        if (targetOutput > uint128(unspecifiedAmount)) revert TargetOutputExceeds();\n\n        // Calculate the fee amount, which is the difference between the swap amount and the target output\n        uint256 feeAmount = uint128(unspecifiedAmount) - targetOutput;\n\n        // Mint ERC-6909 tokens for unspecified currency fee and call handler\n        if (feeAmount > 0) {\n            unspecified.take(poolManager, address(this), feeAmount, true);\n            _afterSwapHandler(key, params, delta, targetOutput, feeAmount);\n        }\n\n        return (this.afterSwap.selector, feeAmount.toInt128());\n    }\n\n    /**\n     * @dev Return the target output to be enforced by the `afterSwap` hook using fees.\n     *\n     * IMPORTANT: The swap will revert if the target output exceeds the output unspecified amount from the swap.\n     * In order to consume all of the output from the swap, set the target output to equal the output unspecified\n     * amount and set the apply flag to `true`.\n     *\n     * @return targetOutput The target output, defined in the unspecified currency of the swap.\n     * @return applyTargetOutput The apply flag, which can be set to `false` to skip applying the target output.\n     */\n    function _getTargetOutput(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) internal virtual returns (uint256 targetOutput, bool applyTargetOutput);\n\n    /**\n     * @dev Handler called after applying the target output to a swap and receiving the currency amount.\n     *\n     * @param key The pool key.\n     * @param params The swap parameters.\n     * @param delta The balance delta from the swap.\n     * @param targetOutput The target output, defined in the unspecified currency of the swap.\n     * @param feeAmount The amount of the unspecified currency taken from the swap.\n     */\n    function _afterSwapHandler(\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        uint256 targetOutput,\n        uint256 feeAmount\n    ) internal virtual;\n\n    /**\n     * @dev Set the hook permissions, specifically {beforeSwap}, {afterSwap} and {afterSwapReturnDelta}.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: true,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n"
    }
}