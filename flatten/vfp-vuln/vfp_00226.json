{
    "vfp_id": "vfp_00226",
    "project_name": "SSO Account Abstraction Audit.md",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "SsoAccount Can Call updateAccountVersion and updateNonceOrdering",
            "description": "The `SsoAccount` contract does not validate function selectors when making system calls via `batchCall`, allowing it to invoke sensitive system functions like `updateAccountVersion` and `updateNonceOrdering` on the `DEPLOYER_SYSTEM_CONTRACT`. This lack of validation stems from missing checks that exist in similar implementations like `DefaultAccount`. An attacker could craft a transaction batch that modifies the account version or nonce ordering, leading to unexpected behavior in transaction processing or nonce management. The impact includes potential disruption of account security invariants and possible denial-of-service or nonce manipulation attacks.\n",
            "severity": "Medium",
            "location": [
                "BatchCaller.sol#38-46",
                "SsoAccount.sol#119-122"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/batch/BatchCaller.sol",
                "zksync-sso-clave-contracts/src/SsoAccount.sol"
            ]
        }
    ],
    "affected_files": {
        "SsoAccount.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { ACCOUNT_VALIDATION_SUCCESS_MAGIC } from \"@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IAccount.sol\";\nimport { Transaction, TransactionHelper } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { EfficientCall } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/EfficientCall.sol\";\nimport { NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder } from \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\nimport { SystemContractsCaller } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/SystemContractsCaller.sol\";\nimport { Utils } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/Utils.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { HookManager } from \"./managers/HookManager.sol\";\n\nimport { TokenCallbackHandler, IERC165 } from \"./helpers/TokenCallbackHandler.sol\";\n\nimport { Errors } from \"./libraries/Errors.sol\";\nimport { SignatureDecoder } from \"./libraries/SignatureDecoder.sol\";\n\nimport { ERC1271Handler } from \"./handlers/ERC1271Handler.sol\";\nimport { BatchCaller } from \"./batch/BatchCaller.sol\";\n\nimport { ISsoAccount } from \"./interfaces/ISsoAccount.sol\";\nimport { IModuleValidator } from \"./interfaces/IModuleValidator.sol\";\n\n/// @title SSO Account\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The implementation is inspired by Clave wallet.\n/// @notice This contract is a modular and extensible account implementation with support of\n/// multi-ownership, custom modules, validation/execution hooks and different signature validation formats.\n/// @dev Contract is expected to be used as Beacon proxy implementation.\ncontract SsoAccount is Initializable, HookManager, ERC1271Handler, TokenCallbackHandler, BatchCaller, ISsoAccount {\n  // Helper library for the Transaction struct\n  using TransactionHelper for Transaction;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializer function that sets account initial configuration. Expected to be used in the proxy.\n  /// @dev Sets passkey and passkey validator within account storage\n  /// @param initialValidators An array of module validator addresses and initial validation keys\n  /// in an ABI encoded format of `abi.encode(validatorAddr,validationKey))`.\n  /// @param initialK1Owners An array of addresses with full control over the account.\n  function initialize(bytes[] calldata initialValidators, address[] calldata initialK1Owners) external initializer {\n    address validatorAddr;\n    bytes memory initData;\n    for (uint256 i = 0; i < initialValidators.length; ++i) {\n      (validatorAddr, initData) = abi.decode(initialValidators[i], (address, bytes));\n      _addModuleValidator(validatorAddr, initData);\n    }\n    for (uint256 i = 0; i < initialK1Owners.length; ++i) {\n      _k1AddOwner(initialK1Owners[i]);\n    }\n  }\n\n  /// @dev Account might receive/hold base tokens.\n  receive() external payable {}\n\n  /// @notice Called by the bootloader to validate that an account agrees to process the transaction\n  /// (and potentially pay for it).\n  /// @dev The developer should strive to preserve as many steps as possible both for valid\n  /// and invalid transactions as this very method is also used during the gas fee estimation\n  /// (without some of the necessary data, e.g. signature).\n  /// @param _suggestedSignedHash The suggested hash of the transaction that is signed by the signer.\n  /// @param _transaction The transaction data.\n  /// @return magic The magic value that should be equal to the signature of this function.\n  /// if the user agrees to proceed with the transaction.\n  function validateTransaction(\n    bytes32,\n    bytes32 _suggestedSignedHash,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader returns (bytes4 magic) {\n    // TODO: session txs have their own nonce managers, so they have to not alter this nonce\n    _incrementNonce(_transaction.nonce);\n\n    // If there is not enough balance for the transaction, the account should reject it\n    // on the validation step to prevent paying fees for revertable transactions.\n    if (_transaction.totalRequiredBalance() > address(this).balance) {\n      revert Errors.INSUFFICIENT_FUNDS(_transaction.totalRequiredBalance(), address(this).balance);\n    }\n\n    // While the suggested signed hash is usually provided, it is generally\n    // not recommended to rely on it to be present, since in the future\n    // there may be tx types with no suggested signed hash.\n    bytes32 signedHash = _suggestedSignedHash == bytes32(0) ? _transaction.encodeHash() : _suggestedSignedHash;\n\n    magic = _validateTransaction(signedHash, _transaction);\n  }\n\n  /// @notice Called by the bootloader to make the account execute the transaction.\n  /// @dev The transaction is considered successful if this function does not revert\n  /// @param _transaction The transaction data.\n  function executeTransaction(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader runExecutionHooks(_transaction) {\n    address to = _safeCastToAddress(_transaction.to);\n    uint128 value = Utils.safeCastToU128(_transaction.value);\n\n    _executeCall(to, value, _transaction.data);\n  }\n\n  /// @notice Executes a call to a given address with a specified value and calldata.\n  /// @param _to The address to which the call is made.\n  /// @param _value The value to send along with the call.\n  /// @param _data The calldata to pass along with the call.\n  function _executeCall(address _to, uint128 _value, bytes calldata _data) internal {\n    uint32 gas = Utils.safeCastToU32(gasleft());\n    bool success;\n\n    if (_to == address(DEPLOYER_SYSTEM_CONTRACT)) {\n      bytes4 selector = bytes4(_data[:4]);\n      // Check that called function is the deployment method,\n      // the other deployer methods are not supposed to be called from the account.\n      // NOTE: DefaultAccount has the same behavior.\n      bool isSystemCall = selector == DEPLOYER_SYSTEM_CONTRACT.create.selector ||\n        selector == DEPLOYER_SYSTEM_CONTRACT.create2.selector ||\n        selector == DEPLOYER_SYSTEM_CONTRACT.createAccount.selector ||\n        selector == DEPLOYER_SYSTEM_CONTRACT.create2Account.selector;\n      // Note, that the deployer contract can only be called with a \"isSystemCall\" flag.\n      success = EfficientCall.rawCall({\n        _gas: gas,\n        _address: _to,\n        _value: _value,\n        _data: _data,\n        _isSystem: isSystemCall\n      });\n    } else {\n      success = EfficientCall.rawCall(gas, _to, _value, _data, false);\n    }\n\n    if (!success) {\n      EfficientCall.propagateRevert();\n    }\n  }\n\n  /// @notice This function allows an EOA to start a transaction for the account. The main purpose of which is\n  /// to have and entry point for escaping funds when L2 transactions are censored by the chain, and only\n  /// forced transactions are accepted by the network.\n  /// @dev It is not implemented yet.\n  function executeTransactionFromOutside(Transaction calldata) external payable override {\n    revert Errors.METHOD_NOT_IMPLEMENTED();\n  }\n\n  /// @notice This function allows the account to pay for its own gas and used when there is no paymaster.\n  /// @param _transaction The transaction data.\n  /// @dev This method must send at least `tx.gasprice * tx.gasLimit` ETH to the bootloader address.\n  function payForTransaction(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader {\n    bool success = _transaction.payToTheBootloader();\n\n    if (!success) {\n      revert Errors.FEE_PAYMENT_FAILED();\n    }\n  }\n  /// @notice This function is called by the system if the transaction has a paymaster\n  /// and prepares the interaction with the paymaster.\n  /// @param _transaction The transaction data.\n  function prepareForPaymaster(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader {\n    _transaction.processPaymasterInput();\n  }\n\n  /// @dev type(ISsoAccount).interfaceId indicates SSO accounts\n  function supportsInterface(bytes4 interfaceId) public view override(IERC165, TokenCallbackHandler) returns (bool) {\n    return interfaceId == type(ISsoAccount).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /// @notice Validates the provided transaction by validating signature of ECDSA k1 owner.\n  /// or running validation hooks and signature validation in the provided validator address.\n  /// @param _signedHash The signed hash of the transaction.\n  /// @param _transaction The transaction data.\n  /// @return The magic value if the validation was successful and bytes4(0) otherwise.\n  function _validateTransaction(bytes32 _signedHash, Transaction calldata _transaction) internal returns (bytes4) {\n    // Run validation hooks\n    bool hookSuccess = runValidationHooks(_signedHash, _transaction);\n    if (!hookSuccess) {\n      return bytes4(0);\n    }\n\n    if (_transaction.signature.length == 65) {\n      (address signer, ECDSA.RecoverError error) = ECDSA.tryRecover(_signedHash, _transaction.signature);\n      return\n        signer == address(0) || error != ECDSA.RecoverError.NoError || !_k1IsOwner(signer)\n          ? bytes4(0)\n          : ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n    }\n\n    // Extract the signature, validator address and hook data from the _transaction.signature\n    (bytes memory signature, address validator, ) = SignatureDecoder.decodeSignature(_transaction.signature);\n\n    bool validationSuccess = _isModuleValidator(validator) &&\n      IModuleValidator(validator).validateTransaction(_signedHash, signature, _transaction);\n    if (!validationSuccess) {\n      return bytes4(0);\n    }\n\n    return ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n  }\n\n  /// @dev Increments the nonce value in Nonce Holder system contract to ensure replay attack protection.\n  /// @dev Reverts if the Nonce Holder stores different `_nonce` value from the expected one.\n  /// @param _expectedNonce The nonce value expected for the account to be stored in the Nonce Holder.\n  function _incrementNonce(uint256 _expectedNonce) internal {\n    SystemContractsCaller.systemCallWithPropagatedRevert(\n      uint32(gasleft()),\n      address(NONCE_HOLDER_SYSTEM_CONTRACT),\n      0,\n      abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_expectedNonce))\n    );\n  }\n\n  /// @dev Safely casts a uint256 to an address.\n  /// @dev Revert if the value exceeds the maximum size for an address (160 bits).\n  function _safeCastToAddress(uint256 _value) internal pure returns (address) {\n    require(_value <= type(uint160).max, \"Overflow\");\n    return address(uint160(_value));\n  }\n}\n",
        "BatchCaller.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { SystemContractsCaller } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/SystemContractsCaller.sol\";\nimport { EfficientCall } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/EfficientCall.sol\";\nimport { DEPLOYER_SYSTEM_CONTRACT } from \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { SelfAuth } from \"../auth/SelfAuth.sol\";\n\n/// @dev Represents an external call data.\n/// @param target The address to which the call will be made.\n/// @param allowFailure Flag that represents whether to revert the whole batch if the call fails.\n/// @param value The amount of Ether (in wei) to be sent along with the call.\n/// @param callData The calldata to be executed on the `target` address.\nstruct Call {\n  address target;\n  bool allowFailure;\n  uint256 value;\n  bytes callData;\n}\n\n/// @title SSO Account\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Make multiple calls from Account in a single transaction.\n/// @notice The implementation is inspired by Clave wallet.\nabstract contract BatchCaller is SelfAuth {\n  /// @notice Make multiple calls, ensure success if required.\n  /// @dev The total Ether sent across all calls must be equal to `msg.value` to maintain the invariant\n  /// that `msg.value` + `tx.fee` is the maximum amount of Ether that can be spent on the transaction.\n  /// @param _calls Array of Call structs, each representing an individual external call to be made.\n  function batchCall(Call[] calldata _calls) external payable onlySelf {\n    uint256 totalValue;\n    uint256 len = _calls.length;\n    for (uint256 i = 0; i < len; ++i) {\n      totalValue += _calls[i].value;\n      bool success;\n      if (_calls[i].target == address(DEPLOYER_SYSTEM_CONTRACT)) {\n        // Note, that the deployer contract can only be called with a \"systemCall\" flag.\n        success = SystemContractsCaller.systemCall(\n          uint32(gasleft()),\n          _calls[i].target,\n          _calls[i].value,\n          _calls[i].callData\n        );\n      } else {\n        success = EfficientCall.rawCall(gasleft(), _calls[i].target, _calls[i].value, _calls[i].callData, false);\n      }\n\n      if (!_calls[i].allowFailure && !success) {\n        revert Errors.CALL_FAILED(i);\n      }\n    }\n\n    if (totalValue != msg.value) {\n      revert Errors.MSG_VALUE_MISMATCH(msg.value, totalValue);\n    }\n  }\n}\n"
    }
}