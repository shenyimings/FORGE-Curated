{
    "vfp_id": "vfp_00224",
    "project_name": "ackee-blockchain-let's-get-hai-new-core-features-report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Front-running RewardDistributor.updateMerkleRoots allows double claim",
            "description": "The `updateMerkleRoots` function in the RewardDistributor contract does not prevent front-running attacks because it updates the active Merkle root without any safeguards. Since the contract maintains only one active root at a time, a malicious user can monitor the mempool for an upcoming root update transaction and front-run it by claiming rewards from the old root, then immediately claim again from the new root once the update is confirmed. This double claim is possible due to the lack of access control or pausing mechanism during root updates, despite such functionality existing in the contract. The root cause is the absence of a required pause-unpause procedure around root updates, despite such functionality existing in the contract. An attacker with sufficient capital and MEV infrastructure can exploit this by timing their claims around root updates, potentially draining the contract of funds and preventing other users from claiming their rightful rewards if the balance is exhausted. The impact includes financial loss and disruption of fair reward distribution.\n",
            "severity": "High",
            "location": [
                "RewardDistributor.sol::updateMerkleRoots",
                "RewardDistributor.sol::multiClaim"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardDistributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport {Pausable} from '@openzeppelin/contracts/utils/Pausable.sol';\n\nimport {IRewardDistributor} from '@interfaces/tokens/IRewardDistributor.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\n/**\n * @title  RewardDistributor\n * @notice This contract distributes rewards to users to claim every 24 hours\n */\n\ncontract RewardDistributor is Authorizable, Modifiable, Pausable, IRewardDistributor {\n  using Encoding for bytes;\n\n  // --- Data ---\n\n  /// @inheritdoc IRewardDistributor\n  uint256 public epochCounter;\n  /// @inheritdoc IRewardDistributor\n  uint256 public epochDuration;\n  /// @inheritdoc IRewardDistributor\n  uint256 public lastUpdatedTime;\n  /// @inheritdoc IRewardDistributor\n  address public rootSetter;\n\n  /// @inheritdoc IRewardDistributor\n  mapping(address _token => bytes32 _root) public merkleRoots;\n  /// @inheritdoc IRewardDistributor\n  mapping(bytes32 _root => mapping(address _account => bool _hasClaimed)) public isClaimed;\n\n  // --- Init ---\n  constructor(uint256 _epochDuration, address _rootSetter) Authorizable(msg.sender) {\n    epochDuration = _epochDuration;\n    epochCounter = 0;\n    rootSetter = _rootSetter;\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IRewardDistributor\n  function pause() external isAuthorized {\n    _pause();\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function unpause() external isAuthorized {\n    _unpause();\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function updateMerkleRoots(address[] calldata _tokens, bytes32[] calldata _merkleRoots) external {\n    if (block.timestamp - lastUpdatedTime < epochDuration) {\n      revert RewardDistributor_TooSoonEpochNotElapsed();\n    }\n    if (msg.sender != rootSetter) revert RewardDistributor_NotRootSetter();\n    if (_tokens.length != _merkleRoots.length) {\n      revert RewardDistributor_ArrayLengthsMustMatch();\n    }\n\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n      if (_tokens[_i] == address(0)) {\n        revert RewardDistributor_InvalidTokenAddress();\n      }\n      if (_merkleRoots[_i] == bytes32(0)) {\n        revert RewardDistributor_InvalidMerkleRoot();\n      }\n      merkleRoots[_tokens[_i]] = _merkleRoots[_i];\n      emit RewardDistributorMerkleRootUpdated(_tokens[_i], _merkleRoots[_i], epochCounter);\n    }\n    lastUpdatedTime = block.timestamp;\n    epochCounter++;\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function claim(address _token, uint256 _wad, bytes32[] calldata _merkleProof) external whenNotPaused {\n    _claim(_token, _wad, _merkleProof);\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function multiClaim(\n    address[] calldata _tokens,\n    uint256[] calldata _wads,\n    bytes32[][] calldata _merkleProofs\n  ) external whenNotPaused {\n    if (_tokens.length != _wads.length || _wads.length != _merkleProofs.length) {\n      revert RewardDistributor_ArrayLengthsMustMatch();\n    }\n\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n      _claim(_tokens[_i], _wads[_i], _merkleProofs[_i]);\n    }\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function emergencyWidthdraw(address _rescueReceiver, address _token, uint256 _wad) external isAuthorized {\n    if (_token == address(0)) {\n      revert RewardDistributor_InvalidTokenAddress();\n    }\n    if (_wad == 0) revert RewardDistributor_InvalidAmount();\n    IERC20(_token).transfer(_rescueReceiver, _wad);\n    emit RewardDistributorEmergencyWithdrawal(_rescueReceiver, _token, _wad);\n  }\n\n  function _claim(address _token, uint256 _wad, bytes32[] calldata _merkleProof) internal {\n    if (isClaimed[merkleRoots[_token]][msg.sender]) {\n      revert RewardDistributor_AlreadyClaimed();\n    }\n\n    bytes32 _leaf = keccak256(bytes.concat(keccak256(abi.encode(address(msg.sender), _wad))));\n\n    if (MerkleProof.verify(_merkleProof, merkleRoots[_token], _leaf)) {\n      isClaimed[merkleRoots[_token]][msg.sender] = true;\n      IERC20(_token).transfer(msg.sender, _wad);\n      emit RewardDistributorRewardClaimed(msg.sender, _token, _wad);\n    } else {\n      revert RewardDistributor_InvalidMerkleProof();\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    address _address = _data.toAddress();\n\n    if (_param == 'epochDuration') epochDuration = _uint256;\n    else if (_param == 'rootSetter') rootSetter = _address;\n    else revert UnrecognizedParam();\n  }\n}\n"
    }
}