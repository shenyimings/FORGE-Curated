{
    "vfp_id": "vfp_00224",
    "project_name": "SSO Account Abstraction Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-924"
                ]
            },
            "title": "Transaction Can Be Executed in Unintended Period",
            "description": "The SessionKeyValidator allows granular spending controls through time-based periods. However, the `periodIds` used to determine which spending period to charge are passed within the `transaction.signature` field, which is not included in the transaction hash. This means that the `periodIds` are not cryptographically bound to the transaction.\n\nThe root cause is that the ZKsync transaction encoding process does not include the auxiliary data in the signature field when computing the transaction hash. As a result, anyone can modify the `periodIds` without invalidating the signature, allowing replay of the same transaction under different time periods.\n\nAn attacker can observe a transaction in the mempool that fails validation due to insufficient allowance in the intended period. They can then resubmit the same transaction with different `periodIds`, potentially draining allowances from other periods. This is especially dangerous if the session has high allowances in other periods.\n\nThe impact is unauthorized spending from unintended time periods, undermining the security model of time-limited sessions. Users may lose funds or have their spending controls bypassed, leading to financial loss or unexpected behavior.\n",
            "severity": "Medium",
            "location": [
                "SessionKeyValidator.sol::validateTransaction#149",
                "SessionLib.sol::checkPeriodAllowance#69",
                "SsoAccount.sol::validateTransaction#199"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol"
            ]
        }
    ],
    "affected_files": {
        "SessionKeyValidator.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\nimport { IValidatorManager } from \"../interfaces/IValidatorManager.sol\";\nimport { SessionLib } from \"../libraries/SessionLib.sol\";\nimport { SignatureDecoder } from \"../libraries/SignatureDecoder.sol\";\nimport { TimestampAsserterLocator } from \"../helpers/TimestampAsserterLocator.sol\";\n\n/// @title SessionKeyValidator\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice This contract is used to manage sessions for a smart account.\ncontract SessionKeyValidator is IModuleValidator {\n  using SessionLib for SessionLib.SessionStorage;\n\n  event SessionCreated(address indexed account, bytes32 indexed sessionHash, SessionLib.SessionSpec sessionSpec);\n  event SessionRevoked(address indexed account, bytes32 indexed sessionHash);\n\n  // account => number of open sessions\n  // NOTE: expired sessions are still counted if not explicitly revoked\n  mapping(address => uint256) private sessionCounter;\n  // session hash => session state\n  mapping(bytes32 => SessionLib.SessionStorage) private sessions;\n\n  /// @notice Get the session state for an account\n  /// @param account The account to fetch the session state for\n  /// @param spec The session specification to get the state of\n  /// @return The session state: status, remaining fee limit, transfer limits, call value and call parameter limits\n  function sessionState(\n    address account,\n    SessionLib.SessionSpec calldata spec\n  ) external view returns (SessionLib.SessionState memory) {\n    return sessions[keccak256(abi.encode(spec))].getState(account, spec);\n  }\n\n  /// @notice Get the status of a session\n  /// @param account The account to fetch the session status for\n  /// @param sessionHash The session hash to fetch the status of\n  /// @return The status of the session: NotInitialized, Active or Closed\n  function sessionStatus(address account, bytes32 sessionHash) external view returns (SessionLib.Status) {\n    return sessions[sessionHash].status[account];\n  }\n\n  /// @notice Runs on module install\n  /// @param data ABI-encoded session specification to immediately create a session, or empty if not needed\n  function onInstall(bytes calldata data) external override {\n    if (data.length > 0) {\n      require(_addValidationKey(data), \"SessionKeyValidator: failed to add key\");\n    }\n  }\n\n  /// @notice Runs on module uninstall\n  /// @param data ABI-encoded array of session hashes to revoke\n  /// @dev Revokes provided sessions before uninstalling,\n  /// reverts if any session is still active after that.\n  function onUninstall(bytes calldata data) external override {\n    // Revoke keys before uninstalling\n    bytes32[] memory sessionHashes = abi.decode(data, (bytes32[]));\n    for (uint256 i = 0; i < sessionHashes.length; i++) {\n      revokeKey(sessionHashes[i]);\n    }\n    // Here we have make sure that all keys are revoked, so that if the module\n    // is installed again later, there will be no active sessions from the past.\n    require(sessionCounter[msg.sender] == 0, \"Revoke all keys first\");\n  }\n\n  /// @notice This module should not be used to validate signatures\n  /// @return false\n  function validateSignature(bytes32, bytes memory) external pure returns (bool) {\n    return false;\n  }\n\n  /// @notice Create a new session for an account\n  /// @param sessionSpec The session specification to create a session with\n  function createSession(SessionLib.SessionSpec memory sessionSpec) public {\n    bytes32 sessionHash = keccak256(abi.encode(sessionSpec));\n    require(isInitialized(msg.sender), \"Account not initialized\");\n    require(sessionSpec.signer != address(0), \"Invalid signer (create)\");\n    require(sessions[sessionHash].status[msg.sender] == SessionLib.Status.NotInitialized, \"Session already exists\");\n    require(sessionSpec.feeLimit.limitType != SessionLib.LimitType.Unlimited, \"Unlimited fee allowance is not safe\");\n    // Sessions should expire in no less than 60 seconds.\n    uint256 minuteBeforeExpiration = sessionSpec.expiresAt <= 60 ? 0 : sessionSpec.expiresAt - 60;\n    TimestampAsserterLocator.locate().assertTimestampInRange(0, minuteBeforeExpiration);\n\n    sessionCounter[msg.sender]++;\n    sessions[sessionHash].status[msg.sender] = SessionLib.Status.Active;\n    emit SessionCreated(msg.sender, sessionHash, sessionSpec);\n  }\n\n  /// @notice creates a new session for an account, called by onInstall\n  /// @param sessionData ABI-encoded session specification\n  function _addValidationKey(bytes calldata sessionData) internal returns (bool) {\n    SessionLib.SessionSpec memory sessionSpec = abi.decode(sessionData, (SessionLib.SessionSpec));\n    createSession(sessionSpec);\n    return true;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\n    return\n      interfaceId == type(IERC165).interfaceId ||\n      interfaceId == type(IModuleValidator).interfaceId ||\n      interfaceId == type(IModule).interfaceId;\n  }\n\n  /// @notice Revoke a session for an account\n  /// @param sessionHash The hash of a session to revoke\n  /// @dev Decreases the session counter for the account\n  function revokeKey(bytes32 sessionHash) public {\n    require(sessions[sessionHash].status[msg.sender] == SessionLib.Status.Active, \"Nothing to revoke\");\n    sessions[sessionHash].status[msg.sender] = SessionLib.Status.Closed;\n    sessionCounter[msg.sender]--;\n    emit SessionRevoked(msg.sender, sessionHash);\n  }\n\n  /// @notice Revoke multiple sessions for an account\n  /// @param sessionHashes An array of session hashes to revoke\n  function revokeKeys(bytes32[] calldata sessionHashes) external {\n    for (uint256 i = 0; i < sessionHashes.length; i++) {\n      revokeKey(sessionHashes[i]);\n    }\n  }\n\n  /// @notice Check if the validator is registered for the smart account\n  /// @param smartAccount The smart account to check\n  /// @return true if validator is registered for the account, false otherwise\n  function isInitialized(address smartAccount) public view returns (bool) {\n    return IValidatorManager(smartAccount).isModuleValidator(address(this));\n  }\n\n  /// @notice Validate a session transaction for an account\n  /// @param signedHash The hash of the transaction\n  /// @param transaction The transaction to validate\n  /// @return true if the transaction is valid\n  /// @dev Session spec and period IDs must be provided as validator data\n  function validateTransaction(\n    bytes32 signedHash,\n    bytes calldata,\n    Transaction calldata transaction\n  ) external returns (bool) {\n    (bytes memory transactionSignature, address _validator, bytes memory validatorData) = SignatureDecoder\n      .decodeSignature(transaction.signature);\n    (SessionLib.SessionSpec memory spec, uint64[] memory periodIds) = abi.decode(\n      validatorData, // this is passed by the signature builder\n      (SessionLib.SessionSpec, uint64[])\n    );\n    require(spec.signer != address(0), \"Invalid signer (empty)\");\n    bytes32 sessionHash = keccak256(abi.encode(spec));\n    // this generally throws instead of returning false\n    sessions[sessionHash].validate(transaction, spec, periodIds);\n    (address recoveredAddress, ECDSA.RecoverError recoverError) = ECDSA.tryRecover(signedHash, transactionSignature);\n    if (recoverError != ECDSA.RecoverError.NoError || recoveredAddress == address(0)) {\n      return false;\n    }\n    require(recoveredAddress == spec.signer, \"Invalid signer (mismatch)\");\n    // This check is separate and performed last to prevent gas estimation failures\n    sessions[sessionHash].validateFeeLimit(transaction, spec, periodIds[0]);\n    return true;\n  }\n}\n"
    }
}