{
    "vfp_id": "vfp_00168",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Not Forwarding The Exact OFT Messaging Fees",
            "description": "The `deposit` function in `SponsoredOFTSrcPeriphery` forwards the entire `msg.value` to the LayerZero messenger without validating it against the calculated fee, which may cause reverts if the amount is not exact.\nThe cause is lack of input validation and fee adjustment logic; the underlying LayerZero contract enforces strict fee equality.\nUsers who send more or less than the exact fee will have their transactions reverted, leading to a denial of service.\nThe impact is poor user experience and potential loss of transaction fees due to failed transactions.\n",
            "severity": "High",
            "location": [
                "SponsoredOFTSrcPeriphery.sol::deposit"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/sponsored-oft/SponsoredOFTSrcPeriphery.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Application Payloads Lack Versioning",
            "description": "The system uses custom-encoded payloads (`composeMsg` and `hookData`) to pass data between chains, but these payloads do not include a version number.\nThe root cause is the absence of a versioning mechanism in the payload structure.\nIf the payload format is changed on the source chain before the destination is updated, the destination will fail to parse the message, likely causing a revert.\nThe impact is that user funds could become stranded on the destination chain due to parsing failures during upgrades, especially in unsynchronized deployments.\n",
            "severity": "Medium",
            "location": [
                "SponsoredOFTSrcPeriphery.sol::composeMsg#107-116",
                "SponsoredCCTPQuoteLib.sol::hookData#78-87"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/sponsored-oft/SponsoredOFTSrcPeriphery.sol"
            ]
        }
    ],
    "affected_files": {
        "SponsoredOFTSrcPeriphery.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport { Quote } from \"./Structs.sol\";\nimport { QuoteSignLib } from \"./QuoteSignLib.sol\";\nimport { ComposeMsgCodec } from \"./ComposeMsgCodec.sol\";\n\nimport { IOFT, IOAppCore, SendParam, MessagingFee } from \"../../../interfaces/IOFT.sol\";\nimport { AddressToBytes32 } from \"../../../libraries/AddressConverters.sol\";\nimport { MinimalLZOptions } from \"../../../external/libraries/MinimalLZOptions.sol\";\n\nimport { Ownable } from \"@openzeppelin/contracts-v4/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice Source chain periphery contract for users to interact with to start a sponsored or a non-sponsored flow\n/// that allows custom Accross-supported flows on destination chain. Uses LayzerZero's OFT as an underlying bridge\ncontract SponsoredOFTSrcPeriphery is Ownable {\n    using AddressToBytes32 for address;\n    using MinimalLZOptions for bytes;\n    using SafeERC20 for IERC20;\n\n    bytes public constant EMPTY_OFT_COMMAND = new bytes(0);\n\n    /// @notice Token that's being sent by an OFT bridge\n    address public immutable TOKEN;\n    /// @notice OFT contract to interact with to initiate the bridge\n    address public immutable OFT_MESSENGER;\n\n    /// @notice Source endpoint id\n    uint32 public immutable SRC_EID;\n\n    /// @custom:storage-location erc7201:SponsoredOFTSrcPeriphery.main\n    struct MainStorage {\n        /// @notice Signer public key to check the signed quote against\n        address signer;\n        /// @notice A mapping to enforce only a single usage per quote\n        mapping(bytes32 => bool) quoteNonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"erc7201:SponsoredOFTSrcPeriphery.main\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant MAIN_STORAGE_LOCATION = 0xbbe623e022cc184bd276c9a778810da1531bdd4c0bac9d86069eb499aa2eb500;\n\n    function _getMainStorage() private pure returns (MainStorage storage $) {\n        assembly {\n            $.slot := MAIN_STORAGE_LOCATION\n        }\n    }\n\n    /**\n     * @notice Event with auxiliary information. To be used in concert with OftSent event to get relevant quote details\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param originSender The address initiating the transfer on the source chain\n     * @param finalRecipient The final recipient address on the destination chain (as bytes32)\n     * @param destinationHandler The handler contract address on the destination chain (as bytes32)\n     * @param quoteDeadline The timestamp by which the quote expires\n     * @param maxBpsToSponsor Maximum basis points that can be sponsored\n     * @param maxUserSlippageBps Maximum user slippage in basis points\n     * @param finalToken The final token address on the destination chain (as bytes32)\n     * @param sig The signature authorizing this transfer\n     */\n    event SponsoredOFTSend(\n        bytes32 indexed quoteNonce,\n        address indexed originSender,\n        bytes32 indexed finalRecipient,\n        bytes32 destinationHandler,\n        uint256 quoteDeadline,\n        uint256 maxBpsToSponsor,\n        uint256 maxUserSlippageBps,\n        bytes32 finalToken,\n        bytes sig\n    );\n\n    /// @notice Thrown when the source eid of the ioft messenger does not match the src eid supplied\n    error IncorrectSrcEid();\n    /// @notice Thrown when the supplied token does not match the supplied ioft messenger\n    error TokenIOFTMismatch();\n    /// @notice Thrown when the signer for quote does not match `signer`\n    error IncorrectSignature();\n    /// @notice Thrown if Quote has expired\n    error QuoteExpired();\n    /// @notice Thrown if Quote nonce was already used\n    error NonceAlreadyUsed();\n    /// @notice Thrown when provided msg.value is not sufficient to cover OFT bridging fee\n    error InsufficientNativeFee();\n\n    constructor(address _token, address _oftMessenger, uint32 _srcEid, address _signer) {\n        TOKEN = _token;\n        OFT_MESSENGER = _oftMessenger;\n        SRC_EID = _srcEid;\n        if (IOAppCore(_oftMessenger).endpoint().eid() != _srcEid) {\n            revert IncorrectSrcEid();\n        }\n        if (IOFT(_oftMessenger).token() != _token) {\n            revert TokenIOFTMismatch();\n        }\n        _getMainStorage().signer = _signer;\n    }\n\n    /**\n     * @notice Returns the signer address that is used to validate the signatures of the quotes.\n     * @return The signer address.\n     */\n    function signer() external view returns (address) {\n        return _getMainStorage().signer;\n    }\n\n    /**\n     * @notice Returns true if the nonce has been used, false otherwise.\n     * @param nonce The nonce to check.\n     * @return True if the nonce has been used, false otherwise.\n     */\n    function usedNonces(bytes32 nonce) external view returns (bool) {\n        return _getMainStorage().quoteNonces[nonce];\n    }\n\n    /**\n     * @notice Main entrypoint function to start the user flow\n     * @param quote The quote struct containing all transfer parameters\n     * @param signature The signature authorizing the quote\n     */\n    function deposit(Quote calldata quote, bytes calldata signature) external payable {\n        // Step 1: validate quote and mark quote nonce used\n        _validateQuote(quote, signature);\n        _getMainStorage().quoteNonces[quote.signedParams.nonce] = true;\n\n        // Step 2: build oft send params from quote\n        (SendParam memory sendParam, MessagingFee memory fee, address refundAddress) = _buildOftTransfer(quote);\n\n        if (fee.nativeFee > msg.value) {\n            revert InsufficientNativeFee();\n        }\n        // OFT doesn't refund the unused native fee portion. Instead, it expects precise fee.nativeFee to be transferred\n        // as msg.value, so we refund the user ourselves\n        uint256 nativeFeeRefund = msg.value - fee.nativeFee;\n        if (nativeFeeRefund > 0) {\n            // Adapted from \"@openzeppelin/contracts/utils/Address.sol\";\n            (bool success, ) = payable(refundAddress).call{ value: nativeFeeRefund }(\"\");\n            require(success, \"Unable to send value, recipient may have reverted\");\n        }\n\n        // Step 3: pull tokens from user and apporove OFT messenger\n        IERC20(TOKEN).safeTransferFrom(msg.sender, address(this), quote.signedParams.amountLD);\n        IERC20(TOKEN).forceApprove(address(OFT_MESSENGER), quote.signedParams.amountLD);\n\n        // Step 4: send oft transfer and emit event with auxiliary data\n        IOFT(OFT_MESSENGER).send{ value: fee.nativeFee }(sendParam, fee, refundAddress);\n        emit SponsoredOFTSend(\n            quote.signedParams.nonce,\n            msg.sender,\n            quote.signedParams.finalRecipient,\n            quote.signedParams.destinationHandler,\n            quote.signedParams.deadline,\n            quote.signedParams.maxBpsToSponsor,\n            quote.unsignedParams.maxUserSlippageBps,\n            quote.signedParams.finalToken,\n            signature\n        );\n    }\n\n    function _buildOftTransfer(\n        Quote calldata quote\n    ) internal view returns (SendParam memory, MessagingFee memory, address) {\n        bytes memory composeMsg = ComposeMsgCodec._encode(\n            quote.signedParams.nonce,\n            quote.signedParams.deadline,\n            quote.signedParams.maxBpsToSponsor,\n            quote.unsignedParams.maxUserSlippageBps,\n            quote.signedParams.finalRecipient,\n            quote.signedParams.finalToken,\n            quote.signedParams.executionMode,\n            quote.signedParams.actionData\n        );\n\n        bytes memory extraOptions = MinimalLZOptions\n            .newOptions()\n            .addExecutorLzReceiveOption(uint128(quote.signedParams.lzReceiveGasLimit), uint128(0))\n            .addExecutorLzComposeOption(uint16(0), uint128(quote.signedParams.lzComposeGasLimit), uint128(0));\n\n        SendParam memory sendParam = SendParam(\n            quote.signedParams.dstEid,\n            quote.signedParams.destinationHandler,\n            // Only support OFT sends that don't take fees in sent token. Set `minAmountLD = amountLD` to enforce this\n            quote.signedParams.amountLD,\n            quote.signedParams.amountLD,\n            extraOptions,\n            composeMsg,\n            // Only support empty OFT commands\n            EMPTY_OFT_COMMAND\n        );\n\n        MessagingFee memory fee = IOFT(OFT_MESSENGER).quoteSend(sendParam, false);\n\n        return (sendParam, fee, quote.unsignedParams.refundRecipient);\n    }\n\n    function _validateQuote(Quote calldata quote, bytes calldata signature) internal view {\n        MainStorage storage $ = _getMainStorage();\n        if (!QuoteSignLib.isSignatureValid($.signer, quote.signedParams, signature)) {\n            revert IncorrectSignature();\n        }\n        if (quote.signedParams.deadline < block.timestamp) {\n            revert QuoteExpired();\n        }\n        if (quote.signedParams.srcEid != SRC_EID) {\n            revert IncorrectSrcEid();\n        }\n        if ($.quoteNonces[quote.signedParams.nonce]) {\n            revert NonceAlreadyUsed();\n        }\n    }\n\n    function setSigner(address _newSigner) external onlyOwner {\n        _getMainStorage().signer = _newSigner;\n    }\n}\n"
    }
}