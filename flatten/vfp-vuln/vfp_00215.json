{
    "vfp_id": "vfp_00215",
    "project_name": "cantina_stryke_aug2025.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Premiums & AMM fees are custody-routed to feeReceiver with no on-chain entitlement for LPers",
            "description": "Option premiums and AMM fees are sent directly to a centralized feeReceiver address without on-chain accounting or attribution to individual LPs. The root cause is the lack of a trustless, on-chain reward distribution mechanism. Although the project claims to distribute rewards off-chain via Merkle claims, this introduces custodial risk and availability dependency, as LPs must rely on an external operator to claim their rewards. An attacker or malicious operator could delay, censor, or misappropriate distributions. The impact is that LPs' earnings exist only as an off-chain promise, reducing transparency and increasing counterparty risk. This undermines the decentralized ethos of DeFi and could lead to disputes or loss of funds if the off-chain system fails.\n",
            "severity": "Medium",
            "location": [
                "V3BaseHandler.sol#L442-L472"
            ],
            "files": [
                "contracts/src/handlers/V3BaseHandler.sol"
            ]
        }
    ],
    "affected_files": {
        "V3BaseHandler.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IHandler} from \"../interfaces/IHandler.sol\";\nimport {IHook} from \"../interfaces/IHook.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {IV3Pool} from \"../interfaces/handlers/V3/IV3Pool.sol\";\n\nimport {ERC6909} from \"../libraries/tokens/ERC6909.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LiquidityAmounts} from \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport {TickMath} from \"v3-core/libraries/TickMath.sol\";\nimport {FullMath} from \"v3-core/libraries/FullMath.sol\";\nimport {FixedPoint128} from \"v3-core/libraries/FixedPoint128.sol\";\n\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n/// @title V3BaseHandler\n/// @author 0xcarrot\n/// @notice Abstract contract for handling Uniswap V3 liquidity positions\n/// @dev Implements IHandler interface and inherits from ERC6909 and Ownable\nabstract contract V3BaseHandler is IHandler, ERC6909, Ownable {\n    using Math for uint128;\n    using TickMath for int24;\n    using SafeERC20 for IERC20;\n\n    /// @notice Struct to store information about a token ID\n    struct TokenIdInfo {\n        uint128 totalLiquidity;\n        uint128 liquidityUsed;\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n        address token0;\n        address token1;\n        uint24 fee;\n        uint128 reservedLiquidity;\n    }\n\n    /// @notice Struct for minting a new position\n    struct MintPositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n    }\n\n    /// @notice Struct for burning an existing position\n    struct BurnPositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n    }\n\n    /// @notice Struct for reserving liquidity\n    struct ReserveOperation {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        bool isReserve;\n    }\n\n    /// @notice Struct for using a position\n    struct UsePositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidityToUse;\n    }\n\n    /// @notice Struct for un-using a position\n    struct UnusePositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidityToUnuse;\n    }\n\n    /// @notice Struct for donating to a position\n    struct DonateParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 amount0;\n        uint128 amount1;\n    }\n\n    /// @notice Enum for wildcard actions\n    enum WildcardActions {\n        RESERVE_LIQUIDITY,\n        COLLECT_FEES\n    }\n\n    /// @notice Struct for reserved liquidity information\n    struct ReserveLiquidityInfo {\n        uint128 liquidity;\n        uint64 lastReserve;\n    }\n\n    /// @notice Mapping of token IDs to their information\n    mapping(uint256 => TokenIdInfo) public tokenIds;\n    /// @notice Mapping of whitelisted applications\n    mapping(address => bool) public whitelistedApps;\n    /// @notice Mapping of reserved liquidity per user for each token ID\n    mapping(uint256 => mapping(address => ReserveLiquidityInfo)) public reservedLiquidityPerUser;\n\n    /// @notice Mapping of reserve cooldown per hook\n    mapping(address => uint64) public reserveCooldownHook;\n\n    /// @notice Mapping of registered hooks\n    mapping(address => bool) public hookRegistered;\n\n    /// @notice Mapping of hook permissions\n    mapping(address => HookPermInfo) public hookPerms;\n\n    /// @notice Address of the fee receiver\n    address public feeReceiver;\n\n    /// @notice Pause state of the contract\n    bool pause;\n\n    error NotWhitelisted();\n    error InsufficientLiquidity();\n    error BeforeReserveCooldown();\n    error InvalidTicks();\n    error HookNotRegistered();\n    error Paused();\n    error HookAlreadyRegistered();\n\n    event LogMintPositionHandler(MintPositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogBurnPositionHandler(BurnPositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogUsePositionHandler(UsePositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogUnusePositionHandler(UnusePositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogDonateToPosition(DonateParams params, address context);\n    event LogReservedLiquidity(ReserveOperation params, address context, uint256 lastReserve);\n    event LogWithdrawReserveLiquidity(ReserveOperation params, address context, uint256 amount0, uint256 amount1);\n    event LogCollectedFees(\n        IV3Pool pool, address hook, int24 tickLower, int24 tickUpper, uint256 tokensOwed0, uint256 tokensOwed1\n    );\n\n    /// @notice Constructor for V3BaseHandler\n    /// @param _feeReceiver Address to receive fees\n    constructor(address _feeReceiver) Ownable(msg.sender) {\n        feeReceiver = _feeReceiver;\n    }\n\n    /// @notice Checks if the caller is whitelisted\n    function onlyWhitelisted() private view {\n        if (!whitelistedApps[msg.sender]) revert NotWhitelisted();\n        if (pause) revert Paused();\n    }\n\n    /// @notice Registers a new hook\n    /// @param _hook Address of the hook to register\n    /// @param _info Permission information for the hook\n    function registerHook(address _hook, IHandler.HookPermInfo memory _info) external onlyOwner {\n        if (hookRegistered[_hook]) {\n            revert HookAlreadyRegistered();\n        }\n\n        hookPerms[_hook] = _info;\n        hookRegistered[_hook] = true;\n    }\n\n    struct MintLiquidityInternalCache {\n        bool self;\n        uint256 tokenId;\n        IV3Pool pool;\n        address hook;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        int24 tickLower;\n        int24 tickUpper;\n        address context;\n    }\n\n    /// @notice Mints a new position in the Uniswap V3 pool\n    /// @param context The address context for minting\n    /// @param _mintPositionData Encoded data for minting position\n    /// @return sharesMinted The amount of shares minted\n    function mintPositionHandler(address context, bytes calldata _mintPositionData) external returns (uint256) {\n        onlyWhitelisted();\n\n        (MintPositionParams memory _params, bytes memory hookData) =\n            abi.decode(_mintPositionData, (MintPositionParams, bytes));\n\n        if (hookPerms[_params.hook].onMint && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onMintBefore(hookData);\n        }\n\n        (uint128 liquidity,,) = mintInternal(\n            MintLiquidityInternalCache({\n                self: false,\n                tokenId: uint256(\n                    keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n                ),\n                pool: _params.pool,\n                hook: _params.hook,\n                liquidity: _params.liquidity,\n                amount0: 0,\n                amount1: 0,\n                tickLower: _params.tickLower,\n                tickUpper: _params.tickUpper,\n                context: context\n            })\n        );\n\n        return liquidity;\n    }\n\n    function mintInternal(MintLiquidityInternalCache memory cache) private returns (uint128, uint256, uint256) {\n        TokenIdInfo storage tki = tokenIds[cache.tokenId];\n\n        if (tki.token0 == address(0)) {\n            tki.token0 = cache.pool.token0();\n            tki.token1 = cache.pool.token1();\n            tki.fee = cache.pool.fee();\n        }\n\n        (uint160 sqrtPriceX96,) = _getCurrentSqrtPriceX96(cache.pool);\n\n        if (cache.liquidity == 0) {\n            cache.liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96,\n                cache.tickLower.getSqrtRatioAtTick(),\n                cache.tickUpper.getSqrtRatioAtTick(),\n                cache.amount0,\n                cache.amount1\n            );\n        }\n\n        if (cache.amount0 == 0 && cache.amount1 == 0) {\n            (cache.amount0, cache.amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                sqrtPriceX96,\n                cache.tickLower.getSqrtRatioAtTick(),\n                cache.tickUpper.getSqrtRatioAtTick(),\n                cache.liquidity\n            );\n        }\n\n        (cache.liquidity, cache.amount0, cache.amount1) =\n            _addLiquidity(cache.self, tki, cache.tickLower, cache.tickUpper, cache.amount0, cache.amount1);\n\n        _feeCalculation(tki, cache.pool, cache.tickLower, cache.tickUpper);\n\n        tki.totalLiquidity += cache.liquidity;\n\n        _mint(cache.context, cache.tokenId, cache.liquidity);\n\n        emit LogMintPositionHandler(\n            MintPositionParams(cache.pool, cache.hook, cache.tickLower, cache.tickUpper, cache.liquidity),\n            cache.context,\n            cache.amount0,\n            cache.amount1\n        );\n\n        return (cache.liquidity, cache.amount0, cache.amount1);\n    }\n\n    struct BurnLiquidityInternalCache {\n        uint256 tokenId;\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        address context;\n        address receiver;\n    }\n\n    /// @notice Burns an existing position in the Uniswap V3 pool\n    /// @param context The address context for burning\n    /// @param _burnPositionData Encoded data for burning position\n    /// @return The amount of liquidity burned\n    function burnPositionHandler(address context, bytes calldata _burnPositionData) external returns (uint256) {\n        onlyWhitelisted();\n\n        (BurnPositionParams memory _params, bytes memory hookData) =\n            abi.decode(_burnPositionData, (BurnPositionParams, bytes));\n\n        if (hookPerms[_params.hook].onBurn && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onBurnBefore(hookData);\n        }\n\n        burnInternal(\n            BurnLiquidityInternalCache({\n                tokenId: uint256(\n                    keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n                ),\n                pool: _params.pool,\n                hook: _params.hook,\n                tickLower: _params.tickLower,\n                tickUpper: _params.tickUpper,\n                liquidity: _params.liquidity,\n                context: context,\n                receiver: context\n            })\n        );\n\n        return _params.liquidity;\n    }\n\n    function burnInternal(BurnLiquidityInternalCache memory cache) private returns (uint256, uint256) {\n        TokenIdInfo storage tki = tokenIds[cache.tokenId];\n\n        if ((tki.totalLiquidity - tki.liquidityUsed) < cache.liquidity) {\n            revert InsufficientLiquidity();\n        }\n\n        (uint256 amount0, uint256 amount1) = cache.pool.burn(cache.tickLower, cache.tickUpper, cache.liquidity);\n\n        _feeCalculation(tki, cache.pool, cache.tickLower, cache.tickUpper);\n\n        cache.pool.collect(cache.receiver, cache.tickLower, cache.tickUpper, uint128(amount0), uint128(amount1));\n\n        tki.totalLiquidity -= cache.liquidity;\n\n        _burn(cache.context, cache.tokenId, cache.liquidity);\n\n        emit LogBurnPositionHandler(\n            BurnPositionParams(cache.pool, cache.hook, cache.tickLower, cache.tickUpper, cache.liquidity),\n            cache.context,\n            amount0,\n            amount1\n        );\n\n        return (amount0, amount1);\n    }\n\n    /// @notice Uses a portion of liquidity from an existing position\n    /// @param _usePositionData Encoded data for using position\n    /// @return An array of token addresses, an array of amounts, and the liquidity used\n    function usePositionHandler(bytes calldata _usePositionData)\n        external\n        returns (address[] memory, uint256[] memory, uint256)\n    {\n        onlyWhitelisted();\n\n        (UsePositionParams memory _params, bytes memory hookData) =\n            abi.decode(_usePositionData, (UsePositionParams, bytes));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        if (hookPerms[_params.hook].onUse && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onPositionUseBefore(hookData);\n        }\n\n        if ((tki.totalLiquidity - tki.liquidityUsed) < _params.liquidityToUse) {\n            revert InsufficientLiquidity();\n        }\n\n        (uint256 amount0, uint256 amount1) =\n            _removeLiquidity(_params.pool, _params.tickLower, _params.tickUpper, _params.liquidityToUse);\n\n        _params.pool.collect(msg.sender, _params.tickLower, _params.tickUpper, uint128(amount0), uint128(amount1));\n\n        _feeCalculation(tki, _params.pool, _params.tickLower, _params.tickUpper);\n\n        tki.liquidityUsed += _params.liquidityToUse;\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tki.token0;\n        tokens[1] = tki.token1;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n\n        emit LogUsePositionHandler(_params, msg.sender, amount0, amount1);\n\n        return (tokens, amounts, _params.liquidityToUse);\n    }\n\n    /// @notice Returns previously used liquidity to a position\n    /// @param _unusePositionData Encoded data for un-using position\n    /// @return An array of amounts and the liquidity returned\n    function unusePositionHandler(bytes calldata _unusePositionData) external returns (uint256[] memory, uint256) {\n        onlyWhitelisted();\n\n        (UnusePositionParams memory _params, bytes memory hookData) =\n            abi.decode(_unusePositionData, (UnusePositionParams, bytes));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        if (hookPerms[_params.hook].onUnuse && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onPositionUnUseBefore(hookData);\n        }\n\n        (uint160 sqrtPriceX96,) = _getCurrentSqrtPriceX96(_params.pool);\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            _params.tickLower.getSqrtRatioAtTick(),\n            _params.tickUpper.getSqrtRatioAtTick(),\n            uint128(_params.liquidityToUnuse)\n        );\n\n        (uint128 liquidity,,) = _addLiquidity(false, tki, _params.tickLower, _params.tickUpper, amount0, amount1);\n\n        _feeCalculation(tki, _params.pool, _params.tickLower, _params.tickUpper);\n\n        if (tki.liquidityUsed >= liquidity) {\n            tki.liquidityUsed -= liquidity;\n        } else {\n            tki.totalLiquidity += (liquidity - tki.liquidityUsed);\n            tki.liquidityUsed = 0;\n        }\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n\n        _params.liquidityToUnuse = liquidity;\n\n        emit LogUnusePositionHandler(_params, msg.sender, amount0, amount1);\n\n        return (amounts, uint256(liquidity));\n    }\n\n    /// @notice Allows donation of tokens to a specific position\n    /// @param _donateData Encoded data for donation\n    /// @return An array of amounts and a placeholder value\n    function donateToPosition(bytes calldata _donateData) external returns (uint256[] memory, uint256) {\n        onlyWhitelisted();\n\n        (DonateParams memory _params, bytes memory hookData) = abi.decode(_donateData, (DonateParams, bytes));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        if (hookPerms[_params.hook].onDonate && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onDonationBefore(hookData);\n        }\n\n        TokenIdInfo memory tki = tokenIds[tokenId];\n\n        if (_params.amount0 > 0) {\n            IERC20(tki.token0).safeTransferFrom(msg.sender, feeReceiver, _params.amount0);\n        }\n\n        if (_params.amount1 > 0) {\n            IERC20(tki.token1).safeTransferFrom(msg.sender, feeReceiver, _params.amount1);\n        }\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = _params.amount0;\n        amounts[1] = _params.amount1;\n\n        emit LogDonateToPosition(_params, msg.sender);\n\n        return (amounts, 0);\n    }\n\n    /// @notice Handles various wildcard actions\n    /// @param context The address context for the action\n    /// @param _wildcardData Encoded data for the wildcard action\n    /// @return Encoded result of the wildcard action\n    function wildcardHandler(address context, bytes calldata _wildcardData) external returns (bytes memory) {\n        onlyWhitelisted();\n\n        (WildcardActions wca, bytes memory _data) = abi.decode(_wildcardData, (WildcardActions, bytes));\n\n        if (wca == WildcardActions.RESERVE_LIQUIDITY) {\n            _reserveOps(context, _data);\n        } else if (wca == WildcardActions.COLLECT_FEES) {\n            _collectFees(_data);\n        }\n        return bytes(\"\");\n    }\n\n    /// @notice Internal function to reserve liquidity\n    /// @param context The address context for the operation\n    /// @param _reserveOperation Encoded data for the reserve operation\n    function _reserveOps(address context, bytes memory _reserveOperation) private {\n        ReserveOperation memory _params = abi.decode(_reserveOperation, (ReserveOperation));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        ReserveLiquidityInfo storage rld = reservedLiquidityPerUser[tokenId][context];\n\n        if (_params.isReserve) {\n            rld.liquidity += _params.liquidity;\n            rld.lastReserve = uint64(block.timestamp);\n\n            tki.totalLiquidity -= _params.liquidity;\n\n            tki.reservedLiquidity += _params.liquidity;\n\n            _burn(context, tokenId, _params.liquidity);\n\n            emit LogReservedLiquidity(_params, context, rld.lastReserve);\n        } else {\n            if (rld.lastReserve + reserveCooldownHook[_params.hook] > block.timestamp) revert BeforeReserveCooldown();\n\n            if (((tki.totalLiquidity + tki.reservedLiquidity) - tki.liquidityUsed) < _params.liquidity) {\n                revert InsufficientLiquidity();\n            }\n\n            (uint256 amount0, uint256 amount1) =\n                _params.pool.burn(_params.tickLower, _params.tickUpper, _params.liquidity);\n\n            _params.pool.collect(context, _params.tickLower, _params.tickUpper, uint128(amount0), uint128(amount1));\n\n            _feeCalculation(tki, _params.pool, _params.tickLower, _params.tickUpper);\n\n            tki.reservedLiquidity -= _params.liquidity;\n            rld.liquidity -= _params.liquidity;\n\n            emit LogWithdrawReserveLiquidity(_params, context, amount1, amount1);\n        }\n    }\n\n    /// @notice Calculates the tokens required for a position\n    /// @param _positionData Encoded position data\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function _tokensToPull(bytes calldata _positionData) private view returns (address[] memory, uint256[] memory) {\n        (MintPositionParams memory _params,) = abi.decode(_positionData, (MintPositionParams, bytes));\n\n        (uint160 sqrtPriceX96,) = _getCurrentSqrtPriceX96(_params.pool);\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            _params.tickLower.getSqrtRatioAtTick(),\n            _params.tickUpper.getSqrtRatioAtTick(),\n            uint128(_params.liquidity)\n        );\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = _params.pool.token0();\n        tokens[1] = _params.pool.token1();\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n\n        return (tokens, amounts);\n    }\n\n    /// @notice Calculates tokens required for un-using a position\n    /// @param _unusePositionData Encoded data for un-using a position\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function tokensToPullForUnUse(bytes calldata _unusePositionData)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        return _tokensToPull(_unusePositionData);\n    }\n\n    /// @notice Calculates tokens required for donating to a position\n    /// @param _donatePosition Encoded data for donation\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function tokensToPullForDonate(bytes calldata _donatePosition)\n        external\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        (DonateParams memory _params,) = abi.decode(_donatePosition, (DonateParams, bytes));\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = _params.pool.token0();\n        tokens[1] = _params.pool.token1();\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = _params.amount0;\n        amounts[1] = _params.amount1;\n\n        return (tokens, amounts);\n    }\n\n    /// @notice Calculates tokens required for wildcard actions\n    /// @param _data wildcard data (unused in this implementation)\n    /// @return tokens An array of token addresses (empty in this implementation)\n    /// @return amounts An array of token amounts (empty in this implementation)\n    function tokensToPullForWildcard(bytes calldata _data) external view returns (address[] memory, uint256[] memory) {\n        address[] memory tokens = new address[](2);\n        uint256[] memory amounts = new uint256[](2);\n        return (tokens, amounts);\n    }\n\n    /// @notice Generates a unique identifier for a handler\n    /// @param _data Encoded data for generating the identifier\n    /// @return handlerIdentifierId The unique identifier\n    function getHandlerIdentifier(bytes calldata _data) external view returns (uint256 handlerIdentifierId) {\n        (address pool, address hook, int24 tickLower, int24 tickUpper) =\n            abi.decode(_data, (address, address, int24, int24));\n\n        return uint256(keccak256(abi.encode(address(this), pool, hook, tickLower, tickUpper)));\n    }\n\n    /// @notice Calculates tokens required for minting a position\n    /// @param _mintPositionData Encoded data for minting a position\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function tokensToPullForMint(bytes calldata _mintPositionData)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        return _tokensToPull(_mintPositionData);\n    }\n\n    /// @notice Internal function to get the current sqrt price from a pool\n    /// @param pool The Uniswap V3 pool\n    /// @return sqrtPriceX96 The current sqrt price\n    /// @return tick The current tick\n    function _getCurrentSqrtPriceX96(IV3Pool pool) internal view returns (uint160 sqrtPriceX96, int24 tick) {\n        (sqrtPriceX96, tick,,,,,) = pool.slot0();\n    }\n\n    /// @notice Internal function to add liquidity to a position\n    /// @param self Whether the operation is performed by the contract itself\n    /// @param tki Token ID information\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0\n    /// @param amount1 The amount of token1\n    /// @return liquidity The amount of liquidity added\n    /// @return amount0 The actual amount of token0 used\n    /// @return amount1 The actual amount of token1 used\n    function _addLiquidity(\n        bool self,\n        TokenIdInfo memory tki,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    ) internal virtual returns (uint128, uint256, uint256) {}\n\n    /// @notice Internal function to remove liquidity from a position\n    /// @param _pool The Uniswap V3 pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidity The amount of liquidity to remove\n    /// @return amount0 The amount of token0 received\n    /// @return amount1 The amount of token1 received\n    function _removeLiquidity(IV3Pool _pool, int24 tickLower, int24 tickUpper, uint128 liquidity)\n        internal\n        virtual\n        returns (uint256, uint256)\n    {}\n\n    /// @notice Internal function to compute the position key\n    /// @param owner The owner of the position\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @return The position key\n    function _computePositionKey(address owner, int24 tickLower, int24 tickUpper) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n    }\n\n    /// @notice Internal function to collect fees from a position\n    /// @param _collectFeesData Encoded data for fee collection\n    function _collectFees(bytes memory _collectFeesData) internal virtual {\n        (IV3Pool _pool, address _hook, int24 _tickLower, int24 _tickUpper) =\n            abi.decode(_collectFeesData, (IV3Pool, address, int24, int24));\n\n        uint256 tokenId = uint256(keccak256(abi.encode(address(this), _pool, _hook, _tickLower, _tickUpper)));\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        _removeLiquidity(_pool, _tickLower, _tickUpper, 0);\n\n        _feeCalculation(tki, _pool, _tickLower, _tickUpper);\n\n        emit LogCollectedFees(_pool, _hook, _tickLower, _tickUpper, tki.tokensOwed0, tki.tokensOwed1);\n\n        _pool.collect(feeReceiver, _tickLower, _tickUpper, tki.tokensOwed0, tki.tokensOwed1);\n\n        tki.tokensOwed0 = 0;\n        tki.tokensOwed1 = 0;\n    }\n\n    /// @notice Internal function to calculate fees for a position\n    /// @param _tki Token ID information\n    /// @param _pool The Uniswap V3 pool\n    /// @param _tickLower The lower tick of the position\n    /// @param _tickUpper The upper tick of the position\n    function _feeCalculation(TokenIdInfo storage _tki, IV3Pool _pool, int24 _tickLower, int24 _tickUpper)\n        internal\n        virtual\n    {\n        bytes32 positionKey = _computePositionKey(address(this), _tickLower, _tickUpper);\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128,,) = _pool.positions(positionKey);\n        unchecked {\n            _tki.tokensOwed0 += uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0LastX128 - _tki.feeGrowthInside0LastX128,\n                    _tki.totalLiquidity + _tki.reservedLiquidity - _tki.liquidityUsed,\n                    FixedPoint128.Q128\n                )\n            );\n            _tki.tokensOwed1 += uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1LastX128 - _tki.feeGrowthInside1LastX128,\n                    _tki.totalLiquidity + _tki.reservedLiquidity - _tki.liquidityUsed,\n                    FixedPoint128.Q128\n                )\n            );\n\n            _tki.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n            _tki.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n        }\n    }\n\n    // Admin Functions\n\n    /// @notice Updates various handler settings\n    /// @param _app The app to update the whitelist status of\n    /// @param _status The new whitelist status of the app\n    /// @param _hook The hook to update the reserve cooldown for\n    /// @param _newReserveCooldown The new reserve cooldown for the hook\n    /// @param _newFeeReceiver The new fee receiver address\n    function updateHandlerSettings(\n        address _app,\n        bool _status,\n        address _hook,\n        uint64 _newReserveCooldown,\n        address _newFeeReceiver\n    ) external onlyOwner {\n        whitelistedApps[_app] = _status;\n        reserveCooldownHook[_hook] = _newReserveCooldown;\n        feeReceiver = _newFeeReceiver;\n    }\n\n    // SOS admin functions\n\n    /// @notice Sweeps tokens from the contract\n    /// @param _token The token to sweep\n    /// @param _amount The amount of tokens to sweep\n    function sweepTokens(address _token, uint256 _amount) external onlyOwner {\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /// @notice Emergency pauses the contract\n    function emergencyPause() external onlyOwner {\n        pause = true;\n    }\n\n    /// @notice Emergency unpauses the contract\n    function emergencyUnpause() external onlyOwner {\n        pause = false;\n    }\n\n    /// @notice Checks if the contract supports an interface\n    /// @param interfaceId The Id of the interface\n    /// @return bool True if the interface is supported\n    function supportsInterface(bytes4 interfaceId) public view override(ERC6909) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    }
}