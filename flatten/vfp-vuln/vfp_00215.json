{
    "vfp_id": "vfp_00215",
    "project_name": "IBC Eureka - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "IBC does not work with chains that generate subsecond blocks",
            "description": "The _checkUpdateResult function in SP1ICS07Tendermint enforces that the timestamp of a new consensus state must be strictly greater than the previous one. However, this comparison uses second-level precision, which breaks when a blockchain produces multiple blocks within the same second (i.e., subsecond blockchains). In such cases, even legitimate updates with identical timestamps will fail the check, causing the IBC client to reject valid state updates. This results in the freezing of the IBC client, halting all cross-chain communication for chains that operate with subsecond block times. The root cause is the lack of finer time granularity (e.g., milliseconds or nanoseconds) in the timestamp comparison logic, making the system incompatible with high-throughput blockchains.\n",
            "severity": "Critical",
            "location": [
                "SP1ICS07Tendermint::_checkUpdateResult"
            ],
            "files": [
                "6bb8fcf6af5094487c85f12d9398c8401fd4a1b7/solidity-ibc-eureka/contracts/light-clients/SP1ICS07Tendermint.sol"
            ]
        }
    ],
    "affected_files": {
        "SP1ICS07Tendermint.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { IICS07TendermintMsgs } from \"./msgs/IICS07TendermintMsgs.sol\";\nimport { IUpdateClientMsgs } from \"./msgs/IUpdateClientMsgs.sol\";\nimport { IMembershipMsgs } from \"./msgs/IMembershipMsgs.sol\";\nimport { IUpdateClientAndMembershipMsgs } from \"./msgs/IUcAndMembershipMsgs.sol\";\nimport { IMisbehaviourMsgs } from \"./msgs/IMisbehaviourMsgs.sol\";\nimport { ISP1Msgs } from \"./msgs/ISP1Msgs.sol\";\nimport { ILightClientMsgs } from \"../msgs/ILightClientMsgs.sol\";\nimport { IICS02ClientMsgs } from \"../msgs/IICS02ClientMsgs.sol\";\n\nimport { ISP1ICS07TendermintErrors } from \"./errors/ISP1ICS07TendermintErrors.sol\";\nimport { ISP1ICS07Tendermint } from \"./ISP1ICS07Tendermint.sol\";\nimport { ILightClient } from \"../interfaces/ILightClient.sol\";\nimport { ISP1Verifier } from \"@sp1-contracts/ISP1Verifier.sol\";\n\nimport { Paths } from \"./utils/Paths.sol\";\nimport { Multicall } from \"@openzeppelin-contracts/utils/Multicall.sol\";\nimport { TransientSlot } from \"@openzeppelin-contracts/utils/TransientSlot.sol\";\n\n/// @title SP1 ICS07 Tendermint Light Client\n/// @author srdtrk\n/// @notice This contract implements an ICS07 IBC tendermint light client using SP1.\n/// @custom:poc This is a proof of concept implementation.\ncontract SP1ICS07Tendermint is ISP1ICS07TendermintErrors, ISP1ICS07Tendermint, ILightClient, Multicall {\n    using TransientSlot for *;\n\n    /// @inheritdoc ISP1ICS07Tendermint\n    bytes32 public immutable UPDATE_CLIENT_PROGRAM_VKEY;\n    /// @inheritdoc ISP1ICS07Tendermint\n    bytes32 public immutable MEMBERSHIP_PROGRAM_VKEY;\n    /// @inheritdoc ISP1ICS07Tendermint\n    bytes32 public immutable UPDATE_CLIENT_AND_MEMBERSHIP_PROGRAM_VKEY;\n    /// @inheritdoc ISP1ICS07Tendermint\n    bytes32 public immutable MISBEHAVIOUR_PROGRAM_VKEY;\n    /// @inheritdoc ISP1ICS07Tendermint\n    ISP1Verifier public immutable VERIFIER;\n\n    /// @notice The ICS07Tendermint client state\n    IICS07TendermintMsgs.ClientState public clientState;\n    /// @notice The mapping from height to consensus state keccak256 hashes.\n    /// @dev Revision number need not be keyed as it is not allowed to change.\n    mapping(uint32 height => bytes32 hash) private _consensusStateHashes;\n\n    /// @inheritdoc ISP1ICS07Tendermint\n    uint16 public constant ALLOWED_SP1_CLOCK_DRIFT = 30 minutes;\n\n    /// @notice The constructor sets the program verification key and the initial client and consensus states.\n    /// @param updateClientProgramVkey The verification key for the update client program.\n    /// @param membershipProgramVkey The verification key for the verify (non)membership program.\n    /// @param updateClientAndMembershipProgramVkey The verification key for the update client and membership program.\n    /// @param misbehaviourProgramVkey The verification key for the misbehaviour program.\n    /// @param sp1Verifier The address of the SP1 verifier contract.\n    /// @param _clientState The encoded initial client state.\n    /// @param _consensusState The encoded initial consensus state.\n    constructor(\n        bytes32 updateClientProgramVkey,\n        bytes32 membershipProgramVkey,\n        bytes32 updateClientAndMembershipProgramVkey,\n        bytes32 misbehaviourProgramVkey,\n        address sp1Verifier,\n        bytes memory _clientState,\n        bytes32 _consensusState\n    ) {\n        UPDATE_CLIENT_PROGRAM_VKEY = updateClientProgramVkey;\n        MEMBERSHIP_PROGRAM_VKEY = membershipProgramVkey;\n        UPDATE_CLIENT_AND_MEMBERSHIP_PROGRAM_VKEY = updateClientAndMembershipProgramVkey;\n        MISBEHAVIOUR_PROGRAM_VKEY = misbehaviourProgramVkey;\n\n        clientState = abi.decode(_clientState, (IICS07TendermintMsgs.ClientState));\n        _consensusStateHashes[clientState.latestHeight.revisionHeight] = _consensusState;\n\n        VERIFIER = ISP1Verifier(sp1Verifier);\n\n        require(\n            clientState.trustingPeriod + ALLOWED_SP1_CLOCK_DRIFT <= clientState.unbondingPeriod,\n            TrustingPeriodTooLong(clientState.trustingPeriod, clientState.unbondingPeriod)\n        );\n    }\n\n    /// @inheritdoc ILightClient\n    function getClientState() external view returns (bytes memory) {\n        return abi.encode(clientState);\n    }\n\n    /// @inheritdoc ISP1ICS07Tendermint\n    function getConsensusStateHash(uint32 revisionHeight) public view returns (bytes32) {\n        bytes32 hash = _consensusStateHashes[revisionHeight];\n        require(hash != 0, ConsensusStateNotFound());\n        return hash;\n    }\n\n    /// @dev This function verifies the public values and forwards the proof to the SP1 verifier.\n    /// @inheritdoc ILightClient\n    function updateClient(bytes calldata updateMsg) external notFrozen returns (ILightClientMsgs.UpdateResult) {\n        IUpdateClientMsgs.MsgUpdateClient memory msgUpdateClient =\n            abi.decode(updateMsg, (IUpdateClientMsgs.MsgUpdateClient));\n        require(\n            msgUpdateClient.sp1Proof.vKey == UPDATE_CLIENT_PROGRAM_VKEY,\n            VerificationKeyMismatch(UPDATE_CLIENT_PROGRAM_VKEY, msgUpdateClient.sp1Proof.vKey)\n        );\n\n        IUpdateClientMsgs.UpdateClientOutput memory output =\n            abi.decode(msgUpdateClient.sp1Proof.publicValues, (IUpdateClientMsgs.UpdateClientOutput));\n\n        _validateUpdateClientPublicValues(output);\n\n        ILightClientMsgs.UpdateResult updateResult = _checkUpdateResult(output);\n        if (updateResult == ILightClientMsgs.UpdateResult.Update) {\n            // adding the new consensus state to the mapping\n            if (output.newHeight.revisionHeight > clientState.latestHeight.revisionHeight) {\n                clientState.latestHeight = output.newHeight;\n            }\n            _consensusStateHashes[output.newHeight.revisionHeight] = keccak256(abi.encode(output.newConsensusState));\n        } else if (updateResult == ILightClientMsgs.UpdateResult.Misbehaviour) {\n            clientState.isFrozen = true;\n        } else if (updateResult == ILightClientMsgs.UpdateResult.NoOp) {\n            return ILightClientMsgs.UpdateResult.NoOp;\n        }\n\n        _verifySP1Proof(msgUpdateClient.sp1Proof);\n\n        return updateResult;\n    }\n\n    /// @inheritdoc ILightClient\n    function verifyMembership(ILightClientMsgs.MsgVerifyMembership calldata msg_)\n        external\n        notFrozen\n        returns (uint256)\n    {\n        require(msg_.value.length > 0, EmptyValue());\n        return _membership(msg_.proof, msg_.proofHeight, msg_.path, msg_.value);\n    }\n\n    /// @inheritdoc ILightClient\n    function verifyNonMembership(ILightClientMsgs.MsgVerifyNonMembership calldata msg_)\n        external\n        notFrozen\n        returns (uint256)\n    {\n        return _membership(msg_.proof, msg_.proofHeight, msg_.path, bytes(\"\"));\n    }\n\n    /// @notice The entrypoint for verifying (non)membership proof.\n    /// @dev This is a non-membership proof if the value is empty.\n    /// @dev If the proof is empty, then we assume that the proof was cached earlier in the same tx.\n    /// @dev The proof is cached in the transient storage.\n    /// @param proof The encoded proof.\n    /// @param proofHeight The height of the proof.\n    /// @param path The path of the key-value pair.\n    /// @param value The value of the key-value pair.\n    /// @return timestamp The timestamp of the trusted consensus state.\n    function _membership(\n        bytes calldata proof,\n        IICS02ClientMsgs.Height calldata proofHeight,\n        bytes[] calldata path,\n        bytes memory value\n    )\n        private\n        returns (uint256 timestamp)\n    {\n        if (proof.length == 0) {\n            // cached proof\n            return _getCachedKvPair(proofHeight.revisionHeight, IMembershipMsgs.KVPair(path, value));\n        }\n\n        IMembershipMsgs.MembershipProof memory membershipProof = abi.decode(proof, (IMembershipMsgs.MembershipProof));\n        if (membershipProof.proofType == IMembershipMsgs.MembershipProofType.SP1MembershipProof) {\n            return _handleSP1MembershipProof(proofHeight, membershipProof.proof, path, value);\n        } else if (membershipProof.proofType == IMembershipMsgs.MembershipProofType.SP1MembershipAndUpdateClientProof) {\n            return _handleSP1UpdateClientAndMembership(proofHeight, membershipProof.proof, path, value);\n        }\n\n        // unreachable\n        revert UnknownMembershipProofType(uint8(membershipProof.proofType));\n    }\n\n    /// @dev The misbehavior is verfied in the sp1 program. Here we only check the public values which contain the\n    /// trusted headers.\n    /// @inheritdoc ILightClient\n    function misbehaviour(bytes calldata misbehaviourMsg) external notFrozen {\n        IMisbehaviourMsgs.MsgSubmitMisbehaviour memory msgSubmitMisbehaviour =\n            abi.decode(misbehaviourMsg, (IMisbehaviourMsgs.MsgSubmitMisbehaviour));\n        require(\n            msgSubmitMisbehaviour.sp1Proof.vKey == MISBEHAVIOUR_PROGRAM_VKEY,\n            VerificationKeyMismatch(MISBEHAVIOUR_PROGRAM_VKEY, msgSubmitMisbehaviour.sp1Proof.vKey)\n        );\n\n        IMisbehaviourMsgs.MisbehaviourOutput memory output =\n            abi.decode(msgSubmitMisbehaviour.sp1Proof.publicValues, (IMisbehaviourMsgs.MisbehaviourOutput));\n\n        _validateMisbehaviourOutput(output);\n\n        _verifySP1Proof(msgSubmitMisbehaviour.sp1Proof);\n\n        // If the misbehaviour and proof is valid, the client needs to be frozen\n        clientState.isFrozen = true;\n    }\n\n    /// @inheritdoc ILightClient\n    function upgradeClient(bytes calldata) external view notFrozen {\n        // TODO: Not yet implemented. (#78)\n        revert FeatureNotSupported();\n    }\n\n    /// @notice Handles the `SP1MembershipProof` proof type.\n    /// @param proofHeight The height of the proof.\n    /// @param proofBytes The encoded proof.\n    /// @param kvPath The path of the key-value pair.\n    /// @param kvValue The value of the key-value pair.\n    /// @return The timestamp of the trusted consensus state.\n    function _handleSP1MembershipProof(\n        IICS02ClientMsgs.Height calldata proofHeight,\n        bytes memory proofBytes,\n        bytes[] calldata kvPath,\n        bytes memory kvValue\n    )\n        private\n        returns (uint256)\n    {\n        IMembershipMsgs.SP1MembershipProof memory proof = abi.decode(proofBytes, (IMembershipMsgs.SP1MembershipProof));\n        require(\n            proof.sp1Proof.vKey == MEMBERSHIP_PROGRAM_VKEY,\n            VerificationKeyMismatch(MEMBERSHIP_PROGRAM_VKEY, proof.sp1Proof.vKey)\n        );\n\n        IMembershipMsgs.MembershipOutput memory output =\n            abi.decode(proof.sp1Proof.publicValues, (IMembershipMsgs.MembershipOutput));\n        require(\n            output.kvPairs.length > 0 && output.kvPairs.length <= type(uint16).max,\n            LengthIsOutOfRange(output.kvPairs.length, 1, type(uint16).max)\n        );\n\n        {\n            // loop through the key-value pairs and validate them\n            bool found = false;\n            for (uint256 i = 0; i < output.kvPairs.length; i++) {\n                if (!Paths.equal(output.kvPairs[i].path, kvPath)) {\n                    continue;\n                }\n\n                bytes memory value = output.kvPairs[i].value;\n                require(\n                    value.length == kvValue.length && keccak256(value) == keccak256(kvValue),\n                    MembershipProofValueMismatch(kvValue, value)\n                );\n\n                found = true;\n                break;\n            }\n            require(found, MembershipProofKeyNotFound(kvPath));\n        }\n\n        _validateMembershipOutput(output.commitmentRoot, proofHeight.revisionHeight, proof.trustedConsensusState);\n\n        _verifySP1Proof(proof.sp1Proof);\n\n        // We avoid the cost of caching for single kv pairs, as reusing the proof is not necessary\n        if (output.kvPairs.length > 1) {\n            _cacheKvPairs(proofHeight.revisionHeight, output.kvPairs, proof.trustedConsensusState.timestamp);\n        }\n        return proof.trustedConsensusState.timestamp;\n    }\n\n    /// @notice The entrypoint for handling the `SP1MembershipAndUpdateClientProof` proof type.\n    /// @dev This function verifies the public values and forwards the proof to the SP1 verifier.\n    /// @param proofHeight The height of the proof.\n    /// @param proofBytes The encoded proof.\n    /// @param kvPath The path of the key-value pair.\n    /// @param kvValue The value of the key-value pair.\n    /// @return The timestamp of the new consensus state.\n    // solhint-disable-next-line code-complexity\n    function _handleSP1UpdateClientAndMembership(\n        IICS02ClientMsgs.Height calldata proofHeight,\n        bytes memory proofBytes,\n        bytes[] calldata kvPath,\n        bytes memory kvValue\n    )\n        private\n        returns (uint256)\n    {\n        // validate proof and deserialize output\n        IUpdateClientAndMembershipMsgs.UcAndMembershipOutput memory output;\n        {\n            IMembershipMsgs.SP1MembershipAndUpdateClientProof memory proof =\n                abi.decode(proofBytes, (IMembershipMsgs.SP1MembershipAndUpdateClientProof));\n            require(\n                proof.sp1Proof.vKey == UPDATE_CLIENT_AND_MEMBERSHIP_PROGRAM_VKEY,\n                VerificationKeyMismatch(UPDATE_CLIENT_AND_MEMBERSHIP_PROGRAM_VKEY, proof.sp1Proof.vKey)\n            );\n\n            output = abi.decode(proof.sp1Proof.publicValues, (IUpdateClientAndMembershipMsgs.UcAndMembershipOutput));\n            require(\n                output.kvPairs.length > 0 && output.kvPairs.length <= type(uint16).max,\n                LengthIsOutOfRange(output.kvPairs.length, 1, type(uint16).max)\n            );\n\n            require(\n                proofHeight.revisionHeight == output.updateClientOutput.newHeight.revisionHeight\n                    && proofHeight.revisionNumber == output.updateClientOutput.newHeight.revisionNumber,\n                ProofHeightMismatch(\n                    proofHeight.revisionNumber,\n                    proofHeight.revisionHeight,\n                    output.updateClientOutput.newHeight.revisionNumber,\n                    output.updateClientOutput.newHeight.revisionHeight\n                )\n            );\n\n            _validateUpdateClientPublicValues(output.updateClientOutput);\n\n            _verifySP1Proof(proof.sp1Proof);\n        }\n\n        // check update result\n        {\n            ILightClientMsgs.UpdateResult updateResult = _checkUpdateResult(output.updateClientOutput);\n            if (updateResult == ILightClientMsgs.UpdateResult.Update) {\n                // adding the new consensus state to the mapping\n                if (proofHeight.revisionHeight > clientState.latestHeight.revisionHeight) {\n                    clientState.latestHeight = proofHeight;\n                }\n                _consensusStateHashes[proofHeight.revisionHeight] =\n                    keccak256(abi.encode(output.updateClientOutput.newConsensusState));\n            } else if (updateResult == ILightClientMsgs.UpdateResult.Misbehaviour) {\n                revert CannotHandleMisbehavior();\n            } // else: NoOp\n        }\n\n        // loop through the key-value pairs and validate them\n        {\n            bool found = false;\n            for (uint256 i = 0; i < output.kvPairs.length; i++) {\n                if (!Paths.equal(output.kvPairs[i].path, kvPath)) {\n                    continue;\n                }\n\n                bytes memory value = output.kvPairs[i].value;\n                require(\n                    value.length == kvValue.length && keccak256(value) == keccak256(kvValue),\n                    MembershipProofValueMismatch(kvValue, value)\n                );\n\n                found = true;\n                break;\n            }\n            require(found, MembershipProofKeyNotFound(kvPath));\n        }\n\n        _validateMembershipOutput(\n            output.updateClientOutput.newConsensusState.root,\n            output.updateClientOutput.newHeight.revisionHeight,\n            output.updateClientOutput.newConsensusState\n        );\n\n        // We avoid the cost of caching for single kv pairs, as reusing the proof is not necessary\n        if (output.kvPairs.length > 1) {\n            _cacheKvPairs(\n                proofHeight.revisionHeight, output.kvPairs, output.updateClientOutput.newConsensusState.timestamp\n            );\n        }\n        return output.updateClientOutput.newConsensusState.timestamp;\n    }\n\n    /// @notice Validates the MembershipOutput public values.\n    /// @param outputCommitmentRoot The commitment root of the output.\n    /// @param proofHeight The height of the proof.\n    /// @param trustedConsensusState The trusted consensus state\n    function _validateMembershipOutput(\n        bytes32 outputCommitmentRoot,\n        uint32 proofHeight,\n        IICS07TendermintMsgs.ConsensusState memory trustedConsensusState\n    )\n        private\n        view\n    {\n        bytes32 trustedConsensusStateHash = keccak256(abi.encode(trustedConsensusState));\n        bytes32 storedConsensusStateHash = getConsensusStateHash(proofHeight);\n        require(\n            trustedConsensusStateHash == storedConsensusStateHash,\n            ConsensusStateHashMismatch(storedConsensusStateHash, trustedConsensusStateHash)\n        );\n\n        require(\n            outputCommitmentRoot == trustedConsensusState.root,\n            ConsensusStateRootMismatch(trustedConsensusState.root, outputCommitmentRoot)\n        );\n    }\n\n    /// @notice Validates the SP1ICS07UpdateClientOutput public values.\n    /// @param output The public values.\n    function _validateUpdateClientPublicValues(IUpdateClientMsgs.UpdateClientOutput memory output) private view {\n        _validateClientStateAndTime(output.clientState, output.time);\n\n        bytes32 outputConsensusStateHash = keccak256(abi.encode(output.trustedConsensusState));\n        bytes32 storedConsensusStateHash = getConsensusStateHash(output.trustedHeight.revisionHeight);\n        require(\n            outputConsensusStateHash == storedConsensusStateHash,\n            ConsensusStateHashMismatch(storedConsensusStateHash, outputConsensusStateHash)\n        );\n    }\n\n    /// @notice Validates the SP1ICS07MisbehaviourOutput public values.\n    /// @param output The public values.\n    function _validateMisbehaviourOutput(IMisbehaviourMsgs.MisbehaviourOutput memory output) private view {\n        _validateClientStateAndTime(output.clientState, output.time);\n\n        // make sure the trusted consensus state from header 1 is known (trusted) by matching it with the one in the\n        // mapping\n        bytes32 outputConsensusStateHash1 = keccak256(abi.encode(output.trustedConsensusState1));\n        bytes32 storedConsensusStateHash1 = getConsensusStateHash(output.trustedHeight1.revisionHeight);\n        require(\n            outputConsensusStateHash1 == storedConsensusStateHash1,\n            ConsensusStateHashMismatch(storedConsensusStateHash1, outputConsensusStateHash1)\n        );\n\n        // make sure the trusted consensus state from header 2 is known (trusted) by matching it with the one in the\n        // mapping\n        bytes32 outputConsensusStateHash2 = keccak256(abi.encode(output.trustedConsensusState2));\n        bytes32 storedConsensusStateHash2 = getConsensusStateHash(output.trustedHeight2.revisionHeight);\n        require(\n            outputConsensusStateHash2 == storedConsensusStateHash2,\n            ConsensusStateHashMismatch(storedConsensusStateHash2, outputConsensusStateHash2)\n        );\n    }\n\n    /// @notice Validates the client state and time.\n    /// @dev This function does not check the equality of the latest height and isFrozen.\n    /// @param publicClientState The public client state.\n    /// @param time The time.\n    function _validateClientStateAndTime(\n        IICS07TendermintMsgs.ClientState memory publicClientState,\n        uint64 time\n    )\n        private\n        view\n    {\n        require(time <= block.timestamp, ProofIsInTheFuture(block.timestamp, time));\n        require(block.timestamp - time <= ALLOWED_SP1_CLOCK_DRIFT, ProofIsTooOld(block.timestamp, time));\n\n        // Check client state equality\n        // NOTE: We do not check the equality of latest height and isFrozen, this is because:\n        // 1. Latest height can be updated by a frontrunner relayer in order to DOS the proof of another relayer.\n        // 2. Each external call has the `notFrozen` modifier which checks if the client is frozen.\n        // 3. The revision number is not allowed to change with us checking the chain-id and the implementation in the\n        // sp1 program.\n        require(\n            bytes(publicClientState.chainId).length == bytes(clientState.chainId).length\n                && keccak256(bytes(publicClientState.chainId)) == keccak256(bytes(clientState.chainId)),\n            ChainIdMismatch(clientState.chainId, publicClientState.chainId)\n        );\n        require(\n            publicClientState.trustLevel.numerator == clientState.trustLevel.numerator\n                && publicClientState.trustLevel.denominator == clientState.trustLevel.denominator,\n            TrustThresholdMismatch(\n                clientState.trustLevel.numerator,\n                clientState.trustLevel.denominator,\n                publicClientState.trustLevel.numerator,\n                publicClientState.trustLevel.denominator\n            )\n        );\n        require(\n            publicClientState.trustingPeriod == clientState.trustingPeriod,\n            TrustingPeriodMismatch(clientState.trustingPeriod, publicClientState.trustingPeriod)\n        );\n        require(\n            publicClientState.unbondingPeriod == clientState.unbondingPeriod,\n            UnbondingPeriodMismatch(clientState.unbondingPeriod, publicClientState.unbondingPeriod)\n        );\n    }\n\n    /// @notice Checks for basic misbehaviour.\n    /// @dev This function checks if the consensus state at the new height is different than the one in the mapping\n    /// @dev or if the timestamp is not increasing.\n    /// @dev If any of these conditions are met, it returns a Misbehaviour UpdateResult.\n    /// @param output The public values of the update client program.\n    /// @return The result of the update.\n    function _checkUpdateResult(IUpdateClientMsgs.UpdateClientOutput memory output)\n        private\n        view\n        returns (ILightClientMsgs.UpdateResult)\n    {\n        bytes32 consensusStateHash = _consensusStateHashes[output.newHeight.revisionHeight];\n        if (consensusStateHash == bytes32(0)) {\n            // No consensus state at the new height, so no misbehaviour\n            return ILightClientMsgs.UpdateResult.Update;\n        } else if (\n            consensusStateHash != keccak256(abi.encode(output.newConsensusState))\n                || output.trustedConsensusState.timestamp >= output.newConsensusState.timestamp\n        ) {\n            // The consensus state at the new height is different than the one in the mapping\n            // or the timestamp is not increasing\n            return ILightClientMsgs.UpdateResult.Misbehaviour;\n        } else {\n            // The consensus state at the new height is the same as the one in the mapping\n            return ILightClientMsgs.UpdateResult.NoOp;\n        }\n    }\n\n    /// @notice Verifies the SP1 proof\n    /// @param proof The SP1 proof.\n    /// @dev WARNING: proof.vKey must be verified before calling this function.\n    function _verifySP1Proof(ISP1Msgs.SP1Proof memory proof) private view {\n        VERIFIER.verifyProof(proof.vKey, proof.publicValues, proof.proof);\n    }\n\n    /// @notice Caches the key-value pairs to the transient storage with the timestamp.\n    /// @param proofHeight The height of the proof.\n    /// @param kvPairs The key-value pairs.\n    /// @param timestamp The timestamp of the trusted consensus state.\n    /// @dev WARNING: Transient store is not reverted even if a message within a transaction reverts.\n    /// @dev WARNING: This function must be called after all proof and validation checks.\n    function _cacheKvPairs(uint32 proofHeight, IMembershipMsgs.KVPair[] memory kvPairs, uint256 timestamp) private {\n        for (uint256 i = 0; i < kvPairs.length; i++) {\n            bytes32 kvPairHash = keccak256(abi.encode(proofHeight, kvPairs[i]));\n            kvPairHash.asUint256().tstore(timestamp);\n        }\n    }\n\n    /// @notice Gets the timestamp of the cached key-value pair from the transient storage.\n    /// @param proofHeight The height of the proof.\n    /// @param kvPair The key-value pair.\n    /// @return The timestamp of the cached key-value pair.\n    function _getCachedKvPair(\n        uint32 proofHeight,\n        IMembershipMsgs.KVPair memory kvPair\n    )\n        private\n        view\n        returns (uint256)\n    {\n        bytes32 kvPairHash = keccak256(abi.encode(proofHeight, kvPair));\n        uint256 timestamp = kvPairHash.asUint256().tload();\n        require(timestamp != 0, KeyValuePairNotInCache(kvPair.path, kvPair.value));\n        return timestamp;\n    }\n\n    /// @notice Modifier to check if the client is not frozen.\n    modifier notFrozen() {\n        require(!clientState.isFrozen, FrozenClientState());\n        _;\n    }\n}\n"
    }
}