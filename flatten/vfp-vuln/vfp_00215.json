{
    "vfp_id": "vfp_00215",
    "project_name": "Forta Firewall Incremental Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Applying Comparison to Raw Signed Integers Causes Unexpected Results",
            "description": "The `_secureExecution` function in the `Firewall` contract casts a byte range from calldata directly to `uint256` without preserving signedness. If the data represents a negative signed integer, its two's complement form becomes a very large positive number when interpreted as unsigned.\nThe cause is improper handling of signed integers during type casting, leading to incorrect interpretation of negative values as large positive ones.\nAn attacker could craft calldata containing negative integers represented in two's complement, which would be misinterpreted as large positive values during threshold checks in `_checkpointActivated`, potentially bypassing intended access controls or validation logic.\nThe impact includes incorrect execution decisions based on flawed comparisons, which could allow unauthorized or unintended operations to proceed, undermining the firewall's security guarantees.\n",
            "severity": "Medium",
            "location": [
                "Firewall.sol::_secureExecution#179-197",
                "Firewall.sol::_checkpointActivated#232-257"
            ],
            "files": [
                "forta-firewall-contracts/src/Firewall.sol"
            ]
        }
    ],
    "affected_files": {
        "Firewall.sol": "// SPDX-License-Identifier: GNU General Public License Version 3\n// See license at: https://github.com/forta-network/forta-firewall-contracts/blob/master/LICENSE-GPLv3.md\n\npragma solidity ^0.8.25;\n\nimport {Proxy} from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport {StorageSlot} from \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {FirewallPermissions} from \"./FirewallPermissions.sol\";\nimport {Quantization} from \"./Quantization.sol\";\nimport \"./interfaces/IFirewall.sol\";\nimport \"./interfaces/FirewallDependencies.sol\";\nimport \"./interfaces/IAttesterInfo.sol\";\n\n/**\n * @notice Firewall is a base contract which provides protection against exploits.\n * It keeps a collection of configurable checkpoints per function, in its namespaced storage,\n * and makes available internal functions to the child contract in order to help intercept\n * function calls.\n *\n * When a function call is intercepted, one of the arguments can be used as a reference to compare\n * with a configured threshold. Exceeding the threshold causes checkpoint execution which requires\n * a corresponding attestation to be present in the SecurityValidator.\n */\nabstract contract Firewall is IFirewall, IAttesterInfo, FirewallPermissions {\n    using StorageSlot for bytes32;\n    using Quantization for uint256;\n\n    error InvalidActivationType();\n    error UntrustedAttester(address attester);\n    error CheckpointBlocked();\n\n    struct FirewallStorage {\n        ISecurityValidator validator;\n        ICheckpointHook checkpointHook;\n        bytes32 attesterControllerId;\n        mapping(bytes4 funcSelector => Checkpoint checkpoint) checkpoints;\n    }\n\n    /// @custom:storage-location erc7201:forta.Firewall.storage\n    bytes32 private constant STORAGE_SLOT = 0x993f81a6354aa9d98fa5ac249e63371dfc7f5589eeb8a5b081145c8ed289c400;\n\n    /**\n     * @notice Updates the firewall config.\n     * @param _validator Validator used for checkpoint execution calls.\n     * @param _checkpointHook Checkpoint hook contract which is called before every checkpoint.\n     * @param _attesterControllerId The ID of the external controller which keeps settings related\n     * to the attesters.\n     * @param _firewallAccess Firewall access controller.\n     */\n    function updateFirewallConfig(\n        ISecurityValidator _validator,\n        ICheckpointHook _checkpointHook,\n        bytes32 _attesterControllerId,\n        IFirewallAccess _firewallAccess\n    ) public virtual onlyFirewallAdmin {\n        _updateFirewallConfig(_validator, _checkpointHook, _attesterControllerId, _firewallAccess);\n    }\n\n    /**\n     * @notice Updates the firewall config.\n     * @param _validator The security validator which the firewall calls for saving\n     * the attestation and executing checkpoints.\n     * @param _checkpointHook Checkpoint hook contract which is called before every checkpoint.\n     * @param _attesterControllerId The id of the controller that lives on Forta chain. Attesters\n     * regards this value to find out the settings for this contract before creating an attestation.\n     * @param _firewallAccess The access control contract that knows the accounts which can manage\n     * the settings of a firewall.\n     */\n    function _updateFirewallConfig(\n        ISecurityValidator _validator,\n        ICheckpointHook _checkpointHook,\n        bytes32 _attesterControllerId,\n        IFirewallAccess _firewallAccess\n    ) internal virtual {\n        FirewallStorage storage $ = _getFirewallStorage();\n        $.validator = _validator;\n        $.checkpointHook = _checkpointHook;\n        $.attesterControllerId = _attesterControllerId;\n        _updateFirewallAccess(_firewallAccess);\n        emit SecurityConfigUpdated(_validator, _firewallAccess);\n        emit AttesterControllerUpdated(_attesterControllerId);\n    }\n\n    /**\n     * @notice Returns the firewall configuration.\n     * @return validator The security validator which the firewall calls for saving\n     * the attestation and executing checkpoints.\n     * @return checkpointHook Checkpoint hook contract which is called before every checkpoint.\n     * @return attesterControllerId The id of the controller that lives on Forta chain. Attesters\n     * regards this value to find out the settings for this contract before creating an attestation.\n     * @return firewallAccess The access control contract that knows the accounts which can manage\n     * the settings of a firewall.\n     */\n    function getFirewallConfig()\n        public\n        view\n        returns (\n            ISecurityValidator validator,\n            ICheckpointHook checkpointHook,\n            bytes32 attesterControllerId,\n            IFirewallAccess firewallAccess\n        )\n    {\n        FirewallStorage storage $ = _getFirewallStorage();\n        firewallAccess = _getFirewallAccess();\n        return ($.validator, $.checkpointHook, $.attesterControllerId, firewallAccess);\n    }\n\n    /**\n     * @notice Returns the attester controller id from the configuration.\n     */\n    function getAttesterControllerId() public view returns (bytes32) {\n        return _getFirewallStorage().attesterControllerId;\n    }\n\n    /**\n     * @notice Sets checkpoint values for given function selector, call data byte range\n     * and with given threshold type.\n     * @param selector Selector of the function.\n     * @param checkpoint Checkpoint data.\n     */\n    function setCheckpoint(bytes4 selector, Checkpoint memory checkpoint) public virtual onlyCheckpointManager {\n        require(checkpoint.refStart <= checkpoint.refEnd, \"refStart is larger than refEnd\");\n        _getFirewallStorage().checkpoints[selector] = checkpoint;\n    }\n\n    /**\n     * @notice Sets the checkpoint activation type.\n     * @param selector Selector of the function.\n     * @param activation Activation type.\n     */\n    function setCheckpointActivation(bytes4 selector, Activation activation) public virtual onlyCheckpointManager {\n        _getFirewallStorage().checkpoints[selector].activation = activation;\n    }\n\n    /**\n     * @notice Gets the checkpoint values for given function selector.\n     * @param selector Selector of the function.\n     */\n    function getCheckpoint(bytes4 selector) public view virtual returns (uint192, uint16, uint16, Activation, bool) {\n        Checkpoint storage checkpoint = _getFirewallStorage().checkpoints[selector];\n        return (\n            checkpoint.threshold,\n            checkpoint.refStart,\n            checkpoint.refEnd,\n            checkpoint.activation,\n            checkpoint.trustedOrigin\n        );\n    }\n\n    /**\n     * @notice Helps write an attestation and call any function of this contract.\n     * @param attestation The set of fields that correspond to and enable the execution of call(s)\n     * @param attestationSignature Signature of EIP-712 message\n     * @param data Call data which contains the function selector and the encoded arguments\n     */\n    function attestedCall(Attestation calldata attestation, bytes calldata attestationSignature, bytes calldata data)\n        public\n        returns (bytes memory)\n    {\n        _getFirewallStorage().validator.saveAttestation(attestation, attestationSignature);\n        return Address.functionDelegateCall(address(this), data);\n    }\n\n    function _secureExecution() internal virtual {\n        Checkpoint memory checkpoint = _getFirewallStorage().checkpoints[msg.sig];\n        require(checkpoint.refEnd <= msg.data.length, \"refEnd too large for slicing\");\n        /// Default to msg data length.\n        uint256 refEnd = checkpoint.refEnd;\n        if (refEnd > msg.data.length) refEnd = msg.data.length;\n        if (msg.sig == 0 || (checkpoint.refEnd == 0 && checkpoint.refStart == 0)) {\n            /// Ether transaction or paid transaction with no ref range: use msg.value as ref\n            _secureExecution(msg.sender, msg.sig, msg.value);\n        } else if (refEnd - checkpoint.refStart > 32) {\n            /// Support larger data ranges as direct input hashes instead of deriving a reference.\n            bytes calldata byteRange = msg.data[checkpoint.refStart:checkpoint.refEnd];\n            bytes32 input = keccak256(byteRange);\n            _secureExecution(msg.sender, msg.sig, input);\n        } else {\n            bytes calldata byteRange = msg.data[checkpoint.refStart:checkpoint.refEnd];\n            uint256 ref = uint256(bytes32(byteRange));\n            _secureExecution(msg.sender, msg.sig, ref);\n        }\n    }\n\n    function _secureExecution(address caller, bytes4 selector, uint256 ref) internal virtual {\n        Checkpoint memory checkpoint = _getFirewallStorage().checkpoints[selector];\n        bool ok;\n        (ref, ok) = _checkpointActivated(checkpoint, caller, selector, ref);\n        if (ok) _executeCheckpoint(checkpoint, caller, bytes32(ref.quantize()), selector);\n    }\n\n    function _secureExecution(address caller, bytes4 selector, bytes32 input) internal virtual {\n        Checkpoint memory checkpoint = _getFirewallStorage().checkpoints[selector];\n        bool ok = _checkpointActivated(checkpoint);\n        if (ok) _executeCheckpoint(checkpoint, caller, input, selector);\n    }\n\n    function _executeCheckpoint(Checkpoint memory checkpoint, address caller, bytes32 input, bytes4 selector)\n        internal\n        virtual\n    {\n        FirewallStorage storage $ = _getFirewallStorage();\n\n        /// Short-circuit if the trusted origin pattern is supported and is available.\n        /// Otherwise, continue with checkpoint execution.\n        if (_isTrustedOrigin(checkpoint)) return;\n\n        $.validator.executeCheckpoint(keccak256(abi.encode(caller, address(this), selector, input)));\n\n        /// Ensure first that the current attester can be trusted.\n        /// If the current attester is zero address, let the security validator deal with that.\n        address currentAttester = $.validator.getCurrentAttester();\n        if (currentAttester != address(0) && !_isTrustedAttester(currentAttester)) {\n            revert UntrustedAttester(currentAttester);\n        }\n    }\n\n    function _checkpointActivated(Checkpoint memory checkpoint, address caller, bytes4 selector, uint256 ref)\n        internal\n        virtual\n        returns (uint256, bool)\n    {\n        ICheckpointHook checkpointHook = _getFirewallStorage().checkpointHook;\n        if (address(checkpointHook) != address(0)) {\n            HookResult result = checkpointHook.handleCheckpoint(caller, selector, ref);\n            if (result == HookResult.ForceActivation) return (ref, true);\n            if (result == HookResult.ForceDeactivation) return (ref, false);\n            // Otherwise, just keep on with default checkpoint configuration and logic.\n        }\n        if (checkpoint.activation == Activation.Inactive) return (ref, false);\n        if (checkpoint.activation == Activation.AlwaysBlocked) revert CheckpointBlocked();\n        if (checkpoint.activation == Activation.AlwaysActive) return (ref, true);\n        if (checkpoint.activation == Activation.ConstantThreshold) return (ref, ref >= checkpoint.threshold);\n        if (checkpoint.activation != Activation.AccumulatedThreshold) {\n            revert InvalidActivationType();\n        }\n        /// Continue with the \"accumulated threshold\" logic.\n        bytes32 slot = keccak256(abi.encode(selector, msg.sender));\n        uint256 acc = StorageSlot.tload(slot.asUint256());\n        acc += ref;\n        StorageSlot.tstore(slot.asUint256(), acc);\n        return (ref, acc >= checkpoint.threshold);\n    }\n\n    function _checkpointActivated(Checkpoint memory checkpoint) internal pure virtual returns (bool) {\n        if (checkpoint.activation == Activation.Inactive) return false;\n        if (checkpoint.activation == Activation.AlwaysBlocked) revert CheckpointBlocked();\n        if (checkpoint.activation == Activation.AlwaysActive) return true;\n        return false;\n    }\n\n    function _isTrustedOrigin(Checkpoint memory checkpoint) internal virtual returns (bool) {\n        if (checkpoint.trustedOrigin) {\n            emit SupportsTrustedOrigin(address(this));\n            return _isTrustedAttester(tx.origin);\n        }\n        return false;\n    }\n\n    function _getFirewallStorage() internal pure virtual returns (FirewallStorage storage $) {\n        assembly {\n            $.slot := STORAGE_SLOT\n        }\n    }\n}\n"
    }
}