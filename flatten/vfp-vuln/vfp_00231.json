{
    "vfp_id": "vfp_00231",
    "project_name": "OpenZeppelin Uniswap Hooks v1.1.0 RC 1 Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Limit Orders Can Be Incorrectly Filled",
            "description": "The `LimitOrderHook` contract marks limit orders as filled when the tick crosses into the order's tick range. It uses `_getCrossedTicks` to determine which ticks were crossed during a swap and processes any orders within that range. However, the logic does not require that both boundaries of a tick range be crossed to consider an order fully filled.\n\nThe root cause is that the `_afterSwap` function processes any tick within the crossed range as a full fill, even if the price only partially traverses the order's range. This is especially problematic when the tick moves into a range and then back out, causing the same tick boundary to be crossed multiple times in opposite directions.\n\nAn attacker can exploit this by triggering a sequence where a swap moves the tick into a limit order range (e.g., from -200 to 5, crossing tick 0), and a subsequent swap moves it back (e.g., from 5 to -5, crossing tick 0 again). The `_getCrossedTicks` function returns a range that includes tick 0, causing the loop in `_afterSwap` to mark the order at [0,10] as filled, even though the upper boundary (tick 10) was never reached.\n\nThe impact is high: users' limit orders can be prematurely and incorrectly marked as filled, resulting in unintended execution at potentially unfavorable prices. This undermines trust in the limit order system and can lead to financial loss for users who expect their orders to execute only when fully crossed.\n",
            "severity": "High",
            "location": [
                "LimitOrderHook.sol::_afterSwap#209",
                "LimitOrderHook.sol::_getCrossedTicks#613",
                "LimitOrderHook.sol#563"
            ],
            "files": [
                "uniswap-hooks/src/general/LimitOrderHook.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Accrued Limit Order Fees Can Be Stolen",
            "description": "The `LimitOrderHook` contract distributes all accrued fees from a limit order proportionally among liquidity providers at the time the order is filled, regardless of when they joined. This creates an incentive for attackers to join a limit order position just before it is filled and capture a disproportionate share of fees that were accrued over a long period by earlier providers.\n\nThe cause is the lack of time-based or snapshot-based fee accounting. Fees are not tracked per-user or per-timeframe; instead, they are distributed based solely on current liquidity share at fill time. This allows a malicious actor to provide a large amount of liquidity (e.g., 90%) immediately before a fill event and claim 90% of all accrued fees, even if they were only active for a single block.\n\nThe exploitation involves three steps: (1) wait for a limit order to accumulate significant fees over time, (2) add a large amount of liquidity just before a swap crosses the tick range, and (3) immediately withdraw after the fill to capture the majority of fees. This can be done in a single block.\n\nThe impact is high: long-term liquidity providers are disincentivized as their rewards can be stolen by JIT attackers. This distorts the economic model, reduces trust in the system, and could lead to reduced liquidity provision overall.\n",
            "severity": "High",
            "location": [
                "LimitOrderHook.sol::withdraw#362",
                "LimitOrderHook.sol::fillOrder#569",
                "LimitOrderHook.sol#305"
            ],
            "files": [
                "uniswap-hooks/src/general/LimitOrderHook.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ]
            },
            "title": "Missing Liquidity Total Update in `withdraw`",
            "description": "In the `LimitOrderHook` contract, the `withdraw` function fails to update `orderInfo.liquidityTotal` when a user withdraws liquidity from a filled order. While the individual user's liquidity is deleted, the total counter remains unchanged. The root cause is the omission of a subtraction operation for `liquidityTotal`. This leads to an inflated denominator in proportional token distribution calculations (`FullMath.mulDiv(orderInfo.currency0Total, liquidity, liquidityTotal)`). As a result, subsequent withdrawers receive less than their fair share. The impact grows with each withdrawal, potentially leaving final users with significantly reduced payouts and causing some tokens to remain locked in the contract due to imprecise division. This results in loss of user funds and incorrect accounting.\n",
            "severity": "High",
            "location": [
                "LimitOrderHook.sol::withdraw#342",
                "LimitOrderHook.sol::withdraw#359",
                "LimitOrderHook.sol::withdraw#362"
            ],
            "files": [
                "uniswap-hooks/src/general/LimitOrderHook.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect Timing of `removingAllLiquidity` Flag Calculation in `cancelOrder`",
            "description": "The `cancelOrder` function in `LimitOrderHook` calculates the `removingAllLiquidity` flag after decrementing the user's liquidity from `orderInfo.liquidityTotal`. Because the total is reduced before the comparison, the flag is always `false`, even when the user is the last LP. The root cause is incorrect execution order: the flag should be computed before modifying the total. This affects fee distribution in `_handleCancelCallback`, where fees that should go to the last LP are instead left in the contract. Additionally, the `orderId` in the `orders` mapping is not reset, allowing an attacker to reuse the same order key to refill and steal the stuck fees. The impact includes misallocated fees, potential fund theft, and indefinite locking of assets.\n",
            "severity": "High",
            "location": [
                "LimitOrderHook.sol::cancelOrder#281",
                "LimitOrderHook.sol::cancelOrder#313",
                "LimitOrderHook.sol::_handleCancelCallback#466"
            ],
            "files": [
                "uniswap-hooks/src/general/LimitOrderHook.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Usage of Returned Balance Delta",
            "description": "In `_handlePlaceCallback` of `LimitOrderHook`, the contract uses the raw `delta` from `modifyLiquidity` to determine if a limit order is placed out of range. However, `delta` includes both principal and accrued fees. If fees exceed the principal, the sign of `delta` can flip, causing an incorrect revert when converting to a negative value. The root cause is the failure to separate fee and principal components in the delta. An attacker could manipulate fee accumulation in a tick to prevent legitimate order placement. The impact is denial of service for limit order placement in fee-rich positions, reducing usability and reliability of the hook.\n",
            "severity": "Medium",
            "location": [
                "LimitOrderHook.sol::_handlePlaceCallback#425",
                "LimitOrderHook.sol::_handlePlaceCallback#430",
                "LimitOrderHook.sol::_handlePlaceCallback#442-458"
            ],
            "files": [
                "uniswap-hooks/src/general/LimitOrderHook.sol"
            ]
        }
    ],
    "affected_files": {
        "LimitOrderHook.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v1.1.0) (src/general/LimitOrderHook.sol)\n\npragma solidity ^0.8.24;\n\n// Internal imports\nimport {CurrencySettler} from \"../utils/CurrencySettler.sol\";\nimport {BaseHook} from \"../base/BaseHook.sol\";\n\n// External imports\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {FullMath} from \"v4-core/src/libraries/FullMath.sol\";\nimport {StateLibrary} from \"v4-core/src/libraries/StateLibrary.sol\";\nimport {TickMath} from \"v4-core/src/libraries/TickMath.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"v4-core/src/interfaces/callback/IUnlockCallback.sol\";\n\n/// @dev The order id library.\nlibrary OrderIdLibrary {\n    /// @dev The order id type.\n    type OrderId is uint232;\n\n    /**\n     * @dev Compare two order ids for equality. Takes two `OrderId` values `a` and `b` and returns whether\n     * their underlying values are equal.\n     */\n    function equals(OrderId a, OrderId b) internal pure returns (bool) {\n        return OrderId.unwrap(a) == OrderId.unwrap(b);\n    }\n\n    /// @dev Increment the order id `a`. Might overflow.\n    function unsafeIncrement(OrderId a) internal pure returns (OrderId) {\n        unchecked {\n            return OrderId.wrap(OrderId.unwrap(a) + 1);\n        }\n    }\n}\n\n/**\n * @dev This hook implements a mechanism to place limit orders on a liquidity pool. Specifically,\n * it allows users to place limit orders at a specific tick, which will be filled if the price of the pool\n * crosses the tick.\n *\n * The hook implements the placing of orders by adding liquidity to the pool in a tick range out of range of the current price.\n * Note that, given the way v4 pools work, if one adds liquidity out of range, the liquidity added will be in a single currency,\n * instead of both, as in an in-range addition.\n *\n * Users can cancel their limit orders at any time until it is filled and liquidity is removed from the pool. Users can also withdraw\n * their liquidity after the limit order is filled.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v1.1.0_\n */\ncontract LimitOrderHook is BaseHook, IUnlockCallback {\n    using StateLibrary for IPoolManager;\n    using OrderIdLibrary for OrderIdLibrary.OrderId;\n    using CurrencySettler for Currency;\n\n    /// @dev The info for each order id.\n    struct OrderInfo {\n        bool filled;\n        Currency currency0;\n        Currency currency1;\n        uint256 currency0Total;\n        uint256 currency1Total;\n        uint128 liquidityTotal;\n        mapping(address => uint128) liquidity;\n    }\n\n    /// @dev Enum of callbacks for the hook, used to determine the type of callback called from the poolManager to `{unlockCallback}`\n    enum Callbacks {\n        PlaceOrder,\n        CancelOrder,\n        Withdraw\n    }\n\n    /// @dev Struct of callback data (sent from the poolManager to `{unlockCallback}`).\n    struct CallbackData {\n        Callbacks callbackType;\n        bytes data;\n    }\n\n    /// @dev Struct of callback data for the place callback.\n    struct CallbackDataPlace {\n        PoolKey key;\n        address owner;\n        bool zeroForOne;\n        int24 tickLower;\n        uint128 liquidity;\n    }\n\n    /// @dev Struct of callback data for the cancel callback.\n    struct CallbackDataCancel {\n        PoolKey key;\n        int24 tickLower;\n        int256 liquidityDelta;\n        address to;\n        bool removingAllLiquidity;\n    }\n\n    /// @dev Struct of callback data for the withdraw callback\n    struct CallbackDataWithdraw {\n        Currency currency0;\n        Currency currency1;\n        uint256 currency0Amount;\n        uint256 currency1Amount;\n        address to;\n    }\n\n    /// @dev The zero bytes.\n    bytes internal constant ZERO_BYTES = bytes(\"\");\n\n    /// @dev The default order id, used to indicate that an order is not yet initialized.\n    OrderIdLibrary.OrderId private constant ORDER_ID_DEFAULT = OrderIdLibrary.OrderId.wrap(0);\n\n    /// @dev The next order id to be used.\n    OrderIdLibrary.OrderId public orderIdNext = OrderIdLibrary.OrderId.wrap(1);\n\n    /// @dev The last tick lower for each pool.\n    mapping(PoolId => int24) public tickLowerLasts;\n\n    /// @dev Tracks each order id for a given identifier, defined by keccak256 of the key, tick lower, and zero for one.\n    mapping(bytes32 => OrderIdLibrary.OrderId) public orders;\n\n    /// @dev Tracks the order info for each order id.\n    mapping(OrderIdLibrary.OrderId => OrderInfo) public orderInfos;\n\n    /// @dev Zero liquidity was attempted to be added or removed.\n    error ZeroLiquidity();\n\n    /// @dev Limit order was placed in range.\n    error InRange();\n\n    /// @dev Limit order placed on the wrong side of the range.\n    error CrossedRange();\n\n    /// @dev Hook was already initialized.\n    error AlreadyInitialized();\n\n    /// @dev Limit order was already filled.\n    error Filled();\n\n    /// @dev Limit order is not filled.\n    error NotFilled();\n\n    /// @dev Event emitted when a limit order is placed.\n    event Place(\n        address indexed owner,\n        OrderIdLibrary.OrderId indexed orderId,\n        PoolKey key,\n        int24 tickLower,\n        bool zeroForOne,\n        uint128 liquidity\n    );\n\n    /// @dev Event emitted when a limit order is filled.\n    event Fill(OrderIdLibrary.OrderId indexed orderId, PoolKey key, int24 tickLower, bool zeroForOne);\n\n    /// @dev Event emitted when a limit order is canceled.\n    event Cancel(\n        address indexed owner,\n        OrderIdLibrary.OrderId indexed orderId,\n        PoolKey key,\n        int24 tickLower,\n        bool zeroForOne,\n        uint128 liquidity\n    );\n\n    /// @dev Event emitted when a limit order is withdrawn.\n    event Withdraw(address indexed owner, OrderIdLibrary.OrderId indexed orderId, uint128 liquidity);\n\n    /// @dev Set the `PoolManager` address.\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    /// @dev Hooks into the `afterInitialize` hook to set the last tick lower for the pool.\n    function _afterInitialize(address, PoolKey calldata key, uint160, int24 tick) internal override returns (bytes4) {\n        // set the last tick lower for the pool\n        tickLowerLasts[key.toId()] = getTickLower(tick, key.tickSpacing);\n\n        return this.afterInitialize.selector;\n    }\n\n    /// @dev Hooks into the `afterSwap` hook to get the ticks crossed by the swap and fill the orders that are crossed, filling them.\n    function _afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual override returns (bytes4, int128) {\n        (int24 tickLower, int24 lower, int24 upper) = _getCrossedTicks(key.toId(), key.tickSpacing);\n\n        if (lower > upper) return (this.afterSwap.selector, 0);\n\n        // set the last tick lower for the pool\n        tickLowerLasts[key.toId()] = tickLower;\n\n        // note that a zeroForOne swap means that the pool is actually gaining token0, so limit\n        // order fills are the opposite of swap fills, hence the inversion below\n        bool zeroForOne = !params.zeroForOne;\n        for (; lower <= upper; lower += key.tickSpacing) {\n            _fillOrder(key, lower, zeroForOne);\n        }\n\n        return (this.afterSwap.selector, 0);\n    }\n\n    /**\n     * @dev Places a limit order by adding liquidity out of range at a specific tick. The order will be filled when the\n     * pool price crosses the specified `tick`. Takes a `PoolKey` `key`, target `tick`, direction `zeroForOne` indicating\n     * whether to buy currency0 or currency1, and amount of `liquidity` to place. The interaction with the `poolManager` is done\n     * via the `unlock` function, which will trigger the `{unlockCallback}` function.\n     */\n    function placeOrder(PoolKey calldata key, int24 tick, bool zeroForOne, uint128 liquidity) external {\n        // revert if liquidity is 0\n        if (liquidity == 0) revert ZeroLiquidity();\n\n        OrderInfo storage orderInfo;\n\n        // get the order for the limit order\n        OrderIdLibrary.OrderId orderId = getOrderId(key, tick, zeroForOne);\n\n        // if the order is not initialized, initialize it\n        if (orderId.equals(ORDER_ID_DEFAULT)) {\n            // initialize the order to the next order\n            unchecked {\n                setOrderId(key, tick, zeroForOne, orderId = orderIdNext);\n\n                // increment the order id\n                orderIdNext = orderIdNext.unsafeIncrement();\n            }\n\n            // get the order info\n            orderInfo = orderInfos[orderId];\n\n            // set the currency0 and currency1\n            orderInfo.currency0 = key.currency0;\n            orderInfo.currency1 = key.currency1;\n        } else {\n            // get the order info\n            orderInfo = orderInfos[orderId];\n        }\n\n        // add the liquidity to the order\n        unchecked {\n            orderInfo.liquidityTotal += liquidity;\n            orderInfo.liquidity[msg.sender] += liquidity;\n        }\n\n        // unlock the callback to the poolManager, the callback will trigger `unlockCallback`\n        // note that multiple functions trigger `unlockCallback`, so the `callbackData.callbackType` will determine what happens\n        // in `unlockCallback`. In this case, it will add liquidity out of range.\n        // IMPORTANT: `tick` must be valid, i.e. within the range of `MIN_TICK` and `MAX_TICK`, defined in the `TickMath` library and it must be\n        // a multiple of `key.tickSpacing`.\n        poolManager.unlock(\n            abi.encode(\n                CallbackData(\n                    Callbacks.PlaceOrder, abi.encode(CallbackDataPlace(key, msg.sender, zeroForOne, tick, liquidity))\n                )\n            )\n        );\n\n        // emit the place event\n        emit Place(msg.sender, orderId, key, tick, zeroForOne, liquidity);\n    }\n\n    /**\n     * @dev Cancels a limit order by removing liquidity from the pool. Takes a `PoolKey` `key`, `tickLower` of the order,\n     * direction `zeroForOne` indicating whether it was buying currency0 or currency1, and recipient address `to` for the\n     * removed liquidity. Note that partial cancellation is not supported - the entire liquidity added by the msg.sender will be removed.\n     * Note also that cancelling an order will cancel the order placed by the msg.sender, not orders placed by other users in the same tick range.\n     * The interaction with the `poolManager` is done via the `unlock` function, which will trigger the `{unlockCallback}` function.\n     */\n    function cancelOrder(PoolKey calldata key, int24 tickLower, bool zeroForOne, address to) external {\n        // get the order\n        OrderIdLibrary.OrderId orderId = getOrderId(key, tickLower, zeroForOne);\n        OrderInfo storage orderInfo = orderInfos[orderId];\n\n        // revert if the order is already filled\n        if (orderInfo.filled) revert Filled();\n\n        // get the liquidity added by the msg.sender\n        uint128 liquidity = orderInfo.liquidity[msg.sender];\n\n        // revert if the liquidity is 0\n        if (liquidity == 0) revert ZeroLiquidity();\n\n        // delete the liquidity from the order\n        delete orderInfo.liquidity[msg.sender];\n\n        // subtract the liquidity from the total liquidity\n        orderInfo.liquidityTotal -= liquidity;\n\n        // unlock the callback to the poolManager, the callback will trigger `unlockCallback`\n        // and remove the liquidity from the pool. Note that this function will return the fees accrued\n        // by the position, since the limit order is a liquidity addition.\n        // Note that `amount0Fee` and `amount1Fee` are the fees accrued by the position and will not be transferred to\n        // the `to` address. Instead, they will be added to the order info (benefiting the remaining limit order placers).\n        (uint256 amount0Fee, uint256 amount1Fee) = abi.decode(\n            poolManager.unlock(\n                abi.encode(\n                    CallbackData(\n                        Callbacks.CancelOrder,\n                        abi.encode(\n                            CallbackDataCancel(\n                                key, tickLower, -int256(uint256(liquidity)), to, liquidity == orderInfo.liquidityTotal\n                            )\n                        )\n                    )\n                )\n            ),\n            (uint256, uint256)\n        );\n\n        // add the fees to the order info\n        // note that the currency totals must be updated after poolManager call as they depend on the returned values of the callback.\n        // This is safe as these functions are only callable on the trusted poolManager\n        unchecked {\n            // slither-disable-next-line reentrancy-no-eth\n            orderInfo.currency0Total += amount0Fee;\n            // slither-disable-next-line reentrancy-no-eth\n            orderInfo.currency1Total += amount1Fee;\n        }\n\n        // emit the cancel event\n        emit Cancel(msg.sender, orderId, key, tickLower, zeroForOne, liquidity);\n    }\n\n    /**\n     * @dev Withdraws liquidity from a filled order, sending it to address `to`. Takes an `OrderId` `orderId` of the filled\n     * order to withdraw from. Returns the withdrawn amounts as `(amount0, amount1)`. Can only be called after the order is\n     * filled - use `cancelOrder` to remove liquidity from unfilled orders. The interaction with the `poolManager` is done via the\n     * `unlock` function, which will trigger the `{unlockCallback}` function.\n     */\n    function withdraw(OrderIdLibrary.OrderId orderId, address to) external returns (uint256 amount0, uint256 amount1) {\n        // get the order info\n        OrderInfo storage orderInfo = orderInfos[orderId];\n\n        // revert if the order is not filled\n        if (!orderInfo.filled) revert NotFilled();\n\n        // get the liquidity added by the msg.sender\n        uint128 liquidity = orderInfo.liquidity[msg.sender];\n\n        // revert if the liquidity is 0\n        if (liquidity == 0) revert ZeroLiquidity();\n\n        // delete the liquidity from the order\n        delete orderInfo.liquidity[msg.sender];\n\n        // get the total liquidity in the order\n        uint128 liquidityTotal = orderInfo.liquidityTotal;\n\n        // calculate the amount of currency0 and currency1 owed to the msg.sender\n        amount0 = FullMath.mulDiv(orderInfo.currency0Total, liquidity, liquidityTotal);\n        amount1 = FullMath.mulDiv(orderInfo.currency1Total, liquidity, liquidityTotal);\n\n        // subtract the amount of currency0 and currency1 from the order info\n        orderInfo.currency0Total -= amount0;\n        orderInfo.currency1Total -= amount1;\n\n        // unlock the callback to the poolManager, the callback will trigger `unlockCallback`\n        // and return the liquidity to the `to` address.\n        poolManager.unlock(\n            abi.encode(\n                CallbackData(\n                    Callbacks.Withdraw,\n                    abi.encode(CallbackDataWithdraw(orderInfo.currency0, orderInfo.currency1, amount0, amount1, to))\n                )\n            )\n        );\n\n        // emit the withdraw event\n        emit Withdraw(msg.sender, orderId, liquidity);\n    }\n\n    /**\n     * @dev Handles callbacks from the `PoolManager` for order operations. Takes encoded `rawData` containing the callback type\n     * and operation-specific data. Returns encoded data containing fees accrued for cancel operations, or empty bytes\n     * otherwise. Only callable by the PoolManager.\n     */\n    function unlockCallback(bytes calldata rawData)\n        external\n        virtual\n        override\n        onlyPoolManager\n        returns (bytes memory returnData)\n    {\n        // decode the callback data\n        CallbackData memory callbackData = abi.decode(rawData, (CallbackData));\n\n        // handle the callback based on the type\n        if (callbackData.callbackType == Callbacks.PlaceOrder) {\n            // decode the callback data\n            CallbackDataPlace memory placeData = abi.decode(callbackData.data, (CallbackDataPlace));\n\n            _handlePlaceCallback(placeData);\n        } else if (callbackData.callbackType == Callbacks.CancelOrder) {\n            // decode the callback data\n            CallbackDataCancel memory cancelData = abi.decode(callbackData.data, (CallbackDataCancel));\n\n            (uint256 amount0Fee, uint256 amount1Fee) = _handleCancelCallback(cancelData);\n\n            // return the fees accrued by the position encoded in the return data\n            return abi.encode(amount0Fee, amount1Fee);\n        } else if (callbackData.callbackType == Callbacks.Withdraw) {\n            CallbackDataWithdraw memory withdrawData = abi.decode(callbackData.data, (CallbackDataWithdraw));\n\n            _handleWithdrawCallback(withdrawData);\n        }\n    }\n\n    /**\n     * @dev Internal handler for place order callbacks. Takes `placeData` containing the order details and adds the\n     * specified liquidity to the pool out of range. Reverts if the order would be placed in range or on the wrong\n     * side of the range.\n     */\n    function _handlePlaceCallback(CallbackDataPlace memory placeData) internal {\n        // get the pool key\n        PoolKey memory key = placeData.key;\n\n        // add the out of range liquidity to the pool\n        (BalanceDelta delta,) = poolManager.modifyLiquidity(\n            key,\n            IPoolManager.ModifyLiquidityParams({\n                tickLower: placeData.tickLower,\n                tickUpper: placeData.tickLower + key.tickSpacing,\n                liquidityDelta: int256(uint256(placeData.liquidity)),\n                salt: 0\n            }),\n            ZERO_BYTES\n        );\n\n        // if the amount of currency0 is negative, the limit order is to sell `currency0` for `currency1`\n        if (delta.amount0() < 0) {\n            // if the amount of currency1 is not 0, the limit order is in range\n            if (delta.amount1() != 0) revert InRange();\n            // if `zeroForOne` is false, the limit order is wrong side of the range\n            if (!placeData.zeroForOne) revert CrossedRange();\n\n            // settle the currency0 to the owner\n            key.currency0.settle(poolManager, placeData.owner, uint256(uint128(-delta.amount0())), false);\n        } else {\n            // if the amount of currency0 is not 0, the limit order is in range\n            if (delta.amount0() != 0) revert InRange();\n            // if `zeroForOne` is true, the limit order is wrong side of the range\n            if (placeData.zeroForOne) revert CrossedRange();\n\n            // settle the currency1 to the owner\n            key.currency1.settle(poolManager, placeData.owner, uint256(uint128(-delta.amount1())), false);\n        }\n    }\n\n    /**\n     * @dev Internal handler for cancel order callbacks. Takes `cancelData` containing the cancellation details and\n     * removes liquidity from the pool. Returns accrued fees `(amount0Fee, amount1Fee)` which are allocated to remaining\n     * limit order placers, or to the cancelling user if they're removing all liquidity.\n     */\n    function _handleCancelCallback(CallbackDataCancel memory cancelData)\n        internal\n        returns (uint256 amount0Fee, uint256 amount1Fee)\n    {\n        // get the tick upper\n        int24 tickUpper = cancelData.tickLower + cancelData.key.tickSpacing;\n\n        // remove the liquidity from the pool. The fees accrued by the position are included in the `cancelDelta`\n        (BalanceDelta cancelDelta, BalanceDelta feesAccrued) = poolManager.modifyLiquidity(\n            cancelData.key,\n            IPoolManager.ModifyLiquidityParams({\n                tickLower: cancelData.tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: cancelData.liquidityDelta,\n                salt: 0\n            }),\n            ZERO_BYTES\n        );\n\n        BalanceDelta principalDelta;\n\n        // because `modifyPosition` includes not just principal value but also fees, we cannot allocate\n        // the proceeds pro-rata. if we were to do so, users who have been in a limit order that's partially filled\n        // could be unfairly diluted by a user synchronously placing then canceling a limit order to skim off fees.\n        // to prevent this, we allocate all fee revenue to remaining limit order placers, unless this is the last order.\n        if (!cancelData.removingAllLiquidity) {\n            // if the amount of fees in currency0 is positive, mint currency0 to the hook\n            if (feesAccrued.amount0() > 0) {\n                poolManager.mint(\n                    address(this), cancelData.key.currency0.toId(), amount0Fee = uint128(feesAccrued.amount0())\n                );\n            }\n\n            // if the amount of fees in currency1 is positive, mint currency1 to the hook\n            if (feesAccrued.amount1() > 0) {\n                poolManager.mint(\n                    address(this), cancelData.key.currency1.toId(), amount1Fee = uint128(feesAccrued.amount1())\n                );\n            }\n\n            // if the `removingAllLiquidity` flag is false, the fees accrued will be allocated to the remaining limit order placers\n            // so we need to subtract the fees from the `cancelDelta` to get the principal delta\n            principalDelta = cancelDelta - feesAccrued;\n        } else {\n            // if the `removingAllLiquidity` flag is true, the fees accrued will be allocated to the placer of the last limit order being cancelled\n            // so we can just use the `cancelDelta` as the principal delta\n            principalDelta = cancelDelta;\n        }\n\n        // if the amount of currency0 is positive, take the currency0 from the pool and send it to the `to` address\n        if (principalDelta.amount0() > 0) {\n            cancelData.key.currency0.take(poolManager, cancelData.to, uint256(uint128(principalDelta.amount0())), false);\n        }\n\n        // if the amount of currency1 is positive, take the currency1 from the pool and send it to the `to` address\n        if (principalDelta.amount1() > 0) {\n            cancelData.key.currency1.take(poolManager, cancelData.to, uint256(uint128(principalDelta.amount1())), false);\n        }\n    }\n\n    /**\n     * @dev Internal handler for withdraw callbacks. Takes `withdrawData` containing withdrawal amounts and recipient,\n     * burns the specified currency amounts from the hook, and transfers them to the recipient address.\n     */\n    function _handleWithdrawCallback(CallbackDataWithdraw memory withdrawData) internal {\n        // if the amount of currency0 is positive, burn the currency0 from the hook\n        if (withdrawData.currency0Amount > 0) {\n            // burn the currency0 from the hook\n            poolManager.burn(address(this), withdrawData.currency0.toId(), withdrawData.currency0Amount);\n            // take the currency0 from the pool and send it to the `to` address\n            poolManager.take(withdrawData.currency0, withdrawData.to, withdrawData.currency0Amount);\n        }\n\n        // if the amount of currency1 is positive, burn the currency1 from the hook\n        if (withdrawData.currency1Amount > 0) {\n            // burn the currency1 from the hook\n            poolManager.burn(address(this), withdrawData.currency1.toId(), withdrawData.currency1Amount);\n            // take the currency1 from the pool and send it to the `to` address\n            poolManager.take(withdrawData.currency1, withdrawData.to, withdrawData.currency1Amount);\n        }\n    }\n\n    /**\n     * @dev Internal handler for filling limit orders when price crosses a tick. Takes a `PoolKey` `key`, target `tickLower`,\n     * and direction `zeroForOne`. Removes liquidity from filled orders, mints the received currencies to the hook, and\n     * updates order state to track filled amounts.\n     */\n    function _fillOrder(PoolKey calldata key, int24 tickLower, bool zeroForOne) internal {\n        // get the order\n        OrderIdLibrary.OrderId orderId = getOrderId(key, tickLower, zeroForOne);\n\n        // if the order is not default (not initialized), fill it\n        if (!orderId.equals(ORDER_ID_DEFAULT)) {\n            // get the order info\n            OrderInfo storage orderInfo = orderInfos[orderId];\n\n            // set the order as filled\n            orderInfo.filled = true;\n\n            // set the order as default (inactive)\n            setOrderId(key, tickLower, zeroForOne, ORDER_ID_DEFAULT);\n\n            // modify the liquidity to remove the order liquidity from the pool\n            (BalanceDelta delta,) = poolManager.modifyLiquidity(\n                key,\n                IPoolManager.ModifyLiquidityParams({\n                    tickLower: tickLower,\n                    tickUpper: tickLower + key.tickSpacing,\n                    liquidityDelta: -int256(uint256(orderInfo.liquidityTotal)),\n                    salt: 0\n                }),\n                ZERO_BYTES\n            );\n\n            uint128 amount0 = 0;\n            uint128 amount1 = 0;\n\n            // if the amount of currency0 is positive, mint the currency0 to the hook\n            if (delta.amount0() > 0) {\n                poolManager.mint(address(this), key.currency0.toId(), amount0 = uint128(delta.amount0()));\n            }\n\n            // if the amount of currency1 is positive, mint the currency1 to the hook\n            if (delta.amount1() > 0) {\n                poolManager.mint(address(this), key.currency1.toId(), amount1 = uint128(delta.amount1()));\n            }\n\n            // add the amount of currency0 and currency1 to the order info\n            // note that the currency totals must be updated after poolManager calls as they depend on the returned values.\n            // This is safe as these functions are only callable on the trusted poolManager\n            unchecked {\n                // slither-disable-next-line reentrancy-no-eth\n                orderInfo.currency0Total += amount0;\n                // slither-disable-next-line reentrancy-no-eth\n                orderInfo.currency1Total += amount1;\n            }\n\n            // emit the fill event\n            emit Fill(orderId, key, tickLower, zeroForOne);\n        }\n    }\n\n    /**\n     * @dev Internal helper that calculates the range of ticks crossed during a price change. Takes a `PoolId` `poolId`\n     * and `tickSpacing`, returns the current `tickLower` and the range of ticks crossed (`lower`, `upper`) that need\n     * to be checked for limit orders.\n     */\n    function _getCrossedTicks(PoolId poolId, int24 tickSpacing)\n        internal\n        view\n        returns (int24 tickLower, int24 lower, int24 upper)\n    {\n        tickLower = getTickLower(getTick(poolId), tickSpacing);\n        int24 tickLowerLast = getTickLowerLast(poolId);\n\n        if (tickLower < tickLowerLast) {\n            lower = tickLower + tickSpacing;\n            upper = tickLowerLast;\n        } else {\n            lower = tickLowerLast;\n            upper = tickLower - tickSpacing;\n        }\n    }\n\n    /**\n     * @dev Returns the last recorded lower tick for a given pool. Takes a `PoolId` `poolId` and returns the\n     * stored `tickLowerLast` value.\n     */\n    function getTickLowerLast(PoolId poolId) public view returns (int24) {\n        return tickLowerLasts[poolId];\n    }\n\n    /**\n     * @dev Retrieves the order id for a given pool position. Takes a `PoolKey` `key`, target `tickLower`, and direction\n     * `zeroForOne` indicating whether it's buying currency0 or currency1. Returns the {OrderId} associated with this\n     * position, or the default order id if no order exists.\n     */\n    function getOrderId(PoolKey memory key, int24 tickLower, bool zeroForOne)\n        public\n        view\n        returns (OrderIdLibrary.OrderId)\n    {\n        return orders[keccak256(abi.encode(key, tickLower, zeroForOne))];\n    }\n\n    /**\n     * @dev Internal helper that updates the order ID mapping. Takes a `PoolKey` `key`, target `tickLower`, direction\n     * `zeroForOne`, and `orderId` to store. Associates the given order id with the pool position's hash.\n     */\n    function setOrderId(PoolKey memory key, int24 tickLower, bool zeroForOne, OrderIdLibrary.OrderId orderId) private {\n        orders[keccak256(abi.encode(key, tickLower, zeroForOne))] = orderId;\n    }\n\n    /**\n     * @dev Get the tick lower. Takes a `tick` and `tickSpacing` and returns the nearest valid tick boundary\n     * at or below the input tick, accounting for negative tick handling.\n     */\n    function getTickLower(int24 tick, int24 tickSpacing) private pure returns (int24) {\n        // slither-disable-next-line divide-before-multiply\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n        return compressed * tickSpacing;\n    }\n\n    /**\n     * @dev Get the liquidity of an order for a given order id and owner. Takes an {OrderId} `orderId` and `owner` address\n     * and returns the amount of liquidity the owner has contributed to the order.\n     */\n    function getOrderLiquidity(OrderIdLibrary.OrderId orderId, address owner) external view returns (uint256) {\n        return orderInfos[orderId].liquidity[owner];\n    }\n\n    /**\n     * @dev Get the current tick for a given pool. Takes a `PoolId` `poolId` and returns the tick calculated\n     * from the pool's current sqrt price.\n     */\n    function getTick(PoolId poolId) private view returns (int24 tick) {\n        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolId);\n        tick = TickMath.getTickAtSqrtPrice(sqrtPriceX96);\n    }\n\n    /**\n     * @dev Get the hook permissions for this contract. Returns a `Hooks.Permissions` struct configured to enable\n     * `afterInitialize` and `afterSwap` hooks while disabling all other hooks.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: true,\n            beforeAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n"
    }
}