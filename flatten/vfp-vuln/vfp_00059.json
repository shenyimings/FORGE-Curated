{
    "vfp_id": "vfp_00059",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Missing access control on unlockCallback()",
            "description": "The unlockCallback() functions in LikwidLendPosition.sol, LikwidMarginPosition.sol, and LikwidPairPosition.sol lack access control, allowing any external caller to invoke them with arbitrary data. This occurs because the contracts do not inherit from Uniswap v4's SafeCallback.sol, which is designed to restrict callback execution to the pool manager only. An attacker can exploit this by calling unlockCallback() directly through a malicious contract, bypassing ownership checks and potentially stealing lender positions. This could lead to unauthorized fund transfers and complete loss of user funds deposited in lending positions.\n",
            "severity": "Critical",
            "location": [
                "LikwidLendPosition.sol::unlockCallback",
                "LikwidMarginPosition.sol::unlockCallback",
                "LikwidPairPosition.sol::unlockCallback"
            ],
            "files": [
                "likwid-margin/src/LikwidLendPosition.sol",
                "likwid-margin/src/LikwidMarginPosition.sol",
                "likwid-margin/src/LikwidPairPosition.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "There is a incorrect marginTotal reduction on liquidation",
            "description": "During liquidation in MarginPosition.sol, the close() function reduces positionValue by rewardAmount before calculating releaseAmount. However, the subsequent marginTotal reduction logic assumes releaseAmount represents the full proportional share of the position, not accounting for the prior subtraction. This causes marginTotal to be under-decreased by rewardAmount, leaving a residual balance. If the position ID is reused, this leftover marginTotal could cause incorrect accounting, leading to inflated collateral values or denial of service in future operations due to state inconsistency.\n",
            "severity": "High",
            "location": [
                "MarginPosition.sol#L174-L175",
                "MarginPosition.sol#L195"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "There is a incorrect reserve accounting in liquidateBurn function",
            "description": "In LikwidMarginPosition.sol, liquidateBurn() uses releaseAmount from the close() function to update reserve deltas, but close() already reduces releaseAmount by rewardAmount. The true amount withdrawn from lending reserves is releaseAmount + rewardAmount, but the delta is constructed using only releaseAmount. This results in under-decreasing the lending reserve and misrepresenting pair reserve changes. Over time, this accounting error causes reserve desynchronization, potentially leading to insolvency as the protocol's internal balances diverge from actual holdings.\n",
            "severity": "High",
            "location": [
                "LikwidMarginPosition.sol#L504",
                "MarginPosition.sol#L174-L175"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Health check inconsistency between position creation and liquidation",
            "description": "The checkLiquidate() function uses truncated reserves (lagging prices) for health checks, while position creation functions (_executeAddLeverage and _executeAddCollateralAndBorrow) use current pair reserves. This creates a discrepancy where positions can be opened at favorable prices but immediately become liquidatable due to lagging truncated prices. Conversely, healthy positions may be unfairly liquidated. Attackers can exploit this by timing swaps to manipulate the gap between current and truncated reserves, leading to unfair advantages or user losses.\n",
            "severity": "High",
            "location": [
                "LikwidMarginPosition.sol"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Slippage is not checked when result amounts are zero",
            "description": "The _processDelta() function in BasePositionManager.sol fails to enforce slippage checks when delta.amount0() or delta.amount1() is exactly zero. This occurs because the slippage validation logic is only triggered when the delta is strictly less than or greater than zero, skipping the case when the resulting amount is zero. The root cause is the absence of a slippage check for zero delta values, even when amount0Min or amount1Min are set to positive values. An attacker could exploit this by executing a swap where the output amount is zero, bypassing the user's minimum output requirement. This could lead to users receiving no tokens despite expecting a minimum amount, resulting in loss of funds or unexpected behavior. The same issue exists in the handleSwap() function of the LikwidLendPosition contract, increasing the attack surface.\n",
            "severity": "Medium",
            "location": [
                "BasePositionManager.sol::delta.amount0#71-83",
                "LikwidLendPosition.sol::handleSwap"
            ],
            "files": [
                "likwid-margin/src/base/BasePositionManager.sol",
                "likwid-margin/src/LikwidLendPosition.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The old pairReserves is used for margin level checks in the margin",
            "description": "In the _margin() function of LikwidMarginPosition.sol, the _checkMinLevel() function is called using the pre-swap value of poolState.pairReserves, even after _executeAddLeverage() modifies the reserves through a leveraged swap. The root cause is the incorrect ordering of operations—margin level validation occurs before the updated pool state is retrieved. Since _executeAddLeverage() changes the effective reserves due to borrowing and swapping, using stale reserves for validation leads to an inaccurate margin level calculation. An attacker could exploit this by adding leverage in a way that artificially inflates the margin level based on outdated reserves, potentially bypassing liquidation thresholds or minimum margin requirements. This could allow undercollateralized positions to persist, increasing systemic risk and potentially leading to losses for liquidity providers.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::_margin#227",
                "LikwidMarginPosition.sol::_executeAddLeverage#303"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The borrow level check blocks positive margin adjustments in the modify function",
            "description": "The modify() function in LikwidMarginPosition.sol enforces a _checkMinLevel() using minBorrowLevel() regardless of whether the user is adding or removing margin. The root cause is the unconditional application of the stricter borrow level check, even when the user is increasing their margin (positive changeAmount). This prevents users from improving their position's health by adding more collateral if their current borrow level is below the threshold, even though doing so would reduce risk. For example, a user close to liquidation who wants to add margin but cannot meet the borrow level requirement will be blocked from doing so, potentially leading to forced liquidation despite having additional funds available. This creates a poor user experience and undermines the purpose of allowing margin adjustments to avoid liquidation, resulting in avoidable losses.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::modify#650"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "The deadline check is missing in the increaseLiquidity and removeLiquidity functions",
            "description": "The increaseLiquidity() and removeLiquidity() functions in LikwidPairPosition.sol do not include a deadline parameter or validation, unlike the swap functions. The root cause is the absence of time-based transaction validity enforcement for liquidity operations. Without a deadline, transactions can remain pending in the mempool indefinitely and be executed at a later time when market conditions have changed significantly. An attacker could exploit this by front-running or delaying transactions to force execution at unfavorable prices, leading to significant slippage or reduced token amounts received. This exposes users to price manipulation and market volatility risks, potentially resulting in financial loss. The impact is particularly severe for large liquidity providers who expect predictable execution outcomes.\n",
            "severity": "Medium",
            "location": [
                "LikwidPairPosition.sol::increaseLiquidity#91",
                "LikwidPairPosition.sol::removeLiquidity#102"
            ],
            "files": [
                "likwid-margin/src/LikwidPairPosition.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Ignored closeAmount in the liquidateBurn function causes user funds loss during liquidation",
            "description": "In the liquidateBurn() function of LikwidMarginPosition.sol, the closeAmount returned by position.close() is not accounted for, even though it represents residual value from the liquidation swap. The root cause is the failure to transfer this amount back to the user. In cases where the swap during liquidation yields a surplus (closeAmount > 0), this value is effectively lost because it is neither credited to the user nor captured by the protocol. For example, a position with a margin level below the liquidation threshold may still generate a small positive closeAmount due to rounding or price differences, but this amount is silently discarded. As a result, users lose part of their remaining margin during liquidation, leading to unfair outcomes and reduced trust in the protocol's liquidation mechanism.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::liquidateBurn#504"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Inconsistent level check when modifying margin position",
            "description": "The modify() function in LikwidMarginPosition.sol uses _marginLevels.minBorrowLevel() for validation, even when modifying leveraged positions that should be subject to minMarginLevel(). The root cause is the use of an incorrect threshold for margin level checks. Since modify() can be used to adjust leveraged positions, it should enforce the minimum margin level rather than the borrow level. Using minBorrowLevel() imposes a stricter requirement that may not align with the risk profile of leveraged positions. While the protocol acknowledges this as intentional to protect LPs during margin reductions, it creates inconsistency in how margin requirements are applied. This can confuse users and lead to unexpected reverts when attempting to modify positions, especially when the minBorrowLevel is significantly higher than minMarginLevel.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::modify#650"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-770"
                ]
            },
            "title": "The lack of restriction when margin with leverage = 0 can cause DoS of operations",
            "description": "The _executeAddCollateralAndBorrow() function restricts borrow amounts to 20% of real reserves per transaction but does not enforce a cumulative limit. The root cause is the absence of a global check on mirrorReserve growth relative to realReserve. A user can repeatedly open margin positions with leverage = 0 to gradually drain real reserves while increasing mirror reserves. Over time, this imbalance causes realReserves to deplete while pairReserve remains unchanged, leading to failures in swaps, liquidity removal, or withdrawals due to insufficient real liquidity. This constitutes a denial-of-service (DoS) attack on normal operations, as the pool becomes unusable despite appearing healthy based on pairReserves. The impact is severe for liquidity providers and traders relying on the pool's functionality.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::_executeAddCollateralAndBorrow#313"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "User can close position even when below liquidation level",
            "description": "The close() function in LikwidMarginPosition.sol allows users to fully close their margin positions without verifying whether the position is above the liquidation threshold. The root cause is the lack of a liquidation state check before allowing closure. The function only validates that lostAmount > 0 or closeAmount meets minimum requirements, but does not prevent closure when the margin level is below the liquidation threshold. This allows users to avoid liquidation penalties by manually closing their position just before liquidation would occur. As a result, the liquidation mechanism is undermined, reducing its effectiveness in protecting the protocol from bad debt. This creates an incentive for users to monitor and close positions proactively, weakening the automated risk management system.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::close#426"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect mirror reserve restriction during leveraged margin addition can cause DoS of operations",
            "description": "The _executeAddLeverage() function in LikwidMarginPosition.sol checks mirror reserve limits using the condition Math.mulDiv(borrowMirrorReserves, 100, borrowRealReserves + borrowMirrorReserves) > 90. The root cause is a flawed mathematical expression that allows mirrorReserves to be up to 9 times larger than realReserves (since 900 / (900 + 100) = 0.9). This permissive check enables users to push the pool into a state where real liquidity is critically low (e.g., 10% of total). As a result, operations requiring real reserves—such as swaps, liquidity removal, or withdrawals—will fail due to insufficient funds, causing a denial-of-service (DoS) for legitimate users and LPs. The intended safety mechanism is effectively bypassed due to incorrect ratio calculation.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::_executeAddLeverage#250"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing maximum leverage validation in _margin function can cause liquidity risk",
            "description": "The _margin() function in LikwidMarginPosition.sol uses params.leverage directly without validating it against the protocol's maximum leverage limit (max_leverage = 5). The root cause is the absence of an explicit bounds check on the leverage parameter. Although marginLevel is checked later, a user could still input an arbitrarily high leverage value, potentially leading to excessive borrowing and liquidity strain. This creates a liquidity risk where the system may become over-leveraged, increasing the likelihood of cascading liquidations during market volatility. The impact is systemic risk to the protocol's stability, especially if multiple users open high-leverage positions simultaneously.\n",
            "severity": "Medium",
            "location": [
                "LikwidMarginPosition.sol::_margin#219-221"
            ],
            "files": [
                "likwid-margin/src/LikwidMarginPosition.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing validation between poolId and tokenId allows mismatched pool assignments leading to permanent locked lend position",
            "description": "The exactInput() and exactOutput() functions in LikwidLendPosition.sol accept both poolId and tokenId as user inputs but do not validate that the provided poolId corresponds to the tokenId. Since the contract maintains a mapping from tokenId to poolId, each tokenId is inherently tied to a specific pool. Without validation, a user could provide a mismatched poolId, causing the resulting lend position to be created in the wrong pool. This would make it impossible for the user to withdraw their funds, effectively locking them permanently. The root cause is the lack of input validation between two related parameters. An attacker could exploit this by intentionally providing a mismatched poolId to manipulate the pool assignment. The impact is permanent loss of user funds due to inability to withdraw from the incorrect pool.\n",
            "severity": "Medium",
            "location": [
                "LikwidLendPosition.sol#L140-L143"
            ],
            "files": [
                "likwid-margin/src/LikwidLendPosition.sol"
            ]
        }
    ],
    "affected_files": {
        "LikwidMarginPosition.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Likwid Contracts\npragma solidity ^0.8.26;\n\n// Local\nimport {BasePositionManager} from \"./base/BasePositionManager.sol\";\nimport {IMarginPositionManager} from \"./interfaces/IMarginPositionManager.sol\";\nimport {IProtocolFees} from \"./interfaces/IProtocolFees.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {CurrencyPoolLibrary} from \"./libraries/CurrencyPoolLibrary.sol\";\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\nimport {FeeLibrary} from \"./libraries/FeeLibrary.sol\";\nimport {MarginPosition} from \"./libraries/MarginPosition.sol\";\nimport {Math} from \"./libraries/Math.sol\";\nimport {PerLibrary} from \"./libraries/PerLibrary.sol\";\nimport {PositionLibrary} from \"./libraries/PositionLibrary.sol\";\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\nimport {StateLibrary} from \"./libraries/StateLibrary.sol\";\nimport {TimeLibrary} from \"./libraries/TimeLibrary.sol\";\nimport {SwapMath} from \"./libraries/SwapMath.sol\";\nimport {MarginActions} from \"./types/MarginActions.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"./types/BalanceDelta.sol\";\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {MarginLevels, MarginLevelsLibrary} from \"./types/MarginLevels.sol\";\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {Reserves} from \"./types/Reserves.sol\";\nimport {PoolState} from \"./types/PoolState.sol\";\nimport {MarginBalanceDelta} from \"./types/MarginBalanceDelta.sol\";\n// Solmate\n\ncontract LikwidMarginPosition is IMarginPositionManager, BasePositionManager {\n    using SafeCast for *;\n    using CurrencyLibrary for Currency;\n    using CurrencyPoolLibrary for Currency;\n    using PerLibrary for uint256;\n    using FeeLibrary for uint24;\n    using CustomRevert for bytes4;\n    using PositionLibrary for address;\n    using MarginLevelsLibrary for MarginLevels;\n    using TimeLibrary for uint32;\n    using MarginPosition for MarginPosition.State;\n\n    uint8 constant MAX_LEVERAGE = 5; // 5x\n\n    mapping(uint256 tokenId => MarginPosition.State positionInfo) private positionInfos;\n    MarginLevels public marginLevels;\n    uint24 public defaultMarginFee = 3000; // 0.3%\n\n    constructor(address initialOwner, IVault _vault)\n        BasePositionManager(\"LIKWIDMarginPositionManager\", \"LMPM\", initialOwner, _vault)\n    {\n        MarginLevels _marginLevels;\n        _marginLevels = _marginLevels.setMinMarginLevel(1170000);\n        _marginLevels = _marginLevels.setMinBorrowLevel(1400000);\n        _marginLevels = _marginLevels.setLiquidateLevel(1100000);\n        _marginLevels = _marginLevels.setLiquidationRatio(950000);\n        _marginLevels = _marginLevels.setCallerProfit(10000);\n        _marginLevels = _marginLevels.setProtocolProfit(5000);\n        marginLevels = _marginLevels;\n    }\n\n    /// @notice Callback function for the vault to execute margin-related actions.\n    /// @param data The encoded action and parameters.\n    /// @return The result of the action.\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        (MarginActions action, bytes memory params) = abi.decode(data, (MarginActions, bytes));\n\n        if (action == MarginActions.LIQUIDATE_BURN) {\n            return handleLiquidateBurn(params);\n        } else {\n            return handleMargin(params);\n        }\n    }\n\n    function _getPoolState(PoolId poolId) internal view returns (PoolState memory state) {\n        state = StateLibrary.getCurrentState(vault, poolId);\n    }\n\n    /// @dev Gets the last cumulative borrow and deposit values for a given position.\n    /// @param poolState The current state of the pool.\n    /// @param marginForOne Whether the margin is on token1.\n    /// @return borrowCumulativeLast The last cumulative borrow value.\n    /// @return depositCumulativeLast The last cumulative deposit value.\n    function _getPoolCumulativeValues(PoolState memory poolState, bool marginForOne)\n        private\n        pure\n        returns (uint256 borrowCumulativeLast, uint256 depositCumulativeLast)\n    {\n        if (marginForOne) {\n            borrowCumulativeLast = poolState.borrow0CumulativeLast;\n            depositCumulativeLast = poolState.deposit1CumulativeLast;\n        } else {\n            borrowCumulativeLast = poolState.borrow1CumulativeLast;\n            depositCumulativeLast = poolState.deposit0CumulativeLast;\n        }\n    }\n\n    function getPositionState(uint256 tokenId) external view returns (MarginPosition.State memory position) {\n        PoolId poolId = poolIds[tokenId];\n        position = positionInfos[tokenId];\n        PoolState memory state = _getPoolState(poolId);\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(state, position.marginForOne);\n\n        position.marginAmount =\n            Math.mulDiv(position.marginAmount, depositCumulativeLast, position.depositCumulativeLast).toUint128();\n        position.marginTotal =\n            Math.mulDiv(position.marginTotal, depositCumulativeLast, position.depositCumulativeLast).toUint128();\n        position.debtAmount =\n            Math.mulDiv(position.debtAmount, borrowCumulativeLast, position.borrowCumulativeLast).toUint128();\n\n        position.depositCumulativeLast = depositCumulativeLast;\n        position.borrowCumulativeLast = borrowCumulativeLast;\n    }\n\n    function checkLiquidate(uint256 tokenId)\n        external\n        view\n        returns (bool liquidated, uint256 marginAmount, uint256 marginTotal, uint256 debtAmount)\n    {\n        PoolId poolId = poolIds[tokenId];\n        MarginPosition.State memory position = positionInfos[tokenId];\n        PoolState memory state = _getPoolState(poolId);\n        (liquidated, marginAmount, marginTotal, debtAmount) = _checkLiquidate(state, position);\n    }\n\n    function _checkLiquidate(PoolState memory state, MarginPosition.State memory position)\n        internal\n        view\n        returns (bool liquidated, uint256 marginAmount, uint256 marginTotal, uint256 debtAmount)\n    {\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(state, position.marginForOne);\n        MarginLevels _marginLevels = marginLevels;\n        // use truncatedReserves\n        uint256 level = position.marginLevel(state.truncatedReserves, borrowCumulativeLast, depositCumulativeLast);\n        liquidated = level < _marginLevels.liquidateLevel();\n        if (liquidated) {\n            marginAmount = Math.mulDiv(position.marginAmount, depositCumulativeLast, position.depositCumulativeLast);\n            marginTotal = Math.mulDiv(position.marginTotal, depositCumulativeLast, position.depositCumulativeLast);\n            debtAmount = Math.mulDiv(position.debtAmount, borrowCumulativeLast, position.borrowCumulativeLast);\n        }\n    }\n\n    function _checkMinLevel(\n        Reserves pairReserves,\n        uint256 borrowCumulativeLast,\n        uint256 depositCumulativeLast,\n        MarginPosition.State memory position,\n        uint256 minLevel\n    ) internal pure {\n        uint256 level = position.marginLevel(pairReserves, borrowCumulativeLast, depositCumulativeLast);\n        if (level < minLevel) {\n            InvalidLevel.selector.revertWith();\n        }\n    }\n\n    function _processLost(PoolState memory state, MarginPosition.State memory position, uint256 lostAmount)\n        internal\n        pure\n        returns (uint256 lendLostAmount, uint256 debtDepositCumulativeLast)\n    {\n        debtDepositCumulativeLast = position.marginForOne ? state.deposit0CumulativeLast : state.deposit1CumulativeLast;\n        if (lostAmount > 0) {\n            (uint128 pairReserve0, uint128 pairReserve1) = state.pairReserves.reserves();\n            (uint128 lendReserve0, uint128 lendReserve1) = state.lendReserves.reserves();\n            uint256 pairReserve = position.marginForOne ? pairReserve0 : pairReserve1;\n            uint256 lendReserve = position.marginForOne ? lendReserve0 : lendReserve1;\n            lendLostAmount = Math.mulDiv(lostAmount, lendReserve, pairReserve + lendReserve);\n            if (lendReserve > 0) {\n                debtDepositCumulativeLast =\n                    Math.mulDiv(debtDepositCumulativeLast, lendReserve - lendLostAmount, lendReserve);\n            }\n        }\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function addMargin(PoolKey memory key, IMarginPositionManager.CreateParams calldata params)\n        external\n        payable\n        ensure(params.deadline)\n        returns (uint256 tokenId, uint256 borrowAmount, uint256 swapFeeAmount)\n    {\n        tokenId = _mintPosition(key, params.recipient);\n        positionInfos[tokenId].marginForOne = params.marginForOne;\n        (borrowAmount, swapFeeAmount) = _margin(\n            msg.sender,\n            params.recipient,\n            IMarginPositionManager.MarginParams({\n                tokenId: tokenId,\n                leverage: params.leverage,\n                marginAmount: params.marginAmount,\n                borrowAmount: params.borrowAmount,\n                borrowAmountMax: params.borrowAmountMax,\n                deadline: params.deadline\n            })\n        );\n    }\n\n    function _margin(address sender, address tokenOwner, IMarginPositionManager.MarginParams memory params)\n        internal\n        returns (uint256 borrowAmount, uint256 swapFeeAmount)\n    {\n        _requireAuth(tokenOwner, params.tokenId);\n        PoolId poolId = poolIds[params.tokenId];\n        PoolState memory poolState = _getPoolState(poolId);\n        if (poolState.lpFee < 3000) revert LowFeePoolMarginBanned();\n        PoolKey memory key = poolKeys[poolId];\n        MarginPosition.State storage position = positionInfos[params.tokenId];\n\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(poolState, position.marginForOne);\n\n        MarginBalanceDelta memory delta;\n        delta.action = MarginActions.MARGIN;\n        delta.marginForOne = position.marginForOne;\n        uint256 minLevel;\n        if (params.leverage > 0) {\n            minLevel = marginLevels.minMarginLevel();\n            (borrowAmount, swapFeeAmount) = _executeAddLeverage(params, poolState, position, delta);\n        } else {\n            minLevel = marginLevels.minBorrowLevel();\n            borrowAmount = _executeAddCollateralAndBorrow(params, poolState, position, delta);\n        }\n        delta.swapFeeAmount = swapFeeAmount;\n        _checkMinLevel(poolState.pairReserves, borrowCumulativeLast, depositCumulativeLast, position, minLevel);\n        bytes memory callbackData = abi.encode(sender, key, delta);\n        bytes memory data = abi.encode(delta.action, callbackData);\n\n        vault.unlock(data);\n        emit Margin(\n            key.toId(),\n            sender,\n            params.tokenId,\n            position.marginAmount,\n            position.marginTotal,\n            position.debtAmount,\n            position.marginForOne\n        );\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function margin(IMarginPositionManager.MarginParams memory params)\n        external\n        payable\n        ensure(params.deadline)\n        returns (uint256 borrowAmount, uint256 swapFeeAmount)\n    {\n        (borrowAmount, swapFeeAmount) = _margin(msg.sender, msg.sender, params);\n    }\n\n    function _executeAddLeverage(\n        IMarginPositionManager.MarginParams memory params,\n        PoolState memory poolState,\n        MarginPosition.State storage position,\n        MarginBalanceDelta memory delta\n    ) internal returns (uint256 borrowAmount, uint256 swapFeeAmount) {\n        uint256 borrowMirrorReserves = poolState.mirrorReserves.reserve01(!position.marginForOne);\n        uint256 borrowRealReserves = poolState.realReserves.reserve01(!position.marginForOne);\n        if (Math.mulDiv(borrowMirrorReserves, 100, borrowRealReserves + borrowMirrorReserves) > 90) {\n            MirrorTooMuch.selector.revertWith();\n        }\n\n        uint256 marginReserves = poolState.realReserves.reserve01(position.marginForOne);\n        uint256 marginTotal = params.marginAmount * params.leverage;\n        if (marginTotal > marginReserves) ReservesNotEnough.selector.revertWith();\n\n        delta.marginTotal = marginTotal.toUint128();\n        delta.marginFee = poolState.marginFee == 0 ? defaultMarginFee : poolState.marginFee;\n        (uint256 marginWithoutFee,) = delta.marginFee.deduct(marginTotal);\n        (borrowAmount,, swapFeeAmount) = SwapMath.getAmountIn(\n            poolState.pairReserves, poolState.truncatedReserves, poolState.lpFee, position.marginForOne, marginTotal\n        );\n        params.borrowAmount = borrowAmount.toUint128();\n\n        uint256 borrowCumulativeLast;\n        uint256 depositCumulativeLast;\n        if (position.marginForOne) {\n            borrowCumulativeLast = poolState.borrow0CumulativeLast;\n            depositCumulativeLast = poolState.deposit1CumulativeLast;\n        } else {\n            borrowCumulativeLast = poolState.borrow1CumulativeLast;\n            depositCumulativeLast = poolState.deposit0CumulativeLast;\n        }\n\n        position.update(\n            borrowCumulativeLast,\n            depositCumulativeLast,\n            params.marginAmount.toInt128(),\n            marginWithoutFee,\n            params.borrowAmount,\n            0\n        );\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n        int128 amount = -params.marginAmount.toInt128();\n        int128 lendAmount = amount - marginWithoutFee.toInt128();\n\n        if (position.marginForOne) {\n            amount1Delta = amount;\n            delta.pairDelta = toBalanceDelta(-borrowAmount.toInt128(), marginWithoutFee.toInt128());\n            delta.lendDelta = toBalanceDelta(0, lendAmount);\n            delta.mirrorDelta = toBalanceDelta(-borrowAmount.toInt128(), 0);\n        } else {\n            amount0Delta = amount;\n            delta.pairDelta = toBalanceDelta(marginWithoutFee.toInt128(), -borrowAmount.toInt128());\n            delta.lendDelta = toBalanceDelta(lendAmount, 0);\n            delta.mirrorDelta = toBalanceDelta(0, -borrowAmount.toInt128());\n        }\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n    }\n\n    function _executeAddCollateralAndBorrow(\n        IMarginPositionManager.MarginParams memory params,\n        PoolState memory poolState,\n        MarginPosition.State storage position,\n        MarginBalanceDelta memory delta\n    ) internal returns (uint256 borrowAmount) {\n        uint256 borrowRealReserves = poolState.realReserves.reserve01(!position.marginForOne);\n        (uint256 borrowMaxAmount,) =\n            SwapMath.getAmountOut(poolState.pairReserves, poolState.lpFee, !position.marginForOne, params.marginAmount);\n        borrowMaxAmount = Math.min(borrowMaxAmount, borrowRealReserves * 20 / 100);\n        if (params.borrowAmount > borrowMaxAmount) BorrowTooMuch.selector.revertWith();\n        if (params.borrowAmount == 0) params.borrowAmount = borrowMaxAmount.toUint128();\n        borrowAmount = params.borrowAmount;\n        uint256 borrowCumulativeLast;\n        uint256 depositCumulativeLast;\n        if (position.marginForOne) {\n            borrowCumulativeLast = poolState.borrow0CumulativeLast;\n            depositCumulativeLast = poolState.deposit1CumulativeLast;\n        } else {\n            borrowCumulativeLast = poolState.borrow1CumulativeLast;\n            depositCumulativeLast = poolState.deposit0CumulativeLast;\n        }\n\n        position.update(\n            borrowCumulativeLast, depositCumulativeLast, params.marginAmount.toInt128(), 0, params.borrowAmount, 0\n        );\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n        int128 amount = -params.marginAmount.toInt128();\n\n        if (position.marginForOne) {\n            amount1Delta = amount;\n            amount0Delta = borrowAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(0, amount);\n            delta.mirrorDelta = toBalanceDelta(-borrowAmount.toInt128(), 0);\n        } else {\n            amount0Delta = amount;\n            amount1Delta = borrowAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(amount, 0);\n            delta.mirrorDelta = toBalanceDelta(0, -borrowAmount.toInt128());\n        }\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function repay(uint256 tokenId, uint256 repayAmount, uint256 deadline) external payable ensure(deadline) {\n        _requireAuth(msg.sender, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        PoolKey memory key = poolKeys[poolId];\n        PoolState memory poolState = _getPoolState(poolId);\n        MarginPosition.State storage position = positionInfos[tokenId];\n        MarginBalanceDelta memory delta;\n\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(poolState, position.marginForOne);\n\n        (uint256 releaseAmount, uint256 realRepayAmount) =\n            position.update(borrowCumulativeLast, depositCumulativeLast, 0, 0, 0, repayAmount);\n\n        MarginLevels _marginLevels = marginLevels;\n        _checkMinLevel(\n            poolState.pairReserves,\n            borrowCumulativeLast,\n            depositCumulativeLast,\n            position,\n            _marginLevels.liquidateLevel()\n        );\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n        if (position.marginForOne) {\n            amount0Delta = -realRepayAmount.toInt128();\n            amount1Delta = releaseAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(0, amount1Delta);\n            delta.mirrorDelta = toBalanceDelta(realRepayAmount.toInt128(), 0);\n        } else {\n            amount0Delta = releaseAmount.toInt128();\n            amount1Delta = -realRepayAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(amount0Delta, 0);\n            delta.mirrorDelta = toBalanceDelta(0, realRepayAmount.toInt128());\n        }\n        delta.action = MarginActions.REPAY;\n        delta.marginForOne = position.marginForOne;\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n\n        bytes memory callbackData = abi.encode(msg.sender, key, delta);\n        bytes memory data = abi.encode(delta.action, callbackData);\n\n        vault.unlock(data);\n\n        emit Repay(\n            key.toId(),\n            msg.sender,\n            tokenId,\n            position.marginAmount,\n            position.marginTotal,\n            position.debtAmount,\n            releaseAmount,\n            realRepayAmount\n        );\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function close(uint256 tokenId, uint24 closeMillionth, uint256 closeAmountMin, uint256 deadline)\n        external\n        ensure(deadline)\n    {\n        _requireAuth(msg.sender, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        PoolKey memory key = poolKeys[poolId];\n        PoolState memory poolState = _getPoolState(poolId);\n        MarginPosition.State storage position = positionInfos[tokenId];\n        MarginBalanceDelta memory delta;\n\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(poolState, position.marginForOne);\n\n        (uint256 releaseAmount, uint256 repayAmount, uint256 closeAmount, uint256 lostAmount, uint256 swapFeeAmount) =\n        position.close(\n            poolState.pairReserves, poolState.lpFee, borrowCumulativeLast, depositCumulativeLast, 0, closeMillionth\n        );\n        if (lostAmount > 0 || (closeAmountMin > 0 && closeAmount < closeAmountMin)) {\n            InsufficientCloseReceived.selector.revertWith();\n        }\n        MarginLevels _marginLevels = marginLevels;\n        _checkMinLevel(\n            poolState.pairReserves,\n            borrowCumulativeLast,\n            depositCumulativeLast,\n            position,\n            _marginLevels.liquidateLevel()\n        );\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n        if (position.marginForOne) {\n            amount1Delta = closeAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(0, releaseAmount.toInt128());\n            delta.mirrorDelta = toBalanceDelta(repayAmount.toInt128(), 0);\n            delta.pairDelta = toBalanceDelta(repayAmount.toInt128(), -(releaseAmount - closeAmount).toInt128());\n        } else {\n            amount0Delta = closeAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(releaseAmount.toInt128(), 0);\n            delta.mirrorDelta = toBalanceDelta(0, repayAmount.toInt128());\n            delta.pairDelta = toBalanceDelta(-(releaseAmount - closeAmount).toInt128(), repayAmount.toInt128());\n        }\n        delta.action = MarginActions.CLOSE;\n        delta.swapFeeAmount = swapFeeAmount;\n        delta.marginForOne = position.marginForOne;\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n\n        bytes memory callbackData = abi.encode(msg.sender, key, delta);\n        bytes memory data = abi.encode(delta.action, callbackData);\n\n        vault.unlock(data);\n        emit Close(\n            key.toId(),\n            msg.sender,\n            tokenId,\n            position.marginAmount,\n            position.marginTotal,\n            position.debtAmount,\n            releaseAmount,\n            repayAmount,\n            closeAmount\n        );\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function liquidateBurn(uint256 tokenId) external returns (uint256 profit) {\n        PoolId poolId = poolIds[tokenId];\n        PoolState memory poolState = _getPoolState(poolId);\n        MarginPosition.State storage position = positionInfos[tokenId];\n        (bool liquidated, uint256 marginAmount, uint256 marginTotal, uint256 debtAmount) =\n            _checkLiquidate(poolState, position);\n        if (!liquidated) {\n            PositionNotLiquidated.selector.revertWith();\n        }\n        PoolKey memory key = poolKeys[poolId];\n        MarginBalanceDelta memory delta;\n        MarginLevels _marginLevels = marginLevels;\n        uint256 assetsAmount = marginAmount + marginTotal;\n        profit = assetsAmount.mulDivMillion(_marginLevels.callerProfit());\n        uint256 protocolProfitAmount = assetsAmount.mulDivMillion(_marginLevels.protocolProfit());\n\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(poolState, position.marginForOne);\n        uint256 rewardAmount = profit + protocolProfitAmount;\n        (uint256 releaseAmount, uint256 repayAmount,, uint256 lostAmount, uint256 swapFeeAmount) = position.close(\n            poolState.pairReserves,\n            poolState.lpFee,\n            borrowCumulativeLast,\n            depositCumulativeLast,\n            rewardAmount,\n            uint24(PerLibrary.ONE_MILLION)\n        );\n        (uint256 lendLostAmount, uint256 debtDepositCumulativeLast) = _processLost(poolState, position, lostAmount);\n        delta.swapFeeAmount = swapFeeAmount;\n        delta.debtDepositCumulativeLast = debtDepositCumulativeLast;\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n        if (position.marginForOne) {\n            amount1Delta = rewardAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(lendLostAmount.toInt128(), releaseAmount.toInt128());\n            delta.mirrorDelta = toBalanceDelta(repayAmount.toInt128(), 0);\n            delta.pairDelta =\n                toBalanceDelta((repayAmount - lendLostAmount).toInt128(), -(releaseAmount - rewardAmount).toInt128());\n        } else {\n            amount0Delta = rewardAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(releaseAmount.toInt128(), lendLostAmount.toInt128());\n            delta.mirrorDelta = toBalanceDelta(0, repayAmount.toInt128());\n            delta.pairDelta =\n                toBalanceDelta(-(releaseAmount - rewardAmount).toInt128(), (repayAmount - lendLostAmount).toInt128());\n        }\n        delta.action = MarginActions.LIQUIDATE_BURN;\n        delta.marginForOne = position.marginForOne;\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n\n        bytes memory callbackData = abi.encode(msg.sender, key, delta, profit, protocolProfitAmount);\n        bytes memory data = abi.encode(delta.action, callbackData);\n\n        vault.unlock(data);\n\n        emit LiquidateBurn(\n            key.toId(),\n            msg.sender,\n            tokenId,\n            marginAmount,\n            marginTotal,\n            debtAmount,\n            Reserves.unwrap(poolState.truncatedReserves),\n            Reserves.unwrap(poolState.pairReserves),\n            releaseAmount,\n            repayAmount,\n            profit,\n            lostAmount\n        );\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function liquidateCall(uint256 tokenId) external payable returns (uint256 profit, uint256 repayAmount) {\n        PoolId poolId = poolIds[tokenId];\n        PoolState memory poolState = _getPoolState(poolId);\n        MarginPosition.State storage position = positionInfos[tokenId];\n        (bool liquidated, uint256 marginAmount, uint256 marginTotal, uint256 debtAmount) =\n            _checkLiquidate(poolState, position);\n        if (!liquidated) {\n            PositionNotLiquidated.selector.revertWith();\n        }\n        PoolKey memory key = poolKeys[poolId];\n        MarginBalanceDelta memory delta;\n        (uint128 reserve0, uint128 reserve1) = poolState.pairReserves.reserves();\n        (uint256 reserveBorrow, uint256 reserveMargin) =\n            position.marginForOne ? (reserve0, reserve1) : (reserve1, reserve0);\n\n        MarginLevels _marginLevels = marginLevels;\n        uint24 _liquidationRatio = _marginLevels.liquidationRatio();\n        uint256 assetsAmount = marginAmount + marginTotal;\n        repayAmount = Math.mulDiv(reserveBorrow, assetsAmount, reserveMargin);\n        uint256 needPayAmount = repayAmount.mulDivMillion(_liquidationRatio);\n        profit = assetsAmount;\n\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(poolState, position.marginForOne);\n\n        uint256 releaseAmount;\n        (releaseAmount, repayAmount) = position.update(borrowCumulativeLast, depositCumulativeLast, 0, 0, 0, debtAmount);\n        if (profit != releaseAmount) {\n            InsufficientReceived.selector.revertWith();\n        }\n        uint256 realRepayAmount = Math.min(repayAmount, needPayAmount);\n\n        uint256 lostAmount;\n        if (debtAmount > realRepayAmount) {\n            lostAmount = debtAmount - realRepayAmount;\n        }\n        (uint256 lendLostAmount, uint256 debtDepositCumulativeLast) = _processLost(poolState, position, lostAmount);\n        delta.debtDepositCumulativeLast = debtDepositCumulativeLast;\n        int128 amount0Delta;\n        int128 amount1Delta;\n        if (position.marginForOne) {\n            amount0Delta = -realRepayAmount.toInt128();\n            amount1Delta = releaseAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(lendLostAmount.toInt128(), amount1Delta);\n            delta.pairDelta = toBalanceDelta((lostAmount - lendLostAmount).toInt128(), 0);\n            delta.mirrorDelta = toBalanceDelta(debtAmount.toInt128(), 0);\n        } else {\n            amount0Delta = releaseAmount.toInt128();\n            amount1Delta = -realRepayAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(amount0Delta, lendLostAmount.toInt128());\n            delta.pairDelta = toBalanceDelta(0, (lostAmount - lendLostAmount).toInt128());\n            delta.mirrorDelta = toBalanceDelta(0, debtAmount.toInt128());\n        }\n        delta.action = MarginActions.LIQUIDATE_CALL;\n        delta.marginForOne = position.marginForOne;\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n\n        bytes memory callbackData = abi.encode(msg.sender, key, delta);\n        bytes memory data = abi.encode(delta.action, callbackData);\n\n        vault.unlock(data);\n\n        emit LiquidateCall(\n            key.toId(),\n            msg.sender,\n            tokenId,\n            marginAmount,\n            marginTotal,\n            debtAmount,\n            Reserves.unwrap(poolState.truncatedReserves),\n            Reserves.unwrap(poolState.pairReserves),\n            releaseAmount,\n            repayAmount,\n            needPayAmount,\n            lostAmount\n        );\n    }\n\n    /// @inheritdoc IMarginPositionManager\n    function modify(uint256 tokenId, int128 changeAmount) external payable {\n        _requireAuth(msg.sender, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        PoolKey memory key = poolKeys[poolId];\n        PoolState memory poolState = _getPoolState(poolId);\n        MarginPosition.State storage position = positionInfos[tokenId];\n        MarginBalanceDelta memory delta;\n\n        (uint256 borrowCumulativeLast, uint256 depositCumulativeLast) =\n            _getPoolCumulativeValues(poolState, position.marginForOne);\n\n        position.update(borrowCumulativeLast, depositCumulativeLast, changeAmount, 0, 0, 0);\n\n        MarginLevels _marginLevels = marginLevels;\n        _checkMinLevel(\n            poolState.pairReserves,\n            borrowCumulativeLast,\n            depositCumulativeLast,\n            position,\n            _marginLevels.minBorrowLevel()\n        );\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n        if (position.marginForOne) {\n            amount1Delta = -changeAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(0, amount1Delta);\n        } else {\n            amount0Delta = -changeAmount.toInt128();\n            delta.lendDelta = toBalanceDelta(amount0Delta, 0);\n        }\n        delta.action = MarginActions.MODIFY;\n        delta.marginForOne = position.marginForOne;\n        delta.marginDelta = toBalanceDelta(amount0Delta, amount1Delta);\n\n        bytes memory callbackData = abi.encode(msg.sender, key, delta);\n        bytes memory data = abi.encode(delta.action, callbackData);\n\n        vault.unlock(data);\n        emit Modify(\n            key.toId(),\n            msg.sender,\n            tokenId,\n            position.marginAmount,\n            position.marginTotal,\n            position.debtAmount,\n            changeAmount\n        );\n    }\n\n    function handleMargin(bytes memory _data) internal returns (bytes memory) {\n        (address sender, PoolKey memory key, MarginBalanceDelta memory params) =\n            abi.decode(_data, (address, PoolKey, MarginBalanceDelta));\n\n        (BalanceDelta delta, uint256 feeAmount) = vault.marginBalance(key, params);\n\n        _processDelta(sender, key, delta, 0, 0, 0, 0);\n\n        return abi.encode(feeAmount);\n    }\n\n    function handleLiquidateBurn(bytes memory _data) internal returns (bytes memory) {\n        (\n            address sender,\n            PoolKey memory key,\n            MarginBalanceDelta memory params,\n            uint256 callerProfitAmount,\n            uint256 protocolProfitAmount\n        ) = abi.decode(_data, (address, PoolKey, MarginBalanceDelta, uint256, uint256));\n\n        vault.marginBalance(key, params);\n\n        Currency marginCurrency = params.marginForOne ? key.currency1 : key.currency0;\n        if (protocolProfitAmount > 0) {\n            address feeTo = IProtocolFees(address(vault)).protocolFeeController();\n            if (feeTo == address(0)) {\n                feeTo = owner;\n            }\n            marginCurrency.take(vault, feeTo, protocolProfitAmount, false);\n        }\n        if (callerProfitAmount > 0) {\n            marginCurrency.take(vault, sender, callerProfitAmount, false);\n        }\n\n        return abi.encode(callerProfitAmount + protocolProfitAmount);\n    }\n\n    // ******************** OWNER CALL ********************\n    function setMarginLevel(bytes32 _marginLevel) external onlyOwner {\n        MarginLevels newMarginLevels = MarginLevels.wrap(_marginLevel);\n        if (!newMarginLevels.isValidMarginLevels()) InvalidLevel.selector.revertWith();\n        bytes32 old = MarginLevels.unwrap(marginLevels);\n        marginLevels = newMarginLevels;\n        emit MarginLevelChanged(old, _marginLevel);\n    }\n\n    function setDefaultMarginFee(uint24 newMarginFee) external onlyOwner {\n        uint24 old = defaultMarginFee;\n        defaultMarginFee = newMarginFee;\n        emit MarginFeeChanged(old, newMarginFee);\n    }\n}\n",
        "LikwidLendPosition.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Likwid Contracts\npragma solidity ^0.8.26;\n\n// Local\nimport {Math} from \"./libraries/Math.sol\";\nimport {BasePositionManager} from \"./base/BasePositionManager.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {Currency} from \"./types/Currency.sol\";\nimport {BalanceDelta} from \"./types/BalanceDelta.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {ILendPositionManager} from \"./interfaces/ILendPositionManager.sol\";\nimport {LendPosition} from \"./libraries/LendPosition.sol\";\nimport {StateLibrary} from \"./libraries/StateLibrary.sol\";\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\nimport {CurrencyPoolLibrary} from \"./libraries/CurrencyPoolLibrary.sol\";\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\n\ncontract LikwidLendPosition is ILendPositionManager, BasePositionManager {\n    using CurrencyPoolLibrary for Currency;\n    using CustomRevert for bytes4;\n    using SafeCast for *;\n\n    mapping(uint256 tokenId => bool lendForOne) public lendDirections;\n\n    constructor(address initialOwner, IVault _vault)\n        BasePositionManager(\"LIKWIDLendPositionManager\", \"LLPM\", initialOwner, _vault)\n    {}\n\n    enum Actions {\n        DEPOSIT,\n        WITHDRAW,\n        SWAP\n    }\n\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        (Actions action, bytes memory params) = abi.decode(data, (Actions, bytes));\n\n        if (action == Actions.DEPOSIT) {\n            return handleLend(params);\n        } else if (action == Actions.WITHDRAW) {\n            return handleLend(params);\n        } else if (action == Actions.SWAP) {\n            return handleSwap(params);\n        } else {\n            InvalidCallback.selector.revertWith();\n        }\n    }\n\n    /// @inheritdoc ILendPositionManager\n    function getPositionState(uint256 tokenId) external view returns (LendPosition.State memory position) {\n        bytes32 salt = bytes32(tokenId);\n        PoolId poolId = poolIds[tokenId];\n        bool lendForOne = lendDirections[tokenId];\n        (,, uint256 deposit0CumulativeLast, uint256 deposit1CumulativeLast) =\n            StateLibrary.getBorrowDepositCumulative(vault, poolId);\n        uint256 depositCumulativeLast = lendForOne ? deposit1CumulativeLast : deposit0CumulativeLast;\n        position = StateLibrary.getLendPositionState(vault, poolId, address(this), lendForOne, salt);\n        position.lendAmount = Math.mulDiv(\n            position.lendAmount,\n            depositCumulativeLast,\n            position.depositCumulativeLast == 0 ? depositCumulativeLast : position.depositCumulativeLast\n        ).toUint128();\n        position.depositCumulativeLast = depositCumulativeLast;\n    }\n\n    /// @inheritdoc ILendPositionManager\n    function addLending(PoolKey memory key, bool lendForOne, address recipient, uint256 amount)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = _mintPosition(key, recipient);\n        lendDirections[tokenId] = lendForOne;\n        if (amount > 0) {\n            _deposit(msg.sender, recipient, tokenId, amount);\n        }\n    }\n\n    function _deposit(address sender, address tokenOwner, uint256 tokenId, uint256 amount) internal {\n        _requireAuth(tokenOwner, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        bool lendForOne = lendDirections[tokenId];\n        PoolKey memory key = poolKeys[poolId];\n\n        IVault.LendParams memory params =\n            IVault.LendParams({lendForOne: lendForOne, lendAmount: -amount.toInt128(), salt: bytes32(tokenId)});\n\n        bytes memory callbackData = abi.encode(sender, key, params);\n        bytes memory data = abi.encode(Actions.DEPOSIT, callbackData);\n\n        vault.unlock(data);\n        Currency currency = lendForOne ? key.currency1 : key.currency0;\n        emit Deposit(poolId, currency, sender, tokenId, tokenOwner, amount);\n    }\n\n    /// @inheritdoc ILendPositionManager\n    function deposit(uint256 tokenId, uint256 amount) external payable {\n        _deposit(msg.sender, msg.sender, tokenId, amount);\n    }\n\n    /// @inheritdoc ILendPositionManager\n    function withdraw(uint256 tokenId, uint256 amount) external {\n        _requireAuth(msg.sender, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        bool lendForOne = lendDirections[tokenId];\n        PoolKey memory key = poolKeys[poolId];\n\n        IVault.LendParams memory params =\n            IVault.LendParams({lendForOne: lendForOne, lendAmount: amount.toInt128(), salt: bytes32(tokenId)});\n\n        bytes memory callbackData = abi.encode(msg.sender, key, params);\n        bytes memory data = abi.encode(Actions.WITHDRAW, callbackData);\n\n        vault.unlock(data);\n        Currency currency = lendForOne ? key.currency1 : key.currency0;\n        emit Withdraw(poolId, currency, msg.sender, tokenId, msg.sender, amount);\n    }\n\n    function handleLend(bytes memory _data) internal returns (bytes memory) {\n        (address sender, PoolKey memory key, IVault.LendParams memory params) =\n            abi.decode(_data, (address, PoolKey, IVault.LendParams));\n\n        BalanceDelta delta = vault.lend(key, params);\n\n        (uint256 amount0, uint256 amount1) = _processDelta(sender, key, delta, 0, 0, 0, 0);\n\n        return abi.encode(amount0, amount1);\n    }\n\n    /// @inheritdoc ILendPositionManager\n    function exactInput(SwapInputParams calldata params)\n        external\n        payable\n        ensure(params.deadline)\n        returns (uint24 swapFee, uint256 feeAmount, uint256 amountOut)\n    {\n        _requireAuth(msg.sender, params.tokenId);\n        PoolKey memory key = poolKeys[params.poolId];\n        if (params.zeroForOne != lendDirections[params.tokenId]) {\n            InvalidCurrency.selector.revertWith();\n        }\n        int256 amountSpecified = -int256(params.amountIn);\n        IVault.SwapParams memory swapParams = IVault.SwapParams({\n            zeroForOne: params.zeroForOne,\n            amountSpecified: amountSpecified,\n            useMirror: true,\n            salt: bytes32(params.tokenId)\n        });\n        uint256 amount0Min = params.zeroForOne ? 0 : params.amountOutMin;\n        uint256 amount1Min = params.zeroForOne ? params.amountOutMin : 0;\n        bytes memory callbackData = abi.encode(msg.sender, key, swapParams, amount0Min, amount1Min, 0, 0);\n        bytes memory data = abi.encode(Actions.SWAP, callbackData);\n\n        bytes memory result = vault.unlock(data);\n        uint256 amount0;\n        uint256 amount1;\n        (swapFee, feeAmount, amount0, amount1) = abi.decode(result, (uint24, uint256, uint256, uint256));\n        amountOut = params.zeroForOne ? amount1 : amount0;\n    }\n\n    /// @inheritdoc ILendPositionManager\n    function exactOutput(SwapOutputParams calldata params)\n        external\n        payable\n        ensure(params.deadline)\n        returns (uint24 swapFee, uint256 feeAmount, uint256 amountIn)\n    {\n        _requireAuth(msg.sender, params.tokenId);\n        PoolKey memory key = poolKeys[params.poolId];\n        if (params.zeroForOne != lendDirections[params.tokenId]) {\n            InvalidCurrency.selector.revertWith();\n        }\n        int256 amountSpecified = int256(params.amountOut);\n        IVault.SwapParams memory swapParams = IVault.SwapParams({\n            zeroForOne: params.zeroForOne,\n            amountSpecified: amountSpecified,\n            useMirror: true,\n            salt: bytes32(params.tokenId)\n        });\n        uint256 amount0Max = params.zeroForOne ? params.amountInMax : 0;\n        uint256 amount1Max = params.zeroForOne ? 0 : params.amountInMax;\n        bytes memory callbackData = abi.encode(msg.sender, key, swapParams, 0, 0, amount0Max, amount1Max);\n        bytes memory data = abi.encode(Actions.SWAP, callbackData);\n\n        bytes memory result = vault.unlock(data);\n        uint256 amount0;\n        uint256 amount1;\n        (swapFee, feeAmount, amount0, amount1) = abi.decode(result, (uint24, uint256, uint256, uint256));\n        amountIn = params.zeroForOne ? amount0 : amount1;\n    }\n\n    function handleSwap(bytes memory _data) internal returns (bytes memory) {\n        (\n            address sender,\n            PoolKey memory key,\n            IVault.SwapParams memory params,\n            uint256 amount0Min,\n            uint256 amount1Min,\n            uint256 amount0Max,\n            uint256 amount1Max\n        ) = abi.decode(_data, (address, PoolKey, IVault.SwapParams, uint256, uint256, uint256, uint256));\n\n        (BalanceDelta delta, uint24 swapFee, uint256 feeAmount) = vault.swap(key, params);\n\n        uint256 amount0;\n        uint256 amount1;\n\n        if (params.zeroForOne) {\n            if (delta.amount0() < 0) {\n                amount0 = uint256(-int256(delta.amount0()));\n                if ((amount0Min > 0 && amount0 < amount0Min) || (amount0Max > 0 && amount0 > amount0Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n                key.currency0.settle(vault, sender, amount0, false);\n            } else if (delta.amount0() > 0) {\n                amount0 = uint256(int256(delta.amount0()));\n                if ((amount0Min > 0 && amount0 < amount0Min) || (amount0Max > 0 && amount0 > amount0Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n                key.currency0.take(vault, sender, amount0, false);\n            }\n            if (delta.amount1() < 0) {\n                amount1 = uint256(-int256(delta.amount1()));\n                if ((amount1Min > 0 && amount1 < amount1Min) || (amount1Max > 0 && amount1 > amount1Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n            } else if (delta.amount1() > 0) {\n                amount1 = uint256(int256(delta.amount1()));\n                if ((amount1Min > 0 && amount1 < amount1Min) || (amount1Max > 0 && amount1 > amount1Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n            }\n        } else {\n            if (delta.amount0() < 0) {\n                amount0 = uint256(-int256(delta.amount0()));\n                if ((amount0Min > 0 && amount0 < amount0Min) || (amount0Max > 0 && amount0 > amount0Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n            } else if (delta.amount0() > 0) {\n                amount0 = uint256(int256(delta.amount0()));\n                if ((amount0Min > 0 && amount0 < amount0Min) || (amount0Max > 0 && amount0 > amount0Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n            }\n            if (delta.amount1() < 0) {\n                amount1 = uint256(-int256(delta.amount1()));\n                if ((amount1Min > 0 && amount1 < amount1Min) || (amount1Max > 0 && amount1 > amount1Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n                key.currency1.settle(vault, sender, amount1, false);\n            } else if (delta.amount1() > 0) {\n                amount1 = uint256(int256(delta.amount1()));\n                if ((amount1Min > 0 && amount1 < amount1Min) || (amount1Max > 0 && amount1 > amount1Max)) {\n                    PriceSlippageTooHigh.selector.revertWith();\n                }\n                key.currency1.take(vault, sender, amount1, false);\n            }\n        }\n        _clearNative(sender);\n\n        return abi.encode(swapFee, feeAmount, amount0, amount1);\n    }\n}\n",
        "LikwidPairPosition.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Likwid Contracts\npragma solidity ^0.8.26;\n\n// Local\nimport {BasePositionManager} from \"./base/BasePositionManager.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {Currency} from \"./types/Currency.sol\";\nimport {BalanceDelta} from \"./types/BalanceDelta.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IPairPositionManager} from \"./interfaces/IPairPositionManager.sol\";\nimport {PairPosition} from \"./libraries/PairPosition.sol\";\nimport {StateLibrary} from \"./libraries/StateLibrary.sol\";\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\nimport {CurrencyPoolLibrary} from \"./libraries/CurrencyPoolLibrary.sol\";\n\ncontract LikwidPairPosition is IPairPositionManager, BasePositionManager {\n    using CurrencyPoolLibrary for Currency;\n    using CustomRevert for bytes4;\n\n    constructor(address initialOwner, IVault _vault)\n        BasePositionManager(\"LIKWIDPairPositionManager\", \"LPPM\", initialOwner, _vault)\n    {}\n\n    enum Actions {\n        MODIFY_LIQUIDITY,\n        SWAP\n    }\n\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        (Actions action, bytes memory params) = abi.decode(data, (Actions, bytes));\n\n        if (action == Actions.MODIFY_LIQUIDITY) {\n            return handleModifyLiquidity(params);\n        } else if (action == Actions.SWAP) {\n            return handleSwap(params);\n        } else {\n            InvalidCallback.selector.revertWith();\n        }\n    }\n\n    /// @inheritdoc IPairPositionManager\n    function getPositionState(uint256 tokenId) external view returns (PairPosition.State memory) {\n        bytes32 salt = bytes32(tokenId);\n        PoolId poolId = poolIds[tokenId];\n        return StateLibrary.getPairPositionState(vault, poolId, address(this), salt);\n    }\n\n    /// @inheritdoc IPairPositionManager\n    function addLiquidity(PoolKey memory key, uint256 amount0, uint256 amount1, uint256 amount0Min, uint256 amount1Min)\n        external\n        payable\n        returns (uint256 tokenId, uint128 liquidity)\n    {\n        tokenId = _mintPosition(key, msg.sender);\n        liquidity = _increaseLiquidity(msg.sender, msg.sender, tokenId, amount0, amount1, amount0Min, amount1Min);\n    }\n\n    function _increaseLiquidity(\n        address sender,\n        address tokenOwner,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) internal returns (uint128 liquidity) {\n        _requireAuth(tokenOwner, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        if (PoolId.unwrap(poolId) == 0) {\n            revert(\"Invalid tokenId\");\n        }\n        PoolKey memory key = poolKeys[poolId];\n\n        IVault.ModifyLiquidityParams memory params = IVault.ModifyLiquidityParams({\n            amount0: amount0,\n            amount1: amount1,\n            liquidityDelta: 0,\n            salt: bytes32(tokenId)\n        });\n\n        bytes memory callbackData = abi.encode(sender, key, params, amount0Min, amount1Min);\n        bytes memory data = abi.encode(Actions.MODIFY_LIQUIDITY, callbackData);\n\n        bytes memory result = vault.unlock(data);\n        (liquidity, amount0, amount1) = abi.decode(result, (uint128, uint256, uint256));\n    }\n\n    /// @inheritdoc IPairPositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) external payable returns (uint128 liquidity) {\n        liquidity = _increaseLiquidity(msg.sender, msg.sender, tokenId, amount0, amount1, amount0Min, amount1Min);\n    }\n\n    /// @inheritdoc IPairPositionManager\n    function removeLiquidity(uint256 tokenId, uint128 liquidity, uint256 amount0Min, uint256 amount1Min)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        _requireAuth(msg.sender, tokenId);\n        PoolId poolId = poolIds[tokenId];\n        if (PoolId.unwrap(poolId) == 0) {\n            revert(\"Invalid tokenId\");\n        }\n        PoolKey memory key = poolKeys[poolId];\n\n        IVault.ModifyLiquidityParams memory params = IVault.ModifyLiquidityParams({\n            amount0: 0,\n            amount1: 0,\n            liquidityDelta: -int128(liquidity),\n            salt: bytes32(tokenId)\n        });\n\n        bytes memory callbackData = abi.encode(msg.sender, key, params, amount0Min, amount1Min);\n        bytes memory data = abi.encode(Actions.MODIFY_LIQUIDITY, callbackData);\n\n        bytes memory result = vault.unlock(data);\n        (, amount0, amount1) = abi.decode(result, (int128, uint256, uint256));\n    }\n\n    function handleModifyLiquidity(bytes memory _data) internal returns (bytes memory) {\n        (\n            address sender,\n            PoolKey memory key,\n            IVault.ModifyLiquidityParams memory params,\n            uint256 amount0Min,\n            uint256 amount1Min\n        ) = abi.decode(_data, (address, PoolKey, IVault.ModifyLiquidityParams, uint256, uint256));\n\n        (BalanceDelta delta, int128 finalLiquidityDelta) = vault.modifyLiquidity(key, params);\n\n        (uint256 amount0, uint256 amount1) =\n            _processDelta(sender, key, delta, amount0Min, amount1Min, params.amount0, params.amount1);\n\n        emit ModifyLiquidity(key.toId(), uint256(params.salt), sender, finalLiquidityDelta, amount0, amount1);\n        return abi.encode(finalLiquidityDelta, amount0, amount1);\n    }\n\n    /// @inheritdoc IPairPositionManager\n    function exactInput(SwapInputParams calldata params)\n        external\n        payable\n        ensure(params.deadline)\n        returns (uint24 swapFee, uint256 feeAmount, uint256 amountOut)\n    {\n        PoolKey memory key = poolKeys[params.poolId];\n        int256 amountSpecified = -int256(params.amountIn);\n        IVault.SwapParams memory swapParams = IVault.SwapParams({\n            zeroForOne: params.zeroForOne,\n            amountSpecified: amountSpecified,\n            useMirror: false,\n            salt: bytes32(0)\n        });\n        uint256 amount0Min = params.zeroForOne ? 0 : params.amountOutMin;\n        uint256 amount1Min = params.zeroForOne ? params.amountOutMin : 0;\n        bytes memory callbackData = abi.encode(msg.sender, key, swapParams, amount0Min, amount1Min, 0, 0);\n        bytes memory data = abi.encode(Actions.SWAP, callbackData);\n\n        bytes memory result = vault.unlock(data);\n        uint256 amount0;\n        uint256 amount1;\n        (swapFee, feeAmount, amount0, amount1) = abi.decode(result, (uint24, uint256, uint256, uint256));\n        amountOut = params.zeroForOne ? amount1 : amount0;\n    }\n\n    /// @inheritdoc IPairPositionManager\n    function exactOutput(SwapOutputParams calldata params)\n        external\n        payable\n        ensure(params.deadline)\n        returns (uint24 swapFee, uint256 feeAmount, uint256 amountIn)\n    {\n        PoolKey memory key = poolKeys[params.poolId];\n        int256 amountSpecified = int256(params.amountOut);\n        IVault.SwapParams memory swapParams = IVault.SwapParams({\n            zeroForOne: params.zeroForOne,\n            amountSpecified: amountSpecified,\n            useMirror: false,\n            salt: bytes32(0)\n        });\n        uint256 amount0Max = params.zeroForOne ? params.amountInMax : 0;\n        uint256 amount1Max = params.zeroForOne ? 0 : params.amountInMax;\n        bytes memory callbackData = abi.encode(msg.sender, key, swapParams, 0, 0, amount0Max, amount1Max);\n        bytes memory data = abi.encode(Actions.SWAP, callbackData);\n\n        bytes memory result = vault.unlock(data);\n        uint256 amount0;\n        uint256 amount1;\n        (swapFee, feeAmount, amount0, amount1) = abi.decode(result, (uint24, uint256, uint256, uint256));\n        amountIn = params.zeroForOne ? amount0 : amount1;\n    }\n\n    function handleSwap(bytes memory _data) internal returns (bytes memory) {\n        (\n            address sender,\n            PoolKey memory key,\n            IVault.SwapParams memory params,\n            uint256 amount0Min,\n            uint256 amount1Min,\n            uint256 amount0Max,\n            uint256 amount1Max\n        ) = abi.decode(_data, (address, PoolKey, IVault.SwapParams, uint256, uint256, uint256, uint256));\n\n        (BalanceDelta delta, uint24 swapFee, uint256 feeAmount) = vault.swap(key, params);\n\n        (uint256 amount0, uint256 amount1) =\n            _processDelta(sender, key, delta, amount0Min, amount1Min, amount0Max, amount1Max);\n\n        return abi.encode(swapFee, feeAmount, amount0, amount1);\n    }\n}\n",
        "BasePositionManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Likwid Contracts\npragma solidity ^0.8.26;\n\n// Openzeppelin\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n// Solmate\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\n// Local\nimport {IBasePositionManager} from \"../interfaces/IBasePositionManager.sol\";\nimport {ImmutableState} from \"./ImmutableState.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {Currency, CurrencyLibrary} from \"../types/Currency.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IUnlockCallback} from \"../interfaces/callback/IUnlockCallback.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\nimport {CurrencyPoolLibrary} from \"../libraries/CurrencyPoolLibrary.sol\";\n\nabstract contract BasePositionManager is\n    IBasePositionManager,\n    ImmutableState,\n    IUnlockCallback,\n    ERC721Enumerable,\n    Owned\n{\n    using CurrencyPoolLibrary for Currency;\n    using CustomRevert for bytes4;\n\n    uint256 public nextId = 1;\n\n    mapping(uint256 tokenId => PoolId poolId) public poolIds;\n    mapping(PoolId poolId => PoolKey poolKey) public poolKeys;\n\n    constructor(string memory name_, string memory symbol_, address initialOwner, IVault _vault)\n        ImmutableState(_vault)\n        Owned(initialOwner)\n        ERC721(name_, symbol_)\n    {}\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        _;\n    }\n\n    function _requireAuth(address spender, uint256 tokenId) internal view {\n        if (spender != ownerOf(tokenId)) {\n            NotOwner.selector.revertWith();\n        }\n    }\n\n    function _clearNative(address spender) internal {\n        // clear any native currency left in the contract\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            CurrencyLibrary.ADDRESS_ZERO.transfer(spender, balance);\n        }\n    }\n\n    function _processDelta(\n        address sender,\n        PoolKey memory key,\n        BalanceDelta delta,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 amount0Max,\n        uint256 amount1Max\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        if (delta.amount0() < 0) {\n            amount0 = uint256(-int256(delta.amount0()));\n            if ((amount0Min > 0 && amount0 < amount0Min) || (amount0Max > 0 && amount0 > amount0Max)) {\n                PriceSlippageTooHigh.selector.revertWith();\n            }\n            key.currency0.settle(vault, sender, amount0, false);\n        } else if (delta.amount0() > 0) {\n            amount0 = uint256(int256(delta.amount0()));\n            if ((amount0Min > 0 && amount0 < amount0Min) || (amount0Max > 0 && amount0 > amount0Max)) {\n                PriceSlippageTooHigh.selector.revertWith();\n            }\n            key.currency0.take(vault, sender, amount0, false);\n        }\n\n        if (delta.amount1() < 0) {\n            amount1 = uint256(-int256(delta.amount1()));\n            if ((amount1Min > 0 && amount1 < amount1Min) || (amount1Max > 0 && amount1 > amount1Max)) {\n                PriceSlippageTooHigh.selector.revertWith();\n            }\n            key.currency1.settle(vault, sender, amount1, false);\n        } else if (delta.amount1() > 0) {\n            amount1 = uint256(int256(delta.amount1()));\n            if ((amount1Min > 0 && amount1 < amount1Min) || (amount1Max > 0 && amount1 > amount1Max)) {\n                PriceSlippageTooHigh.selector.revertWith();\n            }\n            key.currency1.take(vault, sender, amount1, false);\n        }\n\n        _clearNative(sender);\n    }\n\n    function _mintPosition(PoolKey memory key, address to) internal returns (uint256 tokenId) {\n        tokenId = nextId++;\n        _mint(to, tokenId);\n\n        PoolId poolId = key.toId();\n        poolIds[tokenId] = poolId;\n        if (poolKeys[poolId].currency1 == Currency.wrap(address(0))) {\n            poolKeys[poolId] = key;\n        } else {\n            PoolKey memory existingKey = poolKeys[poolId];\n            if (\n                !(\n                    existingKey.currency0 == key.currency0 && existingKey.currency1 == key.currency1\n                        && existingKey.fee == key.fee\n                )\n            ) {\n                MismatchedPoolKey.selector.revertWith();\n            }\n        }\n    }\n\n    /// @inheritdoc IUnlockCallback\n    function unlockCallback(bytes calldata data) external virtual returns (bytes memory);\n}\n"
    }
}