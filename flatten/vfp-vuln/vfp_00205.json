{
    "vfp_id": "vfp_00205",
    "project_name": "ChainSecurity_Steakhouse_Box_Audit.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "FundingMorpho.depledge() Does Not Sanitize collateralToken",
            "description": "The depledge() function in FundingMorpho allows callers to specify any whitelisted collateral token, not necessarily the one associated with the market. If a different whitelisted token is provided, the function withdraws the correct collateral from Morpho but transfers the specified token (e.g., DAI) to the owner instead. This causes the actual withdrawn collateral (e.g., WETH) to remain stuck in the funding module. During winddown, anyone can exploit this to drain mismatched tokens. In normal mode, only privileged allocators can trigger it. A similar issue exists in borrow(). The root cause is the lack of validation that the supplied collateralToken matches the market's actual collateral token.\n",
            "severity": "Medium",
            "location": [
                "FundingMorpho.sol::depledge",
                "FundingMorpho.sol::borrow"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        }
    ],
    "affected_files": {
        "FundingMorpho.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IMorpho, Id, MarketParams, Position} from \"@morpho-blue/interfaces/IMorpho.sol\";\nimport \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MarketParamsLib} from \"@morpho-blue/libraries/MarketParamsLib.sol\";\nimport {MorphoBalancesLib} from \"@morpho-blue/libraries/periphery/MorphoBalancesLib.sol\";\nimport {MorphoLib} from \"@morpho-blue/libraries/periphery/MorphoLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {MathLib} from \"./../lib/morpho-blue/src/libraries/MathLib.sol\";\nimport {FundingBase} from \"./FundingBase.sol\";\nimport {IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\n\ncontract FundingMorpho is FundingBase {\n    using SafeERC20 for IERC20;\n    using MarketParamsLib for MarketParams;\n    using MorphoBalancesLib for IMorpho;\n    using MorphoLib for IMorpho;\n    using MathLib for uint256;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IMorpho public immutable morpho;\n    uint256 public immutable lltvCap; // Maximum LTV/LTTV ration in 18 decimals, e.g. 80e16 for 80%\n\n    mapping(bytes32 => bytes) public facilityDataMap; // hash => facility data\n\n    constructor(address owner_, address morpho_, uint256 lltvCap_) FundingBase(owner_) {\n        require(morpho_ != address(0), ErrorsLib.InvalidAddress());\n        require(lltvCap_ <= 100e16, ErrorsLib.InvalidValue()); // Max 100%\n        require(lltvCap_ > 0, ErrorsLib.InvalidValue()); // Min above 0%\n\n        morpho = IMorpho(morpho_);\n        lltvCap = lltvCap_;\n    }\n\n    // ========== ADMIN ==========\n\n    /// @dev Before adding a facility, you need to add the underlying tokens as collateral/debt tokens\n    function addFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(isCollateralToken(IERC20(market.collateralToken)), ErrorsLib.TokenNotWhitelisted());\n        require(isDebtToken(IERC20(market.loanToken)), ErrorsLib.TokenNotWhitelisted());\n\n        bytes32 facilityHash = keccak256(facilityData);\n        require(facilitiesSet.add(facilityHash), ErrorsLib.AlreadyWhitelisted());\n        facilityDataMap[facilityHash] = facilityData;\n    }\n\n    function removeFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!_isFacilityUsed(facilityData), ErrorsLib.CannotRemove());\n\n        bytes32 facilityHash = keccak256(facilityData);\n        require(facilitiesSet.remove(facilityHash), ErrorsLib.NotWhitelisted());\n        delete facilityDataMap[facilityHash];\n    }\n\n    function facilities(uint256 index) external view returns (bytes memory) {\n        bytes32 facilityHash = facilitiesSet.at(index);\n        return facilityDataMap[facilityHash];\n    }\n\n    /// @dev Before being able to remove a collateral, no facility should reference it and the balance should be 0\n    function removeCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_collateralBalance(collateralToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 length = facilitiesSet.length();\n        for (uint i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            require(address(market.collateralToken) != address(collateralToken), ErrorsLib.CannotRemove());\n        }\n\n        require(collateralTokensSet.remove(address(collateralToken)), ErrorsLib.NotWhitelisted());\n    }\n\n    /// @dev Before being able to remove a debt, no facility should reference it and the balance should be 0\n    function removeDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_debtBalance(debtToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 length = facilitiesSet.length();\n        for (uint i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            require(address(market.loanToken) != address(debtToken), ErrorsLib.CannotRemove());\n        }\n\n        require(debtTokensSet.remove(address(debtToken)), ErrorsLib.NotWhitelisted());\n    }\n\n    // ========== ACTIONS ==========\n\n    /// @dev Assume caller did transfer the collateral tokens to this contract before calling\n    function pledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n\n        collateralToken.forceApprove(address(morpho), collateralAmount);\n        morpho.supplyCollateral(market, collateralAmount, address(this), \"\");\n    }\n\n    function depledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n\n        morpho.withdrawCollateral(market, collateralAmount, address(this), owner);\n\n        require(ltv(facilityData) <= (market.lltv * lltvCap) / 100e16, ErrorsLib.ExcessiveLTV());\n    }\n\n    function borrow(bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n\n        morpho.borrow(market, borrowAmount, 0, address(this), owner);\n\n        require(ltv(facilityData) <= (market.lltv * lltvCap) / 100e16, ErrorsLib.ExcessiveLTV());\n    }\n\n    /// @dev Assume caller did transfer the debt tokens to this contract before calling\n    function repay(bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n\n        uint256 debtAmount = morpho.expectedBorrowAssets(market, address(this));\n\n        debtToken.forceApprove(address(morpho), repayAmount);\n\n        // If the amount repaid is all the debt, we convert to all shares\n        // amount repaid would internally get translated to more shares that there is to repaid\n        if (repayAmount == debtAmount) {\n            morpho.repay(market, 0, morpho.borrowShares(market.id(), address(this)), address(this), \"\");\n        } else {\n            morpho.repay(market, repayAmount, 0, address(this), \"\");\n        }\n    }\n\n    // ========== POSITION ==========\n\n    /// @dev returns 0 if there is no collateral\n    function ltv(bytes calldata facilityData) public view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        Id marketId = market.id();\n        uint256 borrowedAssets = morpho.expectedBorrowAssets(market, address(this));\n        uint256 collateralAmount = morpho.collateral(marketId, address(this));\n        if (collateralAmount == 0) return 0;\n        require(market.oracle != address(0), ErrorsLib.NoOracleForToken());\n        uint256 collateralPrice = IOracle(market.oracle).price();\n        uint256 collateralValue = collateralAmount.mulDivDown(collateralPrice, ORACLE_PRICE_SCALE);\n        return (collateralValue == 0) ? 0 : borrowedAssets.wDivUp(collateralValue);\n    }\n\n    function debtBalance(bytes calldata facilityData, IERC20 debtToken) external view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n        return morpho.expectedBorrowAssets(market, address(this));\n    }\n\n    function collateralBalance(bytes calldata facilityData, IERC20 collateralToken) external view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n        return morpho.collateral(market.id(), address(this));\n    }\n\n    /// @dev The NAV for a given lending market can be negative but there is no recourse so it can be floored to 0.\n    function nav(IOracleCallback oraclesProvider) public view override returns (uint256) {\n        uint256 nav_ = 0;\n        address asset = oraclesProvider.asset();\n        uint256 length = facilitiesSet.length();\n        for (uint256 i = 0; i < length; i++) {\n            uint256 facilityNav = 0;\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            uint256 collateralBalance_ = morpho.collateral(market.id(), address(this));\n\n            if (collateralBalance_ == 0) continue; // No debt if no collateral\n\n            if (market.collateralToken == asset) {\n                // RIs are considered to have a price of ORACLE_PRECISION\n                facilityNav += collateralBalance_;\n            } else {\n                IOracle oracle = oraclesProvider.oracles(IERC20(market.collateralToken));\n                facilityNav += collateralBalance_.mulDivDown(oracle.price(), ORACLE_PRICE_SCALE);\n            }\n\n            uint256 debtBalance_ = morpho.expectedBorrowAssets(market, address(this));\n\n            if (market.loanToken == asset) {\n                facilityNav = (facilityNav > debtBalance_) ? facilityNav - debtBalance_ : 0;\n            } else {\n                IOracle oracle = oraclesProvider.oracles(IERC20(market.loanToken));\n                uint256 value = debtBalance_.mulDivUp(oracle.price(), ORACLE_PRICE_SCALE);\n                facilityNav = (facilityNav > value) ? facilityNav - value : 0;\n            }\n\n            nav_ += facilityNav;\n        }\n        return nav_;\n    }\n\n    // ========== Other exposed view functions ==========\n\n    function decodeFacilityData(bytes memory facilityData) public pure returns (MarketParams memory market) {\n        // MarketParams has 4 addresses (32 bytes each) + 1 uint256 (32 bytes) = 160 bytes\n        require(facilityData.length == 160, ErrorsLib.InvalidFacilityData());\n        (MarketParams memory marketParams) = abi.decode(facilityData, (MarketParams));\n        return (marketParams);\n    }\n\n    function encodeFacilityData(MarketParams memory market) public pure returns (bytes memory) {\n        return abi.encode(market);\n    }\n\n    // ========== Internal functions ==========\n    function _debtBalance(IERC20 debtToken) internal view override returns (uint256 balance) {\n        uint256 length = facilitiesSet.length();\n        for (uint256 i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            if (address(debtToken) == market.loanToken) {\n                balance += morpho.expectedBorrowAssets(market, address(this));\n            }\n        }\n    }\n\n    function _collateralBalance(IERC20 collateralToken) internal view override returns (uint256 balance) {\n        uint256 length = facilitiesSet.length();\n        for (uint256 i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            if (address(collateralToken) == market.collateralToken) {\n                balance += morpho.collateral(market.id(), address(this));\n            }\n        }\n    }\n\n    function _isFacilityUsed(bytes calldata facilityData) internal view override returns (bool) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        Position memory position = morpho.position(market.id(), address(this));\n        return position.collateral > 0 || position.borrowShares > 0;\n    }\n}\n"
    }
}