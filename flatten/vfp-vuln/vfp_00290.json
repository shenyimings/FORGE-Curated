{
    "vfp_id": "vfp_00290",
    "project_name": "Cove - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of access control in requestDeposit",
            "description": "The BasketToken contract's requestDeposit function allows any caller to deposit assets on behalf of any user, provided the user has approved the contract to spend their tokens. This is due to the absence of access control checks ensuring that only the owner can initiate deposits for themselves. An attacker can exploit this by calling requestDeposit with a victim's address as the owner and themselves as the controller, thereby gaining control over the deposited assets. This leads to a complete loss of funds for users who have approved the contract, as their assets can be effectively stolen through unauthorized deposits.\n",
            "severity": "Critical",
            "location": [
                "BasketToken.sol::requestDeposit"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Missing rebalance-status check in updateBitFlag() leads to incorrect rebalancing",
            "description": "The updateBitFlag function in BasketToken allows administrative changes to the basket's asset configuration without verifying whether a rebalance operation is currently in progress. If called during an active rebalance, it updates the basketAssets array, which is used by the rebalancing logic to determine which assets to trade. This can result in the rebalancer using an inconsistent or outdated list of assets, leading to incorrect balance calculations, erroneous trade proposals, or failed rebalances. The root cause is the lack of a reentrancy-like guard or status check to prevent configuration changes during critical operations.\n",
            "severity": "High",
            "location": [
                "BasketToken.sol::updateBitFlag"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Management-fee calculation results in lower effective rate",
            "description": "The _harvestManagementFee function mints new shares as fees, but it calculates the fee amount based on the pre-mint total supply. After minting, the total supply increases, diluting the effective fee rate. For example, a 5% fee results in only ~4.76% effective rate due to the increased denominator. This flaw stems from not accounting for the dilutive effect of minting in the fee calculation. As a result, the protocol consistently collects less value than intended, leading to long-term revenue loss and misaligned incentives.\n",
            "severity": "High",
            "location": [
                "BasketToken.sol::_harvestManagementFee"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Missing mapping update in BasketToken.updateBitFlag() causes rebalancing failure",
            "description": "The updateBitFlag function updates the basketAssets array but fails to update the basketAssetToIndexPlusOne mapping, which is used during rebalancing to locate assets by index. When a new asset is added via bitFlag update, its index is not recorded in this mapping. Subsequently, during rebalancing, calls to basketTokenToRebalanceAssetToIndex fail with \"AssetNotFoundInBasket\" because the index lookup returns zero. This breaks the rebalancing process for baskets with updated assets, preventing proper portfolio adjustments and potentially freezing asset management operations.\n",
            "severity": "Medium",
            "location": [
                "BasketToken.sol::updateBitFlag"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Potential price manipulation via read-only reentrancy in BasketToken.proRataRedeem()",
            "description": "The proRataRedeem function in BasketToken burns shares before completing the redemption via BasketManager, creating a reentrancy window through ERC20PluginsUpgradeable's plugin system. If the 'from' address has a malicious plugin, it can reenter during the _updateBalances call after _burn but before assets are withdrawn. This allows manipulation of the basket's totalAssets during the redemption, temporarily inflating the LP token price. Third-party protocols relying on this price for collateral valuation could be tricked into allowing excessive borrowing. The impact is potential fund loss in integrated systems due to price oracle manipulation, even though the core contract has reentrancy guards.\n",
            "severity": "Medium",
            "location": [
                "BasketToken.sol::proRataRedeem"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        }
    ],
    "affected_files": {
        "BasketToken.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { ERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ERC4626Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { MulticallUpgradeable } from \"@openzeppelin-upgradeable/contracts/utils/MulticallUpgradeable.sol\";\nimport { ERC165Upgradeable } from \"@openzeppelin-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FixedPointMathLib } from \"@solady/utils/FixedPointMathLib.sol\";\nimport { EulerRouter } from \"euler-price-oracle/src/EulerRouter.sol\";\nimport { SelfPermit } from \"src/deps/uniswap-v3-periphery/base/SelfPermit.sol\";\nimport { ERC20PluginsUpgradeable } from \"token-plugins-upgradeable/contracts/ERC20PluginsUpgradeable.sol\";\n\nimport { AssetRegistry } from \"src/AssetRegistry.sol\";\nimport { BasketManager } from \"src/BasketManager.sol\";\nimport { FeeCollector } from \"src/FeeCollector.sol\";\nimport { IERC7540Deposit, IERC7540Operator, IERC7540Redeem } from \"src/interfaces/IERC7540.sol\";\nimport { Errors } from \"src/libraries/Errors.sol\";\nimport { WeightStrategy } from \"src/strategies/WeightStrategy.sol\";\n\n/// @title BasketToken\n/// @notice Manages user deposits and redemptions, which are processed asynchronously by the Basket Manager.\n// slither-disable-next-line missing-inheritance\ncontract BasketToken is\n    ERC20PluginsUpgradeable,\n    ERC4626Upgradeable,\n    ERC165Upgradeable,\n    IERC7540Operator,\n    IERC7540Deposit,\n    IERC7540Redeem,\n    MulticallUpgradeable,\n    SelfPermit\n{\n    /// LIBRARIES ///\n    using SafeERC20 for IERC20;\n\n    /// CONSTANTS ///\n    /// @notice ISO 4217 numeric code for USD, used as a constant address representation\n    address private constant _USD_ISO_4217_CODE = address(840);\n    uint16 private constant _MANAGEMENT_FEE_DECIMALS = 1e4;\n    /// @notice Maximum management fee (30%) in BPS denominated in 1e4.\n    uint16 private constant _MAX_MANAGEMENT_FEE = 3000;\n\n    /// @notice Struct representing a deposit request.\n    struct DepositRequestStruct {\n        // Mapping of controller addresses to their deposited asset amounts.\n        mapping(address controller => uint256 assets) depositAssets;\n        // Total amount of assets deposited in this request.\n        uint256 totalDepositAssets;\n        // Number of shares fulfilled for this deposit request.\n        uint256 fulfilledShares;\n    }\n\n    /// @notice Struct representing a redeem request.\n    struct RedeemRequestStruct {\n        // Mapping of controller addresses to their shares to be redeemed.\n        mapping(address controller => uint256 shares) redeemShares;\n        // Total number of shares to be redeemed in this request.\n        uint256 totalRedeemShares;\n        // Amount of assets fulfilled for this redeem request.\n        uint256 fulfilledAssets;\n        // Flag indicating if the fallback redemption process has been triggered.\n        bool fallbackTriggered;\n    }\n\n    /// STATE VARIABLES ///\n    /// @notice Operator approval status per controller.\n    mapping(address controller => mapping(address operator => bool)) public isOperator;\n    /// @notice Last deposit request ID per controller.\n    mapping(address controller => uint256 requestId) public lastDepositRequestId;\n    /// @notice Last redemption request ID per controller.\n    mapping(address controller => uint256 requestId) public lastRedeemRequestId;\n    /// @dev Deposit requests mapped by request ID. Even IDs are for deposits.\n    mapping(uint256 requestId => DepositRequestStruct) internal _depositRequests;\n    /// @dev Redemption requests mapped by request ID. Odd IDs are for redemptions.\n    mapping(uint256 requestId => RedeemRequestStruct) internal _redeemRequests;\n    /// @notice Address of the BasketManager contract handling deposits and redemptions.\n    address public basketManager;\n    /// @notice Upcoming deposit request ID.\n    uint256 public nextDepositRequestId;\n    /// @notice Upcoming redemption request ID.\n    uint256 public nextRedeemRequestId;\n    /// @notice Address of the AssetRegistry contract for asset status checks.\n    address public assetRegistry;\n    /// @notice Bitflag representing selected assets.\n    uint256 public bitFlag;\n    /// @notice Strategy contract address associated with this basket.\n    address public strategy;\n    /// @notice Timestamp of the last management fee harvest.\n    uint40 public lastManagementFeeHarvestTimestamp;\n\n    /// EVENTS ///\n    /// @notice Emitted when the management fee is harvested.\n    /// @param fee The amount of the management fee harvested.\n    event ManagementFeeHarvested(uint256 fee);\n    /// @notice Emitted when a deposit request is fulfilled and assets are transferred to the user.\n    /// @param requestId The unique identifier of the deposit request.\n    /// @param assets The amount of assets that were deposited.\n    /// @param shares The number of shares minted for the deposit.\n    event DepositFulfilled(uint256 indexed requestId, uint256 assets, uint256 shares);\n    /// @notice Emitted when a redemption request is fulfilled and shares are burned.\n    /// @param requestId The unique identifier of the redemption request.\n    /// @param shares The number of shares redeemed.\n    /// @param assets The amount of assets returned to the user.\n    event RedeemFulfilled(uint256 indexed requestId, uint256 shares, uint256 assets);\n    /// @notice Emitted when the bitflag is updated to a new value.\n    /// @param oldBitFlag The previous bitflag value.\n    /// @param newBitFlag The new bitflag value.\n    event BitFlagUpdated(uint256 oldBitFlag, uint256 newBitFlag);\n\n    /// ERRORS ///\n    /// @notice Thrown when there are no pending deposits to fulfill.\n    error ZeroPendingDeposits();\n    /// @notice Thrown when there are no pending redeems to fulfill.\n    error ZeroPendingRedeems();\n    /// @notice Thrown when attempting to request a deposit or redeem while one or more of the basket's assets are\n    /// paused in the AssetRegistry.\n    error AssetPaused();\n    /// @notice Thrown when attempting to request a new deposit while the user has an outstanding claimable deposit from\n    /// a previous request. The user must first claim the outstanding deposit.\n    error MustClaimOutstandingDeposit();\n    /// @notice Thrown when attempting to request a new redeem while the user has an outstanding claimable redeem from a\n    /// previous request. The user must first claim the outstanding redeem.\n    error MustClaimOutstandingRedeem();\n    /// @notice Thrown when attempting to claim a partial amount of an outstanding deposit or redeem. The user must\n    /// claim the full claimable amount.\n    error MustClaimFullAmount();\n    /// @notice Thrown when the basket manager attempts to fulfill a deposit request with zero shares.\n    error CannotFulfillWithZeroShares();\n    /// @notice Thrown when the basket manager attempts to fulfill a redeem request with zero assets.\n    error CannotFulfillWithZeroAssets();\n    /// @notice Thrown when attempting to claim fallback shares when none are available.\n    error ZeroClaimableFallbackShares();\n    /// @notice Thrown when a non-authorized address attempts to request a deposit or redeem on behalf of another user\n    /// who has not approved them as an operator.\n    error NotAuthorizedOperator();\n    /// @notice Thrown when an address other than the basket manager attempts to call a basket manager only function.\n    error NotBasketManager();\n    /// @notice Thrown when attempting to set an invalid management fee percentage greater than the maximum allowed.\n    error InvalidManagementFee();\n    /// @notice Thrown when the basket manager attempts to fulfill a deposit request that has already been fulfilled.\n    error DepositRequestAlreadyFulfilled();\n    /// @notice Thrown when the basket manager attempts to fulfill a redeem request that has already been fulfilled.\n    error RedeemRequestAlreadyFulfilled();\n    /// @notice Thrown when the basket manager attempts to trigger the fallback for a redeem request that has already\n    /// been put in fallback state.\n    error RedeemRequestAlreadyFallbacked();\n    /// @notice Thrown when attempting to prepare for a new rebalance before the previous epoch's deposit request has\n    /// been fulfilled.\n    error PreviousDepositRequestNotFulfilled();\n    /// @notice Thrown when attempting to prepare for a new rebalance before the previous epoch's redeem request has\n    /// been fulfilled or put in fallback state.\n    error PreviousRedeemRequestNotFulfilled();\n\n    /// @notice Disables initializer functions.\n    constructor() payable {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract.\n    /// @param asset_ Address of the underlying asset.\n    /// @param name_ Name of the token, prefixed with \"CoveBasket-\".\n    /// @param symbol_ Symbol of the token, prefixed with \"cb\".\n    /// @param bitFlag_ Bitflag representing selected assets.\n    /// @param strategy_ Strategy contract address.\n    function initialize(\n        IERC20 asset_,\n        string memory name_,\n        string memory symbol_,\n        uint256 bitFlag_,\n        address strategy_,\n        address assetRegistry_\n    )\n        public\n        initializer\n    {\n        if (strategy_ == address(0) || assetRegistry_ == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        basketManager = msg.sender;\n        bitFlag = bitFlag_;\n        strategy = strategy_;\n        assetRegistry = assetRegistry_;\n        nextDepositRequestId = 2;\n        nextRedeemRequestId = 3;\n        __ERC4626_init(asset_);\n        __ERC20_init(string.concat(\"CoveBasket-\", name_), string.concat(\"covb\", symbol_));\n        __ERC20Plugins_init(8, 2_000_000);\n    }\n\n    /// @notice Returns the value of the basket in assets. This will be an estimate as it does not account for other\n    /// factors that may affect the swap rates.\n    /// @return The total value of the basket in assets.\n    function totalAssets() public view override returns (uint256) {\n        address[] memory assets = AssetRegistry(assetRegistry).getAssets(bitFlag);\n        uint256 usdAmount;\n        uint256 assetsLength = assets.length;\n\n        BasketManager bm = BasketManager(basketManager);\n        EulerRouter eulerRouter = EulerRouter(bm.eulerRouter());\n\n        for (uint256 i = 0; i < assetsLength;) {\n            // slither-disable-start calls-loop\n            uint256 assetBalance = bm.basketBalanceOf(address(this), assets[i]);\n            // Rounding direction: down\n            usdAmount += eulerRouter.getQuote(assetBalance, assets[i], _USD_ISO_4217_CODE);\n            // slither-disable-end calls-loop\n\n            unchecked {\n                // Overflow not possible: i is less than assetsLength\n                ++i;\n            }\n        }\n\n        return eulerRouter.getQuote(usdAmount, _USD_ISO_4217_CODE, asset());\n    }\n\n    /// @notice Returns the target weights for the given epoch.\n    /// @return The target weights for the basket.\n    function getTargetWeights() public view returns (uint64[] memory) {\n        return WeightStrategy(strategy).getTargetWeights(bitFlag);\n    }\n\n    /// ERC7540 LOGIC ///\n\n    /// @notice Transfers assets from owner and submits a request for an asynchronous deposit.\n    /// @param assets The amount of assets to deposit.\n    /// @param controller The address of the controller of the position being created.\n    /// @param owner The address of the owner of the assets being deposited.\n    function requestDeposit(uint256 assets, address controller, address owner) public returns (uint256 requestId) {\n        // Checks\n        if (assets == 0) {\n            revert Errors.ZeroAmount();\n        }\n        requestId = nextDepositRequestId;\n        uint256 userLastDepositRequestId = lastDepositRequestId[controller];\n        // If the user has a pending deposit request in the past, they must wait for it to be fulfilled before making a\n        // new one\n        if (userLastDepositRequestId != requestId) {\n            if (pendingDepositRequest(userLastDepositRequestId, controller) > 0) {\n                revert MustClaimOutstandingDeposit();\n            }\n        }\n        // If the user has a claimable deposit request, they must claim it before making a new one\n        if (claimableDepositRequest(userLastDepositRequestId, controller) > 0) {\n            revert MustClaimOutstandingDeposit();\n        }\n        if (AssetRegistry(assetRegistry).hasPausedAssets(bitFlag)) {\n            revert AssetPaused();\n        }\n        // Effects\n        DepositRequestStruct storage depositRequest = _depositRequests[requestId];\n        // update controllers balance of assets pending deposit\n        depositRequest.depositAssets[controller] += assets;\n        // update total pending deposits for the current requestId\n        depositRequest.totalDepositAssets += assets;\n        // update controllers latest deposit request id\n        lastDepositRequestId[controller] = requestId;\n        emit DepositRequest(controller, owner, requestId, msg.sender, assets);\n        // Interactions\n        // Assets are immediately transferrred to here to await the basketManager to pull them\n        // slither-disable-next-line arbitrary-send-erc20\n        IERC20(asset()).safeTransferFrom(owner, address(this), assets);\n    }\n\n    /// @notice Returns the pending deposit request amount for a controller.\n    /// @dev If the epoch has been advanced then the request has been fulfilled and is no longer pending.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller of the deposit request.\n    /// @return assets The amount of assets pending deposit.\n    function pendingDepositRequest(uint256 requestId, address controller) public view returns (uint256 assets) {\n        DepositRequestStruct storage depositRequest = _depositRequests[requestId];\n        assets = depositRequest.fulfilledShares == 0 ? depositRequest.depositAssets[controller] : 0;\n    }\n\n    /// @notice Returns the amount of requested assets in Claimable state for the controller with the given requestId.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller.\n    function claimableDepositRequest(uint256 requestId, address controller) public view returns (uint256 assets) {\n        DepositRequestStruct storage depositRequest = _depositRequests[requestId];\n        assets = _claimableDepositRequest(depositRequest.fulfilledShares, depositRequest.depositAssets[controller]);\n    }\n\n    function _claimableDepositRequest(\n        uint256 fulfilledShares,\n        uint256 depositAssets\n    )\n        internal\n        pure\n        returns (uint256 assets)\n    {\n        return fulfilledShares != 0 ? depositAssets : 0;\n    }\n\n    /// @notice Requests a redemption of shares from the basket.\n    /// @param shares The amount of shares to redeem.\n    /// @param controller The address of the controller of the redeemed shares.\n    /// @param owner The address of the request owner.\n    function requestRedeem(uint256 shares, address controller, address owner) public returns (uint256 requestId) {\n        // Checks\n        if (shares == 0) {\n            revert Errors.ZeroAmount();\n        }\n        requestId = nextRedeemRequestId;\n        // If the user has a pending redeem request in the past, they must wait for it to be fulfilled before making a\n        // new one\n        uint256 userLastRedeemRequestId = lastRedeemRequestId[controller];\n        if (userLastRedeemRequestId != requestId) {\n            if (pendingRedeemRequest(userLastRedeemRequestId, controller) > 0) {\n                revert MustClaimOutstandingRedeem();\n            }\n        }\n        // If the user has a claimable redeem request, they must claim it before making a new one\n        if (claimableRedeemRequest(userLastRedeemRequestId, controller) > 0 || claimableFallbackShares(controller) > 0)\n        {\n            revert MustClaimOutstandingRedeem();\n        }\n        if (msg.sender != owner) {\n            if (!isOperator[owner][msg.sender]) {\n                _spendAllowance(owner, msg.sender, shares);\n            }\n        }\n        if (AssetRegistry(assetRegistry).hasPausedAssets(bitFlag)) {\n            revert AssetPaused();\n        }\n\n        // Effects\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];\n        // update total pending redemptions for the current requestId\n        redeemRequest.totalRedeemShares += shares;\n        // update controllers latest redeem request id\n        lastRedeemRequestId[controller] = requestId;\n        // update controllers balance of assets pending deposit\n        redeemRequest.redeemShares[controller] += shares;\n        _transfer(owner, address(this), shares);\n        emit RedeemRequest(controller, owner, requestId, msg.sender, shares);\n    }\n\n    /// @notice Returns the pending redeem request amount for a user.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller of the redemption request.\n    /// @return shares The amount of shares pending redemption.\n    function pendingRedeemRequest(uint256 requestId, address controller) public view returns (uint256 shares) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];\n        shares = redeemRequest.fulfilledAssets == 0 && !redeemRequest.fallbackTriggered\n            ? redeemRequest.redeemShares[controller]\n            : 0;\n    }\n\n    /// @notice Returns the amount of requested shares in Claimable state for the controller with the given requestId.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller of the redemption request.\n    /// @return shares The amount of shares claimable.\n    // solhint-disable-next-line no-unused-vars\n    function claimableRedeemRequest(uint256 requestId, address controller) public view returns (uint256 shares) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];\n        shares = _claimableRedeemRequest(redeemRequest.fulfilledAssets, redeemRequest.redeemShares[controller]);\n    }\n\n    function _claimableRedeemRequest(\n        uint256 fulfilledAssets,\n        uint256 redeemShares\n    )\n        internal\n        pure\n        returns (uint256 shares)\n    {\n        return fulfilledAssets != 0 ? redeemShares : 0;\n    }\n\n    /// @notice Fulfills all pending deposit requests. Only callable by the basket manager. Assets are held by the\n    /// basket manager. Locks in the rate at which users can claim their shares for deposited assets.\n    /// @param shares The amount of shares the deposit was fulfilled with.\n    function fulfillDeposit(uint256 shares) public {\n        // Checks\n        _onlyBasketManager();\n        // currentRequestId was advanced by 2 to prepare for rebalance\n        uint256 currentRequestId = nextDepositRequestId - 2;\n        DepositRequestStruct storage depositRequest = _depositRequests[currentRequestId];\n        uint256 assets = depositRequest.totalDepositAssets;\n        if (assets == 0) {\n            revert ZeroPendingDeposits();\n        }\n        if (shares == 0) {\n            revert CannotFulfillWithZeroShares();\n        }\n        if (depositRequest.fulfilledShares > 0) {\n            revert DepositRequestAlreadyFulfilled();\n        }\n        // Effects\n        depositRequest.fulfilledShares = shares;\n        emit DepositFulfilled(currentRequestId, assets, shares);\n        _mint(address(this), shares);\n        // Interactions\n        // transfer the assets to the basket manager\n        IERC20(asset()).safeTransfer(msg.sender, assets);\n    }\n\n    /// @notice Sets the new bitflag for the basket.\n    /// @dev This can only be called by the Basket Manager therefore we assume that the new bitflag is valid.\n    /// @param bitFlag_ The new bitflag.\n    function setBitFlag(uint256 bitFlag_) public {\n        _onlyBasketManager();\n        uint256 oldBitFlag = bitFlag;\n        bitFlag = bitFlag_;\n        emit BitFlagUpdated(oldBitFlag, bitFlag_);\n    }\n\n    /// @notice Called by the basket manager to advance the redeem epoch, preventing any further redeem requests for the\n    /// current epoch. Returns the total amount of assets pending deposit and shares pending redemption. This is called\n    /// at the first step of the rebalance process regardless of the presence of any pending deposits or redemptions.\n    /// When there are no pending deposits or redeems, the epoch is not advanced.\n    /// @dev This function also records the total amount of shares pending redemption for the current epoch.\n    /// @param feeBps The management fee in basis points to be harvested.\n    /// @param feeCollector The address that will receive the harvested management fee.\n    /// @return pendingDeposits The total amount of assets pending deposit.\n    /// @return sharesPendingRedemption The total amount of shares pending redemption.\n    function prepareForRebalance(\n        uint16 feeBps,\n        address feeCollector\n    )\n        external\n        returns (uint256 pendingDeposits, uint256 sharesPendingRedemption)\n    {\n        _onlyBasketManager();\n        uint256 nextDepositRequestId_ = nextDepositRequestId;\n        uint256 nextRedeemRequestId_ = nextRedeemRequestId;\n\n        // Check if previous deposit request has been fulfilled\n        DepositRequestStruct storage previousDepositRequest = _depositRequests[nextDepositRequestId_ - 2];\n        if (previousDepositRequest.totalDepositAssets > 0) {\n            if (previousDepositRequest.fulfilledShares == 0) {\n                revert PreviousDepositRequestNotFulfilled();\n            }\n        }\n\n        // Check if previous redeem request has been fulfilled or fallbacked\n        RedeemRequestStruct storage previousRedeemRequest = _redeemRequests[nextRedeemRequestId_ - 2];\n        if (previousRedeemRequest.totalRedeemShares > 0) {\n            if (previousRedeemRequest.fulfilledAssets == 0) {\n                if (!previousRedeemRequest.fallbackTriggered) {\n                    revert PreviousRedeemRequestNotFulfilled();\n                }\n            }\n        }\n\n        // Get current pending deposits\n        pendingDeposits = _depositRequests[nextDepositRequestId_].totalDepositAssets;\n        if (pendingDeposits > 0) {\n            nextDepositRequestId = nextDepositRequestId_ + 2;\n        }\n\n        sharesPendingRedemption = _redeemRequests[nextRedeemRequestId_].totalRedeemShares;\n        if (sharesPendingRedemption > 0) {\n            nextRedeemRequestId = nextRedeemRequestId_ + 2;\n        }\n\n        _harvestManagementFee(feeBps, feeCollector);\n    }\n\n    /// @notice Fulfills all pending redeem requests. Only callable by the basket manager. Burns the shares which are\n    /// pending redemption. Locks in the rate at which users can claim their assets for redeemed shares.\n    /// @dev prepareForRebalance must be called before this function.\n    /// @param assets The amount of assets the redemption was fulfilled with.\n    function fulfillRedeem(uint256 assets) public {\n        // Checks\n        _onlyBasketManager();\n        uint256 currentRequestId = nextRedeemRequestId - 2;\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[currentRequestId];\n        uint256 sharesPendingRedemption = redeemRequest.totalRedeemShares;\n        if (sharesPendingRedemption == 0) {\n            revert ZeroPendingRedeems();\n        }\n        if (assets == 0) {\n            revert CannotFulfillWithZeroAssets();\n        }\n        if (redeemRequest.fulfilledAssets > 0) {\n            revert RedeemRequestAlreadyFulfilled();\n        }\n        // Effects\n        redeemRequest.fulfilledAssets = assets;\n        emit RedeemFulfilled(currentRequestId, sharesPendingRedemption, assets);\n        _burn(address(this), sharesPendingRedemption);\n        // Interactions\n        // slither-disable-next-line arbitrary-send-erc20\n        IERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n    }\n\n    /// @notice Returns the total amount of assets pending deposit.\n    /// @return The total pending deposit amount.\n    function totalPendingDeposits() public view returns (uint256) {\n        return _depositRequests[nextDepositRequestId].totalDepositAssets;\n    }\n\n    /// @notice Returns the total number of shares pending redemption.\n    /// @return The total pending redeem amount.\n    function totalPendingRedemptions() public view returns (uint256) {\n        return _redeemRequests[nextRedeemRequestId].totalRedeemShares;\n    }\n\n    /// @notice Cancels a pending deposit request.\n    function cancelDepositRequest() public {\n        // Checks\n        uint256 nextDepositRequestId_ = nextDepositRequestId;\n        uint256 pendingDeposit = pendingDepositRequest(nextDepositRequestId_, msg.sender);\n        if (pendingDeposit == 0) {\n            revert ZeroPendingDeposits();\n        }\n        // Effects\n        DepositRequestStruct storage depositRequest = _depositRequests[nextDepositRequestId_];\n        depositRequest.depositAssets[msg.sender] = 0;\n        depositRequest.totalDepositAssets -= pendingDeposit;\n        // Interactions\n        IERC20(asset()).safeTransfer(msg.sender, pendingDeposit);\n    }\n\n    /// @notice Cancels a pending redeem request.\n    function cancelRedeemRequest() public {\n        // Checks\n        uint256 nextRedeemRequestId_ = nextRedeemRequestId;\n        uint256 pendingRedeem = pendingRedeemRequest(nextRedeemRequestId_, msg.sender);\n        if (pendingRedeem == 0) {\n            revert ZeroPendingRedeems();\n        }\n        // Effects\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[nextRedeemRequestId_];\n        redeemRequest.redeemShares[msg.sender] = 0;\n        redeemRequest.totalRedeemShares -= pendingRedeem;\n        _transfer(address(this), msg.sender, pendingRedeem);\n    }\n\n    /// @notice Sets a status for an operator's ability to act on behalf of a controller.\n    /// @param operator The address of the operator.\n    /// @param approved The status of the operator.\n    /// @return success True if the operator status was set, false otherwise.\n    function setOperator(address operator, bool approved) public returns (bool success) {\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n\n    /// @dev Reverts if the controller is not the caller or the operator of the caller.\n    function _onlySelfOrOperator(address controller) internal view {\n        if (msg.sender != controller) {\n            if (!isOperator[controller][msg.sender]) {\n                revert NotAuthorizedOperator();\n            }\n        }\n    }\n\n    /// @dev Reverts if the caller is not the Basket Manager.\n    function _onlyBasketManager() internal view {\n        if (basketManager != msg.sender) {\n            revert NotBasketManager();\n        }\n    }\n\n    /// @notice Returns the address of the share token as per ERC-7575.\n    /// @return shareTokenAddress The address of the share token.\n    /// @dev For non-multi asset vaults this should always return address(this).\n    function share() public view returns (address shareTokenAddress) {\n        shareTokenAddress = address(this);\n    }\n\n    /// FALLBACK REDEEM LOGIC ///\n\n    /// @notice In the event of a failed redemption fulfillment this function is called by the basket manager. Allows\n    /// users to claim their shares back for a redemption in the future and advances the redemption epoch.\n    function fallbackRedeemTrigger() public {\n        _onlyBasketManager();\n        // Check if the redeem is going on. If not, revert\n        uint256 currentRedeemRequestId = nextRedeemRequestId - 2;\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[currentRedeemRequestId];\n        if (redeemRequest.fallbackTriggered) {\n            revert RedeemRequestAlreadyFallbacked();\n        }\n        if (redeemRequest.fulfilledAssets > 0) {\n            revert RedeemRequestAlreadyFulfilled();\n        }\n        if (redeemRequest.totalRedeemShares == 0) {\n            revert ZeroPendingRedeems();\n        }\n        redeemRequest.fallbackTriggered = true;\n    }\n\n    /// @notice Claims shares given for a previous redemption request in the event a redemption fulfillment for a\n    /// given epoch fails.\n    /// @param receiver The address to receive the shares.\n    /// @param controller The address of the controller of the redemption request.\n    /// @return shares The amount of shares claimed.\n    function claimFallbackShares(address receiver, address controller) public returns (uint256 shares) {\n        // Checks\n        _onlySelfOrOperator(controller);\n        shares = claimableFallbackShares(controller);\n        if (shares == 0) {\n            revert ZeroClaimableFallbackShares();\n        }\n        // Effects\n        _redeemRequests[lastRedeemRequestId[controller]].redeemShares[controller] = 0;\n        _transfer(address(this), receiver, shares);\n    }\n\n    /// @notice Allows the caller to claim their own fallback shares.\n    /// @return shares The amount of shares claimed.\n    function claimFallbackShares() public returns (uint256 shares) {\n        return claimFallbackShares(msg.sender, msg.sender);\n    }\n\n    /// @notice Returns the amount of shares claimable for a given user in the event of a failed redemption\n    /// fulfillment.\n    /// @param controller The address of the controller.\n    /// @return shares The amount of shares claimable by the controller.\n    function claimableFallbackShares(address controller) public view returns (uint256 shares) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        if (redeemRequest.fallbackTriggered) {\n            return redeemRequest.redeemShares[controller];\n        }\n        return 0;\n    }\n\n    /// @notice Immediately redeems shares for all assets associated with this basket. This is synchronous and does not\n    /// require the rebalance process to be completed.\n    /// @param shares Number of shares to redeem.\n    /// @param to Address to receive the assets.\n    /// @param from Address to redeem shares from.\n    function proRataRedeem(uint256 shares, address to, address from) public {\n        // Effects\n        uint16 feeBps = BasketManager(basketManager).managementFee(address(this));\n        address feeCollector = BasketManager(basketManager).feeCollector();\n        _harvestManagementFee(feeBps, feeCollector);\n        if (msg.sender != from) {\n            _spendAllowance(from, msg.sender, shares);\n        }\n        uint256 totalSupplyBefore = totalSupply();\n        _burn(from, shares);\n        // Interactions\n        BasketManager(basketManager).proRataRedeem(totalSupplyBefore, shares, to);\n    }\n\n    // slither-disable-next-line timestamp\n    function _harvestManagementFee(uint16 feeBps, address feeCollector) internal {\n        // Checks\n        if (feeBps > _MAX_MANAGEMENT_FEE) {\n            revert InvalidManagementFee();\n        }\n        uint256 timeSinceLastHarvest = block.timestamp - lastManagementFeeHarvestTimestamp;\n\n        // Effects\n        lastManagementFeeHarvestTimestamp = uint40(block.timestamp);\n        if (feeBps != 0) {\n            if (timeSinceLastHarvest != 0) {\n                if (timeSinceLastHarvest != block.timestamp) {\n                    // remove shares held by the treasury or currently pending redemption from calculation\n                    uint256 currentTotalSupply = totalSupply() - balanceOf(feeCollector)\n                        - pendingRedeemRequest(lastRedeemRequestId[feeCollector], feeCollector);\n                    uint256 fee = FixedPointMathLib.fullMulDiv(\n                        currentTotalSupply, feeBps * timeSinceLastHarvest, _MANAGEMENT_FEE_DECIMALS * uint256(365 days)\n                    );\n                    if (fee != 0) {\n                        emit ManagementFeeHarvested(fee);\n                        _mint(feeCollector, fee);\n                        // Interactions\n                        FeeCollector(feeCollector).notifyHarvestFee(fee);\n                    }\n                }\n            }\n        }\n    }\n\n    /// ERC4626 OVERRIDDEN LOGIC ///\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @param assets The amount of assets previously requested for deposit.\n    /// @param receiver The address to receive the shares.\n    /// @param controller The address of the controller of the deposit request.\n    /// @return shares The amount of shares minted.\n    function deposit(uint256 assets, address receiver, address controller) public returns (uint256 shares) {\n        // Checks\n        if (assets == 0) {\n            revert Errors.ZeroAmount();\n        }\n        _onlySelfOrOperator(controller);\n        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];\n        uint256 fulfilledShares = depositRequest.fulfilledShares;\n        uint256 depositAssets = depositRequest.depositAssets[controller];\n        if (assets != _claimableDepositRequest(fulfilledShares, depositAssets)) {\n            revert MustClaimFullAmount();\n        }\n        shares = _maxMint(fulfilledShares, depositAssets, depositRequest.totalDepositAssets);\n        // Effects\n        _claimDeposit(depositRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @param assets The amount of assets to be claimed.\n    /// @param receiver The address to receive the assets.\n    /// @return shares The amount of shares previously requested for redemption.\n    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\n        return deposit(assets, receiver, msg.sender);\n    }\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @dev Deposit should be used in all instances instead.\n    /// @param shares The amount of shares to receive.\n    /// @param receiver The address to receive the shares.\n    /// @param controller The address of the controller of the deposit request.\n    /// @return assets The amount of assets previously requested for deposit.\n    function mint(uint256 shares, address receiver, address controller) public returns (uint256 assets) {\n        // Checks\n        _onlySelfOrOperator(controller);\n        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];\n        uint256 fulfilledShares = depositRequest.fulfilledShares;\n        uint256 depositAssets = depositRequest.depositAssets[controller];\n        if (shares != _maxMint(fulfilledShares, depositAssets, depositRequest.totalDepositAssets)) {\n            revert MustClaimFullAmount();\n        }\n        // Effects\n        assets = _claimableDepositRequest(fulfilledShares, depositAssets);\n        _claimDeposit(depositRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @param shares The amount of shares to receive.\n    /// @param receiver The address to receive the shares.\n    /// @return assets The amount of assets previously requested for deposit.\n    function mint(uint256 shares, address receiver) public override returns (uint256 assets) {\n        return mint(shares, receiver, msg.sender);\n    }\n\n    /// @notice Internal function to claim deposit for a given amount of assets and shares.\n    /// @param assets The amount of assets to claim.\n    /// @param shares The amount of shares to claim.\n    /// @param receiver The address of the receiver of the claimed assets.\n    /// @param controller The address of the controller of the deposit request.\n    function _claimDeposit(\n        DepositRequestStruct storage depositRequest,\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address controller\n    )\n        internal\n    {\n        // Effects\n        depositRequest.depositAssets[controller] = 0;\n        emit Deposit(controller, receiver, assets, shares);\n        // Interactions\n        _transfer(address(this), receiver, shares);\n    }\n\n    /// @notice Transfers a user's assets owed for a previously fulfillled redemption request.\n    /// @dev Redeem should be used in all instances instead.\n    /// @param assets The amount of assets to be claimed.\n    /// @param receiver The address to receive the assets.\n    /// @param controller The address of the controller of the redeem request.\n    /// @return shares The amount of shares previously requested for redemption.\n    function withdraw(uint256 assets, address receiver, address controller) public override returns (uint256 shares) {\n        // Checks\n        _onlySelfOrOperator(controller);\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        uint256 fulfilledAssets = redeemRequest.fulfilledAssets;\n        uint256 redeemShares = redeemRequest.redeemShares[controller];\n        if (assets != _maxWithdraw(fulfilledAssets, redeemShares, redeemRequest.totalRedeemShares)) {\n            revert MustClaimFullAmount();\n        }\n        shares = _claimableRedeemRequest(fulfilledAssets, redeemShares);\n        // Effects\n        _claimRedemption(redeemRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Transfers the receiver assets owed for a fulfilled redeem request.\n    /// @param shares The amount of shares to be claimed.\n    /// @param receiver The address to receive the assets.\n    /// @param controller The address of the controller of the redeem request.\n    /// @return assets The amount of assets previously requested for redemption.\n    function redeem(uint256 shares, address receiver, address controller) public override returns (uint256 assets) {\n        // Checks\n        if (shares == 0) {\n            revert Errors.ZeroAmount();\n        }\n        _onlySelfOrOperator(controller);\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        uint256 fulfilledAssets = redeemRequest.fulfilledAssets;\n        uint256 redeemShares = redeemRequest.redeemShares[controller];\n        if (shares != _claimableRedeemRequest(fulfilledAssets, redeemShares)) {\n            revert MustClaimFullAmount();\n        }\n        assets = _maxWithdraw(fulfilledAssets, redeemShares, redeemRequest.totalRedeemShares);\n        // Effects & Interactions\n        _claimRedemption(redeemRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Internal function to claim redemption for a given amount of assets and shares.\n    /// @param assets The amount of assets to claim.\n    /// @param shares The amount of shares to claim.\n    /// @param receiver The address of the receiver of the claimed assets.\n    /// @param controller The address of the controller of the redemption request.\n    function _claimRedemption(\n        RedeemRequestStruct storage redeemRequest,\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address controller\n    )\n        internal\n    {\n        // Effects\n        redeemRequest.redeemShares[controller] = 0;\n        emit Withdraw(msg.sender, receiver, controller, assets, shares);\n        // Interactions\n        IERC20(asset()).safeTransfer(receiver, assets);\n    }\n\n    /// @notice Returns an controller's amount of assets fulfilled for redemption.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of assets that can be withdrawn.\n    function maxWithdraw(address controller) public view override returns (uint256) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        return _maxWithdraw(\n            redeemRequest.fulfilledAssets, redeemRequest.redeemShares[controller], redeemRequest.totalRedeemShares\n        );\n    }\n\n    function _maxWithdraw(\n        uint256 fulfilledAssets,\n        uint256 redeemShares,\n        uint256 totalRedeemShares\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            totalRedeemShares == 0 ? 0 : FixedPointMathLib.fullMulDiv(fulfilledAssets, redeemShares, totalRedeemShares);\n    }\n\n    /// @notice Returns an controller's amount of shares fulfilled for redemption.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of shares that can be redeemed.\n    function maxRedeem(address controller) public view override returns (uint256) {\n        return claimableRedeemRequest(lastRedeemRequestId[controller], controller);\n    }\n\n    /// @notice Returns an controller's amount of assets fulfilled for deposit.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of assets that can be deposited.\n    function maxDeposit(address controller) public view override returns (uint256) {\n        return claimableDepositRequest(lastDepositRequestId[controller], controller);\n    }\n\n    /// @notice Returns an controller's amount of shares fulfilled for deposit.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of shares that can be minted.\n    function maxMint(address controller) public view override returns (uint256) {\n        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];\n        return _maxMint(\n            depositRequest.fulfilledShares, depositRequest.depositAssets[controller], depositRequest.totalDepositAssets\n        );\n    }\n\n    function _maxMint(\n        uint256 fulfilledShares,\n        uint256 depositAssets,\n        uint256 totalDepositAssets\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return totalDepositAssets == 0\n            ? 0\n            : FixedPointMathLib.fullMulDiv(fulfilledShares, depositAssets, totalDepositAssets);\n    }\n\n    // solhint-disable custom-errors,gas-custom-errors,reason-string\n    // Preview functions always revert for async flows\n    function previewDeposit(uint256) public pure override returns (uint256) {\n        revert();\n    }\n\n    // Preview functions always revert for async flows\n    function previewMint(uint256) public pure override returns (uint256) {\n        revert();\n    }\n\n    // Preview functions always revert for async flows\n    function previewWithdraw(uint256) public pure override returns (uint256) {\n        revert();\n    }\n\n    // Preview functions always revert for async flows\n    function previewRedeem(uint256) public pure override returns (uint256) {\n        revert();\n    }\n    // solhint-enable custom-errors,gas-custom-errors,reason-string\n\n    /// @notice Returns true if the redemption request's fallback has been triggered.\n    /// @param requestId The id of the request.\n    /// @return True if the fallback has been triggered, false otherwise.\n    function fallbackTriggered(uint256 requestId) public view returns (bool) {\n        return _redeemRequests[requestId].fallbackTriggered;\n    }\n\n    //// ERC165 OVERRIDDEN LOGIC ///\n    /// @notice Checks if the contract supports the given interface.\n    /// @param interfaceID The interface ID.\n    /// @return True if the contract supports the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == 0x2f0a18c5 || interfaceID == 0xf815c03d\n            || interfaceID == type(IERC7540Operator).interfaceId || interfaceID == type(IERC7540Deposit).interfaceId\n            || interfaceID == type(IERC7540Redeem).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /// @dev Override to call the ERC20PluginsUpgradeable's _update function.\n    function _update(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override(ERC20PluginsUpgradeable, ERC20Upgradeable)\n    {\n        ERC20PluginsUpgradeable._update(from, to, amount);\n    }\n\n    /// @dev Override to call the ERC20PluginsUpgradeable's balanceOf function.\n    /// See {IERC20-balanceOf}.\n    function balanceOf(address account)\n        public\n        view\n        override(ERC20PluginsUpgradeable, ERC20Upgradeable, IERC20)\n        returns (uint256)\n    {\n        return ERC20PluginsUpgradeable.balanceOf(account);\n    }\n\n    /// @dev Override to use ERC4626's decimals function.\n    /// See {IERC20Metadata-decimals}.\n    function decimals() public view override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8) {\n        return ERC4626Upgradeable.decimals();\n    }\n}\n"
    }
}