{
    "vfp_id": "vfp_00119",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding in Debt Shares Calculation Can Mint Unbacked Tokens",
            "description": "This vulnerability arises from the rounding down of debt shares in the TroveManager._updateBatchShares() function, which allows an attacker to manipulate the debt-to-shares ratio in a batch. By repeatedly donating small amounts of debt and opening/closing troves, an attacker can inflate the ratio to a point where new troves receive zero debt shares for non-zero debt, enabling them to mint unbacked BOLD tokens. The root cause is improper handling of integer division and lack of safeguards against ratio manipulation. An attacker could exploit this by looping through donation and trove operations to inflate the ratio, then mint large amounts of unbacked tokens, leading to protocol insolvency. The impact includes loss of trust, financial loss, and potential collapse of the system's monetary model.\n",
            "severity": "Critical",
            "location": [
                "TroveManager.sol::_updateBatchShares",
                "TroveManager.sol::_requireBelowMaxSharesRatio"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Zappers Can Lose User Funds",
            "description": "When users repay debt via zapper functions, if the repayment would bring the trove below MIN_DEBT, only a partial amount is repaid, and the remainder stays locked in the zapper contract. The cause is the logic in _adjustTrove that silently reduces the repayment amount without refunding excess. An attacker can front-run a large repayment by redeeming the target trove down to just above MIN_DEBT, causing nearly the entire repayment amount to be trapped. The impact is significant loss of user funds, especially in large repayments, and creates an attack vector where malicious actors can profit by backrunning and extracting stuck funds. This undermines user trust and fund safety.\n",
            "severity": "High",
            "location": [
                "BorrowerOperations.sol::_adjustTrove",
                "Zapper contracts::adjust",
                "Zapper contracts::repay"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unredeemable Troves Can Pay Minimum Interest Rate",
            "description": "Troves with debt below MIN_DEBT are marked as unredeemable (zombie troves) and excluded from redemption lists, removing the risk of redemption and thus the incentive to pay higher interest rates. An attacker can create many such troves to pay only the minimum interest, gaining an unfair economic advantage. The cause is the design decision to exclude small troves from redemption lists. While mitigated by gas and capital costs, the strategy could still be profitable under certain conditions. The partial fix ensures zombie troves are redeemed first during redemptions, but an edge case remains where liquidated troves with zero debt can still become unredeemable and pay minimal interest. The impact is economic inefficiency and potential abuse of the interest model.\n",
            "severity": "Medium",
            "location": [
                "TroveManager.sol",
                "RedemptionLogic.sol"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        }
    ],
    "affected_files": {
        "BorrowerOperations.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/AddRemoveManagers.sol\";\nimport \"./Types/LatestTroveData.sol\";\nimport \"./Types/LatestBatchData.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract BorrowerOperations is LiquityBase, AddRemoveManagers, IBorrowerOperations {\n    using SafeERC20 for IERC20;\n\n    // --- Connected contract declarations ---\n\n    IERC20 internal immutable collToken;\n    ITroveManager internal troveManager;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n    bool public hasBeenShutDown;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    /*\n    * Mapping from TroveId to individual delegate for interest rate setting.\n    *\n    * This address then has the ability to update the borrower’s interest rate, but not change its debt or collateral.\n    * Useful for instance for cold/hot wallet setups.\n    */\n    mapping(uint256 => InterestIndividualDelegate) private interestIndividualDelegateOf;\n\n    /*\n     * Mapping from TroveId to granted address for interest rate setting (batch manager).\n     *\n     * Batch managers set the interest rate for every Trove in the batch. The interest rate is the same for all Troves in the batch.\n     */\n    mapping(uint256 => address) public interestBatchManagerOf;\n\n    // List of registered Interest Batch Managers\n    mapping(address => InterestBatchManager) private interestBatchManagers;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct OpenTroveVars {\n        ITroveManager troveManager;\n        uint256 troveId;\n        TroveChange change;\n        LatestBatchData batch;\n    }\n\n    struct LocalVariables_openTrove {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IBoldToken boldToken;\n        uint256 troveId;\n        uint256 price;\n        uint256 avgInterestRate;\n        uint256 entireDebt;\n        uint256 ICR;\n        uint256 newTCR;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_adjustTrove {\n        IActivePool activePool;\n        IBoldToken boldToken;\n        LatestTroveData trove;\n        uint256 price;\n        bool isBelowCriticalThreshold;\n        uint256 newICR;\n        uint256 newDebt;\n        uint256 newColl;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_setInterestBatchManager {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ISortedTroves sortedTroves;\n        address oldBatchManager;\n        LatestTroveData trove;\n        LatestBatchData oldBatch;\n        LatestBatchData newBatch;\n    }\n\n    struct LocalVariables_removeFromBatch {\n        ITroveManager troveManager;\n        ISortedTroves sortedTroves;\n        address batchManager;\n        LatestTroveData trove;\n        LatestBatchData batch;\n        uint256 newBatchDebt;\n    }\n\n    error IsShutDown();\n    error NotShutDown();\n    error TCRNotBelowSCR();\n    error ZeroAdjustment();\n    error NotOwnerNorInterestManager();\n    error TroveInBatch();\n    error TroveNotInBatch();\n    error InterestNotInRange();\n    error BatchInterestRateChangePeriodNotPassed();\n    error TroveNotOpen();\n    error TroveNotActive();\n    error TroveNotUnredeemable();\n    error TroveOpen();\n    error UpfrontFeeTooHigh();\n    error BelowCriticalThreshold();\n    error BorrowingNotPermittedBelowCT();\n    error ICRBelowMCR();\n    error RepaymentNotMatchingCollWithdrawal();\n    error TCRBelowCCR();\n    error DebtBelowMin();\n    error CollWithdrawalTooHigh();\n    error NotEnoughBoldBalance();\n    error InterestRateTooLow();\n    error InterestRateTooHigh();\n    error InterestRateNotNew();\n    error InvalidInterestBatchManager();\n    error BatchManagerExists();\n    error BatchManagerNotNew();\n    error NewFeeNotLower();\n    error CallerNotTroveManager();\n    error CallerNotPriceFeed();\n    error MinGeMax();\n    error AnnualManagementFeeTooHigh();\n    error MinInterestRateChangePeriodTooLow();\n    error NewOracleFailureDetected();\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n\n    event ShutDown(uint256 _tcr);\n    event ShutDownFromOracleFailure(address _oracleAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) AddRemoveManagers(_addressesRegistry) LiquityBase(_addressesRegistry) {\n        // This makes impossible to open a trove with zero withdrawn Bold\n        assert(MIN_DEBT > 0);\n\n        collToken = _addressesRegistry.collToken();\n\n        WETH = _addressesRegistry.WETH();\n\n        CCR = _addressesRegistry.CCR();\n        SCR = _addressesRegistry.SCR();\n        MCR = _addressesRegistry.MCR();\n\n        troveManager = _addressesRegistry.troveManager();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit BoldTokenAddressChanged(address(boldToken));\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(address(activePool), type(uint256).max);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external override returns (uint256) {\n        _requireValidAnnualInterestRate(_annualInterestRate);\n\n        OpenTroveVars memory vars;\n\n        vars.troveId = _openTrove(\n            _owner,\n            _ownerIndex,\n            _collAmount,\n            _boldAmount,\n            _annualInterestRate,\n            address(0),\n            0,\n            0,\n            _maxUpfrontFee,\n            _addManager,\n            _removeManager,\n            _receiver,\n            vars.change\n        );\n\n        // Set the stored Trove properties and mint the NFT\n        troveManager.onOpenTrove(_owner, vars.troveId, vars.change, _annualInterestRate);\n\n        sortedTroves.insert(vars.troveId, _annualInterestRate, _upperHint, _lowerHint);\n\n        return vars.troveId;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        override\n        returns (uint256)\n    {\n        _requireValidInterestBatchManager(_params.interestBatchManager);\n\n        OpenTroveVars memory vars;\n        vars.troveManager = troveManager;\n\n        vars.batch = vars.troveManager.getLatestBatchData(_params.interestBatchManager);\n\n        // We set old weighted values here, as it’s only necessary for batches, so we don’t need to pass them to _openTrove func\n        vars.change.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.change.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.change.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.troveId = _openTrove(\n            _params.owner,\n            _params.ownerIndex,\n            _params.collAmount,\n            _params.boldAmount,\n            vars.batch.annualInterestRate,\n            _params.interestBatchManager,\n            vars.batch.entireDebtWithoutRedistribution,\n            vars.batch.annualManagementFee,\n            _params.maxUpfrontFee,\n            _params.addManager,\n            _params.removeManager,\n            _params.receiver,\n            vars.change\n        );\n\n        interestBatchManagerOf[vars.troveId] = _params.interestBatchManager;\n\n        // Set the stored Trove properties and mint the NFT\n        vars.troveManager.onOpenTroveAndJoinBatch(\n            _params.owner,\n            vars.troveId,\n            vars.change,\n            _params.interestBatchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution\n        );\n\n        sortedTroves.insertIntoBatch(\n            vars.troveId,\n            BatchId.wrap(_params.interestBatchManager),\n            vars.batch.annualInterestRate,\n            _params.upperHint,\n            _params.lowerHint\n        );\n\n        return vars.troveId;\n    }\n\n    function _openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _annualInterestRate,\n        address _interestBatchManager,\n        uint256 _batchEntireDebt,\n        uint256 _batchManagementAnnualFee,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver,\n        TroveChange memory _change\n    ) internal returns (uint256) {\n        _requireIsNotShutDown();\n\n        LocalVariables_openTrove memory vars;\n\n        // TODO: stack too deep not allowing to reuse troveManager from outer functions\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n\n        // --- Checks ---\n\n        _requireNotBelowCriticalThreshold(vars.price);\n\n        vars.troveId = uint256(keccak256(abi.encode(_owner, _ownerIndex)));\n        _requireTroveIsNotOpen(vars.troveManager, vars.troveId);\n\n        _change.collIncrease = _collAmount;\n        _change.debtIncrease = _boldAmount;\n\n        // For simplicity, we ignore the fee when calculating the approx. interest rate\n        _change.newWeightedRecordedDebt = (_batchEntireDebt + _change.debtIncrease) * _annualInterestRate;\n\n        vars.avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_change);\n        _change.upfrontFee = _calcUpfrontFee(_change.debtIncrease, vars.avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_change.upfrontFee, _maxUpfrontFee);\n\n        vars.entireDebt = _change.debtIncrease + _change.upfrontFee;\n        _requireAtLeastMinDebt(vars.entireDebt);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee, and the batch fee if needed\n        if (_interestBatchManager == address(0)) {\n            _change.newWeightedRecordedDebt = vars.entireDebt * _annualInterestRate;\n        } else {\n            // old values have been set outside, before calling this function\n            _change.newWeightedRecordedDebt = (_batchEntireDebt + vars.entireDebt) * _annualInterestRate;\n            _change.newWeightedRecordedBatchManagementFee =\n                (_batchEntireDebt + vars.entireDebt) * _batchManagementAnnualFee;\n        }\n\n        // ICR is based on the composite debt, i.e. the requested Bold amount + Bold gas comp + upfront fee.\n        vars.ICR = LiquityMath._computeCR(_collAmount, vars.entireDebt, vars.price);\n        _requireICRisAboveMCR(vars.ICR);\n\n        vars.newTCR = _getNewTCRFromTroveChange(_change, vars.price);\n        _requireNewTCRisAboveCCR(vars.newTCR);\n\n        // --- Effects & interactions ---\n\n        // Set add/remove managers\n        // TODO: We can restore the condition for non-zero managers if we end up ipmlementing at least one of:\n        // - wipe them out on closing troves\n        // - do not reuse troveIds\n        // for now it is safer to make sure they are set\n        _setAddManager(vars.troveId, _addManager);\n        _setRemoveManagerAndReceiver(vars.troveId, _removeManager, _receiver);\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_change, _interestBatchManager);\n\n        // Pull coll tokens from sender and move them to the Active Pool\n        _pullCollAndSendToActivePool(vars.activePool, _collAmount);\n\n        // Mint the requested _boldAmount to the borrower and mint the gas comp to the GasPool\n        vars.boldToken.mint(msg.sender, _boldAmount);\n        WETH.transferFrom(msg.sender, gasPoolAddress, ETH_GAS_COMPENSATION);\n\n        return vars.troveId;\n    }\n\n    // Send collateral to a trove\n    function addColl(uint256 _troveId, uint256 _collAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collIncrease = _collAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(uint256 _troveId, uint256 _collWithdrawal) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = _collWithdrawal;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw Bold tokens from a trove: mint new Bold tokens to the owner, and increase the trove's debt accordingly\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtIncrease = _boldAmount;\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    // Repay Bold tokens to a Trove: Burn the repaid Bold tokens, and reduce the trove's debt accordingly\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtDecrease = _boldAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    function _initTroveChange(\n        TroveChange memory _troveChange,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease\n    ) internal pure {\n        if (_isCollIncrease) {\n            _troveChange.collIncrease = _collChange;\n        } else {\n            _troveChange.collDecrease = _collChange;\n        }\n\n        if (_isDebtIncrease) {\n            _troveChange.debtIncrease = _boldChange;\n        } else {\n            _troveChange.debtDecrease = _boldChange;\n        }\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    function adjustUnredeemableTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsUnredeemable(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n\n        troveManagerCached.setTroveStatusToActive(_troveId);\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        uint256 batchAnnualInteresRate;\n        if (batchManager != address(0)) {\n            LatestBatchData memory batch = troveManagerCached.getLatestBatchData(batchManager);\n            batchAnnualInteresRate = batch.annualInterestRate;\n        }\n        _reInsertIntoSortedTroves(\n            _troveId,\n            troveManagerCached.getTroveAnnualInterestRate(_troveId),\n            _upperHint,\n            _lowerHint,\n            batchManager,\n            batchAnnualInteresRate\n        );\n    }\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        _requireIsNotInBatch(_troveId);\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrInterestManager(_troveId, owner);\n        _requireInterestRateInDelegateRange(_troveId, _newAnnualInterestRate);\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireAnnualInterestRateIsNew(trove.annualInterestRate, _newAnnualInterestRate);\n\n        uint256 newDebt = trove.entireDebt;\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            trove.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            newDebt = _applyUpfrontFee(trove.entireColl, newDebt, troveChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n\n        activePool.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        sortedTroves.reInsert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        troveManagerCached.onAdjustTroveInterestRate(\n            _troveId, trove.entireColl, newDebt, _newAnnualInterestRate, troveChange\n        );\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    */\n    function _adjustTrove(\n        ITroveManager _troveManager,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_adjustTrove memory vars;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n        vars.isBelowCriticalThreshold = _checkBelowCriticalThreshold(vars.price, CCR);\n\n        // --- Checks ---\n\n        _requireTroveIsOpen(_troveManager, _troveId);\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = owner; // If it’s a withdrawal, and manager has receive privilege, manager would be the receiver\n\n        if (_troveChange.collDecrease > 0 || _troveChange.debtIncrease > 0) {\n            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        }\n\n        if (_troveChange.collIncrease > 0 || _troveChange.debtDecrease > 0) {\n            _requireSenderIsOwnerOrAddManager(_troveId, owner);\n        }\n\n        vars.trove = _troveManager.getLatestTroveData(_troveId);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Bold\n        if (_troveChange.debtDecrease > 0) {\n            uint256 maxRepayment = vars.trove.entireDebt > MIN_DEBT ? vars.trove.entireDebt - MIN_DEBT : 0;\n            if (_troveChange.debtDecrease > maxRepayment) {\n                _troveChange.debtDecrease = maxRepayment;\n            }\n            _requireSufficientBoldBalance(vars.boldToken, msg.sender, _troveChange.debtDecrease);\n        }\n\n        _requireNonZeroAdjustment(_troveChange);\n\n        // When the adjustment is a collateral withdrawal, check that it's no more than the Trove's entire collateral\n        if (_troveChange.collDecrease > 0) {\n            _requireValidCollWithdrawal(vars.trove.entireColl, _troveChange.collDecrease);\n        }\n\n        vars.newColl = vars.trove.entireColl + _troveChange.collIncrease - _troveChange.collDecrease;\n        vars.newDebt = vars.trove.entireDebt + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        bool isTroveInBatch = batchManager != address(0);\n        LatestBatchData memory batch;\n        uint256 batchFutureDebt;\n        if (isTroveInBatch) {\n            batch = _troveManager.getLatestBatchData(batchManager);\n\n            batchFutureDebt = batch.entireDebtWithoutRedistribution + vars.trove.redistBoldDebtGain\n                + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n            // TODO: comment\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            _troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            _troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.oldWeightedRecordedDebt = vars.trove.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n        }\n\n        // Pay an upfront fee on debt increases\n        if (_troveChange.debtIncrease > 0) {\n            uint256 avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n            _troveChange.upfrontFee = _calcUpfrontFee(_troveChange.debtIncrease, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n            vars.newDebt += _troveChange.upfrontFee;\n            if (isTroveInBatch) {\n                batchFutureDebt += _troveChange.upfrontFee;\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n                _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n            } else {\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n            }\n        }\n\n        // Make sure the Trove doesn't end up unredeemable\n        // Now the max repayment is capped to stay above MIN_DEBT, so this only applies to adjustUnredeemableTrove\n        _requireAtLeastMinDebt(vars.newDebt);\n\n        vars.newICR = LiquityMath._computeCR(vars.newColl, vars.newDebt, vars.price);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(_troveChange, vars);\n\n        // --- Effects and interactions ---\n\n        if (isTroveInBatch) {\n            _troveManager.onAdjustTroveInsideBatch(\n                _troveId,\n                vars.newColl,\n                _troveChange,\n                batchManager,\n                batch.entireCollWithoutRedistribution,\n                batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _troveManager.onAdjustTrove(_troveId, vars.newColl, vars.newDebt, _troveChange);\n        }\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_troveChange, batchManager);\n        _moveTokensFromAdjustment(receiver, _troveChange, vars.boldToken, vars.activePool);\n    }\n\n    function closeTrove(uint256 _troveId) external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IBoldToken boldTokenCached = boldToken;\n\n        // --- Checks ---\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n\n        // The borrower must repay their entire debt including accrued interest, batch fee and redist. gains\n        _requireSufficientBoldBalance(boldTokenCached, msg.sender, trove.entireDebt);\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n        if (batchManager != address(0)) {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            uint256 batchFutureDebt =\n                batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain);\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            // troveChange.newWeightedRecordedDebt = 0;\n        }\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n        uint256 newTCR = _getNewTCRFromTroveChange(troveChange, price);\n        if (!hasBeenShutDown) _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.onCloseTrove(\n            _troveId,\n            troveChange,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution\n        );\n\n        // If trove is in batch\n        if (batchManager != address(0)) {\n            // Unlink here in BorrowerOperations\n            interestBatchManagerOf[_troveId] = address(0);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, batchManager);\n\n        // Return ETH gas compensation\n        WETH.transferFrom(gasPoolAddress, receiver, ETH_GAS_COMPENSATION);\n        // Burn the remainder of the Trove's entire debt from the user\n        boldTokenCached.burn(msg.sender, trove.entireDebt);\n\n        // Send the collateral back to the user\n        activePoolCached.sendColl(receiver, trove.entireColl);\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) public {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        TroveChange memory change;\n        change.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        change.appliedRedistCollGain = trove.redistCollGain;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n\n        if (batchManager == address(0)) {\n            change.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            change.newWeightedRecordedDebt = trove.entireDebt * trove.annualInterestRate;\n        } else {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            change.batchAccruedManagementFee = batch.accruedManagementFee;\n            change.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            change.newWeightedRecordedDebt =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualInterestRate;\n            change.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            change.newWeightedRecordedBatchManagementFee =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualManagementFee;\n        }\n\n        troveManagerCached.onApplyTroveInterest(\n            _troveId,\n            trove.entireColl,\n            trove.entireDebt,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            change\n        );\n        activePool.mintAggInterestAndAccountForTroveChange(change, batchManager);\n\n        // If the trove was unredeemable, and now it’s not anymore, put it back in the list\n        if (_checkTroveIsUnredeemable(troveManagerCached, _troveId) && trove.entireDebt >= MIN_DEBT) {\n            troveManagerCached.setTroveStatusToActive(_troveId);\n            _reInsertIntoSortedTroves(\n                _troveId, trove.annualInterestRate, _upperHint, _lowerHint, batchManager, batch.annualInterestRate\n            );\n        }\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory)\n    {\n        return interestIndividualDelegateOf[_troveId];\n    }\n\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireCallerIsBorrower(_troveId);\n        interestIndividualDelegateOf[_troveId] =\n            InterestIndividualDelegate(_delegate, _minInterestRate, _maxInterestRate);\n        // Can’t have both individual delegation and batch manager\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            removeFromBatch(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);\n        }\n    }\n\n    function removeInterestIndividualDelegate(uint256 _troveId) external {\n        _requireCallerIsBorrower(_troveId);\n        delete interestIndividualDelegateOf[_troveId];\n    }\n\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory) {\n        return interestBatchManagers[_account];\n    }\n\n    function registerBatchManager(\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        uint128 _currentInterestRate,\n        uint128 _annualManagementFee,\n        uint128 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireNonExistentInterestBatchManager(msg.sender);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        if (_minInterestRate >= _maxInterestRate) revert MinGeMax();\n        _requireInterestRateInRange(_currentInterestRate, _minInterestRate, _maxInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_currentInterestRate);\n        if (_annualManagementFee > MAX_ANNUAL_BATCH_MANAGEMENT_FEE) revert AnnualManagementFeeTooHigh();\n        if (_minInterestRateChangePeriod < MIN_INTEREST_RATE_CHANGE_PERIOD) revert MinInterestRateChangePeriodTooLow();\n\n        interestBatchManagers[msg.sender] =\n            InterestBatchManager(_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n\n        troveManager.onRegisterBatchManager(msg.sender, _currentInterestRate, _annualManagementFee);\n    }\n\n    function lowerBatchManagementFee(uint256 _newAnnualManagementFee) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n\n        ITroveManager troveManagerCached = troveManager;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        if (_newAnnualManagementFee >= batch.annualManagementFee) {\n            revert NewFeeNotLower();\n        }\n\n        // Lower batch fee on TM\n        troveManagerCached.onLowerBatchManagerAnnualFee(\n            msg.sender,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            _newAnnualManagementFee\n        );\n\n        // active pool mint\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * _newAnnualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n    }\n\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n        _requireInterestRateInBatchManagerRange(msg.sender, _newAnnualInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        _requireInterestRateChangePeriodPassed(msg.sender, uint256(batch.lastInterestRateAdjTime));\n\n        uint256 newDebt = batch.entireDebtWithoutRedistribution;\n\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            uint256 price = _requireOraclesLive();\n\n            uint256 avgInterestRate = activePoolCached.getNewApproxAvgInterestRateFromTroveChange(batchChange);\n            batchChange.upfrontFee = _calcUpfrontFee(newDebt, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(batchChange.upfrontFee, _maxUpfrontFee);\n\n            newDebt += batchChange.upfrontFee;\n\n            // Recalculate the batch's weighted terms, now taking into account the upfront fee\n            batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n            batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n            // Disallow a premature adjustment if it would result in TCR < CCR\n            // (which includes the case when TCR is already below CCR before the adjustment).\n            uint256 newTCR = _getNewTCRFromTroveChange(batchChange, price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n\n        // Check batch is not empty, and then reinsert in sorted list\n        if (!sortedTroves.isEmptyBatch(BatchId.wrap(msg.sender))) {\n            sortedTroves.reInsertBatch(BatchId.wrap(msg.sender), _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        troveManagerCached.onSetBatchManagerAnnualInterestRate(\n            msg.sender, batch.entireCollWithoutRedistribution, newDebt, _newAnnualInterestRate\n        );\n    }\n\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n        LocalVariables_setInterestBatchManager memory vars;\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidInterestBatchManager(_newBatchManager);\n        _requireIsNotInBatch(_troveId);\n\n        interestBatchManagerOf[_troveId] = _newBatchManager;\n        // Can’t have both individual delegation and batch manager\n        if (interestIndividualDelegateOf[_troveId].account != address(0)) delete interestIndividualDelegateOf[_troveId];\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.newBatch = vars.troveManager.getLatestBatchData(_newBatchManager);\n\n        TroveChange memory newBatchTroveChange;\n        newBatchTroveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        newBatchTroveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        newBatchTroveChange.batchAccruedManagementFee = vars.newBatch.accruedManagementFee;\n        newBatchTroveChange.oldWeightedRecordedDebt =\n            vars.newBatch.weightedRecordedDebt + vars.trove.weightedRecordedDebt;\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // We may check the old rate to see if it’s different than the new one, but then we should check the\n        // last interest adjustment times to avoid gaming. So we decided to keep it simple and account it always\n        // as a change. It’s probably not so common to join a batch with the exact same interest rate.\n        // Apply upfront fee on premature adjustments\n        if (block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, newBatchTroveChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // Add batch fees\n        newBatchTroveChange.oldWeightedRecordedBatchManagementFee = vars.newBatch.weightedRecordedBatchManagementFee;\n        newBatchTroveChange.newWeightedRecordedBatchManagementFee =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualManagementFee;\n        vars.activePool.mintAggInterestAndAccountForTroveChange(newBatchTroveChange, _newBatchManager);\n\n        vars.troveManager.onSetInterestBatchManager(\n            ITroveManager.OnSetInterestBatchManagerParams({\n                troveId: _troveId,\n                troveColl: vars.trove.entireColl,\n                troveDebt: vars.trove.entireDebt,\n                troveChange: newBatchTroveChange,\n                newBatchAddress: _newBatchManager,\n                newBatchColl: vars.newBatch.entireCollWithoutRedistribution,\n                newBatchDebt: vars.newBatch.entireDebtWithoutRedistribution\n            })\n        );\n\n        vars.sortedTroves.remove(_troveId);\n        vars.sortedTroves.insertIntoBatch(\n            _troveId, BatchId.wrap(_newBatchManager), vars.newBatch.annualInterestRate, _upperHint, _lowerHint\n        );\n    }\n\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n\n        LocalVariables_removeFromBatch memory vars;\n        vars.troveManager = troveManager;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        vars.batchManager = _requireIsInBatch(_troveId);\n        delete interestBatchManagerOf[_troveId];\n\n        // Remove trove from Batch in SortedTroves\n        vars.sortedTroves.removeFromBatch(_troveId);\n        // Reinsert as single trove\n        vars.sortedTroves.insert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.batch = vars.troveManager.getLatestBatchData(vars.batchManager);\n\n        TroveChange memory batchChange;\n        batchChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        batchChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        batchChange.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt\n            + (vars.trove.entireDebt - vars.trove.redistBoldDebtGain) * vars.batch.annualInterestRate;\n        batchChange.newWeightedRecordedDebt = vars.batch.entireDebtWithoutRedistribution * vars.batch.annualInterestRate\n            + vars.trove.entireDebt * _newAnnualInterestRate;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            vars.batch.annualInterestRate != _newAnnualInterestRate\n            && block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, batchChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        batchChange.newWeightedRecordedDebt = vars.batch.entireDebtWithoutRedistribution * vars.batch.annualInterestRate\n            + vars.trove.entireDebt * _newAnnualInterestRate;\n        // Add batch fees\n        batchChange.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee\n            + (vars.trove.entireDebt - batchChange.upfrontFee - vars.trove.redistBoldDebtGain)\n                * vars.batch.annualManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            vars.batch.entireDebtWithoutRedistribution * vars.batch.annualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, vars.batchManager);\n\n        vars.troveManager.onRemoveFromBatch(\n            _troveId,\n            vars.trove.entireColl,\n            vars.trove.entireDebt,\n            batchChange,\n            vars.batchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution,\n            _newAnnualInterestRate\n        );\n    }\n\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        address oldBatchManager = _requireIsInBatch(_troveId);\n        _requireNewInterestBatchManager(oldBatchManager, _newBatchManager);\n\n        LatestBatchData memory oldBatch = troveManager.getLatestBatchData(oldBatchManager);\n\n        removeFromBatch(_troveId, oldBatch.annualInterestRate, _removeUpperHint, _removeLowerHint, 0);\n        setInterestBatchManager(_troveId, _newBatchManager, _addUpperHint, _addLowerHint, _maxUpfrontFee);\n    }\n\n    function _applyUpfrontFee(\n        uint256 _troveEntireColl,\n        uint256 _troveEntireDebt,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal returns (uint256) {\n        uint256 price = _requireOraclesLive();\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n        _troveChange.upfrontFee = _calcUpfrontFee(_troveEntireDebt, avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n        _troveEntireDebt += _troveChange.upfrontFee;\n\n        // ICR is based on the composite debt, i.e. the requested Bold amount + Bold gas comp + upfront fee.\n        uint256 newICR = LiquityMath._computeCR(_troveEntireColl, _troveEntireDebt, price);\n        _requireICRisAboveMCR(newICR);\n\n        // Disallow a premature adjustment if it would result in TCR < CCR\n        // (which includes the case when TCR is already below CCR before the adjustment).\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        return _troveEntireDebt;\n    }\n\n    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {\n        return _calcInterest(_debt * _avgInterestRate, UPFRONT_INTEREST_PERIOD);\n    }\n\n    // Call from TM to clean state here\n    function onLiquidateTrove(uint256 _troveId) external {\n        _requireCallerIsTroveManager();\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function _wipeTroveMappings(uint256 _troveId) internal {\n        delete interestIndividualDelegateOf[_troveId];\n        delete interestBatchManagerOf[_troveId];\n        delete addManagerOf[_troveId];\n        delete removeManagerReceiverOf[_troveId];\n    }\n\n    /**\n     * Claim remaining collateral from a liquidation with ICR exceeding the liquidation penalty\n     */\n    function claimCollateral() external override {\n        // send coll from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    function shutdown() external {\n        if (hasBeenShutDown) revert IsShutDown();\n\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n        (uint256 price, ) = priceFeed.fetchPrice();\n\n        uint256 TCR = LiquityMath._computeCR(totalColl, totalDebt, price);\n        if (TCR >= SCR) revert TCRNotBelowSCR();\n\n        _applyShutdown();\n\n        emit ShutDown(TCR);\n    }\n\n    // Not technically a \"Borrower op\", but seems best placed here given current shutdown logic.\n    function shutdownFromOracleFailure(address _failedOracleAddr) external {\n        _requireCallerIsPriceFeed();\n\n        // No-op rather than revert here, so that the outer function call which fetches the price does not revert\n        // if the system is already shut down.\n        if (hasBeenShutDown) return;\n\n        _applyShutdown();\n\n        emit ShutDownFromOracleFailure(_failedOracleAddr);\n    }\n\n    function _applyShutdown() internal {\n        activePool.mintAggInterest();\n        hasBeenShutDown = true;\n        troveManager.shutdown();\n    }\n\n    // --- Helper functions ---\n\n    function _reInsertIntoSortedTroves(\n        uint256 _troveId,\n        uint256 _troveAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        address _batchManager,\n        uint256 _batchAnnualInterestRate\n    ) internal {\n        // If it was in a batch, we need to put it back, otherwise we insert it normally\n        if (_batchManager == address(0)) {\n            sortedTroves.insert(_troveId, _troveAnnualInterestRate, _upperHint, _lowerHint);\n        } else {\n            sortedTroves.insertIntoBatch(\n                _troveId, BatchId.wrap(_batchManager), _batchAnnualInterestRate, _upperHint, _lowerHint\n            );\n        }\n    }\n\n    // This function mints the BOLD corresponding to the borrower's chosen debt increase\n    // (it does not mint the accrued interest).\n    function _moveTokensFromAdjustment(\n        address withdrawalReceiver,\n        TroveChange memory _troveChange,\n        IBoldToken _boldToken,\n        IActivePool _activePool\n    ) internal {\n        if (_troveChange.debtIncrease > 0) {\n            _boldToken.mint(withdrawalReceiver, _troveChange.debtIncrease);\n        } else if (_troveChange.debtDecrease > 0) {\n            _boldToken.burn(msg.sender, _troveChange.debtDecrease);\n        }\n\n        if (_troveChange.collIncrease > 0) {\n            // Pull coll tokens from sender and move them to the Active Pool\n            _pullCollAndSendToActivePool(_activePool, _troveChange.collIncrease);\n        } else if (_troveChange.collDecrease > 0) {\n            // Pull Coll from Active Pool and decrease its recorded Coll balance\n            _activePool.sendColl(withdrawalReceiver, _troveChange.collDecrease);\n        }\n    }\n\n    function _pullCollAndSendToActivePool(IActivePool _activePool, uint256 _amount) internal {\n        // Send Coll tokens from sender to active pool\n        collToken.safeTransferFrom(msg.sender, address(_activePool), _amount);\n        // Make sure Active Pool accountancy is right\n        _activePool.accountForReceivedColl(_amount);\n    }\n\n    function checkBatchManagerExists(address _batchManager) external view returns (bool) {\n        return interestBatchManagers[_batchManager].maxInterestRate > 0;\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireIsNotShutDown() internal view {\n        if (hasBeenShutDown) {\n            revert IsShutDown();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (!hasBeenShutDown) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireNonZeroAdjustment(TroveChange memory _troveChange) internal pure {\n        if (\n            _troveChange.collIncrease == 0 && _troveChange.collDecrease == 0 && _troveChange.debtIncrease == 0\n                && _troveChange.debtDecrease == 0\n        ) {\n            revert ZeroAdjustment();\n        }\n    }\n\n    function _requireSenderIsOwnerOrInterestManager(uint256 _troveId, address _owner) internal view {\n        if (msg.sender != _owner && msg.sender != interestIndividualDelegateOf[_troveId].account) {\n            revert NotOwnerNorInterestManager();\n        }\n    }\n\n    function _requireIsNotInBatch(uint256 _troveId) internal view {\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            revert TroveInBatch();\n        }\n    }\n\n    function _requireIsInBatch(uint256 _troveId) internal view returns (address) {\n        address batchManager = interestBatchManagerOf[_troveId];\n        if (batchManager == address(0)) {\n            revert TroveNotInBatch();\n        }\n\n        return batchManager;\n    }\n\n    function _requireInterestRateInDelegateRange(uint256 _troveId, uint256 _annualInterestRate) internal view {\n        InterestIndividualDelegate memory individualDelegate = interestIndividualDelegateOf[_troveId];\n        if (individualDelegate.account != address(0)) {\n            _requireInterestRateInRange(\n                _annualInterestRate, individualDelegate.minInterestRate, individualDelegate.maxInterestRate\n            );\n        }\n    }\n\n    function _requireInterestRateInBatchManagerRange(address _interestBatchManagerAddress, uint256 _annualInterestRate)\n        internal\n        view\n    {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        _requireInterestRateInRange(\n            _annualInterestRate, interestBatchManager.minInterestRate, interestBatchManager.maxInterestRate\n        );\n    }\n\n    function _requireInterestRateInRange(\n        uint256 _annualInterestRate,\n        uint256 _minInterestRate,\n        uint256 _maxInterestRate\n    ) internal pure {\n        if (_minInterestRate > _annualInterestRate || _annualInterestRate > _maxInterestRate) {\n            revert InterestNotInRange();\n        }\n    }\n\n    function _requireInterestRateChangePeriodPassed(\n        address _interestBatchManagerAddress,\n        uint256 _lastInterestRateAdjTime\n    ) internal view {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        if (block.timestamp < _lastInterestRateAdjTime + uint256(interestBatchManager.minInterestRateChangePeriod)) {\n            revert BatchInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireTroveIsOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active && status != ITroveManager.Status.unredeemable) {\n            revert TroveNotOpen();\n        }\n    }\n\n    function _requireTroveIsActive(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active) {\n            revert TroveNotActive();\n        }\n    }\n\n    function _requireTroveIsUnredeemable(ITroveManager _troveManager, uint256 _troveId) internal view {\n        if (!_checkTroveIsUnredeemable(_troveManager, _troveId)) {\n            revert TroveNotUnredeemable();\n        }\n    }\n\n    function _checkTroveIsUnredeemable(ITroveManager _troveManager, uint256 _troveId) internal view returns (bool) {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        return status == ITroveManager.Status.unredeemable;\n    }\n\n    function _requireTroveIsNotOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status == ITroveManager.Status.active || status == ITroveManager.Status.unredeemable) {\n            revert TroveOpen();\n        }\n    }\n\n    function _requireUserAcceptsUpfrontFee(uint256 _fee, uint256 _maxFee) internal pure {\n        if (_fee > _maxFee) {\n            revert UpfrontFeeTooHigh();\n        }\n    }\n\n    function _requireNotBelowCriticalThreshold(uint256 _price) internal view {\n        if (_checkBelowCriticalThreshold(_price, CCR)) {\n            revert BelowCriticalThreshold();\n        }\n    }\n\n    function _requireNoBorrowing(uint256 _debtIncrease) internal pure {\n        if (_debtIncrease > 0) {\n            revert BorrowingNotPermittedBelowCT();\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        TroveChange memory _troveChange,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n        * Below Critical Threshold, it is not permitted:\n        *\n        * - Borrowing\n        * - Collateral withdrawal except accompanied by a debt repayment of at least the same value\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The adjustment won't pull the TCR below CCR\n        *\n        * In Both cases:\n        * - The new ICR is above MCR\n        */\n        _requireICRisAboveMCR(_vars.newICR);\n\n        if (_vars.isBelowCriticalThreshold) {\n            _requireNoBorrowing(_troveChange.debtIncrease);\n            _requireDebtRepaymentGeCollWithdrawal(_troveChange, _vars.price);\n        } else {\n            // if Normal Mode\n            uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, _vars.price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal view {\n        if (_newICR < MCR) {\n            revert ICRBelowMCR();\n        }\n    }\n\n    function _requireDebtRepaymentGeCollWithdrawal(TroveChange memory _troveChange, uint256 _price) internal pure {\n        if ((_troveChange.debtDecrease * DECIMAL_PRECISION < _troveChange.collDecrease * _price)) {\n            revert RepaymentNotMatchingCollWithdrawal();\n        }\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal view {\n        if (_newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireAtLeastMinDebt(uint256 _debt) internal pure {\n        if (_debt < MIN_DEBT) {\n            revert DebtBelowMin();\n        }\n    }\n\n    function _requireValidCollWithdrawal(uint256 _currentColl, uint256 _collWithdrawal) internal pure {\n        if (_collWithdrawal > _currentColl) {\n            revert CollWithdrawalTooHigh();\n        }\n    }\n\n    function _requireSufficientBoldBalance(IBoldToken _boldToken, address _borrower, uint256 _debtRepayment)\n        internal\n        view\n    {\n        if (_boldToken.balanceOf(_borrower) < _debtRepayment) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    function _requireValidAnnualInterestRate(uint256 _annualInterestRate) internal pure {\n        if (_annualInterestRate < MIN_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooLow();\n        }\n        if (_annualInterestRate > MAX_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooHigh();\n        }\n    }\n\n    function _requireAnnualInterestRateIsNew(uint256 _oldAnnualInterestRate, uint256 _newAnnualInterestRate)\n        internal\n        pure\n    {\n        if (_oldAnnualInterestRate == _newAnnualInterestRate) {\n            revert InterestRateNotNew();\n        }\n    }\n\n    function _requireValidInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate == 0) {\n            revert InvalidInterestBatchManager();\n        }\n    }\n\n    function _requireNonExistentInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate > 0) {\n            revert BatchManagerExists();\n        }\n    }\n\n    function _requireNewInterestBatchManager(address _oldBatchManagerAddress, address _newBatchManagerAddress)\n        internal\n        pure\n    {\n        if (_oldBatchManagerAddress == _newBatchManagerAddress) {\n            revert BatchManagerNotNew();\n        }\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        if (msg.sender != address(troveManager)) {\n            revert CallerNotTroveManager();\n        }\n    }\n\n    function _requireCallerIsPriceFeed() internal view {\n        if (msg.sender != address(priceFeed)) {\n            revert CallerNotPriceFeed();\n        }\n    }\n\n    function _requireOraclesLive() internal returns (uint256) {\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        if (newOracleFailureDetected) {\n            revert NewOracleFailureDetected();\n        }\n\n        return price;\n    }\n\n    // --- ICR and TCR getters ---\n\n    function _getNewTCRFromTroveChange(TroveChange memory _troveChange, uint256 _price)\n        internal\n        view\n        returns (uint256 newTCR)\n    {\n        uint256 totalColl = getEntireSystemColl();\n        totalColl += _troveChange.collIncrease;\n        totalColl -= _troveChange.collDecrease;\n\n        uint256 totalDebt = getEntireSystemDebt();\n        totalDebt += _troveChange.debtIncrease;\n        totalDebt += _troveChange.upfrontFee;\n        totalDebt -= _troveChange.debtDecrease;\n\n        newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n    }\n}\n",
        "TroveManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveEvents.sol\";\nimport \"./Interfaces/ITroveNFT.sol\";\nimport \"./Interfaces/ICollateralRegistry.sol\";\nimport \"./Interfaces/IWETH.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract TroveManager is LiquityBase, ITroveManager, ITroveEvents {\n    // --- Connected contract declarations ---\n\n    ITroveNFT public troveNFT;\n    IBorrowerOperations public borrowerOperations;\n    IStabilityPool public stabilityPool;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n    ICollateralRegistry internal collateralRegistry;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 internal immutable MCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 internal immutable SCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 internal immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 internal immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    // --- Data structures ---\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n    }\n\n    mapping(uint256 => Trove) public Troves;\n\n    // Store the necessary data for an interest batch manager. We treat each batch as a “big trove”.\n    // Each trove has a share of the debt and a share of the coll of the global batch (will in general be different, as CRs are different).\n    struct Batch {\n        uint256 debt;\n        uint256 coll;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        uint256 annualManagementFee;\n        uint256 totalDebtShares;\n    }\n\n    mapping(address => Batch) internal batches;\n\n    uint256 internal totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 internal totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 internal totalCollateralSnapshot;\n\n    /*\n    * L_coll and L_boldDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An Coll gain of ( stake * [L_coll - L_coll(0)] )\n    * A boldDebt increase  of ( stake * [L_boldDebt - L_boldDebt(0)] )\n    *\n    * Where L_coll(0) and L_boldDebt(0) are snapshots of L_coll and L_boldDebt for the active Trove taken at the instant the stake was made\n    */\n    uint256 internal L_coll;\n    uint256 internal L_boldDebt;\n\n    // Map active troves to their RewardSnapshot\n    mapping(uint256 => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the Coll and Bold snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 coll;\n        uint256 boldDebt;\n    }\n\n    // Array of all active trove addresses - used to compute an approximate hint off-chain, for the sorted list insertion\n    uint256[] internal TroveIds;\n    // Array of all batch managers - used to fetch them off-chain\n    address[] public batchIds;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 internal lastCollError_Redistribution;\n    uint256 internal lastBoldDebtError_Redistribution;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LiquidationValues {\n        uint256 collGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n        uint256 ETHGasCompensation;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct SingleRedemptionValues {\n        uint256 troveId;\n        address batchAddress;\n        uint256 boldLot;\n        uint256 collLot;\n        uint256 collFee;\n        uint256 appliedRedistBoldDebtGain;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n        uint256 newStake;\n        LatestTroveData trove;\n        LatestBatchData batch;\n    }\n\n    // --- Errors ---\n\n    error EmptyData();\n    error NothingToLiquidate();\n    error CallerNotBorrowerOperations();\n    error CallerNotCollateralRegistry();\n    error OnlyOneTroveLeft();\n    error NotShutDown();\n    error NotEnoughBoldBalance();\n    error MinCollNotReached(uint256 _coll);\n\n    // --- Events ---\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        CCR = _addressesRegistry.CCR();\n        MCR = _addressesRegistry.MCR();\n        SCR = _addressesRegistry.SCR();\n        LIQUIDATION_PENALTY_SP = _addressesRegistry.LIQUIDATION_PENALTY_SP();\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _addressesRegistry.LIQUIDATION_PENALTY_REDISTRIBUTION();\n\n        troveNFT = _addressesRegistry.troveNFT();\n        borrowerOperations = _addressesRegistry.borrowerOperations();\n        stabilityPool = _addressesRegistry.stabilityPool();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        boldToken = _addressesRegistry.boldToken();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        WETH = _addressesRegistry.WETH();\n        collateralRegistry = _addressesRegistry.collateralRegistry();\n\n        emit TroveNFTAddressChanged(address(troveNFT));\n        emit BorrowerOperationsAddressChanged(address(borrowerOperations));\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit BoldTokenAddressChanged(address(boldToken));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit CollateralRegistryAddressChanged(address(collateralRegistry));\n    }\n\n    // --- Getters ---\n\n    function getTroveIdsCount() external view override returns (uint256) {\n        return TroveIds.length;\n    }\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view override returns (uint256) {\n        return TroveIds[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove\n    function _liquidate(\n        IDefaultPool _defaultPool,\n        uint256 _troveId,\n        uint256 _boldInStabPool,\n        uint256 _price,\n        LatestTroveData memory trove,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        address owner = troveNFT.ownerOf(_troveId);\n\n        _getLatestTroveData(_troveId, trove);\n        address batchAddress = _getBatchManager(_troveId);\n        bool isTroveInBatch = batchAddress != address(0);\n        LatestBatchData memory batch;\n        if (isTroveInBatch) _getLatestBatchData(batchAddress, batch);\n\n        _movePendingTroveRewardsToActivePool(_defaultPool, trove.redistBoldDebtGain, trove.redistCollGain);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(trove.entireColl);\n        uint256 collToLiquidate = trove.entireColl - singleLiquidation.collGasCompensation;\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute,\n            singleLiquidation.collSurplus\n        ) = _getOffsetAndRedistributionVals(trove.entireDebt, collToLiquidate, _boldInStabPool, _price);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        _closeTrove(\n            _troveId,\n            troveChange,\n            batchAddress,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            Status.closedByLiquidation\n        );\n\n        if (isTroveInBatch) {\n            singleLiquidation.oldWeightedRecordedDebt =\n                batch.weightedRecordedDebt + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualInterestRate;\n            singleLiquidation.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n            // Mint batch management fee\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee\n                + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, batchAddress);\n        } else {\n            singleLiquidation.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n        }\n\n        // Differencen between liquidation penalty and liquidation threshold\n        if (singleLiquidation.collSurplus > 0) {\n            collSurplusPool.accountSurplus(owner, singleLiquidation.collSurplus);\n        }\n\n        // Wipe out state in BO\n        borrowerOperations.onLiquidateTrove(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.liquidate,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(trove.entireDebt),\n            _collIncreaseFromRedist: trove.redistCollGain,\n            _collChangeFromOperation: -int256(trove.entireColl)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[batchAddress].debt,\n            _coll: batches[batchAddress].coll,\n            _annualInterestRate: batch.annualInterestRate,\n            _annualManagementFee: batch.annualManagementFee,\n            _totalDebtShares: batches[batchAddress].totalDebtShares\n        });\n    }\n\n    // Return the amount of Coll to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {\n        return LiquityMath._min(_entireColl / COLL_GAS_COMPENSATION_DIVISOR, COLL_GAS_COMPENSATION_CAP);\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        uint256 _collToLiquidate, // gas compensation is already subtracted\n        uint256 _boldInStabPool,\n        uint256 _price\n    )\n        internal\n        view\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute,\n            uint256 collSurplus\n        )\n    {\n        uint256 collSPPortion;\n        /*\n         * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n         * between all active troves.\n         *\n         *  If the trove's debt is larger than the deposited Bold in the Stability Pool:\n         *\n         *  - Offset an amount of the trove's debt equal to the Bold in the Stability Pool\n         *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n         *\n         */\n        if (_boldInStabPool > 0) {\n            debtToOffset = LiquityMath._min(_entireTroveDebt, _boldInStabPool);\n            collSPPortion = _collToLiquidate * debtToOffset / _entireTroveDebt;\n            (collToSendToSP, collSurplus) =\n                _getCollPenaltyAndSurplus(collSPPortion, debtToOffset, LIQUIDATION_PENALTY_SP, _price);\n        }\n\n        // Redistribution\n        debtToRedistribute = _entireTroveDebt - debtToOffset;\n        if (debtToRedistribute > 0) {\n            uint256 collRedistributionPortion = _collToLiquidate - collSPPortion;\n            if (collRedistributionPortion > 0) {\n                (collToRedistribute, collSurplus) = _getCollPenaltyAndSurplus(\n                    collRedistributionPortion + collSurplus, // Coll surplus from offset can be eaten up by red. penalty\n                    debtToRedistribute,\n                    LIQUIDATION_PENALTY_REDISTRIBUTION, // _penaltyRatio\n                    _price\n                );\n            }\n        }\n        // assert(_collToLiquidate == collToSendToSP + collToRedistribute + collSurplus);\n    }\n\n    function _getCollPenaltyAndSurplus(\n        uint256 _collToLiquidate,\n        uint256 _debtToLiquidate,\n        uint256 _penaltyRatio,\n        uint256 _price\n    ) internal pure returns (uint256 seizedColl, uint256 collSurplus) {\n        uint256 maxSeizedColl = _debtToLiquidate * (DECIMAL_PRECISION + _penaltyRatio) / _price;\n        if (_collToLiquidate > maxSeizedColl) {\n            seizedColl = maxSeizedColl;\n            collSurplus = _collToLiquidate - maxSeizedColl;\n        } else {\n            seizedColl = _collToLiquidate;\n            collSurplus = 0;\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(uint256[] memory _troveArray) public override {\n        if (_troveArray.length == 0) {\n            revert EmptyData();\n        }\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        TroveChange memory troveChange;\n        LiquidationValues memory totals;\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n        uint256 boldInStabPool = stabilityPoolCached.getTotalBoldDeposits();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        _batchLiquidateTroves(defaultPoolCached, price, boldInStabPool, _troveArray, totals, troveChange);\n\n        if (troveChange.debtDecrease == 0) {\n            revert NothingToLiquidate();\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        // Move liquidated Coll and Bold to the appropriate pools\n        if (totals.debtToOffset > 0 || totals.collToSendToSP > 0) {\n            stabilityPoolCached.offset(totals.debtToOffset, totals.collToSendToSP);\n        }\n        // we check amount is not zero inside\n        _redistributeDebtAndColl(\n            activePoolCached, defaultPoolCached, totals.debtToRedistribute, totals.collToRedistribute\n        );\n        if (totals.collSurplus > 0) {\n            activePoolCached.sendColl(address(collSurplusPool), totals.collSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.collGasCompensation);\n\n        emit Liquidation(\n            totals.debtToOffset,\n            totals.debtToRedistribute,\n            totals.ETHGasCompensation,\n            totals.collGasCompensation,\n            totals.collToSendToSP,\n            totals.collToRedistribute,\n            totals.collSurplus,\n            L_coll,\n            L_boldDebt,\n            price\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, totals.ETHGasCompensation, totals.collGasCompensation);\n    }\n\n    function _isLiquidatableStatus(Status _status) internal pure returns (bool) {\n        return _status == Status.active || _status == Status.unredeemable;\n    }\n\n    function _batchLiquidateTroves(\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _boldInStabPool,\n        uint256[] memory _troveArray,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal {\n        uint256 remainingBoldInStabPool = _boldInStabPool;\n\n        for (uint256 i = 0; i < _troveArray.length; i++) {\n            uint256 troveId = _troveArray[i];\n\n            // Skip non-liquidatable troves\n            if (!_isLiquidatableStatus(Troves[troveId].status)) continue;\n\n            uint256 ICR = getCurrentICR(troveId, _price);\n\n            if (ICR < MCR) {\n                LiquidationValues memory singleLiquidation;\n                LatestTroveData memory trove;\n\n                _liquidate(_defaultPool, troveId, remainingBoldInStabPool, _price, trove, singleLiquidation);\n                remainingBoldInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                _addLiquidationValuesToTotals(trove, singleLiquidation, totals, troveChange);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    // Adds all values from `singleLiquidation` to their respective totals in `totals` in-place\n    function _addLiquidationValuesToTotals(\n        LatestTroveData memory _trove,\n        LiquidationValues memory _singleLiquidation,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal pure {\n        // Tally all the values with their respective running totals\n        totals.collGasCompensation += _singleLiquidation.collGasCompensation;\n        totals.ETHGasCompensation += ETH_GAS_COMPENSATION;\n        troveChange.debtDecrease += _trove.entireDebt;\n        troveChange.collDecrease += _trove.entireColl;\n        troveChange.appliedRedistBoldDebtGain += _trove.redistBoldDebtGain;\n        troveChange.oldWeightedRecordedDebt += _singleLiquidation.oldWeightedRecordedDebt;\n        troveChange.newWeightedRecordedDebt += _singleLiquidation.newWeightedRecordedDebt;\n        totals.debtToOffset += _singleLiquidation.debtToOffset;\n        totals.collToSendToSP += _singleLiquidation.collToSendToSP;\n        totals.debtToRedistribute += _singleLiquidation.debtToRedistribute;\n        totals.collToRedistribute += _singleLiquidation.collToRedistribute;\n        totals.collSurplus += _singleLiquidation.collSurplus;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _eth, uint256 _coll) internal {\n        if (_eth > 0) {\n            WETH.transferFrom(gasPoolAddress, _liquidator, _eth);\n        }\n\n        if (_coll > 0) {\n            _activePool.sendColl(_liquidator, _coll);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IDefaultPool _defaultPool, uint256 _bold, uint256 _coll) internal {\n        if (_bold > 0) {\n            _defaultPool.decreaseBoldDebt(_bold);\n        }\n\n        if (_coll > 0) {\n            _defaultPool.sendCollToActivePool(_coll);\n        }\n    }\n\n    // --- Redemption functions ---\n\n    function _applySingleRedemption(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        // Decrease the debt and collateral of the current Trove according to the Bold lot and corresponding ETH to send\n        uint256 newDebt = _singleRedemption.trove.entireDebt - _singleRedemption.boldLot;\n        uint256 newColl = _singleRedemption.trove.entireColl - _singleRedemption.collLot;\n\n        _singleRedemption.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n\n        if (_isTroveInBatch) {\n            _getLatestBatchData(_singleRedemption.batchAddress, _singleRedemption.batch);\n            // We know boldLot <= trove entire debt, so this subtraction is safe\n            uint256 newAmountForWeightedDebt = _singleRedemption.batch.entireDebtWithoutRedistribution\n                + _singleRedemption.trove.redistBoldDebtGain - _singleRedemption.boldLot;\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.batch.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualInterestRate;\n\n            TroveChange memory troveChange;\n            troveChange.debtDecrease = _singleRedemption.boldLot;\n            troveChange.collDecrease = _singleRedemption.collLot;\n            troveChange.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n            troveChange.appliedRedistCollGain = _singleRedemption.trove.redistCollGain;\n            // batchAccruedManagementFee is handled in the outer function\n            troveChange.oldWeightedRecordedBatchManagementFee =\n                _singleRedemption.batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualManagementFee;\n\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, _singleRedemption.batchAddress);\n\n            Troves[_singleRedemption.troveId].coll = newColl;\n            // interest and fee were updated in the outer function\n            _updateBatchShares(\n                _singleRedemption.troveId,\n                _singleRedemption.batchAddress,\n                troveChange,\n                _singleRedemption.batch.entireCollWithoutRedistribution,\n                _singleRedemption.batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.trove.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt = newDebt * _singleRedemption.trove.annualInterestRate;\n            Troves[_singleRedemption.troveId].debt = newDebt;\n            Troves[_singleRedemption.troveId].coll = newColl;\n            Troves[_singleRedemption.troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _singleRedemption.newStake = _updateStakeAndTotalStakes(_singleRedemption.troveId, newColl);\n        _movePendingTroveRewardsToActivePool(\n            _defaultPool, _singleRedemption.trove.redistBoldDebtGain, _singleRedemption.trove.redistCollGain\n        );\n        _updateTroveRewardSnapshots(_singleRedemption.troveId);\n\n        if (_isTroveInBatch) {\n            emit BatchedTroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _batchDebtShares: Troves[_singleRedemption.troveId].batchDebtShares,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        } else {\n            emit TroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _debt: newDebt,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        }\n\n        emit TroveOperation({\n            _troveId: _singleRedemption.troveId,\n            _operation: Operation.redeemCollateral,\n            _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n            _debtIncreaseFromRedist: _singleRedemption.trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(_singleRedemption.boldLot),\n            _collIncreaseFromRedist: _singleRedemption.trove.redistCollGain,\n            _collChangeFromOperation: -int256(_singleRedemption.collLot)\n        });\n\n        emit RedemptionFeePaidToTrove(_singleRedemption.troveId, _singleRedemption.collFee);\n\n        return newDebt;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _redeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        uint256 _redemptionRate\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of Coll equal in USD value to the boldLot redeemed\n        uint256 correspondingColl = _singleRedemption.boldLot * DECIMAL_PRECISION / _price;\n        // Calculate the collFee separately (for events)\n        _singleRedemption.collFee = correspondingColl * _redemptionRate / DECIMAL_PRECISION;\n        // Get the final collLot to send to redeemer, leaving the fee in the Trove\n        _singleRedemption.collLot = correspondingColl - _singleRedemption.collFee;\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        uint256 newDebt = _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // Make Trove unredeemable if it's tiny, in order to prevent griefing future (normal, sequential) redemptions\n        if (newDebt < MIN_DEBT) {\n            Troves[_singleRedemption.troveId].status = Status.unredeemable;\n            if (isTroveInBatch) {\n                sortedTroves.removeFromBatch(_singleRedemption.troveId);\n            } else {\n                sortedTroves.remove(_singleRedemption.troveId);\n            }\n        }\n    }\n\n    function _updateBatchInterestPriorToRedemption(IActivePool _activePool, address _batchAddress) internal {\n        LatestBatchData memory batch;\n        _getLatestBatchData(_batchAddress, batch);\n        batches[_batchAddress].debt = batch.entireDebtWithoutRedistribution;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        // As we are updating the batch, we update the ActivePool weighted sum too\n        TroveChange memory batchTroveChange;\n        batchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchTroveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchTroveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchTroveChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n\n        _activePool.mintAggInterestAndAccountForTroveChange(batchTroveChange, _batchAddress);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batch.entireDebtWithoutRedistribution,\n            _coll: batch.entireCollWithoutRedistribution,\n            _annualInterestRate: batch.annualInterestRate,\n            _annualManagementFee: batch.annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    /* Send _boldamount Bold to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies redistribution gains to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining Bold amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        address _redeemer,\n        uint256 _boldamount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external override returns (uint256 _redemeedAmount) {\n        _requireCallerIsCollateralRegistry();\n\n        IActivePool activePoolCached = activePool;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        TroveChange memory totalsTroveChange;\n        uint256 totalCollFee;\n\n        uint256 remainingBold = _boldamount;\n\n        SingleRedemptionValues memory singleRedemption;\n        singleRedemption.troveId = sortedTrovesCached.getLast();\n        address lastBatchUpdatedInterest = address(0);\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of Bold is exchanged for collateral\n        if (_maxIterations == 0) _maxIterations = type(uint256).max;\n        while (singleRedemption.troveId != 0 && remainingBold > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the uint256 of the Trove preceding the current one\n            uint256 nextUserToCheck = sortedTrovesCached.getPrev(singleRedemption.troveId);\n            // Skip if ICR < 100%, to make sure that redemptions always improve the CR of hit Troves\n            if (getCurrentICR(singleRedemption.troveId, _price) < _100pct) {\n                singleRedemption.troveId = nextUserToCheck;\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // We do it here outside, to avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (\n                singleRedemption.batchAddress != address(0) && singleRedemption.batchAddress != lastBatchUpdatedInterest\n            ) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n                lastBatchUpdatedInterest = singleRedemption.batchAddress;\n            }\n\n            _redeemCollateralFromTrove(defaultPool, singleRedemption, remainingBold, _price, _redemptionRate);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n            totalCollFee += singleRedemption.collFee;\n\n            remainingBold -= singleRedemption.boldLot;\n            singleRedemption.troveId = nextUserToCheck;\n        }\n\n        // We are removing this condition to prevent blocking redemptions\n        //require(totals.totalCollDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        emit Redemption(\n            _boldamount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, totalCollFee, _price\n        );\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed Coll to sender\n        activePoolCached.sendColl(_redeemer, totalsTroveChange.collDecrease);\n        // We’ll burn all the Bold together out in the CollateralRegistry, to save gas\n\n        return totalsTroveChange.debtDecrease;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _urgentRedeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        SingleRedemptionValues memory _singleRedemption\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of ETH equal in USD value to the BOLD lot redeemed\n        _singleRedemption.collLot = _singleRedemption.boldLot * (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS) / _price;\n        // As here we can redeem when CR < 100%, we need to cap by collateral too\n        if (_singleRedemption.collLot > _singleRedemption.trove.entireColl) {\n            _singleRedemption.collLot = _singleRedemption.trove.entireColl;\n            _singleRedemption.boldLot =\n                _singleRedemption.trove.entireColl * _price / (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS);\n        }\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // No need to make this Trove unredeemable if it has tiny debt, since:\n        // - This collateral branch has shut down and urgent redemptions are enabled\n        // - Urgent redemptions aren't sequential, so they can't be griefed by tiny Troves.\n    }\n\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external {\n        _requireIsShutDown();\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        IActivePool activePoolCached = activePool;\n        TroveChange memory totalsTroveChange;\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n\n        uint256 remainingBold = _boldAmount;\n        for (uint256 i = 0; i < _troveIds.length; i++) {\n            SingleRedemptionValues memory singleRedemption;\n            singleRedemption.troveId = _troveIds[i];\n\n            // If it’s in a batch, we need to update interest first\n            // As we don’t have them ordered now, we cannot avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (singleRedemption.batchAddress != address(0)) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n            }\n\n            _urgentRedeemCollateralFromTrove(defaultPool, remainingBold, price, singleRedemption);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n\n            remainingBold -= singleRedemption.boldLot;\n            if (remainingBold == 0) break;\n        }\n\n        if (totalsTroveChange.collDecrease < _minCollateral) {\n            revert MinCollNotReached(totalsTroveChange.collDecrease);\n        }\n\n        emit Redemption(_boldAmount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, 0, price);\n\n        // Since this branch is shut down, this will mint 0 interest.\n        // We call this only to update the aggregate debt and weighted debt trackers.\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed coll to caller\n        activePoolCached.sendColl(msg.sender, totalsTroveChange.collDecrease);\n        // Burn bold\n        boldToken.burn(msg.sender, totalsTroveChange.debtDecrease);\n    }\n\n    function shutdown() external {\n        _requireCallerIsBorrowerOperations();\n        shutdownTime = block.timestamp;\n        activePool.setShutdownFlag();\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(uint256 _troveId, uint256 _price) public view override returns (uint256) {\n        LatestTroveData memory trove;\n        _getLatestTroveData(_troveId, trove);\n        return LiquityMath._computeCR(trove.entireColl, trove.entireDebt, _price);\n    }\n\n    function _updateTroveRewardSnapshots(uint256 _troveId) internal {\n        rewardSnapshots[_troveId].coll = L_coll;\n        rewardSnapshots[_troveId].boldDebt = L_boldDebt;\n    }\n\n    // Return the Troves entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestTroveData(uint256 _troveId, LatestTroveData memory trove) internal view {\n        // If trove belongs to a batch, we fetch the batch and apply its share to obtained values\n        address batchAddress = _getBatchManager(_troveId);\n        if (batchAddress != address(0)) {\n            LatestBatchData memory batch;\n            _getLatestBatchData(batchAddress, batch);\n            _getLatestTroveDataFromBatch(_troveId, batchAddress, trove, batch);\n            return;\n        }\n\n        uint256 stake = Troves[_troveId].stake;\n        trove.redistBoldDebtGain = stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        trove.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        trove.recordedDebt = Troves[_troveId].debt;\n        trove.annualInterestRate = Troves[_troveId].annualInterestRate;\n        trove.weightedRecordedDebt = trove.recordedDebt * trove.annualInterestRate;\n\n        uint256 period = _getInterestPeriod(Troves[_troveId].lastDebtUpdateTime);\n        trove.accruedInterest = _calcInterest(trove.weightedRecordedDebt, period);\n\n        trove.entireDebt = trove.recordedDebt + trove.redistBoldDebtGain + trove.accruedInterest;\n        trove.entireColl = Troves[_troveId].coll + trove.redistCollGain;\n        trove.lastInterestRateAdjTime = Troves[_troveId].lastInterestRateAdjTime;\n    }\n\n    function _getLatestTroveDataFromBatch(\n        uint256 _troveId,\n        address _batchAddress,\n        LatestTroveData memory _latestTroveData,\n        LatestBatchData memory _latestBatchData\n    ) internal view {\n        Trove memory trove = Troves[_troveId];\n        Batch memory batch = batches[_batchAddress];\n        uint256 batchDebtShares = trove.batchDebtShares;\n        uint256 totalDebtShares = batch.totalDebtShares;\n\n        uint256 stake = trove.stake;\n        //uint256 batchRedistBoldDebtGain = stake * (L_boldDebt - rewardBatchSnapshots[_batchAddress].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistBoldDebtGain =\n            stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        if (totalDebtShares > 0) {\n            _latestTroveData.recordedDebt = _latestBatchData.recordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.weightedRecordedDebt =\n                _latestBatchData.weightedRecordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedInterest = _latestBatchData.accruedInterest * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedBatchManagementFee =\n                _latestBatchData.accruedManagementFee * batchDebtShares / totalDebtShares;\n        }\n        _latestTroveData.annualInterestRate = _latestBatchData.annualInterestRate;\n\n        // We can’t do pro-rata batch entireDebt, because redist gains are proportional to coll, not to debt\n        _latestTroveData.entireDebt = _latestTroveData.recordedDebt + _latestTroveData.redistBoldDebtGain\n            + _latestTroveData.accruedInterest + _latestTroveData.accruedBatchManagementFee;\n        _latestTroveData.entireColl = trove.coll + _latestTroveData.redistCollGain;\n        _latestTroveData.lastInterestRateAdjTime =\n            LiquityMath._max(_latestBatchData.lastInterestRateAdjTime, trove.lastInterestRateAdjTime);\n    }\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory trove) {\n        _getLatestTroveData(_troveId, trove);\n    }\n\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256) {\n        Trove memory trove = Troves[_troveId];\n        address batchAddress = _getBatchManager(trove);\n        if (batchAddress != address(0)) {\n            return batches[batchAddress].annualInterestRate;\n        }\n        return trove.annualInterestRate;\n    }\n\n    function _getBatchManager(uint256 _troveId) internal view returns (address) {\n        return Troves[_troveId].interestBatchManager;\n    }\n\n    function _getBatchManager(Trove memory trove) internal pure returns (address) {\n        return trove.interestBatchManager;\n    }\n\n    // Return the Batch entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestBatchData(address _batchAddress, LatestBatchData memory latestBatchData) internal view {\n        Batch memory batch = batches[_batchAddress];\n\n        latestBatchData.recordedDebt = batch.debt;\n        latestBatchData.annualInterestRate = batch.annualInterestRate;\n        latestBatchData.weightedRecordedDebt = latestBatchData.recordedDebt * latestBatchData.annualInterestRate;\n        uint256 period = _getInterestPeriod(batch.lastDebtUpdateTime);\n        latestBatchData.accruedInterest = _calcInterest(latestBatchData.weightedRecordedDebt, period);\n        latestBatchData.annualManagementFee = batch.annualManagementFee;\n        latestBatchData.weightedRecordedBatchManagementFee =\n            latestBatchData.recordedDebt * latestBatchData.annualManagementFee;\n        latestBatchData.accruedManagementFee =\n            _calcInterest(latestBatchData.weightedRecordedBatchManagementFee, period);\n\n        latestBatchData.entireDebtWithoutRedistribution =\n            latestBatchData.recordedDebt + latestBatchData.accruedInterest + latestBatchData.accruedManagementFee;\n        latestBatchData.entireCollWithoutRedistribution = batch.coll;\n        latestBatchData.lastDebtUpdateTime = batch.lastDebtUpdateTime;\n        latestBatchData.lastInterestRateAdjTime = batch.lastInterestRateAdjTime;\n    }\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory batch) {\n        _getLatestBatchData(_batchAddress, batch);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(uint256 _troveId, uint256 _coll) internal returns (uint256 newStake) {\n        newStake = _computeNewStake(_coll);\n        uint256 oldStake = Troves[_troveId].stake;\n        Troves[_troveId].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the redistribution gains, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            // assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debtToRedistribute,\n        uint256 _collToRedistribute\n    ) internal {\n        if (_debtToRedistribute == 0) return;\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_coll and L_boldDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToRedistribute * DECIMAL_PRECISION + lastCollError_Redistribution;\n        uint256 boldDebtNumerator = _debtToRedistribute * DECIMAL_PRECISION + lastBoldDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint256 collRewardPerUnitStaked = collNumerator / totalStakes;\n        uint256 boldDebtRewardPerUnitStaked = boldDebtNumerator / totalStakes;\n\n        lastCollError_Redistribution = collNumerator - collRewardPerUnitStaked * totalStakes;\n        lastBoldDebtError_Redistribution = boldDebtNumerator - boldDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_coll = L_coll + collRewardPerUnitStaked;\n        L_boldDebt = L_boldDebt + boldDebtRewardPerUnitStaked;\n\n        _defaultPool.increaseBoldDebt(_debtToRedistribute);\n        _activePool.sendCollToDefaultPool(_collToRedistribute);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getCollBalance();\n        uint256 liquidatedColl = defaultPool.getCollBalance();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveIds array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveId(uint256 _troveId, uint256 TroveIdsArrayLength) internal {\n        uint64 index = Troves[_troveId].arrayIndex;\n        uint256 idxLast = TroveIdsArrayLength - 1;\n\n        // assert(index <= idxLast);\n\n        uint256 idToMove = TroveIds[idxLast];\n\n        TroveIds[index] = idToMove;\n        Troves[idToMove].arrayIndex = index;\n\n        TroveIds.pop();\n    }\n\n    function getTroveStatus(uint256 _troveId) external view override returns (Status) {\n        return Troves[_troveId].status;\n    }\n\n    // --- Interest rate calculations ---\n\n    function _getInterestPeriod(uint256 _lastDebtUpdateTime) internal view returns (uint256) {\n        if (shutdownTime == 0) {\n            // If branch is not shut down, interest is earned up to now.\n            return block.timestamp - _lastDebtUpdateTime;\n        } else if (shutdownTime > 0 && _lastDebtUpdateTime < shutdownTime) {\n            // If branch is shut down and the Trove was not updated since shut down, interest is earned up to the shutdown time.\n            return shutdownTime - _lastDebtUpdateTime;\n        } else {\n            // if (shutdownTime > 0 && _lastDebtUpdateTime >= shutdownTime)\n            // If branch is shut down and the Trove was updated after shutdown, no interest is earned since.\n            return 0;\n        }\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != address(borrowerOperations)) {\n            revert CallerNotBorrowerOperations();\n        }\n    }\n\n    function _requireCallerIsCollateralRegistry() internal view {\n        if (msg.sender != address(collateralRegistry)) {\n            revert CallerNotCollateralRegistry();\n        }\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint256 TroveIdsArrayLength) internal pure {\n        if (TroveIdsArrayLength == 1) {\n            revert OnlyOneTroveLeft();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (shutdownTime == 0) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        if (boldBalance < _amount) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    // --- Trove property getters ---\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool) {\n        uint256 totalDebt = getEntireSystemDebt();\n        uint256 spSize = stabilityPool.getTotalBoldDeposits();\n        uint256 unbackedPortion = totalDebt > spSize ? totalDebt - spSize : 0;\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n        // It's redeemable if the TCR is above the shutdown threshold, and branch has not been shut down\n        bool redeemable = _getTCR(price) >= SCR && shutdownTime == 0;\n\n        return (unbackedPortion, price, redeemable);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].debt = _troveChange.debtIncrease + _troveChange.upfrontFee;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _annualInterestRate;\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _troveChange.debtIncrease + _troveChange.upfrontFee,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _annualInterestRate: _annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTrove,\n            _annualInterestRate: _annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n    }\n\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].interestBatchManager = _batchAddress;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _batchColl, _batchDebt);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTroveAndJoinBatch,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function setTroveStatusToActive(uint256 _troveId) external {\n        _requireCallerIsBorrowerOperations();\n        Troves[_troveId].status = Status.active;\n    }\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTroveInterestRate,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n    }\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newColl);\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: newStake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        _closeTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, Status.closedByOwner);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.closeTrove,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        if (_batchAddress != address(0)) {\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[_batchAddress].debt,\n                _coll: batches[_batchAddress].coll,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares\n            });\n        }\n    }\n\n    function _closeTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        Status closedStatus\n    ) internal {\n        // assert(closedStatus == Status.closedByLiquidation || closedStatus == Status.closedByOwner);\n\n        uint256 TroveIdsArrayLength = TroveIds.length;\n        _requireMoreThanOneTroveInSystem(TroveIdsArrayLength);\n\n        _removeTroveId(_troveId, TroveIdsArrayLength);\n\n        Trove memory trove = Troves[_troveId];\n\n        // If trove belongs to a batch, remove from it\n        if (_batchAddress != address(0)) {\n            if (trove.status == Status.active) {\n                sortedTroves.removeFromBatch(_troveId);\n            }\n\n            _removeTroveSharesFromBatch(\n                _troveId,\n                _troveChange.collDecrease,\n                _troveChange.debtDecrease,\n                _troveChange,\n                _batchAddress,\n                _newBatchColl,\n                _newBatchDebt\n            );\n        } else {\n            if (trove.status == Status.active) {\n                sortedTroves.remove(_troveId);\n            }\n        }\n\n        uint256 newTotalStakes = totalStakes - trove.stake;\n        totalStakes = newTotalStakes;\n\n        // Zero Trove properties\n        delete Troves[_troveId];\n        Troves[_troveId].status = closedStatus;\n\n        // Zero Trove snapshots\n        delete rewardSnapshots[_troveId];\n\n        // burn ERC721\n        troveNFT.burn(_troveId);\n    }\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution and trove change\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest, batch fee), but without trove change nor upfront fee nor redistribution\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        // Trove\n        Troves[_troveId].coll = _newTroveColl;\n        _updateTroveRewardSnapshots(_troveId);\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newTroveColl);\n\n        // Batch\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _newBatchColl, _newBatchDebt);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _newTroveColl,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newTroveColl;\n\n        if (_batchAddress != address(0)) {\n            _updateBatchShares(_troveId, _batchAddress, _troveChange, _newBatchColl, _newBatchDebt);\n\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.applyBatchInterestAndFee,\n                _debt: _newBatchDebt,\n                _coll: _newBatchColl,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares\n            });\n        } else {\n            Troves[_troveId].debt = _newTroveDebt;\n            Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.applyPendingDebt,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_account].arrayIndex = uint64(batchIds.length);\n        batches[_account].annualInterestRate = _annualInterestRate;\n        batches[_account].annualManagementFee = _annualManagementFee;\n        batches[_account].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        batchIds.push(_account);\n\n        emit BatchUpdated({\n            _interestBatchManager: _account,\n            _operation: BatchOperation.registerBatchManager,\n            _debt: 0,\n            _coll: 0,\n            _annualInterestRate: _annualInterestRate,\n            _annualManagementFee: _annualManagementFee,\n            _totalDebtShares: 0\n        });\n    }\n\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualManagementFee = _newAnnualManagementFee;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.lowerBatchManagerAnnualFee,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: _newAnnualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualInterestRate = _newAnnualInterestRate;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        batches[_batchAddress].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.setBatchManagerAnnualInterestRate,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: _newAnnualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external {\n        _requireCallerIsBorrowerOperations();\n        TroveChange memory _troveChange = _params.troveChange;\n\n        // assert(batchIds[batches[_params.newBatchAddress].arrayIndex] == _params.newBatchAddress);\n\n        _updateTroveRewardSnapshots(_params.troveId);\n\n        // Clean Trove state\n        Troves[_params.troveId].debt = 0;\n        Troves[_params.troveId].annualInterestRate = 0;\n        Troves[_params.troveId].lastDebtUpdateTime = 0;\n        Troves[_params.troveId].coll = _params.troveColl;\n\n        Troves[_params.troveId].interestBatchManager = _params.newBatchAddress;\n        Troves[_params.troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _troveChange.collIncrease = _params.troveColl - _troveChange.appliedRedistCollGain;\n        _troveChange.debtIncrease = _params.troveDebt - _troveChange.appliedRedistBoldDebtGain - _troveChange.upfrontFee;\n        _updateBatchShares(\n            _params.troveId, _params.newBatchAddress, _troveChange, _params.newBatchColl, _params.newBatchDebt\n        );\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _params.troveId,\n            _interestBatchManager: _params.newBatchAddress,\n            _batchDebtShares: Troves[_params.troveId].batchDebtShares,\n            _coll: _params.troveColl,\n            _stake: Troves[_params.troveId].stake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _params.troveId,\n            _operation: Operation.setInterestBatchManager,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _params.newBatchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_params.newBatchAddress].debt,\n            _coll: batches[_params.newBatchAddress].coll,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _annualManagementFee: batches[_params.newBatchAddress].annualManagementFee,\n            _totalDebtShares: batches[_params.newBatchAddress].totalDebtShares\n        });\n    }\n\n    function _updateBatchShares(\n        uint256 _troveId,\n        address _batchAddress,\n        TroveChange memory _troveChange,\n        uint256 _batchColl, // without trove change\n        uint256 _batchDebt // entire (with interest, batch fee), but without trove change, nor upfront fee nor redist\n    ) internal {\n        // Debt\n        uint256 currentBatchDebtShares = batches[_batchAddress].totalDebtShares;\n        uint256 batchDebtSharesDelta;\n        uint256 debtIncrease =\n            _troveChange.debtIncrease + _troveChange.upfrontFee + _troveChange.appliedRedistBoldDebtGain;\n        uint256 debtDecrease;\n        if (debtIncrease > _troveChange.debtDecrease) {\n            debtIncrease -= _troveChange.debtDecrease;\n        } else {\n            debtDecrease = _troveChange.debtDecrease - debtIncrease;\n            debtIncrease = 0;\n        }\n\n        if (debtIncrease == 0 && debtDecrease == 0) {\n            batches[_batchAddress].debt = _batchDebt;\n        } else {\n            if (debtIncrease > 0) {\n                // Add debt\n                if (_batchDebt == 0) {\n                    batchDebtSharesDelta = debtIncrease;\n                } else {\n                    batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / _batchDebt;\n                }\n\n                Troves[_troveId].batchDebtShares += batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt + debtIncrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares + batchDebtSharesDelta;\n            } else if (debtDecrease > 0) {\n                // Subtract debt\n                batchDebtSharesDelta = currentBatchDebtShares * debtDecrease / _batchDebt;\n\n                Troves[_troveId].batchDebtShares -= batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares - batchDebtSharesDelta;\n            }\n        }\n        // Update debt checkpoint\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        // Collateral\n        uint256 collIncrease = _troveChange.collIncrease + _troveChange.appliedRedistCollGain;\n        uint256 collDecrease;\n        if (collIncrease > _troveChange.collDecrease) {\n            collIncrease -= _troveChange.collDecrease;\n        } else {\n            collDecrease = _troveChange.collDecrease - collIncrease;\n            collIncrease = 0;\n        }\n\n        if (collIncrease == 0 && collDecrease == 0) {\n            batches[_batchAddress].coll = _batchColl;\n        } else {\n            if (collIncrease > 0) {\n                // Add coll\n                batches[_batchAddress].coll = _batchColl + collIncrease;\n            } else if (collDecrease > 0) {\n                // Subtract coll\n                batches[_batchAddress].coll = _batchColl - collDecrease;\n            }\n        }\n    }\n\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        // Subtract from batch\n        _removeTroveSharesFromBatch(\n            _troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt\n        );\n\n        // Restore Trove state\n        Troves[_troveId].debt = _newTroveDebt;\n        Troves[_troveId].coll = _newTroveColl;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.removeFromBatch,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function _removeTroveSharesFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest and batch fee), but without trove change\n    ) internal {\n        // As we are removing:\n        // assert(_newBatchDebt > 0 || _newBatchColl > 0);\n\n        Trove memory trove = Troves[_troveId];\n\n        // We don’t need to increase the shares corresponding to redistribution first, because they would be subtracted immediately after\n        // We don’t need to account for interest nor batch fee because it’s proportional to debt shares\n        uint256 batchDebtDecrease = _newTroveDebt - _troveChange.upfrontFee - _troveChange.appliedRedistBoldDebtGain;\n        uint256 batchCollDecrease = _newTroveColl - _troveChange.appliedRedistCollGain;\n\n        batches[_batchAddress].totalDebtShares -= trove.batchDebtShares;\n        batches[_batchAddress].debt = _newBatchDebt - batchDebtDecrease;\n        batches[_batchAddress].coll = _newBatchColl - batchCollDecrease;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        Troves[_troveId].interestBatchManager = address(0);\n        Troves[_troveId].batchDebtShares = 0;\n    }\n}\n"
    }
}