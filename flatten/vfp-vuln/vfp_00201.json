{
    "vfp_id": "vfp_00201",
    "project_name": "Across Protocol Diff Audit -Arbitrum CustomGasToken & ExclusivityPeriod.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Wrong Scaling for Amount of Gas Tokens",
            "description": "The `Arbitrum_CustomGasToken_Adapter` contract incorrectly calculates the amount of custom gas tokens needed for L1-to-L2 operations by using an 18-decimal scale in the `getL1CallValue` function, regardless of the actual decimals of the custom gas token. This is a critical vulnerability because the formula `L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit` returns a value scaled to 18 decimals, which is then directly used to withdraw tokens from the `CUSTOM_GAS_TOKEN_FUNDER` contract and passed to Arbitrum's `createRetryableTicket`. If the custom gas token (e.g., USDC with 6 decimals) has fewer than 18 decimals, the contract will withdraw and attempt to use an amount inflated by a factor of 10^12, leading to a massive overcharge. The root cause is the lack of decimal scaling adjustment based on the token's actual precision. An attacker could exploit this by initiating a relay that forces the contract to pull excessive funds, potentially draining the funder contract. The impact includes significant financial loss due to over-withdrawal of gas tokens and failure of transactions due to insufficient balance after over-allocation.\n",
            "severity": "Critical",
            "location": [
                "Arbitrum_CustomGasToken_Adapter.sol::getL1CallValue#285",
                "Arbitrum_CustomGasToken_Adapter.sol::_pullCustomGas#284",
                "Arbitrum_CustomGasToken_Adapter.sol::relayTokens#221",
                "Arbitrum_CustomGasToken_Adapter.sol::relayMessage#195"
            ],
            "files": [
                "contracts/contracts/chain-adapters/Arbitrum_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1357"
                ]
            },
            "title": "Outdated `SafeERC20` Contract Does Not Approve to Zero First",
            "description": "The `Arbitrum_CustomGasToken_Adapter` contract uses an outdated version of OpenZeppelin's `SafeERC20` library that does not set an ERC-20 spender's allowance to zero before calling `approve` with a new value. This creates a potential issue with tokens like USDT that require the allowance to be reset to zero before being increased, as they may revert if the current allowance is non-zero. The root cause is the use of an older version of the library that lacks this safety check. An attacker could potentially exploit this by manipulating the allowance state to cause a revert during a legitimate operation, leading to a denial of service for certain token transfers. The impact is limited to transaction failure for tokens with strict approval logic, which could disrupt protocol operations but does not lead to direct fund loss.\n",
            "severity": "Medium",
            "location": [
                "Arbitrum_CustomGasToken_Adapter.sol#255"
            ],
            "files": [
                "contracts/contracts/chain-adapters/Arbitrum_CustomGasToken_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "Arbitrum_CustomGasToken_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\n\ninterface FunderInterface {\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\n * used as native currency on L2.\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\n *       - The token can't be rebasing or have a transfer fee\n *       - The token must only be transferrable via a call to the token address itself\n *       - The token must only be able to set allowance via a call to the token address itself\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\n *       - The token must have a max of 2^256 - 1 wei total supply unscaled\n *       - The token must have a max of 2^256 - 1 wei total supply when scaled to 18 decimals\n */\ninterface ArbitrumL1ERC20Bridge {\n    /**\n     * @notice Returns token that is escrowed in bridge on L1 side and minted on L2 as native currency.\n     * @dev This function doesn't exist on the generic Bridge interface.\n     */\n    function nativeToken() external view returns (address);\n}\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ninterface ArbitrumL1InboxLike {\n    /**\n     * @dev we only use this function to check the native token used by the bridge, so we hardcode the interface\n     * to return an ArbitrumL1ERC20Bridge instead of a more generic Bridge interface.\n     */\n    function bridge() external view returns (ArbitrumL1ERC20Bridge);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @notice Overloads the `createRetryableTicket` function but is not payable, and should only be called when paying\n     * for L1 to L2 message using a custom gas token.\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on L2\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev In case of native token having non-18 decimals: tokenTotalFeeAmount is denominated in native token's decimals. All other value params - l2CallValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on L2.\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on L2.\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external returns (uint256);\n}\n\n/**\n * @notice Layer 1 Gateway contract for bridging standard ERC20s to Arbitrum.\n */\ninterface ArbitrumL1ERC20GatewayLike {\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum.\n     * @dev L2 address alias will not be applied to the following types of addresses on L1:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _l1Token L1 address of ERC20\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract),\n     * not subject to L2 aliasing. This account, or its L2 alias if it have code in L1, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransferCustomRefund(\n        address _l1Token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /**\n     * @notice get ERC20 gateway for token.\n     * @param _token ERC20 address.\n     * @return address of ERC20 gateway.\n     */\n    function getGateway(address _token) external view returns (address);\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @dev This contract is very similar to Arbitrum_Adapter but it allows the caller to pay for submission\n * fees using a custom gas token. This is required to support certain Arbitrum orbit L2s and L3s.\n * @dev This contract\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // Amount of gas token allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // ticketâ€™s calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    // @dev Unlike in Arbitrum_Adapter, this is immutable because we don't know what precision the custom gas token has.\n    uint256 public immutable L2_MAX_SUBMISSION_COST;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public constant L2_GAS_PRICE = 5e9; // 5 gWei\n\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    // This address on L2 receives extra gas token that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    // This token is used to pay for l1 to l2 messages if its configured by an Arbitrum orbit chain.\n    IERC20 public immutable CUSTOM_GAS_TOKEN;\n\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     * @param _customGasTokenFunder Contract that funds the custom gas token.\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2MaxSubmissionCost\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Arbitrum) {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n        CUSTOM_GAS_TOKEN = IERC20(L1_INBOX.bridge().nativeToken());\n        require(address(CUSTOM_GAS_TOKEN) != address(0), \"Invalid custom gas token\");\n        L2_MAX_SUBMISSION_COST = _l2MaxSubmissionCost;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of the custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n        CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), requiredL1TokenTotalFeeAmount);\n        L1_INBOX.createRetryableTicket(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            requiredL1TokenTotalFeeAmount, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n            message // data ABI encoded data of L2 message\n        );\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH or custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n\n            // If custom gas token, call special functions that handle paying with custom gas tokens.\n            uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n            // Must use Inbox to bridge custom gas token.\n            // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L33\n            if (l1Token == address(CUSTOM_GAS_TOKEN)) {\n                uint256 amountToBridge = amount + requiredL1TokenTotalFeeAmount;\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), amountToBridge);\n                L1_INBOX.createRetryableTicket(\n                    to, // destAddr destination L2 contract address\n                    L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n                    L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n                    L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n                    L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n                    RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n                    L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n                    amountToBridge, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n                    \"0x\" // data ABI encoded data of L2 message\n                );\n            } else {\n                IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(erc20Gateway, requiredL1TokenTotalFeeAmount);\n\n                // To pay for gateway outbound transfer with custom gas token, encode the tokenTotalFeeAmount in the data field:\n                // The data format should be (uint256 maxSubmissionCost, bytes extraData, uint256 tokenTotalFeeAmount).\n                // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L57\n                bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\", requiredL1TokenTotalFeeAmount);\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of gas token to send a message via the Inbox.\n     * @return amount of gas token that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public view returns (uint256) {\n        return L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit;\n    }\n\n    function _pullCustomGas(uint32 l2GasLimit) internal returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(CUSTOM_GAS_TOKEN, requiredL1CallValue);\n        require(CUSTOM_GAS_TOKEN.balanceOf(address(this)) >= requiredL1CallValue, \"Insufficient gas balance\");\n        return requiredL1CallValue;\n    }\n}\n"
    }
}