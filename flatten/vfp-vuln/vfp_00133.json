{
    "vfp_id": "vfp_00133",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Zappers Can Lose User Funds",
            "description": "When users repay debt via zapper functions, if the repayment would bring the trove below MIN_DEBT, only a partial amount is repaid, and the remainder stays locked in the zapper contract. The cause is the logic in _adjustTrove that silently reduces the repayment amount without refunding excess. An attacker can front-run a large repayment by redeeming the target trove down to just above MIN_DEBT, causing nearly the entire repayment amount to be trapped. The impact is significant loss of user funds, especially in large repayments, and creates an attack vector where malicious actors can profit by backrunning and extracting stuck funds. This undermines user trust and fund safety.\n",
            "severity": "High",
            "location": [
                "BorrowerOperations.sol::_adjustTrove",
                "Zapper contracts::adjust",
                "Zapper contracts::repay"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        }
    ],
    "affected_files": {
        "BorrowerOperations.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/AddRemoveManagers.sol\";\nimport \"./Types/LatestTroveData.sol\";\nimport \"./Types/LatestBatchData.sol\";\n\ncontract BorrowerOperations is LiquityBase, AddRemoveManagers, IBorrowerOperations {\n    using SafeERC20 for IERC20;\n\n    // --- Connected contract declarations ---\n\n    IERC20 internal immutable collToken;\n    ITroveManager internal troveManager;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n    bool public hasBeenShutDown;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    // Extra buffer of collateral ratio to join a batch or adjust a trove inside a batch (on top of MCR)\n    uint256 public immutable BCR;\n\n    /*\n    * Mapping from TroveId to individual delegate for interest rate setting.\n    *\n    * This address then has the ability to update the borrower’s interest rate, but not change its debt or collateral.\n    * Useful for instance for cold/hot wallet setups.\n    */\n    mapping(uint256 => InterestIndividualDelegate) private interestIndividualDelegateOf;\n\n    /*\n     * Mapping from TroveId to granted address for interest rate setting (batch manager).\n     *\n     * Batch managers set the interest rate for every Trove in the batch. The interest rate is the same for all Troves in the batch.\n     */\n    mapping(uint256 => address) public interestBatchManagerOf;\n\n    // List of registered Interest Batch Managers\n    mapping(address => InterestBatchManager) private interestBatchManagers;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct OpenTroveVars {\n        ITroveManager troveManager;\n        uint256 troveId;\n        TroveChange change;\n        LatestBatchData batch;\n    }\n\n    struct LocalVariables_openTrove {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IBoldToken boldToken;\n        uint256 troveId;\n        uint256 price;\n        uint256 avgInterestRate;\n        uint256 entireDebt;\n        uint256 ICR;\n        uint256 newTCR;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_adjustTrove {\n        IActivePool activePool;\n        IBoldToken boldToken;\n        LatestTroveData trove;\n        uint256 price;\n        bool isBelowCriticalThreshold;\n        uint256 newICR;\n        uint256 newDebt;\n        uint256 newColl;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_setInterestBatchManager {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ISortedTroves sortedTroves;\n        address oldBatchManager;\n        LatestTroveData trove;\n        LatestBatchData oldBatch;\n        LatestBatchData newBatch;\n    }\n\n    struct LocalVariables_removeFromBatch {\n        ITroveManager troveManager;\n        ISortedTroves sortedTroves;\n        address batchManager;\n        LatestTroveData trove;\n        LatestBatchData batch;\n        uint256 batchFutureDebt;\n        TroveChange batchChange;\n    }\n\n    error IsShutDown();\n    error TCRNotBelowSCR();\n    error ZeroAdjustment();\n    error NotOwnerNorInterestManager();\n    error TroveInBatch();\n    error TroveNotInBatch();\n    error InterestNotInRange();\n    error BatchInterestRateChangePeriodNotPassed();\n    error DelegateInterestRateChangePeriodNotPassed();\n    error TroveExists();\n    error TroveNotOpen();\n    error TroveNotActive();\n    error TroveNotZombie();\n    error TroveWithZeroDebt();\n    error UpfrontFeeTooHigh();\n    error ICRBelowMCR();\n    error ICRBelowMCRPlusBCR();\n    error RepaymentNotMatchingCollWithdrawal();\n    error TCRBelowCCR();\n    error DebtBelowMin();\n    error CollWithdrawalTooHigh();\n    error NotEnoughBoldBalance();\n    error InterestRateTooLow();\n    error InterestRateTooHigh();\n    error InterestRateNotNew();\n    error InvalidInterestBatchManager();\n    error BatchManagerExists();\n    error BatchManagerNotNew();\n    error NewFeeNotLower();\n    error CallerNotTroveManager();\n    error CallerNotPriceFeed();\n    error MinGeMax();\n    error AnnualManagementFeeTooHigh();\n    error MinInterestRateChangePeriodTooLow();\n    error NewOracleFailureDetected();\n    error BatchSharesRatioTooLow();\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n\n    event ShutDown(uint256 _tcr);\n\n    constructor(IAddressesRegistry _addressesRegistry)\n        AddRemoveManagers(_addressesRegistry)\n        LiquityBase(_addressesRegistry)\n    {\n        // This makes impossible to open a trove with zero withdrawn Bold\n        assert(MIN_DEBT > 0);\n\n        collToken = _addressesRegistry.collToken();\n\n        WETH = _addressesRegistry.WETH();\n\n        CCR = _addressesRegistry.CCR();\n        SCR = _addressesRegistry.SCR();\n        MCR = _addressesRegistry.MCR();\n        BCR = _addressesRegistry.BCR();\n\n        troveManager = _addressesRegistry.troveManager();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit BoldTokenAddressChanged(address(boldToken));\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(address(activePool), type(uint256).max);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external override returns (uint256) {\n        _requireValidAnnualInterestRate(_annualInterestRate);\n\n        OpenTroveVars memory vars;\n\n        vars.troveId = _openTrove(\n            _owner,\n            _ownerIndex,\n            _collAmount,\n            _boldAmount,\n            _annualInterestRate,\n            address(0),\n            0,\n            0,\n            _maxUpfrontFee,\n            _addManager,\n            _removeManager,\n            _receiver,\n            vars.change\n        );\n\n        // Set the stored Trove properties and mint the NFT\n        troveManager.onOpenTrove(_owner, vars.troveId, vars.change, _annualInterestRate);\n\n        sortedTroves.insert(vars.troveId, _annualInterestRate, _upperHint, _lowerHint);\n\n        return vars.troveId;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        override\n        returns (uint256)\n    {\n        _requireValidInterestBatchManager(_params.interestBatchManager);\n\n        OpenTroveVars memory vars;\n        vars.troveManager = troveManager;\n\n        vars.batch = vars.troveManager.getLatestBatchData(_params.interestBatchManager);\n\n        // We set old weighted values here, as it’s only necessary for batches, so we don’t need to pass them to _openTrove func\n        vars.change.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.change.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.change.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.troveId = _openTrove(\n            _params.owner,\n            _params.ownerIndex,\n            _params.collAmount,\n            _params.boldAmount,\n            vars.batch.annualInterestRate,\n            _params.interestBatchManager,\n            vars.batch.entireDebtWithoutRedistribution,\n            vars.batch.annualManagementFee,\n            _params.maxUpfrontFee,\n            _params.addManager,\n            _params.removeManager,\n            _params.receiver,\n            vars.change\n        );\n\n        interestBatchManagerOf[vars.troveId] = _params.interestBatchManager;\n\n        // Set the stored Trove properties and mint the NFT\n        vars.troveManager.onOpenTroveAndJoinBatch(\n            _params.owner,\n            vars.troveId,\n            vars.change,\n            _params.interestBatchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution\n        );\n\n        sortedTroves.insertIntoBatch(\n            vars.troveId,\n            BatchId.wrap(_params.interestBatchManager),\n            vars.batch.annualInterestRate,\n            _params.upperHint,\n            _params.lowerHint\n        );\n\n        return vars.troveId;\n    }\n\n    function _openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _annualInterestRate,\n        address _interestBatchManager,\n        uint256 _batchEntireDebt,\n        uint256 _batchManagementAnnualFee,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver,\n        TroveChange memory _change\n    ) internal returns (uint256) {\n        _requireIsNotShutDown();\n\n        LocalVariables_openTrove memory vars;\n\n        // stack too deep not allowing to reuse troveManager from outer functions\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n\n        // --- Checks ---\n\n        vars.troveId = uint256(keccak256(abi.encode(msg.sender, _owner, _ownerIndex)));\n        _requireTroveDoesNotExists(vars.troveManager, vars.troveId);\n\n        _change.collIncrease = _collAmount;\n        _change.debtIncrease = _boldAmount;\n\n        // For simplicity, we ignore the fee when calculating the approx. interest rate\n        _change.newWeightedRecordedDebt = (_batchEntireDebt + _change.debtIncrease) * _annualInterestRate;\n\n        vars.avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_change);\n        _change.upfrontFee = _calcUpfrontFee(_change.debtIncrease, vars.avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_change.upfrontFee, _maxUpfrontFee);\n\n        vars.entireDebt = _change.debtIncrease + _change.upfrontFee;\n        _requireAtLeastMinDebt(vars.entireDebt);\n\n        vars.ICR = LiquityMath._computeCR(_collAmount, vars.entireDebt, vars.price);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee, and the batch fee if needed\n        if (_interestBatchManager == address(0)) {\n            _change.newWeightedRecordedDebt = vars.entireDebt * _annualInterestRate;\n\n            // ICR is based on the requested Bold amount + upfront fee.\n            _requireICRisAboveMCR(vars.ICR);\n        } else {\n            // old values have been set outside, before calling this function\n            _change.newWeightedRecordedDebt = (_batchEntireDebt + vars.entireDebt) * _annualInterestRate;\n            _change.newWeightedRecordedBatchManagementFee =\n                (_batchEntireDebt + vars.entireDebt) * _batchManagementAnnualFee;\n\n            // ICR is based on the requested Bold amount + upfront fee.\n            // Troves in a batch have a stronger requirement (MCR+BCR)\n            _requireICRisAboveMCRPlusBCR(vars.ICR);\n        }\n\n        vars.newTCR = _getNewTCRFromTroveChange(_change, vars.price);\n        _requireNewTCRisAboveCCR(vars.newTCR);\n\n        // --- Effects & interactions ---\n\n        // Set add/remove managers\n        _setAddManager(vars.troveId, _addManager);\n        _setRemoveManagerAndReceiver(vars.troveId, _removeManager, _receiver);\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_change, _interestBatchManager);\n\n        // Pull coll tokens from sender and move them to the Active Pool\n        _pullCollAndSendToActivePool(vars.activePool, _collAmount);\n\n        // Mint the requested _boldAmount to the borrower and mint the gas comp to the GasPool\n        vars.boldToken.mint(msg.sender, _boldAmount);\n        WETH.transferFrom(msg.sender, gasPoolAddress, ETH_GAS_COMPENSATION);\n\n        return vars.troveId;\n    }\n\n    // Send collateral to a trove\n    function addColl(uint256 _troveId, uint256 _collAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collIncrease = _collAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(uint256 _troveId, uint256 _collWithdrawal) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = _collWithdrawal;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw Bold tokens from a trove: mint new Bold tokens to the owner, and increase the trove's debt accordingly\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtIncrease = _boldAmount;\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    // Repay Bold tokens to a Trove: Burn the repaid Bold tokens, and reduce the trove's debt accordingly\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtDecrease = _boldAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    function _initTroveChange(\n        TroveChange memory _troveChange,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease\n    ) internal pure {\n        if (_isCollIncrease) {\n            _troveChange.collIncrease = _collChange;\n        } else {\n            _troveChange.collDecrease = _collChange;\n        }\n\n        if (_isDebtIncrease) {\n            _troveChange.debtIncrease = _boldChange;\n        } else {\n            _troveChange.debtDecrease = _boldChange;\n        }\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    function adjustZombieTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsZombie(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n\n        troveManagerCached.setTroveStatusToActive(_troveId);\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        uint256 batchAnnualInterestRate;\n        if (batchManager != address(0)) {\n            LatestBatchData memory batch = troveManagerCached.getLatestBatchData(batchManager);\n            batchAnnualInterestRate = batch.annualInterestRate;\n        }\n        _reInsertIntoSortedTroves(\n            _troveId,\n            troveManagerCached.getTroveAnnualInterestRate(_troveId),\n            _upperHint,\n            _lowerHint,\n            batchManager,\n            batchAnnualInterestRate\n        );\n    }\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        _requireIsNotInBatch(_troveId);\n        _requireSenderIsOwnerOrInterestManager(_troveId);\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireValidDelegateAdustment(_troveId, trove.lastInterestRateAdjTime, _newAnnualInterestRate);\n        _requireAnnualInterestRateIsNew(trove.annualInterestRate, _newAnnualInterestRate);\n\n        uint256 newDebt = trove.entireDebt;\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n\n        // Apply upfront fee on premature adjustments. It checks the resulting ICR\n        if (block.timestamp < trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            newDebt = _applyUpfrontFee(trove.entireColl, newDebt, troveChange, _maxUpfrontFee, false);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n\n        activePool.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        sortedTroves.reInsert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        troveManagerCached.onAdjustTroveInterestRate(\n            _troveId, trove.entireColl, newDebt, _newAnnualInterestRate, troveChange\n        );\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    */\n    function _adjustTrove(\n        ITroveManager _troveManager,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_adjustTrove memory vars;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n        vars.isBelowCriticalThreshold = _checkBelowCriticalThreshold(vars.price, CCR);\n\n        // --- Checks ---\n\n        _requireTroveIsOpen(_troveManager, _troveId);\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = owner; // If it’s a withdrawal, and remove manager privilege is set, a different receiver can be defined\n\n        if (_troveChange.collDecrease > 0 || _troveChange.debtIncrease > 0) {\n            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        } else {\n            // RemoveManager assumes AddManager, so if the former is set, there's no need to check the latter\n            _requireSenderIsOwnerOrAddManager(_troveId, owner);\n            // No need to check the type of trove change for two reasons:\n            // - If the check above fails, it means sender is not owner, nor AddManager, nor RemoveManager.\n            //   An independent 3rd party should not be allowed here.\n            // - If it's not collIncrease or debtDecrease, _requireNonZeroAdjustment would revert\n        }\n\n        vars.trove = _troveManager.getLatestTroveData(_troveId);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Bold\n        if (_troveChange.debtDecrease > 0) {\n            uint256 maxRepayment = vars.trove.entireDebt > MIN_DEBT ? vars.trove.entireDebt - MIN_DEBT : 0;\n            if (_troveChange.debtDecrease > maxRepayment) {\n                _troveChange.debtDecrease = maxRepayment;\n            }\n            _requireSufficientBoldBalance(vars.boldToken, msg.sender, _troveChange.debtDecrease);\n        }\n\n        _requireNonZeroAdjustment(_troveChange);\n\n        // When the adjustment is a collateral withdrawal, check that it's no more than the Trove's entire collateral\n        if (_troveChange.collDecrease > 0) {\n            _requireValidCollWithdrawal(vars.trove.entireColl, _troveChange.collDecrease);\n        }\n\n        vars.newColl = vars.trove.entireColl + _troveChange.collIncrease - _troveChange.collDecrease;\n        vars.newDebt = vars.trove.entireDebt + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        bool isTroveInBatch = batchManager != address(0);\n        LatestBatchData memory batch;\n        uint256 batchFutureDebt;\n        if (isTroveInBatch) {\n            batch = _troveManager.getLatestBatchData(batchManager);\n\n            batchFutureDebt = batch.entireDebtWithoutRedistribution + vars.trove.redistBoldDebtGain\n                + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            _troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            _troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.oldWeightedRecordedDebt = vars.trove.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n        }\n\n        // Pay an upfront fee on debt increases\n        if (_troveChange.debtIncrease > 0) {\n            uint256 avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n            _troveChange.upfrontFee = _calcUpfrontFee(_troveChange.debtIncrease, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n            vars.newDebt += _troveChange.upfrontFee;\n            if (isTroveInBatch) {\n                batchFutureDebt += _troveChange.upfrontFee;\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n                _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n            } else {\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n            }\n        }\n\n        // Make sure the Trove doesn't end up zombie\n        // Now the max repayment is capped to stay above MIN_DEBT, so this only applies to adjustZombieTrove\n        _requireAtLeastMinDebt(vars.newDebt);\n\n        vars.newICR = LiquityMath._computeCR(vars.newColl, vars.newDebt, vars.price);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(_troveChange, vars, isTroveInBatch);\n\n        // --- Effects and interactions ---\n\n        if (isTroveInBatch) {\n            _troveManager.onAdjustTroveInsideBatch(\n                _troveId,\n                vars.newColl,\n                vars.newDebt,\n                _troveChange,\n                batchManager,\n                batch.entireCollWithoutRedistribution,\n                batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _troveManager.onAdjustTrove(_troveId, vars.newColl, vars.newDebt, _troveChange);\n        }\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_troveChange, batchManager);\n        _moveTokensFromAdjustment(receiver, _troveChange, vars.boldToken, vars.activePool);\n    }\n\n    function closeTrove(uint256 _troveId) external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IBoldToken boldTokenCached = boldToken;\n\n        // --- Checks ---\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n\n        // The borrower must repay their entire debt including accrued interest, batch fee and redist. gains\n        _requireSufficientBoldBalance(boldTokenCached, msg.sender, trove.entireDebt);\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n        if (batchManager != address(0)) {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            uint256 batchFutureDebt =\n                batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain);\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            // troveChange.newWeightedRecordedDebt = 0;\n        }\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        uint256 newTCR = _getNewTCRFromTroveChange(troveChange, price);\n        if (!hasBeenShutDown) _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.onCloseTrove(\n            _troveId,\n            troveChange,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution\n        );\n\n        // If trove is in batch\n        if (batchManager != address(0)) {\n            // Unlink here in BorrowerOperations\n            interestBatchManagerOf[_troveId] = address(0);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, batchManager);\n\n        // Return ETH gas compensation\n        WETH.transferFrom(gasPoolAddress, receiver, ETH_GAS_COMPENSATION);\n        // Burn the remainder of the Trove's entire debt from the user\n        boldTokenCached.burn(msg.sender, trove.entireDebt);\n\n        // Send the collateral back to the user\n        activePoolCached.sendColl(receiver, trove.entireColl);\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) public {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireNonZeroDebt(trove.entireDebt);\n\n        TroveChange memory change;\n        change.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        change.appliedRedistCollGain = trove.redistCollGain;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n\n        if (batchManager == address(0)) {\n            change.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            change.newWeightedRecordedDebt = trove.entireDebt * trove.annualInterestRate;\n        } else {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            change.batchAccruedManagementFee = batch.accruedManagementFee;\n            change.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            change.newWeightedRecordedDebt =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualInterestRate;\n            change.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            change.newWeightedRecordedBatchManagementFee =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualManagementFee;\n        }\n\n        troveManagerCached.onApplyTroveInterest(\n            _troveId,\n            trove.entireColl,\n            trove.entireDebt,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            change\n        );\n        activePool.mintAggInterestAndAccountForTroveChange(change, batchManager);\n\n        // If the trove was zombie, and now it’s not anymore, put it back in the list\n        if (_checkTroveIsZombie(troveManagerCached, _troveId) && trove.entireDebt >= MIN_DEBT) {\n            troveManagerCached.setTroveStatusToActive(_troveId);\n            _reInsertIntoSortedTroves(\n                _troveId, trove.annualInterestRate, _upperHint, _lowerHint, batchManager, batch.annualInterestRate\n            );\n        }\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory)\n    {\n        return interestIndividualDelegateOf[_troveId];\n    }\n\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee,\n        uint256 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireTroveIsActive(troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        _requireOrderedRange(_minInterestRate, _maxInterestRate);\n\n        interestIndividualDelegateOf[_troveId] =\n            InterestIndividualDelegate(_delegate, _minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n        // Can’t have both individual delegation and batch manager\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            // Not needed, implicitly checked in removeFromBatch\n            //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n            removeFromBatch(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);\n        }\n    }\n\n    function removeInterestIndividualDelegate(uint256 _troveId) external {\n        _requireCallerIsBorrower(_troveId);\n        delete interestIndividualDelegateOf[_troveId];\n    }\n\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory) {\n        return interestBatchManagers[_account];\n    }\n\n    function registerBatchManager(\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        uint128 _currentInterestRate,\n        uint128 _annualManagementFee,\n        uint128 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireNonExistentInterestBatchManager(msg.sender);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        _requireOrderedRange(_minInterestRate, _maxInterestRate);\n        _requireInterestRateInRange(_currentInterestRate, _minInterestRate, _maxInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_currentInterestRate);\n        if (_annualManagementFee > MAX_ANNUAL_BATCH_MANAGEMENT_FEE) revert AnnualManagementFeeTooHigh();\n        if (_minInterestRateChangePeriod < MIN_INTEREST_RATE_CHANGE_PERIOD) revert MinInterestRateChangePeriodTooLow();\n\n        interestBatchManagers[msg.sender] =\n            InterestBatchManager(_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n\n        troveManager.onRegisterBatchManager(msg.sender, _currentInterestRate, _annualManagementFee);\n    }\n\n    function lowerBatchManagementFee(uint256 _newAnnualManagementFee) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n\n        ITroveManager troveManagerCached = troveManager;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        if (_newAnnualManagementFee >= batch.annualManagementFee) {\n            revert NewFeeNotLower();\n        }\n\n        // Lower batch fee on TM\n        troveManagerCached.onLowerBatchManagerAnnualFee(\n            msg.sender,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            _newAnnualManagementFee\n        );\n\n        // active pool mint\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * _newAnnualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n    }\n\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n        _requireInterestRateInBatchManagerRange(msg.sender, _newAnnualInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        _requireBatchInterestRateChangePeriodPassed(msg.sender, uint256(batch.lastInterestRateAdjTime));\n\n        uint256 newDebt = batch.entireDebtWithoutRedistribution;\n\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            uint256 price = _requireOraclesLive();\n\n            uint256 avgInterestRate = activePoolCached.getNewApproxAvgInterestRateFromTroveChange(batchChange);\n            batchChange.upfrontFee = _calcUpfrontFee(newDebt, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(batchChange.upfrontFee, _maxUpfrontFee);\n\n            newDebt += batchChange.upfrontFee;\n\n            // Recalculate the batch's weighted terms, now taking into account the upfront fee\n            batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n            batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n            // Disallow a premature adjustment if it would result in TCR < CCR\n            // (which includes the case when TCR is already below CCR before the adjustment).\n            uint256 newTCR = _getNewTCRFromTroveChange(batchChange, price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n\n        // Check batch is not empty, and then reinsert in sorted list\n        if (!sortedTroves.isEmptyBatch(BatchId.wrap(msg.sender))) {\n            sortedTroves.reInsertBatch(BatchId.wrap(msg.sender), _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        troveManagerCached.onSetBatchManagerAnnualInterestRate(\n            msg.sender, batch.entireCollWithoutRedistribution, newDebt, _newAnnualInterestRate, batchChange.upfrontFee\n        );\n    }\n\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n        LocalVariables_setInterestBatchManager memory vars;\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidInterestBatchManager(_newBatchManager);\n        _requireIsNotInBatch(_troveId);\n\n        interestBatchManagerOf[_troveId] = _newBatchManager;\n        // Can’t have both individual delegation and batch manager\n        if (interestIndividualDelegateOf[_troveId].account != address(0)) delete interestIndividualDelegateOf[_troveId];\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.newBatch = vars.troveManager.getLatestBatchData(_newBatchManager);\n\n        TroveChange memory newBatchTroveChange;\n        newBatchTroveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        newBatchTroveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        newBatchTroveChange.batchAccruedManagementFee = vars.newBatch.accruedManagementFee;\n        newBatchTroveChange.oldWeightedRecordedDebt =\n            vars.newBatch.weightedRecordedDebt + vars.trove.weightedRecordedDebt;\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // An upfront fee is always charged upon joining a batch to ensure that borrowers can not game the fee logic\n        // and gain free interest rate updates (e.g. if they also manage the batch they joined)\n        // It checks the resulting ICR\n        vars.trove.entireDebt =\n            _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, newBatchTroveChange, _maxUpfrontFee, true);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // Add batch fees\n        newBatchTroveChange.oldWeightedRecordedBatchManagementFee = vars.newBatch.weightedRecordedBatchManagementFee;\n        newBatchTroveChange.newWeightedRecordedBatchManagementFee =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualManagementFee;\n        vars.activePool.mintAggInterestAndAccountForTroveChange(newBatchTroveChange, _newBatchManager);\n\n        vars.troveManager.onSetInterestBatchManager(\n            ITroveManager.OnSetInterestBatchManagerParams({\n                troveId: _troveId,\n                troveColl: vars.trove.entireColl,\n                troveDebt: vars.trove.entireDebt,\n                troveChange: newBatchTroveChange,\n                newBatchAddress: _newBatchManager,\n                newBatchColl: vars.newBatch.entireCollWithoutRedistribution,\n                newBatchDebt: vars.newBatch.entireDebtWithoutRedistribution\n            })\n        );\n\n        vars.sortedTroves.remove(_troveId);\n        vars.sortedTroves.insertIntoBatch(\n            _troveId, BatchId.wrap(_newBatchManager), vars.newBatch.annualInterestRate, _upperHint, _lowerHint\n        );\n    }\n\n    function kickFromBatch(uint256 _troveId, uint256 _upperHint, uint256 _lowerHint) external override {\n        _removeFromBatch({\n            _troveId: _troveId,\n            _newAnnualInterestRate: 0, // ignored when kicking\n            _upperHint: _upperHint,\n            _lowerHint: _lowerHint,\n            _maxUpfrontFee: 0, // will use the batch's existing interest rate, so no fee\n            _kick: true\n        });\n    }\n\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _removeFromBatch({\n            _troveId: _troveId,\n            _newAnnualInterestRate: _newAnnualInterestRate,\n            _upperHint: _upperHint,\n            _lowerHint: _lowerHint,\n            _maxUpfrontFee: _maxUpfrontFee,\n            _kick: false\n        });\n    }\n\n    function _removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee,\n        bool _kick\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_removeFromBatch memory vars;\n        vars.troveManager = troveManager;\n        vars.sortedTroves = sortedTroves;\n\n        if (_kick) {\n            _requireTroveIsOpen(vars.troveManager, _troveId);\n        } else {\n            _requireTroveIsActive(vars.troveManager, _troveId);\n            _requireCallerIsBorrower(_troveId);\n            _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        }\n\n        vars.batchManager = _requireIsInBatch(_troveId);\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.batch = vars.troveManager.getLatestBatchData(vars.batchManager);\n\n        if (_kick) {\n            if (vars.batch.totalDebtShares * MAX_BATCH_SHARES_RATIO >= vars.batch.entireDebtWithoutRedistribution) {\n                revert BatchSharesRatioTooLow();\n            }\n            _newAnnualInterestRate = vars.batch.annualInterestRate;\n        }\n\n        delete interestBatchManagerOf[_troveId];\n\n        if (!_checkTroveIsZombie(vars.troveManager, _troveId)) {\n            // Remove trove from Batch in SortedTroves\n            vars.sortedTroves.removeFromBatch(_troveId);\n            // Reinsert as single trove\n            vars.sortedTroves.insert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        vars.batchFutureDebt =\n            vars.batch.entireDebtWithoutRedistribution - (vars.trove.entireDebt - vars.trove.redistBoldDebtGain);\n\n        vars.batchChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        vars.batchChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        vars.batchChange.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.batchChange.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.batchChange.newWeightedRecordedDebt =\n            vars.batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;\n\n        // Apply upfront fee on premature adjustments. It checks the resulting ICR\n        if (\n            vars.batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, vars.batchChange, _maxUpfrontFee, false);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        vars.batchChange.newWeightedRecordedDebt =\n            vars.batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;\n        // Add batch fees\n        vars.batchChange.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.batchChange.newWeightedRecordedBatchManagementFee = vars.batchFutureDebt * vars.batch.annualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(vars.batchChange, vars.batchManager);\n\n        vars.troveManager.onRemoveFromBatch(\n            _troveId,\n            vars.trove.entireColl,\n            vars.trove.entireDebt,\n            vars.batchChange,\n            vars.batchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution,\n            _newAnnualInterestRate\n        );\n    }\n\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        address oldBatchManager = _requireIsInBatch(_troveId);\n        _requireNewInterestBatchManager(oldBatchManager, _newBatchManager);\n\n        LatestBatchData memory oldBatch = troveManager.getLatestBatchData(oldBatchManager);\n\n        removeFromBatch(_troveId, oldBatch.annualInterestRate, _removeUpperHint, _removeLowerHint, 0);\n        setInterestBatchManager(_troveId, _newBatchManager, _addUpperHint, _addLowerHint, _maxUpfrontFee);\n    }\n\n    function _applyUpfrontFee(\n        uint256 _troveEntireColl,\n        uint256 _troveEntireDebt,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        uint256 price = _requireOraclesLive();\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n        _troveChange.upfrontFee = _calcUpfrontFee(_troveEntireDebt, avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n        _troveEntireDebt += _troveChange.upfrontFee;\n\n        // ICR is based on the requested Bold amount + upfront fee.\n        uint256 newICR = LiquityMath._computeCR(_troveEntireColl, _troveEntireDebt, price);\n        if (_isTroveInBatch) {\n            _requireICRisAboveMCRPlusBCR(newICR);\n        } else {\n            _requireICRisAboveMCR(newICR);\n        }\n\n        // Disallow a premature adjustment if it would result in TCR < CCR\n        // (which includes the case when TCR is already below CCR before the adjustment).\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        return _troveEntireDebt;\n    }\n\n    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {\n        return _calcInterest(_debt * _avgInterestRate, UPFRONT_INTEREST_PERIOD);\n    }\n\n    // Call from TM to clean state here\n    function onLiquidateTrove(uint256 _troveId) external {\n        _requireCallerIsTroveManager();\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function _wipeTroveMappings(uint256 _troveId) internal {\n        delete interestIndividualDelegateOf[_troveId];\n        delete interestBatchManagerOf[_troveId];\n        _wipeAddRemoveManagers(_troveId);\n    }\n\n    /**\n     * Claim remaining collateral from a liquidation with ICR exceeding the liquidation penalty\n     */\n    function claimCollateral() external override {\n        // send coll from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    function shutdown() external {\n        if (hasBeenShutDown) revert IsShutDown();\n\n        uint256 totalColl = getEntireBranchColl();\n        uint256 totalDebt = getEntireBranchDebt();\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        // If the oracle failed, the above call to PriceFeed will have shut this branch down\n        if (newOracleFailureDetected) return;\n\n        // Otherwise, proceed with the TCR check:\n        uint256 TCR = LiquityMath._computeCR(totalColl, totalDebt, price);\n        if (TCR >= SCR) revert TCRNotBelowSCR();\n\n        _applyShutdown();\n\n        emit ShutDown(TCR);\n    }\n\n    // Not technically a \"Borrower op\", but seems best placed here given current shutdown logic.\n    function shutdownFromOracleFailure() external {\n        _requireCallerIsPriceFeed();\n\n        // No-op rather than revert here, so that the outer function call which fetches the price does not revert\n        // if the system is already shut down.\n        if (hasBeenShutDown) return;\n\n        _applyShutdown();\n    }\n\n    function _applyShutdown() internal {\n        activePool.mintAggInterest();\n        hasBeenShutDown = true;\n        troveManager.shutdown();\n    }\n\n    // --- Helper functions ---\n\n    function _reInsertIntoSortedTroves(\n        uint256 _troveId,\n        uint256 _troveAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        address _batchManager,\n        uint256 _batchAnnualInterestRate\n    ) internal {\n        // If it was in a batch, we need to put it back, otherwise we insert it normally\n        if (_batchManager == address(0)) {\n            sortedTroves.insert(_troveId, _troveAnnualInterestRate, _upperHint, _lowerHint);\n        } else {\n            sortedTroves.insertIntoBatch(\n                _troveId, BatchId.wrap(_batchManager), _batchAnnualInterestRate, _upperHint, _lowerHint\n            );\n        }\n    }\n\n    // This function mints the BOLD corresponding to the borrower's chosen debt increase\n    // (it does not mint the accrued interest).\n    function _moveTokensFromAdjustment(\n        address withdrawalReceiver,\n        TroveChange memory _troveChange,\n        IBoldToken _boldToken,\n        IActivePool _activePool\n    ) internal {\n        if (_troveChange.debtIncrease > 0) {\n            _boldToken.mint(withdrawalReceiver, _troveChange.debtIncrease);\n        } else if (_troveChange.debtDecrease > 0) {\n            _boldToken.burn(msg.sender, _troveChange.debtDecrease);\n        }\n\n        if (_troveChange.collIncrease > 0) {\n            // Pull coll tokens from sender and move them to the Active Pool\n            _pullCollAndSendToActivePool(_activePool, _troveChange.collIncrease);\n        } else if (_troveChange.collDecrease > 0) {\n            // Pull Coll from Active Pool and decrease its recorded Coll balance\n            _activePool.sendColl(withdrawalReceiver, _troveChange.collDecrease);\n        }\n    }\n\n    function _pullCollAndSendToActivePool(IActivePool _activePool, uint256 _amount) internal {\n        // Send Coll tokens from sender to active pool\n        collToken.safeTransferFrom(msg.sender, address(_activePool), _amount);\n        // Make sure Active Pool accountancy is right\n        _activePool.accountForReceivedColl(_amount);\n    }\n\n    function checkBatchManagerExists(address _batchManager) external view returns (bool) {\n        return interestBatchManagers[_batchManager].maxInterestRate > 0;\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireIsNotShutDown() internal view {\n        if (hasBeenShutDown) {\n            revert IsShutDown();\n        }\n    }\n\n    function _requireNonZeroAdjustment(TroveChange memory _troveChange) internal pure {\n        if (\n            _troveChange.collIncrease == 0 && _troveChange.collDecrease == 0 && _troveChange.debtIncrease == 0\n                && _troveChange.debtDecrease == 0\n        ) {\n            revert ZeroAdjustment();\n        }\n    }\n\n    function _requireSenderIsOwnerOrInterestManager(uint256 _troveId) internal view {\n        address owner = troveNFT.ownerOf(_troveId);\n        if (msg.sender != owner && msg.sender != interestIndividualDelegateOf[_troveId].account) {\n            revert NotOwnerNorInterestManager();\n        }\n    }\n\n    function _requireValidDelegateAdustment(\n        uint256 _troveId,\n        uint256 _lastInterestRateAdjTime,\n        uint256 _annualInterestRate\n    ) internal view {\n        InterestIndividualDelegate memory individualDelegate = interestIndividualDelegateOf[_troveId];\n        // We have previously checked that sender is either owner or delegate\n        // If it’s owner, this restriction doesn’t apply\n        if (individualDelegate.account == msg.sender) {\n            _requireInterestRateInRange(\n                _annualInterestRate, individualDelegate.minInterestRate, individualDelegate.maxInterestRate\n            );\n            _requireDelegateInterestRateChangePeriodPassed(\n                _lastInterestRateAdjTime, individualDelegate.minInterestRateChangePeriod\n            );\n        }\n    }\n\n    function _requireIsNotInBatch(uint256 _troveId) internal view {\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            revert TroveInBatch();\n        }\n    }\n\n    function _requireIsInBatch(uint256 _troveId) internal view returns (address) {\n        address batchManager = interestBatchManagerOf[_troveId];\n        if (batchManager == address(0)) {\n            revert TroveNotInBatch();\n        }\n\n        return batchManager;\n    }\n\n    function _requireTroveDoesNotExists(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.nonExistent) {\n            revert TroveExists();\n        }\n    }\n\n    function _requireTroveIsOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active && status != ITroveManager.Status.zombie) {\n            revert TroveNotOpen();\n        }\n    }\n\n    function _requireTroveIsActive(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active) {\n            revert TroveNotActive();\n        }\n    }\n\n    function _requireTroveIsZombie(ITroveManager _troveManager, uint256 _troveId) internal view {\n        if (!_checkTroveIsZombie(_troveManager, _troveId)) {\n            revert TroveNotZombie();\n        }\n    }\n\n    function _checkTroveIsZombie(ITroveManager _troveManager, uint256 _troveId) internal view returns (bool) {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        return status == ITroveManager.Status.zombie;\n    }\n\n    function _requireNonZeroDebt(uint256 _troveDebt) internal pure {\n        if (_troveDebt == 0) {\n            revert TroveWithZeroDebt();\n        }\n    }\n\n    function _requireUserAcceptsUpfrontFee(uint256 _fee, uint256 _maxFee) internal pure {\n        if (_fee > _maxFee) {\n            revert UpfrontFeeTooHigh();\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        TroveChange memory _troveChange,\n        LocalVariables_adjustTrove memory _vars,\n        bool _isTroveInBatch\n    ) internal view {\n        /*\n        * Below Critical Threshold, it is not permitted:\n        *\n        * - Borrowing, unless it brings TCR up to CCR again\n        * - Collateral withdrawal except accompanied by a debt repayment of at least the same value\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The adjustment won't pull the TCR below CCR\n        *\n        * In Both cases:\n        * - The new ICR is above MCR, or MCR+BCR if a batched trove\n        */\n\n        if (_isTroveInBatch) {\n            _requireICRisAboveMCRPlusBCR(_vars.newICR);\n        } else {\n            _requireICRisAboveMCR(_vars.newICR);\n        }\n\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, _vars.price);\n        if (_vars.isBelowCriticalThreshold) {\n            _requireNoBorrowingUnlessNewTCRisAboveCCR(_troveChange.debtIncrease, newTCR);\n            _requireDebtRepaymentGeCollWithdrawal(_troveChange, _vars.price);\n        } else {\n            // if Normal Mode\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal view {\n        if (_newICR < MCR) {\n            revert ICRBelowMCR();\n        }\n    }\n\n    function _requireICRisAboveMCRPlusBCR(uint256 _newICR) internal view {\n        if (_newICR < MCR + BCR) {\n            revert ICRBelowMCRPlusBCR();\n        }\n    }\n\n    function _requireNoBorrowingUnlessNewTCRisAboveCCR(uint256 _debtIncrease, uint256 _newTCR) internal view {\n        if (_debtIncrease > 0 && _newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireDebtRepaymentGeCollWithdrawal(TroveChange memory _troveChange, uint256 _price) internal pure {\n        if ((_troveChange.debtDecrease * DECIMAL_PRECISION < _troveChange.collDecrease * _price)) {\n            revert RepaymentNotMatchingCollWithdrawal();\n        }\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal view {\n        if (_newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireAtLeastMinDebt(uint256 _debt) internal pure {\n        if (_debt < MIN_DEBT) {\n            revert DebtBelowMin();\n        }\n    }\n\n    function _requireValidCollWithdrawal(uint256 _currentColl, uint256 _collWithdrawal) internal pure {\n        if (_collWithdrawal > _currentColl) {\n            revert CollWithdrawalTooHigh();\n        }\n    }\n\n    function _requireSufficientBoldBalance(IBoldToken _boldToken, address _borrower, uint256 _debtRepayment)\n        internal\n        view\n    {\n        if (_boldToken.balanceOf(_borrower) < _debtRepayment) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    function _requireValidAnnualInterestRate(uint256 _annualInterestRate) internal pure {\n        if (_annualInterestRate < MIN_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooLow();\n        }\n        if (_annualInterestRate > MAX_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooHigh();\n        }\n    }\n\n    function _requireAnnualInterestRateIsNew(uint256 _oldAnnualInterestRate, uint256 _newAnnualInterestRate)\n        internal\n        pure\n    {\n        if (_oldAnnualInterestRate == _newAnnualInterestRate) {\n            revert InterestRateNotNew();\n        }\n    }\n\n    function _requireOrderedRange(uint256 _minInterestRate, uint256 _maxInterestRate) internal pure {\n        if (_minInterestRate >= _maxInterestRate) revert MinGeMax();\n    }\n\n    function _requireInterestRateInBatchManagerRange(address _interestBatchManagerAddress, uint256 _annualInterestRate)\n        internal\n        view\n    {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        _requireInterestRateInRange(\n            _annualInterestRate, interestBatchManager.minInterestRate, interestBatchManager.maxInterestRate\n        );\n    }\n\n    function _requireInterestRateInRange(\n        uint256 _annualInterestRate,\n        uint256 _minInterestRate,\n        uint256 _maxInterestRate\n    ) internal pure {\n        if (_minInterestRate > _annualInterestRate || _annualInterestRate > _maxInterestRate) {\n            revert InterestNotInRange();\n        }\n    }\n\n    function _requireBatchInterestRateChangePeriodPassed(\n        address _interestBatchManagerAddress,\n        uint256 _lastInterestRateAdjTime\n    ) internal view {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        if (block.timestamp < _lastInterestRateAdjTime + uint256(interestBatchManager.minInterestRateChangePeriod)) {\n            revert BatchInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireDelegateInterestRateChangePeriodPassed(\n        uint256 _lastInterestRateAdjTime,\n        uint256 _minInterestRateChangePeriod\n    ) internal view {\n        if (block.timestamp < _lastInterestRateAdjTime + _minInterestRateChangePeriod) {\n            revert DelegateInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireValidInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate == 0) {\n            revert InvalidInterestBatchManager();\n        }\n    }\n\n    function _requireNonExistentInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate > 0) {\n            revert BatchManagerExists();\n        }\n    }\n\n    function _requireNewInterestBatchManager(address _oldBatchManagerAddress, address _newBatchManagerAddress)\n        internal\n        pure\n    {\n        if (_oldBatchManagerAddress == _newBatchManagerAddress) {\n            revert BatchManagerNotNew();\n        }\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        if (msg.sender != address(troveManager)) {\n            revert CallerNotTroveManager();\n        }\n    }\n\n    function _requireCallerIsPriceFeed() internal view {\n        if (msg.sender != address(priceFeed)) {\n            revert CallerNotPriceFeed();\n        }\n    }\n\n    function _requireOraclesLive() internal returns (uint256) {\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        if (newOracleFailureDetected) {\n            revert NewOracleFailureDetected();\n        }\n\n        return price;\n    }\n\n    // --- ICR and TCR getters ---\n\n    function _getNewTCRFromTroveChange(TroveChange memory _troveChange, uint256 _price)\n        internal\n        view\n        returns (uint256 newTCR)\n    {\n        uint256 totalColl = getEntireBranchColl();\n        totalColl += _troveChange.collIncrease;\n        totalColl -= _troveChange.collDecrease;\n\n        uint256 totalDebt = getEntireBranchDebt();\n        totalDebt += _troveChange.debtIncrease;\n        totalDebt += _troveChange.upfrontFee;\n        totalDebt -= _troveChange.debtDecrease;\n\n        newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n    }\n}\n"
    }
}