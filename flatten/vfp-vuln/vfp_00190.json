{
    "vfp_id": "vfp_00190",
    "project_name": "cantina_horizen_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "Excessive admin controls in LinearTokenVesting could break vesting invariants",
            "description": "The LinearTokenVesting.sol contract grants excessive administrative privileges that can compromise the integrity of the vesting schedule. The changeVestingParams() function allows the admin to modify critical parameters such as timeBetweenClaims and intervalsToClaim with arbitrary values. This creates two potential vulnerabilities: first, the admin can instantly release 100% of the remaining tokens by setting both parameters to 1, effectively bypassing the vesting schedule. Second, a malicious admin can prevent users from claiming tokens by repeatedly resetting the vesting period just before claims are due, resulting in a denial-of-service condition. The root cause is the lack of immutability or restrictions on admin privileges after deployment. This could lead to loss of user trust and potential financial harm if admin keys are compromised.\n",
            "severity": "Medium",
            "location": [
                "LinearTokenVesting.sol::changeVestingParams"
            ],
            "files": [
                "horizen-migration/erc20-migration/contracts/LinearTokenVesting.sol"
            ]
        }
    ],
    "affected_files": {
        "LinearTokenVesting.sol": "// SPDX-License-Identifier: MIT \npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IVesting.sol\";\n\n/// @title LinearTokenVesting\n/// @notice This contract implements the vesting strategy for the remaining ZEN supply.  \ncontract LinearTokenVesting is Ownable, IVesting {\n    \n    uint8 private _allowedOwnershipTransfers = 2;\n\n    ERC20 public token;\n    address public beneficiary;\n\n    uint256 public amountForEachClaim;\n    uint256 public startTimestamp;\n    uint256 public timeBetweenClaims; \n    uint256 public intervalsToClaim;\n    uint256 public intervalsAlreadyClaimed;\n\n    event Claimed(address indexed claimer, address indexed beneficiary, uint256 claimAmount, uint256 timestamp);\n    event ChangedBeneficiary(address indexed newBeneficiary, address indexed oldBeneficiary);\n    event ChangedVestingParams(\n                                uint256 newTimeBetweenClaims, \n                                uint256 newIntervalsToClaim, \n                                uint256 oldTimeBetweenClaims, \n                                uint256 oldIntervalsToClaim);\n\n    error AddressParameterCantBeZero();\n    error TokenAndBeneficiaryCantBeTheSame();\n    error AmountCantBeZero();\n    error InvalidTimes();\n    error InvalidNumOfIntervals();\n    error NothingToClaim();\n    error ClaimCompleted();\n    error UnauthorizedOperation();\n    error ERC20NotSet();\n    error VestingNotStartedYet();\n    error VestingAlreadyStarted();\n    error UnauthorizedAccount(address account);\n    error ImmutableOwner();\n\n    /// @notice Smart contract constructor\n    /// @param _beneficiary the account that will receive the vested zen\n    /// @param _timeBetweenClaims The minimum time in seconds that must be waited between claims\n    /// @param _intervalsToClaim The number of vesting periods \n    constructor(address _beneficiary, uint256 _timeBetweenClaims, uint256 _intervalsToClaim) Ownable(msg.sender) {\n        _setBeneficiary(_beneficiary);\n        _setVestingParams(_timeBetweenClaims, _intervalsToClaim);\n    }\n\n    /// @notice Set official ZEN ERC-20 smart contract that will be used for initial transfer and start vesting\n    /// @param addr Address of the ERC20\n    function setERC20(address addr) public onlyOwner {\n        if (address(token) != address(0)) revert UnauthorizedOperation();  //ERC-20 address already set\n        if(addr == address(0)) revert AddressParameterCantBeZero();\n        if(addr == beneficiary) revert TokenAndBeneficiaryCantBeTheSame();\n        token = ERC20(addr);\n    }\n\n    /// @notice This function is called by the ERC20 when minting has ended, to notify that the vesting period can start.\n    function startVesting() public {\n        if (msg.sender != address(token)) revert UnauthorizedOperation(); \n        if (amountForEachClaim != 0 || startTimestamp != 0) revert VestingAlreadyStarted(); //already called\n\n        uint256 totalToVest = token.balanceOf(address(this));\n        if (totalToVest == 0) revert AmountCantBeZero();\n        amountForEachClaim = totalToVest / intervalsToClaim;\n        startTimestamp = block.timestamp;\n    } \n\n    /// @notice This function is called for transfer to beneficiary the amount that was accrued from the last claim. If it is called before at least one interval has passed, the claim fails. \n    ///         If more than one period have passed, the sum of amounts of the passed periods is transferred. \n    function claim() public {\n        if (address(token) == address(0)) revert ERC20NotSet();\n        if (startTimestamp == 0) revert VestingNotStartedYet();\n        if (intervalsAlreadyClaimed == intervalsToClaim) revert ClaimCompleted();\n\n        uint256 periodsPassed = (block.timestamp - (startTimestamp + timeBetweenClaims * intervalsAlreadyClaimed)) / timeBetweenClaims;\n        if (periodsPassed == 0) revert NothingToClaim();\n\n        uint256 intervalsToClaimNow = _min(intervalsToClaim - intervalsAlreadyClaimed, periodsPassed); \n        intervalsAlreadyClaimed += intervalsToClaimNow;       \n        uint256 amountToClaimNow;\n        if (intervalsAlreadyClaimed < intervalsToClaim) {\n            amountToClaimNow = intervalsToClaimNow * amountForEachClaim;\n        }\n        else {\n            amountToClaimNow = token.balanceOf(address(this));\n        }\n\n        emit Claimed(msg.sender, beneficiary, amountToClaimNow, block.timestamp);\n\n        token.transfer(beneficiary, amountToClaimNow);\n    }\n\n    /// @notice Changes the beneficiary of the vesting\n    /// @param newBeneficiary Address of the new beneficiary\n    function changeBeneficiary(address newBeneficiary) public onlyOwner {\n        if (intervalsAlreadyClaimed == intervalsToClaim) revert UnauthorizedOperation();\n        if (newBeneficiary == address(token)) revert TokenAndBeneficiaryCantBeTheSame();\n\n        address oldBeneficiary = beneficiary;\n        _setBeneficiary(newBeneficiary);\n        emit ChangedBeneficiary(newBeneficiary, oldBeneficiary);\n    }\n\n    /// @notice Changes the number of vesting intervals and their duration. After this method has been called, the supply not claimed yet (i.e the balance of this contract) will be able to be claimed \n    /// in a time equal to newTimeBetweenClaims * newNumberOfIntervalsToClaim. Note that the remaining supply includes the amounts already accrued but not claimed yet.\n    /// @param newTimeBetweenClaims New duration in seconds of a vesting interval\n    /// @param newNumberOfIntervalsToClaim Number of intervals that need to pass for vesting the remaining supply\n    function changeVestingParams(uint256 newTimeBetweenClaims, uint256 newNumberOfIntervalsToClaim) public onlyOwner {\n        if (intervalsAlreadyClaimed == intervalsToClaim) revert UnauthorizedOperation();\n        uint256 oldTimeBetweenClaims = timeBetweenClaims;\n        uint256 oldNumberOfIntervalsToClaim = intervalsToClaim;\n        _setVestingParams(newTimeBetweenClaims, newNumberOfIntervalsToClaim);\n\n        // if startVesting was already called, startTimestamp, amountForEachClaim and intervalsAlreadyClaimed need to be reset\n        if (startTimestamp != 0){\n            uint256 totalToVest = token.balanceOf(address(this));\n            amountForEachClaim = totalToVest / intervalsToClaim;\n            startTimestamp = block.timestamp;\n            intervalsAlreadyClaimed = 0;\n        }\n        emit ChangedVestingParams(newTimeBetweenClaims, newNumberOfIntervalsToClaim, oldTimeBetweenClaims, oldNumberOfIntervalsToClaim);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns(uint256) {\n        return a < b? a : b;\n    }\n\n    function _setBeneficiary(address newBeneficiary) internal {\n        if(newBeneficiary == address(0)) revert AddressParameterCantBeZero();\n        beneficiary = newBeneficiary;\n    }\n\n    function _setVestingParams(uint256 newTimeBetweenClaims, uint256 newNumberOfIntervalsToClaim) internal {\n        if(newNumberOfIntervalsToClaim == 0) revert InvalidNumOfIntervals(); \n        if(newTimeBetweenClaims == 0) revert InvalidTimes();\n\n        timeBetweenClaims = newTimeBetweenClaims;\n        intervalsToClaim = newNumberOfIntervalsToClaim;        \n    }\n\n    function _transferOwnership(address newOwner) internal override {\n        if (_allowedOwnershipTransfers == 0) revert ImmutableOwner();\n\n        unchecked {--_allowedOwnershipTransfers;}\n        super._transferOwnership(newOwner);\n   }\n}"
    }
}