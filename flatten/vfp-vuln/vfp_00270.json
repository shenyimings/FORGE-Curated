{
    "vfp_id": "vfp_00270",
    "project_name": "cantina_seamless_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect rounding in _convertToShares for withdrawal-based actions leads to 1 dead share for users",
            "description": "1. **Description:** The _convertToShares function uses floor rounding in all cases, which causes a loss of one share for users during withdrawal-based actions due to incorrect rounding direction.\n2. **Cause:** The function does not adjust rounding based on the type of action (deposit vs. withdrawal), always applying Math.Rounding.Floor regardless of context.\n3. **Exploitation:** Users withdrawing funds will receive slightly fewer shares than they should due to the floor rounding, effectively losing a small amount of value per withdrawal.\n4. **Impact:** This leads to a systematic loss of user funds on every withdrawal, reducing the accuracy of share conversion and eroding user trust.\n",
            "severity": "Medium",
            "location": [
                "LeverageManager.sol::#L349-L362",
                "LeverageManager.sol::#L381",
                "LeverageManager.sol::#L419"
            ],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Protect external facing LeverageManager functions from reentrancy",
            "description": "1. **Description:** Several external functions in the LeverageManager contract, such as deposit, withdraw, rebalance, and createNewLeverageToken, perform state changes and external calls without reentrancy protection.\n2. **Cause:** The absence of a nonReentrant modifier or similar guard allows potential reentrancy attacks, especially during rebalance operations where state can be manipulated mid-execution.\n3. **Exploitation:** An attacker could exploit reentrancy during rebalance to manipulate the state of a leveraged token, potentially putting it into an invalid state that bypasses validation checks.\n4. **Impact:** This could lead to temporary invalid states in leveraged tokens, disrupting system integrity and potentially enabling further exploits or fund loss.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        }
    ],
    "affected_files": {
        "LeverageManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\n// Dependency imports\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n// Internal imports\nimport {IRebalanceAdapterBase} from \"src/interfaces/IRebalanceAdapterBase.sol\";\nimport {IBeaconProxyFactory} from \"src/interfaces/IBeaconProxyFactory.sol\";\nimport {ILendingAdapter} from \"src/interfaces/ILendingAdapter.sol\";\nimport {ILeverageManager} from \"src/interfaces/ILeverageManager.sol\";\nimport {ILeverageToken} from \"src/interfaces/ILeverageToken.sol\";\nimport {FeeManager} from \"src/FeeManager.sol\";\nimport {LeverageTokenState} from \"src/types/DataTypes.sol\";\nimport {LeverageToken} from \"src/LeverageToken.sol\";\nimport {\n    ActionData,\n    ActionType,\n    ExternalAction,\n    LeverageTokenConfig,\n    BaseLeverageTokenConfig,\n    RebalanceAction,\n    TokenTransfer\n} from \"src/types/DataTypes.sol\";\n\n/**\n * @dev The LeverageManager contract is an upgradeable core contract that is responsible for managing the creation of LeverageTokens.\n * It also acts as an entry point for users to deposit and withdraw equity from the position held by the LeverageToken, and for\n * rebalancers to rebalance LeverageTokens.\n *\n * LeverageTokens are ERC20 tokens that are akin to shares in an ERC-4626 vault - they represent a claim on the equity held by\n * the LeverageToken. They can be created on this contract by calling `createNewLeverageToken`, and their configuration on the\n * LeverageManager is immutable.\n * Note: Although the LeverageToken configuration saved on the LeverageManager is immutable, the configured LendingAdapter and\n *       RebalanceAdapter for the LeverageToken may be upgradeable contracts.\n *\n * The LeverageManager also inherits the `FeeManager` contract, which is used to manage LeverageToken fees (which accrue to\n * the share value of the LeverageToken) and the treasury fees.\n *\n * For deposits of equity into a LeverageToken, the collateral and debt required is calculated by using the LeverageToken's\n * current collateral ratio. As such, the collateral ratio after a deposit must be equal to the collateral ratio before a\n * deposit, within some rounding error.\n *\n * [CAUTION]\n * ====\n * LeverageTokens are susceptible to inflation attacks like ERC-4626 vaults:\n *   \"In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n *   with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n *   attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n *   deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n *   similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n *   verifying the amount received is as expected, using a wrapper that performs these checks such as\n *   https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\"\n *\n * As such it is highly recommended that LeverageToken creators make an initial deposit of a non-trivial amount of equity.\n * It is also recommended to use a router that performs slippage checks when depositing and withdrawing.\n */\ncontract LeverageManager is ILeverageManager, AccessControlUpgradeable, FeeManager, UUPSUpgradeable {\n    // Base collateral ratio constant, 1e18 means that collateral / debt ratio is 1:1\n    uint256 public constant BASE_RATIO = 1e18;\n    uint256 public constant DECIMALS_OFFSET = 0;\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    /// @dev Struct containing all state for the LeverageManager contract\n    /// @custom:storage-location erc7201:seamless.contracts.storage.LeverageManager\n    struct LeverageManagerStorage {\n        /// @dev Factory for deploying new LeverageTokens\n        IBeaconProxyFactory tokenFactory;\n        /// @dev LeverageToken address => Base config for LeverageToken\n        mapping(ILeverageToken token => BaseLeverageTokenConfig) config;\n    }\n\n    function _getLeverageManagerStorage() internal pure returns (LeverageManagerStorage storage $) {\n        // slither-disable-next-line assembly\n        assembly {\n            // keccak256(abi.encode(uint256(keccak256(\"seamless.contracts.storage.LeverageManager\")) - 1)) & ~bytes32(uint256(0xff));\n            $.slot := 0x326e20d598a681eb69bc11b5176604d340fccf9864170f09484f3c317edf3600\n        }\n    }\n\n    function initialize(address initialAdmin, IBeaconProxyFactory leverageTokenFactory) external initializer {\n        __FeeManager_init(initialAdmin);\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n        _getLeverageManagerStorage().tokenFactory = leverageTokenFactory;\n        emit LeverageManagerInitialized(leverageTokenFactory);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenFactory() public view returns (IBeaconProxyFactory factory) {\n        return _getLeverageManagerStorage().tokenFactory;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenCollateralAsset(ILeverageToken token) public view returns (IERC20 collateralAsset) {\n        return getLeverageTokenLendingAdapter(token).getCollateralAsset();\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenDebtAsset(ILeverageToken token) public view returns (IERC20 debtAsset) {\n        return getLeverageTokenLendingAdapter(token).getDebtAsset();\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenRebalanceAdapter(ILeverageToken token)\n        public\n        view\n        returns (IRebalanceAdapterBase module)\n    {\n        return _getLeverageManagerStorage().config[token].rebalanceAdapter;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenConfig(ILeverageToken token) external view returns (LeverageTokenConfig memory config) {\n        BaseLeverageTokenConfig memory baseConfig = _getLeverageManagerStorage().config[token];\n        uint256 depositTokenFee = getLeverageTokenActionFee(token, ExternalAction.Deposit);\n        uint256 withdrawTokenFee = getLeverageTokenActionFee(token, ExternalAction.Withdraw);\n\n        return LeverageTokenConfig({\n            lendingAdapter: baseConfig.lendingAdapter,\n            rebalanceAdapter: baseConfig.rebalanceAdapter,\n            depositTokenFee: depositTokenFee,\n            withdrawTokenFee: withdrawTokenFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenLendingAdapter(ILeverageToken token) public view returns (ILendingAdapter adapter) {\n        return _getLeverageManagerStorage().config[token].lendingAdapter;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenInitialCollateralRatio(ILeverageToken token) public view returns (uint256 ratio) {\n        return getLeverageTokenRebalanceAdapter(token).getLeverageTokenInitialCollateralRatio(token);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenState(ILeverageToken token) public view returns (LeverageTokenState memory state) {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        uint256 collateral = lendingAdapter.getCollateralInDebtAsset();\n        uint256 debt = lendingAdapter.getDebt();\n        uint256 equity = lendingAdapter.getEquityInDebtAsset();\n\n        uint256 collateralRatio =\n            debt > 0 ? Math.mulDiv(collateral, BASE_RATIO, debt, Math.Rounding.Floor) : type(uint256).max;\n\n        return LeverageTokenState({\n            collateralInDebtAsset: collateral,\n            debt: debt,\n            equity: equity,\n            collateralRatio: collateralRatio\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function createNewLeverageToken(LeverageTokenConfig calldata tokenConfig, string memory name, string memory symbol)\n        external\n        returns (ILeverageToken token)\n    {\n        IBeaconProxyFactory tokenFactory = getLeverageTokenFactory();\n\n        // slither-disable-next-line reentrancy-events\n        token = ILeverageToken(\n            tokenFactory.createProxy(\n                abi.encodeWithSelector(LeverageToken.initialize.selector, address(this), name, symbol),\n                bytes32(tokenFactory.numProxies())\n            )\n        );\n\n        _getLeverageManagerStorage().config[token] = BaseLeverageTokenConfig({\n            lendingAdapter: tokenConfig.lendingAdapter,\n            rebalanceAdapter: tokenConfig.rebalanceAdapter\n        });\n        _setLeverageTokenActionFee(token, ExternalAction.Deposit, tokenConfig.depositTokenFee);\n        _setLeverageTokenActionFee(token, ExternalAction.Withdraw, tokenConfig.withdrawTokenFee);\n\n        tokenConfig.lendingAdapter.postLeverageTokenCreation(msg.sender, address(token));\n        tokenConfig.rebalanceAdapter.postLeverageTokenCreation(msg.sender, address(token));\n\n        emit LeverageTokenCreated(\n            token,\n            tokenConfig.lendingAdapter.getCollateralAsset(),\n            tokenConfig.lendingAdapter.getDebtAsset(),\n            tokenConfig\n        );\n        return token;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewDeposit(ILeverageToken token, uint256 equityInCollateralAsset)\n        public\n        view\n        returns (ActionData memory)\n    {\n        ActionData memory data = _previewAction(token, equityInCollateralAsset, ExternalAction.Deposit);\n\n        // For deposits, the collateral amount returned by the preview is the total collateral required to execute the\n        // deposit, so we add the treasury fee to it, since the collateral computed above is wrt the equity amount with\n        // the treasury fee subtracted.\n        data.collateral += data.treasuryFee;\n\n        return data;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewWithdraw(ILeverageToken token, uint256 equityInCollateralAsset)\n        public\n        view\n        returns (ActionData memory)\n    {\n        ActionData memory data = _previewAction(token, equityInCollateralAsset, ExternalAction.Withdraw);\n\n        // For withdrawals, the collateral amount returned is the collateral transferred to the sender, so we subtract the\n        // treasury fee, since the collateral computed by `previewAction` is wrt the equity amount without the treasury fee\n        // subtracted.\n        // Note: It is possible for collateral to be < treasuryFee because of rounding down for both the share calculation and\n        //       the resulting collateral calculated using those shares in `previewAction`, while the treasury fee is calculated\n        //       based on the initial equity amount rounded up. In this case, we set the collateral to 0 and the treasury fee to\n        //       the computed collateral amount\n        data.treasuryFee = Math.min(data.collateral, data.treasuryFee);\n        data.collateral = data.collateral > data.treasuryFee ? data.collateral - data.treasuryFee : 0;\n\n        return data;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function deposit(ILeverageToken token, uint256 equityInCollateralAsset, uint256 minShares)\n        external\n        returns (ActionData memory actionData)\n    {\n        ActionData memory depositData = previewDeposit(token, equityInCollateralAsset);\n\n        if (depositData.shares < minShares) {\n            revert SlippageTooHigh(depositData.shares, minShares);\n        }\n\n        // Take collateral asset from sender\n        IERC20 collateralAsset = getLeverageTokenCollateralAsset(token);\n        SafeERC20.safeTransferFrom(collateralAsset, msg.sender, address(this), depositData.collateral);\n\n        // Add collateral to LeverageToken\n        _executeLendingAdapterAction(token, ActionType.AddCollateral, depositData.collateral - depositData.treasuryFee);\n\n        // Charge treasury fee\n        _chargeTreasuryFee(collateralAsset, depositData.treasuryFee);\n\n        // Borrow and send debt assets to caller\n        _executeLendingAdapterAction(token, ActionType.Borrow, depositData.debt);\n        SafeERC20.safeTransfer(getLeverageTokenDebtAsset(token), msg.sender, depositData.debt);\n\n        // Mint shares to user\n        // slither-disable-next-line reentrancy-events\n        token.mint(msg.sender, depositData.shares);\n\n        // Emit event and explicit return statement\n        emit Deposit(token, msg.sender, depositData);\n        return depositData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function withdraw(ILeverageToken token, uint256 equityInCollateralAsset, uint256 maxShares)\n        external\n        returns (ActionData memory actionData)\n    {\n        ActionData memory withdrawData = previewWithdraw(token, equityInCollateralAsset);\n\n        if (withdrawData.shares > maxShares) {\n            revert SlippageTooHigh(withdrawData.shares, maxShares);\n        }\n\n        // Burn shares from user and total supply\n        token.burn(msg.sender, withdrawData.shares);\n\n        // Take assets from sender and repay the debt\n        SafeERC20.safeTransferFrom(getLeverageTokenDebtAsset(token), msg.sender, address(this), withdrawData.debt);\n        _executeLendingAdapterAction(token, ActionType.Repay, withdrawData.debt);\n\n        // Withdraw collateral from lending pool\n        _executeLendingAdapterAction(\n            token, ActionType.RemoveCollateral, withdrawData.collateral + withdrawData.treasuryFee\n        );\n\n        // Send collateral assets to sender\n        IERC20 collateralAsset = getLeverageTokenCollateralAsset(token);\n        SafeERC20.safeTransfer(collateralAsset, msg.sender, withdrawData.collateral);\n\n        // Charge treasury fee\n        _chargeTreasuryFee(collateralAsset, withdrawData.treasuryFee);\n\n        // Emit event and explicit return statement\n        emit Withdraw(token, msg.sender, withdrawData);\n        return withdrawData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function rebalance(\n        RebalanceAction[] calldata actions,\n        TokenTransfer[] calldata tokensIn,\n        TokenTransfer[] calldata tokensOut\n    ) external {\n        _transferTokens(tokensIn, msg.sender, address(this));\n\n        LeverageTokenState[] memory leverageTokensStateBefore = new LeverageTokenState[](actions.length);\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            ILeverageToken leverageToken = actions[i].leverageToken;\n\n            // Check if the LeverageToken is eligible for rebalance if it has not been checked yet in a previous iteration of the loop\n            if (!_isElementInSlice(actions, leverageToken, i)) {\n                LeverageTokenState memory state = getLeverageTokenState(leverageToken);\n                leverageTokensStateBefore[i] = state;\n\n                IRebalanceAdapterBase rebalanceAdapter = getLeverageTokenRebalanceAdapter(leverageToken);\n                if (!rebalanceAdapter.isEligibleForRebalance(leverageToken, state, msg.sender)) {\n                    revert LeverageTokenNotEligibleForRebalance(leverageToken);\n                }\n            }\n\n            _executeLendingAdapterAction(leverageToken, actions[i].actionType, actions[i].amount);\n        }\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            // Validate the LeverageToken state after rebalancing if it has not been validated yet in a previous iteration of the loop\n            if (!_isElementInSlice(actions, actions[i].leverageToken, i)) {\n                ILeverageToken leverageToken = actions[i].leverageToken;\n                IRebalanceAdapterBase rebalanceAdapter = getLeverageTokenRebalanceAdapter(leverageToken);\n\n                if (!rebalanceAdapter.isStateAfterRebalanceValid(leverageToken, leverageTokensStateBefore[i])) {\n                    revert InvalidLeverageTokenStateAfterRebalance(leverageToken);\n                }\n            }\n        }\n\n        _transferTokens(tokensOut, address(this), msg.sender);\n    }\n\n    /// @notice Function that converts user's equity to shares\n    /// @notice Function uses OZ formula for calculating shares\n    /// @param token LeverageToken to convert equity for\n    /// @param equityInCollateralAsset Equity to convert to shares, denominated in collateral asset\n    /// @return shares Shares\n    /// @dev Function should be used to calculate how much shares user should receive for their equity\n    function _convertToShares(ILeverageToken token, uint256 equityInCollateralAsset)\n        internal\n        view\n        returns (uint256 shares)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        return Math.mulDiv(\n            equityInCollateralAsset,\n            token.totalSupply() + 10 ** DECIMALS_OFFSET,\n            lendingAdapter.getEquityInCollateralAsset() + 1,\n            Math.Rounding.Floor\n        );\n    }\n\n    /// @notice Previews parameters related to a deposit action\n    /// @param token LeverageToken to preview deposit for\n    /// @param equityInCollateralAsset Amount of equity to add or withdraw, denominated in collateral asset\n    /// @param action Type of the action to preview, can be Deposit or Withdraw\n    /// @return data Preview data for the action\n    /// @dev If the LeverageToken has zero total supply of shares (so the LeverageToken does not hold any collateral or debt,\n    ///      or holds some leftover dust after all shares are redeemed), then the preview will use the target\n    ///      collateral ratio for determining how much collateral and debt is required instead of the current collateral ratio.\n    /// @dev If action is deposit collateral will be rounded down and debt up, if action is withdraw collateral will be rounded up and debt down\n    function _previewAction(ILeverageToken token, uint256 equityInCollateralAsset, ExternalAction action)\n        internal\n        view\n        returns (ActionData memory data)\n    {\n        (uint256 equityToCover, uint256 equityForShares, uint256 tokenFee, uint256 treasuryFee) =\n            _computeEquityFees(token, equityInCollateralAsset, action);\n\n        uint256 shares = _convertToShares(token, equityForShares);\n\n        (uint256 collateral, uint256 debt) = _computeCollateralAndDebtForAction(token, equityToCover, action);\n\n        // The collateral returned by `_computeCollateralAndDebtForAction` can be zero if the amount of equity for the LeverageToken\n        // cannot be exchanged for at least 1 LeverageToken share due to rounding down in the exchange rate calculation.\n        // The treasury fee returned by `_computeEquityFees` is wrt the equity amount, not the share amount, thus it's possible\n        // for it to be non-zero even if the collateral amount is zero. In this case, the treasury fee should be set to 0\n        treasuryFee = collateral == 0 ? 0 : treasuryFee;\n\n        return ActionData({\n            collateral: collateral,\n            debt: debt,\n            equity: equityInCollateralAsset,\n            shares: shares,\n            tokenFee: tokenFee,\n            treasuryFee: treasuryFee\n        });\n    }\n\n    /// @notice Function that computes collateral and debt required by the position held by a LeverageToken for a given action and an amount of equity to add / remove\n    /// @param token LeverageToken to compute collateral and debt for\n    /// @param equityInCollateralAsset Equity amount in collateral asset\n    /// @param action Action to compute collateral and debt for\n    /// @return collateral Collateral to add / remove from the LeverageToken\n    /// @return debt Debt to borrow / repay to the LeverageToken\n    function _computeCollateralAndDebtForAction(\n        ILeverageToken token,\n        uint256 equityInCollateralAsset,\n        ExternalAction action\n    ) internal view returns (uint256 collateral, uint256 debt) {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalDebt = lendingAdapter.getDebt();\n        uint256 totalShares = token.totalSupply();\n\n        Math.Rounding collateralRounding = action == ExternalAction.Deposit ? Math.Rounding.Ceil : Math.Rounding.Floor;\n        Math.Rounding debtRounding = action == ExternalAction.Deposit ? Math.Rounding.Floor : Math.Rounding.Ceil;\n\n        uint256 shares = _convertToShares(token, equityInCollateralAsset);\n\n        // If action is deposit there might be some dust in collateral but debt can be 0. In that case we should follow target ratio\n        bool shouldFollowInitialRatio = totalShares == 0 || (action == ExternalAction.Deposit && totalDebt == 0);\n\n        if (shouldFollowInitialRatio) {\n            uint256 initialRatio = getLeverageTokenInitialCollateralRatio(token);\n            collateral =\n                Math.mulDiv(equityInCollateralAsset, initialRatio, initialRatio - BASE_RATIO, collateralRounding);\n            debt = lendingAdapter.convertCollateralToDebtAsset(collateral - equityInCollateralAsset);\n        } else {\n            collateral = Math.mulDiv(lendingAdapter.getCollateral(), shares, totalShares, collateralRounding);\n            debt = Math.mulDiv(totalDebt, shares, totalShares, debtRounding);\n        }\n\n        return (collateral, debt);\n    }\n\n    /// @notice Helper function that checks if a specific element has already been processed in the slice up to the given index\n    /// @param actions Entire array to go through\n    /// @param token Element to search for\n    /// @param untilIndex Search until this specific index\n    /// @dev This function is used to check if we already stored the state of the LeverageToken before rebalance.\n    ///      This function is used to check if LeverageToken state has been already validated after rebalance\n    function _isElementInSlice(RebalanceAction[] calldata actions, ILeverageToken token, uint256 untilIndex)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < untilIndex; i++) {\n            if (address(actions[i].leverageToken) == address(token)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /// @notice Executes actions on the LendingAdapter for a specific LeverageToken\n    /// @param token LeverageToken to execute action for\n    /// @param actionType Type of the action to execute\n    /// @param amount Amount to execute action with\n    function _executeLendingAdapterAction(ILeverageToken token, ActionType actionType, uint256 amount) internal {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        if (actionType == ActionType.AddCollateral) {\n            IERC20 collateralAsset = lendingAdapter.getCollateralAsset();\n            // slither-disable-next-line reentrancy-events\n            SafeERC20.forceApprove(collateralAsset, address(lendingAdapter), amount);\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.addCollateral(amount);\n        } else if (actionType == ActionType.RemoveCollateral) {\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.removeCollateral(amount);\n        } else if (actionType == ActionType.Borrow) {\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.borrow(amount);\n        } else if (actionType == ActionType.Repay) {\n            IERC20 debtAsset = lendingAdapter.getDebtAsset();\n            // slither-disable-next-line reentrancy-events\n            SafeERC20.forceApprove(debtAsset, address(lendingAdapter), amount);\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.repay(amount);\n        }\n    }\n\n    /// @notice Used for batching token transfers\n    /// @param transfers Array of transfer data. Transfer data consist of token to transfer and amount\n    /// @param from Address to transfer tokens from\n    /// @param to Address to transfer tokens to\n    /// @dev If from address is this smart contract it will use the regular transfer function otherwise it will use transferFrom\n    function _transferTokens(TokenTransfer[] calldata transfers, address from, address to) internal {\n        for (uint256 i = 0; i < transfers.length; i++) {\n            TokenTransfer calldata transfer = transfers[i];\n\n            if (from == address(this)) {\n                SafeERC20.safeTransfer(IERC20(transfer.token), to, transfer.amount);\n            } else {\n                SafeERC20.safeTransferFrom(IERC20(transfer.token), from, to, transfer.amount);\n            }\n        }\n    }\n}\n"
    }
}