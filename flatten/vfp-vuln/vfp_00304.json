{
    "vfp_id": "vfp_00304",
    "project_name": "cantina_tadle_oct2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing contract code check in TadleImplementations",
            "description": "The TadleImplementations contract allows setting default and additional implementations without verifying that the provided addresses contain contract code. This could result in routing to EOAs or destroyed contracts, causing reverts or malfunctioning proxies. The root cause is the absence of a code presence check like Address.isContract. While addImplementation was fixed to include a check, setDefaultImplementation still only rejects the zero address. An admin could accidentally or maliciously set a non-contract address as the default, breaking all routing. The impact is denial of service and disruption of dependent systems relying on correct implementation resolution.\n",
            "severity": "Medium",
            "location": [
                "Implementations.sol::setDefaultImplementation#",
                "Implementations.sol::addImplementation#83-97"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Implementations.sol"
            ]
        }
    ],
    "affected_files": {
        "Implementations.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable2Step, Ownable} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n/**\n * @title IAuth\n * @dev Interface for authentication contract\n */\ninterface IAuth {\n    function isAdmin(address account) external view returns (bool);\n}\n\n/**\n * @title Setup\n * @dev Base contract for implementation management\n * Stores mappings between function signatures and their implementation addresses\n */\nabstract contract Setup {\n    /// @dev Initialization flag to prevent multiple initialization calls\n    bool internal _initialized;\n\n    /// @dev Auth contract instance for access control\n    IAuth public auth;\n\n    /// @dev Default implementation address for fallback when signature not found\n    address public defaultImplementation;\n\n    /// @dev Mapping of function signatures to their implementation addresses\n    mapping(bytes4 => address) internal sigImplementations;\n\n    /// @dev Mapping of implementation addresses to their function signatures\n    /// @notice This allows efficient removal of all signatures for an implementation\n    mapping(address => bytes4[]) internal implementationSigs;\n}\n\n/**\n * @title Implementations\n * @dev Contract for managing implementation addresses and their function signatures\n */\nabstract contract Implementations is Setup {\n    // Events for implementation management\n    event LogSetDefaultImplementation(address indexed oldImplementation, address indexed newImplementation);\n    event LogAddImplementation(address indexed implementation, bytes4[] sigs);\n    event LogRemoveImplementation(address indexed implementation, bytes4[] sigs);\n\n    /**\n     * @dev Modifier to restrict function access to admin users only\n     * @notice Reverts if caller is not an admin in the auth contract\n     */\n    modifier isAdmin() {\n        require(auth.isAdmin(msg.sender), \"Implementations: not admin\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure contract is only initialized once\n     * @notice Prevents multiple initialization calls that could reset contract state\n     */\n    modifier initializer() {\n        require(!_initialized, \"Implementations: already initialized\");\n        _;\n        _initialized = true;\n    }\n\n    /**\n     * @dev Sets the default implementation address used when no specific implementation is found\n     * @param _defaultImplementation Address of the new default implementation\n     */\n    function setDefaultImplementation(address _defaultImplementation) external isAdmin {\n        require(_defaultImplementation != address(0), \"Implementations: invalid default implementation address\");\n        require(_defaultImplementation != defaultImplementation, \"Implementations: new implementation same as current\");\n\n        emit LogSetDefaultImplementation(defaultImplementation, _defaultImplementation);\n        defaultImplementation = _defaultImplementation;\n    }\n\n    /**\n     * @dev Add new implementation with its function signatures\n     * @param _implementation Address of the implementation contract\n     * @param _sigs Array of function signatures supported by the implementation\n     */\n    function addImplementation(address _implementation, bytes4[] calldata _sigs) external isAdmin {\n        require(_implementation != address(0), \"Implementations: invalid implementation address\");\n        require(implementationSigs[_implementation].length == 0, \"Implementations: implementation already registered\");\n        require(_sigs.length > 0, \"Implementations: empty signatures array\");\n\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            bytes4 _sig = _sigs[i];\n            require(_sig != bytes4(0), \"Implementations: invalid function signature\");\n            require(sigImplementations[_sig] == address(0), \"Implementations: signature already registered\");\n            sigImplementations[_sig] = _implementation;\n        }\n\n        implementationSigs[_implementation] = _sigs;\n        emit LogAddImplementation(_implementation, _sigs);\n    }\n\n    /**\n     * @dev Remove an implementation and its associated function signatures\n     * @param _implementation Address of the implementation to remove\n     */\n    function removeImplementation(address _implementation) external isAdmin {\n        require(_implementation != address(0), \"Implementations: invalid implementation address\");\n        require(implementationSigs[_implementation].length != 0, \"Implementations: implementation not found\");\n        require(_implementation != defaultImplementation, \"Implementations: cannot remove default implementation\");\n\n        bytes4[] memory sigs = implementationSigs[_implementation];\n        for (uint256 i = 0; i < sigs.length; i++) {\n            bytes4 sig = sigs[i];\n            delete sigImplementations[sig];\n        }\n\n        delete implementationSigs[_implementation];\n        emit LogRemoveImplementation(_implementation, sigs);\n    }\n}\n\n/**\n * @title TadleImplementations\n * @dev Implementation registry contract with getter functions\n */\ncontract TadleImplementations is Ownable2Step, Implementations {\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @dev Initialize the contract with auth contract address\n     * @param _auth Address of the auth contract for access control\n     */\n    function initialize(address _auth) external onlyOwner initializer {\n        require(_auth != address(0), \"TadleImplementations: invalid auth address\");\n        auth = IAuth(_auth);\n    }\n\n    /**\n     * @dev Get implementation address for a function signature\n     * @param _sig Function signature to lookup\n     * @return Implementation address or default implementation if not found\n     */\n    function getImplementation(bytes4 _sig) external view returns (address) {\n        address _implementation = sigImplementations[_sig];\n        return _implementation == address(0) ? defaultImplementation : _implementation;\n    }\n\n    /**\n     * @dev Get all function signatures for an implementation\n     * @param _impl Implementation address to lookup\n     * @return Array of function signatures\n     */\n    function getImplementationSigs(address _impl) external view returns (bytes4[] memory) {\n        return implementationSigs[_impl];\n    }\n\n    /**\n     * @dev Get specific implementation for a function signature\n     * @param _sig Function signature to lookup\n     * @return Implementation address (returns zero address if not found)\n     */\n    function getSigImplementation(bytes4 _sig) external view returns (address) {\n        return sigImplementations[_sig];\n    }\n}\n"
    }
}