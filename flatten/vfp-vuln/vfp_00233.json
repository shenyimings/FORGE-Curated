{
    "vfp_id": "vfp_00233",
    "project_name": "Zenith Audit Report - Stream Protocol.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "`instantUnstake` and `unstake` can be used to bypass `minimumSupply`",
            "description": "1.  **Description:** The `instantUnstake` and `unstake` functions do not enforce the `minimumSupply` requirement, allowing users to withdraw funds even when doing so would drop the total supply below the intended minimum threshold.\n2.  **Cause:** Missing validation checks in the unstake functions to ensure the `minimumSupply` is maintained after withdrawals.\n3.  **Exploitation:** An attacker could exploit this by rapidly unstaking small amounts to drain the vault below the minimum supply, potentially destabilizing the system.\n4.  **Impact:** The vault may fall below its minimum supply, affecting system stability and economic model integrity.\n",
            "severity": "Medium",
            "location": [
                "StreamVault.sol::instantUnstake",
                "StreamVault.sol::unstake"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "The vault's `cap` can be bypassed, and the `minimumSupply` can be reached earlier than intended",
            "description": "1.  **Description:** There exists a logic flaw that allows the vault's deposit cap to be circumvented, and the minimum supply threshold to be reached prematurely.\n2.  **Cause:** Improper enforcement of deposit limits in certain code paths, possibly through indirect deposits or wrapper contracts.\n3.  **Exploitation:** An attacker could exploit this by routing deposits through alternative functions or contracts that do not enforce the cap or supply checks.\n4.  **Impact:** The vault could exceed its intended capacity or reach minimum supply too early, disrupting yield distribution and economic balance.\n",
            "severity": "Medium",
            "location": [
                "StreamVault.sol",
                "StableWrapper.sol"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Providing yield on the first `rollToNextRound` causes unexpected behavior",
            "description": "1.  **Description:** Yield calculation during the first round transition via `rollToNextRound` leads to incorrect or unexpected state changes.\n2.  **Cause:** The initialization logic does not properly handle the first yield distribution, possibly due to uninitialized price-per-share or zero base values.\n3.  **Exploitation:** An attacker could trigger `rollToNextRound` prematurely or manipulate the timing to receive disproportionate rewards.\n4.  **Impact:** Users may receive incorrect share allocations, leading to unfair distribution and potential loss of funds.\n",
            "severity": "Medium",
            "location": [
                "StreamVault.sol::rollToNextRound"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        }
    ],
    "affected_files": {
        "StreamVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ShareMath} from \"./lib/ShareMath.sol\";\nimport {Vault} from \"./lib/Vault.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IStableWrapper} from \"./interfaces/IStableWrapper.sol\";\nimport {OFT} from \"@layerzerolabs/oft-evm/contracts/OFT.sol\";\nimport {SendParam, MessagingFee, MessagingReceipt, OFTReceipt} from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\n/**\n * @title StreamVault\n * @notice A vault that allows users to stake and withdraw from an off-chain managed Stream strategy\n * @notice Users receive shares for their stakes, which can be redeemed for assets\n * @notice The rounds will be rolled over on a weekly basis\n */\ncontract StreamVault is ReentrancyGuard, OFT {\n    using SafeERC20 for IERC20;\n    using ShareMath for Vault.StakeReceipt;\n\n    // #############################################\n    // CONSTANTS\n    // #############################################\n    /// @notice Minimum round number for valid stake receipts\n    uint256 private constant MINIMUM_VALID_ROUND = 2;\n\n    // #############################################\n    // STATE\n    // #############################################\n    /// @notice Stores the user's pending stake for the round\n    mapping(address => Vault.StakeReceipt) public stakeReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their StakeReceipt.stakeAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice address of the stable wrapper contract\n    address public stableWrapper;\n\n    /// @notice the total supply of shares across all chains\n    uint256 public omniTotalSupply;\n\n    /// @notice Whether the vault allows independence from the stable wrapper\n    bool public allowIndependence;\n\n    // #############################################\n    // EVENTS\n    // #############################################\n    event Stake(address indexed account, uint256 amount, uint256 round);\n\n    event Unstake(address indexed account, uint256 amount, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event RoundRolled(\n        uint256 round,\n        uint256 pricePerShare,\n        uint256 sharesMinted,\n        uint256 wrappedTokensMinted,\n        uint256 wrappedTokensBurned,\n        uint256 yield,\n        bool isYieldPositive\n    );\n\n    event InstantUnstake(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event AllowIndependenceSet(bool allowIndependence);\n\n    // #############################################\n    // ERRORS\n    // #############################################\n    error IndependenceNotAllowed();\n\n    error AmountMustBeGreaterThanZero();\n\n    error AddressMustBeNonZero();\n\n    error CapExceeded();\n\n    error MinimumSupplyNotMet();\n\n    error RoundMismatch();\n\n    error AmountExceedsReceipt();\n\n    error RoundMustBeGreaterThanOne();\n\n    error InsufficientUnredeemedShares();\n\n    error CapMustBeGreaterThanZero();\n\n    // #############################################\n    // CONSTRUCTOR & INITIALIZATION\n    // #############################################\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _tokenName is the token name of the share ERC-20\n     * @param _tokenSymbol is the token symbol of the share ERC-20\n     * @param _stableWrapper is the address of the stable wrapper contract\n     * @param _lzEndpoint is the address of the LayerZero endpoint\n     * @param _delegate is the address of the delegate\n     * @param _vaultParams is the `VaultParams` struct with general vault data\n     */\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stableWrapper,\n        address _lzEndpoint,\n        address _delegate,\n        Vault.VaultParams memory _vaultParams\n    )\n        ReentrancyGuard()\n        OFT(_tokenName, _tokenSymbol, _lzEndpoint, _delegate)\n        Ownable(msg.sender)\n    {\n        if (_vaultParams.cap == 0) revert CapMustBeGreaterThanZero();\n        if (_stableWrapper == address(0)) revert AddressMustBeNonZero();\n\n        stableWrapper = _stableWrapper;\n        vaultParams = _vaultParams;\n        vaultState.round = 1;\n        allowIndependence = false;\n    }\n    // #############################################\n    // Wrapper functions\n    // #############################################\n\n    /**\n     * @notice Deposits assets and stakes them in a single transaction\n     * @param amount Amount of assets to deposit and stake\n     */\n    function depositAndStake(\n        uint104 amount,\n        address creditor\n    ) external nonReentrant {\n        IStableWrapper(stableWrapper).depositToVault(msg.sender, amount);\n\n        // Then stake the wrapped tokens\n        _stakeInternal(amount, creditor);\n    }\n\n    /**\n     * @notice Unstakes tokens and initiates withdrawal in a single transaction\n     * @param numShares Number of shares to unstake\n     */\n    function unstakeAndWithdraw(uint256 numShares) external nonReentrant {\n        // First unstake the tokens\n        uint256 withdrawAmount = _unstake(numShares, stableWrapper);\n\n        // Then initiate withdrawal in the wrapper\n        IStableWrapper(stableWrapper).initiateWithdrawalFromVault(\n            msg.sender,\n            uint224(withdrawAmount)\n        );\n    }\n\n    /**\n     * @notice Performs instant unstake and initiates withdrawal in a single transaction\n     * @param amount Amount to unstake instantly\n     */\n    function instantUnstakeAndWithdraw(uint104 amount) external nonReentrant {\n        // First perform instant unstake\n        _instantUnstake(amount, stableWrapper);\n\n        // Then initiate withdrawal in the wrapper\n        IStableWrapper(stableWrapper).initiateWithdrawalFromVault(\n            msg.sender,\n            uint224(amount)\n        );\n    }\n\n    function bridgeWithRedeem(\n        SendParam calldata sendParam,\n        MessagingFee calldata fee,\n        address payable refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory) {\n        // First redeem any shares if needed\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[msg.sender];\n        if (stakeReceipt.amount > 0 || stakeReceipt.unredeemedShares > 0) {\n            _redeem(0);\n        }\n\n        // Then call the internal _send\n        return _send(sendParam, fee, refundAddress);\n    }\n\n    // #############################################\n    // PUBLIC STAKING\n    // #############################################\n\n    /**\n     * @notice Stakes the `asset` from msg.sender added to `creditor`'s stake.\n     * @notice Used for vault -> vault stakes on the user's behalf\n     * @param amount is the amount of `asset` to stake\n     * @param creditor is the address that can claim/withdraw staked amount\n     * @dev An approve() by the msg.sender is required beforehand\n     */\n    function stake(uint104 amount, address creditor) public nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (creditor == address(0)) revert AddressMustBeNonZero();\n\n        IERC20(stableWrapper).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _stakeInternal(amount, creditor);\n    }\n\n    /**\n     * @notice Manages the stake receipts for a staker\n     * @param amount is the amount of `asset` staked\n     * @param creditor is the address to receieve the stake\n     * @dev This function should be called after the underlying\n     * token has been transferred to the vault\n     */\n    function _stakeInternal(uint104 amount, address creditor) private {\n        uint16 currentRound = vaultState.round;\n        Vault.VaultParams memory _vaultParams = vaultParams;\n        uint256 totalWithStakedAmount = IERC20(stableWrapper).balanceOf(\n            address(this)\n        );\n\n        if (totalWithStakedAmount > _vaultParams.cap) revert CapExceeded();\n        if (totalWithStakedAmount < _vaultParams.minimumSupply)\n            revert MinimumSupplyNotMet();\n\n        emit Stake(creditor, amount, currentRound);\n\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[creditor];\n\n        // If we have an unprocessed pending stake from the previous rounds, we have to process it.\n        uint256 unredeemedShares = stakeReceipt.getSharesFromReceipt(\n            currentRound,\n            roundPricePerShare[stakeReceipt.round],\n            _vaultParams.decimals\n        );\n\n        uint104 stakeAmount = amount;\n\n        // If we have a pending stake in the current round, we add on to the pending stake\n        if (currentRound == stakeReceipt.round) {\n            stakeAmount = stakeAmount + stakeReceipt.amount;\n        }\n\n        stakeReceipts[creditor] = Vault.StakeReceipt({\n            round: currentRound,\n            amount: stakeAmount,\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        vaultState.totalPending = vaultState.totalPending + amount;\n    }\n\n    // #############################################\n    // WITHDRAWALS\n    // #############################################\n\n    /**\n     * @notice External wrapper for instant unstaking\n     * @param amount is the amount to withdraw\n     */\n    function instantUnstake(uint104 amount) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        _instantUnstake(amount, msg.sender);\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `StakeReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function _instantUnstake(uint104 amount, address to) internal {\n        Vault.StakeReceipt storage stakeReceipt = stakeReceipts[msg.sender];\n\n        uint16 currentRound = vaultState.round;\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (stakeReceipt.round != currentRound) revert RoundMismatch();\n\n        uint104 receiptAmount = stakeReceipt.amount;\n        if (receiptAmount < amount) revert AmountExceedsReceipt();\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        stakeReceipt.amount = receiptAmount - amount;\n        vaultState.totalPending = vaultState.totalPending - amount;\n\n        emit InstantUnstake(msg.sender, amount, currentRound);\n\n        _transferAsset(to, amount);\n    }\n\n    /**\n     * @notice External wrapper for unstaking shares\n     * @param numShares is the number of shares to withdraw and burn\n     */\n    function unstake(uint256 numShares) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        _unstake(numShares, msg.sender);\n    }\n\n    /**\n     * @notice Initiates a withdrawal\n     * @param numShares is the number of shares to withdraw and burn\n     */\n    function _unstake(\n        uint256 numShares,\n        address to\n    ) internal returns (uint256) {\n        if (numShares == 0) revert AmountMustBeGreaterThanZero();\n        if (to == address(0)) revert AddressMustBeNonZero();\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        {\n            Vault.StakeReceipt memory stakeReceipt = stakeReceipts[msg.sender];\n            if (stakeReceipt.amount > 0 || stakeReceipt.unredeemedShares > 0) {\n                _redeem(0);\n            }\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        if (currentRound < MINIMUM_VALID_ROUND)\n            revert RoundMustBeGreaterThanOne();\n\n        uint256 withdrawAmount = ShareMath.sharesToAsset(\n            numShares,\n            roundPricePerShare[currentRound - 1],\n            vaultParams.decimals\n        );\n\n        emit Unstake(msg.sender, withdrawAmount, currentRound);\n\n        _burn(msg.sender, numShares);\n\n        omniTotalSupply = omniTotalSupply - numShares;\n\n        IERC20(stableWrapper).safeTransfer(to, withdrawAmount);\n\n        return withdrawAmount;\n    }\n\n    // #############################################\n    // REDEMPTIONS\n    // #############################################\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        if (numShares == 0) revert AmountMustBeGreaterThanZero();\n\n        _redeem(numShares);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem,\n     * if numShares is 0, it will redeem all unredeemed shares\n     */\n    function _redeem(uint256 numShares) internal {\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares = stakeReceipt.getSharesFromReceipt(\n            currentRound,\n            roundPricePerShare[stakeReceipt.round],\n            vaultParams.decimals\n        );\n\n        numShares = numShares == 0 ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        if (numShares > unredeemedShares) revert InsufficientUnredeemedShares();\n\n        // If we have a stakeReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new stakes, we just zero it out for new stakes.\n        if (stakeReceipt.round < currentRound) {\n            stakeReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n        stakeReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares - numShares\n        );\n\n        emit Redeem(msg.sender, numShares, stakeReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    // #############################################\n    // VAULT OPERATIONS\n    // #############################################\n\n    /**\n     * @notice Rolls to the next round, finalizing prev round pricePerShare and minting new shares\n     * @param yield is the amount of assets earnt or lost in the round\n     * @param isYieldPositive is true if the yield is positive, false if it is negative\n     */\n    function rollToNextRound(\n        uint256 yield,\n        bool isYieldPositive\n    ) external onlyOwner nonReentrant {\n        uint256 balance = IERC20(stableWrapper).balanceOf(address(this));\n        uint256 currentBalance;\n        if (isYieldPositive) {\n            currentBalance = balance + yield;\n        } else {\n            currentBalance = balance - yield;\n        }\n\n        Vault.VaultParams memory _vaultParams = vaultParams;\n        if (currentBalance < uint256(_vaultParams.minimumSupply)) {\n            revert MinimumSupplyNotMet();\n        }\n        Vault.VaultState memory state = vaultState;\n        uint256 currentRound = state.round;\n\n        uint256 newPricePerShare = ShareMath.pricePerShare(\n            omniTotalSupply,\n            currentBalance,\n            state.totalPending,\n            _vaultParams.decimals\n        );\n\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        vaultState.totalPending = 0;\n        vaultState.round = uint16(currentRound + 1);\n\n        uint256 mintShares = ShareMath.assetToShares(\n            state.totalPending,\n            newPricePerShare,\n            _vaultParams.decimals\n        );\n\n        _mint(address(this), mintShares);\n\n        omniTotalSupply = omniTotalSupply + mintShares;\n\n        if (currentBalance > balance) {\n            IStableWrapper(stableWrapper).permissionedMint(\n                address(this),\n                currentBalance - balance\n            );\n            emit RoundRolled(\n                currentRound,\n                newPricePerShare,\n                mintShares,\n                currentBalance - balance,\n                0,\n                yield,\n                isYieldPositive\n            );\n        } else if (currentBalance < balance) {\n            IStableWrapper(stableWrapper).permissionedBurn(\n                address(this),\n                balance - currentBalance\n            );\n            emit RoundRolled(\n                currentRound,\n                newPricePerShare,\n                mintShares,\n                0,\n                balance - currentBalance,\n                yield,\n                isYieldPositive\n            );\n        } else {\n            emit RoundRolled(\n                currentRound,\n                newPricePerShare,\n                mintShares,\n                0,\n                0,\n                yield,\n                isYieldPositive\n            );\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function _transferAsset(address recipient, uint256 amount) internal {\n        IERC20(stableWrapper).safeTransfer(recipient, amount);\n    }\n\n    // #############################################\n    // SETTERS\n    // #############################################\n\n    /**\n     * @notice Sets a new stable wrapper contract address\n     * @param newStableWrapper is the address of the new stable wrapper contract\n     */\n    function setStableWrapper(address newStableWrapper) external onlyOwner {\n        if (newStableWrapper == address(0)) revert AddressMustBeNonZero();\n        stableWrapper = newStableWrapper;\n    }\n\n    /**\n     * @notice Allows owner to set allowIndependence\n     * @param _allowIndependence New allowIndependence value\n     */\n    function setAllowIndependence(bool _allowIndependence) public onlyOwner {\n        allowIndependence = _allowIndependence;\n        emit AllowIndependenceSet(_allowIndependence);\n    }\n\n    /**\n     * @notice Sets a new cap for stakes\n     * @param newCap is the new cap for stakes\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        if (newCap == 0) revert CapMustBeGreaterThanZero();\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /**\n     * @notice Sets the new vault parameters\n     */\n    function setVaultParams(\n        Vault.VaultParams memory newVaultParams\n    ) external onlyOwner {\n        if (newVaultParams.cap == 0) revert CapMustBeGreaterThanZero();\n        vaultParams = newVaultParams;\n    }\n\n    // #############################################\n    // GETTERS\n    // #############################################\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account not accounting for current round stakes\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(\n        address account\n    ) public view returns (uint256) {\n        if (vaultState.round < MINIMUM_VALID_ROUND)\n            revert RoundMustBeGreaterThanOne();\n        uint256 _decimals = vaultParams.decimals;\n        uint256 pricePerShare = roundPricePerShare[vaultState.round - 1];\n        return\n            ShareMath.sharesToAsset(shares(account), pricePerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        uint256 heldByAccount = shareBalancesHeldByAccount(account);\n        uint256 heldByVault = shareBalancesHeldByVault(account);\n        return heldByAccount + heldByVault;\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance held by the account\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     */\n    function shareBalancesHeldByAccount(\n        address account\n    ) public view returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance held by the vault\n     * @param account is the account to lookup share balance for\n     * @return heldByVault is the shares held by the vault (unredeemedShares)\n     */\n    function shareBalancesHeldByVault(\n        address account\n    ) public view returns (uint256) {\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[account];\n\n        return\n            stakeReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[stakeReceipt.round],\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    /**\n     * @notice Returns the shared token decimals for OFT\n     */\n    function sharedDecimals() public view virtual override returns (uint8) {\n        return decimals();\n    }\n\n    /**\n     * @notice Returns the maximum amount of wrapped tokens\n     * that can be deposited into the vault\n     */\n    function cap() public view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    /**\n     * @notice Returns the total amount of wrapped tokens\n     * for which share issuance is pending\n     */\n    function totalPending() public view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /**\n     * @notice Returns the current round number\n     */\n    function round() public view returns (uint256) {\n        return vaultState.round;\n    }\n\n    // #############################################\n    // OTHER\n    // #############################################\n\n    /**\n     * @notice Rescues ERC20 tokens stuck in the contract\n     * @param _token The address of the token to rescue\n     * @param amount The amount of tokens to rescue\n     * @dev Only callable by owner\n     */\n    function rescueTokens(address _token, uint256 amount) external onlyOwner {\n        if (_token == address(0)) revert AddressMustBeNonZero();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    }
}