{
    "vfp_id": "vfp_00054",
    "project_name": "cantina_liminal_oct2025.pdf",
    "findings": [
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Performance Fee Calculation",
            "description": "1. **Description:** The collectPerformanceFee function in the FeeManager contract fails to differentiate between actual yield generated by the vault's investment strategies and new capital deposited by users. This leads to inaccurate performance fee calculations.\n2. **Cause:** The root cause is a logical flaw in the fee calculation mechanism, which uses a metric that does not isolate real gains from simple inflows of new capital.\n3. **Exploitation:** An attacker or large depositor could potentially manipulate the timing and size of deposits to artificially inflate the perceived performance, thereby either avoiding fair fee payments or causing the system to overcharge other users.\n4. **Impact:** The impact includes economic unfairness, misallocation of fees, potential loss of user funds due to incorrect fee distribution, and erosion of trust in the vault's financial integrity.\n",
            "severity": "Medium",
            "location": [
                "FeeManager.sol::collectPerformanceFee"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "High-Water Mark Logic Penalizes Performance Fee Collection",
            "description": "The collectPerformanceFee function in FeeManager updates the lastSupplyForPerformance state variable before minting fee shares. This causes the high-water mark to be set pre-dilution, so the next fee calculation interprets the dilution as a performance loss.\nThe root cause is incorrect ordering of state updates relative to share minting, violating the intended economic model.\nThis unfairly penalizes the fee recipient by requiring performance to \"recover\" the value of previously taken fees before new fees can accrue.\nThe impact is a disincentive for fee collection and potential misalignment of economic incentives, even when underlying strategies are profitable net of fees.\n",
            "severity": "Medium",
            "location": [
                "FeeManager.sol#L135-L190"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Client-Identified Flaw in Performance Fee Calculation Under Rework",
            "description": "A flaw was identified in the performance fee calculation logic in FeeManager.sol where the high-water mark is updated before minting fee shares, leading to incorrect performance tracking.\nThe root cause is the same as in finding 4.1 â€” improper sequencing of state updates in the fee collection process.\nThis results in the protocol requiring recovery of previously taken fees before accruing new ones, distorting the performance fee mechanism.\nThe impact is economic inefficiency and misaligned incentives in the fee structure, potentially affecting protocol sustainability and participant rewards.\n",
            "severity": "Medium",
            "location": [
                "FeeManager.sol#L135-L143"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        }
    ],
    "affected_files": {
        "FeeManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {INAVOracle} from \"./interfaces/INAVOracle.sol\";\nimport {IShareManager} from \"./interfaces/IShareManager.sol\";\n\n/**\n * @title FeeManager\n * @notice Centralized fee management for the vault system\n * @dev FEE_COLLECTOR_ROLE must be granted to the fee manager address\n * @dev Handles performance fees and management fees across all pipes\n */\ncontract FeeManager is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using Math for uint256;\n\n    /// @notice Role for timelock operations\n    bytes32 public constant SAFE_MANAGER_ROLE = keccak256(\"SAFE_MANAGER_ROLE\");\n    bytes32 public constant FEE_COLLECTOR_ROLE = keccak256(\"FEE_COLLECTOR_ROLE\");\n\n    /// @notice Fee configuration\n    struct FeeConfig {\n        uint256 managementFeeBps; // Annual management fee in basis points\n        uint256 performanceFeeBps; // Performance fee in basis points\n    }\n\n    /// @custom:storage-location erc7201:liminal.feeManager.v1\n    struct FeeManagerStorage {\n        /// @notice Core contracts\n        IShareManager shareManager;\n        INAVOracle navOracle;\n        /// @notice Fee receiver address\n        address feeReceiver;\n        /// @notice Fee configuration\n        FeeConfig fees;\n        /// @notice Performance fee tracking\n        uint256 lastNAVForPerformance;\n        uint256 lastSupplyForPerformance;\n        uint256 lastManagementFeeTimestamp;\n        /// @notice High-Water Mark accumulator for performance fee tracking (PPS-based)\n        /// @dev Stores the Price Per Share (PPS) at the last point fees were accrued\n        /// @dev Stored with 1e18 precision. Fees only charged when PPS increases above this mark\n        uint256 ppsTrack;\n        /// @notice Accrued performance fees in assets (18 decimals) calculated but not yet minted\n        /// @dev Accumulates on every deposit/withdrawal to prevent yield loss with infrequent collections\n        /// @dev Only converted to shares when collectPerformanceFee() is called\n        uint256 accruedPerformanceFeeInAssets;\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Safe manager address\n        address safeManager;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.feesManager.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant FEE_MANAGER_STORAGE_LOCATION =\n        0x4b4022d112866c56e7ce4fba50b143067d70699d5800adf7d8c91134a5bcaf00;\n\n    function _getFeeManagerStorage() private pure returns (FeeManagerStorage storage $) {\n        assembly {\n            $.slot := FEE_MANAGER_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Events\n    event PerformanceFeeTaken(uint256 sharesMinted, uint256 feeInAssets, uint256 newHighWatermarkPPS);\n    event NoPerformanceFeeTaken(uint256 currentPPS, uint256 highWatermarkPPS);\n    event ManagementFeeTaken(uint256 sharesMinted, uint256 annualizedValue, uint256 timestamp);\n    event FeeConfigUpdated(uint256 managementFeeBps, uint256 performanceFeeBps);\n    event FeeReceiverUpdated(address indexed newReceiver);\n    event TimeLockControllerUpdated(address indexed oldTimeLockController, address indexed newTimeLockController);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        require(msg.sender == $.timeLockController, \"FeeManager: only timelock\");\n        _;\n    }\n\n    /// @notice Modifier for safe manager-protected functions\n    modifier onlySafeManager() {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        require(msg.sender == $.safeManager, \"FeeManager: only safe manager\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the fee manager\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param _shareManager Share manager contract\n     * @param _navOracle NAV oracle contract\n     * @param _feeReceiver Address to receive fees\n     * @param _deployer Deployer address (receives DEFAULT_ADMIN_ROLE)\n     * @param _safeManager Safe manager address (for operational functions, not ownership)\n     * @param _managementFeeBps Annual management fee in basis points\n     * @param _performanceFeeBps Performance fee in basis points\n     * @param _timeLockController Timelock controller for critical operations\n     */\n    function initialize(\n        address _shareManager,\n        address _navOracle,\n        address _feeReceiver,\n        address _deployer,\n        address _safeManager,\n        uint256 _managementFeeBps,\n        uint256 _performanceFeeBps,\n        address _timeLockController\n    ) external initializer {\n        require(_shareManager != address(0), \"FeeManager: zero share manager\");\n        require(_navOracle != address(0), \"FeeManager: zero nav oracle\");\n        require(_feeReceiver != address(0), \"FeeManager: zero fee receiver\");\n        require(_deployer != address(0), \"FeeManager: zero deployer\");\n        require(_safeManager != address(0), \"FeeManager: zero safe manager\");\n        require(_timeLockController != address(0), \"FeeManager: zero timelock\");\n        require(_managementFeeBps <= 500, \"FeeManager: management fee too high\"); // Max 5%\n        require(_performanceFeeBps <= 3000, \"FeeManager: performance fee too high\"); // Max 30%\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        $.shareManager = IShareManager(_shareManager);\n        $.navOracle = INAVOracle(_navOracle);\n        $.feeReceiver = _feeReceiver;\n        $.timeLockController = _timeLockController;\n        $.safeManager = _safeManager;\n\n        $.fees = FeeConfig({managementFeeBps: _managementFeeBps, performanceFeeBps: _performanceFeeBps});\n\n        // Initialize high-water mark accumulator to initial PPS (1e18 = 1.0 share price)\n        // This is fair: sets the baseline at the initial share price\n        $.ppsTrack = 1e18;\n        $.lastNAVForPerformance = $.navOracle.getNAV();\n        $.lastSupplyForPerformance = $.shareManager.totalSupply();\n        $.lastManagementFeeTimestamp = block.timestamp;\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(SAFE_MANAGER_ROLE, _safeManager);\n    }\n\n    /**\n     * @notice Internal function to accrue performance fees without minting shares\n     * @dev Called on deposits/withdrawals to checkpoint fees earned so far\n     * @dev Prevents yield loss with infrequent collections while avoiding dilution on every deposit\n     */\n    function _accruePerformanceFee() internal {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        \n        if ($.fees.performanceFeeBps == 0) return;\n        \n        uint256 currentNAV = $.navOracle.getNAV();\n        uint256 currentSupply = $.shareManager.totalSupply();\n        \n        if (currentSupply == 0) return;\n        if ($.lastSupplyForPerformance == 0) {\n            // First time setup\n            $.ppsTrack = currentNAV.mulDiv(1e18, currentSupply, Math.Rounding.Floor);\n            $.lastSupplyForPerformance = currentSupply;\n            $.lastNAVForPerformance = currentNAV;\n            return;\n        }\n        \n        // Calculate current PPS\n        uint256 currentPPS = currentNAV.mulDiv(1e18, currentSupply, Math.Rounding.Floor);\n        \n        // If PPS increased, accrue the fee (but don't mint shares yet)\n        if (currentPPS > $.ppsTrack) {\n            uint256 ppsIncrease = currentPPS - $.ppsTrack;\n            uint256 profitInAssets = ppsIncrease.mulDiv($.lastSupplyForPerformance, 1e18, Math.Rounding.Floor);\n            uint256 feeInAssets = profitInAssets.mulDiv($.fees.performanceFeeBps, 10_000, Math.Rounding.Floor);\n            \n            // Add to accrued fees\n            $.accruedPerformanceFeeInAssets += feeInAssets;\n            \n            // Update checkpoint for next accrual\n            $.ppsTrack = currentPPS;\n        }\n        \n        // Always update supply and NAV tracking\n        $.lastSupplyForPerformance = currentSupply;\n        $.lastNAVForPerformance = currentNAV;\n    }\n\n    /**\n     * @notice Collect all accrued performance fees by minting shares\n     * @dev Accrues any new fees first, then mints shares for all accrued fees\n     * @dev This is the ONLY function that actually mints performance fee shares\n     * @return sharesMinted Amount of shares minted as fee\n     */\n    function collectPerformanceFee() external onlySafeManager nonReentrant returns (uint256 sharesMinted) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        \n        // First accrue any new performance fees\n        _accruePerformanceFee();\n        \n        // If no accrued fees, nothing to collect\n        if ($.accruedPerformanceFeeInAssets == 0) {\n            emit NoPerformanceFeeTaken(0, $.ppsTrack);\n            return 0;\n        }\n        \n        uint256 currentNAV = $.navOracle.getNAV();\n        uint256 currentSupply = $.shareManager.totalSupply();\n        \n        if (currentSupply == 0) return 0;\n        \n        // Convert all accrued fees to shares\n        uint256 feeInAssets = $.accruedPerformanceFeeInAssets;\n        uint256 navPostFee = currentNAV - feeInAssets;\n        sharesMinted = feeInAssets.mulDiv(currentSupply, navPostFee, Math.Rounding.Floor);\n        \n        if (sharesMinted > 0) {\n            $.shareManager.mintFeesShares($.feeReceiver, sharesMinted);\n            \n            // Reset accrued fees after minting\n            $.accruedPerformanceFeeInAssets = 0;\n            \n            // Update tracking after minting\n            $.lastSupplyForPerformance = $.shareManager.totalSupply();\n            $.lastNAVForPerformance = currentNAV;\n            \n            emit PerformanceFeeTaken(sharesMinted, feeInAssets, $.ppsTrack);\n        }\n        \n        return sharesMinted;\n    }\n\n    /**\n     * @notice Public function to accrue performance fees without collecting them\n     * @dev Can be called by DepositPipe/RedemptionPipe before mints/burns\n     * @dev Checkpoints fees so they're not lost with infrequent collections\n     */\n    function accruePerformanceFee() external {\n        _accruePerformanceFee();\n    }\n\n    /**\n     * @notice Collect management fee based on time elapsed\n     * @dev Mints shares to fee receiver proportional to time passed\n     * @return sharesMinted Amount of shares minted as fee\n     */\n    function collectManagementFee() external nonReentrant onlySafeManager returns (uint256 sharesMinted) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        if ($.fees.managementFeeBps == 0) return 0;\n\n        uint256 currentTime = block.timestamp;\n        uint256 timeElapsed = currentTime - $.lastManagementFeeTimestamp;\n\n        // Only collect if more than 1 day has passed\n        if (timeElapsed < 1 days) return 0;\n\n        uint256 currentSupply = $.shareManager.totalSupply();\n        if (currentSupply == 0) return 0;\n\n        // Calculate annualized management fee with dilution adjustment\n        // Formula: shares = supply * feeRate / (1 - feeRate)\n        // This ensures fee recipient receives exactly the intended percentage after dilution\n        uint256 feeRateNumerator = $.fees.managementFeeBps * timeElapsed;\n        uint256 feeRateDenominator = 10_000 * 365 days;\n\n        sharesMinted = currentSupply.mulDiv(\n            feeRateNumerator,\n            feeRateDenominator - feeRateNumerator,\n            Math.Rounding.Floor\n        );\n\n        if (sharesMinted > 0) {\n            $.shareManager.mintFeesShares($.feeReceiver, sharesMinted);\n\n            // Calculate annualized value for event\n            uint256 currentNAV = $.navOracle.getNAV();\n            uint256 annualizedValue = currentNAV.mulDiv($.fees.managementFeeBps, 10_000);\n\n            emit ManagementFeeTaken(sharesMinted, annualizedValue, currentTime);\n\n            // Management fee mints dilute PPS without changing NAV.\n            // Recalculate and update the PPS-based high-water mark after the dilution.\n            // New supply includes the minted management fee shares.\n            uint256 newSupply = $.shareManager.totalSupply();\n            uint256 newPPS = currentNAV.mulDiv(1e18, newSupply, Math.Rounding.Floor);\n            $.ppsTrack = newPPS;\n            \n            // Also update the tracking variables\n            $.lastNAVForPerformance = currentNAV;\n            $.lastSupplyForPerformance = newSupply;\n        }\n\n        $.lastManagementFeeTimestamp = currentTime;\n        return sharesMinted;\n    }\n\n    /**\n     * @notice Update timelock controller address\n     * @param _timelockController New timelock controller address\n     */\n    function setTimelockController(address _timelockController) external onlyTimelock {\n        require(_timelockController != address(0), \"FeeManager: zero timelock\");\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        address oldTimeLockController = $.timeLockController;\n        $.timeLockController = _timelockController;\n        emit TimeLockControllerUpdated(oldTimeLockController, _timelockController);\n    }\n\n    /**\n     * @notice Update fee configuration\n     * @param _managementFeeBps New management fee in basis points\n     * @param _performanceFeeBps New performance fee in basis points\n     */\n    function setFees(uint256 _managementFeeBps, uint256 _performanceFeeBps) external onlyTimelock {\n        require(_managementFeeBps <= 500, \"FeeManager: management fee too high\");\n        require(_performanceFeeBps <= 3000, \"FeeManager: performance fee too high\");\n\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        $.fees.managementFeeBps = _managementFeeBps;\n        $.fees.performanceFeeBps = _performanceFeeBps;\n\n        emit FeeConfigUpdated(_managementFeeBps, _performanceFeeBps);\n    }\n\n    /**\n     * @notice Update fee receiver address\n     * @param _feeReceiver New fee receiver address\n     */\n    function setFeeReceiver(address _feeReceiver) external onlyTimelock {\n        require(_feeReceiver != address(0), \"FeeManager: zero address\");\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        $.feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    /**\n     * @notice Reset performance fee baseline and PPS high-water mark accumulator\n     * @dev Used after significant events or initial setup\n     * @dev Resets the high-water mark to current PPS\n     */\n    function resetPerformanceBaseline() external onlyRole(SAFE_MANAGER_ROLE) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        uint256 currentNAV = $.navOracle.getNAV();\n        uint256 currentSupply = $.shareManager.totalSupply();\n        \n        uint256 currentPPS;\n        if (currentSupply == 0) {\n            currentPPS = 1e18; // Default to 1.0 if no shares\n        } else {\n            currentPPS = currentNAV.mulDiv(1e18, currentSupply, Math.Rounding.Floor);\n        }\n        \n        $.ppsTrack = currentPPS;\n        $.lastNAVForPerformance = currentNAV;\n        $.lastSupplyForPerformance = currentSupply;\n    }\n\n\n    /**\n     * @notice Get current fee configuration\n     * @return managementFeeBps Annual management fee in basis points\n     * @return performanceFeeBps Performance fee in basis points\n     */\n    function getFees() external view returns (uint256 managementFeeBps, uint256 performanceFeeBps) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        return ($.fees.managementFeeBps, $.fees.performanceFeeBps);\n    }\n\n    /// @notice Get last NAV for performance fee calculation\n    function lastNAVForPerformance() external view returns (uint256) {\n        return _getFeeManagerStorage().lastNAVForPerformance;\n    }\n\n    /// @notice Get last supply for performance fee calculation\n    function lastSupplyForPerformance() external view returns (uint256) {\n        return _getFeeManagerStorage().lastSupplyForPerformance;\n    }\n\n    /// @notice Get last management fee timestamp\n    function lastManagementFeeTimestamp() external view returns (uint256) {\n        return _getFeeManagerStorage().lastManagementFeeTimestamp;\n    }\n\n    /// @notice Get fee receiver address\n    function feeReceiver() external view returns (address) {\n        return _getFeeManagerStorage().feeReceiver;\n    }\n\n    /// @notice Get timelock controller address\n    function timeLockController() external view returns (address) {\n        return _getFeeManagerStorage().timeLockController;\n    }\n\n    /// @notice Get high-water mark accumulator (PPS at last performance fee collection, stored with 1e18 precision)\n    function highWatermarkPPS() external view returns (uint256) {\n        return _getFeeManagerStorage().ppsTrack;\n    }\n\n    /// @notice Get accrued performance fees in assets (18 decimals) not yet minted as shares\n    function accruedPerformanceFeeInAssets() external view returns (uint256) {\n        return _getFeeManagerStorage().accruedPerformanceFeeInAssets;\n    }\n}\n"
    }
}