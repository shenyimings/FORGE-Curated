{
    "vfp_id": "vfp_00016",
    "project_name": "cantina_uniswap_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Execute calls can be front-run",
            "description": "1. **Description:** The `execute` function in the MinimalDelegation contract is publicly callable, allowing any external address to invoke it if a valid signature is provided. This enables front-running of execute calls by malicious actors.\n2. **Cause:** The lack of an intended executor address in the signature's domain separator allows any relayer to submit the transaction, removing execution exclusivity.\n3. **Exploitation:** An attacker can front-run a legitimate execute call with a zero-value transaction, potentially causing batched calls to revert, especially when `shouldRevert` is false, thereby disrupting the intended execution flow.\n4. **Impact:** This can lead to denial of service or manipulation of transaction outcomes, undermining the reliability of batched operations.\n",
            "severity": "High",
            "location": [
                "MinimalDelegation.sol::execute#66"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Execute calls can be forced to fail with an out of gas error",
            "description": "1. **Description:** The `execute` function allows a malicious user to specify a gas limit that is sufficient for the high-level validation but insufficient for the low-level `_dispatch` and `_execute` calls, causing them to fail with an out-of-gas error.\n2. **Cause:** The contract does not enforce a minimum gas limit for the execution phase, relying solely on the caller's gas allocation.\n3. **Exploitation:** An attacker can submit a transaction with a gas limit just above the threshold required for signature validation but below what is needed for the actual call execution, forcing the subcalls to revert.\n4. **Impact:** This can result in partial execution failure of batched calls, especially when `shouldRevert` is false, leading to inconsistent state changes and potential fund loss.\n",
            "severity": "High",
            "location": [
                "MinimalDelegation.sol::execute#66"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        }
    ],
    "affected_files": {
        "MinimalDelegation.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.29;\n\nimport {EnumerableSetLib} from \"solady/utils/EnumerableSetLib.sol\";\nimport {Receiver} from \"solady/accounts/Receiver.sol\";\nimport {IMinimalDelegation} from \"./interfaces/IMinimalDelegation.sol\";\nimport {Call, CallLib} from \"./libraries/CallLib.sol\";\nimport {IKeyManagement} from \"./interfaces/IKeyManagement.sol\";\nimport {Key, KeyLib, KeyType} from \"./libraries/KeyLib.sol\";\nimport {ModeDecoder} from \"./libraries/ModeDecoder.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {IERC1271} from \"./interfaces/IERC1271.sol\";\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC7201} from \"./ERC7201.sol\";\nimport {CalldataDecoder} from \"./libraries/CalldataDecoder.sol\";\nimport {P256} from \"@openzeppelin/contracts/utils/cryptography/P256.sol\";\nimport {PackedUserOperation} from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport {NonceManager} from \"./NonceManager.sol\";\nimport {IAccount} from \"account-abstraction/interfaces/IAccount.sol\";\nimport {ERC4337Account} from \"./ERC4337Account.sol\";\nimport {IERC4337Account} from \"./interfaces/IERC4337Account.sol\";\nimport {WrappedDataHash} from \"./libraries/WrappedDataHash.sol\";\nimport {ERC7914} from \"./ERC7914.sol\";\nimport {SignedBatchedCallLib, SignedBatchedCall} from \"./libraries/SignedBatchedCallLib.sol\";\nimport {BatchedCallLib, BatchedCall} from \"./libraries/BatchedCallLib.sol\";\nimport {KeyManagement} from \"./KeyManagement.sol\";\nimport {IHook} from \"./interfaces/IHook.sol\";\nimport {HooksLib} from \"./libraries/HooksLib.sol\";\nimport {ModeDecoder} from \"./libraries/ModeDecoder.sol\";\nimport {Settings, SettingsLib} from \"./libraries/SettingsLib.sol\";\nimport {Static} from \"./libraries/Static.sol\";\nimport {ERC7821} from \"./ERC7821.sol\";\nimport {IERC7821} from \"./interfaces/IERC7821.sol\";\nimport {Multicall} from \"./Multicall.sol\";\n\ncontract MinimalDelegation is\n    IMinimalDelegation,\n    ERC7821,\n    ERC1271,\n    EIP712,\n    ERC4337Account,\n    Receiver,\n    KeyManagement,\n    NonceManager,\n    ERC7914,\n    ERC7201,\n    Multicall\n{\n    using ModeDecoder for bytes32;\n    using KeyLib for *;\n    using EnumerableSetLib for EnumerableSetLib.Bytes32Set;\n    using CalldataDecoder for bytes;\n    using WrappedDataHash for bytes32;\n    using CallLib for Call[];\n    using BatchedCallLib for BatchedCall;\n    using SignedBatchedCallLib for SignedBatchedCall;\n    using HooksLib for IHook;\n    using SettingsLib for Settings;\n\n    function execute(BatchedCall memory batchedCall) public payable {\n        bytes32 keyHash = msg.sender.toKeyHash();\n        if (!_isOwnerOrAdmin(keyHash)) revert Unauthorized();\n        _dispatch(batchedCall, keyHash);\n    }\n\n    function execute(SignedBatchedCall memory signedBatchedCall, bytes memory wrappedSignature) public payable {\n        _handleVerifySignature(signedBatchedCall, wrappedSignature);\n        _dispatch(signedBatchedCall.batchedCall, signedBatchedCall.keyHash);\n    }\n\n    function execute(bytes32 mode, bytes memory executionData) external payable override {\n        if (!mode.isBatchedCall()) revert IERC7821.UnsupportedExecutionMode();\n        Call[] memory calls = abi.decode(executionData, (Call[]));\n        BatchedCall memory batchedCall = BatchedCall({calls: calls, shouldRevert: mode.shouldRevert()});\n        execute(batchedCall);\n    }\n\n    /// @dev This function is executeable only by the EntryPoint contract, and is the main pathway for UserOperations to be executed.\n    /// UserOperations can be executed through the execute function, but another method of authorization (ie through a passed in signature) is required.\n    /// userOp.callData is abi.encodeCall(IAccountExecute.executeUserOp.selector, (abi.encode(Call[]), bool))\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32) external onlyEntryPoint {\n        // Parse the keyHash from the signature. This is the keyHash that has been pre-validated as the correct signer over the UserOp data\n        // and must be used to check further on-chain permissions over the call execution.\n        (bytes32 keyHash,,) = abi.decode(userOp.signature, (bytes32, bytes, bytes));\n\n        // The mode is only passed in to signify the EXEC_TYPE of the calls.\n        bytes calldata executionData = userOp.callData.removeSelector();\n        (BatchedCall memory batchedCall) = abi.decode(executionData, (BatchedCall));\n\n        _dispatch(batchedCall, keyHash);\n    }\n\n    function _dispatch(BatchedCall memory batchedCall, bytes32 keyHash) private {\n        for (uint256 i = 0; i < batchedCall.calls.length; i++) {\n            (bool success, bytes memory output) = _execute(batchedCall.calls[i], keyHash);\n            // Reverts with the first call that is unsuccessful if the EXEC_TYPE is set to force a revert.\n            if (!success && batchedCall.shouldRevert) revert IMinimalDelegation.CallFailed(output);\n        }\n    }\n\n    /// @dev Executes a low level call using execution hooks if set\n    function _execute(Call memory _call, bytes32 keyHash) internal returns (bool success, bytes memory output) {\n        // Per ERC7821, replace address(0) with address(this)\n        address to = _call.to == address(0) ? address(this) : _call.to;\n\n        Settings settings = getKeySettings(keyHash);\n        if (!settings.isAdmin() && to == address(this)) revert IKeyManagement.OnlyAdminCanSelfCall();\n\n        IHook hook = settings.hook();\n        bytes memory beforeExecuteData;\n        if (hook.hasPermission(HooksLib.BEFORE_EXECUTE_FLAG)) {\n            beforeExecuteData = hook.handleBeforeExecute(keyHash, to, _call.value, _call.data);\n        }\n\n        (success, output) = to.call{value: _call.value}(_call.data);\n\n        if (hook.hasPermission(HooksLib.AFTER_EXECUTE_FLAG)) hook.handleAfterExecute(keyHash, beforeExecuteData);\n    }\n\n    /// @inheritdoc IAccount\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n        external\n        onlyEntryPoint\n        returns (uint256 validationData)\n    {\n        _payEntryPoint(missingAccountFunds);\n        (bytes32 keyHash, bytes memory signature, bytes memory hookData) =\n            abi.decode(userOp.signature, (bytes32, bytes, bytes));\n\n        /// The userOpHash does not need to be safe hashed with _hashTypedData, as the EntryPoint will always call the sender contract of the UserOperation for validation.\n        /// It is possible that the signature is a wrapped signature, so any supported key can be used to validate the signature.\n        /// This is because the signature field is not defined by the protocol, but by the account implementation. See https://eips.ethereum.org/EIPS/eip-4337#definitions\n        Key memory key = getKey(keyHash);\n        bool isValid = key.verify(userOpHash, signature);\n\n        // If signature verification failed, return failure immediately WITHOUT expiry as it cannot be trusted\n        if (!isValid) {\n            return SIG_VALIDATION_FAILED;\n        }\n\n        Settings settings = getKeySettings(keyHash);\n        _checkExpiry(settings);\n\n        /// validationData is (uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)\n        /// `validAfter` is always 0.\n        validationData = uint256(settings.expiration()) << 160 | SIG_VALIDATION_SUCCEEDED;\n\n        IHook hook = settings.hook();\n        if (hook.hasPermission(HooksLib.AFTER_VALIDATE_USER_OP_FLAG)) {\n            // The hook can override the validation data\n            validationData = hook.handleAfterValidateUserOp(keyHash, userOp, userOpHash, hookData);\n        }\n    }\n\n    /// @dev This function is used to handle the verification of signatures sent through execute()\n    function _handleVerifySignature(SignedBatchedCall memory signedBatchedCall, bytes memory wrappedSignature)\n        private\n    {\n        _useNonce(signedBatchedCall.nonce);\n\n        (bytes memory signature, bytes memory hookData) = abi.decode(wrappedSignature, (bytes, bytes));\n\n        bytes32 digest = _hashTypedData(signedBatchedCall.hash());\n\n        Key memory key = getKey(signedBatchedCall.keyHash);\n        bool isValid = key.verify(digest, signature);\n        if (!isValid) revert IMinimalDelegation.InvalidSignature();\n\n        Settings settings = getKeySettings(signedBatchedCall.keyHash);\n        _checkExpiry(settings);\n\n        IHook hook = settings.hook();\n        if (hook.hasPermission(HooksLib.AFTER_VERIFY_SIGNATURE_FLAG)) {\n            // Hook must revert to signal that signature verification\n            hook.handleAfterVerifySignature(signedBatchedCall.keyHash, digest, hookData);\n        }\n    }\n\n    /// @notice Reverts if the key settings are expired\n    function _checkExpiry(Settings settings) private view {\n        (bool isExpired, uint40 expiry) = settings.isExpired();\n        if (isExpired) revert IKeyManagement.KeyExpired(expiry);\n    }\n\n    /// @inheritdoc ERC1271\n    function isValidSignature(bytes32 data, bytes calldata wrappedSignature)\n        public\n        view\n        override(ERC1271, IERC1271)\n        returns (bytes4 result)\n    {\n        (bytes32 keyHash, bytes memory signature, bytes memory hookData) =\n            abi.decode(wrappedSignature, (bytes32, bytes, bytes));\n        bytes32 digest = _hashTypedData(data.hashWithWrappedType());\n\n        Key memory key = getKey(keyHash);\n        bool isValid = key.verify(digest, signature);\n        if (!isValid) return _1271_INVALID_VALUE;\n        result = _1271_MAGIC_VALUE;\n\n        Settings settings = getKeySettings(keyHash);\n        _checkExpiry(settings);\n\n        IHook hook = settings.hook();\n        if (hook.hasPermission(HooksLib.AFTER_IS_VALID_SIGNATURE_FLAG)) {\n            // Hook can override the result\n            result = hook.handleAfterIsValidSignature(keyHash, digest, hookData);\n        }\n    }\n}\n"
    }
}