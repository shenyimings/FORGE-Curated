{
    "vfp_id": "vfp_00167",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect Execution Context for Transfer on Core When Finalizing a Swap",
            "description": "The `finalizeSwapFlows` function in `HyperCoreFlowExecutor.sol` attempts to transfer final tokens from a `SwapHandler` back to the user by calling `HyperCoreLib.transferERC20CoreToCore` directly. However, this call is executed from the context of the `HyperCoreFlowExecutor` contract, not the `SwapHandler` contract that holds the funds. Since the `HyperCoreFlowExecutor` does not own the tokens, the transfer fails and reverts.\n\nThe root cause is a logic error in the execution context: the transfer is not delegated to the `SwapHandler`, which is the rightful owner of the swapped assets. An attacker cannot directly exploit this, but any user attempting to finalize a swap will face a transaction revert.\n\nThis results in a permanent denial-of-service (DoS) for all swap finalizations, freezing user funds in their respective `SwapHandler` contracts. Only a privileged administrator can manually recover the funds, which undermines the protocol's self-service design and availability.\n\nThis issue was resolved in pull request #29 by modifying `_finalizeSingleSwap` to delegate the transfer call to the correct `SwapHandler`.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::finalizeSwapFlows#558",
                "HyperCoreFlowExecutor.sol::_finalizeSingleSwap#670",
                "HyperCoreLib.transferERC20CoreToCore"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Token Index Prevents Asset Rescue",
            "description": "The `sweepOnCoreFromSwapHandler` function in `HyperCoreFlowExecutor.sol` is the only administrative mechanism to withdraw assets from a `SwapHandler` on the HyperCore layer. However, it incorrectly uses a market-specific `assetIndex` instead of the required token-specific `coreIndex` when calling `transferFundsToUserOnCore`.\n\nThis flaw stems from a mismatch in index types: `assetIndex` is used in the context of trading markets, while `coreIndex` is required for token identification on HyperCore. If these indices collide, the function may transfer the wrong asset.\n\nAn attacker could potentially manipulate market configurations to cause index collisions, leading to incorrect asset sweeps. More critically, if funds become stuck in a `SwapHandler` due to other failures, this function cannot reliably rescue them, rendering the assets permanently trapped.\n\nThis issue was resolved in pull request #30 by correcting the index to `coreTokenInfos[token].coreIndex`.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::sweepOnCoreFromSwapHandler#940",
                "SwapHandler.sol::transferFundsToUserOnCore"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect `finalToken` in `HyperEVMFallback`",
            "description": "In the `_initiateSwapFlow` function, if a user's HyperCore account is not activated and the swap is not sponsored, the flow diverts to `_fallbackHyperEVMFlow`. However, the `params` object passed to the fallback still contains the user's intended `finalToken`, not the `initialToken` they provided.\n\nThe cause is a logic error in parameter handling: the fallback mechanism is meant to refund the input token, but it attempts to transfer the output token instead. If the contract holds any balance of the `finalToken`, it will try to send it to the user.\n\nThis can lead to failed transactions if the contract does not hold the `finalToken`, causing the `safeTransfer` call to revert. In the worst case, if the contract does hold the `finalToken`, it may send an incorrect token to the user, leading to confusion and potential loss.\n\nThis issue was resolved in pull request #28 by setting `params.finalToken` to `initialToken` before calling the fallback function.\n",
            "severity": "Medium",
            "location": [
                "HyperCoreFlowExecutor.sol::_initiateSwapFlow#445",
                "HyperCoreFlowExecutor.sol::_fallbackHyperEVMFlow"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Stranded `baseToken` Dust in `SwapHandler` Contracts",
            "description": "The `HyperCoreFlowExecutor` transfers the entire `baseToken` amount to a `SwapHandler` for external swaps. Due to exchange precision limits (e.g., tick size, fees), small amounts of `baseToken` dust may remain in the `SwapHandler` after a swap.\n\nThe root cause is the lack of a mechanism to recover this dust. The existing `sweepOnCoreFromSwapHandler` function only sweeps the `finalToken`, not the `baseToken`. Over time, this leads to a cumulative loss of funds across multiple `SwapHandler` instances.\n\nWhile not directly exploitable, this results in inefficient capital use and commingling of user funds. A privileged role cannot recover the dust, increasing reliance on off-chain bots to manage residual balances.\n\nThis issue was resolved in pull request #40 by updating `sweepOnCoreFromSwapHandler` to sweep both `finalToken` and `baseToken`.\n",
            "severity": "Medium",
            "location": [
                "HyperCoreFlowExecutor.sol::_initiateSwapFlow#549",
                "HyperCoreFlowExecutor.sol::sweepOnCoreFromSwapHandler#934"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Finalize Swap Flow Lacks Configuration Check for Final Token",
            "description": "The `finalizeSwapFlows` function in `HyperCoreFlowExecutor` reads `FinalTokenInfo` from a mapping without validating whether the token is configured. If an unconfigured token is passed, the `swapHandler` will be address(0), leading to a balance check on the zero address, which may return a non-zero balance and prevent finalization.\nThe root cause is the absence of a validation check before using the `FinalTokenInfo` struct.\nA permissioned bot could accidentally pass an unconfigured token, or an attacker could attempt to manipulate the flow with invalid inputs, though the function is permissioned.\nThe impact is that legitimate swap flows may fail to finalize, leading to user fund delays or denial of service for valid transactions.\n",
            "severity": "Medium",
            "location": [
                "HyperCoreFlowExecutor.sol::finalizeSwapFlows#564-633",
                "HyperCoreFlowExecutor.sol::FinalTokenInfo#573",
                "HyperCoreFlowExecutor.sol::_getExistingFinalTokenInfo#223-228"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Inconsistent Storage Layout Pattern",
            "description": "The contracts use a hybrid storage model combining Solidity's default state variable layout with a namespaced storage pattern using EIP-7201.\nThe root cause is an attempt to manage contract size while minimizing refactoring, leading to mixed patterns.\nThis complexity increases the risk of storage collisions or developer errors during future upgrades.\nThe impact is reduced code readability, higher maintenance burden, and increased risk of storage-related vulnerabilities in future development.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        }
    ],
    "affected_files": {
        "HyperCoreFlowExecutor.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { AuthorizedFundedFlow } from \"./AuthorizedFundedFlow.sol\";\nimport { HyperCoreFlowRoles } from \"./HyperCoreFlowRoles.sol\";\nimport { DonationBox } from \"../../chain-adapters/DonationBox.sol\";\nimport { HyperCoreLib } from \"../../libraries/HyperCoreLib.sol\";\nimport { CoreTokenInfo } from \"./Structs.sol\";\nimport { FinalTokenInfo } from \"./Structs.sol\";\nimport { SwapHandler } from \"./SwapHandler.sol\";\nimport { BPS_SCALAR, BPS_DECIMALS } from \"./Constants.sol\";\nimport { CommonFlowParams } from \"./Structs.sol\";\n\n// Note: v5 is necessary since v4 does not use ERC-7201.\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title HyperCoreFlowExecutor\n * @notice Contract handling HyperCore interactions for transfer-to-core or swap-with-core actions after stablecoin bridge transactions\n * @dev This contract is designed to work with stablecoins. baseToken and every finalToken should all be stablecoins.\n *\n * @dev This contract is intended to be used exclusively via delegatecall from handler contracts.\n * Direct calls to this contract will produce incorrect results because functions rely on the\n * caller's context, including address(this) for calculations and storage layout from the\n * delegating contract.\n *\n * @custom:security-contact bugs@across.to\n */\ncontract HyperCoreFlowExecutor is AccessControlUpgradeable, AuthorizedFundedFlow, HyperCoreFlowRoles {\n    using SafeERC20 for IERC20;\n\n    // Common decimals scalars\n    uint256 public constant PPM_DECIMALS = 6;\n    uint256 public constant PPM_SCALAR = 10 ** PPM_DECIMALS;\n    uint64 public constant ONEX1e8 = 10 ** 8;\n\n    /// @notice The donation box contract.\n    DonationBox public immutable donationBox;\n\n    /// @notice All operations performed in this contract are relative to this baseToken\n    address public immutable baseToken;\n\n    /// @notice A struct used for storing state of a swap flow that has been initialized, but not yet finished\n    struct SwapFlowState {\n        address finalRecipient;\n        address finalToken;\n        uint64 minAmountToSend; // for sponsored: one to one, non-sponsored: one to one minus slippage\n        uint64 maxAmountToSend; // for sponsored: one to one (from total bridged amt), for non-sponsored: one to one, less bridging fees incurred\n        bool isSponsored;\n        bool finalized;\n    }\n\n    /// @custom:storage-location erc7201:HyperCoreFlowExecutor.main\n    struct MainStorage {\n        /// @notice A mapping of token addresses to their core token info.\n        mapping(address => CoreTokenInfo) coreTokenInfos;\n        /// @notice A mapping of token address to additional relevan info for final tokens, like Hyperliquid market params\n        mapping(address => FinalTokenInfo) finalTokenInfos;\n        /// @notice The block number of the last funds pull action per final token: either as a part of finalizing pending swaps,\n        /// or an admin funds pull\n        mapping(address finalToken => uint256 lastPullFundsBlock) lastPullFundsBlock;\n        /// @notice A mapping containing the pending state between initializing the swap flow and finalizing it\n        mapping(bytes32 quoteNonce => SwapFlowState swap) swaps;\n        /// @notice The cumulative amount of funds sponsored for each final token.\n        mapping(address => uint256) cumulativeSponsoredAmount;\n        /// @notice The cumulative amount of activation fees sponsored for each final token.\n        mapping(address => uint256) cumulativeSponsoredActivationFee;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"erc7201:HyperCoreFlowExecutor.main\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant MAIN_STORAGE_LOCATION = 0x6c70e510d36398bee89cc6e19ea6807a9915863d7d724712e0b3c15b01368b00;\n\n    function _getMainStorage() private pure returns (MainStorage storage $) {\n        assembly {\n            $.slot := MAIN_STORAGE_LOCATION\n        }\n    }\n\n    /**************************************\n     *            EVENTS               *\n     **************************************/\n\n    /**\n     * @notice Emitted when the donation box is insufficient funds.\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param token The token address that was requested\n     * @param amount The amount requested from the donation box\n     * @param balance The actual balance available in the donation box\n     */\n    event DonationBoxInsufficientFunds(bytes32 indexed quoteNonce, address token, uint256 amount, uint256 balance);\n\n    /**\n     * @notice Emitted whenever the account is not activated in the non-sponsored flow. We fall back to HyperEVM flow in that case\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param user The address of the user whose account is not activated\n     */\n    event AccountNotActivated(bytes32 indexed quoteNonce, address user);\n\n    /**\n     * @notice Emitted when a simple transfer to core is executed.\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param finalRecipient The address receiving the funds on HyperCore\n     * @param finalToken The token address being transferred\n     * @param evmAmountIn The amount received on HyperEVM (in finalToken)\n     * @param bridgingFeesIncurred The bridging fees incurred (in finalToken)\n     * @param evmAmountSponsored The amount sponsored from the donation box (in finalToken)\n     */\n    event SimpleTransferFlowCompleted(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // All amounts are in finalToken\n        uint256 evmAmountIn,\n        uint256 bridgingFeesIncurred,\n        uint256 evmAmountSponsored\n    );\n\n    /**\n     * @notice Emitted upon successful completion of fallback HyperEVM flow\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param finalRecipient The address receiving the funds on HyperEVM\n     * @param finalToken The token address being transferred\n     * @param evmAmountIn The amount received on HyperEVM (in finalToken)\n     * @param bridgingFeesIncurred The bridging fees incurred (in finalToken)\n     * @param evmAmountSponsored The amount sponsored from the donation box (in finalToken)\n     */\n    event FallbackHyperEVMFlowCompleted(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // All amounts are in finalToken\n        uint256 evmAmountIn,\n        uint256 bridgingFeesIncurred,\n        uint256 evmAmountSponsored\n    );\n\n    /**\n     * @notice Emitted when a swap flow is initialized\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param finalRecipient The address that will receive the swapped funds on HyperCore\n     * @param finalToken The token address to swap to\n     * @param evmAmountIn The amount received on HyperEVM (in baseToken)\n     * @param bridgingFeesIncurred The bridging fees incurred (in baseToken)\n     * @param coreAmountIn The amount sent to HyperCore (in finalToken)\n     * @param minAmountToSend Minimum amount to send to user after swap (in finalToken)\n     * @param maxAmountToSend Maximum amount to send to user after swap (in finalToken)\n     */\n    event SwapFlowInitialized(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // In baseToken\n        uint256 evmAmountIn,\n        uint256 bridgingFeesIncurred,\n        // In finalToken\n        uint256 coreAmountIn,\n        uint64 minAmountToSend,\n        uint64 maxAmountToSend\n    );\n\n    /**\n     * @notice Emitted when a swap flow is finalized\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param finalRecipient The address that received the swapped funds on HyperCore\n     * @param finalToken The token address that was swapped to\n     * @param totalSent Total amount sent to the final recipient on HyperCore (in finalToken)\n     * @param evmAmountSponsored The amount sponsored from the donation box (in EVM finalToken)\n     */\n    event SwapFlowFinalized(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // In finalToken\n        uint64 totalSent,\n        // In EVM finalToken\n        uint256 evmAmountSponsored\n    );\n\n    /**\n     * @notice Emitted upon cancelling a Limit order\n     * @param token The token address for which the limit order was placed\n     * @param cloid Client order ID of the cancelled limit order\n     */\n    event CancelledLimitOrder(address indexed token, uint128 indexed cloid);\n\n    /**\n     * @notice Emitted upon submitting a Limit order\n     * @param token The token address for which the limit order is placed\n     * @param priceX1e8 The limit order price (scaled by 1e8)\n     * @param sizeX1e8 The limit order size (scaled by 1e8)\n     * @param cloid Client order ID of the submitted limit order\n     */\n    event SubmittedLimitOrder(address indexed token, uint64 priceX1e8, uint64 sizeX1e8, uint128 indexed cloid);\n\n    /**\n     * @notice Emitted when we have to fall back from the swap flow because it's too expensive (either to sponsor or the slippage is too big)\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param finalToken The token address that was intended to be swapped to\n     * @param estBpsSlippage Estimated slippage in basis points\n     * @param maxAllowableBpsSlippage Maximum allowable slippage in basis points\n     */\n    event SwapFlowTooExpensive(\n        bytes32 indexed quoteNonce,\n        address indexed finalToken,\n        uint256 estBpsSlippage,\n        uint256 maxAllowableBpsSlippage\n    );\n\n    /**\n     * @notice Emitted when we can't bridge some token from HyperEVM to HyperCore\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param token The token address that is unsafe to bridge\n     * @param amount The amount that was attempted to be bridged\n     */\n    event UnsafeToBridge(bytes32 indexed quoteNonce, address indexed token, uint64 amount);\n\n    /**\n     * @notice Emitted whenever donationBox funds are used for activating a user account\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param finalRecipient The address of the user whose account is being activated\n     * @param fundingToken The token used to fund the account activation\n     * @param evmAmountSponsored The amount sponsored for activation (in EVM token)\n     */\n    event SponsoredAccountActivation(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed fundingToken,\n        uint256 evmAmountSponsored\n    );\n\n    /**\n     * @notice Emitted whenever a new CoreTokenInfo is configured\n     * @param token The token address being configured\n     * @param coreIndex The index of the token on HyperCore\n     * @param canBeUsedForAccountActivation Whether this token can be used to pay for account activation\n     * @param accountActivationFeeCore The account activation fee amount (in Core token units)\n     * @param bridgeSafetyBufferCore The safety buffer for bridging (in Core token units)\n     */\n    event SetCoreTokenInfo(\n        address indexed token,\n        uint32 coreIndex,\n        bool canBeUsedForAccountActivation,\n        uint64 accountActivationFeeCore,\n        uint64 bridgeSafetyBufferCore\n    );\n\n    /// @notice Emitted whenever a new FinalTokenInfo is configured\n    event SetFinalTokenInfo(\n        address indexed token,\n        uint32 spotIndex,\n        bool isBuy,\n        uint32 feePpm,\n        address indexed swapHandler,\n        uint32 suggestedFeeDiscountBps\n    );\n\n    /**\n     * @notice Emitted when we do an ad-hoc send of sponsorship funds to one of the Swap Handlers\n     * @param token The token address being sent to the swap handler\n     * @param evmAmountSponsored The amount sponsored from the donation box (in EVM token)\n     */\n    event SentSponsorshipFundsToSwapHandler(address indexed token, uint256 evmAmountSponsored);\n\n    /**************************************\n     *            ERRORS               *\n     **************************************/\n\n    /// @notice Thrown when an attempt to finalize a non-existing swap is made\n    error SwapDoesNotExist();\n\n    /// @notice Thrown when an attemp to finalize an already finalized swap is made\n    error SwapAlreadyFinalized();\n\n    /// @notice Thrown when trying to finalize a quoteNonce, calling a finalizeSwapFlows with an incorrect token\n    error WrongSwapFinalizationToken(bytes32 quoteNonce);\n\n    /// @notice Emitted when we're inside the sponsored flow and a user doesn't have a HyperCore account activated. The\n    /// bot should activate user's account first by calling `activateUserAccount`\n    error AccountNotActivatedError(address user);\n\n    /// @notice Thrown when we can't bridge some token from HyperEVM to HyperCore\n    error UnsafeToBridgeError(address token, uint64 amount);\n\n    /**************************************\n     *            MODIFIERS               *\n     **************************************/\n\n    modifier onlyExistingCoreToken(address evmTokenAddress) {\n        _getExistingCoreTokenInfo(evmTokenAddress);\n        _;\n    }\n\n    /// @notice Reverts if the token is not configured\n    function _getExistingCoreTokenInfo(\n        address evmTokenAddress\n    ) internal view returns (CoreTokenInfo memory coreTokenInfo) {\n        coreTokenInfo = _getMainStorage().coreTokenInfos[evmTokenAddress];\n        require(\n            coreTokenInfo.tokenInfo.evmContract != address(0) && coreTokenInfo.tokenInfo.weiDecimals != 0,\n            \"CoreTokenInfo not set\"\n        );\n    }\n\n    /// @notice Reverts if the token is not configured\n    function _getExistingFinalTokenInfo(\n        address evmTokenAddress\n    ) internal view returns (FinalTokenInfo memory finalTokenInfo) {\n        finalTokenInfo = _getMainStorage().finalTokenInfos[evmTokenAddress];\n        require(address(finalTokenInfo.swapHandler) != address(0), \"FinalTokenInfo not set\");\n    }\n\n    /**\n     *\n     * @param _donationBox Sponsorship funds live here\n     * @param _baseToken Main token used with this Forwarder\n     */\n    constructor(address _donationBox, address _baseToken) {\n        // Set immutable variables only\n        donationBox = DonationBox(_donationBox);\n        baseToken = _baseToken;\n    }\n\n    /****************************************\n     *            VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns the core token info for a given token address.\n     * @param token The token address.\n     * @return The core token info for the given token address.\n     */\n    function coreTokenInfos(address token) external view returns (CoreTokenInfo memory) {\n        return _getMainStorage().coreTokenInfos[token];\n    }\n\n    /**\n     * @notice Returns the final token info for a given token address.\n     * @param token The token address.\n     * @return The final token info for the given token address.\n     */\n    function finalTokenInfos(address token) external view returns (FinalTokenInfo memory) {\n        return _getMainStorage().finalTokenInfos[token];\n    }\n\n    /**\n     * @notice Returns the block number of the last time funds were pulled from the donation box.\n     * @param token The token address.\n     * @return The block number of the last time funds were pulled from the donation box for the given token address.\n     */\n    function lastPullFundsBlock(address token) external view returns (uint256) {\n        return _getMainStorage().lastPullFundsBlock[token];\n    }\n\n    /**\n     * @notice Returns the swap info for a given quote nonce.\n     * @param quoteNonce The quote nonce.\n     * @return The swap info for the given quote nonce.\n     */\n    function swaps(bytes32 quoteNonce) external view returns (SwapFlowState memory) {\n        return _getMainStorage().swaps[quoteNonce];\n    }\n\n    /**\n     * @notice Returns the cumulative sponsored amount for a given token address.\n     * @param token The token address.\n     * @return The cumulative sponsored amount for the given token address.\n     */\n    function cumulativeSponsoredAmount(address token) external view returns (uint256) {\n        return _getMainStorage().cumulativeSponsoredAmount[token];\n    }\n\n    /**\n     * @notice Returns the cumulative sponsored activation fee for a given token address.\n     * @param token The token address.\n     * @return The cumulative sponsored activation fee for the given token address.\n     */\n    function cumulativeSponsoredActivationFee(address token) external view returns (uint256) {\n        return _getMainStorage().cumulativeSponsoredActivationFee[token];\n    }\n\n    /**************************************\n     *      CONFIGURATION FUNCTIONS       *\n     **************************************/\n\n    /**\n     * @notice Set or update information for the token to use it in this contract\n     * @dev To be able to use the token in the swap flow, FinalTokenInfo has to be set as well\n     * @dev Setting core token info to incorrect values can lead to loss of funds. Should NEVER be unset while the\n     * finalTokenParams are not unset\n     * @param token The token address being configured\n     * @param coreIndex The index of the token on HyperCore\n     * @param canBeUsedForAccountActivation Whether this token can be used to pay for account activation\n     * @param accountActivationFeeCore The account activation fee amount (in Core token units)\n     * @param bridgeSafetyBufferCore The safety buffer for bridging (in Core token units)\n     */\n    function setCoreTokenInfo(\n        address token,\n        uint32 coreIndex,\n        bool canBeUsedForAccountActivation,\n        uint64 accountActivationFeeCore,\n        uint64 bridgeSafetyBufferCore\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setCoreTokenInfo(\n            token,\n            coreIndex,\n            canBeUsedForAccountActivation,\n            accountActivationFeeCore,\n            bridgeSafetyBufferCore\n        );\n    }\n\n    /**\n     * @notice Sets the parameters for a final token.\n     * @dev This function deploys a new SwapHandler contract if one is not already set. If the final token\n     * can't be used for account activation, the handler will be left unactivated and would need to be activated by the caller.\n     * @param finalToken The address of the final token.\n     * @param spotIndex The index of the asset in the Hyperliquid market.\n     * @param isBuy Whether the final token is a buy or a sell.\n     * @param feePpm The fee in parts per million.\n     * @param suggestedDiscountBps The suggested slippage in basis points.\n     */\n    function setFinalTokenInfo(\n        address finalToken,\n        uint32 spotIndex,\n        bool isBuy,\n        uint32 feePpm,\n        uint32 suggestedDiscountBps\n    ) external onlyExistingCoreToken(finalToken) onlyRole(DEFAULT_ADMIN_ROLE) {\n        MainStorage storage $ = _getMainStorage();\n        SwapHandler swapHandler = $.finalTokenInfos[finalToken].swapHandler;\n        if (address(swapHandler) == address(0)) {\n            bytes32 salt = _swapHandlerSalt(finalToken);\n            swapHandler = new SwapHandler{ salt: salt }();\n        }\n\n        $.finalTokenInfos[finalToken] = FinalTokenInfo({\n            spotIndex: spotIndex,\n            isBuy: isBuy,\n            feePpm: feePpm,\n            swapHandler: swapHandler,\n            suggestedDiscountBps: suggestedDiscountBps\n        });\n\n        // We don't allow SwapHandler accounts to be uninitiated. That could lead to loss of funds. They instead should\n        // be pre-funded using `predictSwapHandler` to predict their address\n        require(HyperCoreLib.coreUserExists(address(swapHandler)), \"SwapHandler @ core doesn't exist\");\n\n        emit SetFinalTokenInfo(finalToken, spotIndex, isBuy, feePpm, address(swapHandler), suggestedDiscountBps);\n    }\n\n    /**\n     * @notice Predicts the deterministic address of a SwapHandler for a given finalToken using CREATE2\n     * @param finalToken The token address for which to predict the SwapHandler address\n     * @return The predicted address of the SwapHandler contract\n     */\n    function predictSwapHandler(address finalToken) public view returns (address) {\n        bytes32 salt = _swapHandlerSalt(finalToken);\n        bytes32 initCodeHash = keccak256(type(SwapHandler).creationCode);\n        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash)))));\n    }\n\n    /// @notice Returns the salt to use when creating a SwapHandler via CREATE2\n    function _swapHandlerSalt(address finalToken) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), finalToken));\n    }\n\n    /**************************************\n     *            FLOW FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice External entrypoint to execute flow when called via delegatecall from a handler. Works with params\n     * checked by a handler. Params authorization by a handler is enforced via `onlyAuthorizedFlow` modifier\n     */\n    function executeFlow(CommonFlowParams memory params, uint256 maxUserSlippageBps) external onlyAuthorizedFlow {\n        if (params.finalToken == baseToken) {\n            _executeSimpleTransferFlow(params);\n        } else {\n            _initiateSwapFlow(params, maxUserSlippageBps);\n        }\n    }\n\n    /// @notice External entrypoint to execute simple transfer flow (see `executeFlow` comment for details)\n    function executeSimpleTransferFlow(CommonFlowParams memory params) external onlyAuthorizedFlow {\n        _executeSimpleTransferFlow(params);\n    }\n\n    /// @notice External entrypoint to execute fallback evm flow (see `executeFlow` comment for details)\n    function fallbackHyperEVMFlow(CommonFlowParams memory params) external onlyAuthorizedFlow {\n        _fallbackHyperEVMFlow(params);\n    }\n\n    /// @notice Execute a simple transfer flow in which we transfer `finalToken` to the user on HyperCore after receiving\n    /// an amount of finalToken from the user on HyperEVM\n    function _executeSimpleTransferFlow(CommonFlowParams memory params) internal {\n        address finalToken = params.finalToken;\n        MainStorage storage $ = _getMainStorage();\n        CoreTokenInfo memory coreTokenInfo = $.coreTokenInfos[finalToken];\n\n        // Check account activation\n        if (!HyperCoreLib.coreUserExists(params.finalRecipient)) {\n            if (params.maxBpsToSponsor > 0) {\n                revert AccountNotActivatedError(params.finalRecipient);\n            } else {\n                emit AccountNotActivated(params.quoteNonce, params.finalRecipient);\n                _fallbackHyperEVMFlow(params);\n                return;\n            }\n        }\n\n        // Calculate sponsorship amount in scope\n        uint256 amountToSponsor;\n        {\n            uint256 maxEvmAmountToSponsor = ((params.amountInEVM + params.extraFeesIncurred) * params.maxBpsToSponsor) /\n                BPS_SCALAR;\n            amountToSponsor = params.extraFeesIncurred;\n            if (amountToSponsor > maxEvmAmountToSponsor) {\n                amountToSponsor = maxEvmAmountToSponsor;\n            }\n\n            if (amountToSponsor > 0) {\n                if (!_availableInDonationBox(params.quoteNonce, finalToken, amountToSponsor)) {\n                    // If the full amount is not available in the donation box, use the balance of the token in the donation box\n                    amountToSponsor = IERC20(finalToken).balanceOf(address(donationBox));\n                }\n            }\n        }\n\n        // Calculate quoted amounts and check safety\n        uint256 quotedEvmAmount;\n        uint64 quotedCoreAmount;\n        {\n            uint256 finalAmount = params.amountInEVM + amountToSponsor;\n            (quotedEvmAmount, quotedCoreAmount) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n                finalAmount,\n                coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n            );\n            // If there are no funds left on the destination side of the bridge, the funds will be lost in the\n            // bridge. We check send safety via `isCoreAmountSafeToBridge`\n            if (\n                !HyperCoreLib.isCoreAmountSafeToBridge(\n                    coreTokenInfo.coreIndex,\n                    quotedCoreAmount,\n                    coreTokenInfo.bridgeSafetyBufferCore\n                )\n            ) {\n                // If the amount is not safe to bridge because the bridge doesn't have enough liquidity,\n                // fall back to sending user funds on HyperEVM.\n                _fallbackHyperEVMFlow(params);\n                emit UnsafeToBridge(params.quoteNonce, finalToken, quotedCoreAmount);\n                return;\n            }\n        }\n\n        if (amountToSponsor > 0) {\n            // This will succeed because we checked the balance earlier\n            donationBox.withdraw(IERC20(finalToken), amountToSponsor);\n        }\n\n        $.cumulativeSponsoredAmount[finalToken] += amountToSponsor;\n\n        // There is a very slim change that someone is sending > buffer amount in the same EVM block and the balance of\n        // the bridge is not enough to cover our transfer, so the funds are lost.\n        HyperCoreLib.transferERC20EVMToCore(\n            finalToken,\n            coreTokenInfo.coreIndex,\n            params.finalRecipient,\n            quotedEvmAmount,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        emit SimpleTransferFlowCompleted(\n            params.quoteNonce,\n            params.finalRecipient,\n            finalToken,\n            params.amountInEVM,\n            params.extraFeesIncurred,\n            amountToSponsor\n        );\n    }\n\n    /**\n     * @notice Initiates the swap flow. Sends the funds received on EVM side over to a SwapHandler corresponding to a\n     * finalToken. This is the first leg of the swap flow. Next, the bot should submit a limit order through a `submitLimitOrderFromBot`\n     * function, and then settle the flow via a `finalizeSwapFlows` function\n     * @dev Only works for stable -> stable swap flows (or equivalent token flows. Price between tokens is supposed to be approximately one to one)\n     * @param maxUserSlippageBps Describes a configured user setting. Slippage here is wrt the one to one exchange\n     */\n    function _initiateSwapFlow(CommonFlowParams memory params, uint256 maxUserSlippageBps) internal {\n        address initialToken = baseToken;\n\n        // Check account activation\n        if (!HyperCoreLib.coreUserExists(params.finalRecipient)) {\n            if (params.maxBpsToSponsor > 0) {\n                revert AccountNotActivatedError(params.finalRecipient);\n            } else {\n                emit AccountNotActivated(params.quoteNonce, params.finalRecipient);\n                params.finalToken = initialToken;\n                _fallbackHyperEVMFlow(params);\n                return;\n            }\n        }\n\n        MainStorage storage $ = _getMainStorage();\n        CoreTokenInfo memory initialCoreTokenInfo = $.coreTokenInfos[initialToken];\n        CoreTokenInfo memory finalCoreTokenInfo = $.coreTokenInfos[params.finalToken];\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(params.finalToken);\n\n        // Calculate limit order amounts and check if feasible\n        uint64 minAllowableAmountToForwardCore;\n        uint64 maxAllowableAmountToForwardCore;\n        // Estimated slippage in ppm, as compared to a one-to-one totalBridgedAmount -> finalAmount conversion\n        uint256 estSlippagePpm;\n        {\n            // In finalToken\n            (minAllowableAmountToForwardCore, maxAllowableAmountToForwardCore) = _calcAllowableAmtsSwapFlow(\n                params.amountInEVM,\n                params.extraFeesIncurred,\n                initialCoreTokenInfo,\n                finalCoreTokenInfo,\n                params.maxBpsToSponsor > 0,\n                maxUserSlippageBps\n            );\n\n            uint64 approxExecutionPriceX1e8 = _getApproxRealizedPrice(\n                finalTokenInfo,\n                finalCoreTokenInfo,\n                initialCoreTokenInfo\n            );\n            uint256 maxAllowableBpsDeviation = params.maxBpsToSponsor > 0 ? params.maxBpsToSponsor : maxUserSlippageBps;\n            if (finalTokenInfo.isBuy) {\n                if (approxExecutionPriceX1e8 < ONEX1e8) {\n                    estSlippagePpm = 0;\n                } else {\n                    // ceil\n                    estSlippagePpm = ((approxExecutionPriceX1e8 - ONEX1e8) * PPM_SCALAR + (ONEX1e8 - 1)) / ONEX1e8;\n                }\n            } else {\n                if (approxExecutionPriceX1e8 > ONEX1e8) {\n                    estSlippagePpm = 0;\n                } else {\n                    // ceil\n                    estSlippagePpm = ((ONEX1e8 - approxExecutionPriceX1e8) * PPM_SCALAR + (ONEX1e8 - 1)) / ONEX1e8;\n                }\n            }\n            // Add `extraFeesIncurred` to \"slippage from one to one\"\n            estSlippagePpm +=\n                (params.extraFeesIncurred * PPM_SCALAR + (params.amountInEVM + params.extraFeesIncurred) - 1) /\n                (params.amountInEVM + params.extraFeesIncurred);\n\n            if (estSlippagePpm > maxAllowableBpsDeviation * 10 ** (PPM_DECIMALS - BPS_DECIMALS)) {\n                emit SwapFlowTooExpensive(\n                    params.quoteNonce,\n                    params.finalToken,\n                    (estSlippagePpm + 10 ** (PPM_DECIMALS - BPS_DECIMALS) - 1) / 10 ** (PPM_DECIMALS - BPS_DECIMALS),\n                    maxAllowableBpsDeviation\n                );\n                params.finalToken = initialToken;\n                _executeSimpleTransferFlow(params);\n                return;\n            }\n        }\n\n        (uint256 tokensToSendEvm, uint64 coreAmountIn) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n            params.amountInEVM,\n            initialCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        // Check that we can safely bridge to HCore (for the trade amount actually needed)\n        bool isSafeToBridgeMainToken = HyperCoreLib.isCoreAmountSafeToBridge(\n            initialCoreTokenInfo.coreIndex,\n            coreAmountIn,\n            initialCoreTokenInfo.bridgeSafetyBufferCore\n        );\n\n        if (!isSafeToBridgeMainToken) {\n            emit UnsafeToBridge(params.quoteNonce, initialToken, coreAmountIn);\n            params.finalToken = initialToken;\n            _fallbackHyperEVMFlow(params);\n            return;\n        }\n\n        // Finalize swap flow setup by updating state and funding SwapHandler\n        // State changes\n        $.swaps[params.quoteNonce] = SwapFlowState({\n            finalRecipient: params.finalRecipient,\n            finalToken: params.finalToken,\n            minAmountToSend: minAllowableAmountToForwardCore,\n            maxAmountToSend: maxAllowableAmountToForwardCore,\n            isSponsored: params.maxBpsToSponsor > 0,\n            finalized: false\n        });\n\n        emit SwapFlowInitialized(\n            params.quoteNonce,\n            params.finalRecipient,\n            params.finalToken,\n            params.amountInEVM,\n            params.extraFeesIncurred,\n            coreAmountIn,\n            minAllowableAmountToForwardCore,\n            maxAllowableAmountToForwardCore\n        );\n\n        // Send amount received from user to a corresponding SwapHandler\n        SwapHandler swapHandler = finalTokenInfo.swapHandler;\n        IERC20(initialToken).safeTransfer(address(swapHandler), tokensToSendEvm);\n        swapHandler.transferFundsToSelfOnCore(\n            initialToken,\n            initialCoreTokenInfo.coreIndex,\n            tokensToSendEvm,\n            initialCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n    }\n\n    /**\n     * @notice Finalizes multiple swap flows associated with a final token, subject to the L1 Hyperliquid balance\n     * @dev Caller is responsible for providing correct limitOrderOutput amounts per assosicated swap flow. The caller\n     * has to estimate how much final tokens it received on core based on the input of the corresponding quote nonce\n     * swap flow\n     * @param finalToken The token address for the swaps being finalized\n     * @param quoteNonces Array of quote nonces identifying the swap flows to finalize\n     * @param limitOrderOuts Array of limit order output amounts corresponding to each quote nonce\n     * @return finalized The number of swap flows that were successfully finalized\n     */\n    function finalizeSwapFlows(\n        address finalToken,\n        bytes32[] calldata quoteNonces,\n        uint64[] calldata limitOrderOuts\n    ) external onlyRole(PERMISSIONED_BOT_ROLE) returns (uint256 finalized) {\n        MainStorage storage $ = _getMainStorage();\n        require(quoteNonces.length == limitOrderOuts.length, \"length\");\n        require($.lastPullFundsBlock[finalToken] < block.number, \"too soon\");\n\n        CoreTokenInfo memory finalCoreTokenInfo = _getExistingCoreTokenInfo(finalToken);\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(finalToken);\n\n        uint64 availableBalance = HyperCoreLib.spotBalance(\n            address(finalTokenInfo.swapHandler),\n            finalCoreTokenInfo.coreIndex\n        );\n        uint64 totalAdditionalToSend = 0;\n        for (; finalized < quoteNonces.length; ++finalized) {\n            bool success;\n            uint64 additionalToSend;\n            (success, additionalToSend, availableBalance) = _finalizeSingleSwap(\n                quoteNonces[finalized],\n                limitOrderOuts[finalized],\n                finalCoreTokenInfo,\n                finalTokenInfo.swapHandler,\n                finalToken,\n                availableBalance\n            );\n            if (!success) {\n                break;\n            }\n            totalAdditionalToSend += additionalToSend;\n        }\n\n        if (finalized > 0) {\n            $.lastPullFundsBlock[finalToken] = block.number;\n        } else {\n            return 0;\n        }\n\n        if (totalAdditionalToSend > 0) {\n            (uint256 totalAdditionalToSendEVM, uint64 totalAdditionalReceivedCore) = HyperCoreLib\n                .minimumCoreReceiveAmountToAmounts(\n                    totalAdditionalToSend,\n                    finalCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n                );\n\n            if (\n                !HyperCoreLib.isCoreAmountSafeToBridge(\n                    finalCoreTokenInfo.coreIndex,\n                    totalAdditionalReceivedCore,\n                    finalCoreTokenInfo.bridgeSafetyBufferCore\n                )\n            ) {\n                // We expect this situation to be so rare and / or intermittend that we're willing to rely on admin to sweep the funds if this leads to\n                // swaps being impossible to finalize\n                revert UnsafeToBridgeError(finalToken, totalAdditionalToSend);\n            }\n\n            $.cumulativeSponsoredAmount[finalToken] += totalAdditionalToSendEVM;\n\n            // ! Notice: as per HyperEVM <> HyperCore rules, this amount will land on HyperCore *before* all of the core > core sends get executed\n            // Get additional amount to send from donation box, and send it to self on core\n            donationBox.withdraw(IERC20(finalToken), totalAdditionalToSendEVM);\n            IERC20(finalToken).safeTransfer(address(finalTokenInfo.swapHandler), totalAdditionalToSendEVM);\n            finalTokenInfo.swapHandler.transferFundsToSelfOnCore(\n                finalToken,\n                finalCoreTokenInfo.coreIndex,\n                totalAdditionalToSendEVM,\n                finalCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n            );\n        }\n    }\n\n    /// @notice Finalizes a single swap flow, sending the tokens to user on core. Relies on caller to send the `additionalToSend`\n    function _finalizeSingleSwap(\n        bytes32 quoteNonce,\n        uint64 limitOrderOut,\n        CoreTokenInfo memory finalCoreTokenInfo,\n        SwapHandler swapHandler,\n        address finalToken,\n        uint64 availableBalance\n    ) internal returns (bool success, uint64 additionalToSend, uint64 balanceRemaining) {\n        SwapFlowState storage swap = _getMainStorage().swaps[quoteNonce];\n        if (swap.finalRecipient == address(0)) revert SwapDoesNotExist();\n        if (swap.finalized) revert SwapAlreadyFinalized();\n        if (swap.finalToken != finalToken) revert WrongSwapFinalizationToken(quoteNonce);\n\n        uint64 totalToSend;\n        (totalToSend, additionalToSend) = _calcSwapFlowSendAmounts(\n            limitOrderOut,\n            swap.minAmountToSend,\n            swap.maxAmountToSend,\n            swap.isSponsored\n        );\n\n        // `additionalToSend` will land on HCore before this core > core send will need to be executed\n        balanceRemaining = availableBalance + additionalToSend;\n        if (totalToSend > balanceRemaining) {\n            return (false, 0, availableBalance);\n        }\n\n        swap.finalized = true;\n        success = true;\n        balanceRemaining -= totalToSend;\n\n        (uint256 additionalToSendEVM, ) = HyperCoreLib.minimumCoreReceiveAmountToAmounts(\n            additionalToSend,\n            finalCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        swapHandler.transferFundsToUserOnCore(finalCoreTokenInfo.coreIndex, swap.finalRecipient, totalToSend);\n        emit SwapFlowFinalized(quoteNonce, swap.finalRecipient, swap.finalToken, totalToSend, additionalToSendEVM);\n    }\n\n    /// @notice Forwards `amount` plus potential sponsorship funds (for bridging fee) to user on HyperEVM\n    function _fallbackHyperEVMFlow(CommonFlowParams memory params) internal {\n        uint256 maxEvmAmountToSponsor = ((params.amountInEVM + params.extraFeesIncurred) * params.maxBpsToSponsor) /\n            BPS_SCALAR;\n        uint256 sponsorshipFundsToForward = params.extraFeesIncurred > maxEvmAmountToSponsor\n            ? maxEvmAmountToSponsor\n            : params.extraFeesIncurred;\n\n        if (!_availableInDonationBox(params.quoteNonce, params.finalToken, sponsorshipFundsToForward)) {\n            sponsorshipFundsToForward = 0;\n        }\n        if (sponsorshipFundsToForward > 0) {\n            donationBox.withdraw(IERC20(params.finalToken), sponsorshipFundsToForward);\n        }\n        uint256 totalAmountToForward = params.amountInEVM + sponsorshipFundsToForward;\n        IERC20(params.finalToken).safeTransfer(params.finalRecipient, totalAmountToForward);\n        _getMainStorage().cumulativeSponsoredAmount[params.finalToken] += sponsorshipFundsToForward;\n        emit FallbackHyperEVMFlowCompleted(\n            params.quoteNonce,\n            params.finalRecipient,\n            params.finalToken,\n            params.amountInEVM,\n            params.extraFeesIncurred,\n            sponsorshipFundsToForward\n        );\n    }\n\n    /**\n     * @notice Activates a user account on Core by funding the account activation fee.\n     * @param quoteNonce The nonce of the quote that is used to identify the user.\n     * @param finalRecipient The address of the recipient of the funds.\n     * @param fundingToken The address of the token that is used to fund the account activation fee.\n     */\n    function activateUserAccount(\n        bytes32 quoteNonce,\n        address finalRecipient,\n        address fundingToken\n    ) external onlyRole(PERMISSIONED_BOT_ROLE) {\n        CoreTokenInfo memory coreTokenInfo = _getExistingCoreTokenInfo(fundingToken);\n        bool coreUserExists = HyperCoreLib.coreUserExists(finalRecipient);\n        require(!coreUserExists, \"Can't fund account activation for existing user\");\n        require(coreTokenInfo.canBeUsedForAccountActivation, \"Token can't be used for this\");\n\n        // +1 wei for a spot send\n        uint64 totalBalanceRequiredToActivate = coreTokenInfo.accountActivationFeeCore + 1;\n        (uint256 evmAmountToSend, ) = HyperCoreLib.minimumCoreReceiveAmountToAmounts(\n            totalBalanceRequiredToActivate,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        bool safeToBridge = HyperCoreLib.isCoreAmountSafeToBridge(\n            coreTokenInfo.coreIndex,\n            totalBalanceRequiredToActivate,\n            coreTokenInfo.bridgeSafetyBufferCore\n        );\n        require(safeToBridge, \"Not safe to bridge\");\n        _getMainStorage().cumulativeSponsoredActivationFee[fundingToken] += evmAmountToSend;\n\n        // donationBox @ evm -> Handler @ evm\n        donationBox.withdraw(IERC20(fundingToken), evmAmountToSend);\n        // Handler @ evm -> Handler @ core\n        HyperCoreLib.transferERC20EVMToSelfOnCore(\n            fundingToken,\n            coreTokenInfo.coreIndex,\n            evmAmountToSend,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n        // The total balance withdrawn from Handler @ Core for this operation is activationFee + amountSent, so we set\n        // amountSent to 1 wei to only activate the account\n        // Handler @ core -> finalRecipient @ core\n        HyperCoreLib.transferERC20CoreToCore(coreTokenInfo.coreIndex, finalRecipient, 1);\n\n        emit SponsoredAccountActivation(quoteNonce, finalRecipient, fundingToken, evmAmountToSend);\n    }\n\n    /**\n     * @notice Cancells a pending limit order by `cloid` with an intention to submit a new limit order in its place. To\n     * be used for stale limit orders to speed up executing user transactions\n     * @param finalToken The token address for which the limit order was placed\n     * @param cloid Client order ID of the limit order to cancel\n     */\n    function cancelLimitOrderByCloid(address finalToken, uint128 cloid) external onlyRole(PERMISSIONED_BOT_ROLE) {\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(finalToken);\n        finalTokenInfo.swapHandler.cancelOrderByCloid(finalTokenInfo.spotIndex, cloid);\n\n        emit CancelledLimitOrder(finalToken, cloid);\n    }\n\n    function submitLimitOrderFromBot(\n        address finalToken,\n        uint64 priceX1e8,\n        uint64 sizeX1e8,\n        uint128 cloid\n    ) external onlyRole(PERMISSIONED_BOT_ROLE) {\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(finalToken);\n        finalTokenInfo.swapHandler.submitSpotLimitOrder(finalTokenInfo, priceX1e8, sizeX1e8, cloid);\n\n        emit SubmittedLimitOrder(finalToken, priceX1e8, sizeX1e8, cloid);\n    }\n\n    function _setCoreTokenInfo(\n        address token,\n        uint32 coreIndex,\n        bool canBeUsedForAccountActivation,\n        uint64 accountActivationFeeCore,\n        uint64 bridgeSafetyBufferCore\n    ) internal {\n        HyperCoreLib.TokenInfo memory tokenInfo = HyperCoreLib.tokenInfo(coreIndex);\n\n        (uint256 accountActivationFeeEVM, ) = HyperCoreLib.minimumCoreReceiveAmountToAmounts(\n            accountActivationFeeCore,\n            tokenInfo.evmExtraWeiDecimals\n        );\n\n        _getMainStorage().coreTokenInfos[token] = CoreTokenInfo({\n            tokenInfo: tokenInfo,\n            coreIndex: coreIndex,\n            canBeUsedForAccountActivation: canBeUsedForAccountActivation,\n            accountActivationFeeEVM: accountActivationFeeEVM,\n            accountActivationFeeCore: accountActivationFeeCore,\n            bridgeSafetyBufferCore: bridgeSafetyBufferCore\n        });\n\n        emit SetCoreTokenInfo(\n            token,\n            coreIndex,\n            canBeUsedForAccountActivation,\n            accountActivationFeeCore,\n            bridgeSafetyBufferCore\n        );\n    }\n\n    /**\n     * @notice Used for ad-hoc sends of sponsorship funds to associated SwapHandler @ HyperCore\n     * @param token The final token for which we want to fund the SwapHandler\n     * @param amount The amount of tokens to send to the SwapHandler\n     */\n    function sendSponsorshipFundsToSwapHandler(address token, uint256 amount) external onlyRole(PERMISSIONED_BOT_ROLE) {\n        CoreTokenInfo memory coreTokenInfo = _getExistingCoreTokenInfo(token);\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(token);\n        (uint256 amountEVMToSend, uint64 amountCoreToReceive) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n            amount,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n        if (\n            !HyperCoreLib.isCoreAmountSafeToBridge(\n                coreTokenInfo.coreIndex,\n                amountCoreToReceive,\n                coreTokenInfo.bridgeSafetyBufferCore\n            )\n        ) {\n            revert UnsafeToBridgeError(token, amountCoreToReceive);\n        }\n\n        _getMainStorage().cumulativeSponsoredAmount[token] += amountEVMToSend;\n\n        emit SentSponsorshipFundsToSwapHandler(token, amountEVMToSend);\n\n        donationBox.withdraw(IERC20(token), amountEVMToSend);\n        IERC20(token).safeTransfer(address(finalTokenInfo.swapHandler), amountEVMToSend);\n        finalTokenInfo.swapHandler.transferFundsToSelfOnCore(\n            token,\n            coreTokenInfo.coreIndex,\n            amountEVMToSend,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n    }\n\n    /// @notice Checks if `amount` of `token` is available to withdraw from donationBox\n    function _availableInDonationBox(\n        bytes32 quoteNonce,\n        address token,\n        uint256 amount\n    ) internal returns (bool available) {\n        uint256 balance = IERC20(token).balanceOf(address(donationBox));\n        available = balance >= amount;\n        if (!available) {\n            emit DonationBoxInsufficientFunds(quoteNonce, token, amount, balance);\n        }\n    }\n\n    function _calcAllowableAmtsSwapFlow(\n        uint256 amount,\n        uint256 extraFeesIncurred,\n        CoreTokenInfo memory initialCoreTokenInfo,\n        CoreTokenInfo memory finalCoreTokenInfo,\n        bool isSponsoredFlow,\n        uint256 maxUserSlippageBps\n    ) internal pure returns (uint64 minAllowableAmountToForwardCore, uint64 maxAllowableAmountToForwardCore) {\n        (, uint64 feelessAmountCoreInitialToken) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n            amount + extraFeesIncurred,\n            initialCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n        uint64 feelessAmountCoreFinalToken = HyperCoreLib.convertCoreDecimalsSimple(\n            feelessAmountCoreInitialToken,\n            initialCoreTokenInfo.tokenInfo.weiDecimals,\n            finalCoreTokenInfo.tokenInfo.weiDecimals\n        );\n        if (isSponsoredFlow) {\n            minAllowableAmountToForwardCore = feelessAmountCoreFinalToken;\n            maxAllowableAmountToForwardCore = feelessAmountCoreFinalToken;\n        } else {\n            minAllowableAmountToForwardCore = uint64(\n                (feelessAmountCoreFinalToken * (BPS_SCALAR - maxUserSlippageBps)) / BPS_SCALAR\n            );\n            maxAllowableAmountToForwardCore = feelessAmountCoreFinalToken;\n        }\n    }\n\n    /**\n     * @return totalToSend What we will forward to user on HCore\n     * @return additionalToSend What we will send from donationBox right now\n     */\n    function _calcSwapFlowSendAmounts(\n        uint64 limitOrderOut,\n        uint64 minAmountToSend,\n        uint64 maxAmountToSend,\n        bool isSponsored\n    ) internal pure returns (uint64 totalToSend, uint64 additionalToSend) {\n        if (isSponsored) {\n            // `minAmountToSend` is equal to `maxAmountToSend` for the sponsored flow\n            totalToSend = minAmountToSend;\n            additionalToSend = totalToSend > limitOrderOut ? totalToSend - limitOrderOut : 0;\n        } else {\n            additionalToSend = limitOrderOut < minAmountToSend ? minAmountToSend - limitOrderOut : 0;\n            uint64 proposedToSend = limitOrderOut + additionalToSend;\n            totalToSend = proposedToSend > maxAmountToSend ? maxAmountToSend : proposedToSend;\n        }\n    }\n\n    /// @notice Reads the current spot price from HyperLiquid and applies a configured suggested discount for faster execution\n    /// @dev Includes HyperLiquid fees\n    function _getApproxRealizedPrice(\n        FinalTokenInfo memory finalTokenInfo,\n        CoreTokenInfo memory finalCoreTokenInfo,\n        CoreTokenInfo memory initialCoreTokenInfo\n    ) internal view returns (uint64 limitPriceX1e8) {\n        uint256 spotPxRaw = HyperCoreLib.spotPx(finalTokenInfo.spotIndex);\n        // Convert to 10 ** 8 precision (https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/hyperevm/interacting-with-hypercore)\n        // `szDecimals` of the base aseet for spot market\n        uint8 additionalPowersOf10 = finalTokenInfo.isBuy\n            ? finalCoreTokenInfo.tokenInfo.szDecimals\n            : initialCoreTokenInfo.tokenInfo.szDecimals;\n        uint256 spotX1e8 = spotPxRaw * (10 ** additionalPowersOf10);\n\n        // Buy above spot, sell below spot\n        uint256 adjPpm = finalTokenInfo.isBuy\n            ? (PPM_SCALAR + finalTokenInfo.suggestedDiscountBps * 10 ** 2 + finalTokenInfo.feePpm)\n            : (PPM_SCALAR - finalTokenInfo.suggestedDiscountBps * 10 ** 2 - finalTokenInfo.feePpm);\n        limitPriceX1e8 = uint64((uint256(spotX1e8) * adjPpm) / PPM_SCALAR);\n    }\n\n    /**************************************\n     *            SWEEP FUNCTIONS         *\n     **************************************/\n\n    function sweepNative(uint256 amount) external onlyRole(FUNDS_SWEEPER_ROLE) {\n        (bool success, ) = msg.sender.call{ value: amount }(\"\");\n        require(success, \"Failed to send native funds\");\n    }\n\n    function sweepErc20(address token, uint256 amount) external onlyRole(FUNDS_SWEEPER_ROLE) {\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function sweepErc20FromDonationBox(address token, uint256 amount) external onlyRole(FUNDS_SWEEPER_ROLE) {\n        donationBox.withdraw(IERC20(token), amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function sweepERC20FromSwapHandler(address token, uint256 amount) external onlyRole(FUNDS_SWEEPER_ROLE) {\n        SwapHandler swapHandler = _getExistingFinalTokenInfo(token).swapHandler;\n        swapHandler.sweepErc20(token, amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function sweepOnCore(address token, uint64 amount) external onlyRole(FUNDS_SWEEPER_ROLE) {\n        HyperCoreLib.transferERC20CoreToCore(_getMainStorage().coreTokenInfos[token].coreIndex, msg.sender, amount);\n    }\n\n    function sweepOnCoreFromSwapHandler(\n        address finalToken,\n        uint64 finalTokenAmount,\n        uint64 baseTokenAmount\n    ) external onlyRole(FUNDS_SWEEPER_ROLE) {\n        MainStorage storage $ = _getMainStorage();\n        require($.lastPullFundsBlock[finalToken] < block.number, \"Can't pull funds twice in the same block\");\n        $.lastPullFundsBlock[finalToken] = block.number;\n\n        SwapHandler swapHandler = $.finalTokenInfos[finalToken].swapHandler;\n        if (finalTokenAmount > 0) {\n            swapHandler.transferFundsToUserOnCore($.coreTokenInfos[finalToken].coreIndex, msg.sender, finalTokenAmount);\n        }\n        if (baseTokenAmount > 0) {\n            swapHandler.transferFundsToUserOnCore($.coreTokenInfos[baseToken].coreIndex, msg.sender, baseTokenAmount);\n        }\n    }\n}\n"
    }
}