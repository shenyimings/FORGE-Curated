{
    "vfp_id": "vfp_00313",
    "project_name": "cantina_tadle_oct2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Permanent block of withdrawal requests",
            "description": "The ETH withdrawal logic in main.sol compares the contract's current balance against the sum of claimed ETH and the requested withdrawal amount. However, if the airdrop contract records the exact ETH amount claimed, the balance becomes equal to the claimed amount immediately after the first claim. This makes any subsequent withdrawal request fail because claimedAmount + amt exceeds the current balance, even if sufficient funds are present. The root cause is the flawed accounting logic that does not track spendable vs. claimed funds. An attacker or malicious airdrop design could trigger this condition, causing the smart account to be unable to withdraw ETH despite holding it. The impact is permanent locking of ETH within the account, rendering it unusable.\n",
            "severity": "High",
            "location": [
                "main.sol::withdraw#117-125"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/airdrop/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/account-manager-v1/main.sol"
            ]
        }
    ],
    "affected_files": {
        "main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {TokenHelper, TokenInterface} from \"../../../libraries/TokenHelper.sol\";\n\n/**\n * @title IAirdrop\n * @author Tadle Team\n * @notice Interface for interacting with the Airdrop contract\n * @dev Provides functionality to query user claimed amounts\n */\ninterface IAirdrop {\n    /// @notice Get the amount of tokens claimed by a user\n    /// @param user Address of the user\n    /// @param token Address of the token\n    /// @return Amount of tokens claimed by the user\n    function getUserClaimedAmount(\n        address user,\n        address token\n    ) external view returns (uint256);\n}\n\n/**\n * @title IValidator\n * @notice Interface for validator contract\n * @dev Provides token whitelist verification functionality\n */\ninterface IValidator {\n    /// @notice Verify if a validator is authorized for a specific key\n    /// @param _key The validation key\n    /// @param _validator The validator address to check\n    /// @return True if validator is authorized, false otherwise\n    function verify(\n        bytes32 _key,\n        address _validator\n    ) external view returns (bool);\n}\n\n/**\n * @title AccountManagerResolver\n * @author Tadle Team\n * @notice Contract for managing account operations and asset withdrawals\n * @dev Handles secure token withdrawals with airdrop claim validation and whitelist checks\n * @custom:security Implements balance validation and whitelist verification\n */\ncontract AccountManagerResolver {\n    /// @dev Address of the airdrop contract for claim validation\n    /// @notice Immutable reference to airdrop contract\n    address public immutable airdropAddress;\n\n    /// @dev Address of the validator contract for whitelist checks\n    /// @notice Immutable reference to validator contract\n    address public immutable validatorAddress;\n\n    /// @dev Ethereum token address representation\n    /// @notice Standard ETH address used across the protocol\n    address internal constant ethAddr =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Key for token whitelist validation\n    /// @notice Used to verify if tokens are approved for withdrawal\n    bytes32 internal constant VALIDATOR_TOKEN_WHITELIST_KEY =\n        keccak256(\"account-manager-token-whitelist\");\n\n    /**\n     * @dev Constructor to initialize contract addresses\n     * @param _airdropAddress Address of the airdrop contract\n     * @param _validatorAddress Address of the validator contract\n     * @notice Sets up the resolver with required system contracts\n     * @custom:validation Addresses can be zero for optional functionality\n     */\n    constructor(address _airdropAddress, address _validatorAddress) {\n        airdropAddress = _airdropAddress;\n        validatorAddress = _validatorAddress;\n    }\n\n    /**\n     * @dev Withdraw assets from the smart account\n     * @param token Address of the token to withdraw (ethAddr for ETH)\n     * @param amt Amount of tokens to withdraw\n     * @param to Recipient address\n     * @return _eventName Name of the event emitted\n     * @return _eventParam Encoded event parameters\n     * @notice Securely withdraws tokens with validation checks\n     * @custom:validation Validates recipient, amount, and token whitelist\n     * @custom:security Checks airdrop claims for ETH withdrawals\n     * @custom:access-control Requires token to be whitelisted\n     */\n    function withdraw(\n        address token,\n        uint256 amt,\n        address payable to\n    )\n        external\n        payable\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Validate input parameters\n        require(\n            to != address(0),\n            \"AccountManagerResolver: recipient address cannot be zero\"\n        );\n        require(\n            amt > 0,\n            \"AccountManagerResolver: withdrawal amount must be greater than zero\"\n        );\n\n        // Verify token is whitelisted\n        require(\n            IValidator(validatorAddress).verify(\n                VALIDATOR_TOKEN_WHITELIST_KEY,\n                token\n            ),\n            \"AccountManagerResolver: token not whitelisted for withdrawal\"\n        );\n\n        // Check ETH balance considering airdrop claims\n        if (token == ethAddr && airdropAddress != address(0)) {\n            uint256 claimedAmount = IAirdrop(airdropAddress)\n                .getUserClaimedAmount(address(this), ethAddr);\n            require(\n                address(this).balance >= claimedAmount + amt,\n                \"AccountManagerResolver: insufficient balance after airdrop claims\"\n            );\n        }\n\n        // Transfer tokens based on type\n        if (token == ethAddr) {\n            _safeTransferETH(to, amt);\n        } else {\n            _safeTransferERC20(token, to, amt);\n        }\n\n        // Return event data\n        _eventName = \"LogWithdraw(address,uint256,address)\";\n        _eventParam = abi.encode(token, amt, to);\n    }\n\n    /**\n     * @dev Safely transfers ETH to a recipient\n     * @param to Recipient address\n     * @param amount Amount of ETH to transfer\n     * @notice Uses low-level call for ETH transfer with failure handling\n     * @custom:security Validates transfer success and reverts on failure\n     */\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"AccountManagerResolver: ETH transfer failed\");\n    }\n\n    /**\n     * @dev Safely transfers ERC20 tokens to a recipient\n     * @param token Address of the ERC20 token\n     * @param to Recipient address\n     * @param amount Amount of tokens to transfer\n     * @notice Uses TokenHelper for safe ERC20 transfers\n     * @custom:security Leverages battle-tested transfer helper\n     */\n    function _safeTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        TokenHelper.safeTransfer(TokenInterface(token), to, amount);\n    }\n}\n\n/**\n * @title ConnectV1AccountManager\n * @author Tadle Team\n * @notice Version 1.0.0 of the Account Manager connector\n * @dev Extends AccountManagerResolver with version identification\n * @custom:version 1.0.0\n */\ncontract ConnectV1AccountManager is AccountManagerResolver {\n    string public constant name = \"AccountManager-v1.0.0\";\n\n    /**\n     * @dev Constructor to initialize contract addresses\n     * @param _airdropAddress Address of the airdrop contract\n     * @param _validatorAddress Address of the validator contract\n     * @notice Sets up the connector with required system contracts\n     * @custom:initialization Inherits validation from AccountManagerResolver\n     */\n    constructor(\n        address _airdropAddress,\n        address _validatorAddress\n    ) AccountManagerResolver(_airdropAddress, _validatorAddress) {}\n}\n"
    }
}