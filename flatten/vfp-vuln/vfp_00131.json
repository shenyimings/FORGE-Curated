{
    "vfp_id": "vfp_00131",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "BalancerFlashLoan Missing Access Control",
            "description": "The BalancerFlashLoan contract lacks proper access control on its makeFlashLoan function, allowing any external caller to trigger flash loans and bypass the intended authorization checks in the leverage zapper contracts. The cause is the absence of a modifier or check to ensure only authorized zappers can initiate flash loans. An attacker could exploit this by directly calling makeFlashLoan with arbitrary parameters, including targeting troves they do not control, thereby adjusting troves without proper rights. This could lead to unauthorized trove modifications, potential liquidation risks, and financial gain via sandwich attacks on associated swaps. The impact includes loss of user funds and unauthorized manipulation of trove positions.\n",
            "severity": "High",
            "location": [
                "BalancerFlashLoan.sol::makeFlashLoan",
                "BalancerFlashLoan.sol::receiveFlashLoan"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        }
    ],
    "affected_files": {
        "BalancerFlashLoan.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Balancer/vault/IVault.sol\";\nimport \"./Balancer/vault/IFlashLoanRecipient.sol\";\n\nimport \"../../Interfaces/ILeverageZapper.sol\";\nimport \"../../Interfaces/IFlashLoanReceiver.sol\";\nimport \"../../Interfaces/IFlashLoanProvider.sol\";\n\ncontract BalancerFlashLoan is IFlashLoanRecipient, IFlashLoanProvider {\n    using SafeERC20 for IERC20;\n\n    IVault private constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    IFlashLoanReceiver public receiver;\n\n    function makeFlashLoan(IERC20 _token, uint256 _amount, Operation _operation, bytes calldata _params) external {\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n\n        // Data for the callback receiveFlashLoan\n        bytes memory userData;\n        if (_operation == Operation.OpenTrove) {\n            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =\n                abi.decode(_params, (ILeverageZapper.OpenLeveragedTroveParams));\n            userData = abi.encode(_operation, openTroveParams);\n        } else if (_operation == Operation.LeverUpTrove) {\n            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =\n                abi.decode(_params, (ILeverageZapper.LeverUpTroveParams));\n            userData = abi.encode(_operation, leverUpTroveParams);\n        } else if (_operation == Operation.LeverDownTrove) {\n            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =\n                abi.decode(_params, (ILeverageZapper.LeverDownTroveParams));\n            userData = abi.encode(_operation, leverDownTroveParams);\n        } else if (_operation == Operation.CloseTrove) {\n            IZapper.CloseTroveParams memory closeTroveParams = abi.decode(_params, (IZapper.CloseTroveParams));\n            userData = abi.encode(_operation, closeTroveParams);\n        } else {\n            revert(\"LZ: Wrong Operation\");\n        }\n\n        // This will be used by the callback below no\n        receiver = IFlashLoanReceiver(msg.sender);\n\n        vault.flashLoan(this, tokens, amounts, userData);\n    }\n\n    function receiveFlashLoan(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata feeAmounts,\n        bytes calldata userData\n    ) external override {\n        require(msg.sender == address(vault), \"Caller is not Vault\");\n        require(address(receiver) != address(0), \"Flash loan not properly initiated\");\n\n        // Cache and reset receiver, to comply with CEI pattern, as some callbacks in zappers do raw calls\n        // It’s not necessary, as Balancer flash loans are protected against re-entrancy\n        // But it’s safer, specially if someone tries to reuse this code, and more gas efficient\n        IFlashLoanReceiver receiverCached = receiver;\n        receiver = IFlashLoanReceiver(address(0));\n\n        // decode and operation\n        Operation operation = abi.decode(userData[0:32], (Operation));\n\n        if (operation == Operation.OpenTrove) {\n            // Open\n            // decode params\n            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =\n                abi.decode(userData[32:], (ILeverageZapper.OpenLeveragedTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnOpenLeveragedTrove(openTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.LeverUpTrove) {\n            // Lever up\n            // decode params\n            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =\n                abi.decode(userData[32:], (ILeverageZapper.LeverUpTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnLeverUpTrove(leverUpTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.LeverDownTrove) {\n            // Lever down\n            // decode params\n            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =\n                abi.decode(userData[32:], (ILeverageZapper.LeverDownTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnLeverDownTrove(leverDownTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.CloseTrove) {\n            // Close trove\n            // decode params\n            IZapper.CloseTroveParams memory closeTroveParams = abi.decode(userData[32:], (IZapper.CloseTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnCloseTroveFromCollateral(closeTroveParams, effectiveFlashLoanAmount);\n        } else {\n            revert(\"LZ: Wrong Operation\");\n        }\n\n        // Return flash loan\n        tokens[0].safeTransfer(address(vault), amounts[0] + feeAmounts[0]);\n    }\n}\n"
    }
}