{
    "vfp_id": "vfp_00131",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Problematic Conflict Resolution Design",
            "description": "The current conflict resolution design, triggered by TransitionConflictDetected, fails to act as a circuit breaker and leads to multiple systemic issues. It does not halt propose(), prove(), or saveForcedInclusion(), allowing the ring buffer to fill with unprocessable proposals, leading to complete unavailability. Recovery via _compositeKeyVersion bumping invalidates proofs but leaves proposals intact, creating permanent deadlocks if the canonical chain must be re-rooted. Honest provers lose rewards due to \"zombie proofs,\" and malicious actors can withdraw bonds before slashing. Forced inclusions continue, enabling cheap griefing attacks. The design lacks granular governance tools to resolve conflicts safely and forces a coarse \"nuclear\" reset, causing unnecessary waste and fragility. This undermines both security and liveness during critical failure scenarios.\n",
            "severity": "Critical",
            "location": [
                "IInbox.sol::TransitionConflictDetected",
                "Inbox.sol::_finalize#955",
                "Inbox.sol::_proposalHashes",
                "Inbox.sol::_compositeKeyVersion#125"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/iface/IInbox.sol"
            ]
        }
    ],
    "affected_files": {
        "IInbox.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { LibBlobs } from \"../libs/LibBlobs.sol\";\nimport { LibBonds } from \"src/shared/libs/LibBonds.sol\";\nimport { ICheckpointStore } from \"src/shared/signal/ICheckpointStore.sol\";\n\n/// @title IInbox\n/// @notice Interface for the Shasta inbox contracts\n/// @custom:security-contact security@taiko.xyz\ninterface IInbox {\n    /// @notice Configuration struct for Inbox constructor parameters\n    struct Config {\n        /// @notice The codec used for encoding and hashing\n        address codec;\n        /// @notice The token used for bonds\n        address bondToken;\n        /// @notice The signal service contract address\n        address checkpointStore;\n        /// @notice The proof verifier contract\n        address proofVerifier;\n        /// @notice The proposer checker contract\n        address proposerChecker;\n        /// @notice The proving window in seconds\n        uint48 provingWindow;\n        /// @notice The extended proving window in seconds\n        uint48 extendedProvingWindow;\n        /// @notice The maximum number of finalized proposals in one block\n        uint256 maxFinalizationCount;\n        /// @notice The finalization grace period in seconds\n        uint48 finalizationGracePeriod;\n        /// @notice The ring buffer size for storing proposal hashes\n        uint256 ringBufferSize;\n        /// @notice The percentage of basefee paid to coinbase\n        uint8 basefeeSharingPctg;\n        /// @notice The minimum number of forced inclusions that the proposer is forced to process\n        /// if they are due\n        uint256 minForcedInclusionCount;\n        /// @notice The delay for forced inclusions measured in seconds\n        uint16 forcedInclusionDelay;\n        /// @notice The base fee for forced inclusions in Gwei used in dynamic fee calculation\n        uint64 forcedInclusionFeeInGwei;\n        /// @notice Queue size at which the fee doubles\n        uint64 forcedInclusionFeeDoubleThreshold;\n        /// @notice The minimum delay between checkpoints in seconds\n        /// @dev Must be less than or equal to finalization grace period\n        uint16 minCheckpointDelay;\n        /// @notice The multiplier to determine when a forced inclusion is too old so that proposing\n        /// becomes permissionless\n        uint8 permissionlessInclusionMultiplier;\n        /// @notice Version identifier for composite key generation\n        uint16 compositeKeyVersion;\n    }\n\n    /// @notice Represents a source of derivation data within a Derivation\n    struct DerivationSource {\n        /// @notice Whether this source is from a forced inclusion.\n        bool isForcedInclusion;\n        /// @notice Blobs that contain the source's manifest data.\n        LibBlobs.BlobSlice blobSlice;\n    }\n\n    /// @notice Contains derivation data for a proposal that is not needed during proving.\n    /// @dev This data is hashed and stored in the Proposal struct to reduce calldata size.\n    struct Derivation {\n        /// @notice The L1 block number when the proposal was accepted.\n        uint48 originBlockNumber;\n        /// @notice The hash of the origin block.\n        bytes32 originBlockHash;\n        /// @notice The percentage of base fee paid to coinbase.\n        uint8 basefeeSharingPctg;\n        /// @notice Array of derivation sources, where each can be regular or forced inclusion.\n        DerivationSource[] sources;\n    }\n\n    /// @notice Represents a proposal for L2 blocks.\n    struct Proposal {\n        /// @notice Unique identifier for the proposal.\n        uint48 id;\n        /// @notice The L1 block timestamp when the proposal was accepted.\n        uint48 timestamp;\n        /// @notice The timestamp of the last slot where the current preconfer can propose.\n        uint48 endOfSubmissionWindowTimestamp;\n        /// @notice Address of the proposer.\n        address proposer;\n        /// @notice The current hash of coreState\n        bytes32 coreStateHash;\n        /// @notice Hash of the Derivation struct containing additional proposal data.\n        bytes32 derivationHash;\n    }\n\n    /// @notice Represents a transition about the state transition of a proposal.\n    /// @dev Prover information has been moved to TransitionMetadata for out-of-order proving\n    /// support\n    struct Transition {\n        /// @notice The proposal's hash.\n        bytes32 proposalHash;\n        /// @notice The parent transition's hash, this is used to link the transition to its parent\n        /// transition to\n        /// finalize the corresponding proposal.\n        bytes32 parentTransitionHash;\n        /// @notice The end block header containing number, hash, and state root.\n        ICheckpointStore.Checkpoint checkpoint;\n    }\n\n    /// @notice Metadata about the proving of a transition\n    /// @dev Separated from Transition to enable out-of-order proving\n    struct TransitionMetadata {\n        /// @notice The designated prover for this transition.\n        address designatedProver;\n        /// @notice The actual prover who submitted the proof.\n        address actualProver;\n    }\n\n    /// @notice Represents a record of a transition with additional metadata.\n    struct TransitionRecord {\n        /// @notice The span indicating how many proposals this transition record covers.\n        uint8 span;\n        /// @notice The bond instructions.\n        LibBonds.BondInstruction[] bondInstructions;\n        /// @notice The hash of the last transition in the span.\n        bytes32 transitionHash;\n        /// @notice The hash of the last checkpoint in the span.\n        bytes32 checkpointHash;\n    }\n\n    /// @notice Represents the core state of the inbox.\n    struct CoreState {\n        /// @notice The next proposal ID to be assigned.\n        uint48 nextProposalId;\n        /// @notice The last block ID where a proposal was made.\n        uint48 lastProposalBlockId;\n        /// @notice The ID of the last finalized proposal.\n        uint48 lastFinalizedProposalId;\n        /// @notice The timestamp when the last checkpoint was saved.\n        /// @dev In genesis block, this is set to 0 to allow the first checkpoint to be saved.\n        uint48 lastCheckpointTimestamp;\n        /// @notice The hash of the last finalized transition.\n        bytes32 lastFinalizedTransitionHash;\n        /// @notice The hash of all bond instructions.\n        bytes32 bondInstructionsHash;\n    }\n\n    /// @notice Input data for the propose function\n    struct ProposeInput {\n        /// @notice The deadline timestamp for transaction inclusion (0 = no deadline).\n        uint48 deadline;\n        /// @notice The current core state before this proposal.\n        CoreState coreState;\n        /// @notice Array of existing proposals for validation (1-2 elements).\n        Proposal[] parentProposals;\n        /// @notice Blob reference for proposal data.\n        LibBlobs.BlobReference blobReference;\n        /// @notice Array of transition records for finalization.\n        TransitionRecord[] transitionRecords;\n        /// @notice The checkpoint for finalization.\n        ICheckpointStore.Checkpoint checkpoint;\n        /// @notice The number of forced inclusions that the proposer wants to process.\n        /// @dev This can be set to 0 if no forced inclusions are due, and there's none in the queue\n        /// that he wants to include.\n        uint8 numForcedInclusions;\n    }\n\n    /// @notice Input data for the prove function\n    struct ProveInput {\n        /// @notice Array of proposals to prove.\n        Proposal[] proposals;\n        /// @notice Array of transitions containing proof details.\n        Transition[] transitions;\n        /// @notice Array of metadata for prover information.\n        /// @dev Must have same length as transitions array.\n        TransitionMetadata[] metadata;\n    }\n\n    /// @notice Payload data emitted in the Proposed event\n    struct ProposedEventPayload {\n        /// @notice The proposal that was created.\n        Proposal proposal;\n        /// @notice The derivation data for the proposal.\n        Derivation derivation;\n        /// @notice The core state after the proposal.\n        CoreState coreState;\n        /// @notice Bond instructions finalized while processing this proposal.\n        LibBonds.BondInstruction[] bondInstructions;\n    }\n\n    /// @notice Payload data emitted in the Proved event\n    struct ProvedEventPayload {\n        /// @notice The proposal ID that was proven.\n        uint48 proposalId;\n        /// @notice The transition that was proven.\n        Transition transition;\n        /// @notice The transition record containing additional metadata.\n        TransitionRecord transitionRecord;\n        /// @notice The metadata containing prover information.\n        TransitionMetadata metadata;\n    }\n\n    // ---------------------------------------------------------------\n    // Events\n    // ---------------------------------------------------------------\n\n    /// @notice Emitted when a new proposal is proposed.\n    /// @param data The encoded ProposedEventPayload\n    event Proposed(bytes data);\n\n    /// @notice Emitted when a proof is submitted\n    /// @param data The encoded ProvedEventPayload\n    event Proved(bytes data);\n\n    /// @notice Emitted when a conflicting transition is detected. This event will be followed by a\n    /// Proved event.\n    event TransitionConflictDetected();\n\n    /// @notice Emitted when a transition is proved again. This event will be followed by a Proved\n    /// event.\n    event TransitionDuplicateDetected();\n\n    // ---------------------------------------------------------------\n    // External Transactional Functions\n    // ---------------------------------------------------------------\n\n    /// @notice Proposes new proposals of L2 blocks.\n    /// @param _lookahead Encoded data forwarded to the proposer checker (i.e. lookahead payloads).\n    /// @param _data The encoded ProposeInput struct.\n    function propose(bytes calldata _lookahead, bytes calldata _data) external;\n\n    /// @notice Proves a transition about some properties of a proposal, including its state\n    /// transition.\n    /// @param _data The encoded ProveInput struct.\n    /// @param _proof Validity proof for the transitions.\n    function prove(bytes calldata _data, bytes calldata _proof) external;\n\n    // ---------------------------------------------------------------\n    // External View Functions\n    // ---------------------------------------------------------------\n\n    /// @notice Returns the proposal hash for a given proposal ID.\n    /// @param _proposalId The proposal ID to look up.\n    /// @return proposalHash_ The hash stored at the proposal's ring buffer slot.\n    function getProposalHash(uint48 _proposalId) external view returns (bytes32 proposalHash_);\n\n    /// @notice Returns the transition record hash for a given proposal ID and parent transition\n    /// hash.\n    /// @param _proposalId The proposal ID.\n    /// @param _parentTransitionHash The parent transition hash.\n    /// @return finalizationDeadline_ The timestamp when finalization is enforced.\n    /// @return recordHash_ The hash of the transition record.\n    function getTransitionRecordHash(\n        uint48 _proposalId,\n        bytes32 _parentTransitionHash\n    )\n        external\n        view\n        returns (uint48 finalizationDeadline_, bytes26 recordHash_);\n\n    /// @notice Returns the configuration parameters of the Inbox contract\n    /// @return config_ The configuration struct containing all immutable parameters\n    function getConfig() external view returns (Config memory config_);\n}\n"
    }
}