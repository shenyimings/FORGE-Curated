{
    "vfp_id": "vfp_00118",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Liquidation mechanism can be permanently disabled by misconfigured grace and expiry periods",
            "description": "The Lender contract does not validate that the grace period is less than the expiry period during initialization. If grace >= expiry, the liquidation mechanism becomes impossible to trigger because the validateLiquidation function requires block.timestamp to be both greater than start+grace and less than start+expiry, which cannot be satisfied simultaneously. The root cause is the lack of input validation for critical configuration parameters. Since these parameters cannot be reset after deployment, a misconfiguration would permanently disable liquidations. An attacker or negligent admin could deploy the contract with such invalid parameters, preventing any liquidation from occurring even when agents are severely undercollateralized. This leads to the accumulation of bad debt and potentially results in protocol insolvency as unhealthy positions remain outstanding indefinitely.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol#L98-L102",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "ValidationLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IDelegation } from \"../../interfaces/IDelegation.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ILender } from \"../../interfaces/ILender.sol\";\nimport { ViewLogic } from \"./ViewLogic.sol\";\n\n/// @title Validation Logic\n/// @author kexley, @capLabs\n/// @notice Validate actions before state is altered\nlibrary ValidationLogic {\n    /// @dev Collateral cannot cover new borrow\n    error CollateralCannotCoverNewBorrow();\n\n    /// @dev Health factor not below threshold\n    error HealthFactorNotBelowThreshold();\n\n    /// @dev Health factor lower than liquidation threshold\n    error HealthFactorLowerThanLiquidationThreshold(uint256 health);\n\n    /// @dev Already initiated\n    error AlreadyInitiated();\n\n    /// @dev Grace period not over\n    error GracePeriodNotOver();\n\n    /// @dev Liquidation expired\n    error LiquidationExpired();\n\n    /// @dev Reserve paused\n    error ReservePaused();\n\n    /// @dev Asset not listed\n    error AssetNotListed();\n\n    /// @dev Variable debt supply not zero\n    error VariableDebtSupplyNotZero();\n\n    /// @dev Zero address not valid\n    error ZeroAddressNotValid();\n\n    /// @dev Reserve already initialized\n    error ReserveAlreadyInitialized();\n\n    /// @dev Interest receiver not set\n    error InterestReceiverNotSet();\n\n    /// @dev Restaker interest receiver not set\n    error RestakerInterestReceiverNotSet();\n\n    /// @dev Minimum borrow amount\n    error MinBorrowAmount();\n\n    /// @notice Validate the borrow of an agent\n    /// @dev Check the pause state of the reserve and the health of the agent before and after the\n    /// borrow.\n    /// @param $ Lender storage\n    /// @param params Validation parameters\n    function validateBorrow(ILender.LenderStorage storage $, ILender.BorrowParams memory params) external {\n        if (params.amount < $.reservesData[params.asset].minBorrow) revert MinBorrowAmount();\n        if (params.receiver == address(0) || params.asset == address(0)) revert ZeroAddressNotValid();\n        if ($.reservesData[params.asset].paused) revert ReservePaused();\n\n        uint256 borrowCapacity = ViewLogic.maxBorrowable($, params.agent, params.asset);\n\n        if (params.amount > borrowCapacity) revert CollateralCannotCoverNewBorrow();\n\n        IDelegation($.delegation).setLastBorrow(params.agent);\n    }\n\n    /// @notice Validate the initialization of the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    /// @param start Last liquidation start time\n    /// @param expiry Liquidation duration after which it expires\n    function validateInitiateLiquidation(uint256 health, uint256 start, uint256 expiry) external view {\n        if (health >= 1e27) revert HealthFactorNotBelowThreshold();\n        if (block.timestamp <= start + expiry) revert AlreadyInitiated();\n    }\n\n    /// @notice Validate the cancellation of the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    function validateCancelLiquidation(uint256 health) external pure {\n        if (health < 1e27) revert HealthFactorLowerThanLiquidationThreshold(health);\n    }\n\n    /// @notice Validate the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    /// @param emergencyHealth Emergency health below which the grace period is voided\n    /// @param start Last liquidation start time\n    /// @param grace Grace period duration\n    /// @param expiry Liquidation duration after which it expires\n    function validateLiquidation(uint256 health, uint256 emergencyHealth, uint256 start, uint256 grace, uint256 expiry)\n        external\n        view\n    {\n        if (health >= 1e27) revert HealthFactorNotBelowThreshold();\n        if (emergencyHealth >= 1e27) {\n            if (block.timestamp <= start + grace) revert GracePeriodNotOver();\n            if (block.timestamp >= start + expiry) revert LiquidationExpired();\n        }\n    }\n\n    /// @notice Validate adding an asset as a reserve\n    /// @param $ Lender storage\n    /// @param params Parameters for adding an asset\n    function validateAddAsset(ILender.LenderStorage storage $, ILender.AddAssetParams memory params) external view {\n        if (params.asset == address(0) || params.vault == address(0)) revert ZeroAddressNotValid();\n        if (params.interestReceiver == address(0)) revert InterestReceiverNotSet();\n        if (params.restakerInterestReceiver == address(0)) revert RestakerInterestReceiverNotSet();\n        if ($.reservesData[params.asset].vault != address(0)) revert ReserveAlreadyInitialized();\n    }\n\n    /// @notice Validate dropping an asset as a reserve\n    /// @dev All principal borrows must be repaid, interest is ignored\n    /// @param $ Lender storage\n    /// @param _asset Asset to remove\n    function validateRemoveAsset(ILender.LenderStorage storage $, address _asset) external view {\n        if (IERC20($.reservesData[_asset].debtToken).totalSupply() != 0) revert VariableDebtSupplyNotZero();\n    }\n\n    /// @notice Validate pausing a reserve\n    /// @param $ Lender storage\n    /// @param _asset Asset to pause\n    function validatePauseAsset(ILender.LenderStorage storage $, address _asset) external view {\n        if ($.reservesData[_asset].vault == address(0)) revert AssetNotListed();\n    }\n\n    /// @notice Validate setting the minimum borrow amount\n    /// @param $ Lender storage\n    /// @param _asset Asset to set minimum borrow amount\n    function validateSetMinBorrow(ILender.LenderStorage storage $, address _asset) external view {\n        if ($.reservesData[_asset].vault == address(0)) revert AssetNotListed();\n    }\n}\n"
    }
}