{
    "vfp_id": "vfp_00318",
    "project_name": "ackee-blockchain-fluidkey-earn-module-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Cross-chain replay attack vulnerability",
            "description": "The autoEarn function generates a signature verification hash without including the chain ID in its calculation. This omission allows the same signature to be valid across multiple blockchain networks where the module is deployed.\nThe root cause is the failure to bind the signature to a specific chain, making it possible for an attacker to replay a valid signature from one chain on another.\nAn attacker can observe a valid transaction and signature on one chain (e.g., Chain A), then replay that signature on a different chain (e.g., Chain B) where the same module is deployed. Since the chain ID is not part of the hash, the signature verification will succeed on the target chain.\nThis leads to unauthorized execution of operations, such as unauthorized asset movements, effectively allowing an attacker to perform actions on behalf of the original signer on a different chain.\n",
            "severity": "High",
            "location": [
                "FluidkeyEarnModule.sol::autoEarn#291"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "MAX_TOKENS limit bypass via setConfig leading to unintended module persistence",
            "description": "The module enforces a MAX_TOKENS limit during installation via the onInstall function, but this validation is missing in the setConfig function. As a result, users can add more configurations after installation, bypassing the intended cap.\nThe cause is inconsistent validation logicâ€”while onInstall checks the number of configurations against MAX_TOKENS, setConfig does not, creating an attack vector to exceed the limit.\nAn attacker (or authorized user) can install the module with up to 100 configurations, then use setConfig to add more. Upon uninstallation, only the first 100 configurations are cleaned up, leaving excess configurations active.\nThese leftover configurations remain functional even after the module is uninstalled, allowing continued calls to autoEarn and unauthorized token movements, undermining the module's lifecycle integrity.\n",
            "severity": "Medium",
            "location": [
                "FluidkeyEarnModule.sol::setConfig",
                "FluidkeyEarnModule.sol::onUninstall"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        }
    ],
    "affected_files": {
        "FluidkeyEarnModule.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport { IERC20 } from \"forge-std/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\nimport { SentinelListLib, SENTINEL } from \"sentinellist/SentinelList.sol\";\nimport { Ownable } from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ECDSA } from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\nimport { MessageHashUtils } from\n    \"openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol\";\n\n/**\n * @title FluidkeyEarnModule\n * This module allows Fluidkey to automatically deposit funds into an ERC-4626 vault on behalf of\n * users.\n * @dev This contract is based on a contract originally authored by Rhinestone.\n * The original contract can be found at\n * https://github.com/rhinestonewtf/core-modules/blob/main/src/AutoSavings/AutoSavings.sol (commit\n * 18b057).\n */\ninterface Safe {\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation\n    )\n        external\n        returns (bool success);\n}\n\ninterface IWrappedNative {\n    function deposit() external payable;\n}\n\ncontract FluidkeyEarnModule is Ownable {\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                            CONSTANTS & STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    error TooManyTokens();\n    error ModuleNotInitialized(address account);\n    error NotAuthorized(address relayer);\n    error ConfigNotFound(address token);\n    error CannotRemoveSelf();\n    error SignatureAlreadyUsed();\n\n    uint256 internal constant MAX_TOKENS = 100;\n    address public immutable ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public wrappedNative;\n\n    constructor(address _authorizedRelayer, address _wrappedNative) Ownable(msg.sender) {\n        authorizedRelayers[_authorizedRelayer] = true;\n        emit AddAuthorizedRelayer(_authorizedRelayer);\n        wrappedNative = _wrappedNative;\n    }\n\n    struct ConfigWithToken {\n        address token; // address of the token\n        address vault; // address of the vault\n    }\n\n    // authorizedRelayer -> bool\n    mapping(address authorizedRelayer => bool) public authorizedRelayers;\n\n    // account => token => Config\n    mapping(address account => mapping(address token => address vault)) public config;\n\n    // account => tokens\n    mapping(address account => SentinelListLib.SentinelList) tokens;\n\n    // hash => executed (avoid replay attacks)\n    mapping(bytes32 => bool) public executedHashes;\n\n    event AddAuthorizedRelayer(address indexed relayer);\n    event RemoveAuthorizedRelayer(address indexed relayer);\n    event ModuleInitialized(address indexed account);\n    event ModuleUninitialized(address indexed account);\n    event ConfigSet(address indexed account, address indexed token);\n    event AutoEarnExecuted(address indexed smartAccount, address indexed token, uint256 amountIn);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONFIG\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Modifier to check if the caller is an authorized relayer or the owner\n     */\n    modifier onlyAuthorizedRelayer() {\n        if (!authorizedRelayers[msg.sender] && msg.sender != owner()) {\n            revert NotAuthorized(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * Adds a new authorized relayer\n     * @dev the function will revert if the caller is not an authorized relayer or the owner\n     *\n     * @param newRelayer address of the new relayer\n     */\n    function addAuthorizedRelayer(address newRelayer) external onlyAuthorizedRelayer {\n        authorizedRelayers[newRelayer] = true;\n        emit AddAuthorizedRelayer(newRelayer);\n    }\n\n    /**\n     * Removes an authorized relayer\n     * @dev the function will revert if the caller is not an authorized relayer or the owner\n     *\n     * @param relayer address of the relayer to be removed\n     */\n    function removeAuthorizedRelayer(address relayer) external onlyAuthorizedRelayer {\n        if (relayer == msg.sender) revert CannotRemoveSelf();\n        delete authorizedRelayers[relayer];\n        emit RemoveAuthorizedRelayer(relayer);\n    }\n\n    /**\n     * Initializes the module with the tokens and their configurations\n     * @dev data is encoded as follows: abi.encode(ConfigWithToken[])\n     *\n     * @param data encoded data containing the tokens and their configurations\n     */\n    function onInstall(bytes calldata data) external {\n        // cache the account address\n        address account = msg.sender;\n\n        // decode the data to get the tokens and their configurations\n        (ConfigWithToken[] memory _configs) = abi.decode(data, (ConfigWithToken[]));\n\n        // initialize the sentinel list\n        tokens[account].init();\n\n        // get the length of the tokens\n        uint256 length = _configs.length;\n\n        // check that the length of tokens is less than max\n        if (length > MAX_TOKENS) revert TooManyTokens();\n\n        // loop through the tokens, add them to the list and set their configurations\n        for (uint256 i; i < length; i++) {\n            address _token = _configs[i].token;\n            address _vault = _configs[i].vault;\n            config[account][_token] = _vault;\n            tokens[account].push(_token);\n        }\n\n        emit ModuleInitialized(account);\n    }\n\n    /**\n     * Handles the uninstallation of the module and clears the tokens and configurations\n     * @dev the data parameter is not used\n     */\n    function onUninstall() external {\n        // cache the account address\n        address account = msg.sender;\n\n        // clear the configurations\n        (address[] memory tokensArray,) = tokens[account].getEntriesPaginated(SENTINEL, MAX_TOKENS);\n        uint256 tokenLength = tokensArray.length;\n        for (uint256 i; i < tokenLength; i++) {\n            delete config[account][tokensArray[i]];\n        }\n\n        // clear the tokens\n        tokens[account].popAll();\n\n        emit ModuleUninitialized(account);\n    }\n\n    /**\n     * Checks if the module is initialized\n     *\n     * @param smartAccount address of the smart account\n     * @return true if the module is initialized, false otherwise\n     */\n    function isInitialized(address smartAccount) public view returns (bool) {\n        // check if the linked list is initialized for the smart account\n        return tokens[smartAccount].alreadyInitialized();\n    }\n\n    /**\n     * Sets the configuration for a token\n     * @dev the function will revert if the module is not initialized\n     * @dev this function can be used to set a new configuration or update an existing one\n     *\n     * @param token address of the token\n     * @param vault address of the vault\n     */\n    function setConfig(address token, address vault) public {\n        // cache the account address\n        address account = msg.sender;\n        // check if the module is not initialized and revert if it is not\n        if (!isInitialized(account)) revert ModuleNotInitialized(account);\n\n        // set the configuration for the token\n        config[account][token] = vault;\n\n        // add the token to the list if it is not already there\n        if (!tokens[account].contains(token)) {\n            tokens[account].push(token);\n        }\n\n        emit ConfigSet(account, token);\n    }\n\n    /**\n     * Deletes the configuration for a token\n     * @dev the function will revert if the module is not initialized\n     *\n     * @param prevToken address of the token stored before the token to be deleted\n     * @param token address of the token to be deleted\n     */\n    function deleteConfig(address prevToken, address token) public {\n        // cache the account address\n        address account = msg.sender;\n\n        // delete the configuration for the token\n        delete config[account][token];\n\n        // remove the token from the list\n        tokens[account].pop(prevToken, token);\n\n        emit ConfigSet(account, token);\n    }\n\n    /**\n     * Gets a list of all tokens\n     * @dev the function will revert if the module is not initialized\n     *\n     * @param account address of the account\n     */\n    function getTokens(address account) external view returns (address[] memory tokensArray) {\n        // return the tokens from the list\n        (tokensArray,) = tokens[account].getEntriesPaginated(SENTINEL, MAX_TOKENS);\n    }\n\n    /**\n     * Gets all configurations for an account\n     * @dev the function will revert if the module is not initialized\n     *\n     * @param account address of the account\n     */\n    function getAllConfigs(address account) external view returns (ConfigWithToken[] memory) {\n        address[] memory tokensArray = this.getTokens(account);\n        ConfigWithToken[] memory configsArray = new ConfigWithToken[](tokensArray.length);\n\n        for (uint256 i; i < tokensArray.length; i++) {\n            address tokenAddr = tokensArray[i];\n            configsArray[i] =\n                ConfigWithToken({ token: tokenAddr, vault: config[account][tokenAddr] });\n        }\n\n        return configsArray;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     MODULE LOGIC\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Initiates the auto-earn process for the specified token and amount.\n     * This overload checks the relayer's authorization and verifies the signature.\n     *\n     * @param token The address of the token to be saved.\n     * @param amountToSave The amount of tokens to deposit into the vault.\n     * @param safe The address of the Safe from which the transaction is executed.\n     * @param nonce A unique identifier for the transaction, so that 2 txs for same token, safe and\n     * amount can be distinguished.\n     * @param signature A signature from the relayer verifying the transaction details.\n     */\n    function autoEarn(\n        address token,\n        uint256 amountToSave,\n        address safe,\n        uint256 nonce,\n        bytes memory signature\n    )\n        external\n    {\n        // Ensure the relayer is an authorized one and the signature not already used\n        bytes32 hash = keccak256(abi.encodePacked(token, amountToSave, safe, nonce));\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(hash);\n        if (executedHashes[ethSignedHash]) {\n            revert SignatureAlreadyUsed();\n        }\n        address relayer = ECDSA.recover(ethSignedHash, signature);\n        if (!authorizedRelayers[relayer]) {\n            revert NotAuthorized(relayer);\n        }\n        executedHashes[ethSignedHash] = true;\n\n        // Execute the auto-earn process\n        _autoEarn(token, amountToSave, safe);\n    }\n\n    /**\n     * Initiates the auto-earn process for the specified token and amount.\n     * This overload assumes the caller is already an authorized relayer.\n     *\n     * @param token The address of the token to be saved.\n     * @param amountToSave The amount of tokens to deposit into the vault.\n     * @param safe The address of the Safe from which the transaction is executed.\n     */\n    function autoEarn(\n        address token,\n        uint256 amountToSave,\n        address safe\n    )\n        external\n        onlyAuthorizedRelayer\n    {\n        _autoEarn(token, amountToSave, safe);\n    }\n\n    /**\n     * Executes the auto earn logic\n     * @dev the function acts on behalf of the safe's own context\n     *\n     * @param token address of the token received\n     * @param amountToSave amount received by the user\n     * @param safe address of the user's safe to execute the transaction on\n     */\n    function _autoEarn(address token, uint256 amountToSave, address safe) private {\n        // initialize the safe instance\n        Safe safeInstance = Safe(safe);\n\n        // get the configuration for the token\n        address vaultAddress = config[safe][token];\n\n        // get the vault\n        IERC4626 vault = IERC4626(vaultAddress);\n\n        // check if the config exists and revert if not\n        if (address(vault) == address(0)) {\n            revert ConfigNotFound(token);\n        }\n\n        IERC20 tokenToSave;\n\n        // if token is ETH, wrap it\n        if (token == address(ETH)) {\n            safeInstance.execTransactionFromModule(\n                address(wrappedNative),\n                amountToSave,\n                abi.encodeWithSelector(IWrappedNative.deposit.selector),\n                0\n            );\n            tokenToSave = IERC20(wrappedNative);\n        } else {\n            tokenToSave = IERC20(token);\n        }\n\n        // approve the vault to spend the token\n        bool approvalSuccess = safeInstance.execTransactionFromModule(\n            address(tokenToSave),\n            0,\n            abi.encodeWithSelector(IERC20.approve.selector, address(vault), amountToSave),\n            0\n        );\n        if (!approvalSuccess) {\n            revert(\"Failed to approve vault to spend tokens\");\n        }\n\n        // deposit to vault\n        bool depositSuccess = safeInstance.execTransactionFromModule(\n            address(vault),\n            0,\n            abi.encodeWithSelector(IERC4626.deposit.selector, amountToSave, safe),\n            0\n        );\n        if (!depositSuccess) {\n            revert(\"Failed to deposit tokens into the vault\");\n        }\n\n        // emit event\n        emit AutoEarnExecuted(safe, token, amountToSave);\n    }\n}\n"
    }
}