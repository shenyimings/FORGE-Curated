{
    "vfp_id": "vfp_00316",
    "project_name": "Sorella - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "zeroForOne current tick transition is incorrect",
            "description": "The vulnerability occurs in the TickIteratorDown initialization during a swap where the current tick matches the upper tick of a liquidity position. Because the upper tick is exclusive, the liquidity should be added when the price moves down, but the reset() function in TickIteratorDown calls _advanceToNextDown(), which skips the current tick, failing to account for the pending liquidity. This causes an incorrect liquidity subtraction during a zeroForOne swap, potentially leading to an overflow when subtracting liquidity that was never added. An attacker could exploit this by creating a position at the current tick and triggering a downward swap, resulting in an invalid state and potential DoS or incorrect fee distribution. The impact includes miscalculated liquidity and potential reverts during swaps, disrupting pool operations.\n",
            "severity": "High",
            "location": [
                "CompensationPriceFinder.sol#L67"
            ],
            "files": [
                "l2-angstrom/src/libraries/CompensationPriceFinder.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "beforeInitialization() checks are bypassed due to noSelfCall modifier",
            "description": "The beforeInitialize() hook is intended to enforce pool configuration constraints, such as requiring native currency and dynamic fees. However, the noSelfCall modifier prevents the hook from being executed when the contract itself initiates the call, which occurs during pool initialization. As a result, the validation checks in beforeInitialize() are bypassed, allowing incompatible pool configurations to be created. This is caused by the modifier's logic that only allows external callers, excluding self-calls. An attacker could exploit this by creating a pool with invalid parameters, such as non-native currency or static fees, undermining the protocol's security assumptions. The impact includes potential misconfiguration of pools and violation of intended constraints.\n",
            "severity": "Medium",
            "location": [
                "AngstromL2.sol#L179",
                "AngstromL2.sol#L186-L196"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Liquidity ranges deltas are not rounded in the right direction",
            "description": "The liquidity delta calculations in _zeroForOneCreditRewards(), _oneForZeroCreditRewards(), getZeroForOne(), and getOneForZero() always round down, which deviates from the intended economic model. The protocol expects delta1 to be rounded up in zero-for-one swaps and delta0 in one-for-zero swaps to fairly reward liquidity providers near the price. Due to incorrect rounding, LPs may receive less reward than expected, and in edge cases, it can lead to underflow when lpCompensationAmount is reduced. This can be exploited by crafting swaps across many small liquidity ranges, causing miscalculations in reward distribution. The impact includes unfair reward allocation and potential arithmetic underflows, leading to transaction failures.\n",
            "severity": "Medium",
            "location": [
                "AngstromL2",
                "CompensationPriceFinder"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol",
                "l2-angstrom/src/libraries/CompensationPriceFinder.sol"
            ]
        }
    ],
    "affected_files": {
        "AngstromL2.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.26;\n\nimport {UniConsumer} from \"./modules/UniConsumer.sol\";\nimport {Ownable} from \"solady/src/auth/Ownable.sol\";\nimport {IAngstromL2Hook} from \"./interfaces/IAngstromL2Hook.sol\";\nimport {IUniV4, IPoolManager, PoolId} from \"./interfaces/IUniV4.sol\";\nimport {TickIteratorLib, TickIteratorUp, TickIteratorDown} from \"./libraries/TickIterator.sol\";\nimport {\n    PoolKey,\n    IBeforeSwapHook,\n    IAfterSwapHook,\n    IAfterAddLiquidityHook,\n    IAfterRemoveLiquidityHook,\n    IBeforeInitializeHook\n} from \"./interfaces/IHooks.sol\";\nimport {IFlashBlockNumber} from \"./interfaces/IFlashBlockNumber.sol\";\nimport {IFactory} from \"./interfaces/IFactory.sol\";\nimport {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {ModifyLiquidityParams, SwapParams} from \"v4-core/src/types/PoolOperation.sol\";\nimport {Hooks, IHooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {Slot0} from \"v4-core/src/types/Slot0.sol\";\nimport {TickMath} from \"v4-core/src/libraries/TickMath.sol\";\nimport {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";\nimport {SqrtPriceMath} from \"v4-core/src/libraries/SqrtPriceMath.sol\";\nimport {LPFeeLibrary} from \"v4-core/src/libraries/LPFeeLibrary.sol\";\nimport {SafeCastLib} from \"solady/src/utils/SafeCastLib.sol\";\nimport {MixedSignLib} from \"./libraries/MixedSignLib.sol\";\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\nimport {Q96MathLib} from \"./libraries/Q96MathLib.sol\";\nimport {CompensationPriceFinder} from \"./libraries/CompensationPriceFinder.sol\";\nimport {PoolRewards, PoolRewardsLib} from \"./types/PoolRewards.sol\";\nimport {PoolKeyHelperLib} from \"./libraries/PoolKeyHelperLib.sol\";\nimport {getRequiredHookPermissions} from \"src/hook-config.sol\";\nimport {tuint256, tbytes32} from \"transient-goodies/TransientPrimitives.sol\";\n\n/// @author philogy <https://github.com/philogy>\ncontract AngstromL2 is\n    UniConsumer,\n    Ownable,\n    IBeforeInitializeHook,\n    IBeforeSwapHook,\n    IAfterSwapHook,\n    IAfterAddLiquidityHook,\n    IAfterRemoveLiquidityHook,\n    IAngstromL2Hook\n{\n    using IUniV4 for IPoolManager;\n    using PoolKeyHelperLib for PoolKey;\n    using Hooks for IHooks;\n    using MixedSignLib for *;\n    using FixedPointMathLib for *;\n    using Q96MathLib for uint256;\n    using SafeCastLib for *;\n\n    error NegationOverflow();\n    error CreatorFeeExceedsMaximum();\n    error AttemptingToWithdrawLPRewards();\n    error IncompatiblePoolConfiguration();\n    error PoolNotInitialized();\n    error PoolAlreadyInitialized();\n\n    /// @dev The `SWAP_TAXED_GAS` is the abstract estimated gas cost for a swap. We want it to be\n    /// a constant so that competing searchers have a bid cost independent of how much gas swap\n    /// actually uses, the overall tax just needs to scale proportional to `priority_fee * swap_fixed_cost`.\n    uint256 internal constant SWAP_TAXED_GAS = 100_000;\n    /// @dev MEV tax charged is `priority_fee * SWAP_MEV_TAX_FACTOR` meaning the tax rate is\n    /// `SWAP_MEV_TAX_FACTOR / (SWAP_MEV_TAX_FACTOR + 1)`\n    uint256 constant SWAP_MEV_TAX_FACTOR = 49;\n    /// @dev Parameters for taxing just-in-time (JIT) liquidity\n    uint256 internal constant JIT_TAXED_GAS = 100_000;\n    uint256 internal constant JIT_MEV_TAX_FACTOR = SWAP_MEV_TAX_FACTOR * 4;\n\n    uint256 internal constant NATIVE_CURRENCY_ID = 0;\n    Currency internal constant NATIVE_CURRENCY = CurrencyLibrary.ADDRESS_ZERO;\n    uint256 internal constant FACTOR_E6 = 1e6;\n    uint256 internal constant MAX_CREATOR_SWAP_FEE_E6 = 0.2e6;\n    uint256 internal constant MAX_CREATOR_TAX_FEE_E6 = 0.5e6; // 50%\n\n    // TODO: Be able to set provider.\n    address public immutable FACTORY;\n\n    IFlashBlockNumber internal flashBlockNumberProvider;\n    uint96 internal _blockOfLastTopOfBlock;\n    mapping(PoolId id => PoolRewards) internal rewards;\n\n    struct PoolFeeConfiguration {\n        bool isInitialized;\n        uint24 creatorTaxFeeE6;\n        uint24 protocolTaxFeeE6;\n        uint24 creatorSwapFeeE6;\n        uint24 protocolSwapFeeE6;\n    }\n\n    mapping(PoolId id => PoolFeeConfiguration) internal _poolFeeConfiguration;\n\n    tuint256 internal liquidityBeforeSwap;\n    tbytes32 internal slot0BeforeSwapStore;\n\n    // Ownable explicit constructor commented out because of weird foundry bug causing\n    // \"modifier-style base constructor call without arguments\": https://github.com/foundry-rs/foundry/issues/11607.\n    constructor(\n        IPoolManager uniV4,\n        IFlashBlockNumber initialFlashBlockNumberProvider,\n        address owner\n    ) UniConsumer(uniV4) /* Ownable() */ {\n        _initializeOwner(owner);\n        FACTORY = msg.sender;\n        Hooks.validateHookPermissions(IHooks(address(this)), getRequiredHookPermissions());\n        flashBlockNumberProvider = initialFlashBlockNumberProvider;\n    }\n\n    receive() external payable {}\n\n    function syncFlashBlockNumberProvider() public {\n        flashBlockNumberProvider = IFactory(FACTORY).flashBlockNumberProvider();\n    }\n\n    function withdrawCreatorRevenue(Currency currency, address to, uint256 amount) public {\n        _checkOwner();\n        currency.transfer(to, amount);\n    }\n\n    function setProtocolSwapFee(PoolKey calldata key, uint256 newFeeE6) public {\n        _checkCallerIsFactory();\n        PoolFeeConfiguration storage feeConfiguration = _poolFeeConfiguration[key.calldataToId()];\n        if (!feeConfiguration.isInitialized) revert PoolNotInitialized();\n        feeConfiguration.protocolSwapFeeE6 = newFeeE6.toUint24();\n    }\n\n    function setProtocolTaxFee(PoolKey calldata key, uint256 newFeeE6) public {\n        _checkCallerIsFactory();\n        PoolFeeConfiguration storage feeConfiguration = _poolFeeConfiguration[key.calldataToId()];\n        if (!feeConfiguration.isInitialized) revert PoolNotInitialized();\n        feeConfiguration.protocolTaxFeeE6 = newFeeE6.toUint24();\n    }\n\n    function getSwapTaxAmount(uint256 priorityFee) public pure returns (uint256) {\n        return SWAP_MEV_TAX_FACTOR * SWAP_TAXED_GAS * priorityFee;\n    }\n\n    function getJitTaxAmount(uint256 priorityFee) public pure returns (uint256) {\n        return JIT_MEV_TAX_FACTOR * JIT_TAXED_GAS * priorityFee;\n    }\n\n    function getPendingPositionRewards(\n        PoolKey calldata key,\n        address owner,\n        int24 lowerTick,\n        int24 upperTick,\n        bytes32 salt\n    ) public view returns (uint256 rewards0) {\n        PoolId id = key.calldataToId();\n        rewards0 =\n            rewards[id].getPendingPositionRewards(UNI_V4, id, owner, lowerTick, upperTick, salt);\n    }\n\n    function getPoolFeeConfiguration(PoolKey calldata key)\n        public\n        view\n        returns (PoolFeeConfiguration memory)\n    {\n        return _poolFeeConfiguration[key.calldataToId()];\n    }\n\n    function initializeNewPool(\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        uint24 creatorSwapFeeE6,\n        uint24 creatorTaxFeeE6\n    ) public {\n        if (!(msg.sender == owner() || msg.sender == FACTORY)) revert Unauthorized();\n        PoolFeeConfiguration storage feeConfiguration = _poolFeeConfiguration[key.calldataToId()];\n        if (feeConfiguration.isInitialized) revert PoolAlreadyInitialized();\n        if (!(creatorSwapFeeE6 <= MAX_CREATOR_SWAP_FEE_E6)) revert CreatorFeeExceedsMaximum();\n        if (!(creatorTaxFeeE6 <= MAX_CREATOR_TAX_FEE_E6)) revert CreatorFeeExceedsMaximum();\n        feeConfiguration.isInitialized = true;\n        UNI_V4.initialize(key, sqrtPriceX96);\n        feeConfiguration.creatorSwapFeeE6 = creatorSwapFeeE6.toUint24();\n        feeConfiguration.creatorTaxFeeE6 = creatorTaxFeeE6.toUint24();\n        (feeConfiguration.protocolSwapFeeE6, feeConfiguration.protocolTaxFeeE6) = IFactory(FACTORY)\n            .recordPoolCreationAndGetStartingProtocolFee(key, creatorSwapFeeE6, creatorTaxFeeE6);\n    }\n\n    function beforeInitialize(address sender, PoolKey calldata key, uint160)\n        external\n        view\n        returns (bytes4)\n    {\n        _onlyUniV4();\n        if (sender != address(this)) revert Unauthorized();\n        if (key.currency0.toId() != NATIVE_CURRENCY_ID) revert IncompatiblePoolConfiguration();\n        if (LPFeeLibrary.isDynamicFee(key.fee)) revert IncompatiblePoolConfiguration();\n        return this.beforeInitialize.selector;\n    }\n\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) external returns (bytes4, BalanceDelta) {\n        _onlyUniV4();\n\n        PoolId id = key.calldataToId();\n        rewards[id].updateAfterLiquidityAdd(UNI_V4, id, key.tickSpacing, sender, params);\n        uint256 taxAmountInEther = _getJitTaxAmount();\n        if (taxAmountInEther > 0) {\n            // Protocol collects 100% of the JIT MEV tax\n            UNI_V4.take(CurrencyLibrary.fromId(NATIVE_CURRENCY_ID), FACTORY, taxAmountInEther);\n        }\n        return (this.afterAddLiquidity.selector, toBalanceDelta(taxAmountInEther.toInt128(), 0));\n    }\n\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) external returns (bytes4, BalanceDelta) {\n        _onlyUniV4();\n\n        PoolId id = key.calldataToId();\n        uint256 rewardAmount0 = rewards[id].updateAfterLiquidityRemove(UNI_V4, id, sender, params);\n        uint256 taxAmountInEther = _getJitTaxAmount();\n        if (taxAmountInEther > 0) {\n            // Protocol collects 100% of the JIT MEV tax\n            UNI_V4.take(CurrencyLibrary.fromId(NATIVE_CURRENCY_ID), FACTORY, taxAmountInEther);\n        }\n        if (rewardAmount0 > 0) {\n            UNI_V4.burn(address(this), NATIVE_CURRENCY_ID, rewardAmount0);\n        }\n        return (\n            this.afterRemoveLiquidity.selector,\n            toBalanceDelta(taxAmountInEther.toInt128() - rewardAmount0.toInt128(), 0)\n        );\n    }\n\n    function beforeSwap(address, PoolKey calldata key, SwapParams calldata params, bytes calldata)\n        external\n        override\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        _onlyUniV4();\n\n        PoolId id = key.calldataToId();\n        slot0BeforeSwapStore.set(Slot0.unwrap(UNI_V4.getSlot0(id)));\n\n        if (_getBlock() == _blockOfLastTopOfBlock) {\n            return (this.beforeSwap.selector, toBeforeSwapDelta(0, 0), 0);\n        }\n\n        liquidityBeforeSwap.set(UNI_V4.getPoolLiquidity(id));\n        int128 etherDelta = _getSwapTaxAmount().toInt128();\n\n        bool etherWasSpecified = params.zeroForOne == params.amountSpecified < 0;\n        return (\n            this.beforeSwap.selector,\n            etherWasSpecified ? toBeforeSwapDelta(etherDelta, 0) : toBeforeSwapDelta(0, etherDelta),\n            0\n        );\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta swapDelta,\n        bytes calldata\n    ) external override returns (bytes4, int128 hookDeltaUnspecified) {\n        _onlyUniV4();\n\n        PoolId id = key.calldataToId();\n        uint96 blockNumber = _getBlock();\n        bool isTopOfBlock = blockNumber != _blockOfLastTopOfBlock;\n        (uint256 feeInUnspecified, uint256 lpCompensationAmount) = _computeAndCollectProtocolSwapFee(\n            key, id, params, swapDelta, isTopOfBlock ? _getSwapTaxAmount() : 0\n        );\n        hookDeltaUnspecified = feeInUnspecified.toInt128();\n\n        PoolKey calldata key_ = key;\n        Slot0 slot0BeforeSwap = Slot0.wrap(slot0BeforeSwapStore.get());\n        Slot0 slot0AfterSwap = UNI_V4.getSlot0(id);\n        rewards[id].updateAfterTickMove(\n            id, UNI_V4, slot0BeforeSwap.tick(), slot0AfterSwap.tick(), key_.tickSpacing\n        );\n\n        if (!isTopOfBlock || lpCompensationAmount == 0) {\n            return (this.afterSwap.selector, hookDeltaUnspecified);\n        }\n        _blockOfLastTopOfBlock = blockNumber;\n\n        params.zeroForOne\n            ? _zeroForOneDistributeTax(\n                id, key_.tickSpacing, slot0BeforeSwap, slot0AfterSwap, lpCompensationAmount\n            )\n            : _oneForZeroDistributeTax(\n                id, key_.tickSpacing, slot0BeforeSwap, slot0AfterSwap, lpCompensationAmount\n            );\n\n        return (this.afterSwap.selector, hookDeltaUnspecified);\n    }\n\n    function _computeAndCollectProtocolSwapFee(\n        PoolKey calldata key,\n        PoolId id,\n        SwapParams calldata params,\n        BalanceDelta swapDelta,\n        uint256 totalTaxInEther\n    ) internal returns (uint256 fee, uint256 lpCompensationAmountInEther) {\n        PoolFeeConfiguration storage feeConfiguration = _poolFeeConfiguration[id];\n        uint256 totalSwapFeeRateE6 =\n            feeConfiguration.protocolSwapFeeE6 + feeConfiguration.creatorSwapFeeE6;\n\n        // Compute the total swap fee amount\n        bool exactIn = params.amountSpecified < 0;\n        uint256 creatorSwapFeeAmount = 0;\n        uint256 protocolSwapFeeAmount = 0;\n        if (totalSwapFeeRateE6 != 0) {\n            int128 unspecifiedDelta =\n                exactIn != params.zeroForOne ? swapDelta.amount0() : swapDelta.amount1();\n            uint256 absTargetAmount = unspecifiedDelta.abs();\n            fee = exactIn\n                ? absTargetAmount * totalSwapFeeRateE6 / FACTOR_E6\n                : absTargetAmount * FACTOR_E6 / (FACTOR_E6 - totalSwapFeeRateE6) - absTargetAmount;\n\n            // Determine protocol/creator split\n            creatorSwapFeeAmount = fee * feeConfiguration.creatorSwapFeeE6 / totalSwapFeeRateE6;\n            protocolSwapFeeAmount = fee - creatorSwapFeeAmount;\n        }\n        Currency feeCurrency = exactIn != params.zeroForOne ? key.currency0 : key.currency1;\n\n        if (totalTaxInEther == 0) {\n            UNI_V4.take(feeCurrency, address(this), creatorSwapFeeAmount);\n            UNI_V4.take(feeCurrency, FACTORY, protocolSwapFeeAmount);\n            return (fee, 0);\n        }\n\n        uint256 creatorTaxShareInEther =\n            totalTaxInEther * feeConfiguration.creatorTaxFeeE6 / FACTOR_E6;\n        uint256 protocolTaxShareInEther =\n            totalTaxInEther * feeConfiguration.protocolTaxFeeE6 / FACTOR_E6;\n        lpCompensationAmountInEther =\n            totalTaxInEther - creatorTaxShareInEther - protocolTaxShareInEther;\n        UNI_V4.mint(address(this), NATIVE_CURRENCY_ID, lpCompensationAmountInEther);\n\n        if (feeCurrency == NATIVE_CURRENCY) {\n            UNI_V4.take(\n                NATIVE_CURRENCY, address(this), creatorSwapFeeAmount + creatorTaxShareInEther\n            );\n            UNI_V4.take(NATIVE_CURRENCY, FACTORY, protocolSwapFeeAmount + protocolTaxShareInEther);\n        } else {\n            UNI_V4.take(NATIVE_CURRENCY, address(this), creatorTaxShareInEther);\n            UNI_V4.take(NATIVE_CURRENCY, FACTORY, protocolTaxShareInEther);\n            UNI_V4.take(feeCurrency, address(this), creatorSwapFeeAmount);\n            UNI_V4.take(feeCurrency, FACTORY, protocolSwapFeeAmount);\n        }\n    }\n\n    function _zeroForOneDistributeTax(\n        PoolId id,\n        int24 tickSpacing,\n        Slot0 slot0BeforeSwap,\n        Slot0 slot0AfterSwap,\n        uint256 lpCompensationAmount\n    ) internal {\n        TickIteratorDown memory ticks = TickIteratorLib.initDown(\n            UNI_V4, id, tickSpacing, slot0BeforeSwap.tick(), slot0AfterSwap.tick()\n        );\n\n        uint128 liquidity = liquidityBeforeSwap.get().toUint128();\n        (int24 lastTick, uint160 pstarSqrtX96) = CompensationPriceFinder.getZeroForOne(\n            ticks, liquidity, lpCompensationAmount, slot0BeforeSwap.sqrtPriceX96(), slot0AfterSwap\n        );\n\n        ticks.reset(slot0BeforeSwap.tick());\n        _zeroForOneCreditRewards(\n            ticks,\n            liquidity,\n            lpCompensationAmount,\n            slot0BeforeSwap.sqrtPriceX96(),\n            lastTick,\n            pstarSqrtX96\n        );\n    }\n\n    function _oneForZeroDistributeTax(\n        PoolId id,\n        int24 tickSpacing,\n        Slot0 slot0BeforeSwap,\n        Slot0 slot0AfterSwap,\n        uint256 lpCompensationAmount\n    ) internal {\n        TickIteratorUp memory ticks = TickIteratorLib.initUp(\n            UNI_V4, id, tickSpacing, slot0BeforeSwap.tick(), slot0AfterSwap.tick()\n        );\n\n        uint128 liquidity = liquidityBeforeSwap.get().toUint128();\n        (int24 lastTick, uint160 pstarSqrtX96) = CompensationPriceFinder.getOneForZero(\n            ticks, liquidity, lpCompensationAmount, slot0BeforeSwap, slot0AfterSwap\n        );\n\n        ticks.reset(slot0BeforeSwap.tick());\n        _oneForZeroCreditRewards(\n            ticks,\n            liquidity,\n            lpCompensationAmount,\n            slot0BeforeSwap.sqrtPriceX96(),\n            lastTick,\n            pstarSqrtX96\n        );\n    }\n\n    function _zeroForOneCreditRewards(\n        TickIteratorDown memory ticks,\n        uint128 liquidity,\n        uint256 lpCompensationAmount,\n        uint160 priceUpperSqrtX96,\n        int24 lastTick,\n        uint160 pstarSqrtX96\n    ) internal {\n        uint256 pstarX96 = uint256(pstarSqrtX96).mulX96(pstarSqrtX96);\n        uint256 cumulativeGrowthX128 = 0;\n        uint160 priceLowerSqrtX96;\n\n        while (ticks.hasNext()) {\n            int24 tickNext = ticks.getNext();\n\n            priceLowerSqrtX96 = max(TickMath.getSqrtPriceAtTick(tickNext), pstarSqrtX96);\n\n            uint256 rangeReward = 0;\n            if (tickNext >= lastTick && liquidity != 0) {\n                uint256 delta0 = SqrtPriceMath.getAmount0Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                uint256 delta1 = SqrtPriceMath.getAmount1Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                rangeReward = (delta1.divX96(pstarX96) - delta0).min(lpCompensationAmount);\n\n                unchecked {\n                    lpCompensationAmount -= rangeReward;\n                    cumulativeGrowthX128 += PoolRewardsLib.getGrowthDelta(rangeReward, liquidity);\n                }\n            }\n\n            unchecked {\n                rewards[ticks.poolId].rewardGrowthOutsideX128[tickNext] += cumulativeGrowthX128;\n            }\n\n            (, int128 liquidityNet) = ticks.manager.getTickLiquidity(ticks.poolId, tickNext);\n            liquidity = liquidity.sub(liquidityNet);\n\n            priceUpperSqrtX96 = priceLowerSqrtX96;\n        }\n\n        // Distribute remainder to last range and update global accumulator.\n        unchecked {\n            cumulativeGrowthX128 += PoolRewardsLib.getGrowthDelta(lpCompensationAmount, liquidity);\n            rewards[ticks.poolId].globalGrowthX128 += cumulativeGrowthX128;\n        }\n    }\n\n    function _oneForZeroCreditRewards(\n        TickIteratorUp memory ticks,\n        uint128 liquidity,\n        uint256 lpCompensationAmount,\n        uint160 priceLowerSqrtX96,\n        int24 lastTick,\n        uint160 pstarSqrtX96\n    ) internal {\n        uint256 pstarX96 = uint256(pstarSqrtX96).mulX96(pstarSqrtX96);\n        uint256 cumulativeGrowthX128 = 0;\n        uint160 priceUpperSqrtX96;\n\n        while (ticks.hasNext()) {\n            int24 tickNext = ticks.getNext();\n\n            priceUpperSqrtX96 = min(TickMath.getSqrtPriceAtTick(tickNext), pstarSqrtX96);\n\n            uint256 rangeReward = 0;\n            if (tickNext <= lastTick || liquidity == 0) {\n                uint256 delta0 = SqrtPriceMath.getAmount0Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                uint256 delta1 = SqrtPriceMath.getAmount1Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                rangeReward = (delta0 - delta1.divX96(pstarX96)).min(lpCompensationAmount);\n\n                unchecked {\n                    lpCompensationAmount -= rangeReward;\n                    cumulativeGrowthX128 += PoolRewardsLib.getGrowthDelta(rangeReward, liquidity);\n                }\n            }\n\n            unchecked {\n                rewards[ticks.poolId].rewardGrowthOutsideX128[tickNext] += cumulativeGrowthX128;\n            }\n\n            (, int128 liquidityNet) = ticks.manager.getTickLiquidity(ticks.poolId, tickNext);\n            liquidity = liquidity.add(liquidityNet);\n\n            priceLowerSqrtX96 = priceUpperSqrtX96;\n        }\n\n        // Distribute remainder to last range and update global accumulator.\n        unchecked {\n            cumulativeGrowthX128 += PoolRewardsLib.getGrowthDelta(lpCompensationAmount, liquidity);\n            rewards[ticks.poolId].globalGrowthX128 += cumulativeGrowthX128;\n        }\n    }\n\n    function min(uint160 x, uint160 y) internal pure returns (uint160) {\n        return x < y ? x : y;\n    }\n\n    function max(uint160 x, uint160 y) internal pure returns (uint160) {\n        return x > y ? x : y;\n    }\n\n    function _getBlock() internal view returns (uint96) {\n        if (address(flashBlockNumberProvider) == address(0)) {\n            return uint96(block.number);\n        }\n        return uint96(flashBlockNumberProvider.getFlashblockNumber());\n    }\n\n    function _getSwapTaxAmount() internal view returns (uint256) {\n        uint256 priorityFee = tx.gasprice - block.basefee;\n        return getSwapTaxAmount(priorityFee);\n    }\n\n    function _getJitTaxAmount() internal view returns (uint256) {\n        if (_getBlock() == _blockOfLastTopOfBlock) {\n            return 0;\n        }\n        uint256 priorityFee = tx.gasprice - block.basefee;\n        return getJitTaxAmount(priorityFee);\n    }\n\n    function _checkCallerIsFactory() internal view {\n        if (msg.sender != FACTORY) revert Unauthorized();\n    }\n}\n",
        "CompensationPriceFinder.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IUniV4, IPoolManager} from \"../interfaces/IUniV4.sol\";\nimport {Slot0} from \"v4-core/src/types/Slot0.sol\";\nimport {TickMath} from \"v4-core/src/libraries/TickMath.sol\";\nimport {SqrtPriceMath} from \"v4-core/src/libraries/SqrtPriceMath.sol\";\nimport {MixedSignLib} from \"../libraries/MixedSignLib.sol\";\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\nimport {TickIteratorUp, TickIteratorDown} from \"./TickIterator.sol\";\nimport {Math512Lib} from \"./Math512Lib.sol\";\nimport {SafeCastLib} from \"solady/src/utils/SafeCastLib.sol\";\nimport {Q96MathLib} from \"./Q96MathLib.sol\";\n\n/// @author philogy <https://github.com/philogy>\nlibrary CompensationPriceFinder {\n    using IUniV4 for IPoolManager;\n    using MixedSignLib for *;\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n    using Q96MathLib for uint256;\n\n    function getZeroForOne(\n        TickIteratorDown memory ticks,\n        uint128 liquidity,\n        uint256 taxInEther,\n        uint160 priceUpperSqrtX96,\n        Slot0 slot0AfterSwap\n    ) internal view returns (int24 lastTick, uint160 pstarSqrtX96) {\n        uint256 sumAmount0Deltas = 0; // X\n        uint256 sumAmount1Deltas = 0; // Y\n\n        uint160 priceLowerSqrtX96;\n        while (ticks.hasNext()) {\n            lastTick = ticks.getNext();\n            priceLowerSqrtX96 = TickMath.getSqrtPriceAtTick(lastTick);\n\n            {\n                uint256 delta0 = SqrtPriceMath.getAmount0Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                uint256 delta1 = SqrtPriceMath.getAmount1Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                sumAmount0Deltas += delta0;\n                sumAmount1Deltas += delta1;\n\n                if (sumAmount0Deltas > taxInEther) {\n                    if (\n                        sumAmount1Deltas.divX96(sumAmount0Deltas + taxInEther)\n                            >= uint256(priceLowerSqrtX96).mulX96(priceLowerSqrtX96)\n                    ) {\n                        pstarSqrtX96 = _zeroForOneGetFinalCompensationPrice(\n                            priceUpperSqrtX96,\n                            taxInEther,\n                            liquidity,\n                            sumAmount0Deltas - delta0,\n                            sumAmount1Deltas - delta1\n                        );\n\n                        return (lastTick, pstarSqrtX96);\n                    }\n                }\n            }\n\n            (, int128 liquidityNet) = ticks.manager.getTickLiquidity(ticks.poolId, lastTick);\n            liquidity = liquidity.sub(liquidityNet);\n\n            priceUpperSqrtX96 = priceLowerSqrtX96;\n        }\n\n        priceLowerSqrtX96 = slot0AfterSwap.sqrtPriceX96();\n\n        uint256 delta0 =\n            SqrtPriceMath.getAmount0Delta(priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false);\n        uint256 delta1 =\n            SqrtPriceMath.getAmount1Delta(priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false);\n        sumAmount0Deltas += delta0;\n        sumAmount1Deltas += delta1;\n\n        uint256 simplePstarX96 = sumAmount1Deltas.divX96(sumAmount0Deltas + taxInEther);\n        if (simplePstarX96 > uint256(priceLowerSqrtX96).mulX96(priceLowerSqrtX96)) {\n            pstarSqrtX96 = _zeroForOneGetFinalCompensationPrice(\n                priceUpperSqrtX96,\n                taxInEther,\n                liquidity,\n                sumAmount0Deltas - delta0,\n                sumAmount1Deltas - delta1\n            );\n\n            return (type(int24).min, pstarSqrtX96);\n        }\n\n        (uint256 p1, uint256 p0) = Math512Lib.checkedMul2Pow96(0, simplePstarX96);\n\n        return (type(int24).min, Math512Lib.sqrt512(p1, p0).toUint160());\n    }\n\n    /// @dev Computes the effective execution price `p*` such that we can compensate as many\n    /// liquidity ranges for the difference between their actual execution price and `p*`.\n    function getOneForZero(\n        TickIteratorUp memory ticks,\n        uint128 liquidity,\n        uint256 taxInEther,\n        Slot0 slot0BeforeSwap,\n        Slot0 slot0AfterSwap\n    ) internal view returns (int24 lastTick, uint160 pstarSqrtX96) {\n        uint256 sumAmount0Deltas = 0; // X\n        uint256 sumAmount1Deltas = 0; // Y\n\n        uint160 priceLowerSqrtX96 = slot0BeforeSwap.sqrtPriceX96();\n        uint160 priceUpperSqrtX96;\n        while (ticks.hasNext()) {\n            lastTick = ticks.getNext();\n            priceUpperSqrtX96 = TickMath.getSqrtPriceAtTick(lastTick);\n\n            {\n                uint256 delta0 = SqrtPriceMath.getAmount0Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                uint256 delta1 = SqrtPriceMath.getAmount1Delta(\n                    priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false\n                );\n                sumAmount0Deltas += delta0;\n                sumAmount1Deltas += delta1;\n\n                if (sumAmount0Deltas > taxInEther) {\n                    uint256 simplePstarX96 = sumAmount1Deltas.divX96(sumAmount0Deltas - taxInEther);\n                    if (simplePstarX96 <= uint256(priceUpperSqrtX96).mulX96(priceUpperSqrtX96)) {\n                        pstarSqrtX96 = _oneForZeroGetFinalCompensationPrice(\n                            liquidity,\n                            priceLowerSqrtX96,\n                            taxInEther,\n                            sumAmount0Deltas - delta0,\n                            sumAmount1Deltas - delta1\n                        );\n\n                        return (lastTick, pstarSqrtX96);\n                    }\n                }\n            }\n\n            (, int128 liquidityNet) = ticks.manager.getTickLiquidity(ticks.poolId, lastTick);\n            liquidity = liquidity.add(liquidityNet);\n\n            priceLowerSqrtX96 = priceUpperSqrtX96;\n        }\n\n        priceUpperSqrtX96 = slot0AfterSwap.sqrtPriceX96();\n\n        uint256 delta0 =\n            SqrtPriceMath.getAmount0Delta(priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false);\n        uint256 delta1 =\n            SqrtPriceMath.getAmount1Delta(priceLowerSqrtX96, priceUpperSqrtX96, liquidity, false);\n        sumAmount0Deltas += delta0;\n        sumAmount1Deltas += delta1;\n\n        uint256 simplePstarX96 = sumAmount1Deltas.divX96(sumAmount0Deltas - taxInEther);\n        if (simplePstarX96 <= uint256(priceUpperSqrtX96).mulX96(priceUpperSqrtX96)) {\n            pstarSqrtX96 = _oneForZeroGetFinalCompensationPrice(\n                liquidity,\n                priceLowerSqrtX96,\n                taxInEther,\n                sumAmount0Deltas - delta0,\n                sumAmount1Deltas - delta1\n            );\n\n            return (type(int24).max, pstarSqrtX96);\n        }\n\n        (uint256 p1, uint256 p0) = Math512Lib.checkedMul2Pow96(0, simplePstarX96);\n\n        return (type(int24).max, Math512Lib.sqrt512(p1, p0).toUint160());\n    }\n\n    function _zeroForOneGetFinalCompensationPrice(\n        uint160 priceUpperSqrtX96,\n        uint256 compensationAmount0,\n        uint128 liquidity,\n        uint256 sumUpToThisRange0,\n        uint256 sumUpToThisRange1\n    ) internal pure returns (uint160 pstarSqrtX96) {\n        uint256 rangeVirtualReserves0 = uint256(liquidity).divX96(priceUpperSqrtX96);\n        uint256 rangeVirtualReserves1 = uint256(liquidity).mulX96(priceUpperSqrtX96);\n        // sumX: `Xhat + B`\n        uint256 sumX = sumUpToThisRange0 + compensationAmount0;\n        (uint256 d1, uint256 d0) = Math512Lib.fullMul(rangeVirtualReserves1, sumX);\n        if (sumX >= rangeVirtualReserves0) {\n            // `A` is positive, compute `D = y * (Xhat + B) + A * Yhat`, `p* = (-L + sqrt(D)) / A`.\n            uint256 a = sumX - rangeVirtualReserves0;\n            {\n                (uint256 ay1, uint256 ay0) = Math512Lib.fullMul(a, sumUpToThisRange1);\n                (d1, d0) = Math512Lib.checkedAdd(d1, d0, ay1, ay0);\n            }\n            // Compute `sqrtDX96 := sqrt(D) * 2^96 <> sqrt(D * 2^192)`\n            (d1, d0) = Math512Lib.checkedMul2Pow192(d1, d0);\n            // Reuse `d1, d0` to store numerator `-L + sqrt(D)`.\n            (d1, d0) =\n                Math512Lib.checkedSub(0, Math512Lib.sqrt512(d1, d0), 0, uint256(liquidity) << 96);\n            (uint256 upperBits, uint256 p1) = Math512Lib.div512by256(d1, d0, a);\n            assert(upperBits == 0);\n\n            return p1.toUint160();\n        } else {\n            // `A` is negative, compute `D = y * (Xhat + B) - (-A) * Yhat`, `p* = (L - sqrt(D)) / -A`.\n            uint256 negA = rangeVirtualReserves0 - sumX;\n            {\n                (uint256 ay1, uint256 ay0) = Math512Lib.fullMul(negA, sumUpToThisRange1);\n                (d1, d0) = Math512Lib.checkedSub(d1, d0, ay1, ay0);\n            }\n            // Compute `sqrtDX96 := sqrt(D) * 2^96 <> sqrt(D * 2^192)`\n            (d1, d0) = Math512Lib.checkedMul2Pow192(d1, d0);\n            // Reuse `d1, d0` to store numerator `L - sqrt(D)`.\n            (d1, d0) =\n                Math512Lib.checkedSub(0, uint256(liquidity) << 96, 0, Math512Lib.sqrt512(d1, d0));\n            (uint256 upperBits, uint256 p1) = Math512Lib.div512by256(d1, d0, negA);\n            assert(upperBits == 0);\n\n            return p1.toUint160();\n        }\n    }\n\n    function _oneForZeroGetFinalCompensationPrice(\n        uint128 liquidity,\n        uint160 priceLowerSqrtX96,\n        uint256 compensationAmount0,\n        uint256 sumUpToThisRange0,\n        uint256 sumUpToThisRange1\n    ) internal pure returns (uint160 pstarSqrtX96) {\n        uint256 rangeVirtualReserves0 = uint256(liquidity).divX96(priceLowerSqrtX96);\n        uint256 rangeVirtualReserves1 = uint256(liquidity).mulX96(priceLowerSqrtX96);\n        // `A = Xhat + x - B`\n        uint256 a = sumUpToThisRange0 + rangeVirtualReserves0 - compensationAmount0;\n        // Compute determinant.\n        uint256 d1;\n        uint256 d0;\n        {\n            (uint256 x1, uint256 x0) = Math512Lib.fullMul(sumUpToThisRange1, a);\n            if (sumUpToThisRange0 >= compensationAmount0) {\n                // if `Xhat >= B` then compute `D = Yhat * A - y * (Xhat - B)`\n                (d1, d0) = Math512Lib.fullMul(\n                    rangeVirtualReserves1, sumUpToThisRange0 - compensationAmount0\n                );\n                (d1, d0) = Math512Lib.checkedSub(x1, x0, d1, d0);\n            } else {\n                // if `Xhat < B` then compute `D = Yhat * A + y * (B - Xhat)`\n                (d1, d0) = Math512Lib.fullMul(\n                    rangeVirtualReserves1, compensationAmount0 - sumUpToThisRange0\n                );\n                (d1, d0) = Math512Lib.checkedAdd(x1, x0, d1, d0);\n            }\n        }\n        // Compute `sqrtDX96 := sqrt(D) * 2^96 <> sqrt(D * 2^192)`\n        (d1, d0) = Math512Lib.checkedMul2Pow192(d1, d0);\n        uint256 sqrtDX96 = Math512Lib.sqrt512(d1, d0);\n\n        uint256 liquidityX96 = uint256(liquidity) << 96;\n        // Reuse `d1, d0` to store numerator `L + sqrt(D)`.\n        (d1, d0) = Math512Lib.checkedAdd(0, liquidityX96, 0, sqrtDX96);\n        (uint256 upperBits, uint256 p1) = Math512Lib.div512by256(d1, d0, a);\n        assert(upperBits == 0);\n\n        return p1.toUint160();\n    }\n}\n"
    }
}