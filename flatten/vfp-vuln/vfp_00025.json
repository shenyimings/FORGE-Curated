{
    "vfp_id": "vfp_00025",
    "project_name": "cantina_kpk_oct2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Asset removal during pending subscriptions inflates supply via zero-decimals recomputation",
            "description": "This vulnerability arises when an asset is removed between the creation and approval of a subscription request. The approval process recomputes the number of shares (sharesOut) using the current global asset configuration, which, after asset removal, returns zero decimals. This causes an incorrect scaling that inflates the computed sharesOut, allowing an oversized sharesAmount to pass the price guard. The contract then mints the originally requested (inflated) sharesAmount despite the incorrect valuation. The root cause is the reliance on mutable asset configuration data at the time of approval, which differs from the state at request creation. An attacker could exploit this by requesting a large number of shares with a valid asset, then having the operator remove the asset before approval, leading to the minting of significantly more shares than should be allowed. This results in share supply inflation and devaluation, potentially enabling theft of value from other holders.\n",
            "severity": "High",
            "location": [
                "kpkShares.sol::kpkShares.sol#L493-L509",
                "kpkShares.sol::kpkShares.sol#L684-L694",
                "kpkShares.sol::kpkShares.sol#L852-L861"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Subscription approval mints sharesAmount instead of computed sharesOut and event",
            "description": "During subscription approval, the contract mints the user-requested sharesAmount rather than the price-derived sharesOut computed at approval time. This decouples the minted amount from the current asset price, allowing users to potentially receive more shares than justified by the current rate if the price has moved favorably since request creation. The root cause is the use of stale user input (sharesAmount) instead of the dynamically computed value (sharesOut). An attacker could exploit this by submitting a subscription with a high minOut during a price dip and waiting for approval when the price has recovered, thereby receiving more shares than fair value. The impact includes economic loss to the fund and dilution of existing shareholders. Additionally, the emitted event reflects the requested value, not the computed one, leading to inaccurate off-chain tracking.\n",
            "severity": "High",
            "location": [
                "kpkShares.sol::kpkShares.sol#L684-L694"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Mistakes in sharesPriceInAsset have big consequences",
            "description": "The sharesPriceInAsset parameter in processRequests() directly influences share minting and redemption calculations. If set incorrectly by the operator, it can lead to catastrophic economic consequences, such as massive over-minting or under-minting of shares, effectively breaking the protocol's valuation model. The root cause is the lack of safeguards around price input, relying solely on operator discretion without validation or multi-signature oversight. An attacker with access to the pricing role, or a mistaken operator, could set an incorrect price, leading to severe financial loss for investors and loss of trust in the protocol. This could prevent institutional adoption due to the high risk of operational error.\n",
            "severity": "Medium",
            "location": [
                "kpkShares.sol::kpkShares.sol#L382-L391"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "assetsToShares() doesn't check the asset exists",
            "description": "The assetsToShares() function does not validate whether the provided asset is an approved asset before using its configuration. This allows calculations to proceed with non-existent or unapproved assets, which return zero decimals and other default values, leading to incorrect share calculations. The root cause is the missing validation check for asset existence. This issue contributes to the \"Asset removal during pending subscriptions\" vulnerability and could allow operators to accidentally enable deposits of unsupported or worthless assets. An attacker could exploit this in conjunction with asset removal to inflate shares or manipulate pricing. The impact includes potential loss of funds and incorrect accounting.\n",
            "severity": "Medium",
            "location": [
                "kpkShares.sol::kpkShares.sol#L493-L502",
                "kpkShares.sol::kpkShares.sol#L512-L521"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Performance fee gated by USD assets enables fee avoidance via asset choice and ordering",
            "description": "Performance fees are only charged when processing batches for assets flagged as isUsd, creating exploitable gaming vectors. Users can avoid fees entirely by redeeming in non-USD assets, and operators can manipulate processing order (e.g., non-USD first, then USD shortly after) to skip fee accrual due to time-based thresholds. The root cause is the coupling of fee accrual logic to the specific asset being processed, rather than a global or per-asset time tracking mechanism. This allows systematic under-collection of performance fees based on operational choices rather than economic fairness. The impact is reduced revenue for the fund and unfair advantage to users who exploit the timing and asset selection, undermining the fee model.\n",
            "severity": "Medium",
            "location": [
                "kpkShares.sol::kpkShares.sol#L784-L803",
                "kpkShares.sol::kpkShares.sol#L793-L795"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Asset removal bricks pending requests and enables sweeping escrowed funds",
            "description": "Removing an asset while subscription or redemption requests are pending deletes its configuration, which breaks the processing of those requests. For redemptions, approval fails because canRedeem is now false. For subscriptions, escrowed funds can be swept by recovery functions since the asset config is gone, leaving users unable to cancel or approve. The root cause is the immediate deletion of asset config without a deprecation period. This bricks user exits for redemptions and allows unintended sweeping of escrowed funds. The impact includes denial of service for users with pending requests and potential loss of access to funds until TTL expires, reducing user trust and fund reliability.\n",
            "severity": "Medium",
            "location": [
                "kpkShares.sol::kpkShares.sol#L554-L557",
                "kpkShares.sol::kpkShares.sol#L852-L862"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Allowing the share token as an approved asset enables circular accounting",
            "description": "The updateAsset function does not prevent the share token itself (address(this)) from being added as an approved asset. This creates a circular accounting risk where escrowed shares during redemption could be misinterpreted as underlying assets, leading to artificial inflation or fund draining. The root cause is the missing validation to block self-referential asset registration. An attacker could exploit this by registering the share token as an asset and manipulating accounting functions that rely on asset balances, potentially allowing unauthorized minting or sweeping of shares. The impact includes potential total loss of funds and complete compromise of the share price mechanism.\n",
            "severity": "Medium",
            "location": [
                "kpkShares.sol::kpkShares.sol#L554-L562",
                "kpkShares.sol::kpkShares.sol#L852-L854"
            ],
            "files": [
                "3e4e054b/onchain-investment-vehicles/src/kpkShares.sol"
            ]
        }
    ],
    "affected_files": {
        "kpkShares.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport {\n    IERC20,\n    ERC20Upgradeable,\n    IERC20Metadata\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IPerfFeeModule} from \"./FeeModules/IPerfFeeModule.sol\";\nimport {IkpkShares} from \"./IkpkShares.sol\";\nimport {RecoverFunds} from \"./utils/RecoverFunds.sol\";\n\n/// @title KpkShares - Onchain Investment Vehicles Implementation\n/// @author kpk\n/// @notice Onchain Investment Vehicles shares with subscription/redemption requests and fee management\ncontract KpkShares is\n    Initializable,\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    ERC20Upgradeable,\n    IkpkShares,\n    RecoverFunds\n{\n    //\n    // Libraries\n    //\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    //\n    // Constants\n    //\n    /// @notice Precision constant for WAD (18 decimals)\n    uint256 private constant _PRECISION_WAD = 1e18;\n\n    /// @notice Normalized precision for USD calculations (8 decimals)\n    uint256 private constant _NORMALIZED_PRECISION_USD = 1e8;\n\n    uint256 private constant _PRECISION_BPS = 10_000;\n\n    /// @notice Maximum time-to-live for requests (7 days)\n    uint64 public constant MAX_TTL = 7 days;\n\n    /// @notice Maximum fee rate allowed (2000 = 20%)\n    uint256 public constant MAX_FEE_RATE = 2000;\n\n    /// @notice Number of seconds in a year (365 days)\n    uint256 public constant SECONDS_PER_YEAR = 365 days;\n\n    /// @notice Minimum time elapsed required for fee calculations (6 hours)\n    uint256 public constant MIN_TIME_ELAPSED = 6 hours;\n\n    /// @notice Maximum price deviation allowed (3000 = 30%)\n    uint256 public constant MAX_PRICE_DEVIATION_BPS = 3000;\n\n    /// @notice Role identifier for operators\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n\n    //\n    // State Variables\n    //\n\n    /// @notice List of added assets\n    address[] private _approvedAssets;\n\n    /// @notice Asset configurations mapped by asset address\n    mapping(address => ApprovedAsset) private _approvedAssetsMap;\n\n    /// @notice Unique identifier for requests\n    uint256 public requestId;\n\n    /// @notice Portfolio safe address where assets are transferred for fund operations\n    address public portfolioSafe;\n\n    /// @notice Performance fee module address\n    address public performanceFeeModule;\n\n    /// @notice Total assets pending in subscription requests\n    mapping(address => uint256) public subscriptionAssets;\n\n    /// @notice Counter of pending requests (subscriptions + redemptions) per asset\n    mapping(address => uint256) private _pendingRequestsCount;\n\n    /// @notice Time-to-live for subscription requests before they can be cancelled\n    uint64 public subscriptionRequestTtl;\n\n    /// @notice Time-to-live for redemption requests before they can be cancelled\n    uint64 public redemptionRequestTtl;\n\n    /// @notice Address that receives redemption fees\n    address public feeReceiver;\n\n    /// @notice Management fee rate (in basis points, 2000 = 20%)\n    uint256 public managementFeeRate;\n\n    /// @notice Redemption fee rate (in basis points, 2000 = 20%)\n    uint256 public redemptionFeeRate;\n\n    /// @notice Performance fee rate (in basis points, 2000 = 20%)\n    uint256 public performanceFeeRate;\n\n    /// @notice Management fee last update timestamp\n    uint256 private _managementFeeLastUpdate;\n\n    /// @notice Performance fee last update timestamp\n    uint256 private _performanceFeeLastUpdate;\n\n    /// @notice Last settled price per asset (in normalized USD units, 8 decimals)\n    mapping(address => uint256) private _lastSettledPrice;\n\n    //\n    // Storage Mappings\n    //\n\n    /// @notice Requests indexed by request ID\n    mapping(uint256 requestId => UserRequest request) private _requests;\n\n    //\n    // Constructor\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //\n    // Initialization\n    //\n\n    /// @notice Parameters for fund initialization\n    /// @param asset The address of the underlying asset (MUST be configured with isFeeModuleAsset=true to initialize performance fee calculations)\n    /// @param admin The address of the initial default admin\n    /// @param name The name of the shares\n    /// @param symbol The symbol of the shares\n    /// @param safe The address of the main safe\n    /// @param subscriptionRequestTtl The time-to-live for subscription requests\n    /// @param redemptionRequestTtl The time-to-live for redemption requests\n    /// @param feeReceiver The address that receives redemption fees\n    /// @param managementFeeRate The management fee rate (in basis points, 2000 = 20%)\n    /// @param redemptionFeeRate The redemption fee rate (in basis points, 2000 = 20%)\n    /// @param performanceFeeModule The performance fee module address\n    /// @param performanceFeeRate The performance fee rate (in basis points, 2000 = 20%)\n    struct ConstructorParams {\n        address asset;\n        address admin;\n        string name;\n        string symbol;\n        address safe;\n        uint64 subscriptionRequestTtl;\n        uint64 redemptionRequestTtl;\n        address feeReceiver;\n        uint256 managementFeeRate;\n        uint256 redemptionFeeRate;\n        address performanceFeeModule;\n        uint256 performanceFeeRate;\n    }\n\n    /// @notice Initialize the contract with fund parameters\n    /// @param params Initialization parameters\n    function initialize(ConstructorParams memory params) external initializer {\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n        __ERC20_init(params.name, params.symbol);\n        __Context_init();\n        __ERC165_init();\n        _validateInitializationParams(params);\n        _initializeState(params);\n        _setupRoles(params.admin);\n    }\n\n    //\n    // Authorization Functions\n    //\n\n    /// @notice Modifier to check if the caller is an admin\n    modifier isAdmin() {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) revert NotAuthorized();\n        _;\n    }\n\n    /// @notice Modifier to check if the caller is an operator\n    modifier isOperator() {\n        if (!hasRole(OPERATOR, msg.sender)) revert NotAuthorized();\n        _;\n    }\n\n    //\n    // Subscription Operations\n    //\n\n    /// @inheritdoc IkpkShares\n    function previewSubscription(uint256 assets, uint256 sharesPrice, address subscriptionAsset)\n        external\n        view\n        returns (uint256 shares)\n    {\n        // If sharesPrice is 0, use the last settled price\n        if (sharesPrice == 0) {\n            uint256 lastPrice = _lastSettledPrice[subscriptionAsset];\n            if (lastPrice == 0) {\n                revert NoStoredPrice();\n            }\n            sharesPrice = lastPrice;\n        }\n        // sharesToShares() checks canDeposit of subscriptionAsset\n        return assetsToShares(assets, sharesPrice, subscriptionAsset);\n    }\n\n    /// @inheritdoc IkpkShares\n    function requestSubscription(uint256 assetsIn, uint256 minSharesOut, address subscriptionAsset, address receiver)\n        external\n        returns (uint256)\n    {\n        _requireValidRequestParams(assetsIn, minSharesOut, receiver);\n\n        // Check if the asset is approved for subscriptions\n        ApprovedAsset memory assetConfig = _approvedAssetsMap[subscriptionAsset];\n        if (!assetConfig.canDeposit) revert NotAnApprovedAsset();\n\n        // Transfer assets from investor first (before updating state)\n        IERC20(subscriptionAsset).safeTransferFrom(msg.sender, address(this), assetsIn);\n\n        // Update state and create request\n        subscriptionAssets[subscriptionAsset] += assetsIn;\n        _pendingRequestsCount[subscriptionAsset]++;\n        uint256 currentRequestId = ++requestId;\n\n        // Calculate expiry and cancelableFrom timestamps\n        uint64 currentTimestamp = uint64(block.timestamp);\n        uint64 expiryAt = currentTimestamp + MAX_TTL;\n        uint64 cancelableFrom = currentTimestamp + subscriptionRequestTtl;\n\n        // Create the actual request with the correct requestId\n        _requests[currentRequestId] = UserRequest({\n            requestType: RequestType.SUBSCRIPTION,\n            requestStatus: RequestStatus.PENDING,\n            asset: subscriptionAsset,\n            assetAmount: assetsIn,\n            sharesAmount: minSharesOut,\n            investor: msg.sender,\n            receiver: receiver,\n            timestamp: currentTimestamp,\n            expiryAt: expiryAt\n        });\n\n        emit SubscriptionRequest(\n            msg.sender,\n            currentRequestId,\n            receiver,\n            subscriptionAsset,\n            assetsIn,\n            minSharesOut,\n            currentTimestamp,\n            cancelableFrom,\n            expiryAt\n        );\n\n        return currentRequestId;\n    }\n\n    /// @inheritdoc IkpkShares\n    function cancelSubscription(uint256 id) external {\n        UserRequest memory request = _requests[id];\n\n        if (!_checkValidRequest(request.investor, request.requestStatus)) {\n            revert RequestNotPending();\n        }\n        if (request.requestType != RequestType.SUBSCRIPTION) {\n            revert RequestTypeMismatch();\n        }\n\n        // Check TTL - can only cancel after TTL has expired\n        if (block.timestamp < request.timestamp + subscriptionRequestTtl) {\n            revert RequestNotPastTtl();\n        }\n\n        _requireCancellationAuthorization(request.investor, request.receiver);\n\n        uint256 totalAssets = request.assetAmount;\n        subscriptionAssets[request.asset] -= totalAssets;\n        _pendingRequestsCount[request.asset]--;\n\n        // Update status to CANCELLED instead of deleting\n        _requests[id].requestStatus = RequestStatus.CANCELLED;\n\n        IERC20(request.asset).safeTransfer(request.investor, totalAssets);\n\n        emit SubscriptionCancellation(id, msg.sender);\n    }\n\n    //\n    // Redemption Operations\n    //\n\n    /// @inheritdoc IkpkShares\n    function previewRedemption(uint256 shares, uint256 sharesPrice, address redemptionAsset)\n        external\n        view\n        returns (uint256 assets)\n    {\n        // If sharesPrice is 0, use the last settled price\n        if (sharesPrice == 0) {\n            uint256 lastPrice = _lastSettledPrice[redemptionAsset];\n            if (lastPrice == 0) {\n                revert NoStoredPrice();\n            }\n            sharesPrice = lastPrice;\n        }\n\n        // Calculate redemption fee if applicable\n        uint256 redemptionFee = 0;\n        if (redemptionFeeRate > 0) {\n            redemptionFee = (shares * redemptionFeeRate) / _PRECISION_BPS;\n        }\n\n        // Calculate net shares after fee deduction\n        uint256 netShares = shares - redemptionFee;\n\n        // Calculate net assets that will be received (after fees)\n        // sharesToAssets() checks canRedeem of redemptionAsset\n        return sharesToAssets(netShares, sharesPrice, redemptionAsset);\n    }\n\n    /// @inheritdoc IkpkShares\n    function requestRedemption(uint256 sharesIn, uint256 minAssetsOut, address redemptionAsset, address receiver)\n        external\n        returns (uint256)\n    {\n        _requireValidRequestParams(sharesIn, minAssetsOut, receiver);\n\n        // Check if the asset is approved for redemptions\n        if (!_approvedAssetsMap[redemptionAsset].canRedeem) revert NotAnApprovedAsset();\n\n        // Transfer shares to contract as escrow\n        _transfer(msg.sender, address(this), sharesIn);\n\n        uint256 currentRequestId = ++requestId;\n\n        // Calculate expiry and cancelableFrom timestamps\n        uint64 currentTimestamp = uint64(block.timestamp);\n        uint64 expiryAt = currentTimestamp + MAX_TTL;\n        uint64 cancelableFrom = currentTimestamp + redemptionRequestTtl;\n\n        // Create the actual request with the correct requestId\n        UserRequest memory request = UserRequest({\n            requestType: RequestType.REDEMPTION,\n            requestStatus: RequestStatus.PENDING,\n            asset: redemptionAsset,\n            assetAmount: minAssetsOut,\n            sharesAmount: sharesIn,\n            investor: msg.sender,\n            receiver: receiver,\n            timestamp: currentTimestamp,\n            expiryAt: expiryAt\n        });\n\n        _requests[currentRequestId] = request;\n        _pendingRequestsCount[redemptionAsset]++;\n\n        emit RedemptionRequest(\n            msg.sender,\n            currentRequestId,\n            receiver,\n            redemptionAsset,\n            minAssetsOut,\n            sharesIn,\n            currentTimestamp,\n            cancelableFrom,\n            expiryAt\n        );\n\n        return currentRequestId;\n    }\n\n    /// @inheritdoc IkpkShares\n    function cancelRedemption(uint256 id) external {\n        UserRequest memory request = _requests[id];\n\n        if (!_checkValidRequest(request.investor, request.requestStatus)) {\n            revert RequestNotPending();\n        }\n        if (request.requestType != RequestType.REDEMPTION) {\n            revert RequestTypeMismatch();\n        }\n        // Check TTL - can only cancel after TTL has expired\n        if (block.timestamp < request.timestamp + redemptionRequestTtl) {\n            revert RequestNotPastTtl();\n        }\n\n        _requireCancellationAuthorization(request.investor, request.receiver);\n\n        // Update status to CANCELLED instead of deleting\n        _requests[id].requestStatus = RequestStatus.CANCELLED;\n        _pendingRequestsCount[request.asset]--;\n\n        // Return shares from escrow to investor\n        _transfer(address(this), request.investor, request.sharesAmount);\n\n        emit RedemptionCancellation(id, msg.sender);\n    }\n\n    //\n    // Operator Functions\n    //\n\n    /// @inheritdoc IkpkShares\n    function processRequests(\n        uint256[] calldata approveRequests,\n        uint256[] calldata rejectRequests,\n        address asset,\n        uint256 sharesPriceInAsset\n    ) external isOperator {\n        // Validate price deviation from last settled price\n        _validatePriceDeviation(asset, sharesPriceInAsset);\n\n        _chargeFees(asset, sharesPriceInAsset);\n        _processApproved(approveRequests, asset, sharesPriceInAsset);\n        _processRejected(rejectRequests, asset);\n\n        // Update last settled price after successful processing\n        _lastSettledPrice[asset] = sharesPriceInAsset;\n    }\n\n    /// @inheritdoc IkpkShares\n    function updateAsset(address asset, bool isFeeModuleAsset, bool canDeposit, bool canRedeem) external isOperator {\n        _updateAsset(asset, isFeeModuleAsset, canDeposit, canRedeem);\n    }\n\n    //\n    // Admin Functions\n    //\n\n    /// @inheritdoc IkpkShares\n    function setSubscriptionRequestTtl(uint64 ttl) external isAdmin {\n        if (ttl == 0) revert InvalidArguments();\n\n        _setSubscriptionRequestTtl(ttl);\n    }\n\n    /// @inheritdoc IkpkShares\n    function setRedemptionRequestTtl(uint64 ttl) external isAdmin {\n        if (ttl == 0) revert InvalidArguments();\n\n        _setRedemptionRequestTtl(ttl);\n    }\n\n    /// @inheritdoc IkpkShares\n    function setFeeReceiver(address newFeeReceiver) external isAdmin {\n        if (newFeeReceiver == address(0)) revert InvalidArguments();\n        _setFeeReceiver(newFeeReceiver);\n    }\n\n    /// @inheritdoc IkpkShares\n    function setManagementFeeRate(uint256 newRate) external isAdmin {\n        // Allow 0 rate (no fees)\n        if (newRate > MAX_FEE_RATE) revert FeeRateLimitExceeded();\n        if (managementFeeRate != newRate) {\n            _setManagementFeeRate(newRate);\n        }\n    }\n\n    /// @inheritdoc IkpkShares\n    function setRedemptionFeeRate(uint256 newRate) external isAdmin {\n        // Allow 0 rate (no fees)\n        if (newRate > MAX_FEE_RATE) revert FeeRateLimitExceeded();\n\n        if (redemptionFeeRate != newRate) {\n            _setRedemptionFeeRate(newRate);\n        }\n    }\n\n    /// @inheritdoc IkpkShares\n    function setPerformanceFeeRate(uint256 newRate, address usdAsset) external isAdmin {\n        // Allow 0 rate (no fees)\n        if (newRate > MAX_FEE_RATE) revert FeeRateLimitExceeded(); // Max 20%\n\n        if (performanceFeeRate != newRate) {\n            _setPerformanceFeeRate(newRate, usdAsset);\n        }\n    }\n\n    /// @inheritdoc IkpkShares\n    function setPerformanceFeeModule(address newPerfFeeModule) external isAdmin {\n        // Allow address(0) to disable performance fees\n        _setPerformanceFeeModule(newPerfFeeModule);\n    }\n\n    //\n    // View Functions\n    //\n\n    /// @inheritdoc IkpkShares\n    function getApprovedAssets() external view returns (address[] memory) {\n        uint256 length = _approvedAssets.length;\n        address[] memory assets = new address[](length);\n        for (uint256 i = 0; i < length; i++) {\n            assets[i] = _approvedAssets[i];\n        }\n        return assets;\n    }\n\n    /// @inheritdoc IkpkShares\n    function getApprovedAsset(address asset) external view returns (ApprovedAsset memory) {\n        return _approvedAssetsMap[asset];\n    }\n\n    /// @inheritdoc IkpkShares\n    function isApprovedAsset(address asset) external view returns (bool) {\n        ApprovedAsset memory assetConfig = _approvedAssetsMap[asset];\n        return assetConfig.asset != address(0) && (assetConfig.canDeposit || assetConfig.canRedeem);\n    }\n\n    /// @inheritdoc IkpkShares\n    function assetDecimals(address asset) external view returns (uint8) {\n        return _approvedAssetsMap[asset].decimals;\n    }\n\n    /// @inheritdoc IkpkShares\n    function getRequest(uint256 id) external view returns (UserRequest memory) {\n        return _requests[id];\n    }\n\n    /// @inheritdoc IkpkShares\n    function getLastSettledPrice(address asset) external view returns (uint256) {\n        return _lastSettledPrice[asset];\n    }\n\n    /// @inheritdoc IkpkShares\n    function assetsToShares(uint256 assetAmount, uint256 sharesPrice, address subscriptionAsset)\n        public\n        view\n        returns (uint256)\n    {\n        if (sharesPrice == 0 || assetAmount == 0) return 0;\n\n        ApprovedAsset memory assetConfig = _approvedAssetsMap[subscriptionAsset];\n        if (!assetConfig.canDeposit) revert NotAnApprovedAsset();\n\n        uint8 assetDec = assetConfig.decimals;\n\n        // Calculate the value of the assets\n        // assetsValue = assetAmount * (10^shareDecimals * 1e18) / sharesPrice\n        uint256 assetsValue = assetAmount.mulDiv((10 ** decimals()) * _PRECISION_WAD, sharesPrice, Math.Rounding.Floor);\n\n        // Convert value to shares\n        // shares = assetsValue * 1e8 / (10^assetDec * 1e18)\n        return assetsValue.mulDiv(_NORMALIZED_PRECISION_USD, (10 ** assetDec) * _PRECISION_WAD, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IkpkShares\n    function sharesToAssets(uint256 shares, uint256 sharesPrice, address redemptionAsset)\n        public\n        view\n        returns (uint256)\n    {\n        if (sharesPrice == 0 || shares == 0) return 0;\n\n        // Get the asset configuration\n        ApprovedAsset memory assetConfig = _approvedAssetsMap[redemptionAsset];\n        if (!assetConfig.canRedeem) revert UnredeemableAsset();\n\n        uint8 assetDec = assetConfig.decimals;\n\n        // Calculate the value of the shares\n        // sharesValue = shares * (sharesPrice * 1e18) / 1e8\n        // This properly handles different asset decimal places\n        uint256 sharesValue =\n            shares.mulDiv(sharesPrice * _PRECISION_WAD, _NORMALIZED_PRECISION_USD, Math.Rounding.Floor);\n\n        // Convert value to assets\n        // assets = sharesValue * 10^assetDec / (10^shareDecimals * 1e18)\n        return sharesValue.mulDiv((10 ** assetDec), (10 ** decimals()) * _PRECISION_WAD, Math.Rounding.Floor);\n    }\n    //\n    // Overrides\n    //\n\n    /// @inheritdoc UUPSUpgradeable\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(\n        address /* newImpl */\n    )\n        internal\n        view\n        override(UUPSUpgradeable)\n        isAdmin\n    {\n        // Authorization is handled by the isAdmin modifier\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IERC165, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IkpkShares).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc RecoverFunds\n    /// @dev WARNING: This function assumes tokens are not rebasing or fee-on-transfer.\n    function _assetRecoverableAmount(address token) internal view override(RecoverFunds) returns (uint256) {\n        // Hard-block the share token from being recovered\n        if (token == address(this)) {\n            return 0;\n        }\n\n        // Check if there are pending requests for this asset (even if config is deleted)\n        if (_hasPendingRequests(token)) {\n            return 0;\n        }\n\n        // Always exclude recorded escrow, even if asset config is deleted\n        // This prevents sweeping funds needed for pending subscriptions\n        uint256 escrowed = subscriptionAssets[token];\n        if (escrowed > 0) {\n            return 0;\n        }\n\n        return super._assetRecoverableAmount(token);\n    }\n\n    /// @inheritdoc RecoverFunds\n    function _assetRecoverer() internal view override(RecoverFunds) returns (address) {\n        return portfolioSafe;\n    }\n\n    //\n    // Internal Functions\n    //\n\n    //\n    // Initialization\n    //\n\n    /// @notice Validate initialization parameters\n    /// @param params The initialization parameters\n    function _validateInitializationParams(ConstructorParams memory params) internal pure {\n        if (\n            params.asset == address(0) || params.admin == address(0) || params.safe == address(0)\n                || params.feeReceiver == address(0) || params.subscriptionRequestTtl == 0\n                || params.redemptionRequestTtl == 0\n        ) {\n            revert InvalidArguments();\n        }\n\n        // Validate fee rates are within reasonable bounds.\n        if (params.managementFeeRate > MAX_FEE_RATE) revert FeeRateLimitExceeded();\n        if (params.performanceFeeRate > MAX_FEE_RATE) revert FeeRateLimitExceeded();\n        if (params.redemptionFeeRate > MAX_FEE_RATE) revert FeeRateLimitExceeded();\n    }\n\n    /// @notice Initialize contract state variables\n    /// @param params The initialization parameters\n    /// @dev The base asset MUST be configured with isFeeModuleAsset=true to enable performance fee calculations.\n    ///      This asset is used as the base pricing unit for fee module operations.\n    function _initializeState(ConstructorParams memory params) internal {\n        _updateAsset(params.asset, true, true, true);\n        portfolioSafe = params.safe;\n\n        _setFeeReceiver(params.feeReceiver);\n        _setManagementFeeRate(params.managementFeeRate);\n        _setRedemptionFeeRate(params.redemptionFeeRate);\n        _setPerformanceFeeRate(params.performanceFeeRate, params.asset);\n        _setPerformanceFeeModule(params.performanceFeeModule);\n\n        // Set TTLs with overflow protection\n        _setSubscriptionRequestTtl(params.subscriptionRequestTtl);\n        _setRedemptionRequestTtl(params.redemptionRequestTtl);\n\n        // Initialize managementFeeLastUpdate timestamp\n        _managementFeeLastUpdate = block.timestamp;\n        // Initialize performanceFeeLastUpdate timestamp\n\n        _performanceFeeLastUpdate = block.timestamp;\n    }\n\n    /// @notice Setup access control roles\n    /// @param admin The initial admin address\n    function _setupRoles(address admin) internal {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    //\n    // Request Logic\n    //\n\n    /// @notice Require valid request parameters (reverts on invalid)\n    /// @param amountIn The amount (assets or shares) for the request\n    /// @param amountOut The amount (shares or assets) for the request\n    /// @param receiver The receiver address\n    function _requireValidRequestParams(uint256 amountIn, uint256 amountOut, address receiver) internal pure {\n        if (amountIn == 0 || amountOut == 0 || receiver == address(0)) revert InvalidArguments();\n    }\n\n    /// @notice Require cancellation authorization (reverts on invalid)\n    /// @param investor The request investor\n    /// @param receiver The receiver of the assets or shares\n    function _requireCancellationAuthorization(address investor, address receiver) internal view {\n        if (investor != msg.sender && receiver != msg.sender) {\n            revert NotAuthorized();\n        }\n    }\n\n    /// @notice Process approved requests\n    /// @param approveRequests Array of request IDs to approve\n    /// @param asset The asset to approve\n    /// @param sharesPrice The price per share in normalized USD units (8 decimals, i.e., _NORMALIZED_PRECISION_USD)\n    function _processApproved(uint256[] calldata approveRequests, address asset, uint256 sharesPrice) internal {\n        uint256 length = approveRequests.length;\n        for (uint256 i; i < length; i++) {\n            UserRequest memory request = _requests[approveRequests[i]];\n            if (!_checkValidRequest(request.investor, request.requestStatus)) continue;\n\n            if (request.asset != asset) continue;\n\n            // Check if request has expired\n            if (block.timestamp > request.expiryAt) {\n                // Request has expired, process as rejection and emit expiry event\n                if (request.requestType == RequestType.SUBSCRIPTION) {\n                    _rejectSubscriptionRequest(approveRequests[i], request);\n                    emit SubscriptionRequestExpired(approveRequests[i], request.expiryAt);\n                } else {\n                    _rejectRedeemRequest(approveRequests[i], request);\n                    emit RedemptionRequestExpired(approveRequests[i], request.expiryAt);\n                }\n                continue;\n            }\n\n            if (request.requestType == RequestType.SUBSCRIPTION) {\n                _approveSubscriptionRequest(approveRequests[i], request, sharesPrice);\n            } else {\n                _approveRedeemRequest(approveRequests[i], request, sharesPrice);\n            }\n        }\n    }\n\n    /// @notice Process rejected requests\n    /// @param rejectRequests Array of request IDs to reject\n    /// @param asset The asset to reject requests for\n    function _processRejected(uint256[] calldata rejectRequests, address asset) internal {\n        uint256 length = rejectRequests.length;\n        for (uint256 i; i < length; i++) {\n            UserRequest memory request = _requests[rejectRequests[i]];\n            if (!_checkValidRequest(request.investor, request.requestStatus)) continue;\n            if (request.asset != asset) continue;\n\n            if (request.requestType == RequestType.SUBSCRIPTION) {\n                _rejectSubscriptionRequest(rejectRequests[i], request);\n            } else {\n                _rejectRedeemRequest(rejectRequests[i], request);\n            }\n        }\n    }\n\n    //\n    // Subscription Processing\n    //\n\n    /// @notice Approve a subscription request\n    /// @param id The ID of the request to approve\n    /// @param request Subscription approval request\n    /// @param sharesPrice The current price per share in normalized USD units (8 decimals, i.e., _NORMALIZED_PRECISION_USD)\n    function _approveSubscriptionRequest(uint256 id, UserRequest memory request, uint256 sharesPrice) internal {\n        // Compute sharesOut from the approved assetsIn and sharesPriceInAsset at approval\n        uint256 sharesOut = assetsToShares(request.assetAmount, sharesPrice, request.asset);\n        // Enforce sharesOut >= minSharesOut (the user's slippage bound)\n        if (sharesOut < request.sharesAmount) revert RequestPriceLowerThanOperatorPrice();\n\n        // --- Effects ---\n        // Update status to PROCESSED\n        // WARNING: request.requestStatus (memory copy) is now out of sync with storage - do not use it after this line.\n        _requests[id].requestStatus = RequestStatus.PROCESSED;\n        // Update subscription assets tracking\n        subscriptionAssets[request.asset] -= request.assetAmount;\n        _pendingRequestsCount[request.asset]--;\n        // Mint sharesOut to the receiver\n        _mint(request.receiver, sharesOut);\n\n        // --- Interaction ---\n        // Transfer assets to safe (the fund's vault)\n        IERC20(request.asset).safeTransfer(portfolioSafe, request.assetAmount);\n\n        // Emit the event using sharesOut\n        emit SubscriptionApproval(id, request.assetAmount, sharesOut);\n    }\n\n    /// @notice Reject a subscription request\n    /// @param id The ID of the request to reject\n    /// @param request Request to reject\n    function _rejectSubscriptionRequest(uint256 id, UserRequest memory request) internal {\n        // --- Effects ---\n        // Update status to REJECTED\n        // WARNING: request.requestStatus (memory copy) is now out of sync with storage - do not use it after this line.\n        _requests[id].requestStatus = RequestStatus.REJECTED;\n        // Update subscription assets tracking\n        subscriptionAssets[request.asset] -= request.assetAmount;\n        _pendingRequestsCount[request.asset]--;\n\n        // --- Interaction ---\n        IERC20(request.asset).safeTransfer(request.investor, request.assetAmount);\n\n        emit SubscriptionDenial(id, request.assetAmount, request.sharesAmount);\n    }\n\n    /// @notice Check if a request is valid (returns bool, does not revert)\n    /// @param investor The investor address to check\n    /// @param requestStatus The request status to check\n    /// @return valid Whether the request was valid\n    function _checkValidRequest(address investor, RequestStatus requestStatus) internal pure returns (bool) {\n        if (investor == address(0) || requestStatus != RequestStatus.PENDING) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Check if there are any pending requests (subscriptions or redemptions) for an asset\n    /// @param asset The asset address to check\n    /// @return hasPending True if there are pending requests for this asset\n    /// @dev Uses counter-based tracking for efficient checking\n    function _hasPendingRequests(address asset) internal view returns (bool) {\n        return _pendingRequestsCount[asset] > 0;\n    }\n\n    //\n    // Redemption Processing\n    //\n\n    /// @notice Approve a redemption request\n    /// @param id The ID of the request to approve\n    /// @param request Redemption approval request\n    /// @param operatorPrice The current price per share in normalized USD units (8 decimals, i.e., _NORMALIZED_PRECISION_USD)\n    function _approveRedeemRequest(uint256 id, UserRequest memory request, uint256 operatorPrice) internal {\n        // Charge redemption fee before processing the redemption\n        uint256 redemptionFee;\n        if (redemptionFeeRate > 0) {\n            redemptionFee = _chargeRedemptionFee(request);\n        }\n\n        // --- Effects ---\n        // Calculate net shares to redeem after fees\n        uint256 netShares = request.sharesAmount - redemptionFee;\n\n        // Check if operator price is at least as good as the request price\n        // Validate using net shares to ensure slippage protection applies to the actual amount received\n        uint256 assetsOutNet = sharesToAssets(netShares, operatorPrice, request.asset);\n        if (assetsOutNet < request.assetAmount) revert RequestPriceLowerThanOperatorPrice();\n\n        // Update status to PROCESSED\n        // WARNING: request.requestStatus (memory copy) is now out of sync with storage - do not use it after this line.\n        _requests[id].requestStatus = RequestStatus.PROCESSED;\n        _pendingRequestsCount[request.asset]--;\n        // Burn only the net shares (fee shares are transferred, not burned)\n        _burn(address(this), netShares);\n\n        // --- Interaction (Asset Transfer) ---\n        // Transfer assets to receiver\n        IERC20(request.asset).safeTransferFrom(portfolioSafe, request.receiver, assetsOutNet);\n        emit RedemptionApproval(id, assetsOutNet, request.sharesAmount, redemptionFee);\n    }\n\n    /// @notice Reject a redemption request\n    /// @param id The ID of the request to reject\n    /// @param request Redemption rejection request\n    function _rejectRedeemRequest(uint256 id, UserRequest memory request) internal {\n        // --- Effects ---\n        // Update status to REJECTED\n        // WARNING: request.requestStatus (memory copy) is now out of sync with storage - do not use it after this line.\n        _requests[id].requestStatus = RequestStatus.REJECTED;\n        _pendingRequestsCount[request.asset]--;\n\n        // --- Interaction ---\n        _transfer(address(this), request.investor, request.sharesAmount);\n\n        emit RedemptionDenial(id, request.assetAmount, request.sharesAmount);\n    }\n\n    //\n    // Share Management\n    //\n\n    /// @notice Validate that the price deviation from the last settled price is within acceptable bounds\n    /// @param asset The asset to validate the price for\n    /// @param sharesPriceInAsset The current price per share in normalized USD units (8 decimals)\n    /// @dev If there's no previous settled price, the price is accepted (first time processing)\n    /// @dev If there is a previous price, the deviation must be within MAX_PRICE_DEVIATION_BPS (10%)\n    function _validatePriceDeviation(address asset, uint256 sharesPriceInAsset) internal view {\n        uint256 lastPrice = _lastSettledPrice[asset];\n\n        // If there's no previous settled price, accept the price (first time processing)\n        if (lastPrice == 0) {\n            return;\n        }\n\n        // Calculate the absolute deviation\n        uint256 deviation;\n        if (sharesPriceInAsset > lastPrice) {\n            // Price increased\n            deviation = sharesPriceInAsset - lastPrice;\n        } else {\n            // Price decreased\n            deviation = lastPrice - sharesPriceInAsset;\n        }\n\n        // Calculate deviation in basis points: (deviation * 10000) / lastPrice\n        // Use mulDiv to avoid overflow\n        uint256 deviationBps = deviation.mulDiv(_PRECISION_BPS, lastPrice, Math.Rounding.Floor);\n\n        // Check if deviation exceeds maximum allowed\n        if (deviationBps > MAX_PRICE_DEVIATION_BPS) {\n            revert PriceDeviationTooLarge();\n        }\n    }\n\n    /// @notice Charge management and performance fees based on time elapsed\n    /// @param asset The asset to charge fees for\n    /// @param sharesPriceInAsset The current price per share in normalized USD units (8 decimals, i.e., _NORMALIZED_PRECISION_USD)\n    function _chargeFees(address asset, uint256 sharesPriceInAsset) internal {\n        // Charge management and performance fees based on time elapsed\n        uint256 managementFee;\n        uint256 performanceFee;\n\n        // Management fees use shared managementFeeLastUpdate timestamp\n        if (managementFeeRate > 0) {\n            uint256 timeElapsed = block.timestamp - _managementFeeLastUpdate;\n            if (timeElapsed > MIN_TIME_ELAPSED) {\n                // Update state before external calls\n                _managementFeeLastUpdate = block.timestamp;\n                managementFee = _chargeManagementFee(timeElapsed);\n            }\n        }\n\n        // Performance fees use asset-specific performanceFeeLastUpdate to prevent gaming\n        if (performanceFeeRate > 0 && _approvedAssetsMap[asset].isFeeModuleAsset) {\n            uint256 perfTimeElapsed = block.timestamp - _performanceFeeLastUpdate;\n            if (perfTimeElapsed > MIN_TIME_ELAPSED) {\n                _performanceFeeLastUpdate = block.timestamp;\n                performanceFee = _chargePerformanceFee(sharesPriceInAsset, perfTimeElapsed);\n            }\n        }\n\n        // Only emit FeeCollection event if at least one fee is non-zero\n        if (managementFee > 0 || performanceFee > 0) {\n            emit FeeCollection(managementFee, performanceFee);\n        }\n    }\n\n    /// @notice Charge redemption fee and calculate net shares to redeem\n    /// @param request The request to charge fees for\n    /// @return feeShares The shares remaining after fee deduction\n    function _chargeRedemptionFee(UserRequest memory request) internal returns (uint256 feeShares) {\n        // Calculate fee shares: feeShares = requestedShares * REDEMPTION_FEE_RATE / 10000\n        feeShares = (request.sharesAmount * redemptionFeeRate) / _PRECISION_BPS;\n\n        // Transfer fee shares to fee receiver\n        if (feeShares > 0) {\n            _transfer(address(this), feeReceiver, feeShares);\n        }\n\n        return feeShares;\n    }\n\n    /// @notice Calculate and charge management fees based on time elapsed and total supply\n    /// @param timeElapsed The time elapsed since last fee calculation\n    /// @return The amount of management fee charged\n    function _chargeManagementFee(uint256 timeElapsed) internal returns (uint256) {\n        uint256 feeReceiverBalance = balanceOf(feeReceiver);\n        uint256 feeAmount = ((totalSupply() - feeReceiverBalance) * managementFeeRate * timeElapsed)\n            / (_PRECISION_BPS * SECONDS_PER_YEAR);\n        if (feeAmount > 0) {\n            _mint(feeReceiver, feeAmount);\n        }\n        return feeAmount;\n    }\n\n    /// @notice Calculate and charge performance fees using the performance fee module\n    /// @param sharesPriceInUSD The current price per share in normalized USD units (8 decimals, i.e., _NORMALIZED_PRECISION_USD)\n    /// @param timeElapsed The time elapsed since last fee calculation\n    /// @return The amount of performance fee charged\n    function _chargePerformanceFee(uint256 sharesPriceInUSD, uint256 timeElapsed) internal returns (uint256) {\n        if (performanceFeeModule == address(0)) {\n            return 0;\n        }\n        uint256 feeReceiverBalance = balanceOf(feeReceiver);\n        uint256 netSupply = totalSupply() - feeReceiverBalance;\n        uint256 performanceFee = IPerfFeeModule(performanceFeeModule)\n            .calculatePerformanceFee(sharesPriceInUSD, timeElapsed, performanceFeeRate, netSupply);\n        if (performanceFee > 0) {\n            _mint(feeReceiver, performanceFee);\n        }\n        return performanceFee;\n    }\n\n    /// @notice Update asset configuration for deposits and redemptions\n    /// @param asset The asset address to configure\n    /// @param isFeeModuleAsset Whether the asset can be used for performance fee module calculations\n    /// @param canDeposit Whether the asset is approved for deposits\n    /// @param canRedeem Whether the asset is approved for redemptions\n    /// @dev WARNING: Rebasing tokens (e.g., sUSDe) and fee-on-transfer tokens are NOT supported.\n    function _updateAsset(address asset, bool isFeeModuleAsset, bool canDeposit, bool canRedeem) internal {\n        if (asset == address(0)) revert InvalidArguments();\n        if (asset == address(this)) revert InvalidArguments();\n\n        //check if asset exists\n        if (_approvedAssetsMap[asset].asset != address(0)) {\n            //check if asset is being removed\n            if (!canDeposit && !canRedeem) {\n                // Gate full deletion: only allow removal when there are no pending subscriptions/redemptions\n                // and subscriptionAssets[asset] == 0\n                if (subscriptionAssets[asset] != 0) {\n                    revert InvalidArguments(); // Cannot remove asset with pending subscriptions\n                }\n                // Check for pending requests using counter\n                if (_pendingRequestsCount[asset] > 0) {\n                    revert InvalidArguments(); // Cannot remove asset with pending requests\n                }\n                // Prevent removing the last asset\n                if (_approvedAssets.length <= 1) {\n                    revert InvalidArguments(); // Cannot remove last asset\n                }\n\n                _shadowAsset(asset);\n                delete _approvedAssetsMap[asset];\n                emit AssetRemove(asset);\n            } else {\n                //update asset configuration\n                _approvedAssetsMap[asset].isFeeModuleAsset = isFeeModuleAsset;\n                _approvedAssetsMap[asset].canDeposit = canDeposit;\n                _approvedAssetsMap[asset].canRedeem = canRedeem;\n                emit AssetUpdate(asset, isFeeModuleAsset, canDeposit, canRedeem);\n            }\n        } else {\n            if (!canDeposit && !canRedeem) {\n                // cannot add an asset with both canDeposit and canRedeem false\n                revert InvalidArguments();\n            } else {\n                // Set address, symbol and decimals\n                _approvedAssetsMap[asset].asset = asset;\n                _approvedAssetsMap[asset].symbol = IERC20Metadata(asset).symbol();\n                uint8 thisDecimals = IERC20Metadata(asset).decimals();\n                if (thisDecimals > 36) revert InvalidArguments(); // Prevent overflow risks\n                _approvedAssetsMap[asset].decimals = thisDecimals;\n                _approvedAssetsMap[asset].isFeeModuleAsset = isFeeModuleAsset;\n                _approvedAssetsMap[asset].canDeposit = canDeposit;\n                _approvedAssetsMap[asset].canRedeem = canRedeem;\n                //add asset\n                _approvedAssets.push(asset);\n                emit AssetAdd(asset);\n                emit AssetUpdate(asset, isFeeModuleAsset, canDeposit, canRedeem);\n            }\n        }\n    }\n\n    /// @notice Remove an asset from the approved assets list\n    /// @param asset The asset address to remove\n    function _shadowAsset(address asset) internal {\n        uint256 len = _approvedAssets.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (_approvedAssets[i] == asset) {\n                _approvedAssets[i] = _approvedAssets[len - 1];\n                _approvedAssets.pop();\n                break;\n            }\n        }\n    }\n\n    //\n    // Setters\n    //\n\n    /// @notice Set subscription request TTL with 7-day maximum limit\n    /// @param ttl New TTL value\n    function _setSubscriptionRequestTtl(uint64 ttl) internal {\n        uint64 newTtl = ttl > MAX_TTL ? MAX_TTL : ttl;\n        if (subscriptionRequestTtl != newTtl) {\n            subscriptionRequestTtl = newTtl;\n            emit SubscriptionRequestTtlUpdate(subscriptionRequestTtl);\n        }\n    }\n\n    /// @notice Set redemption request TTL with 7-day maximum limit\n    /// @param ttl New TTL value\n    function _setRedemptionRequestTtl(uint64 ttl) internal {\n        uint64 newTtl = ttl > MAX_TTL ? MAX_TTL : ttl;\n        if (redemptionRequestTtl != newTtl) {\n            redemptionRequestTtl = newTtl;\n            emit RedemptionRequestTtlUpdate(redemptionRequestTtl);\n        }\n    }\n\n    /// @notice Set the fee receiver address\n    /// @param newFeeReceiver The new fee receiver address\n    function _setFeeReceiver(address newFeeReceiver) internal {\n        feeReceiver = newFeeReceiver;\n        emit FeeReceiverUpdate(newFeeReceiver);\n    }\n\n    /// @notice Set the management fee rate\n    /// @param newRate The new management fee rate in basis points\n    function _setManagementFeeRate(uint256 newRate) internal {\n        // charge any management fees that have not been charged yet\n        if (managementFeeRate > 0) {\n            _chargeManagementFee(block.timestamp - _managementFeeLastUpdate);\n        }\n        _managementFeeLastUpdate = block.timestamp;\n        managementFeeRate = newRate;\n        emit ManagementFeeRateUpdate(newRate);\n    }\n\n    /// @notice Set the redemption fee rate\n    /// @param newRate The new redemption fee rate in basis points\n    function _setRedemptionFeeRate(uint256 newRate) internal {\n        redemptionFeeRate = newRate;\n        emit RedemptionFeeRateUpdate(newRate);\n    }\n\n    /// @notice Set the performance fee rate\n    /// @param newRate The new performance fee rate in basis points\n    function _setPerformanceFeeRate(uint256 newRate, address usdAsset) internal {\n        if (performanceFeeRate > 0 && _approvedAssetsMap[usdAsset].isFeeModuleAsset) {\n            _chargePerformanceFee(_lastSettledPrice[usdAsset], block.timestamp - _performanceFeeLastUpdate);\n        }\n        // if performance fees is not charged due to incompatible asset, update the timestamp\n        // and forfeit any performance fees that have not been charged yet\n        _performanceFeeLastUpdate = block.timestamp;\n        performanceFeeRate = newRate;\n        emit PerformanceFeeRateUpdate(newRate);\n    }\n\n    /// @notice Set the performance fee module address\n    /// @param newPerformanceFeeModule The new performance fee module address\n    function _setPerformanceFeeModule(address newPerformanceFeeModule) internal {\n        performanceFeeModule = newPerformanceFeeModule;\n        emit PerformanceFeeModuleUpdate(newPerformanceFeeModule);\n    }\n}\n"
    }
}