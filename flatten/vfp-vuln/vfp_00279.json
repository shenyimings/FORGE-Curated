{
    "vfp_id": "vfp_00279",
    "project_name": "Across Audit.md",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Griefing Attacks Are Possible in ZK Adapters",
            "description": "A malicious user can manipulate the `tx.gasprice` parameter during a transaction to inflate the estimated L2 transaction cost, causing the HubPool to transfer excessive ETH to the L2 network. The root cause is the direct use of `tx.gasprice` in the `_computeETHTxCost` function without any upper limit, making it susceptible to manipulation by validators who can profit from inflated fees. An attacker can invoke the `executeRootBundle` function, triggering the `relayMessage` call in the adapter, which uses the manipulated gas price to calculate costs. This leads to a loss of funds from the HubPool as ETH is transferred to L2 based on the inflated estimate, enabling griefing attacks.\n",
            "severity": "High",
            "location": [
                "ZkStack_Adapter.sol::_computeETHTxCost#188",
                "ZkStack_Adapter.sol::relayMessage#91",
                "HubPool.sol::executeRootBundle#620",
                "ZkStack_CustomGasToken_Adapter.sol::_pullCustomGas#36"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "ZkStack_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with ETH as the gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://era.zksync.io/docs/dev/developer-guides/bridging/l1-l2.html#getting-the-base-cost\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // SharedBridge address, which is read from the BridgeHub at construction.\n    address public immutable SHARED_BRIDGE;\n\n    event ZkStackMessageRelayed(bytes32 canonicalTxHash);\n    error ETHGasTokenRequired();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit\n    ) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        L2_GAS_LIMIT = _l2GasLimit;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        SHARED_BRIDGE = BRIDGE_HUB.sharedBridge();\n        address gasToken = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (gasToken != address(1)) {\n            revert ETHGasTokenRequired();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = BRIDGE_HUB.requestL2TransactionDirect{ value: txBaseCost }(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkStackMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost.\n            L1_WETH.withdraw(amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect{ value: amount + txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Contract: to,\n                    l2Value: 0,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else {\n            // An ERC20 that is not WETH.\n            IERC20(l1Token).safeIncreaseAllowance(SHARED_BRIDGE, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: BRIDGE_HUB.sharedBridge(),\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkStackMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of ETH needed and\n     * returns the amount.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _computeETHTxCost(uint256 l2GasLimit) internal view returns (uint256) {\n        return BRIDGE_HUB.l2TransactionBaseCost(CHAIN_ID, tx.gasprice, l2GasLimit, L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT);\n    }\n}\n"
    }
}