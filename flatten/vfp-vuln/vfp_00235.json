{
    "vfp_id": "vfp_00235",
    "project_name": "Parallel Protocol - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "MainFeeDistributor.sol#swapLzToken function always revert because of interface mismatch",
            "description": "The swapLzToken function in MainFeeDistributor.sol attempts to call swapLzTokenToPrincipalToken on the bridgeable token contract with only one parameter (swapAmount). However, the actual implementation of swapLzTokenToPrincipalToken in the IBridgeableToken interface requires two parameters: _to and _amount. This mismatch in function signature causes the external call to revert on execution. The root cause is an incorrect assumption about the function's interface, likely due to outdated or incorrect interface definition. As a result, any attempt to use the swapLzToken function will fail, disrupting the intended token swap mechanism. This leads to a loss of functionality and prevents the system from correctly processing lz token swaps, impacting the overall protocol operations dependent on this function.\n",
            "severity": "High",
            "location": [
                "MainFeeDistributor.sol::swapLzToken",
                "IBridgeableToken::swapLzTokenToPrincipalToken"
            ],
            "files": [
                "cd3992aec0847063c2b979c51f6cac7dd2ff03bd/tokenomics/contracts/fees/MainFeeDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "MainFeeDistributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IBridgeableToken } from \"contracts/interfaces/IBridgeableToken.sol\";\n\nimport { FeeCollectorCore, ReentrancyGuard, IERC20, SafeERC20 } from \"./FeeCollectorCore.sol\";\n\n/// @title MainFeeDistributor\n/// @author Cooper Labs\n/// @custom:contact security@cooperlabs.xyz\n/// @notice Handles the reception and the distribution of fee tokens.\n\ncontract MainFeeDistributor is FeeCollectorCore {\n    using SafeERC20 for IERC20;\n\n    //-------------------------------------------\n    // Storage\n    //-------------------------------------------\n\n    /// @notice token bridgeableToken contract\n    IERC20 public bridgeableToken;\n    /// @notice Total shares of the fee receivers.\n    uint256 public totalShares;\n    /// @notice Mapping of the shares of the fee receivers.\n    mapping(address => uint256) public shares;\n    /// @notice Array of the fee receivers.\n    address[] public feeReceivers;\n\n    //-------------------------------------------\n    // Events\n    //-------------------------------------------\n\n    /// @notice Emitted when a new fee receiver is added to the fee distribution.\n    /// @param feeReceiver The address of the fee receiver.\n    /// @param shares The number of shares assigned to the fee receiver.\n    event FeeReceiverAdded(address feeReceiver, uint256 shares);\n\n    /// @notice Emitted when fees are released.\n    /// @param feeReceiver The address of the fee receiver.\n    /// @param income The amount of income released.\n    event FeeReleasedTo(address feeReceiver, uint256 income);\n\n    /// @notice Emitted when the bridgeable token is updated.\n    /// @param newBridgeableToken The address of the new bridgeable token.\n    event BridgeableTokenUpdated(address newBridgeableToken);\n\n    /// @notice Emitted when lzToken are swapped.\n    /// @param amount The amount of lzToken swapped.\n    event LzTokenSwapped(uint256 amount);\n\n    //-------------------------------------------\n    // Errors\n    //-------------------------------------------\n\n    /// @notice Thrown when the fee receiver address is zero.\n    error FeeReceiverZeroAddress();\n    /// @notice Thrown when the shares are zero.\n    error SharesIsZero();\n    /// @notice Thrown when the fee receiver is already added.\n    error FeeReceiverAlreadyAdded();\n    /// @notice Thrown when there is no fee receivers.\n    error NoFeeReceivers();\n    /// @notice Thrown when the array length mismatch.\n    error ArrayLengthMismatch();\n    /// @notice Thrown when the maximum swap amount is zero.\n    error MaxSwappableAmountIsZero();\n    /// @notice Thrown when the lzToken balance is zero.\n    error NothingToSwap();\n    /// @notice Thrown when the lzToken balance is not zero\n    /// during bridgeableToken contract address update.\n    error NeedToSwapAllLzTokenFirst();\n\n    //-------------------------------------------\n    // Constructor\n    //-------------------------------------------\n\n    ///@notice MainFeeDistributor constructor.\n    ///@param _bridgeableToken address of the bridgeable token.\n    ///@param _accessManager address of the AccessManager contract.\n    ///@param _feeToken address of the fee token.\n    constructor(\n        address _accessManager,\n        address _bridgeableToken,\n        address _feeToken\n    )\n        FeeCollectorCore(_accessManager, _feeToken)\n    {\n        bridgeableToken = IERC20(_bridgeableToken);\n    }\n\n    //-------------------------------------------\n    // External functions\n    //-------------------------------------------\n\n    /// @notice Release the fees to the fee receivers according to their shares.\n    function release() external nonReentrant whenNotPaused {\n        uint256 income = feeToken.balanceOf(address(this));\n        if (income == 0) revert NothingToRelease();\n        if (feeReceivers.length == 0) revert NoFeeReceivers();\n        for (uint256 i = 0; i < feeReceivers.length; i++) {\n            address feeReceiver = feeReceivers[i];\n            _release(income, feeReceiver);\n        }\n    }\n\n    /// @notice swap Lz-Token to Token if limit not reached.\n    /// @dev lzToken doesn't need approval to be swapped.\n    function swapLzToken() external nonReentrant whenNotPaused {\n        uint256 balance = bridgeableToken.balanceOf(address(this));\n        if (balance == 0) revert NothingToSwap();\n\n        uint256 maxSwapAmount = IBridgeableToken(address(bridgeableToken)).getMaxCreditableAmount();\n        if (maxSwapAmount == 0) revert MaxSwappableAmountIsZero();\n\n        uint256 swapAmount = balance > maxSwapAmount ? maxSwapAmount : balance;\n\n        emit LzTokenSwapped(swapAmount);\n        IBridgeableToken(address(bridgeableToken)).swapLzTokenToPrincipalToken(address(this), swapAmount);\n    }\n\n    /// @notice Get the addresses that will receive fees.\n    function getFeeReceivers() external view returns (address[] memory) {\n        return feeReceivers;\n    }\n\n    //-------------------------------------------\n    // AccessManaged functions\n    //-------------------------------------------\n\n    /// @notice Allow to update the fees receivers list and shares.\n    /// @dev This function can only be called by the accessManager.\n    /// @param _feeReceivers The list of the fee receivers.\n    /// @param _shares The list of the shares assigned to the fee receivers.\n    function updateFeeReceivers(address[] memory _feeReceivers, uint256[] memory _shares) public restricted {\n        if (_feeReceivers.length == 0) revert NoFeeReceivers();\n        if (_feeReceivers.length != _shares.length) revert ArrayLengthMismatch();\n        delete feeReceivers;\n\n        uint256 _totalShares = 0;\n        uint256 i = 0;\n        for (; i < _feeReceivers.length; ++i) {\n            _totalShares += _addFeeReceiver(_feeReceivers[i], _shares[i]);\n        }\n        totalShares = _totalShares;\n    }\n\n    /// @notice Allow to update the bridgeable token.\n    /// @dev This function can only be called by the accessManager.\n    /// @param _newBridgeableToken The address of the bridgeable token.\n    function updateBridgeableToken(address _newBridgeableToken) external restricted {\n        if (bridgeableToken.balanceOf(address(this)) > 0) revert NeedToSwapAllLzTokenFirst();\n        bridgeableToken = IERC20(_newBridgeableToken);\n        emit BridgeableTokenUpdated(_newBridgeableToken);\n    }\n\n    //-------------------------------------------\n    // Internal/Private functions\n    //-------------------------------------------\n\n    /// @notice Release the fees to the fee receiver.\n    /// @param _totalIncomeToDistribute The total amount of income received.\n    /// @param _feeReceiver The address of the fee receiver.\n    function _release(uint256 _totalIncomeToDistribute, address _feeReceiver) internal {\n        uint256 amount = _totalIncomeToDistribute * shares[_feeReceiver] / totalShares;\n        emit FeeReleasedTo(_feeReceiver, amount);\n        feeToken.safeTransfer(_feeReceiver, amount);\n    }\n\n    /// @notice Add a new fee receiver.\n    /// @param _feeReceiver The address of the fee receiver.\n    /// @param _shares The number of shares assigned to the fee receiver.\n    function _addFeeReceiver(address _feeReceiver, uint256 _shares) internal returns (uint256) {\n        if (_feeReceiver == address(0)) revert FeeReceiverZeroAddress();\n        if (_shares == 0) revert SharesIsZero();\n\n        feeReceivers.push(_feeReceiver);\n        shares[_feeReceiver] = _shares;\n        emit FeeReceiverAdded(_feeReceiver, _shares);\n        return _shares;\n    }\n}\n"
    }
}