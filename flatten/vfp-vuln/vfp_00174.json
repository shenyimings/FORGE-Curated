{
    "vfp_id": "vfp_00174",
    "project_name": "ChainSecurity_Gelato_GelatoSmartWallet_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Transient Validator Variable Override",
            "description": "This vulnerability involves the use of a single transient state variable `transientValidator` in the Delegation contract, which is set during the `validateUserOp` call and later used in the `execute` phase. The root cause is the shared mutable state across multiple UserOperations from the same account within a single bundle processed by the EntryPoint. Since the EntryPoint loops through all UserOperations and calls `validateUserOp` before starting execution, if two operations from the same account are included, the second validation overwrites the validator set by the first. During execution, the first operation may then use the validator from the second operation, leading to incorrect post-execution checks. An attacker could exploit this by bundling malicious operations to bypass intended validator logic, potentially allowing unauthorized execution flows or circumventing critical post-execution validations. The impact includes a compromise in the integrity of the validation-execution sequence, undermining the security model of EIP-4337 compliant account abstraction.\n",
            "severity": "Medium",
            "location": [
                "Delegation.sol::validateUserOp",
                "Delegation.sol::execute"
            ],
            "files": [
                "smartwallet-contracts/src/Delegation.sol"
            ]
        }
    ],
    "affected_files": {
        "Delegation.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {IERC7821} from \"./interfaces/IERC7821.sol\";\nimport {IERC1271} from \"./interfaces/IERC1271.sol\";\nimport {IERC4337} from \"./interfaces/IERC4337.sol\";\nimport {IValidator} from \"./interfaces/IValidator.sol\";\nimport {\n    CALL_TYPE_BATCH,\n    EXEC_TYPE_DEFAULT,\n    EXEC_MODE_DEFAULT,\n    EXEC_MODE_OP_DATA,\n    ENTRY_POINT_V8\n} from \"./types/Constants.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\ncontract Delegation is IERC7821, IERC1271, IERC4337, EIP712 {\n    error UnsupportedExecutionMode();\n    error InvalidCaller();\n    error InvalidValidator();\n    error InvalidSignatureLength();\n    error InvalidSignatureS();\n    error InvalidSignature();\n    error Unauthorized();\n    error InvalidNonce();\n    error ExcessiveInvalidation();\n\n    event ValidatorAdded(IValidator validator);\n    event ValidatorRemoved(IValidator validator);\n\n    // https://eips.ethereum.org/EIPS/eip-7201\n    /// @custom:storage-location erc7201:gelato.delegation.storage\n    struct Storage {\n        mapping(uint192 => uint64) nonceSequenceNumber;\n        mapping(IValidator => bool) validatorEnabled;\n    }\n\n    IValidator transient transientValidator;\n\n    // keccak256(abi.encode(uint256(keccak256(\"gelato.delegation.storage\")) - 1)) &\n    // ~bytes32(uint256(0xff));\n    bytes32 private constant STORAGE_LOCATION =\n        0x1581abf533ae210f1ff5d25f322511179a9a65d8d8e43c998eab264f924af900;\n\n    // keccak256(\"Execute(bytes32 mode,Call[] calls,uint256 nonce)Call(address to,uint256\n    // value,bytes data)\")\n    bytes32 private constant EXECUTE_TYPEHASH =\n        0xdf21343e200fb58137ad2784f9ea58605ec77f388015dc495486275b8eec47da;\n\n    // keccak256(\"Call(address to,uint256 value,bytes data)\")\n    bytes32 private constant CALL_TYPEHASH =\n        0x9085b19ea56248c94d86174b3784cfaaa8673d1041d6441f61ff52752dac8483;\n\n    modifier onlyThis() {\n        if (msg.sender != address(this)) {\n            revert InvalidCaller();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() {\n        if (msg.sender != entryPoint()) {\n            revert InvalidCaller();\n        }\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function execute(bytes32 mode, bytes calldata executionData) external payable {\n        _execute(mode, executionData, false);\n    }\n\n    function supportsExecutionMode(bytes32 mode) external pure returns (bool) {\n        (bytes1 callType, bytes1 execType, bytes4 modeSelector,) = _decodeExecutionMode(mode);\n\n        if (callType != CALL_TYPE_BATCH || execType != EXEC_TYPE_DEFAULT) {\n            return false;\n        }\n\n        if (modeSelector != EXEC_MODE_DEFAULT && modeSelector != EXEC_MODE_OP_DATA) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // https://eips.ethereum.org/EIPS/eip-1271\n    function isValidSignature(bytes32 digest, bytes calldata signature)\n        external\n        view\n        returns (bytes4)\n    {\n        // If `signature` length is 65, treat it as secp256k1 signature.\n        // Otherwise, invoke the specified validator module.\n        if (signature.length == 65) {\n            return _verifySignature(digest, signature) ? bytes4(0x1626ba7e) : bytes4(0xffffffff);\n        }\n\n        (IValidator validator, bytes calldata innerSignature) = _decodeValidator(signature);\n\n        if (!_getStorage().validatorEnabled[validator]) {\n            revert InvalidValidator();\n        }\n\n        return validator.isValidSignature(digest, innerSignature);\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external onlyEntryPoint returns (uint256) {\n        if (missingAccountFunds != 0) {\n            (bool success,) = payable(msg.sender).call{value: missingAccountFunds}(\"\");\n            (success); // ignore failure since it's the EntryPoint's job to verify\n        }\n\n        // If `signature` length is 65, treat it as secp256k1 signature.\n        // Otherwise, invoke the specified validator module.\n        if (userOp.signature.length == 65) {\n            return _verifySignature(userOpHash, userOp.signature) ? 0 : 1;\n        }\n\n        (IValidator validator, bytes calldata innerSignature) = _decodeValidator(userOp.signature);\n\n        if (!_getStorage().validatorEnabled[validator]) {\n            revert InvalidValidator();\n        }\n\n        transientValidator = validator;\n\n        Call[] calldata calls = _decodeCallsFromExecute(userOp.callData);\n\n        return validator.validate(calls, msg.sender, userOpHash, innerSignature) ? 0 : 1;\n    }\n\n    function addValidator(IValidator validator) external onlyThis {\n        _getStorage().validatorEnabled[validator] = true;\n        emit ValidatorAdded(validator);\n    }\n\n    function removeValidator(IValidator validator) external onlyThis {\n        delete _getStorage().validatorEnabled[validator];\n        emit ValidatorRemoved(validator);\n    }\n\n    function isValidatorEnabled(IValidator validator) external view returns (bool) {\n        return _getStorage().validatorEnabled[validator];\n    }\n\n    function entryPoint() public pure returns (address) {\n        // https://github.com/eth-infinitism/account-abstraction/releases/tag/v0.8.0\n        return ENTRY_POINT_V8;\n    }\n\n    function getNonce(uint192 key) external view returns (uint256) {\n        Storage storage s = _getStorage();\n        return _encodeNonce(key, s.nonceSequenceNumber[key]);\n    }\n\n    function invalidateNonce(uint256 newNonce) external onlyThis {\n        (uint192 key, uint64 targetSeq) = _decodeNonce(newNonce);\n        uint64 currentSeq = _getStorage().nonceSequenceNumber[key];\n\n        if (targetSeq <= currentSeq) {\n            revert InvalidNonce();\n        }\n\n        // Limit how many nonces can be invalidated at once.\n        unchecked {\n            uint64 delta = targetSeq - currentSeq;\n            if (delta > type(uint16).max) revert ExcessiveInvalidation();\n        }\n\n        _getStorage().nonceSequenceNumber[key] = targetSeq;\n    }\n\n    function _execute(bytes32 mode, bytes calldata executionData, bool mockSignature) internal {\n        (bytes1 callType, bytes1 execType, bytes4 modeSelector,) = _decodeExecutionMode(mode);\n\n        if (callType != CALL_TYPE_BATCH || execType != EXEC_TYPE_DEFAULT) {\n            revert UnsupportedExecutionMode();\n        }\n\n        Call[] calldata calls = _decodeCalls(executionData);\n\n        if (modeSelector == EXEC_MODE_DEFAULT) {\n            // https://eips.ethereum.org/EIPS/eip-7821\n            // If `opData` is empty, the implementation SHOULD require that `msg.sender ==\n            // address(this)`.\n            // If `msg.sender` is an authorized entry point, then `execute` MAY accept calls from\n            // the entry point.\n            if (msg.sender == address(this)) {\n                _executeCalls(calls);\n            } else if (msg.sender == entryPoint()) {\n                IValidator validator = transientValidator;\n                delete transientValidator;\n\n                _executeCalls(calls);\n\n                if (address(validator) != address(0)) {\n                    validator.postExecute();\n                }\n            } else {\n                revert Unauthorized();\n            }\n        } else if (modeSelector == EXEC_MODE_OP_DATA) {\n            bytes calldata opData = _decodeOpData(executionData);\n            bytes calldata signature = _decodeSignature(opData);\n\n            uint256 nonce = _getAndUseNonce(_decodeNonceKey(opData));\n            bytes32 digest = _computeDigest(mode, calls, nonce);\n\n            // If `opData` is not empty, the implementation SHOULD use the signature encoded in\n            // `opData` to determine if the caller can perform the execution.\n            // If `signature` length is 65, treat it as secp256k1 signature.\n            // Otherwise, invoke the specified validator module.\n            if (signature.length == 65) {\n                if (!_verifySignature(digest, signature) && !mockSignature) {\n                    revert Unauthorized();\n                }\n\n                _executeCalls(calls);\n            } else {\n                (IValidator validator, bytes calldata innerSignature) = _decodeValidator(signature);\n\n                if (!_getStorage().validatorEnabled[validator]) {\n                    revert InvalidValidator();\n                }\n\n                if (\n                    !validator.validate(calls, msg.sender, digest, innerSignature) && !mockSignature\n                ) {\n                    revert Unauthorized();\n                }\n\n                _executeCalls(calls);\n\n                validator.postExecute();\n            }\n        } else {\n            revert UnsupportedExecutionMode();\n        }\n    }\n\n    function _executeCalls(Call[] calldata calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            Call calldata call = calls[i];\n            address to = call.to == address(0) ? address(this) : call.to;\n\n            (bool success, bytes memory data) = to.call{value: call.value}(call.data);\n\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n    }\n\n    function _decodeCalls(bytes calldata executionData)\n        internal\n        pure\n        returns (Call[] calldata calls)\n    {\n        // `executionData` is simply `abi.encode(calls)`.\n        // We decode this from calldata rather than abi.decode which avoids a memory copy.\n        assembly {\n            let offset := add(executionData.offset, calldataload(executionData.offset))\n            calls.offset := add(offset, 32)\n            calls.length := calldataload(offset)\n        }\n    }\n\n    function _decodeCallsFromExecute(bytes calldata callData)\n        internal\n        pure\n        returns (Call[] calldata calls)\n    {\n        // `callData` is the call to `execute(bytes32 mode,bytes calldata executionData)` and\n        // `executionData` is simply `abi.encode(calls)`.\n        // We decode this from calldata rather than abi.decode which avoids a memory copy.\n        assembly {\n            let executionData := add(callData.offset, 100)\n            let offset := add(executionData, calldataload(executionData))\n            calls.offset := add(offset, 32)\n            calls.length := calldataload(offset)\n        }\n    }\n\n    function _decodeOpData(bytes calldata executionData)\n        internal\n        pure\n        returns (bytes calldata opData)\n    {\n        // If `opData` is not empty, `executionData` is `abi.encode(calls, opData)`.\n        // We decode this from calldata rather than abi.decode which avoids a memory copy.\n        assembly {\n            let offset := add(executionData.offset, calldataload(add(executionData.offset, 32)))\n            opData.offset := add(offset, 32)\n            opData.length := calldataload(offset)\n        }\n    }\n\n    function _decodeNonceKey(bytes calldata opData) internal pure returns (uint192 nonceKey) {\n        assembly {\n            nonceKey := shr(64, calldataload(opData.offset))\n        }\n    }\n\n    function _decodeSignature(bytes calldata opData)\n        internal\n        pure\n        returns (bytes calldata signature)\n    {\n        assembly {\n            signature.offset := add(opData.offset, 24)\n            signature.length := sub(opData.length, 24)\n        }\n    }\n\n    function _decodeSignatureComponents(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 r, bytes32 s, uint8 v)\n    {\n        assembly {\n            r := calldataload(signature.offset)\n            s := calldataload(add(signature.offset, 32))\n            v := byte(0, calldataload(add(signature.offset, 64)))\n        }\n    }\n\n    function _decodeValidator(bytes calldata signature)\n        internal\n        pure\n        returns (IValidator validator, bytes calldata data)\n    {\n        // `signature` is `abi.encodePacked(validator, data)`.\n        // We decode this from calldata rather than abi.decode which avoids a memory copy.\n        assembly {\n            validator := shr(96, calldataload(signature.offset))\n\n            data.offset := add(signature.offset, 20)\n            data.length := sub(signature.length, 20)\n        }\n    }\n\n    function _verifySignature(bytes32 digest, bytes calldata signature)\n        internal\n        view\n        returns (bool)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = _decodeSignatureComponents(signature);\n\n        // https://github.com/openzeppelin/openzeppelin-contracts/blob/v5.3.0/contracts/utils/cryptography/ECDSA.sol#L134-L145\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert InvalidSignatureS();\n        }\n\n        address signer = ecrecover(digest, v, r, s);\n\n        if (signer == address(0)) {\n            revert InvalidSignature();\n        }\n\n        return signer == address(this);\n    }\n\n    function _computeDigest(bytes32 mode, Call[] calldata calls, uint256 nonce)\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32[] memory callsHashes = new bytes32[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            callsHashes[i] = keccak256(\n                abi.encode(CALL_TYPEHASH, calls[i].to, calls[i].value, keccak256(calls[i].data))\n            );\n        }\n\n        bytes32 executeHash = keccak256(\n            abi.encode(EXECUTE_TYPEHASH, mode, keccak256(abi.encodePacked(callsHashes)), nonce)\n        );\n\n        return _hashTypedData(executeHash);\n    }\n\n    function _getAndUseNonce(uint192 key) internal returns (uint256) {\n        uint64 seq = _getStorage().nonceSequenceNumber[key];\n        _getStorage().nonceSequenceNumber[key]++;\n        return _encodeNonce(key, seq);\n    }\n\n    function _encodeNonce(uint192 key, uint64 seq) internal pure returns (uint256) {\n        return (uint256(key) << 64) | seq;\n    }\n\n    function _decodeNonce(uint256 nonce) internal pure returns (uint192 key, uint64 seq) {\n        key = uint192(nonce >> 64);\n        seq = uint64(nonce);\n    }\n\n    function _getStorage() internal pure returns (Storage storage $) {\n        assembly {\n            $.slot := STORAGE_LOCATION\n        }\n    }\n\n    function _decodeExecutionMode(bytes32 mode)\n        internal\n        pure\n        returns (bytes1 calltype, bytes1 execType, bytes4 modeSelector, bytes22 modePayload)\n    {\n        // https://eips.ethereum.org/EIPS/eip-7579\n        // https://eips.ethereum.org/EIPS/eip-7821\n        assembly {\n            calltype := mode\n            execType := shl(8, mode)\n            modeSelector := shl(48, mode)\n            modePayload := shl(80, mode)\n        }\n    }\n\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"GelatoDelegation\";\n        version = \"0.0.1\";\n    }\n}\n"
    }
}