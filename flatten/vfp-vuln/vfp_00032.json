{
    "vfp_id": "vfp_00032",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Cross-contract reentrancy allows YIELD_- TOKEN theft for the GenericERC4626 WithdrawalRequestManager variant",
            "description": "The WithdrawalRequestManager in the GenericERC4626 variant is vulnerable to a cross-contract reentrancy attack due to the absence of reentrancy guards in critical functions. The vulnerability arises because the contract allows multiple whitelisted vaults to interact with it, and functions like initiateWithdraw do not employ nonReentrant modifiers or equivalent protections against reentrancy from external contracts.\n\nThe root cause is the lack of reentrancy protection in the WithdrawalRequestManager, particularly in functions that handle asset transfers and state changes. Since the contract relies on external calls to yield strategies that may contain malicious code, an attacker can exploit the reentrancy window during a Uniswap swap that includes a malicious pool. This pool can trigger a callback into the protocol, re-entering the deposit function before the initial transaction completes.\n\nAn attacker can initiate a withdrawal, leaving YIELD_TOKENs in the WithdrawalRequestManager, then execute a multihop swap through a malicious pool that re-enters the protocol to deposit assets. This reentrant call manipulates the accounting of YIELD_TOKEN balances, causing the system to mint more shares than deserved based on inflated balance differences.\n\nThe impact is severe: attackers can steal YIELD_TOKENs from pending withdrawal requests of other users, effectively draining funds from the WithdrawalRequestManager. This leads to loss of user funds and undermines the integrity of the withdrawal mechanism.\n",
            "severity": "High",
            "location": [
                "src/withdraws/GenericERC4626.sol",
                "src/withdraws/WithdrawalRequestManager.sol::initiateWithdraw"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/contracts/trading/adapters/UniV3Adapter.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/withdraws/GenericERC4626.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/withdraws/AbstractWithdrawRequestManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Attacker can drain the entire suppliers on Morpho market by inflating collateral price",
            "description": "The AbstractYieldStrategy contract allows users to initiate a withdrawal without burning their shares, only escrowing them. This leads to a reduction in effectiveSupply() while keeping totalSupply() unchanged. An attacker can exploit this by initiating a large withdrawal, drastically reducing effectiveSupply(), and then donating a large amount of yield tokens to inflate the price() function's output.\n\nThe root cause lies in the price() calculation, which depends on effectiveSupply() and the yield token balance. Since effectiveSupply() can be reduced arbitrarily by initiating withdrawals, and the price is calculated as (yieldTokens * convertYieldTokenToAsset()) / effectiveSupply(), a low effectiveSupply() combined with a high yield token balance results in an extremely high price.\n\nThe attacker can then borrow a massive amount of assets from the Morpho market using this inflated price as collateral value. Since Morpho allows direct borrowing without going through the LendingRouter, the transient state checks are bypassed, making the attack feasible. After borrowing, the attacker can finalize their withdrawal and reclaim their original collateral.\n\nThe impact is catastrophic: the attacker can borrow nearly the entire supply of the loan asset from the Morpho market, leading to a complete loss of funds for all suppliers in that market. The only cost to the attacker is the donated yield tokens, which is negligible compared to the borrowed amount.\n",
            "severity": "High",
            "location": [
                "src/AbstractYieldStrategy.sol::initiateWithdraw#280-307",
                "src/AbstractYieldStrategy.sol::convertToAssets",
                "src/AbstractYieldStrategy.sol::convertSharesToYieldToken",
                "src/AbstractYieldStrategy.sol::price"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/AbstractYieldStrategy.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "When users borrow directly from Morpho price of the collateral will not be accurate",
            "description": "The vulnerability arises because the Morpho price oracle prices withdrawal requests based on the requested value when going through the lending router, but when users borrow directly from Morpho, the pricing falls back to the raw share value via super.convertToAssets(shares), which does not account for active withdrawal requests. The root cause is the reliance on the t_currentAccount variable being set only by the lending router, leading to inconsistent pricing logic. An attacker can exploit this by initiating a withdrawal request and then borrowing directly from Morpho without using the lending router, causing the oracle to misprice their collateral. This results in incorrect collateral valuation, potentially allowing over-borrowing or under-collateralized positions, which threatens protocol solvency.\n",
            "severity": "High",
            "location": [
                "AbstractYieldStrategy.sol#L118-L120",
                "AbstractSingleSidedLP.sol#L300-L303"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/AbstractYieldStrategy.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "migrateRewardPool Fails Due to Incompatible Storage Design in CurveConvexLib",
            "description": "The migrateRewardPool function in AbstractRewardManager is designed to migrate rewards from an old to a new Convex reward pool by updating internal storage and using delegatecall. However, the function fails in practice because CurveConvexLib, used by CurveConvex2Token, stores the reward pool address as immutable. As a result, even if the reward manager updates its state, newly minted LP tokens continue to deposit into the old reward pool. The root cause is the incompatibility between the mutable storage assumption in AbstractRewardManager and the immutable design of CurveConvexLib. There is no direct attack path, but if Convex deprecates a reward pool, the protocol cannot migrate, breaking expected functionality. This violates the IRewardManager interface specification, which requires support for reward pool changes.\n",
            "severity": "High",
            "location": [
                "AbstractRewardManager.sol#L44-L65",
                "IRewardManager.sol#L82-L86"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/rewards/AbstractRewardManager.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/interfaces/IRewardManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "RewardManagerMixin.claimAccountRewards lacks of necessary param check",
            "description": "The claimAccountRewards function in RewardManagerMixin does not validate the account parameter, allowing any caller to specify any address, including privileged addresses like MORPHO. The root cause is the absence of input validation and the logic that uses balanceOf(account) when the caller is not a lending router. If MORPHO is passed as the account, it will receive rewards based on its vault token balance, which accumulates when users enter positions via AbstractLendingRouter. An attacker can exploit this by calling enterPosition with MORPHO as the account, causing rewards to be incorrectly distributed to MORPHO. This leads to users receiving fewer rewards than expected, as MORPHO holds a large portion of vault tokens, thereby misallocating reward distributions.\n",
            "severity": "High",
            "location": [
                "RewardManagerMixin.sol#L155-L177",
                "AbstractLendingRouter.sol#L241",
                "AbstractLendingRouter.sol#L244"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/AbstractLendingRouter.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/rewards/RewardManagerMixin.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Hardcoded useEth = true in remove_liquidity_one_coin or remove_liquidity lead to stuck fund",
            "description": "The vulnerability arises when exiting a Curve V2 pool via the _exitPool function in single-sided strategies, where the useEth parameter is hardcoded to true during remove_liquidity_one_coin and remove_liquidity calls. This causes the Curve pool to return native ETH instead of WETH. However, the protocol expects WETH, and the subsequent logic in unstakeAndExitPool fails to wrap the received native ETH back into WETH because it only checks if TOKEN_1 or TOKEN_2 is ETH_ADDRESS (0x0), which is false when dealing with WETH. The root cause is the hardcoded useEth = true regardless of the actual token configuration. An attacker cannot directly exploit this, but any user action triggering an exit will leave native ETH in the vault. The impact is severe: the vault becomes desynchronized from its expected asset (WETH), leading to incorrect balance accounting and potential loss of user funds during withdrawals, as _burnShares measures WETH balance changes and returns zero if only native ETH is present.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::add_liquidity#236-238",
                "CurveConvex2Token.sol::remove_liquidity_one_coin#255-258",
                "CurveConvex2Token.sol::remove_liquidity#281-283",
                "CurveConvex2Token.sol::unstakeAndExitPool#205-211",
                "AbstractYieldStrategy.sol::_burnShares#416-433"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/AbstractYieldStrategy.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Malicious user can change the TradeType to steal funds from the vault or withdraw request manager",
            "description": "The vulnerability exists in the _executeRedemptionTrades function of AbstractSingleSidedLP and the _preStakingTrade function of AbstractWithdrawRequestManager, where the trade type (TradeType) is not hardcoded and can be arbitrarily set by the caller. The intended behavior is to use TradeType.EXACT_IN_SINGLE to swap a precise amount of non-asset tokens (e.g., DAI) for an unknown amount of the asset token (e.g., WBTC). However, a malicious user can set the trade type to TradeType.EXACT_OUT_SINGLE, which instead swaps an arbitrary amount of input tokens to receive an exact, potentially massive amount of output tokens (e.g., 10,000 DAI swapped to receive 1e14 WBTC). The root cause is the lack of validation or hardcoding of the trade type, allowing user-controlled parameters to dictate critical trade behavior. This can be exploited during redemption or withdrawal flows by crafting malicious trade data, especially via flexible adapters like ZeroExAdaptor. The impact is high: attackers can drain vaults or withdraw request managers by extracting vastly more assets than entitled, leading to significant fund loss.\n",
            "severity": "High",
            "location": [
                "AbstractSingleSidedLP.sol::_executeRedemptionTrades#223",
                "AbstractWithdrawRequestManager.sol::_preStakingTrade#268",
                "AbstractSingleSidedLP.sol::Trade#223"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/withdraws/AbstractWithdrawRequestManager.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "WETH.withdraw called on native ETH balance causes revert",
            "description": "The vulnerability arises when a yield strategy deposits into a Curve pool where one of the underlying tokens is ETH. In such cases, the strategy receives native ETH after a trade, but later attempts to call WETH.withdraw(msgValue) when msgValue > 0, assuming it holds WETH. However, since the contract only holds native ETH and not WETH, the withdraw call reverts, blocking further operations.\n\nThe root cause is the incorrect assumption that receiving ETH via trade implies holding WETH, leading to an invalid WETH.withdraw() call. The code checks if TOKEN_1 or TOKEN_2 is ETH_ADDRESS and sets msgValue accordingly, then calls WETH.withdraw(msgValue), which fails because no WETH is present.\n\nAn attacker cannot directly exploit this, but the condition occurs naturally when users deposit into ETH-paired Curve pools. The attack path requires no malicious action—simply depositing into such a pool triggers the issue.\n\nThe impact is that users cannot complete deposits if the asset is one of the Curve LP tokens. If the reward token is WETH, the entire strategy state can be disrupted due to failed withdrawals, rendering the strategy unusable.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::deposit#180-196",
                "AbstractSingleSidedLP.sol::executeTrade#181-219",
                "TradingUtils.sol::ensureEtherBalance#164-172"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Hard-Coded Mainnet WETH Address Breaks All Non-Mainnet Deployments",
            "description": "The protocol uses a compile-time constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), which is the WETH address on Ethereum mainnet. This constant is used across core contracts like AbstractStakingStrategy, CurveConvexLib, and various withdraw managers. The root cause is the hardcoding of a chain-specific address in a protocol designed for multi-chain deployment. When deployed on L2s like Arbitrum or Base, where WETH exists at a different address or is not present, calls to WETH.withdraw() will revert and WETH.deposit{value:...}() will fail to mint tokens. This breaks critical functionality such as withdrawals and redemptions. The impact is medium: while the protocol functions on mainnet, it becomes unusable on other chains, contradicting the project's stated goal of supporting multiple networks. The likelihood is medium given the explicit mention of future Base and Arbitrum deployments.\n",
            "severity": "Medium",
            "location": [
                "Constants.sol::WETH#19",
                "AbstractStakingStrategy",
                "CurveConvexLib",
                "EtherFiWithdrawRequestManager"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/utils/Constants.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/staking/AbstractStakingStrategy.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Single sided strategy cant do trades for ETH pools",
            "description": "When users deposit the asset into a single-sided Curve LP strategy where one of the pool's underlying tokens is ETH (not WETH), the trade execution fails. The issue occurs because the TRADING_MODULE returns native ETH when ETH is requested, but the strategy code expects to receive WETH. The root cause is a mismatch between the expected token type (WETH) and the actual received token (ETH) in the trade settlement logic. This leads to accounting errors or reverts when the contract attempts to handle the received ETH as WETH. Exploitation is not direct, but users attempting to use the strategy with ETH-pool assets will find their deposits fail or result in lost funds. The impact is medium: it breaks functionality for a specific but valid use case, limiting the protocol's flexibility.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Liquidations can be frontrunned to avoid by paying as little as 1 share",
            "description": "The protocol integrates with Morpho for debt management, and during liquidation, the full debt is expected to be repaid. However, a user can frontrun their own liquidation by repaying just 1 share of debt via exitPosition, which reduces their borrowShares.\n\nThe root cause lies in Morpho's internal accounting: when liquidate() is called after a partial repayment, it attempts to subtract the full sharesToLiquidate from the borrower's reduced borrowShares, causing an underflow revert. This is exacerbated by the lack of a cooldown or rate-limiting mechanism on exitPosition.\n\nThe attack path involves a user detecting an impending liquidation and frontrunning it with a minimal repayment (1 share), causing the liquidation transaction to revert due to arithmetic underflow when subtracting shares.\n\nThe impact is that liquidations can be consistently avoided by borrowers at minimal cost, undermining the protocol's solvency mechanism and increasing systemic risk.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::_liquidate",
                "Morpho.sol::liquidate#247",
                "Morpho.sol::position#L532"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Minting yield tokens single sided can be impossible if CURVE_V2 dexId is used on redemptions",
            "description": "In single-sided yield strategies, the strategy contract grants infinite allowance to the Curve pool for both underlying tokens upon deployment. However, when a user withdraws and chooses CURVE_V2 as the dexId to swap one of the underlying tokens back to the asset token, the TRADING_MODULE revokes the allowance of the sellToken (which is the asset token) after the swap.\n\nThe root cause is that the trading module revokes token allowances for security after swaps, but does not account for the fact that the strategy itself depends on those allowances to continue depositing into the yield pool. If the swap uses the same pool the strategy is LP'ing into, the allowance revocation breaks future deposits.\n\nAn attacker can exploit this by withdrawing double-sided and selecting the same Curve pool via CURVE_V2 to swap one token to the other, triggering the allowance revocation. This can be done repeatedly to permanently block deposits.\n\nThe impact is that the strategy becomes permanently unusable for new deposits, as it loses the required token allowance to mint LP tokens, effectively bricking the strategy.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol::constructor#169-178",
                "AbstractSingleSidedLP.sol::withdrawDoubleSided#163-178",
                "TradingUtils.sol::executeTrade#54-57",
                "CurveV2Adapter.sol::swap#42-63"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Withdrawals ongoing for OETH, apxETH, weETH, and almost any LST are overpriced by the oracle",
            "description": "When a user initiates a withdrawal of an LST (like OETH), the yield token is sent to the Withdraw Request Manager to start beacon chain unstaking. However, during the pending withdrawal period, the protocol continues to price the collateral using the yield token's oracle rate, even though the LST has stopped earning yield.\n\nThe root cause is that the pricing logic in getWithdrawRequestValue defaults to using the YIELD_TOKEN's oracle price if the withdrawal is not yet finalized. Since the LST no longer accrues rewards after unstaking begins, this leads to overvaluation of the collateral.\n\nAn attacker can initiate a withdrawal, keep the overvalued collateral on the Morpho market, and borrow additional funds based on the inflated value, even though the underlying asset is no longer generating yield.\n\nThe impact is that users can over-leverage by borrowing against collateral that is no longer earning yield, creating a risk of under-collateralization. In extreme cases (e.g., slashing), the collateral could be significantly overvalued, threatening protocol solvency.\n",
            "severity": "Medium",
            "location": [
                "AbstractStakingStrategy.sol::initiateWithdraw#64-74",
                "AbstractWithdrawRequestManager.sol::getWithdrawRequestValue#307-340",
                "Origin.sol::withdraw#12-19"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/staking/AbstractStakingStrategy.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding discrepancy between MorphoLendingRouter::healthFactor and Morpho::repay causes position migration failures",
            "description": "The MorphoLendingRouter::healthFactor function calculates borrowed assets using integer division (rounding down), while Morpho's internal repay function uses a rounding-up method (toAssetsUp). This discrepancy causes the router to underestimate the amount of debt that must be repaid during a position migration.\n\nThe root cause is the inconsistent rounding logic between the two systems: the router uses truncating division, while Morpho uses ceiling division for asset conversion. Over time, as interest accrues, the difference—though small (e.g., 1 wei)—becomes significant enough to cause failures.\n\nDuring a migratePosition call, the router computes a flash loan amount based on the underestimated debt. When Morpho attempts to repay the full shares, it demands slightly more assets than were borrowed, causing a balance shortfall and revert.\n\nThe impact is that position migrations fail unexpectedly, even for healthy positions, breaking a core protocol feature. This issue is latent and may only manifest after prolonged market activity, making it difficult to detect.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::healthFactor#279",
                "Morpho.sol::_isHealthy#532",
                "Morpho.sol::repay#284"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect rounding in MorphoLendingRouter::healthFactor breaks migratePosition",
            "description": "The vulnerability lies in the MorphoLendingRouter::healthFactor function, which calculates the borrow amount for position migration using integer division that rounds down. This causes an underestimation of the required repayment amount during flash loans. The root cause is the use of truncating integer division (a * b) / c instead of ceiling division, which fails to account for the rounding-up behavior used by Morpho Blue's toAssetsUp() during actual repayment. An attacker cannot directly exploit this, but any user attempting to migrate a position will trigger a revert when the flash loaned amount is insufficient by ~1 wei to cover the actual repayment. This results in a denial of service for the migratePosition functionality, a core protocol feature, rendering it unusable despite correct user intent and sufficient underlying collateral.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::healthFactor",
                "AbstractLendingRouter.sol::migratePosition#L74",
                "AbstractLendingRouter.sol::_enterPosition#L97",
                "MorphoLendingRouter.sol::onMorphoFlashLoan#L140",
                "AbstractLendingRouter.sol::_enterOrMigrate#L236",
                "MorphoLendingRouter.sol::_exitWithRepay#L192",
                "Morpho.sol::repay#L284",
                "MorphoLendingRouter.sol::onMorphoRepay#L224"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Emission rewards accrue when yield strategy is empty due to virtual shares",
            "description": "The vulnerability occurs in the AbstractRewardManager and AbstractYieldStrategy contracts, where emission rewards continue to accrue even when there are no real depositors in a yield strategy. The root cause is the assumption that effectiveSupply can reach zero to halt reward accrual, but due to the use of VIRTUAL_SHARES (a non-zero minimum), effectiveSupply never reaches zero. This leads to the rewardPerToken accumulator continuing to increase unnecessarily. The issue is triggered naturally whenever a strategy has no real deposits but still holds virtual shares. The impact is that reward distribution logic remains active when it should be paused, leading to incorrect state accumulation and potential future miscalculations or unfair reward distribution when users eventually join. This breaks the intended economic model and wastes protocol resources.\n",
            "severity": "Medium",
            "location": [
                "AbstractRewardManager.sol#L298",
                "AbstractYieldStrategy.sol#L149-L151"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/AbstractYieldStrategy.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/rewards/AbstractRewardManager.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Incorrect ETH/WETH comparison causes DoS in CurveConvexStrategy exit",
            "description": "The vulnerability exists in the CurveConvexStrategy's _executeRedemptionTrades function, where a strict address comparison fails to recognize that ETH and WETH are economically equivalent. The root cause is the use of direct address equality (tokens[i] == asset) without considering that ETH is automatically wrapped into WETH during the exit process. When the strategy asset is WETH and one of the pool tokens is ETH, the function incorrectly attempts to trade ETH to WETH, using invalid trade parameters. This leads to a revert during redemption, preventing users from exiting their positions. The impact is a denial of service that can lock user funds in the vault, especially affecting users redeeming shares when the pool contains ETH. This breaks a fundamental user expectation of liquidity and exitability.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol#L205",
                "AbstractSingleSidedLP.sol#L176",
                "AbstractSingleSidedLP.sol#L229"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Users cannot claim rewards when LP tokens are staked directly to Curve Gauge",
            "description": "The vulnerability is in the AbstractRewardManager's _claimVaultRewards function, which fails to handle the case where LP tokens are staked directly to a Curve Gauge without using Convex Booster. The root cause is a conditional check that returns early if rewardPool is address(0), which is the case when staking directly to Gauge. This short-circuits the reward claim process, preventing any rewards from being distributed. The impact is that users who have their LP tokens staked in Curve Gauges are unable to claim their earned rewards, leading to loss of expected yield and reduced protocol trust. This affects all users in strategies that bypass Convex and stake directly to Gauges, effectively locking their rewards indefinitely unless the contract is upgraded.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol#L291-L298",
                "AbstractRewardManager.sol#L190"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/rewards/AbstractRewardManager.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Incompatibility of ERC20::approve with USDT tokens on Ethereum",
            "description": "The vulnerability arises from the use of high-level Solidity calls (e.g., ERC20(token).approve) that expect a boolean return value, which is not returned by certain ERC-20 tokens like USDT on Ethereum. The root cause is the violation of the ERC-20 standard by USDT, which omits the return statement in its approve function. When the Notional protocol calls approve on such tokens, the EVM attempts to decode a return value that does not exist, causing the transaction to revert. This leads to a failure in token approval, preventing users from depositing or interacting with USDT in the protocol. The impact is a denial of service for USDT users, blocking core functionality such as entering positions or migrating assets. This issue affects all operations requiring approval of USDT and similar non-conforming tokens.\n",
            "severity": "Medium",
            "location": [
                "ERC20.sol#L81"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/AbstractLendingRouter.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/MorphoLendingRouter.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/staking/AbstractStakingStrategy.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/withdraws/GenericERC4626.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "USDT approve() reverts due to non-standard return value",
            "description": "The AbstractLendingRouter::_enterOrMigrate, MorphoLendingRouter::_supplyCollateral, AbstractStakingStrategy::_mintYieldToken, and GenericERC4626::_stakeTokens functions use the standard ERC20::approve function to set token allowances. However, the USDT token on Ethereum does not return a boolean value upon approval, which violates the ERC20 standard expectation that approve() returns a bool. As a result, any call to approve() for USDT will revert.\n\nThe root cause is the direct use of IERC20.approve without handling non-conforming implementations like USDT. Additionally, these functions do not first reset the allowance to zero before setting a new one, which is required by USDT's implementation. If the current allowance is non-zero, the approve() call will revert again due to USDT's internal requirement that the previous allowance must be zero.\n\nAn attacker cannot directly exploit this, but any legitimate user attempting to use USDT in core protocol functions (e.g., entering a vault, staking, or migrating) will face transaction reverts. This breaks core functionality for a supported asset.\n\nThe impact is critical because USDT is a primary token the protocol intends to support, and users are unable to perform essential operations when using USDT on Ethereum Mainnet.\n",
            "severity": "Critical",
            "location": [
                "AbstractLendingRouter.sol::deposit#222-245",
                "MorphoLendingRouter.sol::supplyCollateral#150-164",
                "AbstractStakingStrategy.sol::mintYieldToken#77-81",
                "GenericERC4626.sol::stakeTokens#77-81"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/AbstractLendingRouter.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/MorphoLendingRouter.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/staking/AbstractStakingStrategy.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/withdraws/GenericERC4626.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Value of Etherna's Withdrawal Request is incorrect",
            "description": "The protocol prices pending withdrawal requests using the yield token's (e.g., sUSDe) oracle price, even when the underlying asset amount is fixed at initiation. For tokens like sUSDe, where the cooldownShares function converts shares into a predetermined amount of USDe that is escrowed and guaranteed, the value should be based on the fixed USDe amount, not the fluctuating sUSDe price.\n\nThe root cause is that the getWithdrawRequestValue function in AbstractWithdrawRequestManager always uses the yield token price from Chainlink oracles, regardless of whether the yield token is subject to slashing or price changes. This is incorrect for stable staking tokens like sUSDe, where the final payout is fixed upon cooldown initiation.\n\nIf the sUSDe price increases after withdrawal initiation, the protocol overvalues the withdrawal request, making an undercollateralized position appear healthy and preventing timely liquidation. Conversely, if the price drops, it may cause premature liquidation. An attacker could exploit timing to initiate withdrawals when sUSDe is undervalued and borrow excessively against inflated collateral values.\n\nThe impact is high: incorrect valuation can lead to bad debt accumulation due to missed liquidations or unjust liquidations, threatening protocol solvency and user funds.\n",
            "severity": "High",
            "location": [
                "AbstractWithdrawRequestManager.sol::getWithdrawRequestValue#330",
                "StakedUSDeV2.sol::cooldownShares#112-117",
                "Ethena.sol::canFinalizeWithdrawRequest#94-97"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/withdraws/AbstractWithdrawRequestManager.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Loss of reward tokens during initiating withdrawal due to cooldown",
            "description": "When a user initiates a withdrawal, the protocol skips claiming rewards from external protocols if the reward pool is in cooldown. However, the accumulatedRewardPerVaultShare is updated based only on claimed rewards, leading to an outdated state when calculating user rewards.\n\nThe root cause is that _claimVaultRewards in AbstractRewardManager.sol skips external reward claims during cooldown periods, even though this is the last chance for the withdrawing user to claim their entitled rewards. Since effectiveSupply changes after withdrawal initiation, future reward accruals will be based on a different total supply, but the user's final reward is calculated before the supply change using incomplete data.\n\nFor example, if 10 WETH has accrued but only 5 were claimed before withdrawal due to cooldown, the user receives rewards based on 5 WETH instead of 10. The remaining unclaimed rewards are distributed to remaining stakers, effectively redistributing the withdrawing user's share.\n\nThe impact is high, as users initiating withdrawals lose a portion of their earned reward tokens, resulting in direct financial loss.\n",
            "severity": "High",
            "location": [
                "AbstractRewardManager.sol::updateAccountRewards#159",
                "AbstractRewardManager.sol::claimVaultRewards#159",
                "RewardManagerMixin.sol::_initiateWithdraw#131"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/rewards/AbstractRewardManager.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Users will be unfairly liquidated if collateral value drops after initiating withdraw request",
            "description": "After a user initiates a withdrawal request, they are blocked from minting new shares, which also prevents them from depositing additional collateral to avoid liquidation. This occurs because _isWithdrawRequestPending reverts minting if a withdrawal is pending.\n\nThe root cause is the design decision to lock the account from further minting once a withdrawal is initiated, without allowing separate collateral top-ups. While the position remains active and subject to market fluctuations, the user cannot adjust their collateralization ratio during the cooldown period (e.g., 7 days for sUSDe).\n\nIf the value of the collateral drops during this period, the user’s position may become undercollateralized and subject to liquidation. Unlike standard leveraged systems, the user cannot “top up” their margin to avoid this, leading to forced liquidation and loss of funds.\n\nThe impact is high, as users risk losing a portion of their assets to liquidators despite being willing and able to maintain their position, resulting in unfair economic loss.\n",
            "severity": "High",
            "location": [
                "AbstractYieldStrategy.sol::mintShares#197",
                "AbstractYieldStrategy.sol::_isWithdrawRequestPending#197"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/AbstractYieldStrategy.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "User unable to migrate under certain edge case",
            "description": "During migration, the _exitWithRepay function sets assetToRepay to type(uint256).max, which can result in both assetToRepay and sharesToRepay being zero when the user has no debt. This causes the Morpho.repay() call to revert due to the UtilsLib.exactlyOneZero(assets, shares) check, which requires exactly one of the two values to be zero.\n\nThe root cause is the lack of a conditional check to skip repayment when the user has no debt. Since users without debt have zero borrow shares, and assetToRepay is set to max (which Morpho interprets as zero), both parameters become zero, violating Morpho Blue's safety invariant.\n\nAn attacker cannot exploit this, but legitimate users with only collateral and no debt are unable to migrate their positions, leading to a denial of service for a core protocol feature.\n\nThe impact is medium, as it affects a specific edge case (users with no debt), but migration is a critical function for protocol flexibility and user experience.\n",
            "severity": "Medium",
            "location": [
                "AbstractLendingRouter.sol::_exitWithRepay#237",
                "MorphoLendingRouter.sol::repay#192",
                "Morpho.sol::repay#278"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/AbstractLendingRouter.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Unable to deposit to Convex in Arbitrum",
            "description": "The protocol attempts to deposit Curve LP tokens to Convex using the IConvexBooster interface on Arbitrum. However, the deposit function on Arbitrum's Convex Booster contract only accepts two parameters (_pid, _amount), whereas the Ethereum version accepts three parameters (_pid, _amount, _stake). The code calls a three-parameter version on Arbitrum, which does not exist, causing the transaction to revert.\n\nThe root cause is the lack of chain-specific handling for the Convex deposit function interface differences.\n\nAn attacker cannot directly exploit this, but any user attempting to stake LP tokens on Arbitrum will face transaction reverts.\n\nThis renders the protocol non-functional on Arbitrum, preventing users from entering positions and undermining cross-chain compatibility.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol::deposit#291",
                "CurveConvex2Token.sol::constructor#137"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Lack of minimum debt threshold enables unliquidatable small positions",
            "description": "The protocol allows users to partially repay debt via the exitPosition() function, potentially leaving behind minimal debt (e.g., 1 wei). Since liquidation rewards are proportional to repaid debt and gas costs are fixed, liquidators have no economic incentive to liquidate such tiny debts.\n\nThe root cause is the absence of a minimum debt threshold or a mechanism to enforce full repayment before closing a position.\n\nA borrower can strategically leave behind negligible debt after partial repayment, effectively creating an unliquidatable position.\n\nOver time, accumulation of these positions skews the protocol’s debt accounting and may lead to insolvency, especially on high-gas chains like Ethereum.\n",
            "severity": "Medium",
            "location": [
                "AbstractLendingRouter.sol::exitPosition#120",
                "AbstractLendingRouter.sol::_exitWithRepay"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/AbstractLendingRouter.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Funds stuck if one of the withdrawal requests cannot be finalized",
            "description": "The protocol requires all withdrawal requests (WRs) to be finalized before allowing redemption. If one WR fails to finalize due to external factors (e.g., protocol compromise, liquidity issues, slashing events, or zero-asset redemption reverts), the entire withdrawal is blocked—even if other WRs are ready.\n\nThe root cause is the all-or-nothing design in handling multiple WRs and the lack of a minimum position size, which can trigger reverts during redemption (e.g., due to rounding errors in ERC4626 vaults like PirexETH).\n\nAn external event such as a hack or pause in a staking protocol (e.g., LIDO) can prevent finalization of one WR, thereby freezing funds in other WRs.\n\nThis leads to total loss of access to funds, even those unrelated to the failed WR, resulting in high user impact and potential fund loss.\n",
            "severity": "High",
            "location": [
                "AbstractSingleSidedLP.sol::finalizeAndRedeemWithdrawRequest#397",
                "AbstractSingleSidedLP.sol::hasPendingWithdrawals#338"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Setup with asset = WETH and a Curve pool that contains Native ETH will lead to a loss for the users",
            "description": "When a yield strategy uses WETH as its asset and a Curve pool containing Native ETH (e.g., ETH/wstETH), the protocol incorrectly handles token addresses by mapping Native ETH (0xEeeee...) to address(0). This causes the _PRIMARY_INDEX to point to Native ETH, leading to incorrect trade execution during proportional exits.\n\nThe root cause is improper handling of Native ETH in token comparisons and trade routing logic, particularly in _executeRedemptionTrades, where the vault attempts to sell Native ETH it no longer holds (after wrapping to WETH).\n\nDuring withdrawal initiation, the vault wraps all ETH to WETH, leaving zero Native ETH balance. However, the trade logic still tries to sell Native ETH, causing a revert due to insufficient balance.\n\nUsers cannot initiate withdrawals, and during liquidation or position exit, they are forced into single-sided exits on Curve, which incur higher slippage and asset loss when the pool is imbalanced.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::_PRIMARY_INDEX#59",
                "AbstractSingleSidedLP.sol::_executeRedemptionTrades#223",
                "CurveConvex2Token.sol::unstakeAndExitPool#207"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unable to support Curve Pool with Native ETH",
            "description": "When a Curve pool includes Native ETH, the _rewriteAltETH() function converts its address to 0x00000000. Later, during withdrawal or liquidation, the protocol attempts to fetch a Withdraw Request Manager (WRM) for this zero address via ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i])).\n\nThe root cause is the assumption that all tokens have a corresponding WRM, without validating whether the token is a standard ERC20 or Native ETH (which has no WRM).\n\nAny operation that loops through tokens to check pending withdrawals or finalize them (e.g., getWithdrawRequestValue, hasPendingWithdrawals) will revert when encountering Native ETH.\n\nThis breaks core functionality for pools with Native ETH, potentially bricking user accounts by making withdrawals and liquidations impossible, leading to permanently stuck funds.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::_rewriteAltETH#54",
                "AbstractSingleSidedLP.sol::getWithdrawRequestValue#326",
                "AbstractSingleSidedLP.sol::hasPendingWithdrawals#338"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Convex cannot be configured for the Yield Strategy vault in Arbitrum even though Convex is available in Arbitrum",
            "description": "The constructor of CurveConvex2Token checks if block.chainid == CHAIN_ID_MAINNET before configuring the Convex booster and pool ID. This condition prevents the configuration of Convex on Arbitrum, even though Convex is deployed and functional there.\n\nThe root cause is a hardcoded chain ID check that excludes Arbitrum from Convex integration, despite it being in scope per the contest README.\n\nAs a result, yield strategies on Arbitrum cannot leverage Convex staking, limiting yield potential and rendering the Convex integration unusable on that chain.\n\nThis breaks intended cross-chain functionality and reduces capital efficiency for Arbitrum users.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol::constructor#137"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Revert in getWithdrawRequestValue Can Freeze Account Positions",
            "description": "The getWithdrawRequestValue function in AbstractSingleSidedLP.sol reverts if no withdraw request exists for any of the pool tokens (Line 332). This revert can be triggered when a token's exit balance is zero, which can occur due to rounding down during proportional withdrawal, especially for tokens with low decimals or in cases of near-total asset swaps or depeg events.\n\nThe root cause is the lack of a conditional check to skip tokens with zero withdrawal amounts instead of requiring a withdraw request to exist. Since Notional's price() function depends on getWithdrawRequestValue(), a revert here will cause the entire price calculation to fail.\n\nAn attacker could exploit this by manipulating pool balances (e.g., via large swaps) to force a zero exit balance for a token, thereby ensuring any call to price() reverts. This would prevent any interaction with affected accounts.\n\nThe impact is severe: affected accounts become permanently stuck, as no operations (repay, withdraw, liquidate, exit) can proceed if the price oracle reverts. This leads to a denial of service for user positions and potential permanent loss of access to funds.\n",
            "severity": "Critical",
            "location": [
                "AbstractSingleSidedLP.sol::getWithdrawRequestValue#332",
                "AbstractSingleSidedLP.sol::getWithdrawRequestValue#362"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "initializeMarket Can Be Frontran, Preventing Markets From Being Configured in MorphoLendingRouter",
            "description": "The initializeMarket function in MorphoLendingRouter.sol can be frontran by an attacker who calls Morpho's createMarket() with the same market parameters before the legitimate initialization. This is possible because initializeMarket does not use try/catch and assumes it will always succeed in creating the market.\n\nThe root cause is the lack of error handling for market creation. Since Morpho enforces that each market can only be created once, a malicious actor can preemptively create the market, causing the legitimate initializeMarket call to revert.\n\nAn attacker can monitor the mempool for calls to initializeMarket and quickly submit a transaction calling createMarket directly with identical parameters. This would block the router from storing the market configuration in s_morphoParams.\n\nThe impact is medium: it results in a denial of service for market initialization, preventing the router from supporting the affected vault. While the issue is recoverable via an upgrade (as noted in discussion), it still disrupts normal operations and requires manual intervention, reducing system reliability and autonomy.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::initializeMarket#51"
            ],
            "files": [
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/routers/MorphoLendingRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "UniV3Adapter.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Deployments} from \"@deployments/Deployments.sol\";\nimport {TradeHandler} from \"../TradeHandler.sol\";\nimport \"@interfaces/trading/ITradingModule.sol\";\nimport \"@interfaces/uniswap/v3/ISwapRouter.sol\";\n\nlibrary UniV3Adapter {\n\n    struct UniV3SingleData { uint24 fee; }\n\n    // Path is packed encoding `token, fee, token, fee, outToken`\n    struct UniV3BatchData { bytes path; }\n\n    function _toAddress(bytes memory _bytes, uint256 _start) private pure returns (address) {\n        // _bytes.length checked by the caller\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function _getTokenAddress(address token) internal pure returns (address) {\n        return token == Deployments.ETH_ADDRESS ? address(Deployments.WETH) : token;\n    }\n\n    function _exactInSingle(address from, Trade memory trade)\n        private pure returns (bytes memory)\n    {\n        UniV3SingleData memory data = abi.decode(trade.exchangeData, (UniV3SingleData));\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\n            _getTokenAddress(trade.sellToken), \n            _getTokenAddress(trade.buyToken), \n            data.fee, from, trade.deadline, trade.amount, trade.limit, 0 // sqrtPriceLimitX96\n        );\n\n        return abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector, params);\n    }\n\n    function _exactOutSingle(address from, Trade memory trade) private pure returns (bytes memory) {\n        UniV3SingleData memory data = abi.decode(trade.exchangeData, (UniV3SingleData));\n\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\n            _getTokenAddress(trade.sellToken), \n            _getTokenAddress(trade.buyToken), \n            data.fee, from, trade.deadline, trade.amount, trade.limit, 0 // sqrtPriceLimitX96\n        );\n\n        return abi.encodeWithSelector(ISwapRouter.exactOutputSingle.selector, params);\n    }\n\n    function _exactInBatch(address from, Trade memory trade) private pure returns (bytes memory) {\n        UniV3BatchData memory data = abi.decode(trade.exchangeData, (UniV3BatchData));\n\n        // Validate path EXACT_IN = [sellToken, fee, ... buyToken]\n        require(32 <= data.path.length);\n        require(_toAddress(data.path, 0) == _getTokenAddress(trade.sellToken));\n        require(_toAddress(data.path, data.path.length - 20) == _getTokenAddress(trade.buyToken));\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams(\n            data.path, from, trade.deadline, trade.amount, trade.limit\n        );\n\n        return abi.encodeWithSelector(ISwapRouter.exactInput.selector, params);\n    }\n\n    function _exactOutBatch(address from, Trade memory trade) private pure returns (bytes memory) {\n        UniV3BatchData memory data = abi.decode(trade.exchangeData, (UniV3BatchData));\n\n        // Validate path EXACT_OUT = [buyToken, fee, ... sellToken]\n        require(32 <= data.path.length);\n        require(_toAddress(data.path, 0) == _getTokenAddress(trade.buyToken));\n        require(_toAddress(data.path, data.path.length - 20) == _getTokenAddress(trade.sellToken));\n\n        ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams(\n            data.path, from, trade.deadline, trade.amount, trade.limit\n        );\n\n        return abi.encodeWithSelector(ISwapRouter.exactOutput.selector, params);\n    }\n\n    function getExecutionData(address from, Trade memory trade)\n        internal pure returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        spender = address(Deployments.UNIV3_ROUTER);\n        target = address(Deployments.UNIV3_ROUTER);\n        // msgValue is always zero for uniswap\n        msgValue = 0;\n\n        if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n            executionCallData = _exactInSingle(from, trade);\n        } else if (trade.tradeType == TradeType.EXACT_OUT_SINGLE) {\n            executionCallData = _exactOutSingle(from, trade);\n        } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n            executionCallData = _exactInBatch(from, trade);\n        } else if (trade.tradeType == TradeType.EXACT_OUT_BATCH) {\n            executionCallData = _exactOutBatch(from, trade);\n        }\n    }\n}",
        "IRewardManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nstruct VaultRewardState {\n    address rewardToken;\n    uint32 lastAccumulatedTime;\n    uint32 endTime;\n    // Slot #2\n    // If secondary rewards are enabled, they will be streamed to the accounts via\n    // an annual emission rate. If the same reward token is also issued by the LP pool,\n    // those tokens will be added on top of the annual emission rate. If the vault is under\n    // automatic reinvestment mode, the secondary reward token cannot be sold.\n    uint128 emissionRatePerYear; // in internal token precision\n    uint128 accumulatedRewardPerVaultShare;\n}\n\nenum RewardPoolType {\n    _UNUSED,\n    AURA,\n    CONVEX_MAINNET,\n    CONVEX_ARBITRUM\n}\n\nstruct RewardPoolStorage {\n    address rewardPool;\n    uint32 lastClaimTimestamp;\n    uint32 forceClaimAfter;\n}\n\n/// Each reward manager is responsible for claiming rewards for a given protocol.\n/// it will be called through a delegatecall from the vault to avoid token transfers\n/// of staked tokens.\ninterface IRewardManager {\n\n    event VaultRewardTransfer(address token, address account, uint256 amount);\n    event VaultRewardUpdate(address rewardToken, uint128 emissionRatePerYear, uint32 endTime);\n\n    /// @notice Returns the current reward claim method and reward state\n    /// @return rewardStates Array of vault reward states\n    /// @return rewardPool Reward pool storage\n    function getRewardSettings() external view returns (\n        VaultRewardState[] memory rewardStates,\n        RewardPoolStorage memory rewardPool\n    );\n\n    /// @notice Returns the reward debt for the given reward token and account\n    /// @param rewardToken Address of the reward token\n    /// @param account Address of the account\n    /// @return rewardDebt The reward debt for the account\n    function getRewardDebt(address rewardToken, address account) external view returns (\n        uint256 rewardDebt\n    );\n\n\n    /// @notice Updates account rewards during enter and exit vault operations, only\n    /// callable via delegatecall from inside the vault\n    /// @param account Address of the account\n    /// @param effectiveSupplyBefore Total vault shares before the operation\n    /// @param accountSharesBefore Number of shares before the operation\n    /// @param accountSharesAfter Number of shares after the operation\n    /// @param sharesInEscrow Whether the shares are in escrow\n    function updateAccountRewards(\n        address account,\n        uint256 effectiveSupplyBefore,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        bool sharesInEscrow\n    ) external returns (uint256[] memory rewards);\n\n    /// @notice Sets a secondary reward rate for a given token, only callable via the owner\n    /// @param index Index of the reward token\n    /// @param rewardToken Address of the reward token\n    /// @param emissionRatePerYear Emission rate per year for the token\n    /// @param endTime End time for the emission rate\n    function updateRewardToken(\n        uint256 index,\n        address rewardToken,\n        uint128 emissionRatePerYear,\n        uint32 endTime\n    ) external;\n\n    /// @notice Migrates the reward pool to a new reward pool, needs to be called initially\n    /// to set the reward pool storage and when the reward pool is updated.\n    /// @param poolToken The pool token to migrate\n    /// @param newRewardPool The new reward pool storage configuration\n    function migrateRewardPool(address poolToken, RewardPoolStorage memory newRewardPool) external;\n\n    /// @notice Claims all the rewards for the entire vault and updates the accumulators\n    function claimRewardTokens() external;\n}",
        "AbstractRewardManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ReentrancyGuardTransient} from \"@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IRewardManager.sol\";\nimport {IYieldStrategy} from \"../interfaces/IYieldStrategy.sol\";\nimport {Unauthorized} from \"../interfaces/Errors.sol\";\nimport {DEFAULT_PRECISION, ADDRESS_REGISTRY, YEAR} from \"../utils/Constants.sol\";\nimport {TypeConvert} from \"../utils/TypeConvert.sol\";\nimport {IEIP20NonStandard} from \"../interfaces/IEIP20NonStandard.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\n\nabstract contract AbstractRewardManager is IRewardManager, ReentrancyGuardTransient {\n    using TypeConvert for uint256;\n    using TokenUtils for ERC20;\n\n    modifier onlyUpgradeAdmin() {\n        if (msg.sender != ADDRESS_REGISTRY.upgradeAdmin()) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    // Uses custom storage slots to avoid collisions with other contracts\n    uint256 private constant REWARD_POOL_SLOT = 1000001;\n    uint256 private constant VAULT_REWARD_STATE_SLOT = 1000002;\n    uint256 private constant ACCOUNT_REWARD_DEBT_SLOT = 1000003;\n    uint256 private constant ACCOUNT_ESCROW_STATE_SLOT = 1000004;\n\n    function _getRewardPoolSlot() internal pure returns (RewardPoolStorage storage store) {\n        assembly { store.slot := REWARD_POOL_SLOT }\n    }\n\n    function _getVaultRewardStateSlot() internal pure returns (VaultRewardState[] storage store) {\n        assembly { store.slot := VAULT_REWARD_STATE_SLOT }\n    }\n\n    function _getAccountRewardDebtSlot() internal pure returns (\n        mapping(address account => mapping(address rewardToken => uint256 rewardDebt)) storage store\n    ) {\n        assembly { store.slot := ACCOUNT_REWARD_DEBT_SLOT }\n    }\n\n    /// @inheritdoc IRewardManager\n    function migrateRewardPool(address poolToken, RewardPoolStorage memory newRewardPool) external override onlyUpgradeAdmin nonReentrant {\n        // Claim all rewards from the previous reward pool before withdrawing\n        uint256 effectiveSupplyBefore = IYieldStrategy(address(this)).effectiveSupply();\n        _claimVaultRewards(effectiveSupplyBefore, _getVaultRewardStateSlot());\n        RewardPoolStorage memory oldRewardPool = _getRewardPoolSlot();\n\n        if (oldRewardPool.rewardPool != address(0)) {\n            _withdrawFromPreviousRewardPool(oldRewardPool);\n\n            // Clear approvals on the old pool.\n            ERC20(poolToken).checkRevoke(address(oldRewardPool.rewardPool));\n        }\n\n        uint256 poolTokens = ERC20(poolToken).balanceOf(address(this));\n        _depositIntoNewRewardPool(poolToken, poolTokens, newRewardPool);\n\n        // Set the last claim timestamp to the current block timestamp since we re claiming all the rewards\n        // earlier in this method.\n        _getRewardPoolSlot().lastClaimTimestamp = uint32(block.timestamp);\n        _getRewardPoolSlot().rewardPool = newRewardPool.rewardPool;\n        _getRewardPoolSlot().forceClaimAfter = newRewardPool.forceClaimAfter;\n    }\n\n\n    /// @inheritdoc IRewardManager\n    function getRewardSettings() external view override returns (\n        VaultRewardState[] memory rewardStates,\n        RewardPoolStorage memory rewardPool\n    ) {\n        rewardStates = _getVaultRewardStateSlot();\n        rewardPool = _getRewardPoolSlot();\n    }\n\n    /// @inheritdoc IRewardManager\n    function getRewardDebt(address rewardToken, address account) external view override returns (uint256) {\n        return _getAccountRewardDebtSlot()[rewardToken][account];\n    }\n\n    /// @inheritdoc IRewardManager\n    function updateRewardToken(\n        uint256 index,\n        address rewardToken,\n        uint128 emissionRatePerYear,\n        uint32 endTime\n    ) external override onlyUpgradeAdmin {\n        uint256 effectiveSupplyBefore = IYieldStrategy(address(this)).effectiveSupply();\n        uint256 numRewardStates = _getVaultRewardStateSlot().length;\n\n        if (index < numRewardStates) {\n            VaultRewardState memory state = _getVaultRewardStateSlot()[index];\n            // Safety check to ensure that the correct token is specified, we can never change the\n            // token address once set.\n            require(state.rewardToken == rewardToken);\n            // Modifies the emission rate on an existing token, direct claims of the token will\n            // not be affected by the emission rate.\n            // First accumulate under the old regime up to the current time. Even if the previous\n            // emissionRatePerYear is zero this will still set the lastAccumulatedTime to the current\n            // blockTime.\n            _accumulateSecondaryRewardViaEmissionRate(index, state, effectiveSupplyBefore);\n\n            // Save the new emission rates\n            state.emissionRatePerYear = emissionRatePerYear;\n            if (state.emissionRatePerYear == 0) {\n                state.endTime = 0;\n            } else {\n                require(block.timestamp < endTime);\n                state.endTime = endTime;\n            }\n            _getVaultRewardStateSlot()[index] = state;\n        } else if (index == numRewardStates) {\n            // This sets a new reward token, ensure that the current slot is empty\n            VaultRewardState[] storage states = _getVaultRewardStateSlot();\n            // If no emission rate is set then governance is just adding a token that can be claimed\n            // via the LP tokens without an emission rate. These settings will be left empty and the\n            // subsequent _claimVaultRewards method will set the initial accumulatedRewardPerVaultShare.\n            if (0 < emissionRatePerYear) require(block.timestamp < endTime);\n\n            states.push(VaultRewardState({\n                rewardToken: rewardToken,\n                lastAccumulatedTime: uint32(block.timestamp),\n                endTime: endTime,\n                emissionRatePerYear: emissionRatePerYear,\n                accumulatedRewardPerVaultShare: 0\n            }));\n        } else {\n            // Can only append or modify existing tokens\n            revert();\n        }\n\n        // Claim all vault rewards up to the current time\n        _claimVaultRewards(effectiveSupplyBefore, _getVaultRewardStateSlot());\n        emit VaultRewardUpdate(rewardToken, emissionRatePerYear, endTime);\n    }\n\n    /// @notice Claims all the rewards for the entire vault and updates the accumulators. Does not\n    /// update emission rewarders since those are automatically updated on every account claim.\n    function claimRewardTokens() external nonReentrant {\n        // This method is not executed from inside enter or exit vault positions, so this total\n        // vault shares value is valid.\n        uint256 effectiveSupplyBefore = IYieldStrategy(address(this)).effectiveSupply();\n        _claimVaultRewards(effectiveSupplyBefore, _getVaultRewardStateSlot());\n    }\n\n    /// @inheritdoc IRewardManager\n    function updateAccountRewards(\n        address account,\n        uint256 effectiveSupplyBefore,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        bool sharesInEscrow\n    ) external returns (uint256[] memory rewards) {\n        // Short circuit in this case, no rewards to claim\n        if (sharesInEscrow && accountSharesAfter > 0) return rewards;\n\n        VaultRewardState[] memory state = _getVaultRewardStateSlot();\n        _claimVaultRewards(effectiveSupplyBefore, state);\n        rewards = new uint256[](state.length);\n\n        for (uint256 i; i < state.length; i++) {\n            if (sharesInEscrow && accountSharesAfter == 0) {\n                delete _getAccountRewardDebtSlot()[state[i].rewardToken][account];\n                continue;\n            }\n\n            if (0 < state[i].emissionRatePerYear) {\n                // Accumulate any rewards with an emission rate here\n                _accumulateSecondaryRewardViaEmissionRate(i, state[i], effectiveSupplyBefore);\n            }\n\n            rewards[i] = _claimRewardToken(\n                state[i].rewardToken,\n                account,\n                accountSharesBefore,\n                accountSharesAfter,\n                state[i].accumulatedRewardPerVaultShare\n            );\n        }\n    }\n\n    /// @notice Executes a claim against the given reward pool type and updates internal\n    /// rewarder accumulators.\n    function _claimVaultRewards(\n        uint256 effectiveSupplyBefore,\n        VaultRewardState[] memory state\n    ) internal {\n        RewardPoolStorage memory rewardPool = _getRewardPoolSlot();\n        if (rewardPool.rewardPool == address(0)) return;\n        if (block.timestamp < rewardPool.lastClaimTimestamp + rewardPool.forceClaimAfter) return;\n\n        uint256[] memory balancesBefore = new uint256[](state.length);\n        // Run a generic call against the reward pool and then do a balance\n        // before and after check.\n        for (uint256 i; i < state.length; i++) {\n            // Presumes that ETH will never be given out as a reward token.\n            balancesBefore[i] = ERC20(state[i].rewardToken).balanceOf(address(this));\n        }\n\n        _executeClaim();\n\n        _getRewardPoolSlot().lastClaimTimestamp = uint32(block.timestamp);\n\n        // This only accumulates rewards claimed, it does not accumulate any secondary emissions\n        // that are streamed to vault users.\n        for (uint256 i; i < state.length; i++) {\n            uint256 balanceAfter = ERC20(state[i].rewardToken).balanceOf(address(this));\n            _accumulateSecondaryRewardViaClaim(\n                i,\n                state[i],\n                // balanceAfter should never be less than balanceBefore\n                balanceAfter - balancesBefore[i],\n                effectiveSupplyBefore\n            );\n        }\n    }\n\n\n    /** Reward Claim Methods **/\n\n    function _claimRewardToken(\n        address rewardToken,\n        address account,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        uint256 rewardsPerVaultShare\n    ) internal returns (uint256 rewardToClaim) {\n        // Vault shares are always in DEFAULT_PRECISION\n        uint256 rewardDebt = _getAccountRewardDebtSlot()[rewardToken][account];\n        rewardToClaim = ((accountSharesBefore * rewardsPerVaultShare) / DEFAULT_PRECISION) - rewardDebt;\n        _getAccountRewardDebtSlot()[rewardToken][account] = (\n            (accountSharesAfter * rewardsPerVaultShare) / DEFAULT_PRECISION\n        );\n\n        if (0 < rewardToClaim) {\n            // Ignore transfer errors here so that any strange failures here do not\n            // prevent normal vault operations from working. Failures may include a\n            // lack of balances or some sort of blacklist that prevents an account\n            // from receiving tokens.\n            if (rewardToken.code.length > 0) {\n                try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n                    bool success = TokenUtils.checkReturnCode();\n                    if (success) {\n                        emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n                    } else {\n                        emit VaultRewardTransfer(rewardToken, account, 0);\n                    }\n                // Emits zero tokens transferred if the transfer fails.\n                } catch {\n                    emit VaultRewardTransfer(rewardToken, account, 0);\n                }\n            }\n        }\n    }\n\n    /*** ACCUMULATORS  ***/\n\n    function _accumulateSecondaryRewardViaClaim(\n        uint256 index,\n        VaultRewardState memory state,\n        uint256 tokensClaimed,\n        uint256 effectiveSupplyBefore\n    ) private {\n        if (tokensClaimed == 0) return;\n\n        state.accumulatedRewardPerVaultShare += (\n            (tokensClaimed * DEFAULT_PRECISION) / effectiveSupplyBefore\n        ).toUint128();\n\n        _getVaultRewardStateSlot()[index] = state;\n    }\n\n    function _accumulateSecondaryRewardViaEmissionRate(\n        uint256 index,\n        VaultRewardState memory state,\n        uint256 effectiveSupplyBefore\n    ) private {\n        state.accumulatedRewardPerVaultShare = _getAccumulatedRewardViaEmissionRate(\n            state, effectiveSupplyBefore, block.timestamp\n        ).toUint128();\n        state.lastAccumulatedTime = uint32(block.timestamp);\n\n        _getVaultRewardStateSlot()[index] = state;\n    }\n\n    function _getAccumulatedRewardViaEmissionRate(\n        VaultRewardState memory state,\n        uint256 effectiveSupplyBefore,\n        uint256 blockTime\n    ) private pure returns (uint256) {\n        // Short circuit the method with no emission rate\n        if (state.emissionRatePerYear == 0) return state.accumulatedRewardPerVaultShare;\n        require(0 < state.endTime);\n        uint256 time = blockTime < state.endTime ? blockTime : state.endTime;\n\n        uint256 additionalIncentiveAccumulatedPerVaultShare;\n        if (state.lastAccumulatedTime < time && 0 < effectiveSupplyBefore) {\n            // NOTE: no underflow, checked in if statement\n            uint256 timeSinceLastAccumulation = time - state.lastAccumulatedTime;\n            // Precision here is:\n            //  timeSinceLastAccumulation (SECONDS)\n            //  emissionRatePerYear (REWARD_TOKEN_PRECISION)\n            //  DEFAULT_PRECISION (1e18)\n            // DIVIDE BY\n            //  YEAR (SECONDS)\n            //  DEFAULT_PRECISION (1e18)\n            // => Precision = REWARD_TOKEN_PRECISION\n            additionalIncentiveAccumulatedPerVaultShare = (timeSinceLastAccumulation * DEFAULT_PRECISION * state.emissionRatePerYear)\n                / (YEAR * effectiveSupplyBefore);\n        }\n\n        return state.accumulatedRewardPerVaultShare + additionalIncentiveAccumulatedPerVaultShare;\n    }\n\n    /// @notice Executes the proper call for various rewarder types.\n    function _executeClaim() internal virtual;\n    function _withdrawFromPreviousRewardPool(RewardPoolStorage memory oldRewardPool) internal virtual;\n    function _depositIntoNewRewardPool(address poolToken, uint256 poolTokens, RewardPoolStorage memory newRewardPool) internal virtual;\n}",
        "Constants.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {WETH9} from \"../interfaces/IWETH.sol\";\nimport {AddressRegistry} from \"../proxy/AddressRegistry.sol\";\n\naddress constant ETH_ADDRESS = address(0);\naddress constant ALT_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\nuint256 constant DEFAULT_PRECISION = 1e18;\nuint256 constant DEFAULT_DECIMALS = 18;\n\nuint256 constant COOLDOWN_PERIOD = 5 minutes;\nuint256 constant YEAR = 365 days;\n\n\n\n// TODO: move these to a deployment file\nuint256 constant CHAIN_ID_MAINNET = 1;\nWETH9 constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\nAddressRegistry constant ADDRESS_REGISTRY = AddressRegistry(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f);",
        "AbstractLendingRouter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ILendingRouter, VaultPosition} from \"../interfaces/ILendingRouter.sol\";\nimport {\n    NotAuthorized,\n    CannotExitPositionWithinCooldownPeriod,\n    CannotInitiateWithdraw,\n    CannotForceWithdraw,\n    InvalidLendingRouter,\n    NoExistingPosition,\n    LiquidatorHasPosition,\n    CannotEnterPosition,\n    CannotLiquidateZeroShares,\n    InsufficientSharesHeld\n} from \"../interfaces/Errors.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IYieldStrategy} from \"../interfaces/IYieldStrategy.sol\";\nimport {RewardManagerMixin} from \"../rewards/RewardManagerMixin.sol\";\nimport {ILendingRouter} from \"../interfaces/ILendingRouter.sol\";\nimport {ADDRESS_REGISTRY, COOLDOWN_PERIOD} from \"../utils/Constants.sol\";\n\nabstract contract AbstractLendingRouter is ILendingRouter {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    mapping(address user => mapping(address operator => bool approved)) private s_isApproved;\n\n    /*** Authorization Methods ***/\n    modifier isAuthorized(address onBehalf, address vault) {\n        // In this case msg.sender is the operator\n        if (msg.sender != onBehalf && !isApproved(onBehalf, msg.sender)) {\n            revert NotAuthorized(msg.sender, onBehalf);\n        }\n\n        _;\n\n        // Clear the current account after the transaction is finished\n        IYieldStrategy(vault).clearCurrentAccount();\n    }\n\n    /// @inheritdoc ILendingRouter\n    function setApproval(address operator, bool approved) external override {\n        if (operator == msg.sender) revert NotAuthorized(msg.sender, operator);\n        s_isApproved[msg.sender][operator] = approved;\n    }\n\n    /// @inheritdoc ILendingRouter\n    function isApproved(address user, address operator) public view override returns (bool) {\n        return s_isApproved[user][operator];\n    }\n\n    /// @inheritdoc ILendingRouter\n    function enterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes calldata depositData\n    ) public override isAuthorized(onBehalf, vault) {\n        _enterPosition(onBehalf, vault, depositAssetAmount, borrowAmount, depositData, address(0));\n    }\n\n    /// @inheritdoc ILendingRouter\n    function migratePosition(\n        address onBehalf,\n        address vault,\n        address migrateFrom\n    ) public override isAuthorized(onBehalf, vault) {\n        if (!ADDRESS_REGISTRY.isLendingRouter(migrateFrom)) revert InvalidLendingRouter();\n        // Borrow amount is set to the amount of debt owed to the previous lending router\n        (uint256 borrowAmount, /* */, /* */) = ILendingRouter(migrateFrom).healthFactor(onBehalf, vault);\n\n        _enterPosition(onBehalf, vault, 0, borrowAmount, bytes(\"\"), migrateFrom);\n    }\n\n    function _enterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal {\n        address asset = IYieldStrategy(vault).asset();\n        // Cannot enter a position if the account already has a native share balance\n        if (IYieldStrategy(vault).balanceOf(onBehalf) > 0) revert CannotEnterPosition();\n\n        if (depositAssetAmount > 0) {\n            // Take any margin deposit from the sender initially\n            ERC20(asset).safeTransferFrom(msg.sender, address(this), depositAssetAmount);\n        }\n\n        if (borrowAmount > 0) {\n            _flashBorrowAndEnter(\n                onBehalf, vault, asset, depositAssetAmount, borrowAmount, depositData, migrateFrom\n            );\n        } else {\n            _enterOrMigrate(onBehalf, vault, asset, depositAssetAmount, depositData, migrateFrom);\n        }\n\n        ADDRESS_REGISTRY.setPosition(onBehalf, vault);\n    }\n\n    /// @inheritdoc ILendingRouter\n    function exitPosition(\n        address onBehalf,\n        address vault,\n        address receiver,\n        uint256 sharesToRedeem,\n        uint256 assetToRepay,\n        bytes calldata redeemData\n    ) external override isAuthorized(onBehalf, vault) {\n        _checkExit(onBehalf, vault);\n\n        address asset = IYieldStrategy(vault).asset();\n        if (0 < assetToRepay) {\n            _exitWithRepay(onBehalf, vault, asset, receiver, sharesToRedeem, assetToRepay, redeemData);\n        } else {\n            address migrateTo = _isMigrate(receiver) ? receiver : address(0);\n            uint256 assetsWithdrawn = _redeemShares(onBehalf, vault, asset, migrateTo, sharesToRedeem, redeemData);\n            if (0 < assetsWithdrawn) ERC20(asset).safeTransfer(receiver, assetsWithdrawn);\n        }\n\n        if (balanceOfCollateral(onBehalf, vault) == 0) {\n            ADDRESS_REGISTRY.clearPosition(onBehalf, vault);\n        }\n    }\n\n    /// @inheritdoc ILendingRouter\n    function liquidate(\n        address liquidateAccount,\n        address vault,\n        uint256 sharesToLiquidate,\n        uint256 debtToRepay\n    ) external override returns (uint256 sharesToLiquidator) {\n        if (sharesToLiquidate == 0) revert CannotLiquidateZeroShares();\n\n        address liquidator = msg.sender;\n        VaultPosition memory position = ADDRESS_REGISTRY.getVaultPosition(liquidator, vault);\n        // If the liquidator has a position then they cannot liquidate or they will have\n        // a native balance and a balance on the lending market.\n        if (position.lendingRouter != address(0)) revert LiquidatorHasPosition();\n\n        uint256 balanceBefore = balanceOfCollateral(liquidateAccount, vault);\n        if (balanceBefore == 0) revert InsufficientSharesHeld();\n\n        // Runs any checks on the vault to ensure that the liquidation can proceed, whitelists the lending platform\n        // to transfer collateral to the lending router. The current account is set in this method.\n        IYieldStrategy(vault).preLiquidation(liquidator, liquidateAccount, sharesToLiquidate, balanceBefore);\n\n        // After this call, address(this) will have the liquidated shares\n        sharesToLiquidator = _liquidate(liquidator, vault, liquidateAccount, sharesToLiquidate, debtToRepay);\n\n        // Transfers the shares to the liquidator from the lending router and does any post liquidation logic. The\n        // current account is cleared in this method.\n        IYieldStrategy(vault).postLiquidation(liquidator, liquidateAccount, sharesToLiquidator);\n\n        // The liquidator will receive shares in their native balance and then they can call redeem\n        // on the yield strategy to get the assets.\n\n        // Clear the position if the liquidator has taken all the shares, in the case of an insolvency,\n        // the account's position will just be left on the lending market with zero collateral. The account\n        // would be able to create a new position on this lending router or a new position on a different\n        // lending router. If they do create a new position on an insolvent account their old debt may\n        // be applied to their new position.\n        if (sharesToLiquidator == balanceBefore) ADDRESS_REGISTRY.clearPosition(liquidateAccount, vault);\n    }\n\n    /// @inheritdoc ILendingRouter\n    function initiateWithdraw(\n        address onBehalf,\n        address vault,\n        bytes calldata data\n    ) external override isAuthorized(onBehalf, vault) returns (uint256 requestId) {\n        requestId = _initiateWithdraw(vault, onBehalf, data);\n    }\n\n    /// @inheritdoc ILendingRouter\n    function forceWithdraw(address account, address vault, bytes calldata data) external returns (uint256 requestId) {\n        // Can only force a withdraw if health factor is negative, this allows a liquidator to\n        // force a withdraw and liquidate a position at a later time.\n        (uint256 borrowed, /* */, uint256 maxBorrow) = healthFactor(account, vault);\n        if (borrowed <= maxBorrow) revert CannotForceWithdraw(account);\n\n        requestId = _initiateWithdraw(vault, account, data);\n\n        // Clear the current account since this method is not called using isAuthorized\n        IYieldStrategy(vault).clearCurrentAccount();\n    }\n\n    /// @inheritdoc ILendingRouter\n    function claimRewards(address vault) external returns (uint256[] memory rewards) {\n        return RewardManagerMixin(vault).claimAccountRewards(msg.sender, balanceOfCollateral(msg.sender, vault));\n    }\n\n    /// @inheritdoc ILendingRouter\n    function healthFactor(address borrower, address vault) public override virtual returns (uint256 borrowed, uint256 collateralValue, uint256 maxBorrow);\n\n    /// @inheritdoc ILendingRouter\n    function balanceOfCollateral(address account, address vault) public override view virtual returns (uint256 collateralBalance);\n\n\n    /*** Internal Methods ***/\n\n    function _checkExit(address onBehalf, address vault) internal view  {\n        VaultPosition memory position = ADDRESS_REGISTRY.getVaultPosition(onBehalf, vault);\n        if (position.lendingRouter != address(this)) revert NoExistingPosition();\n        if (block.timestamp - position.lastEntryTime < COOLDOWN_PERIOD) {\n            revert CannotExitPositionWithinCooldownPeriod();\n        }\n    }\n\n    /// @dev Checks if an exitPosition call is a migration, this would be called via a lending router\n    function _isMigrate(address receiver) internal view returns (bool) {\n        return receiver == msg.sender && ADDRESS_REGISTRY.isLendingRouter(msg.sender);\n    }\n\n    /// @dev Enters a position or migrates shares from a previous lending router\n    function _enterOrMigrate(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 assetAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal returns (uint256 sharesReceived) {\n        if (migrateFrom != address(0)) {\n            // Allow the previous lending router to repay the debt from assets held here.\n            ERC20(asset).checkApprove(migrateFrom, assetAmount);\n            sharesReceived = ILendingRouter(migrateFrom).balanceOfCollateral(onBehalf, vault);\n\n            // Must migrate the entire position\n            ILendingRouter(migrateFrom).exitPosition(\n                onBehalf, vault, address(this), sharesReceived, type(uint256).max, bytes(\"\")\n            );\n        } else {\n            ERC20(asset).approve(vault, assetAmount);\n            sharesReceived = IYieldStrategy(vault).mintShares(assetAmount, onBehalf, depositData);\n        }\n\n        _supplyCollateral(onBehalf, vault, asset, sharesReceived);\n    }\n\n    /// @dev Redeems or withdraws shares from the lending market, handles migration\n    function _redeemShares(\n        address sharesOwner,\n        address vault,\n        address asset,\n        address migrateTo,\n        uint256 sharesToRedeem,\n        bytes memory redeemData\n    ) internal returns (uint256 assetsWithdrawn) {\n        address receiver = migrateTo == address(0) ? sharesOwner : migrateTo;\n        uint256 sharesHeld = balanceOfCollateral(sharesOwner, vault);\n\n        // Allows the transfer from the lending market to the sharesOwner\n        IYieldStrategy(vault).allowTransfer(receiver, sharesToRedeem, sharesOwner);\n        _withdrawCollateral(vault, asset, sharesToRedeem, sharesOwner, receiver);\n\n        // If we are not migrating then burn the shares\n        if (migrateTo == address(0)) {\n            assetsWithdrawn = IYieldStrategy(vault).burnShares(\n                sharesOwner, sharesToRedeem, sharesHeld, redeemData\n            );\n        }\n    }\n\n    /// @dev Initiates a withdraw request for the vault shares held by the account\n    function _initiateWithdraw(\n        address vault,\n        address account,\n        bytes calldata data\n    ) internal returns (uint256 requestId) {\n        uint256 sharesHeld = balanceOfCollateral(account, vault);\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n        return IYieldStrategy(vault).initiateWithdraw(account, sharesHeld, data);\n    }\n\n    /*** Virtual Methods (lending market specific) ***/\n\n    /// @dev Flash borrows the assets and enters a position\n    function _flashBorrowAndEnter(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal virtual;\n\n    /// @dev Supplies collateral in the amount of shares received to the lending market\n    function _supplyCollateral(\n        address onBehalf, address vault, address asset, uint256 sharesReceived\n    ) internal virtual;\n\n    /// @dev Withdraws collateral from the lending market\n    function _withdrawCollateral(\n        address vault,\n        address asset,\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        address receiver\n    ) internal virtual;\n\n    /// @dev Liquidates a position on the lending market\n    function _liquidate(\n        address liquidator,\n        address vault,\n        address liquidateAccount,\n        uint256 sharesToLiquidate,\n        uint256 debtToRepay\n    ) internal virtual returns (uint256 sharesToLiquidator);\n\n    /// @dev Exits a position with a debt repayment\n    function _exitWithRepay(\n        address onBehalf,\n        address vault,\n        address asset,\n        address receiver,\n        uint256 sharesToRedeem,\n        uint256 assetToRepay,\n        bytes calldata redeemData\n    ) internal virtual;\n\n}",
        "MorphoLendingRouter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ILendingRouter} from \"../interfaces/ILendingRouter.sol\";\nimport {InsufficientAssetsForRepayment} from \"../interfaces/Errors.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IYieldStrategy} from \"../interfaces/IYieldStrategy.sol\";\nimport {IMorphoLiquidateCallback, IMorphoFlashLoanCallback, IMorphoRepayCallback} from \"../interfaces/Morpho/IMorphoCallbacks.sol\";\nimport {ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {AbstractLendingRouter} from \"./AbstractLendingRouter.sol\";\nimport {\n    MORPHO,\n    MarketParams,\n    Id,\n    Position,\n    Market,\n    Withdrawal,\n    PUBLIC_ALLOCATOR\n} from \"../interfaces/Morpho/IMorpho.sol\";\n\nstruct MorphoParams {\n    address irm;\n    uint256 lltv;\n}\n\nstruct MorphoAllocation {\n    address vault;\n    uint256 feeAmount;\n    Withdrawal[] withdrawals;\n}\n\ncontract MorphoLendingRouter is AbstractLendingRouter, IMorphoLiquidateCallback, IMorphoFlashLoanCallback, IMorphoRepayCallback {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    mapping(address vault => MorphoParams params) private s_morphoParams;\n\n    function initializeMarket(address vault, address irm, uint256 lltv) external {\n        require(ADDRESS_REGISTRY.upgradeAdmin() == msg.sender);\n        // Cannot override parameters once they are set\n        require(s_morphoParams[vault].irm == address(0));\n        require(s_morphoParams[vault].lltv == 0);\n\n        s_morphoParams[vault] = MorphoParams({\n            irm: irm,\n            lltv: lltv\n        });\n\n        MORPHO.createMarket(marketParams(vault));\n    }\n\n    function marketParams(address vault) public view returns (MarketParams memory) {\n        return marketParams(vault, IYieldStrategy(vault).asset());\n    }\n\n    function marketParams(address vault, address asset) internal view returns (MarketParams memory) {\n        MorphoParams memory params = s_morphoParams[vault];\n\n        return MarketParams({\n            loanToken: asset,\n            collateralToken: vault,\n            oracle: vault,\n            irm: params.irm,\n            lltv: params.lltv\n        });\n    }\n\n    function morphoId(MarketParams memory m) internal pure returns (Id) {\n        return Id.wrap(keccak256(abi.encode(m)));\n    }\n\n    /// @dev Allows integration with the public allocator so that accounts can\n    /// ensure there is sufficient liquidity in the lending market before entering\n    function _allocate(address vault, MorphoAllocation[] calldata allocationData) internal {\n        MarketParams memory m = marketParams(vault);\n\n        uint256 totalFeeAmount;\n        for (uint256 i = 0; i < allocationData.length; i++) {\n            PUBLIC_ALLOCATOR.reallocateTo{value: allocationData[i].feeAmount}(\n                allocationData[i].vault, allocationData[i].withdrawals, m\n            );\n            totalFeeAmount += allocationData[i].feeAmount;\n        }\n        require(msg.value == totalFeeAmount, \"Insufficient fee amount\");\n    }\n\n    function allocateAndEnterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes calldata depositData,\n        MorphoAllocation[] calldata allocationData\n    ) external payable isAuthorized(onBehalf, vault) {\n        _allocate(vault, allocationData);\n        enterPosition(onBehalf, vault, depositAssetAmount, borrowAmount, depositData);\n    }\n\n    function allocateAndMigratePosition(\n        address onBehalf,\n        address vault,\n        address migrateFrom,\n        MorphoAllocation[] calldata allocationData\n    ) external payable isAuthorized(onBehalf, vault) {\n        _allocate(vault, allocationData);\n        migratePosition(onBehalf, vault, migrateFrom);\n    }\n\n    function _flashBorrowAndEnter(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal override {\n        // At this point we will flash borrow funds from the lending market and then\n        // receive control in a different function on a callback.\n        bytes memory flashLoanData = abi.encode(\n            onBehalf, vault, asset, depositAssetAmount, depositData, migrateFrom\n        );\n        MORPHO.flashLoan(asset, borrowAmount, flashLoanData);\n    }\n\n    function onMorphoFlashLoan(uint256 assets, bytes calldata data) external override {\n        require(msg.sender == address(MORPHO));\n\n        (\n            address onBehalf,\n            address vault,\n            address asset,\n            uint256 depositAssetAmount,\n            bytes memory depositData,\n            address migrateFrom\n        ) = abi.decode(data, (address, address, address, uint256, bytes, address));\n\n        _enterOrMigrate(onBehalf, vault, asset, assets + depositAssetAmount, depositData, migrateFrom);\n\n        MarketParams memory m = marketParams(vault, asset);\n        // Borrow the assets in order to repay the flash loan\n        MORPHO.borrow(m, assets, 0, onBehalf, address(this));\n\n        // Allow for flash loan to be repaid\n        ERC20(asset).checkApprove(address(MORPHO), assets);\n    }\n\n    function _supplyCollateral(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 sharesReceived\n    ) internal override {\n        MarketParams memory m = marketParams(vault, asset);\n\n        // Allows the transfer from the lending market to the Morpho contract\n        IYieldStrategy(vault).allowTransfer(address(MORPHO), sharesReceived, onBehalf);\n\n        // We should receive shares in return\n        ERC20(vault).approve(address(MORPHO), sharesReceived);\n        MORPHO.supplyCollateral(m, sharesReceived, onBehalf, \"\");\n    }\n\n    function _withdrawCollateral(\n        address vault,\n        address asset,\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        address receiver\n    ) internal override {\n        MarketParams memory m = marketParams(vault, asset);\n        MORPHO.withdrawCollateral(m, sharesToRedeem, sharesOwner, receiver);\n    }\n\n    function _exitWithRepay(\n        address onBehalf,\n        address vault,\n        address asset,\n        address receiver,\n        uint256 sharesToRedeem,\n        uint256 assetToRepay,\n        bytes calldata redeemData\n    ) internal override {\n        MarketParams memory m = marketParams(vault, asset);\n\n        uint256 sharesToRepay;\n        if (assetToRepay == type(uint256).max) {\n            // If assetToRepay is uint256.max then get the morpho borrow shares amount to\n            // get a full exit.\n            sharesToRepay = MORPHO.position(morphoId(m), onBehalf).borrowShares;\n            assetToRepay = 0;\n        }\n\n        bytes memory repayData = abi.encode(\n            onBehalf, vault, asset, receiver, sharesToRedeem, redeemData, _isMigrate(receiver)\n        );\n\n        // Will trigger a callback to onMorphoRepay\n        MORPHO.repay(m, assetToRepay, sharesToRepay, onBehalf, repayData);\n    }\n\n    function onMorphoRepay(uint256 assetToRepay, bytes calldata data) external override {\n        require(msg.sender == address(MORPHO));\n\n        (\n            address sharesOwner,\n            address vault,\n            address asset,\n            address receiver,\n            uint256 sharesToRedeem,\n            bytes memory redeemData,\n            bool isMigrate\n        ) = abi.decode(data, (address, address, address, address, uint256, bytes, bool));\n\n        uint256 assetsWithdrawn = _redeemShares(\n            sharesOwner, vault, asset, isMigrate ? receiver : address(0), sharesToRedeem, redeemData\n        );\n\n        if (isMigrate) {\n            // When migrating we do not withdraw any assets and we must repay the entire debt\n            // from the previous lending router.\n            ERC20(asset).safeTransferFrom(receiver, address(this), assetToRepay);\n            assetsWithdrawn = assetToRepay;\n        }\n\n        // Transfer any profits to the receiver\n        if (assetsWithdrawn < assetToRepay) {\n            // We have to revert in this case because we've already redeemed the yield tokens\n            revert InsufficientAssetsForRepayment(assetToRepay, assetsWithdrawn);\n        }\n\n        uint256 profitsWithdrawn;\n        unchecked {\n            profitsWithdrawn = assetsWithdrawn - assetToRepay;\n        }\n        ERC20(asset).safeTransfer(receiver, profitsWithdrawn);\n\n        // Allow morpho to repay the debt\n        ERC20(asset).checkApprove(address(MORPHO), assetToRepay);\n    }\n\n    function _liquidate(\n        address liquidator,\n        address vault,\n        address liquidateAccount,\n        uint256 sharesToLiquidate,\n        uint256 debtToRepay\n    ) internal override returns (uint256 sharesToLiquidator) {\n        MarketParams memory m = marketParams(vault);\n        (sharesToLiquidator, /* */) = MORPHO.liquidate(\n            m, liquidateAccount, sharesToLiquidate, debtToRepay, abi.encode(m.loanToken, liquidator)\n        );\n    }\n\n    function onMorphoLiquidate(uint256 repaidAssets, bytes calldata data) external override {\n        require(msg.sender == address(MORPHO));\n        (address asset, address liquidator) = abi.decode(data, (address, address));\n\n        ERC20(asset).safeTransferFrom(liquidator, address(this), repaidAssets);\n        ERC20(asset).checkApprove(address(MORPHO), repaidAssets);\n    }\n\n    function balanceOfCollateral(address account, address vault) public view override returns (uint256 collateralBalance) {\n        MarketParams memory m = marketParams(vault);\n        collateralBalance = MORPHO.position(morphoId(m), account).collateral;\n    }\n\n    function healthFactor(address borrower, address vault) public override returns (uint256 borrowed, uint256 collateralValue, uint256 maxBorrow) {\n        MarketParams memory m = marketParams(vault);\n        Id id = morphoId(m);\n        // Ensure interest is accrued before calculating health factor\n        MORPHO.accrueInterest(m);\n        Position memory position = MORPHO.position(id, borrower);\n        Market memory market = MORPHO.market(id);\n\n        if (position.borrowShares > 0) {\n            borrowed = (uint256(position.borrowShares) * uint256(market.totalBorrowAssets)) / uint256(market.totalBorrowShares);\n        } else {\n            borrowed = 0;\n        }\n        collateralValue = (uint256(position.collateral) * IYieldStrategy(vault).price(borrower)) / 1e36;\n        maxBorrow = collateralValue * m.lltv / 1e18;\n    }\n\n}\n",
        "AbstractSingleSidedLP.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport \"../interfaces/ISingleSidedLP.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {DEFAULT_PRECISION, ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Trade, TradeType} from \"../interfaces/ITradingModule.sol\";\nimport {RewardManagerMixin} from \"../rewards/RewardManagerMixin.sol\";\nimport {IWithdrawRequestManager, WithdrawRequest, TokenizedWithdrawRequest} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {\n    CannotEnterPosition,\n    WithdrawRequestNotFinalized,\n    PoolShareTooHigh,\n    AssetRemaining\n} from \"../interfaces/Errors.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract AbstractSingleSidedLP is RewardManagerMixin {\n    using TokenUtils for ERC20;\n\n    uint256 immutable MAX_POOL_SHARE;\n    address internal immutable LP_LIB;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as address(0)\n    function TOKENS() internal view virtual returns (ERC20[] memory);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256);\n\n    /// @dev Checks that the reentrancy context is valid\n    function _checkReentrancyContext() internal virtual;\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(ILPLib.initialApproveTokens.selector));\n    }\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(ILPLib.joinPoolAndStake.selector, amounts, minPoolClaim));\n    }\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.unstakeAndExitPool.selector, poolClaim, minAmounts, isSingleSided\n        ));\n        exitBalances = abi.decode(result, (uint256[]));\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(\n        uint256 _maxPoolShare,\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        uint8 _yieldTokenDecimals,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) RewardManagerMixin( _asset, _yieldToken, _feeRate, _rewardManager, _yieldTokenDecimals) {\n        MAX_POOL_SHARE = _maxPoolShare;\n        // Although there will be multiple withdraw request managers, we only need to set one here\n        // to check whether or not a withdraw request is pending. If any one of the withdraw requests\n        // is not finalized then the entire withdraw will revert and the user will remain in a pending\n        // withdraw state.\n        withdrawRequestManager = _withdrawRequestManager;\n    }\n\n    function _initialize(bytes calldata data) internal override {\n        super._initialize(data);\n        _initialApproveTokens();\n    }\n\n    function _mintYieldTokens(\n        uint256 assets,\n        address /* receiver */,\n        bytes memory depositData\n    ) internal override {\n        DepositParams memory params = abi.decode(depositData, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            // NOTE: amounts is modified in place\n            _executeDepositTrades(assets, amounts, params.depositTrades);\n        } else {\n            // This is a single sided entry, will revert if index is out of bounds\n            amounts[PRIMARY_INDEX()] = assets;\n        }\n\n        _joinPoolAndStake(amounts, params.minPoolClaim);\n\n        _checkPoolShare();\n    }\n\n    function _checkPoolShare() internal view virtual {\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * MAX_POOL_SHARE) / DEFAULT_PRECISION;\n        // This is incumbent on a 1-1 ratio between the lpToken and the yieldToken, if that is not the\n        // case then this function must be overridden.\n        uint256 poolClaim = _yieldTokenBalance();\n        if (maxSupplyThreshold < poolClaim) revert PoolShareTooHigh(poolClaim, maxSupplyThreshold);\n    }\n\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal override {\n        RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n\n        // Stores the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances;\n        bool isSingleSided;\n        ERC20[] memory tokens;\n        if (isEscrowed) {\n            // Attempt to withdraw all pending requests, tokens may be different if there\n            // is a withdraw request.\n            (exitBalances, tokens) = _withdrawPendingRequests(sharesOwner, sharesToRedeem);\n            // If there are pending requests, then we are not single sided by definition\n            isSingleSided = false;\n        } else {\n            isSingleSided = params.redemptionTrades.length == 0;\n            uint256 yieldTokensBurned = convertSharesToYieldToken(sharesToRedeem);\n            exitBalances = _unstakeAndExitPool(yieldTokensBurned, params.minAmounts, isSingleSided);\n            tokens = TOKENS();\n        }\n\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            _executeRedemptionTrades(tokens, exitBalances, params.redemptionTrades);\n        }\n    }\n\n    /// @dev Trades the amount of primary token into other secondary tokens prior to entering a pool.\n    function _executeDepositTrades(\n        uint256 assets,\n        uint256[] memory amounts,\n        TradeParams[] memory depositTrades\n    ) internal {\n        ERC20[] memory tokens = TOKENS();\n        Trade memory trade;\n        uint256 assetRemaining = assets;\n\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == PRIMARY_INDEX()) continue;\n            TradeParams memory t = depositTrades[i];\n\n            if (t.tradeAmount > 0) {\n                trade = Trade({\n                    tradeType: t.tradeType,\n                    sellToken: address(asset),\n                    buyToken: address(tokens[i]),\n                    amount: t.tradeAmount,\n                    limit: t.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: t.exchangeData\n                });\n                // Always selling the primaryToken and buying the secondary token.\n                (uint256 amountSold, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n                amounts[i] = amountBought;\n                // Will revert on underflow if over-selling the primary borrowed\n                assetRemaining -= amountSold;\n            }\n        }\n\n        if (PRIMARY_INDEX() < amounts.length) {\n            amounts[PRIMARY_INDEX()] = assetRemaining;\n        } else if (0 < assetRemaining) {\n            // This can happen if the asset is not in the pool and we need to trade all\n            // of the remaining asset for tokens in the pool.\n            revert AssetRemaining(assetRemaining);\n        }\n    }\n\n    /// @dev Trades the amount of secondary tokens into the primary token after exiting a pool.\n    function _executeRedemptionTrades(\n        ERC20[] memory tokens,\n        uint256[] memory exitBalances,\n        TradeParams[] memory redemptionTrades\n    ) internal returns (uint256 finalPrimaryBalance) {\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (address(tokens[i]) == address(asset)) {\n                finalPrimaryBalance += exitBalances[i];\n                continue;\n            }\n\n            TradeParams memory t = redemptionTrades[i];\n            // Always sell the entire exit balance to the primary token\n            if (exitBalances[i] > 0) {\n                Trade memory trade = Trade({\n                    tradeType: t.tradeType,\n                    sellToken: address(tokens[i]),\n                    buyToken: address(asset),\n                    amount: exitBalances[i],\n                    limit: t.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: t.exchangeData\n                });\n                (/* */, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n                finalPrimaryBalance += amountBought;\n            }\n        }\n    }\n\n    function _preLiquidation(address liquidateAccount, address liquidator, uint256 sharesToLiquidate, uint256 accountSharesHeld) internal override {\n        _checkReentrancyContext();\n        return super._preLiquidation(liquidateAccount, liquidator, sharesToLiquidate, accountSharesHeld);\n    }\n\n    function __postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal override returns (bool didTokenize) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.tokenizeWithdrawRequest.selector, liquidateAccount, liquidator, sharesToLiquidator\n        ));\n        didTokenize = abi.decode(result, (bool));\n    }\n\n    function __initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override returns (uint256 requestId) {\n        WithdrawParams memory params = abi.decode(data, (WithdrawParams));\n\n        uint256[] memory exitBalances = _unstakeAndExitPool({\n            poolClaim: yieldTokenAmount,\n            minAmounts: params.minAmounts,\n            // When initiating a withdraw, we always exit proportionally\n            isSingleSided: false\n        });\n\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.initiateWithdraw.selector, account, sharesHeld, exitBalances, params.withdrawData\n        ));\n        uint256[] memory requestIds = abi.decode(result, (uint256[]));\n        // Although we get multiple requests ids, we just return the first one here. The rest will be\n        // observable off chain.\n        requestId = requestIds[0];\n    }\n\n    function _withdrawPendingRequests(\n        address sharesOwner,\n        uint256 sharesToRedeem\n    ) internal returns (uint256[] memory exitBalances, ERC20[] memory tokens) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.finalizeAndRedeemWithdrawRequest.selector, sharesOwner, sharesToRedeem\n        ));\n        (exitBalances, tokens) = abi.decode(result, (uint256[], ERC20[]));\n    }\n\n    /// @notice Returns the total value in terms of the borrowed token of the account's position\n    function convertToAssets(uint256 shares) public view override returns (uint256) {\n        if (t_CurrentAccount != address(0) && _isWithdrawRequestPending(t_CurrentAccount)) {\n            return ILPLib(LP_LIB).getWithdrawRequestValue(t_CurrentAccount, asset, shares);\n        }\n\n        return super.convertToAssets(shares);\n    }\n\n    function _isWithdrawRequestPending(address account) internal view override returns (bool) {\n        return ILPLib(LP_LIB).hasPendingWithdrawals(account);\n    }\n}\n\nabstract contract BaseLPLib is ILPLib {\n    using TokenUtils for ERC20;\n\n    function TOKENS() internal view virtual returns (ERC20[] memory);\n\n    /// @inheritdoc ILPLib\n    function getWithdrawRequestValue(\n        address account,\n        address asset,\n        uint256 shares\n    ) external view returns (uint256 totalValue) {\n        ERC20[] memory tokens = TOKENS();\n\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            // This is called as a view function, not a delegate call so use the msg.sender to get\n            // the correct vault address\n            (bool hasRequest, uint256 value) = manager.getWithdrawRequestValue(msg.sender, account, asset, shares);\n            // Ensure that this is true so that we do not lose any value.\n            require(hasRequest);\n            totalValue += value;\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function hasPendingWithdrawals(address account) external view override returns (bool) {\n        ERC20[] memory tokens = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            if (address(manager) == address(0)) continue;\n            // This is called as a view function, not a delegate call so use the msg.sender to get\n            // the correct vault address\n            (WithdrawRequest memory w, /* */) = manager.getWithdrawRequest(msg.sender, account);\n            if (w.requestId != 0) return true;\n        }\n\n        return false;\n    }\n\n    /// @inheritdoc ILPLib\n    function initiateWithdraw(\n        address account,\n        uint256 sharesHeld,\n        uint256[] calldata exitBalances,\n        bytes[] calldata withdrawData\n    ) external override returns (uint256[] memory requestIds) {\n        ERC20[] memory tokens = TOKENS();\n\n        requestIds = new uint256[](exitBalances.length);\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (exitBalances[i] == 0) continue;\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n\n            tokens[i].checkApprove(address(manager), exitBalances[i]);\n            // Will revert if there is already a pending withdraw\n            requestIds[i] = manager.initiateWithdraw({\n                account: account,\n                yieldTokenAmount: exitBalances[i],\n                sharesAmount: sharesHeld,\n                data: withdrawData[i]\n            });\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function finalizeAndRedeemWithdrawRequest(\n        address sharesOwner,\n        uint256 sharesToRedeem\n    ) external override returns (uint256[] memory exitBalances, ERC20[] memory withdrawTokens) {\n        ERC20[] memory tokens = TOKENS();\n\n        exitBalances = new uint256[](tokens.length);\n        withdrawTokens = new ERC20[](tokens.length);\n\n        WithdrawRequest memory w;\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            (w, /* */) = manager.getWithdrawRequest(address(this), sharesOwner);\n\n            uint256 yieldTokensBurned = uint256(w.yieldTokenAmount) * sharesToRedeem / w.sharesAmount;\n            bool finalized;\n            (exitBalances[i], finalized) = manager.finalizeAndRedeemWithdrawRequest({\n                account: sharesOwner, withdrawYieldTokenAmount: yieldTokensBurned, sharesToBurn: sharesToRedeem\n            });\n            if (!finalized) revert WithdrawRequestNotFinalized(w.requestId);\n            withdrawTokens[i] = ERC20(manager.WITHDRAW_TOKEN());\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function tokenizeWithdrawRequest(\n        address liquidateAccount,\n        address liquidator,\n        uint256 sharesToLiquidator\n    ) external override returns (bool didTokenize) {\n        ERC20[] memory tokens = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            if (address(manager) == address(0)) continue;\n            // If there is no withdraw request then this will be a noop, make sure to OR with the previous result\n            // to ensure that the result is always set but it is done after so the tokenizeWithdrawRequest call\n            // is not short circuited.\n            didTokenize = manager.tokenizeWithdrawRequest(liquidateAccount, liquidator, sharesToLiquidator) || didTokenize;\n        }\n    }\n}\n",
        "AbstractWithdrawRequestManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport \"../interfaces/IWithdrawRequestManager.sol\";\nimport {Initializable} from \"../proxy/Initializable.sol\";\nimport {ClonedCoolDownHolder} from \"./ClonedCoolDownHolder.sol\";\nimport {\n    Unauthorized,\n    ExistingWithdrawRequest,\n    NoWithdrawRequest,\n    InvalidWithdrawRequestTokenization\n} from \"../interfaces/Errors.sol\";\nimport {TypeConvert} from \"../utils/TypeConvert.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {ADDRESS_REGISTRY, DEFAULT_PRECISION} from \"../utils/Constants.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Trade, TradeType, TRADING_MODULE, nProxy, TradeFailed} from \"../interfaces/ITradingModule.sol\";\n\n\n/**\n * Library to handle potentially illiquid withdraw requests of staking tokens where there\n * is some indeterminate lock up time before tokens can be redeemed. Examples would be withdraws\n * of staked or restaked ETH, tokens like sUSDe or stkAave which have cooldown periods before they\n * can be withdrawn.\n *\n * Primarily, this library tracks the withdraw request and an associated identifier for the withdraw\n * request. It also allows for the withdraw request to be \"tokenized\" so that shares of the withdraw\n * request can be liquidated.\n */\nabstract contract AbstractWithdrawRequestManager is IWithdrawRequestManager, Initializable {\n    using SafeERC20 for ERC20;\n    using TypeConvert for uint256;\n\n    /// @inheritdoc IWithdrawRequestManager\n    address public immutable override YIELD_TOKEN;\n    /// @inheritdoc IWithdrawRequestManager\n    address public immutable override WITHDRAW_TOKEN;\n    /// @inheritdoc IWithdrawRequestManager\n    address public immutable override STAKING_TOKEN;\n\n    mapping(address => bool) public override isApprovedVault;\n    mapping(address vault => mapping(address account => WithdrawRequest)) private s_accountWithdrawRequest;\n    mapping(uint256 requestId => TokenizedWithdrawRequest) private s_tokenizedWithdrawRequest;\n\n    constructor(address _withdrawToken, address _yieldToken, address _stakingToken) Initializable() {\n        WITHDRAW_TOKEN = _withdrawToken;\n        YIELD_TOKEN = _yieldToken;\n        STAKING_TOKEN = _stakingToken;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != ADDRESS_REGISTRY.upgradeAdmin()) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    /// @dev Ensures that only approved vaults can initiate withdraw requests.\n    modifier onlyApprovedVault() {\n        if (!isApprovedVault[msg.sender]) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function getWithdrawRequest(address vault, address account) public view override\n        returns (WithdrawRequest memory w, TokenizedWithdrawRequest memory s) {\n        w = s_accountWithdrawRequest[vault][account];\n        s = s_tokenizedWithdrawRequest[w.requestId];\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function isPendingWithdrawRequest(address vault, address account) public view override returns (bool) {\n        return s_accountWithdrawRequest[vault][account].requestId != 0;\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function setApprovedVault(address vault, bool isApproved) external override onlyOwner {\n        isApprovedVault[vault] = isApproved;\n        emit ApprovedVault(vault, isApproved);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function stakeTokens(\n        address depositToken,\n        uint256 amount,\n        bytes calldata data\n    ) external override onlyApprovedVault returns (uint256 yieldTokensMinted) {\n        uint256 initialYieldTokenBalance = ERC20(YIELD_TOKEN).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        (uint256 stakeTokenAmount, bytes memory stakeData) = _preStakingTrade(depositToken, amount, data);\n        _stakeTokens(stakeTokenAmount, stakeData);\n\n        yieldTokensMinted = ERC20(YIELD_TOKEN).balanceOf(address(this)) - initialYieldTokenBalance;\n        ERC20(YIELD_TOKEN).safeTransfer(msg.sender, yieldTokensMinted);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesAmount,\n        bytes calldata data\n    ) external override onlyApprovedVault returns (uint256 requestId) {\n        WithdrawRequest storage accountWithdraw = s_accountWithdrawRequest[msg.sender][account];\n        if (accountWithdraw.requestId != 0) revert ExistingWithdrawRequest(msg.sender, account, accountWithdraw.requestId);\n\n        // Receive the requested amount of yield tokens from the approved vault.\n        ERC20(YIELD_TOKEN).safeTransferFrom(msg.sender, address(this), yieldTokenAmount);\n\n        requestId = _initiateWithdrawImpl(account, yieldTokenAmount, data);\n        accountWithdraw.requestId = requestId;\n        accountWithdraw.yieldTokenAmount = yieldTokenAmount.toUint120();\n        accountWithdraw.sharesAmount = sharesAmount.toUint120();\n        s_tokenizedWithdrawRequest[requestId] = TokenizedWithdrawRequest({\n            totalYieldTokenAmount: yieldTokenAmount.toUint120(),\n            totalWithdraw: 0,\n            finalized: false\n        });\n\n        emit InitiateWithdrawRequest(account, msg.sender, yieldTokenAmount, sharesAmount, requestId);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function finalizeAndRedeemWithdrawRequest(\n        address account,\n        uint256 withdrawYieldTokenAmount,\n        uint256 sharesToBurn\n    ) external override onlyApprovedVault returns (uint256 tokensWithdrawn, bool finalized) {\n        WithdrawRequest storage s_withdraw = s_accountWithdrawRequest[msg.sender][account];\n        if (s_withdraw.requestId == 0) return (0, false);\n\n        (tokensWithdrawn, finalized) = _finalizeWithdraw(account, s_withdraw);\n\n        if (finalized) {\n            // Allows for partial withdrawal of yield tokens\n            if (withdrawYieldTokenAmount < s_withdraw.yieldTokenAmount) {\n                tokensWithdrawn = tokensWithdrawn * withdrawYieldTokenAmount / s_withdraw.yieldTokenAmount;\n                s_withdraw.sharesAmount -= sharesToBurn.toUint120();\n                s_withdraw.yieldTokenAmount -= withdrawYieldTokenAmount.toUint120();\n            } else {\n                require(s_withdraw.yieldTokenAmount == withdrawYieldTokenAmount);\n                delete s_accountWithdrawRequest[msg.sender][account];\n            }\n\n            ERC20(WITHDRAW_TOKEN).safeTransfer(msg.sender, tokensWithdrawn);\n        }\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function finalizeRequestManual(\n        address vault,\n        address account\n    ) external override returns (uint256 tokensWithdrawn, bool finalized) {\n        WithdrawRequest storage s_withdraw = s_accountWithdrawRequest[vault][account];\n        if (s_withdraw.requestId == 0) revert NoWithdrawRequest(vault, account);\n\n        // Do not transfer any tokens off of this method here. Withdrawn tokens will be held in the\n        // tokenized withdraw request until the vault calls this contract to withdraw the tokens.\n        (tokensWithdrawn, finalized) = _finalizeWithdraw(account, s_withdraw);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function tokenizeWithdrawRequest(\n        address _from,\n        address _to,\n        uint256 sharesAmount\n    ) external override onlyApprovedVault returns (bool didTokenize) {\n        if (_from == _to) revert();\n\n        WithdrawRequest storage s_withdraw = s_accountWithdrawRequest[msg.sender][_from];\n        uint256 requestId = s_withdraw.requestId;\n        if (requestId == 0 || sharesAmount == 0) return false;\n\n        // Ensure that no withdraw request gets overridden, the _to account always receives their withdraw\n        // request in the account withdraw slot. All storage is updated prior to changes to the `w` storage\n        // variable below.\n        WithdrawRequest storage toWithdraw = s_accountWithdrawRequest[msg.sender][_to];\n        if (toWithdraw.requestId != 0 && toWithdraw.requestId != requestId) {\n            revert ExistingWithdrawRequest(msg.sender, _to, toWithdraw.requestId);\n        }\n\n        toWithdraw.requestId = requestId;\n\n        if (s_withdraw.sharesAmount < sharesAmount) {\n            // This should never occur given the checks below.\n            revert InvalidWithdrawRequestTokenization();\n        } else if (s_withdraw.sharesAmount == sharesAmount) {\n            // If the resulting vault shares is zero, then delete the request. The _from account's\n            // withdraw request is fully transferred to _to. In this case, the _to account receives\n            // the full amount of the _from account's withdraw request.\n            toWithdraw.yieldTokenAmount = toWithdraw.yieldTokenAmount + s_withdraw.yieldTokenAmount;\n            toWithdraw.sharesAmount = toWithdraw.sharesAmount + s_withdraw.sharesAmount;\n            delete s_accountWithdrawRequest[msg.sender][_from];\n        } else {\n            // In this case, the amount of yield tokens is transferred from one account to the other.\n            uint256 yieldTokenAmount = s_withdraw.yieldTokenAmount * sharesAmount / s_withdraw.sharesAmount;\n            toWithdraw.yieldTokenAmount = (toWithdraw.yieldTokenAmount + yieldTokenAmount).toUint120();\n            toWithdraw.sharesAmount = (toWithdraw.sharesAmount + sharesAmount).toUint120();\n            s_withdraw.yieldTokenAmount = (s_withdraw.yieldTokenAmount - yieldTokenAmount).toUint120();\n            s_withdraw.sharesAmount = (s_withdraw.sharesAmount - sharesAmount).toUint120();\n        }\n\n        emit WithdrawRequestTokenized(_from, _to, requestId, sharesAmount);\n        return true;\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function rescueTokens(\n        address cooldownHolder, address token, address receiver, uint256 amount\n    ) external override onlyOwner {\n        ClonedCoolDownHolder(cooldownHolder).rescueTokens(ERC20(token), receiver, amount);\n    }\n\n    /// @notice Finalizes a withdraw request and updates the account required to determine how many\n    /// tokens the account has a claim over.\n    function _finalizeWithdraw(\n        address account,\n        WithdrawRequest memory w\n    ) internal returns (uint256 tokensWithdrawn, bool finalized) {\n        TokenizedWithdrawRequest storage s = s_tokenizedWithdrawRequest[w.requestId];\n\n        // If the tokenized request was already finalized in a different transaction\n        // then return the values here and we can short circuit the withdraw impl\n        if (s.finalized) {\n            return (\n                uint256(s.totalWithdraw) * uint256(w.yieldTokenAmount) / uint256(s.totalYieldTokenAmount),\n                true\n            );\n        }\n\n        // These values are the total tokens claimed from the withdraw request, does not\n        // account for potential tokenization.\n        (tokensWithdrawn, finalized) = _finalizeWithdrawImpl(account, w.requestId);\n\n        if (finalized) {\n            s.totalWithdraw = tokensWithdrawn.toUint120();\n            // Safety check to ensure that we do not override a finalized tokenized withdraw request\n            require(s.finalized == false);\n            s.finalized = true;\n\n            tokensWithdrawn = uint256(s.totalWithdraw) * uint256(w.yieldTokenAmount) / uint256(s.totalYieldTokenAmount);\n        } else {\n            // No tokens claimed if not finalized\n            require(tokensWithdrawn == 0);\n        }\n    }\n\n\n    /// @notice Required implementation to begin the withdraw request\n    /// @return requestId some identifier of the withdraw request\n    function _initiateWithdrawImpl(\n        address account,\n        uint256 yieldTokenAmount,\n        bytes calldata data\n    ) internal virtual returns (uint256 requestId);\n\n    /// @notice Required implementation to finalize the withdraw\n    /// @return tokensWithdrawn total tokens claimed as a result of the withdraw, does not\n    /// necessarily represent the tokens that go to the account if the request has been\n    /// tokenized due to liquidation\n    /// @return finalized returns true if the withdraw has been finalized\n    function _finalizeWithdrawImpl(address account, uint256 requestId) internal virtual returns (uint256 tokensWithdrawn, bool finalized);\n\n    /// @notice Required implementation to stake the deposit token to the yield token\n    function _stakeTokens(uint256 amount, bytes memory stakeData) internal virtual;\n\n    /// @dev Allows for the deposit token to be traded into the staking token prior to staking, i.e.\n    /// enables USDC to USDe trades before staking into sUSDe.\n    function _preStakingTrade(address depositToken, uint256 depositAmount, bytes calldata data) internal returns (uint256 amountBought, bytes memory stakeData) {\n        if (depositToken == STAKING_TOKEN) {\n            amountBought = depositAmount;\n            stakeData = data;\n        } else {\n            StakingTradeParams memory params = abi.decode(data, (StakingTradeParams));\n            stakeData = params.stakeData;\n\n            (/* */, amountBought) = _executeTrade(Trade({\n                tradeType: params.tradeType,\n                sellToken: depositToken,\n                buyToken: STAKING_TOKEN,\n                amount: depositAmount,\n                exchangeData: params.exchangeData,\n                limit: params.minPurchaseAmount,\n                deadline: block.timestamp\n            }), params.dexId);\n        }\n    }\n\n    function _executeTrade(\n        Trade memory trade,\n        uint16 dexId\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        (bool success, bytes memory result) = nProxy(payable(address(TRADING_MODULE))).getImplementation()\n            .delegatecall(abi.encodeWithSelector(TRADING_MODULE.executeTrade.selector, dexId, trade));\n        if (!success) {\n            assembly {\n                // Copy the return data to memory\n                returndatacopy(0, 0, returndatasize())\n                // Revert with the return data\n                revert(0, returndatasize())\n            }\n        }\n\n        (amountSold, amountBought) = abi.decode(result, (uint256, uint256));\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function getWithdrawRequestValue(\n        address vault,\n        address account,\n        address asset,\n        uint256 shares\n    ) external view override returns (bool hasRequest, uint256 valueInAsset) {\n        WithdrawRequest memory w = s_accountWithdrawRequest[vault][account];\n        if (w.requestId == 0) return (false, 0);\n\n        TokenizedWithdrawRequest memory s = s_tokenizedWithdrawRequest[w.requestId];\n\n        int256 tokenRate;\n        uint256 tokenAmount;\n        uint256 tokenDecimals;\n        uint256 assetDecimals = TokenUtils.getDecimals(asset);\n        if (s.finalized) {\n            // If finalized the withdraw request is locked to the tokens withdrawn\n            (tokenRate, /* */) = TRADING_MODULE.getOraclePrice(WITHDRAW_TOKEN, asset);\n            tokenDecimals = TokenUtils.getDecimals(WITHDRAW_TOKEN);\n            tokenAmount = (uint256(w.yieldTokenAmount) * uint256(s.totalWithdraw)) / uint256(s.totalYieldTokenAmount);\n        } else {\n            // Otherwise we use the yield token rate\n            (tokenRate, /* */) = TRADING_MODULE.getOraclePrice(YIELD_TOKEN, asset);\n            tokenDecimals = TokenUtils.getDecimals(YIELD_TOKEN);\n            tokenAmount = w.yieldTokenAmount;\n        }\n\n        // The trading module always returns a positive rate in 18 decimals so we can safely\n        // cast to uint256\n        uint256 totalValue = (uint256(tokenRate) * tokenAmount * (10 ** assetDecimals)) /\n            ((10 ** tokenDecimals) * DEFAULT_PRECISION);\n        // NOTE: returns the normalized value given the shares input\n        return (true, totalValue * shares / w.sharesAmount);\n    }\n\n}",
        "CurveConvex2Token.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {IWithdrawRequestManager} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {AbstractSingleSidedLP, BaseLPLib} from \"./AbstractSingleSidedLP.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {ETH_ADDRESS, ALT_ETH_ADDRESS, WETH, CHAIN_ID_MAINNET} from \"../utils/Constants.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/Curve/ICurve.sol\";\nimport \"../interfaces/Curve/IConvex.sol\";\n\nstruct DeploymentParams {\n    address pool;\n    address poolToken;\n    address gauge;\n    address convexRewardPool;\n    CurveInterface curveInterface;\n}\n\ncontract CurveConvex2Token is AbstractSingleSidedLP {\n\n    uint256 internal constant _NUM_TOKENS = 2;\n\n    ERC20 internal immutable CURVE_POOL_TOKEN;\n    uint8 internal immutable _PRIMARY_INDEX;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n\n    function NUM_TOKENS() internal pure override returns (uint256) { return _NUM_TOKENS; }\n    function PRIMARY_INDEX() internal view override returns (uint256) { return _PRIMARY_INDEX; }\n    function TOKENS() internal view override returns (ERC20[] memory) {\n        ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n        tokens[0] = ERC20(TOKEN_1);\n        tokens[1] = ERC20(TOKEN_2);\n        return tokens;\n    }\n\n    constructor(\n        uint256 _maxPoolShare,\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        DeploymentParams memory params,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) AbstractSingleSidedLP(_maxPoolShare, _asset, _yieldToken, _feeRate, _rewardManager, 18, _withdrawRequestManager) {\n        CURVE_POOL_TOKEN = ERC20(params.poolToken);\n\n        // We interact with curve pools directly so we never pass the token addresses back\n        // to the curve pools. The amounts are passed back based on indexes instead. Therefore\n        // we can rewrite the token addresses from ALT Eth (0xeeee...) back to (0x0000...) which\n        // is used by the vault internally to represent ETH.\n        TOKEN_1 = _rewriteAltETH(ICurvePool(params.pool).coins(0));\n        TOKEN_2 = _rewriteAltETH(ICurvePool(params.pool).coins(1));\n\n        // Assets may be WETH, so we need to unwrap it in this case.\n        _PRIMARY_INDEX =\n            (TOKEN_1 == _asset || (TOKEN_1 == ETH_ADDRESS && _asset == address(WETH))) ? 0 :\n            (TOKEN_2 == _asset || (TOKEN_2 == ETH_ADDRESS && _asset == address(WETH))) ? 1 :\n            // Otherwise the primary index is not set and we will not be able to enter or exit\n            // single sided.\n            type(uint8).max;\n\n        LP_LIB = address(new CurveConvexLib(TOKEN_1, TOKEN_2, _asset, _PRIMARY_INDEX, params));\n    }\n\n    function _rewriteAltETH(address token) private pure returns (address) {\n        return token == address(ALT_ETH_ADDRESS) ? ETH_ADDRESS : address(token);\n    }\n\n    function _transferYieldTokenToOwner(address owner, uint256 yieldTokens) internal override {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(\n            CurveConvexLib.transferYieldTokenToOwner.selector, owner, yieldTokens)\n        );\n    }\n\n    function _totalPoolSupply() internal view override returns (uint256) {\n        return CURVE_POOL_TOKEN.totalSupply();\n    }\n\n    function _checkReentrancyContext() internal override {\n        CurveConvexLib(payable(LP_LIB)).checkReentrancyContext();\n    }\n}\n\ncontract CurveConvexLib is BaseLPLib {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    uint256 internal constant _NUM_TOKENS = 2;\n\n    address internal immutable CURVE_POOL;\n    ERC20 internal immutable CURVE_POOL_TOKEN;\n\n    /// @dev Curve gauge contract used when there is no convex reward pool\n    address internal immutable CURVE_GAUGE;\n    /// @dev Convex booster contract used for staking BPT\n    address internal immutable CONVEX_BOOSTER;\n    /// @dev Convex reward pool contract used for unstaking and claiming reward tokens\n    address internal immutable CONVEX_REWARD_POOL;\n    uint256 internal immutable CONVEX_POOL_ID;\n\n    uint8 internal immutable _PRIMARY_INDEX;\n    address internal immutable ASSET;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n    CurveInterface internal immutable CURVE_INTERFACE;\n\n    // Payable is required for the CurveV1 interface which will execute a transfer\n    // when the remove_liquidity function is called, it only will be done to this contract\n    // during the checkReentrancyContext function.\n    receive() external payable {}\n\n    constructor(\n        address _token1,\n        address _token2,\n        address _asset,\n        uint8 _primaryIndex,\n        DeploymentParams memory params\n    ) {\n        TOKEN_1 = _token1;\n        TOKEN_2 = _token2;\n        ASSET = _asset;\n        _PRIMARY_INDEX = _primaryIndex;\n\n        CURVE_POOL = params.pool;\n        CURVE_GAUGE = params.gauge;\n        CURVE_POOL_TOKEN = ERC20(params.poolToken);\n        CURVE_INTERFACE = params.curveInterface;\n\n        // If the convex reward pool is set then get the booster and pool id, if not then\n        // we will stake on the curve gauge directly.\n        CONVEX_REWARD_POOL = params.convexRewardPool;\n        address convexBooster;\n        uint256 poolId;\n        if (block.chainid == CHAIN_ID_MAINNET && CONVEX_REWARD_POOL != address(0)) {\n            convexBooster = IConvexRewardPool(CONVEX_REWARD_POOL).operator();\n            poolId = IConvexRewardPool(CONVEX_REWARD_POOL).pid();\n        }\n\n        CONVEX_POOL_ID = poolId;\n        CONVEX_BOOSTER = convexBooster;\n    }\n\n    function checkReentrancyContext() external {\n        uint256[2] memory minAmounts;\n        if (CURVE_INTERFACE == CurveInterface.V1) {\n            ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity(0, minAmounts);\n        } else if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n            // Total supply on stable swap has a non-reentrant lock\n            ICurveStableSwapNG(CURVE_POOL).totalSupply();\n        } else if (CURVE_INTERFACE == CurveInterface.V2) {\n            // Curve V2 does a `-1` on the liquidity amount so set the amount removed to 1 to\n            // avoid an underflow.\n            ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(1, minAmounts, true, address(this));\n        } else {\n            revert();\n        }\n    }\n\n    function TOKENS() internal view override returns (ERC20[] memory) {\n        ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n        tokens[0] = ERC20(TOKEN_1);\n        tokens[1] = ERC20(TOKEN_2);\n        return tokens;\n    }\n\n    function initialApproveTokens() external {\n        // If either token is ETH_ADDRESS the check approve will short circuit\n        ERC20(TOKEN_1).checkApprove(address(CURVE_POOL), type(uint256).max);\n        ERC20(TOKEN_2).checkApprove(address(CURVE_POOL), type(uint256).max);\n        if (CONVEX_BOOSTER != address(0)) {\n            CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n        } else {\n            CURVE_POOL_TOKEN.checkApprove(address(CURVE_GAUGE), type(uint256).max);\n        }\n    }\n\n    function joinPoolAndStake(\n        uint256[] memory _amounts, uint256 minPoolClaim\n    ) external {\n        // Although Curve uses ALT_ETH to represent native ETH, it is rewritten in the Curve2TokenPoolMixin\n        // to the Deployments.ETH_ADDRESS which we use internally.\n        uint256 msgValue;\n        if (TOKEN_1 == ETH_ADDRESS) {\n            msgValue = _amounts[0];\n        } else if (TOKEN_2 == ETH_ADDRESS) {\n            msgValue = _amounts[1];\n        }\n        if (msgValue > 0) WETH.withdraw(msgValue);\n\n        uint256 lpTokens = _enterPool(_amounts, minPoolClaim, msgValue);\n\n        _stakeLpTokens(lpTokens);\n    }\n\n    function unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) external returns (uint256[] memory exitBalances) {\n        _unstakeLpTokens(poolClaim);\n\n        exitBalances = _exitPool(poolClaim, _minAmounts, isSingleSided);\n\n        if (ASSET == address(WETH)) {\n            if (TOKEN_1 == ETH_ADDRESS) {\n                WETH.deposit{value: exitBalances[0]}();\n            } else if (TOKEN_2 == ETH_ADDRESS) {\n                WETH.deposit{value: exitBalances[1]}();\n            }\n        }\n    }\n\n    function transferYieldTokenToOwner(address owner, uint256 yieldTokens) external {\n        _unstakeLpTokens(yieldTokens);\n        CURVE_POOL_TOKEN.safeTransfer(owner, yieldTokens);\n    }\n\n    function _enterPool(\n        uint256[] memory _amounts, uint256 minPoolClaim, uint256 msgValue\n    ) internal returns (uint256) {\n        if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n            return ICurveStableSwapNG(CURVE_POOL).add_liquidity{value: msgValue}(\n                _amounts, minPoolClaim\n            );\n        } \n\n        uint256[2] memory amounts;\n        amounts[0] = _amounts[0];\n        amounts[1] = _amounts[1];\n        if (CURVE_INTERFACE == CurveInterface.V1) {\n            return ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim\n            );\n        } else if (CURVE_INTERFACE == CurveInterface.V2) {\n            return ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n            );\n        }\n\n        revert();\n    }\n\n    function _exitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) internal returns (uint256[] memory exitBalances) {\n        if (isSingleSided) {\n            exitBalances = new uint256[](_NUM_TOKENS);\n            if (CURVE_INTERFACE == CurveInterface.V1 || CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n                // Method signature is the same for v1 and stable swap ng\n                exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity_one_coin(\n                    poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n                );\n            } else {\n                exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity_one_coin(\n                    // Last two parameters are useEth = true and receiver = this contract\n                    poolClaim, _PRIMARY_INDEX, _minAmounts[_PRIMARY_INDEX], true, address(this)\n                );\n            }\n        } else {\n            // Two sided exit\n            if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n                return ICurveStableSwapNG(CURVE_POOL).remove_liquidity(poolClaim, _minAmounts);\n            }\n            \n            // Redeem proportionally, min amounts are rewritten to a fixed length array\n            uint256[2] memory minAmounts;\n            minAmounts[0] = _minAmounts[0];\n            minAmounts[1] = _minAmounts[1];\n\n            exitBalances = new uint256[](_NUM_TOKENS);\n            if (CURVE_INTERFACE == CurveInterface.V1) {\n                uint256[2] memory _exitBalances = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity(poolClaim, minAmounts);\n                exitBalances[0] = _exitBalances[0];\n                exitBalances[1] = _exitBalances[1];\n            } else {\n                exitBalances[0] = TokenUtils.tokenBalance(TOKEN_1);\n                exitBalances[1] = TokenUtils.tokenBalance(TOKEN_2);\n                // Remove liquidity on CurveV2 does not return the exit amounts so we have to measure\n                // them before and after.\n                ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(\n                    // Last two parameters are useEth = true and receiver = this contract\n                    poolClaim, minAmounts, true, address(this)\n                );\n                exitBalances[0] = TokenUtils.tokenBalance(TOKEN_1) - exitBalances[0];\n                exitBalances[1] = TokenUtils.tokenBalance(TOKEN_2) - exitBalances[1];\n            }\n        }\n    }\n\n    function _stakeLpTokens(uint256 lpTokens) internal {\n        if (CONVEX_BOOSTER != address(0)) {\n            bool success = IConvexBooster(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens, true);\n            require(success);\n        } else {\n            ICurveGauge(CURVE_GAUGE).deposit(lpTokens);\n        }\n    }\n\n\n    function _unstakeLpTokens(uint256 poolClaim) internal {\n        if (CONVEX_REWARD_POOL != address(0)) {\n            bool success = IConvexRewardPool(CONVEX_REWARD_POOL).withdrawAndUnwrap(poolClaim, false);\n            require(success);\n        } else {\n            ICurveGauge(CURVE_GAUGE).withdraw(poolClaim);\n        }\n    }\n\n}",
        "AbstractStakingStrategy.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {WithdrawRequestNotFinalized} from \"../interfaces/Errors.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {\n    IWithdrawRequestManager,\n    WithdrawRequest,\n    TokenizedWithdrawRequest\n} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {Trade, TradeType, TRADING_MODULE} from \"../interfaces/ITradingModule.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nstruct RedeemParams {\n    uint8 dexId;\n    uint256 minPurchaseAmount;\n    bytes exchangeData;\n}\n\nstruct DepositParams {\n    uint8 dexId;\n    uint256 minPurchaseAmount;\n    bytes exchangeData;\n}\n\n/**\n * Supports vaults that borrow a token and stake it into a token that earns yield but may\n * require some illiquid redemption period.\n */\nabstract contract AbstractStakingStrategy is AbstractYieldStrategy {\n    using SafeERC20 for ERC20;\n\n    address internal immutable withdrawToken;\n\n    constructor(\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) AbstractYieldStrategy(_asset, _yieldToken, _feeRate, ERC20(_yieldToken).decimals()) {\n        // For Pendle PT the yield token does not define the withdraw request manager,\n        // it is the token out sy\n        withdrawRequestManager = _withdrawRequestManager;\n        withdrawToken = address(withdrawRequestManager) != address(0) ? withdrawRequestManager.WITHDRAW_TOKEN() : address(0);\n    }\n\n    /// @notice Returns the total value in terms of the borrowed token of the account's position\n    function convertToAssets(uint256 shares) public view override returns (uint256) {\n        if (t_CurrentAccount != address(0) && _isWithdrawRequestPending(t_CurrentAccount)) {\n            (bool hasRequest, uint256 value) = withdrawRequestManager.getWithdrawRequestValue(\n                address(this), t_CurrentAccount, asset, shares\n            );\n\n            // If the account does not have a withdraw request then this will fall through\n            // to the super implementation.\n            if (hasRequest) return value;\n        }\n\n        return super.convertToAssets(shares);\n    }\n\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override virtual returns (uint256 requestId) {\n        ERC20(yieldToken).approve(address(withdrawRequestManager), yieldTokenAmount);\n        requestId = withdrawRequestManager.initiateWithdraw({\n            account: account, yieldTokenAmount: yieldTokenAmount, sharesAmount: sharesHeld, data: data\n        });\n    }\n\n    /// @dev By default we can use the withdraw request manager to stake the tokens\n    function _mintYieldTokens(uint256 assets, address /* receiver */, bytes memory depositData) internal override virtual {\n        ERC20(asset).approve(address(withdrawRequestManager), assets);\n        withdrawRequestManager.stakeTokens(address(asset), assets, depositData);\n    }\n\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal override {\n        if (isEscrowed) {\n            (WithdrawRequest memory w, /* */) = withdrawRequestManager.getWithdrawRequest(address(this), sharesOwner);\n            uint256 yieldTokensBurned = uint256(w.yieldTokenAmount) * sharesToRedeem / w.sharesAmount;\n\n            (uint256 tokensClaimed, bool finalized) = withdrawRequestManager.finalizeAndRedeemWithdrawRequest({\n                account: sharesOwner, withdrawYieldTokenAmount: yieldTokensBurned, sharesToBurn: sharesToRedeem\n            });\n            if (!finalized) revert WithdrawRequestNotFinalized(w.requestId);\n\n            // Trades may be required here if the borrowed token is not the same as what is\n            // received when redeeming.\n            if (asset != withdrawToken) {\n                RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n                Trade memory trade = Trade({\n                    tradeType: TradeType.EXACT_IN_SINGLE,\n                    sellToken: address(withdrawToken),\n                    buyToken: address(asset),\n                    amount: tokensClaimed,\n                    limit: params.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: params.exchangeData\n                });\n\n                _executeTrade(trade, params.dexId);\n            }\n        } else {\n            uint256 yieldTokensBurned = convertSharesToYieldToken(sharesToRedeem);\n            _executeInstantRedemption(yieldTokensBurned, redeemData);\n        }\n    }\n\n    /// @notice Default implementation for an instant redemption is to sell the staking token to the\n    /// borrow token through the trading module. Can be overridden if required for different implementations.\n    function _executeInstantRedemption(\n        uint256 yieldTokensToRedeem,\n        bytes memory redeemData\n    ) internal virtual returns (uint256 assetsPurchased) {\n        RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(yieldToken),\n            buyToken: address(asset),\n            amount: yieldTokensToRedeem,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        // Executes a trade on the given Dex, the vault must have permissions set for\n        // each dex and token it wants to sell.\n        (/* */, assetsPurchased) = _executeTrade(trade, params.dexId);\n    }\n    \n    function _preLiquidation(address, address, uint256, uint256) internal override { /* no-op */ }\n\n    function _postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal override returns (bool didTokenize) {\n        if (address(withdrawRequestManager) != address(0)) {\n            // No need to accrue fees because neither the total supply or total yield token balance is changing. If there\n            // is no withdraw request then this will be a noop.\n            didTokenize = withdrawRequestManager.tokenizeWithdrawRequest(liquidateAccount, liquidator, sharesToLiquidator);\n        }\n    }\n\n}",
        "AbstractYieldStrategy.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ReentrancyGuardTransient} from \"@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol\";\nimport {DEFAULT_DECIMALS, DEFAULT_PRECISION, YEAR, ADDRESS_REGISTRY} from \"./utils/Constants.sol\";\n\nimport {\n    Unauthorized,\n    UnauthorizedLendingMarketTransfer,\n    InsufficientSharesHeld,\n    CannotLiquidate,\n    CannotEnterPosition,\n    CurrentAccountAlreadySet\n} from \"./interfaces/Errors.sol\";\nimport {IYieldStrategy} from \"./interfaces/IYieldStrategy.sol\";\nimport {IOracle} from \"./interfaces/Morpho/IOracle.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Trade, TradeType, TRADING_MODULE, nProxy, TradeFailed} from \"./interfaces/ITradingModule.sol\";\nimport {IWithdrawRequestManager} from \"./interfaces/IWithdrawRequestManager.sol\";\nimport {Initializable} from \"./proxy/Initializable.sol\";\nimport {ADDRESS_REGISTRY} from \"./utils/Constants.sol\";\nimport {ILendingRouter} from \"./interfaces/ILendingRouter.sol\";\n\n/// @title AbstractYieldStrategy\n/// @notice This is the base contract for all yield strategies, it implements the core logic for\n/// minting, burning and the valuation of tokens.\nabstract contract AbstractYieldStrategy is Initializable, ERC20, ReentrancyGuardTransient, IYieldStrategy {\n    using TokenUtils for ERC20;\n    using SafeERC20 for ERC20;\n\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\n    uint256 internal constant VIRTUAL_YIELD_TOKENS = 1;\n    uint256 internal constant SHARE_PRECISION = DEFAULT_PRECISION * VIRTUAL_SHARES;\n\n    /// @inheritdoc IYieldStrategy\n    address public immutable override asset;\n    /// @inheritdoc IYieldStrategy\n    address public immutable override yieldToken;\n    /// @inheritdoc IYieldStrategy\n    uint256 public immutable override feeRate;\n\n    IWithdrawRequestManager internal immutable withdrawRequestManager;\n\n    uint8 internal immutable _yieldTokenDecimals;\n    uint8 internal immutable _assetDecimals;\n\n    /********* Storage Variables *********/\n    string private s_name;\n    string private s_symbol;\n\n    uint32 private s_lastFeeAccrualTime;\n    uint256 private s_accruedFeesInYieldToken;\n    uint256 private s_escrowedShares;\n    /****** End Storage Variables ******/\n\n    /********* Transient Variables *********/\n    // Used to adjust the valuation call of price(), is set on some methods and\n    // cleared by the lending router using clearCurrentAccount(). This is required to\n    // ensure that the variable is set throughout the entire context of the lending router\n    // call.\n    address internal transient t_CurrentAccount;\n    // Set and cleared on every call to a lending router authorized method\n    address internal transient t_CurrentLendingRouter;\n    // Used to authorize transfers off of the lending market\n    address internal transient t_AllowTransfer_To;\n    uint256 internal transient t_AllowTransfer_Amount;\n    /****** End Transient Variables ******/\n\n    constructor(\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        uint8 __yieldTokenDecimals\n    ) ERC20(\"\", \"\") {\n        feeRate = _feeRate;\n        asset = address(_asset);\n        yieldToken = address(_yieldToken);\n        // Not all yield tokens have a decimals() function (i.e. Convex staked tokens), so we\n        // do have to pass in the decimals as a parameter.\n        _yieldTokenDecimals = __yieldTokenDecimals;\n        _assetDecimals = TokenUtils.getDecimals(_asset);\n    }\n\n    function name() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        return s_name;\n    }\n\n    function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        return s_symbol;\n    }\n\n    /*** Valuation and Conversion Functions ***/\n\n    /// @inheritdoc IYieldStrategy\n    function convertSharesToYieldToken(uint256 shares) public view override returns (uint256) {\n        // NOTE: rounds down on division\n        return (shares * (_yieldTokenBalance() - feesAccrued() + VIRTUAL_YIELD_TOKENS)) / (effectiveSupply());\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function convertYieldTokenToShares(uint256 yieldTokens) public view returns (uint256) {\n        // NOTE: rounds down on division\n        return (yieldTokens * effectiveSupply()) / (_yieldTokenBalance() - feesAccrued() + VIRTUAL_YIELD_TOKENS);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function convertToShares(uint256 assets) public view override returns (uint256) {\n        // NOTE: rounds down on division\n        uint256 yieldTokens = assets * (10 ** (_yieldTokenDecimals + DEFAULT_DECIMALS)) / \n            (convertYieldTokenToAsset() * (10 ** _assetDecimals));\n        return convertYieldTokenToShares(yieldTokens);\n    }\n\n    /// @inheritdoc IOracle\n    function price() public view override returns (uint256) {\n        return convertToAssets(SHARE_PRECISION) * (10 ** (36 - 24));\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function price(address borrower) external override returns (uint256) {\n        // Do not change the current account in this method since this method is not\n        // authenticated and we do not want to have any unexpected side effects.\n        address prevCurrentAccount = t_CurrentAccount;\n\n        t_CurrentAccount = borrower;\n        uint256 p = convertToAssets(SHARE_PRECISION) * (10 ** (36 - 24));\n\n        t_CurrentAccount = prevCurrentAccount;\n        return p;\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function totalAssets() public view override returns (uint256) {\n        return convertToAssets(totalSupply());\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function convertYieldTokenToAsset() public view returns (uint256) {\n        // The trading module always returns a positive rate in 18 decimals so we can safely\n        // cast to uint256\n        (int256 rate , /* */) = TRADING_MODULE.getOraclePrice(yieldToken, asset);\n        return uint256(rate);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function effectiveSupply() public view returns (uint256) {\n        return (totalSupply() - s_escrowedShares + VIRTUAL_SHARES);\n    }\n\n    /*** Fee Methods ***/\n\n    /// @inheritdoc IYieldStrategy\n    function feesAccrued() public view override returns (uint256 feesAccruedInYieldToken) {\n        return s_accruedFeesInYieldToken + _calculateAdditionalFeesInYieldToken();\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function collectFees() external override {\n        _accrueFees();\n        _transferYieldTokenToOwner(ADDRESS_REGISTRY.feeReceiver(), s_accruedFeesInYieldToken);\n\n        delete s_accruedFeesInYieldToken;\n    }\n\n    /*** Core Functions ***/\n    modifier onlyLendingRouter() {\n        if (ADDRESS_REGISTRY.isLendingRouter(msg.sender) == false) revert Unauthorized(msg.sender);\n        t_CurrentLendingRouter = msg.sender;\n        _;\n        delete t_CurrentLendingRouter;\n    }\n\n    modifier setCurrentAccount(address onBehalf) {\n        if (t_CurrentAccount == address(0)) {\n            t_CurrentAccount = onBehalf;\n        } else if (t_CurrentAccount != onBehalf) {\n            revert CurrentAccountAlreadySet();\n        }\n\n        _;\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function clearCurrentAccount() external override onlyLendingRouter {\n        delete t_CurrentAccount;\n    }\n\n    function mintShares(\n        uint256 assetAmount,\n        address receiver,\n        bytes calldata depositData\n    ) external override onlyLendingRouter setCurrentAccount(receiver) nonReentrant returns (uint256 sharesMinted) {\n        // Cannot mint shares if the receiver has an active withdraw request\n        if (_isWithdrawRequestPending(receiver)) revert CannotEnterPosition();\n        ERC20(asset).safeTransferFrom(t_CurrentLendingRouter, address(this), assetAmount);\n        sharesMinted = _mintSharesGivenAssets(assetAmount, depositData, receiver);\n\n        t_AllowTransfer_To = t_CurrentLendingRouter;\n        t_AllowTransfer_Amount = sharesMinted;\n        // Transfer the shares to the lending router so it can supply collateral\n        _transfer(receiver, t_CurrentLendingRouter, sharesMinted);\n    }\n\n    function burnShares(\n        address sharesOwner,\n        uint256 sharesToBurn,\n        uint256 sharesHeld,\n        bytes calldata redeemData\n    ) external override onlyLendingRouter setCurrentAccount(sharesOwner) nonReentrant returns (uint256 assetsWithdrawn) {\n        assetsWithdrawn = _burnShares(sharesToBurn, sharesHeld, redeemData, sharesOwner);\n\n        // Send all the assets back to the lending router\n        ERC20(asset).safeTransfer(t_CurrentLendingRouter, assetsWithdrawn);\n    }\n\n    function allowTransfer(\n        address to, uint256 amount, address currentAccount\n    ) external setCurrentAccount(currentAccount) onlyLendingRouter {\n        // Sets the transient variables to allow the lending market to transfer shares on exit position\n        // or liquidation.\n        t_AllowTransfer_To = to;\n        t_AllowTransfer_Amount = amount;\n    }\n\n    function preLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidate,\n        uint256 accountSharesHeld\n    ) external onlyLendingRouter {\n        t_CurrentAccount = liquidateAccount;\n        // Liquidator cannot liquidate if they have an active withdraw request, including a tokenized\n        // withdraw request.\n        if (_isWithdrawRequestPending(liquidator)) revert CannotEnterPosition();\n        // Cannot receive a pending withdraw request if the liquidator has a balanceOf\n        if (_isWithdrawRequestPending(liquidateAccount) && balanceOf(liquidator) > 0) {\n            revert CannotEnterPosition();\n        }\n        _preLiquidation(liquidateAccount, liquidator, sharesToLiquidate, accountSharesHeld);\n\n        // Allow transfers to the lending router which will proxy the call to liquidate.\n        t_AllowTransfer_To = msg.sender;\n        t_AllowTransfer_Amount = sharesToLiquidate;\n    }\n\n    function postLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidator\n    ) external onlyLendingRouter {\n        t_AllowTransfer_To = liquidator;\n        t_AllowTransfer_Amount = sharesToLiquidator;\n        // Transfer the shares to the liquidator from the lending router\n        _transfer(t_CurrentLendingRouter, liquidator, sharesToLiquidator);\n\n        _postLiquidation(liquidator, liquidateAccount, sharesToLiquidator);\n\n        // Clear the transient variables to prevent re-use in a future call.\n        delete t_CurrentAccount;\n    }\n\n    /// @inheritdoc IYieldStrategy\n    /// @dev We do not set the current account here because valuation is not done in this method.\n    /// A native balance does not require a collateral check.\n    function redeemNative(\n        uint256 sharesToRedeem,\n        bytes memory redeemData\n    ) external override nonReentrant returns (uint256 assetsWithdrawn) {\n        uint256 sharesHeld = balanceOf(msg.sender);\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n\n        assetsWithdrawn = _burnShares(sharesToRedeem, sharesHeld, redeemData, msg.sender);\n        ERC20(asset).safeTransfer(msg.sender, assetsWithdrawn);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function initiateWithdraw(\n        address account,\n        uint256 sharesHeld,\n        bytes calldata data\n    ) external onlyLendingRouter setCurrentAccount(account) override returns (uint256 requestId) {\n        requestId = _withdraw(account, sharesHeld, data);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    /// @dev We do not set the current account here because valuation is not done in this method. A\n    /// native balance does not require a collateral check.\n    function initiateWithdrawNative(\n        bytes memory data\n    ) external override returns (uint256 requestId) {\n        requestId = _withdraw(msg.sender, balanceOf(msg.sender), data);\n    }\n\n    function _withdraw(address account, uint256 sharesHeld, bytes memory data) internal returns (uint256 requestId) {\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n\n        // Accrue fees before initiating a withdraw since it will change the effective supply\n        _accrueFees();\n        uint256 yieldTokenAmount = convertSharesToYieldToken(sharesHeld);\n        requestId = _initiateWithdraw(account, yieldTokenAmount, sharesHeld, data);\n        // Escrow the shares after the withdraw since it will change the effective supply\n        // during reward claims when using the RewardManagerMixin.\n        s_escrowedShares += sharesHeld;\n    }\n\n    /*** Private Functions ***/\n\n    function _calculateAdditionalFeesInYieldToken() private view returns (uint256 additionalFeesInYieldToken) {\n        uint256 timeSinceLastFeeAccrual = block.timestamp - s_lastFeeAccrualTime;\n        // e ^ (feeRate * timeSinceLastFeeAccrual / YEAR)\n        uint256 x = (feeRate * timeSinceLastFeeAccrual) / YEAR;\n        if (x == 0) return 0;\n\n        uint256 preFeeUserHeldYieldTokens = _yieldTokenBalance() - s_accruedFeesInYieldToken;\n        // Taylor approximation of e ^ x = 1 + x + x^2 / 2! + x^3 / 3! + ...\n        uint256 eToTheX = DEFAULT_PRECISION + x + (x * x) / (2 * DEFAULT_PRECISION) + (x * x * x) / (6 * DEFAULT_PRECISION * DEFAULT_PRECISION);\n        // Decay the user's yield tokens by e ^ (feeRate * timeSinceLastFeeAccrual / YEAR)\n        uint256 postFeeUserHeldYieldTokens = preFeeUserHeldYieldTokens * DEFAULT_PRECISION / eToTheX;\n\n        additionalFeesInYieldToken = preFeeUserHeldYieldTokens - postFeeUserHeldYieldTokens;\n    }\n\n    function _accrueFees() private {\n        if (s_lastFeeAccrualTime == block.timestamp) return;\n        // NOTE: this has to be called before any mints or burns.\n        s_accruedFeesInYieldToken += _calculateAdditionalFeesInYieldToken();\n        s_lastFeeAccrualTime = uint32(block.timestamp);\n    }\n\n    function _update(address from, address to, uint256 value) internal override {\n        if (from != address(0) && to != address(0)) {\n            // Any transfers off of the lending market must be authorized here, this means that native balances\n            // held cannot be transferred.\n            if (t_AllowTransfer_To != to) revert UnauthorizedLendingMarketTransfer(from, to, value);\n            if (t_AllowTransfer_Amount < value) revert UnauthorizedLendingMarketTransfer(from, to, value);\n\n            delete t_AllowTransfer_To;\n            delete t_AllowTransfer_Amount;\n        }\n\n        super._update(from, to, value);\n    }\n\n    /*** Internal Helper Functions ***/\n\n    function _isWithdrawRequestPending(address account) virtual internal view returns (bool) {\n        return address(withdrawRequestManager) != address(0)\n            && withdrawRequestManager.isPendingWithdrawRequest(address(this), account);\n    }\n\n    function _yieldTokenBalance() internal view returns (uint256) {\n        return ERC20(yieldToken).balanceOf(address(this));\n    }\n\n    /// @dev Can be used to delegate call to the TradingModule's implementation in order to execute a trade\n    function _executeTrade(\n        Trade memory trade,\n        uint16 dexId\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        if (trade.tradeType == TradeType.STAKE_TOKEN) {\n            IWithdrawRequestManager wrm = ADDRESS_REGISTRY.getWithdrawRequestManager(trade.buyToken);\n            ERC20(trade.sellToken).checkApprove(address(wrm), trade.amount);\n            amountBought = wrm.stakeTokens(trade.sellToken, trade.amount, trade.exchangeData);\n            return (trade.amount, amountBought);\n        } else {\n            address implementation = nProxy(payable(address(TRADING_MODULE))).getImplementation();\n            bytes memory result = _delegateCall(\n                implementation, abi.encodeWithSelector(TRADING_MODULE.executeTrade.selector, dexId, trade)\n            );\n            (amountSold, amountBought) = abi.decode(result, (uint256, uint256));\n        }\n    }\n\n    function _delegateCall(address target, bytes memory data) internal returns (bytes memory result) {\n        bool success;\n        (success, result) = target.delegatecall(data);\n        if (!success) {\n            assembly {\n                // Copy the return data to memory\n                returndatacopy(0, 0, returndatasize())\n                // Revert with the return data\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /*** Virtual Functions ***/\n\n    function _initialize(bytes calldata data) internal override virtual {\n        (string memory _name, string memory _symbol) = abi.decode(data, (string, string));\n        s_name = _name;\n        s_symbol = _symbol;\n\n        s_lastFeeAccrualTime = uint32(block.timestamp);\n        emit VaultCreated(address(this));\n    }\n\n    /// @dev Marked as virtual to allow for RewardManagerMixin to override\n    function _mintSharesGivenAssets(uint256 assets, bytes memory depositData, address receiver) internal virtual returns (uint256 sharesMinted) {\n        if (assets == 0) return 0;\n\n        // First accrue fees on the yield token\n        _accrueFees();\n        uint256 initialYieldTokenBalance = _yieldTokenBalance();\n        _mintYieldTokens(assets, receiver, depositData);\n        uint256 yieldTokensMinted = _yieldTokenBalance() - initialYieldTokenBalance;\n\n        sharesMinted = (yieldTokensMinted * effectiveSupply()) / (initialYieldTokenBalance - feesAccrued() + VIRTUAL_YIELD_TOKENS);\n        _mint(receiver, sharesMinted);\n    }\n\n    /// @dev Marked as virtual to allow for RewardManagerMixin to override\n    function _burnShares(\n        uint256 sharesToBurn,\n        uint256 /* sharesHeld */,\n        bytes memory redeemData,\n        address sharesOwner\n    ) internal virtual returns (uint256 assetsWithdrawn) {\n        if (sharesToBurn == 0) return 0;\n        bool isEscrowed = _isWithdrawRequestPending(sharesOwner);\n\n        uint256 initialAssetBalance = TokenUtils.tokenBalance(asset);\n\n        // First accrue fees on the yield token\n        _accrueFees();\n        _redeemShares(sharesToBurn, sharesOwner, isEscrowed, redeemData);\n        if (isEscrowed) s_escrowedShares -= sharesToBurn;\n\n        uint256 finalAssetBalance = TokenUtils.tokenBalance(asset);\n        assetsWithdrawn = finalAssetBalance - initialAssetBalance;\n\n        // This burns the shares from the sharesOwner's balance\n        _burn(sharesOwner, sharesToBurn);\n    }\n\n    /// @dev Some yield tokens (such as Convex staked tokens) cannot be transferred, so we may need\n    /// to override this function.\n    function _transferYieldTokenToOwner(address owner, uint256 yieldTokens) internal virtual {\n        ERC20(yieldToken).safeTransfer(owner, yieldTokens);\n    }\n\n    /// @dev Returns the maximum number of shares that can be liquidated. Allows the strategy to override the\n    /// underlying lending market's liquidation logic.\n    function _preLiquidation(address liquidateAccount, address liquidator, uint256 sharesToLiquidate, uint256 accountSharesHeld) internal virtual;\n\n    /// @dev Called after liquidation\n    function _postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal virtual returns (bool didTokenize);\n\n    /// @dev Mints yield tokens given a number of assets.\n    function _mintYieldTokens(uint256 assets, address receiver, bytes memory depositData) internal virtual;\n\n    /// @dev Redeems shares\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal virtual;\n\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal virtual returns (uint256 requestId);\n\n    /// @inheritdoc IYieldStrategy\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        uint256 yieldTokens = convertSharesToYieldToken(shares);\n        // NOTE: rounds down on division\n        return (yieldTokens * convertYieldTokenToAsset() * (10 ** _assetDecimals)) /\n            (10 ** (_yieldTokenDecimals + DEFAULT_DECIMALS));\n    }\n\n}\n\n",
        "RewardManagerMixin.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {IRewardManager} from \"../interfaces/IRewardManager.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {ILendingRouter} from \"../interfaces/ILendingRouter.sol\";\nimport {ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {CannotLiquidateZeroShares} from \"../interfaces/Errors.sol\";\n\nabstract contract RewardManagerMixin is AbstractYieldStrategy {\n    IRewardManager public immutable REWARD_MANAGER;\n\n    uint256 internal transient t_Liquidator_SharesBefore;\n    uint256 internal transient t_LiquidateAccount_SharesBefore;\n\n    constructor(\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        uint8 _yieldTokenDecimals\n    ) AbstractYieldStrategy(_asset, _yieldToken, _feeRate, _yieldTokenDecimals) {\n        REWARD_MANAGER = IRewardManager(_rewardManager);\n    }\n\n    function _preLiquidation(\n        address /* liquidateAccount */,\n        address liquidator,\n        uint256 /* sharesToLiquidate */,\n        uint256 accountSharesHeld\n    ) internal override virtual {\n        // This only works because the liquidator is prevented from having a position on the lending router so any\n        // balance will be a native token balance.\n        t_Liquidator_SharesBefore = balanceOf(liquidator);\n        t_LiquidateAccount_SharesBefore = accountSharesHeld;\n    }\n\n    function __postLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidator\n    ) internal virtual returns (bool didTokenize);\n\n    function _postLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidator\n    ) internal override returns (bool didTokenize) {\n        // Total supply does not change during liquidation\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        if (sharesToLiquidator == 0) revert CannotLiquidateZeroShares();\n\n        didTokenize = __postLiquidation(liquidator, liquidateAccount, sharesToLiquidator);\n\n        _updateAccountRewards({\n            account: liquidator,\n            accountSharesBefore: t_Liquidator_SharesBefore,\n            accountSharesAfter: t_Liquidator_SharesBefore + sharesToLiquidator,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: didTokenize\n        });\n\n        _updateAccountRewards({\n            account: liquidateAccount,\n            accountSharesBefore: t_LiquidateAccount_SharesBefore,\n            accountSharesAfter: t_LiquidateAccount_SharesBefore - sharesToLiquidator,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: didTokenize\n        });\n    }\n\n    function _mintSharesGivenAssets(\n        uint256 assets,\n        bytes memory depositData,\n        address receiver\n    ) internal override returns (uint256 sharesMinted) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        uint256 initialVaultShares = ILendingRouter(t_CurrentLendingRouter).balanceOfCollateral(receiver, address(this));\n        sharesMinted = super._mintSharesGivenAssets(assets, depositData, receiver);\n        _updateAccountRewards({\n            account: receiver,\n            accountSharesBefore: initialVaultShares,\n            accountSharesAfter: initialVaultShares + sharesMinted,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            // Shares cannot be in escrow during minting\n            sharesInEscrow: false\n        });\n    }\n\n    function _burnShares(\n        uint256 sharesToBurn,\n        uint256 sharesHeld,\n        bytes memory redeemData,\n        address sharesOwner\n    ) internal override returns (uint256 assetsWithdrawn) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        // Get the escrow state before burning the shares since it will be cleared if\n        // the entire balance is burned.\n        bool wasEscrowed = _isWithdrawRequestPending(sharesOwner);\n\n        assetsWithdrawn = super._burnShares(sharesToBurn, sharesHeld, redeemData, sharesOwner);\n\n        _updateAccountRewards({\n            account: sharesOwner,\n            accountSharesBefore: sharesHeld,\n            // If shares after is zero then the escrow state will be cleared\n            accountSharesAfter: sharesHeld - sharesToBurn,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: wasEscrowed\n        });\n    }\n\n    function __initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal virtual returns (uint256 requestId);\n    \n    /// @dev Ensures that the account no longer accrues rewards after a withdraw request is initiated.\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override returns (uint256 requestId) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n\n        // Claim all rewards before initiating a withdraw shares not considered \n        // in the escrow state at this point.\n        _updateAccountRewards({\n            account: account,\n            accountSharesBefore: sharesHeld,\n            accountSharesAfter: sharesHeld,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: false\n        });\n\n        requestId = __initiateWithdraw(account, yieldTokenAmount, sharesHeld, data);\n    }\n\n    function _updateAccountRewards(\n        address account,\n        uint256 effectiveSupplyBefore,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        bool sharesInEscrow\n    ) internal returns (bytes memory) {\n        return _delegateCall(address(REWARD_MANAGER), abi.encodeWithSelector(\n            IRewardManager.updateAccountRewards.selector,\n            account, effectiveSupplyBefore, accountSharesBefore, accountSharesAfter, sharesInEscrow\n        ));\n    }\n\n    function claimAccountRewards(\n        address account,\n        uint256 sharesHeld\n    ) external nonReentrant returns (uint256[] memory rewards) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        if (!ADDRESS_REGISTRY.isLendingRouter(msg.sender)) {\n            // If the caller is not a lending router we get the shares held in a\n            // native token account.\n            sharesHeld = balanceOf(account);\n        }\n        // Short circuit if the account has no shares or a withdraw request is pending\n        if (sharesHeld == 0 || _isWithdrawRequestPending(account)) return rewards;\n\n        bytes memory result = _updateAccountRewards({\n            account: account,\n            accountSharesBefore: sharesHeld,\n            accountSharesAfter: sharesHeld,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: false\n        });\n\n        rewards = abi.decode(result, (uint256[]));\n    }\n\n    fallback() external {\n        address target = address(REWARD_MANAGER);\n        // Cannot call updateAccountRewards unless it's through the internal methods\n        require(msg.sig != IRewardManager.updateAccountRewards.selector);\n        bytes memory result = _delegateCall(target, msg.data);\n\n        assembly {\n            // Copy the result to memory\n            let resultSize := mload(result)\n            // Copy the result data (skipping the length prefix)\n            let resultData := add(result, 0x20)\n            // Copy to the return data area\n            return(resultData, resultSize)\n        }\n    }\n}\n",
        "GenericERC4626.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {AbstractWithdrawRequestManager} from \"./AbstractWithdrawRequestManager.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @dev Used for ERC4626s that can be staked and unstaked on demand without any additional\n/// time constraints.\ncontract GenericERC4626WithdrawRequestManager is AbstractWithdrawRequestManager {\n\n    uint256 private currentRequestId;\n    mapping(uint256 => uint256) private s_withdrawRequestShares;\n\n    constructor(address _erc4626)\n        AbstractWithdrawRequestManager(IERC4626(_erc4626).asset(), _erc4626, IERC4626(_erc4626).asset()) { }\n\n    function _initiateWithdrawImpl(\n        address /* account */,\n        uint256 sharesToWithdraw,\n        bytes calldata /* data */\n    ) override internal returns (uint256 requestId) {\n        requestId = ++currentRequestId;\n        s_withdrawRequestShares[requestId] = sharesToWithdraw;\n    }\n\n    function _stakeTokens(uint256 amount, bytes memory /* stakeData */) internal override {\n        ERC20(STAKING_TOKEN).approve(address(YIELD_TOKEN), amount);\n        IERC4626(YIELD_TOKEN).deposit(amount, address(this));\n    }\n\n    function _finalizeWithdrawImpl(\n        address /* account */,\n        uint256 requestId\n    ) internal override returns (uint256 tokensClaimed, bool finalized) {\n        uint256 sharesToRedeem = s_withdrawRequestShares[requestId];\n        delete s_withdrawRequestShares[requestId];\n        tokensClaimed = IERC4626(YIELD_TOKEN).redeem(sharesToRedeem, address(this), address(this));\n        finalized = true;\n    }\n\n    function canFinalizeWithdrawRequest(uint256 /* requestId */) public pure override returns (bool) {\n        return true;\n    }\n}"
    }
}