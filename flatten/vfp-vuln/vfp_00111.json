{
    "vfp_id": "vfp_00111",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Reward distribution enables front-running attacks and reward siphoning",
            "description": "The reward distribution mechanism allocates rewards to all vaults backing an agent at the time of loan repayment without considering the duration of their delegation. This creates a timing vulnerability where opportunistic actors can monitor pending repayment transactions in the mempool and front-run them by adding their own collateral just before repayment. The root cause is the lack of time-based eligibility criteria for reward distribution. By doing so, these actors can capture a disproportionate share of the accrued interest rewards despite having provided capital for only a minimal period. This allows them to systematically siphon rewards from long-term backers who actually bore the lending risk over time. The impact is an unfair redistribution of rewards that disincentivizes long-term participation and undermines the economic fairness of the protocol.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/NetworkMiddleware.sol",
                "contracts/delegation/Delegation.sol",
                "StakedCap.sol::distributeRewards"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The NetworkMiddleware.registerVault function does not check if a vault has already been registered for a given agent, allowing duplicate entries. This leads to the same vault's delegation being counted multiple times when calculating coverage. The root cause is the lack of deduplication or uniqueness checks during vault registration. An attacker or user could exploit this by re-registering the same vault multiple times, especially after a transaction failure and replacement. The impact is an inflated delegation value, which can cause incorrect risk assessment and lead to under-collateralized liquidations, resulting in potential loss of funds for the senior tranche.\n",
            "severity": "Medium",
            "location": [
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::registerVault#58-69",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::coverage#195-206",
                "Delegation.sol::addVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 47,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The vulnerability allows the same vault to be registered multiple times in the middleware, resulting in inflated delegation counts. This is caused by the absence of a check to prevent duplicate vault registrations. An attacker could exploit this by repeatedly adding the same vault to artificially increase its delegation weight. This would distort yield distribution and governance voting power, leading to unfair advantages and potential economic imbalance.\n",
            "severity": "Medium",
            "location": [
                "Middleware.sol::_verifyVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        }
    ],
    "affected_files": {
        "NetworkMiddleware.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../../../access/Access.sol\";\nimport { IOracle } from \"../../../interfaces/IOracle.sol\";\nimport { IStakerRewards } from \"../../../interfaces/IStakerRewards.sol\";\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IBurnerRouter } from \"@symbioticfi/burners/src/interfaces/router/IBurnerRouter.sol\";\n\nimport { INetworkMiddleware } from \"../../../interfaces/INetworkMiddleware.sol\";\nimport { NetworkMiddlewareStorageUtils } from \"../../../storage/NetworkMiddlewareStorageUtils.sol\";\nimport { Subnetwork } from \"@symbioticfi/core/src/contracts/libraries/Subnetwork.sol\";\nimport { IEntity } from \"@symbioticfi/core/src/interfaces/common/IEntity.sol\";\nimport { IRegistry } from \"@symbioticfi/core/src/interfaces/common/IRegistry.sol\";\nimport { IBaseDelegator } from \"@symbioticfi/core/src/interfaces/delegator/IBaseDelegator.sol\";\nimport { ISlasher } from \"@symbioticfi/core/src/interfaces/slasher/ISlasher.sol\";\nimport { IVault } from \"@symbioticfi/core/src/interfaces/vault/IVault.sol\";\n\n/// @title Cap Symbiotic Network Middleware Contract\n/// @author Cap Labs\n/// @notice This contract manages the symbiotic collateral and slashing.\ncontract NetworkMiddleware is INetworkMiddleware, UUPSUpgradeable, Access, NetworkMiddlewareStorageUtils {\n    using SafeERC20 for IERC20;\n\n    /// @dev Disable initializers on the implementation\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize\n    /// @param _accessControl Access control address\n    /// @param _network Network address\n    /// @param _vaultRegistry Vault registry address\n    /// @param _oracle Oracle address\n    /// @param _requiredEpochDuration Required epoch duration in seconds\n    /// @param _feeAllowed Fee allowed to be charged on rewards by restakers\n    function initialize(\n        address _accessControl,\n        address _network,\n        address _vaultRegistry,\n        address _oracle,\n        uint48 _requiredEpochDuration,\n        uint256 _feeAllowed\n    ) external initializer {\n        __Access_init(_accessControl);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        $.network = _network;\n        $.vaultRegistry = _vaultRegistry;\n        $.oracle = _oracle;\n        $.requiredEpochDuration = _requiredEpochDuration;\n        $.feeAllowed = _feeAllowed;\n    }\n\n    /// @notice Register agent to be used as collateral within the CAP system\n    /// @param _vault Vault address\n    /// @param _agent Agent address\n    function registerAgent(address _vault, address _agent) external checkAccess(this.registerAgent.selector) {\n        _verifyVault(_vault);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        if (_agent == address(0)) revert InvalidAgent();\n        if ($.agentsToVault[_agent] != address(0)) revert ExistingCoverage();\n        if (!$.vaults[_vault].exists) revert VaultDoesNotExist();\n        $.agentsToVault[_agent] = _vault;\n        emit AgentRegistered(_agent);\n    }\n\n    /// @notice Register vault to be used as collateral within the CAP system\n    /// @param _vault Vault address\n    /// @param _stakerRewarder Staker rewarder address\n    function registerVault(address _vault, address _stakerRewarder) external checkAccess(this.registerVault.selector) {\n        _verifyVault(_vault);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        Vault storage vault = $.vaults[_vault];\n        if (vault.exists) revert VaultExists();\n        vault.stakerRewarder = _stakerRewarder;\n        vault.exists = true;\n        emit VaultRegistered(_vault);\n    }\n\n    /// @notice Set fee allowed\n    /// @param _feeAllowed Fee allowed to be charged on rewards by restakers\n    function setFeeAllowed(uint256 _feeAllowed) external checkAccess(this.setFeeAllowed.selector) {\n        getNetworkMiddlewareStorage().feeAllowed = _feeAllowed;\n    }\n\n    /// @notice Slash delegation and send to recipient\n    /// @param _agent Agent address\n    /// @param _recipient Recipient of the slashed assets\n    /// @param _slashShare Percentage of delegation to slash encoded with 18 decimals\n    /// @param _timestamp Timestamp to slash at\n    function slash(address _agent, address _recipient, uint256 _slashShare, uint48 _timestamp)\n        external\n        checkAccess(this.slash.selector)\n    {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n\n        IVault vault = IVault($.agentsToVault[_agent]);\n\n        (, uint256 totalSlashableCollateral) =\n            slashableCollateralByVault($.network, _agent, address(vault), $.oracle, _timestamp);\n\n        // Round up in favor of the liquidator\n        uint256 slashShareOfCollateral = (totalSlashableCollateral * _slashShare / 1e18) + 1;\n\n        // If the slash share is greater than the total slashable collateral, set it to the total slashable collateral\n        if (slashShareOfCollateral > totalSlashableCollateral) {\n            slashShareOfCollateral = totalSlashableCollateral;\n        }\n\n        ISlasher(vault.slasher()).slash(subnetwork(_agent), _agent, slashShareOfCollateral, _timestamp, new bytes(0));\n\n        IBurnerRouter(vault.burner()).triggerTransfer(address(this));\n        IERC20(vault.collateral()).safeTransfer(_recipient, slashShareOfCollateral);\n\n        emit Slash(_agent, _recipient, slashShareOfCollateral);\n    }\n\n    /// @dev Get vault info\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @return burnerRouter The burner router contract\n    /// @return decimals The collateral token decimals\n    /// @return collateralPrice The collateral token price\n    function _getVaultInfo(address _network, address _agent, address _vault, address _oracle)\n        private\n        view\n        returns (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice)\n    {\n        burnerRouter = IBurnerRouter(IVault(_vault).burner());\n\n        // Check pending receivers\n        (address pendingReceiver,) = burnerRouter.pendingNetworkReceiver(_network);\n        if (pendingReceiver != address(0) && pendingReceiver != address(this)) {\n            return (IBurnerRouter(address(0)), 0, 0);\n        }\n\n        (pendingReceiver,) = burnerRouter.pendingOperatorNetworkReceiver(_network, _agent);\n        if (pendingReceiver != address(0) && pendingReceiver != address(this)) {\n            return (IBurnerRouter(address(0)), 0, 0);\n        }\n\n        address collateralAddress = IVault(_vault).collateral();\n        decimals = IERC20Metadata(collateralAddress).decimals();\n        (collateralPrice,) = IOracle(_oracle).getPrice(collateralAddress);\n    }\n\n    /// @notice Coverage of an agent by a specific vault at a given timestamp\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @param _timestamp Timestamp to check coverage at\n    /// @return collateralValue Coverage value in USD (8 decimals)\n    /// @return collateral Coverage amount in the vault's collateral token decimals\n    function coverageByVault(address _network, address _agent, address _vault, address _oracle, uint48 _timestamp)\n        public\n        view\n        returns (uint256 collateralValue, uint256 collateral)\n    {\n        (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice) =\n            _getVaultInfo(_network, _agent, _vault, _oracle);\n\n        if (address(burnerRouter) == address(0)) return (0, 0);\n\n        collateral = IBaseDelegator(IVault(_vault).delegator()).stakeAt(subnetwork(_agent), _agent, _timestamp, \"\");\n        collateralValue = collateral * collateralPrice / (10 ** decimals);\n    }\n\n    /// @notice Slashable collateral of an agent by a specific vault at a given timestamp\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @param _timestamp Timestamp to check slashable collateral at\n    /// @return collateralValue Slashable collateral value in USD (8 decimals)\n    function slashableCollateralByVault(\n        address _network,\n        address _agent,\n        address _vault,\n        address _oracle,\n        uint48 _timestamp\n    ) public view returns (uint256 collateralValue, uint256 collateral) {\n        (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice) =\n            _getVaultInfo(_network, _agent, _vault, _oracle);\n\n        if (address(burnerRouter) == address(0)) return (0, 0);\n\n        ISlasher slasher = ISlasher(IVault(_vault).slasher());\n        collateral = slasher.slashableStake(subnetwork(_agent), _agent, _timestamp, \"\");\n        collateralValue = collateral * collateralPrice / (10 ** decimals);\n    }\n\n    /// @notice Coverage of an agent by Symbiotic vaults\n    /// @param _agent Agent address\n    /// @return delegation Delegation amount in USD (8 decimals)\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        address _vault = $.agentsToVault[_agent];\n        if (_vault == address(0)) revert InvalidAgent();\n        address _network = $.network;\n        address _oracle = $.oracle;\n        uint48 _timestamp = uint48(block.timestamp);\n\n        (delegation,) = coverageByVault(_network, _agent, _vault, _oracle, _timestamp);\n    }\n\n    /// @notice Slashable collateral of an agent by Symbiotic vaults\n    /// @param _agent Agent address\n    /// @param _timestamp Timestamp to check slashable collateral at\n    /// @return _slashableCollateral Slashable collateral amount in USD (8 decimals)\n    function slashableCollateral(address _agent, uint48 _timestamp)\n        public\n        view\n        returns (uint256 _slashableCollateral)\n    {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        address _vault = $.agentsToVault[_agent];\n        address _network = $.network;\n        address _oracle = $.oracle;\n\n        (_slashableCollateral,) = slashableCollateralByVault(_network, _agent, _vault, _oracle, _timestamp);\n    }\n\n    /// @notice Subnetwork id\n    /// @dev Creates a collision resistant uint96 identifier by taking keccak256 hash of agent address\n    /// and using the first 96 bits of the hash\n    /// @param _agent Agent address\n    /// @return id Subnetwork identifier (first 96 bits of keccak256 hash of agent address)\n    function subnetworkIdentifier(address _agent) public pure returns (uint96 id) {\n        bytes32 hash = keccak256(abi.encodePacked(_agent));\n        id = uint96(uint256(hash)); // Takes first 96 bits of hash\n    }\n\n    /// @notice Subnetwork id concatenated with network address\n    /// @return id Subnetwork id\n    function subnetwork(address _agent) public view returns (bytes32 id) {\n        id = Subnetwork.subnetwork(getNetworkMiddlewareStorage().network, subnetworkIdentifier(_agent));\n    }\n\n    /// @notice Registered vault for an agent\n    /// @param _agent Agent address\n    /// @return vaultAddress Vault address\n    function vaults(address _agent) external view returns (address vaultAddress) {\n        vaultAddress = getNetworkMiddlewareStorage().agentsToVault[_agent];\n    }\n\n    /// @dev Verify a vault has the required specifications\n    /// @param _vault Vault address\n    function _verifyVault(address _vault) internal view {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n\n        if (!IRegistry($.vaultRegistry).isEntity(_vault)) {\n            revert NotVault();\n        }\n\n        if (!IVault(_vault).isInitialized()) revert VaultNotInitialized();\n\n        uint48 vaultEpoch = IVault(_vault).epochDuration();\n        if (vaultEpoch < $.requiredEpochDuration) revert InvalidEpochDuration($.requiredEpochDuration, vaultEpoch);\n\n        address slasher = IVault(_vault).slasher();\n        uint64 slasherType = IEntity(slasher).TYPE();\n        if (slasher == address(0)) revert NoSlasher();\n        if (slasherType != uint64(INetworkMiddleware.SlasherType.INSTANT)) revert InvalidSlasher();\n\n        address burner = IVault(_vault).burner();\n        if (burner == address(0)) revert NoBurner();\n        address receiver = IBurnerRouter(burner).networkReceiver($.network);\n        if (receiver != address(this)) revert InvalidBurnerRouter();\n\n        address delegator = IVault(_vault).delegator();\n        uint64 delegatorType = IEntity(delegator).TYPE();\n        if (delegatorType != uint64(INetworkMiddleware.DelegatorType.NETWORK_RESTAKE)) revert InvalidDelegator();\n    }\n\n    /// @notice Distribute rewards accumulated by the agent borrowing\n    /// @param _agent Agent address\n    /// @param _token Token address\n    function distributeRewards(address _agent, address _token) external checkAccess(this.distributeRewards.selector) {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        uint256 _amount = IERC20(_token).balanceOf(address(this));\n\n        address _vault = $.agentsToVault[_agent];\n        address stakerRewarder = $.vaults[_vault].stakerRewarder;\n        if (stakerRewarder == address(0)) revert NoStakerRewarder();\n\n        IERC20(_token).forceApprove(address(IStakerRewards(stakerRewarder)), _amount);\n        IStakerRewards(stakerRewarder).distributeRewards(\n            $.network, _token, _amount, abi.encode(uint48(block.timestamp - 1), $.feeAllowed, \"\", \"\")\n        );\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n"
    }
}