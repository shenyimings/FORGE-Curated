{
    "vfp_id": "vfp_00273",
    "project_name": "Across Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "relayTokens Calls Made By Forwarders May Fail",
            "description": "The `Router_Adapter` contract sends two separate messages to L2 forwarders: one to relay tokens and another to trigger their forwarding to L3. These messages may arrive out of order due to differing bridging mechanisms (e.g., CCTP for tokens, Arbitrum Inbox for messages). \nThe root cause is the lack of synchronization between token and message delivery channels, leading to race conditions where the `relayTokens` call on the forwarder attempts to send tokens before they arrive on L2. \nAn attacker could exploit this by triggering a sequence where message execution precedes token arrival, causing the relay to revert. This could be used to disrupt liquidity flow or force repeated transaction costs on users. \nThe impact is medium: temporary failure of token relays, requiring manual retries and increasing operational costs and user friction.\n",
            "severity": "Medium",
            "location": [
                "Router_Adapter.sol::relayTokens#109-111",
                "Router_Adapter.sol::relayMessage#115-119",
                "ForwarderBase.sol::relayTokens#119",
                "Arbitrum_Adapter.sol#L116-L119",
                "Arbitrum_Adapter.sol#L87-L96"
            ],
            "files": [
                "contracts/contracts/chain-adapters/Router_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "Router_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\nimport { ForwarderInterface } from \"./interfaces/ForwarderInterface.sol\";\nimport { HubPoolInterface } from \"../interfaces/HubPoolInterface.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to \"L3\" networks that do not have direct connections\n * with L1. L3's are defined as networks that connect to L1 indirectly via L2, and this contract sends\n * messages to those L3's by rerouting them via those L2's. This contract is called a \"Router\" because it uses\n * (i.e. delegatecall's) existing L2 adapter logic to send a message first from L1 to L2 and then from L2 to L3.\n * @dev Due to the constraints of the `SetCrossChainContracts` event as outlined in UMIP-157 and how the HubPool\n * delegatecalls adapters like this one, all messages relayed through this\n * adapter have target addresses on the L3's. However, these target addresses do not exist on L2 where all messages are\n * rerouted through. Therefore, this contract is designed to be used in tandem with \"L2 Forwarder Adapters\" which help\n * get the messages from L1 to L3 via L2's.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Router_Adapter is AdapterInterface {\n    // Adapter designed to relay messages from L1 to L2 addresses and delegatecalled by this contract to reroute\n    // messages to L3 via the L2_TARGET.\n    address public immutable L1_ADAPTER;\n    // L2_TARGET is a \"Forwarder\" contract that will help relay messages from L1 to L3. Messages are \"rerouted\" through\n    // the L2_TARGET.\n    address public immutable L2_TARGET;\n    // L2_CHAIN_ID is the chain ID of the network which is \"in between\" the L1 and L3. This network will contain the forwarder.\n    uint256 public immutable L2_CHAIN_ID;\n    // L3_CHAIN_ID is the chain ID of the network which contains the target spoke pool. This chain id is passed to the\n    // forwarder contract so that it may determine the correct L2-L3 bridge to use to arrive at L3.\n    uint256 public immutable L3_CHAIN_ID;\n    // Interface of the Hub Pool. Used to query state related to L1-L2 token mappings.\n    HubPoolInterface public immutable HUB_POOL;\n\n    error RelayMessageFailed();\n    error RelayTokensFailed(address l1Token);\n    error L2RouteNotWhitelisted(address l1Token);\n\n    /**\n     * @notice Constructs new Adapter. This contract will re-route messages destined for an L3 to L2_TARGET via the L1_ADAPTER contract.\n     * @param _l1Adapter Address of the adapter contract on mainnet which implements message transfers\n     * and token relays to the L2 where _l2Target is deployed.\n     * @param _l2Target Address of the L2 contract which receives the token and message relays in order to forward them to an L3.\n     * @param _l2ChainId Chain ID of the network which contains the forwarder. It is the network which is intermediate in message\n     * transmission from L1 to L3.\n     * @param _l3ChainId Chain ID of the network which contains the spoke pool which corresponds to this adapter instance.\n     * @param _hubPool Address of the hub pool deployed on L1.\n     */\n    constructor(\n        address _l1Adapter,\n        address _l2Target,\n        uint256 _l2ChainId,\n        uint256 _l3ChainId,\n        HubPoolInterface _hubPool\n    ) {\n        L1_ADAPTER = _l1Adapter;\n        L2_TARGET = _l2Target;\n        L2_CHAIN_ID = _l2ChainId;\n        L3_CHAIN_ID = _l3ChainId;\n        HUB_POOL = _hubPool;\n    }\n\n    /**\n     * @notice Send cross-chain message to a target on L2 which will forward messages to the intended remote target on an L3.\n     * @param target Address of the remote contract which receives `message` after it has been forwarded by all intermediate\n     * contracts.\n     * @param message Data to send to `target`.\n     * @dev The message passed into this function is wrapped into a `relayMessage` function call, which is then passed\n     * to L2. The `L2_TARGET` contract implements AdapterInterface, so upon arrival on L2, the arguments to the L2 contract's\n     * `relayMessage` call will be these `target` and `message` values. From there, the forwarder derives the next appropriate\n     * method to send `message` to the following layers and ultimately to the target on L3.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        bytes memory wrappedMessage = abi.encodeCall(ForwarderInterface.relayMessage, (target, L3_CHAIN_ID, message));\n        (bool success, ) = L1_ADAPTER.delegatecall(\n            abi.encodeCall(AdapterInterface.relayMessage, (L2_TARGET, wrappedMessage))\n        );\n        if (!success) revert RelayMessageFailed();\n    }\n\n    /**\n     * @notice Bridge tokens to a target on L2 and follow up the token bridge with a call to continue bridging the sent tokens.\n     * @param l1Token L1 token to deposit.\n     * @param l3Token L3 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L3 tokens to receive.\n     * @param target The address of the contract which should ultimately receive `amount` of `l3Token`.\n     * @dev When sending tokens, we follow-up with a message describing the amount of tokens we wish to continue bridging.\n     * This allows forwarders to know how much of some token to allocate to a certain target.\n     */\n    function relayTokens(\n        address l1Token,\n        address l3Token,\n        uint256 amount,\n        address target\n    ) external payable override {\n        // Fetch the address of the L2 token, as defined in the Hub Pool. This is to complete a proper token bridge from L1 to L2.\n        address l2Token = HUB_POOL.poolRebalanceRoute(L2_CHAIN_ID, l1Token);\n        // If l2Token is the zero address, then this means that the L2 token is not enabled as a pool rebalance route. This is similar\n        // to the check in the hub pool contract found here: https://github.com/across-protocol/contracts/blob/a2afefecba57177a62be35be092516d0c106097e/contracts/HubPool.sol#L890\n        if (l2Token == address(0)) revert L2RouteNotWhitelisted(l1Token);\n\n        // Relay tokens to the forwarder.\n        (bool success, ) = L1_ADAPTER.delegatecall(\n            abi.encodeCall(AdapterInterface.relayTokens, (l1Token, l2Token, amount, L2_TARGET))\n        );\n        if (!success) revert RelayTokensFailed(l1Token);\n\n        // Follow-up token relay with a message to continue the token relay on L2.\n        bytes memory message = abi.encodeCall(\n            ForwarderInterface.relayTokens,\n            (l2Token, l3Token, amount, L3_CHAIN_ID, target)\n        );\n        (success, ) = L1_ADAPTER.delegatecall(abi.encodeCall(AdapterInterface.relayMessage, (L2_TARGET, message)));\n        if (!success) revert RelayMessageFailed();\n    }\n}\n"
    }
}