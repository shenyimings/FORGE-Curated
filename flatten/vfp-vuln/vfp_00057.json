{
    "vfp_id": "vfp_00057",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "The mirrorReserve is not updated by total interest, causing cumulative debt mismatch and reserve discrepancy",
            "description": "In InterestMath.sol, the updateInterestForOne() function updates mirrorReserve using only the net interest after deducting the protocol fee. The root cause is the incorrect accounting of interest distribution: while borrower debt grows based on total accrued interest (including protocol fee), mirrorReserve only reflects the remaining portion after fee deduction. This creates a growing mismatch between cumulative debt and recorded reserves. Over time, debtAmount becomes larger than what is backed by mirrorReserve, leading to a reserve shortfall. Additionally, since the protocol fee is not subtracted from realReserve, the internal accounting diverges from actual balances. This discrepancy can cause failures during liquidation or withdrawal, resulting in unrecoverable losses and undermining the solvency of the system.\n",
            "severity": "Medium",
            "location": [
                "InterestMath.sol::updateInterestForOne#105"
            ],
            "files": [
                "likwid-margin/src/libraries/InterestMath.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Protocol fees extracted from interests are not accounted for",
            "description": "In InterestMath.sol, the updateInterestForOne() function calculates protocol fees from accrued interest using ProtocolFeeLibrary.splitFee(), but fails to store or return these fees. Although the fees are subtracted from the user's interest, they are not added to the protocol's accrued fee balance. This results in the permanent loss of protocol revenue. The impact is a direct financial loss to the protocol, reducing its sustainability and governance-controlled treasury income. Since the fees are computed but not recorded, this is a silent accounting error that accumulates over time with each interest accrual.\n",
            "severity": "High",
            "location": [
                "InterestMath.sol"
            ],
            "files": [
                "likwid-margin/src/libraries/InterestMath.sol"
            ]
        }
    ],
    "affected_files": {
        "InterestMath.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FeeTypes} from \"../types/FeeTypes.sol\";\nimport {Reserves} from \"../types/Reserves.sol\";\nimport {MarginState} from \"../types/MarginState.sol\";\nimport {Math} from \"./Math.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\nimport {FeeLibrary} from \"./FeeLibrary.sol\";\nimport {PerLibrary} from \"./PerLibrary.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\nimport {ProtocolFeeLibrary} from \"./ProtocolFeeLibrary.sol\";\n\nlibrary InterestMath {\n    using CustomRevert for bytes4;\n    using FeeLibrary for uint24;\n    using PerLibrary for uint256;\n\n    function getBorrowRateByReserves(MarginState marginState, uint256 borrowReserve, uint256 mirrorReserve)\n        internal\n        pure\n        returns (uint256 rate)\n    {\n        rate = marginState.rateBase();\n        if (mirrorReserve == 0) {\n            return rate;\n        }\n        uint256 useLevel = Math.mulDiv(mirrorReserve, PerLibrary.ONE_MILLION, borrowReserve);\n        if (useLevel >= marginState.useHighLevel()) {\n            rate += uint256(useLevel - marginState.useHighLevel()) * marginState.mHigh() / 100;\n            useLevel = marginState.useHighLevel();\n        }\n        if (useLevel >= marginState.useMiddleLevel()) {\n            rate += uint256(useLevel - marginState.useMiddleLevel()) * marginState.mMiddle() / 100;\n            useLevel = marginState.useMiddleLevel();\n        }\n        return rate + useLevel * marginState.mLow() / 100;\n    }\n\n    function getBorrowRateCumulativeLast(\n        uint256 timeElapsed,\n        uint256 rate0CumulativeBefore,\n        uint256 rate1CumulativeBefore,\n        MarginState marginState,\n        Reserves realReserves,\n        Reserves mirrorReserve\n    ) internal pure returns (uint256 rate0CumulativeLast, uint256 rate1CumulativeLast) {\n        if (timeElapsed == 0) {\n            return (rate0CumulativeBefore, rate1CumulativeBefore);\n        }\n        (uint256 realReserve0, uint256 realReserve1) = realReserves.reserves();\n        (uint256 mirrorReserve0, uint256 mirrorReserve1) = mirrorReserve.reserves();\n        uint256 rate0 = getBorrowRateByReserves(marginState, realReserve0 + mirrorReserve0, mirrorReserve0);\n        uint256 rate0LastYear = PerLibrary.YEAR_TRILLION_SECONDS + rate0 * timeElapsed * PerLibrary.ONE_MILLION;\n        rate0CumulativeLast = Math.mulDiv(rate0CumulativeBefore, rate0LastYear, PerLibrary.YEAR_TRILLION_SECONDS);\n        uint256 rate1 = getBorrowRateByReserves(marginState, realReserve1 + mirrorReserve1, mirrorReserve1);\n        uint256 rate1LastYear = PerLibrary.YEAR_TRILLION_SECONDS + rate1 * timeElapsed * PerLibrary.ONE_MILLION;\n        rate1CumulativeLast = Math.mulDiv(rate1CumulativeBefore, rate1LastYear, PerLibrary.YEAR_TRILLION_SECONDS);\n    }\n\n    struct InterestUpdateParams {\n        uint256 mirrorReserve;\n        uint256 borrowCumulativeLast;\n        uint256 borrowCumulativeBefore;\n        uint256 interestReserve;\n        uint256 pairReserve;\n        uint256 lendReserve;\n        uint256 depositCumulativeLast;\n        uint24 protocolFee;\n    }\n\n    struct InterestUpdateResult {\n        uint256 newMirrorReserve;\n        uint256 newPairReserve;\n        uint256 newLendReserve;\n        uint256 newInterestReserve;\n        uint256 newDepositCumulativeLast;\n        uint256 pairInterest;\n        bool changed;\n    }\n\n    function updateInterestForOne(InterestUpdateParams memory params)\n        internal\n        pure\n        returns (InterestUpdateResult memory result)\n    {\n        result.newMirrorReserve = params.mirrorReserve;\n        result.newPairReserve = params.pairReserve;\n        result.newLendReserve = params.lendReserve;\n        result.newInterestReserve = params.interestReserve;\n        result.newDepositCumulativeLast = params.depositCumulativeLast;\n\n        if (params.mirrorReserve > 0 && params.borrowCumulativeLast > params.borrowCumulativeBefore) {\n            uint256 allInterest = Math.mulDiv(\n                params.mirrorReserve * FixedPoint96.Q96, params.borrowCumulativeLast, params.borrowCumulativeBefore\n            ) - params.mirrorReserve * FixedPoint96.Q96 + params.interestReserve;\n\n            (uint256 protocolInterest,) =\n                ProtocolFeeLibrary.splitFee(params.protocolFee, FeeTypes.INTERESTS, allInterest);\n\n            if (protocolInterest == 0 || protocolInterest > FixedPoint96.Q96) {\n                uint256 allInterestNoQ96 = allInterest / FixedPoint96.Q96;\n                allInterestNoQ96 -= protocolInterest / FixedPoint96.Q96;\n\n                result.pairInterest =\n                    Math.mulDiv(allInterestNoQ96, params.pairReserve, params.pairReserve + params.lendReserve);\n\n                if (allInterestNoQ96 > result.pairInterest) {\n                    uint256 lendingInterest = allInterestNoQ96 - result.pairInterest;\n                    result.newDepositCumulativeLast = Math.mulDiv(\n                        params.depositCumulativeLast, params.lendReserve + lendingInterest, params.lendReserve\n                    );\n                    result.newLendReserve += lendingInterest;\n                }\n\n                result.newMirrorReserve += allInterestNoQ96;\n                result.newPairReserve += result.pairInterest;\n                result.changed = true;\n                result.newInterestReserve = 0;\n            } else {\n                result.newInterestReserve = allInterest;\n            }\n        }\n    }\n}\n"
    }
}