{
    "vfp_id": "vfp_00003",
    "project_name": "Zenith - SSI Protocol Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "cancelSwapRequest() old orderInfo using new swap causing failure to cancel",
            "description": "1. **Description:** The cancelSwapRequest function uses outdated orderInfo after a new swap has been processed, leading to a mismatch and failure in cancellation.\n2. **Cause:** The function does not validate the state or version of the orderInfo against the current swap data.\n3. **Exploitation:** A user attempting to cancel a swap may be unable to do so if the orderInfo is outdated, allowing the swap to proceed undesired.\n4. **Impact:** Users may suffer unintended transactions, leading to potential loss of funds or incorrect asset transfers.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ssi-protocol/src/Swap.sol"
            ]
        }
    ],
    "affected_files": {
        "Swap.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport './Interface.sol';\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {Utils} from './Utils.sol';\n\ncontract Swap is AccessControl, Pausable, ISwap {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    string public chain;\n    EnumerableSet.Bytes32Set orderHashs;\n    mapping(bytes32 => SwapRequest) swapRequests;\n\n    bytes32 public constant TAKER_ROLE = keccak256(\"TAKER_ROLE\");\n    bytes32 public constant MAKER_ROLE = keccak256(\"MAKER_ROLE\");\n\n    mapping(string => bool) outWhiteAddresses;\n    string[] public takerReceivers;\n    string[] public takerSenders;\n\n    uint256 public constant MAX_MARKER_CONFIRM_DELAY = 1 hours;\n\n    event AddSwapRequest(address indexed taker, bool inByContract, bool outByContract, OrderInfo orderInfo);\n    event MakerConfirmSwapRequest(address indexed maker, bytes32 orderHash);\n    event ConfirmSwapRequest(address indexed taker, bytes32 orderHash);\n    event MakerRejectSwapRequest(address indexed maker, bytes32 orderHash);\n    event RollbackSwapRequest(address indexed taker, bytes32 orderHash);\n    event SetTakerAddresses(string[] receivers, string[] senders);\n    event CancelSwapRequest(address indexed taker, bytes32 orderHash);\n\n    constructor(address owner, string memory chain_) {\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n        chain = chain_;\n    }\n\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function checkOrderInfo(OrderInfo memory orderInfo) public view returns (uint) {\n        if (block.timestamp >= orderInfo.order.deadline) {\n            return 1;\n        }\n        bytes32 orderHash = keccak256(abi.encode(orderInfo.order));\n        if (orderHash != orderInfo.orderHash) {\n            return 2;\n        }\n        if (!SignatureChecker.isValidSignatureNow(orderInfo.order.maker, orderHash, orderInfo.orderSign)) {\n            return 3;\n        }\n        if (orderHashs.contains(orderHash)) {\n            return 4;\n        }\n        if (orderInfo.order.inAddressList.length != orderInfo.order.inTokenset.length) {\n            return 5;\n        }\n        if (orderInfo.order.outAddressList.length != orderInfo.order.outTokenset.length) {\n            return 6;\n        }\n        if (!hasRole(MAKER_ROLE, orderInfo.order.maker)) {\n            return 7;\n        }\n        for (uint i = 0; i < orderInfo.order.outAddressList.length; i++) {\n            if (!outWhiteAddresses[orderInfo.order.outAddressList[i]]) {\n                return 8;\n            }\n        }\n        return 0;\n    }\n\n    function validateOrderInfo(OrderInfo memory orderInfo) internal view {\n        require(orderHashs.contains(orderInfo.orderHash), \"order hash not exists\");\n        require(orderInfo.orderHash == keccak256(abi.encode(orderInfo.order)), \"order hash invalid\");\n    }\n\n    function getOrderHashs() external view returns (bytes32[] memory) {\n        return orderHashs.values();\n    }\n\n    function getOrderHashLength() external view returns (uint256) {\n        return orderHashs.length();\n    }\n\n    function getOrderHash(uint256 idx) external view returns (bytes32) {\n        require(idx < orderHashs.length(), \"out of range\");\n        return orderHashs.at(idx);\n    }\n\n    function checkTokenset(Token[] memory tokenset, string[] memory addressList) internal view {\n        require(tokenset.length == addressList.length, \"tokenset length not maatch addressList length\");\n        for (uint i = 0; i < tokenset.length; i++) {\n            require(bytes32(bytes(tokenset[i].chain)) == bytes32(bytes(chain)), \"chain not match\");\n            address tokenAddress = Utils.stringToAddress(tokenset[i].addr);\n            require(tokenAddress != address(0), \"zero token address\");\n            address receiveAddress = Utils.stringToAddress(addressList[i]);\n            require(receiveAddress != address(0), \"zero receive address\");\n        }\n    }\n\n    function addSwapRequest(OrderInfo memory orderInfo, bool inByContract, bool outByContract) external onlyRole(TAKER_ROLE) whenNotPaused {\n        uint code = checkOrderInfo(orderInfo);\n        require(code == 0, \"order not valid\");\n        swapRequests[orderInfo.orderHash].status = SwapRequestStatus.PENDING;\n        swapRequests[orderInfo.orderHash].requester = msg.sender;\n        orderHashs.add(orderInfo.orderHash);\n        if (inByContract) {\n            checkTokenset(orderInfo.order.inTokenset, orderInfo.order.inAddressList);\n        }\n        if (outByContract) {\n            checkTokenset(orderInfo.order.outTokenset, orderInfo.order.outAddressList);\n        }\n        swapRequests[orderInfo.orderHash].inByContract = inByContract;\n        swapRequests[orderInfo.orderHash].outByContract = outByContract;\n        swapRequests[orderInfo.orderHash].blocknumber = block.number;\n        swapRequests[orderInfo.orderHash].requestTimestamp = block.timestamp;\n        emit AddSwapRequest(msg.sender, inByContract, outByContract, orderInfo);\n    }\n\n    function getSwapRequest(bytes32 orderHash) external view returns (SwapRequest memory) {\n        return swapRequests[orderHash];\n    }\n\n    function cancelSwapRequest(OrderInfo memory orderInfo) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].requester == msg.sender, \"not order taker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING, \"swap request status is not pending\");\n        require(swapRequests[orderHash].requestTimestamp + MAX_MARKER_CONFIRM_DELAY <= block.timestamp, \"swap request not timeout\");\n        swapRequests[orderHash].status = SwapRequestStatus.CANCEL;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit CancelSwapRequest(msg.sender, orderHash);\n    }\n\n    function makerRejectSwapRequest(OrderInfo memory orderInfo) external onlyRole(MAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(orderInfo.order.maker == msg.sender, \"not order maker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING, \"swap request status is not pending\");\n        swapRequests[orderHash].status = SwapRequestStatus.REJECTED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit MakerRejectSwapRequest(msg.sender, orderHash);\n    }\n\n    function transferTokenset(address from, Token[] memory tokenset, uint256 amount, string[] memory toAddressList) internal {\n        for (uint i = 0; i < tokenset.length; i++) {\n            address tokenAddress = Utils.stringToAddress(tokenset[i].addr);\n            address to = Utils.stringToAddress(toAddressList[i]);\n            IERC20 token = IERC20(tokenAddress);\n            uint tokenAmount = tokenset[i].amount * amount / 10**8;\n            require(token.balanceOf(from) >= tokenAmount, \"not enough balance\");\n            require(token.allowance(from, address(this)) >= tokenAmount, \"not enough allowance\");\n            token.safeTransferFrom(from, to, tokenAmount);\n        }\n    }\n\n    function makerConfirmSwapRequest(OrderInfo memory orderInfo, bytes[] memory outTxHashs) external onlyRole(MAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        SwapRequest memory swapRequest = swapRequests[orderHash];\n        require(orderInfo.order.maker == msg.sender, \"not order maker\");\n        require(swapRequest.status == SwapRequestStatus.PENDING, \"status error\");\n        if (swapRequest.outByContract) {\n            transferTokenset(msg.sender, orderInfo.order.outTokenset, orderInfo.order.outAmount, orderInfo.order.outAddressList);\n        } else {\n            require(orderInfo.order.outTokenset.length == outTxHashs.length, \"wrong outTxHashs length\");\n            swapRequests[orderHash].outTxHashs = outTxHashs;\n        }\n        swapRequests[orderHash].status = SwapRequestStatus.MAKER_CONFIRMED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit MakerConfirmSwapRequest(msg.sender, orderHash);\n    }\n\n    function rollbackSwapRequest(OrderInfo memory orderInfo) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].requester == msg.sender, \"not order taker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.MAKER_CONFIRMED, \"swap request status is not maker_confirmed\");\n        require(!swapRequests[orderHash].outByContract, \"out by contract cannot rollback\");\n        swapRequests[orderHash].status = SwapRequestStatus.PENDING;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit RollbackSwapRequest(msg.sender, orderHash);\n    }\n\n    function confirmSwapRequest(OrderInfo memory orderInfo, bytes[] memory inTxHashs) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        SwapRequest memory swapRequest = swapRequests[orderHash];\n        require(swapRequest.requester == msg.sender, \"not order taker\");\n        require(swapRequest.status == SwapRequestStatus.MAKER_CONFIRMED, \"status error\");\n         if (swapRequest.inByContract) {\n            transferTokenset(msg.sender, orderInfo.order.inTokenset, orderInfo.order.inAmount, orderInfo.order.inAddressList);\n        } else {\n            require(orderInfo.order.inTokenset.length == inTxHashs.length, \"wrong inTxHashs length\");\n            swapRequests[orderHash].inTxHashs = inTxHashs;\n        }\n        swapRequests[orderHash].status = SwapRequestStatus.CONFIRMED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit ConfirmSwapRequest(msg.sender, orderHash);\n    }\n\n    function setTakerAddresses(string[] memory takerReceivers_, string[] memory takerSenders_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < takerReceivers.length; i++) {\n            outWhiteAddresses[takerReceivers[i]] = false;\n        }\n        delete takerReceivers;\n        for (uint i = 0; i < takerReceivers_.length; i++) {\n            takerReceivers.push(takerReceivers_[i]);\n            outWhiteAddresses[takerReceivers[i]] = true;\n        }\n        delete takerSenders;\n        for (uint i = 0; i < takerSenders_.length; i++) {\n            takerSenders.push(takerSenders_[i]);\n        }\n        emit SetTakerAddresses(takerReceivers, takerSenders);\n    }\n\n    function getTakerAddresses() external view returns (string[] memory receivers, string[] memory senders) {\n        return (takerReceivers, takerSenders);\n    }\n}\n"
    }
}