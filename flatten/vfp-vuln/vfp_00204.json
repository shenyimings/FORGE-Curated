{
    "vfp_id": "vfp_00204",
    "project_name": "ChainSecurity_Steakhouse_Box_Audit.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-1038"
                ]
            },
            "title": "BoxAdapterCached Can Be Arbitraged",
            "description": "This vulnerability arises from the caching mechanism in BoxAdapterCached, which stores the totalAssets value for up to 24 hours to avoid expensive recalculations. During this period, the cached value may diverge significantly from the actual value returned by Box.totalAssets(). An attacker can exploit this discrepancy by depositing into or withdrawing from the parent VaultV2 when the cached value is staleâ€”depositing after the Box has gained value or withdrawing before a loss is reflected. This allows the attacker to extract value from other investors due to the mispricing of VaultV2 shares. The root cause is the long, fixed caching window without a mechanism to force updates based on significant price movements. While allocators or sentinels can manually trigger updates via updateTotalAssets(), this is not automatic and relies on active monitoring. The impact is economic loss for honest investors due to share price manipulation via arbitrage.\n",
            "severity": "Medium",
            "location": [
                "BoxAdapterCached.sol::realAssets",
                "BoxAdapterCached.sol::updateTotalAssets"
            ],
            "files": [
                "box/src/BoxAdapterCached.sol"
            ]
        }
    ],
    "affected_files": {
        "BoxAdapterCached.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 Morpho Association, Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IVaultV2} from \"./../lib/vault-v2/src/interfaces/IVaultV2.sol\";\nimport {MathLib} from \"./../lib/vault-v2/src/libraries/MathLib.sol\";\nimport {SafeERC20Lib} from \"./../lib/vault-v2/src/libraries/SafeERC20Lib.sol\";\nimport {IBox} from \"./interfaces/IBox.sol\";\nimport {IBoxAdapter} from \"./interfaces/IBoxAdapter.sol\";\n\ncontract BoxAdapterCached is IBoxAdapter {\n    using MathLib for uint256;\n    using SafeCast for uint256;\n\n    /* EVENTS */\n    event UpdateTotalAsset(uint256 oldTotalAssets, uint256 totalAssets);\n\n    /* IMMUTABLES */\n\n    address public immutable factory;\n    address public immutable parentVault;\n    IBox public immutable box;\n    bytes32 public immutable adapterId;\n\n    /* STORAGE */\n\n    address public skimRecipient;\n    uint256 public totalAssets;\n    uint256 public totalAssetsTimestamp;\n\n    /* FUNCTIONS */\n\n    constructor(address _parentVault, IBox _box) {\n        factory = msg.sender;\n        parentVault = _parentVault;\n        box = _box;\n        adapterId = keccak256(abi.encode(\"this\", address(this)));\n        address asset = IVaultV2(_parentVault).asset();\n        require(asset == _box.asset(), AssetMismatch());\n        SafeERC20Lib.safeApprove(asset, _parentVault, type(uint256).max);\n        SafeERC20Lib.safeApprove(asset, address(_box), type(uint256).max);\n    }\n\n    function setSkimRecipient(address newSkimRecipient) external {\n        require(msg.sender == IVaultV2(parentVault).owner(), NotAuthorized());\n        skimRecipient = newSkimRecipient;\n        emit SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @dev Skims the adapter's balance of `token` and sends it to `skimRecipient`.\n    /// @dev This is useful to handle rewards that the adapter has earned.\n    function skim(address token) external {\n        require(msg.sender == skimRecipient, NotAuthorized());\n        require(token != address(box), CannotSkimBoxShares());\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        SafeERC20Lib.safeTransfer(token, skimRecipient, balance);\n        emit Skim(token, balance);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the allocation and the change in allocation.\n    function allocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(box).deposit(assets, address(this));\n        // Safe casts because bounded by Vault V2 which requires totalAssets to stay below ~10^35\n        uint256 newTotalAssets = _updateTotalAssets();\n        int256 newAllocation = newTotalAssets.toInt256();\n        int256 oldAllocation = allocation().toInt256();\n\n        return (ids(), newAllocation - oldAllocation);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the deallocation and the change in allocation.\n    function deallocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(box).withdraw(assets, address(this), address(this));\n        // Safe casts because bounded by Vault V2 which requires totalAssets to stay below ~10^35\n        uint256 newTotalAssets = _updateTotalAssets();\n        int256 newAllocation = newTotalAssets.toInt256();\n        int256 oldAllocation = allocation().toInt256();\n\n        return (ids(), newAllocation - oldAllocation);\n    }\n\n    /// @dev Returns adapter's ids.\n    function ids() public view returns (bytes32[] memory) {\n        bytes32[] memory ids_ = new bytes32[](1);\n        ids_[0] = adapterId;\n        return ids_;\n    }\n\n    function allocation() public view returns (uint256) {\n        return IVaultV2(parentVault).allocation(adapterId);\n    }\n\n    function realAssets() external view returns (uint256) {\n        return allocation() != 0 ? totalAssets : 0;\n    }\n\n    /// @dev Updates the cached total assets of the adapter.\n    /// @dev Allowed: Vault allocator, sentinel or anyone after 24 hours of inactivity\n    function updateTotalAssets() external {\n        require(\n            IVaultV2(parentVault).isAllocator(msg.sender) ||\n                IVaultV2(parentVault).isSentinel(msg.sender) ||\n                totalAssetsTimestamp + 1 days < block.timestamp,\n            NotAuthorized()\n        );\n\n        uint256 oldTotalAssets = totalAssets;\n        uint256 newTotalAssets = _updateTotalAssets();\n        emit UpdateTotalAsset(oldTotalAssets, newTotalAssets);\n    }\n\n    function _updateTotalAssets() internal returns (uint256 newTotalAssets) {\n        newTotalAssets = box.previewRedeem(box.balanceOf(address(this)));\n        totalAssets = newTotalAssets;\n        totalAssetsTimestamp = block.timestamp;\n    }\n\n    function adapterData() external view returns (bytes memory) {\n        return abi.encode(\"this\", address(this));\n    }\n}\n"
    }
}