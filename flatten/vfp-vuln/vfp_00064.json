{
    "vfp_id": "vfp_00064",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Unused setMarginFee function causes margin fee to remain hardcoded",
            "description": "The setMarginFee() function in Pool.sol is defined but never called, causing the protocol to rely on a hardcoded defaultMarginFee value. This renders the margin fee immutable after deployment, preventing dynamic adjustments based on governance, market conditions, or risk parameters. The impact is reduced protocol flexibility and inability to respond to changing economic conditions, potentially leading to suboptimal fee revenue or increased risk exposure during volatile markets.\n",
            "severity": "High",
            "location": [
                "Pool.sol#L108"
            ],
            "files": [
                "likwid-margin/src/libraries/Pool.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Protocol fees are included in the reserves",
            "description": "During swaps in Pool.sol, protocol fees are split from LP fees and included in the amount added to reserves. However, protocol fees should be tracked separately in protocolFeesAccrued and not contribute to liquidity reserves. Including them in reserves inflates the available liquidity and distorts price calculations, health checks, and fee accruals. This misaccounting can lead to incorrect margin levels, unfair liquidations, and long-term reserve imbalances, undermining the economic model and potentially causing insolvency.\n",
            "severity": "High",
            "location": [
                "Pool.sol"
            ],
            "files": [
                "likwid-margin/src/libraries/Pool.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Inconsistent update of interest state",
            "description": "The updateInterests() function in Pool.sol conditionally updates state variables based on the 'changed' flag returned by updateInterestForOne(). While most state variables like mirrorReserve0 and pairReserve0 are updated only if result0.changed is true, borrow0CumulativeLast is assigned unconditionally. However, borrow0CumulativeLast is derived from getBorrowRateCumulativeLast() and may not reflect the latest interest accrual if not properly synchronized. The root cause is the inconsistent update logicâ€”some fields depend on the 'changed' flag while others do not. Additionally, newInterestReserve may be updated even when changed is false, but this update is ignored in the main function. This can lead to a state inconsistency where the cumulative borrow rate is updated but the corresponding reserve values are not, resulting in incorrect interest calculations and potential discrepancies in debt tracking. The impact includes inaccurate financial accounting and potential loss of funds during liquidation or withdrawal.\n",
            "severity": "Medium",
            "location": [
                "Pool.sol::updateInterests#390-398"
            ],
            "files": [
                "likwid-margin/src/libraries/Pool.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-1188"
                ],
                "5": [
                    "CWE-453"
                ]
            },
            "title": "Zero truncated reserves on first liquidity addition enables dynamic fee bypass",
            "description": "When a pool is initialized, truncated reserves are set to zero and remain unchanged during the first liquidity addition within the same block. The root cause is the failure to update truncated reserves immediately after liquidity is added. Because updateInterests() and getCurrentState() return early when no time has passed, truncated reserves stay at zero, causing the dynamic fee calculation in swaps to yield a zero degree value. This results in users paying only the base fee instead of the intended dynamic fee, effectively bypassing the fee mechanism. An attacker could exploit this by adding liquidity and immediately executing large swaps at reduced fees, leading to loss of fee revenue for the protocol and unfair advantages during the initial phase of a pool's lifecycle.\n",
            "severity": "Medium",
            "location": [
                "Pool.sol",
                "LikwidPairPosition.sol"
            ],
            "files": [
                "likwid-margin/src/libraries/Pool.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Truncated reserves calculated with stale pair reserves",
            "description": "The updateInterests() function in Pool.sol calculates new truncatedReserves using outdated _pairReserves instead of the updated pairReserve0 and pairReserve1 values returned by updateInterestForOne(). The root cause is the use of stale data in the PriceMath.transferReserves() call. When result0.changed or result1.changed is true, the function should use the freshly computed pairReserve values to ensure accuracy. Using stale reserves results in truncated reserves being slightly smaller than they should be, which affects dynamic fee calculations and price estimations. Over time, this discrepancy can accumulate, leading to incorrect fee levels and potential losses for liquidity providers. The impact is subtle but persistent, affecting the economic integrity of the pool.\n",
            "severity": "Medium",
            "location": [
                "Pool.sol::updateInterests"
            ],
            "files": [
                "likwid-margin/src/libraries/Pool.sol"
            ]
        }
    ],
    "affected_files": {
        "Pool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"../types/BalanceDelta.sol\";\nimport {FeeTypes} from \"../types/FeeTypes.sol\";\nimport {MarginActions} from \"../types/MarginActions.sol\";\nimport {MarginState} from \"../types/MarginState.sol\";\nimport {MarginBalanceDelta} from \"../types/MarginBalanceDelta.sol\";\nimport {ReservesType, Reserves, toReserves, ReservesLibrary} from \"../types/Reserves.sol\";\nimport {Slot0} from \"../types/Slot0.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\nimport {FeeLibrary} from \"./FeeLibrary.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\nimport {Math} from \"./Math.sol\";\nimport {PairPosition} from \"./PairPosition.sol\";\nimport {LendPosition} from \"./LendPosition.sol\";\nimport {PerLibrary} from \"./PerLibrary.sol\";\nimport {ProtocolFeeLibrary} from \"./ProtocolFeeLibrary.sol\";\nimport {TimeLibrary} from \"./TimeLibrary.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {InterestMath} from \"./InterestMath.sol\";\nimport {PriceMath} from \"./PriceMath.sol\";\n\n/// @title A library for managing Likwid pools.\n/// @notice This library contains all the functions for interacting with a Likwid pool.\nlibrary Pool {\n    using CustomRevert for bytes4;\n    using SafeCast for *;\n    using SwapMath for *;\n    using FeeLibrary for uint24;\n    using PerLibrary for uint256;\n    using TimeLibrary for uint32;\n    using Pool for State;\n    using PairPosition for PairPosition.State;\n    using PairPosition for mapping(bytes32 => PairPosition.State);\n    using LendPosition for LendPosition.State;\n    using LendPosition for mapping(bytes32 => LendPosition.State);\n    using ProtocolFeeLibrary for uint24;\n\n    /// @notice Thrown when trying to initialize an already initialized pool\n    error PoolAlreadyInitialized();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when trying to remove more liquidity than available in the pool\n    error InsufficientLiquidity();\n\n    error InsufficientAmount();\n\n    struct State {\n        Slot0 slot0;\n        /// @notice The cumulative borrow rate of the first currency in the pool.\n        uint256 borrow0CumulativeLast;\n        /// @notice The cumulative borrow rate of the second currency in the pool.\n        uint256 borrow1CumulativeLast;\n        /// @notice The cumulative deposit rate of the first currency in the pool.\n        uint256 deposit0CumulativeLast;\n        /// @notice The cumulative deposit rate of the second currency in the pool.\n        uint256 deposit1CumulativeLast;\n        Reserves realReserves;\n        Reserves mirrorReserves;\n        Reserves pairReserves;\n        Reserves truncatedReserves;\n        Reserves lendReserves;\n        Reserves interestReserves;\n        /// @notice The positions in the pool, mapped by a hash of the owner's address and a salt.\n        mapping(bytes32 positionKey => PairPosition.State) positions;\n        mapping(bytes32 positionKey => LendPosition.State) lendPositions;\n    }\n\n    struct ModifyLiquidityParams {\n        // the address that owns the position\n        address owner;\n        uint256 amount0;\n        uint256 amount1;\n        // any change in liquidity\n        int128 liquidityDelta;\n        // used to distinguish positions of the same owner, at the same tick range\n        bytes32 salt;\n    }\n\n    /// @notice Initializes the pool with a given fee\n    /// @param self The pool state\n    /// @param lpFee The initial fee for the pool\n    function initialize(State storage self, uint24 lpFee) internal {\n        if (self.borrow0CumulativeLast != 0) PoolAlreadyInitialized.selector.revertWith();\n\n        self.slot0 = Slot0.wrap(bytes32(0)).setLastUpdated(uint32(block.timestamp)).setLpFee(lpFee);\n        self.borrow0CumulativeLast = FixedPoint96.Q96;\n        self.borrow1CumulativeLast = FixedPoint96.Q96;\n        self.deposit0CumulativeLast = FixedPoint96.Q96;\n        self.deposit1CumulativeLast = FixedPoint96.Q96;\n    }\n\n    /// @notice Sets the protocol fee for the pool\n    /// @param self The pool state\n    /// @param protocolFee The new protocol fee\n    function setProtocolFee(State storage self, uint24 protocolFee) internal {\n        self.checkPoolInitialized();\n        self.slot0 = self.slot0.setProtocolFee(protocolFee);\n    }\n\n    /// @notice Sets the margin fee for the pool\n    /// @param self The pool state\n    /// @param marginFee The new margin fee\n    function setMarginFee(State storage self, uint24 marginFee) internal {\n        self.checkPoolInitialized();\n        self.slot0 = self.slot0.setMarginFee(marginFee);\n    }\n\n    /// @notice Adds or removes liquidity from the pool\n    /// @param self The pool state\n    /// @param params The parameters for modifying liquidity\n    /// @return delta The change in balances\n    function modifyLiquidity(State storage self, ModifyLiquidityParams memory params)\n        internal\n        returns (BalanceDelta delta, int128 finalLiquidityDelta)\n    {\n        if (params.liquidityDelta == 0 && params.amount0 == 0 && params.amount1 == 0) {\n            return (BalanceDelta.wrap(0), 0);\n        }\n\n        Slot0 _slot0 = self.slot0;\n        Reserves _pairReserves = self.pairReserves;\n\n        (uint128 _reserve0, uint128 _reserve1) = _pairReserves.reserves();\n        uint128 totalSupply = _slot0.totalSupply();\n\n        if (params.liquidityDelta < 0) {\n            // --- Remove Liquidity ---\n            uint256 liquidityToRemove = uint256(-int256(params.liquidityDelta));\n            if (liquidityToRemove > totalSupply) InsufficientLiquidity.selector.revertWith();\n\n            uint256 amount0Out = Math.mulDiv(liquidityToRemove, _reserve0, totalSupply);\n            uint256 amount1Out = Math.mulDiv(liquidityToRemove, _reserve1, totalSupply);\n\n            delta = toBalanceDelta(amount0Out.toInt128(), amount1Out.toInt128());\n            self.slot0 = _slot0.setTotalSupply(totalSupply - liquidityToRemove.toUint128());\n            finalLiquidityDelta = params.liquidityDelta;\n        } else {\n            // --- Add Liquidity ---\n            uint256 amount0In;\n            uint256 amount1In;\n            uint256 liquidityAdded;\n\n            if (totalSupply == 0) {\n                amount0In = params.amount0;\n                amount1In = params.amount1;\n                liquidityAdded = Math.sqrt(amount0In * amount1In);\n            } else {\n                uint256 amount1FromAmount0 = Math.mulDiv(params.amount0, _reserve1, _reserve0);\n                if (amount1FromAmount0 <= params.amount1) {\n                    amount0In = params.amount0;\n                    amount1In = amount1FromAmount0;\n                } else {\n                    amount0In = Math.mulDiv(params.amount1, _reserve0, _reserve1);\n                    amount1In = params.amount1;\n                }\n                liquidityAdded = Math.min(\n                    Math.mulDiv(amount0In, totalSupply, _reserve0), Math.mulDiv(amount1In, totalSupply, _reserve1)\n                );\n            }\n\n            delta = toBalanceDelta(-amount0In.toInt128(), -amount1In.toInt128());\n\n            self.slot0 = _slot0.setTotalSupply(totalSupply + liquidityAdded.toUint128());\n            finalLiquidityDelta = liquidityAdded.toInt128();\n        }\n        ReservesLibrary.UpdateParam[] memory deltaParams = new ReservesLibrary.UpdateParam[](2);\n        deltaParams[0] = ReservesLibrary.UpdateParam(ReservesType.REAL, delta);\n        deltaParams[1] = ReservesLibrary.UpdateParam(ReservesType.PAIR, delta);\n        self.updateReserves(deltaParams);\n\n        self.positions.get(params.owner, params.salt).update(finalLiquidityDelta, delta);\n    }\n\n    struct SwapParams {\n        address sender;\n        // zeroForOne Whether to swap token0 for token1\n        bool zeroForOne;\n        // The amount to swap, negative for exact input, positive for exact output\n        int256 amountSpecified;\n        // Whether to use the mirror reserves for the swap\n        bool useMirror;\n        bytes32 salt;\n    }\n\n    /// @notice Swaps tokens in the pool\n    /// @param self The pool state\n    /// @param params The parameters for the swap\n    /// @return swapDelta The change in balances\n    /// @return amountToProtocol The amount of fees to be sent to the protocol\n    /// @return swapFee The fee for the swap\n    /// @return feeAmount The total fee amount for the swap.\n    function swap(State storage self, SwapParams memory params, uint24 defaultProtocolFee)\n        internal\n        returns (BalanceDelta swapDelta, uint256 amountToProtocol, uint24 swapFee, uint256 feeAmount)\n    {\n        Reserves _pairReserves = self.pairReserves;\n        Reserves _truncatedReserves = self.truncatedReserves;\n        Slot0 _slot0 = self.slot0;\n        uint24 _lpFee = _slot0.lpFee();\n\n        bool exactIn = params.amountSpecified < 0;\n\n        uint256 amountIn;\n        uint256 amountOut;\n\n        if (exactIn) {\n            amountIn = uint256(-params.amountSpecified);\n            (amountOut, swapFee, feeAmount) =\n                SwapMath.getAmountOut(_pairReserves, _truncatedReserves, _lpFee, params.zeroForOne, amountIn);\n        } else {\n            amountOut = uint256(params.amountSpecified);\n            (amountIn, swapFee, feeAmount) =\n                SwapMath.getAmountIn(_pairReserves, _truncatedReserves, _lpFee, params.zeroForOne, amountOut);\n        }\n\n        (amountToProtocol, feeAmount) =\n            ProtocolFeeLibrary.splitFee(_slot0.protocolFee(defaultProtocolFee), FeeTypes.SWAP, feeAmount);\n\n        int128 amount0Delta;\n        int128 amount1Delta;\n\n        if (params.zeroForOne) {\n            amount0Delta = -amountIn.toInt128();\n            amount1Delta = amountOut.toInt128();\n        } else {\n            amount0Delta = amountOut.toInt128();\n            amount1Delta = -amountIn.toInt128();\n        }\n\n        ReservesLibrary.UpdateParam[] memory deltaParams;\n        swapDelta = toBalanceDelta(amount0Delta, amount1Delta);\n        if (!params.useMirror) {\n            deltaParams = new ReservesLibrary.UpdateParam[](2);\n            deltaParams[0] = ReservesLibrary.UpdateParam(ReservesType.REAL, swapDelta);\n            deltaParams[1] = ReservesLibrary.UpdateParam(ReservesType.PAIR, swapDelta);\n        } else {\n            deltaParams = new ReservesLibrary.UpdateParam[](3);\n            BalanceDelta realDelta;\n            BalanceDelta lendDelta;\n            if (params.zeroForOne) {\n                realDelta = toBalanceDelta(amount0Delta, 0);\n                lendDelta = toBalanceDelta(0, -amount1Delta);\n            } else {\n                realDelta = toBalanceDelta(0, amount1Delta);\n                lendDelta = toBalanceDelta(-amount0Delta, 0);\n            }\n            deltaParams[0] = ReservesLibrary.UpdateParam(ReservesType.REAL, realDelta);\n            // pair MIRROR<=>lend MIRROR\n            deltaParams[1] = ReservesLibrary.UpdateParam(ReservesType.LEND, lendDelta);\n            deltaParams[2] = ReservesLibrary.UpdateParam(ReservesType.PAIR, swapDelta);\n            uint256 depositCumulativeLast;\n            if (params.zeroForOne) {\n                depositCumulativeLast = self.deposit1CumulativeLast;\n            } else {\n                depositCumulativeLast = self.deposit0CumulativeLast;\n            }\n            self.lendPositions.get(params.sender, params.zeroForOne, params.salt).update(\n                params.zeroForOne, depositCumulativeLast, lendDelta\n            );\n        }\n        self.updateReserves(deltaParams);\n    }\n\n    struct LendParams {\n        address sender;\n        /// False if lend token0,true if lend token1\n        bool lendForOne;\n        /// The amount to lend, negative for deposit, positive for withdraw\n        int128 lendAmount;\n        bytes32 salt;\n    }\n\n    /// @notice Lends tokens to the pool.\n    /// @param self The pool state.\n    /// @param params The parameters for the lending operation.\n    /// @return lendDelta The change in the lender's balance.\n    /// @return depositCumulativeLast The last cumulative deposit rate.\n    function lend(State storage self, LendParams memory params)\n        internal\n        returns (BalanceDelta lendDelta, uint256 depositCumulativeLast)\n    {\n        int128 amount0Delta;\n        int128 amount1Delta;\n\n        if (params.lendForOne) {\n            amount1Delta = params.lendAmount;\n            depositCumulativeLast = self.deposit1CumulativeLast;\n        } else {\n            amount0Delta = params.lendAmount;\n            depositCumulativeLast = self.deposit0CumulativeLast;\n        }\n\n        lendDelta = toBalanceDelta(amount0Delta, amount1Delta);\n        ReservesLibrary.UpdateParam[] memory deltaParams = new ReservesLibrary.UpdateParam[](2);\n        deltaParams[0] = ReservesLibrary.UpdateParam(ReservesType.REAL, lendDelta);\n        deltaParams[1] = ReservesLibrary.UpdateParam(ReservesType.LEND, lendDelta);\n        self.updateReserves(deltaParams);\n\n        self.lendPositions.get(params.sender, params.lendForOne, params.salt).update(\n            params.lendForOne, depositCumulativeLast, lendDelta\n        );\n    }\n\n    function margin(State storage self, MarginBalanceDelta memory params, uint24 defaultProtocolFee)\n        internal\n        returns (BalanceDelta marginDelta, uint256 amountToProtocol, uint256 feeAmount)\n    {\n        if (\n            (params.action != MarginActions.CLOSE && params.action != MarginActions.LIQUIDATE_BURN)\n                && params.marginDelta == BalanceDeltaLibrary.ZERO_DELTA\n        ) {\n            InsufficientAmount.selector.revertWith();\n        }\n        Slot0 _slot0 = self.slot0;\n        if (params.action == MarginActions.MARGIN) {\n            (, feeAmount) = params.marginFee.deduct(params.marginTotal);\n            (amountToProtocol,) =\n                ProtocolFeeLibrary.splitFee(_slot0.protocolFee(defaultProtocolFee), FeeTypes.MARGIN, feeAmount);\n        }\n        marginDelta = params.marginDelta;\n        if (params.debtDepositCumulativeLast > 0) {\n            if (params.marginForOne) {\n                self.deposit0CumulativeLast = params.debtDepositCumulativeLast;\n            } else {\n                self.deposit1CumulativeLast = params.debtDepositCumulativeLast;\n            }\n        }\n        ReservesLibrary.UpdateParam[] memory deltaParams = new ReservesLibrary.UpdateParam[](4);\n        deltaParams[0] = ReservesLibrary.UpdateParam(ReservesType.REAL, marginDelta);\n        deltaParams[1] = ReservesLibrary.UpdateParam(ReservesType.PAIR, params.pairDelta);\n        deltaParams[2] = ReservesLibrary.UpdateParam(ReservesType.LEND, params.lendDelta);\n        deltaParams[3] = ReservesLibrary.UpdateParam(ReservesType.MIRROR, params.mirrorDelta);\n        self.updateReserves(deltaParams);\n    }\n\n    /// @notice Reverts if the given pool has not been initialized\n    /// @param self The pool state\n    function checkPoolInitialized(State storage self) internal view {\n        if (self.borrow0CumulativeLast == 0) PoolNotInitialized.selector.revertWith();\n    }\n\n    /// @notice Updates the interest rates for the pool.\n    /// @param self The pool state.\n    /// @param marginState The current rate state.\n    /// @return pairInterest0 The interest earned by the pair for token0.\n    /// @return pairInterest1 The interest earned by the pair for token1.\n    function updateInterests(State storage self, MarginState marginState, uint24 defaultProtocolFee)\n        internal\n        returns (uint256 pairInterest0, uint256 pairInterest1)\n    {\n        Slot0 _slot0 = self.slot0;\n        uint256 timeElapsed = _slot0.lastUpdated().getTimeElapsed();\n        if (timeElapsed == 0) return (0, 0);\n\n        Reserves _realReserves = self.realReserves;\n        Reserves _mirrorReserves = self.mirrorReserves;\n        Reserves _interestReserves = self.interestReserves;\n        Reserves _pairReserves = self.pairReserves;\n        Reserves _lendReserves = self.lendReserves;\n\n        uint256 borrow0CumulativeBefore = self.borrow0CumulativeLast;\n        uint256 borrow1CumulativeBefore = self.borrow1CumulativeLast;\n\n        (uint256 borrow0CumulativeLast, uint256 borrow1CumulativeLast) = InterestMath.getBorrowRateCumulativeLast(\n            timeElapsed, borrow0CumulativeBefore, borrow1CumulativeBefore, marginState, _realReserves, _mirrorReserves\n        );\n        (uint256 pairReserve0, uint256 pairReserve1) = _pairReserves.reserves();\n        (uint256 lendReserve0, uint256 lendReserve1) = _lendReserves.reserves();\n        (uint256 mirrorReserve0, uint256 mirrorReserve1) = _mirrorReserves.reserves();\n        (uint256 interestReserve0, uint256 interestReserve1) = _interestReserves.reserves();\n\n        InterestMath.InterestUpdateResult memory result0 = InterestMath.updateInterestForOne(\n            InterestMath.InterestUpdateParams({\n                mirrorReserve: mirrorReserve0,\n                borrowCumulativeLast: borrow0CumulativeLast,\n                borrowCumulativeBefore: borrow0CumulativeBefore,\n                interestReserve: interestReserve0,\n                pairReserve: pairReserve0,\n                lendReserve: lendReserve0,\n                depositCumulativeLast: self.deposit0CumulativeLast,\n                protocolFee: _slot0.protocolFee(defaultProtocolFee)\n            })\n        );\n\n        if (result0.changed) {\n            mirrorReserve0 = result0.newMirrorReserve;\n            pairReserve0 = result0.newPairReserve;\n            lendReserve0 = result0.newLendReserve;\n            interestReserve0 = result0.newInterestReserve;\n            self.deposit0CumulativeLast = result0.newDepositCumulativeLast;\n            pairInterest0 = result0.pairInterest;\n            self.borrow0CumulativeLast = borrow0CumulativeLast;\n        }\n\n        InterestMath.InterestUpdateResult memory result1 = InterestMath.updateInterestForOne(\n            InterestMath.InterestUpdateParams({\n                mirrorReserve: mirrorReserve1,\n                borrowCumulativeLast: borrow1CumulativeLast,\n                borrowCumulativeBefore: borrow1CumulativeBefore,\n                interestReserve: interestReserve1,\n                pairReserve: pairReserve1,\n                lendReserve: lendReserve1,\n                depositCumulativeLast: self.deposit1CumulativeLast,\n                protocolFee: _slot0.protocolFee(defaultProtocolFee)\n            })\n        );\n\n        if (result1.changed) {\n            mirrorReserve1 = result1.newMirrorReserve;\n            pairReserve1 = result1.newPairReserve;\n            lendReserve1 = result1.newLendReserve;\n            interestReserve1 = result1.newInterestReserve;\n            self.deposit1CumulativeLast = result1.newDepositCumulativeLast;\n            pairInterest1 = result1.pairInterest;\n            self.borrow1CumulativeLast = borrow1CumulativeLast;\n        }\n\n        if (result0.changed || result1.changed) {\n            self.mirrorReserves = toReserves(mirrorReserve0.toUint128(), mirrorReserve1.toUint128());\n            self.pairReserves = toReserves(pairReserve0.toUint128(), pairReserve1.toUint128());\n            self.lendReserves = toReserves(lendReserve0.toUint128(), lendReserve1.toUint128());\n            Reserves _truncatedReserves = self.truncatedReserves;\n            self.truncatedReserves = PriceMath.transferReserves(\n                _truncatedReserves,\n                _pairReserves,\n                _slot0.lastUpdated().getTimeElapsed(),\n                marginState.maxPriceMovePerSecond()\n            );\n        } else {\n            self.truncatedReserves = _pairReserves;\n        }\n\n        self.interestReserves = toReserves(interestReserve0.toUint128(), interestReserve1.toUint128());\n        self.slot0 = self.slot0.setLastUpdated(uint32(block.timestamp));\n    }\n\n    /// @notice Updates the reserves of the pool.\n    /// @param self The pool state.\n    /// @param params An array of parameters for updating the reserves.\n    function updateReserves(State storage self, ReservesLibrary.UpdateParam[] memory params) internal {\n        if (params.length == 0) return;\n        Reserves _realReserves = self.realReserves;\n        Reserves _mirrorReserves = self.mirrorReserves;\n        Reserves _pairReserves = self.pairReserves;\n        Reserves _lendReserves = self.lendReserves;\n        for (uint256 i = 0; i < params.length; i++) {\n            ReservesType _type = params[i]._type;\n            BalanceDelta delta = params[i].delta;\n            if (_type == ReservesType.REAL) {\n                _realReserves = _realReserves.applyDelta(delta);\n            } else if (_type == ReservesType.MIRROR) {\n                _mirrorReserves = _mirrorReserves.applyDelta(delta, true);\n            } else if (_type == ReservesType.PAIR) {\n                _pairReserves = _pairReserves.applyDelta(delta);\n            } else if (_type == ReservesType.LEND) {\n                _lendReserves = _lendReserves.applyDelta(delta);\n            }\n        }\n        self.realReserves = _realReserves;\n        self.mirrorReserves = _mirrorReserves;\n        self.pairReserves = _pairReserves;\n        self.lendReserves = _lendReserves;\n    }\n}\n"
    }
}