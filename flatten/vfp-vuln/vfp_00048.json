{
    "vfp_id": "vfp_00048",
    "project_name": "cantina_byzantine_sep2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Inconsistent skim protection between adapters",
            "description": "The CompoundV3Adapter's skim() function lacks validation to prevent the withdrawal of underlying protocol tokens (cTokens), unlike the secure implementation in ERC4626MerklAdapter. The root cause is the absence of a safeguard that checks whether the token being skimmed is the underlying asset of the vault. A malicious or compromised skimRecipient could call skim() with the cToken address, draining the adapter's entire asset balance and potentially causing the parent vault to become insolvent. This creates a critical financial risk, though the likelihood is reduced due to the protected role of skimRecipient. The impact is high due to potential insolvency, but the overall severity is medium due to lower exploit likelihood.\n",
            "severity": "Medium",
            "location": [
                "CompoundV3Adapter.sol#L55-L60"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing slippage protection in claim functions",
            "description": "Both CompoundV3Adapter and ERC4626MerklAdapter perform token swaps in their claim functions without enforcing minimum output amounts, leaving users exposed to MEV and sandwich attacks. The root cause is the lack of slippage controls during swap execution, where only a minimal check (receiving at least 1 wei) is performed. An attacker could exploit this by frontrunning or backrunning claim transactions to manipulate swap prices and extract value. This could result in significant loss of reward value during liquidation, especially for large claims. The impact ranges from medium to high depending on the value involved, and the likelihood is medium due to partial mitigation via private mempools, leading to a medium severity rating.\n",
            "severity": "Medium",
            "location": [
                "CompoundV3Adapter.sol#L94"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol",
                "debt-fund-vault-v2/src/adapters/ERC4626MerklAdapter.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC4626MerklAdapter.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity 0.8.28;\n\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport {IERC4626} from \"../interfaces/IERC4626.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC4626MerklAdapter} from \"./interfaces/IERC4626MerklAdapter.sol\";\nimport {IMerklDistributor} from \"../interfaces/IMerklDistributor.sol\";\nimport {SafeERC20Lib} from \"../libraries/SafeERC20Lib.sol\";\n\n/// @dev Generic ERC4626 adapter with Merkl rewards claiming functionality\n/// @dev Designed for integration with ERC4626-compliant vaults like Stata (AAVE wrapper)\n/// @dev This adapter must be used with ERC4626 vaults that are protected against inflation attacks\n/// @dev Must not be used with an ERC4626 vault which can re-enter the parent vault\ncontract ERC4626MerklAdapter is IERC4626MerklAdapter {\n    /* IMMUTABLES */\n\n    address public immutable factory;\n    address public immutable parentVault;\n    address public immutable erc4626Vault;\n    bytes32 public immutable adapterId;\n\n    /* CONSTANTS */\n\n    /// @dev Merkl distributor address on the vast majority of chains\n    address public constant MERKL_DISTRIBUTOR = 0x3Ef3D8bA38EBe18DB133cEc108f4D14CE00Dd9Ae;\n\n    /* STORAGE */\n\n    address public skimRecipient;\n    address public claimer;\n\n    /* FUNCTIONS */\n\n    constructor(address _parentVault, address _erc4626Vault) {\n        factory = msg.sender;\n        parentVault = _parentVault;\n        erc4626Vault = _erc4626Vault;\n        adapterId = keccak256(abi.encode(\"this\", address(this)));\n        address asset = IVaultV2(_parentVault).asset();\n        require(asset == IERC4626(_erc4626Vault).asset(), AssetMismatch());\n        SafeERC20Lib.safeApprove(asset, _parentVault, type(uint256).max);\n        SafeERC20Lib.safeApprove(asset, _erc4626Vault, type(uint256).max);\n    }\n\n    function setClaimer(address newClaimer) external {\n        if (msg.sender != IVaultV2(parentVault).curator()) revert NotAuthorized();\n        claimer = newClaimer;\n        emit SetClaimer(newClaimer);\n    }\n\n    function setSkimRecipient(address newSkimRecipient) external {\n        require(msg.sender == IVaultV2(parentVault).owner(), NotAuthorized());\n        skimRecipient = newSkimRecipient;\n        emit SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @dev Skims the adapter's balance of `token` and sends it to `skimRecipient`.\n    /// @dev This is useful to handle rewards that the adapter has earned.\n    function skim(address token) external {\n        require(msg.sender == skimRecipient, NotAuthorized());\n        require(token != erc4626Vault, CannotSkimERC4626Shares());\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        SafeERC20Lib.safeTransfer(token, skimRecipient, balance);\n        emit Skim(token, balance);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the allocation and the change in allocation.\n    function allocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(erc4626Vault).deposit(assets, address(this));\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = IERC4626(erc4626Vault).previewRedeem(IERC4626(erc4626Vault).balanceOf(address(this)));\n\n        // Safe casts because ERC4626 vaults bound the total supply, and allocation is less than the\n        // max total assets of the vault.\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the deallocation and the change in allocation.\n    function deallocate(bytes memory data, uint256 assets, bytes4, address)\n        external\n        returns (bytes32[] memory, int256)\n    {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(erc4626Vault).withdraw(assets, address(this), address(this));\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = IERC4626(erc4626Vault).previewRedeem(IERC4626(erc4626Vault).balanceOf(address(this)));\n\n        // Safe casts because ERC4626 vaults bound the total supply, and allocation is less than the\n        // max total assets of the vault.\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Claims rewards from Merkl distributor contract and swap it to parent vault's asset\n    /// @dev Only the claimer can call this function\n    /// @param data Encoded ClaimParams struct containing merkl params and swap params\n    function claim(bytes calldata data) external {\n        require(msg.sender == claimer, NotAuthorized());\n\n        // Decode the claim data\n        ClaimParams memory claimParams = abi.decode(data, (ClaimParams));\n        MerklParams memory merklParams = claimParams.merklParams;\n        SwapParams[] memory swapParams = claimParams.swapParams;\n\n        // Claim data checks\n        require(swapParams.length == merklParams.tokens.length, InvalidData());\n\n        // Call the Merkl distributor\n        IMerklDistributor(MERKL_DISTRIBUTOR).claim(\n            merklParams.users, merklParams.tokens, merklParams.amounts, merklParams.proofs\n        );\n\n        IERC20 parentVaultAsset = IERC20(IVaultV2(parentVault).asset());\n        for (uint256 i; i < swapParams.length; ++i) {\n            // Check the swapper contract isn't the erc4626Vault\n            require(swapParams[i].swapper != erc4626Vault, SwapperCannotBeUnderlyingVault());\n\n            // Snapshot for sanity check\n            uint256 parentVaultBalanceBefore = parentVaultAsset.balanceOf(parentVault);\n            uint256 rewardTokenBalanceBefore = IERC20(merklParams.tokens[i]).balanceOf(address(this));\n\n            // Swap the rewards\n            SafeERC20Lib.safeApprove(merklParams.tokens[i], swapParams[i].swapper, merklParams.amounts[i]);\n            (bool success,) = swapParams[i].swapper.call(swapParams[i].swapData);\n            require(success, SwapReverted());\n            uint256 swappedAmount = rewardTokenBalanceBefore - IERC20(merklParams.tokens[i]).balanceOf(address(this));\n\n            // Check if the parent vault received them\n            uint256 parentVaultBalanceAfter = parentVaultAsset.balanceOf(parentVault);\n            require(parentVaultBalanceAfter > parentVaultBalanceBefore, RewardsNotReceived());\n\n            emit ClaimRewards(merklParams.tokens[i], merklParams.amounts[i]);\n            emit SwapRewards(swapParams[i].swapper, merklParams.tokens[i], swappedAmount, swapParams[i].swapData);\n        }\n    }\n\n    /// @dev Returns adapter's ids.\n    function ids() public view returns (bytes32[] memory) {\n        bytes32[] memory ids_ = new bytes32[](1);\n        ids_[0] = adapterId;\n        return ids_;\n    }\n\n    function allocation() public view returns (uint256) {\n        return IVaultV2(parentVault).allocation(adapterId);\n    }\n\n    function realAssets() external view returns (uint256) {\n        return allocation() != 0\n            ? IERC4626(erc4626Vault).previewRedeem(IERC4626(erc4626Vault).balanceOf(address(this)))\n            : 0;\n    }\n}\n",
        "CompoundV3Adapter.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity 0.8.28;\n\nimport {CometInterface} from \"../interfaces/CometInterface.sol\";\nimport {CometRewardsInterface} from \"../interfaces/CometRewardsInterface.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {ICompoundV3Adapter} from \"./interfaces/ICompoundV3Adapter.sol\";\nimport {SafeERC20Lib} from \"../libraries/SafeERC20Lib.sol\";\n\ncontract CompoundV3Adapter is ICompoundV3Adapter {\n    /* IMMUTABLES */\n\n    address public immutable factory;\n    address public immutable parentVault;\n    address public immutable asset;\n    address public immutable comet;\n    address public immutable cometRewards;\n    bytes32 public immutable adapterId;\n\n    /* STORAGE */\n\n    address public skimRecipient;\n    address public claimer;\n\n    /* FUNCTIONS */\n\n    constructor(address _parentVault, address _comet, address _cometRewards) {\n        factory = msg.sender;\n        parentVault = _parentVault;\n        comet = _comet;\n        cometRewards = _cometRewards;\n        adapterId = keccak256(abi.encode(\"this\", address(this)));\n        asset = IVaultV2(_parentVault).asset();\n        SafeERC20Lib.safeApprove(asset, _comet, type(uint256).max);\n        SafeERC20Lib.safeApprove(asset, _parentVault, type(uint256).max);\n    }\n\n    function setClaimer(address newClaimer) external {\n        if (msg.sender != IVaultV2(parentVault).curator()) revert NotAuthorized();\n        claimer = newClaimer;\n        emit SetClaimer(newClaimer);\n    }\n\n    function setSkimRecipient(address newSkimRecipient) external {\n        if (msg.sender != IVaultV2(parentVault).owner()) revert NotAuthorized();\n        skimRecipient = newSkimRecipient;\n        emit SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @dev Skims the adapter's balance of `token` and sends it to `skimRecipient`.\n    /// @dev This is useful to handle rewards that the adapter has earned.\n    function skim(address token) external {\n        if (msg.sender != skimRecipient) revert NotAuthorized();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        SafeERC20Lib.safeTransfer(token, skimRecipient, balance);\n        emit Skim(token, balance);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the allocation and the change in allocation.\n    function allocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        if (data.length != 0) revert InvalidData();\n        if (msg.sender != parentVault) revert NotAuthorized();\n\n        if (assets > 0) CometInterface(comet).supply(asset, assets);\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = CometInterface(comet).balanceOf(address(this));\n\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the deallocation and the change in allocation.\n    function deallocate(bytes memory data, uint256 assets, bytes4, address)\n        external\n        returns (bytes32[] memory, int256)\n    {\n        if (data.length != 0) revert InvalidData();\n        if (msg.sender != parentVault) revert NotAuthorized();\n\n        if (assets > 0) CometInterface(comet).withdraw(asset, assets);\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = CometInterface(comet).balanceOf(address(this));\n\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Claims COMP rewards accumulated by the adapter and swap it to parent vault's asset\n    /// @dev Only the claimer can call this function\n    /// @param data Encoded SwapParams struct containing swapper and swap data\n    function claim(bytes calldata data) external {\n        if (msg.sender != claimer) revert NotAuthorized();\n\n        // Decode the data\n        (address swapper, bytes memory swapData) = abi.decode(data, (address, bytes));\n\n        // Check the swapper contract isn't the comet contract\n        if (swapper == comet) revert SwapperCannotBeComet();\n\n        // Get assets\n        IERC20 rewardToken = IERC20(CometRewardsInterface(cometRewards).rewardConfig(comet).token);\n        IERC20 parentVaultAsset = IERC20(IVaultV2(parentVault).asset());\n\n        // Claim the rewards\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        CometRewardsInterface(cometRewards).claim(comet, address(this), true);\n        uint256 balanceAfter = rewardToken.balanceOf(address(this));\n        uint256 claimedAmount = balanceAfter - balanceBefore;\n\n        // Snapshot for sanity check\n        balanceBefore = parentVaultAsset.balanceOf(parentVault);\n\n        // Swap the rewards\n        SafeERC20Lib.safeApprove(address(rewardToken), swapper, claimedAmount);\n        (bool success,) = swapper.call(swapData);\n        require(success, SwapReverted());\n        uint256 swappedAmount = balanceAfter - rewardToken.balanceOf(address(this));\n\n        // Check if the parent vault received them\n        balanceAfter = parentVaultAsset.balanceOf(parentVault);\n        require(balanceAfter > balanceBefore, RewardsNotReceived());\n\n        emit Claim(address(rewardToken), claimedAmount);\n        emit SwapRewards(swapper, address(rewardToken), swappedAmount, swapData);\n    }\n\n    /// @dev Returns adapter's ids.\n    function ids() public view returns (bytes32[] memory) {\n        bytes32[] memory ids_ = new bytes32[](1);\n        ids_[0] = adapterId;\n        return ids_;\n    }\n\n    function allocation() public view returns (uint256) {\n        return IVaultV2(parentVault).allocation(adapterId);\n    }\n\n    function realAssets() external view returns (uint256) {\n        return allocation() != 0 ? CometInterface(comet).balanceOf(address(this)) : 0;\n    }\n}\n"
    }
}