{
    "vfp_id": "vfp_00146",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Linked list data structure in LinkedListStorage can be corrupted",
            "description": "The vulnerability exists in the LinkedListStorage._dequeueItem() function, where certain storage variables are not properly cleared when removing the first item from the queue. Specifically, namespace.next and namespace.item are not reset, even though they should be to prevent stale data from being misinterpreted.\n\nThe root cause is incomplete cleanup of storage slots during dequeue operations. While namespace.prev is correctly left as zero for the first item, namespace.next is not cleared, and namespace.item remains set. This is problematic because _enqueueItem() does not always set .next for new items, especially when the queue is empty.\n\nAn attacker can manipulate the dangling next pointer to corrupt the internal state of the linked list. For example, by crafting a scenario where a dequeued item's next pointer still points to a previous location, subsequent calls to peekItem() may return incorrect values. Additionally, since namespace.item is not cleared, functions like getItem() and scan() can return items that have already been removed.\n\nThe impact is corruption of critical data structures, leading to incorrect behavior in any contract relying on this linked list for state management, potentially resulting in loss of funds or denial of service.\n",
            "severity": "Critical",
            "location": [
                "LinkedListStorage.sol::_dequeueItem#134-164",
                "LinkedListStorage.sol::_removeItem#95-102"
            ],
            "files": [
                "rocketpool/contracts/contract/util/LinkedListStorage.sol"
            ]
        }
    ],
    "affected_files": {
        "LinkedListStorage.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {LinkedListStorageInterface} from \"../../interface/util/LinkedListStorageInterface.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\n\n/// @notice A linked list storage helper for the deposit requests queue data\ncontract LinkedListStorage is RocketBase, LinkedListStorageInterface {\n\n    // Constants for packing queue metadata into a single uint256\n    uint256 constant internal startOffset = 256 - 64;\n    uint256 constant internal endOffset = 256 - 128;\n    uint256 constant internal lengthOffset = 256 - 192;\n\n    // Constants for packing a deposit item (struct) into a single uint256\n    uint256 constant internal receiverOffset = 256 - 160;\n    uint256 constant internal indexOffset = 256 - 160 - 32;\n    uint256 constant internal suppliedOffset = 256 - 160 - 32 - 32;\n\n    uint64 constant internal ones64Bits = 0xFFFFFFFFFFFFFFFF;\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 1;\n    }\n\n    /// @notice The number of items in the queue\n    /// @param _namespace defines the queue to be used\n    function getLength(bytes32 _namespace) override public view returns (uint256) {\n        return uint64(getUint(keccak256(abi.encodePacked(_namespace, \".data\"))) >> lengthOffset);\n    }\n\n    /// @notice The item in a queue by index\n    /// @param _namespace defines the queue to be used\n    /// @param _index the item index\n    function getItem(bytes32 _namespace, uint256 _index) override external view returns (DepositQueueValue memory) {\n        uint256 packedValue = getUint(keccak256(abi.encodePacked(_namespace, \".item\", _index)));\n        return _unpackItem(packedValue);\n    }\n\n    /// @notice The index of an item in a queue. Returns 0 if the value is not found\n    /// @param _namespace defines the queue to be used\n    /// @param _key the deposit queue value\n    function getIndexOf(bytes32 _namespace, DepositQueueKey memory _key) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(_namespace, \".index\", _key.receiver, _key.validatorId)));\n    }\n\n    /// @notice Returns the index of the item at the head of the list\n    /// @param _namespace defines the queue to be used\n    function getHeadIndex(bytes32 _namespace) override external view returns (uint256) {\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        return uint64(data >> startOffset);\n    }\n\n    /// @notice Finds an item index in a queue and returns the previous item\n    /// @param _namespace defines the queue to be used\n    /// @param _value the deposit queue value\n    function getPreviousItem(bytes32 _namespace, DepositQueueValue memory _value) external view returns (DepositQueueValue memory previousItem) {\n        uint256 index = getUint(keccak256(abi.encodePacked(_namespace, \".index\", _value.receiver, _value.validatorId)));\n        if (index > 0) {\n            uint256 previousIndex = getUint(keccak256(abi.encodePacked(_namespace, \".prev\", index)));\n            previousItem = _unpackItem(getUint(keccak256(abi.encodePacked(_namespace, \".item\", previousIndex))));\n        }\n    }\n\n    /// @notice Finds an item index in a queue and returns the next item\n    /// @param _namespace defines the queue to be used\n    /// @param _value the deposit queue value\n    function getNextItem(bytes32 _namespace, DepositQueueValue memory _value) external view returns (DepositQueueValue memory nextItem) {\n        uint256 index = getUint(keccak256(abi.encodePacked(_namespace, \".index\", _value.receiver, _value.validatorId)));\n        if (index > 0) {\n            uint256 nextIndex = getUint(keccak256(abi.encodePacked(_namespace, \".next\", index)));\n            nextItem = _unpackItem(getUint(keccak256(abi.encodePacked(_namespace, \".item\", nextIndex))));\n        }\n    }\n\n    /// @notice Add an item to the end of the list. Requires that the item does not exist in the list\n    /// @param _namespace defines the queue to be used\n    /// @param _item the deposit queue item to be added\n    function enqueueItem(bytes32 _namespace, DepositQueueValue memory _item) virtual override external onlyLatestContract(\"linkedListStorage\", address(this)) onlyLatestNetworkContract {\n        _enqueueItem(_namespace, _item);\n    }\n\n    /// @notice Internal function created to allow testing enqueueItem\n    /// @param _namespace defines the queue to be used\n    /// @param _item the deposit queue value\n    function _enqueueItem(bytes32 _namespace, DepositQueueValue memory _item) internal {\n        require(getUint(keccak256(abi.encodePacked(_namespace, \".index\", _item.receiver, _item.validatorId))) == 0, \"Item already exists in queue\");\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        uint256 endIndex = uint64(data >> endOffset);\n        uint256 newIndex = endIndex + 1;\n\n        if (endIndex > 0) {\n            setUint(keccak256(abi.encodePacked(_namespace, \".next\", endIndex)), newIndex);\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", newIndex)), endIndex);\n        } else {\n            // clear the 64 bits used to stored the 'start' pointer\n            data &= ~(uint256(ones64Bits) << startOffset);\n            data |= newIndex << startOffset;\n        }\n\n        setUint(keccak256(abi.encodePacked(_namespace, \".item\", newIndex)), _packItem(_item));\n        setUint(keccak256(abi.encodePacked(_namespace, \".index\", _item.receiver, _item.validatorId)), newIndex);\n        // clear the 64 bits used to stored the 'end' pointer\n        data &= ~(uint256(ones64Bits) << endOffset);\n        data |= newIndex << endOffset;\n\n        // Update the length of the queue\n        uint256 currentLength = uint64(data >> lengthOffset);\n        // clear the 64 bits used to stored the 'length' information\n        data &= ~(uint256(ones64Bits) << lengthOffset);\n        data |= (currentLength + 1) << lengthOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".data\")), data);\n    }\n\n    /// @notice Remove an item from the start of a queue and return it. Requires that the queue is not empty\n    /// @param _namespace defines the queue to be used\n    function dequeueItem(bytes32 _namespace) public virtual override onlyLatestContract(\"linkedListStorage\", address(this)) onlyLatestNetworkContract returns (DepositQueueValue memory item) {\n        return _dequeueItem(_namespace);\n    }\n\n    /// @notice Returns the item from the start of the queue without removing it\n    function peekItem(bytes32 _namespace) public virtual override view returns (DepositQueueValue memory item) {\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        uint256 length = uint64(data >> lengthOffset);\n        require(length > 0, \"Queue can't be empty\");\n        uint256 start = uint64(data >> startOffset);\n        uint256 packedItem = getUint(keccak256(abi.encodePacked(_namespace, \".item\", start)));\n        item = _unpackItem(packedItem);\n    }\n\n    /// @notice Remove an item from the start of a queue and return it. Requires that the queue is not empty\n    /// @param _namespace defines the queue to be used\n    function _dequeueItem(bytes32 _namespace) internal returns (DepositQueueValue memory item) {\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        uint256 length = uint64(data >> lengthOffset);\n        require(length > 0, \"Queue can't be empty\");\n        uint256 start = uint64(data >> startOffset);\n        uint256 packedItem = getUint(keccak256(abi.encodePacked(_namespace, \".item\", start)));\n        item = _unpackItem(packedItem);\n\n        uint256 nextItem = getUint(keccak256(abi.encodePacked(_namespace, \".next\", start)));\n        // clear the 64 bits used to stored the 'start' pointer\n        data &= ~(uint256(ones64Bits) << startOffset);\n        data |= nextItem << startOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".index\", item.receiver, item.validatorId)), 0);\n\n        if (nextItem > 0) {\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", nextItem)), 0);\n        } else {\n            // zero the 64 bits storing the 'end' pointer\n            data &= ~(uint256(ones64Bits) << endOffset);\n        }\n\n        // Update the length of the queue\n        // clear the 64 bits used to stored the 'length' information\n        data &= ~(uint256(ones64Bits) << lengthOffset);\n        data |= (length - 1) << lengthOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".data\")), data);\n\n        return item;\n    }\n\n    /// @notice Removes an item from a queue. Requires that the item exists in the queue\n    /// @param _namespace defines the queue to be used\n    /// @param _key to be removed from the queue\n    function removeItem(bytes32 _namespace, DepositQueueKey memory _key) public virtual override onlyLatestContract(\"linkedListStorage\", address(this)) onlyLatestNetworkContract {\n        _removeItem(_namespace, _key);\n    }\n\n    /// @notice Internal function to remove an item from a queue. Requires that the item exists in the queue\n    /// @param _namespace defines the queue to be used\n    /// @param _key to be removed from the queue\n    function _removeItem(bytes32 _namespace, DepositQueueKey memory _key) internal {\n        uint256 index = getUint(keccak256(abi.encodePacked(_namespace, \".index\", _key.receiver, _key.validatorId)));\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        require(index > 0, \"Item does not exist in queue\");\n\n        uint256 prevIndex = getUint(keccak256(abi.encodePacked(_namespace, \".prev\", index)));\n        uint256 nextIndex = getUint(keccak256(abi.encodePacked(_namespace, \".next\", index)));\n        if (prevIndex > 0) {\n            // Not the first item\n            setUint(keccak256(abi.encodePacked(_namespace, \".next\", prevIndex)), nextIndex);\n        } else {\n            // First item\n            // clear the 64 bits used to stored the 'start' pointer\n            data &= ~(uint256(ones64Bits) << startOffset);\n            data |= nextIndex << startOffset;\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", nextIndex)), 0);\n        }\n\n        if (nextIndex > 0) {\n            // Not the last item\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", nextIndex)), prevIndex);\n        } else {\n            // Last item\n            // clear the 64 bits used to stored the 'end' pointer\n            data &= ~(uint256(ones64Bits) << endOffset);\n            data |= prevIndex << endOffset;\n        }\n\n        setUint(keccak256(abi.encodePacked(_namespace, \".index\", _key.receiver, _key.validatorId)), 0);\n        setUint(keccak256(abi.encodePacked(_namespace, \".next\", index)), 0);\n        setUint(keccak256(abi.encodePacked(_namespace, \".prev\", index)), 0);\n\n        // Update the length of the queue\n        uint256 currentLength = uint64(data >> lengthOffset);\n        // clear the 64 bits used to stored the 'length' information\n        data &= ~(uint256(ones64Bits) << lengthOffset);\n        data |= (currentLength - 1) << lengthOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".data\")), data);\n    }\n\n    /// @notice packs a deposit queue value into a single uint256\n    /// @param _item the deposit queue item to be packed\n    function _packItem(DepositQueueValue memory _item) internal pure returns (uint256 packed) {\n        packed |= uint256(uint160(_item.receiver)) << receiverOffset;\n        packed |= uint256(_item.validatorId) << indexOffset;\n        packed |= uint256(_item.suppliedValue) << suppliedOffset;\n        packed |= uint256(_item.requestedValue);\n    }\n\n    /// @notice unpacks an uint256 value into a deposit queue struct \n    /// @param _packedValue the packed deposit queue value \n    function _unpackItem(uint256 _packedValue) internal pure returns (DepositQueueValue memory item) {\n        item.receiver = address(uint160(_packedValue >> receiverOffset));\n        item.validatorId = uint32(_packedValue >> indexOffset);\n        item.suppliedValue = uint32(_packedValue >> suppliedOffset);\n        item.requestedValue = uint32(_packedValue);\n    }\n\n    /// @notice Returns the supplied number of entries starting at the supplied index\n    /// @param _namespace The namespace of the linked list to scan\n    /// @param _start The index to start from, or 0 to start from the start of the first item in the list\n    /// @param _count The maximum number of items to return\n    function scan(bytes32 _namespace, uint256 _start, uint256 _count) override external view returns (DepositQueueValue[] memory entries, uint256 nextIndex) {\n        entries = new DepositQueueValue[](_count);\n        nextIndex = _start;\n        uint256 total = 0;\n\n        // If nextIndex is 0, begin scan at the start of the list\n        if (nextIndex == 0) {\n            uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n            uint256 start = uint64(data >> startOffset);\n            nextIndex = start;\n        }\n\n        while (total < _count && nextIndex != 0) {\n            uint256 packedValue = getUint(keccak256(abi.encodePacked(_namespace, \".item\", nextIndex)));\n            entries[total] = _unpackItem(packedValue);\n            nextIndex = getUint(keccak256(abi.encodePacked(_namespace, \".next\", nextIndex)));\n            total++;\n        }\n\n        assembly {\n            mstore(entries, total)\n        }\n\n        return (entries, nextIndex);\n    }\n}"
    }
}