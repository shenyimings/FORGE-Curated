{
    "vfp_id": "vfp_00126",
    "project_name": "Ozean Finance Security Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Potential Inflation Attack Risk",
            "description": "The vulnerability exists in the initialize function of the OzUSD contract, where the _sharesAmount variable can be set to zero during initialization. This creates a risk of artificial inflation of the share price, which could severely distort the token's value and break economic assumptions. The root cause is the lack of input validation for _sharesAmount, allowing a malicious or erroneous initialization. An attacker could exploit this by initializing the contract with zero shares and then sending a small amount of USDX, causing the share price to inflate by many orders of magnitude. The impact includes broken front-end displays, loss of effective precision in calculations, and potential user fund mismanagement due to incorrect balance representations.\n",
            "severity": "Medium",
            "location": [
                "OzUSD.sol::initialize"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L2/OzUSD.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-224"
                ]
            },
            "title": "Incorrect Burn Event Emission in redeemOzUSD Function",
            "description": "In the redeemOzUSD function of the OzUSD contract, the _emitTransferEvents function incorrectly attributes the burn event to msg.sender instead of the actual account (_from) from which shares are burned. This discrepancy stems from a logic error in event emission, where the source of the burn is misrepresented. While this does not affect the actual token balances or security, it misleads off-chain systems and monitoring tools that rely on accurate event logs. The impact is reduced reliability of event-based tracking, potential confusion in analytics, and incorrect attribution in user interfaces or indexing services.\n",
            "severity": "Medium",
            "location": [
                "OzUSD.sol::redeemOzUSD#198"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L2/OzUSD.sol"
            ]
        }
    ],
    "affected_files": {
        "OzUSD.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IERC20} from \"openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Initializable} from \"openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// @title  Ozean USD (ozUSD) Token Contract\n/// @notice This contract implements a rebasing token (ozUSD), where token balances are dynamic and calculated\n///         based on shares controlled by each account. The total pooled USDX (protocol-controlled USDX) determines the\n///         total balances; meaning that any USDX sent to this contract automatically rebases all user balances.\n///         1 USDX == 1 ozUSD.\n/// @dev    This contract does not fully comply with the ERC20 standard as rebasing events do not emit `Transfer`\n/// events.\n///         This contract is inspired by Lido's stETH contract:\n/// https://vscode.blockscan.com/ethereum/0x17144556fd3424edc8fc8a4c940b2d04936d17eb\ncontract OzUSD is IERC20, ReentrancyGuard, Initializable {\n    string public constant name = \"Ozean USD\";\n    string public constant symbol = \"ozUSD\";\n    uint8 public constant decimals = 18;\n    uint256 private totalShares;\n\n    /// @notice A mapping from addresses to shares controlled by each account.\n    /// @dev    ozUSD balances are dynamic and are calculated based on the accounts' shares and the total amount of\n    ///         USDX controlled by the protocol. Account shares aren't normalized, so the contract also stores the\n    ///         sum of all shares to calculate each account's token balance which equals to:\n    ///         shares[account] * _getTotalPooledUSDX() / totalShares\n    mapping(address => uint256) private shares;\n\n    /// @notice A mapping to track token allowances for delegated spending.\n    /// @dev    Allowances are denominated in tokens, not token shares.\n    mapping(address => mapping(address => uint256)) private allowances;\n\n    /// @notice An executed shares transfer from `sender` to `recipient`.\n    /// @param  from The address the shares are leaving from.\n    /// @param  to The address receiving the shares.\n    /// @param  sharesValue The number of shares being transferred.\n    /// @dev    This is emitted in pair with an ERC20-defined `Transfer` event.\n    event TransferShares(address indexed from, address indexed to, uint256 sharesValue);\n\n    /// @notice An executed `burnShares` request\n    /// @param  account holder of the burnt shares.\n    /// @param  preRebaseTokenAmount amount of ozUSD the burnt shares corresponded to before the burn.\n    /// @param  postRebaseTokenAmount amount of ozUSD the burnt shares corresponded to after the burn.\n    /// @param  sharesAmount amount of burnt shares.\n    /// @dev    Reports simultaneously burnt shares amount and corresponding ozUSD amount.\n    ///         The ozUSD amount is calculated twice: before and after the burning incurred rebase.\n    event SharesBurnt(\n        address indexed account, uint256 preRebaseTokenAmount, uint256 postRebaseTokenAmount, uint256 sharesAmount\n    );\n\n    /// @notice An event for distribution of yield (in the form of USDX) to all participants.\n    /// @param  _previousTotalBalance The total amount of USDX held by the contract before rebasing.\n    /// @param  _newTotalBalance The total amount of USDX held by the contract after rebasing.\n    event YieldDistributed(uint256 _previousTotalBalance, uint256 _newTotalBalance);\n\n    /// SETUP ///\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with a specific amount of shares.\n    /// @param  _sharesAmount The number of shares to initialize.\n    /// @dev    Requires the sender to send USDX equal to the number of shares specified in `_sharesAmount`.\n    function initialize(uint256 _sharesAmount) external payable initializer nonReentrant {\n        require(msg.value == _sharesAmount, \"OzUSD: Incorrect value.\");\n        _mintShares(address(0xdead), _sharesAmount);\n        _emitTransferAfterMintingShares(address(0xdead), _sharesAmount);\n    }\n\n    /// EXTERNAL ///\n\n    receive() external payable {}\n\n    /// @notice Distributes the yield to the protocol by updating the total pooled USDX balance.\n    function distributeYield() external payable nonReentrant {\n        require(msg.value > 1 ether, \"OzUSD: Must distribute at least one USDX.\");\n        emit YieldDistributed(_getTotalPooledUSDX() - msg.value, _getTotalPooledUSDX());\n    }\n\n    /// @notice Transfers an amount of ozUSD tokens from the caller to a recipient.\n    /// @param  _recipient The recipient of the token transfer.\n    /// @param  _amount The number of ozUSD tokens to transfer.\n    /// @return bool Returns `true` if the transfer was successful.\n    /// @dev    The `_amount` parameter represents the number of tokens, not shares. It calculates the equivalent shares\n    ///         and transfers those shares between the accounts.\n    function transfer(address _recipient, uint256 _amount) external nonReentrant returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /// @notice Transfers `ozUSD` tokens on behalf of a sender to a recipient.\n    /// @param  _sender The account from which the tokens are transferred.\n    /// @param  _recipient The recipient of the token transfer.\n    /// @param  _amount The number of ozUSD tokens to transfer.\n    /// @return success Returns `true` if the transfer was successful.\n    /// @dev    The `_amount` parameter represents the number of tokens, not shares. The caller must have an allowance\n    ///         from the sender to spend the specified amount.\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external nonReentrant returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /// @notice Approves a spender to spend a specific number of `ozUSD` tokens on behalf of the caller.\n    /// @param  _spender The address authorized to spend the tokens.\n    /// @param  _amount The number of tokens allowed to be spent.\n    /// @return success Returns `true` if the approval was successful.\n    /// @dev    The `_amount` argument is the amount of tokens, not shares.\n    function approve(address _spender, uint256 _amount) external nonReentrant returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /// @notice Increases the allowance of a spender by a specified amount.\n    /// @param  _spender The address authorized to spend the tokens.\n    /// @param  _addedValue The additional amount of tokens the spender is allowed to spend.\n    /// @return success Returns `true` if the operation was successful.\n    /// @dev    The `_addedValue` argument is the amount of tokens, not shares.\n    function increaseAllowance(address _spender, uint256 _addedValue) external nonReentrant returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender] + _addedValue);\n        return true;\n    }\n\n    /// @notice Decreases the allowance of a spender by a specified amount.\n    /// @param  _spender The address authorized to spend the tokens.\n    /// @param  _subtractedValue The amount of tokens to subtract from the current allowance.\n    /// @return success Returns `true` if the operation was successful.\n    /// @dev    The `_subtractedValue` argument is the amount of tokens, not shares.\n    ///         Reverts if the current allowance is less than the amount being subtracted.\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external nonReentrant returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, \"OzUSD: Allowance below value.\");\n        _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n        return true;\n    }\n\n    /// @notice Transfers `ozUSD` shares from the caller to a recipient and returns the equivalent ozUSD tokens.\n    /// @param  _recipient The recipient of the share transfer.\n    /// @param  _sharesAmount The number of shares to transfer.\n    /// @return uint256 The equivalent ozUSD token amount corresponding to the transferred shares.\n    /// @dev    The `_sharesAmount` argument is the amount of shares, not tokens.\n    function transferShares(address _recipient, uint256 _sharesAmount) external nonReentrant returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledUSDXByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /// @notice Transfers `_sharesAmount` shares from `_sender` to `_recipient` and returns the equivalent ozUSD tokens.\n    /// @param  _sender The address to transfer shares from.\n    /// @param  _recipient The address to transfer shares to.\n    /// @param  _sharesAmount The number of shares to transfer.\n    /// @return uint256 The amount of ozUSD tokens equivalent to the transferred shares.\n    /// @dev    The `_sharesAmount` argument is the amount of shares, not tokens.\n    function transferSharesFrom(address _sender, address _recipient, uint256 _sharesAmount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokensAmount = getPooledUSDXByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /// @notice Mints `ozUSD` to the specified `_to` address by depositing a `_usdxAmount` of USDX.\n    /// @dev    Transfers USDX and mints new shares accordingly.\n    /// @param  _to The address to receive the minted ozUSD.\n    /// @param  _usdxAmount The amount of USDX to lock in exchange for ozUSD.\n    function mintOzUSD(address _to, uint256 _usdxAmount) external payable nonReentrant {\n        require(_usdxAmount != 0, \"OzUSD: Amount zero.\");\n        require(msg.value == _usdxAmount, \"OzUSD: Insufficient USDX transfer.\");\n\n        /// @dev Have to minus `_usdxAmount` from denominator given the transfer of funds has already occured\n        uint256 sharesToMint = (_usdxAmount * totalShares) / (_getTotalPooledUSDX() - _usdxAmount);\n        _mintShares(_to, sharesToMint);\n\n        _emitTransferAfterMintingShares(_to, sharesToMint);\n    }\n\n    /// @notice Redeems ozUSD tokens by burning shares and redeeming the equivalent amount of `_ozUSDAmount` in USDX.\n    /// @param  _from The address that owns the ozUSD to redeem.\n    /// @param  _ozUSDAmount The amount of ozUSD to redeem.\n    /// @dev    Burns shares and transfers back the corresponding USDX.\n    function redeemOzUSD(address _from, uint256 _ozUSDAmount) external nonReentrant {\n        require(_ozUSDAmount != 0, \"OzUSD: Amount zero.\");\n        if (msg.sender != _from) _spendAllowance(_from, msg.sender, _ozUSDAmount);\n\n        uint256 sharesToBurn = getSharesByPooledUSDX(_ozUSDAmount);\n        _burnShares(_from, sharesToBurn);\n\n        (bool s,) = _from.call{value: _ozUSDAmount}(\"\");\n        assert(s);\n\n        _emitTransferEvents(msg.sender, address(0), _ozUSDAmount, sharesToBurn);\n    }\n\n    /// VIEW ///\n\n    /// @notice Returns the balance of ozUSD tokens owned by `_account`.\n    /// @param  _account The address to query the balance for.\n    /// @return uint256 The amount of ozUSD tokens owned by `_account`.\n    /// @dev    Balances are dynamic and equal to the _account's share of the total USDX controlled by the protocol.\n    ///         This is calculated using the `sharesOf` function.\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledUSDXByShares(shares[_account]);\n    }\n\n    /// @notice Returns the remaining number of ozUSD tokens that `_spender` is allowed to spend on behalf of `_owner`.\n    /// @param  _owner The address of the token owner.\n    /// @param  _spender The address of the spender.\n    /// @return uint256 The remaining amount of ozUSD tokens that `_spender` can spend on behalf of `_owner`.\n    /// @dev    This value is updated when `approve` or `transferFrom` is called. Defaults to zero.\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /// @notice Returns the amount of shares owned by `_account`.\n    /// @param  _account The address to query for shares.\n    /// @return uint256 The amount of shares owned by `_account`.\n    function sharesOf(address _account) external view returns (uint256) {\n        return shares[_account];\n    }\n\n    /// @notice Returns the amount of shares that corresponds to the `_usdxAmount` of protocol-controlled USDX.\n    /// @param  _usdxAmount The amount of USDX to convert to shares.\n    /// @return uint256 The equivalent amount of shares for `_usdxAmount`.\n    function getSharesByPooledUSDX(uint256 _usdxAmount) public view returns (uint256) {\n        return (_usdxAmount * totalShares) / _getTotalPooledUSDX();\n    }\n\n    /// @notice Returns the amount of USDX that corresponds to `_sharesAmount` token shares.\n    /// @param  _sharesAmount The number of shares to convert to USDX.\n    /// @return The equivalent amount of USDX for `_sharesAmount`.\n    function getPooledUSDXByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return (_sharesAmount * _getTotalPooledUSDX()) / totalShares;\n    }\n\n    /// @notice Returns the total supply of ozUSD tokens in existence.\n    /// @return The total supply of ozUSD tokens.\n    /// @dev    This is always equal to the total amount of USDX controlled by the protocol.\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledUSDX();\n    }\n\n    /// INTERNAL ///\n\n    function _getTotalPooledUSDX() internal view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /// @dev    Moves `_amount` tokens from `_sender` to `_recipient`.\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledUSDX(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), \"OzUSD: Approve from zero address.\");\n        require(_spender != address(0), \"OzUSD: Approve to zero address.\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != ~uint256(0)) {\n            require(currentAllowance >= _amount, \"OzUSD: Allowance exceeded.\");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), \"OzUSD: Transfer from zero address.\");\n        require(_recipient != address(0), \"OzUSD: Transfer to zero address.\");\n        require(_recipient != address(this), \"OzUSD: Transfer to this contract.\");\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, \"OzUSD: Balance exceeded.\");\n\n        shares[_sender] = currentSenderShares - _sharesAmount;\n        shares[_recipient] = shares[_recipient] + _sharesAmount;\n    }\n\n    /// @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n    /// @dev    This doesn't increase the token total supply.\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"OzUSD: Mint to zero address.\");\n\n        newTotalShares = totalShares + _sharesAmount;\n        totalShares = newTotalShares;\n        shares[_recipient] += _sharesAmount;\n    }\n\n    /// @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n    /// @dev    This doesn't decrease the token total supply.\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), \"OzUSD: Burn from zero address.\");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, \"OzUSD: Balance exceeded.\");\n\n        uint256 preRebaseTokenAmount = getPooledUSDXByShares(_sharesAmount);\n\n        newTotalShares = totalShares - _sharesAmount;\n        totalShares = newTotalShares;\n        shares[_account] = accountShares - _sharesAmount;\n\n        uint256 postRebaseTokenAmount = getPooledUSDXByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n    }\n\n    function _emitTransferEvents(address _from, address _to, uint256 _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /// @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledUSDXByShares(_sharesAmount), _sharesAmount);\n    }\n}\n"
    }
}