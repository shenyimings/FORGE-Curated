{
    "vfp_id": "vfp_00126",
    "project_name": "Aori 0.3.1 Upgrade - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Missing reentrancy guard in the cancel function",
            "description": "The cancel function in the Aori contract lacks a reentrancy guard modifier, making it vulnerable to reentrancy attacks. This issue arises because the function does not follow the checks-effects-interactions pattern and allows external calls (such as native token transfers) before state changes are finalized. An attacker who compromises a solver's address and converts it into a malicious contract via EIP-7702 can trigger a reentrant call to the cancel function during the fallback execution. This could allow the attacker to manipulate balance states across multiple orders, particularly by canceling an order while funds are being transferred, leading to inconsistent accounting. The impact includes potential financial gain for the attacker by exploiting settlement logic on cross-chain orders, especially when paired with failed settlements on the destination chain.\n",
            "severity": "High",
            "location": [
                "Aori.sol::cancel"
            ],
            "files": [
                "aori/contracts/Aori.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-460"
                ]
            },
            "title": "Incorrect state update on settlement failure",
            "description": "The _settleOrder function in the Aori contract updates balances without ensuring atomicity. If one balance update succeeds (e.g., increasing the filler's unlocked balance) but the other fails (e.g., decreasing the offerer's locked balance), the function returns early without reverting the successful operation. This leads to an inconsistent state where the filler gains unlocked funds without the corresponding deduction from the offerer, and the order remains active. The root cause is the lack of a rollback mechanism when either balance update fails. An attacker could potentially trigger such a failure condition (e.g., through balance overflow or underflow edge cases) to gain unauthorized tokens. The impact is incorrect balance accounting, which undermines the integrity of the protocol's financial state.\n",
            "severity": "High",
            "location": [
                "Aori.sol::_settleOrder"
            ],
            "files": [
                "aori/contracts/Aori.sol"
            ]
        }
    ],
    "affected_files": {
        "Aori.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { OApp, Origin, MessagingFee, MessagingReceipt } from \"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { EIP712 } from \"solady/src/utils/EIP712.sol\";\nimport { ECDSA } from \"solady/src/utils/ECDSA.sol\";\nimport { IAori } from \"./IAori.sol\";\nimport \"./AoriUtils.sol\";\n\n/**                            @@@@@@@@@@@@                                              \n                             @@         @@@@@@                     @@@@@                  \n                             @@           @@@@@                    @@@@@                  \n                             @@@                                                          \n                               @@@@                                                       \n                                 @@@@@                                                   \n                                     @@@@@                                                \n       @@@@@@@@@    @@@@          @@@@@@@@@@    @@@@@@    @@@@@@@  @@@@@                  \n     @@@@      @@   @@@@      @@@@       @@@@@@@   @@@@ @@    @@@   @@@@                  \n    @@@@         @ @@@@     @@@@          @@@@@@   @@@@        @@   @@@@                  \n   @@@@@         @@@@@@   @@@@@            @@@@@@  @@@@         @   @@@@                  \n   @@@@@          @@@@    @@@@@   @    @    @@@@@  @@@@             @@@@                  \n   @@@@@          @@@@   @@@@@@   @@@@@@    @@@@@  @@@@             @@@@                  \n   @@@@@         @@@@@   @@@@@@   @    @    @@@@@  @@@@             @@@@                  \n   @@@@@         @@@@     @@@@@             @@@@   @@@@             @@@@                  \n    @@@@        @@@@@@    @@@@@@           @@@@    @@@@             @@@@                  \n     @@@@      @@@@  @@@@@@ @@@@@         @@@      @@@@             @@@@   @@             \n       @@@@@@@@@     @@@@@     @@@@@@@@@@@         @@@@               @@@@@\n */\n/**\n * @title Aori  \n * @dev version 0.3.1 \n * @notice Aori is a trust-minimized omnichain intent settlement protocol.\n * Connecting users and solvers from any chain to any chain,\n * facilitating peer to peer exchange from any token to any token.\n */\n\ncontract Aori is IAori, OApp, ReentrancyGuard, Pausable, EIP712 {\n    using PayloadPackUtils for bytes32[];\n    using PayloadUnpackUtils for bytes;\n    using PayloadSizeUtils for uint8;\n    using HookUtils for SrcHook;\n    using HookUtils for DstHook;\n    using SafeERC20 for IERC20;\n    using BalanceUtils for Balance;\n    using ValidationUtils for IAori.Order;\n    using NativeTokenUtils for address;\n    \n    constructor(\n        address _endpoint, // LayerZero endpoint address\n        address _owner, // Contract owner address\n        uint32 _eid, // Endpoint ID for this chain\n        uint16 _maxFillsPerSettle // Maximum number of fills per settlement\n    ) OApp(_endpoint, _owner) Ownable(_owner) EIP712() {\n        ENDPOINT_ID = _eid;\n        MAX_FILLS_PER_SETTLE = _maxFillsPerSettle;\n        require(_owner != address(0), \"Set owner\");\n        isSupportedChain[_eid] = true;\n    }\n\n    /**\n     * @notice Allows the contract to receive native tokens\n     * @dev Required for native token operations including hook interactions\n     */\n    receive() external payable {\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         SRC STATE                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Unique identifier for this endpoint in the LayerZero network\n    uint32 public immutable ENDPOINT_ID;\n\n    // Tracks locked and unlocked balances for each user and token\n    mapping(address => mapping(address => Balance)) private balances;\n\n    // Stores orders by their unique hash\n    mapping(bytes32 => Order) public orders;\n    \n    // Tracks supported chains by their endpoint IDs\n    mapping(uint32 => bool) public isSupportedChain;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         DST STATE                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Maximum number of fills that can be included in a single settlement\n    uint16 public immutable MAX_FILLS_PER_SETTLE;\n\n    // Tracks the current status of each order\n    mapping(bytes32 => IAori.OrderStatus) public orderStatus;\n\n    // Tracks whitelisted hook addresses for token conversion\n    mapping(address => bool) public isAllowedHook;\n\n    // Tracks whitelisted solver addresses\n    mapping(address => bool) public isAllowedSolver;\n\n    // Maps source endpoint and maker to an array of order hashes filled by a filler\n    mapping(uint32 => mapping(address => bytes32[])) public srcEidToFillerFills;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OWNER FUNCTIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Pauses all contract operations\n     * @dev Only callable by the contract owner\n    */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses all contract operations\n     * @dev Only callable by the contract owner\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Adds a hook address to the whitelist\n     * @param hook The address of the hook to whitelist\n     * @dev Only callable by the contract owner\n     */\n    function addAllowedHook(address hook) external onlyOwner {\n        isAllowedHook[hook] = true;\n    }\n\n    /**\n     * @notice Removes a hook address from the whitelist\n     * @param hook The address of the hook to remove\n     * @dev Only callable by the contract owner\n     */\n    function removeAllowedHook(address hook) external onlyOwner {\n        isAllowedHook[hook] = false;\n    }\n\n    /**\n     * @notice Adds a solver address to the whitelist\n     * @param solver The address of the solver to whitelist\n     * @dev Only callable by the contract owner\n     */\n    function addAllowedSolver(address solver) external onlyOwner {\n        isAllowedSolver[solver] = true;\n    }\n\n    /**\n     * @notice Removes a solver address from the whitelist\n     * @param solver The address of the solver to remove\n     * @dev Only callable by the contract owner\n     */\n    function removeAllowedSolver(address solver) external onlyOwner {\n        isAllowedSolver[solver] = false;\n    }\n\n    /**\n    * @notice Adds a single chain to the supported chains list\n    * @param eid The endpoint ID of the chain to add\n    * @dev Only callable by the contract owner\n    */\n    function addSupportedChain(uint32 eid) external onlyOwner {\n        isSupportedChain[eid] = true;\n        emit ChainSupported(eid);\n    }\n\n    /**\n    * @notice Adds multiple chains to the supported chains list\n    * @param eids Array of endpoint IDs of the chains to add\n    * @return results Array of booleans indicating which EIDs were successfully added\n    * @dev Only callable by the contract owner\n    */\n    function addSupportedChains(uint32[] calldata eids) external onlyOwner returns (bool[] memory results) {\n        uint256 length = eids.length;\n        results = new bool[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            isSupportedChain[eids[i]] = true;\n            emit ChainSupported(eids[i]);\n            results[i] = true;\n        }\n        return results;\n    }\n\n    /**\n     * @notice Removes a supported chain by its endpoint ID\n     * @param eid The endpoint ID of the chain to remove\n     * @dev Only callable by the contract owner\n     */\n    function removeSupportedChain(uint32 eid) external onlyOwner {\n        isSupportedChain[eid] = false;\n        emit ChainRemoved(eid);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EMERGENCY FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n    * @notice Emergency function to cancel an order, bypassing normal restrictions\n    * @dev Only callable by the contract owner. Always transfers tokens to maintain accounting consistency.\n    * @param orderId The hash of the order to cancel\n    * @param recipient The address to send tokens to\n    */\n    function emergencyCancel(bytes32 orderId, address recipient) external onlyOwner {\n        require(orderStatus[orderId] == IAori.OrderStatus.Active, \"Can only cancel active orders\");\n        require(recipient != address(0), \"Invalid recipient address\");\n        \n        Order memory order = orders[orderId];\n        require(order.srcEid == ENDPOINT_ID, \"Emergency cancel only allowed on source chain\");\n        \n        address tokenAddress = order.inputToken;\n        uint128 amountToReturn = uint128(order.inputAmount);\n        \n        // Validate sufficient balance\n        tokenAddress.validateSufficientBalance(amountToReturn);\n        \n        orderStatus[orderId] = IAori.OrderStatus.Cancelled;\n        bool success = balances[order.offerer][tokenAddress].decreaseLockedNoRevert(amountToReturn);\n        require(success, \"Failed to decrease locked balance\");\n        \n        // Transfer tokens to recipient\n        tokenAddress.safeTransfer(recipient, amountToReturn);\n        \n        emit Cancel(orderId);\n        emit Withdraw(recipient, tokenAddress, amountToReturn);\n    }\n \n    /**\n     * @notice Emergency function to extract tokens or ether from the contract\n     * @dev Only callable by the contract owner. Does not update user balances - use for direct contract withdrawals.\n     * @param token The token address to withdraw\n     * @param amount The amount of tokens to withdraw\n     */\n    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n        uint256 etherBalance = address(this).balance;\n        if (etherBalance > 0) {\n            (bool success, ) = payable(owner()).call{ value: etherBalance }(\"\");\n            require(success, \"Ether withdrawal failed\");\n        }\n        if (amount > 0) {\n            token.safeTransfer(owner(), amount);\n        }\n    }\n\n    /**\n     * @notice Emergency function to extract tokens from a specific user's balance while maintaining accounting consistency\n     * @dev Only callable by the contract owner. Updates user balances to maintain internal accounting state.\n     * @param token The token address to withdraw\n     * @param amount The amount of tokens to withdraw\n     * @param user The user address whose balance to withdraw from\n     * @param isLocked Whether to withdraw from locked (true) or unlocked (false) balance\n     * @param recipient The address to send the withdrawn tokens to\n     */\n    function emergencyWithdraw(\n        address token, \n        uint256 amount, \n        address user, \n        bool isLocked,\n        address recipient\n    ) external onlyOwner {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(user != address(0), \"Invalid user address\");\n        require(recipient != address(0), \"Invalid recipient address\");\n        \n        if (isLocked) {\n            bool success = balances[user][token].decreaseLockedNoRevert(uint128(amount));\n            require(success, \"Failed to decrease locked balance\");\n        } else {\n            uint256 unlockedBalance = balances[user][token].unlocked;\n            require(unlockedBalance >= amount, \"Insufficient unlocked balance\");\n            balances[user][token].unlocked = uint128(unlockedBalance - amount);\n        }\n        \n        // Validate sufficient balance and transfer\n        token.validateSufficientBalance(amount);\n        token.safeTransfer(recipient, amount);\n        \n        emit Withdraw(user, token, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Modifier to ensure the caller is a whitelisted solver\n     * @dev Only allows whitelisted solvers to proceed\n     */\n    modifier onlySolver() {\n        require(isAllowedSolver[msg.sender], \"Invalid solver\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the caller is a whitelisted hook address\n     * @dev Only allows whitelisted hook addresses to proceed\n     * @param hookAddress The address of the hook to check\n     */\n    modifier allowedHookAddress(address hookAddress) {\n        require(isAllowedHook[hookAddress], \"Invalid hook address\");\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          DEPOSIT                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Deposits tokens to the contract without a hook call\n     * @dev Takes tokens from offerer (not the caller) via transferFrom after signature verification\n     * @param order The order details\n     * @param signature The user's EIP712 signature over the order\n     */\n    function deposit(\n        Order calldata order,\n        bytes calldata signature\n    ) external nonReentrant whenNotPaused onlySolver {\n        require(!order.inputToken.isNativeToken(), \"Use depositNative for native tokens\");\n        \n        bytes32 orderId = order.validateDeposit(\n            signature,\n            _hashOrder712(order),\n            ENDPOINT_ID,\n            this.orderStatus,\n            this.isSupportedChain\n        );\n        IERC20(order.inputToken).safeTransferFrom(order.offerer, address(this), order.inputAmount);\n        _postDeposit(order.inputToken, order.inputAmount, order, orderId);\n    }\n\n    /**\n     * @notice Deposits tokens to the contract with a hook call\n     * @dev Executes a hook call for token conversion before deposit processing\n     * @param order The order details\n     * @param signature The user's EIP712 signature over the order\n     * @param hook The pre-hook configuration\n     */\n    function deposit(\n        Order calldata order,\n        bytes calldata signature,\n        SrcHook calldata hook\n    ) external nonReentrant whenNotPaused onlySolver {\n        require(hook.isSome(), \"Missing hook\");\n        bytes32 orderId = order.validateDeposit(\n            signature,\n            _hashOrder712(order),\n            ENDPOINT_ID,\n            this.orderStatus,\n            this.isSupportedChain\n        );\n\n        // Execute hook and handle single-chain or cross-chain logic\n        (uint256 amountReceived, address tokenReceived) = \n            _executeSrcHook(order, hook);\n        \n        emit SrcHookExecuted(orderId, tokenReceived, amountReceived);\n        \n        if (order.isSingleChainSwap()) {\n            // Save the order details\n            orders[orderId] = order;\n            \n            // Update order status directly \n            orderStatus[orderId] = IAori.OrderStatus.Settled;\n            emit Settle(orderId);\n        } else {\n            // Process the cross-chain deposit\n            _postDeposit(tokenReceived, amountReceived, order, orderId);\n        }\n    }\n\n    /**\n     * @notice Executes a source hook and returns the balance change\n     * @param order The order details\n     * @param hook The source hook configuration\n     * @return amountReceived The amount of tokens received from the hook\n     * @return tokenReceived The token address that was received\n     */\n    function _executeSrcHook(\n        Order calldata order,\n        SrcHook calldata hook\n    ) internal allowedHookAddress(hook.hookAddress) returns (\n        uint256 amountReceived,\n        address tokenReceived\n    ) {\n        // Transfer input tokens to the hook\n        if (order.inputToken.isNativeToken()) {\n            require(msg.value == order.inputAmount, \"Incorrect native amount\");\n            (bool success, ) = payable(hook.hookAddress).call{value: order.inputAmount}(\"\");\n            require(success, \"Native transfer to hook failed\");\n        } else {\n            IERC20(order.inputToken).safeTransferFrom(\n                order.offerer,\n                hook.hookAddress,\n                order.inputAmount\n            );\n        }\n        \n        if (order.isSingleChainSwap()) {\n            // For single-chain swaps, observe balance changes in the output token\n            amountReceived = ExecutionUtils.observeBalChg(\n                hook.hookAddress,\n                hook.instructions,\n                order.outputToken\n            );\n            \n            // Ensure sufficient output was received\n            require(amountReceived >= order.outputAmount, \"Insufficient output from hook\");\n            \n            // Set token received to the output token\n            tokenReceived = order.outputToken;\n            \n            // Handle token distribution for single-chain swaps here\n            // 1. Transfer agreed amount to recipient\n            order.outputToken.safeTransfer(order.recipient, order.outputAmount);\n            \n            // 2. Return any surplus to the solver\n            uint256 surplus = amountReceived - order.outputAmount;\n            if (surplus > 0) {\n                order.outputToken.safeTransfer(msg.sender, surplus);\n            }\n        } else {\n            // For cross-chain swaps, observe balance changes in the preferred token\n            amountReceived = ExecutionUtils.observeBalChg(\n                hook.hookAddress,\n                hook.instructions,\n                hook.preferredToken\n            );\n            \n            // Ensure sufficient preferred tokens were received\n            require(amountReceived >= hook.minPreferedTokenAmountOut, \"Insufficient output from hook\");\n            \n            // Set token received to the preferred token\n            tokenReceived = hook.preferredToken;\n        }\n    }\n\n    /**\n     * @notice Posts a deposit and updates the order status\n     * @param depositToken The token address to deposit\n     * @param depositAmount The amount of tokens to deposit\n     * @param order The order details\n     * @param orderId The unique identifier for the order\n     */\n    function _postDeposit(\n        address depositToken,\n        uint256 depositAmount,\n        Order calldata order,\n        bytes32 orderId\n    ) internal {\n        balances[order.offerer][depositToken].lock(SafeCast.toUint128(depositAmount));\n        orderStatus[orderId] = IAori.OrderStatus.Active;\n        orders[orderId] = order;\n        orders[orderId].inputToken = depositToken;\n        orders[orderId].inputAmount = SafeCast.toUint128(depositAmount);\n\n        emit Deposit(orderId, order);\n    }\n\n    /**\n     * @notice Deposits native tokens to the contract without a hook call\n     * @dev User calls this directly and sends their own ETH via msg.value\n     * @param order The order details (must specify NATIVE_TOKEN as inputToken)\n     * @param signature The user's EIP712 signature over the order\n     */\n    function depositNative(\n        Order calldata order,\n        bytes calldata signature\n    ) external payable nonReentrant whenNotPaused {\n        require(order.inputToken.isNativeToken(), \"Order must specify native token\");\n        require(msg.value == order.inputAmount, \"Incorrect native amount\");\n        require(msg.sender == order.offerer, \"Only offerer can deposit native tokens\");\n        \n        bytes32 orderId = order.validateDeposit(\n            signature,\n            _hashOrder712(order),\n            ENDPOINT_ID,\n            this.orderStatus,\n            this.isSupportedChain\n        );\n        \n        _postDeposit(order.inputToken, order.inputAmount, order, orderId);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                             FILL                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Fills an order by transferring output tokens from the filler\n     * @dev Uses safeTransferFrom to move tokens directly from solver to recipient\n     * @param order The order details to fill\n     */\n    function fill(Order calldata order) external payable nonReentrant whenNotPaused onlySolver {\n        bytes32 orderId = order.validateFill(\n            ENDPOINT_ID,\n            this.orderStatus\n        );\n        \n        // Handle native or ERC20 output\n        if (order.outputToken.isNativeToken()) {\n            // For native tokens, solver must send exact amount via msg.value\n            require(msg.value == order.outputAmount, \"Incorrect native amount sent\");\n            order.outputToken.safeTransfer(order.recipient, order.outputAmount);\n        } else {\n            // For ERC20 tokens, ensure no native tokens were sent\n            require(msg.value == 0, \"No native tokens should be sent for ERC20 fills\");\n            IERC20(order.outputToken).safeTransferFrom(msg.sender, order.recipient, order.outputAmount);\n        }\n\n        // single-chain swap path\n        if (order.isSingleChainSwap()) {\n            // Use simplified settlement without hook flag since we know it's a direct fill\n            _settleSingleChainSwap(orderId, order, msg.sender);\n            return;\n        }\n\n        // Cross-chain swap path\n        _postFill(orderId, order);\n    }\n\n    /**\n     * @notice Fills an order by converting preferred tokens from the filler to output tokens   \n     * @dev Utilizes a hook contract to perform the token conversion\n     * @param order The order details to fill\n     * @param hook The solver data including hook configuration\n     */\n    function fill(\n        Order calldata order,\n        IAori.DstHook calldata hook\n    ) external payable nonReentrant whenNotPaused onlySolver {\n\n        bytes32 orderId = order.validateFill(\n            ENDPOINT_ID,\n            this.orderStatus\n        );\n        uint256 amountReceived = _executeDstHook(order, hook);\n\n        emit DstHookExecuted(orderId, hook.preferredToken, amountReceived);\n\n        uint256 surplus = amountReceived - order.outputAmount;\n\n        // Handle native or ERC20 output with surplus\n        if (order.outputToken.isNativeToken()) {\n            order.outputToken.safeTransfer(order.recipient, order.outputAmount);\n            \n            if (surplus > 0) {\n                order.outputToken.safeTransfer(msg.sender, surplus);\n            }\n        } else {\n            IERC20(order.outputToken).safeTransfer(order.recipient, order.outputAmount);\n            \n            if (surplus > 0) {\n                IERC20(order.outputToken).safeTransfer(msg.sender, surplus);\n            }\n        }\n\n        // Handle settlement based on chain type\n        if (order.isSingleChainSwap()) {\n            // For single-chain swaps, settle immediately with proper balance accounting\n            _settleSingleChainSwap(orderId, order, msg.sender);\n        } else {\n            // For cross-chain swaps, use normal fill processing\n            _postFill(orderId, order);\n        }\n    }\n\n    /**\n     * @notice Executes a destination hook and handles token conversion\n     * @param order The order details\n     * @param hook The destination hook configuration\n     * @return balChg The balance change observed from the hook execution\n     */\n    function _executeDstHook(\n        Order calldata order,\n        IAori.DstHook calldata hook\n    ) internal allowedHookAddress(hook.hookAddress) returns (uint256 balChg) {\n        if (msg.value > 0) {\n            // Native token input\n            (bool success, ) = payable(hook.hookAddress).call{value: msg.value}(\"\");\n            require(success, \"Native transfer to hook failed\");\n        } else if (hook.preferedDstInputAmount > 0) {\n            // ERC20 or native token input\n            if (hook.preferredToken.isNativeToken()) {\n                require(msg.value == hook.preferedDstInputAmount, \"Incorrect native amount for preferred token\");\n                (bool success, ) = payable(hook.hookAddress).call{value: hook.preferedDstInputAmount}(\"\");\n                require(success, \"Native transfer to hook failed\");\n            } else {\n                IERC20(hook.preferredToken).safeTransferFrom(\n                    msg.sender,\n                    hook.hookAddress,\n                    hook.preferedDstInputAmount\n                );\n            }\n        }\n\n        balChg = ExecutionUtils.observeBalChg(\n            hook.hookAddress,\n            hook.instructions,\n            order.outputToken\n        );\n        require(balChg >= order.outputAmount, \"Hook must provide at least the expected output amount\");\n    }\n\n    /**\n     * @notice Processes an order after successful filling\n     * @param orderId The unique identifier for the order\n     * @param order The order details that were filled\n     */\n    function _postFill(bytes32 orderId, Order calldata order) internal {\n        orderStatus[orderId] = IAori.OrderStatus.Filled;\n        srcEidToFillerFills[order.srcEid][msg.sender].push(orderId);\n        emit Fill(orderId, order);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                            SETTLE                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Settles filled orders by batching order hashes into a payload and sending through LayerZero\n     * @dev Requires ETH to be sent for LayerZero fees\n     * @param srcEid The source endpoint ID\n     * @param filler The filler address\n     * @param extraOptions Additional LayerZero options\n     */\n    function settle(\n        uint32 srcEid,\n        address filler,\n        bytes calldata extraOptions\n    ) external payable nonReentrant whenNotPaused onlySolver {\n        bytes32[] storage arr = srcEidToFillerFills[srcEid][filler];\n        uint256 arrLength = arr.length;\n        require(arrLength > 0, \"No orders provided\");\n\n        uint16 fillCount = uint16(\n            arrLength < MAX_FILLS_PER_SETTLE ? arrLength : MAX_FILLS_PER_SETTLE\n        );\n        bytes memory payload = arr.packSettlement(filler, fillCount);\n\n        MessagingReceipt memory receipt = _lzSend(srcEid, payload, extraOptions, MessagingFee(msg.value, 0), payable(msg.sender));\n        emit SettleSent(srcEid, filler, payload, receipt.guid, receipt.nonce, receipt.fee.nativeFee);\n    }\n\n    /**\n     * @notice Settles a single order and updates balances\n     * @param orderId The hash of the order to settle\n     * @param filler The filler address\n     */\n    function _settleOrder(bytes32 orderId, address filler) internal {\n        if (orderStatus[orderId] != IAori.OrderStatus.Active) {\n            return; // Any reverts are skipped\n        }\n        // Update balances: move from locked to unlocked\n        Order memory order = orders[orderId];\n        bool successLock = balances[order.offerer][order.inputToken].decreaseLockedNoRevert(\n            uint128(order.inputAmount)\n        );\n        bool successUnlock = balances[filler][order.inputToken].increaseUnlockedNoRevert(\n            uint128(order.inputAmount)\n        );\n\n        if (!successLock || !successUnlock) {\n            return; // Any reverts are skipped\n        }\n        orderStatus[orderId] = IAori.OrderStatus.Settled;\n\n        emit Settle(orderId);\n    }\n\n    /**\n     * @notice Handles settlement of filled orders\n     * @param payload The settlement payload containing order hashes and filler information\n     * @param senderEid The source endpoint ID\n     * @dev Skips orders that were filled on the wrong chain and emits an event\n     */\n    function _handleSettlement(bytes calldata payload, uint32 senderEid) internal {\n        payload.validateSettlementLen();\n        (address filler, uint16 fillCount) = payload.unpackSettlementHeader();\n        payload.validateSettlementLen(fillCount);\n\n        for (uint256 i = 0; i < fillCount; ++i) {\n            bytes32 orderId = payload.unpackSettlementBodyAt(i);\n            Order memory order = orders[orderId];\n            \n            if (order.dstEid != senderEid) {\n                emit settlementFailed(\n                    orderId, \n                    order.dstEid, \n                    senderEid, \n                    \"Eid mismatch\"\n                );\n                continue; \n            }\n            \n            _settleOrder(orderId, filler);\n        }\n    }\n\n    /**\n     * @notice Handles settlement of same-chain swaps without hooks\n     * @dev Performs immediate settlement without cross-chain messaging for same-chain orders\n     * @param orderId The unique identifier for the order\n     * @param order The order details\n     * @param solver The address of the solver\n     */\n    function _settleSingleChainSwap(\n        bytes32 orderId,\n        Order memory order,\n        address solver\n    ) internal {\n        // Capture initial balance state for validation\n        uint128 initialOffererLocked = balances[order.offerer][order.inputToken].locked;\n        uint128 initialSolverUnlocked = balances[solver][order.inputToken].unlocked;\n        \n        // Move tokens from offerer's locked balance to solver's unlocked balance\n        if (balances[order.offerer][order.inputToken].locked >= order.inputAmount) {\n            bool successLock = balances[order.offerer][order.inputToken].decreaseLockedNoRevert(\n                uint128(order.inputAmount)\n            );\n            \n            bool successUnlock = balances[solver][order.inputToken].increaseUnlockedNoRevert(\n                uint128(order.inputAmount)\n            );\n            \n            require(successLock && successUnlock, \"Balance operation failed\");\n        }\n        \n        // Validate balance transfer\n        uint128 finalOffererLocked = balances[order.offerer][order.inputToken].locked;\n        uint128 finalSolverUnlocked = balances[solver][order.inputToken].unlocked;\n\n        balances[order.offerer][order.inputToken].validateBalanceTransferOrRevert(\n            initialOffererLocked,\n            finalOffererLocked,\n            initialSolverUnlocked,\n            finalSolverUnlocked,\n            uint128(order.inputAmount)\n        );\n\n        // Order is immediately settled\n        orderStatus[orderId] = IAori.OrderStatus.Settled;\n        emit Settle(orderId);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                            CANCEL                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Allows cancellation of single-chain orders from the source chain\n     * @dev Cross-chain orders must be cancelled from the destination chain to prevent race conditions.\n     * Cancellation is permitted for:\n     *      1. Whitelisted solvers (for any active single-chain order)\n     *      2. Order offerers (for their own expired single-chain orders)\n     * @param orderId The hash of the order to cancel\n     */\n    function cancel(bytes32 orderId) external whenNotPaused {\n        Order memory order = orders[orderId];\n        \n        order.validateSourceChainCancel(\n            orderId,\n            ENDPOINT_ID,\n            this.orderStatus,\n            msg.sender,\n            this.isAllowedSolver\n        );\n        \n        _cancel(orderId);\n    }\n\n    /**\n     * @notice Cancels a cross-chain order from the destination chain by sending a cancellation message to the source chain\n     * @dev This is the required method for cancelling cross-chain orders to prevent race conditions with settlement.\n     * Requires ETH to be sent for LayerZero fees. Cancellation is permitted for:\n     *      1. Whitelisted solvers (anytime before settlement)\n     *      2. Order offerers (after expiry)\n     *      3. Order recipients (after expiry)\n     * @param orderId The hash of the order to cancel\n     * @param orderToCancel The order details to cancel\n     * @param extraOptions Additional LayerZero options\n     */\n    function cancel(\n        bytes32 orderId,\n        Order calldata orderToCancel,\n        bytes calldata extraOptions\n    ) external payable nonReentrant whenNotPaused {\n        require(hash(orderToCancel) == orderId, \"Submitted order data doesn't match orderId\");\n        \n        orderToCancel.validateCancel(\n            orderId,\n            ENDPOINT_ID,\n            this.orderStatus,\n            msg.sender,\n            this.isAllowedSolver\n        );\n        bytes memory payload = PayloadPackUtils.packCancellation(orderId);\n        MessagingReceipt memory receipt = __lzSend(orderToCancel.srcEid, payload, extraOptions);\n        orderStatus[orderId] = IAori.OrderStatus.Cancelled;\n        emit CancelSent(orderId, receipt.guid, receipt.nonce, receipt.fee.nativeFee);\n    }\n\n    /**\n     * @notice Internal function to cancel an order and update balances\n     * @param orderId The hash of the order to cancel\n     */\n    function _cancel(bytes32 orderId) internal {\n        require(orderStatus[orderId] == IAori.OrderStatus.Active, \"Can only cancel active orders\");\n        \n        // Get order details and amount before changing state\n        Order memory order = orders[orderId];\n        uint128 amountToReturn = uint128(order.inputAmount);\n        address tokenAddress = order.inputToken;\n        address recipient = order.offerer;\n        \n        // Validate contract has sufficient tokens before any state changes\n        tokenAddress.validateSufficientBalance(amountToReturn);\n        \n        // Update state first (checks-effects)\n        orderStatus[orderId] = IAori.OrderStatus.Cancelled;\n        \n        // Decrease locked balance\n        bool success = balances[recipient][tokenAddress].decreaseLockedNoRevert(amountToReturn);\n        require(success, \"Failed to decrease locked balance\");\n        \n        // Transfer tokens directly to offerer (interactions)\n        tokenAddress.safeTransfer(recipient, amountToReturn);\n        \n        // Emit the Cancel event from IAori interface\n        emit Cancel(orderId);\n    }\n\n    /**\n     * @notice Handles cancellation payload from source chain\n     * @param payload The cancellation payload containing the order hash\n     */\n    function _handleCancellation(bytes calldata payload) internal {\n        payload.validateCancellationLen();\n        bytes32 orderId = payload.unpackCancellation();\n        _cancel(orderId);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          WITHDRAW                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Allows users to withdraw their unlocked token balances\n     * @param token The token address to withdraw\n     * @param amount The amount to withdraw (use 0 to withdraw full balance)\n     */\n    function withdraw(address token, uint256 amount) external nonReentrant whenNotPaused {\n        address holder = msg.sender;\n        uint256 unlockedBalance = balances[holder][token].unlocked;\n        require(unlockedBalance > 0, \"Non-zero balance required\");\n        \n        if (amount == 0) {\n            amount = unlockedBalance;\n        } else {\n            require(unlockedBalance >= amount, \"Insufficient unlocked balance\");\n        }\n        \n        // Validate sufficient contract balance and transfer\n        token.validateSufficientBalance(amount);\n        token.safeTransfer(holder, amount);\n        \n        balances[holder][token].unlocked = uint128(unlockedBalance - amount);\n        emit Withdraw(holder, token, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   LAYERZERO FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Sends a message through LayerZero\n     * @dev Captures and returns the MessagingReceipt for event emission\n     * @param eId The destination endpoint ID\n     * @param payload The message payload\n     * @param extraOptions Additional options\n     * @return receipt The messaging receipt containing transaction details (guid, nonce, fee)\n     */\n    function __lzSend(\n        uint32 eId, \n        bytes memory payload, \n        bytes calldata extraOptions\n    ) internal returns (MessagingReceipt memory receipt) {\n        return _lzSend(eId, payload, extraOptions, MessagingFee(msg.value, 0), payable(msg.sender));\n    }\n\n    /**\n     * @notice Handles incoming LayerZero messages for order settlement and cancellation\n     * @dev Processes settlement and cancellation payloads\n     * @param payload The message payload containing order hashes and filler information\n     */\n    function _lzReceive(\n        Origin calldata origin,\n        bytes32,\n        bytes calldata payload,\n        address,\n        bytes calldata\n    ) internal override whenNotPaused {\n        require(payload.length > 0, \"Empty payload\");\n        \n        // Pass the sender chain's endpoint ID\n        _recvPayload(payload, origin.srcEid);\n    }\n\n    /**\n     * @notice Processes incoming LayerZero messages based on the payload type\n     * @param payload The message payload containing order hashes and filler information\n     */\n    function _recvPayload(bytes calldata payload, uint32 srcEid) internal {\n        PayloadType msgType = payload.getType();\n        if (msgType == PayloadType.Cancellation) {\n            _handleCancellation(payload);\n        } else if (msgType == PayloadType.Settlement) {\n            _handleSettlement(payload, srcEid);\n        } else {\n            revert(\"Unsupported payload type\");\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               EIP-712/HASHING HELPER FUNCTIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Returns the domain name and version for EIP712.\n     */\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        return (\"Aori\", \"0.3.0\");\n    }\n\n    /**\n     * @dev EIP712 typehash for order struct\n     */\n    bytes32 private constant _ORDER_TYPEHASH =\n        keccak256(\n            \"Order(uint128 inputAmount,uint128 outputAmount,address inputToken,address outputToken,uint32 startTime,uint32 endTime,uint32 srcEid,uint32 dstEid,address offerer,address recipient)\"\n        );\n\n    /**\n     * @dev Returns the EIP712 digest for the given order\n     * @param order The order details\n     * @return The computed digest\n     */\n    function _hashOrder712(Order calldata order) internal view returns (bytes32) {\n        return\n            _hashTypedDataSansChainId(\n                keccak256(\n                    abi.encode(\n                        _ORDER_TYPEHASH,\n                        order.inputAmount,\n                        order.outputAmount,\n                        order.inputToken,\n                        order.outputToken,\n                        order.startTime,\n                        order.endTime,\n                        order.srcEid,\n                        order.dstEid,\n                        order.offerer,\n                        order.recipient\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Computes the hash of an order\n     * @param order The order to hash\n     * @return The computed hash\n     */\n    function hash(IAori.Order calldata order) public pure returns (bytes32) {\n        return keccak256(abi.encode(order));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       VIEW FUNCTIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Returns the locked balance for a user and token\n     * @param offerer The user address\n     * @param token The token address\n     * @return The locked balance amount\n     */\n    function getLockedBalances(address offerer, address token) external view returns (uint256) {\n        return balances[offerer][token].locked;\n    }\n\n    /**\n     * @notice Returns the unlocked balance for a user and token\n     * @param offerer The user address\n     * @param token The token address\n     * @return The unlocked balance amount\n     */\n    function getUnlockedBalances(address offerer, address token) external view returns (uint256) {\n        return balances[offerer][token].unlocked;\n    }\n\n    /**\n     * @notice Returns a fee quote for sending a message through LayerZero\n     * @param _dstEid Destination endpoint ID\n     * @param _msgType Message type (0 for settlement, 1 for cancellation)\n     * @param _options Execution options\n     * @param _payInLzToken Whether to pay fee in LayerZero token\n     * @param _srcEid Source endpoint ID (for settle operations)\n     * @param _filler Filler address (for settle operations)\n     * @return fee The messaging fee in native currency\n     */\n    function quote(\n        uint32 _dstEid,\n        uint8 _msgType,\n        bytes calldata _options,\n        bool _payInLzToken,\n        uint32 _srcEid,\n        address _filler\n    ) public view returns (uint256 fee) {\n        // Calculate payload size using the library function\n        uint256 fillsLength = srcEidToFillerFills[_srcEid][_filler].length;\n        uint256 payloadSize = PayloadSizeUtils.calculatePayloadSize(\n            _msgType,\n            fillsLength,\n            MAX_FILLS_PER_SETTLE\n        );\n\n    // Get the quote from LayerZero\n    MessagingFee memory messagingFee = _quote(\n            _dstEid,\n            new bytes(payloadSize),\n            _options,\n            _payInLzToken\n        );\n\n        return messagingFee.nativeFee;\n    }\n}\n"
    }
}