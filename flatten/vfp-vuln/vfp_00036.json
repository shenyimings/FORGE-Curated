{
    "vfp_id": "vfp_00036",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Malicious user can change the TradeType to steal funds from the vault or withdraw request manager",
            "description": "The vulnerability exists in the _executeRedemptionTrades function of AbstractSingleSidedLP and the _preStakingTrade function of AbstractWithdrawRequestManager, where the trade type (TradeType) is not hardcoded and can be arbitrarily set by the caller. The intended behavior is to use TradeType.EXACT_IN_SINGLE to swap a precise amount of non-asset tokens (e.g., DAI) for an unknown amount of the asset token (e.g., WBTC). However, a malicious user can set the trade type to TradeType.EXACT_OUT_SINGLE, which instead swaps an arbitrary amount of input tokens to receive an exact, potentially massive amount of output tokens (e.g., 10,000 DAI swapped to receive 1e14 WBTC). The root cause is the lack of validation or hardcoding of the trade type, allowing user-controlled parameters to dictate critical trade behavior. This can be exploited during redemption or withdrawal flows by crafting malicious trade data, especially via flexible adapters like ZeroExAdaptor. The impact is high: attackers can drain vaults or withdraw request managers by extracting vastly more assets than entitled, leading to significant fund loss.\n",
            "severity": "High",
            "location": [
                "AbstractSingleSidedLP.sol::_executeRedemptionTrades#223",
                "AbstractWithdrawRequestManager.sol::_preStakingTrade#268",
                "AbstractSingleSidedLP.sol::Trade#223"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/withdraws/AbstractWithdrawRequestManager.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Value of Etherna's Withdrawal Request is incorrect",
            "description": "The protocol prices pending withdrawal requests using the yield token's (e.g., sUSDe) oracle price, even when the underlying asset amount is fixed at initiation. For tokens like sUSDe, where the cooldownShares function converts shares into a predetermined amount of USDe that is escrowed and guaranteed, the value should be based on the fixed USDe amount, not the fluctuating sUSDe price.\n\nThe root cause is that the getWithdrawRequestValue function in AbstractWithdrawRequestManager always uses the yield token price from Chainlink oracles, regardless of whether the yield token is subject to slashing or price changes. This is incorrect for stable staking tokens like sUSDe, where the final payout is fixed upon cooldown initiation.\n\nIf the sUSDe price increases after withdrawal initiation, the protocol overvalues the withdrawal request, making an undercollateralized position appear healthy and preventing timely liquidation. Conversely, if the price drops, it may cause premature liquidation. An attacker could exploit timing to initiate withdrawals when sUSDe is undervalued and borrow excessively against inflated collateral values.\n\nThe impact is high: incorrect valuation can lead to bad debt accumulation due to missed liquidations or unjust liquidations, threatening protocol solvency and user funds.\n",
            "severity": "High",
            "location": [
                "AbstractWithdrawRequestManager.sol::getWithdrawRequestValue#330",
                "StakedUSDeV2.sol::cooldownShares#112-117",
                "Ethena.sol::canFinalizeWithdrawRequest#94-97"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/withdraws/AbstractWithdrawRequestManager.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Revert in getWithdrawRequestValue Can Freeze Account Positions",
            "description": "The getWithdrawRequestValue function in AbstractSingleSidedLP.sol reverts if no withdraw request exists for any of the pool tokens (Line 332). This revert can be triggered when a token's exit balance is zero, which can occur due to rounding down during proportional withdrawal, especially for tokens with low decimals or in cases of near-total asset swaps or depeg events.\n\nThe root cause is the lack of a conditional check to skip tokens with zero withdrawal amounts instead of requiring a withdraw request to exist. Since Notional's price() function depends on getWithdrawRequestValue(), a revert here will cause the entire price calculation to fail.\n\nAn attacker could exploit this by manipulating pool balances (e.g., via large swaps) to force a zero exit balance for a token, thereby ensuring any call to price() reverts. This would prevent any interaction with affected accounts.\n\nThe impact is severe: affected accounts become permanently stuck, as no operations (repay, withdraw, liquidate, exit) can proceed if the price oracle reverts. This leads to a denial of service for user positions and potential permanent loss of access to funds.\n",
            "severity": "Critical",
            "location": [
                "AbstractSingleSidedLP.sol::getWithdrawRequestValue#332",
                "AbstractSingleSidedLP.sol::getWithdrawRequestValue#362"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        }
    ],
    "affected_files": {
        "AbstractSingleSidedLP.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport \"../interfaces/ISingleSidedLP.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {DEFAULT_PRECISION, ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Trade, TradeType} from \"../interfaces/ITradingModule.sol\";\nimport {RewardManagerMixin} from \"../rewards/RewardManagerMixin.sol\";\nimport {IWithdrawRequestManager, WithdrawRequest, TokenizedWithdrawRequest} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {\n    CannotEnterPosition,\n    WithdrawRequestNotFinalized,\n    PoolShareTooHigh,\n    AssetRemaining\n} from \"../interfaces/Errors.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract AbstractSingleSidedLP is RewardManagerMixin {\n    using TokenUtils for ERC20;\n\n    uint256 immutable MAX_POOL_SHARE;\n    address internal immutable LP_LIB;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as address(0)\n    function TOKENS() internal view virtual returns (ERC20[] memory);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256);\n\n    /// @dev Checks that the reentrancy context is valid\n    function _checkReentrancyContext() internal virtual;\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(ILPLib.initialApproveTokens.selector));\n    }\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(ILPLib.joinPoolAndStake.selector, amounts, minPoolClaim));\n    }\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.unstakeAndExitPool.selector, poolClaim, minAmounts, isSingleSided\n        ));\n        exitBalances = abi.decode(result, (uint256[]));\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(\n        uint256 _maxPoolShare,\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        uint8 _yieldTokenDecimals,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) RewardManagerMixin( _asset, _yieldToken, _feeRate, _rewardManager, _yieldTokenDecimals) {\n        MAX_POOL_SHARE = _maxPoolShare;\n        // Although there will be multiple withdraw request managers, we only need to set one here\n        // to check whether or not a withdraw request is pending. If any one of the withdraw requests\n        // is not finalized then the entire withdraw will revert and the user will remain in a pending\n        // withdraw state.\n        withdrawRequestManager = _withdrawRequestManager;\n    }\n\n    function _initialize(bytes calldata data) internal override {\n        super._initialize(data);\n        _initialApproveTokens();\n    }\n\n    function _mintYieldTokens(\n        uint256 assets,\n        address /* receiver */,\n        bytes memory depositData\n    ) internal override {\n        DepositParams memory params = abi.decode(depositData, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            // NOTE: amounts is modified in place\n            _executeDepositTrades(assets, amounts, params.depositTrades);\n        } else {\n            // This is a single sided entry, will revert if index is out of bounds\n            amounts[PRIMARY_INDEX()] = assets;\n        }\n\n        _joinPoolAndStake(amounts, params.minPoolClaim);\n\n        _checkPoolShare();\n    }\n\n    function _checkPoolShare() internal view virtual {\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * MAX_POOL_SHARE) / DEFAULT_PRECISION;\n        // This is incumbent on a 1-1 ratio between the lpToken and the yieldToken, if that is not the\n        // case then this function must be overridden.\n        uint256 poolClaim = _yieldTokenBalance();\n        if (maxSupplyThreshold < poolClaim) revert PoolShareTooHigh(poolClaim, maxSupplyThreshold);\n    }\n\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal override {\n        RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n\n        // Stores the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances;\n        bool isSingleSided;\n        ERC20[] memory tokens;\n        if (isEscrowed) {\n            // Attempt to withdraw all pending requests, tokens may be different if there\n            // is a withdraw request.\n            (exitBalances, tokens) = _withdrawPendingRequests(sharesOwner, sharesToRedeem);\n            // If there are pending requests, then we are not single sided by definition\n            isSingleSided = false;\n        } else {\n            isSingleSided = params.redemptionTrades.length == 0;\n            uint256 yieldTokensBurned = convertSharesToYieldToken(sharesToRedeem);\n            exitBalances = _unstakeAndExitPool(yieldTokensBurned, params.minAmounts, isSingleSided);\n            tokens = TOKENS();\n        }\n\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            _executeRedemptionTrades(tokens, exitBalances, params.redemptionTrades);\n        }\n    }\n\n    /// @dev Trades the amount of primary token into other secondary tokens prior to entering a pool.\n    function _executeDepositTrades(\n        uint256 assets,\n        uint256[] memory amounts,\n        TradeParams[] memory depositTrades\n    ) internal {\n        ERC20[] memory tokens = TOKENS();\n        Trade memory trade;\n        uint256 assetRemaining = assets;\n\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == PRIMARY_INDEX()) continue;\n            TradeParams memory t = depositTrades[i];\n\n            if (t.tradeAmount > 0) {\n                trade = Trade({\n                    tradeType: t.tradeType,\n                    sellToken: address(asset),\n                    buyToken: address(tokens[i]),\n                    amount: t.tradeAmount,\n                    limit: t.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: t.exchangeData\n                });\n                // Always selling the primaryToken and buying the secondary token.\n                (uint256 amountSold, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n                amounts[i] = amountBought;\n                // Will revert on underflow if over-selling the primary borrowed\n                assetRemaining -= amountSold;\n            }\n        }\n\n        if (PRIMARY_INDEX() < amounts.length) {\n            amounts[PRIMARY_INDEX()] = assetRemaining;\n        } else if (0 < assetRemaining) {\n            // This can happen if the asset is not in the pool and we need to trade all\n            // of the remaining asset for tokens in the pool.\n            revert AssetRemaining(assetRemaining);\n        }\n    }\n\n    /// @dev Trades the amount of secondary tokens into the primary token after exiting a pool.\n    function _executeRedemptionTrades(\n        ERC20[] memory tokens,\n        uint256[] memory exitBalances,\n        TradeParams[] memory redemptionTrades\n    ) internal returns (uint256 finalPrimaryBalance) {\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (address(tokens[i]) == address(asset)) {\n                finalPrimaryBalance += exitBalances[i];\n                continue;\n            }\n\n            TradeParams memory t = redemptionTrades[i];\n            // Always sell the entire exit balance to the primary token\n            if (exitBalances[i] > 0) {\n                Trade memory trade = Trade({\n                    tradeType: t.tradeType,\n                    sellToken: address(tokens[i]),\n                    buyToken: address(asset),\n                    amount: exitBalances[i],\n                    limit: t.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: t.exchangeData\n                });\n                (/* */, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n                finalPrimaryBalance += amountBought;\n            }\n        }\n    }\n\n    function _preLiquidation(address liquidateAccount, address liquidator, uint256 sharesToLiquidate, uint256 accountSharesHeld) internal override {\n        _checkReentrancyContext();\n        return super._preLiquidation(liquidateAccount, liquidator, sharesToLiquidate, accountSharesHeld);\n    }\n\n    function __postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal override returns (bool didTokenize) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.tokenizeWithdrawRequest.selector, liquidateAccount, liquidator, sharesToLiquidator\n        ));\n        didTokenize = abi.decode(result, (bool));\n    }\n\n    function __initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override returns (uint256 requestId) {\n        WithdrawParams memory params = abi.decode(data, (WithdrawParams));\n\n        uint256[] memory exitBalances = _unstakeAndExitPool({\n            poolClaim: yieldTokenAmount,\n            minAmounts: params.minAmounts,\n            // When initiating a withdraw, we always exit proportionally\n            isSingleSided: false\n        });\n\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.initiateWithdraw.selector, account, sharesHeld, exitBalances, params.withdrawData\n        ));\n        uint256[] memory requestIds = abi.decode(result, (uint256[]));\n        // Although we get multiple requests ids, we just return the first one here. The rest will be\n        // observable off chain.\n        requestId = requestIds[0];\n    }\n\n    function _withdrawPendingRequests(\n        address sharesOwner,\n        uint256 sharesToRedeem\n    ) internal returns (uint256[] memory exitBalances, ERC20[] memory tokens) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.finalizeAndRedeemWithdrawRequest.selector, sharesOwner, sharesToRedeem\n        ));\n        (exitBalances, tokens) = abi.decode(result, (uint256[], ERC20[]));\n    }\n\n    /// @notice Returns the total value in terms of the borrowed token of the account's position\n    function convertToAssets(uint256 shares) public view override returns (uint256) {\n        if (t_CurrentAccount != address(0) && _isWithdrawRequestPending(t_CurrentAccount)) {\n            return ILPLib(LP_LIB).getWithdrawRequestValue(t_CurrentAccount, asset, shares);\n        }\n\n        return super.convertToAssets(shares);\n    }\n\n    function _isWithdrawRequestPending(address account) internal view override returns (bool) {\n        return ILPLib(LP_LIB).hasPendingWithdrawals(account);\n    }\n}\n\nabstract contract BaseLPLib is ILPLib {\n    using TokenUtils for ERC20;\n\n    function TOKENS() internal view virtual returns (ERC20[] memory);\n\n    /// @inheritdoc ILPLib\n    function getWithdrawRequestValue(\n        address account,\n        address asset,\n        uint256 shares\n    ) external view returns (uint256 totalValue) {\n        ERC20[] memory tokens = TOKENS();\n\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            // This is called as a view function, not a delegate call so use the msg.sender to get\n            // the correct vault address\n            (bool hasRequest, uint256 value) = manager.getWithdrawRequestValue(msg.sender, account, asset, shares);\n            // Ensure that this is true so that we do not lose any value.\n            require(hasRequest);\n            totalValue += value;\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function hasPendingWithdrawals(address account) external view override returns (bool) {\n        ERC20[] memory tokens = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            if (address(manager) == address(0)) continue;\n            // This is called as a view function, not a delegate call so use the msg.sender to get\n            // the correct vault address\n            (WithdrawRequest memory w, /* */) = manager.getWithdrawRequest(msg.sender, account);\n            if (w.requestId != 0) return true;\n        }\n\n        return false;\n    }\n\n    /// @inheritdoc ILPLib\n    function initiateWithdraw(\n        address account,\n        uint256 sharesHeld,\n        uint256[] calldata exitBalances,\n        bytes[] calldata withdrawData\n    ) external override returns (uint256[] memory requestIds) {\n        ERC20[] memory tokens = TOKENS();\n\n        requestIds = new uint256[](exitBalances.length);\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (exitBalances[i] == 0) continue;\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n\n            tokens[i].checkApprove(address(manager), exitBalances[i]);\n            // Will revert if there is already a pending withdraw\n            requestIds[i] = manager.initiateWithdraw({\n                account: account,\n                yieldTokenAmount: exitBalances[i],\n                sharesAmount: sharesHeld,\n                data: withdrawData[i]\n            });\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function finalizeAndRedeemWithdrawRequest(\n        address sharesOwner,\n        uint256 sharesToRedeem\n    ) external override returns (uint256[] memory exitBalances, ERC20[] memory withdrawTokens) {\n        ERC20[] memory tokens = TOKENS();\n\n        exitBalances = new uint256[](tokens.length);\n        withdrawTokens = new ERC20[](tokens.length);\n\n        WithdrawRequest memory w;\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            (w, /* */) = manager.getWithdrawRequest(address(this), sharesOwner);\n\n            uint256 yieldTokensBurned = uint256(w.yieldTokenAmount) * sharesToRedeem / w.sharesAmount;\n            bool finalized;\n            (exitBalances[i], finalized) = manager.finalizeAndRedeemWithdrawRequest({\n                account: sharesOwner, withdrawYieldTokenAmount: yieldTokensBurned, sharesToBurn: sharesToRedeem\n            });\n            if (!finalized) revert WithdrawRequestNotFinalized(w.requestId);\n            withdrawTokens[i] = ERC20(manager.WITHDRAW_TOKEN());\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function tokenizeWithdrawRequest(\n        address liquidateAccount,\n        address liquidator,\n        uint256 sharesToLiquidator\n    ) external override returns (bool didTokenize) {\n        ERC20[] memory tokens = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            if (address(manager) == address(0)) continue;\n            // If there is no withdraw request then this will be a noop, make sure to OR with the previous result\n            // to ensure that the result is always set but it is done after so the tokenizeWithdrawRequest call\n            // is not short circuited.\n            didTokenize = manager.tokenizeWithdrawRequest(liquidateAccount, liquidator, sharesToLiquidator) || didTokenize;\n        }\n    }\n}\n",
        "AbstractWithdrawRequestManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport \"../interfaces/IWithdrawRequestManager.sol\";\nimport {Initializable} from \"../proxy/Initializable.sol\";\nimport {ClonedCoolDownHolder} from \"./ClonedCoolDownHolder.sol\";\nimport {\n    Unauthorized,\n    ExistingWithdrawRequest,\n    NoWithdrawRequest,\n    InvalidWithdrawRequestTokenization\n} from \"../interfaces/Errors.sol\";\nimport {TypeConvert} from \"../utils/TypeConvert.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {ADDRESS_REGISTRY, DEFAULT_PRECISION} from \"../utils/Constants.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Trade, TradeType, TRADING_MODULE, nProxy, TradeFailed} from \"../interfaces/ITradingModule.sol\";\n\n\n/**\n * Library to handle potentially illiquid withdraw requests of staking tokens where there\n * is some indeterminate lock up time before tokens can be redeemed. Examples would be withdraws\n * of staked or restaked ETH, tokens like sUSDe or stkAave which have cooldown periods before they\n * can be withdrawn.\n *\n * Primarily, this library tracks the withdraw request and an associated identifier for the withdraw\n * request. It also allows for the withdraw request to be \"tokenized\" so that shares of the withdraw\n * request can be liquidated.\n */\nabstract contract AbstractWithdrawRequestManager is IWithdrawRequestManager, Initializable {\n    using SafeERC20 for ERC20;\n    using TypeConvert for uint256;\n\n    /// @inheritdoc IWithdrawRequestManager\n    address public immutable override YIELD_TOKEN;\n    /// @inheritdoc IWithdrawRequestManager\n    address public immutable override WITHDRAW_TOKEN;\n    /// @inheritdoc IWithdrawRequestManager\n    address public immutable override STAKING_TOKEN;\n\n    mapping(address => bool) public override isApprovedVault;\n    mapping(address vault => mapping(address account => WithdrawRequest)) private s_accountWithdrawRequest;\n    mapping(uint256 requestId => TokenizedWithdrawRequest) private s_tokenizedWithdrawRequest;\n\n    constructor(address _withdrawToken, address _yieldToken, address _stakingToken) Initializable() {\n        WITHDRAW_TOKEN = _withdrawToken;\n        YIELD_TOKEN = _yieldToken;\n        STAKING_TOKEN = _stakingToken;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != ADDRESS_REGISTRY.upgradeAdmin()) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    /// @dev Ensures that only approved vaults can initiate withdraw requests.\n    modifier onlyApprovedVault() {\n        if (!isApprovedVault[msg.sender]) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function getWithdrawRequest(address vault, address account) public view override\n        returns (WithdrawRequest memory w, TokenizedWithdrawRequest memory s) {\n        w = s_accountWithdrawRequest[vault][account];\n        s = s_tokenizedWithdrawRequest[w.requestId];\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function isPendingWithdrawRequest(address vault, address account) public view override returns (bool) {\n        return s_accountWithdrawRequest[vault][account].requestId != 0;\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function setApprovedVault(address vault, bool isApproved) external override onlyOwner {\n        isApprovedVault[vault] = isApproved;\n        emit ApprovedVault(vault, isApproved);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function stakeTokens(\n        address depositToken,\n        uint256 amount,\n        bytes calldata data\n    ) external override onlyApprovedVault returns (uint256 yieldTokensMinted) {\n        uint256 initialYieldTokenBalance = ERC20(YIELD_TOKEN).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        (uint256 stakeTokenAmount, bytes memory stakeData) = _preStakingTrade(depositToken, amount, data);\n        _stakeTokens(stakeTokenAmount, stakeData);\n\n        yieldTokensMinted = ERC20(YIELD_TOKEN).balanceOf(address(this)) - initialYieldTokenBalance;\n        ERC20(YIELD_TOKEN).safeTransfer(msg.sender, yieldTokensMinted);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesAmount,\n        bytes calldata data\n    ) external override onlyApprovedVault returns (uint256 requestId) {\n        WithdrawRequest storage accountWithdraw = s_accountWithdrawRequest[msg.sender][account];\n        if (accountWithdraw.requestId != 0) revert ExistingWithdrawRequest(msg.sender, account, accountWithdraw.requestId);\n\n        // Receive the requested amount of yield tokens from the approved vault.\n        ERC20(YIELD_TOKEN).safeTransferFrom(msg.sender, address(this), yieldTokenAmount);\n\n        requestId = _initiateWithdrawImpl(account, yieldTokenAmount, data);\n        accountWithdraw.requestId = requestId;\n        accountWithdraw.yieldTokenAmount = yieldTokenAmount.toUint120();\n        accountWithdraw.sharesAmount = sharesAmount.toUint120();\n        s_tokenizedWithdrawRequest[requestId] = TokenizedWithdrawRequest({\n            totalYieldTokenAmount: yieldTokenAmount.toUint120(),\n            totalWithdraw: 0,\n            finalized: false\n        });\n\n        emit InitiateWithdrawRequest(account, msg.sender, yieldTokenAmount, sharesAmount, requestId);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function finalizeAndRedeemWithdrawRequest(\n        address account,\n        uint256 withdrawYieldTokenAmount,\n        uint256 sharesToBurn\n    ) external override onlyApprovedVault returns (uint256 tokensWithdrawn, bool finalized) {\n        WithdrawRequest storage s_withdraw = s_accountWithdrawRequest[msg.sender][account];\n        if (s_withdraw.requestId == 0) return (0, false);\n\n        (tokensWithdrawn, finalized) = _finalizeWithdraw(account, s_withdraw);\n\n        if (finalized) {\n            // Allows for partial withdrawal of yield tokens\n            if (withdrawYieldTokenAmount < s_withdraw.yieldTokenAmount) {\n                tokensWithdrawn = tokensWithdrawn * withdrawYieldTokenAmount / s_withdraw.yieldTokenAmount;\n                s_withdraw.sharesAmount -= sharesToBurn.toUint120();\n                s_withdraw.yieldTokenAmount -= withdrawYieldTokenAmount.toUint120();\n            } else {\n                require(s_withdraw.yieldTokenAmount == withdrawYieldTokenAmount);\n                delete s_accountWithdrawRequest[msg.sender][account];\n            }\n\n            ERC20(WITHDRAW_TOKEN).safeTransfer(msg.sender, tokensWithdrawn);\n        }\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function finalizeRequestManual(\n        address vault,\n        address account\n    ) external override returns (uint256 tokensWithdrawn, bool finalized) {\n        WithdrawRequest storage s_withdraw = s_accountWithdrawRequest[vault][account];\n        if (s_withdraw.requestId == 0) revert NoWithdrawRequest(vault, account);\n\n        // Do not transfer any tokens off of this method here. Withdrawn tokens will be held in the\n        // tokenized withdraw request until the vault calls this contract to withdraw the tokens.\n        (tokensWithdrawn, finalized) = _finalizeWithdraw(account, s_withdraw);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function tokenizeWithdrawRequest(\n        address _from,\n        address _to,\n        uint256 sharesAmount\n    ) external override onlyApprovedVault returns (bool didTokenize) {\n        if (_from == _to) revert();\n\n        WithdrawRequest storage s_withdraw = s_accountWithdrawRequest[msg.sender][_from];\n        uint256 requestId = s_withdraw.requestId;\n        if (requestId == 0 || sharesAmount == 0) return false;\n\n        // Ensure that no withdraw request gets overridden, the _to account always receives their withdraw\n        // request in the account withdraw slot. All storage is updated prior to changes to the `w` storage\n        // variable below.\n        WithdrawRequest storage toWithdraw = s_accountWithdrawRequest[msg.sender][_to];\n        if (toWithdraw.requestId != 0 && toWithdraw.requestId != requestId) {\n            revert ExistingWithdrawRequest(msg.sender, _to, toWithdraw.requestId);\n        }\n\n        toWithdraw.requestId = requestId;\n\n        if (s_withdraw.sharesAmount < sharesAmount) {\n            // This should never occur given the checks below.\n            revert InvalidWithdrawRequestTokenization();\n        } else if (s_withdraw.sharesAmount == sharesAmount) {\n            // If the resulting vault shares is zero, then delete the request. The _from account's\n            // withdraw request is fully transferred to _to. In this case, the _to account receives\n            // the full amount of the _from account's withdraw request.\n            toWithdraw.yieldTokenAmount = toWithdraw.yieldTokenAmount + s_withdraw.yieldTokenAmount;\n            toWithdraw.sharesAmount = toWithdraw.sharesAmount + s_withdraw.sharesAmount;\n            delete s_accountWithdrawRequest[msg.sender][_from];\n        } else {\n            // In this case, the amount of yield tokens is transferred from one account to the other.\n            uint256 yieldTokenAmount = s_withdraw.yieldTokenAmount * sharesAmount / s_withdraw.sharesAmount;\n            toWithdraw.yieldTokenAmount = (toWithdraw.yieldTokenAmount + yieldTokenAmount).toUint120();\n            toWithdraw.sharesAmount = (toWithdraw.sharesAmount + sharesAmount).toUint120();\n            s_withdraw.yieldTokenAmount = (s_withdraw.yieldTokenAmount - yieldTokenAmount).toUint120();\n            s_withdraw.sharesAmount = (s_withdraw.sharesAmount - sharesAmount).toUint120();\n        }\n\n        emit WithdrawRequestTokenized(_from, _to, requestId, sharesAmount);\n        return true;\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function rescueTokens(\n        address cooldownHolder, address token, address receiver, uint256 amount\n    ) external override onlyOwner {\n        ClonedCoolDownHolder(cooldownHolder).rescueTokens(ERC20(token), receiver, amount);\n    }\n\n    /// @notice Finalizes a withdraw request and updates the account required to determine how many\n    /// tokens the account has a claim over.\n    function _finalizeWithdraw(\n        address account,\n        WithdrawRequest memory w\n    ) internal returns (uint256 tokensWithdrawn, bool finalized) {\n        TokenizedWithdrawRequest storage s = s_tokenizedWithdrawRequest[w.requestId];\n\n        // If the tokenized request was already finalized in a different transaction\n        // then return the values here and we can short circuit the withdraw impl\n        if (s.finalized) {\n            return (\n                uint256(s.totalWithdraw) * uint256(w.yieldTokenAmount) / uint256(s.totalYieldTokenAmount),\n                true\n            );\n        }\n\n        // These values are the total tokens claimed from the withdraw request, does not\n        // account for potential tokenization.\n        (tokensWithdrawn, finalized) = _finalizeWithdrawImpl(account, w.requestId);\n\n        if (finalized) {\n            s.totalWithdraw = tokensWithdrawn.toUint120();\n            // Safety check to ensure that we do not override a finalized tokenized withdraw request\n            require(s.finalized == false);\n            s.finalized = true;\n\n            tokensWithdrawn = uint256(s.totalWithdraw) * uint256(w.yieldTokenAmount) / uint256(s.totalYieldTokenAmount);\n        } else {\n            // No tokens claimed if not finalized\n            require(tokensWithdrawn == 0);\n        }\n    }\n\n\n    /// @notice Required implementation to begin the withdraw request\n    /// @return requestId some identifier of the withdraw request\n    function _initiateWithdrawImpl(\n        address account,\n        uint256 yieldTokenAmount,\n        bytes calldata data\n    ) internal virtual returns (uint256 requestId);\n\n    /// @notice Required implementation to finalize the withdraw\n    /// @return tokensWithdrawn total tokens claimed as a result of the withdraw, does not\n    /// necessarily represent the tokens that go to the account if the request has been\n    /// tokenized due to liquidation\n    /// @return finalized returns true if the withdraw has been finalized\n    function _finalizeWithdrawImpl(address account, uint256 requestId) internal virtual returns (uint256 tokensWithdrawn, bool finalized);\n\n    /// @notice Required implementation to stake the deposit token to the yield token\n    function _stakeTokens(uint256 amount, bytes memory stakeData) internal virtual;\n\n    /// @dev Allows for the deposit token to be traded into the staking token prior to staking, i.e.\n    /// enables USDC to USDe trades before staking into sUSDe.\n    function _preStakingTrade(address depositToken, uint256 depositAmount, bytes calldata data) internal returns (uint256 amountBought, bytes memory stakeData) {\n        if (depositToken == STAKING_TOKEN) {\n            amountBought = depositAmount;\n            stakeData = data;\n        } else {\n            StakingTradeParams memory params = abi.decode(data, (StakingTradeParams));\n            stakeData = params.stakeData;\n\n            (/* */, amountBought) = _executeTrade(Trade({\n                tradeType: params.tradeType,\n                sellToken: depositToken,\n                buyToken: STAKING_TOKEN,\n                amount: depositAmount,\n                exchangeData: params.exchangeData,\n                limit: params.minPurchaseAmount,\n                deadline: block.timestamp\n            }), params.dexId);\n        }\n    }\n\n    function _executeTrade(\n        Trade memory trade,\n        uint16 dexId\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        (bool success, bytes memory result) = nProxy(payable(address(TRADING_MODULE))).getImplementation()\n            .delegatecall(abi.encodeWithSelector(TRADING_MODULE.executeTrade.selector, dexId, trade));\n        if (!success) {\n            assembly {\n                // Copy the return data to memory\n                returndatacopy(0, 0, returndatasize())\n                // Revert with the return data\n                revert(0, returndatasize())\n            }\n        }\n\n        (amountSold, amountBought) = abi.decode(result, (uint256, uint256));\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function getWithdrawRequestValue(\n        address vault,\n        address account,\n        address asset,\n        uint256 shares\n    ) external view override returns (bool hasRequest, uint256 valueInAsset) {\n        WithdrawRequest memory w = s_accountWithdrawRequest[vault][account];\n        if (w.requestId == 0) return (false, 0);\n\n        TokenizedWithdrawRequest memory s = s_tokenizedWithdrawRequest[w.requestId];\n\n        int256 tokenRate;\n        uint256 tokenAmount;\n        uint256 tokenDecimals;\n        uint256 assetDecimals = TokenUtils.getDecimals(asset);\n        if (s.finalized) {\n            // If finalized the withdraw request is locked to the tokens withdrawn\n            (tokenRate, /* */) = TRADING_MODULE.getOraclePrice(WITHDRAW_TOKEN, asset);\n            tokenDecimals = TokenUtils.getDecimals(WITHDRAW_TOKEN);\n            tokenAmount = (uint256(w.yieldTokenAmount) * uint256(s.totalWithdraw)) / uint256(s.totalYieldTokenAmount);\n        } else {\n            // Otherwise we use the yield token rate\n            (tokenRate, /* */) = TRADING_MODULE.getOraclePrice(YIELD_TOKEN, asset);\n            tokenDecimals = TokenUtils.getDecimals(YIELD_TOKEN);\n            tokenAmount = w.yieldTokenAmount;\n        }\n\n        // The trading module always returns a positive rate in 18 decimals so we can safely\n        // cast to uint256\n        uint256 totalValue = (uint256(tokenRate) * tokenAmount * (10 ** assetDecimals)) /\n            ((10 ** tokenDecimals) * DEFAULT_PRECISION);\n        // NOTE: returns the normalized value given the shares input\n        return (true, totalValue * shares / w.sharesAmount);\n    }\n\n}"
    }
}