{
    "vfp_id": "vfp_00252",
    "project_name": "2024.12.21 - Final - Idle Finance Credit Vaults Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "A single depositor can grief other depositors on the liquidity deposited for the first epoch",
            "description": "This vulnerability allows a single depositor to exploit the withdrawal mechanism before the first epoch begins, enabling them to claim both principal and interest immediately without waiting for epoch finalization. The root cause lies in the `claimWithdrawRequest` function of `IdleCreditVault.sol`, which fails to enforce a check on `epochEndDate` when validating withdrawal claims. Since `epochEndDate` is initialized as 0, the condition `if (epochEndDate != 0 && ...)` evaluates to false, allowing withdrawals to be claimed prematurely. An attacker can continuously deposit, request withdrawal, and claim the request before the first epoch ends, effectively stealing interest (and potentially principal) from other depositors. This leads to a loss of funds for honest users who deposited liquidity expecting to earn interest over the epoch.\n",
            "severity": "High",
            "location": [
                "IdleCreditVault.sol::claimWithdrawRequest#194-196",
                "IdleCDOEpochVariant.sol::_additionalInit#67-92"
            ],
            "files": [
                "idle-tranches/contracts/strategies/idle/IdleCreditVault.sol",
                "idle-tranches/contracts/IdleCDOEpochVariant.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Users may not withdraw their funds because of the grief attack",
            "description": "A malicious user can manipulate the tranche share price by donating a large amount of underlying tokens after deposits but before withdrawals, thereby increasing the value per share. When the attacker requests a withdrawal, they receive a disproportionately large amount of underlying tokens due to the inflated share price. This depletes the available strategy tokens in the contract, leaving insufficient balance for other users to withdraw their full amount. The root cause is the lack of protection against donation-based manipulation of the share price during the withdrawal phase. Although the attacker does not profit directly, they can grief other users by preventing them from withdrawing their expected funds, leading to potential loss of user funds and reduced trust in the system.\n",
            "severity": "Medium",
            "location": [
                "IdleCDOEpochVariant.sol::requestWithdraw#490"
            ],
            "files": [
                "idle-tranches/contracts/IdleCDOEpochVariant.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "A user can avoid paying fees in the requestWithdraw function",
            "description": "Due to precision loss in fee calculation, a user can avoid paying withdrawal fees by splitting a large withdrawal into multiple smaller ones. The fee is calculated as a percentage of the interest earned on the withdrawn amount, but because of integer division and truncation, very small interest amounts result in zero fees. On tokens with low decimals (e.g., WBTC with 8 decimals), an attacker can structure withdrawals such that the interest per transaction is less than 10 wei, causing the 10% fee to round down to zero. Given low L2 transaction costs (e.g., Optimism), this attack is economically feasible and can be repeated thousands of times at minimal cost, leading to significant loss of protocol fees over time.\n",
            "severity": "Medium",
            "location": [
                "IdleCDOEpochVariant.sol::requestWithdraw#519"
            ],
            "files": [
                "idle-tranches/contracts/IdleCDOEpochVariant.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Interest will be lost if funds are withdrawn from a tranche in which the APRRatio != FULL_ALLOC",
            "description": "When a user withdraws from a tranche with a non-full APR ratio (e.g., the junior BB tranche with 0% APR), the contract only calculates interest owed to the user but fails to account for the total interest that should be generated by the lent funds. Specifically, the `_calcInterestWithdrawRequest` function multiplies interest by `_trancheAprRatio`, which is zero for the junior tranche, resulting in no interest being collected. However, the underlying assets are still lent out and should generate yield for the senior tranche. Because this interest is not captured, the senior tranche loses out on expected yield. This flaw leads to a loss of revenue for senior tranche holders whenever a junior tranche withdrawal occurs, undermining the yield distribution model.\n",
            "severity": "Medium",
            "location": [
                "IdleCDOEpochVariant.sol::requestWithdraw#518-524"
            ],
            "files": [
                "idle-tranches/contracts/IdleCDOEpochVariant.sol"
            ]
        }
    ],
    "affected_files": {
        "IdleCDOEpochVariant.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport {IdleCDO} from \"./IdleCDO.sol\";\nimport {IKeyring} from \"./interfaces/keyring/IKeyring.sol\";\nimport {IdleCDOTranche} from \"./IdleCDOTranche.sol\";\nimport {IdleCreditVault} from \"./strategies/idle/IdleCreditVault.sol\";\nimport {IERC20Detailed} from \"./interfaces/IERC20Detailed.sol\";\nimport {IIdleCDOStrategy} from \"./interfaces/IIdleCDOStrategy.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nerror EpochRunning();\nerror NotAllowed();\nerror Default();\n\n/// @title IdleCDO variant that supports epochs. \n/// @dev When epoch is running no deposits or withdrawals are allowed. When epoch ends \n/// lenders can request withdrawals, that will be fullfilled by the end of the next epoch.\n/// If the apr for the new epoch is lower than the last one, lenders can request 'instant' \n/// withdrawals that will be fullfilled when the epoch starts and after instantWithdrawDelay (3 days).\n/// Funds for instant and normal withdrawals are sent to the strategy contract (IdleCreditVault)\ncontract IdleCDOEpochVariant is IdleCDO {\n  using SafeERC20Upgradeable for IERC20Detailed;\n\n  /// @notice flag to check if epoch is running\n  bool public isEpochRunning;\n  /// @notice flag to allow AA withdraw requests\n  bool public allowAAWithdrawRequest;\n  /// @notice flag to allow BB withdraw requests\n  bool public allowBBWithdrawRequest;\n  /// @notice duration of the epoch\n  uint256 public epochDuration;\n  /// @notice delay to allow instant withdraw requests after next epoch starts\n  uint256 public instantWithdrawDelay;\n  /// @notice expected interest for the current epoch\n  uint256 public expectedEpochInterest;\n  /// @notice end date of the current epoch\n  uint256 public epochEndDate;\n  /// @notice deadline to allow instant withdraw requests\n  uint256 public instantWithdrawDeadline;\n  /// @notice apr of the last epoch, unscaled\n  uint256 public lastEpochApr;\n  /// @notice min apr change to trigger instant withdraw\n  uint256 public instantWithdrawAprDelta;\n  /// @notice fees from pending withdraw request for the curr epoch\n  uint256 public pendingWithdrawFees;\n  /// @notice net underlyings gained last epoch\n  uint256 public lastEpochInterest;\n  /// @notice flag to allow instant withdraws\n  bool public allowInstantWithdraw;\n  /// @notice flag to completely disable instant withdraw\n  bool public disableInstantWithdraw;\n  /// @notice flag to check if borrower defaulted\n  bool public defaulted;\n  /// @notice Keyring wallet checker address\n  address public keyring;\n  /// @notice keyring policyId\n  uint256 public keyringPolicyId;\n  /// @notice time between 2 epochs, can be set to 0 to start the next epoch without waiting a specified time\n  uint256 public bufferPeriod;\n  /// @notice flag for enabling anyone to request a withdraw (needed for liquidations)\n  bool public keyringAllowWithdraw;\n\n  event AccrueInterest(uint256 interest, uint256 fees);\n  event BorrowerDefault(uint256 funds);\n\n  function _additionalInit() internal virtual override {\n    // no unlent perc\n    unlentPerc = 0;\n\n    // Set the contract with monotranche as default (can still be changed if needed)\n    // losses are split according to tvl, senior has no priority\n    lossToleranceBps = FULL_ALLOC;\n    // all yield to senior\n    isAYSActive = false;\n    // deposit directly in the strategy\n    directDeposit = true;\n\n    // set epoch params\n    epochDuration = 30 days;\n    bufferPeriod = 5 days;\n\n    // allow requests for withdrawals\n    allowAAWithdrawRequest = true;\n    allowBBWithdrawRequest = true;\n\n    // default no instant withdraw allowed\n    disableInstantWithdraw = true;\n\n    // scale the apr to include the buffer period\n    _setScaledApr(IdleCreditVault(strategy).getApr());\n  }\n\n  /// @notice Check if msg sender is owner or manager\n  function _checkOnlyOwnerOrManager() internal view {\n    if (msg.sender != owner() && msg.sender != IdleCreditVault(strategy).manager()) {\n      revert NotAllowed();\n    }\n  }\n\n  ///\n  /// Only owner or manager methods \n  ///\n\n  /// @notice update epoch duration\n  /// @dev IMPORTANT: bufferPeriod should not be changed once set otherwise interest calculations will be wrong\n  /// @param _epochDuration duration in seconds\n  /// @param _bufferPeriod time between 2 epochs\n  function setEpochParams(uint256 _epochDuration, uint256 _bufferPeriod) public {\n    _checkOnlyOwnerOrManager();\n    // cannot set epoch params if epoch is running\n    // cannot set epochDuration to 0 as it's reserved for closing the pool\n    // and cannot set epochDuration if previously was set to 0 as borrower repaid all funds\n    if (isEpochRunning || _epochDuration == 0 || epochDuration == 0) {\n      revert NotAllowed();\n    }\n    epochDuration = _epochDuration;\n    bufferPeriod = _bufferPeriod;\n  }\n\n  /// @notice update instant withdraw params\n  /// @param _delay delay in seconds\n  /// @param _aprDelta min apr delta to trigger instant withdraw\n  /// @param _disable flag to disable instant withdraw\n  function setInstantWithdrawParams(uint256 _delay, uint256 _aprDelta, bool _disable) external {\n    _checkOnlyOwnerOrManager();\n    if (isEpochRunning) {\n      revert EpochRunning();\n    }\n    instantWithdrawDelay = _delay;\n    instantWithdrawAprDelta = _aprDelta;\n    disableInstantWithdraw = _disable;\n  }\n\n  /// @notice update keyring address\n  /// @param _keyring address of the keyring contract\n  /// @param _keyringPolicyId policyId to check for wallet\n  /// @param _keyringAllowWithdraw flag to allow anyone to request a withdraw\n  function setKeyringParams(address _keyring, uint256 _keyringPolicyId, bool _keyringAllowWithdraw) external {\n    _checkOnlyOwnerOrManager();\n    keyring = _keyring;\n    keyringPolicyId = _keyringPolicyId;\n    keyringAllowWithdraw = _keyringAllowWithdraw;\n  }\n\n  /// @notice Start the epoch. No deposits or withdrawals are allowed after this.\n  /// @dev We calculate the total funds that the borrower should return at the end of the epoch\n  /// ie interests + fees from normal withdraw requests. We send to the borrower underlyings amounts ie interests + \n  /// new deposits - instant withdraw requests if any. If funds are not enough to satisfy all requests\n  /// then borrower should return the difference before instantWithdrawDeadline. After epoch start there\n  /// should be no underlyings in this contract\n  function startEpoch() external {\n    _checkOnlyOwnerOrManager();\n\n    // Check that buffer period passed (and epoch is not running as epochEndDate is set)\n    // and that the pool is not closed (ie epochDuration == 0)\n    uint256 _epochDuration = epochDuration; \n    if (block.timestamp < (epochEndDate + bufferPeriod) || _epochDuration == 0) {\n      revert NotAllowed();\n    }\n\n    isEpochRunning = true;\n    // prevent deposits\n    _pause();\n\n    // prevent withdrawals requests\n    allowAAWithdrawRequest = false;\n    allowBBWithdrawRequest = false;\n\n    IdleCreditVault _strategy = IdleCreditVault(strategy);\n\n    // calculate expected interest \n    // NOTE: all withdrawal requests, burn tranche tokens and decrease getContractValue,\n    // this can be done only prior to the start of the epoch so getContractValue() is the total amount net\n    // of all withdrawal requests. We add the fee that we should get for normal pending withdraws\n    expectedEpochInterest = _calcInterest(getContractValue()) + pendingWithdrawFees;\n\n    // set expected epoch end date\n    epochEndDate = block.timestamp + _epochDuration;\n    // set instant withdraw deadline\n    instantWithdrawDeadline = block.timestamp + instantWithdrawDelay;\n\n    // transfer in this contract funds from interest payment, that were sent to the strategy in stopEpoch\n    _strategy.sendInterestAndDeposits(lastEpochInterest + _strategy.totEpochDeposits());\n\n    // we should first check if there are *instant* redeem requests pending \n    // and if yes we should send as much underlyings as possible to the IdleCreditVault contract\n    // if there is any surplus then we send those to the borrower\n    uint256 pendingInstant = _strategy.pendingInstantWithdraws();\n    uint256 totUnderlyings = _contractTokenBalance(token);\n\n    // if there are more requests than the current underlyings we simply send all underlyings\n    // to the IdleCreditVault contract\n    if (pendingInstant > totUnderlyings) {\n      // transfer funds to strategy\n      _strategy.collectInstantWithdrawFunds(totUnderlyings);\n      return;\n    }\n    // otherwise we send the amount needed to satisfy the requests to the strategy \n    _strategy.collectInstantWithdrawFunds(pendingInstant);\n    // allow instant withdraws right away without waiting for the deadline\n    allowInstantWithdraw = true;\n    // and transfer the surplus to the borrower\n    try this.sendFundsToBorrower(totUnderlyings - pendingInstant) {\n      // funds transferred correctly\n    } catch {\n      _handleBorrowerDefault(totUnderlyings - pendingInstant);\n    }\n  }\n\n  /// @notice workaround to have safeTransfer to borrower as external and use it in a try/catch block\n  /// @param _amount Amount of underlyings to transfer\n  function sendFundsToBorrower(uint256 _amount) external {\n     if (msg.sender != address(this)) {\n      revert NotAllowed();\n    }\n    IERC20Detailed(token).safeTransfer(IdleCreditVault(strategy).borrower(), _amount);\n  }\n\n  /// @notice Stop epoch, accrue interest to the vault and get funds to fullfill normal\n  /// (ie non-instant) withdraw requests from the prev epoch.\n  /// @param _newApr New apr to set for the next epoch\n  /// @param _interest Interest gained in the epoch. This will overwrite the expected interest\n  /// must be 0 if there is no need to overwrite the expected interest and if > 0 then it should\n  /// be greater than the pending withdraw fees and newApr must be 0. If `_interest` is 1 then\n  /// it is interpreted as a special case where we request everything back from the borrower\n  /// @dev Only owner or manager can call this function. Borrower MUST approve this contract\n  function stopEpoch(uint256 _newApr, uint256 _interest) public {\n    _checkOnlyOwnerOrManager();\n\n    IdleCreditVault _strategy = IdleCreditVault(strategy);\n    uint256 _pendingWithdraws = _strategy.pendingWithdraws();\n    uint256 _pendingWithdrawFees = pendingWithdrawFees;\n\n    if (\n      // Check that epoch is running\n      !isEpochRunning || \n      // Check that end date is passed\n      block.timestamp < epochEndDate || \n      // Check that there are no pending instant withdraws, ie `getInstantWithdrawFunds` was called\n      // before closing the epoch\n      _strategy.pendingInstantWithdraws() > 0 ||\n      // Check that overridden interest, if passed (ie > 1), is greater than pending withdraw fees and the apr is 0 \n      // otherwise withdrawal requests may not be fullfilled as they consider also the interest gained in the next epoch \n      (_interest > 1 && (_interest < _pendingWithdrawFees || _newApr != 0))\n    ) {\n      revert NotAllowed();\n    }\n\n    uint256 _expectedInterest = _interest > 1 ? _interest : expectedEpochInterest;\n    uint256 _totBorrowed;\n    bool _isRequestingAllFunds = _interest == 1;\n    // special case where we get everything back from the borrower\n    if (_isRequestingAllFunds) {\n      // do not consider underlyings already in this contract\n      _totBorrowed = getContractValue() - _contractTokenBalance(token);\n      _expectedInterest += _totBorrowed;\n    }\n\n    // accrue interest to idleCDO, this will increase tranche prices.\n    // Send also tot withdraw requests amount to the IdleCreditVault contract\n    try this.getFundsFromBorrower(_expectedInterest, _pendingWithdraws, 0) {\n      // transfer in strategy and decrease pendingWithdraws\n      if (_pendingWithdraws > 0) {\n        _strategy.collectWithdrawFunds(_pendingWithdraws);\n      }\n\n      // Transfer pending withdraw fees to feeReceiver before update accounting\n      // NOTE: Fees are sent with 2 different transfer calls, here and after updateAccounting, to avoid complicated calculations\n      if (_pendingWithdrawFees > 0) {\n        IERC20Detailed(token).safeTransfer(feeReceiver, _pendingWithdrawFees);\n      }\n\n      if (_isRequestingAllFunds) {\n        // we already have strategyTokens equal to _totBorrowed in this contract\n        // so we simply transfer _totBorrowed to the strategy to avoid double counting\n        // for getContractValue\n        IERC20Detailed(token).safeTransfer(address(_strategy), _totBorrowed);\n      }\n\n      // update tranche prices and unclaimed fees\n      _updateAccounting();\n\n      // transfer fees\n      uint256 _fees = unclaimedFees;\n      IERC20Detailed(token).safeTransfer(feeReceiver, _fees);\n      unclaimedFees = 0;\n\n      // save net gain (this does not include interest gained for pending withdrawals)\n      uint256 netInterest = (_isRequestingAllFunds ? _expectedInterest - _totBorrowed : _expectedInterest) - _fees - _pendingWithdrawFees;\n      lastEpochInterest = netInterest;\n      // mint strategyTokens equal to interest and send underlying to strategy to avoid double counting for NAV\n      _strategy.deposit(netInterest);\n\n      // save last apr, unscaled\n      lastEpochApr = _strategy.unscaledApr();\n      // set apr for next epoch\n      _setScaledApr(_newApr);\n\n      // stop epoch\n      isEpochRunning = false;\n      expectedEpochInterest = 0;\n      pendingWithdrawFees = 0;\n\n      // allow deposits\n      _unpause();\n      // allow withdrawals requests\n      allowAAWithdrawRequest = true;\n      allowBBWithdrawRequest = true;\n      // block instant withdraws claims as these can be done only after the deadline\n      // or only if borrower is repaying all funds\n      allowInstantWithdraw = _isRequestingAllFunds;\n\n      if (_isRequestingAllFunds) {\n        // user will request only normal withdraw and can claim right after\n        disableInstantWithdraw = true;\n        epochDuration = 0;\n        epochEndDate = 0;\n      }\n\n      emit AccrueInterest(_expectedInterest - _totBorrowed, _fees + _pendingWithdrawFees);\n    } catch {\n      isEpochRunning = false;\n      // if borrower defaults, prev instant withdraw requests can still be withdrawn\n      // as were already fullfilled prior to the default (all funds already sent to the strategy)\n      allowInstantWithdraw = true;\n      _handleBorrowerDefault(_expectedInterest + _pendingWithdraws);\n    }\n  }\n\n  /// @notice Stop epoch and set new duration\n  /// @dev see stopEpoch and setEpochParams for more details, bufferPeriod is not modified\n  /// @param _newApr New apr to set for the next epoch\n  /// @param _interest Interest gained in the epoch\n  /// @param _duration New epoch duration\n  function stopEpochWithDuration(uint256 _newApr, uint256 _interest, uint256 _duration) external {\n    // stop epoch checks that msg.sender is allowed\n    stopEpoch(_newApr, _interest);\n    // buffer period is not changed\n    setEpochParams(_duration, bufferPeriod);\n\n    // scale the apr with the new durantion and buffer\n    _setScaledApr(_newApr);\n  }\n\n  /// @notice The apr should be increased by an amount proportional to the buffer period in this \n  /// way during a buffer period lenders will still get interest. Eg if epoch is 30 days and buffer \n  /// is 5 days and the apr lenders should receive is 10% then _newApr should be 10% * 35/30 = 11.67%.\n  /// @param _apr Apr to scale\n  function _scaleAprWithBuffer(uint256 _apr) internal view returns (uint256) {\n    uint256 _duration = epochDuration;\n    return _duration == 0 ? _apr : _apr * (_duration + bufferPeriod) / _duration;\n  }\n\n  /// @notice Set the scaled apr for the next epoch\n  /// @param _newApr New apr to set for the next epoch\n  function _setScaledApr(uint256 _newApr) internal {\n    IdleCreditVault(strategy).setAprs(_newApr, _scaleAprWithBuffer(_newApr));\n  }\n\n  /// @dev Get interest and funds for fullfill withdraw requests (normal and instant) from borrower,\n  /// method is external so it can be used in the try/catch blocks\n  /// @param _amount Amount of interest to transfer\n  /// @param _withdrawRequests Total withdraw requests\n  /// @param _instantWithdrawRequests Total instant withdraw requests\n  function getFundsFromBorrower(uint256 _amount, uint256 _withdrawRequests, uint256 _instantWithdrawRequests) external {\n    if (msg.sender != address(this)) {\n      revert NotAllowed();\n    }\n\n    uint256 _tot = _amount + _withdrawRequests + _instantWithdrawRequests;\n    if (_tot == 0) {\n      return;\n    }\n    IERC20Detailed(token).safeTransferFrom(IdleCreditVault(strategy).borrower(), address(this), _tot);\n  }\n\n  /// @notice Get funds from borrower to fullfill instant withdraw requests\n  /// Manager should call this method after instantWithdrawDeadline (when epoch is running)\n  function getInstantWithdrawFunds() external {\n    _checkOnlyOwnerOrManager();\n\n    // Check that epoch is running and that current time is after the deadline\n    if (!isEpochRunning || block.timestamp < instantWithdrawDeadline) {\n      revert NotAllowed();\n    }\n\n    IdleCreditVault _strategy = IdleCreditVault(strategy);\n    uint256 _instantWithdraws = _strategy.pendingInstantWithdraws();\n    // transfer funds for instant withdraw to this contract\n    try this.getFundsFromBorrower(0, 0, _instantWithdraws) {\n      // transfer funds to IdleCreditVault and decrease pendingInstantWithdraws\n      if (_instantWithdraws > 0) {\n        _strategy.collectInstantWithdrawFunds(_instantWithdraws);\n      }\n      // allow instant withdraws\n      allowInstantWithdraw = true;\n    } catch {\n      _handleBorrowerDefault(_instantWithdraws);\n    }\n  }\n\n  /// @notice Handle borrower default\n  function _handleBorrowerDefault(uint256 funds) internal {\n    defaulted = true;\n\n    // deposits should be already prevented\n    if (!paused()) {\n      _pause();\n    }\n\n    // stop the current epoch\n    isEpochRunning = false;\n\n    // prevent withdrawals requests\n    allowAAWithdrawRequest = false;\n    allowBBWithdrawRequest = false;\n\n    // allow strategyTokens transfers \n    IdleCreditVault(strategy).allowTransfers();\n\n    emit BorrowerDefault(funds);\n  }\n\n  /// @notice Prevent deposits and redeems for all classes of tranches\n  function _emergencyShutdown(bool) internal override {\n    // prevent deposits\n    if (!paused()) {\n      _pause();\n    }\n    // prevent withdraws requests\n    allowAAWithdrawRequest = false;\n    allowBBWithdrawRequest = false;\n    // Allow deposits/withdraws (once selectively re-enabled, eg for AA holders)\n    // without checking for lending protocol default\n    skipDefaultCheck = true;\n  }\n\n  /// @notice allow deposits and redeems for all classes of tranches\n  /// @dev can be called by the owner only\n  function restoreOperations() external override {\n    _checkOnlyOwner();\n    // Check if the pool was defaulted\n    if (defaulted) {\n      revert NotAllowed();\n    }\n    // restore deposits\n    if (paused()) {\n      _unpause();\n    }\n    // restore withdraws\n    allowAAWithdrawRequest = true;\n    allowBBWithdrawRequest = true;\n    // Allow deposits/withdraws but checks for lending protocol default\n    skipDefaultCheck = false;\n  }\n\n  /// \n  /// User methods\n  ///\n\n  /// @notice Deposit funds in the vault. Overrides the parent method and adds a check for wallet \n  function _deposit(uint256 _amount, address _tranche, address _referral) internal override whenNotPaused returns (uint256) {\n    if (!isWalletAllowed(msg.sender)) {\n      revert NotAllowed();\n    }\n    return super._deposit(_amount, _tranche, _referral);\n  }\n\n  /// @notice Request a withdraw from the vault\n  /// @param _amount Amount of tranche tokens \n  /// @param _tranche Tranche to withdraw from\n  /// @return Amount of underlyings requested\n  function requestWithdraw(uint256 _amount, address _tranche) external returns (uint256) {\n    address aa = AATranche;\n    address bb = BBTranche;\n    // check if _tranche is valid and if withdraws for that tranche are allowed and if user is allowed\n    if (!(_tranche == aa || _tranche == bb) || \n      (!allowAAWithdrawRequest && _tranche == aa) || \n      (!allowBBWithdrawRequest && _tranche == bb) ||\n      (!keyringAllowWithdraw && !isWalletAllowed(msg.sender))\n    ) {\n      revert NotAllowed();\n    }\n  \n    // we trigger an update accounting to check for eventual losses\n    _updateAccounting();\n\n    IdleCreditVault creditVault = IdleCreditVault(strategy);\n    uint256 _underlyings = _amount * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN;\n    uint256 _userTrancheTokens = IERC20Detailed(_tranche).balanceOf(msg.sender);\n\n    if (!disableInstantWithdraw) {\n      // If apr decresed wrt last epoch, request instant withdraw and burn tranche tokens directly\n      // we compare unscaled aprs\n      if (lastEpochApr > (creditVault.unscaledApr() + instantWithdrawAprDelta)) {\n        // Calc max withdrawable if amount passed is 0\n        _underlyings = _amount == 0 ? maxWithdrawableInstant(msg.sender, _tranche) : _underlyings;\n        // burn strategy tokens from cdo and mint an equal amount to msg.sender as receipt\n        creditVault.requestInstantWithdraw(_underlyings, msg.sender);\n\n        // burn tranche tokens and decrease NAV\n        if (_amount == 0) {\n          _amount = _userTrancheTokens;\n        }\n        _withdrawOps(_amount, _underlyings, _tranche);\n        return _underlyings;\n      }\n    }\n\n    // recalculate underlyings considering also interest accrued in the epoch as normal withdraws\n    // will still accrue interest for the next epoch\n    if (_amount == 0) {\n      _underlyings = _userTrancheTokens * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN;\n      _amount = _userTrancheTokens;\n    }\n\n    uint256 interest = _calcInterestWithdrawRequest(_underlyings) * _trancheAprRatio(_tranche) / FULL_ALLOC;\n    uint256 fees = interest * fee / FULL_ALLOC;\n    uint256 netInterest = interest - fees;\n    // user is requesting principal + interest of next epoch minus fees\n    _underlyings += netInterest;\n    // add expected fees to pending withdraw fees counter\n    pendingWithdrawFees += fees;\n    \n    // request normal withdraw, we burn strategy tokens without interest for the new epoch and mint and eq amount to msg.sender\n    creditVault.requestWithdraw(_underlyings, msg.sender, netInterest);\n    // burn tranche tokens and decrease NAV without interest for the next epoch as it was not yet counted in NAV\n    _withdrawOps(_amount, _underlyings - netInterest, _tranche);\n    return _underlyings;\n  }\n\n  /// @notice Get the tranche apr split ratio\n  /// @param _tranche address\n  /// @return _aprRatio apr split ratio for the tranche\n  function _trancheAprRatio(address _tranche) internal view returns (uint256 _aprRatio) {\n    _aprRatio = _tranche == AATranche ? trancheAPRSplitRatio : FULL_ALLOC - trancheAPRSplitRatio;\n  }\n\n  /// @notice Calculate the interest of an epoch for the given amount\n  /// @param _amount Amount of underlyings\n  function _calcInterest(uint256 _amount) internal view returns (uint256) {\n    return _amount * (IdleCreditVault(strategy).getApr() / 100) * epochDuration / (365 days * ONE_TRANCHE_TOKEN);\n  }\n\n  /// @notice Calculate the interest of an epoch for a withdraw request\n  /// @dev to avoid having funds not getting interest during buffer period, the apr \n  /// set in the stopEpoch is higher than then intended one so it will cover also the buffer period\n  /// eg epoch = 30 days, buffer = 5 days, then if we want to give 10% apr for all the 35 days then\n  /// in stop epoch we set the apr to 10% * 35/30 = 11.67%. For this reason people who instead request\n  /// a withdraw should not get the additional interest for the buffer period because they can withdraw\n  /// a block after the buffer period starts. So we calculate the interest for the 30 days only,\n  /// eg. if apr is set to 11.67% and we want to calculate the interest for 30 days at 10% we need to do the \n  /// the opposite -> 11.67% * 30/35 = 10%\n  /// @param _amount Amount of underlyings\n  function _calcInterestWithdrawRequest(uint256 _amount) internal view returns (uint256) {\n    uint256 _duration = epochDuration;\n    return _duration == 0 ? 0 : _calcInterest(_amount) * _duration / (_duration + bufferPeriod);\n  }\n\n  /// @notice Get the max amount of underlyings that can be withdrawn by user\n  /// @param _user User address\n  /// @param _tranche Tranche to withdraw from\n  function maxWithdrawable(address _user, address _tranche) external view returns (uint256) {\n    uint256 currentUnderlyings = IERC20Detailed(_tranche).balanceOf(_user) * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN;\n    // add interest for one epoch\n    uint256 interest = _calcInterestWithdrawRequest(currentUnderlyings) * _trancheAprRatio(_tranche) / FULL_ALLOC;\n    // sum and remove fees\n    return currentUnderlyings + interest - (interest * fee / FULL_ALLOC);\n  }\n\n  /// @notice Get the max amount of underlyings that can be withdrawn instantly by user\n  /// @param _user User address\n  /// @param _tranche Tranche to withdraw from\n  function maxWithdrawableInstant(address _user, address _tranche) public view returns (uint256) {\n    return IERC20Detailed(_tranche).balanceOf(_user) * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN;\n  }\n\n  /// @notice Burn tranche tokens and update NAV and trancheAPRSplitRatio\n  /// @param _amount Amount of tranche tokens\n  /// @param _underlyings Amount of underlyings\n  /// @param _tranche Tranche to withdraw from\n  function _withdrawOps(uint256 _amount, uint256 _underlyings, address _tranche) internal {\n    // burn tranche token\n    IdleCDOTranche(_tranche).burn(msg.sender, _amount);\n\n    // update NAV with the _amount of underlyings removed\n    if (_tranche == AATranche) {\n      lastNAVAA -= _underlyings;\n    } else {\n      lastNAVBB -= _underlyings;\n    }\n\n    // update trancheAPRSplitRatio\n    _updateSplitRatio(_getAARatio(true));\n  }\n\n  /// @notice Claim a withdraw request from the vault. Can be done when at least 1 epoch passed\n  /// since last withdraw request\n  function claimWithdrawRequest() external {\n    // underlyings requested, here we check that user waited at least one epoch and that borrower\n    // did not default upon repayment (old requests can still be claimed)\n    IdleCreditVault(strategy).claimWithdrawRequest(msg.sender);\n  }\n\n  /// @notice Claim an instant withdraw request from the vault. Can be done when epoch is running\n  /// as funds will get transferred from borrower when epoch starts\n  function claimInstantWithdrawRequest() external {\n    // Check that instant withdraws are available\n    if (!allowInstantWithdraw) {\n      revert NotAllowed();\n    }\n    IdleCreditVault(strategy).claimInstantWithdrawRequest(msg.sender);\n  }\n\n  /// @notice Check if wallet is allowed to interact with the contract\n  /// @param _user User address\n  /// @return true if wallet is allowed or keyring address is not set\n  function isWalletAllowed(address _user) public view returns (bool) {\n    address _keyring = keyring;\n    return _keyring == address(0) || IKeyring(_keyring).checkCredential(keyringPolicyId, _user);\n  }\n\n  /// \n  /// Overridden method not used in this contract (to reduce bytcode size)\n  ///\n\n  /// NOTE: normal withdraw are not allowed\n  function withdrawAA(uint256) external override returns (uint256) {}\n  function withdrawBB(uint256) external override returns (uint256) {}\n  function _withdraw(uint256, address) override pure internal returns (uint256) {}\n  function setAllowAAWithdraw(bool) external override {}\n  function setAllowBBWithdraw(bool) external override {}\n  function liquidate(uint256, bool) external override returns (uint256) {}\n  function _liquidate(uint256, bool) internal override returns (uint256) {}\n  function setRevertIfTooLow(bool) external override {}\n  function setLiquidationTolerance(uint256) external override {}\n\n  /// NOTE: strategy price is alway equal to 1 underlying\n  function _checkDefault() override internal {}\n  function setSkipDefaultCheck(bool) external override {}\n  function setMaxDecreaseDefault(uint256) external override {}\n\n  /// NOTE: harvest is not performed to transfer funds to the strategy (startEpoch is used)\n  function harvest(\n    bool[] calldata,\n    bool[] calldata,\n    uint256[] calldata,\n    uint256[] calldata,\n    bytes[] calldata\n  ) public override returns (uint256[][] memory) {}\n\n  /// NOTE: there are no rewards to sell nor incentives\n  function _sellAllRewards(IIdleCDOStrategy, uint256[] memory, uint256[] memory, bool[] memory, bytes memory)\n    internal override returns (uint256[] memory, uint256[] memory, uint256) {}\n  function _sellReward(address, bytes memory, uint256, uint256)\n    internal override returns (uint256, uint256) {}\n  function setReleaseBlocksPeriod(uint256) external override {}\n  function _lockedRewards() internal view override returns (uint256) {}\n\n  /// NOTE: stkIDLE gating is not used\n  function toggleStkIDLEForTranche(address) external override {}\n  function _checkStkIDLEBal(address, uint256) internal view override {}\n  function setStkIDLEPerUnderlying(uint256) external override {}\n\n  /// NOTE: fees are not deposited in this contract\n  function _depositFees() internal override {}\n  function depositBBRef(uint256, address) external override returns (uint256) {}\n\n  /// NOTE: unlent perc should always be 0 and set in additionalInit\n  function setUnlentPerc(uint256) external override {}\n\n  /// NOTE: the vault is either a single tranche (ie all interest to senior and set in additionalInit) or AYS is active\n  function setTrancheAPRSplitRatio(uint256) external override {}\n}",
        "IdleCreditVault.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IIdleCDOStrategy.sol\";\nimport \"../../interfaces/IERC20Detailed.sol\";\n\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IIdleCDOEpochVariant {\n  function isEpochRunning() external view returns (bool);\n  function epochEndDate() external view returns (uint256);\n}\n\nerror NotAllowed();\n\ncontract IdleCreditVault is\n  Initializable,\n  OwnableUpgradeable,\n  ERC20Upgradeable,\n  ReentrancyGuardUpgradeable,\n  IIdleCDOStrategy\n{\n  using SafeERC20Upgradeable for IERC20Detailed;\n\n  /// @notice underlying token address (pool currency for Clearpool)\n  address public override token;\n  /// @notice decimals of the underlying asset\n  uint256 public override tokenDecimals;\n  /// @notice one underlying token\n  uint256 public override oneToken;\n  /// @notice underlying ERC20 token contract (pool currency for Clearpool)\n  IERC20Detailed public underlyingToken;\n  /// @notice address of the IdleCDO\n  address public idleCDO;\n  /// @notice one year, used to calculate the APR\n  uint256 public constant YEAR = 365 days;\n  /// @notice latest saved apr, already scaled to include the buffer period\n  uint256 public lastApr;\n  /// @notice address of the borrower\n  address public borrower;\n  /// @notice address of the manager\n  address public manager;\n  /// @notice user withdraw requests\n  mapping (address => uint256) public withdrawsRequests;\n  /// @notice user instant withdraw requests\n  mapping (address => uint256) public instantWithdrawsRequests;\n  /// @notice total withdraw requests\n  uint256 public pendingWithdraws;\n  /// @notice pending instant withdraw requests\n  uint256 public pendingInstantWithdraws;\n  /// @notice counter for epoch deposits\n  uint256 public totEpochDeposits;\n  /// @notice flag to allow transfers\n  bool public canTransfer;\n  /// @notice last withdraw request epoch for a user\n  mapping (address => uint256) public lastWithdrawRequest;\n  /// @notice current epoch number\n  uint256 public epochNumber;\n  /// @notice unscaled apr\n  uint256 public unscaledApr;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    token = address(1);\n  }\n\n  /// @notice can be only called once\n  /// @param _underlyingToken address of the underlying token (pool currency)\n  function initialize(\n    address _underlyingToken,\n    address _owner,\n    address _manager,\n    address _borrower,\n    string memory borrowerName,\n    uint256 _apr\n  ) public virtual initializer {\n    OwnableUpgradeable.__Ownable_init();\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n    require(token == address(0), \"Token is already initialized\");\n\n    //----- // -------//\n    token = _underlyingToken;\n    underlyingToken = IERC20Detailed(token);\n    tokenDecimals = underlyingToken.decimals();\n    oneToken = 10**(tokenDecimals);\n    borrower = _borrower;\n    manager = _manager;\n    // on the first setup we set the lastApr equal to the unscaledApr\n    lastApr = _apr;\n    unscaledApr = _apr;\n\n    // name will be like: Idle Credit Vault Borrower USDC\n    // symbol will be like: BorrowerUSDC\n    string memory _symbol = IERC20Detailed(token).symbol();\n    ERC20Upgradeable.__ERC20_init(\n      _concat(_concat(_concat(string(\"Idle Credit Vault \"), borrowerName), \" \"), _symbol),\n      _concat(borrowerName, _symbol)\n    );\n    //------//-------//\n\n    transferOwnership(_owner);\n  }\n\n  /// @notice strategy token decimals\n  /// @dev equal to underlying token decimals\n  /// @return number of decimals\n  function decimals() public view override returns (uint8) {\n    return uint8(tokenDecimals);\n  }\n\n  /// @notice strategy token address\n  function strategyToken() external view override returns (address) {\n    return address(this);\n  }\n\n  /// @notice return strategy token price which is always 1\n  /// @return price in underlyings\n  function price() public view virtual override returns (uint256) {\n    return oneToken;\n  }\n\n  /// @notice current fixed apr for the epoch\n  function getApr() external view returns (uint256) {\n    return lastApr;\n  }\n\n  /// @notice set manager address\n  /// @param _manager address of the new manager\n  function setManager(address _manager) external onlyOwner {\n    manager = _manager;\n  }\n\n  /// @notice set both the scaled and unscaled apr\n  /// @dev only cdo and manager can set the apr.\n  /// @param _unscaledApr unscaled apr\n  /// @param _apr scaled apr\n  function setAprs(uint256 _unscaledApr, uint256 _apr) external {\n    unscaledApr = _unscaledApr;\n    // here we also check that msg.sender is allowed\n    setApr(_apr);\n  }\n\n  /// @notice set the fixed apr\n  /// @dev only cdo and manager can set the apr. If manager manually set apr from \n  /// here it will not be scaled to include the buffer period\n  function setApr(uint256 _apr) public {\n    address _cdo = idleCDO;\n\n    // if cdo is not yet set we skip the check (this can happen only during the setup)\n    if (_cdo != address(0)) {\n      if (msg.sender != _cdo && msg.sender != manager) {\n        revert NotAllowed();\n      }\n    }\n    lastApr = _apr;\n  }\n\n  /// @notice request withdraw of underlying token from the vault\n  /// @dev we don't burn strategy tokens here, but we increase the withdraw requests\n  /// @param _amount number of tokens to withdraw\n  /// @param _user address of the user\n  /// @param _netInterest net interest gained in the next epoch\n  function requestWithdraw(uint256 _amount, address _user, uint256 _netInterest) external {\n    _onlyIdleCDO();\n    // burn strategy tokens from cdo (we don't burn interest here, only the principal)\n    _burn(msg.sender, _amount - _netInterest);\n    // mint equal amount of strategy tokens to the user as receipt (interest included), useful in case of default\n    _mint(_user, _amount);\n\n    // increase the withdraw requests for the user\n    withdrawsRequests[_user] += _amount;\n    // increase the total withdraw requests\n    pendingWithdraws += _amount;\n    // save the epoch of the last withdraw request (buffer + epochDuration is 1 epoch)\n    lastWithdrawRequest[_user] = epochNumber;\n  }\n\n  /// @notice claim the withdraw request\n  /// @dev we burn the strategy tokens and transfer the underlying tokens\n  /// @param _user address of the user\n  /// @return amount number of tokens claimed\n  function claimWithdrawRequest(address _user) external returns (uint256 amount) {\n    _onlyIdleCDO();\n    // User should wait at least an epoch before claiming the withdraw. Once the epoch is over user can withdraw \n    // at any time even if a new epoch started. \n    // So if epochNumber is the same as the last withdraw request then we revert. Epoch number is increased at stopEpoch\n    // NOTE: If a user does not claim a withdraw request and instead requests another withdraw, he will have to wait\n    // for another epoch to claim both requests.\n    // NOTE 2: if borrower defaults, old withdraw requests can still be claimed\n    if (IIdleCDOEpochVariant(idleCDO).epochEndDate() != 0 && (epochNumber <= lastWithdrawRequest[_user])) {\n      revert NotAllowed();\n    }\n    // get amount of underlyings\n    amount = withdrawsRequests[_user];\n    // burn strategy tokens 1:1 with the amount of underlyings\n    _burn(_user, amount);\n    withdrawsRequests[_user] = 0;\n    lastWithdrawRequest[_user] = 0;\n    underlyingToken.safeTransfer(_user, amount);\n  }\n\n  /// @notice request instant withdraw of underlying token from the vault\n  /// @dev we burn strategy tokens here, and we increase the instant withdraw requests\n  /// @param _amount number of tokens to withdraw\n  /// @param _user address of the user\n  function requestInstantWithdraw(uint256 _amount, address _user) external {\n    _onlyIdleCDO();\n    // burn strategy tokens from cdo\n    _burn(msg.sender, _amount);\n  \n    // mint equal amount of strategy tokens to the user as receipt, useful in case of default\n    _mint(_user, _amount);\n\n    // increase the instant withdraw requests for the user\n    instantWithdrawsRequests[_user] += _amount;\n    // increase the total instant withdraw requests\n    pendingInstantWithdraws += _amount;\n  }\n\n  /// @notice claim the instant withdraw request\n  /// @dev we transfer the underlying tokens\n  /// @param _user address of the user\n  function claimInstantWithdrawRequest(address _user) external {\n    _onlyIdleCDO();\n    uint256 amount = instantWithdrawsRequests[_user];\n    // burn strategy tokens from user\n    _burn(_user, amount);\n\n    instantWithdrawsRequests[_user] = 0;\n    underlyingToken.safeTransfer(_user, amount);\n  }\n\n  /// @notice collect the instant withdraw funds\n  /// @dev only IdleCDO can call this function\n  /// @param _amount number of tokens to collect\n  function collectInstantWithdrawFunds(uint256 _amount) external {\n    _onlyIdleCDO();\n    pendingInstantWithdraws -= _amount;\n    underlyingToken.safeTransferFrom(idleCDO, address(this), _amount);\n  }\n\n  /// @notice collect the withdraw funds\n  /// @dev only IdleCDO can call this function\n  /// @param _amount number of tokens to collect\n  function collectWithdrawFunds(uint256 _amount) external {\n    _onlyIdleCDO();\n    pendingWithdraws -= _amount;\n    underlyingToken.safeTransferFrom(idleCDO, address(this), _amount);\n  }\n\n  /// @notice Send funds to the IdleCDO\n  /// @param _amount number of underlyings to transfer\n  function sendInterestAndDeposits(uint256 _amount) external {\n    _onlyIdleCDO();\n    IERC20Detailed(token).safeTransfer(idleCDO, _amount);\n  }\n\n  /// @notice Get funds from IdleCDO and mint strategy tokens. Funds are not sent to the borrower here\n  /// @param _amount number of underlyings to transfer\n  function deposit(uint256 _amount)\n    external\n    virtual\n    override\n    returns (uint256) {\n    _onlyIdleCDO();\n    underlyingToken.safeTransferFrom(msg.sender, address(this), _amount);\n    _mint(msg.sender, _amount);\n\n    if (IIdleCDOEpochVariant(idleCDO).isEpochRunning()) {\n      // deposit done on stopEpoch (before setting the var to false) so we reset the counter\n      totEpochDeposits = 0;\n      epochNumber += 1;\n    } else {\n      // deposit done between epochs so we increase the counter\n      totEpochDeposits += _amount;\n    }\n\n    return _amount;\n  }\n  \n  /// @inheritdoc ERC20Upgradeable\n  /// @dev we don't allow transfers of strategy tokens normally, transfers are allowed only after a default\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\n    if (msg.sender != idleCDO && !canTransfer) {\n      revert NotAllowed();\n    }\n    super._transfer(sender, recipient, amount);\n  }\n\n  /// @notice allow transfers of strategy tokens\n  function allowTransfers() external {\n    _onlyIdleCDO();\n    canTransfer = true;\n  }\n\n  /// @notice allow to update whitelisted address\n  function setWhitelistedCDO(address _cdo) external onlyOwner {\n    require(_cdo != address(0), \"IS_0\");\n    idleCDO = _cdo;\n  }\n\n  /// @notice Emergency method to rescue funds\n  /// @param _token address of the token to transfer\n  /// @param value amount of `_token` to transfer\n  /// @param _to receiver address\n  function transferToken(address _token, uint256 value, address _to) external onlyOwner {\n    IERC20Detailed(_token).safeTransfer(_to, value);\n  }\n\n  /// @notice Modifier to make sure that caller os only the idleCDO contract\n  function _onlyIdleCDO() internal view {\n    if (msg.sender != idleCDO) {\n      revert NotAllowed();\n    }\n  }\n\n  /// @notice concat 2 strings in a single one\n  /// @param a first string\n  /// @param b second string\n  /// @return new string with a and b concatenated\n  function _concat(string memory a, string memory b) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b));\n  }\n\n  /// @notice Not used as redeems happens only via requestWithdraw and requestInstantWithdraw\n  function redeem(uint256 _amount)\n    external\n    override\n    returns (uint256) {}\n\n  /// @notice Not used as redeems happens only via requestWithdraw and requestInstantWithdraw\n  function redeemUnderlying(uint256)\n    external\n    returns (uint256) {}\n\n  /// @notice not used in this strategy\n  function pullStkAAVE() \n    external \n    pure \n    override \n    returns (uint256) {}\n\n  /// @notice not used for this strategy\n  function getRewardTokens()\n    external\n    view\n    override\n    returns (address[] memory) {}\n\n  /// @notice not used for this strategy\n  function redeemRewards(bytes calldata)\n    external\n    override\n    returns (uint256[] memory rewards) {}\n}\n"
    }
}