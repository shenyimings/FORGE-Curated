{
    "vfp_id": "vfp_00130",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Lack of Cryptographic Binding Between Proof and Guest Program ID",
            "description": "The Risc0Verifier and SP1Verifier contracts verify proofs using external verifiers but fail to cryptographically bind the verified proof to the claimed guest program ID (blockImageId or blockProvingProgram). While the contracts check that the ID is in a trusted list, the external verification does not confirm that the aggregation proof actually executed the specified guest program. An attacker can generate a proof from a malicious guest program, aggregate it using the legitimate aggregation program, and submit it with a trusted ID. The contract accepts it because the aggregation proof is valid, even though it attests to an unauthorized program. This allows bypassing protocol validity rules and finalizing arbitrary, potentially malicious state transitions.\n",
            "severity": "Critical",
            "location": [
                "Risc0Verifier.sol::verifyProof",
                "SP1Verifier.sol::verifyProof"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/verifiers/Risc0Verifier.sol",
                "taiko-mono/packages/protocol/contracts/layer1/verifiers/SP1Verifier.sol"
            ]
        }
    ],
    "affected_files": {
        "Risc0Verifier.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IProofVerifier } from \"./IProofVerifier.sol\";\nimport { LibPublicInput } from \"./LibPublicInput.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { IRiscZeroVerifier } from \"@risc0/contracts/IRiscZeroVerifier.sol\";\n\n/// @title Risc0Verifier\n/// @custom:security-contact security@taiko.xyz\ncontract Risc0Verifier is IProofVerifier, Ownable2Step {\n    bytes32 internal constant RISCZERO_GROTH16_VERIFIER = bytes32(\"risc0_groth16_verifier\");\n\n    // [32, 0, 0, 0] -- big-endian uint32(32) for hash bytes len\n    bytes private constant FIXED_JOURNAL_HEADER = hex\"20000000\";\n    uint64 public immutable taikoChainId;\n    address public immutable riscoGroth16Verifier;\n\n    /// @notice Trusted imageId mapping\n    mapping(bytes32 imageId => bool trusted) public isImageTrusted;\n\n    uint256[49] private __gap;\n\n    /// @dev Emitted when a trusted image is set / unset.\n    /// @param imageId The id of the image\n    /// @param trusted True if trusted, false otherwise\n    event ImageTrusted(bytes32 imageId, bool trusted);\n\n    error RISC_ZERO_INVALID_BLOCK_PROOF_IMAGE_ID();\n    error RISC_ZERO_INVALID_AGGREGATION_IMAGE_ID();\n    error RISC_ZERO_INVALID_PROOF();\n\n    constructor(uint64 _taikoChainId, address _riscoGroth16Verifier, address _owner) {\n        require(_taikoChainId != 0, \"Invalid chain id\");\n        require(_riscoGroth16Verifier != address(0), \"Invalid risc0 groth16 verifier\");\n        taikoChainId = _taikoChainId;\n        riscoGroth16Verifier = _riscoGroth16Verifier;\n\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Sets/unsets an the imageId as trusted entity\n    /// @param _imageId The id of the image.\n    /// @param _trusted True if trusted, false otherwise.\n    function setImageIdTrusted(bytes32 _imageId, bool _trusted) external onlyOwner {\n        isImageTrusted[_imageId] = _trusted;\n        emit ImageTrusted(_imageId, _trusted);\n    }\n\n    /// @inheritdoc IProofVerifier\n    function verifyProof(\n        uint256, /* _proposalAge */\n        bytes32 _aggregatedProvingHash,\n        bytes calldata _proof\n    )\n        external\n        view\n    {\n        // Decode will throw if not proper length/encoding\n        (bytes memory seal, bytes32 blockImageId, bytes32 aggregationImageId) =\n            abi.decode(_proof, (bytes, bytes32, bytes32));\n\n        // Check if the aggregation program is trusted\n        require(isImageTrusted[aggregationImageId], RISC_ZERO_INVALID_AGGREGATION_IMAGE_ID());\n        // Check if the block proving program is trusted\n        require(isImageTrusted[blockImageId], RISC_ZERO_INVALID_BLOCK_PROOF_IMAGE_ID());\n\n        bytes32 publicInput = LibPublicInput.hashPublicInputs(\n            _aggregatedProvingHash, address(this), address(0), taikoChainId\n        );\n\n        // journalDigest is the sha256 hash of the hashed public input\n        bytes32 journalDigest = sha256(abi.encodePacked(publicInput));\n\n        // call risc0 verifier contract\n        (bool success,) = riscoGroth16Verifier.staticcall(\n            abi.encodeCall(IRiscZeroVerifier.verify, (seal, aggregationImageId, journalDigest))\n        );\n        require(success, RISC_ZERO_INVALID_PROOF());\n    }\n}\n",
        "SP1Verifier.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IProofVerifier } from \"./IProofVerifier.sol\";\nimport { LibPublicInput } from \"./LibPublicInput.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ISP1Verifier } from \"@sp1-contracts/src/ISP1Verifier.sol\";\n\n/// @title SP1Verifier\n/// @custom:security-contact security@taiko.xyz\ncontract SP1Verifier is IProofVerifier, Ownable2Step {\n    bytes32 internal constant SP1_REMOTE_VERIFIER = bytes32(\"sp1_remote_verifier\");\n\n    uint64 public immutable taikoChainId;\n    address public immutable sp1RemoteVerifier;\n\n    /// @notice The verification keys mappings for the proving programs.\n    mapping(bytes32 provingProgramVKey => bool trusted) public isProgramTrusted;\n\n    uint256[49] private __gap;\n\n    /// @dev Emitted when a trusted image is set / unset.\n    /// @param programVKey The id of the image\n    /// @param trusted The block's assigned prover.\n    event ProgramTrusted(bytes32 programVKey, bool trusted);\n\n    error SP1_INVALID_PROGRAM_VKEY();\n    error SP1_INVALID_AGGREGATION_VKEY();\n    error SP1_INVALID_PARAMS();\n    error SP1_INVALID_PROOF();\n\n    constructor(uint64 _taikoChainId, address _sp1RemoteVerifier, address _owner) {\n        taikoChainId = _taikoChainId;\n        sp1RemoteVerifier = _sp1RemoteVerifier;\n\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Sets/unsets an the program's verification key as trusted entity\n    /// @param _programVKey The verification key of the program.\n    /// @param _trusted True if trusted, false otherwise.\n    function setProgramTrusted(bytes32 _programVKey, bool _trusted) external onlyOwner {\n        isProgramTrusted[_programVKey] = _trusted;\n        emit ProgramTrusted(_programVKey, _trusted);\n    }\n\n    /// @inheritdoc IProofVerifier\n    function verifyProof(\n        uint256, /* _proposalAge */\n        bytes32 _aggregatedProvingHash,\n        bytes calldata _proof\n    )\n        external\n        view\n    {\n        require(_proof.length > 64, SP1_INVALID_PARAMS());\n        // Extract the necessary data\n        bytes32 aggregationProgram = bytes32(_proof[0:32]);\n        bytes32 blockProvingProgram = bytes32(_proof[32:64]);\n\n        // Check if the aggregation program is trusted\n        require(isProgramTrusted[aggregationProgram], SP1_INVALID_AGGREGATION_VKEY());\n        // Check if the block proving program is trusted\n        require(isProgramTrusted[blockProvingProgram], SP1_INVALID_PROGRAM_VKEY());\n\n        bytes32 publicInput = LibPublicInput.hashPublicInputs(\n            _aggregatedProvingHash, address(this), address(0), taikoChainId\n        );\n\n        // _proof[64:] is the succinct's proof position\n        (bool success,) = sp1RemoteVerifier.staticcall(\n            abi.encodeCall(\n                ISP1Verifier.verifyProof,\n                (aggregationProgram, abi.encodePacked(publicInput), _proof[64:])\n            )\n        );\n\n        require(success, SP1_INVALID_PROOF());\n    }\n}\n"
    }
}