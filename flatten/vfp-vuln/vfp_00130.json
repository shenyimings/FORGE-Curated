{
    "vfp_id": "vfp_00130",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding in Debt Shares Calculation Can Mint Unbacked Tokens",
            "description": "This vulnerability arises from the rounding down of debt shares in the TroveManager._updateBatchShares() function, which allows an attacker to manipulate the debt-to-shares ratio in a batch. By repeatedly donating small amounts of debt and opening/closing troves, an attacker can inflate the ratio to a point where new troves receive zero debt shares for non-zero debt, enabling them to mint unbacked BOLD tokens. The root cause is improper handling of integer division and lack of safeguards against ratio manipulation. An attacker could exploit this by looping through donation and trove operations to inflate the ratio, then mint large amounts of unbacked tokens, leading to protocol insolvency. The impact includes loss of trust, financial loss, and potential collapse of the system's monetary model.\n",
            "severity": "Critical",
            "location": [
                "TroveManager.sol::_updateBatchShares",
                "TroveManager.sol::_requireBelowMaxSharesRatio"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unredeemable Troves Can Pay Minimum Interest Rate",
            "description": "Troves with debt below MIN_DEBT are marked as unredeemable (zombie troves) and excluded from redemption lists, removing the risk of redemption and thus the incentive to pay higher interest rates. An attacker can create many such troves to pay only the minimum interest, gaining an unfair economic advantage. The cause is the design decision to exclude small troves from redemption lists. While mitigated by gas and capital costs, the strategy could still be profitable under certain conditions. The partial fix ensures zombie troves are redeemed first during redemptions, but an edge case remains where liquidated troves with zero debt can still become unredeemable and pay minimal interest. The impact is economic inefficiency and potential abuse of the interest model.\n",
            "severity": "Medium",
            "location": [
                "TroveManager.sol",
                "RedemptionLogic.sol"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        }
    ],
    "affected_files": {
        "TroveManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveEvents.sol\";\nimport \"./Interfaces/ITroveNFT.sol\";\nimport \"./Interfaces/ICollateralRegistry.sol\";\nimport \"./Interfaces/IWETH.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\ncontract TroveManager is LiquityBase, ITroveManager, ITroveEvents {\n    // --- Connected contract declarations ---\n\n    ITroveNFT public troveNFT;\n    IBorrowerOperations public borrowerOperations;\n    IStabilityPool public stabilityPool;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their interest rate\n    ISortedTroves public sortedTroves;\n    ICollateralRegistry internal collateralRegistry;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 internal immutable MCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 internal immutable SCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 internal immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 internal immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    // --- Data structures ---\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n    }\n\n    mapping(uint256 => Trove) public Troves;\n\n    // Store the necessary data for an interest batch manager. We treat each batch as a “big trove”.\n    // Each trove has a share of the debt of the global batch. Collateral is stored per trove (as CRs are different)\n    // Still the total amount of batch collateral is stored for informational purposes\n    struct Batch {\n        uint256 debt;\n        uint256 coll;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        uint256 annualManagementFee;\n        uint256 totalDebtShares;\n    }\n\n    mapping(address => Batch) internal batches;\n\n    uint256 internal totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 internal totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 internal totalCollateralSnapshot;\n\n    /*\n    * L_coll and L_boldDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An Coll gain of ( stake * [L_coll - L_coll(0)] )\n    * A boldDebt increase  of ( stake * [L_boldDebt - L_boldDebt(0)] )\n    *\n    * Where L_coll(0) and L_boldDebt(0) are snapshots of L_coll and L_boldDebt for the active Trove taken at the instant the stake was made\n    */\n    uint256 internal L_coll;\n    uint256 internal L_boldDebt;\n\n    // Map active troves to their RewardSnapshot\n    mapping(uint256 => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the Coll and Bold snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 coll;\n        uint256 boldDebt;\n    }\n\n    // Array of all active trove addresses - used to compute an approximate hint off-chain, for the sorted list insertion\n    uint256[] internal TroveIds;\n    // Array of all batch managers - used to fetch them off-chain\n    address[] public batchIds;\n\n    uint256 public lastZombieTroveId;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 internal lastCollError_Redistribution;\n    uint256 internal lastBoldDebtError_Redistribution;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LiquidationValues {\n        uint256 collGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n        uint256 ETHGasCompensation;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedeemCollateralValues {\n        uint256 totalCollFee;\n        uint256 remainingBold;\n        address lastBatchUpdatedInterest;\n        uint256 nextUserToCheck;\n    }\n\n    struct SingleRedemptionValues {\n        uint256 troveId;\n        address batchAddress;\n        uint256 boldLot;\n        uint256 collLot;\n        uint256 collFee;\n        uint256 appliedRedistBoldDebtGain;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n        uint256 newStake;\n        bool isZombieTrove;\n        LatestTroveData trove;\n        LatestBatchData batch;\n    }\n\n    // --- Errors ---\n\n    error EmptyData();\n    error NothingToLiquidate();\n    error CallerNotBorrowerOperations();\n    error CallerNotCollateralRegistry();\n    error OnlyOneTroveLeft();\n    error NotShutDown();\n    error ZeroAmount();\n    error NotEnoughBoldBalance();\n    error MinCollNotReached(uint256 _coll);\n    error BatchSharesRatioTooHigh();\n\n    // --- Events ---\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        CCR = _addressesRegistry.CCR();\n        MCR = _addressesRegistry.MCR();\n        SCR = _addressesRegistry.SCR();\n        LIQUIDATION_PENALTY_SP = _addressesRegistry.LIQUIDATION_PENALTY_SP();\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _addressesRegistry.LIQUIDATION_PENALTY_REDISTRIBUTION();\n\n        troveNFT = _addressesRegistry.troveNFT();\n        borrowerOperations = _addressesRegistry.borrowerOperations();\n        stabilityPool = _addressesRegistry.stabilityPool();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        boldToken = _addressesRegistry.boldToken();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        WETH = _addressesRegistry.WETH();\n        collateralRegistry = _addressesRegistry.collateralRegistry();\n\n        emit TroveNFTAddressChanged(address(troveNFT));\n        emit BorrowerOperationsAddressChanged(address(borrowerOperations));\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit BoldTokenAddressChanged(address(boldToken));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit CollateralRegistryAddressChanged(address(collateralRegistry));\n    }\n\n    // --- Getters ---\n\n    function getTroveIdsCount() external view override returns (uint256) {\n        return TroveIds.length;\n    }\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view override returns (uint256) {\n        return TroveIds[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove\n    function _liquidate(\n        IDefaultPool _defaultPool,\n        uint256 _troveId,\n        uint256 _boldInSPForOffsets,\n        uint256 _price,\n        LatestTroveData memory trove,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        address owner = troveNFT.ownerOf(_troveId);\n\n        _getLatestTroveData(_troveId, trove);\n        address batchAddress = _getBatchManager(_troveId);\n        bool isTroveInBatch = batchAddress != address(0);\n        LatestBatchData memory batch;\n        if (isTroveInBatch) _getLatestBatchData(batchAddress, batch);\n\n        _movePendingTroveRewardsToActivePool(_defaultPool, trove.redistBoldDebtGain, trove.redistCollGain);\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.collGasCompensation,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute,\n            singleLiquidation.collSurplus\n        ) = _getOffsetAndRedistributionVals(trove.entireDebt, trove.entireColl, _boldInSPForOffsets, _price);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        _closeTrove(\n            _troveId,\n            troveChange,\n            batchAddress,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            Status.closedByLiquidation\n        );\n\n        if (isTroveInBatch) {\n            // the parenthesis in the old weighted term equals `recordedDebt + accruedInterest + accruedBatchManagementFee`\n            // We want to capture last 2 ones, as the batch part only has recorded debt. The recorded debt of the trove is duplicated there,\n            // but it needs to be, because it’s also included in `entireDebtWithoutRedistribution` in the next line.\n            // So in the end we add it once and subtract it twice, which is the same as subtracting it once.\n            singleLiquidation.oldWeightedRecordedDebt =\n                batch.weightedRecordedDebt + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualInterestRate;\n            singleLiquidation.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n            // Mint batch management fee\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee\n                + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, batchAddress);\n        } else {\n            singleLiquidation.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n        }\n\n        // Difference between liquidation penalty and liquidation threshold\n        if (singleLiquidation.collSurplus > 0) {\n            collSurplusPool.accountSurplus(owner, singleLiquidation.collSurplus);\n        }\n\n        // Wipe out state in BO\n        borrowerOperations.onLiquidateTrove(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.liquidate,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(trove.entireDebt),\n            _collIncreaseFromRedist: trove.redistCollGain,\n            _collChangeFromOperation: -int256(trove.entireColl)\n        });\n\n        if (isTroveInBatch) {\n            emit BatchUpdated({\n                _interestBatchManager: batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[batchAddress].debt,\n                _coll: batches[batchAddress].coll,\n                _annualInterestRate: batch.annualInterestRate,\n                _annualManagementFee: batch.annualManagementFee,\n                _totalDebtShares: batches[batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n    }\n\n    // Return the amount of Coll to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint256 _coll) internal pure returns (uint256) {\n        // _entireDebt should never be zero, but we add the condition defensively to avoid an unexpected revert\n        return LiquityMath._min(_coll / COLL_GAS_COMPENSATION_DIVISOR, COLL_GAS_COMPENSATION_CAP);\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        uint256 _entireTroveColl,\n        uint256 _boldInSPForOffsets,\n        uint256 _price\n    )\n        internal\n        view\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 collGasCompensation,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute,\n            uint256 collSurplus\n        )\n    {\n        uint256 collSPPortion;\n        /*\n         * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n         * between all active troves.\n         *\n         *  If the trove's debt is larger than the deposited Bold in the Stability Pool:\n         *\n         *  - Offset an amount of the trove's debt equal to the Bold in the Stability Pool\n         *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n         *\n         */\n        if (_boldInSPForOffsets > 0) {\n            debtToOffset = LiquityMath._min(_entireTroveDebt, _boldInSPForOffsets);\n            collSPPortion = _entireTroveColl * debtToOffset / _entireTroveDebt;\n\n            collGasCompensation = _getCollGasCompensation(collSPPortion);\n            uint256 collToOffset = collSPPortion - collGasCompensation;\n\n            (collToSendToSP, collSurplus) =\n                _getCollPenaltyAndSurplus(collToOffset, debtToOffset, LIQUIDATION_PENALTY_SP, _price);\n        }\n\n        // Redistribution\n        debtToRedistribute = _entireTroveDebt - debtToOffset;\n        if (debtToRedistribute > 0) {\n            uint256 collRedistributionPortion = _entireTroveColl - collSPPortion;\n            if (collRedistributionPortion > 0) {\n                (collToRedistribute, collSurplus) = _getCollPenaltyAndSurplus(\n                    collRedistributionPortion + collSurplus, // Coll surplus from offset can be eaten up by red. penalty\n                    debtToRedistribute,\n                    LIQUIDATION_PENALTY_REDISTRIBUTION, // _penaltyRatio\n                    _price\n                );\n            }\n        }\n        // assert(_collToLiquidate == collToSendToSP + collToRedistribute + collSurplus);\n    }\n\n    function _getCollPenaltyAndSurplus(\n        uint256 _collToLiquidate,\n        uint256 _debtToLiquidate,\n        uint256 _penaltyRatio,\n        uint256 _price\n    ) internal pure returns (uint256 seizedColl, uint256 collSurplus) {\n        uint256 maxSeizedColl = _debtToLiquidate * (DECIMAL_PRECISION + _penaltyRatio) / _price;\n        if (_collToLiquidate > maxSeizedColl) {\n            seizedColl = maxSeizedColl;\n            collSurplus = _collToLiquidate - maxSeizedColl;\n        } else {\n            seizedColl = _collToLiquidate;\n            collSurplus = 0;\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(uint256[] memory _troveArray) public override {\n        if (_troveArray.length == 0) {\n            revert EmptyData();\n        }\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        TroveChange memory troveChange;\n        LiquidationValues memory totals;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n\n        // - If the SP has total deposits >= 1e18, we leave 1e18 in it untouched.\n        // - If it has 0 < x < 1e18 total deposits, we leave x in it.\n        uint256 totalBoldDeposits = stabilityPoolCached.getTotalBoldDeposits();\n        uint256 boldToLeaveInSP = LiquityMath._min(MIN_BOLD_IN_SP, totalBoldDeposits);\n        uint256 boldInSPForOffsets = totalBoldDeposits - boldToLeaveInSP;\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        _batchLiquidateTroves(defaultPoolCached, price, boldInSPForOffsets, _troveArray, totals, troveChange);\n\n        if (troveChange.debtDecrease == 0) {\n            revert NothingToLiquidate();\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        // Move liquidated Coll and Bold to the appropriate pools\n        if (totals.debtToOffset > 0 || totals.collToSendToSP > 0) {\n            stabilityPoolCached.offset(totals.debtToOffset, totals.collToSendToSP);\n        }\n        // we check amount is not zero inside\n        _redistributeDebtAndColl(\n            activePoolCached, defaultPoolCached, totals.debtToRedistribute, totals.collToRedistribute\n        );\n        if (totals.collSurplus > 0) {\n            activePoolCached.sendColl(address(collSurplusPool), totals.collSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.collGasCompensation);\n\n        emit Liquidation(\n            totals.debtToOffset,\n            totals.debtToRedistribute,\n            totals.ETHGasCompensation,\n            totals.collGasCompensation,\n            totals.collToSendToSP,\n            totals.collToRedistribute,\n            totals.collSurplus,\n            L_coll,\n            L_boldDebt,\n            price\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, totals.ETHGasCompensation, totals.collGasCompensation);\n    }\n\n    function _isActiveOrZombie(Status _status) internal pure returns (bool) {\n        return _status == Status.active || _status == Status.zombie;\n    }\n\n    function _batchLiquidateTroves(\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _boldInSPForOffsets,\n        uint256[] memory _troveArray,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal {\n        uint256 remainingBoldInSPForOffsets = _boldInSPForOffsets;\n\n        for (uint256 i = 0; i < _troveArray.length; i++) {\n            uint256 troveId = _troveArray[i];\n\n            // Skip non-liquidatable troves\n            if (!_isActiveOrZombie(Troves[troveId].status)) continue;\n\n            uint256 ICR = getCurrentICR(troveId, _price);\n\n            if (ICR < MCR) {\n                LiquidationValues memory singleLiquidation;\n                LatestTroveData memory trove;\n\n                _liquidate(_defaultPool, troveId, remainingBoldInSPForOffsets, _price, trove, singleLiquidation);\n                remainingBoldInSPForOffsets -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                _addLiquidationValuesToTotals(trove, singleLiquidation, totals, troveChange);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    // Adds all values from `singleLiquidation` to their respective totals in `totals` in-place\n    function _addLiquidationValuesToTotals(\n        LatestTroveData memory _trove,\n        LiquidationValues memory _singleLiquidation,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal pure {\n        // Tally all the values with their respective running totals\n        totals.collGasCompensation += _singleLiquidation.collGasCompensation;\n        totals.ETHGasCompensation += ETH_GAS_COMPENSATION;\n        troveChange.debtDecrease += _trove.entireDebt;\n        troveChange.collDecrease += _trove.entireColl;\n        troveChange.appliedRedistBoldDebtGain += _trove.redistBoldDebtGain;\n        troveChange.oldWeightedRecordedDebt += _singleLiquidation.oldWeightedRecordedDebt;\n        troveChange.newWeightedRecordedDebt += _singleLiquidation.newWeightedRecordedDebt;\n        totals.debtToOffset += _singleLiquidation.debtToOffset;\n        totals.collToSendToSP += _singleLiquidation.collToSendToSP;\n        totals.debtToRedistribute += _singleLiquidation.debtToRedistribute;\n        totals.collToRedistribute += _singleLiquidation.collToRedistribute;\n        totals.collSurplus += _singleLiquidation.collSurplus;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _eth, uint256 _coll) internal {\n        if (_eth > 0) {\n            WETH.transferFrom(gasPoolAddress, _liquidator, _eth);\n        }\n\n        if (_coll > 0) {\n            _activePool.sendColl(_liquidator, _coll);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IDefaultPool _defaultPool, uint256 _bold, uint256 _coll) internal {\n        if (_bold > 0) {\n            _defaultPool.decreaseBoldDebt(_bold);\n        }\n\n        if (_coll > 0) {\n            _defaultPool.sendCollToActivePool(_coll);\n        }\n    }\n\n    // --- Redemption functions ---\n\n    function _applySingleRedemption(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        // Decrease the debt and collateral of the current Trove according to the Bold lot and corresponding ETH to send\n        uint256 newDebt = _singleRedemption.trove.entireDebt - _singleRedemption.boldLot;\n        uint256 newColl = _singleRedemption.trove.entireColl - _singleRedemption.collLot;\n\n        _singleRedemption.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n\n        if (_isTroveInBatch) {\n            _getLatestBatchData(_singleRedemption.batchAddress, _singleRedemption.batch);\n            // We know boldLot <= trove entire debt, so this subtraction is safe\n            uint256 newAmountForWeightedDebt = _singleRedemption.batch.entireDebtWithoutRedistribution\n                + _singleRedemption.trove.redistBoldDebtGain - _singleRedemption.boldLot;\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.batch.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualInterestRate;\n\n            TroveChange memory troveChange;\n            troveChange.debtDecrease = _singleRedemption.boldLot;\n            troveChange.collDecrease = _singleRedemption.collLot;\n            troveChange.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n            troveChange.appliedRedistCollGain = _singleRedemption.trove.redistCollGain;\n            // batchAccruedManagementFee is handled in the outer function\n            troveChange.oldWeightedRecordedBatchManagementFee =\n                _singleRedemption.batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualManagementFee;\n\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, _singleRedemption.batchAddress);\n\n            Troves[_singleRedemption.troveId].coll = newColl;\n            // interest and fee were updated in the outer function\n            // This call could revert due to BatchSharesRatioTooHigh if trove.redistCollGain > boldLot\n            // so we skip that check to avoid blocking redemptions\n            _updateBatchShares(\n                _singleRedemption.troveId,\n                _singleRedemption.batchAddress,\n                troveChange,\n                newDebt,\n                _singleRedemption.batch.entireCollWithoutRedistribution,\n                _singleRedemption.batch.entireDebtWithoutRedistribution,\n                false // _checkBatchSharesRatio\n            );\n        } else {\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.trove.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt = newDebt * _singleRedemption.trove.annualInterestRate;\n            Troves[_singleRedemption.troveId].debt = newDebt;\n            Troves[_singleRedemption.troveId].coll = newColl;\n            Troves[_singleRedemption.troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _singleRedemption.newStake = _updateStakeAndTotalStakes(_singleRedemption.troveId, newColl);\n        _movePendingTroveRewardsToActivePool(\n            _defaultPool, _singleRedemption.trove.redistBoldDebtGain, _singleRedemption.trove.redistCollGain\n        );\n        _updateTroveRewardSnapshots(_singleRedemption.troveId);\n\n        if (_isTroveInBatch) {\n            emit BatchedTroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _batchDebtShares: Troves[_singleRedemption.troveId].batchDebtShares,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        } else {\n            emit TroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _debt: newDebt,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        }\n\n        emit TroveOperation({\n            _troveId: _singleRedemption.troveId,\n            _operation: Operation.redeemCollateral,\n            _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n            _debtIncreaseFromRedist: _singleRedemption.trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(_singleRedemption.boldLot),\n            _collIncreaseFromRedist: _singleRedemption.trove.redistCollGain,\n            _collChangeFromOperation: -int256(_singleRedemption.collLot)\n        });\n\n        if (_isTroveInBatch) {\n            emit BatchUpdated({\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _operation: BatchOperation.troveChange,\n                _debt: batches[_singleRedemption.batchAddress].debt,\n                _coll: batches[_singleRedemption.batchAddress].coll,\n                _annualInterestRate: _singleRedemption.batch.annualInterestRate,\n                _annualManagementFee: _singleRedemption.batch.annualManagementFee,\n                _totalDebtShares: batches[_singleRedemption.batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n\n        emit RedemptionFeePaidToTrove(_singleRedemption.troveId, _singleRedemption.collFee);\n\n        return newDebt;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _redeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        uint256 _maxBoldamount,\n        uint256 _redemptionPrice,\n        uint256 _redemptionRate\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of Coll equal in USD value to the boldLot redeemed\n        uint256 correspondingColl = _singleRedemption.boldLot * DECIMAL_PRECISION / _redemptionPrice;\n        // Calculate the collFee separately (for events)\n        _singleRedemption.collFee = correspondingColl * _redemptionRate / DECIMAL_PRECISION;\n        // Get the final collLot to send to redeemer, leaving the fee in the Trove\n        _singleRedemption.collLot = correspondingColl - _singleRedemption.collFee;\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        uint256 newDebt = _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // Make Trove zombie if it's tiny (and it wasn’t already), in order to prevent griefing future (normal, sequential) redemptions\n        if (newDebt < MIN_DEBT) {\n            if (!_singleRedemption.isZombieTrove) {\n                Troves[_singleRedemption.troveId].status = Status.zombie;\n                if (isTroveInBatch) {\n                    sortedTroves.removeFromBatch(_singleRedemption.troveId);\n                } else {\n                    sortedTroves.remove(_singleRedemption.troveId);\n                }\n                // If it’s a partial redemption, let’s store a pointer to it so it’s used first in the next one\n                if (newDebt > 0) {\n                    lastZombieTroveId = _singleRedemption.troveId;\n                }\n            } else if (newDebt == 0) {\n                // Reset last zombie trove pointer if the previous one was fully redeemed now\n                lastZombieTroveId = 0;\n            }\n        }\n        // Note: technically, it could happen that the Trove pointed to by `lastZombieTroveId` ends up with\n        // newDebt >= MIN_DEBT thanks to BOLD debt redistribution, which means it _could_ be made active again,\n        // however we don't do that here, as it would require hints for re-insertion into `SortedTroves`.\n    }\n\n    function _updateBatchInterestPriorToRedemption(IActivePool _activePool, address _batchAddress) internal {\n        LatestBatchData memory batch;\n        _getLatestBatchData(_batchAddress, batch);\n        batches[_batchAddress].debt = batch.entireDebtWithoutRedistribution;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        // As we are updating the batch, we update the ActivePool weighted sum too\n        TroveChange memory batchTroveChange;\n        batchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchTroveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchTroveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchTroveChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n\n        _activePool.mintAggInterestAndAccountForTroveChange(batchTroveChange, _batchAddress);\n    }\n\n    /* Send _boldamount Bold to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies redistribution gains to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, and therefore in “zombie” state\n    */\n    function redeemCollateral(\n        address _redeemer,\n        uint256 _boldamount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external override returns (uint256 _redeemedAmount) {\n        _requireCallerIsCollateralRegistry();\n\n        IActivePool activePoolCached = activePool;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        TroveChange memory totalsTroveChange;\n        RedeemCollateralValues memory vars;\n\n        vars.remainingBold = _boldamount;\n\n        SingleRedemptionValues memory singleRedemption;\n        // Let’s check if there’s a pending zombie trove from previous redemption\n        if (lastZombieTroveId != 0) {\n            singleRedemption.troveId = lastZombieTroveId;\n            singleRedemption.isZombieTrove = true;\n        } else {\n            singleRedemption.troveId = sortedTrovesCached.getLast();\n        }\n        vars.lastBatchUpdatedInterest = address(0);\n\n        // Get the price to use for the redemption collateral calculations\n        (uint256 redemptionPrice,) = priceFeed.fetchRedemptionPrice();\n\n        // Loop through the Troves starting from the one with lowest interest rate until _amount of Bold is exchanged for collateral\n        if (_maxIterations == 0) _maxIterations = type(uint256).max;\n        while (singleRedemption.troveId != 0 && vars.remainingBold > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the uint256 of the Trove preceding the current one\n            if (singleRedemption.isZombieTrove) {\n                vars.nextUserToCheck = sortedTrovesCached.getLast();\n            } else {\n                vars.nextUserToCheck = sortedTrovesCached.getPrev(singleRedemption.troveId);\n            }\n\n            // Skip if ICR < 100%, to make sure that redemptions don’t decrease the CR of hit Troves.\n            // Use the normal price for the ICR check.\n            if (getCurrentICR(singleRedemption.troveId, _price) < _100pct) {\n                singleRedemption.troveId = vars.nextUserToCheck;\n                singleRedemption.isZombieTrove = false;\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // We do it here outside, to avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (\n                singleRedemption.batchAddress != address(0)\n                    && singleRedemption.batchAddress != vars.lastBatchUpdatedInterest\n            ) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n                vars.lastBatchUpdatedInterest = singleRedemption.batchAddress;\n            }\n\n            _redeemCollateralFromTrove(\n                defaultPool, singleRedemption, vars.remainingBold, redemptionPrice, _redemptionRate\n            );\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n            vars.totalCollFee += singleRedemption.collFee;\n\n            vars.remainingBold -= singleRedemption.boldLot;\n            singleRedemption.troveId = vars.nextUserToCheck;\n            singleRedemption.isZombieTrove = false;\n        }\n\n        // We are removing this condition to prevent blocking redemptions\n        //require(totals.totalCollDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        emit Redemption(\n            _boldamount,\n            totalsTroveChange.debtDecrease,\n            totalsTroveChange.collDecrease,\n            vars.totalCollFee,\n            _price,\n            redemptionPrice\n        );\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed Coll to sender\n        activePoolCached.sendColl(_redeemer, totalsTroveChange.collDecrease);\n        // We’ll burn all the Bold together out in the CollateralRegistry, to save gas\n\n        return totalsTroveChange.debtDecrease;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _urgentRedeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        SingleRedemptionValues memory _singleRedemption\n    ) internal {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of ETH equal in USD value to the BOLD lot redeemed\n        _singleRedemption.collLot = _singleRedemption.boldLot * (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS) / _price;\n        // As here we can redeem when CR < 101% (accounting for 1% bonus), we need to cap by collateral too\n        if (_singleRedemption.collLot > _singleRedemption.trove.entireColl) {\n            _singleRedemption.collLot = _singleRedemption.trove.entireColl;\n            _singleRedemption.boldLot =\n                _singleRedemption.trove.entireColl * _price / (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS);\n        }\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // No need to make this Trove zombie if it has tiny debt, since:\n        // - This collateral branch has shut down and urgent redemptions are enabled\n        // - Urgent redemptions aren't sequential, so they can't be griefed by tiny Troves.\n    }\n\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external {\n        _requireIsShutDown();\n        _requireAmountGreaterThanZero(_boldAmount);\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        IActivePool activePoolCached = activePool;\n        TroveChange memory totalsTroveChange;\n\n        // Use the standard fetchPrice here, since if branch has shut down we don't worry about small redemption arbs\n        (uint256 price,) = priceFeed.fetchPrice();\n\n        uint256 remainingBold = _boldAmount;\n        for (uint256 i = 0; i < _troveIds.length; i++) {\n            if (remainingBold == 0) break;\n\n            SingleRedemptionValues memory singleRedemption;\n            singleRedemption.troveId = _troveIds[i];\n            _getLatestTroveData(singleRedemption.troveId, singleRedemption.trove);\n\n            if (!_isActiveOrZombie(Troves[singleRedemption.troveId].status) || singleRedemption.trove.entireDebt == 0) {\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // As we don’t have them ordered now, we cannot avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (singleRedemption.batchAddress != address(0)) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n            }\n\n            _urgentRedeemCollateralFromTrove(defaultPool, remainingBold, price, singleRedemption);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n\n            remainingBold -= singleRedemption.boldLot;\n        }\n\n        if (totalsTroveChange.collDecrease < _minCollateral) {\n            revert MinCollNotReached(totalsTroveChange.collDecrease);\n        }\n\n        emit Redemption(_boldAmount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, 0, price, price);\n\n        // Since this branch is shut down, this will mint 0 interest.\n        // We call this only to update the aggregate debt and weighted debt trackers.\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed coll to caller\n        activePoolCached.sendColl(msg.sender, totalsTroveChange.collDecrease);\n        // Burn bold\n        boldToken.burn(msg.sender, totalsTroveChange.debtDecrease);\n    }\n\n    function shutdown() external {\n        _requireCallerIsBorrowerOperations();\n        shutdownTime = block.timestamp;\n        activePool.setShutdownFlag();\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(uint256 _troveId, uint256 _price) public view override returns (uint256) {\n        LatestTroveData memory trove;\n        _getLatestTroveData(_troveId, trove);\n        return LiquityMath._computeCR(trove.entireColl, trove.entireDebt, _price);\n    }\n\n    function _updateTroveRewardSnapshots(uint256 _troveId) internal {\n        rewardSnapshots[_troveId].coll = L_coll;\n        rewardSnapshots[_troveId].boldDebt = L_boldDebt;\n    }\n\n    // Return the Troves entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestTroveData(uint256 _troveId, LatestTroveData memory trove) internal view {\n        // If trove belongs to a batch, we fetch the batch and apply its share to obtained values\n        address batchAddress = _getBatchManager(_troveId);\n        if (batchAddress != address(0)) {\n            LatestBatchData memory batch;\n            _getLatestBatchData(batchAddress, batch);\n            _getLatestTroveDataFromBatch(_troveId, trove, batch);\n            return;\n        }\n\n        uint256 stake = Troves[_troveId].stake;\n        trove.redistBoldDebtGain = stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        trove.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        trove.recordedDebt = Troves[_troveId].debt;\n        trove.annualInterestRate = Troves[_troveId].annualInterestRate;\n        trove.weightedRecordedDebt = trove.recordedDebt * trove.annualInterestRate;\n\n        uint256 period = _getInterestPeriod(Troves[_troveId].lastDebtUpdateTime);\n        trove.accruedInterest = _calcInterest(trove.weightedRecordedDebt, period);\n\n        trove.entireDebt = trove.recordedDebt + trove.redistBoldDebtGain + trove.accruedInterest;\n        trove.entireColl = Troves[_troveId].coll + trove.redistCollGain;\n        trove.lastInterestRateAdjTime = Troves[_troveId].lastInterestRateAdjTime;\n    }\n\n    function _getLatestTroveDataFromBatch(\n        uint256 _troveId,\n        LatestTroveData memory _latestTroveData,\n        LatestBatchData memory _latestBatchData\n    ) internal view {\n        Trove memory trove = Troves[_troveId];\n        uint256 batchDebtShares = trove.batchDebtShares;\n        uint256 totalDebtShares = _latestBatchData.totalDebtShares;\n\n        uint256 stake = trove.stake;\n        _latestTroveData.redistBoldDebtGain =\n            stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        if (totalDebtShares > 0) {\n            _latestTroveData.recordedDebt = _latestBatchData.recordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.weightedRecordedDebt = _latestTroveData.recordedDebt * _latestBatchData.annualInterestRate;\n            _latestTroveData.accruedInterest = _latestBatchData.accruedInterest * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedBatchManagementFee =\n                _latestBatchData.accruedManagementFee * batchDebtShares / totalDebtShares;\n        }\n        _latestTroveData.annualInterestRate = _latestBatchData.annualInterestRate;\n\n        // We can’t do pro-rata batch entireDebt, because redist gains are proportional to coll, not to debt\n        _latestTroveData.entireDebt = _latestTroveData.recordedDebt + _latestTroveData.redistBoldDebtGain\n            + _latestTroveData.accruedInterest + _latestTroveData.accruedBatchManagementFee;\n        _latestTroveData.entireColl = trove.coll + _latestTroveData.redistCollGain;\n        _latestTroveData.lastInterestRateAdjTime =\n            LiquityMath._max(_latestBatchData.lastInterestRateAdjTime, trove.lastInterestRateAdjTime);\n    }\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory trove) {\n        _getLatestTroveData(_troveId, trove);\n    }\n\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256) {\n        Trove memory trove = Troves[_troveId];\n        address batchAddress = _getBatchManager(trove);\n        if (batchAddress != address(0)) {\n            return batches[batchAddress].annualInterestRate;\n        }\n        return trove.annualInterestRate;\n    }\n\n    function _getBatchManager(uint256 _troveId) internal view returns (address) {\n        return Troves[_troveId].interestBatchManager;\n    }\n\n    function _getBatchManager(Trove memory trove) internal pure returns (address) {\n        return trove.interestBatchManager;\n    }\n\n    // Return the Batch entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestBatchData(address _batchAddress, LatestBatchData memory latestBatchData) internal view {\n        Batch memory batch = batches[_batchAddress];\n\n        latestBatchData.totalDebtShares = batch.totalDebtShares;\n        latestBatchData.recordedDebt = batch.debt;\n        latestBatchData.annualInterestRate = batch.annualInterestRate;\n        latestBatchData.weightedRecordedDebt = latestBatchData.recordedDebt * latestBatchData.annualInterestRate;\n        uint256 period = _getInterestPeriod(batch.lastDebtUpdateTime);\n        latestBatchData.accruedInterest = _calcInterest(latestBatchData.weightedRecordedDebt, period);\n        latestBatchData.annualManagementFee = batch.annualManagementFee;\n        latestBatchData.weightedRecordedBatchManagementFee =\n            latestBatchData.recordedDebt * latestBatchData.annualManagementFee;\n        latestBatchData.accruedManagementFee = _calcInterest(latestBatchData.weightedRecordedBatchManagementFee, period);\n\n        latestBatchData.entireDebtWithoutRedistribution =\n            latestBatchData.recordedDebt + latestBatchData.accruedInterest + latestBatchData.accruedManagementFee;\n        latestBatchData.entireCollWithoutRedistribution = batch.coll;\n        latestBatchData.lastDebtUpdateTime = batch.lastDebtUpdateTime;\n        latestBatchData.lastInterestRateAdjTime = batch.lastInterestRateAdjTime;\n    }\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory batch) {\n        _getLatestBatchData(_batchAddress, batch);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(uint256 _troveId, uint256 _coll) internal returns (uint256 newStake) {\n        newStake = _computeNewStake(_coll);\n        uint256 oldStake = Troves[_troveId].stake;\n        Troves[_troveId].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the redistribution gains, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            // assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debtToRedistribute,\n        uint256 _collToRedistribute\n    ) internal {\n        if (_debtToRedistribute == 0) return; // Otherwise _collToRedistribute > 0 too\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_coll and L_boldDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToRedistribute * DECIMAL_PRECISION + lastCollError_Redistribution;\n        uint256 boldDebtNumerator = _debtToRedistribute * DECIMAL_PRECISION + lastBoldDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint256 collRewardPerUnitStaked = collNumerator / totalStakes;\n        uint256 boldDebtRewardPerUnitStaked = boldDebtNumerator / totalStakes;\n\n        lastCollError_Redistribution = collNumerator - collRewardPerUnitStaked * totalStakes;\n        lastBoldDebtError_Redistribution = boldDebtNumerator - boldDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_coll = L_coll + collRewardPerUnitStaked;\n        L_boldDebt = L_boldDebt + boldDebtRewardPerUnitStaked;\n\n        _defaultPool.increaseBoldDebt(_debtToRedistribute);\n        _activePool.sendCollToDefaultPool(_collToRedistribute);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getCollBalance();\n        uint256 liquidatedColl = defaultPool.getCollBalance();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveIds array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveId(uint256 _troveId, uint256 TroveIdsArrayLength) internal {\n        uint64 index = Troves[_troveId].arrayIndex;\n        uint256 idxLast = TroveIdsArrayLength - 1;\n\n        // assert(index <= idxLast);\n\n        uint256 idToMove = TroveIds[idxLast];\n\n        TroveIds[index] = idToMove;\n        Troves[idToMove].arrayIndex = index;\n\n        TroveIds.pop();\n    }\n\n    function getTroveStatus(uint256 _troveId) external view override returns (Status) {\n        return Troves[_troveId].status;\n    }\n\n    // --- Interest rate calculations ---\n\n    function _getInterestPeriod(uint256 _lastDebtUpdateTime) internal view returns (uint256) {\n        if (shutdownTime == 0) {\n            // If branch is not shut down, interest is earned up to now.\n            return block.timestamp - _lastDebtUpdateTime;\n        } else if (shutdownTime > 0 && _lastDebtUpdateTime < shutdownTime) {\n            // If branch is shut down and the Trove was not updated since shut down, interest is earned up to the shutdown time.\n            return shutdownTime - _lastDebtUpdateTime;\n        } else {\n            // if (shutdownTime > 0 && _lastDebtUpdateTime >= shutdownTime)\n            // If branch is shut down and the Trove was updated after shutdown, no interest is earned since.\n            return 0;\n        }\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != address(borrowerOperations)) {\n            revert CallerNotBorrowerOperations();\n        }\n    }\n\n    function _requireCallerIsCollateralRegistry() internal view {\n        if (msg.sender != address(collateralRegistry)) {\n            revert CallerNotCollateralRegistry();\n        }\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint256 TroveIdsArrayLength) internal pure {\n        if (TroveIdsArrayLength == 1) {\n            revert OnlyOneTroveLeft();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (shutdownTime == 0) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        if (boldBalance < _amount) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    // --- Trove property getters ---\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool) {\n        uint256 totalDebt = getEntireBranchDebt();\n        uint256 spSize = stabilityPool.getTotalBoldDeposits();\n        uint256 unbackedPortion = totalDebt > spSize ? totalDebt - spSize : 0;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        // It's redeemable if the TCR is above the shutdown threshold, and branch has not been shut down.\n        // Use the normal price for the TCR check.\n        bool redeemable = _getTCR(price) >= SCR && shutdownTime == 0;\n\n        return (unbackedPortion, price, redeemable);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].debt = _troveChange.debtIncrease + _troveChange.upfrontFee;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _annualInterestRate;\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _troveChange.debtIncrease + _troveChange.upfrontFee,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _annualInterestRate: _annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTrove,\n            _annualInterestRate: _annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n    }\n\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].interestBatchManager = _batchAddress;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        assert(_troveChange.debtIncrease > 0);\n        _updateBatchShares(\n            _troveId, _batchAddress, _troveChange, _troveChange.debtIncrease, _batchColl, _batchDebt, true\n        );\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTroveAndJoinBatch,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove joining the batch pays an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function setTroveStatusToActive(uint256 _troveId) external {\n        _requireCallerIsBorrowerOperations();\n        Troves[_troveId].status = Status.active;\n        if (lastZombieTroveId == _troveId) {\n            lastZombieTroveId = 0;\n        }\n    }\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTroveInterestRate,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n    }\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newColl);\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: newStake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        _closeTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, Status.closedByOwner);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.closeTrove,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        if (_batchAddress != address(0)) {\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[_batchAddress].debt,\n                _coll: batches[_batchAddress].coll,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n    }\n\n    function _closeTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        Status closedStatus\n    ) internal {\n        // assert(closedStatus == Status.closedByLiquidation || closedStatus == Status.closedByOwner);\n\n        uint256 TroveIdsArrayLength = TroveIds.length;\n        // If branch has not been shut down, or it's a liquidation,\n        // require at least 1 trove in the system\n        if (shutdownTime == 0 || closedStatus == Status.closedByLiquidation) {\n            _requireMoreThanOneTroveInSystem(TroveIdsArrayLength);\n        }\n\n        _removeTroveId(_troveId, TroveIdsArrayLength);\n\n        Trove memory trove = Troves[_troveId];\n\n        // If trove belongs to a batch, remove from it\n        if (_batchAddress != address(0)) {\n            if (trove.status == Status.active) {\n                sortedTroves.removeFromBatch(_troveId);\n            } else if (trove.status == Status.zombie && lastZombieTroveId == _troveId) {\n                lastZombieTroveId = 0;\n            }\n\n            _removeTroveSharesFromBatch(\n                _troveId,\n                _troveChange.collDecrease,\n                _troveChange.debtDecrease,\n                _troveChange,\n                _batchAddress,\n                _newBatchColl,\n                _newBatchDebt\n            );\n        } else {\n            if (trove.status == Status.active) {\n                sortedTroves.remove(_troveId);\n            } else if (trove.status == Status.zombie && lastZombieTroveId == _troveId) {\n                lastZombieTroveId = 0;\n            }\n        }\n\n        uint256 newTotalStakes = totalStakes - trove.stake;\n        totalStakes = newTotalStakes;\n\n        // Zero Trove properties\n        delete Troves[_troveId];\n        Troves[_troveId].status = closedStatus;\n\n        // Zero Trove snapshots\n        delete rewardSnapshots[_troveId];\n\n        // burn ERC721\n        troveNFT.burn(_troveId);\n    }\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution and trove change\n        uint256 _newTroveDebt, // entire, with redistribution and trove change\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest, batch fee), but without trove change nor upfront fee nor redistribution\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        // Trove\n        Troves[_troveId].coll = _newTroveColl;\n        _updateTroveRewardSnapshots(_troveId);\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newTroveColl);\n\n        // Batch\n        assert(_newTroveDebt > 0);\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _newTroveDebt, _newBatchColl, _newBatchDebt, true);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _newTroveColl,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove being adjusted may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newTroveColl;\n\n        if (_batchAddress != address(0)) {\n            assert(_newTroveDebt > 0);\n            _updateBatchShares(_troveId, _batchAddress, _troveChange, _newTroveDebt, _newBatchColl, _newBatchDebt, true);\n\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.applyBatchInterestAndFee,\n                _debt: _newBatchDebt,\n                _coll: _newBatchColl,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        } else {\n            Troves[_troveId].debt = _newTroveDebt;\n            Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.applyPendingDebt,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_account].arrayIndex = uint64(batchIds.length);\n        batches[_account].annualInterestRate = _annualInterestRate;\n        batches[_account].annualManagementFee = _annualManagementFee;\n        batches[_account].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        batchIds.push(_account);\n\n        emit BatchUpdated({\n            _interestBatchManager: _account,\n            _operation: BatchOperation.registerBatchManager,\n            _debt: 0,\n            _coll: 0,\n            _annualInterestRate: _annualInterestRate,\n            _annualManagementFee: _annualManagementFee,\n            _totalDebtShares: 0,\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualManagementFee = _newAnnualManagementFee;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.lowerBatchManagerAnnualFee,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: _newAnnualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        uint256 _upfrontFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualInterestRate = _newAnnualInterestRate;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        batches[_batchAddress].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.setBatchManagerAnnualInterestRate,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: _newAnnualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            _debtIncreaseFromUpfrontFee: _upfrontFee\n        });\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external {\n        _requireCallerIsBorrowerOperations();\n        TroveChange memory _troveChange = _params.troveChange;\n\n        // assert(batchIds[batches[_params.newBatchAddress].arrayIndex] == _params.newBatchAddress);\n\n        _updateTroveRewardSnapshots(_params.troveId);\n\n        // Clean Trove state\n        Troves[_params.troveId].debt = 0;\n        Troves[_params.troveId].annualInterestRate = 0;\n        Troves[_params.troveId].lastDebtUpdateTime = 0;\n        Troves[_params.troveId].coll = _params.troveColl;\n\n        Troves[_params.troveId].interestBatchManager = _params.newBatchAddress;\n        Troves[_params.troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _troveChange.collIncrease = _params.troveColl - _troveChange.appliedRedistCollGain;\n        _troveChange.debtIncrease = _params.troveDebt - _troveChange.appliedRedistBoldDebtGain - _troveChange.upfrontFee;\n        assert(_params.troveDebt > 0);\n        _updateBatchShares(\n            _params.troveId,\n            _params.newBatchAddress,\n            _troveChange,\n            _params.troveDebt,\n            _params.newBatchColl,\n            _params.newBatchDebt,\n            true\n        );\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _params.troveId,\n            _interestBatchManager: _params.newBatchAddress,\n            _batchDebtShares: Troves[_params.troveId].batchDebtShares,\n            _coll: _params.troveColl,\n            _stake: Troves[_params.troveId].stake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _params.troveId,\n            _operation: Operation.setInterestBatchManager,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _params.newBatchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_params.newBatchAddress].debt,\n            _coll: batches[_params.newBatchAddress].coll,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _annualManagementFee: batches[_params.newBatchAddress].annualManagementFee,\n            _totalDebtShares: batches[_params.newBatchAddress].totalDebtShares,\n            // Although the Trove joining the batch may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    // This function will revert if there’s a total debt increase and the ratio debt / shares has exceeded the max\n    function _updateBatchShares(\n        uint256 _troveId,\n        address _batchAddress,\n        TroveChange memory _troveChange,\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        uint256 _batchColl, // without trove change\n        uint256 _batchDebt, // entire (with interest, batch fee), but without trove change, nor upfront fee nor redist\n        bool _checkBatchSharesRatio // whether we do the check on the resulting ratio inside the func call\n    ) internal {\n        // Debt\n        uint256 currentBatchDebtShares = batches[_batchAddress].totalDebtShares;\n        uint256 batchDebtSharesDelta;\n        uint256 debtIncrease =\n            _troveChange.debtIncrease + _troveChange.upfrontFee + _troveChange.appliedRedistBoldDebtGain;\n        uint256 debtDecrease;\n        if (debtIncrease > _troveChange.debtDecrease) {\n            debtIncrease -= _troveChange.debtDecrease;\n        } else {\n            debtDecrease = _troveChange.debtDecrease - debtIncrease;\n            debtIncrease = 0;\n        }\n\n        if (debtIncrease == 0 && debtDecrease == 0) {\n            batches[_batchAddress].debt = _batchDebt;\n        } else {\n            if (debtIncrease > 0) {\n                // Add debt\n                if (_batchDebt == 0) {\n                    batchDebtSharesDelta = debtIncrease;\n                } else {\n                    // To avoid rebasing issues, let’s make sure the ratio debt / shares is not too high\n                    _requireBelowMaxSharesRatio(currentBatchDebtShares, _batchDebt, _checkBatchSharesRatio);\n\n                    batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / _batchDebt;\n                }\n\n                Troves[_troveId].batchDebtShares += batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt + debtIncrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares + batchDebtSharesDelta;\n            } else if (debtDecrease > 0) {\n                // Subtract debt\n                // We make sure that if final trove debt is zero, shares are too (avoiding rounding issues)\n                // This can only happen from redemptions, as otherwise we would be using _removeTroveSharesFromBatch\n                // In redemptions we don’t do that because we don’t want to kick the trove out of the batch (it’d be bad UX)\n                if (_newTroveDebt == 0) {\n                    batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                    batches[_batchAddress].totalDebtShares = currentBatchDebtShares - Troves[_troveId].batchDebtShares;\n                    Troves[_troveId].batchDebtShares = 0;\n                } else {\n                    batchDebtSharesDelta = currentBatchDebtShares * debtDecrease / _batchDebt;\n\n                    Troves[_troveId].batchDebtShares -= batchDebtSharesDelta;\n                    batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                    batches[_batchAddress].totalDebtShares = currentBatchDebtShares - batchDebtSharesDelta;\n                }\n            }\n        }\n        // Update debt checkpoint\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        // Collateral\n        uint256 collIncrease = _troveChange.collIncrease + _troveChange.appliedRedistCollGain;\n        uint256 collDecrease;\n        if (collIncrease > _troveChange.collDecrease) {\n            collIncrease -= _troveChange.collDecrease;\n        } else {\n            collDecrease = _troveChange.collDecrease - collIncrease;\n            collIncrease = 0;\n        }\n\n        if (collIncrease == 0 && collDecrease == 0) {\n            batches[_batchAddress].coll = _batchColl;\n        } else {\n            if (collIncrease > 0) {\n                // Add coll\n                batches[_batchAddress].coll = _batchColl + collIncrease;\n            } else if (collDecrease > 0) {\n                // Subtract coll\n                batches[_batchAddress].coll = _batchColl - collDecrease;\n            }\n        }\n    }\n\n    // For the debt / shares ratio to increase by a factor 1e9\n    // at a average annual debt increase (compounded interest + fees) of 10%, it would take more than 217 years (log(1e9)/log(1.1))\n    // at a average annual debt increase (compounded interest + fees) of 50%, it would take more than 51 years (log(1e9)/log(1.5))\n    // When that happens, no more debt can be manually added to the batch, so batch should be migrated to a new one\n    function _requireBelowMaxSharesRatio(\n        uint256 _currentBatchDebtShares,\n        uint256 _batchDebt,\n        bool _checkBatchSharesRatio\n    ) internal pure {\n        // debt / shares should be below MAX_BATCH_SHARES_RATIO\n        if (_currentBatchDebtShares * MAX_BATCH_SHARES_RATIO < _batchDebt && _checkBatchSharesRatio) {\n            revert BatchSharesRatioTooHigh();\n        }\n    }\n\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        // Subtract from batch\n        _removeTroveSharesFromBatch(\n            _troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt\n        );\n\n        // Restore Trove state\n        Troves[_troveId].debt = _newTroveDebt;\n        Troves[_troveId].coll = _newTroveColl;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.removeFromBatch,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove leaving the batch may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function _removeTroveSharesFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest and batch fee), but without trove change\n    ) internal {\n        // As we are removing:\n        // assert(_newBatchDebt > 0 || _newBatchColl > 0);\n\n        Trove memory trove = Troves[_troveId];\n\n        // We don’t need to increase the shares corresponding to redistribution first, because they would be subtracted immediately after\n        // We don’t need to account for interest nor batch fee because it’s proportional to debt shares\n        uint256 batchDebtDecrease = _newTroveDebt - _troveChange.upfrontFee - _troveChange.appliedRedistBoldDebtGain;\n        uint256 batchCollDecrease = _newTroveColl - _troveChange.appliedRedistCollGain;\n\n        batches[_batchAddress].totalDebtShares -= trove.batchDebtShares;\n        batches[_batchAddress].debt = _newBatchDebt - batchDebtDecrease;\n        batches[_batchAddress].coll = _newBatchColl - batchCollDecrease;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        Troves[_troveId].interestBatchManager = address(0);\n        Troves[_troveId].batchDebtShares = 0;\n    }\n}\n"
    }
}