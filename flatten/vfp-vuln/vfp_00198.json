{
    "vfp_id": "vfp_00198",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "M1: processExitDelayReport griefing",
            "description": "The processExitDelayReport function in CSExitPenalties.sol reverts when a validator has already been reported for exit delay, which prevents batch reporting transactions from succeeding if any single validator in the batch has already been reported. This behavior enables a griefing attack where an attacker can front-run a batch report transaction by submitting a report for one validator in the batch, causing the entire batch to revert and waste gas. The root cause is the use of a revert instead of a silent skip when a validator is already reported. This increases the cost and risk of reporting for honest actors and can be abused to disrupt the penalty enforcement mechanism.\n",
            "severity": "Medium",
            "location": [
                "CSExitPenalties.sol::processExitDelayReport",
                "ValidatorExitDelayVerifier.sol::verifyValidatorExitDelay#178-196"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSExitPenalties.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/core/contracts/0.8.25/ValidatorExitDelayVerifier.sol"
            ]
        }
    ],
    "affected_files": {
        "ValidatorExitDelayVerifier.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.25;\n\nimport {BeaconBlockHeader, Validator} from \"./lib/BeaconTypes.sol\";\nimport {GIndex} from \"./lib/GIndex.sol\";\nimport {SSZ} from \"./lib/SSZ.sol\";\nimport {ILidoLocator} from \"../common/interfaces/ILidoLocator.sol\";\nimport {IValidatorsExitBus} from \"./interfaces/IValidatorsExitBus.sol\";\nimport {IStakingRouter} from \"./interfaces/IStakingRouter.sol\";\n\nstruct ExitRequestData {\n    bytes data;\n    uint256 dataFormat;\n}\n\nstruct ValidatorWitness {\n    // The index of an exit request in the VEB exit requests data\n    uint32 exitRequestIndex;\n    // -------------------- Validator details -------------------\n    bytes32 withdrawalCredentials;\n    uint64 effectiveBalance;\n    bool slashed;\n    uint64 activationEligibilityEpoch;\n    uint64 activationEpoch;\n    uint64 withdrawableEpoch;\n    // ------------------------ Proof ---------------------------\n    bytes32[] validatorProof;\n}\n\nstruct ProvableBeaconBlockHeader {\n    BeaconBlockHeader header; // Header of the block which root is known at 'rootsTimestamp'.\n    uint64 rootsTimestamp; // Timestamp passed to EIP-4788 block roots contract to retrieve the known block root.\n}\n\n// A witness for a block header which root is accessible via `historical_summaries` field.\nstruct HistoricalHeaderWitness {\n    BeaconBlockHeader header;\n    GIndex rootGIndex; // The generalized index of the old block root in the historical_summaries.\n    bytes32[] proof; // The Merkle proof for the old block header against the state's historical_summaries root.\n}\n\n/**\n * @title ValidatorExitDelayVerifier\n * @notice Allows permissionless reporting of exit delays for validators that have been requested to exit\n *         via the Validator Exit Bus.\n *\n * @dev Uses EIP-4788 to confirm the correctness of a given beacon block root.\n */\ncontract ValidatorExitDelayVerifier {\n    using SSZ for Validator;\n    using SSZ for BeaconBlockHeader;\n\n    /// @notice EIP-4788 contract address that provides a mapping of timestamp -> known beacon block root.\n    address public constant BEACON_ROOTS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    uint64 private constant FAR_FUTURE_EPOCH = type(uint64).max;\n\n    uint64 public immutable GENESIS_TIME;\n    uint32 public immutable SLOTS_PER_EPOCH;\n    uint32 public immutable SECONDS_PER_SLOT;\n    uint32 public immutable SHARD_COMMITTEE_PERIOD_IN_SECONDS;\n\n    /**\n     * @notice The GIndex pointing to BeaconState.validators[0] for the \"previous\" fork.\n     * @dev Used to derive the correct GIndex when verifying proofs for a block prior to pivot.\n     */\n    GIndex public immutable GI_FIRST_VALIDATOR_PREV;\n\n    /**\n     * @notice The GIndex pointing to BeaconState.validators[0] for the \"current\" fork.\n     * @dev Used to derive the correct GIndex when verifying proofs for a block after the pivot slot.\n     */\n    GIndex public immutable GI_FIRST_VALIDATOR_CURR;\n\n    /**\n     * @notice The GIndex pointing to BeaconState.historical_summaries for the \"previous\" fork.\n     * @dev Used when verifying old blocks (i.e., blocks with slot < PIVOT_SLOT).\n     */\n    GIndex public immutable GI_HISTORICAL_SUMMARIES_PREV;\n\n    /**\n     * @notice The GIndex pointing to BeaconState.historical_summaries for the \"current\" fork.\n     * @dev Used when verifying old blocks (i.e., blocks with slot >= PIVOT_SLOT).\n     */\n    GIndex public immutable GI_HISTORICAL_SUMMARIES_CURR;\n\n    /// @notice The first slot this verifier will accept proofs for.\n    uint64 public immutable FIRST_SUPPORTED_SLOT;\n\n    /// @notice The first slot of the currently-compatible fork.\n    uint64 public immutable PIVOT_SLOT;\n\n    ILidoLocator public immutable LOCATOR;\n\n    error RootNotFound();\n    error InvalidGIndex();\n    error InvalidBlockHeader();\n    error UnsupportedSlot(uint64 slot);\n    error InvalidPivotSlot();\n    error ZeroLidoLocatorAddress();\n    error ExitIsNotEligibleOnProvableBeaconBlock(\n        uint256 provableBeaconBlockTimestamp,\n        uint256 eligibleExitRequestTimestamp\n    );\n    error EmptyDeliveryHistory();\n\n    /**\n     * @dev The previous and current forks can be essentially the same.\n     * @param lidoLocator The address of the LidoLocator contract.\n     * @param gIFirstValidatorPrev GIndex pointing to validators[0] on the previous fork.\n     * @param gIFirstValidatorCurr GIndex pointing to validators[0] on the current fork.\n     * @param gIHistoricalSummariesPrev GIndex pointing to the historical_summaries on the previous fork.\n     * @param gIHistoricalSummariesCurr GIndex pointing to the historical_summaries on the current fork.\n     * @param firstSupportedSlot The earliest slot number that proofs can be submitted for verification.\n     * @param pivotSlot The pivot slot number used to differentiate \"previous\" vs \"current\" fork indexing.\n     * @param slotsPerEpoch Number of slots per epoch in Ethereum consensus.\n     * @param secondsPerSlot Duration of a single slot, in seconds, in Ethereum consensus.\n     * @param genesisTime Genesis timestamp of the Ethereum Beacon chain.\n     * @param shardCommitteePeriodInSeconds The length of the shard committee period, in seconds.\n     */\n    constructor(\n        address lidoLocator,\n        GIndex gIFirstValidatorPrev,\n        GIndex gIFirstValidatorCurr,\n        GIndex gIHistoricalSummariesPrev,\n        GIndex gIHistoricalSummariesCurr,\n        uint64 firstSupportedSlot,\n        uint64 pivotSlot,\n        uint32 slotsPerEpoch,\n        uint32 secondsPerSlot,\n        uint64 genesisTime,\n        uint32 shardCommitteePeriodInSeconds\n    ) {\n        if (lidoLocator == address(0)) revert ZeroLidoLocatorAddress();\n        if (firstSupportedSlot > pivotSlot) revert InvalidPivotSlot();\n\n        LOCATOR = ILidoLocator(lidoLocator);\n\n        GI_FIRST_VALIDATOR_PREV = gIFirstValidatorPrev;\n        GI_FIRST_VALIDATOR_CURR = gIFirstValidatorCurr;\n\n        GI_HISTORICAL_SUMMARIES_PREV = gIHistoricalSummariesPrev;\n        GI_HISTORICAL_SUMMARIES_CURR = gIHistoricalSummariesCurr;\n\n        FIRST_SUPPORTED_SLOT = firstSupportedSlot;\n        PIVOT_SLOT = pivotSlot;\n        SLOTS_PER_EPOCH = slotsPerEpoch;\n        SECONDS_PER_SLOT = secondsPerSlot;\n        GENESIS_TIME = genesisTime;\n        SHARD_COMMITTEE_PERIOD_IN_SECONDS = shardCommitteePeriodInSeconds;\n    }\n\n    // ------------------------- External Functions -------------------------\n\n    /**\n     * @notice Verifies that the provided validators were not requested to exit on the CL after a VEB exit request.\n     *         Reports exit delays to the Staking Router.\n     * @dev Ensures that `exitEpoch` is equal to `FAR_FUTURE_EPOCH` at the given beacon block.\n     * @param beaconBlock The block header and EIP-4788 timestamp to prove the block root is known.\n     * @param validatorWitnesses Array of validator proofs to confirm they are not yet exited.\n     * @param exitRequests The concatenated VEBO exit requests, each 64 bytes in length.\n     */\n    function verifyValidatorExitDelay(\n        ProvableBeaconBlockHeader calldata beaconBlock,\n        ValidatorWitness[] calldata validatorWitnesses,\n        ExitRequestData calldata exitRequests\n    ) external {\n        _verifyBeaconBlockRoot(beaconBlock);\n\n        IValidatorsExitBus veb = IValidatorsExitBus(LOCATOR.validatorsExitBusOracle());\n        IStakingRouter stakingRouter = IStakingRouter(LOCATOR.stakingRouter());\n\n        uint256 deliveredTimestamp = _getExitRequestDeliveryTimestamp(veb, exitRequests);\n        uint256 proofSlotTimestamp = _slotToTimestamp(beaconBlock.header.slot);\n\n        for (uint256 i = 0; i < validatorWitnesses.length; i++) {\n            ValidatorWitness calldata witness = validatorWitnesses[i];\n\n            (bytes memory pubkey, uint256 nodeOpId, uint256 moduleId, uint256 valIndex) = veb.unpackExitRequest(\n                exitRequests.data,\n                exitRequests.dataFormat,\n                witness.exitRequestIndex\n            );\n\n            uint256 eligibleToExitInSec = _getSecondsSinceExitIsEligible(\n                deliveredTimestamp,\n                witness.activationEpoch,\n                proofSlotTimestamp\n            );\n\n            _verifyValidatorExitUnset(beaconBlock.header, validatorWitnesses[i], pubkey, valIndex);\n\n            stakingRouter.reportValidatorExitDelay(moduleId, nodeOpId, proofSlotTimestamp, pubkey, eligibleToExitInSec);\n        }\n    }\n\n    /**\n     * @notice Verifies that the provided validators were not requested to exit on the CL after a VEB exit request.\n     *         Reports exit delays to the Staking Router.\n     * @dev Ensures that `exitEpoch` is equal to `FAR_FUTURE_EPOCH` at the given beacon block.\n     * @dev Verifies historical blocks (via historical_summaries).\n     * @dev The oldBlock.header must have slot >= FIRST_SUPPORTED_SLOT.\n     * @param beaconBlock The block header and EIP-4788 timestamp to prove the block root is known.\n     * @param oldBlock Historical block header witness data and its proof.\n     * @param validatorWitnesses Array of validator proofs to confirm they are not yet exited in oldBlock.header.\n     * @param exitRequests The concatenated VEBO exit requests, each 64 bytes in length.\n     */\n    function verifyHistoricalValidatorExitDelay(\n        ProvableBeaconBlockHeader calldata beaconBlock,\n        HistoricalHeaderWitness calldata oldBlock,\n        ValidatorWitness[] calldata validatorWitnesses,\n        ExitRequestData calldata exitRequests\n    ) external {\n        _verifyBeaconBlockRoot(beaconBlock);\n        _verifyHistoricalBeaconBlockRoot(beaconBlock, oldBlock);\n\n        IValidatorsExitBus veb = IValidatorsExitBus(LOCATOR.validatorsExitBusOracle());\n        IStakingRouter stakingRouter = IStakingRouter(LOCATOR.stakingRouter());\n\n        uint256 deliveredTimestamp = _getExitRequestDeliveryTimestamp(veb, exitRequests);\n        uint256 proofSlotTimestamp = _slotToTimestamp(oldBlock.header.slot);\n\n        for (uint256 i = 0; i < validatorWitnesses.length; i++) {\n            ValidatorWitness calldata witness = validatorWitnesses[i];\n\n            (bytes memory pubkey, uint256 nodeOpId, uint256 moduleId, uint256 valIndex) = veb.unpackExitRequest(\n                exitRequests.data,\n                exitRequests.dataFormat,\n                witness.exitRequestIndex\n            );\n\n            uint256 eligibleToExitInSec = _getSecondsSinceExitIsEligible(\n                deliveredTimestamp,\n                witness.activationEpoch,\n                proofSlotTimestamp\n            );\n\n            _verifyValidatorExitUnset(oldBlock.header, witness, pubkey, valIndex);\n\n            stakingRouter.reportValidatorExitDelay(moduleId, nodeOpId, proofSlotTimestamp, pubkey, eligibleToExitInSec);\n        }\n    }\n\n    /**\n     * @dev Verifies the beacon block header is known in EIP-4788.\n     * @param beaconBlock The provable beacon block header and the EIP-4788 timestamp.\n     */\n    function _verifyBeaconBlockRoot(ProvableBeaconBlockHeader calldata beaconBlock) internal view {\n        if (beaconBlock.header.slot < FIRST_SUPPORTED_SLOT) {\n            revert UnsupportedSlot(beaconBlock.header.slot);\n        }\n\n        (bool success, bytes memory data) = BEACON_ROOTS.staticcall(abi.encode(beaconBlock.rootsTimestamp));\n        if (!success || data.length == 0) {\n            revert RootNotFound();\n        }\n\n        bytes32 trustedRoot = abi.decode(data, (bytes32));\n        if (trustedRoot != beaconBlock.header.hashTreeRoot()) {\n            revert InvalidBlockHeader();\n        }\n    }\n\n    function _verifyHistoricalBeaconBlockRoot(\n        ProvableBeaconBlockHeader calldata beaconBlock,\n        HistoricalHeaderWitness calldata oldBlock\n    ) internal view {\n        if (oldBlock.header.slot < FIRST_SUPPORTED_SLOT) {\n            revert UnsupportedSlot(oldBlock.header.slot);\n        }\n\n        if (!_getHistoricalSummariesGI(beaconBlock.header.slot).isParentOf(oldBlock.rootGIndex)) {\n            revert InvalidGIndex();\n        }\n\n        SSZ.verifyProof({\n            proof: oldBlock.proof,\n            root: beaconBlock.header.stateRoot,\n            leaf: oldBlock.header.hashTreeRoot(),\n            gI: oldBlock.rootGIndex\n        });\n    }\n\n    /**\n     * @notice Proves—via an SSZ Merkle proof—that the validator\n     *         has not scheduled nor completed an exit.\n     *\n     * @dev    It reconstructs the `Validator` object with `exitEpoch` hard-coded\n     *         to `FAR_FUTURE_EPOCH` and checks that this leaf is present under\n     *         the supplied `stateRoot`.\n     *\n     *         Reverts if proof verification fail.\n     */\n    function _verifyValidatorExitUnset(\n        BeaconBlockHeader calldata header,\n        ValidatorWitness calldata witness,\n        bytes memory pubkey,\n        uint256 validatorIndex\n    ) internal view {\n        Validator memory validator = Validator({\n            pubkey: pubkey,\n            withdrawalCredentials: witness.withdrawalCredentials,\n            effectiveBalance: witness.effectiveBalance,\n            slashed: witness.slashed,\n            activationEligibilityEpoch: witness.activationEligibilityEpoch,\n            activationEpoch: witness.activationEpoch,\n            exitEpoch: FAR_FUTURE_EPOCH,\n            withdrawableEpoch: witness.withdrawableEpoch\n        });\n\n        SSZ.verifyProof({\n            proof: witness.validatorProof,\n            root: header.stateRoot,\n            leaf: validator.hashTreeRoot(),\n            gI: _getValidatorGI(validatorIndex, header.slot)\n        });\n    }\n\n    /**\n     * @dev Determines how many seconds have passed since a validator was first eligible\n     *      to exit after VEB exit request.\n     * @return uint256 The elapsed seconds since the earliest eligible exit request time.\n     */\n    function _getSecondsSinceExitIsEligible(\n        uint256 deliveredTimestamp,\n        uint256 activationEpoch,\n        uint256 referenceSlotTimestamp\n    ) internal view returns (uint256) {\n        // The earliest a validator can voluntarily exit is after the Shard Committee Period\n        // subsequent to its activation epoch.\n        uint256 earliestPossibleVoluntaryExitTimestamp = GENESIS_TIME +\n            (activationEpoch * SLOTS_PER_EPOCH * SECONDS_PER_SLOT) +\n            SHARD_COMMITTEE_PERIOD_IN_SECONDS;\n\n        // The actual eligible timestamp is the max between the exit request submission time\n        // and the earliest possible voluntary exit time.\n        uint256 eligibleExitRequestTimestamp = deliveredTimestamp > earliestPossibleVoluntaryExitTimestamp\n            ? deliveredTimestamp\n            : earliestPossibleVoluntaryExitTimestamp;\n\n        if (referenceSlotTimestamp < eligibleExitRequestTimestamp) {\n            revert ExitIsNotEligibleOnProvableBeaconBlock(referenceSlotTimestamp, eligibleExitRequestTimestamp);\n        }\n\n        return referenceSlotTimestamp - eligibleExitRequestTimestamp;\n    }\n\n    function _getValidatorGI(uint256 offset, uint64 stateSlot) internal view returns (GIndex) {\n        GIndex gI = stateSlot < PIVOT_SLOT ? GI_FIRST_VALIDATOR_PREV : GI_FIRST_VALIDATOR_CURR;\n        return gI.shr(offset);\n    }\n\n    function _getHistoricalSummariesGI(uint64 stateSlot) internal view returns (GIndex) {\n        return stateSlot < PIVOT_SLOT ? GI_HISTORICAL_SUMMARIES_PREV : GI_HISTORICAL_SUMMARIES_CURR;\n    }\n\n    function _getExitRequestDeliveryTimestamp(\n        IValidatorsExitBus veb,\n        ExitRequestData calldata exitRequests\n    ) internal view returns (uint256 deliveryTimestamp) {\n        bytes32 exitRequestsHash = keccak256(abi.encode(exitRequests.data, exitRequests.dataFormat));\n        deliveryTimestamp = veb.getDeliveryTimestamp(exitRequestsHash);\n\n        if (deliveryTimestamp == 0) {\n            revert EmptyDeliveryHistory();\n        }\n    }\n\n    function _slotToTimestamp(uint64 slot) internal view returns (uint256) {\n        return GENESIS_TIME + slot * SECONDS_PER_SLOT;\n    }\n}\n",
        "CSExitPenalties.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ExitTypes } from \"./abstract/ExitTypes.sol\";\n\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSExitPenalties, MarkedUint248, ExitPenaltyInfo } from \"./interfaces/ICSExitPenalties.sol\";\nimport { ICSModule } from \"./interfaces/ICSModule.sol\";\nimport { ICSParametersRegistry } from \"./interfaces/ICSParametersRegistry.sol\";\n\ncontract CSExitPenalties is ICSExitPenalties, ExitTypes {\n    using SafeCast for uint256;\n\n    ICSModule public immutable MODULE;\n    ICSParametersRegistry public immutable PARAMETERS_REGISTRY;\n    ICSAccounting public immutable ACCOUNTING;\n    address public immutable STRIKES;\n\n    mapping(bytes32 keyPointer => ExitPenaltyInfo) private _exitPenaltyInfo;\n\n    modifier onlyModule() {\n        if (msg.sender != address(MODULE)) {\n            revert SenderIsNotModule();\n        }\n\n        _;\n    }\n\n    modifier onlyStrikes() {\n        if (msg.sender != STRIKES) {\n            revert SenderIsNotStrikes();\n        }\n\n        _;\n    }\n\n    constructor(address module, address parametersRegistry, address strikes) {\n        if (module == address(0)) {\n            revert ZeroModuleAddress();\n        }\n        if (parametersRegistry == address(0)) {\n            revert ZeroParametersRegistryAddress();\n        }\n        if (strikes == address(0)) {\n            revert ZeroStrikesAddress();\n        }\n\n        MODULE = ICSModule(module);\n        PARAMETERS_REGISTRY = ICSParametersRegistry(parametersRegistry);\n        ACCOUNTING = MODULE.accounting();\n        STRIKES = strikes;\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function processExitDelayReport(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external onlyModule {\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n\n        uint256 allowedExitDelay = PARAMETERS_REGISTRY.getAllowedExitDelay(\n            curveId\n        );\n        if (eligibleToExitInSec <= allowedExitDelay) {\n            revert ValidatorExitDelayNotApplicable();\n        }\n\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        ExitPenaltyInfo storage exitPenaltyInfo = _exitPenaltyInfo[keyPointer];\n        if (exitPenaltyInfo.delayPenalty.isValue) {\n            revert ValidatorExitDelayAlreadyReported();\n        }\n\n        uint256 delayPenalty = PARAMETERS_REGISTRY.getExitDelayPenalty(curveId);\n        exitPenaltyInfo.delayPenalty = MarkedUint248(\n            delayPenalty.toUint248(),\n            true\n        );\n        emit ValidatorExitDelayProcessed(\n            nodeOperatorId,\n            publicKey,\n            delayPenalty\n        );\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function processTriggeredExit(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 withdrawalRequestPaidFee,\n        uint256 exitType\n    ) external onlyModule {\n        if (exitType == VOLUNTARY_EXIT_TYPE_ID) {\n            return;\n        }\n\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        ExitPenaltyInfo storage exitPenaltyInfo = _exitPenaltyInfo[keyPointer];\n        // don't update the fee if it was already set to prevent hypothetical manipulations\n        //    with double reporting to get lower/higher fee.\n        if (exitPenaltyInfo.withdrawalRequestFee.isValue) {\n            return;\n        }\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n        uint256 maxFee = PARAMETERS_REGISTRY.getMaxWithdrawalRequestFee(\n            curveId\n        );\n\n        uint256 fee = Math.min(withdrawalRequestPaidFee, maxFee);\n\n        exitPenaltyInfo.withdrawalRequestFee = MarkedUint248(\n            fee.toUint248(),\n            true\n        );\n        emit TriggeredExitFeeRecorded({\n            nodeOperatorId: nodeOperatorId,\n            exitType: exitType,\n            pubkey: publicKey,\n            withdrawalRequestPaidFee: withdrawalRequestPaidFee,\n            withdrawalRequestRecordedFee: fee\n        });\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function processStrikesReport(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey\n    ) external onlyStrikes {\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        ExitPenaltyInfo storage exitPenaltyInfo = _exitPenaltyInfo[keyPointer];\n        if (exitPenaltyInfo.strikesPenalty.isValue) {\n            return;\n        }\n\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n        uint256 penalty = PARAMETERS_REGISTRY.getBadPerformancePenalty(curveId);\n        exitPenaltyInfo.strikesPenalty = MarkedUint248(\n            penalty.toUint248(),\n            true\n        );\n        emit StrikesPenaltyProcessed(nodeOperatorId, publicKey, penalty);\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    /// @dev there is a `onlyModule` modifier to prevent using it from outside\n    ///     as it gives a false-positive information for non-existent node operators.\n    ///     use `isValidatorExitDelayPenaltyApplicable` in the CSModule.sol instead\n    function isValidatorExitDelayPenaltyApplicable(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external view onlyModule returns (bool) {\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n        uint256 allowedExitDelay = PARAMETERS_REGISTRY.getAllowedExitDelay(\n            curveId\n        );\n        if (eligibleToExitInSec <= allowedExitDelay) {\n            return false;\n        }\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        bool isPenaltySet = _exitPenaltyInfo[keyPointer].delayPenalty.isValue;\n        return !isPenaltySet;\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function getExitPenaltyInfo(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey\n    ) external view returns (ExitPenaltyInfo memory) {\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        return _exitPenaltyInfo[keyPointer];\n    }\n\n    function _keyPointer(\n        uint256 nodeOperatorId,\n        bytes memory publicKey\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(nodeOperatorId, publicKey));\n    }\n}\n"
    }
}