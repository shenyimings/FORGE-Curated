{
    "vfp_id": "vfp_00303",
    "project_name": "Metamask Delegation Framework April 2025 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Missing Safe Transfer Validation in Execution Logic",
            "description": "The `beforeHook` function in the `MultiTokenPeriodEnforcer` contract performs low-level calls to execute ERC-20 token transfers but does not validate that the transfer returned `true`, as required by the ERC-20 standard. This omission is due to the lack of a success check on the return value of the token transfer, relying solely on reverts for failure signaling. An attacker or malfunctioning token could exploit this by using a non-compliant ERC-20 token that returns `false` on failure without reverting, leading to a silent failure where the system assumes the transfer succeeded. This could result in incorrect state updates, loss of expected tokens, or incorrect accounting within the delegation framework, potentially leading to fund loss or incorrect access control decisions.\n",
            "severity": "Critical",
            "location": [
                "src/enforcers/MultiTokenPeriodEnforcer.sol::beforeHook#131-144",
                "src/DeleGatorCore.sol::execute#182-216",
                "erc7579-implementation/src/core/ExecutionHelper.sol::_execute"
            ],
            "files": [
                "delegation-framework/src/enforcers/MultiTokenPeriodEnforcer.sol",
                "delegation-framework/src/DeleGatorCore.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "getTermsInfo Reverts Because of Block Gas Limit",
            "description": "The `getTermsInfo` function in the `MultiTokenPeriodEnforcer` contract iterates over the entire `_terms` byte array to find a matching token configuration, which results in unbounded gas usage proportional to the number of tokens. This is caused by a linear search without indexing or pagination, making the function vulnerable to gas limit exhaustion when the array is large. An attacker or legitimate user attempting to access a token near the end of a long list could cause the transaction to exceed the block gas limit, leading to a revert. This would prevent delegates from executing valid delegations for that token, resulting in a denial of service for specific token transfers and undermining the reliability of the delegation system.\n",
            "severity": "Critical",
            "location": [
                "src/enforcers/MultiTokenPeriodEnforcer.sol::getTermsInfo#157-187"
            ],
            "files": [
                "delegation-framework/src/enforcers/MultiTokenPeriodEnforcer.sol"
            ]
        }
    ],
    "affected_files": {
        "MultiTokenPeriodEnforcer.sol": "// SPDX-License-Identifier: MIT AND Apache-2.0\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ExecutionLib } from \"@erc7579/lib/ExecutionLib.sol\";\n\nimport { CaveatEnforcer } from \"./CaveatEnforcer.sol\";\nimport { ModeCode } from \"../utils/Types.sol\";\n\n/**\n * @title MultiTokenPeriodEnforcer\n * @notice Enforces periodic transfer limits for multiple tokens per delegation.\n * @dev The enforcer expects the _terms to be a concatenation of one or more 116-byte configurations.\n *      Each 116-byte segment encodes:\n *        - 20 bytes: token address (address(0) indicates a native transfer)\n *        - 32 bytes: periodAmount.\n *        - 32 bytes: periodDuration (in seconds).\n *        - 32 bytes: startDate for the first period.\n *\n *      For optimal gas usage, it is recommended that the configurations in _terms are sorted\n *      from the most frequently used token to the least frequently used token. Tokens placed\n *      earlier in the sequence will be processed first, reducing gas consumption.\n *\n *      The logic does not support duplicated token entries in the _terms. In the event that\n *      duplicate tokens are provided, the enforcer will only consider the configuration for the\n *      first occurrence and ignore subsequent configurations. This design choice is made to\n *      optimize gas efficiency and will not result in a revert.\n *\n *      Additionally, the enforcer does not support restrictions on the recipient address or\n *      arbitrary calldata. For ERC20 transfers, the execution data is strictly required to\n *      match the IERC20.transfer function selector with a zero ETH value, and for native transfers,\n *      only an empty calldata is permitted.\n *\n *      The _executionCallData always contains instructions for one token transfer.\n */\ncontract MultiTokenPeriodEnforcer is CaveatEnforcer {\n    using ExecutionLib for bytes;\n\n    ////////////////////////////// State //////////////////////////////\n\n    struct PeriodicAllowance {\n        uint256 periodAmount; // Maximum transferable amount per period.\n        uint256 periodDuration; // Duration of each period in seconds.\n        uint256 startDate; // Timestamp when the first period begins.\n        uint256 lastTransferPeriod; // The period index in which the last transfer was made.\n        uint256 transferredInCurrentPeriod; // Cumulative amount transferred in the current period.\n    }\n\n    // Mapping from delegation manager => delegation hash => token address => PeriodicAllowance.\n    mapping(address delegationManager => mapping(bytes32 delegationHash => mapping(address token => PeriodicAllowance))) public\n        periodicAllowances;\n\n    ////////////////////////////// Events //////////////////////////////\n\n    /**\n     * @notice Emitted when a transfer is made and the allowance is updated.\n     * @param sender The address initiating the transfer.\n     * @param redeemer The address receiving the tokens/ETH.\n     * @param delegationHash The hash identifying the delegation.\n     * @param token The token contract address; for native transfers this is address(0).\n     * @param periodAmount The maximum transferable amount per period.\n     * @param periodDuration The duration of each period in seconds.\n     * @param startDate The timestamp when the first period begins.\n     * @param transferredInCurrentPeriod The total transferred in the current period after this transfer.\n     * @param transferTimestamp The block timestamp when the transfer occurred.\n     */\n    event TransferredInPeriod(\n        address indexed sender,\n        address indexed redeemer,\n        bytes32 indexed delegationHash,\n        address token,\n        uint256 periodAmount,\n        uint256 periodDuration,\n        uint256 startDate,\n        uint256 transferredInCurrentPeriod,\n        uint256 transferTimestamp\n    );\n\n    ////////////////////////////// Public Methods //////////////////////////////\n\n    /**\n     * @notice Retrieves the available amount along with period details for a specific token.\n     * @param _delegationHash The delegation hash.\n     * @param _delegationManager The delegation manager's address.\n     * @param _terms A concatenation of one or more 116-byte configurations.\n     * @param _token The token for which the available amount is requested (address(0) for native).\n     * @return availableAmount_ The remaining transferable amount in the current period.\n     * @return isNewPeriod_ True if a new period has begun.\n     * @return currentPeriod_ The current period index.\n     */\n    function getAvailableAmount(\n        bytes32 _delegationHash,\n        address _delegationManager,\n        bytes calldata _terms,\n        address _token\n    )\n        external\n        view\n        returns (uint256 availableAmount_, bool isNewPeriod_, uint256 currentPeriod_)\n    {\n        PeriodicAllowance memory storedAllowance_ = periodicAllowances[_delegationManager][_delegationHash][_token];\n        if (storedAllowance_.startDate != 0) {\n            return _getAvailableAmount(storedAllowance_);\n        }\n\n        // Not yet initialized; simulate using provided terms.\n        (uint256 periodAmount_, uint256 periodDuration_, uint256 startDate_) = getTermsInfo(_terms, _token);\n\n        PeriodicAllowance memory allowance_ = PeriodicAllowance({\n            periodAmount: periodAmount_,\n            periodDuration: periodDuration_,\n            startDate: startDate_,\n            lastTransferPeriod: 0,\n            transferredInCurrentPeriod: 0\n        });\n        return _getAvailableAmount(allowance_);\n    }\n\n    /**\n     * @notice Hook called before a transfer to enforce the periodic limit.\n     * @dev For ERC20 transfers, expects _executionCallData to decode to (target,, callData)\n     *      with callData length of 68, beginning with IERC20.transfer.selector and zero value.\n     *      For native transfers, expects _executionCallData to decode to (target, value, callData)\n     *      with an empty callData.\n     * @param _terms A concatenation of one or more 116-byte configurations.\n     * @param _mode The execution mode (must be single callType, default execType).\n     * @param _executionCallData The encoded execution data.\n     * @param _delegationHash The delegation hash.\n     * @param _redeemer The address intended to receive the tokens/ETH.\n     */\n    function beforeHook(\n        bytes calldata _terms,\n        bytes calldata,\n        ModeCode _mode,\n        bytes calldata _executionCallData,\n        bytes32 _delegationHash,\n        address,\n        address _redeemer\n    )\n        public\n        override\n        onlySingleCallTypeMode(_mode)\n        onlyDefaultExecutionMode(_mode)\n    {\n        _validateAndConsumeTransfer(_terms, _executionCallData, _delegationHash, _redeemer);\n    }\n\n    /**\n     * @notice Searches the provided _terms for a configuration matching _token.\n     * @dev Expects _terms length to be a multiple of 116.\n     * @param _terms A concatenation of 116-byte configurations.\n     * @param _token The token address to search for (address(0) for native transfers).\n     * @return periodAmount_ The maximum transferable amount for this token.\n     * @return periodDuration_ The period duration (in seconds) for this token.\n     * @return startDate_ The start date for the first period.\n     */\n    function getTermsInfo(\n        bytes calldata _terms,\n        address _token\n    )\n        public\n        pure\n        returns (uint256 periodAmount_, uint256 periodDuration_, uint256 startDate_)\n    {\n        uint256 termsLength_ = _terms.length;\n        require(termsLength_ != 0 && termsLength_ % 116 == 0, \"MultiTokenPeriodEnforcer:invalid-terms-length\");\n\n        // Iterate over the byte offset directly in increments of 116 bytes.\n        for (uint256 offset_ = 0; offset_ < termsLength_;) {\n            // Extract token address from the first 20 bytes.\n            address token_ = address(bytes20(_terms[offset_:offset_ + 20]));\n            if (token_ == _token) {\n                // Get periodAmount from the next 32 bytes.\n                periodAmount_ = uint256(bytes32(_terms[offset_ + 20:offset_ + 52]));\n                // Get periodDuration from the subsequent 32 bytes.\n                periodDuration_ = uint256(bytes32(_terms[offset_ + 52:offset_ + 84]));\n                // Get startDate from the final 32 bytes.\n                startDate_ = uint256(bytes32(_terms[offset_ + 84:offset_ + 116]));\n                return (periodAmount_, periodDuration_, startDate_);\n            }\n\n            unchecked {\n                offset_ += 116;\n            }\n        }\n        revert(\"MultiTokenPeriodEnforcer:token-config-not-found\");\n    }\n\n    /**\n     * @notice Decodes all configurations contained in _terms.\n     * @dev Expects _terms length to be a multiple of 116.\n     * @param _terms A concatenation of 116-byte configurations.\n     * @return tokens_ An array of token addresses.\n     * @return periodAmounts_ An array of period amounts.\n     * @return periodDurations_ An array of period durations (in seconds).\n     * @return startDates_ An array of start dates for the first period.\n     */\n    function getAllTermsInfo(bytes calldata _terms)\n        public\n        pure\n        returns (\n            address[] memory tokens_,\n            uint256[] memory periodAmounts_,\n            uint256[] memory periodDurations_,\n            uint256[] memory startDates_\n        )\n    {\n        uint256 termsLength_ = _terms.length;\n        require(termsLength_ % 116 == 0 && termsLength_ != 0, \"MultiTokenPeriodEnforcer:invalid-terms-length\");\n        uint256 numConfigs_ = termsLength_ / 116;\n        tokens_ = new address[](numConfigs_);\n        periodAmounts_ = new uint256[](numConfigs_);\n        periodDurations_ = new uint256[](numConfigs_);\n        startDates_ = new uint256[](numConfigs_);\n\n        // Loop over each configuration using its index.\n        for (uint256 i = 0; i < numConfigs_; ++i) {\n            // Calculate the starting offset for this configuration.\n            uint256 offset_ = i * 116;\n            // Get the token address from the first 20 bytes.\n            tokens_[i] = address(bytes20(_terms[offset_:offset_ + 20]));\n            // Get the periodAmount from the next 32 bytes.\n            periodAmounts_[i] = uint256(bytes32(_terms[offset_ + 20:offset_ + 52]));\n            // Get the periodDuration from the following 32 bytes.\n            periodDurations_[i] = uint256(bytes32(_terms[offset_ + 52:offset_ + 84]));\n            // Get the startDate from the final 32 bytes.\n            startDates_[i] = uint256(bytes32(_terms[offset_ + 84:offset_ + 116]));\n        }\n    }\n\n    ////////////////////////////// Internal Methods //////////////////////////////\n\n    /**\n     * @notice Validates and consumes a transfer (native or ERC20) by ensuring the amount does not exceed the available limit.\n     * @dev Decodes the execution data based on token type:\n     *      - For native transfers (_token == address(0)): expect no calldata, value greater than zero.\n     *      - For ERC20 transfers (_token != address(0)): requires callData length to be 68 with a\n     *        valid IERC20.transfer selector, and zero value.\n     * @param _terms The concatenated configurations.\n     * @param _executionCallData The encoded execution data.\n     * @param _delegationHash The delegation hash.\n     * @param _redeemer The address intended to receive the tokens/ETH.\n     */\n    function _validateAndConsumeTransfer(\n        bytes calldata _terms,\n        bytes calldata _executionCallData,\n        bytes32 _delegationHash,\n        address _redeemer\n    )\n        private\n    {\n        uint256 transferAmount_;\n        address token_;\n\n        // Decode _executionCallData using decodeSingle.\n        (address target_, uint256 value_, bytes calldata callData_) = _executionCallData.decodeSingle();\n\n        if (callData_.length == 68) {\n            // ERC20 transfer.\n            require(value_ == 0, \"MultiTokenPeriodEnforcer:invalid-value-in-erc20-transfer\");\n            require(bytes4(callData_[0:4]) == IERC20.transfer.selector, \"MultiTokenPeriodEnforcer:invalid-method\");\n            token_ = target_;\n            transferAmount_ = uint256(bytes32(callData_[36:68]));\n        } else if (callData_.length == 0) {\n            // Native transfer.\n            require(value_ > 0, \"MultiTokenPeriodEnforcer:invalid-zero-value-in-native-transfer\");\n            token_ = address(0);\n            transferAmount_ = value_;\n        } else {\n            // If callData length is neither 68 nor 0, revert.\n            revert(\"MultiTokenPeriodEnforcer:invalid-call-data-length\");\n        }\n\n        // Retrieve the configuration for the token from _terms.\n        (uint256 periodAmount_, uint256 periodDuration_, uint256 startDate_) = getTermsInfo(_terms, token_);\n\n        // Use the multi-token mapping.\n        PeriodicAllowance storage allowance_ = periodicAllowances[msg.sender][_delegationHash][token_];\n\n        // Initialize the allowance if not already set.\n        if (allowance_.startDate == 0) {\n            require(startDate_ > 0, \"MultiTokenPeriodEnforcer:invalid-zero-start-date\");\n            require(periodAmount_ > 0, \"MultiTokenPeriodEnforcer:invalid-zero-period-amount\");\n            require(periodDuration_ > 0, \"MultiTokenPeriodEnforcer:invalid-zero-period-duration\");\n            require(block.timestamp >= startDate_, \"MultiTokenPeriodEnforcer:transfer-not-started\");\n\n            allowance_.periodAmount = periodAmount_;\n            allowance_.periodDuration = periodDuration_;\n            allowance_.startDate = startDate_;\n        }\n\n        // Determine the available amount.\n        (uint256 availableAmount_, bool isNewPeriod_, uint256 currentPeriod_) = _getAvailableAmount(allowance_);\n        require(transferAmount_ <= availableAmount_, \"MultiTokenPeriodEnforcer:transfer-amount-exceeded\");\n\n        // Reset transferred amount if a new period has begun.\n        if (isNewPeriod_) {\n            allowance_.lastTransferPeriod = currentPeriod_;\n            allowance_.transferredInCurrentPeriod = 0;\n        }\n        allowance_.transferredInCurrentPeriod += transferAmount_;\n\n        emit TransferredInPeriod(\n            msg.sender,\n            _redeemer,\n            _delegationHash,\n            token_,\n            periodAmount_,\n            periodDuration_,\n            startDate_,\n            allowance_.transferredInCurrentPeriod,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Computes the available amount for the current period.\n     * @dev If block.timestamp is before startDate, available amount is 0.\n     * @param _allowance The PeriodicAllowance struct.\n     * @return availableAmount_ The remaining transferable amount in the current period.\n     * @return isNewPeriod_ True if the last transfer period is not equal to the current period.\n     * @return currentPeriod_ The current period index.\n     */\n    function _getAvailableAmount(PeriodicAllowance memory _allowance)\n        internal\n        view\n        returns (uint256 availableAmount_, bool isNewPeriod_, uint256 currentPeriod_)\n    {\n        if (block.timestamp < _allowance.startDate) {\n            return (0, false, 0);\n        }\n\n        currentPeriod_ = (block.timestamp - _allowance.startDate) / _allowance.periodDuration + 1;\n        isNewPeriod_ = (_allowance.lastTransferPeriod != currentPeriod_);\n        uint256 alreadyTransferred_ = isNewPeriod_ ? 0 : _allowance.transferredInCurrentPeriod;\n        availableAmount_ = _allowance.periodAmount > alreadyTransferred_ ? _allowance.periodAmount - alreadyTransferred_ : 0;\n    }\n}\n",
        "DeleGatorCore.sol": "// SPDX-License-Identifier: MIT AND Apache-2.0\npragma solidity 0.8.23;\n\nimport { IEntryPoint } from \"@account-abstraction/interfaces/IEntryPoint.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC1271 } from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC1155Receiver } from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { ERC1967Utils } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport { ModeLib } from \"@erc7579/lib/ModeLib.sol\";\nimport { ExecutionLib } from \"@erc7579/lib/ExecutionLib.sol\";\nimport { ExecutionHelper } from \"@erc7579/core/ExecutionHelper.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { MessageHashUtils } from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\n\nimport { ERC1271Lib } from \"./libraries/ERC1271Lib.sol\";\nimport { IDeleGatorCore } from \"./interfaces/IDeleGatorCore.sol\";\nimport { IDelegationManager } from \"./interfaces/IDelegationManager.sol\";\nimport { CallType, ExecType, Execution, Delegation, PackedUserOperation, ModeCode } from \"./utils/Types.sol\";\nimport { CALLTYPE_SINGLE, CALLTYPE_BATCH, EXECTYPE_DEFAULT, EXECTYPE_TRY } from \"./utils/Constants.sol\";\n\n/**\n * @title DeleGatorCore\n * @notice This contract contains the shared logic for a DeleGator SCA implementation.\n * @dev Implements the interface needed for a DelegationManager to interact with a DeleGator implementation.\n * @dev DeleGator implementations can inherit this to enable Delegation, ERC4337 and UUPS.\n * @dev DeleGator implementations MUST use Namespaced Storage to ensure subsequent UUPS implementation updates are safe.\n */\nabstract contract DeleGatorCore is\n    Initializable,\n    ExecutionHelper,\n    UUPSUpgradeable,\n    IERC165,\n    IDeleGatorCore,\n    IERC721Receiver,\n    IERC1155Receiver,\n    EIP712\n{\n    using ModeLib for ModeCode;\n    using ExecutionLib for bytes;\n\n    ////////////////////////////// State //////////////////////////////\n\n    /// @dev The DelegationManager contract that has root access to this contract\n    IDelegationManager public immutable delegationManager;\n\n    /// @dev The EntryPoint contract that has root access to this contract\n    IEntryPoint public immutable entryPoint;\n\n    /// @dev The typehash for the PackedUserOperation struct\n    bytes32 public constant PACKED_USER_OP_TYPEHASH = keccak256(\n        \"PackedUserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,bytes32 accountGasLimits,uint256 preVerificationGas,bytes32 gasFees,bytes paymasterAndData,address entryPoint)\"\n    );\n\n    ////////////////////////////// Events //////////////////////////////\n\n    /// @dev Emitted when the Delegation manager is set\n    event SetDelegationManager(IDelegationManager indexed newDelegationManager);\n\n    /// @dev Emitted when the EntryPoint is set\n    event SetEntryPoint(IEntryPoint indexed entryPoint);\n\n    /// @dev Emitted when the storage is cleared\n    event ClearedStorage();\n\n    /// @dev Event emitted when prefunding is sent.\n    event SentPrefund(address indexed sender, uint256 amount, bool success);\n\n    ////////////////////////////// Errors //////////////////////////////\n\n    /// @dev Error thrown when the caller is not this contract.\n    error NotSelf();\n\n    /// @dev Error thrown when the caller is not the entry point.\n    error NotEntryPoint();\n\n    /// @dev Error thrown when the caller is not the EntryPoint or this contract.\n    error NotEntryPointOrSelf();\n\n    /// @dev Error thrown when the caller is not the delegation manager.\n    error NotDelegationManager();\n\n    /// @dev Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n\n    /// @dev Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n\n    ////////////////////////////// Modifiers //////////////////////////////\n\n    /**\n     * @notice Require the function call to come from the EntryPoint.\n     * @dev Check that the caller is the entry point\n     */\n    modifier onlyEntryPoint() {\n        if (msg.sender != address(entryPoint)) revert NotEntryPoint();\n        _;\n    }\n\n    /**\n     * @notice Require the function call to come from the EntryPoint or this contract.\n     * @dev Check that the caller is either the delegator contract itself or the entry point\n     */\n    modifier onlyEntryPointOrSelf() {\n        if (msg.sender != address(entryPoint) && msg.sender != address(this)) revert NotEntryPointOrSelf();\n        _;\n    }\n\n    /**\n     * @notice Require the function call to come from the DelegationManager.\n     * @dev Check that the caller is the stored delegation manager.\n     */\n    modifier onlyDelegationManager() {\n        if (msg.sender != address(delegationManager)) revert NotDelegationManager();\n        _;\n    }\n\n    ////////////////////////////// Constructor //////////////////////////////\n\n    /**\n     * @notice Initializes the DeleGatorCore contract\n     * @custom:oz-upgrades-unsafe-allow constructor\n     * @param _delegationManager the address of the trusted DelegationManager contract that will have root access to this contract\n     * @param _entryPoint the address of entry point\n     * @param _name Name of the contract\n     * @param _domainVersion Domain version of the contract\n     */\n    constructor(\n        IDelegationManager _delegationManager,\n        IEntryPoint _entryPoint,\n        string memory _name,\n        string memory _domainVersion\n    )\n        EIP712(_name, _domainVersion)\n    {\n        _disableInitializers();\n        delegationManager = _delegationManager;\n        entryPoint = _entryPoint;\n        emit SetDelegationManager(_delegationManager);\n        emit SetEntryPoint(_entryPoint);\n    }\n\n    ////////////////////////////// External Methods //////////////////////////////\n\n    /**\n     * @notice Allows this contract to receive the chains native token\n     */\n    receive() external payable { }\n\n    /**\n     * @notice Redeems a delegation on the DelegationManager and executes the specified executions on behalf of the root delegator.\n     * @param _permissionContexts An array of bytes where each element is made up of an array\n     * of `Delegation` structs that are used to validate the authority given to execute the corresponding execution on the\n     * root delegator, ordered from leaf to root.\n     * @param _modes An array of `ModeCode` structs representing the mode of execiton for each execution callData.\n     * @param _executionCallDatas An array of `Execution` structs representing the executions to be executed.\n     */\n    function redeemDelegations(\n        bytes[] calldata _permissionContexts,\n        ModeCode[] calldata _modes,\n        bytes[] calldata _executionCallDatas\n    )\n        external\n        onlyEntryPointOrSelf\n    {\n        delegationManager.redeemDelegations(_permissionContexts, _modes, _executionCallDatas);\n    }\n\n    /**\n     * @notice Executes an Execution from this contract\n     * @dev This method is intended to be called through a UserOp which ensures the invoker has sufficient permissions\n     * @dev This convenience method defeaults to reverting on failure and a single execution.\n     * @param _execution The Execution to be executed\n     */\n    function execute(Execution calldata _execution) external payable onlyEntryPoint {\n        _execute(_execution.target, _execution.value, _execution.callData);\n    }\n\n    /**\n     * @notice Executes an Execution from this contract\n     * @dev Related: @erc7579/MSAAdvanced.sol\n     * @dev This method is intended to be called through a UserOp which ensures the invoker has sufficient permissions\n     * @param _mode The ModeCode for the execution\n     * @param _executionCalldata The calldata for the execution\n     */\n    function execute(ModeCode _mode, bytes calldata _executionCalldata) external payable onlyEntryPoint {\n        (CallType callType_, ExecType execType_,,) = _mode.decode();\n\n        // Check if calltype is batch or single\n        if (callType_ == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions_ = _executionCalldata.decodeBatch();\n            // Check if execType is revert or try\n            if (execType_ == EXECTYPE_DEFAULT) _execute(executions_);\n            else if (execType_ == EXECTYPE_TRY) _tryExecute(executions_);\n            else revert UnsupportedExecType(execType_);\n        } else if (callType_ == CALLTYPE_SINGLE) {\n            // Destructure executionCallData according to single exec\n            (address target_, uint256 value_, bytes calldata callData_) = _executionCalldata.decodeSingle();\n            // Check if execType is revert or try\n            if (execType_ == EXECTYPE_DEFAULT) {\n                _execute(target_, value_, callData_);\n            } else if (execType_ == EXECTYPE_TRY) {\n                bytes[] memory returnData_ = new bytes[](1);\n                bool success_;\n                (success_, returnData_[0]) = _tryExecute(target_, value_, callData_);\n                if (!success_) emit TryExecuteUnsuccessful(0, returnData_[0]);\n            } else {\n                revert UnsupportedExecType(execType_);\n            }\n        } else {\n            revert UnsupportedCallType(callType_);\n        }\n    }\n\n    /**\n     * @inheritdoc IDeleGatorCore\n     * @dev Related: @erc7579/MSAAdvanced.sol\n     */\n    function executeFromExecutor(\n        ModeCode _mode,\n        bytes calldata _executionCalldata\n    )\n        external\n        payable\n        onlyDelegationManager\n        returns (bytes[] memory returnData_)\n    {\n        (CallType callType_, ExecType execType_,,) = _mode.decode();\n\n        // Check if calltype is batch or single\n        if (callType_ == CALLTYPE_BATCH) {\n            // Destructure executionCallData according to batched exec\n            Execution[] calldata executions_ = _executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType_ == EXECTYPE_DEFAULT) returnData_ = _execute(executions_);\n            else if (execType_ == EXECTYPE_TRY) returnData_ = _tryExecute(executions_);\n            else revert UnsupportedExecType(execType_);\n        } else if (callType_ == CALLTYPE_SINGLE) {\n            // Destructure executionCallData according to single exec\n            (address target_, uint256 value_, bytes calldata callData_) = _executionCalldata.decodeSingle();\n            returnData_ = new bytes[](1);\n            bool success_;\n            // check if execType is revert or try\n            if (execType_ == EXECTYPE_DEFAULT) {\n                returnData_[0] = _execute(target_, value_, callData_);\n            } else if (execType_ == EXECTYPE_TRY) {\n                (success_, returnData_[0]) = _tryExecute(target_, value_, callData_);\n                if (!success_) emit TryExecuteUnsuccessful(0, returnData_[0]);\n            } else {\n                revert UnsupportedExecType(execType_);\n            }\n        } else {\n            revert UnsupportedCallType(callType_);\n        }\n    }\n\n    /**\n     * @notice Validates a UserOp signature and sends any necessary funds to the EntryPoint\n     * @dev Related: ERC4337\n     * @param _userOp The UserOp struct to validate\n     * @param _missingAccountFunds The missing funds from the account\n     * @return validationData_ The validation data\n     */\n    function validateUserOp(\n        PackedUserOperation calldata _userOp,\n        bytes32, // Ignore UserOpHash from the Entry Point\n        uint256 _missingAccountFunds\n    )\n        external\n        onlyEntryPoint\n        onlyProxy\n        returns (uint256 validationData_)\n    {\n        validationData_ = _validateUserOpSignature(_userOp, getPackedUserOperationTypedDataHash(_userOp));\n        _payPrefund(_missingAccountFunds);\n    }\n\n    /**\n     * @inheritdoc IERC1271\n     * @notice Verifies the signatures of the signers.\n     * @dev Related: ERC4337, Delegation\n     * @param _hash The hash of the data signed.\n     * @param _signature The signatures of the signers.\n     * @return magicValue_ A bytes4 magic value which is EIP1271_MAGIC_VALUE(0x1626ba7e) if the signature is valid, returns\n     * SIG_VALIDATION_FAILED(0xffffffff) if there is a signature mismatch and reverts (for all other errors).\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes calldata _signature\n    )\n        external\n        view\n        override\n        onlyProxy\n        returns (bytes4 magicValue_)\n    {\n        return _isValidSignature(_hash, _signature);\n    }\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes memory) external view override onlyProxy returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    )\n        external\n        view\n        override\n        onlyProxy\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    )\n        public\n        view\n        override\n        onlyProxy\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @notice Deposits more funds for this account in the entry point\n     * @dev Related: ERC4337\n     */\n    function addDeposit() external payable onlyProxy {\n        entryPoint.depositTo{ value: msg.value }(address(this));\n    }\n\n    /**\n     * @notice This method withdraws funds of this account from the entry point\n     * @dev Related: ERC4337\n     * @param _withdrawAddress Address to withdraw the amount to\n     * @param _withdrawAmount Amount to be withdraw from the entry point\n     */\n    function withdrawDeposit(address payable _withdrawAddress, uint256 _withdrawAmount) external onlyEntryPointOrSelf {\n        entryPoint.withdrawTo(_withdrawAddress, _withdrawAmount);\n    }\n\n    /**\n     * @notice Disables a delegation from being used\n     * @param _delegation The delegation to be disabled\n     */\n    function disableDelegation(Delegation calldata _delegation) external onlyEntryPointOrSelf {\n        delegationManager.disableDelegation(_delegation);\n    }\n\n    /**\n     * @notice Enables a delegation to be used\n     * @dev Delegations only need to be enabled if they have been disabled\n     * @param _delegation The delegation to be enabled\n     */\n    function enableDelegation(Delegation calldata _delegation) external onlyEntryPointOrSelf {\n        delegationManager.enableDelegation(_delegation);\n    }\n\n    /**\n     * @notice Retains storage and updates the logic contract in use.\n     * @dev Related: UUPS\n     * @param _newImplementation Address of the new logic contract to use.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     */\n    function upgradeToAndCallAndRetainStorage(address _newImplementation, bytes memory _data) external payable {\n        super.upgradeToAndCall(_newImplementation, _data);\n    }\n\n    /**\n     * @notice Clears storage by default and updates the logic contract in use.\n     * @dev Related: UUPS\n     * @param _newImplementation Address of the new logic contract to use.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     */\n    function upgradeToAndCall(address _newImplementation, bytes memory _data) public payable override {\n        _clearDeleGatorStorage();\n        super.upgradeToAndCall(_newImplementation, _data);\n    }\n\n    /**\n     * @notice Checks if the delegation is disabled\n     * @param _delegationHash the hash of the delegation to check for disabled status.\n     * @return bool is the delegation disabled\n     */\n    function isDelegationDisabled(bytes32 _delegationHash) external view returns (bool) {\n        return delegationManager.disabledDelegations(_delegationHash);\n    }\n\n    /**\n     * @notice Gets the current account's deposit in the entry point\n     * @dev Related: ERC4337\n     * @return uint256 The current account's deposit in the entry point\n     */\n    function getDeposit() external view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Retrieves the address of the current UUPS Logic contract\n     * @dev Related: UUPS\n     * @return The address of the current UUPS Logic contract.\n     */\n    function getImplementation() external view returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n\n    /**\n     * @notice Retrieves the version of the current UUPS Logic contract\n     * @dev This version number is moreso the count of initializations that have occurred for this proxy contract.\n     * @dev Related: UUPS\n     */\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /**\n     * @notice Returns the next sequential nonce using a static key\n     * @dev Related: ERC4337\n     * @return uint256 The next sequential nonce\n     */\n    function getNonce() external view returns (uint256) {\n        return entryPoint.getNonce(address(this), 0);\n    }\n\n    /**\n     * @notice Returns the next sequential nonce using a custom key\n     * @dev Related: ERC4337\n     * @return uint256 The next sequential nonce for the key provided\n     * @param _key The key to use for the nonce\n     */\n    function getNonce(uint192 _key) external view returns (uint256) {\n        return entryPoint.getNonce(address(this), _key);\n    }\n\n    /**\n     * @notice This method returns the domain hash used for signing typed data\n     * @return bytes32 The domain hash\n     */\n    function getDomainHash() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Returns the formatted hash to sign for an EIP712 typed data signature\n     * @param _userOp the UserOp to hash\n     * @notice Returns an EIP712 typed data hash for a given UserOp\n     */\n    function getPackedUserOperationTypedDataHash(PackedUserOperation calldata _userOp) public view returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), getPackedUserOperationHash(_userOp));\n    }\n\n    /**\n     * @inheritdoc IERC165\n     * @dev Supports the following interfaces: IDeleGatorCore, IERC721Receiver, IERC1155Receiver, IERC165, IERC1271\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(IERC165) onlyProxy returns (bool) {\n        return _interfaceId == type(IDeleGatorCore).interfaceId || _interfaceId == type(IERC721Receiver).interfaceId\n            || _interfaceId == type(IERC1155Receiver).interfaceId || _interfaceId == type(IERC165).interfaceId\n            || _interfaceId == type(IERC1271).interfaceId;\n    }\n\n    /**\n     * Provides the typed data hash for a PackedUserOperation\n     * @param _userOp the PackedUserOperation to hash\n     */\n    function getPackedUserOperationHash(PackedUserOperation calldata _userOp) public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                PACKED_USER_OP_TYPEHASH,\n                _userOp.sender,\n                _userOp.nonce,\n                keccak256(_userOp.initCode),\n                keccak256(_userOp.callData),\n                _userOp.accountGasLimits,\n                _userOp.preVerificationGas,\n                _userOp.gasFees,\n                keccak256(_userOp.paymasterAndData),\n                entryPoint\n            )\n        );\n    }\n\n    ////////////////////////////// Internal Methods //////////////////////////////\n\n    /**\n     * @notice The logic to verify if the signature is valid for this contract\n     * @dev This is an internal function that should be overridden by the implementing contract based on the signature scheme used.\n     * @dev Related: ERC4337\n     * @param _hash The hash of the data signed.\n     * @param _signature The signatures of the signers.\n     * @return A bytes4 magic value which is EIP1271_MAGIC_VALUE(0x1626ba7e) if the signature is valid, returns\n     * SIG_VALIDATION_FAILED(0xffffffff) if there is a signature mismatch and reverts (for all other errors).\n     */\n    function _isValidSignature(bytes32 _hash, bytes calldata _signature) internal view virtual returns (bytes4);\n\n    /**\n     * @notice Clears the storage being used by a DeleGator Implementation\n     * @dev Related: UUPS\n     */\n    function _clearDeleGatorStorage() internal virtual;\n\n    /**\n     * @notice Validates that the sender is allowed to upgrade the contract\n     * @dev Related: UUPS\n     * @dev This is needed for UUPS secure upgradeability\n     * @param _newImplementation The address of the new implementation.\n     */\n    function _authorizeUpgrade(address _newImplementation) internal override onlyEntryPointOrSelf { }\n\n    /**\n     * @notice Validates a UserOp signature and returns a code indicating if the signature is valid or not\n     * @dev This method calls the DeleGator implementations `_isValidSignature` to validate the signature according to the\n     * implementations auth scheme.\n     * @dev Returns 0 if the signature is valid, 1 if the signature is invalid.\n     * @dev Related: ERC4337\n     * @param _userOp The UserOp\n     * @param _userOpHash UserOp hash produced with typed data\n     * @return validationData_ A code indicating if the signature is valid or not\n     */\n    function _validateUserOpSignature(\n        PackedUserOperation calldata _userOp,\n        bytes32 _userOpHash\n    )\n        internal\n        view\n        returns (uint256 validationData_)\n    {\n        bytes4 result_ = _isValidSignature(_userOpHash, _userOp.signature);\n        if (result_ == ERC1271Lib.EIP1271_MAGIC_VALUE) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n     * @notice Sends the entrypoint (msg.sender) any needed funds for the transaction.\n     * @param _missingAccountFunds the minimum value this method should send the entrypoint.\n     *         this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 _missingAccountFunds) internal {\n        if (_missingAccountFunds != 0) {\n            (bool success_,) = payable(msg.sender).call{ value: _missingAccountFunds, gas: type(uint256).max }(\"\");\n            (success_);\n            // Ignore failure (it's EntryPoint's job to verify, not account.)\n            emit SentPrefund(msg.sender, _missingAccountFunds, success_);\n        }\n    }\n}\n"
    }
}