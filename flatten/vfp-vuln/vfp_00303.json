{
    "vfp_id": "vfp_00303",
    "project_name": "cantina_tadle_oct2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Slippage input mis-scaled, causing reverts or loose fills",
            "description": "The mint and deposit functions accept slippage in basis points but pass it directly to internal functions expecting WAD-scale (1e18 = 100%). This causes a 1% slippage input (100) to be interpreted as 0.00000000000000001%, making trades extremely sensitive to price changes and likely to revert. Conversely, large inputs create excessive slippage, leading to poor execution prices. The root cause is a unit mismatch between the public interface and internal logic. Users or bots may incorrectly adjust slippage values trying to fix reverts, worsening the issue. The impact includes failed transactions, suboptimal trade execution, and potential financial loss due to unfavorable fills.\n",
            "severity": "Medium",
            "location": [
                "main.sol::mint#84",
                "main.sol::_mint#",
                "main.sol::getMinAmount#"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-swap/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-v3/main.sol"
            ]
        }
    ],
    "affected_files": {
        "main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {UniswapRouter02Helper} from \"./helpers.sol\";\n\n/**\n * @title UniswapSwapRouter\n * @dev Contract for executing token swaps through Uniswap\n * @notice Provides high-level swap functionality with storage integration\n */\ncontract UniswapSwapRouter02Resolver is UniswapRouter02Helper {\n    /**\n     * @dev Initializes the contract with required addresses\n     * @param _uniswapRouter Address of Uniswap Router contract\n     * @param _wethAddr Address of WETH token\n     * @param _tadleMemory Address of storage contract\n     */\n    constructor(address _uniswapRouter, address _wethAddr, address _tadleMemory)\n        UniswapRouter02Helper(_uniswapRouter, _wethAddr, _tadleMemory)\n    {}\n\n    /**\n     * @dev Executes a token swap with storage integration\n     * @param amountIn Amount of input tokens\n     * @param amountOutMin Minimum amount of output tokens expected\n     * @param path Encoded swap path data\n     * @param getIds Storage ID for retrieving input amount\n     * @param setIds Storage ID for storing output amount\n     * @return _eventName Name of the event to be logged\n     * @return _eventParam Encoded event parameters\n     */\n    function buy(bool isEth, uint256 amountIn, uint256 amountOutMin, bytes memory path, uint256 getIds, uint256 setIds)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Get input amount from storage\n        amountIn = getUint(getIds, amountIn);\n\n        // Execute swap\n        uint256 amountOut = _buy(amountIn, amountOutMin, address(this), isEth, path);\n\n        // Store output amount\n        setUint(setIds, amountOut);\n\n        // Return event data\n        _eventName = \"Buy(address,bytes,uint256,uint256)\";\n        _eventParam = abi.encode(address(this), path, amountIn, amountOut);\n    }\n}\n\n/**\n * @title ConnectV1UniswapSwapRouter02\n * @dev Connector implementation for Uniswap Router V2\n * @notice Entry point for Uniswap V2/V3 swap operations\n */\ncontract ConnectV1UniswapSwapRouter02 is UniswapSwapRouter02Resolver {\n    /// @dev Version identifier for the connector\n    string public constant name = \"UniswapSwapRouter02-v1.0.0\";\n\n    /**\n     * @dev Initializes the connector with required dependencies\n     * @param _uniswapRouter Address of Uniswap Router contract\n     * @param _wethAddr Address of WETH token\n     * @param _tadleMemory Address of storage contract\n     */\n    constructor(address _uniswapRouter, address _wethAddr, address _tadleMemory)\n        UniswapSwapRouter02Resolver(_uniswapRouter, _wethAddr, _tadleMemory)\n    {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-v3/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {INonfungiblePositionManager, Helpers} from \"./helpers.sol\";\n\n/**\n * @title Uniswap V3 Position Resolver\n * @dev Contract for managing Uniswap V3 NFT liquidity positions\n * @notice Provides functionality for minting, depositing, withdrawing, collecting fees, and burning positions\n */\ncontract UniswapV3PositionResolver is Helpers {\n    constructor(address _nftManager, address _wethAddr, address _tadleMemory, address _uniswapV3Factory)\n        Helpers(_nftManager, _wethAddr, _tadleMemory, _uniswapV3Factory)\n    {}\n\n    /**\n     * @dev Creates a new Uniswap V3 liquidity pool\n     * @param tokenA Address of the first token in the pair\n     * @param tokenB Address of the second token in the pair\n     * @param fee Trading fee tier (500 = 0.05%, 3000 = 0.3%, 10000 = 1%)\n     * @param sqrtPriceX96 Initial sqrt price of the pool (Q64.96 format)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters containing pool details\n     */\n    function createPool(address tokenA, address tokenB, uint24 fee, uint160 sqrtPriceX96)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Create pool and get pool address\n        address pool = _createPool(tokenA, tokenB, fee, sqrtPriceX96);\n\n        // Return event data for logging\n        _eventName = \"LogCreatePool(address,address,uint24,uint160,address)\";\n        _eventParam = abi.encode(tokenA, tokenB, fee, sqrtPriceX96, pool);\n    }\n\n    /**\n     * @dev Creates a new Uniswap V3 NFT liquidity position\n     * @param tokenA Address of the first token in the pair\n     * @param tokenB Address of the second token in the pair\n     * @param fee Trading fee tier (500 = 0.05%, 3000 = 0.3%, 10000 = 1%)\n     * @param tickLower Lower price bound of the position\n     * @param tickUpper Upper price bound of the position\n     * @param amtA Amount of tokenA to deposit (use type(uint256).max for entire balance)\n     * @param amtB Amount of tokenB to deposit (use type(uint256).max for entire balance)\n     * @param slippage Maximum allowed slippage in basis points\n     * @param getIds Array of IDs to retrieve token amounts [amtAId, amtBId]\n     * @param setId ID to store the liquidity amount\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function mint(\n        address tokenA,\n        address tokenB,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amtA,\n        uint256 amtB,\n        uint256 slippage,\n        uint256[] calldata getIds,\n        uint256 setId\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        MintParams memory params;\n        {\n            params = MintParams(tokenA, tokenB, fee, tickLower, tickUpper, amtA, amtB, slippage);\n        }\n        params.amtA = getUint(getIds[0], params.amtA);\n        params.amtB = getUint(getIds[1], params.amtB);\n\n        (uint256 _tokenId, uint256 liquidity, uint256 amountA, uint256 amountB) = _mint(params);\n\n        setUint(setId, liquidity);\n\n        _eventName = \"LogMint(uint256,uint256,uint256,uint256,int24,int24)\";\n        _eventParam = abi.encode(_tokenId, liquidity, amountA, amountB, params.tickLower, params.tickUpper);\n    }\n\n    /**\n     * @dev Increases liquidity in an existing position\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @param amountA Amount of tokenA to add\n     * @param amountB Amount of tokenB to add\n     * @param slippage Maximum allowed slippage in basis points\n     * @param getIds Array of IDs to retrieve token amounts [amtAId, amtBId]\n     * @param setId ID to store the new liquidity amount\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function deposit(\n        uint256 tokenId,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 slippage,\n        uint256[] calldata getIds,\n        uint256 setId\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        amountA = getUint(getIds[0], amountA);\n        amountB = getUint(getIds[1], amountB);\n        (uint256 _liquidity, uint256 _amtA, uint256 _amtB) = _addLiquidityWrapper(tokenId, amountA, amountB, slippage);\n        setUint(setId, _liquidity);\n\n        _eventName = \"LogDeposit(uint256,uint256,uint256,uint256)\";\n        _eventParam = abi.encode(tokenId, _liquidity, _amtA, _amtB);\n    }\n\n    /**\n     * @dev Decreases liquidity from a position\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @param liquidity Amount of liquidity to remove\n     * @param amountAMin Minimum amount of tokenA to receive\n     * @param amountBMin Minimum amount of tokenB to receive\n     * @param getId ID to retrieve liquidity amount\n     * @param setIds Array of IDs to store withdrawn amounts [amtAId, amtBId]\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function withdraw(\n        uint256 tokenId,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 getId,\n        uint256[] calldata setIds\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        uint128 _liquidity = uint128(getUint(getId, liquidity));\n\n        (uint256 _amtA, uint256 _amtB) = _decreaseLiquidity(tokenId, _liquidity, amountAMin, amountBMin);\n\n        setUint(setIds[0], _amtA);\n        setUint(setIds[1], _amtB);\n\n        _eventName = \"LogWithdraw(uint256,uint256,uint256,uint256)\";\n        _eventParam = abi.encode(tokenId, _liquidity, _amtA, _amtB);\n    }\n\n    /**\n     * @dev Collects accumulated fees from a position\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @param amount0Max Maximum amount of token0 to collect\n     * @param amount1Max Maximum amount of token1 to collect\n     * @param getIds Array of IDs to retrieve max amounts [amount0MaxId, amount1MaxId]\n     * @param setIds Array of IDs to store collected amounts [amount0Id, amount1Id]\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function collect(\n        uint256 tokenId,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256[] calldata getIds,\n        uint256[] calldata setIds\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        uint128 _amount0Max = uint128(getUint(getIds[0], amount0Max));\n        uint128 _amount1Max = uint128(getUint(getIds[1], amount1Max));\n        (uint256 amount0, uint256 amount1) = _collect(tokenId, _amount0Max, _amount1Max);\n\n        setUint(setIds[0], amount0);\n        setUint(setIds[1], amount1);\n        _eventName = \"LogCollect(uint256,uint256,uint256)\";\n        _eventParam = abi.encode(tokenId, amount0, amount1);\n    }\n\n    /**\n     * @dev Burns an NFT position after all liquidity has been withdrawn\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function burn(uint256 tokenId) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        _burn(tokenId);\n        _eventName = \"LogBurnPosition(uint256)\";\n        _eventParam = abi.encode(tokenId);\n    }\n}\n\n/**\n * @title Uniswap V3 Position Connector\n * @dev Connector contract for integrating Uniswap V3 position management\n */\ncontract ConnectV1UniswapV3Position is UniswapV3PositionResolver {\n    /// @dev Connector name for identification\n    string public constant name = \"UniswapV3-position-v1.0.0\";\n\n    constructor(address _nftManager, address _wethAddr, address _tadleMemory, address _uniswapV3Factory)\n        UniswapV3PositionResolver(_nftManager, _wethAddr, _tadleMemory, _uniswapV3Factory)\n    {}\n}\n"
    }
}