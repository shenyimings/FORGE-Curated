{
    "vfp_id": "vfp_00173",
    "project_name": "Jovay Sequencer System Contracts Audit.md",
    "findings": [
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Function Visibility Overly Permissive",
            "description": "Several functions across multiple contracts are declared with more permissive visibility than necessary, which could potentially allow unintended access from derived contracts or external callers. The root cause is the use of `internal` or `public` visibility when `private` or `external` would be sufficient based on the function's intended use. For instance, utility functions like `_fromHexChar` and `sliceBytes` are marked `internal` but are only used within their defining contract, making them candidates for `private`. Similarly, getter functions like `getSuperAdmin` are `public` but could be `external` to save gas. While this does not directly lead to fund loss, it increases the attack surface and reduces code clarity. An attacker could potentially exploit overly public functions if future code changes introduce vulnerabilities in those entry points. The impact is primarily on code maintainability, gas efficiency, and security hygiene.\n",
            "severity": "Medium",
            "location": [
                "permission_control.sol::checkSuperPermission#14-20",
                "permission_control.sol::checkAdminPermission#22-28",
                "permission_control.sol::checkGrantPermission#30-38",
                "permission_control.sol::getSuperAdmin#54-56",
                "permission_control.sol::getGranteeAdmin#59-61",
                "rule_mng.sol::addRule#128-144",
                "rule_mng.sol::updateRule#158-190",
                "rule_mng.sol::delRule#196-242",
                "rule_mng.sol::getAllRules#245-259",
                "rule_mng.sol::getNextId#262-264",
                "rule_mng.sol::getContractRules#267-275",
                "rule_mng.sol::updateProvingResult#283-310",
                "rule_mng.sol::getSuperAdmin#372-374",
                "rule_mng.sol::getGranteeAdmin#377-379",
                "sys_chaincfg.sol::changeSys#33-38",
                "sys_chaincfg.sol::get_config#40-50",
                "sys_chaincfg.sol::get_configs#52-58",
                "sys_staking.sol::hexStringToBytes#2442-2465",
                "sys_staking.sol::sliceBytes#2467-2477",
                "sys_staking.sol::_fromHexChar#2479-2490",
                "sys_staking.sol::isArrayContains#2492-2502",
                "sys_staking.sol::isValidatorPendingExit#2512-2516",
                "sys_staking.sol::_transferTo#2518-2552",
                "sys_staking.sol::advanceEpoch#2579-2583",
                "sys_staking.sol::setChainEpochBlock#2606-2622",
                "sys_staking.sol::getWithdrawEffectiveWindow#2644-2648",
                "sys_staking.sol::getChainCfg#2650-2655"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        }
    ],
    "affected_files": {
        "permission_control.sol": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.20;\n\ncontract PermissionControl {\n    address private administrator_;\n    // todo add grants admin\n    address [] private grantees_;\n\n    constructor() {\n        administrator_ = msg.sender;\n    }\n\n    function checkSuperPermission(address _addr) internal view returns(bool) {\n        if (_addr == administrator_ || _addr == address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function checkAdminPermission(address _addr) internal view returns(bool) {\n        if (checkSuperPermission(_addr) || checkGrantPermission(_addr)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function checkGrantPermission(address _addr) internal view returns(bool) {\n        for (uint256 i = 0; i < grantees_.length; i++) {\n            if (grantees_[i] == _addr) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    event SuperTransferred(\n        address old_administrator_,\n        address new_administrator_\n    );\n    function tranferSuperAdmin(address _new_admin) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(administrator_ != _new_admin, \"Permission denied, same address\");\n\n        address old_admin = administrator_;\n        administrator_ = _new_admin;\n        emit SuperTransferred(old_admin, _new_admin);\n    }\n\n    // return administrator_\n    function getSuperAdmin() public view returns (address) {\n        return administrator_;\n    }\n\n    // return administrator_\n    function getGranteeAdmin() public view returns ( address[] memory) {\n        return grantees_;\n    }\n\n    event AdminGranted(\n        address grantee\n    );\n    function grantAdmin(address _addr) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(!checkGrantPermission(_addr), \"Address already exist in grantees\");\n\n        grantees_.push(_addr);\n        emit AdminGranted(_addr);\n    }\n    event AdminRevoked(\n        address revoker\n    );\n    function revokeAdmin(address _addr) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(checkGrantPermission(_addr), \"Address not exist in grantees\");\n\n        for (uint256 i = 0; i < grantees_.length; i++) {\n            if (grantees_[i] == _addr) {\n                grantees_[i] = grantees_[grantees_.length - 1];\n                grantees_.pop();\n                break;\n            }\n        }\n\n        emit AdminRevoked(_addr);\n    }\n}"
    }
}