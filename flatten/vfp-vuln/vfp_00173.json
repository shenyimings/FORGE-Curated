{
    "vfp_id": "vfp_00173",
    "project_name": "P2P.org Resolv Integration Security Audit Report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Profit Misclassification Due to Stale Rewards Calculation",
            "description": "The _withdraw() function calculates accruedRewards before calling the external withdrawal function. However, in the ResolvStaking contract, the withdrawal triggers a checkpoint() that updates and transfers newly accrued rewards to the proxy. Because the reward snapshot was taken before this update, the newly transferred rewards are not included in the accruedRewards calculation and are instead treated as principal. This results in fees being undercharged on the newly accrued portion, causing revenue loss for the protocol.\nThe root cause is the incorrect ordering of balance measurement and external call execution. An attacker cannot directly exploit this, but all users benefit from reduced fees on checkpoint-triggered rewards. The impact is systematic loss of protocol fees and inaccurate accounting, where s_totalWithdrawn is inflated and getUserPrincipal() is deflated over time.\n",
            "severity": "Medium",
            "location": [
                "P2pYieldProxy.sol::_withdraw",
                "ResolvStaking.sol::withdraw",
                "ResolvStaking.sol::checkpoint"
            ],
            "files": [
                "P2pResolvProxy/src/p2pYieldProxy/P2pYieldProxy.sol"
            ]
        }
    ],
    "affected_files": {
        "P2pYieldProxy.sol": "// SPDX-FileCopyrightText: 2025 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.30;\n\nimport \"../@openzeppelin/contracts-upgradable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../@openzeppelin/contracts/utils/Address.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"../common/AllowedCalldataChecker.sol\";\nimport \"../p2pYieldProxyFactory/IP2pYieldProxyFactory.sol\";\nimport \"../structs/P2pStructs.sol\";\nimport \"./IP2pYieldProxy.sol\";\n\nerror P2pYieldProxy__ZeroAddressAsset();\nerror P2pYieldProxy__ZeroAssetAmount();\nerror P2pYieldProxy__ZeroSharesAmount();\nerror P2pYieldProxy__InvalidClientBasisPoints(uint96 _clientBasisPoints);\nerror P2pYieldProxy__NotFactory(address _factory);\nerror P2pYieldProxy__DifferentActuallyDepositedAmount(\n    uint256 _requestedAmount,\n    uint256 _actualAmount\n);\nerror P2pYieldProxy__NotFactoryCalled(\n    address _msgSender,\n    IP2pYieldProxyFactory _actualFactory\n);\nerror P2pYieldProxy__NotClientCalled(\n    address _msgSender,\n    address _actualClient\n);\nerror P2pYieldProxy__ZeroAddressFactory();\nerror P2pYieldProxy__ZeroAddressP2pTreasury();\nerror P2pYieldProxy__ZeroAllowedCalldataChecker();\nerror P2pYieldProxy__DataTooShort();\n\n/// @title P2pYieldProxy\n/// @notice P2pYieldProxy is a contract that allows a client to deposit and withdraw assets from a yield protocol.\nabstract contract P2pYieldProxy is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    ERC165,\n    IP2pYieldProxy {\n\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @dev P2pYieldProxyFactory\n    IP2pYieldProxyFactory internal immutable i_factory;\n\n    /// @dev P2pTreasury\n    address internal immutable i_p2pTreasury;\n\n    IAllowedCalldataChecker internal immutable i_allowedCalldataChecker;\n\n    /// @dev Client\n    address internal s_client;\n\n    /// @dev Client basis points\n    uint96 internal s_clientBasisPoints;\n\n    // asset => amount\n    mapping(address => uint256) internal s_totalDeposited;\n\n    // asset => amount\n    mapping(address => Withdrawn) internal s_totalWithdrawn;\n\n    /// @notice If caller is not factory, revert\n    modifier onlyFactory() {\n        if (msg.sender != address(i_factory)) {\n            revert P2pYieldProxy__NotFactoryCalled(msg.sender, i_factory);\n        }\n        _;\n    }\n\n    /// @notice If caller is not client, revert\n    modifier onlyClient() {\n        if (msg.sender != s_client) {\n            revert P2pYieldProxy__NotClientCalled(msg.sender, s_client);\n        }\n        _;\n    }\n\n    /// @dev Modifier for checking if a calldata is allowed\n    /// @param _yieldProtocolAddress The address of the yield protocol\n    /// @param _yieldProtocolCalldata The calldata (encoded signature + arguments) to be passed to the yield protocol\n    modifier calldataShouldBeAllowed(\n        address _yieldProtocolAddress,\n        bytes calldata _yieldProtocolCalldata\n    ) {\n        // validate yieldProtocolCalldata for yieldProtocolAddress\n        bytes4 selector = _getFunctionSelector(_yieldProtocolCalldata);\n        i_allowedCalldataChecker.checkCalldata(\n            _yieldProtocolAddress,\n            selector,\n            _yieldProtocolCalldata[4:]\n        );\n        _;\n    }\n\n    /// @notice Constructor for P2pYieldProxy\n    /// @param _factory The factory address\n    /// @param _p2pTreasury The P2pTreasury address\n    /// @param _allowedCalldataChecker AllowedCalldataChecker\n    constructor(\n        address _factory,\n        address _p2pTreasury,\n        address _allowedCalldataChecker\n    ) {\n        require(_factory != address(0), P2pYieldProxy__ZeroAddressFactory());\n        i_factory = IP2pYieldProxyFactory(_factory);\n\n        require(_p2pTreasury != address(0), P2pYieldProxy__ZeroAddressP2pTreasury());\n        i_p2pTreasury = _p2pTreasury;\n\n        require (_allowedCalldataChecker != address(0), P2pYieldProxy__ZeroAllowedCalldataChecker());\n        i_allowedCalldataChecker = IAllowedCalldataChecker(_allowedCalldataChecker);\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function initialize(\n        address _client,\n        uint96 _clientBasisPoints\n    )\n    external\n    initializer\n    onlyFactory\n    {\n        __ReentrancyGuard_init();\n\n        require(\n            _clientBasisPoints > 0 && _clientBasisPoints <= 10_000,\n            P2pYieldProxy__InvalidClientBasisPoints(_clientBasisPoints)\n        );\n\n        s_client = _client;\n        s_clientBasisPoints = _clientBasisPoints;\n\n        emit P2pYieldProxy__Initialized();\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /// @notice Deposit assets into yield protocol\n    /// @param _yieldProtocolAddress yield protocol address\n    /// @param _yieldProtocolDepositCalldata calldata for deposit function of yield protocol\n    /// @param _asset asset to deposit\n    /// @param _amount amount to deposit\n    function _deposit(\n        address _yieldProtocolAddress,\n        bytes memory _yieldProtocolDepositCalldata,\n        address _asset,\n        uint256 _amount\n    )\n    internal\n    onlyFactory\n    {\n        require (_asset != address(0), P2pYieldProxy__ZeroAddressAsset());\n        require (_amount > 0, P2pYieldProxy__ZeroAssetAmount());\n\n        address client = s_client;\n\n        uint256 assetAmountBefore = IERC20(_asset).balanceOf(address(this));\n\n        // transfer tokens into Proxy\n        IERC20(_asset).safeTransferFrom(\n            client,\n            address(this),\n            _amount\n        );\n\n        uint256 assetAmountAfter = IERC20(_asset).balanceOf(address(this));\n        uint256 actualAmount = assetAmountAfter - assetAmountBefore;\n\n        require (\n            actualAmount == _amount,\n            P2pYieldProxy__DifferentActuallyDepositedAmount(_amount, actualAmount)\n        ); // no support for fee-on-transfer or rebasing tokens\n\n        uint256 totalDepositedAfter = s_totalDeposited[_asset] + actualAmount;\n        s_totalDeposited[_asset] = totalDepositedAfter;\n        emit P2pYieldProxy__Deposited(\n            _yieldProtocolAddress,\n            _asset,\n            actualAmount,\n            totalDepositedAfter\n        );\n\n        IERC20(_asset).safeIncreaseAllowance(\n            _yieldProtocolAddress,\n            actualAmount\n        );\n\n        _yieldProtocolAddress.functionCall(_yieldProtocolDepositCalldata);\n    }\n\n    /// @notice Withdraw assets from yield protocol\n    /// @param _yieldProtocolAddress yield protocol address\n    /// @param _asset ERC-20 asset address\n    /// @param _yieldProtocolWithdrawalCalldata calldata for withdraw function of yield protocol\n    function _withdraw(\n        address _yieldProtocolAddress,\n        address _asset,\n        bytes memory _yieldProtocolWithdrawalCalldata\n    )\n    internal\n    {\n        _withdraw(_yieldProtocolAddress, _asset, _yieldProtocolWithdrawalCalldata, false);\n    }\n\n    /// @notice Withdraw assets from yield protocol\n    /// @param _yieldProtocolAddress yield protocol address\n    /// @param _asset ERC-20 asset address\n    /// @param _yieldProtocolWithdrawalCalldata calldata for withdraw function of yield protocol\n    /// @param _rewardsOnly if true, prioritize treating the withdrawal as profit (used by operator reward flows)\n    function _withdraw(\n        address _yieldProtocolAddress,\n        address _asset,\n        bytes memory _yieldProtocolWithdrawalCalldata,\n        bool _rewardsOnly\n    )\n    internal\n    nonReentrant\n    {\n        int256 accruedRewardsBefore = calculateAccruedRewards(_yieldProtocolAddress, _asset);\n\n        uint256 assetAmountBefore = IERC20(_asset).balanceOf(address(this));\n\n        // withdraw assets from Protocol\n        _yieldProtocolAddress.functionCall(_yieldProtocolWithdrawalCalldata);\n\n        uint256 assetAmountAfter = IERC20(_asset).balanceOf(address(this));\n\n        uint256 newAssetAmount = assetAmountAfter - assetAmountBefore;\n\n        Withdrawn memory withdrawn = s_totalWithdrawn[_asset];\n        bool isClient = msg.sender == s_client;\n        uint256 remainingPrincipal = s_totalDeposited[_asset] > withdrawn.amount\n            ? s_totalDeposited[_asset] - withdrawn.amount\n            : 0;\n        bool isClosingWithdrawal = isClient && withdrawn.amount + newAssetAmount >= s_totalDeposited[_asset];\n\n        uint256 positiveAccruedRewards = accruedRewardsBefore > 0\n            ? uint256(accruedRewardsBefore)\n            : 0;\n\n        uint256 profitFromAccrued = newAssetAmount > positiveAccruedRewards\n            ? positiveAccruedRewards\n            : newAssetAmount;\n\n        uint256 remainingAfterAccrued = newAssetAmount - profitFromAccrued;\n\n        uint256 principalPortion;\n        uint256 profitPortion;\n\n        if (_rewardsOnly) {\n            profitPortion = profitFromAccrued;\n            uint256 remainingAfterProfit = newAssetAmount - profitPortion;\n            principalPortion = remainingAfterProfit > remainingPrincipal\n                ? remainingPrincipal\n                : remainingAfterProfit;\n        } else {\n            if (isClosingWithdrawal) {\n                if (newAssetAmount > remainingPrincipal) {\n                    principalPortion = remainingPrincipal;\n                    profitPortion = newAssetAmount - remainingPrincipal;\n                } else {\n                    principalPortion = newAssetAmount;\n                    profitPortion = 0;\n                }\n            } else {\n                principalPortion = remainingAfterAccrued > remainingPrincipal\n                    ? remainingPrincipal\n                    : remainingAfterAccrued;\n\n                uint256 extraProfit = remainingAfterAccrued - principalPortion;\n                profitPortion = profitFromAccrued + extraProfit;\n            }\n        }\n\n        uint256 totalWithdrawnBefore = uint256(withdrawn.amount);\n        uint256 totalWithdrawnAfter = totalWithdrawnBefore + principalPortion;\n\n        // update total withdrawn\n        withdrawn.amount = uint208(totalWithdrawnAfter);\n        withdrawn.lastFeeCollectionTime = uint48(block.timestamp);\n        s_totalWithdrawn[_asset] = withdrawn;\n\n        uint256 p2pAmount;\n        if (profitPortion > 0) {\n            // That extra 9999 ensures that any nonzero remainder will push the result up by 1 (ceiling division).\n            p2pAmount = calculateP2pFeeAmount(profitPortion);\n        }\n        uint256 clientAmount = newAssetAmount - p2pAmount;\n\n        if (p2pAmount > 0) {\n            IERC20(_asset).safeTransfer(i_p2pTreasury, p2pAmount);\n        }\n        // clientAmount must be > 0 at this point\n        IERC20(_asset).safeTransfer(s_client, clientAmount);\n\n        emit P2pYieldProxy__Withdrawn(\n            _yieldProtocolAddress,\n            _yieldProtocolAddress,\n            _asset,\n            newAssetAmount,\n            totalWithdrawnAfter,\n            int256(profitPortion),\n            p2pAmount,\n            clientAmount\n        );\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function callAnyFunction(\n        address _yieldProtocolAddress,\n        bytes calldata _yieldProtocolCalldata\n    )\n    external\n    onlyClient\n    nonReentrant\n    calldataShouldBeAllowed(_yieldProtocolAddress, _yieldProtocolCalldata)\n    {\n        emit P2pYieldProxy__CalledAsAnyFunction(_yieldProtocolAddress);\n        _yieldProtocolAddress.functionCall(_yieldProtocolCalldata);\n    }\n\n    /// @notice Returns function selector (first 4 bytes of data)\n    /// @param _data calldata (encoded signature + arguments)\n    /// @return functionSelector function selector\n    function _getFunctionSelector(\n        bytes calldata _data\n    ) private pure returns (bytes4 functionSelector) {\n        require (_data.length >= 4, P2pYieldProxy__DataTooShort());\n        return bytes4(_data[:4]);\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function getFactory() external view returns (address) {\n        return address(i_factory);\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function getP2pTreasury() external view returns (address) {\n        return i_p2pTreasury;\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function getClient() external view returns (address) {\n        return s_client;\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function getClientBasisPoints() external view returns (uint96) {\n        return s_clientBasisPoints;\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function getTotalDeposited(address _asset) external view returns (uint256) {\n        return s_totalDeposited[_asset];\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function getTotalWithdrawn(address _asset) external view returns (uint256) {\n        return s_totalWithdrawn[_asset].amount;\n    }\n\n    function getUserPrincipal(address _asset) public view returns(uint256) {\n        uint256 totalDeposited = s_totalDeposited[_asset];\n        uint256 totalWithdrawn = s_totalWithdrawn[_asset].amount;\n        if (totalDeposited > totalWithdrawn) {\n            return totalDeposited - totalWithdrawn;\n        }\n        return 0;\n    }\n\n    function calculateAccruedRewards(address _yieldProtocolAddress, address _asset) public view virtual returns(int256) {\n        uint256 currentAmount = _getCurrentAssetAmount(_yieldProtocolAddress, _asset);\n        uint256 userPrincipal = getUserPrincipal(_asset);\n        return int256(currentAmount) - int256(userPrincipal);\n    }\n\n    function _getCurrentAssetAmount(address _yieldProtocolAddress, address _asset) internal view virtual returns (uint256);\n\n    function getLastFeeCollectionTime(address _asset) public view returns(uint48) {\n        return s_totalWithdrawn[_asset].lastFeeCollectionTime;\n    }\n\n    /// @notice Calculates P2P treasury fee amount using ceiling division\n    /// @param _amount amount\n    /// @return p2pFeeAmount p2p fee amount\n    function calculateP2pFeeAmount(uint256 _amount) internal view returns (uint256 p2pFeeAmount) {\n        if (_amount == 0) return 0;\n        p2pFeeAmount = (_amount * (10_000 - s_clientBasisPoints) + 9999) / 10_000;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IP2pYieldProxy).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    }
}