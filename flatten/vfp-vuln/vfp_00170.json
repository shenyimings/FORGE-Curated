{
    "vfp_id": "vfp_00170",
    "project_name": "Flare FAsset Review - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "The upgradeWNatContract function must now be called by governance or executor",
            "description": "1. **Description:** The upgradeWNatContract function in AgentCollateralFacet.sol previously allowed any agent vault owner to update the WNAT contract address, creating a risk of inconsistent state updates between the asset manager and collateral pool if the agent failed to act promptly.\n\n2. **Cause:** The access control was too permissive, relying only on onlyAgentVaultOwner, which allowed individual agents to trigger the upgrade. This could lead to accounting discrepancies if the collateral pool was not updated in sync.\n\n3. **Exploitation:** A malicious or negligent agent could delay or manipulate the update of the WNAT address in the collateral pool, leading to incorrect collateral accounting and potential financial loss.\n\n4. **Impact:** The inconsistency between contract states could result in incorrect collateral tracking, potentially leading to under- or over-collateralization and financial risk to the system.\n",
            "severity": "High",
            "location": [
                "AgentCollateralFacet.sol::upgradeWNatContract#(unknown line)"
            ],
            "files": [
                "fassets/contracts/assetManager/facets/AgentCollateralFacet.sol"
            ]
        }
    ],
    "affected_files": {
        "AgentCollateralFacet.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ReentrancyGuard} from \"../../openzeppelin/security/ReentrancyGuard.sol\";\nimport {AssetManagerBase} from \"./AssetManagerBase.sol\";\nimport {AgentCollateral} from \"../library/AgentCollateral.sol\";\nimport {Globals} from \"../library/Globals.sol\";\nimport {Liquidation} from \"../library/Liquidation.sol\";\nimport {Agents} from \"../library/Agents.sol\";\nimport {AgentUpdates} from \"../library/AgentUpdates.sol\";\nimport {Agent} from \"../library/data/Agent.sol\";\nimport {AssetManagerState} from \"../library/data/AssetManagerState.sol\";\nimport {Collateral} from \"../library/data/Collateral.sol\";\nimport {IWNat} from \"../../flareSmartContracts/interfaces/IWNat.sol\";\nimport {SafePct} from \"../../utils/library/SafePct.sol\";\nimport {CollateralType} from \"../../userInterfaces/data/CollateralType.sol\";\nimport {AssetManagerSettings} from \"../../userInterfaces/data/AssetManagerSettings.sol\";\nimport {IAssetManagerEvents} from \"../../userInterfaces/IAssetManagerEvents.sol\";\n\n\ncontract AgentCollateralFacet is AssetManagerBase, ReentrancyGuard {\n    using SafePct for uint256;\n    using SafeCast for uint256;\n    using AgentCollateral for Collateral.Data;\n    using Agents for Agent.State;\n    using AgentUpdates for Agent.State;\n\n    error WithdrawalInvalidAgentStatus();\n    error WithdrawalNotAnnounced();\n    error WithdrawalMoreThanAnnounced();\n    error WithdrawalNotAllowedYet();\n    error WithdrawalTooLate();\n    error WithdrawalCRTooLow();\n    error WithdrawalValueTooHigh();\n\n    error OnlyAgentVaultOrPool();\n    error CollateralWithdrawalAnnounced();\n    error FAssetNotTerminated();\n\n    /**\n     * Agent is going to withdraw `_valueNATWei` amount of collateral from agent vault.\n     * This has to be announced and agent must then wait `withdrawalWaitMinSeconds` time.\n     * After that time, agent can call withdraw(_valueNATWei) on agent vault.\n     * NOTE: may only be called by the agent vault owner.\n     * @param _agentVault agent vault address\n     * @param _valueNATWei the amount to be withdrawn\n     * @return _withdrawalAllowedAt the timestamp when the withdrawal can be made\n     */\n    function announceVaultCollateralWithdrawal(\n        address _agentVault,\n        uint256 _valueNATWei\n    )\n        external\n        notEmergencyPaused\n        onlyAgentVaultOwner(_agentVault)\n        returns (uint256 _withdrawalAllowedAt)\n    {\n        return _announceWithdrawal(Collateral.Kind.VAULT, _agentVault, _valueNATWei);\n    }\n\n    /**\n     * Agent is going to withdraw `_valueNATWei` amount of collateral from agent vault.\n     * This has to be announced and agent must then wait `withdrawalWaitMinSeconds` time.\n     * After that time, agent can call withdraw(_valueNATWei) on agent vault.\n     * NOTE: may only be called by the agent vault owner.\n     * @param _agentVault agent vault address\n     * @param _valueNATWei the amount to be withdrawn\n     * @return _redemptionAllowedAt the timestamp when the redemption can be made\n     */\n    function announceAgentPoolTokenRedemption(\n        address _agentVault,\n        uint256 _valueNATWei\n    )\n        external\n        notEmergencyPaused\n        onlyAgentVaultOwner(_agentVault)\n        returns (uint256 _redemptionAllowedAt)\n    {\n        return _announceWithdrawal(Collateral.Kind.AGENT_POOL, _agentVault, _valueNATWei);\n    }\n\n    /**\n     * Called by AgentVault when agent calls `withdraw()`.\n     * NOTE: may only be called from an agent vault, not from an EOA address.\n     * @param _amountWei the withdrawn amount\n     */\n    function beforeCollateralWithdrawal(\n        IERC20 _token,\n        uint256 _amountWei\n    )\n        external\n        notFullyEmergencyPaused\n    {\n        Agent.State storage agent = Agent.get(msg.sender);\n        Collateral.Kind kind;\n        if (_token == agent.getVaultCollateralToken()) {\n            kind = Collateral.Kind.VAULT;\n        } else if (_token == agent.collateralPool.poolToken()) {\n            kind = Collateral.Kind.AGENT_POOL;\n        } else {\n            return;     // we don't care about other token withdrawals from agent vault\n        }\n        Agent.WithdrawalAnnouncement storage withdrawal = agent.withdrawalAnnouncement(kind);\n        Collateral.Data memory collateralData = AgentCollateral.singleCollateralData(agent, kind);\n        // only agents that are not being liquidated can withdraw\n        // however, if the agent is in FULL_LIQUIDATION and totally liquidated,\n        // the withdrawals must still be possible, otherwise the collateral gets locked forever\n        require(agent.status == Agent.Status.NORMAL || agent.totalBackedAMG() == 0, WithdrawalInvalidAgentStatus());\n        require(withdrawal.allowedAt != 0, WithdrawalNotAnnounced());\n        require(_amountWei <= withdrawal.amountWei, WithdrawalMoreThanAnnounced());\n        require(block.timestamp >= withdrawal.allowedAt, WithdrawalNotAllowedYet());\n        AssetManagerSettings.Data storage settings = Globals.getSettings();\n        require(block.timestamp <= withdrawal.allowedAt + settings.agentTimelockedOperationWindowSeconds,\n            WithdrawalTooLate());\n        // Check that withdrawal doesn't reduce CR below mintingCR (withdrawal is not executed yet, but it balances\n        // with the withdrawal announcement that is still in effect).\n        // This would be equivalent to `collateralData.freeCollateralWei >= 0` if freeCollateralWei was signed,\n        // but actually freeCollateralWei always returns positive part, so it cannot be used in this test.\n        require(collateralData.lockedCollateralWei(agent) <= collateralData.fullCollateral, WithdrawalCRTooLow());\n        // (partially) clear withdrawal announcement\n        uint256 remaining = withdrawal.amountWei - _amountWei;    // guarded by above require\n        withdrawal.amountWei = uint128(remaining);\n        if (remaining == 0) {\n            withdrawal.allowedAt = 0;\n        }\n    }\n\n    /**\n     * Called by AgentVault or CollateralPool when there was a deposit.\n     * May pull agent out of liquidation.\n     * NOTE: may only be called from an agent vault or collateral pool, not from an EOA address.\n     */\n    function updateCollateral(\n        address _agentVault,\n        IERC20 _token\n    )\n        // no emergency pause check to allow change token / deposit collateral\n        external\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        require(msg.sender == _agentVault || msg.sender == address(agent.collateralPool),\n            OnlyAgentVaultOrPool());\n        // try to pull agent out of liquidation\n        if (agent.isCollateralToken(_token)) {\n            Liquidation.endLiquidationIfHealthy(agent);\n        }\n    }\n\n    /**\n     * When current pool collateral token contract (WNat) is replaced by the method setPoolWNatCollateralType,\n     * pools don't switch automatically. Instead, the agent must call this method that swaps old WNat tokens for\n     * new ones and sets it for use by the pool.\n     * NOTE: may only be called by the agent vault owner.\n     */\n    function upgradeWNatContract(\n        uint256 _start,\n        uint256 _end\n    )\n        external\n        onlyImmediateGovernanceOrExecutor\n    {\n        (address[] memory agentVaults,) = Agents.getAllAgents(_start, _end);\n        for (uint256 i = 0; i < agentVaults.length; i++) {\n            _upgradeWNatContract(agentVaults[i]);\n        }\n    }\n\n    function _upgradeWNatContract(\n        address _agentVault\n    )\n        private\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        AssetManagerState.State storage state = AssetManagerState.get();\n        IWNat wNat = IWNat(address(state.collateralTokens[state.poolCollateralIndex].token));\n        // upgrade pool wnat\n        if (agent.poolCollateralIndex != state.poolCollateralIndex) {\n            agent.poolCollateralIndex = state.poolCollateralIndex;\n            agent.collateralPool.upgradeWNatContract(wNat);\n            emit IAssetManagerEvents.AgentCollateralTypeChanged(_agentVault,\n                uint8(CollateralType.Class.POOL), address(wNat));\n        }\n    }\n\n    function _announceWithdrawal(\n        Collateral.Kind _kind,\n        address _agentVault,\n        uint256 _amountWei\n    )\n        private\n        returns (uint256)\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        // only agents that are not being liquidated can withdraw\n        // however, if the agent is in FULL_LIQUIDATION and totally liquidated,\n        // the withdrawals must still be possible, otherwise the collateral gets locked forever\n        require(agent.status == Agent.Status.NORMAL || agent.totalBackedAMG() == 0, WithdrawalInvalidAgentStatus());\n        Agent.WithdrawalAnnouncement storage withdrawal = agent.withdrawalAnnouncement(_kind);\n        if (_amountWei > withdrawal.amountWei) {\n            AssetManagerSettings.Data storage settings = Globals.getSettings();\n            Collateral.Data memory collateralData = AgentCollateral.singleCollateralData(agent, _kind);\n            // announcement increased - must check there is enough free collateral and then lock it\n            // in this case the wait to withdrawal restarts from this moment\n            uint256 increase = _amountWei - withdrawal.amountWei;\n            require(increase <= collateralData.freeCollateralWei(agent), WithdrawalValueTooHigh());\n            withdrawal.allowedAt = (block.timestamp + settings.withdrawalWaitMinSeconds).toUint64();\n        } else {\n            // announcement decreased or cancelled\n            // if value is 0, we cancel announcement completely (i.e. set announcement time to 0)\n            // otherwise, for decreasing announcement, we can safely leave announcement time unchanged\n            if (_amountWei == 0) {\n                withdrawal.allowedAt = 0;\n            }\n        }\n        withdrawal.amountWei = _amountWei.toUint128();\n        if (_kind == Collateral.Kind.VAULT) {\n            emit IAssetManagerEvents.VaultCollateralWithdrawalAnnounced(_agentVault, _amountWei, withdrawal.allowedAt);\n        } else {\n            emit IAssetManagerEvents.PoolTokenRedemptionAnnounced(_agentVault, _amountWei, withdrawal.allowedAt);\n        }\n        return withdrawal.allowedAt;\n    }\n}"
    }
}