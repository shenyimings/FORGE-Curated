{
    "vfp_id": "vfp_00223",
    "project_name": "SSO Account Abstraction Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Lack of Output Validation Can Lock the SsoAccount",
            "description": "The SsoAccount contract and its managers use OpenZeppelin's EnumerableSet library to manage sets of hooks, owners, and validators. However, the code does not check the boolean return values of the `add` and `remove` functions, incorrectly assuming that these operations will revert on failure. This leads to silent failures where operations appear to succeed but do not modify the set.\n\nThe root cause is the lack of validation of return values from `add` and `remove` calls in the `HookManager`, `OwnerManager`, and `ValidatorManager` contracts. As a result, when a user attempts to remove a hook with an incorrect `isValidation` flag, the removal fails silently, but the `onUninstall` function is still called. This can lead to inconsistent state in the hook, potentially causing future transaction validations to fail.\n\nAn attacker or user error could exploit this by calling `removeHook` or `unlinkHook` with the wrong flag, leading to a situation where the hook believes it is uninstalled but remains in the list, or vice versa. Similarly, attempting to add a duplicate owner or validator does not change the set but still emits events, misleading off-chain indexers.\n\nThe impact includes potential permanent lockup of the account if a critical hook enters an inconsistent state, or incorrect state tracking by external services relying on emitted events. This could prevent the account from executing any further transactions, resulting in a denial of service.\n",
            "severity": "High",
            "location": [
                "HookManager.sol::removeHook#35-44",
                "OwnerManager.sol::addOwner#40-50",
                "ValidatorManager.sol::addValidator#28-43",
                "HookManager.sol::unlinkHook#35-44",
                "OwnerManager.sol::removeOwner#40-50",
                "ValidatorManager.sol::removeValidator#28-43"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol",
                "zksync-sso-clave-contracts/src/managers/OwnerManager.sol",
                "zksync-sso-clave-contracts/src/managers/ValidatorManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Adding or Removing Execution Hooks Causes Unexpected Behaviour",
            "description": "The HookManager uses a modifier `runExecutionHooks` that iterates over a list of execution hooks before and after transaction execution. However, if the transaction itself adds or removes an execution hook, the loop that runs the `postExecutionHook` functions can go out of bounds or execute hooks in an incorrect order.\n\nThe cause lies in the use of a cached `totalHooks` variable at the start of the loop, while the underlying set is modified during execution. Since the OpenZeppelin EnumerableSet does not guarantee ordering, removing a hook during execution can cause the loop to access an index that no longer exists, causing a revert. Similarly, adding a hook may result in it being executed in the post-hook phase while others are skipped.\n\nAn attacker or user attempting to remove an execution hook would find the transaction reverting due to the out-of-bounds access. This effectively prevents the removal of execution hooks, creating a denial of service. Additionally, inconsistent hook execution order can lead to state corruption in hooks that depend on execution sequence.\n\nThe impact is an inability to manage execution hooks safely, potentially locking the account into unwanted hook behavior. This undermines the flexibility of the account abstraction model and could prevent necessary upgrades or security fixes.\n",
            "severity": "Medium",
            "location": [
                "HookManager.sol::runExecutionHooks#77",
                "HookManager.sol::postExecutionHook#87-89"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol"
            ]
        }
    ],
    "affected_files": {
        "ValidatorManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { ExcessivelySafeCall } from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\nimport { Auth } from \"../auth/Auth.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { IValidatorManager } from \"../interfaces/IValidatorManager.sol\";\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\n\n/**\n * @title Manager contract for validators\n * @notice Abstract contract for managing the validators of the account\n * @dev Validators are stored in an enumerable set\n * @author https://getclave.io\n */\nabstract contract ValidatorManager is IValidatorManager, Auth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  // Interface helper library\n  using ERC165Checker for address;\n  // Low level calls helper library\n  using ExcessivelySafeCall for address;\n\n  ///@inheritdoc IValidatorManager\n  function addModuleValidator(address validator, bytes calldata initData) external onlySelf {\n    _addModuleValidator(validator, initData);\n  }\n\n  ///@inheritdoc IValidatorManager\n  function removeModuleValidator(address validator, bytes calldata deinitData) external onlySelf {\n    _removeModuleValidator(validator);\n    IModule(validator).onUninstall(deinitData);\n  }\n\n  ///@inheritdoc IValidatorManager\n  function unlinkModuleValidator(address validator, bytes calldata deinitData) external onlySelf {\n    _removeModuleValidator(validator);\n    validator.excessivelySafeCall(gasleft(), 0, abi.encodeWithSelector(IModule.onUninstall.selector, deinitData));\n  }\n\n  /// @inheritdoc IValidatorManager\n  function isModuleValidator(address validator) external view override returns (bool) {\n    return _isModuleValidator(validator);\n  }\n\n  /// @inheritdoc IValidatorManager\n  function listModuleValidators() external view override returns (address[] memory validatorList) {\n    validatorList = _moduleValidators().values();\n  }\n\n  function _addModuleValidator(address validator, bytes memory initData) internal {\n    if (!_supportsModuleValidator(validator)) {\n      revert Errors.VALIDATOR_ERC165_FAIL(validator);\n    }\n\n    _moduleValidators().add(validator);\n    IModule(validator).onInstall(initData);\n\n    emit ValidatorAdded(validator);\n  }\n\n  function _removeModuleValidator(address validator) internal {\n    _moduleValidators().remove(validator);\n\n    emit ValidatorRemoved(validator);\n  }\n\n  function _isModuleValidator(address validator) internal view returns (bool) {\n    return _moduleValidators().contains(validator);\n  }\n\n  function _supportsModuleValidator(address validator) private view returns (bool) {\n    return\n      validator.supportsInterface(type(IModuleValidator).interfaceId) &&\n      validator.supportsInterface(type(IModule).interfaceId);\n  }\n\n  function _moduleValidators() private view returns (EnumerableSet.AddressSet storage moduleValidators) {\n    moduleValidators = SsoStorage.layout().moduleValidators;\n  }\n}\n",
        "HookManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { ExcessivelySafeCall } from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\nimport { Auth } from \"../auth/Auth.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { IExecutionHook, IValidationHook } from \"../interfaces/IHook.sol\";\nimport { IHookManager } from \"../interfaces/IHookManager.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\n\n/**\n * @title Manager contract for hooks\n * @notice Abstract contract for managing the enabled hooks of the account\n * @dev Hook addresses are stored in a linked list\n * @author https://getclave.io\n */\nabstract contract HookManager is IHookManager, Auth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  // Interface helper library\n  using ERC165Checker for address;\n  // Low level calls helper library\n  using ExcessivelySafeCall for address;\n\n  /// @inheritdoc IHookManager\n  function addHook(address hook, bool isValidation, bytes calldata initData) external override onlySelf {\n    _addHook(hook, isValidation, initData);\n  }\n\n  /// @inheritdoc IHookManager\n  function removeHook(address hook, bool isValidation, bytes calldata deinitData) external override onlySelf {\n    _removeHook(hook, isValidation);\n    IModule(hook).onUninstall(deinitData);\n  }\n\n  /// @inheritdoc IHookManager\n  function unlinkHook(address hook, bool isValidation, bytes calldata deinitData) external onlySelf {\n    _removeHook(hook, isValidation);\n    hook.excessivelySafeCall(gasleft(), 0, abi.encodeWithSelector(IModule.onUninstall.selector, deinitData));\n  }\n\n  /// @inheritdoc IHookManager\n  function isHook(address addr) external view override returns (bool) {\n    return _isHook(addr);\n  }\n\n  /// @inheritdoc IHookManager\n  function listHooks(bool isValidation) external view override returns (address[] memory hookList) {\n    if (isValidation) {\n      hookList = _validationHooks().values();\n    } else {\n      hookList = _executionHooks().values();\n    }\n  }\n\n  // Runs the validation hooks that are enabled by the account and returns true if none reverts\n  function runValidationHooks(bytes32 signedHash, Transaction calldata transaction) internal returns (bool) {\n    EnumerableSet.AddressSet storage hookList = _validationHooks();\n    uint256 totalHooks = hookList.length();\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      bool success = _call(hookList.at(i), abi.encodeCall(IValidationHook.validationHook, (signedHash, transaction)));\n\n      if (!success) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Runs the execution hooks that are enabled by the account before and after _executeTransaction\n  modifier runExecutionHooks(Transaction calldata transaction) {\n    EnumerableSet.AddressSet storage hookList = _executionHooks();\n    uint256 totalHooks = hookList.length();\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      IExecutionHook(hookList.at(i)).preExecutionHook(transaction);\n    }\n\n    _;\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      IExecutionHook(hookList.at(i)).postExecutionHook();\n    }\n  }\n\n  function _addHook(address hook, bool isValidation, bytes calldata initData) internal {\n    if (!_supportsHook(hook, isValidation)) {\n      revert Errors.HOOK_ERC165_FAIL(hook, isValidation);\n    }\n\n    if (isValidation) {\n      _validationHooks().add(hook);\n    } else {\n      _executionHooks().add(hook);\n    }\n\n    IModule(hook).onInstall(initData);\n\n    emit HookAdded(hook);\n  }\n\n  function _removeHook(address hook, bool isValidation) internal {\n    if (isValidation) {\n      _validationHooks().remove(hook);\n    } else {\n      _executionHooks().remove(hook);\n    }\n\n    emit HookRemoved(hook);\n  }\n\n  function _isHook(address addr) internal view override returns (bool) {\n    return _validationHooks().contains(addr) || _executionHooks().contains(addr);\n  }\n\n  function _call(address target, bytes memory data) private returns (bool success) {\n    assembly (\"memory-safe\") {\n      success := call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  function _validationHooks() private view returns (EnumerableSet.AddressSet storage validationHooks) {\n    validationHooks = SsoStorage.layout().validationHooks;\n  }\n\n  function _executionHooks() private view returns (EnumerableSet.AddressSet storage executionHooks) {\n    executionHooks = SsoStorage.layout().executionHooks;\n  }\n\n  function _supportsHook(address hook, bool isValidation) private view returns (bool) {\n    return\n      hook.supportsInterface(type(IModule).interfaceId) &&\n      (\n        isValidation\n          ? hook.supportsInterface(type(IValidationHook).interfaceId)\n          : hook.supportsInterface(type(IExecutionHook).interfaceId)\n      );\n  }\n}\n",
        "OwnerManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Auth } from \"../auth/Auth.sol\";\nimport { IOwnerManager } from \"../interfaces/IOwnerManager.sol\";\n\n/**\n * @title Manager contract for owners\n * @notice Abstract contract for managing the owners of the account\n * @dev K1 Owners are secp256k1 addresses\n * @dev Owners are stored in a linked list\n * @author https://getclave.io\n */\nabstract contract OwnerManager is IOwnerManager, Auth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @inheritdoc IOwnerManager\n  function k1AddOwner(address addr) external override onlySelf {\n    _k1AddOwner(addr);\n  }\n\n  /// @inheritdoc IOwnerManager\n  function k1RemoveOwner(address addr) external override onlySelf {\n    _k1RemoveOwner(addr);\n  }\n\n  /// @inheritdoc IOwnerManager\n  function k1IsOwner(address addr) external view override returns (bool) {\n    return _k1IsOwner(addr);\n  }\n\n  /// @inheritdoc IOwnerManager\n  function k1ListOwners() external view override returns (address[] memory k1OwnerList) {\n    k1OwnerList = _k1Owners().values();\n  }\n\n  function _k1AddOwner(address addr) internal {\n    _k1Owners().add(addr);\n\n    emit K1AddOwner(addr);\n  }\n\n  function _k1RemoveOwner(address addr) internal {\n    _k1Owners().remove(addr);\n\n    emit K1RemoveOwner(addr);\n  }\n\n  function _k1IsOwner(address addr) internal view returns (bool) {\n    return _k1Owners().contains(addr);\n  }\n\n  function _k1Owners() private view returns (EnumerableSet.AddressSet storage k1Owners) {\n    k1Owners = SsoStorage.layout().k1Owners;\n  }\n}\n"
    }
}