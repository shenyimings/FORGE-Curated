{
    "vfp_id": "vfp_00073",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of approval reset on buffer allows anyone to drain the Vault",
            "description": "The lack of approval reset after the call to deposit allows a malicious wrapper contract to steal the Vault’s funds. When wrapping tokens, the _wrapWithBuffer function allows the wrapped token contract to transfer the underlying tokens via ERC20 approval. However, since the approval is not reset to zero after the deposit call, a malicious wrapper contract can retain the approval and later withdraw the Vault's funds after it has been locked. This vulnerability arises from improper handling of ERC20 approvals and trust in external contracts without proper safeguards. An attacker can exploit this by creating a malicious wrapper that does nothing during deposit, thereby preserving the approval, and later directly transferring the tokens out. The impact is critical as it allows an attacker to drain all of the Vault’s tokens for any underlying asset.\n",
            "severity": "High",
            "location": [
                "Vault.sol::deposit#1169-1172",
                "Vault.sol::erc4626BufferWrapOrUnwrap",
                "https://github.com/balancer/balancer-v3-monorepo/pull/855"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Lack of reserve updates when collecting fees allows anyone to drain the Vault",
            "description": "The Vault fails to update its internal reserves after collecting fees, leading to a discrepancy between the recorded reserves and actual token balance. When fees are collected via collectAggregateFees, the tokens are transferred out but the Vault's reserve accounting remains unchanged. This causes the Vault to believe it holds more tokens than it actually does. The root cause is the omission of a reserve update step after fee collection. An attacker can exploit this by using the erc4626BufferWrapOrUnwrap function, which relies on reserve accounting to determine how many tokens to credit. By manipulating this discrepancy with a malicious wrapper contract, the attacker can withdraw tokens corresponding to the difference. The impact is high, as this can be repeated to drain the entire Vault of all its assets.\n",
            "severity": "High",
            "location": [
                "VaultAdmin.sol::collectAggregateFees#273-295",
                "Vault.sol::_updateReservesAfterWrapping#1367-1390",
                "https://github.com/balancer/balancer-v3-monorepo/pull/857"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-454"
                ]
            },
            "title": "Vault can be drained by updating the buffer underlying token",
            "description": "A malicious user can drain the Vault by manipulating the underlying token of a buffer. The erc4626BufferWrapOrUnwrap function allows wrapping via uninitialized buffers, and the addLiquidityToBuffer function does not prevent changes to the underlying token. An attacker can first wrap a worthless token into a buffer, then change the underlying token to a valuable one (e.g., DAI), and withdraw the full balance of that token. The root cause is the lack of a check ensuring that a buffer must be explicitly initialized before interaction and that the underlying token cannot be changed after initialization. Exploitation involves creating a malicious wrapper token, inflating buffer balances with a worthless token, switching the underlying token, and withdrawing the real assets. The impact is high, as it allows complete draining of any token in the Vault.\n",
            "severity": "High",
            "location": [
                "Vault.sol::erc4626BufferWrapOrUnwrap#1054-1108",
                "Vault.sol::_wrapWithBuffer#1117-1238",
                "VaultAdmin.sol::addLiquidityToBuffer#415-465",
                "https://github.com/balancer/balancer-v3-monorepo/pull/881"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Yield fees collected when exiting recovery mode will be lost",
            "description": "When a pool exits recovery mode, yield fees that are accrued during the disableRecoveryMode call are removed from the pool balance but not credited to the aggregate fee balance, resulting in permanent loss. The issue arises because _setPoolRecoveryMode sets the recovery mode flag to false before updating balances, causing _loadPoolData to accrue yield fees. However, there is no mechanism to transfer these fees to the ProtocolFeeController. The root cause is incorrect ordering of state updates. An attacker cannot directly exploit this for profit, but can trigger the condition by forcing a pool into recovery mode and waiting for yield accumulation. The impact is medium, as it leads to loss of fees that should have been distributed to stakeholders, affecting economic fairness.\n",
            "severity": "Medium",
            "location": [
                "VaultAdmin.sol::disableRecoveryMode#352-355",
                "VaultAdmin.sol::_setPoolRecoveryMode#374-383",
                "PoolDataLib.sol::load#31-64",
                "PoolDataLib.sol::load#49-91",
                "https://github.com/balancer/balancer-v3-monorepo/pull/880"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/lib/PoolDataLib.sol"
            ]
        }
    ],
    "affected_files": {
        "Vault.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IVaultExtension } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultExtension.sol\";\nimport { IVaultMain } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultMain.sol\";\nimport { IBasePool } from \"@balancer-labs/v3-interfaces/contracts/vault/IBasePool.sol\";\nimport { IHooks } from \"@balancer-labs/v3-interfaces/contracts/vault/IHooks.sol\";\nimport { IPoolLiquidity } from \"@balancer-labs/v3-interfaces/contracts/vault/IPoolLiquidity.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { EVMCallModeHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/EVMCallModeHelpers.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { CastingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/CastingHelpers.sol\";\nimport { InputHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/InputHelpers.sol\";\nimport {\n    TransientStorageHelpers\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/TransientStorageHelpers.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { BasePoolMath } from \"@balancer-labs/v3-solidity-utils/contracts/math/BasePoolMath.sol\";\nimport { StorageSlotExtension } from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/StorageSlotExtension.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\nimport { BufferHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/BufferHelpers.sol\";\n\nimport { VaultStateLib, VaultStateBits } from \"./lib/VaultStateLib.sol\";\nimport { PoolConfigLib } from \"./lib/PoolConfigLib.sol\";\nimport { HooksConfigLib } from \"./lib/HooksConfigLib.sol\";\nimport { PoolDataLib } from \"./lib/PoolDataLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\ncontract Vault is IVaultMain, VaultCommon, Proxy {\n    using PackedTokenBalance for bytes32;\n    using BufferHelpers for bytes32;\n    using InputHelpers for uint256;\n    using FixedPoint for *;\n    using Address for *;\n    using CastingHelpers for uint256[];\n    using SafeERC20 for IERC20;\n    using PoolConfigLib for PoolConfigBits;\n    using HooksConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using ScalingHelpers for *;\n    using TransientStorageHelpers for *;\n    using StorageSlotExtension for *;\n    using PoolDataLib for PoolData;\n\n    IVaultExtension private immutable _vaultExtension;\n\n    constructor(IVaultExtension vaultExtension, IAuthorizer authorizer, IProtocolFeeController protocolFeeController) {\n        if (address(vaultExtension.vault()) != address(this)) {\n            revert WrongVaultExtensionDeployment();\n        }\n\n        if (address(protocolFeeController.vault()) != address(this)) {\n            revert WrongProtocolFeeControllerDeployment();\n        }\n\n        _vaultExtension = vaultExtension;\n        _protocolFeeController = protocolFeeController;\n\n        _vaultPauseWindowEndTime = IVaultAdmin(address(vaultExtension)).getPauseWindowEndTime();\n        _vaultBufferPeriodDuration = IVaultAdmin(address(vaultExtension)).getBufferPeriodDuration();\n        _vaultBufferPeriodEndTime = IVaultAdmin(address(vaultExtension)).getBufferPeriodEndTime();\n\n        _authorizer = authorizer;\n    }\n\n    /*******************************************************************************\n                              Transient Accounting\n    *******************************************************************************/\n\n    /**\n     * @dev This modifier is used for functions that temporarily modify the token deltas\n     * of the Vault, but expect to revert or settle balances by the end of their execution.\n     * It works by ensuring that the balances are properly settled by the time the last\n     * operation is executed.\n     *\n     * This is useful for functions like `unlock`, which perform arbitrary external calls:\n     * we can keep track of temporary deltas changes, and make sure they are settled by the\n     * time the external call is complete.\n     */\n    modifier transient() {\n        bool isUnlockedBefore = _isUnlocked().tload();\n\n        if (isUnlockedBefore == false) {\n            _isUnlocked().tstore(true);\n        }\n\n        // The caller does everything here and has to settle all outstanding balances\n        _;\n\n        if (isUnlockedBefore == false) {\n            if (_nonZeroDeltaCount().tload() != 0) {\n                revert BalanceNotSettled();\n            }\n\n            _isUnlocked().tstore(false);\n        }\n    }\n\n    /// @inheritdoc IVaultMain\n    function unlock(bytes calldata data) external transient returns (bytes memory result) {\n        return (msg.sender).functionCall(data);\n    }\n\n    /// @inheritdoc IVaultMain\n    function settle(IERC20 token, uint256 amountHint) external nonReentrant onlyWhenUnlocked returns (uint256 credit) {\n        uint256 reservesBefore = _reservesOf[token];\n        uint256 currentReserves = token.balanceOf(address(this));\n        _reservesOf[token] = currentReserves;\n        credit = currentReserves - reservesBefore;\n\n        // If the given hint is equal or greater to the reserve difference, we just take the actual reserve difference\n        // as the paid amount; the actual balance of the tokens in the vault is what matters here.\n        if (credit > amountHint) {\n            // If the difference in reserves is higher than the amount claimed to be paid by the caller, there was some\n            // leftover that had been sent to the vault beforehand, which was not incorporated into the reserves.\n            // In that case, we simply discard the leftover by considering the given hint as the amount paid.\n            // In turn, this gives the caller credit for the given amount hint, which is what the caller is expecting.\n            credit = amountHint;\n        }\n\n        _supplyCredit(token, credit);\n    }\n\n    /// @inheritdoc IVaultMain\n    function sendTo(IERC20 token, address to, uint256 amount) external nonReentrant onlyWhenUnlocked {\n        _takeDebt(token, amount);\n        _reservesOf[token] -= amount;\n\n        token.safeTransfer(to, amount);\n    }\n\n    /*******************************************************************************\n                                    Pool Operations\n    *******************************************************************************/\n\n    // The Vault performs all upscaling and downscaling (due to token decimals, rates, etc.), so that the pools\n    // don't have to. However, scaling inevitably leads to rounding errors, so we take great care to ensure that\n    // any rounding errors favor the Vault. An important invariant of the system is that there is no repeatable\n    // path where tokensOut > tokensIn.\n    //\n    // In general, this means rounding up any values entering the Vault, and rounding down any values leaving\n    // the Vault, so that external users either pay a little extra or receive a little less in the case of a\n    // rounding error.\n    //\n    // However, it's not always straightforward to determine the correct rounding direction, given the presence\n    // and complexity of intermediate steps. An \"amountIn\" sounds like it should be rounded up: but only if that\n    // is the amount actually being transferred. If instead it is an amount sent to the pool math, where rounding\n    // up would result in a *higher* calculated amount out, that would favor the user instead of the Vault. So in\n    // that case, amountIn should be rounded down.\n    //\n    // See comments justifying the rounding direction in each case.\n    //\n    // This reasoning applies to Weighted Pool math, and is likely to apply to others as well, but of course\n    // it's possible a new pool type might not conform. Duplicate the tests for new pool types (e.g., Stable Math).\n    // Also, the final code should ensure that we are not relying entirely on the rounding directions here,\n    // but have enough additional layers (e.g., minimum amounts, buffer wei on all transfers) to guarantee safety,\n    // even if it turns out these directions are incorrect for a new pool type.\n\n    /*******************************************************************************\n                                          Swaps\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function swap(\n        SwapParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256 amountCalculated, uint256 amountIn, uint256 amountOut)\n    {\n        _ensureUnpaused(params.pool);\n\n        if (params.amountGivenRaw == 0) {\n            revert AmountGivenZero();\n        }\n\n        if (params.tokenIn == params.tokenOut) {\n            revert CannotSwapSameToken();\n        }\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the swap hooks are reentrant and could do anything, including\n        // change these balances, we cannot defer settlement until `_swap`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances`, `_aggregateFeeAmounts`\n        // in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_DOWN);\n\n        // State is fully populated here, and shall not be modified at a lower level.\n        SwapState memory state = _loadSwapState(params, poolData);\n\n        PoolSwapParams memory swapParams = _buildPoolSwapParams(params, state, poolData);\n\n        if (poolData.poolConfigBits.shouldCallBeforeSwap()) {\n            HooksConfigLib.callBeforeSwapHook(swapParams, params.pool, _hooksContracts[params.pool]);\n\n            // The call to `onBeforeSwap` could potentially update token rates and balances.\n            // We update `poolData.tokenRates`, `poolData.rawBalances` and `poolData.balancesLiveScaled18`\n            // to ensure the `onSwap` and `onComputeDynamicSwapFeePercentage` are called with the current values.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_DOWN);\n\n            // Also update amountGivenScaled18, as it will now be used in the swap, and the rates might have changed.\n            state.amountGivenScaled18 = _computeAmountGivenScaled18(params, poolData, state);\n\n            swapParams = _buildPoolSwapParams(params, state, poolData);\n        }\n\n        _ensureValidTradeAmount(state.amountGivenScaled18);\n\n        // Note that this must be called *after* the before hook, to guarantee that the swap params are the same\n        // as those passed to the main operation.\n        //\n        // At this point, the static swap fee percentage is loaded in the swap state as the default, to be used\n        // unless the pool has a dynamic swap fee. It is also passed into the hook, to support common cases\n        // where the dynamic fee computation logic uses it.\n        if (poolData.poolConfigBits.shouldCallComputeDynamicSwapFee()) {\n            (bool dynamicSwapFeeCalculated, uint256 dynamicSwapFee) = HooksConfigLib.callComputeDynamicSwapFeeHook(\n                swapParams,\n                params.pool,\n                state.swapFeePercentage,\n                _hooksContracts[params.pool]\n            );\n\n            if (dynamicSwapFeeCalculated) {\n                state.swapFeePercentage = dynamicSwapFee;\n            }\n        }\n\n        // Non-reentrant call that updates accounting.\n        // The following side-effects are important to note:\n        // PoolData balancesRaw and balancesLiveScaled18 are adjusted for swap amounts and fees inside of _swap.\n        uint256 amountCalculatedScaled18;\n        (amountCalculated, amountCalculatedScaled18, amountIn, amountOut) = _swap(params, state, poolData, swapParams);\n\n        _ensureValidTradeAmount(amountCalculatedScaled18);\n\n        // The new amount calculated is 'amountCalculated + delta'. If the underlying hook fails, or limits are\n        // violated, `onAfterSwap` will revert. Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterSwap()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountCalculated = poolData.poolConfigBits.callAfterSwapHook(\n                amountCalculatedScaled18,\n                amountCalculated,\n                msg.sender,\n                params,\n                state,\n                poolData,\n                hooksContract\n            );\n        }\n\n        if (params.kind == SwapKind.EXACT_IN) {\n            amountOut = amountCalculated;\n        } else {\n            amountIn = amountCalculated;\n        }\n    }\n\n    function _loadSwapState(\n        SwapParams memory params,\n        PoolData memory poolData\n    ) private pure returns (SwapState memory state) {\n        state.indexIn = _findTokenIndex(poolData.tokens, params.tokenIn);\n        state.indexOut = _findTokenIndex(poolData.tokens, params.tokenOut);\n\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        state.amountGivenScaled18 = _computeAmountGivenScaled18(params, poolData, state);\n        state.swapFeePercentage = poolData.poolConfigBits.getStaticSwapFeePercentage();\n    }\n\n    function _buildPoolSwapParams(\n        SwapParams memory params,\n        SwapState memory state,\n        PoolData memory poolData\n    ) internal view returns (PoolSwapParams memory) {\n        // Uses msg.sender as the router (the contract that called the vault)\n        return\n            PoolSwapParams({\n                kind: params.kind,\n                amountGivenScaled18: state.amountGivenScaled18,\n                balancesScaled18: poolData.balancesLiveScaled18,\n                indexIn: state.indexIn,\n                indexOut: state.indexOut,\n                router: msg.sender,\n                userData: params.userData\n            });\n    }\n\n    /**\n     * @dev Preconditions: decimalScalingFactors and tokenRates in `poolData` must be current.\n     * Uses amountGivenRaw and kind from `params`.\n     */\n    function _computeAmountGivenScaled18(\n        SwapParams memory params,\n        PoolData memory poolData,\n        SwapState memory state\n    ) private pure returns (uint256) {\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        return\n            params.kind == SwapKind.EXACT_IN\n                ? params.amountGivenRaw.toScaled18ApplyRateRoundDown(\n                    poolData.decimalScalingFactors[state.indexIn],\n                    poolData.tokenRates[state.indexIn]\n                )\n                : params.amountGivenRaw.toScaled18ApplyRateRoundUp(\n                    poolData.decimalScalingFactors[state.indexOut],\n                    poolData.tokenRates[state.indexOut]\n                );\n    }\n\n    struct SwapInternalLocals {\n        uint256 swapFeeAmountScaled18;\n        uint256 swapFeeIndex;\n        IERC20 swapFeeToken;\n        uint256 balanceInIncrement;\n        uint256 balanceOutDecrement;\n        uint256 swapFeeAmountRaw;\n    }\n\n    /**\n     * @dev Main non-reentrant portion of the swap, which calls the pool hook and updates accounting. `vaultSwapParams`\n     * are passed to the pool's `onSwap` hook.\n     *\n     * Preconditions: complete `SwapParams`, `SwapState`, and `PoolData`.\n     * Side effects: mutates balancesRaw and balancesLiveScaled18 in `poolData`.\n     * Updates `_aggregateFeeAmounts`, and `_poolTokenBalances` in storage.\n     * Emits Swap event.\n     */\n    function _swap(\n        SwapParams memory params,\n        SwapState memory state,\n        PoolData memory poolData,\n        PoolSwapParams memory swapParams\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256 amountCalculatedRaw,\n            uint256 amountCalculatedScaled18,\n            uint256 amountInRaw,\n            uint256 amountOutRaw\n        )\n    {\n        SwapInternalLocals memory locals;\n\n        // Perform the swap request hook and compute the new balances for 'token in' and 'token out' after the swap.\n        amountCalculatedScaled18 = IBasePool(params.pool).onSwap(swapParams);\n\n        // Note that balances are kept in memory, and are not fully computed until the `setPoolBalances` below.\n        // Intervening code cannot read balances from storage, as they are temporarily out-of-sync here. This function\n        // is nonReentrant, to guard against read-only reentrancy issues.\n\n        // (1) and (2): get raw amounts and check limits.\n        if (params.kind == SwapKind.EXACT_IN) {\n            // Swap fee is always a percentage of the amountCalculated. On ExactIn, subtract it from the calculated\n            // amountOut. Round up to avoid losses during precision loss.\n            locals.swapFeeAmountScaled18 = amountCalculatedScaled18.mulUp(state.swapFeePercentage);\n\n            // Need to update `amountCalculatedScaled18` for the onAfterSwap hook.\n            amountCalculatedScaled18 -= locals.swapFeeAmountScaled18;\n\n            // For `ExactIn` the amount calculated is leaving the Vault, so we round down.\n            amountCalculatedRaw = amountCalculatedScaled18.toRawUndoRateRoundDown(\n                poolData.decimalScalingFactors[state.indexOut],\n                poolData.tokenRates[state.indexOut]\n            );\n\n            (amountInRaw, amountOutRaw) = (params.amountGivenRaw, amountCalculatedRaw);\n\n            if (amountOutRaw < params.limitRaw) {\n                revert SwapLimit(amountOutRaw, params.limitRaw);\n            }\n        } else {\n            // To ensure symmetry with EXACT_IN, the swap fee used by ExactOut is\n            // `amountCalculated * fee% / (100% - fee%)`. Add it to the calculated amountIn. Round up to avoid losses\n            // during precision loss.\n            locals.swapFeeAmountScaled18 = amountCalculatedScaled18.mulDivUp(\n                state.swapFeePercentage,\n                state.swapFeePercentage.complement()\n            );\n\n            amountCalculatedScaled18 += locals.swapFeeAmountScaled18;\n\n            // For `ExactOut` the amount calculated is entering the Vault, so we round up.\n            amountCalculatedRaw = amountCalculatedScaled18.toRawUndoRateRoundUp(\n                poolData.decimalScalingFactors[state.indexIn],\n                poolData.tokenRates[state.indexIn]\n            );\n\n            (amountInRaw, amountOutRaw) = (amountCalculatedRaw, params.amountGivenRaw);\n\n            if (amountInRaw > params.limitRaw) {\n                revert SwapLimit(amountInRaw, params.limitRaw);\n            }\n        }\n\n        // 3) Deltas: debit for token in, credit for token out.\n        _takeDebt(params.tokenIn, amountInRaw);\n        _supplyCredit(params.tokenOut, amountOutRaw);\n\n        // 4) Compute and charge protocol and creator fees.\n        (locals.swapFeeIndex, locals.swapFeeToken) = params.kind == SwapKind.EXACT_IN\n            ? (state.indexOut, params.tokenOut)\n            : (state.indexIn, params.tokenIn);\n\n        // Note that protocol fee storage is updated before balance storage, as the final raw balances need to take\n        // the fees into account.\n        uint256 totalFeesRaw = _computeAndChargeAggregateSwapFees(\n            poolData,\n            locals.swapFeeAmountScaled18,\n            params.pool,\n            locals.swapFeeToken,\n            locals.swapFeeIndex\n        );\n\n        // 5) Pool balances: raw and live.\n        //\n        // Adjust for raw swap amounts and total fees on the calculated end.\n        // So that fees are always subtracted from pool balances:\n        // For ExactIn, we increase the tokenIn balance by `amountIn`, and decrease the tokenOut balance by the\n        // (`amountOut` + fees).\n        // For ExactOut, we increase the tokenInBalance by (`amountIn` - fees), and decrease the tokenOut balance by\n        // `amountOut`.\n        (locals.balanceInIncrement, locals.balanceOutDecrement) = params.kind == SwapKind.EXACT_IN\n            ? (amountInRaw, amountOutRaw + totalFeesRaw)\n            : (amountInRaw - totalFeesRaw, amountOutRaw);\n\n        poolData.updateRawAndLiveBalance(\n            state.indexIn,\n            poolData.balancesRaw[state.indexIn] + locals.balanceInIncrement,\n            Rounding.ROUND_UP\n        );\n        poolData.updateRawAndLiveBalance(\n            state.indexOut,\n            poolData.balancesRaw[state.indexOut] - locals.balanceOutDecrement,\n            Rounding.ROUND_DOWN\n        );\n\n        // 6) Store pool balances, raw and live (only index in and out).\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[params.pool];\n        poolBalances[state.indexIn] = PackedTokenBalance.toPackedBalance(\n            poolData.balancesRaw[state.indexIn],\n            poolData.balancesLiveScaled18[state.indexIn]\n        );\n        poolBalances[state.indexOut] = PackedTokenBalance.toPackedBalance(\n            poolData.balancesRaw[state.indexOut],\n            poolData.balancesLiveScaled18[state.indexOut]\n        );\n\n        // 7) Off-chain events.\n        // Since the swapFeeAmountScaled18 (derived from scaling up either the amountGiven or amountCalculated)\n        // also contains the rate, undo it when converting to raw.\n        locals.swapFeeAmountRaw = locals.swapFeeAmountScaled18.toRawUndoRateRoundDown(\n            poolData.decimalScalingFactors[locals.swapFeeIndex],\n            poolData.tokenRates[locals.swapFeeIndex]\n        );\n\n        emit Swap(\n            params.pool,\n            params.tokenIn,\n            params.tokenOut,\n            amountInRaw,\n            amountOutRaw,\n            state.swapFeePercentage,\n            locals.swapFeeAmountRaw,\n            locals.swapFeeToken\n        );\n    }\n\n    /***************************************************************************\n                                   Add Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function addLiquidity(\n        AddLiquidityParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData)\n    {\n        // Round balances up when adding liquidity:\n        // If proportional, higher balances = higher proportional amountsIn, favoring the pool.\n        // If unbalanced, higher balances = lower invariant ratio with fees.\n        // bptOut = supply * (ratio - 1), so lower ratio = less bptOut, favoring the pool.\n\n        _ensureUnpaused(params.pool);\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the add liquidity hooks are reentrant and could do anything,\n        // including change these balances, we cannot defer settlement until `_addLiquidity`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances`, and\n        // `_aggregateFeeAmounts` in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_UP);\n        InputHelpers.ensureInputLengthMatch(poolData.tokens.length, params.maxAmountsIn.length);\n\n        // Amounts are entering pool math, so round down.\n        // Introducing `maxAmountsInScaled18` here and passing it through to _addLiquidity is not ideal,\n        // but it avoids the even worse options of mutating amountsIn inside AddLiquidityParams,\n        // or cluttering the AddLiquidityParams interface by adding amountsInScaled18.\n        uint256[] memory maxAmountsInScaled18 = params.maxAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        if (poolData.poolConfigBits.shouldCallBeforeAddLiquidity()) {\n            HooksConfigLib.callBeforeAddLiquidityHook(\n                msg.sender,\n                maxAmountsInScaled18,\n                params,\n                poolData,\n                _hooksContracts[params.pool]\n            );\n            // The hook might have altered the balances, so we need to read them again to ensure that the data\n            // are fresh moving forward. We also need to upscale (adding liquidity, so round up) again.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_UP);\n\n            // Also update maxAmountsInScaled18, as the rates might have changed.\n            maxAmountsInScaled18 = params.maxAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, and the final balances\n        // are computed. This function is non-reentrant, as it performs the accounting updates.\n        //\n        // Note that poolData is mutated to update the Raw and Live balances, so they are accurate when passed\n        // into the AfterAddLiquidity hook.\n        //\n        // `amountsInScaled18` will be overwritten in the custom case, so we need to pass it back and forth to\n        // encapsulate that logic in `_addLiquidity`.\n        uint256[] memory amountsInScaled18;\n        (amountsIn, amountsInScaled18, bptAmountOut, returnData) = _addLiquidity(\n            poolData,\n            params,\n            maxAmountsInScaled18\n        );\n\n        // AmountsIn can be changed by onAfterAddLiquidity if the hook charges fees or gives discounts.\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterAddLiquidity()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountsIn = poolData.poolConfigBits.callAfterAddLiquidityHook(\n                msg.sender,\n                amountsInScaled18,\n                amountsIn,\n                bptAmountOut,\n                params,\n                poolData,\n                hooksContract\n            );\n        }\n    }\n\n    // Avoid \"stack too deep\" - without polluting the Add/RemoveLiquidity params interface.\n    struct LiquidityLocals {\n        uint256 numTokens;\n        uint256 totalFeesRaw;\n        uint256 tokenIndex;\n    }\n\n    /**\n     * @dev Calls the appropriate pool hook and calculates the required inputs and outputs for the operation\n     * considering the given kind, and updates the vault's internal accounting. This includes:\n     * - Setting pool balances\n     * - Taking debt from the liquidity provider\n     * - Minting pool tokens\n     * - Emitting events\n     *\n     * It is non-reentrant, as it performs external calls and updates the vault's state accordingly.\n     */\n    function _addLiquidity(\n        PoolData memory poolData,\n        AddLiquidityParams memory params,\n        uint256[] memory maxAmountsInScaled18\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256[] memory amountsInRaw,\n            uint256[] memory amountsInScaled18,\n            uint256 bptAmountOut,\n            bytes memory returnData\n        )\n    {\n        LiquidityLocals memory locals;\n        locals.numTokens = poolData.tokens.length;\n        uint256[] memory swapFeeAmountsScaled18;\n\n        if (params.kind == AddLiquidityKind.PROPORTIONAL) {\n            bptAmountOut = params.minBptAmountOut;\n            // Initializes the swapFeeAmountsScaled18 empty array (no swap fees on proportional add liquidity).\n            swapFeeAmountsScaled18 = new uint256[](locals.numTokens);\n\n            amountsInScaled18 = BasePoolMath.computeProportionalAmountsIn(\n                poolData.balancesLiveScaled18,\n                _totalSupply(params.pool),\n                bptAmountOut\n            );\n        } else if (params.kind == AddLiquidityKind.DONATION) {\n            poolData.poolConfigBits.requireDonationEnabled();\n\n            swapFeeAmountsScaled18 = new uint256[](maxAmountsInScaled18.length);\n            bptAmountOut = 0;\n            amountsInScaled18 = maxAmountsInScaled18;\n        } else if (params.kind == AddLiquidityKind.UNBALANCED) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n\n            amountsInScaled18 = maxAmountsInScaled18;\n            (bptAmountOut, swapFeeAmountsScaled18) = BasePoolMath.computeAddLiquidityUnbalanced(\n                poolData.balancesLiveScaled18,\n                maxAmountsInScaled18,\n                _totalSupply(params.pool),\n                poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                IBasePool(params.pool)\n            );\n        } else if (params.kind == AddLiquidityKind.SINGLE_TOKEN_EXACT_OUT) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n\n            bptAmountOut = params.minBptAmountOut;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(maxAmountsInScaled18);\n\n            amountsInScaled18 = maxAmountsInScaled18;\n            (amountsInScaled18[locals.tokenIndex], swapFeeAmountsScaled18) = BasePoolMath\n                .computeAddLiquiditySingleTokenExactOut(\n                    poolData.balancesLiveScaled18,\n                    locals.tokenIndex,\n                    bptAmountOut,\n                    _totalSupply(params.pool),\n                    poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                    IBasePool(params.pool)\n                );\n        } else if (params.kind == AddLiquidityKind.CUSTOM) {\n            poolData.poolConfigBits.requireAddCustomLiquidityEnabled();\n\n            // Uses msg.sender as the router (the contract that called the vault).\n            (amountsInScaled18, bptAmountOut, swapFeeAmountsScaled18, returnData) = IPoolLiquidity(params.pool)\n                .onAddLiquidityCustom(\n                    msg.sender,\n                    maxAmountsInScaled18,\n                    params.minBptAmountOut,\n                    poolData.balancesLiveScaled18,\n                    params.userData\n                );\n        } else {\n            revert InvalidAddLiquidityKind();\n        }\n\n        // At this point we have the calculated BPT amount.\n        if (bptAmountOut < params.minBptAmountOut) {\n            revert BptAmountOutBelowMin(bptAmountOut, params.minBptAmountOut);\n        }\n\n        _ensureValidTradeAmount(bptAmountOut);\n\n        amountsInRaw = new uint256[](locals.numTokens);\n\n        for (uint256 i = 0; i < locals.numTokens; ++i) {\n            uint256 amountInRaw;\n\n            // 1) Calculate raw amount in.\n            {\n                uint256 amountInScaled18 = amountsInScaled18[i];\n                _ensureValidTradeAmount(amountInScaled18);\n\n                // amountsInRaw are amounts actually entering the Pool, so we round up.\n                // Do not mutate in place yet, as we need them scaled for the `onAfterAddLiquidity` hook.\n                amountInRaw = amountInScaled18.toRawUndoRateRoundUp(\n                    poolData.decimalScalingFactors[i],\n                    poolData.tokenRates[i]\n                );\n\n                amountsInRaw[i] = amountInRaw;\n            }\n\n            IERC20 token = poolData.tokens[i];\n\n            // 2) Check limits for raw amounts.\n            if (amountInRaw > params.maxAmountsIn[i]) {\n                revert AmountInAboveMax(token, amountInRaw, params.maxAmountsIn[i]);\n            }\n\n            // 3) Deltas: Debit of token[i] for amountInRaw.\n            _takeDebt(token, amountInRaw);\n\n            // 4) Compute and charge protocol and creator fees.\n            locals.totalFeesRaw = _computeAndChargeAggregateSwapFees(\n                poolData,\n                swapFeeAmountsScaled18[i],\n                params.pool,\n                token,\n                i\n            );\n\n            // 5) Pool balances: raw and live.\n            // We need regular balances to complete the accounting, and the upscaled balances\n            // to use in the `after` hook later on.\n\n            // A pool's token balance increases by amounts in after adding liquidity, minus fees.\n            poolData.updateRawAndLiveBalance(\n                i,\n                poolData.balancesRaw[i] + amountInRaw - locals.totalFeesRaw,\n                Rounding.ROUND_UP\n            );\n        }\n\n        // 6) Store pool balances, raw and live.\n        _writePoolBalancesToStorage(params.pool, poolData);\n\n        // 7) BPT supply adjustment.\n        // When adding liquidity, we must mint tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        _mint(address(params.pool), params.to, bptAmountOut);\n\n        // 8) Off-chain events.\n        emit PoolBalanceChanged(params.pool, params.to, amountsInRaw.unsafeCastToInt256(true));\n    }\n\n    /***************************************************************************\n                                 Remove Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function removeLiquidity(\n        RemoveLiquidityParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData)\n    {\n        // Round down when removing liquidity:\n        // If proportional, lower balances = lower proportional amountsOut, favoring the pool.\n        // If unbalanced, lower balances = lower invariant ratio without fees.\n        // bptIn = supply * (1 - ratio), so lower ratio = more bptIn, favoring the pool.\n        _ensureUnpaused(params.pool);\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the swap hooks are reentrant and could do anything, including\n        // change these balances, we cannot defer settlement until `_removeLiquidity`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances` and\n        // `_aggregateFeeAmounts in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_DOWN);\n        InputHelpers.ensureInputLengthMatch(poolData.tokens.length, params.minAmountsOut.length);\n\n        // Amounts are entering pool math; higher amounts would burn more BPT, so round up to favor the pool.\n        // Do not mutate minAmountsOut, so that we can directly compare the raw limits later, without potentially\n        // losing precision by scaling up and then down.\n        uint256[] memory minAmountsOutScaled18 = params.minAmountsOut.copyToScaled18ApplyRateRoundUpArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallBeforeRemoveLiquidity()) {\n            HooksConfigLib.callBeforeRemoveLiquidityHook(\n                minAmountsOutScaled18,\n                msg.sender,\n                params,\n                poolData,\n                _hooksContracts[params.pool]\n            );\n\n            // The hook might alter the balances, so we need to read them again to ensure that the data is\n            // fresh moving forward.\n            // We also need to upscale (removing liquidity, so round down) again.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_DOWN);\n\n            // Also update minAmountsOutScaled18, as the rates might have changed.\n            minAmountsOutScaled18 = params.minAmountsOut.copyToScaled18ApplyRateRoundUpArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, and the final balances\n        // are computed. This function is non-reentrant, as it performs the accounting updates.\n        //\n        // Note that poolData is mutated to update the Raw and Live balances, so they are accurate when passed\n        // into the AfterRemoveLiquidity hook.\n        uint256[] memory amountsOutScaled18;\n        (bptAmountIn, amountsOut, amountsOutScaled18, returnData) = _removeLiquidity(\n            poolData,\n            params,\n            minAmountsOutScaled18\n        );\n\n        // AmountsOut can be changed by onAfterRemoveLiquidity if the hook charges fees or gives discounts.\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterRemoveLiquidity()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountsOut = poolData.poolConfigBits.callAfterRemoveLiquidityHook(\n                msg.sender,\n                amountsOutScaled18,\n                amountsOut,\n                bptAmountIn,\n                params,\n                poolData,\n                hooksContract\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the appropriate pool hook and calculates the required inputs and outputs for the operation\n     * considering the given kind, and updates the vault's internal accounting. This includes:\n     * - Setting pool balances\n     * - Supplying credit to the liquidity provider\n     * - Burning pool tokens\n     * - Emitting events\n     *\n     * It is non-reentrant, as it performs external calls and updates the vault's state accordingly.\n     */\n    function _removeLiquidity(\n        PoolData memory poolData,\n        RemoveLiquidityParams memory params,\n        uint256[] memory minAmountsOutScaled18\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOutRaw,\n            uint256[] memory amountsOutScaled18,\n            bytes memory returnData\n        )\n    {\n        LiquidityLocals memory locals;\n        locals.numTokens = poolData.tokens.length;\n        uint256[] memory swapFeeAmountsScaled18;\n\n        if (params.kind == RemoveLiquidityKind.PROPORTIONAL) {\n            bptAmountIn = params.maxBptAmountIn;\n            swapFeeAmountsScaled18 = new uint256[](locals.numTokens);\n            amountsOutScaled18 = BasePoolMath.computeProportionalAmountsOut(\n                poolData.balancesLiveScaled18,\n                _totalSupply(params.pool),\n                bptAmountIn\n            );\n        } else if (params.kind == RemoveLiquidityKind.SINGLE_TOKEN_EXACT_IN) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n            bptAmountIn = params.maxBptAmountIn;\n            amountsOutScaled18 = minAmountsOutScaled18;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(params.minAmountsOut);\n\n            (amountsOutScaled18[locals.tokenIndex], swapFeeAmountsScaled18) = BasePoolMath\n                .computeRemoveLiquiditySingleTokenExactIn(\n                    poolData.balancesLiveScaled18,\n                    locals.tokenIndex,\n                    bptAmountIn,\n                    _totalSupply(params.pool),\n                    poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                    IBasePool(params.pool)\n                );\n        } else if (params.kind == RemoveLiquidityKind.SINGLE_TOKEN_EXACT_OUT) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n            amountsOutScaled18 = minAmountsOutScaled18;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(params.minAmountsOut);\n\n            (bptAmountIn, swapFeeAmountsScaled18) = BasePoolMath.computeRemoveLiquiditySingleTokenExactOut(\n                poolData.balancesLiveScaled18,\n                locals.tokenIndex,\n                amountsOutScaled18[locals.tokenIndex],\n                _totalSupply(params.pool),\n                poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                IBasePool(params.pool)\n            );\n        } else if (params.kind == RemoveLiquidityKind.CUSTOM) {\n            poolData.poolConfigBits.requireRemoveCustomLiquidityEnabled();\n            // Uses msg.sender as the router (the contract that called the vault)\n            (bptAmountIn, amountsOutScaled18, swapFeeAmountsScaled18, returnData) = IPoolLiquidity(params.pool)\n                .onRemoveLiquidityCustom(\n                    msg.sender,\n                    params.maxBptAmountIn,\n                    minAmountsOutScaled18,\n                    poolData.balancesLiveScaled18,\n                    params.userData\n                );\n        } else {\n            revert InvalidRemoveLiquidityKind();\n        }\n\n        if (bptAmountIn > params.maxBptAmountIn) {\n            revert BptAmountInAboveMax(bptAmountIn, params.maxBptAmountIn);\n        }\n\n        _ensureValidTradeAmount(bptAmountIn);\n\n        amountsOutRaw = new uint256[](locals.numTokens);\n\n        for (uint256 i = 0; i < locals.numTokens; ++i) {\n            uint256 amountOutRaw;\n\n            // 1) Calculate raw amount out.\n            {\n                uint256 amountOutScaled18 = amountsOutScaled18[i];\n                _ensureValidTradeAmount(amountOutScaled18);\n\n                // amountsOut are amounts exiting the Pool, so we round down.\n                // Do not mutate in place yet, as we need them scaled for the `onAfterRemoveLiquidity` hook.\n                amountOutRaw = amountOutScaled18.toRawUndoRateRoundDown(\n                    poolData.decimalScalingFactors[i],\n                    poolData.tokenRates[i]\n                );\n            }\n\n            amountsOutRaw[i] = amountOutRaw;\n\n            IERC20 token = poolData.tokens[i];\n            // 2) Check limits for raw amounts.\n            if (amountOutRaw < params.minAmountsOut[i]) {\n                revert AmountOutBelowMin(token, amountOutRaw, params.minAmountsOut[i]);\n            }\n\n            // 3) Deltas: Credit token[i] for amountOutRaw.\n            _supplyCredit(token, amountOutRaw);\n\n            // 4) Compute and charge protocol and creator fees.\n            locals.totalFeesRaw = _computeAndChargeAggregateSwapFees(\n                poolData,\n                swapFeeAmountsScaled18[i],\n                params.pool,\n                token,\n                i\n            );\n\n            // 5) Pool balances: raw and live.\n            // We need regular balances to complete the accounting, and the upscaled balances\n            // to use in the `after` hook later on.\n\n            // A Pool's token balance always decreases after an exit\n            // (potentially by 0). Also adjust by protocol and pool creator fees.\n            poolData.updateRawAndLiveBalance(\n                i,\n                poolData.balancesRaw[i] - (amountOutRaw + locals.totalFeesRaw),\n                Rounding.ROUND_DOWN\n            );\n        }\n\n        // 6) Store pool balances, raw and live.\n        _writePoolBalancesToStorage(params.pool, poolData);\n\n        // 7) BPT supply adjustment.\n        // Uses msg.sender as the router (the contract that called the vault).\n        _spendAllowance(address(params.pool), params.from, msg.sender, bptAmountIn);\n\n        if (_isQueryContext()) {\n            // Increase `from` balance to ensure the burn function succeeds.\n            _queryModeBalanceIncrease(params.pool, params.from, bptAmountIn);\n        }\n        // When removing liquidity, we must burn tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Burning will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _burn(address(params.pool), params.from, bptAmountIn);\n\n        // 8) Off-chain events\n        emit PoolBalanceChanged(\n            params.pool,\n            params.from,\n            // We can unsafely cast to int256 because balances are stored as uint128 (see PackedTokenBalance).\n            amountsOutRaw.unsafeCastToInt256(false)\n        );\n    }\n\n    /**\n     * @dev Preconditions: poolConfigBits, decimalScalingFactors, tokenRates in `poolData`.\n     * Side effects: updates `_aggregateFeeAmounts` storage.\n     * Note that this computes the aggregate total of the protocol fees and stores it, without emitting any events.\n     * Splitting the fees and event emission occur during fee collection.\n     * Should only be called in a non-reentrant context.\n     *\n     * @return totalFeesRaw Sum of protocol and pool creator fees raw\n     */\n    function _computeAndChargeAggregateSwapFees(\n        PoolData memory poolData,\n        uint256 swapFeeAmountScaled18,\n        address pool,\n        IERC20 token,\n        uint256 index\n    ) internal returns (uint256 totalFeesRaw) {\n        uint256 aggregateSwapFeePercentage = poolData.poolConfigBits.getAggregateSwapFeePercentage();\n        // If swapFeeAmount equals zero, no need to charge anything.\n        if (\n            swapFeeAmountScaled18 > 0 &&\n            aggregateSwapFeePercentage > 0 &&\n            poolData.poolConfigBits.isPoolInRecoveryMode() == false\n        ) {\n            uint256 aggregateSwapFeeAmountScaled18 = swapFeeAmountScaled18.mulUp(aggregateSwapFeePercentage);\n\n            // Ensure we can never charge more than the total swap fee.\n            if (aggregateSwapFeeAmountScaled18 > swapFeeAmountScaled18) {\n                revert ProtocolFeesExceedTotalCollected();\n            }\n\n            totalFeesRaw = aggregateSwapFeeAmountScaled18.toRawUndoRateRoundDown(\n                poolData.decimalScalingFactors[index],\n                poolData.tokenRates[index]\n            );\n\n            // Both Swap and Yield fees are stored together in a PackedTokenBalance.\n            // We have designated \"Raw\" the derived half for Swap fee storage.\n            bytes32 currentPackedBalance = _aggregateFeeAmounts[pool][token];\n            _aggregateFeeAmounts[pool][token] = currentPackedBalance.setBalanceRaw(\n                currentPackedBalance.getBalanceRaw() + totalFeesRaw\n            );\n        }\n    }\n\n    /*******************************************************************************\n                                    Pool Information\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getPoolTokenCountAndIndexOfToken(\n        address pool,\n        IERC20 token\n    ) external view withRegisteredPool(pool) returns (uint256, uint256) {\n        IERC20[] memory poolTokens = _poolTokens[pool];\n\n        uint256 index = _findTokenIndex(poolTokens, token);\n\n        return (poolTokens.length, index);\n    }\n\n    /*******************************************************************************\n                             Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function erc4626BufferWrapOrUnwrap(\n        BufferWrapOrUnwrapParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 amountCalculatedRaw, uint256 amountInRaw, uint256 amountOutRaw)\n    {\n        IERC20 underlyingToken = IERC20(params.wrappedToken.asset());\n\n        address bufferAsset = _bufferAssets[params.wrappedToken];\n\n        if (bufferAsset != address(0) && bufferAsset != address(underlyingToken)) {\n            // Asset was changed since the first addLiquidityToBuffer call.\n            revert WrongWrappedTokenAsset(address(params.wrappedToken));\n        }\n\n        if (params.amountGivenRaw < _MINIMUM_WRAP_AMOUNT) {\n            // If amount given is too small, rounding issues can be introduced that favors the user and can drain\n            // the buffer. _MINIMUM_WRAP_AMOUNT prevents it. Most tokens have protections against it already, this\n            // is just an extra layer of security.\n            revert WrapAmountTooSmall(address(params.wrappedToken));\n        }\n\n        if (params.direction == WrappingDirection.UNWRAP) {\n            (amountInRaw, amountOutRaw) = _unwrapWithBuffer(\n                params.kind,\n                underlyingToken,\n                params.wrappedToken,\n                params.amountGivenRaw\n            );\n            emit Unwrap(params.wrappedToken, underlyingToken, amountInRaw, amountOutRaw);\n        } else {\n            (amountInRaw, amountOutRaw) = _wrapWithBuffer(\n                params.kind,\n                underlyingToken,\n                params.wrappedToken,\n                params.amountGivenRaw\n            );\n            emit Wrap(underlyingToken, params.wrappedToken, amountInRaw, amountOutRaw);\n        }\n\n        if (params.kind == SwapKind.EXACT_IN) {\n            if (amountOutRaw < params.limitRaw) {\n                revert SwapLimit(amountOutRaw, params.limitRaw);\n            }\n            amountCalculatedRaw = amountOutRaw;\n        } else {\n            if (amountInRaw > params.limitRaw) {\n                revert SwapLimit(amountInRaw, params.limitRaw);\n            }\n            amountCalculatedRaw = amountInRaw;\n        }\n    }\n\n    /**\n     * @dev If the buffer has enough liquidity, it uses the internal ERC4626 buffer to perform the wrap\n     * operation without any external calls. If not, it wraps the assets needed to fulfill the trade + the surplus\n     * of assets in the buffer, so that the buffer is rebalanced at the end of the operation.\n     *\n     * Updates `_reservesOf` and token deltas in storage.\n     */\n    function _wrapWithBuffer(\n        SwapKind kind,\n        IERC20 underlyingToken,\n        IERC4626 wrappedToken,\n        uint256 amountGiven\n    ) private returns (uint256 amountInUnderlying, uint256 amountOutWrapped) {\n        // When wrapping and in query mode, the vault needs to have enough reserves of underlying token to do the\n        // wrap operation. If the vault does not have enough tokens to do the actual wrap, use ERC4626 preview.\n        bool isQueryContext = _isQueryContext();\n\n        if (kind == SwapKind.EXACT_IN) {\n            if (isQueryContext) {\n                return (amountGiven, wrappedToken.previewDeposit(amountGiven));\n            }\n            // EXACT_IN wrap, so AmountGiven is underlying amount.\n            (amountInUnderlying, amountOutWrapped) = (amountGiven, wrappedToken.convertToShares(amountGiven));\n        } else {\n            if (isQueryContext) {\n                return (wrappedToken.previewMint(amountGiven), amountGiven);\n            }\n            // EXACT_OUT wrap, so AmountGiven is wrapped amount.\n            (amountInUnderlying, amountOutWrapped) = (wrappedToken.convertToAssets(amountGiven), amountGiven);\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (bufferBalances.getBalanceDerived() >= amountOutWrapped) {\n            // The buffer has enough liquidity to facilitate the wrap without making an external call.\n            uint256 newDerivedBalance;\n            unchecked {\n                // We have verified above that this is safe to do unchecked.\n                newDerivedBalance = bufferBalances.getBalanceDerived() - amountOutWrapped;\n            }\n\n            bufferBalances = PackedTokenBalance.toPackedBalance(\n                bufferBalances.getBalanceRaw() + amountInUnderlying,\n                newDerivedBalance\n            );\n            _bufferTokenBalances[wrappedToken] = bufferBalances;\n        } else {\n            // The buffer does not have enough liquidity to facilitate the wrap without making an external call.\n            // We wrap the user's tokens via an external call and additionally rebalance the buffer if it has a\n            // surplus of underlying tokens.\n\n            // Gets the amount of underlying to wrap in order to rebalance the buffer.\n            uint256 bufferUnderlyingSurplus = bufferBalances.getBufferUnderlyingSurplus(wrappedToken);\n            uint256 bufferWrappedSurplus;\n\n            if (kind == SwapKind.EXACT_IN) {\n                // The amount of underlying tokens to deposit is the necessary amount to fulfill the trade\n                // (amountInUnderlying), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferUnderlyingSurplus).\n                uint256 amountToDeposit = amountInUnderlying + bufferUnderlyingSurplus;\n                underlyingToken.forceApprove(address(wrappedToken), amountToDeposit);\n                // EXACT_IN requires the exact amount of underlying tokens to be deposited, so deposit is called.\n                wrappedToken.deposit(amountToDeposit, address(this));\n            } else {\n                if (bufferUnderlyingSurplus > 0) {\n                    bufferWrappedSurplus = wrappedToken.convertToShares(bufferUnderlyingSurplus);\n                }\n\n                // The mint operation returns exactly `vaultWrappedDelta` shares. To do so, it withdraws underlying\n                // from the vault and returns the shares. So, the vault needs to approve the transfer of underlying\n                // tokens to the wrapper.\n                // Add 2 because mint can consume up to 2 wei more tokens than we anticipated.\n                underlyingToken.forceApprove(address(wrappedToken), amountInUnderlying + bufferUnderlyingSurplus + 2);\n\n                // EXACT_OUT requires the exact amount of wrapped tokens to be returned, so mint is called.\n                wrappedToken.mint(amountOutWrapped + bufferWrappedSurplus, address(this));\n\n                // Remove approval, in case mint consumed less tokens than we approved, due to convert error.\n                underlyingToken.forceApprove(address(wrappedToken), 0);\n            }\n\n            // ERC4626 output should not be trusted, so it's a good practice to measure the amount of\n            // deposited and returned tokens.\n            (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) = _updateReservesAfterWrapping(\n                underlyingToken,\n                IERC20(wrappedToken)\n            );\n\n            // Only updates buffer balances if buffer has a surplus of underlying tokens.\n            if (bufferUnderlyingSurplus > 0) {\n                if (kind == SwapKind.EXACT_IN) {\n                    // amountInUnderlying is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultUnderlyingDelta should be absorbed by the buffer.\n                    bufferUnderlyingSurplus = vaultUnderlyingDelta - amountInUnderlying;\n                    // Since bufferUnderlyingSurplus was wrapped, the final amountOut needs to discount the wrapped\n                    // amount that will stay in the buffer. Refresh `bufferWrappedSurplus` after external calls on the\n                    // wrapped token.\n                    bufferWrappedSurplus = wrappedToken.convertToShares(bufferUnderlyingSurplus);\n                    amountOutWrapped = vaultWrappedDelta - bufferWrappedSurplus;\n                } else {\n                    // If buffer has an underlying surplus, it wraps the surplus + amountIn, so the final amountIn needs\n                    // to be discounted for that.\n                    amountInUnderlying = vaultUnderlyingDelta - bufferUnderlyingSurplus;\n                    // amountOutWrapped is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultWrappedDelta should be absorbed by the buffer.\n                    bufferWrappedSurplus = vaultWrappedDelta - amountOutWrapped;\n                }\n\n                // In a wrap operation, the underlying balance of the buffer will decrease and the wrapped balance will\n                // increase. To decrease underlying balance, we get the delta amount that was deposited\n                // (vaultUnderlyingDelta) and discounts the amount needed in the wrapping operation\n                // (amountInUnderlying). Same logic applies to wrapped balances.\n                //\n                // Note: bufferUnderlyingSurplus = vaultUnderlyingDelta - amountInUnderlying\n                //       bufferWrappedSurplus = vaultWrappedDelta - amountOutWrapped\n                bufferBalances = PackedTokenBalance.toPackedBalance(\n                    bufferBalances.getBalanceRaw() - bufferUnderlyingSurplus,\n                    bufferBalances.getBalanceDerived() + bufferWrappedSurplus\n                );\n                _bufferTokenBalances[wrappedToken] = bufferBalances;\n            } else {\n                amountInUnderlying = vaultUnderlyingDelta;\n                amountOutWrapped = vaultWrappedDelta;\n            }\n        }\n\n        _takeDebt(underlyingToken, amountInUnderlying);\n        _supplyCredit(wrappedToken, amountOutWrapped);\n    }\n\n    /**\n     * @dev If the buffer has enough liquidity, it uses the internal ERC4626 buffer to perform the unwrap\n     * operation without any external calls. If not, it unwraps the assets needed to fulfill the trade + the surplus\n     * of assets in the buffer, so that the buffer is rebalanced at the end of the operation.\n     *\n     * Updates `_reservesOf` and token deltas in storage.\n     */\n    function _unwrapWithBuffer(\n        SwapKind kind,\n        IERC20 underlyingToken,\n        IERC4626 wrappedToken,\n        uint256 amountGiven\n    ) private returns (uint256 amountInWrapped, uint256 amountOutUnderlying) {\n        bool isQueryContext = _isQueryContext();\n\n        if (kind == SwapKind.EXACT_IN) {\n            if (isQueryContext) {\n                return (amountGiven, wrappedToken.previewRedeem(amountGiven));\n            }\n            // EXACT_IN unwrap, so AmountGiven is wrapped amount.\n            (amountOutUnderlying, amountInWrapped) = (wrappedToken.convertToAssets(amountGiven), amountGiven);\n        } else {\n            if (isQueryContext) {\n                return (wrappedToken.previewWithdraw(amountGiven), amountGiven);\n            }\n            // EXACT_OUT unwrap, so AmountGiven is underlying amount.\n            (amountOutUnderlying, amountInWrapped) = (amountGiven, wrappedToken.convertToShares(amountGiven));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (bufferBalances.getBalanceRaw() >= amountOutUnderlying) {\n            // The buffer has enough liquidity to facilitate the wrap without making an external call.\n            uint256 newRawBalance;\n            unchecked {\n                // We have verified above that this is safe to do unchecked.\n                newRawBalance = bufferBalances.getBalanceRaw() - amountOutUnderlying;\n            }\n            bufferBalances = PackedTokenBalance.toPackedBalance(\n                newRawBalance,\n                bufferBalances.getBalanceDerived() + amountInWrapped\n            );\n            _bufferTokenBalances[wrappedToken] = bufferBalances;\n        } else {\n            // The buffer does not have enough liquidity to facilitate the unwrap without making an external call.\n            // We unwrap the user's tokens via an external call and additionally rebalance the buffer if it has a\n            // surplus of underlying tokens.\n\n            // Gets the amount of wrapped tokens to unwrap in order to rebalance the buffer.\n            uint256 bufferWrappedSurplus = bufferBalances.getBufferWrappedSurplus(wrappedToken);\n            uint256 bufferUnderlyingSurplus;\n\n            if (kind == SwapKind.EXACT_IN) {\n                // EXACT_IN requires the exact amount of wrapped tokens to be unwrapped, so redeem is called\n                // The amount of wrapped tokens to redeem is the necessary amount to fulfill the trade\n                // (amountInWrapped), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferWrappedSurplus).\n                wrappedToken.redeem(amountInWrapped + bufferWrappedSurplus, address(this), address(this));\n            } else {\n                // EXACT_OUT requires the exact amount of underlying tokens to be returned, so withdraw is called.\n                // The amount of underlying tokens to withdraw is the necessary amount to fulfill the trade\n                // (amountOutUnderlying), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferUnderlyingSurplus).\n                if (bufferWrappedSurplus > 0) {\n                    bufferUnderlyingSurplus = wrappedToken.convertToAssets(bufferWrappedSurplus);\n                }\n                wrappedToken.withdraw(amountOutUnderlying + bufferUnderlyingSurplus, address(this), address(this));\n            }\n\n            // ERC4626 output should not be trusted, so it's a good practice to measure the amount of\n            // deposited and returned tokens.\n            (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) = _updateReservesAfterWrapping(\n                underlyingToken,\n                IERC20(wrappedToken)\n            );\n\n            // Only updates buffer balances if buffer has a surplus of wrapped tokens.\n            if (bufferWrappedSurplus > 0) {\n                if (kind == SwapKind.EXACT_IN) {\n                    // amountInWrapped is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultWrappedDelta should be absorbed by the buffer.\n                    bufferWrappedSurplus = vaultWrappedDelta - amountInWrapped;\n                    // Since bufferWrappedSurplus was unwrapped, the final amountOut needs to discount the underlying\n                    // amount that will stay in the buffer. Refresh `bufferUnderlyingSurplus` after external calls\n                    // on the wrapped token.\n                    bufferUnderlyingSurplus = wrappedToken.convertToAssets(bufferWrappedSurplus);\n                    amountOutUnderlying = vaultUnderlyingDelta - bufferUnderlyingSurplus;\n                } else {\n                    // If buffer has a wrapped surplus, it unwraps surplus + amountIn, so the final amountIn needs to\n                    // be discounted for that.\n                    amountInWrapped = vaultWrappedDelta - bufferWrappedSurplus;\n                    // amountOutUnderlying is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultUnderlyingDelta should be absorbed by the buffer.\n                    bufferUnderlyingSurplus = vaultUnderlyingDelta - amountOutUnderlying;\n                }\n\n                // In an unwrap operation, the underlying balance of the buffer will increase and the wrapped balance\n                // will decrease. To increase the underlying balance, we get the delta amount that was withdrawn\n                // (vaultUnderlyingDelta) and discount the amount expected in the unwrapping operation\n                // (amountOutUnderlying). The same logic applies to wrapped balances.\n                //\n                // Note: bufferUnderlyingSurplus = vaultUnderlyingDelta - amountOutUnderlying\n                //       bufferWrappedSurplus = vaultWrappedDelta - amountInWrapped\n                bufferBalances = PackedTokenBalance.toPackedBalance(\n                    bufferBalances.getBalanceRaw() + bufferUnderlyingSurplus,\n                    bufferBalances.getBalanceDerived() - bufferWrappedSurplus\n                );\n                _bufferTokenBalances[wrappedToken] = bufferBalances;\n            } else {\n                amountOutUnderlying = vaultUnderlyingDelta;\n                amountInWrapped = vaultWrappedDelta;\n            }\n        }\n\n        _takeDebt(wrappedToken, amountInWrapped);\n        _supplyCredit(underlyingToken, amountOutUnderlying);\n    }\n\n    function _isQueryContext() internal view returns (bool) {\n        return EVMCallModeHelpers.isStaticCall() && _vaultStateBits.isQueryDisabled() == false;\n    }\n\n    /**\n     * @dev Updates reserves for underlying and wrapped tokens after wrap/unwrap operation:\n     * - updates `_reservesOf`\n     * - returns the delta underlying and wrapped tokens that were deposited/withdrawn from vault reserves\n     */\n    function _updateReservesAfterWrapping(\n        IERC20 underlyingToken,\n        IERC20 wrappedToken\n    ) internal returns (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) {\n        uint256 vaultUnderlyingBefore = _reservesOf[underlyingToken];\n        uint256 vaultUnderlyingAfter = underlyingToken.balanceOf(address(this));\n        _reservesOf[underlyingToken] = vaultUnderlyingAfter;\n\n        uint256 vaultWrappedBefore = _reservesOf[wrappedToken];\n        uint256 vaultWrappedAfter = wrappedToken.balanceOf(address(this));\n        _reservesOf[wrappedToken] = vaultWrappedAfter;\n\n        if (vaultUnderlyingBefore > vaultUnderlyingAfter) {\n            // Wrap\n            // Since deposit takes underlying tokens from the vault, the actual underlying tokens deposited is\n            // underlyingBefore - underlyingAfter\n            // checked against underflow: vaultUnderlyingBefore > vaultUnderlyingAfter in `if` clause.\n            unchecked {\n                vaultUnderlyingDelta = vaultUnderlyingBefore - vaultUnderlyingAfter;\n            }\n            // Since deposit puts wrapped tokens into the vault, the actual wrapped minted is\n            // wrappedAfter - wrappedBefore.\n            vaultWrappedDelta = vaultWrappedAfter - vaultWrappedBefore;\n        } else {\n            // Unwrap\n            // Since withdraw puts underlying tokens into the vault, the actual underlying token amount withdrawn is\n            // assetsAfter - assetsBefore.\n            // checked against underflow: vaultUnderlyingAfter > vaultUnderlyingBefore in `else` clause.\n            unchecked {\n                vaultUnderlyingDelta = vaultUnderlyingAfter - vaultUnderlyingBefore;\n            }\n            // Since withdraw takes wrapped tokens from the vault, the actual wrapped token amount burned is\n            // wrappedBefore - wrappedAfter.\n            vaultWrappedDelta = vaultWrappedBefore - vaultWrappedAfter;\n        }\n    }\n\n    // Minimum swap amount (applied to scaled18 values), enforced as a security measure to block potential\n    // exploitation of rounding errors.\n    function _ensureValidTradeAmount(uint256 tradeAmount) private pure {\n        if (tradeAmount != 0 && tradeAmount < _MINIMUM_TRADE_AMOUNT) {\n            revert TradeAmountTooSmall();\n        }\n    }\n\n    /*******************************************************************************\n                                    Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getAuthorizer() external view returns (IAuthorizer) {\n        return _authorizer;\n    }\n\n    /*******************************************************************************\n                                     Default handlers\n    *******************************************************************************/\n\n    receive() external payable {\n        revert CannotReceiveEth();\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Override proxy implementation of `fallback` to disallow incoming ETH transfers.\n     * This function actually returns whatever the Vault Extension does when handling the request.\n     */\n    fallback() external payable override {\n        if (msg.value > 0) {\n            revert CannotReceiveEth();\n        }\n\n        _fallback();\n    }\n\n    /*******************************************************************************\n                                     Miscellaneous\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getVaultExtension() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Returns Vault Extension, where fallback requests are forwarded.\n     */\n    function _implementation() internal view override returns (address) {\n        return address(_vaultExtension);\n    }\n}\n",
        "VaultAdmin.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { PoolFunctionPermission, Rounding } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { Authentication } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/Authentication.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { VaultStateBits, VaultStateLib } from \"./lib/VaultStateLib.sol\";\nimport { VaultExtensionsLib } from \"./lib/VaultExtensionsLib.sol\";\nimport { PoolConfigLib, PoolConfigBits } from \"./lib/PoolConfigLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\n/**\n * @dev Bytecode extension for the Vault containing permissioned functions. Complementary to `VaultExtension`,\n * it has access to the same storage layout as the main vault.\n *\n * The functions in this contract are not meant to be called directly. They must only be called by the Vault\n * via delegate calls, so that any state modifications produced by this contract's code will actually target\n * the main Vault's state.\n *\n * The storage of this contract is in practice unused.\n */\ncontract VaultAdmin is IVaultAdmin, VaultCommon, Authentication {\n    using PackedTokenBalance for bytes32;\n    using PoolConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using VaultExtensionsLib for IVault;\n    using SafeERC20 for IERC20;\n\n    IVault private immutable _vault;\n\n    /// @dev Functions with this modifier can only be delegate-called by the vault.\n    modifier onlyVaultDelegateCall() {\n        _vault.ensureVaultDelegateCall();\n        _;\n    }\n\n    /// @dev Functions with this modifier can only be called by the pool creator.\n    modifier onlyProtocolFeeController() {\n        if (msg.sender != address(_protocolFeeController)) {\n            revert SenderNotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Validate aggregate percentage values.\n    modifier withValidPercentage(uint256 aggregatePercentage) {\n        if (aggregatePercentage > FixedPoint.ONE) {\n            revert ProtocolFeesExceedTotalCollected();\n        }\n        _;\n    }\n\n    /// @dev Use with permissioned functions that use `PoolRoleAccounts`.\n    modifier authenticateByRole(address pool) {\n        _ensureAuthenticatedByRole(pool);\n        _;\n    }\n\n    function _ensureAuthenticatedByRole(address pool) private view {\n        bytes32 actionId = getActionId(msg.sig);\n\n        PoolFunctionPermission memory roleAssignment = _poolFunctionPermissions[pool][actionId];\n\n        // If there is no role assignment, fall through and delegate to governance.\n        if (roleAssignment.account != address(0)) {\n            // If the sender matches the permissioned account, all good; just return.\n            if (msg.sender == roleAssignment.account) {\n                return;\n            }\n\n            // If it doesn't, check whether it's onlyOwner. onlyOwner means *only* the permissioned account\n            // may call the function, so revert if this is the case. Otherwise, fall through and check\n            // governance.\n            if (roleAssignment.onlyOwner) {\n                revert SenderNotAllowed();\n            }\n        }\n\n        // Delegate to governance.\n        if (_canPerform(actionId, msg.sender, pool) == false) {\n            revert SenderNotAllowed();\n        }\n    }\n\n    constructor(\n        IVault mainVault,\n        uint32 pauseWindowDuration,\n        uint32 bufferPeriodDuration\n    ) Authentication(bytes32(uint256(uint160(address(mainVault))))) {\n        if (pauseWindowDuration > _MAX_PAUSE_WINDOW_DURATION) {\n            revert VaultPauseWindowDurationTooLarge();\n        }\n        if (bufferPeriodDuration > _MAX_BUFFER_PERIOD_DURATION) {\n            revert PauseBufferPeriodDurationTooLarge();\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint32 pauseWindowEndTime = uint32(block.timestamp) + pauseWindowDuration;\n\n        _vaultPauseWindowEndTime = pauseWindowEndTime;\n        _vaultBufferPeriodDuration = bufferPeriodDuration;\n        _vaultBufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n\n        _vault = mainVault;\n    }\n\n    /*******************************************************************************\n                               Constants and immutables\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function vault() external view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getPauseWindowEndTime() external view returns (uint32) {\n        return _vaultPauseWindowEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodDuration() external view returns (uint32) {\n        return _vaultBufferPeriodDuration;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodEndTime() external view returns (uint32) {\n        return _vaultBufferPeriodEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMinimumPoolTokens() external pure returns (uint256) {\n        return _MIN_TOKENS;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMaximumPoolTokens() external pure returns (uint256) {\n        return _MAX_TOKENS;\n    }\n\n    /*******************************************************************************\n                                    Vault Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function isVaultPaused() external view onlyVaultDelegateCall returns (bool) {\n        return _isVaultPaused();\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getVaultPausedState() external view onlyVaultDelegateCall returns (bool, uint32, uint32) {\n        return (_isVaultPaused(), _vaultPauseWindowEndTime, _vaultBufferPeriodEndTime);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(false);\n    }\n\n    /**\n     * @dev The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     */\n    function _setVaultPaused(bool pausing) internal {\n        if (_isVaultPaused()) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert VaultPaused();\n            }\n\n            // The Vault can always be unpaused while it's paused.\n            // When the buffer period expires, `_isVaultPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= _vaultPauseWindowEndTime) {\n                    revert VaultPauseWindowExpired();\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert VaultNotPaused();\n            }\n        }\n\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setVaultPaused(pausing);\n        _vaultStateBits = vaultState;\n\n        emit VaultPausedStateChanged(pausing);\n    }\n\n    /*******************************************************************************\n                                     Pool Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pausePool(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpausePool(\n        address pool\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, false);\n    }\n\n    function _setPoolPaused(address pool, bool pausing) internal {\n        PoolConfigBits config = _poolConfigBits[pool];\n\n        if (_isPoolPaused(pool)) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert PoolPaused(pool);\n            }\n\n            // The pool can always be unpaused while it's paused.\n            // When the buffer period expires, `_isPoolPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= config.getPauseWindowEndTime()) {\n                    revert PoolPauseWindowExpired(pool);\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert PoolNotPaused(pool);\n            }\n        }\n\n        // Update poolConfigBits.\n        _poolConfigBits[pool] = config.setPoolPaused(pausing);\n\n        emit PoolPausedStateChanged(pool, pausing);\n    }\n\n    /*******************************************************************************\n                                        Fees\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setStaticSwapFeePercentage(\n        address pool,\n        uint256 swapFeePercentage\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        // Saving bits by not implementing a new modifier.\n        _ensureUnpaused(pool);\n        _setStaticSwapFeePercentage(pool, swapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function collectAggregateFees(address pool) public onlyVaultDelegateCall nonReentrant withRegisteredPool(pool) {\n        IERC20[] memory poolTokens = _vault.getPoolTokens(pool);\n        address feeController = address(_protocolFeeController);\n        uint256 numTokens = poolTokens.length;\n\n        uint256[] memory totalSwapFees = new uint256[](numTokens);\n        uint256[] memory totalYieldFees = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < poolTokens.length; ++i) {\n            IERC20 token = poolTokens[i];\n\n            (totalSwapFees[i], totalYieldFees[i]) = _aggregateFeeAmounts[pool][token].fromPackedBalance();\n\n            if (totalSwapFees[i] > 0 || totalYieldFees[i] > 0) {\n                // The ProtocolFeeController will pull tokens from the Vault.\n                token.forceApprove(feeController, totalSwapFees[i] + totalYieldFees[i]);\n\n                _aggregateFeeAmounts[pool][token] = 0;\n            }\n        }\n\n        _protocolFeeController.receiveAggregateFees(pool, totalSwapFees, totalYieldFees);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateSwapFeePercentage(\n        address pool,\n        uint256 newAggregateSwapFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateSwapFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateSwapFeePercentage(newAggregateSwapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateYieldFeePercentage(\n        address pool,\n        uint256 newAggregateYieldFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateYieldFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateYieldFeePercentage(newAggregateYieldFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function setProtocolFeeController(\n        IProtocolFeeController newProtocolFeeController\n    ) external onlyVaultDelegateCall authenticate nonReentrant {\n        _protocolFeeController = newProtocolFeeController;\n\n        emit ProtocolFeeControllerChanged(newProtocolFeeController);\n    }\n\n    /*******************************************************************************\n                                    Recovery Mode\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function enableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) {\n        _ensurePoolNotInRecoveryMode(pool);\n\n        // If the Vault or pool is pausable (and currently paused), this call is permissionless.\n        if (_isPoolPaused(pool) == false && _isVaultPaused() == false) {\n            // If not permissionless, authenticate with governance.\n            _authenticateCaller();\n        }\n\n        _setPoolRecoveryMode(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function disableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticate {\n        _ensurePoolInRecoveryMode(pool);\n        _setPoolRecoveryMode(pool, false);\n    }\n\n    /**\n     * @dev Reverts if the pool is in recovery mode.\n     * @param pool The pool\n     */\n    function _ensurePoolNotInRecoveryMode(address pool) internal view {\n        if (_isPoolInRecoveryMode(pool)) {\n            revert PoolInRecoveryMode(pool);\n        }\n    }\n\n    /**\n     * @dev Change the recovery mode state of a pool, and emit an event. Assumes any validation (e.g., whether\n     * the proposed state change is consistent) has already been done.\n     *\n     * @param pool The pool\n     * @param recoveryMode The desired recovery mode state\n     */\n    function _setPoolRecoveryMode(address pool, bool recoveryMode) internal {\n        // Update poolConfigBits\n        _poolConfigBits[pool] = _poolConfigBits[pool].setPoolInRecoveryMode(recoveryMode);\n\n        if (recoveryMode == false) {\n            _writePoolBalancesToStorage(pool, _loadPoolData(pool, Rounding.ROUND_DOWN));\n        }\n\n        emit PoolRecoveryModeStateChanged(pool, recoveryMode);\n    }\n\n    /*******************************************************************************\n                                        Queries\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function disableQuery() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setQueryDisabled(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /*******************************************************************************\n                                Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(false);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function addLiquidityToBuffer(\n        IERC4626 wrappedToken,\n        uint256 amountUnderlying,\n        uint256 amountWrapped,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 issuedShares)\n    {\n        address underlyingToken = wrappedToken.asset();\n\n        // Amount of shares to issue is the total underlying token that the user is depositing.\n        issuedShares = wrappedToken.convertToAssets(amountWrapped) + amountUnderlying;\n\n        if (_bufferAssets[wrappedToken] == address(0)) {\n            // Buffer is not initialized yet, so we initialize it.\n\n            // Register asset of wrapper, so it cannot change.\n            _bufferAssets[wrappedToken] = underlyingToken;\n\n            // Burn MINIMUM_TOTAL_SUPPLY shares, so the buffer can never go back to zero liquidity\n            // (avoids rounding issues with low liquidity).\n            _bufferTotalShares[wrappedToken] = _MINIMUM_TOTAL_SUPPLY;\n            issuedShares -= _MINIMUM_TOTAL_SUPPLY;\n        } else if (_bufferAssets[wrappedToken] != underlyingToken) {\n            // Asset was changed since the first bufferAddLiquidity call.\n            revert WrongWrappedTokenAsset(address(wrappedToken));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        // Adds the issued shares to the total shares of the liquidity pool.\n        _bufferLpShares[wrappedToken][sharesOwner] += issuedShares;\n        _bufferTotalShares[wrappedToken] += issuedShares;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() + amountUnderlying,\n            bufferBalances.getBalanceDerived() + amountWrapped\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _takeDebt(IERC20(underlyingToken), amountUnderlying);\n        _takeDebt(wrappedToken, amountWrapped);\n\n        emit LiquidityAddedToBuffer(wrappedToken, sharesOwner, amountWrapped, amountUnderlying, issuedShares);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function removeLiquidityFromBuffer(\n        IERC4626 wrappedToken,\n        uint256 sharesToRemove,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        authenticate\n        nonReentrant\n        returns (uint256 removedUnderlyingBalance, uint256 removedWrappedBalance)\n    {\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (sharesToRemove > _bufferLpShares[wrappedToken][sharesOwner]) {\n            revert NotEnoughBufferShares();\n        }\n        uint256 totalShares = _bufferTotalShares[wrappedToken];\n\n        removedUnderlyingBalance = (bufferBalances.getBalanceRaw() * sharesToRemove) / totalShares;\n        removedWrappedBalance = (bufferBalances.getBalanceDerived() * sharesToRemove) / totalShares;\n\n        _bufferLpShares[wrappedToken][sharesOwner] -= sharesToRemove;\n        _bufferTotalShares[wrappedToken] -= sharesToRemove;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() - removedUnderlyingBalance,\n            bufferBalances.getBalanceDerived() - removedWrappedBalance\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _supplyCredit(IERC20(_bufferAssets[wrappedToken]), removedUnderlyingBalance);\n        _supplyCredit(wrappedToken, removedWrappedBalance);\n\n        emit LiquidityRemovedFromBuffer(\n            wrappedToken,\n            sharesOwner,\n            removedWrappedBalance,\n            removedUnderlyingBalance,\n            sharesToRemove\n        );\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferOwnerShares(\n        IERC4626 token,\n        address user\n    ) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferLpShares[token][user];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferTotalShares(IERC4626 token) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferTotalShares[token];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferBalance(IERC4626 token) external view onlyVaultDelegateCall returns (uint256, uint256) {\n        // The first balance is underlying, and the last is wrapped balance.\n        return (_bufferTokenBalances[token].getBalanceRaw(), _bufferTokenBalances[token].getBalanceDerived());\n    }\n\n    /*******************************************************************************\n                                Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setAuthorizer(IAuthorizer newAuthorizer) external onlyVaultDelegateCall authenticate {\n        _authorizer = newAuthorizer;\n\n        emit AuthorizerChanged(newAuthorizer);\n    }\n\n    /// @dev Access control is delegated to the Authorizer.\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\n        return _authorizer.canPerform(actionId, user, address(this));\n    }\n\n    /// @dev Access control is delegated to the Authorizer. `where` refers to the target contract.\n    function _canPerform(bytes32 actionId, address user, address where) internal view returns (bool) {\n        return _authorizer.canPerform(actionId, user, where);\n    }\n}\n",
        "PoolDataLib.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { PoolData, TokenInfo, TokenType, Rounding } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\nimport { IVaultErrors } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultErrors.sol\";\n\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { PoolConfigBits, PoolConfigLib } from \"./PoolConfigLib.sol\";\n\n/**\n * @notice Helper functions to read/write a `PoolData` struct.\n * @dev Note that the entire configuration of each pool is stored in the `_poolConfigBits` mapping (one slot per pool).\n * This includes the data in the `PoolConfig` struct, plus the data in the `HookFlags` struct. The layout (i.e.,\n * offsets for each data field) is specified in `PoolConfigConst`.\n *\n * The `PoolData` struct contains the raw bitmap with the entire pool state (`PoolConfigBits`), plus the token\n * configuration, scaling factors, and dynamic information such as current balances and rates.\n */\nlibrary PoolDataLib {\n    using PackedTokenBalance for bytes32;\n    using FixedPoint for *;\n    using ScalingHelpers for *;\n    using PoolConfigLib for PoolConfigBits;\n\n    function load(\n        PoolData memory poolData,\n        mapping(uint => bytes32) storage poolTokenBalances,\n        PoolConfigBits poolConfigBits,\n        mapping(IERC20 => TokenInfo) storage poolTokenInfo,\n        IERC20[] storage tokens,\n        Rounding roundingDirection\n    ) internal view {\n        uint256 numTokens = tokens.length;\n\n        poolData.poolConfigBits = poolConfigBits;\n        poolData.tokens = tokens;\n        poolData.tokenInfo = new TokenInfo[](numTokens);\n        poolData.balancesRaw = new uint256[](numTokens);\n        poolData.balancesLiveScaled18 = new uint256[](numTokens);\n        poolData.decimalScalingFactors = PoolConfigLib.getDecimalScalingFactors(poolData.poolConfigBits, numTokens);\n        poolData.tokenRates = new uint256[](numTokens);\n\n        bool poolSubjectToYieldFees = poolData.poolConfigBits.isPoolInitialized() &&\n            poolData.poolConfigBits.getAggregateYieldFeePercentage() > 0 &&\n            poolData.poolConfigBits.isPoolInRecoveryMode() == false;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            TokenInfo memory tokenInfo = poolTokenInfo[poolData.tokens[i]];\n            bytes32 packedBalance = poolTokenBalances[i];\n\n            poolData.tokenInfo[i] = tokenInfo;\n            poolData.tokenRates[i] = getTokenRate(tokenInfo);\n            updateRawAndLiveBalance(poolData, i, packedBalance.getBalanceRaw(), roundingDirection);\n\n            // If there are no yield fees, we can save gas by skipping to the next token now.\n            if (poolSubjectToYieldFees == false) {\n                continue;\n            }\n\n            // `poolData` already has live balances computed from raw balances according to the token rates and the\n            // given rounding direction. Charging a yield fee changes the raw balance, in which case the safest and\n            // most numerically precise way to adjust the live balance is to simply repeat the scaling (hence the\n            // second call below).\n\n            // The Vault actually guarantees that a token with paysYieldFees set is a WITH_RATE token, so technically\n            // we could just check the flag, but we don't want to introduce that dependency for a slight gas savings.\n            bool tokenSubjectToYieldFees = tokenInfo.paysYieldFees && tokenInfo.tokenType == TokenType.WITH_RATE;\n\n            // Do not charge yield fees before the pool is initialized, or in recovery mode.\n            if (tokenSubjectToYieldFees) {\n                uint256 aggregateYieldFeePercentage = poolData.poolConfigBits.getAggregateYieldFeePercentage();\n                uint256 balanceRaw = poolData.balancesRaw[i];\n\n                uint256 aggregateYieldFeeAmountRaw = _computeYieldFeesDue(\n                    poolData,\n                    packedBalance.getBalanceDerived(),\n                    i,\n                    aggregateYieldFeePercentage\n                );\n\n                if (aggregateYieldFeeAmountRaw > 0) {\n                    updateRawAndLiveBalance(poolData, i, balanceRaw - aggregateYieldFeeAmountRaw, roundingDirection);\n                }\n            }\n        }\n    }\n\n    function syncPoolBalancesAndFees(\n        PoolData memory poolData,\n        mapping(uint256 => bytes32) storage poolTokenBalances,\n        mapping(IERC20 => bytes32) storage poolAggregateProtocolFeeAmounts\n    ) internal {\n        uint256 numTokens = poolData.balancesRaw.length;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            IERC20 token = poolData.tokens[i];\n            bytes32 packedBalances = poolTokenBalances[i];\n            uint256 storedBalanceRaw = packedBalances.getBalanceRaw();\n\n            // `poolData` now has balances updated with yield fees.\n            // If yield fees are not 0, then the stored balance is greater than the one in memory.\n            if (storedBalanceRaw > poolData.balancesRaw[i]) {\n                // Both Swap and Yield fees are stored together in a `PackedTokenBalance`.\n                // We have designated \"Derived\" the derived half for Yield fee storage.\n                bytes32 packedProtocolFeeAmounts = poolAggregateProtocolFeeAmounts[token];\n                poolAggregateProtocolFeeAmounts[token] = packedProtocolFeeAmounts.setBalanceDerived(\n                    packedProtocolFeeAmounts.getBalanceDerived() + (storedBalanceRaw - poolData.balancesRaw[i])\n                );\n            }\n\n            poolTokenBalances[i] = PackedTokenBalance.toPackedBalance(\n                poolData.balancesRaw[i],\n                poolData.balancesLiveScaled18[i]\n            );\n        }\n    }\n\n    /**\n     * @dev This is typically called after a reentrant callback (e.g., a \"before\" liquidity operation callback),\n     * to refresh the poolData struct with any balances (or rates) that might have changed.\n     *\n     * Preconditions: tokenConfig, balancesRaw, and decimalScalingFactors must be current in `poolData`.\n     * Side effects: mutates tokenRates, balancesLiveScaled18 in `poolData`.\n     */\n    function reloadBalancesAndRates(\n        PoolData memory poolData,\n        mapping(uint256 => bytes32) storage poolTokenBalances,\n        Rounding roundingDirection\n    ) internal view {\n        uint256 numTokens = poolData.tokens.length;\n\n        // It's possible a reentrant hook changed the raw balances in Vault storage.\n        // Update them before computing the live balances.\n        bytes32 packedBalance;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            poolData.tokenRates[i] = getTokenRate(poolData.tokenInfo[i]);\n\n            packedBalance = poolTokenBalances[i];\n\n            // Note the order dependency. This requires up-to-date tokenRate for the token at index `i` in `poolData`\n            updateRawAndLiveBalance(poolData, i, packedBalance.getBalanceRaw(), roundingDirection);\n        }\n    }\n\n    function getTokenRate(TokenInfo memory tokenInfo) internal view returns (uint256 rate) {\n        TokenType tokenType = tokenInfo.tokenType;\n\n        if (tokenType == TokenType.STANDARD) {\n            rate = FixedPoint.ONE;\n        } else if (tokenType == TokenType.WITH_RATE) {\n            rate = tokenInfo.rateProvider.getRate();\n        } else {\n            revert IVaultErrors.InvalidTokenConfiguration();\n        }\n    }\n\n    function updateRawAndLiveBalance(\n        PoolData memory poolData,\n        uint256 tokenIndex,\n        uint256 newRawBalance,\n        Rounding roundingDirection\n    ) internal pure {\n        poolData.balancesRaw[tokenIndex] = newRawBalance;\n\n        function(uint256, uint256, uint256) internal pure returns (uint256) _upOrDown = roundingDirection ==\n            Rounding.ROUND_UP\n            ? ScalingHelpers.toScaled18ApplyRateRoundUp\n            : ScalingHelpers.toScaled18ApplyRateRoundDown;\n\n        poolData.balancesLiveScaled18[tokenIndex] = _upOrDown(\n            newRawBalance,\n            poolData.decimalScalingFactors[tokenIndex],\n            poolData.tokenRates[tokenIndex]\n        );\n    }\n\n    // solhint-disable-next-line private-vars-leading-underscore\n    function _computeYieldFeesDue(\n        PoolData memory poolData,\n        uint256 lastLiveBalance,\n        uint256 tokenIndex,\n        uint256 aggregateYieldFeePercentage\n    ) internal pure returns (uint256 aggregateYieldFeeAmountRaw) {\n        uint256 currentLiveBalance = poolData.balancesLiveScaled18[tokenIndex];\n\n        // Do not charge fees if rates go down. If the rate were to go up, down, and back up again, protocol fees\n        // would be charged multiple times on the \"same\" yield. For tokens subject to yield fees, this should not\n        // happen, or at least be very rare. It can be addressed for known volatile rates by setting the yield fee\n        // exempt flag on registration, or compensated off-chain if there is an incident with a normally\n        // well-behaved rate provider.\n        if (currentLiveBalance > lastLiveBalance) {\n            unchecked {\n                // Magnitudes are checked above, so it's safe to do unchecked math here.\n                uint256 aggregateYieldFeeAmountScaled18 = (currentLiveBalance - lastLiveBalance).mulUp(\n                    aggregateYieldFeePercentage\n                );\n\n                // A pool is subject to yield fees if poolSubjectToYieldFees is true, meaning that\n                // `protocolYieldFeePercentage > 0`. So, we don't need to check this again in here, saving some gas.\n                aggregateYieldFeeAmountRaw = aggregateYieldFeeAmountScaled18.toRawUndoRateRoundDown(\n                    poolData.decimalScalingFactors[tokenIndex],\n                    poolData.tokenRates[tokenIndex]\n                );\n            }\n        }\n    }\n}\n"
    }
}