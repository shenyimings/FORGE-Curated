{
    "vfp_id": "vfp_00229",
    "project_name": "2025.08.14 - Final - Malda Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Wrong direction of rounding in redeem may lead to drain if exchange rate grows large",
            "description": "In the mToken contract, the redeem function uses `div_` (rounding down) when calculating the number of tokens to burn in exchange for underlying assets. This causes the protocol to burn fewer shares than it should, while still sending out the full requested amount of underlying. Over many transactions, this discrepancy can be exploited. The root cause is the incorrect rounding direction in the division operation during redeem logic. An attacker can manipulate the exchange rate by repeatedly depositing and redeeming small amounts when the supply is low, inflating the exchange rate significantly. Once the exchange rate is large enough, the rounding error becomes substantial, allowing the attacker to withdraw large amounts of underlying while burning negligible shares. The impact is a potential economic drain on the protocol's reserves.\n",
            "severity": "Medium",
            "location": [
                "mToken.sol#614-630",
                "mToken.sol#699-707"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/mToken.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "First depositor can brick market by forcing very large borrow rate",
            "description": "The JumpRateModelV4 calculates the borrow rate based on utilization, which is defined as borrows / (cash + borrows - reserves). However, this formula can result in utilization exceeding 1e18 when cash + borrows - reserves is less than borrows. A malicious first depositor can manipulate the market state by borrowing nearly all liquidity, letting interest accrue, repaying most of the debt, and then redeeming all shares, leaving a small borrow amount with zero cash. This results in an extremely high utilization rate, which causes the borrow rate to exceed the maximum allowed value (0.0005e16). As a result, the _accrueInterest function reverts on every call, effectively bricking the market. The root cause is the lack of a cap on utilization rate. The impact is a denial of service for all market operations, rendering the market unusable.\n",
            "severity": "Medium",
            "location": [
                "JumpRateModelV4.sol#140-150",
                "JumpRateModelV4.sol#127-135",
                "mToken.sol#36-39",
                "mTokenStorage.sol#351-356"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/interest/JumpRateModelV4.sol",
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/mToken.sol",
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/mTokenStorage.sol"
            ]
        }
    ],
    "affected_files": {
        "mTokenStorage.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\n// interfaces\nimport {IRoles} from \"src/interfaces/IRoles.sol\";\nimport {ImToken, ImTokenMinimal} from \"src/interfaces/ImToken.sol\";\nimport {IInterestRateModel} from \"src/interfaces/IInterestRateModel.sol\";\n\n// contracts\nimport {ExponentialNoError} from \"src/utils/ExponentialNoError.sol\";\n\nabstract contract mTokenStorage is ImToken, ExponentialNoError {\n    // ----------- ACCESS STORAGE ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    address payable public admin;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    address payable public pendingAdmin;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    address public operator;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    IRoles public rolesOperator;\n\n    // ----------- TOKENS STORAGE ------------\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    string public name;\n\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    string public symbol;\n\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    uint8 public decimals;\n\n    // ----------- MARKET STORAGE ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    address public interestRateModel;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    uint256 public reserveFactorMantissa;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    uint256 public accrualBlockTimestamp;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    uint256 public borrowIndex;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    uint256 public totalBorrows;\n\n    /**\n     * @inheritdoc ImToken\n     */\n    uint256 public totalReserves;\n\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    uint256 public totalSupply;\n\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied\n     */\n    uint256 public borrowRateMaxMantissa = 0.0005e16;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n    // Mapping of account addresses to outstanding borrow balances\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    // Official record of token balances for each account\n    mapping(address => uint256) internal accountTokens;\n\n    // Approved token transfer amounts on behalf of others\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n    /**\n     * @notice Initial exchange rate used when minting the first mTokens (used when totalSupply = 0)\n     */\n    uint256 internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     */\n    uint256 internal constant RESERVE_FACTOR_MAX_MANTISSA = 1e18;\n\n    /**\n     * @notice Share of seized collateral that is added to reserves\n     */\n    uint256 internal constant PROTOCOL_SEIZE_SHARE_MANTISSA = 2.8e16; //2.8%\n\n    // ----------- ERRORS ------------\n    error mt_OnlyAdmin();\n    error mt_RedeemEmpty();\n    error mt_InvalidInput();\n    error mt_OnlyAdminOrRole();\n    error mt_TransferNotValid();\n    error mt_MinAmountNotValid();\n    error mt_BorrowRateTooHigh();\n    error mt_AlreadyInitialized();\n    error mt_ReserveFactorTooHigh();\n    error mt_ExchangeRateNotValid();\n    error mt_MarketMethodNotValid();\n    error mt_LiquidateSeizeTooMuch();\n    error mt_RedeemCashNotAvailable();\n    error mt_BorrowCashNotAvailable();\n    error mt_ReserveCashNotAvailable();\n    error mt_RedeemTransferOutNotPossible();\n    error mt_SameChainOperationsAreDisabled();\n    error mt_CollateralBlockTimestampNotValid();\n\n    // ----------- ACCESS EVENTS ------------\n    /**\n     * @notice Event emitted when rolesOperator is changed\n     */\n    event NewRolesOperator(address indexed oldRoles, address indexed newRoles);\n\n    /**\n     * @notice Event emitted when Operator is changed\n     */\n    event NewOperator(address indexed oldOperator, address indexed newOperator);\n\n    // ----------- TOKENS EVENTS ------------\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    // ----------- MARKETS EVENTS ------------\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address indexed minter, address indexed receiver, uint256 mintAmount, uint256 mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address indexed borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(\n        address indexed payer,\n        address indexed borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address indexed liquidator,\n        address indexed borrower,\n        uint256 repayAmount,\n        address indexed mTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(address indexed oldInterestRateModel, address indexed newInterestRateModel);\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address indexed benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address indexed admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n    /**\n     * @notice Event emitted when the borrow max mantissa is updated\n     */\n    event NewBorrowRateMaxMantissa(uint256 oldVal, uint256 maxMantissa);\n\n    /**\n     * @notice Event emitted when same chain flow state is enabled or disabled\n     */\n    event SameChainFlowStateUpdated(address indexed sender, bool _oldState, bool _newState);\n\n    /**\n     * @notice Event emitted when same chain flow state is enabled or disabled\n     */\n    event ZkVerifierUpdated(address indexed oldVerifier, address indexed newVerifier);\n\n    // ----------- VIRTUAL ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function accrueInterest() external virtual {\n        _accrueInterest();\n    }\n\n    /**\n     * @dev Function to simply retrieve block timestamp\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function _getBlockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the MToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     *      Can generate issues if inflated by an attacker when market is created\n     *      Solution: use 0 collateral factor initially\n     * @return calculated exchange rate scaled by 1e18\n     */\n    function _exchangeRateStored() internal view virtual returns (uint256) {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint256 totalCash = _getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n            uint256 exchangeRate = (cashPlusBorrowsMinusReserves * expScale) / _totalSupply;\n\n            return exchangeRate;\n        }\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function _getCashPrior() internal view virtual returns (uint256);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function _doTransferIn(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function _doTransferOut(address payable to, uint256 amount) internal virtual;\n\n    // ----------- NON-VIRTUAL ------------\n    function _accrueInterest() internal {\n        /* Remember the initial block timestamp */\n        uint256 currentBlockTimestamp = _getBlockTimestamp();\n        uint256 accrualBlockTimestampPrior = accrualBlockTimestamp;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockTimestampPrior == currentBlockTimestamp) return;\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = _getCashPrior();\n        uint256 borrowsPrior = totalBorrows;\n        uint256 reservesPrior = totalReserves;\n        uint256 borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa =\n            IInterestRateModel(interestRateModel).getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        if (borrowRateMaxMantissa > 0) {\n            require(borrowRateMantissa <= borrowRateMaxMantissa, mt_BorrowRateTooHigh());\n        }\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint256 blockDelta = currentBlockTimestamp - accrualBlockTimestampPrior;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\n        uint256 totalReservesNew =\n            mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockTimestamp = currentBlockTimestamp;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n    }\n}\n",
        "mToken.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\n// interfaces\nimport {ImToken, ImTokenMinimal} from \"src/interfaces/ImToken.sol\";\nimport {IInterestRateModel} from \"src/interfaces/IInterestRateModel.sol\";\nimport {IOperator, IOperatorDefender} from \"src/interfaces/IOperator.sol\";\n\n// contracts\nimport {mTokenConfiguration} from \"./mTokenConfiguration.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nabstract contract mToken is mTokenConfiguration, ReentrancyGuard {\n    constructor() {\n        borrowRateMaxMantissa = 0.0005e16;\n    }\n    /**\n     * @notice Initialize the money market\n     * @param operator_ The address of the Operator\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n\n    function _initializeMToken(\n        address operator_,\n        address interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        require(accrualBlockTimestamp == 0 && borrowIndex == 0, mt_AlreadyInitialized());\n        require(initialExchangeRateMantissa_ > 0, mt_ExchangeRateNotValid());\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        _setOperator(operator_);\n\n        accrualBlockTimestamp = _getBlockTimestamp();\n        borrowIndex = mantissaOne;\n\n        _setInterestRateModel(interestRateModel_);\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    // ----------- TOKENS VIEW ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    // ----------- MARKETS VIEW ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256) {\n        return (accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function borrowRatePerBlock() external view override returns (uint256) {\n        return IInterestRateModel(interestRateModel).getBorrowRate(_getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return IInterestRateModel(interestRateModel).getSupplyRate(\n            _getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa\n        );\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function borrowBalanceStored(address account) external view override returns (uint256) {\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function getCash() external view override returns (uint256) {\n        return _getCashPrior();\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function exchangeRateStored() external view override returns (uint256) {\n        return _exchangeRateStored();\n    }\n\n    // ----------- TOKENS PUBLIC ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, msg.sender, dst, amount);\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, src, dst, amount);\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        transferAllowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // ----------- MARKETS PUBLIC ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n        _accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n        _accrueInterest();\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\n        _accrueInterest();\n        return _exchangeRateStored();\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external override nonReentrant {\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\n        require(\n            msg.sender == admin || rolesOperator.isAllowedFor(msg.sender, rolesOperator.GUARDIAN_RESERVE()),\n            mt_OnlyAdminOrRole()\n        );\n\n        _accrueInterest();\n\n        require(_getCashPrior() >= reduceAmount, mt_ReserveCashNotAvailable());\n        require(reduceAmount <= totalReserves, mt_ReserveCashNotAvailable());\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew = totalReserves - reduceAmount;\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        _doTransferOut(payable(msg.sender), reduceAmount);\n        totalUnderlying -= reduceAmount;\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n    }\n\n    // ----------- INTERNAL VIEW ------------\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function _borrowBalanceStored(address account) internal view returns (uint256) {\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return 0;\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n        return principalTimesIndex / borrowSnapshot.interestIndex;\n    }\n\n    // ----------- INTERNAL ------------\n    /**\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param user The user address\n     * @param user The receiver address\n     * @param mintAmount The amount of the underlying asset to supply\n     * @param minAmountOut The minimum amount to be received\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _mint(address user, address receiver, uint256 mintAmount, uint256 minAmountOut, bool doTransfer)\n        internal\n        nonReentrant\n    {\n        _accrueInterest();\n        // emits the actual Mint event if successful and logs on errors, so we don't need to\n        __mint(user, receiver, mintAmount, minAmountOut, doTransfer);\n    }\n\n    /**\n     * @notice Sender redeems mTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param user The user address\n     * @param redeemTokens The number of mTokens to redeem into underlying\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _redeem(address user, uint256 redeemTokens, bool doTransfer)\n        internal\n        nonReentrant\n        returns (uint256 underlyingAmount)\n    {\n        _accrueInterest();\n        // emits redeem-specific logs on errors, so we don't need to\n        underlyingAmount = __redeem(payable(user), redeemTokens, 0, doTransfer);\n    }\n\n    /**\n     * @notice Sender redeems mTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param user The user address\n     * @param redeemAmount The amount of underlying to receive from redeeming mTokens\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _redeemUnderlying(address user, uint256 redeemAmount, bool doTransfer) internal nonReentrant {\n        _accrueInterest();\n        // emits redeem-specific logs on errors, so we don't need to\n        __redeem(payable(user), 0, redeemAmount, doTransfer);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param user The user address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _borrow(address user, uint256 borrowAmount, bool doTransfer) internal nonReentrant {\n        _accrueInterest();\n        // emits borrow-specific logs on errors, so we don't need to\n        __borrow(payable(user), payable(user), borrowAmount, doTransfer);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param user The user address\n     * @param receiver The underlying receiver address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     */\n    function _borrowWithReceiver(address user, address receiver, uint256 borrowAmount) internal nonReentrant {\n        _accrueInterest();\n        __borrow(payable(user), payable(receiver), borrowAmount, true);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or `type(uint256).max` for the full outstanding amount\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _repay(uint256 repayAmount, bool doTransfer) internal nonReentrant returns (uint256) {\n        _accrueInterest();\n        // emits repay-borrow-specific logs on errors, so we don't need to\n        return __repay(msg.sender, msg.sender, repayAmount, doTransfer);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or `type(uint256).max` for the full outstanding amount\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _repayBehalf(address borrower, uint256 repayAmount, bool doTransfer)\n        internal\n        nonReentrant\n        returns (uint256)\n    {\n        _accrueInterest();\n        // emits repay-borrow-specific logs on errors, so we don't need to\n        return __repay(msg.sender, borrower, repayAmount, doTransfer);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param liquidator The liquidator address\n     * @param borrower The borrower of this mToken to be liquidated\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _liquidate(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address mTokenCollateral,\n        bool doTransfer\n    ) internal nonReentrant {\n        _accrueInterest();\n\n        ImToken(mTokenCollateral).accrueInterest();\n\n        // emits borrow-specific logs on errors, so we don't need to\n        __liquidate(liquidator, borrower, repayAmount, mTokenCollateral, doTransfer);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another mToken.\n     *  Its absolutely critical to use msg.sender as the seizer mToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed mToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of mTokens to seize\n     */\n    function _seize(address seizerToken, address liquidator, address borrower, uint256 seizeTokens) internal {\n        IOperatorDefender(operator).beforeMTokenSeize(address(this), seizerToken, liquidator, borrower);\n\n        require(borrower != liquidator, mt_InvalidInput());\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        uint256 protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: PROTOCOL_SEIZE_SHARE_MANTISSA}));\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\n        uint256 totalReservesNew = totalReserves + protocolSeizeAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the calculated values into storage */\n        totalReserves = totalReservesNew;\n        totalSupply = totalSupply - protocolSeizeTokens;\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     */\n    function _addReserves(uint256 addAmount) internal nonReentrant {\n        _accrueInterest();\n\n        // totalReserves + actualAddAmount\n        uint256 totalReservesNew;\n        uint256 actualAddAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the mToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n\n        actualAddAmount = _doTransferIn(msg.sender, addAmount);\n        totalUnderlying += actualAddAmount;\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    // ----------- PRIVATE ------------\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param borrower The borrower of this mToken to be liquidated\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function __liquidate(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address mTokenCollateral,\n        bool doTransfer\n    ) internal {\n        require(borrower != liquidator, mt_InvalidInput());\n        require(repayAmount > 0 && repayAmount != type(uint256).max, mt_InvalidInput());\n\n        IOperatorDefender(operator).beforeMTokenLiquidate(address(this), mTokenCollateral, borrower, repayAmount);\n\n        require(\n            ImToken(mTokenCollateral).accrualBlockTimestamp() == _getBlockTimestamp(),\n            mt_CollateralBlockTimestampNotValid()\n        );\n\n        /* Fail if repayBorrow fails */\n        uint256 actualRepayAmount = __repay(liquidator, borrower, repayAmount, doTransfer);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        uint256 seizeTokens =\n            IOperator(operator).liquidateCalculateSeizeTokens(address(this), mTokenCollateral, actualRepayAmount);\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(ImToken(mTokenCollateral).balanceOf(borrower) >= seizeTokens, mt_LiquidateSeizeTooMuch());\n\n        // If this is also the collateral, run _seize to avoid re-entrancy, otherwise make an external call\n        if (address(mTokenCollateral) == address(this)) {\n            _seize(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            ImToken(mTokenCollateral).seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(mTokenCollateral), seizeTokens);\n    }\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of underlying tokens being returned, or `type(uint256).max` for the full outstanding amount\n     * @param doTransfer If an actual transfer should be performed\n     */\n\n    function __repay(address payer, address borrower, uint256 repayAmount, bool doTransfer) private returns (uint256) {\n        IOperatorDefender(operator).beforeMTokenRepay(address(this), borrower);\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\n\n        /* If repayAmount == type(uint256).max , repayAmount = accountBorrows */\n        uint256 repayAmountFinal = repayAmount == type(uint256).max ? accountBorrowsPrev : repayAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call _doTransferIn for the payer and the repayAmount\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the mToken holds an additional repayAmount of cash.\n         *  _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        uint256 actualRepayAmount = doTransfer ? _doTransferIn(payer, repayAmountFinal) : repayAmountFinal;\n        totalUnderlying += actualRepayAmount;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n        return actualRepayAmount;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     */\n    function __borrow(address payable borrower, address payable receiver, uint256 borrowAmount, bool doTransfer)\n        private\n    {\n        IOperatorDefender(operator).beforeMTokenBorrow(address(this), borrower, borrowAmount);\n\n        require(_getCashPrior() >= borrowAmount, mt_BorrowCashNotAvailable());\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowNew = accountBorrow + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        if (doTransfer) {\n            /*\n            * We invoke _doTransferOut for the borrower and the borrowAmount.\n            *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n            *  On success, the mToken borrowAmount less of cash.\n            *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n            */\n            _doTransferOut(receiver, borrowAmount);\n        }\n        totalUnderlying -= borrowAmount;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n    }\n\n    function __redeem(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, bool doTransfer)\n        private\n        returns (uint256 redeemAmount)\n    {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, mt_InvalidInput());\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\n\n        uint256 redeemTokens;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n        if (redeemTokens == 0 && redeemAmount == 0) revert mt_RedeemEmpty();\n\n        /* Fail if redeem not allowed */\n        IOperatorDefender(operator).beforeMTokenRedeem(address(this), redeemer, redeemTokens);\n\n        require(_getCashPrior() >= redeemAmount, mt_RedeemCashNotAvailable());\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n         */\n        totalSupply = totalSupply - redeemTokens;\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n        /*\n         * We invoke _doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the mToken has redeemAmount less of cash.\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        if (doTransfer) _doTransferOut(redeemer, redeemAmount);\n        totalUnderlying -= redeemAmount;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), redeemTokens);\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\n    }\n    /**\n     * @notice User supplies assets into the market and receives mTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param receiver The address of the account which is receiving the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @param minAmountOut The min amount to be received\n     * @param doTransfer If an actual transfer should be performed\n     */\n\n    function __mint(address minter, address receiver, uint256 mintAmount, uint256 minAmountOut, bool doTransfer)\n        private\n    {\n        IOperatorDefender(operator).beforeMTokenMint(address(this), minter);\n\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `_doTransferIn` for the minter and the mintAmount.\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the mToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        uint256 actualMintAmount = doTransfer ? _doTransferIn(minter, mintAmount) : mintAmount;\n        totalUnderlying += actualMintAmount;\n\n        /*\n         * We get the current exchange rate and calculate the number of mTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\n        require(mintTokens >= minAmountOut, mt_MinAmountNotValid());\n\n        // avoid exchangeRate manipulation\n        if (totalSupply == 0) {\n            totalSupply = 1000;\n            accountTokens[address(0)] = 1000;\n            mintTokens -= 1000;\n        }\n\n        /*\n         * We calculate the new total supply of mTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[receiver] = accountTokens[receiver] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, receiver, actualMintAmount, mintTokens);\n        emit Transfer(address(this), receiver, mintTokens);\n\n        /* We call the defense hook */\n        IOperatorDefender(operator).afterMTokenMint(address(this));\n\n        // Activate market by default if not entered already\n        bool isEntered = IOperator(operator).checkMembership(minter, address(this));\n        if (!isEntered) {\n            IOperator(operator).enterMarketsWithSender(minter);\n        }\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     */\n    function _transferTokens(address spender, address src, address dst, uint256 tokens) private {\n        IOperatorDefender(operator).beforeMTokenTransfer(address(this), src, dst, tokens);\n\n        require(src != dst, mt_TransferNotValid());\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint256 allowanceNew = startingAllowance - tokens;\n        uint256 srcTokensNew = accountTokens[src] - tokens;\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint256).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n    }\n}\n",
        "JumpRateModelV4.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IInterestRateModel} from \"src/interfaces/IInterestRateModel.sol\";\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\n/**\n * @title JumpRateModelV4\n * @notice Implementation of the IInterestRateModel interface for calculating interest rates\n */\ncontract JumpRateModelV4 is IInterestRateModel, Ownable {\n    // ----------- STORAGE ------------\n\n    error JumpRateModelV4_MultiplierNotValid();\n    error JumpRateModelV4_InputNotValid();\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    uint256 public override blocksPerYear;\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    uint256 public override multiplierPerBlock;\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    uint256 public override baseRatePerBlock;\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    uint256 public override jumpMultiplierPerBlock;\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    uint256 public override kink;\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    string public override name;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param blocksPerYear_ The estimated number of blocks per year\n     * @param baseRatePerYear The base APR, scaled by 1e18\n     * @param multiplierPerYear The rate increase in interest wrt utilization, scaled by 1e18\n     * @param jumpMultiplierPerYear The multiplier per block after utilization point\n     * @param kink_ The utilization point where the jump multiplier applies\n     * @param owner_ The owner of the contract\n     * @param name_ A user-friendly name for the contract\n     */\n    constructor(\n        uint256 blocksPerYear_,\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address owner_,\n        string memory name_\n    ) Ownable(owner_) {\n        blocksPerYear = blocksPerYear_;\n        name = name_;\n        _updateJumpRateModel(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    // ----------- OWNER ------------\n\n    /**\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external onlyOwner {\n        _updateJumpRateModel(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Updates the blocksPerYear in order to make interest calculations simpler\n     * @param blocksPerYear_ The new estimated eth blocks per year.\n     */\n    function updateBlocksPerYear(uint256 blocksPerYear_) external onlyOwner {\n        blocksPerYear = blocksPerYear_;\n    }\n\n    // ----------- PUBLIC ------------\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    function isInterestRateModel() external pure override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    function utilizationRate(uint256 cash, uint256 borrows, uint256 reserves) public pure override returns (uint256) {\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows * 1e18 / (cash + borrows - reserves);\n    }\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) public view override returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return util * multiplierPerBlock / 1e18 + baseRatePerBlock;\n        } else {\n            uint256 normalRate = kink * multiplierPerBlock / 1e18 + baseRatePerBlock;\n            uint256 excessUtil = util - kink;\n            return excessUtil * jumpMultiplierPerBlock / 1e18 + normalRate;\n        }\n    }\n\n    /**\n     * @inheritdoc IInterestRateModel\n     */\n    function getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactorMantissa)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 oneMinusReserveFactor = 1e18 - reserveFactorMantissa;\n        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = borrowRate * oneMinusReserveFactor / 1e18;\n        return utilizationRate(cash, borrows, reserves) * rateToPool / 1e18;\n    }\n\n    // ----------- PRIVATE ------------\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The base APR, scaled by 1e18\n     * @param multiplierPerYear The rate increase wrt utilization, scaled by 1e18\n     * @param jumpMultiplierPerYear The multiplier per block after utilization point\n     * @param kink_ The utilization point where the jump multiplier applies\n     */\n    function _updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) private {\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\n        multiplierPerBlock = multiplierPerYear * 1e18 / (blocksPerYear * kink_);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n}\n"
    }
}