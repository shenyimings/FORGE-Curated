{
    "vfp_id": "vfp_00229",
    "project_name": "Cloak V1 - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Front-running the encryption-keyâ€“registration transaction can deny service to function finalizeBundle",
            "description": "The function registerNewEncryptionKey in ScrollChainValidium.sol is called after contract deployment to register the first encryption key, which is associated with a specific message index. However, because the key registration occurs in a separate transaction after deployment, malicious actors can front-run this transaction by submitting cross-chain messages beforehand. This causes the nextCrossDomainMessageIndex to increment, so that when finalizeBundle is later called, it attempts to retrieve an encryption key for message index 0, but no such key exists because the first registered key applies to a higher index. This leads to the _getEncryptionKey function reverting with ErrorUnknownEncryptionKey, thereby preventing the finalization of the bundle. The root cause is the lack of atomicity between contract deployment and initial key registration. An attacker can exploit this by monitoring the mempool for the key registration transaction and submitting their own messages first. The impact is a denial-of-service condition on bundle finalization, which disrupts the system's ability to process messages securely and reliably.\n",
            "severity": "High",
            "location": [
                "ScrollChainValidium.sol::registerNewEncryptionKey",
                "ScrollChainValidium.sol::_finalizeBundle",
                "ScrollChainValidium.sol::_getEncryptionKey"
            ],
            "files": [
                "scroll-contracts/src/validium/ScrollChainValidium.sol"
            ]
        }
    ],
    "affected_files": {
        "ScrollChainValidium.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL1MessageQueueV2} from \"../L1/rollup/IL1MessageQueueV2.sol\";\nimport {IRollupVerifier} from \"../libraries/verifier/IRollupVerifier.sol\";\nimport {IScrollChainValidium} from \"./IScrollChainValidium.sol\";\n\nimport {BatchHeaderValidiumV0Codec} from \"./codec/BatchHeaderValidiumV0Codec.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title ScrollChainValidium\ncontract ScrollChainValidium is AccessControlUpgradeable, PausableUpgradeable, IScrollChainValidium {\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given genesis batch is invalid.\n    error ErrorInvalidGenesisBatch();\n\n    /// @dev Thrown when finalizing a verified batch.\n    error ErrorBatchIsAlreadyVerified();\n\n    /// @dev Thrown when importing genesis batch twice.\n    error ErrorGenesisBatchImported();\n\n    /// @dev Thrown when the batch hash is incorrect.\n    error ErrorIncorrectBatchHash();\n\n    /// @dev Thrown when reverting a finalized batch.\n    error ErrorRevertFinalizedBatch();\n\n    /// @dev Thrown when the given state root is zero.\n    error ErrorStateRootIsZero();\n\n    /// @dev Thrown when given batch is not committed before.\n    error ErrorBatchNotCommitted();\n\n    /// @dev Error thrown when encryption key length is invalid.\n    error ErrorInvalidEncryptionKeyLength();\n\n    /// @dev Error thrown the user attempts to use an encryption key that is unknown.\n    error ErrorUnknownEncryptionKey();\n\n    /// @dev Error thrown the user attempts to use an encryption key that is deprecated.\n    error ErrorDeprecatedEncryptionKey();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for import genesis batch.\n    bytes32 public constant GENESIS_IMPORTER_ROLE = keccak256(\"GENESIS_IMPORTER_ROLE\");\n\n    /// @notice The role for sequencer who can commit batch.\n    bytes32 public constant SEQUENCER_ROLE = keccak256(\"SEQUENCER_ROLE\");\n\n    /// @notice The role for prover who can finalize batch.\n    bytes32 public constant PROVER_ROLE = keccak256(\"PROVER_ROLE\");\n\n    /// @notice The role that can rotate encryption keys.\n    bytes32 public constant KEY_MANAGER_ROLE = keccak256(\"KEY_MANAGER_ROLE\");\n\n    /***********************\n     * Immutable Variables *\n     ***********************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public immutable layer2ChainId;\n\n    /// @notice The address of `L1MessageQueueV2`.\n    address public immutable messageQueueV2;\n\n    /// @notice The address of `MultipleVersionRollupVerifier`.\n    address public immutable verifier;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct EncryptionKey {\n        // The on-chain message index when the key was set.\n        uint256 msgIndex;\n        // The 33-bytes compressed public key, i.e. encryption key.\n        bytes key;\n    }\n\n    /*********************\n     * Storage Variables *\n     *********************/\n\n    /// @inheritdoc IScrollChainValidium\n    uint256 public override lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChainValidium\n    uint256 public override lastCommittedBatchIndex;\n\n    /// @dev Mapping from batch index to batch hash.\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @dev Mapping from batch index to corresponding state root in Validium L3.\n    mapping(uint256 => bytes32) public override stateRoots;\n\n    /// @dev Mapping from batch index to corresponding withdraw root in Validium L3.\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /// @dev An array of encryption keys.\n    EncryptionKey[] public encryptionKeys;\n\n    /// @dev The storage slots reserved for future usage.\n    uint256[50] private __gap;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Constructor for `ScrollChainValidium` implementation contract.\n    ///\n    /// @param _chainId The chain id of L2.\n    /// @param _messageQueueV2 The address of `L1MessageQueueV2`.\n    /// @param _verifier The address of `MultipleVersionRollupVerifier`.\n    constructor(\n        uint64 _chainId,\n        address _messageQueueV2,\n        address _verifier\n    ) {\n        _disableInitializers();\n\n        layer2ChainId = _chainId;\n        messageQueueV2 = _messageQueueV2;\n        verifier = _verifier;\n    }\n\n    /// @notice Initialize the storage of ScrollChainValidium.\n    /// @param _admin The address of the admin.\n    function initialize(address _admin) external initializer {\n        __Context_init();\n        __ERC165_init();\n        __AccessControl_init();\n        __Pausable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChainValidium\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /// @inheritdoc IScrollChainValidium\n    function getLatestEncryptionKey() external view override returns (uint256, bytes memory) {\n        uint256 _numKeys = encryptionKeys.length;\n        if (_numKeys == 0) revert ErrorUnknownEncryptionKey();\n        return (_numKeys - 1, encryptionKeys[_numKeys - 1].key);\n    }\n\n    /// @inheritdoc IScrollChainValidium\n    function getEncryptionKey(uint256 _keyId) external view override returns (bytes memory) {\n        uint256 _numKeys = encryptionKeys.length;\n        if (_numKeys == 0) revert ErrorUnknownEncryptionKey();\n        if (_keyId >= _numKeys) revert ErrorUnknownEncryptionKey();\n        if (_keyId < _numKeys - 1) revert ErrorDeprecatedEncryptionKey();\n        return encryptionKeys[_numKeys - 1].key;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @param _batchHeader The header of the genesis batch.\n    function importGenesisBatch(bytes calldata _batchHeader) external onlyRole(GENESIS_IMPORTER_ROLE) {\n        (uint256 batchPtr, uint256 _length) = BatchHeaderValidiumV0Codec.loadAndValidate(_batchHeader);\n        // batch index should be 0 for genesis batch\n        if (BatchHeaderValidiumV0Codec.getBatchIndex(batchPtr) != 0) {\n            revert ErrorInvalidGenesisBatch();\n        }\n        // parant batch hash should be 0 for genesis batch\n        if (BatchHeaderValidiumV0Codec.getParentBatchHash(batchPtr) != bytes32(0)) {\n            revert ErrorInvalidGenesisBatch();\n        }\n        // withdraw root should be 0 for genesis batch\n        if (BatchHeaderValidiumV0Codec.getWithdrawRoot(batchPtr) != bytes32(0)) {\n            revert ErrorInvalidGenesisBatch();\n        }\n\n        bytes32 _postStateRoot = BatchHeaderValidiumV0Codec.getPostStateRoot(batchPtr);\n\n        // check state root\n        if (_postStateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        // check whether the genesis batch is imported\n        if (stateRoots[0] != bytes32(0)) revert ErrorGenesisBatchImported();\n\n        bytes32 _batchHash = BatchHeaderValidiumV0Codec.computeBatchHash(batchPtr, _length);\n\n        committedBatches[0] = _batchHash;\n        stateRoots[0] = _postStateRoot;\n\n        emit CommitBatch(0, _batchHash);\n        emit FinalizeBatch(0, _batchHash, _postStateRoot, bytes32(0));\n    }\n\n    /// @inheritdoc IScrollChainValidium\n    function commitBatch(\n        uint8 version,\n        bytes32 parentBatchHash,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata commitment\n    ) external onlyRole(SEQUENCER_ROLE) whenNotPaused {\n        if (postStateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        uint256 cachedLastCommittedBatchIndex = lastCommittedBatchIndex;\n        if (parentBatchHash != committedBatches[cachedLastCommittedBatchIndex]) {\n            revert ErrorIncorrectBatchHash();\n        }\n\n        cachedLastCommittedBatchIndex += 1;\n        bytes memory batchHeader = BatchHeaderValidiumV0Codec.encode(\n            version,\n            uint64(cachedLastCommittedBatchIndex),\n            parentBatchHash,\n            postStateRoot,\n            withdrawRoot,\n            commitment\n        );\n        bytes32 batchHash = BatchHeaderValidiumV0Codec.computeBatchHash(batchHeader);\n\n        lastCommittedBatchIndex = cachedLastCommittedBatchIndex;\n        committedBatches[cachedLastCommittedBatchIndex] = batchHash;\n        stateRoots[cachedLastCommittedBatchIndex] = postStateRoot;\n        withdrawRoots[cachedLastCommittedBatchIndex] = withdrawRoot;\n\n        emit CommitBatch(cachedLastCommittedBatchIndex, batchHash);\n    }\n\n    /// @inheritdoc IScrollChainValidium\n    function revertBatch(bytes calldata batchHeader) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 lastBatchIndex = lastCommittedBatchIndex;\n        (, , uint256 startBatchIndex) = _loadBatchHeader(batchHeader, lastBatchIndex);\n\n        // check finalization\n        if (startBatchIndex <= lastFinalizedBatchIndex) revert ErrorRevertFinalizedBatch();\n\n        // actual revert\n        for (uint256 i = lastBatchIndex; i >= startBatchIndex; --i) {\n            delete committedBatches[i];\n            delete stateRoots[i];\n            delete withdrawRoots[i];\n        }\n        emit RevertBatch(startBatchIndex, lastBatchIndex);\n\n        // update `lastCommittedBatchIndex`\n        lastCommittedBatchIndex = startBatchIndex - 1;\n    }\n\n    /// @inheritdoc IScrollChainValidium\n    function finalizeBundle(\n        bytes calldata batchHeader,\n        uint256 totalL1MessagesPoppedOverall,\n        bytes calldata aggrProof\n    ) external override onlyRole(PROVER_ROLE) whenNotPaused {\n        _finalizeBundle(batchHeader, totalL1MessagesPoppedOverall, aggrProof);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    function registerNewEncryptionKey(bytes memory _key) external onlyRole(KEY_MANAGER_ROLE) {\n        if (_key.length != 33) revert ErrorInvalidEncryptionKeyLength();\n        uint256 _keyId = encryptionKeys.length;\n\n        // The message from `nextCrossDomainMessageIndex` will utilise the newly registered encryption key.\n        uint256 _msgIndex = IL1MessageQueueV2(messageQueueV2).nextCrossDomainMessageIndex();\n        encryptionKeys.push(EncryptionKey(_msgIndex, _key));\n\n        emit NewEncryptionKey(_keyId, _msgIndex, _key);\n    }\n\n    /// @notice Pause the contract\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to do common actions before actual batch finalization.\n    function _beforeFinalizeBatch(bytes calldata batchHeader)\n        internal\n        view\n        returns (\n            uint256 version,\n            bytes32 batchHash,\n            uint256 batchIndex,\n            uint256 prevBatchIndex\n        )\n    {\n        uint256 batchPtr;\n        // compute pending batch hash and verify\n        (batchPtr, batchHash, batchIndex) = _loadBatchHeader(batchHeader, lastCommittedBatchIndex);\n\n        // make sure don't finalize batch multiple times\n        prevBatchIndex = lastFinalizedBatchIndex;\n        if (batchIndex <= prevBatchIndex) revert ErrorBatchIsAlreadyVerified();\n\n        version = BatchHeaderValidiumV0Codec.getVersion(batchPtr);\n    }\n\n    /// @dev Internal function to do common actions after actual batch finalization.\n    function _afterFinalizeBatch(\n        uint256 batchIndex,\n        bytes32 batchHash,\n        uint256 totalL1MessagesPoppedOverall,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot\n    ) internal {\n        lastFinalizedBatchIndex = batchIndex;\n\n        if (totalL1MessagesPoppedOverall > 0) {\n            IL1MessageQueueV2(messageQueueV2).finalizePoppedCrossDomainMessage(totalL1MessagesPoppedOverall);\n        }\n\n        emit FinalizeBatch(batchIndex, batchHash, postStateRoot, withdrawRoot);\n    }\n\n    /// @dev Internal function to finalize a bundle.\n    /// @param batchHeader The header of the last batch in this bundle.\n    /// @param totalL1MessagesPoppedOverall The number of messages processed after this bundle.\n    /// @param aggrProof The bundle proof for this bundle.\n    function _finalizeBundle(\n        bytes calldata batchHeader,\n        uint256 totalL1MessagesPoppedOverall,\n        bytes calldata aggrProof\n    ) internal virtual {\n        // actions before verification\n        (uint256 version, bytes32 batchHash, uint256 batchIndex, uint256 prevBatchIndex) = _beforeFinalizeBatch(\n            batchHeader\n        );\n\n        // L1 message hashes are chained,\n        // this hash commits to the whole queue up to and including `totalL1MessagesPoppedOverall-1`\n        bytes32 messageQueueHash = totalL1MessagesPoppedOverall == 0\n            ? bytes32(0)\n            : IL1MessageQueueV2(messageQueueV2).getMessageRollingHash(totalL1MessagesPoppedOverall - 1);\n\n        bytes32 postStateRoot = stateRoots[batchIndex];\n        bytes32 withdrawRoot = withdrawRoots[batchIndex];\n\n        // Get the encryption key at the time of on-chain message queue index.\n        bytes memory encryptionKey = totalL1MessagesPoppedOverall == 0\n            ? _getEncryptionKey(0)\n            : _getEncryptionKey(totalL1MessagesPoppedOverall - 1);\n\n        bytes memory publicInputs = abi.encodePacked(\n            layer2ChainId,\n            messageQueueHash,\n            uint32(batchIndex - prevBatchIndex), // numBatches\n            stateRoots[prevBatchIndex], // _prevStateRoot\n            committedBatches[prevBatchIndex], // _prevBatchHash\n            postStateRoot,\n            batchHash,\n            withdrawRoot,\n            encryptionKey\n        );\n\n        // verify bundle, choose the correct verifier based on the last batch\n        // our off-chain service will make sure all unfinalized batches have the same batch version.\n        IRollupVerifier(verifier).verifyBundleProof(version, batchIndex, aggrProof, publicInputs);\n\n        // actions after verification\n        _afterFinalizeBatch(batchIndex, batchHash, totalL1MessagesPoppedOverall, postStateRoot, withdrawRoot);\n    }\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @param _lastCommittedBatchIndex The index of the last committed batch.\n    /// @return batchPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    /// @return _batchIndex The index of this batch.\n    /// @dev This function only works with batches whose hashes are stored in `committedBatches`.\n    function _loadBatchHeader(bytes calldata _batchHeader, uint256 _lastCommittedBatchIndex)\n        internal\n        view\n        virtual\n        returns (\n            uint256 batchPtr,\n            bytes32 _batchHash,\n            uint256 _batchIndex\n        )\n    {\n        // load version from batch header, it is always the first byte.\n        uint256 version;\n        assembly {\n            version := shr(248, calldataload(_batchHeader.offset))\n        }\n\n        uint256 length;\n        (batchPtr, length) = BatchHeaderValidiumV0Codec.loadAndValidate(_batchHeader);\n\n        _batchIndex = BatchHeaderValidiumV0Codec.getBatchIndex(batchPtr);\n\n        if (_batchIndex > _lastCommittedBatchIndex) revert ErrorBatchNotCommitted();\n\n        // check against local storage\n        _batchHash = BatchHeaderValidiumV0Codec.computeBatchHash(batchPtr, length);\n        if (committedBatches[_batchIndex] != _batchHash) {\n            revert ErrorIncorrectBatchHash();\n        }\n    }\n\n    /// @dev Internal function to get the relevant encryption key that was used to encrypt messages up to the provided message index.\n    /// @param _msgIndex The on-chain message queue index being finalised.\n    /// @return The encryption key used at the time of the provided on-chain message queue index.\n    function _getEncryptionKey(uint256 _msgIndex) internal view returns (bytes memory) {\n        // Start from the \"latest\" key and continue fetching keys until we find the key\n        // that was rotated before the message index we have been provided.\n        uint256 _numKeys = encryptionKeys.length;\n        if (_numKeys == 0) revert ErrorUnknownEncryptionKey();\n        EncryptionKey memory _encryptionKey = encryptionKeys[--_numKeys];\n\n        while (_encryptionKey.msgIndex > _msgIndex) {\n            if (_numKeys == 0) revert ErrorUnknownEncryptionKey();\n            _encryptionKey = encryptionKeys[--_numKeys];\n        }\n\n        return _encryptionKey.key;\n    }\n}\n"
    }
}