{
    "vfp_id": "vfp_00123",
    "project_name": "Jovay Rollup Contracts Audit.md",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-1283"
                ]
            },
            "title": "Mutable `layer2ChainId` Can Break Batch Verification and Cause DoS",
            "description": "The `Rollup` contract allows the `layer2ChainId` to be updated via `setL2ChainId` after initialization. However, this value is used in the commitment input for TEE proof verification in `verifyBatch`. If the chain ID is changed after batches are committed but before they are verified, the proof verification will fail due to mismatched commitments.\n\nThe root cause is the mutable nature of a parameter that is part of a cryptographic commitment. Since batch verification must proceed sequentially and each batch depends on the previous state, a single failed verification halts the entire chain.\n\nAn attacker with ownership privileges could change the `layer2ChainId` to intentionally break verification, causing a denial of service. Even accidental changes would freeze the system until a fix is deployed.\n\nThe impact is a complete halt in batch processing, preventing all withdrawals and message finalizations until the issue is resolved, leading to a full system freeze and loss of liveness.\n",
            "severity": "Medium",
            "location": [
                "Rollup.sol::setL2ChainId#361",
                "Rollup.sol::verifyBatch#187-218",
                "Rollup.sol::_verifyTeeProof#291-297"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "Inconsistent Handling of `l2MsgRoot` Across Proofs",
            "description": "The `Rollup.verifyBatch` function enforces consistency of the `postStateRoot` across multiple proof types (e.g., TEE and ZK proofs) by storing and comparing values. However, it does not perform the same check for the `l2MsgRoot`, allowing the second proof to overwrite the value without validation.\n\nThe root cause is the absence of a cross-proof consistency check for `l2MsgRoot`, relying instead on the assumption that valid proofs will inherently agree on the message root. This weakens the security model, which is designed to tolerate bugs in one proof system by requiring agreement between two independent verifiers.\n\nIf a vulnerability exists in one proof system, an attacker could generate two valid but inconsistent proofs—one with a legitimate `l2MsgRoot` and another with a malicious one—causing the system to accept an incorrect message root. This could allow invalid or forged L2→L1 messages to be processed.\n\nThe impact is a potential compromise of message integrity, leading to unauthorized withdrawals or execution of unapproved cross-chain actions, especially if one proof system is compromised. This undermines the redundancy-based security design.\n",
            "severity": "Medium",
            "location": [
                "Rollup.sol::verifyBatch#187-230",
                "Rollup.sol::_verifyTeeProof#291-297"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Free-Memory Pointer is Moved to a Non-Word-Aligned Address",
            "description": "In the loadAndValidate function of BatchHeaderCodec.sol, the free memory pointer (0x40) is updated by adding a length of 105 bytes, which is not a multiple of 32, breaking Solidity's requirement for 32-byte alignment. This misalignment can cause subsequent memory allocations to overwrite existing data or lead to out-of-bounds reads, resulting in undefined behavior or transaction reverts. Additionally, store functions in the same library write directly to memory without updating the free memory pointer, which could cause memory corruption if used outside the Rollup contract. The root cause is improper memory management in low-level assembly code. The impact includes potential runtime failures, data corruption, and unpredictable contract behavior, especially if the library is reused in other contexts.\n",
            "severity": "Medium",
            "location": [
                "BatchHeaderCodec.sol::loadAndValidate#47-56",
                "Rollup.sol#161-164"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/libraries/codec/BatchHeaderCodec.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Setter Truncates 64-bit `rollupTimeLimit` to 32 bits",
            "description": "In `Rollup.sol`, the `rollupTimeLimit` state variable is declared as `uint64`, but the setter function `setRollupTimeLimit` accepts a `uint32` parameter. This causes any value above 4,294,967,295 to be silently truncated, imposing an undocumented 32-bit cap on a 64-bit field. The root cause is a mismatch in parameter and variable size. An attacker or malicious owner could set a high value expecting full 64-bit range, but the truncation would result in a much lower effective limit, potentially disrupting protocol timing assumptions. This could lead to unexpected behavior in time-dependent logic, such as rollup finalization windows. The impact is moderate, primarily affecting configurability and introducing a silent failure mode.\n",
            "severity": "Medium",
            "location": [
                "Rollup.sol::setRollupTimeLimit#355",
                "Rollup.sol::rollupTimeLimit"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        }
    ],
    "affected_files": {
        "BatchHeaderCodec.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\n// solhint-disable no-inline-assembly\n/// @dev Below is the encoding for `Chunk`, total 40*n+1+m bytes.\n/// ```text\n///   * Field           Bytes       Type            Index       Comments\n///   * numBlocks       1           uint8           0           The number of blocks in this chunk\n///   * block[0]        40          BlockContext    1           The first block in this chunk\n///   * ......\n///   * block[i]        40          BlockContext    40*i+1      The (i+1)'th block in this chunk\n///   * ......\n///   * block[n-1]      40          BlockContext    40*n-39     The last block in this chunk\n///   * l2Transactions  dynamic     bytes           40*n+1      l2txRlpdatalength|l2txRlpdata|l2txRlpdatalength|l2txRlpdata| ...\n/// ```\n///\n/// @dev Below is the encoding for `BlockContext`, total 40 bytes.\n/// ```text\n///   * Field                   Bytes      Type         Index  Comments\n///   * spec_version            4          uint32       0      The spec_version of this block.\n///   * blockNumber             8          uint64       4      The height of this block.\n///   * timestamp               8          uint64       12     The timestamp of this block.\n///   * baseFee                 8          uint64       20     The base fee of this block. Currently, it is always 0, because we disable EIP-1559.\n///   * gasLimit                8          uint64       28     The gas limit of this block.\n///   * numTransactions         2          uint16       36     The number of transactions in this block, both L1 & L2 txs.\n///   * numL1Messages           2          uint16       38     The number of l1 messages in this block.\n/// ```\n\n/// @dev Below is the encoding for `BatchHeader` V0, total 89 + ceil(l1MessagePopped / 256) * 32 bytes.\n/// ```text\n///   * Field                   Bytes       Type        Index   Comments\n///   * version                 1           uint8       0       The batch version\n///   * batchIndex              8           uint64      1       The index of the batch\n///   * L1MsgRollingHash        32          bytes32     9       Number of total L1 message popped after the batch\n///   * dataHash                32          bytes32     41      The data hash of the batch\n///   * parentBatchHash         32          bytes32     73      The parent batch hash\n/// ```\nlibrary BatchHeaderCodec {\n    /// @dev The length of fixed parts of the batch header.\n    uint256 internal constant BATCH_HEADER_FIXED_LENGTH = 105;\n\n    /// @notice Load batch header in calldata to memory.\n    /// @param _batchHeader The encoded batch header bytes in calldata.\n    /// @return batchPtr The start memory offset of the batch header in memory.\n    /// @return length The length in bytes of the batch header.\n    function loadAndValidate(bytes calldata _batchHeader) internal pure returns (uint256 batchPtr, uint256 length) {\n        length = _batchHeader.length;\n        require(length == BATCH_HEADER_FIXED_LENGTH, \"INVALID_PARAMETER : batchHeader is invalid\");\n\n        // copy batch header to memory.\n        assembly {\n            batchPtr := mload(0x40)\n            calldatacopy(batchPtr, _batchHeader.offset, length)\n            mstore(0x40, add(batchPtr, length))\n        }\n    }\n\n    /// @notice Get the version of the batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _version The version of the batch header.\n    function version(uint256 batchPtr) internal pure returns (uint256 _version) {\n        assembly {\n            _version := shr(248, mload(batchPtr))\n        }\n    }\n\n        /// @notice Get the batch index of the batch.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _batchIndex The batch index of the batch.\n    function batchIndex(uint256 batchPtr) internal pure returns (uint256 _batchIndex) {\n        assembly {\n            _batchIndex := shr(192, mload(add(batchPtr, 1)))\n        }\n    }\n\n    /// @notice Get the number of L1 messages popped before this batch.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _l1RollingHash The the number of L1 messages popped before this batch.\n    function l1RollingHash(uint256 batchPtr) internal pure returns (bytes32 _l1RollingHash) {\n        assembly {\n            _l1RollingHash := mload(add(batchPtr, 9))\n        }\n    }\n\n    /// @notice Get the data hash of the batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _dataHash The data hash of the batch header.\n    function dataHash(uint256 batchPtr) internal pure returns (bytes32 _dataHash) {\n        assembly {\n            _dataHash := mload(add(batchPtr, 41))\n        }\n    }\n\n    /// @notice Get the parent batch hash of the batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _parentBatchHash The parent batch hash of the batch header.\n    function parentBatchHash(uint256 batchPtr) internal pure returns (bytes32 _parentBatchHash) {\n        assembly {\n            _parentBatchHash := mload(add(batchPtr, 73))\n        }\n    }\n\n    /// @notice Store the version of batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _version The version of batch header.\n    function storeVersion(uint256 batchPtr, uint256 _version) internal pure {\n        assembly {\n            mstore8(batchPtr, _version)\n        }\n    }\n\n    /// @notice Store the batch index of batch header.\n    /// @dev Because this function can overwrite the subsequent fields, it must be called before\n    /// `storeL1MessagePopped`, `storeTotalL1MessagePopped`, and `storeDataHash`.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _batchIndex The batch index.\n    function storeBatchIndex(uint256 batchPtr, uint256 _batchIndex) internal pure {\n        assembly {\n            mstore(add(batchPtr, 1), shl(192, _batchIndex))\n        }\n    }\n\n    /// @notice Store the total number of L1 messages popped after current batch to batch header.\n    /// @dev Because this function can overwrite the subsequent fields, it must be called before\n    /// `storeDataHash`.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _l1RollingHash The total number of L1 messages popped after current batch.\n    function storeL1RollingHash(uint256 batchPtr, bytes32 _l1RollingHash) internal pure {\n        assembly {\n            mstore(add(batchPtr, 9), _l1RollingHash)\n        }\n    }\n\n    /// @notice Store the data hash of batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _dataHash The data hash.\n    function storeDataHash(uint256 batchPtr, bytes32 _dataHash) internal pure {\n        assembly {\n            mstore(add(batchPtr, 41), _dataHash)\n        }\n    }\n\n    /// @notice Store the parent batch hash of batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _parentBatchHash The parent batch hash.\n    function storeParentBatchHash(uint256 batchPtr, bytes32 _parentBatchHash) internal pure {\n        assembly {\n            mstore(add(batchPtr, 73), _parentBatchHash)\n        }\n    }\n\n    /// @notice Compute the batch hash.\n    /// @dev Caller should make sure that the encoded batch header is correct.\n    ///\n    /// @param batchPtr The memory offset of the encoded batch header.\n    /// @param length The length of the batch.\n    /// @return _batchHash The hash of the corresponding batch.\n    function computeBatchHash(uint256 batchPtr, uint256 length) internal pure returns (bytes32 _batchHash) {\n        // in the current version, the hash is: keccak(BatchHeader without timestamp)\n        assembly {\n            _batchHash := keccak256(batchPtr, length)\n        }\n    }\n}\n",
        "Rollup.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IRollup.sol\";\nimport \"../libraries/codec/BatchHeaderCodec.sol\";\nimport \"../libraries/verifier/ITeeRollupVerifier.sol\";\nimport \"../libraries/verifier/IZkRollupVerifier.sol\";\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IL1MailQueue} from \"../interfaces/IL1MailQueue.sol\";\n\n\ncontract Rollup is IRollup, OwnableUpgradeable, PausableUpgradeable {\n\n    error NotSupportZkProof();\n\n    /// @notice The max number of txs in a chunk, fill by bytes32(0) if not enough.\n    uint32 public maxTxsInChunk;\n\n    /// @notice The max number of blocks in a chunk, not need fill by (0) if not enough.\n    uint32 public maxBlockInChunk;\n\n    /// @notice The max tx data size in a chunk;\n    uint32 public maxCallDataInChunk;\n\n    /// @notice The max zk circle in a chunk;\n    uint32 public maxZkCircleInChunk;\n\n    /// @notice The max tx data (byte) limit in L1;\n    uint32 public l1BlobNumberLimit;\n\n    /// @notice Time limit between two rollups;\n    uint64 public rollupTimeLimit;\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public layer2ChainId;\n\n    // The batch index that has been committed;\n    uint256 public lastCommittedBatch;\n\n    // The batch index that has been zk verified;\n    uint256 public lastZkVerifiedBatch;\n\n    // The batch index that has been tee verified;\n    uint256 public lastTeeVerifiedBatch;\n\n    // Record the batchhash corresponding to the batch\n    mapping(uint256 => bytes32) public committedBatches;\n\n    // Record the stateroot corresponding to each batch of L2 and the stateroot of the last block of the batch\n    mapping(uint256 => bytes32) public finalizedStateRoots;\n\n    // batchindex corresponds to the root of the L2withroot message tree; it is used to verify L2 transactions;\n    mapping(uint256 => bytes32) public l2MsgRoots;\n\n    // total pop l1msg of batch;\n    mapping(uint256 => uint256) public l1MsgCount;\n\n    address public zk_verifier;  // zk_verifier contract address, compatibility operations such as upgrades are handled by the verifier contract\n    address public tee_verifier;  // tee_verifier contract address, compatibility operations such as upgrades are handled by the verifier contract\n    address public l1_mail_box;   // mail box address; L1 Msg Rolling hash storage in it\n\n    /// @notice Whether an account is a relayer.\n    mapping(address => bool) public isRelayer;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlyRelayer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isRelayer[_msgSender()], \"INVALID_PERMISSION : sender is not relayer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n//    /// @notice Constructor implementation .\n    constructor(\n    ) {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint64 _chainId,\n        address _zk_verifier,\n        address _tee_verifier,\n        address _l1_mail_box,\n        uint32 _maxTxsInChunk,\n        uint32 _maxBlockInChunk,\n        uint32 _maxCallDataInChunk,\n        uint32 _maxZkCircleInChunk,\n        uint32 _l1BlobNumberLimit,\n        uint32 _rollupTimeLimit\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n\n        require(_zk_verifier != address(0) || _tee_verifier != address(0), \"INVALID_PARAMETER : must specify one verifier address\");\n        layer2ChainId = _chainId;\n        zk_verifier = _zk_verifier;\n        tee_verifier = _tee_verifier;\n        l1_mail_box = _l1_mail_box;\n        maxTxsInChunk = _maxTxsInChunk;\n        maxBlockInChunk = _maxBlockInChunk;\n        maxCallDataInChunk = _maxCallDataInChunk;\n        maxZkCircleInChunk = _maxZkCircleInChunk;\n        l1BlobNumberLimit = _l1BlobNumberLimit;\n        rollupTimeLimit = _rollupTimeLimit;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n    /// @notice Import layer 2 genesis block\n    /// @param _batchHeader The header of the genesis batch.\n    /// @param _stateRoot The state root of the genesis block.\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external onlyOwner {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"INVALID_PARAMETER : state root is zero\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"INVALID_PARAMETER : genesis batch is imported\");\n\n        (uint256 memPtr, , bytes32 _batchHash, ) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderCodec.version(memPtr) +\n                                BatchHeaderCodec.batchIndex(memPtr);\n            require(sum == 0, \"INVALID_PARAMETER : genesis batch has no zero field\");\n            require(BatchHeaderCodec.l1RollingHash(memPtr) == bytes32(0), \"INVALID_PARAMETER : genesis batch rolling hash must be zero\");\n            require(BatchHeaderCodec.dataHash(memPtr) != bytes32(0), \"INVALID_PARAMETER : genesis batch data hash is zero\");\n            require(BatchHeaderCodec.parentBatchHash(memPtr) == bytes32(0), \"INVALID_PARAMETER : genesis parent batch hash must be zero\");\n        }\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        lastCommittedBatch = 0;\n        lastZkVerifiedBatch = 0;\n        lastTeeVerifiedBatch = 0;\n        l1MsgCount[0] = 0;\n        l2MsgRoots[0] = bytes32(0);\n        emit CommitBatch( 0, _batchHash);\n    }\n\n    /// @inheritdoc IRollup\n    function commitBatch(\n        uint8 _version,\n        uint256 _batchIndex,\n        uint256 _totalL1MessagePopped\n    ) external override OnlyRelayer whenNotPaused {\n        require(_batchIndex == lastCommittedBatch + 1, \"INVALID_PARAMETER : commit batch one by one\");\n\n        uint256 BATCH_HEADER_LENGTH = BatchHeaderCodec.BATCH_HEADER_FIXED_LENGTH;\n        // init empty batch\n        uint256 batchPtr;\n        assembly {\n            batchPtr := mload(0x40)\n            mstore(0x40, add(batchPtr, BATCH_HEADER_LENGTH))\n        }\n\n        BatchHeaderCodec.storeVersion(batchPtr, _version);\n        BatchHeaderCodec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderCodec.storeL1RollingHash(\n            batchPtr,\n            IL1MailQueue(l1_mail_box).getMsg(_totalL1MessagePopped)\n        );\n        BatchHeaderCodec.storeDataHash(batchPtr, _getBlobDataHash());\n        BatchHeaderCodec.storeParentBatchHash(batchPtr, committedBatches[_batchIndex - 1]);\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderCodec.computeBatchHash(\n            batchPtr,\n            BatchHeaderCodec.BATCH_HEADER_FIXED_LENGTH\n        );\n\n        committedBatches[_batchIndex] = _batchHash;\n        lastCommittedBatch =  _batchIndex;\n        l1MsgCount[_batchIndex] = _totalL1MessagePopped;\n        emit CommitBatch(_batchIndex, _batchHash);\n    }\n\n    /// @inheritdoc IRollup\n    function verifyBatch(\n        uint8 _prove_type,\n        bytes calldata _batchHeader,\n        bytes32 _postStateRoot,\n        bytes32 _l2MsgRoot,\n        bytes calldata _proof\n    ) external override OnlyRelayer whenNotPaused {\n        require(_prove_type == 0 || _prove_type == 1, \"INVALID_PARAMETER : invalid prove type\");\n        require(_postStateRoot != bytes32(0), \"INVALID_PARAMETER : invalid state root\");\n        uint256 _verifiedBatchIndex = _prove_type == 0 ? lastZkVerifiedBatch : lastTeeVerifiedBatch;\n\n        // compute pending batch hash and verify\n        (\n            ,\n            uint256 _batchIndex,\n            bytes32 _batchHash,\n        ) = _loadBatchHeader(_batchHeader);\n        require(_batchIndex == _verifiedBatchIndex + 1, \"INVALID_PARAMETER : invalid verify batch index, must one by one\");\n        require(committedBatches[_batchIndex] != bytes32(0) && committedBatches[_batchIndex] ==  _batchHash, \"INVALID_PARAMETER : invalid commit batch hash\");\n        require(finalizedStateRoots[_batchIndex] == bytes32(0) || finalizedStateRoots[_batchIndex] == _postStateRoot, \"INVALID_PARAMETER : invalid verify state root\");\n        bytes memory _publicInput = abi.encodePacked(\n            layer2ChainId,\n            finalizedStateRoots[_verifiedBatchIndex], // _prevStateRoot\n            _postStateRoot,\n            _batchHash,\n            _l2MsgRoot\n        );\n        if (_prove_type == 0) {\n            revert NotSupportZkProof();\n        } else if (_prove_type == 1) {\n            _verifyTeeProof(_proof, _publicInput);\n        }\n\n        // TODO : add finalize check\n//        if ((_prove_type == 0 && lastTeeVerifiedBatch >= _batchIndex) || (_prove_type == 1 && lastZkVerifiedBatch >= _batchIndex)) {\n        // after verify update contract storage\n        if (finalizedStateRoots[_batchIndex] == bytes32(0)) {\n            finalizedStateRoots[_batchIndex] = _postStateRoot;\n        }\n        l2MsgRoots[_batchIndex] = _l2MsgRoot;\n        IL1MailQueue(l1_mail_box).popMsgs(l1MsgCount[_batchIndex]);\n//        }\n        emit VerifyBatch(_prove_type, _batchIndex, _batchHash, _postStateRoot, _l2MsgRoot);\n    }\n\n    /// @inheritdoc IRollup\n    /// @dev If the owner want to revert a sequence of batches by sending multiple transactions,\n    ///      make sure to revert recent batches first.\n    /// can only revert L2; L1 can not be revert;\n    function revertBatches(uint256 _newLastBatchIndex) external override onlyOwner {\n        require(_newLastBatchIndex < lastCommittedBatch, \"INVALID_PARAMETER : revert lastCommitBatchIndex must smaller than current\");\n        require(lastCommittedBatch - _newLastBatchIndex <= 100, \"INVALID_PARAMETER : revert block number must smaller than 100 for gas limit\");\n        require(_newLastBatchIndex >= lastZkVerifiedBatch, \"INVALID_PARAMETER : revert block number bigger than last zk verify block number\");\n        require(_newLastBatchIndex >= lastTeeVerifiedBatch, \"INVALID_PARAMETER : revert block number bigger than last tee verify block number\");\n\n        // actual revert\n        for (uint256 _batchIndex = lastCommittedBatch; _batchIndex > _newLastBatchIndex; --_batchIndex) {\n            committedBatches[_batchIndex] = bytes32(0);\n        }\n        lastCommittedBatch = _newLastBatchIndex;\n    }\n\n    function getL2MsgRoot(uint256 batch_index) external view override returns (bytes32) {\n        return l2MsgRoots[batch_index];\n    }\n\n    function _getBlobDataHash() internal virtual returns (bytes32 _blobDataHash) {\n        uint32 blobNumberLimit = l1BlobNumberLimit;\n        assembly {\n            let dataStart := mload(0x40)\n            let offset := 0\n            let i := 0\n            for {} lt(i, blobNumberLimit) { i := add(i, 1) } {\n                let hash := blobhash(i)\n                if iszero(hash) {\n                    break\n                }\n                mstore(add(dataStart, offset), hash)\n                offset := add(offset, 0x20)\n            }\n            _blobDataHash := keccak256(dataStart, offset)\n            mstore(0x40, add(dataStart, offset))\n        }\n        emit BlobDataHash(_blobDataHash);\n    }\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchIndex The index of the loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    /// @return _l1MsgRollingHash The rolling hash of L1 msg on this batch.\n    function _loadBatchHeader(\n        bytes calldata _batchHeader\n    ) internal pure returns (uint256 memPtr, uint256 _batchIndex, bytes32 _batchHash, bytes32 _l1MsgRollingHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderCodec.loadAndValidate(_batchHeader);\n        // compute batch hash\n        _batchHash = BatchHeaderCodec.computeBatchHash(memPtr, _length);\n        _batchIndex = BatchHeaderCodec.batchIndex(memPtr);\n        _l1MsgRollingHash = BatchHeaderCodec.l1RollingHash(memPtr);\n    }\n\n    function _verifyTeeProof(bytes memory _proof, bytes memory _publicInput) internal {\n        bytes32 _commitment = keccak256(_publicInput);\n        (uint32 error_code, bytes32 commitment) = ITeeRollupVerifier(tee_verifier).verifyProof(_proof);\n        require(error_code == 0, \"ERROR : verify failed\");\n        require(commitment == _commitment, \"ERROR : error tee commitment for verify\");\n        lastTeeVerifiedBatch = lastTeeVerifiedBatch + 1;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add an account to the relayer list.\n    /// @param _account The address of account to add.\n    function addRelayer(address _account) external onlyOwner {\n        // @note Currently many external services rely on EOA sequencer to decode metadata directly from tx.calldata.\n        // So we explicitly make sure the account is EOA.\n        require(_account.code.length == 0, \"INVALID_PERMISSION : relayer account must be a eoa\");\n\n        isRelayer[_account] = true;\n    }\n\n    /// @notice Remove an account from the relayer list.\n    /// @param _account The address of account to remove.\n    function removeRelayer(address _account) external onlyOwner {\n        isRelayer[_account] = false;\n    }\n\n    /// @notice Pause the contract\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Set maxTxsInChunk of tx size in a chunk.\n    /// @param _maxTxsInChunk The number of tx size in a chunk.\n    function setMaxTxsInChunk(uint32 _maxTxsInChunk) external onlyOwner {\n        maxTxsInChunk = _maxTxsInChunk;\n    }\n\n    /// @notice Set maxBlockInChunk of block size in a chunk.\n    /// @param _maxBlockInChunk The number of block size in a chunk.\n    function setMaxBlockInChunk(uint32 _maxBlockInChunk) external onlyOwner {\n        maxBlockInChunk = _maxBlockInChunk;\n    }\n\n    /// @notice Set maxCallDataInChunk of tx data size in a chunk.\n    /// @param _maxCallDataInChunk The number of tx data size in a chunk.\n    function setMaxCallDataInChunk(uint32 _maxCallDataInChunk) external onlyOwner {\n        maxCallDataInChunk = _maxCallDataInChunk;\n    }\n\n    /// @notice Set l1BlobNumberLimit of the limit of l1 tx data size.\n    /// @param _l1BlobNumberLimit The limit of L1 tx data size.\n    function setL1BlobNumberLimit(uint32 _l1BlobNumberLimit) external onlyOwner {\n        l1BlobNumberLimit = _l1BlobNumberLimit;\n    }\n\n    /// @notice Set rollupTimeLimit of the limit of l1 tx data size.\n    /// @param _rollupTimeLimit The limit of L1 tx data size.\n    function setRollupTimeLimit(uint32 _rollupTimeLimit) external onlyOwner {\n        rollupTimeLimit = _rollupTimeLimit;\n    }\n\n    /// @notice Set setL2ChainId\n    /// @param _layer2ChainId The chain Id of L2.\n    function setL2ChainId(uint64 _layer2ChainId) external onlyOwner {\n        layer2ChainId = _layer2ChainId;\n    }\n\n    /// @notice Set tee_verifier\n    /// @param _teeVerifierAddress The verifier address of tee.\n    function setTeeVerifierAddress(address _teeVerifierAddress) external onlyOwner whenPaused {\n        require(_teeVerifierAddress != address(0), \"INVALID_PARAMETER : must specify one verifier address\");\n        tee_verifier = _teeVerifierAddress;\n    }\n\n    /// @notice Set zk_verifier\n    /// @param _zkVerifierAddress The verifier address of tee.\n    function setZkVerifierAddress(address _zkVerifierAddress) external onlyOwner whenPaused {\n        require(_zkVerifierAddress != address(0), \"INVALID_PARAMETER : must specify one verifier address\");\n        zk_verifier = _zkVerifierAddress;\n    }\n}"
    }
}