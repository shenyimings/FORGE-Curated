{
    "vfp_id": "vfp_00007",
    "project_name": "2025-06-reserveprotocol-solidity400-securityreview.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Redundant Auction End Time Storage",
            "description": "The system maintains auction end times in two separate data structures: the `endTime` field within the Auction struct and the `auctionEnds` mapping in the Folio contract. This redundancy increases the risk of state inconsistency because both must be updated in sync across multiple functions, such as in `bid` and `closeAuction`. The root cause is poor data model design, leading to duplicated state. An attacker could potentially exploit a scenario where these values fall out of sync due to a logic error or incomplete update, leading to incorrect auction state transitions. The impact includes potential manipulation of auction timing, which could affect bid validity and fairness.\n",
            "severity": "Medium",
            "location": [
                "Folio.sol::closeAuction#773-789",
                "AuctionLib.sol::bid#179-235",
                "AuctionLib.sol#48-57"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol",
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/utils/AuctionLib.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Unbounded Iteration in Folio Functions",
            "description": "Several externally callable functions in the Folio contract iterate over variable-sized data structures such as `basket.values` and `feeRecipients`, including `startRebalance`, `getRebalance`, `totalAssets`, `toAssets`, `mint`, `redeem`, and `distributeFees`. The cause is the use of loops over dynamic arrays without checks on their size. If the number of tokens or fee recipients grows sufficiently large, the gas cost of these functions could exceed the block gas limit, rendering them uncallable. An attacker could exploit this by inflating the size of these collections, leading to a denial of service for critical rebalancing and fee distribution operations. While the report estimates this would require an impractically large number of tokens (~2.75 million), the risk remains as the system scales.\n",
            "severity": "Medium",
            "location": [
                "Folio.sol::startRebalance",
                "Folio.sol::getRebalance",
                "Folio.sol::totalAssets",
                "Folio.sol::toAssets",
                "Folio.sol::mint",
                "Folio.sol::redeem",
                "Folio.sol::distributeFees",
                "Folio.sol::setFeeRecipients"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol"
            ]
        }
    ],
    "affected_files": {
        "AuctionLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IBidderCallee } from \"@interfaces/IBidderCallee.sol\";\nimport { IFolio } from \"@interfaces/IFolio.sol\";\n\nimport { D18, D27, MAX_AUCTION_PRICE, MAX_AUCTION_PRICE_RANGE, MAX_TOKEN_BALANCE } from \"@utils/Constants.sol\";\nimport { MathLib } from \"@utils/MathLib.sol\";\n\nlibrary AuctionLib {\n    // stack-too-deep\n    struct AuctionArgs {\n        uint256 auctionId;\n        IERC20 sellToken;\n        IERC20 buyToken;\n        uint256 sellLimit;\n        uint256 buyLimit;\n        uint256 startPrice;\n        uint256 endPrice;\n        uint256 auctionBuffer;\n    }\n\n    /// Open a new auction\n    function openAuction(\n        IFolio.Rebalance storage rebalance,\n        mapping(uint256 auctionId => IFolio.Auction auction) storage auctions,\n        mapping(uint256 rebalanceNonce => mapping(bytes32 pair => uint256 endTime)) storage auctionEnds,\n        uint256 totalSupply,\n        uint256 auctionLength,\n        AuctionArgs memory args\n    ) external {\n        IFolio.RebalanceDetails storage sellDetails = rebalance.details[address(args.sellToken)];\n        IFolio.RebalanceDetails storage buyDetails = rebalance.details[address(args.buyToken)];\n\n        // confirm rebalance ongoing\n        require(\n            block.timestamp >= rebalance.startedAt + args.auctionBuffer && block.timestamp < rebalance.availableUntil,\n            IFolio.Folio__NotRebalancing()\n        );\n\n        // confirm tokens are in rebalance\n        require(sellDetails.inRebalance && buyDetails.inRebalance, IFolio.Folio__NotRebalancing());\n\n        // confirm no auction collision on token pair\n        {\n            bytes32 pair = AuctionLib.pairHash(args.sellToken, args.buyToken);\n            require(\n                block.timestamp > auctionEnds[rebalance.nonce][pair] + args.auctionBuffer,\n                IFolio.Folio__AuctionCollision()\n            );\n\n            auctionEnds[rebalance.nonce][pair] = block.timestamp + auctionLength;\n        }\n\n        // preserve limits relative ordering\n        require(\n            args.sellLimit >= sellDetails.limits.low && args.sellLimit <= sellDetails.limits.high,\n            IFolio.Folio__InvalidSellLimit()\n        );\n        require(\n            args.buyLimit >= buyDetails.limits.low && args.buyLimit <= buyDetails.limits.high,\n            IFolio.Folio__InvalidBuyLimit()\n        );\n\n        // confirm sellToken is in surplus and buyToken is in deficit\n        {\n            // {sellTok} = D27{sellTok/share} * {share} / D27\n            uint256 sellBalLimit = Math.mulDiv(args.sellLimit, totalSupply, D27, Math.Rounding.Ceil);\n            require(args.sellToken.balanceOf(address(this)) > sellBalLimit, IFolio.Folio__InvalidSellLimit());\n\n            // {buyTok} = D27{buyTok/share} * {share} / D27\n            uint256 buyBalLimit = Math.mulDiv(args.buyLimit, totalSupply, D27, Math.Rounding.Floor);\n            require(args.buyToken.balanceOf(address(this)) < buyBalLimit, IFolio.Folio__InvalidBuyLimit());\n        }\n\n        // ensure valid price range (startPrice == endPrice is valid)\n        require(\n            args.startPrice >= args.endPrice &&\n                args.endPrice != 0 &&\n                args.startPrice <= MAX_AUCTION_PRICE &&\n                args.startPrice / args.endPrice <= MAX_AUCTION_PRICE_RANGE,\n            IFolio.Folio__InvalidPrices()\n        );\n\n        // update spot limits to prevent double trading in the future by openAuctionUnrestricted()\n        sellDetails.limits.spot = args.sellLimit;\n        buyDetails.limits.spot = args.buyLimit;\n\n        // update low/high limits to prevent double trading in the future by openAuction()\n        sellDetails.limits.high = args.sellLimit;\n        buyDetails.limits.low = args.buyLimit;\n        // by lowering the high sell limit the AUCTION_LAUNCHER cannot backtrack and later buy the sellToken\n        // by raising the low buy limit the AUCTION_LAUNCHER cannot backtrack and later sell the buyToken\n        // intentional: by leaving the other 2 limits unchanged (sell.low and buy.high) there can be future\n        //              auctions to trade FURTHER, incase current auctions go better than expected\n\n        IFolio.Auction memory auction = IFolio.Auction({\n            rebalanceNonce: rebalance.nonce,\n            sellToken: args.sellToken,\n            buyToken: args.buyToken,\n            sellLimit: args.sellLimit,\n            buyLimit: args.buyLimit,\n            startPrice: args.startPrice,\n            endPrice: args.endPrice,\n            startTime: block.timestamp,\n            endTime: block.timestamp + auctionLength\n        });\n        auctions[args.auctionId] = auction;\n\n        emit IFolio.AuctionOpened(args.auctionId, auction);\n    }\n\n    /// Get bid parameters for an ongoing auction\n    /// @param totalSupply {share} Current total supply of the Folio\n    /// @param timestamp {s} Timestamp to fetch bid for\n    /// @param sellBal {sellTok} Folio's available balance of sell token, including any active fills\n    /// @param buyBal {buyTok} Folio's available balance of buy token, including any active fills\n    /// @param minSellAmount {sellTok} The minimum sell amount the bidder should receive\n    /// @param maxSellAmount {sellTok} The maximum sell amount the bidder should receive\n    /// @param maxBuyAmount {buyTok} The maximum buy amount the bidder is willing to offer\n    /// @return sellAmount {sellTok} The actual sell amount in the bid\n    /// @return bidAmount {buyTok} The corresponding buy amount\n    /// @return price D27{buyTok/sellTok} The price at the given timestamp as an 27-decimal fixed point\n    function getBid(\n        IFolio.Auction storage auction,\n        uint256 totalSupply,\n        uint256 timestamp,\n        uint256 sellBal,\n        uint256 buyBal,\n        uint256 minSellAmount,\n        uint256 maxSellAmount,\n        uint256 maxBuyAmount\n    ) external view returns (uint256 sellAmount, uint256 bidAmount, uint256 price) {\n        assert(minSellAmount <= maxSellAmount);\n\n        // checks auction is ongoing\n        // D27{buyTok/sellTok}\n        price = _price(auction, timestamp);\n\n        // {sellTok} = D27{sellTok/share} * {share} / D27\n        uint256 sellLimitBal = Math.mulDiv(auction.sellLimit, totalSupply, D27, Math.Rounding.Ceil);\n        uint256 sellAvailable = sellBal > sellLimitBal ? sellBal - sellLimitBal : 0;\n\n        // {buyTok} = D27{buyTok/share} * {share} / D27\n        uint256 buyLimitBal = Math.mulDiv(auction.buyLimit, totalSupply, D27, Math.Rounding.Floor);\n        uint256 buyAvailable = buyBal < buyLimitBal ? buyLimitBal - buyBal : 0;\n\n        // maximum valid token balance is 1e36; do not try to buy more than this\n        buyAvailable = Math.min(buyAvailable, MAX_TOKEN_BALANCE);\n\n        // {sellTok} = {buyTok} * D27 / D27{buyTok/sellTok}\n        uint256 sellAvailableFromBuy = Math.mulDiv(buyAvailable, D27, price, Math.Rounding.Floor);\n        sellAvailable = Math.min(sellAvailable, sellAvailableFromBuy);\n\n        // ensure auction is large enough to cover bid\n        require(sellAvailable >= minSellAmount, IFolio.Folio__InsufficientSellAvailable());\n\n        // {sellTok}\n        sellAmount = Math.min(sellAvailable, maxSellAmount);\n\n        // {buyTok} = {sellTok} * D27{buyTok/sellTok} / D27\n        bidAmount = Math.mulDiv(sellAmount, price, D27, Math.Rounding.Ceil);\n        require(bidAmount != 0 && bidAmount <= maxBuyAmount, IFolio.Folio__SlippageExceeded());\n    }\n\n    /// Bid in an ongoing auction\n    ///   If withCallback is true, caller must adhere to IBidderCallee interface and receives a callback\n    ///   If withCallback is false, caller must have provided an allowance in advance\n    /// @dev Callable by anyone\n    /// @param sellAmount {sellTok} Sell amount as returned by getBid\n    /// @param bidAmount {buyTok} Bid amount as returned by getBid\n    /// @param withCallback If true, caller must adhere to IBidderCallee interface and transfers tokens via callback\n    /// @param data Arbitrary data to pass to the callback\n    /// @return shouldRemoveFromBasket If true, the auction's sell token should be removed from the basket after\n    function bid(\n        IFolio.Auction storage auction,\n        mapping(bytes32 pair => uint256 endTime) storage auctionEnds,\n        uint256 totalSupply,\n        uint256 sellAmount,\n        uint256 bidAmount,\n        bool withCallback,\n        bytes calldata data\n    ) external returns (bool shouldRemoveFromBasket) {\n        // pay bidder\n        SafeERC20.safeTransfer(auction.sellToken, msg.sender, sellAmount);\n\n        // D27{sellTok/share}\n        uint256 sellBasketPresence;\n        {\n            // {sellTok}\n            uint256 sellBal = auction.sellToken.balanceOf(address(this));\n\n            // remove sell token from basket at 0 balance\n            if (sellBal == 0) {\n                shouldRemoveFromBasket = true;\n            }\n\n            // D27{sellTok/share} = {sellTok} * D27 / {share}\n            sellBasketPresence = Math.mulDiv(sellBal, D27, totalSupply, Math.Rounding.Ceil);\n            assert(sellBasketPresence >= auction.sellLimit); // function-use invariant\n        }\n\n        // D27{buyTok/share}\n        uint256 buyBasketPresence;\n        {\n            // {buyTok}\n            uint256 buyBalBefore = auction.buyToken.balanceOf(address(this));\n\n            // collect payment from bidder\n            if (withCallback) {\n                IBidderCallee(msg.sender).bidCallback(address(auction.buyToken), bidAmount, data);\n            } else {\n                SafeERC20.safeTransferFrom(auction.buyToken, msg.sender, address(this), bidAmount);\n            }\n\n            uint256 buyBalAfter = auction.buyToken.balanceOf(address(this));\n\n            require(buyBalAfter - buyBalBefore >= bidAmount, IFolio.Folio__InsufficientBid());\n\n            // D27{buyTok/share} = {buyTok} * D27 / {share}\n            buyBasketPresence = Math.mulDiv(buyBalAfter, D27, totalSupply, Math.Rounding.Floor);\n        }\n\n        // end auction at limits\n        // can still be griefed\n        // limits may not be reacheable due to limited precision + defensive roundings\n        if (sellBasketPresence == auction.sellLimit || buyBasketPresence >= auction.buyLimit) {\n            auction.endTime = block.timestamp - 1;\n            auctionEnds[pairHash(auction.sellToken, auction.buyToken)] = block.timestamp - 1;\n        }\n    }\n\n    // ==== Internal ====\n\n    /// @return p D27{buyTok/sellTok}\n    function _price(IFolio.Auction storage auction, uint256 timestamp) internal view returns (uint256 p) {\n        // ensure auction is ongoing\n        require(timestamp >= auction.startTime && timestamp <= auction.endTime, IFolio.Folio__AuctionNotOngoing());\n\n        if (timestamp == auction.startTime) {\n            return auction.startPrice;\n        }\n        if (timestamp == auction.endTime) {\n            return auction.endPrice;\n        }\n\n        uint256 elapsed = timestamp - auction.startTime;\n        uint256 auctionLength = auction.endTime - auction.startTime;\n\n        // D18{1}\n        // k = ln(P_0 / P_t) / t\n        uint256 k = MathLib.ln(Math.mulDiv(auction.startPrice, D18, auction.endPrice)) / auctionLength;\n\n        // P_t = P_0 * e ^ -kt\n        // D27{buyTok/sellTok} = D27{buyTok/sellTok} * D18{1} / D18\n        p = Math.mulDiv(auction.startPrice, MathLib.exp(-1 * int256(k * elapsed)), D18);\n        if (p < auction.endPrice) {\n            p = auction.endPrice;\n        }\n    }\n\n    /// @return pair The hash of the pair\n    function pairHash(IERC20 sellToken, IERC20 buyToken) internal pure returns (bytes32) {\n        return\n            sellToken > buyToken\n                ? keccak256(abi.encode(sellToken, buyToken))\n                : keccak256(abi.encode(buyToken, sellToken));\n    }\n}\n",
        "Folio.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ITrustedFillerRegistry, IBaseTrustedFiller } from \"@reserve-protocol/trusted-fillers/contracts/interfaces/ITrustedFillerRegistry.sol\";\n\nimport { AuctionLib } from \"@utils/AuctionLib.sol\";\nimport { D18, D27, MAX_TVL_FEE, MAX_MINT_FEE, MIN_MINT_FEE, MIN_AUCTION_LENGTH, MAX_AUCTION_LENGTH, MAX_FEE_RECIPIENTS, MAX_LIMIT, MAX_TOKEN_PRICE, MAX_TOKEN_PRICE_RANGE, MAX_TTL, RESTRICTED_AUCTION_BUFFER, ONE_OVER_YEAR, ONE_DAY } from \"@utils/Constants.sol\";\nimport { MathLib } from \"@utils/MathLib.sol\";\nimport { Versioned } from \"@utils/Versioned.sol\";\n\nimport { IFolioDAOFeeRegistry } from \"@interfaces/IFolioDAOFeeRegistry.sol\";\nimport { IFolio } from \"@interfaces/IFolio.sol\";\n\n/**\n * @title Folio\n * @author akshatmittal, julianmrodri, pmckelvy1, tbrent\n * @notice Folio is a backed ERC20 token with permissionless minting/redemption and a rebalancing mechanism.\n *\n * A Folio is backed by a flexible number of ERC20 tokens of any denomination/price (within assumed ranges, see README)\n * All tokens tracked by the Folio are required to mint/redeem. This forms the basket.\n *\n * There are 3 main roles:\n *   1. DEFAULT_ADMIN_ROLE: can set erc20 assets, fees, auction length, close auctions/rebalances, and deprecateFolio\n *   2. REBALANCE_MANAGER: can start/end rebalances\n *   3. AUCTION_LAUNCHER: can open auctions during an ongoing rebalance, and close auctions\n *\n * There is also an additional BRAND_MANAGER role that does not have any permissions. It is used off-chain.\n *\n * Rebalance lifecycle:\n *   startRebalance() -> openAuction() -> bid() -> [optional] closeAuction()\n *\n * After a new rebalance is started by the REBALANCE_MANAGER, there is a period of time where only the AUCTION_LAUNCHER\n * can open auctions. They can choose to act within the range of the REBALANCE_MANAGER's initial estimates. After this\n * period is over, anyone can open auctions until the rebalance expires.\n *\n * An auction for a given token pair can run any number of times. However it requires the sell token to be in surplus\n * and the buy token in deficit.\n *\n * Targets for the rebalance are called \"limits\" and defined in basket ratios: ratios of token to Folio shares, D27{tok/share}\n *\n * Fees:\n *   - TVL fee: fee per unit time. Max 10% annually. Causes supply inflation over time, discretely once a day.\n *   - Mint fee: fee on mint. Max 5%. Does not cause supply inflation.\n *\n * After fees have been applied, the DAO takes a cut based on the configuration of the FolioDAOFeeRegistry including\n * a minimum fee floor of 15bps. The remaining portion above 15bps is distributed to the Folio's fee recipients.\n * Note that this means it is possible for the fee recipients to receive nothing despite configuring a nonzero fee.\n */\ncontract Folio is\n    IFolio,\n    Initializable,\n    ERC20Upgradeable,\n    AccessControlEnumerableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Versioned\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IFolioDAOFeeRegistry public daoFeeRegistry;\n\n    /**\n     * Roles\n     */\n    bytes32 public constant REBALANCE_MANAGER = keccak256(\"REBALANCE_MANAGER\"); // expected to be trading governance's timelock\n    bytes32 public constant AUCTION_LAUNCHER = keccak256(\"AUCTION_LAUNCHER\"); // optional: EOA or multisig\n    bytes32 public constant BRAND_MANAGER = keccak256(\"BRAND_MANAGER\"); // optional: no permissions\n\n    /**\n     * Mandate\n     */\n    string public mandate; // mutable field that describes mission/brand of the Folio\n\n    /**\n     * Basket\n     */\n    EnumerableSet.AddressSet private basket;\n\n    /**\n     * Fees\n     */\n    FeeRecipient[] public feeRecipients;\n    uint256 public tvlFee; // D18{1/s} demurrage fee on AUM\n    uint256 public mintFee; // D18{1} fee on mint\n\n    /**\n     * System\n     */\n    uint256 public lastPoke; // {s}\n    uint256 public daoPendingFeeShares; // {share} shares pending to be distributed ONLY to the DAO\n    uint256 public feeRecipientsPendingFeeShares; // {share} shares pending to be distributed ONLY to fee recipients\n    bool public isDeprecated; // {bool} if true, Folio goes into redemption-only mode\n\n    modifier notDeprecated() {\n        require(!isDeprecated, Folio__FolioDeprecated());\n        _;\n    }\n\n    DeprecatedStruct[] private auctions_DEPRECATED;\n    mapping(address token => uint256 timepoint) private sellEnds_DEPRECATED; // {s} timestamp of last possible second we could sell the token\n    mapping(address token => uint256 timepoint) private buyEnds_DEPRECATED; // {s} timestamp of last possible second we could buy the token\n    uint256 private auctionDelay_DEPRECATED; // {s} delay in the APPROVED state before an auction can be opened by anyone\n\n    uint256 public auctionLength; // {s} length of an auction\n\n    // === 2.0.0 ===\n    mapping(uint256 auctionId => DeprecatedStruct details) private auctionDetails_DEPRECATED;\n    mapping(address token => uint256 amount) private dustAmount_DEPRECATED;\n\n    // === 3.0.0 ===\n    ITrustedFillerRegistry public trustedFillerRegistry;\n    bool public trustedFillerEnabled;\n    IBaseTrustedFiller private activeTrustedFill;\n\n    /**\n     * Rebalancing\n     *   REBALANCE_MANAGER\n     *   - There can only be 1 rebalance live at a time\n     *   - There can be an auction for each unique token pair in the basket\n     *   - A token can be ONLY sold or ONLY bought depending on whether it is in surplus or deficit\n     *   - Auctions are restricted to the AUCTION_LAUNCHER until rebalance.restrictedUntil\n     *   - Auctions cannot be launched after availableUntil, though their end time may extend past it\n     *   - The AUCTION_LAUNCHER acts within the bounds set by the REBALANCE_MANAGER, adding precision to limits/prices\n     *   - If the AUCTION_LAUNCHER is not active, the original spot estimates from the REBALANCE_MANAGER are used\n     *   - At anytime the rebalance can be stopped or a new one can be started (closing live auctions)\n     *   - The AUCTION_LAUNCHER is limited in the damage they can do and can always be removed if griefing\n     */\n    Rebalance public rebalance;\n\n    /**\n     * Auctions\n     *   Openable by AUCTION_LAUNCHER -> Openable by anyone (optional) -> Running -> Closed\n     *   - There can only be one live auction per token pair\n     *   - Multiple bids can be executed against the same auction\n     *   - All auctions are dutch auctions with an exponential decay curve, but startPrice can equal endPrice\n     */\n    mapping(uint256 id => Auction auction) public auctions;\n    mapping(uint256 rebalanceNonce => mapping(bytes32 pair => uint256 endTime)) public auctionEnds;\n    uint256 public nextAuctionId;\n\n    /// Any external call to the Folio that relies on accurate share accounting must pre-hook poke\n    modifier sync() {\n        _poke();\n        _;\n    }\n\n    // ====\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        FolioBasicDetails calldata _basicDetails,\n        FolioAdditionalDetails calldata _additionalDetails,\n        address _creator,\n        address _daoFeeRegistry,\n        address _trustedFillerRegistry,\n        bool _trustedFillerEnabled\n    ) external initializer {\n        __ERC20_init(_basicDetails.name, _basicDetails.symbol);\n        __AccessControlEnumerable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setFeeRecipients(_additionalDetails.feeRecipients);\n        _setTVLFee(_additionalDetails.tvlFee);\n        _setMintFee(_additionalDetails.mintFee);\n        _setAuctionLength(_additionalDetails.auctionLength);\n        _setMandate(_additionalDetails.mandate);\n        _setTrustedFillerRegistry(_trustedFillerRegistry, _trustedFillerEnabled);\n\n        daoFeeRegistry = IFolioDAOFeeRegistry(_daoFeeRegistry);\n\n        require(_basicDetails.initialShares != 0, Folio__ZeroInitialShares());\n\n        uint256 assetLength = _basicDetails.assets.length;\n        require(assetLength != 0, Folio__EmptyAssets());\n\n        for (uint256 i; i < assetLength; i++) {\n            require(_basicDetails.assets[i] != address(0), Folio__InvalidAsset());\n\n            uint256 assetBalance = IERC20(_basicDetails.assets[i]).balanceOf(address(this));\n            require(assetBalance != 0, Folio__InvalidAssetAmount(_basicDetails.assets[i]));\n\n            _addToBasket(_basicDetails.assets[i]);\n        }\n\n        lastPoke = block.timestamp;\n\n        _mint(_creator, _basicDetails.initialShares);\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev Testing function, no production use\n    function poke() external nonReentrant {\n        _poke();\n    }\n\n    /// Check if the Folio state can be relied upon to be complete\n    /// @dev Safety check for consuming protocols to check for synchronous and asynchronous state changes\n    /// @dev Consuming protocols SHOULD call this function and ensure it returns (false, false) before\n    ///      strongly relying on the Folio state.\n    function stateChangeActive() external view returns (bool syncStateChangeActive, bool asyncStateChangeActive) {\n        syncStateChangeActive = _reentrancyGuardEntered();\n        asyncStateChangeActive = address(activeTrustedFill) != address(0) && activeTrustedFill.swapActive();\n    }\n\n    // ==== Governance ====\n\n    /// Escape hatch function to be used when tokens get acquired not through an auction but\n    /// through any other means and should become part of the Folio without being sold.\n    /// @dev Does not require a token balance\n    /// @param token The token to add to the basket\n    function addToBasket(IERC20 token) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_addToBasket(address(token)), Folio__BasketModificationFailed());\n    }\n\n    /// @dev Enables permissionless removal of tokens for 0 balance tokens\n    function removeFromBasket(IERC20 token) external nonReentrant {\n        _closeTrustedFill();\n\n        // always allow admin to remove from basket\n        // allow permissionless removal if 0 weight AND 0 balance\n        // known: can be griefed by token donation\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                (rebalance.details[address(token)].limits.spot == 0 && IERC20(token).balanceOf(address(this)) == 0),\n            Folio__BalanceNotRemovable()\n        );\n        require(_removeFromBasket(address(token)), Folio__BasketModificationFailed());\n    }\n\n    /// An annual tvl fee below the DAO fee floor will result in the entirety of the fee being sent to the DAO\n    /// @dev Non-reentrant via distributeFees()\n    /// @param _newFee D18{1/s} Fee per second on AUM\n    function setTVLFee(uint256 _newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setTVLFee(_newFee);\n    }\n\n    /// A minting fee below the DAO fee floor will result in the entirety of the fee being sent to the DAO\n    /// @dev Non-reentrant via distributeFees()\n    /// @param _newFee D18{1} Fee on mint\n    function setMintFee(uint256 _newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setMintFee(_newFee);\n    }\n\n    /// @dev Non-reentrant via distributeFees()\n    /// @dev Fee recipients must be unique and sorted by address, and sum to 1e18\n    /// @dev Warning: An empty fee recipients table will result in all fees being sent to DAO\n    function setFeeRecipients(FeeRecipient[] memory _newRecipients) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setFeeRecipients(_newRecipients);\n    }\n\n    /// @param _newLength {s} Length of an auction\n    function setAuctionLength(uint256 _newLength) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setAuctionLength(_newLength);\n    }\n\n    /// @param _newMandate New mandate, a schelling point to guide governance\n    function setMandate(string calldata _newMandate) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setMandate(_newMandate);\n    }\n\n    /// @dev _newFillerRegistry must be the already set registry if already set. This is to ensure\n    ///      correctness and in order to be explicit what registry is being enabled/disabled.\n    function setTrustedFillerRegistry(address _newFillerRegistry, bool _enabled) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setTrustedFillerRegistry(_newFillerRegistry, _enabled);\n    }\n\n    /// Deprecate the Folio, callable only by the admin\n    /// @dev Folio cannot be minted and auctions cannot be approved, opened, or bid on\n    function deprecateFolio() external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        isDeprecated = true;\n\n        emit FolioDeprecated();\n    }\n\n    // ==== Share + Asset Accounting ====\n\n    /// @dev Contains all pending fee shares\n    function totalSupply() public view override returns (uint256) {\n        (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares, ) = _getPendingFeeShares();\n\n        return super.totalSupply() + _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n    }\n\n    /// @return _assets\n    /// @return _amounts {tok}\n    function totalAssets() external view returns (address[] memory _assets, uint256[] memory _amounts) {\n        return _totalAssets();\n    }\n\n    /// @param shares {share}\n    /// @return _assets\n    /// @return _amounts {tok}\n    function toAssets(\n        uint256 shares,\n        Math.Rounding rounding\n    ) external view returns (address[] memory _assets, uint256[] memory _amounts) {\n        return _toAssets(shares, rounding);\n    }\n\n    /// @dev Use allowances to set slippage limits for provided assets\n    /// @dev Minting has 3 share-portions: (i) receiver shares, (ii) DAO fee shares, (iii) fee recipients shares\n    /// @param shares {share} Amount of shares to mint\n    /// @param minSharesOut {share} Minimum amount of shares the caller must receive after fees\n    /// @return _assets\n    /// @return _amounts {tok}\n    function mint(\n        uint256 shares,\n        address receiver,\n        uint256 minSharesOut\n    ) external nonReentrant notDeprecated sync returns (address[] memory _assets, uint256[] memory _amounts) {\n        // === Calculate fee shares ===\n\n        (, uint256 daoFeeNumerator, uint256 daoFeeDenominator, uint256 daoFeeFloor) = daoFeeRegistry.getFeeDetails(\n            address(this)\n        );\n\n        // ensure DAO fee floor is at least 3 bps (set just above daily MAX_TVL_FEE)\n        daoFeeFloor = Math.max(daoFeeFloor, MIN_MINT_FEE);\n\n        // {share} = {share} * D18{1} / D18\n        uint256 totalFeeShares = (shares * mintFee + D18 - 1) / D18;\n        uint256 daoFeeShares = (totalFeeShares * daoFeeNumerator + daoFeeDenominator - 1) / daoFeeDenominator;\n\n        // ensure DAO's portion of fees is at least the DAO feeFloor\n        uint256 minDaoShares = (shares * daoFeeFloor + D18 - 1) / D18;\n        daoFeeShares = daoFeeShares < minDaoShares ? minDaoShares : daoFeeShares;\n\n        // 100% to DAO, if necessary\n        totalFeeShares = totalFeeShares < daoFeeShares ? daoFeeShares : totalFeeShares;\n\n        // {share}\n        uint256 sharesOut = shares - totalFeeShares;\n        require(sharesOut != 0 && sharesOut >= minSharesOut, Folio__InsufficientSharesOut());\n\n        // === Transfer assets in ===\n\n        (_assets, _amounts) = _toAssets(shares, Math.Rounding.Ceil);\n\n        uint256 assetLength = _assets.length;\n        for (uint256 i; i < assetLength; i++) {\n            if (_amounts[i] != 0) {\n                SafeERC20.safeTransferFrom(IERC20(_assets[i]), msg.sender, address(this), _amounts[i]);\n            }\n        }\n\n        // === Mint shares ===\n\n        _mint(receiver, sharesOut);\n\n        // defer fee handouts until distributeFees()\n        daoPendingFeeShares += daoFeeShares;\n        feeRecipientsPendingFeeShares += totalFeeShares - daoFeeShares;\n    }\n\n    /// @param shares {share} Amount of shares to redeem\n    /// @param assets Assets to receive, must match basket exactly\n    /// @param minAmountsOut {tok} Minimum amounts of each asset to receive\n    /// @return _amounts {tok} Actual amounts transferred of each asset\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address[] calldata assets,\n        uint256[] calldata minAmountsOut\n    ) external nonReentrant sync returns (uint256[] memory _amounts) {\n        address[] memory _assets;\n        (_assets, _amounts) = _toAssets(shares, Math.Rounding.Floor);\n\n        // === Burn shares ===\n\n        _burn(msg.sender, shares);\n\n        // === Transfer assets out ===\n\n        uint256 len = _assets.length;\n        require(len == assets.length && len == minAmountsOut.length, Folio__InvalidArrayLengths());\n\n        for (uint256 i; i < len; i++) {\n            require(_assets[i] == assets[i], Folio__InvalidAsset());\n            require(_amounts[i] >= minAmountsOut[i], Folio__InvalidAssetAmount(_assets[i]));\n\n            if (_amounts[i] != 0) {\n                SafeERC20.safeTransfer(IERC20(_assets[i]), receiver, _amounts[i]);\n            }\n        }\n    }\n\n    // ==== Fee Shares ====\n\n    /// @return {share} Up-to-date sum of DAO and fee recipients pending fee shares\n    function getPendingFeeShares() public view returns (uint256) {\n        (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares, ) = _getPendingFeeShares();\n        return _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n    }\n\n    /// Distribute all pending fee shares\n    /// @dev Recipients: DAO and fee recipients; if feeRecipients are empty, the DAO gets all the fees\n    /// @dev Pending fee shares are already reflected in the total supply, this function only concretizes balances\n    function distributeFees() public nonReentrant sync {\n        // daoPendingFeeShares and feeRecipientsPendingFeeShares are up-to-date\n\n        // === Fee recipients ===\n\n        uint256 _feeRecipientsPendingFeeShares = feeRecipientsPendingFeeShares;\n        feeRecipientsPendingFeeShares = 0;\n        uint256 feeRecipientsTotal;\n\n        uint256 len = feeRecipients.length;\n        for (uint256 i; i < len; i++) {\n            // {share} = {share} * D18{1} / D18\n            uint256 shares = (_feeRecipientsPendingFeeShares * feeRecipients[i].portion) / D18;\n            feeRecipientsTotal += shares;\n\n            _mint(feeRecipients[i].recipient, shares);\n\n            emit FolioFeePaid(feeRecipients[i].recipient, shares);\n        }\n\n        // === DAO ===\n\n        // {share}\n        uint256 daoShares = daoPendingFeeShares + _feeRecipientsPendingFeeShares - feeRecipientsTotal;\n\n        (address daoRecipient, , , ) = daoFeeRegistry.getFeeDetails(address(this));\n        _mint(daoRecipient, daoShares);\n        emit ProtocolFeePaid(daoRecipient, daoShares);\n\n        daoPendingFeeShares = 0;\n    }\n\n    // ==== Auctions ====\n\n    /// Get the currently ongoing rebalance\n    /// @dev The other rebalance variables are part of the autogenerated `rebalance()` getter\n    /// @dev Nonzero return values do not imply a rebalance is ongoing; check `rebalance.availableUntil`\n    function getRebalance()\n        external\n        view\n        returns (\n            address[] memory tokens,\n            BasketRange[] memory limits,\n            Prices[] memory prices,\n            bool[] memory inRebalance\n        )\n    {\n        tokens = basket.values();\n        uint256 len = tokens.length;\n        limits = new BasketRange[](len);\n        prices = new Prices[](len);\n        inRebalance = new bool[](len);\n\n        for (uint256 i; i < len; i++) {\n            RebalanceDetails storage details = rebalance.details[tokens[i]];\n            limits[i] = details.limits;\n            prices[i] = details.prices;\n            inRebalance[i] = details.inRebalance;\n        }\n    }\n\n    /// Set basket and start rebalancing towards it, ending currently running auctions\n    /// @dev If caller omits old tokens they will be kept in the basket for mint/redeem but skipped in the rebalance\n    /// @dev Note that limits will be _slightly_ stale after the fee supply inflation on a 24h boundary\n    /// @param newTokens Tokens to add to the basket, MUST be unique\n    /// @param newLimits D27{tok/share} New rebalance limits\n    /// @param newPrices D27{UoA/tok} New prices for each asset in terms of the Folio\n    ///                  Can pass 0 for ALL token prices to defer to AUCTION_LAUNCHER (cannot pick and choose)\n    function startRebalance(\n        address[] calldata newTokens,\n        BasketRange[] calldata newLimits,\n        Prices[] calldata newPrices,\n        uint256 auctionLauncherWindow,\n        uint256 ttl\n    ) external onlyRole(REBALANCE_MANAGER) nonReentrant notDeprecated sync {\n        require(ttl >= auctionLauncherWindow && ttl <= MAX_TTL, Folio__InvalidTTL());\n\n        // keep old tokens in the basket for mint/redeem, but remove from rebalance\n        address[] memory oldTokens = basket.values();\n        uint256 len = oldTokens.length;\n        for (uint256 i; i < len; i++) {\n            delete rebalance.details[oldTokens[i]];\n        }\n\n        len = newTokens.length;\n        require(len != 0 && len == newLimits.length && len == newPrices.length, Folio__InvalidArrayLengths());\n\n        // enforce that if one price is 0, all prices are 0\n        bool deferPrices = newPrices[0].low == 0;\n\n        // set new basket\n        for (uint256 i; i < len; i++) {\n            address token = newTokens[i];\n\n            require(!rebalance.details[token].inRebalance, Folio__DuplicateAsset());\n\n            require(\n                newLimits[i].low <= newLimits[i].spot &&\n                    newLimits[i].spot <= newLimits[i].high &&\n                    newLimits[i].high <= MAX_LIMIT,\n                Folio__InvalidLimits()\n            );\n\n            require(newLimits[i].spot != 0 || newLimits[i].high == 0, Folio__InvalidLimits());\n\n            require(\n                deferPrices == (newPrices[i].low == 0) && deferPrices == (newPrices[i].high == 0),\n                Folio__InvalidPrices()\n            );\n\n            if (!deferPrices) {\n                require(\n                    newPrices[i].low <= newPrices[i].high &&\n                        newPrices[i].high <= MAX_TOKEN_PRICE &&\n                        newPrices[i].high / newPrices[i].low <= MAX_TOKEN_PRICE_RANGE,\n                    Folio__InvalidPrices()\n                );\n            }\n\n            _addToBasket(token);\n            rebalance.details[token] = RebalanceDetails({\n                inRebalance: true,\n                limits: newLimits[i],\n                prices: newPrices[i]\n            });\n        }\n\n        rebalance.nonce++;\n        rebalance.startedAt = block.timestamp;\n        rebalance.restrictedUntil = block.timestamp + auctionLauncherWindow;\n        rebalance.availableUntil = block.timestamp + ttl;\n\n        emit RebalanceStarted(\n            rebalance.nonce,\n            newTokens,\n            newLimits,\n            newPrices,\n            block.timestamp + auctionLauncherWindow,\n            block.timestamp + ttl\n        );\n    }\n\n    /// Open an auction between two tokens as the AUCTION_LAUNCHER, with specific limits and prices\n    /// @param sellLimit D27{sellTok/share} min ratio of sell token to shares allowed, inclusive, 1e54 max\n    /// @param buyLimit D27{buyTok/share} max balance-ratio to shares allowed, exclusive, 1e54 max\n    /// @param startPrice D27{buyTok/sellTok} (0, 1e54]\n    /// @param endPrice D27{buyTok/sellTok} (0, 1e54]\n    /// @return auctionId The newly created auctionId\n    function openAuction(\n        IERC20 sellToken,\n        IERC20 buyToken,\n        uint256 sellLimit,\n        uint256 buyLimit,\n        uint256 startPrice,\n        uint256 endPrice\n    ) external onlyRole(AUCTION_LAUNCHER) nonReentrant notDeprecated sync returns (uint256 auctionId) {\n        // auction launcher can:\n        //   - select a sell limit within the approved basket weight range\n        //   - select a buy limit within the approved basket weight range\n        //   - raise starting price by up to 100x\n        //   - raise ending price arbitrarily (can cause auction not to clear, same end result as closing auction)\n\n        RebalanceDetails storage sellDetails = rebalance.details[address(sellToken)];\n        RebalanceDetails storage buyDetails = rebalance.details[address(buyToken)];\n\n        // startRebalance invariant: if any of the tokens have a 0 price, they must all have a 0 price\n        if (sellDetails.prices.high != 0) {\n            // D27{buyTok/sellTok} = D27 * D27{UoA/sellTok} / D27{UoA/buyTok}\n            uint256 oldStartPrice = (D27 * sellDetails.prices.high + buyDetails.prices.low - 1) / buyDetails.prices.low;\n            uint256 oldEndPrice = (D27 * sellDetails.prices.low + buyDetails.prices.high - 1) / buyDetails.prices.high;\n\n            // allow up to 100x price increase\n            require(\n                startPrice >= oldStartPrice && startPrice <= 100 * oldStartPrice && endPrice >= oldEndPrice,\n                Folio__InvalidPrices()\n            );\n        }\n\n        // for upgraded Folios, pick up on the next auction index from the old array\n        nextAuctionId = nextAuctionId != 0 ? nextAuctionId : auctions_DEPRECATED.length;\n        auctionId = nextAuctionId++;\n\n        AuctionLib.AuctionArgs memory args = AuctionLib.AuctionArgs({\n            auctionId: auctionId,\n            sellToken: sellToken,\n            buyToken: buyToken,\n            sellLimit: sellLimit,\n            buyLimit: buyLimit,\n            startPrice: startPrice,\n            endPrice: endPrice,\n            auctionBuffer: 0\n        });\n\n        // many more checks, including confirming sellToken is in surplus and buyToken is in deficit\n        AuctionLib.openAuction(rebalance, auctions, auctionEnds, totalSupply(), auctionLength, args);\n    }\n\n    /// Open an auction without restrictions\n    /// @dev Callable only after the auction launcher window passes\n    /// @return auctionId The newly created auctionId\n    function openAuctionUnrestricted(\n        IERC20 sellToken,\n        IERC20 buyToken\n    ) external nonReentrant notDeprecated sync returns (uint256 auctionId) {\n        require(block.timestamp >= rebalance.restrictedUntil, Folio__AuctionCannotBeOpenedWithoutRestriction());\n\n        // open an auction on spot limits + full price range\n\n        RebalanceDetails storage sellDetails = rebalance.details[address(sellToken)];\n        RebalanceDetails storage buyDetails = rebalance.details[address(buyToken)];\n\n        // startRebalance invariant: if any of the tokens have a 0 price, they must all have a 0 price\n        require(buyDetails.prices.low != 0, Folio__AuctionCannotBeOpenedWithoutRestriction());\n\n        // D27{buyTok/sellTok} = D27 * D27{UoA/sellTok} / D27{UoA/buyTok}\n        uint256 startPrice = (D27 * sellDetails.prices.high + buyDetails.prices.low - 1) / buyDetails.prices.low;\n        uint256 endPrice = (D27 * sellDetails.prices.low + buyDetails.prices.high - 1) / buyDetails.prices.high;\n\n        // for upgraded Folios, pick up on the next auction index from the old array\n        nextAuctionId = nextAuctionId != 0 ? nextAuctionId : auctions_DEPRECATED.length;\n        auctionId = nextAuctionId++;\n\n        AuctionLib.AuctionArgs memory args = AuctionLib.AuctionArgs({\n            auctionId: auctionId,\n            sellToken: sellToken,\n            buyToken: buyToken,\n            sellLimit: sellDetails.limits.spot,\n            buyLimit: buyDetails.limits.spot,\n            startPrice: startPrice,\n            endPrice: endPrice,\n            auctionBuffer: RESTRICTED_AUCTION_BUFFER\n        });\n\n        // many more checks, including confirming sellToken is in surplus and buyToken is in deficit\n        AuctionLib.openAuction(rebalance, auctions, auctionEnds, totalSupply(), auctionLength, args);\n    }\n\n    /// Get auction bid parameters at the current timestamp, up to a maximum sell amount\n    /// @param timestamp {s} The timestamp to get the bid parameters for, or 0 to use the current timestamp\n    /// @param maxSellAmount {sellTok} The max amount of sell tokens the bidder can offer the protocol\n    /// @return sellAmount {sellTok} The amount of sell token on sale in the auction at a given timestamp\n    /// @return bidAmount {buyTok} The amount of buy tokens required to bid for the full sell amount\n    /// @return price D27{buyTok/sellTok} The price at the given timestamp as an 27-decimal fixed point\n    function getBid(\n        uint256 auctionId,\n        uint256 timestamp,\n        uint256 maxSellAmount\n    ) external view returns (uint256 sellAmount, uint256 bidAmount, uint256 price) {\n        Auction storage auction = auctions[auctionId];\n\n        require(auction.rebalanceNonce == rebalance.nonce, Folio__AuctionNotOngoing());\n\n        // checks auction is ongoing and that sellAmount is below maxSellAmount\n        (sellAmount, bidAmount, price) = AuctionLib.getBid(\n            auction,\n            totalSupply(),\n            timestamp == 0 ? block.timestamp : timestamp,\n            _balanceOfToken(auction.sellToken),\n            _balanceOfToken(auction.buyToken),\n            0,\n            maxSellAmount,\n            type(uint256).max\n        );\n    }\n\n    /// Bid in an ongoing auction\n    ///   If withCallback is true, caller must adhere to IBidderCallee interface and receives a callback\n    ///   If withCallback is false, caller must have provided an allowance in advance\n    /// @dev Callable by anyone\n    /// @param sellAmount {sellTok} Sell token, the token the bidder receives\n    /// @param maxBuyAmount {buyTok} Max buy token, the token the bidder provides\n    /// @param withCallback If true, caller must adhere to IBidderCallee interface and transfers tokens via callback\n    /// @param data Arbitrary data to pass to the callback\n    /// @return boughtAmt {buyTok} The amount bidder receives\n    function bid(\n        uint256 auctionId,\n        uint256 sellAmount,\n        uint256 maxBuyAmount,\n        bool withCallback,\n        bytes calldata data\n    ) external nonReentrant notDeprecated sync returns (uint256 boughtAmt) {\n        Auction storage auction = auctions[auctionId];\n\n        require(auction.rebalanceNonce == rebalance.nonce, Folio__AuctionNotOngoing());\n\n        uint256 _totalSupply = totalSupply();\n\n        // checks auction is ongoing and that sellAmount is below maxSellAmount\n        (, boughtAmt, ) = AuctionLib.getBid(\n            auction,\n            _totalSupply,\n            block.timestamp,\n            auction.sellToken.balanceOf(address(this)),\n            auction.buyToken.balanceOf(address(this)),\n            sellAmount,\n            sellAmount,\n            maxBuyAmount\n        );\n\n        // bid via approval or callback\n        if (\n            AuctionLib.bid(\n                auction,\n                auctionEnds[auction.rebalanceNonce],\n                _totalSupply,\n                sellAmount,\n                boughtAmt,\n                withCallback,\n                data\n            )\n        ) {\n            _removeFromBasket(address(auction.sellToken));\n        }\n\n        emit AuctionBid(auctionId, sellAmount, boughtAmt);\n    }\n\n    /// As an alternative to bidding directly, an in-block async swap can be opened without removing Folio's access\n    function createTrustedFill(\n        uint256 auctionId,\n        address targetFiller,\n        bytes32 deploymentSalt\n    ) external nonReentrant notDeprecated sync returns (IBaseTrustedFiller filler) {\n        Auction storage auction = auctions[auctionId];\n\n        require(auction.rebalanceNonce == rebalance.nonce, Folio__AuctionNotOngoing());\n        require(\n            address(trustedFillerRegistry) != address(0) && trustedFillerEnabled,\n            Folio__TrustedFillerRegistryNotEnabled()\n        );\n\n        // checks auction is ongoing and that sellAmount is below maxSellAmount\n        (uint256 sellAmount, uint256 buyAmount, ) = AuctionLib.getBid(\n            auction,\n            totalSupply(),\n            block.timestamp,\n            auction.sellToken.balanceOf(address(this)),\n            auction.buyToken.balanceOf(address(this)),\n            0,\n            type(uint256).max,\n            type(uint256).max\n        );\n\n        // Create Trusted Filler\n        filler = trustedFillerRegistry.createTrustedFiller(msg.sender, targetFiller, deploymentSalt);\n        SafeERC20.forceApprove(auction.sellToken, address(filler), sellAmount);\n\n        filler.initialize(address(this), auction.sellToken, auction.buyToken, sellAmount, buyAmount);\n        activeTrustedFill = filler;\n\n        emit AuctionTrustedFillCreated(auctionId, address(filler));\n    }\n\n    /// Close an auction\n    /// A auction can be closed from anywhere in its lifecycle\n    /// @dev Callable by ADMIN or REBALANCE_MANAGER or AUCTION_LAUNCHER\n    function closeAuction(uint256 auctionId) external nonReentrant {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(REBALANCE_MANAGER, msg.sender) ||\n                hasRole(AUCTION_LAUNCHER, msg.sender),\n            Folio__Unauthorized()\n        );\n        Auction storage auction = auctions[auctionId];\n\n        // do not revert, to prevent griefing\n        auction.endTime = block.timestamp - 1;\n        auctionEnds[auction.rebalanceNonce][AuctionLib.pairHash(auction.sellToken, auction.buyToken)] =\n            block.timestamp -\n            1;\n\n        emit AuctionClosed(auctionId);\n    }\n\n    /// End the current rebalance, including all ongoing auctions\n    /// @dev Callable by ADMIN or REBALANCE_MANAGER or AUCTION_LAUNCHER\n    /// @dev Still have to wait out auctionEnds after\n    function endRebalance() external nonReentrant {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(REBALANCE_MANAGER, msg.sender) ||\n                hasRole(AUCTION_LAUNCHER, msg.sender),\n            Folio__Unauthorized()\n        );\n\n        emit RebalanceEnded(rebalance.nonce);\n\n        // do not revert, to prevent griefing\n        rebalance.nonce++; // advancing nonce clears auctionEnds\n        rebalance.availableUntil = block.timestamp;\n    }\n\n    // ==== Internal ====\n\n    /// @param shares {share}\n    /// @return _assets\n    /// @return _amounts {tok}\n    function _toAssets(\n        uint256 shares,\n        Math.Rounding rounding\n    ) internal view returns (address[] memory _assets, uint256[] memory _amounts) {\n        uint256 _totalSupply = totalSupply();\n\n        (_assets, _amounts) = _totalAssets();\n\n        uint256 assetLen = _assets.length;\n        for (uint256 i; i < assetLen; i++) {\n            // {tok} = {share} * {tok} / {share}\n            _amounts[i] = Math.mulDiv(shares, _amounts[i], _totalSupply, rounding);\n        }\n    }\n\n    /// @return _assets\n    /// @return _amounts {tok}\n    function _totalAssets() internal view returns (address[] memory _assets, uint256[] memory _amounts) {\n        _assets = basket.values();\n\n        uint256 assetLength = _assets.length;\n        _amounts = new uint256[](assetLength);\n        for (uint256 i; i < assetLength; i++) {\n            _amounts[i] = _balanceOfToken(IERC20(_assets[i]));\n        }\n    }\n\n    /// @return amount The known balances of a token, including trusted fills\n    function _balanceOfToken(IERC20 token) internal view returns (uint256 amount) {\n        amount = token.balanceOf(address(this));\n\n        if (\n            address(activeTrustedFill) != address(0) &&\n            (activeTrustedFill.sellToken() == token || activeTrustedFill.buyToken() == token)\n        ) {\n            amount += token.balanceOf(address(activeTrustedFill));\n        }\n    }\n\n    /// @return _daoPendingFeeShares {share}\n    /// @return _feeRecipientsPendingFeeShares {share}\n    function _getPendingFeeShares()\n        internal\n        view\n        returns (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares, uint256 _accountedUntil)\n    {\n        // {s} Always in full days\n        _accountedUntil = (block.timestamp / ONE_DAY) * ONE_DAY;\n        uint256 elapsed = _accountedUntil > lastPoke ? _accountedUntil - lastPoke : 0;\n\n        if (elapsed == 0) {\n            return (daoPendingFeeShares, feeRecipientsPendingFeeShares, lastPoke);\n        }\n\n        _daoPendingFeeShares = daoPendingFeeShares;\n        _feeRecipientsPendingFeeShares = feeRecipientsPendingFeeShares;\n\n        // {share}\n        uint256 supply = super.totalSupply() + _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n\n        (, uint256 daoFeeNumerator, uint256 daoFeeDenominator, uint256 daoFeeFloor) = daoFeeRegistry.getFeeDetails(\n            address(this)\n        );\n\n        // convert annual percentage to per-second for comparison with stored tvlFee\n        // = 1 - (1 - feeFloor) ^ (1 / 31536000)\n        // D18{1/s} = D18{1} - D18{1} * D18{1} ^ D18{1/s}\n        uint256 feeFloor = D18 - MathLib.pow(D18 - daoFeeFloor, ONE_OVER_YEAR);\n\n        // D18{1/s}\n        uint256 _tvlFee = feeFloor > tvlFee ? feeFloor : tvlFee;\n\n        // {share} += {share} * D18 / D18{1/s} ^ {s} - {share}\n        uint256 feeShares = (supply * D18) / MathLib.powu(D18 - _tvlFee, elapsed) - supply;\n\n        // D18{1} = D18{1/s} * D18 / D18{1/s}\n        uint256 correction = (feeFloor * D18 + _tvlFee - 1) / _tvlFee;\n\n        // {share} = {share} * D18{1} / D18\n        uint256 daoShares = (correction > (daoFeeNumerator * D18 + daoFeeDenominator - 1) / daoFeeDenominator)\n            ? (feeShares * correction + D18 - 1) / D18\n            : (feeShares * daoFeeNumerator + daoFeeDenominator - 1) / daoFeeDenominator;\n\n        _daoPendingFeeShares += daoShares;\n        _feeRecipientsPendingFeeShares += feeShares - daoShares;\n    }\n\n    /// Set TVL fee by annual percentage. Different from how it is stored!\n    /// @param _newFeeAnnually D18{1}\n    function _setTVLFee(uint256 _newFeeAnnually) internal {\n        require(_newFeeAnnually <= MAX_TVL_FEE, Folio__TVLFeeTooHigh());\n\n        // convert annual percentage to per-second\n        // = 1 - (1 - _newFeeAnnually) ^ (1 / 31536000)\n        // D18{1/s} = D18{1} - D18{1} ^ {s}\n        tvlFee = D18 - MathLib.pow(D18 - _newFeeAnnually, ONE_OVER_YEAR);\n\n        require(_newFeeAnnually == 0 || tvlFee != 0, Folio__TVLFeeTooLow());\n\n        emit TVLFeeSet(tvlFee, _newFeeAnnually);\n    }\n\n    /// Set mint fee\n    /// @param _newFee D18{1}\n    function _setMintFee(uint256 _newFee) internal {\n        require(_newFee <= MAX_MINT_FEE, Folio__MintFeeTooHigh());\n\n        mintFee = _newFee;\n        emit MintFeeSet(_newFee);\n    }\n\n    /// @dev Warning: An empty fee recipients table will result in all fees being sent to DAO\n    function _setFeeRecipients(FeeRecipient[] memory _feeRecipients) internal {\n        emit FeeRecipientsSet(_feeRecipients);\n\n        // Clear existing fee table\n        uint256 len = feeRecipients.length;\n        for (uint256 i; i < len; i++) {\n            feeRecipients.pop();\n        }\n\n        // Add new items to the fee table\n        len = _feeRecipients.length;\n\n        if (len == 0) {\n            return;\n        }\n\n        require(len <= MAX_FEE_RECIPIENTS, Folio__TooManyFeeRecipients());\n\n        address previousRecipient;\n        uint256 total;\n\n        for (uint256 i; i < len; i++) {\n            require(_feeRecipients[i].recipient > previousRecipient, Folio__FeeRecipientInvalidAddress());\n            require(_feeRecipients[i].portion != 0, Folio__FeeRecipientInvalidFeeShare());\n\n            total += _feeRecipients[i].portion;\n            previousRecipient = _feeRecipients[i].recipient;\n            feeRecipients.push(_feeRecipients[i]);\n        }\n\n        // ensure table adds up to 100%\n        require(total == D18, Folio__BadFeeTotal());\n    }\n\n    /// @param _newLength {s}\n    function _setAuctionLength(uint256 _newLength) internal {\n        require(_newLength >= MIN_AUCTION_LENGTH && _newLength <= MAX_AUCTION_LENGTH, Folio__InvalidAuctionLength());\n\n        auctionLength = _newLength;\n        emit AuctionLengthSet(auctionLength);\n    }\n\n    function _setMandate(string memory _newMandate) internal {\n        mandate = _newMandate;\n        emit MandateSet(_newMandate);\n    }\n\n    /// @dev After: daoPendingFeeShares and feeRecipientsPendingFeeShares are up-to-date\n    function _poke() internal {\n        _closeTrustedFill();\n\n        (\n            uint256 _daoPendingFeeShares,\n            uint256 _feeRecipientsPendingFeeShares,\n            uint256 _accountedUntil\n        ) = _getPendingFeeShares();\n\n        if (_accountedUntil > lastPoke) {\n            daoPendingFeeShares = _daoPendingFeeShares;\n            feeRecipientsPendingFeeShares = _feeRecipientsPendingFeeShares;\n            lastPoke = _accountedUntil;\n        }\n    }\n\n    function _addToBasket(address token) internal returns (bool) {\n        require(token != address(0) && token != address(this), Folio__InvalidAsset());\n        emit BasketTokenAdded(token);\n\n        return basket.add(token);\n    }\n\n    function _removeFromBasket(address token) internal returns (bool) {\n        emit BasketTokenRemoved(token);\n\n        delete rebalance.details[token];\n\n        return basket.remove(token);\n    }\n\n    function _setTrustedFillerRegistry(address _newFillerRegistry, bool _enabled) internal {\n        if (address(trustedFillerRegistry) != _newFillerRegistry) {\n            require(address(trustedFillerRegistry) == address(0), Folio__TrustedFillerRegistryAlreadySet());\n\n            trustedFillerRegistry = ITrustedFillerRegistry(_newFillerRegistry);\n        }\n\n        if (trustedFillerEnabled != _enabled) {\n            trustedFillerEnabled = _enabled;\n        }\n\n        emit TrustedFillerRegistrySet(address(trustedFillerRegistry), trustedFillerEnabled);\n    }\n\n    /// Claim all token balances from outstanding trusted fill\n    function _closeTrustedFill() internal {\n        if (address(activeTrustedFill) != address(0)) {\n            activeTrustedFill.closeFiller();\n\n            delete activeTrustedFill;\n        }\n    }\n\n    function _update(address from, address to, uint256 value) internal override {\n        // prevent accidental donations\n        require(to != address(this), Folio__InvalidTransferToSelf());\n\n        super._update(from, to, value);\n    }\n}\n"
    }
}