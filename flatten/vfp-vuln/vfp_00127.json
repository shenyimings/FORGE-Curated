{
    "vfp_id": "vfp_00127",
    "project_name": "Ozean Finance Security Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "USDC Depeg Risk in USDX Bridge",
            "description": "The bridge function in the USDXBridge contract does not have a pause mechanism, exposing it to instant arbitrage risks if USDC or other bridged assets lose their peg. The cause is the absence of emergency controls to halt operations during market instability. An attacker could exploit price discrepancies during a depeg event to drain value from the system or destabilize USDX's market price. The impact is potential loss of user confidence, market depreciation of USDX, and financial losses for liquidity providers or users relying on stable 1:1 conversions.\n",
            "severity": "Medium",
            "location": [
                "USDXBridge.sol::bridge"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/USDXBridge.sol"
            ]
        }
    ],
    "affected_files": {
        "USDXBridge.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Ownable} from \"openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {OptimismPortal} from \"optimism/src/L1/OptimismPortal.sol\";\nimport {SystemConfig} from \"optimism/src/L1/SystemConfig.sol\";\nimport {ISemver} from \"optimism/src/universal/interfaces/ISemver.sol\";\n\n/// @title  USDX Bridge\n/// @notice This contract provides bridging functionality for allow-listed stablecoins to the Ozean Layer L2.\n///         Users can deposit any allow-listed stablecoin and recieve USDX, the native gas token for Ozean, on\n///         the L2 via the Optimism Portal contract. The owner of this contract can modify the set of\n///         allow-listed stablecoins accepted, along with the deposit caps, and can also withdraw any deposited\n///         ERC20 tokens.\ncontract USDXBridge is Ownable, ReentrancyGuard, ISemver {\n    using SafeERC20 for IERC20Decimals;\n\n    /// @notice Semantic version.\n    /// @custom:semver 1.0.0\n    string public constant version = \"1.0.0\";\n\n    /// @notice Contract of the Optimism Portal.\n    /// @custom:network-specific\n    OptimismPortal public immutable portal;\n\n    /// @notice Address of the System Config contract.\n    SystemConfig public immutable config;\n\n    /// @notice Addresses of allow-listed stablecoins.\n    /// @dev    stablecoin => allowlisted\n    mapping(address => bool) public allowlisted;\n\n    /// @notice The limit to the total USDX supply that can be minted and bridged per deposted stablecoin.\n    /// @dev    stablecoin => amount\n    mapping(address => uint256) public depositCap;\n\n    /// @notice The total amount of USDX bridged via this contract per deposted stablecoin.\n    /// @dev    stablecoin => amount\n    mapping(address => uint256) public totalBridged;\n\n    /// @notice The gas limit passed to the Optimism portal when depositing USDX.\n    uint64 public gasLimit;\n\n    /// EVENTS ///\n\n    /// @notice An event emitted when a bridge deposit is made by a user.\n    event BridgeDeposit(address indexed _stablecoin, uint256 _amount, address indexed _to);\n\n    /// @notice An event emitted when an ERC20 token is withdrawn from this contract.\n    event WithdrawCoins(address indexed _coin, uint256 _amount, address indexed _to);\n\n    /// @notice An event emitted when en ERC20 stablecoin is set as allowlisted or not (true if allowlisted, false if\n    /// removed).\n    event AllowlistSet(address indexed _coin, bool _set);\n\n    /// @notice An event emitted when the deposit cap for an ERC20 stablecoin is modified.\n    event DepositCapSet(address indexed _coin, uint256 _newDepositCap);\n\n    /// @notice An event emitted when the gas limit is updated.\n    event GasLimitSet(uint64 _newGasLimit);\n\n    /// SETUP ///\n\n    /// @notice The constructor contract set up.\n    /// @param  _owner The address granted ownership rights to this contract.\n    /// @param  _portal The Optimism Portal contract, which is directly responsible for bridging USDX.\n    /// @param  _config The Optimism System Config contract, which ensures alignment on the gas token.\n    /// @param  _stablecoins An array of allow-listed stablecoins that can be used to mint and bridge USDX.\n    /// @param  _depositCaps The deposit caps per stablecoin for this contract, which limits the total amount bridged.\n    /// @dev    Ensure that the index for each deposit cap aligns with the index of the stablecoin that is allowlisted.\n    /// @dev    This function includes an unbounded for-loop. Ensure that the array of allow-listed\n    ///         stablecoins is reasonable in length.\n    constructor(\n        address _owner,\n        OptimismPortal _portal,\n        SystemConfig _config,\n        address[] memory _stablecoins,\n        uint256[] memory _depositCaps\n    ) {\n        _transferOwnership(_owner);\n        portal = _portal;\n        config = _config;\n        gasLimit = 21000;\n        /// Add allow-listed stablecoins and deposit caps\n        if (address(config) != address(0)) {\n            uint256 length = _stablecoins.length;\n            require(\n                length == _depositCaps.length,\n                \"USDXBridge: Stablecoins array length must equal the Deposit Caps array length.\"\n            );\n            for (uint256 i; i < length; ++i) {\n                allowlisted[_stablecoins[i]] = true;\n                emit AllowlistSet(_stablecoins[i], true);\n                depositCap[_stablecoins[i]] = _depositCaps[i];\n                emit DepositCapSet(_stablecoins[i], _depositCaps[i]);\n            }\n        }\n    }\n\n    /// BRIDGE ///\n\n    /// @notice This function allows users to deposit any allow-listed stablecoin to the Ozean Layer L2.\n    /// @param  _stablecoin Depositing stablecoin address.\n    /// @param  _amount The amount of deposit stablecoin to be swapped for USDX.\n    /// @param  _to Recieving address on L2.\n    function bridge(address _stablecoin, uint256 _amount, address _to) external nonReentrant {\n        /// Checks\n        require(allowlisted[_stablecoin], \"USDXBridge: Stablecoin not accepted.\");\n        require(_amount > 0, \"USDXBridge: May not bridge nothing.\");\n        uint256 bridgeAmount = _getBridgeAmount(_stablecoin, _amount);\n        require(\n            totalBridged[_stablecoin] + bridgeAmount < depositCap[_stablecoin],\n            \"USDXBridge: Bridge amount exceeds deposit cap.\"\n        );\n        /// Update state\n        totalBridged[_stablecoin] += bridgeAmount;\n        IERC20Decimals(_stablecoin).safeTransferFrom(msg.sender, address(this), _amount);\n        /// Mint USDX\n        usdx().mint(address(this), bridgeAmount);\n        /// Bridge USDX\n        usdx().approve(address(portal), bridgeAmount);\n        portal.depositERC20Transaction({\n            _to: _to,\n            _mint: bridgeAmount,\n            _value: bridgeAmount,\n            _gasLimit: gasLimit,\n            _isCreation: false,\n            _data: \"\"\n        });\n        emit BridgeDeposit(_stablecoin, _amount, _to);\n    }\n\n    /// OWNER ///\n\n    /// @notice This function allows the owner to either add or remove an allow-listed stablecoin for bridging.\n    /// @param  _stablecoin The stablecoin address to add or remove.\n    /// @param  _set A boolean for whether the stablecoin is allow-listed or not. True for allow-listed, false\n    ///         otherwise.\n    function setAllowlist(address _stablecoin, bool _set) external onlyOwner {\n        allowlisted[_stablecoin] = _set;\n        emit AllowlistSet(_stablecoin, _set);\n    }\n\n    /// @notice This function allows the owner to modify the deposit cap for deposited stablecoins.\n    /// @param  _stablecoin The stablecoin address to modify the deposit cap.\n    /// @param  _newDepositCap The new deposit cap.\n    function setDepositCap(address _stablecoin, uint256 _newDepositCap) external onlyOwner {\n        depositCap[_stablecoin] = _newDepositCap;\n        emit DepositCapSet(_stablecoin, _newDepositCap);\n    }\n\n    /// @notice This function allows the owner to modify the gas limit for USDX deposits.\n    /// @param  _newGasLimit The new gas limit to be set for transactions.\n    function setGasLimit(uint64 _newGasLimit) external onlyOwner {\n        gasLimit = _newGasLimit;\n        emit GasLimitSet(_newGasLimit);\n    }\n\n    /// @notice This function allows the owner to withdraw any ERC20 token held by this contract.\n    /// @param  _coin The address of the ERC20 token to withdraw.\n    /// @param  _amount The amount of tokens to withdraw.\n    function withdrawERC20(address _coin, uint256 _amount) external onlyOwner {\n        IERC20Decimals(_coin).safeTransfer(msg.sender, _amount);\n        emit WithdrawCoins(_coin, _amount, msg.sender);\n    }\n\n    /// VIEW ///\n\n    /// @notice This view function returns the address, as the USDX interface, for minting and bridging.\n    /// @return IUSDX Interface and address.\n    function usdx() public view returns (IUSDX) {\n        (address addr,) = config.gasPayingToken();\n        return IUSDX(addr);\n    }\n\n    /// @notice This view function normalises deposited amounts given diverging decimals for tokens and USDX.\n    /// @param  _stablecoin The address of the deposited stablecoin.\n    /// @param  _amount The amount of the stablecoin deposited.\n    /// @return uint256 The amount of USDX to mint given the deposited stablecoin amount.\n    /// @dev    Assumes 1:1 conversion between the deposited stablecoin and USDX.\n    function _getBridgeAmount(address _stablecoin, uint256 _amount) internal view returns (uint256) {\n        uint8 depositDecimals = IERC20Decimals(_stablecoin).decimals();\n        uint8 usdxDecimals = usdx().decimals();\n        return (_amount * 10 ** usdxDecimals) / (10 ** depositDecimals);\n    }\n}\n\n/// @notice An interface whihc extends the IERC20 to include a decimals view function.\n/// @dev    Any allow-listed stablecoin added to the bridge must conform to this interface.\ninterface IERC20Decimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\n/// @notice An interface whihc extends the IERC20Decimals to include a mint function to allow for minting\n///         of new USDX tokens by this bridge.\ninterface IUSDX is IERC20Decimals {\n    function mint(address to, uint256 amount) external;\n}\n"
    }
}