{
    "vfp_id": "vfp_00177",
    "project_name": "Bridged USDC Support Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "Restricted USDC Bridging via Shared Bridge with Custom Gas Token",
            "description": "In the `ZkStack_CustomGasToken_Adapter` contract, the `relayTokens` function incorrectly approves the `txBaseCost` amount of custom gas tokens to the `USDC_SHARED_BRIDGE` instead of the `sharedBridge` when bridging USDC via the shared bridge. This causes the bridging transaction to fail because the actual bridge (`sharedBridge`) lacks the necessary allowance.\n\nThe root cause is a logic error in the approval destination: the code uses `USDC_SHARED_BRIDGE` unconditionally, even when the `sharedBridge` is the one performing the transfer. This mismatch prevents the bridge from deducting gas fees.\n\nAn attacker could exploit this by initiating bridging transactions that appear valid but are guaranteed to revert, potentially disrupting user flows or causing front-running opportunities in dependent systems.\n\nThe impact is failed bridging transactions for USDC when using the shared bridge with custom gas tokens, leading to user fund lockups (temporarily) and degraded user experience. It breaks a core functionality path.\n",
            "severity": "High",
            "location": [
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#178",
                "ZkStack_CustomGasToken_Adapter.sol#230"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "ZkStack_CustomGasToken_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\nimport { CircleCCTPAdapter } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with a custom gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // The ZkSync bridgehub contract treats address(1) to represent ETH.\n    address private constant ETH_TOKEN_ADDRESS = address(1);\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://docs.zksync.io/build/developer-reference/l1-l2-interoperability#l1-to-l2-gas-estimation-for-transactions\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // USDC SharedBridge address, which is passed in on construction and used as the second bridge contract for USDC transfers.\n    address public immutable USDC_SHARED_BRIDGE;\n\n    // Custom gas token address, which is read from the BridgeHub at construction.\n    address public immutable CUSTOM_GAS_TOKEN;\n\n    // Custom gas token funder\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    // The maximum gas price a transaction sent to this adapter may have. This is set to prevent a block producer from setting an artificially high priority fee\n    // when calling a hub pool message relay, which would otherwise cause a large amount of the custom gas token to be sent to L2.\n    uint256 private immutable MAX_TX_GASPRICE;\n\n    event ZkStackMessageRelayed(bytes32 indexed canonicalTxHash);\n    error ETHGasTokenNotAllowed();\n    error TransactionFeeTooHigh();\n    error InvalidBridgeConfig();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _chainId The target ZkStack network's chain ID.\n     * @param _bridgeHub The bridge hub contract address for the ZkStack network.\n     * @param _circleUSDC Circle USDC address on L1. If not set to address(0), then either the USDCSharedBridge\n     * or CCTP token messenger must be set and will be used to bridge this token.\n     * @param _usdcSharedBridge Address of the second bridge contract for USDC corresponding to the configured ZkStack network.\n     * @param _cctpTokenMessenger address of the CCTP token messenger contract for the configured network.\n     * @param _recipientCircleDomainId Circle domain ID for the destination network.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     * @param _customGasTokenFunder Contract on L1 which funds bridge fees with amounts in the custom gas token.\n     * @param _l2GasLimit The maximum amount of gas this contract is willing to pay to execute a transaction on L2.\n     * @param _l1GasToL2GasPerPubDataLimit The exchange rate of l1 gas to l2 gas.\n     * @param _maxTxGasprice The maximum effective gas price any transaction sent to this adapter may have.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        IERC20 _circleUSDC,\n        address _usdcSharedBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit,\n        uint256 _maxTxGasprice\n    ) CircleCCTPAdapter(_circleUSDC, _cctpTokenMessenger, _recipientCircleDomainId) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        L2_GAS_LIMIT = _l2GasLimit;\n        MAX_TX_GASPRICE = _maxTxGasprice;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        address zero = address(0);\n        if (address(_circleUSDC) != zero) {\n            bool zkUSDCBridgeDisabled = _usdcSharedBridge == zero;\n            bool cctpUSDCBridgeDisabled = address(_cctpTokenMessenger) == zero;\n            // Bridged and Native USDC are mutually exclusive.\n            if (zkUSDCBridgeDisabled == cctpUSDCBridgeDisabled) {\n                revert InvalidBridgeConfig();\n            }\n        }\n        USDC_SHARED_BRIDGE = _usdcSharedBridge;\n        CUSTOM_GAS_TOKEN = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (CUSTOM_GAS_TOKEN == ETH_TOKEN_ADDRESS) {\n            revert ETHGasTokenNotAllowed();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        IERC20(CUSTOM_GAS_TOKEN).forceApprove(BRIDGE_HUB.sharedBridge(), txBaseCost);\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = BRIDGE_HUB.requestL2TransactionDirect(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkStackMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        address sharedBridge = BRIDGE_HUB.sharedBridge();\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost of custom gas tokens.\n            L1_WETH.withdraw(amount);\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            // Note: When bridging ETH with `L2TransactionRequestTwoBridgesOuter`, the second bridge must be 0 for the shared bridge call to not revert.\n            // https://github.com/matter-labs/era-contracts/blob/aafee035db892689df3f7afe4b89fd6467a39313/l1-contracts/contracts/bridge/L1SharedBridge.sol#L328\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: amount }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: amount,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, ETH_TOKEN_ADDRESS, 0)\n                })\n            );\n        } else if (l1Token == CUSTOM_GAS_TOKEN) {\n            // The chain's custom gas token.\n            IERC20(l1Token).forceApprove(sharedBridge, txBaseCost + amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost + amount,\n                    l2Contract: to,\n                    l2Value: amount,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else if (l1Token == address(usdcToken)) {\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                IERC20(CUSTOM_GAS_TOKEN).forceApprove(USDC_SHARED_BRIDGE, txBaseCost);\n                IERC20(l1Token).forceApprove(USDC_SHARED_BRIDGE, amount);\n                txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                    BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                        chainId: CHAIN_ID,\n                        mintValue: txBaseCost,\n                        l2Value: 0,\n                        l2GasLimit: L2_GAS_LIMIT,\n                        l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                        refundRecipient: L2_REFUND_ADDRESS,\n                        secondBridgeAddress: USDC_SHARED_BRIDGE,\n                        secondBridgeValue: 0,\n                        secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                    })\n                );\n            }\n        } else {\n            // An ERC20 that is not WETH and not the custom gas token.\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            IERC20(l1Token).forceApprove(sharedBridge, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkStackMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of tokens needed, pulls them from the funder, and\n     * returns the amount.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _pullCustomGas(uint256 l2GasLimit) internal returns (uint256) {\n        if (tx.gasprice > MAX_TX_GASPRICE) revert TransactionFeeTooHigh();\n        uint256 cost = BRIDGE_HUB.l2TransactionBaseCost(\n            CHAIN_ID,\n            tx.gasprice,\n            l2GasLimit,\n            L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT\n        );\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(IERC20(CUSTOM_GAS_TOKEN), cost);\n\n        return cost;\n    }\n}\n"
    }
}