{
    "vfp_id": "vfp_00183",
    "project_name": "ChainSecurity_M0_MExtensions_Audit.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "MEarnerManager Can Be Forced Into an Irrecoverable State",
            "description": "The MEarnerManager contract uses `wasEarningEnabled` and `disableIndex` to manage its earning state, forming a state machine where the (0, !0) state is invalid but reachable. If the contract is not an allowed earner at deployment, anyone can call `disableEarning()`, setting it into this invalid state. Once there, calling `enableEarning()` will not restore functionality, permanently disabling interest accrual. The cause is flawed state transition logic that does not validate preconditions. This leads to a bricked contract state, preventing any future yield distribution and effectively freezing user funds indefinitely.\n",
            "severity": "Medium",
            "location": [
                "MEarnerManager::disableEarning",
                "MEarnerManager::enableEarning"
            ],
            "files": [
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Removing MEarnerManager From the Earner List Will Make It Insolvent",
            "description": "If MEarnerManager is removed from the earner list without proper handling, its internal accounting continues to accrue yield even though no real yield is received. This discrepancy causes the contract to become insolvent, as obligations exceed actual holdings. The root cause is the lack of automatic pausing of the index upon removal from the earners list. An attacker or governance action could exploit this by removing and re-adding the contract, triggering a bank run as users rush to withdraw before insolvency is realized. This undermines trust and financial integrity.\n",
            "severity": "Medium",
            "location": [
                "MEarnerManager::disableEarning"
            ],
            "files": [
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        }
    ],
    "affected_files": {
        "MEarnerManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { IERC20 } from \"../../../lib/common/src/interfaces/IERC20.sol\";\n\nimport {\n    AccessControlUpgradeable\n} from \"../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\n\nimport { IndexingMath } from \"../../libs/IndexingMath.sol\";\nimport { UIntMath } from \"../../../lib/common/src/libs/UIntMath.sol\";\n\nimport { IMEarnerManager } from \"./IMEarnerManager.sol\";\n\nimport { MExtension } from \"../../MExtension.sol\";\n\nabstract contract MEarnerManagerStorageLayout {\n    /**\n     * @dev   Struct to represent an account's balance, whitelisted status, and earning details like `feeRate` and earning principal.\n     * @param balance       The current balance of the account.\n     * @param isWhitelisted Whether the account is whitelisted by an earner manager.\n     * @param feeRate       The fee rate that defines yield split between account and earner manager.\n     * @param principal     The earning principal for the account.\n     */\n    struct Account {\n        // Slot 1\n        uint256 balance;\n        // Slot 2\n        bool isWhitelisted;\n        uint16 feeRate;\n        uint112 principal;\n    }\n\n    /// @custom:storage-location erc7201:M0.storage.MEarnerManager\n    struct MEarnerManagerStorageStruct {\n        // Slot 1\n        address feeRecipient;\n        // Slot 2\n        uint256 totalSupply;\n        // Slot 3\n        uint112 totalPrincipal;\n        // Slot 4\n        mapping(address account => Account) accounts;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MEarnerManager\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_EARNER_MANAGER_STORAGE_LOCATION =\n        0x1c4485857d96206482b943eeab7f941848f1c52b84a4bd59d8c2a3e8468f8300;\n\n    function _getMEarnerManagerStorageLocation() internal pure returns (MEarnerManagerStorageStruct storage $) {\n        assembly {\n            $.slot := _M_EARNER_MANAGER_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title M Extension where Earner Manager whitelists accounts and sets fee rates for them.\n * @author M0 Labs\n */\ncontract MEarnerManager is IMEarnerManager, AccessControlUpgradeable, MEarnerManagerStorageLayout, MExtension {\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMEarnerManager\n    uint16 public constant ONE_HUNDRED_PERCENT = 10_000;\n\n    /// @inheritdoc IMEarnerManager\n    bytes32 public constant EARNER_MANAGER_ROLE = keccak256(\"EARNER_MANAGER_ROLE\");\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @dev   Initializes the M extension token with earner manager role and different fee tiers.\n     * @param name               The name of the token (e.g. \"M Earner Manager\").\n     * @param symbol             The symbol of the token (e.g. \"MEM\").\n     * @param mToken             The address of an M Token.\n     * @param swapFacility       The address of the Swap Facility.\n     * @param admin              The address administrating the M extension. Can grant and revoke roles.\n     * @param earnerManager      The address of earner manager\n     * @param feeRecipient_      The address that will receive the fees from all the earners.\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address mToken,\n        address swapFacility,\n        address admin,\n        address earnerManager,\n        address feeRecipient_\n    ) public virtual initializer {\n        if (admin == address(0)) revert ZeroAdmin();\n        if (earnerManager == address(0)) revert ZeroEarnerManager();\n\n        __MExtension_init(name, symbol, mToken, swapFacility);\n\n        _setFeeRecipient(feeRecipient_);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(EARNER_MANAGER_ROLE, earnerManager);\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMEarnerManager\n    function setAccountInfo(address account, bool status, uint16 feeRate) public onlyRole(EARNER_MANAGER_ROLE) {\n        _setAccountInfo(account, status, feeRate);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function setAccountInfo(\n        address[] calldata accounts,\n        bool[] calldata statuses,\n        uint16[] calldata feeRates\n    ) external onlyRole(EARNER_MANAGER_ROLE) {\n        if (accounts.length == 0) revert ArrayLengthZero();\n        if (accounts.length != statuses.length || accounts.length != feeRates.length) revert ArrayLengthMismatch();\n\n        for (uint256 index_; index_ < accounts.length; ++index_) {\n            _setAccountInfo(accounts[index_], statuses[index_], feeRates[index_]);\n        }\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function setFeeRecipient(address feeRecipient_) external onlyRole(EARNER_MANAGER_ROLE) {\n        _setFeeRecipient(feeRecipient_);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function claimFor(address account) public returns (uint256 yieldWithFee, uint256 fee, uint256 yieldNetOfFee) {\n        if (account == address(0)) revert ZeroAccount();\n\n        (yieldWithFee, fee, yieldNetOfFee) = accruedYieldAndFeeOf(account);\n\n        if (yieldWithFee == 0) return (0, 0, 0);\n\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        // Emit the appropriate `YieldClaimed` and `Transfer` events.\n        emit YieldClaimed(account, yieldNetOfFee);\n        emit Transfer(address(0), account, yieldWithFee);\n\n        // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.\n        unchecked {\n            $.accounts[account].balance += yieldWithFee;\n            $.totalSupply += yieldWithFee;\n        }\n\n        if (fee == 0) return (yieldWithFee, 0, yieldNetOfFee);\n\n        address feeRecipient_ = $.feeRecipient;\n\n        // Emit the appropriate `FeeClaimed` and `Transfer` events.\n        emit FeeClaimed(account, feeRecipient_, fee);\n        emit Transfer(account, feeRecipient_, fee);\n\n        // Transfer fee to the fee recipient.\n        _update(account, feeRecipient_, fee);\n    }\n\n    /* ============ External/Public view functions ============ */\n\n    /// @inheritdoc IMEarnerManager\n    function accruedYieldAndFeeOf(\n        address account\n    ) public view returns (uint256 yieldWithFee, uint256 fee, uint256 yieldNetOfFee) {\n        Account storage accountInfo_ = _getMEarnerManagerStorageLocation().accounts[account];\n\n        yieldWithFee = _getAccruedYield(accountInfo_.balance, accountInfo_.principal, currentIndex());\n        uint16 feeRate_ = accountInfo_.feeRate;\n\n        if (feeRate_ == 0 || yieldWithFee == 0) return (yieldWithFee, 0, yieldWithFee);\n\n        unchecked {\n            fee = (yieldWithFee * feeRate_) / ONE_HUNDRED_PERCENT;\n            yieldNetOfFee = yieldWithFee - fee;\n        }\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function accruedYieldOf(address account) public view returns (uint256 yieldNetOfFee) {\n        (, , yieldNetOfFee) = accruedYieldAndFeeOf(account);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function accruedFeeOf(address account) public view returns (uint256 fee) {\n        (, fee, ) = accruedYieldAndFeeOf(account);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function balanceWithYieldOf(address account) external view returns (uint256) {\n        unchecked {\n            return balanceOf(account) + accruedYieldOf(account);\n        }\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view override returns (uint256) {\n        return _getMEarnerManagerStorageLocation().accounts[account].balance;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view returns (uint256) {\n        return _getMEarnerManagerStorageLocation().totalSupply;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function projectedTotalSupply() public view returns (uint256) {\n        return IndexingMath.getPresentAmountRoundedUp(totalPrincipal(), currentIndex());\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function totalPrincipal() public view returns (uint112) {\n        return _getMEarnerManagerStorageLocation().totalPrincipal;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function feeRecipient() public view returns (address) {\n        return _getMEarnerManagerStorageLocation().feeRecipient;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function isWhitelisted(address account) public view returns (bool) {\n        return _getMEarnerManagerStorageLocation().accounts[account].isWhitelisted;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function principalOf(address account) public view returns (uint112) {\n        return _getMEarnerManagerStorageLocation().accounts[account].principal;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function feeRateOf(address account) public view returns (uint16) {\n        return _getMEarnerManagerStorageLocation().accounts[account].feeRate;\n    }\n\n    /* ============ Hooks For Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Hook called before approving an allowance.\n     * @param account  The account that is approving the allowance.\n     * @param spender  The account that is being approved to spend tokens.\n     */\n    function _beforeApprove(address account, address spender, uint256 /* amount */) internal view override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        _revertIfNotWhitelisted($, account);\n        _revertIfNotWhitelisted($, spender);\n    }\n\n    /**\n     * @dev    Hooks called before wrapping M into M Extension token.\n     * @param  account   The account from which M is deposited.\n     * @param  recipient The account receiving the minted M Extension token.\n     */\n    function _beforeWrap(address account, address recipient, uint256 /* amount */) internal view override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        _revertIfNotWhitelisted($, account);\n        _revertIfNotWhitelisted($, recipient);\n    }\n\n    /**\n     * @dev   Hook called before unwrapping M Extension token.\n     * @param account The account from which M Extension token is burned.\n     */\n    function _beforeUnwrap(address account, uint256 /* amount */) internal view override {\n        _revertIfNotWhitelisted(_getMEarnerManagerStorageLocation(), account);\n    }\n\n    /**\n     * @dev   Hook called before transferring tokens.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     */\n    function _beforeTransfer(address sender, address recipient, uint256 /* amount */) internal view override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        _revertIfNotWhitelisted($, msg.sender);\n\n        _revertIfNotWhitelisted($, sender);\n        _revertIfNotWhitelisted($, recipient);\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @notice Sets the account info like:\n     *         - whitelisting or removing account from whitelist,\n     *         - fee rate for the account.\n     * @param  account The address of the accounts to whitelist for earning or remove from the whitelist.\n     * @param  status Whether an account is a whitelisted account, respectively, according to the admin.\n     * @param  feeRate The fee rate, in bps, that will be taken from the yield generated by the account.\n     */\n    function _setAccountInfo(address account, bool status, uint16 feeRate) internal {\n        if (account == address(0)) revert ZeroAccount();\n        if (feeRate > ONE_HUNDRED_PERCENT) revert InvalidFeeRate();\n        if (status == false && feeRate != 0) revert InvalidAccountInfo();\n\n        Account storage accountInfo_ = _getMEarnerManagerStorageLocation().accounts[account];\n        bool isWhitelisted_ = accountInfo_.isWhitelisted;\n\n        // No change, no-op action\n        if (!isWhitelisted_ && !status) return;\n\n        // No change, no-op action\n        if (isWhitelisted_ && status && accountInfo_.feeRate == feeRate) return;\n\n        emit AccountInfoSet(account, status, feeRate);\n\n        // Set up a new whitelisted account\n        if (!isWhitelisted_ && status) {\n            accountInfo_.isWhitelisted = true;\n            accountInfo_.feeRate = feeRate;\n            return;\n        }\n\n        // Claim yield as the action below will lead to the change in whitelisted account info.\n        claimFor(account);\n\n        if (!status) {\n            // Remove whitelisted account info.\n            accountInfo_.isWhitelisted = false;\n            // fee recipient will receive all yield from such 'un-whitelisted' accounts.\n            accountInfo_.feeRate = ONE_HUNDRED_PERCENT;\n        } else {\n            // Change fee rate for the whitelisted account.\n            accountInfo_.feeRate = feeRate;\n        }\n    }\n\n    /**\n     * @notice Sets the yield fee recipient that will receive part of the yield generated by token.\n     * @dev    Reverts if the yield fee recipient is address zero.\n     * @dev    Returns early if the yield fee recipient is the same as the current one.\n     * @param  feeRecipient_ The yield fee recipient address.\n     */\n    function _setFeeRecipient(address feeRecipient_) internal {\n        if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();\n\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        if ($.feeRecipient == feeRecipient_) return;\n\n        // Yield fee recipient does not pay fees.\n        _setAccountInfo(feeRecipient_, true, 0);\n\n        $.feeRecipient = feeRecipient_;\n\n        emit FeeRecipientSet(feeRecipient_);\n    }\n\n    /**\n     * @dev   Mints `amount` tokens to `account`.\n     * @param account The address that will receive tokens.\n     * @param amount  The amount of tokens to mint.\n     */\n    function _mint(address account, uint256 amount) internal override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n        Account storage accountInfo_ = $.accounts[account];\n\n        // Slightly underestimate the principal amount to be minted, round down in favor of protocol.\n        uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex());\n\n        // NOTE: Can be `unchecked` because the max amount of $M is never greater than `type(uint240).max`.\n        //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `principal[account]`\n        unchecked {\n            accountInfo_.balance += amount;\n            $.totalSupply += amount;\n\n            $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal_);\n            // No need for `UIntMath.safe112`, `accountInfo_.principal` cannot be greater than `totalPrincipal`.\n            accountInfo_.principal += principal_;\n        }\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev   Burns `amount` tokens from `account`.\n     * @param account The address whose account balance will be decremented.\n     * @param amount  The present amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n        Account storage accountInfo_ = $.accounts[account];\n\n        // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in the unchecked block.\n        uint112 fromPrincipal_ = accountInfo_.principal;\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above\n        unchecked {\n            accountInfo_.balance -= amount;\n            $.totalSupply -= amount;\n\n            accountInfo_.principal = fromPrincipal_ - principal_;\n            $.totalPrincipal -= principal_;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _update(address sender, address recipient, uint256 amount) internal override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n        Account storage senderAccount_ = $.accounts[sender];\n        Account storage recipientAccount_ = $.accounts[recipient];\n\n        // Slightly overestimate the principal amount to be moved on transfer\n        uint112 fromPrincipal_ = senderAccount_.principal;\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used in MExtension.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and\n        unchecked {\n            senderAccount_.balance -= amount;\n            recipientAccount_.balance += amount;\n\n            senderAccount_.principal = fromPrincipal_ - principal_;\n            recipientAccount_.principal += principal_;\n        }\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev    Compute the yield given a balance, principal and index.\n     * @param  balance   The current balance of the account.\n     * @param  principal The principal of the account.\n     * @param  index     The current index.\n     * @return The yield accrued since the last claim.\n     */\n    function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {\n        if (principal == 0) return 0;\n\n        uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);\n        unchecked {\n            return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;\n        }\n    }\n\n    /**\n     * @dev Reverts if `account` is not whitelisted by earner manager.\n     */\n    function _revertIfNotWhitelisted(MEarnerManagerStorageStruct storage $, address account) internal view {\n        if (!$.accounts[account].isWhitelisted) revert NotWhitelisted(account);\n    }\n}\n"
    }
}