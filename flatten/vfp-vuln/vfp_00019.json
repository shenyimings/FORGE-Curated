{
    "vfp_id": "vfp_00019",
    "project_name": "OP Succinct - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Creation of contract OPSuccinctDisputeGame could be blocked by front-running the output proposal",
            "description": "1. **Description:** The `OPSuccinctDisputeGame` contract's initialization process involves calling `proposeL2Output` on `OPSuccinctL2OutputOracle`. However, due to a race condition, an external malicious proposer can front-run this call.\n2. **Cause:** After one proposal, there is a required interval before another can occur. Since `proposeL2Output` can be called directly by anyone (if conditions like fallback timeout are met), a malicious user can submit a proposal just before the dispute game attempts to initialize.\n3. **Exploitation:** An attacker can monitor the mempool for the deployment transaction of `OPSuccinctDisputeGame` and front-run it by directly calling `proposeL2Output`, thereby blocking the dispute gameâ€™s own proposal due to the rate-limiting mechanism.\n4. **Impact:** This could prevent the creation or proper initialization of a dispute game, undermining the dispute resolution mechanism and potentially allowing invalid state transitions to go unchallenged.\n",
            "severity": "Medium",
            "location": [
                "OPSuccinctDisputeGame.sol::initialize",
                "OPSuccinctL2OutputOracle.sol::proposeL2Output"
            ],
            "files": [
                "op-succinct/contracts/src/validity/OPSuccinctDisputeGame.sol"
            ]
        }
    ],
    "affected_files": {
        "OPSuccinctDisputeGame.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {OPSuccinctL2OutputOracle} from \"./OPSuccinctL2OutputOracle.sol\";\nimport {Clone} from \"@solady/utils/Clone.sol\";\nimport {ISemver} from \"interfaces/universal/ISemver.sol\";\nimport {IDisputeGame} from \"interfaces/dispute/IDisputeGame.sol\";\nimport {Claim, GameStatus, GameType, GameTypes, Hash, Timestamp} from \"@optimism/src/dispute/lib/Types.sol\";\nimport {GameNotInProgress, OutOfOrderResolution} from \"@optimism/src/dispute/lib/Errors.sol\";\n\ncontract OPSuccinctDisputeGame is ISemver, Clone, IDisputeGame {\n    ////////////////////////////////////////////////////////////////\n    //                         Events                             //\n    ////////////////////////////////////////////////////////////////\n\n    /// @notice The address of the L2 output oracle proxy contract.\n    address internal immutable L2_OUTPUT_ORACLE;\n\n    /// @notice The timestamp of the game's global creation.\n    Timestamp public createdAt;\n\n    /// @notice The timestamp of the game's global resolution.\n    Timestamp public resolvedAt;\n\n    /// @notice Returns the current status of the game.\n    GameStatus public status;\n\n    /// @notice A boolean for whether or not the game type was respected when the game was created.\n    bool public wasRespectedGameTypeWhenCreated;\n\n    /// @notice Semantic version.\n    /// @custom:semver v3.0.0-rc.1\n    string public constant version = \"v3.0.0-rc.1\";\n\n    constructor(address _l2OutputOracle) {\n        L2_OUTPUT_ORACLE = _l2OutputOracle;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                    IDisputeGame impl                   //\n    ////////////////////////////////////////////////////////////\n\n    function initialize() external payable {\n        createdAt = Timestamp.wrap(uint64(block.timestamp));\n        status = GameStatus.IN_PROGRESS;\n        wasRespectedGameTypeWhenCreated = true;\n\n        OPSuccinctL2OutputOracle oracle = OPSuccinctL2OutputOracle(L2_OUTPUT_ORACLE);\n        oracle.proposeL2Output(\n            configName(), rootClaim().raw(), l2BlockNumber(), l1BlockNumber(), proof(), proverAddress()\n        );\n\n        this.resolve();\n    }\n\n    /// @notice Getter for the game type.\n    /// @dev The reference impl should be entirely different depending on the type (fault, validity)\n    ///      i.e. The game type should indicate the security model.\n    /// @return gameType_ The type of proof system being used.\n    function gameType() public pure returns (GameType) {\n        return GameTypes.OP_SUCCINCT;\n    }\n\n    /// @notice Getter for the creator of the dispute game.\n    /// @dev `clones-with-immutable-args` argument #1\n    /// @return The creator of the dispute game.\n    function gameCreator() public pure returns (address) {\n        return _getArgAddress(0x00);\n    }\n\n    /// @notice Getter for the root claim.\n    /// @dev `clones-with-immutable-args` argument #2\n    /// @return The root claim of the DisputeGame.\n    function rootClaim() public pure returns (Claim) {\n        return Claim.wrap(_getArgBytes32(0x14));\n    }\n\n    /// @notice Getter for the parent hash of the L1 block when the dispute game was created.\n    /// @dev `clones-with-immutable-args` argument #3\n    /// @return The parent hash of the L1 block when the dispute game was created.\n    function l1Head() public pure returns (Hash) {\n        return Hash.wrap(_getArgBytes32(0x34));\n    }\n\n    /// @notice The l2BlockNumber of the disputed output root in the `L2OutputOracle`.\n    function l2BlockNumber() public pure returns (uint256 l2BlockNumber_) {\n        l2BlockNumber_ = _getArgUint256(0x54);\n    }\n\n    /// @notice The l2BlockNumber of the disputed output root in the `L2OutputOracle`.\n    function l1BlockNumber() public pure returns (uint256 l1BlockNumber_) {\n        l1BlockNumber_ = _getArgUint256(0x74);\n    }\n\n    /// @notice The prover address of the disputed output root in the `L2OutputOracle`.\n    function proverAddress() public pure returns (address proverAddress_) {\n        proverAddress_ = _getArgAddress(0x94);\n    }\n\n    /// @notice Getter for the config name.\n    /// @return configName_ The config name to use for the L2OutputOracle.\n    function configName() public pure returns (bytes32 configName_) {\n        configName_ = _getArgBytes32(0xA8);\n    }\n\n    /// @notice The SP1 proof of the new output root. To be verified in the `L2OutputOracle`.\n    function proof() public pure returns (bytes memory proof_) {\n        uint256 len;\n        assembly {\n            // 0xC8 is the starting point of the proof in the calldata.\n            // calldataload(sub(calldatasize(), 2)) loads the last 2 bytes of the calldata, which gives the length of the immutable args.\n            // shr(240, calldataload(sub(calldatasize(), 2))) masks the last 30 bytes loaded in the previous step, so only the length of the immutable args is left.\n            // sub(sub(...)) subtracts the length of the immutable args (2 bytes) and the starting point of the proof (0xC8).\n            len := sub(sub(shr(240, calldataload(sub(calldatasize(), 2))), 2), 0xC8)\n        }\n        proof_ = _getArgBytes(0xC8, len);\n    }\n\n    /// @notice Getter for the extra data.\n    /// @dev `clones-with-immutable-args` argument #4\n    /// @return extraData_ Any extra data supplied to the dispute game contract by the creator.\n    function extraData() public pure returns (bytes memory extraData_) {\n        uint256 len;\n        assembly {\n            // 0x54 is the starting point of the extra data in the calldata.\n            // calldataload(sub(calldatasize(), 2)) loads the last 2 bytes of the calldata, which gives the length of the immutable args.\n            // shr(240, calldataload(sub(calldatasize(), 2))) masks the last 30 bytes loaded in the previous step, so only the length of the immutable args is left.\n            // sub(sub(...)) subtracts the length of the immutable args (2 bytes) and the starting point of the extra data (0x54).\n            len := sub(sub(shr(240, calldataload(sub(calldatasize(), 2))), 2), 0x54)\n        }\n        extraData_ = _getArgBytes(0x54, len);\n    }\n\n    /// @notice If all necessary information has been gathered, this function should mark the game\n    ///         status as either `CHALLENGER_WINS` or `DEFENDER_WINS` and return the status of\n    ///         the resolved game. It is at this stage that the bonds should be awarded to the\n    ///         necessary parties.\n    /// @dev May only be called if the `status` is `IN_PROGRESS`.\n    /// @return status_ The status of the game after resolution.\n    function resolve() external returns (GameStatus status_) {\n        // INVARIANT: Resolution cannot occur unless the game is currently in progress.\n        if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();\n\n        resolvedAt = Timestamp.wrap(uint64(block.timestamp));\n        status_ = GameStatus.DEFENDER_WINS;\n\n        emit Resolved(status = status_);\n    }\n\n    /// @notice A compliant implementation of this interface should return the components of the\n    ///         game UUID's preimage provided in the cwia payload. The preimage of the UUID is\n    ///         constructed as `keccak256(gameType . rootClaim . extraData)` where `.` denotes\n    ///         concatenation.\n    /// @return gameType_ The type of proof system being used.\n    /// @return rootClaim_ The root claim of the DisputeGame.\n    /// @return extraData_ Any extra data supplied to the dispute game contract by the creator.\n    function gameData() external pure returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_) {\n        gameType_ = gameType();\n        rootClaim_ = rootClaim();\n        extraData_ = extraData();\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                     IMMUTABLE GETTERS                      //\n    ////////////////////////////////////////////////////////////////\n\n    /// @notice Getter for the L2OutputOracle.\n    /// @return l2OutputOracle_ The address of the L2OutputOracle.\n    function l2OutputOracle() external view returns (address l2OutputOracle_) {\n        l2OutputOracle_ = L2_OUTPUT_ORACLE;\n    }\n}\n"
    }
}