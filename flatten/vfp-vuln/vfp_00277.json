{
    "vfp_id": "vfp_00277",
    "project_name": "cantina_generic_money_nov2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Insufficient slippage control for vault operations",
            "description": "The protocol performs vault operations, including user deposits/withdrawals and privileged rebalancing, without proper slippage controls. This is due to reliance on the ERC4626 standard without guaranteeing monotonically increasing share prices, which exposes operations to potential slippage in volatile vaults such as those integrated with Curve's 3pool. An attacker could exploit price discrepancies during vault operations to cause unexpected losses. The impact includes potential loss of user funds during deposits or withdrawals and incorrect valuation during rebalancing, undermining the system's financial integrity.\n",
            "severity": "High",
            "location": [
                "RebalancingManager.sol::#L99-L111",
                "RebalancingManager.sol::#L128-L161"
            ],
            "files": [
                "67cb0291/generic-protocol/src/controller/RebalancingManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Periphery manager can manipulate rebalance and rewards and extract funds",
            "description": "The periphery manager, who controls the swapper and yield distributor addresses, can manipulate slippage during rebalancing by controlling the swapper contract's return values. Since the protocol trusts these values without validating actual asset balances before and after swaps, the periphery manager can extract funds beyond surplus yield. Additionally, re-entrancy during external calls allows temporary balance inflation to bypass value checks. The safety buffer check is also sometimes disabled, reducing protection. This could lead to significant fund loss, especially during rebalancing when safeguards are inactive.\n",
            "severity": "Medium",
            "location": [
                "RebalancingManager.sol::#L128-L160",
                "RewardsManager.sol::#L69-L89"
            ],
            "files": [
                "67cb0291/generic-protocol/src/controller/RebalancingManager.sol",
                "67cb0291/generic-protocol/src/controller/PeripheryManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ]
            },
            "title": "An attacker can (temporarily) freeze deposits and withdrawals",
            "description": "An attacker can trigger a deadlock state by manipulating vault proportions such that two or more vaults simultaneously hit their min or max proportionality limits. For example, driving two vaults to minimum and two to maximum proportionality blocks all deposits and withdrawals. Recovery requires external intervention, such as donations or rebalancing. The attacker can sandwich rebalancing transactions to induce this state without financial loss. The impact is a temporary freeze of all user funds, leading to a denial-of-service condition that disrupts protocol functionality and user access.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "67cb0291/generic-protocol/src/controller/RebalancingManager.sol",
                "67cb0291/generic-protocol/src/controller/VaultManager.sol"
            ]
        }
    ],
    "affected_files": {
        "RebalancingManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { BaseController } from \"./BaseController.sol\";\nimport { AccountingLogic } from \"./AccountingLogic.sol\";\nimport { IControlledVault } from \"../interfaces/IControlledVault.sol\";\n\n/**\n * @title RebalancingManager\n * @notice Abstract contract that manages the rebalancing of assets between controlled vaults\n * @dev This contract allows authorized users to rebalance assets from one vault to another,\n * with optional asset swapping if the vaults use different underlying assets.\n * It extends BaseController to inherit access control and common functionality.\n */\nabstract contract RebalancingManager is BaseController, AccountingLogic {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    /**\n     * @notice Role identifier for addresses authorized to perform rebalancing operations\n     */\n    bytes32 public constant REBALANCING_MANAGER_ROLE = keccak256(\"REBALANCING_MANAGER_ROLE\");\n\n    /**\n     * @notice Emitted when assets are successfully rebalanced between vaults\n     */\n    event Rebalanced(address indexed fromVault, address indexed toVault, uint256 fromAmount, uint256 toAmount);\n\n    /**\n     * @notice Thrown when one or both of the provided vault addresses are not valid vaults\n     */\n    error Rebalance_InvalidVault();\n    /**\n     * @notice Thrown when attempting to rebalance between the same vault\n     */\n    error Rebalance_SameVault();\n    /**\n     * @notice Thrown when the fromAmount parameter is zero\n     */\n    error Rebalance_ZeroFromAmount();\n    /**\n     * @notice Thrown when the received amount is less than the minimum expected amount\n     */\n    error Rebalance_SlippageTooHigh();\n\n    /**\n     * @notice Internal initializer for the RebalancingManager contract\n     * @dev This function is called during contract initialization and is marked as onlyInitializing\n     * to ensure it can only be called once during the initialization process\n     */\n    // forge-lint: disable-next-line(mixed-case-function)\n    function __RebalancingManager_init() internal onlyInitializing { }\n\n    /**\n     * @notice Rebalances assets from one vault to another, with optional asset swapping\n     * @param fromVault The address of the vault to withdraw assets from\n     * @param fromAmount The amount of assets to withdraw from the source vault\n     * @param toVault The address of the vault to deposit assets to\n     * @param minToAmount The minimum amount of assets expected to be deposited (slippage protection)\n     * @param swapperData Additional data passed to the swapper for asset conversion\n     */\n    function rebalance(\n        address fromVault,\n        uint256 fromAmount,\n        address toVault,\n        uint256 minToAmount,\n        bytes calldata swapperData\n    )\n        external\n        nonReentrant\n        onlyRole(REBALANCING_MANAGER_ROLE)\n    {\n        require(isVault(fromVault) && isVault(toVault), Rebalance_InvalidVault());\n        require(fromVault != toVault, Rebalance_SameVault());\n        require(fromAmount > 0, Rebalance_ZeroFromAmount());\n\n        address fromAsset = IControlledVault(fromVault).asset();\n        address toAsset = IControlledVault(toVault).asset();\n\n        uint256 toAmount = fromAsset == toAsset\n            ? _rebalanceSameAssets(fromVault, toVault, fromAsset, fromAmount)\n            : _rebalanceDiffAssets(fromVault, toVault, fromAsset, toAsset, fromAmount, minToAmount, swapperData);\n\n        emit Rebalanced(fromVault, toVault, fromAmount, toAmount);\n    }\n\n    /**\n     * @dev Internal function to rebalance the same asset type between two vaults\n     * @param fromVault The address of the vault to withdraw assets from\n     * @param toVault The address of the vault to deposit assets to\n     * @param amount The amount of assets to rebalance between vaults\n     * @return toAmount The actual amount of assets that were successfully rebalanced\n     */\n    function _rebalanceSameAssets(\n        address fromVault,\n        address toVault,\n        address asset,\n        uint256 amount\n    )\n        internal\n        returns (uint256 toAmount)\n    {\n        IControlledVault(fromVault).controllerWithdraw(asset, amount, toVault);\n        IControlledVault(toVault).controllerDeposit(amount);\n        return amount;\n    }\n\n    /**\n     * @dev Internal function to rebalance different asset types between vaults with asset swapping.\n     * The function includes multiple slippage protection mechanisms:\n     * - Individual swap slippage protection via minToAmount\n     * - Protocol-wide backing value slippage protection\n     * - Safety buffer validation to ensure losses don't exceed acceptable limits\n     * @param fromVault The address of the vault to withdraw assets from\n     * @param toVault The address of the vault to deposit assets to\n     * @param fromAsset The address of the asset being withdrawn from the source vault\n     * @param toAsset The address of the asset being deposited to the destination vault\n     * @param fromAmount The amount of assets to withdraw from the source vault\n     * @param minToAmount The minimum amount of destination assets expected (slippage protection)\n     * @param swapperData Additional data passed to the swapper for asset conversion\n     * @return toAmount The actual amount of destination assets received and deposited\n     */\n    function _rebalanceDiffAssets(\n        address fromVault,\n        address toVault,\n        address fromAsset,\n        address toAsset,\n        uint256 fromAmount,\n        uint256 minToAmount,\n        bytes calldata swapperData\n    )\n        internal\n        returns (uint256 toAmount)\n    {\n        // Store original backing value for slippage calculations\n        uint256 originalBackingValue = backingAssetsValue();\n\n        IControlledVault(fromVault).controllerWithdraw(fromAsset, fromAmount, address(_swapper));\n        toAmount = _swapper.swap(fromAsset, fromAmount, toAsset, minToAmount, toVault, swapperData);\n        IControlledVault(toVault).controllerDeposit(toAmount);\n\n        // Individual swap slippage protection\n        require(toAmount >= minToAmount, Rebalance_SlippageTooHigh());\n        // Check overall protocol backing value to ensure slippage is within acceptable range\n        uint256 newBackingValue = backingAssetsValue();\n        require(\n            newBackingValue >= originalBackingValue.mulDiv(MAX_BPS - maxProtocolRebalanceSlippage, MAX_BPS),\n            Rebalance_SlippageTooHigh()\n        );\n        // Slippage loss must not exceed safety buffer\n        if (skipNextRebalanceSafetyBufferCheck) {\n            skipNextRebalanceSafetyBufferCheck = false;\n        } else {\n            require(_safetyBuffer(newBackingValue) > 0, Rebalance_SlippageTooHigh());\n        }\n    }\n}\n",
        "VaultManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IControlledVault } from \"../interfaces/IControlledVault.sol\";\nimport { BaseController } from \"./BaseController.sol\";\nimport { PriceFeedManager } from \"./PriceFeedManager.sol\";\n\n/**\n * @title VaultManager\n * @notice Manages vaults within Controller system\n * @dev Abstract contract that handles vault registration, removal, and configuration\n * Uses a linked list structure for efficient vault management and iteration\n * Inherits from BaseController for access control and basic functionality\n */\nabstract contract VaultManager is BaseController, PriceFeedManager {\n    using Math for uint256;\n\n    /**\n     * @notice Role identifier for vault management operations\n     */\n    bytes32 public constant VAULT_MANAGER_ROLE = keccak256(\"VAULT_MANAGER_ROLE\");\n    /**\n     * @notice Sentinel address used as the head and tail of the vaults linked list\n     */\n    address public constant SENTINEL_VAULTS = address(0x1);\n\n    /**\n     * @notice Emitted when a new vault is added to the system\n     */\n    event VaultAdded(address indexed vault, address indexed asset);\n    /**\n     * @notice Emitted when a vault is removed from the system\n     */\n    event VaultRemoved(address indexed vault);\n    /**\n     * @notice Emitted when vault settings are updated\n     */\n    event VaultSettingsUpdated(\n        address indexed vault, uint256 maxCapacity, uint256 maxProportionality, uint256 minProportionality\n    );\n    /**\n     * @notice Emitted when the main vault for an asset is updated\n     */\n    event MainVaultForAssetUpdated(address indexed asset, address indexed oldVault, address indexed newVault);\n\n    /**\n     * @notice Thrown when a vault's controller does not match this contract\n     */\n    error Vault_ControllerMismatch();\n    /**\n     * @notice Thrown when an invalid vault address is provided\n     */\n    error Vault_InvalidVault();\n    /**\n     * @notice Thrown when trying to add a vault for an asset without a price feed\n     */\n    error Vault_NoPriceFeedForAsset();\n    /**\n     * @notice Thrown when trying to remove a vault that still contains assets\n     */\n    error Vault_VaultNotEmpty();\n    /**\n     * @notice Thrown when the provided previous vault in the linked list is incorrect\n     */\n    error Vault_InvalidPrevVault();\n    /**\n     * @notice Thrown when the maximum proportionality exceeds the allowed limit\n     */\n    error Vault_InvalidMaxProportionality();\n    /**\n     * @notice Thrown when the minimum proportionality exceeds the allowed limit\n     */\n    error Vault_InvalidMinProportionality();\n    /**\n     * @notice Thrown when minimum proportionality is greater than maximum proportionality\n     */\n    error Vault_MinProportionalityNotLessThanMax();\n    /**\n     * @notice Thrown when trying to set a vault as the main vault for an asset it already is\n     */\n    error Vault_AlreadyMainVaultForAsset();\n\n    /**\n     * @notice Initializes the VaultManager with an empty vaults linked list\n     * @dev Sets up the sentinel vault as the head of the linked list\n     * This function should be called during contract initialization\n     */\n    // forge-lint: disable-next-line(mixed-case-function)\n    function __VaultManager_init() internal onlyInitializing {\n        _vaults[SENTINEL_VAULTS] = SENTINEL_VAULTS;\n    }\n\n    /**\n     * @notice Adds a new vault to the system with specified settings\n     * @dev The vault is inserted at the beginning of the linked list for O(1) insertion\n     * @param vault The address of the vault to add\n     * @param settings The configuration settings for the vault\n     * @param isMainVaultForAsset If true, sets this vault as the main vault for its asset\n     */\n    function addVault(\n        address vault,\n        VaultSettings calldata settings,\n        bool isMainVaultForAsset\n    )\n        external\n        onlyRole(VAULT_MANAGER_ROLE)\n    {\n        require(vault != SENTINEL_VAULTS && vault != address(0) && !isVault(vault), Vault_InvalidVault());\n        require(IControlledVault(vault).controller() == address(this), Vault_ControllerMismatch());\n\n        address asset = IControlledVault(vault).asset();\n        require(priceFeedExists(asset), Vault_NoPriceFeedForAsset());\n\n        _vaults[vault] = _vaults[SENTINEL_VAULTS];\n        _vaults[SENTINEL_VAULTS] = vault;\n        _vaultsCount++;\n        emit VaultAdded(vault, asset);\n\n        _checkVaultSettings(settings);\n        vaultSettings[vault] = settings;\n        emit VaultSettingsUpdated(vault, settings.maxCapacity, settings.maxProportionality, settings.minProportionality);\n\n        if (isMainVaultForAsset || _vaultFor[asset] == address(0)) {\n            emit MainVaultForAssetUpdated(asset, _vaultFor[asset], vault);\n            _vaultFor[asset] = vault;\n        }\n    }\n\n    /**\n     * @notice Removes a vault from the system\n     * @dev Removes the vault from the linked list and clears its settings\n     * @param vault The address of the vault to remove\n     * @param prevVault The address of the vault that precedes this vault in the linked list\n     */\n    function removeVault(address vault, address prevVault) external onlyRole(VAULT_MANAGER_ROLE) {\n        require(isVault(vault), Vault_InvalidVault());\n        require(IControlledVault(vault).totalNormalizedAssets() == 0, Vault_VaultNotEmpty());\n        require(_vaults[prevVault] == vault, Vault_InvalidPrevVault());\n\n        _vaults[prevVault] = _vaults[vault];\n        delete _vaults[vault];\n        _vaultsCount--;\n        emit VaultRemoved(vault);\n\n        delete vaultSettings[vault];\n        emit VaultSettingsUpdated(vault, 0, 0, 0);\n\n        address asset = IControlledVault(vault).asset();\n        if (_vaultFor[asset] == vault) {\n            emit MainVaultForAssetUpdated(asset, _vaultFor[asset], address(0));\n            delete _vaultFor[asset];\n        }\n    }\n\n    /**\n     * @notice Updates the settings for an existing vault\n     * @dev Note: It's possible to set settings that are incompatible with the current vault state\n     * (e.g., maxCapacity < totalAssets). Such settings may prevent further deposits but\n     * should not break existing functionality\n     * @param vault The address of the vault to update\n     * @param settings The new configuration settings for the vault\n     */\n    function updateVaultSettings(\n        address vault,\n        VaultSettings calldata settings\n    )\n        external\n        onlyRole(VAULT_MANAGER_ROLE)\n    {\n        require(isVault(vault), Vault_InvalidVault());\n        _checkVaultSettings(settings);\n        vaultSettings[vault] = settings;\n        emit VaultSettingsUpdated(vault, settings.maxCapacity, settings.maxProportionality, settings.minProportionality);\n    }\n\n    /**\n     * @notice Sets the main vault for the asset managed by the specified vault\n     * @dev The specified vault must be registered\n     * @param vault The address of the vault to set as main for the asset\n     */\n    function setMainVault(address vault) external onlyRole(VAULT_MANAGER_ROLE) {\n        require(isVault(vault), Vault_InvalidVault());\n        address asset = IControlledVault(vault).asset();\n        require(_vaultFor[asset] != vault, Vault_AlreadyMainVaultForAsset());\n        emit MainVaultForAssetUpdated(asset, _vaultFor[asset], vault);\n        _vaultFor[asset] = vault;\n    }\n\n    /**\n     * @notice Checks if an address is a registered vault\n     * @param vault The address to check\n     * @return True if the address is a registered vault, false otherwise\n     */\n    function isVault(address vault) public view returns (bool) {\n        return vault != SENTINEL_VAULTS && _vaults[vault] != address(0);\n    }\n\n    /**\n     * @notice Returns an array of all registered vault addresses\n     * @dev Iterates through the linked list to collect all vault addresses\n     * The order matches the insertion order (most recently added vaults first)\n     * @return Array containing all registered vault addresses\n     */\n    function vaults() public view returns (address[] memory) {\n        uint256 vaultCount = _vaultsCount;\n        address[] memory vaultList = new address[](vaultCount);\n        address currentVault = _vaults[SENTINEL_VAULTS];\n        for (uint256 i; i < vaultCount; ++i) {\n            vaultList[i] = currentVault;\n            currentVault = _vaults[currentVault];\n        }\n        return vaultList;\n    }\n\n    /**\n     * @notice Calculates the value of a specific amount of assets held in a vault\n     * @param vault The address of the vault\n     * @param normalizedAmount The amount of normalized assets to value\n     * @return The value of the specified asset amount in normalized decimals\n     */\n    function _vaultValue(address vault, uint256 normalizedAmount) internal view returns (uint256) {\n        return normalizedAmount.mulDiv(getAssetPrice(IControlledVault(vault).asset()), 10 ** NORMALIZED_PRICE_DECIMALS);\n    }\n\n    /**\n     * @notice Validates vault settings parameters\n     * @param settings The vault settings to validate\n     */\n    function _checkVaultSettings(VaultSettings calldata settings) internal pure {\n        require(settings.maxProportionality <= MAX_BPS, Vault_InvalidMaxProportionality());\n        require(settings.minProportionality <= MAX_BPS, Vault_InvalidMinProportionality());\n        require(settings.minProportionality <= settings.maxProportionality, Vault_MinProportionalityNotLessThanMax());\n    }\n\n    /**\n     * @notice Retrieves the asset managed by a given vault\n     * @param vault The address of the vault\n     * @return The address of the asset managed by the vault, or address(0) if not a vault\n     */\n    function _vaultAsset(address vault) internal view returns (address) {\n        return isVault(vault) ? IControlledVault(vault).asset() : address(0);\n    }\n\n    struct VaultsOverview {\n        address[] vaults;\n        uint256[] assets;\n        VaultSettings[] settings;\n        uint256 totalAssets;\n        uint256 totalValue;\n    }\n\n    /**\n     * @notice Gets a comprehensive overview of all vaults in the system\n     * @dev Iterates through all registered vaults to collect their data\n     * @param calculateTotalValue If true, calculates the total USD value of all assets\n     * @return overview Complete overview struct with vault data and optionally total value\n     */\n    function _vaultsOverview(bool calculateTotalValue) internal view returns (VaultsOverview memory overview) {\n        overview.vaults = vaults();\n        uint256 count = overview.vaults.length;\n        overview.assets = new uint256[](count);\n        overview.settings = new VaultSettings[](count);\n        overview.totalAssets = 0;\n        overview.totalValue = 0;\n\n        for (uint256 i; i < count; ++i) {\n            overview.assets[i] = IControlledVault(overview.vaults[i]).totalNormalizedAssets();\n            overview.settings[i] = vaultSettings[overview.vaults[i]];\n            overview.totalAssets += overview.assets[i];\n            if (calculateTotalValue) {\n                overview.totalValue += _vaultValue(overview.vaults[i], overview.assets[i]);\n            }\n        }\n    }\n}\n",
        "PeripheryManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { BaseController, ISwapper, IYieldDistributor } from \"./BaseController.sol\";\n\n/**\n * @title PeripheryManager\n * @notice Abstract contract for managing periphery services like swappers and yield distributors\n * @dev Inherits from BaseController and provides role-based management of external service contracts\n */\nabstract contract PeripheryManager is BaseController {\n    /**\n     * @notice Role identifier for addresses authorized to manage periphery services\n     */\n    bytes32 public constant PERIPHERY_MANAGER_ROLE = keccak256(\"PERIPHERY_MANAGER_ROLE\");\n\n    /**\n     * @notice Emitted when the swapper contract address is updated\n     */\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\n    /**\n     * @notice Emitted when the yield distributor contract address is updated\n     */\n    event YieldDistributorUpdated(address indexed oldDistributor, address indexed newDistributor);\n\n    /**\n     * @notice Thrown when attempting to set the swapper to the zero address\n     */\n    error Periphery_ZeroSwapper();\n    /**\n     * @notice Thrown when attempting to set the yield distributor to the zero address\n     */\n    error Periphery_ZeroYieldDistributor();\n\n    /**\n     * @notice Initializes the PeripheryManager with swapper and yield distributor contracts\n     * @dev Internal function called during contract initialization\n     * @param swapper_ The swapper contract interface for token swapping operations\n     * @param yieldDistributor_ The yield distributor contract interface for yield distribution\n     */\n    // forge-lint: disable-next-line(mixed-case-function)\n    function __PeripheryManager_init(\n        ISwapper swapper_,\n        IYieldDistributor yieldDistributor_\n    )\n        internal\n        onlyInitializing\n    {\n        require(address(swapper_) != address(0), Periphery_ZeroSwapper());\n        require(address(yieldDistributor_) != address(0), Periphery_ZeroYieldDistributor());\n        _swapper = swapper_;\n        _yieldDistributor = yieldDistributor_;\n    }\n\n    /**\n     * @notice Updates the swapper contract used for token swapping operations\n     * @dev Only callable by addresses with PERIPHERY_MANAGER_ROLE\n     * @param newSwapper The new swapper to use\n     */\n    function setSwapper(ISwapper newSwapper) external onlyRole(PERIPHERY_MANAGER_ROLE) {\n        require(address(newSwapper) != address(0), Periphery_ZeroSwapper());\n        emit SwapperUpdated(address(_swapper), address(newSwapper));\n        _swapper = newSwapper;\n    }\n\n    /**\n     * @notice Updates the yield distributor contract used for yield distribution\n     * @dev Only callable by addresses with PERIPHERY_MANAGER_ROLE\n     * @param newDistributor The new yield distributor to use\n     */\n    function setYieldDistributor(IYieldDistributor newDistributor) external onlyRole(PERIPHERY_MANAGER_ROLE) {\n        require(address(newDistributor) != address(0), Periphery_ZeroYieldDistributor());\n        emit YieldDistributorUpdated(address(_yieldDistributor), address(newDistributor));\n        _yieldDistributor = newDistributor;\n    }\n\n    /**\n     * @notice Returns the address of the current swapper contract\n     * @return The address of the swapper contract\n     */\n    function swapper() public view returns (address) {\n        return address(_swapper);\n    }\n\n    /**\n     * @notice Returns the address of the current yield distributor contract\n     * @return The address of the yield distributor contract\n     */\n    function yieldDistributor() public view returns (address) {\n        return address(_yieldDistributor);\n    }\n}\n"
    }
}