{
    "vfp_id": "vfp_00002",
    "project_name": "Zenith - SSI Protocol Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Missing pause function in `USSI`",
            "description": "1. **Description:** The USSI contract lacks a pause function, which could prevent administrators from halting operations during emergencies or critical bugs.\n2. **Cause:** The absence of a pausable mechanism in the contract design.\n3. **Exploitation:** An attacker could continue to exploit ongoing operations if a vulnerability is discovered while the system remains active.\n4. **Impact:** Lack of operational control may lead to prolonged exposure to risks, potentially resulting in financial loss or system instability.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ssi-protocol/src/USSI.sol"
            ]
        }
    ],
    "affected_files": {
        "USSI.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport './Interface.sol';\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"forge-std/console.sol\";\n\ncontract USSI is Initializable, OwnableUpgradeable, AccessControlUpgradeable, ERC20Upgradeable, UUPSUpgradeable, PausableUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20 for IERC20;\n\n    enum HedgeOrderType { NONE, MINT, REDEEM }\n    enum HedgeOrderStatus { NONE, PENDING, REJECTED, CONFIRMED }\n\n    struct HedgeOrder {\n        HedgeOrderType orderType;\n        uint256 assetID;\n        address redeemToken;\n        uint256 nonce;\n        uint256 inAmount;\n        uint256 outAmount;\n        uint256 deadline;\n        address requester;\n        uint256[5] __gap;\n    }\n\n    EnumerableSet.Bytes32Set orderHashs;\n    mapping(bytes32 => HedgeOrder) public hedgeOrders;\n    mapping(bytes32 => HedgeOrderStatus) public orderStatus;\n    mapping(bytes32 => uint256) public requestTimestamps;\n\n    EnumerableSet.UintSet supportAssetIDs;\n\n    address public redeemToken;\n    address public orderSigner;\n    address public factoryAddress;\n\n    bytes32 public constant PARTICIPANT_ROLE = keccak256(\"PARTICIPANT_ROLE\");\n\n    mapping(bytes32 => bytes32) public redeemTxHashs;\n\n    event AddAssetID(uint256 assetID);\n    event RemoveAssetID(uint256 assetID);\n    event UpdateOrderSigner(address oldOrderSigner, address orderSigner);\n    event UpdateRedeemToken(address oldRedeemToken, address redeemToken);\n    event ApplyMint(HedgeOrder hedgeOrder);\n    event RejectMint(bytes32 orderHash);\n    event ConfirmMint(bytes32 orderHash);\n    event ApplyRedeem(HedgeOrder hedgeOrder);\n    event RejectRedeem(bytes32 orderHash);\n    event ConfirmRedeem(bytes32 orderHash);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address owner, address orderSigner_, address factoryAddress_, address redeemToken_) public initializer {\n        __Ownable_init(owner);\n        __AccessControl_init();\n        __ERC20_init(\"USSI\", \"USSI\");\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n        require(factoryAddress_ != address(0), \"zero factory address\");\n        require(redeemToken_ != address(0), \"zero redeem token address\");\n        require(orderSigner_ != address(0), \"zero order signer address\");\n        factoryAddress = factoryAddress_;\n        redeemToken = redeemToken_;\n        orderSigner = orderSigner_;\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function decimals() public pure override(ERC20Upgradeable) returns (uint8) {\n        return 8;\n    }\n\n    function getSupportAssetIDs() external view returns (uint256[] memory assetIDs) {\n        assetIDs = new uint256[](supportAssetIDs.length());\n        for (uint i = 0; i < assetIDs.length; i++) {\n            assetIDs[i] = supportAssetIDs.at(i);\n        }\n    }\n\n    function addSupportAsset(uint256 assetID) external onlyOwner {\n        require(IAssetFactory(factoryAddress).hasAssetID(assetID), \"asset not exists\");\n        require(!supportAssetIDs.contains(assetID), \"already contains assetID\");\n        supportAssetIDs.add(assetID);\n        emit AddAssetID(assetID);\n    }\n\n    function removeSupportAsset(uint256 assetID) external onlyOwner {\n        require(IAssetFactory(factoryAddress).hasAssetID(assetID), \"asset not exists\");\n        require(supportAssetIDs.contains(assetID), \"assetID is not supported\");\n        supportAssetIDs.remove(assetID);\n        emit RemoveAssetID(assetID);\n    }\n\n    function updateOrderSigner(address orderSigner_) external onlyOwner {\n        address oldOrderSigner = orderSigner;\n        require(orderSigner_ != address(0), \"orderSigner is zero address\");\n        require(orderSigner_ != orderSigner, \"orderSigner not change\");\n        orderSigner = orderSigner_;\n        emit UpdateOrderSigner(oldOrderSigner, orderSigner);\n    }\n\n    function updateRedeemToken(address redeemToken_) external onlyOwner {\n        address oldRedeemToken = redeemToken;\n        require(redeemToken_ != address(0), \"redeem token is zero address\");\n        require(redeemToken_ != redeemToken, \"redeem token not change\");\n        redeemToken = redeemToken_;\n        emit UpdateRedeemToken(oldRedeemToken, redeemToken);\n    }\n\n    function checkHedgeOrder(HedgeOrder calldata hedgeOrder, bytes32 orderHash, bytes calldata orderSignature) public view {\n        if (hedgeOrder.orderType == HedgeOrderType.MINT) {\n            require(supportAssetIDs.contains(hedgeOrder.assetID), \"assetID not supported\");\n        }\n        if (hedgeOrder.orderType == HedgeOrderType.REDEEM) {\n            require(redeemToken == hedgeOrder.redeemToken, \"redeem token not supported\");\n        }\n        require(block.timestamp <= hedgeOrder.deadline, \"expired\");\n        require(!orderHashs.contains(orderHash), \"order already exists\");\n        require(SignatureChecker.isValidSignatureNow(orderSigner, orderHash, orderSignature), \"signature not valid\");\n    }\n\n    function applyMint(HedgeOrder calldata hedgeOrder, bytes calldata orderSignature) external onlyRole(PARTICIPANT_ROLE) whenNotPaused {\n        require(hedgeOrder.requester == msg.sender, \"msg sender is not requester\");\n        bytes32 orderHash = keccak256(abi.encode(hedgeOrder));\n        checkHedgeOrder(hedgeOrder, orderHash, orderSignature);\n        require(hedgeOrder.orderType == HedgeOrderType.MINT, \"order type not match\");\n        HedgeOrder storage hedgeOrder_ = hedgeOrders[orderHash];\n        hedgeOrder_.orderType = hedgeOrder.orderType;\n        hedgeOrder_.assetID = hedgeOrder.assetID;\n        hedgeOrder_.nonce = hedgeOrder.nonce;\n        hedgeOrder_.inAmount = hedgeOrder.inAmount;\n        hedgeOrder_.outAmount = hedgeOrder.outAmount;\n        hedgeOrder_.deadline = hedgeOrder.deadline;\n        hedgeOrder_.requester = hedgeOrder.requester;\n        orderHashs.add(orderHash);\n        orderStatus[orderHash] = HedgeOrderStatus.PENDING;\n        requestTimestamps[orderHash] = block.timestamp;\n        IERC20 assetToken = IERC20(IAssetFactory(factoryAddress).assetTokens(hedgeOrder.assetID));\n        require(assetToken.allowance(hedgeOrder.requester, address(this)) >= hedgeOrder.inAmount, \"not enough allowance\");\n        assetToken.safeTransferFrom(hedgeOrder.requester, address(this), hedgeOrder.inAmount);\n        emit ApplyMint(hedgeOrder);\n    }\n\n    function rejectMint(bytes32 orderHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.MINT, \"order type not match\");\n        orderStatus[orderHash] = HedgeOrderStatus.REJECTED;\n        IERC20 assetToken = IERC20(IAssetFactory(factoryAddress).assetTokens(hedgeOrder.assetID));\n        assetToken.safeTransfer(hedgeOrder.requester, hedgeOrder.inAmount);\n        emit RejectMint(orderHash);\n    }\n\n    function confirmMint(bytes32 orderHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.MINT, \"order type not match\");\n        _mint(hedgeOrder.requester, hedgeOrder.outAmount);\n        orderStatus[orderHash] = HedgeOrderStatus.CONFIRMED;\n        IERC20 assetToken = IERC20(IAssetFactory(factoryAddress).assetTokens(hedgeOrder.assetID));\n        IAssetIssuer issuer = IAssetIssuer(IAssetFactory(factoryAddress).issuers(hedgeOrder.assetID));\n        if (assetToken.allowance(address(this), address(issuer)) < hedgeOrder.inAmount) {\n            assetToken.forceApprove(address(issuer), type(uint256).max);\n        }\n        issuer.burnFor(hedgeOrder.assetID, hedgeOrder.inAmount);\n        emit ConfirmMint(orderHash);\n    }\n\n    function applyRedeem(HedgeOrder calldata hedgeOrder, bytes calldata orderSignature) external onlyRole(PARTICIPANT_ROLE) whenNotPaused {\n        require(hedgeOrder.requester == msg.sender, \"msg sender is not requester\");\n        bytes32 orderHash = keccak256(abi.encode(hedgeOrder));\n        checkHedgeOrder(hedgeOrder, orderHash, orderSignature);\n        require(hedgeOrder.orderType == HedgeOrderType.REDEEM, \"order type not match\");\n        require(allowance(hedgeOrder.requester, address(this)) >= hedgeOrder.inAmount, \"not enough allowance\");\n        HedgeOrder storage hedgeOrder_ = hedgeOrders[orderHash];\n        hedgeOrder_.orderType = hedgeOrder.orderType;\n        hedgeOrder_.redeemToken = hedgeOrder.redeemToken;\n        hedgeOrder_.nonce = hedgeOrder.nonce;\n        hedgeOrder_.inAmount = hedgeOrder.inAmount;\n        hedgeOrder_.outAmount = hedgeOrder.outAmount;\n        hedgeOrder_.deadline = hedgeOrder.deadline;\n        hedgeOrder_.requester = hedgeOrder.requester;\n        orderHashs.add(orderHash);\n        orderStatus[orderHash] = HedgeOrderStatus.PENDING;\n        requestTimestamps[orderHash] = block.timestamp;\n        IERC20(address(this)).safeTransferFrom(hedgeOrder.requester, address(this), hedgeOrder.inAmount);\n        emit ApplyRedeem(hedgeOrder);\n    }\n\n    function rejectRedeem(bytes32 orderHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.REDEEM, \"order type not match\");\n        orderStatus[orderHash] = HedgeOrderStatus.REJECTED;\n        IERC20(address(this)).safeTransfer(hedgeOrder.requester, hedgeOrder.inAmount);\n        emit RejectRedeem(orderHash);\n    }\n\n    function confirmRedeem(bytes32 orderHash, bytes32 txHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.REDEEM, \"order type not match\");\n        orderStatus[orderHash] = HedgeOrderStatus.CONFIRMED;\n        if (txHash == bytes32(0)) {\n            require(IERC20(hedgeOrder.redeemToken).balanceOf(address(this)) >= hedgeOrder.outAmount, \"not enough redeem token\");\n            IERC20(hedgeOrder.redeemToken).safeTransfer(hedgeOrder.requester, hedgeOrder.outAmount);\n        } else {\n            redeemTxHashs[orderHash] = txHash;\n        }\n        _burn(address(this), hedgeOrder.inAmount);\n        emit ConfirmRedeem(orderHash);\n    }\n\n    function getOrderHashs() external view returns (bytes32[] memory orderHashs_) {\n        orderHashs_ = new bytes32[](orderHashs.length());\n        for (uint i = 0; i < orderHashs.length(); i++) {\n            orderHashs_[i] = orderHashs.at(i);\n        }\n    }\n\n    function getOrderHashLength() external view returns (uint256) {\n        return orderHashs.length();\n    }\n\n    function getOrderHash(uint256 nonce) external view returns (bytes32) {\n        return orderHashs.at(nonce);\n    }\n}"
    }
}