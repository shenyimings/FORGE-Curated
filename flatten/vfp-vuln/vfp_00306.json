{
    "vfp_id": "vfp_00306",
    "project_name": "Cove - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Weights can pass unchecked",
            "description": "The completeRebalance function allows the rebalancing process to finalize even if the target weights are not met after the maximum number of retries (_MAX_RETRIES). Instead of reverting, the function proceeds with the current (potentially unfavorable) weights, leading to a basket that may be improperly balanced. The cause is the design decision to continue rather than revert when target weights are unmet. An attacker could exploit this by manipulating market conditions or delaying trades to ensure target weights are not met, forcing a rebalance with suboptimal allocations. The impact is a potential imbalance in basket composition, which could affect performance, valuation, and user trust. This is considered a design limitation rather than a critical flaw, but it introduces risk in volatile market conditions.\n",
            "severity": "Medium",
            "location": [
                "BasketManagerUtils.sol::completeRebalance#_isTargetWeightMet"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Underflow when calculating basket balances",
            "description": "The _processInternalTrades function in BasketManagerUtils performs unchecked arithmetic when updating basket balances. Although it checks that the net buy amount does not exceed the current balance, it subtracts the larger initialBuyAmount (before fee deduction) from the balance within an unchecked block. This can result in an underflow, setting the balance to an extremely large value due to integer wraparound. Since the operation occurs in an unchecked context, Solidity's built-in overflow protection is bypassed. This could corrupt basket state, block further operations, and potentially lead to loss of funds by disrupting internal accounting and rebalancing mechanisms.\n",
            "severity": "Critical",
            "location": [
                "BasketManagerUtils.sol::_processInternalTrades"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect swap-fee calculation on feeOnBuy",
            "description": "The swap fee is calculated based on initialBuyAmount, which is derived after deducting the sell-side fee. However, according to the protocol specification, the fee should be calculated on the buy amount before any fee deductions. This discrepancy causes the protocol to collect less fee revenue than intended, as the fee base is smaller than it should be. The cause is a misalignment between the documented fee model and the implementation logic. Over time, this leads to significant financial loss for the protocol due to undercollected fees.\n",
            "severity": "High",
            "location": [
                "BasketManagerUtils.sol::_processInternalTrades"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Denial-of-service risk where attackers can disrupt rebalance process with BasketManagerUtils.completeRebalance() functionality",
            "description": "The completeRebalance function can be called by anyone once 15 minutes have passed since the rebalance was proposed, even if the rebalance is not ready to complete. If the target weights are not met, the function resets the status to REBALANCE_PROPOSED instead of reverting, allowing an attacker to repeatedly call it and force the admin to re-propose token swaps. The root cause is the lack of access control on completeRebalance and the silent reset of state instead of reverting. An attacker can exploit this by monitoring the rebalance timeline and calling completeRebalance at the 15-minute mark to reset the process, preventing the admin from progressing to TOKEN_SWAP_EXECUTED. The impact is a denial-of-service on the rebalancing mechanism, delaying or disrupting basket maintenance, which could affect liquidity and user confidence. The team acknowledges the vector but considers it mitigated by completing rebalances within 15 minutes.\n",
            "severity": "Medium",
            "location": [
                "BasketManagerUtils.sol::completeRebalance#status reset"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        }
    ],
    "affected_files": {
        "BasketManagerUtils.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FixedPointMathLib } from \"@solady/utils/FixedPointMathLib.sol\";\n\nimport { AssetRegistry } from \"src/AssetRegistry.sol\";\nimport { BasketToken } from \"src/BasketToken.sol\";\nimport { Errors } from \"src/libraries/Errors.sol\";\nimport { MathUtils } from \"src/libraries/MathUtils.sol\";\nimport { TokenSwapAdapter } from \"src/swap_adapters/TokenSwapAdapter.sol\";\nimport { BasketManagerStorage, RebalanceStatus, Status } from \"src/types/BasketManagerStorage.sol\";\nimport { BasketTradeOwnership, ExternalTrade, InternalTrade } from \"src/types/Trades.sol\";\n\n/// @title BasketManagerUtils\n/// @notice Library containing utility functions for managing storage related to baskets, including creating new\n/// baskets, proposing and executing rebalances, and settling internal and external token trades.\nlibrary BasketManagerUtils {\n    using SafeERC20 for IERC20;\n\n    /// STRUCTS ///\n\n    /// @notice Struct containing data for an internal trade.\n    struct InternalTradeInfo {\n        // Index of the basket that is selling.\n        uint256 fromBasketIndex;\n        // Index of the basket that is buying.\n        uint256 toBasketIndex;\n        // Index of the token to sell.\n        uint256 sellTokenAssetIndex;\n        // Index of the token to buy.\n        uint256 buyTokenAssetIndex;\n        // Index of the buy token in the buying basket.\n        uint256 toBasketBuyTokenIndex;\n        // Index of the sell token in the buying basket.\n        uint256 toBasketSellTokenIndex;\n        // Amount of the buy token that is traded.\n        uint256 netBuyAmount;\n        // Amount of the sell token that is traded.\n        uint256 netSellAmount;\n        // Fee charged on the buy token on the trade.\n        uint256 feeOnBuy;\n        // Fee charged on the sell token on the trade.\n        uint256 feeOnSell;\n    }\n\n    /// @notice Struct containing data for an external trade.\n    struct ExternalTradeInfo {\n        // Price of the sell token.\n        uint256 sellTokenPrice;\n        // Price of the buy token.\n        uint256 buyTokenPrice;\n        // Value of the sell token.\n        uint256 sellValue;\n        // Minimum amount of the buy token that the trade results in.\n        uint256 internalMinAmount;\n        // Difference between the internalMinAmount and the minAmount.\n        uint256 diff;\n    }\n\n    /// @notice Struct containing data for basket ownership of an external trade.\n    struct BasketOwnershipInfo {\n        // Index of the basket.\n        uint256 basketIndex;\n        // Index of the buy token asset.\n        uint256 buyTokenAssetIndex;\n        // Index of the sell token asset.\n        uint256 sellTokenAssetIndex;\n    }\n\n    /// CONSTANTS ///\n    /// @notice ISO 4217 numeric code for USD, used as a constant address representation\n    address private constant _USD_ISO_4217_CODE = address(840);\n    /// @notice Maximum number of basket tokens allowed to be created.\n    uint256 private constant _MAX_NUM_OF_BASKET_TOKENS = 256;\n    /// @notice Maximum slippage multiplier for token swaps, expressed in 1e18.\n    uint256 private constant _MAX_SLIPPAGE = 0.05e18; // 5%\n    /// @notice Maximum deviation multiplier to determine if a set of balances has reached the desired target weights.\n    uint256 private constant _MAX_WEIGHT_DEVIATION = 0.05e18; // 5%\n    /// @notice Precision used for weight calculations and slippage calculations.\n    uint256 private constant _WEIGHT_PRECISION = 1e18;\n    /// @notice Maximum number of retries for a rebalance.\n    uint8 private constant _MAX_RETRIES = 3;\n    /// @notice Minimum time between rebalances in seconds.\n    uint40 private constant _REBALANCE_COOLDOWN_SEC = 1 hours;\n\n    /// EVENTS ///\n    /// @notice Emitted when an internal trade is settled.\n    /// @param internalTrade Internal trade that was settled.\n    /// @param buyAmount Amount of the the from token that is traded.\n    event InternalTradeSettled(InternalTrade internalTrade, uint256 buyAmount);\n    /// @notice Emitted when swap fees are charged on an internal trade.\n    /// @param asset Asset that the swap fee was charged in.\n    /// @param amount Amount of the asset that was charged.\n    event SwapFeeCharged(address indexed asset, uint256 amount);\n    /// @notice Emitted when a rebalance is proposed for a set of baskets\n    /// @param epoch Unique identifier for the rebalance, incremented each time a rebalance is proposed\n    /// @param baskets Array of basket addresses to rebalance\n    /// @param proposedTargetWeights Array of target weights for each basket\n    /// @param basketHash Hash of the basket addresses and target weights for the rebalance\n    event RebalanceProposed(\n        uint40 indexed epoch, address[] baskets, uint64[][] proposedTargetWeights, bytes32 basketHash\n    );\n    /// @notice Emitted when a rebalance is completed.\n    event RebalanceCompleted(uint40 indexed epoch);\n\n    /// ERRORS ///\n    /// @dev Reverts when the total supply of a basket token is zero.\n    error ZeroTotalSupply();\n    /// @dev Reverts when the amount of burned shares is zero.\n    error ZeroBurnedShares();\n    /// @dev Reverts when trying to burn more shares than the total supply.\n    error CannotBurnMoreSharesThanTotalSupply();\n    /// @dev Reverts when the requested basket token is not found.\n    error BasketTokenNotFound();\n    /// @dev Reverts when the requested asset is not found in the basket.\n    error AssetNotFoundInBasket();\n    /// @dev Reverts when trying to create a basket token that already exists.\n    error BasketTokenAlreadyExists();\n    /// @dev Reverts when the maximum number of basket tokens has been reached.\n    error BasketTokenMaxExceeded();\n    /// @dev Reverts when the requested element index is not found.\n    error ElementIndexNotFound();\n    /// @dev Reverts when the strategy registry does not support the given strategy.\n    error StrategyRegistryDoesNotSupportStrategy();\n    /// @dev Reverts when the baskets or target weights do not match the proposed rebalance.\n    error BasketsMismatch();\n    /// @dev Reverts when the base asset does not match the given asset.\n    error BaseAssetMismatch();\n    /// @dev Reverts when the asset is not found in the asset registry.\n    error AssetListEmpty();\n    /// @dev Reverts when a rebalance is in progress and the caller must wait for it to complete.\n    error MustWaitForRebalanceToComplete();\n    /// @dev Reverts when there is no rebalance in progress.\n    error NoRebalanceInProgress();\n    /// @dev Reverts when it is too early to complete the rebalance.\n    error TooEarlyToCompleteRebalance();\n    /// @dev Reverts when it is too early to propose a rebalance.\n    error TooEarlyToProposeRebalance();\n    /// @dev Reverts when a rebalance is not required.\n    error RebalanceNotRequired();\n    /// @dev Reverts when the external trade slippage exceeds the allowed limit.\n    error ExternalTradeSlippage();\n    /// @dev Reverts when the target weights are not met.\n    error TargetWeightsNotMet();\n    /// @dev Reverts when the minimum or maximum amount is not reached for an internal trade.\n    error InternalTradeMinMaxAmountNotReached();\n    /// @dev Reverts when the trade token amount is incorrect.\n    error IncorrectTradeTokenAmount();\n    /// @dev Reverts when given external trades do not match.\n    error ExternalTradeMismatch();\n    /// @dev Reverts when the delegatecall to the tokenswap adapter fails.\n    error CompleteTokenSwapFailed();\n    /// @dev Reverts when an asset included in a bit flag is not enabled in the asset registry.\n    error AssetNotEnabled();\n\n    /// @notice Creates a new basket token with the given parameters.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basketName Name of the basket.\n    /// @param symbol Symbol of the basket.\n    /// @param bitFlag Asset selection bitFlag for the basket.\n    /// @param strategy Address of the strategy contract for the basket.\n    /// @return basket Address of the newly created basket token.\n    function createNewBasket(\n        BasketManagerStorage storage self,\n        string calldata basketName,\n        string calldata symbol,\n        address baseAsset,\n        uint256 bitFlag,\n        address strategy\n    )\n        external\n        returns (address basket)\n    {\n        // Checks\n        if (baseAsset == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        uint256 basketTokensLength = self.basketTokens.length;\n        if (basketTokensLength >= _MAX_NUM_OF_BASKET_TOKENS) {\n            revert BasketTokenMaxExceeded();\n        }\n        bytes32 basketId = keccak256(abi.encodePacked(bitFlag, strategy));\n        if (self.basketIdToAddress[basketId] != address(0)) {\n            revert BasketTokenAlreadyExists();\n        }\n        // Checks with external view calls\n        if (!self.strategyRegistry.supportsBitFlag(bitFlag, strategy)) {\n            revert StrategyRegistryDoesNotSupportStrategy();\n        }\n        AssetRegistry assetRegistry = AssetRegistry(self.assetRegistry);\n        {\n            if (assetRegistry.hasPausedAssets(bitFlag)) {\n                revert AssetNotEnabled();\n            }\n            address[] memory assets = assetRegistry.getAssets(bitFlag);\n            if (assets.length == 0) {\n                revert AssetListEmpty();\n            }\n            basket = Clones.clone(self.basketTokenImplementation);\n            _setBaseAssetIndex(self, basket, assets, baseAsset);\n            self.basketTokens.push(basket);\n            self.basketAssets[basket] = assets;\n            self.basketIdToAddress[basketId] = basket;\n            // The set default management fee will given to the zero address\n            self.managementFees[basket] = self.managementFees[address(0)];\n            uint256 assetsLength = assets.length;\n            for (uint256 j = 0; j < assetsLength;) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketAssetToIndexPlusOne[basket][assets[j]] = j + 1;\n                unchecked {\n                    // Overflow not possible: j is bounded by assets.length\n                    ++j;\n                }\n            }\n        }\n        unchecked {\n            // Overflow not possible: basketTokensLength is less than the constant _MAX_NUM_OF_BASKET_TOKENS\n            self.basketTokenToIndexPlusOne[basket] = basketTokensLength + 1;\n        }\n        // Interactions\n        BasketToken(basket).initialize(IERC20(baseAsset), basketName, symbol, bitFlag, strategy, address(assetRegistry));\n    }\n\n    /// @notice Proposes a rebalance for the given baskets. The rebalance is proposed if the difference between the\n    /// target balance and the current balance of any asset in the basket is more than 500 USD.\n    /// @param baskets Array of basket addresses to rebalance.\n    // solhint-disable code-complexity\n    // slither-disable-next-line cyclomatic-complexity\n    function proposeRebalance(BasketManagerStorage storage self, address[] calldata baskets) external {\n        // Checks\n        // Revert if a rebalance is already in progress\n        if (self.rebalanceStatus.status != Status.NOT_STARTED) {\n            revert MustWaitForRebalanceToComplete();\n        }\n        // slither-disable-next-line timestamp\n        if (block.timestamp - self.rebalanceStatus.timestamp < _REBALANCE_COOLDOWN_SEC) {\n            revert TooEarlyToProposeRebalance();\n        }\n\n        // Effects\n        self.rebalanceStatus.basketMask = _createRebalanceBitMask(self, baskets);\n        self.rebalanceStatus.timestamp = uint40(block.timestamp);\n        self.rebalanceStatus.status = Status.REBALANCE_PROPOSED;\n\n        address assetRegistry = self.assetRegistry;\n        uint64[][] memory basketTargetWeights = new uint64[][](baskets.length);\n\n        // Interactions\n        bool shouldRebalance = false;\n        for (uint256 i = 0; i < baskets.length;) {\n            // slither-disable-start calls-loop\n            address basket = baskets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            basketTargetWeights[i] = BasketToken(basket).getTargetWeights();\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            if (assets.length == 0) {\n                revert BasketTokenNotFound();\n            }\n            if (AssetRegistry(assetRegistry).hasPausedAssets(BasketToken(basket).bitFlag())) {\n                revert AssetNotEnabled();\n            }\n            // Calculate current basket value\n            (uint256[] memory balances, uint256 basketValue) = _calculateBasketValue(self, basket, assets);\n            // Notify Basket Token of rebalance:\n            (uint256 pendingDeposits, uint256 pendingRedeems) =\n                BasketToken(basket).prepareForRebalance(self.managementFees[basket], self.feeCollector);\n            if (pendingDeposits > 0) {\n                shouldRebalance = true;\n            }\n            uint256 totalSupply;\n            {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;\n                uint256 pendingDepositValue;\n                // Process pending deposits and fulfill them\n                (totalSupply, pendingDepositValue) = _processPendingDeposits(\n                    self, basket, basketValue, balances[baseAssetIndex], pendingDeposits, baseAssetIndex\n                );\n                balances[baseAssetIndex] += pendingDeposits;\n                basketValue += pendingDepositValue;\n            }\n            uint256 requiredWithdrawValue = 0;\n            // Pre-process pending redemptions\n            if (pendingRedeems > 0) {\n                shouldRebalance = true;\n                if (totalSupply > 0) {\n                    // totalSupply cannot be 0 when pendingRedeems is greater than 0, as redemptions\n                    // can only occur if there are issued shares (i.e., totalSupply > 0).\n                    // Division-by-zero is not possible: totalSupply is greater than 0\n                    requiredWithdrawValue = FixedPointMathLib.fullMulDiv(basketValue, pendingRedeems, totalSupply);\n                    if (requiredWithdrawValue > basketValue) {\n                        // This should never happen, but if it does, withdraw the entire basket value\n                        requiredWithdrawValue = basketValue;\n                    }\n                    unchecked {\n                        // Overflow not possible: requiredWithdrawValue is less than or equal to basketValue\n                        basketValue -= requiredWithdrawValue;\n                    }\n                }\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.pendingRedeems[basket] = pendingRedeems;\n            }\n            uint256[] memory targetBalances = _calculateTargetBalances(\n                self, basket, basketValue, requiredWithdrawValue, assets, basketTargetWeights[i]\n            );\n            if (_isRebalanceRequired(assets, balances, targetBalances)) {\n                shouldRebalance = true;\n            }\n            // slither-disable-end calls-loop\n            unchecked {\n                // Overflow not possible: i is less than baskets.length\n                ++i;\n            }\n        }\n        if (!shouldRebalance) {\n            revert RebalanceNotRequired();\n        }\n        // Effects after Interactions. Target weights require external view calls to respective strategies.\n        bytes32 basketHash = keccak256(abi.encode(baskets, basketTargetWeights));\n        self.rebalanceStatus.basketHash = basketHash;\n        // slither-disable-next-line reentrancy-events\n        emit RebalanceProposed(self.rebalanceStatus.epoch, baskets, basketTargetWeights, basketHash);\n    }\n    // solhint-enable code-complexity\n\n    // @notice Proposes a set of internal trades and external trades to rebalance the given baskets.\n    /// If the proposed token swap results are not close to the target balances, this function will revert.\n    /// @dev This function can only be called after proposeRebalance.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param internalTrades Array of internal trades to execute.\n    /// @param externalTrades Array of external trades to execute.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketTargetWeights Array of target weights for each basket.\n    // slither-disable-next-line cyclomatic-complexity\n    function proposeTokenSwap(\n        BasketManagerStorage storage self,\n        InternalTrade[] calldata internalTrades,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata baskets,\n        uint64[][] calldata basketTargetWeights\n    )\n        external\n    {\n        // Checks\n        RebalanceStatus memory status = self.rebalanceStatus;\n        if (status.status != Status.REBALANCE_PROPOSED) {\n            revert MustWaitForRebalanceToComplete();\n        }\n        _validateBasketHash(self, baskets, basketTargetWeights);\n\n        // Effects\n        status.timestamp = uint40(block.timestamp);\n        status.status = Status.TOKEN_SWAP_PROPOSED;\n        self.rebalanceStatus = status;\n        self.externalTradesHash = keccak256(abi.encode(externalTrades));\n\n        uint256 numBaskets = baskets.length;\n        uint256[] memory totalValues = new uint256[](numBaskets);\n        // 2d array of asset balances for each basket\n        uint256[][] memory basketBalances = new uint256[][](numBaskets);\n        _initializeBasketData(self, baskets, basketBalances, totalValues);\n        // NOTE: for rebalance retries the internal trades must be updated as well\n        _processInternalTrades(self, internalTrades, baskets, basketBalances);\n        _validateExternalTrades(self, externalTrades, baskets, totalValues, basketBalances);\n        if (!_isTargetWeightMet(self, baskets, basketBalances, totalValues, basketTargetWeights)) {\n            revert TargetWeightsNotMet();\n        }\n    }\n\n    /// @notice Completes the rebalance for the given baskets. The rebalance can be completed if it has been more than\n    /// 15 minutes since the last action.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades matching those proposed for rebalance.\n    /// @param baskets Array of basket addresses proposed for rebalance.\n    /// @param basketTargetWeights Array of target weights for each basket.\n    // slither-disable-next-line cyclomatic-complexity\n    function completeRebalance(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata baskets,\n        uint64[][] calldata basketTargetWeights\n    )\n        external\n    {\n        // Revert if there is no rebalance in progress\n        // slither-disable-next-line incorrect-equality\n        if (self.rebalanceStatus.status == Status.NOT_STARTED) {\n            revert NoRebalanceInProgress();\n        }\n        _validateBasketHash(self, baskets, basketTargetWeights);\n        // Check if the rebalance was proposed more than 15 minutes ago\n        // slither-disable-next-line timestamp\n        if (block.timestamp - self.rebalanceStatus.timestamp < 15 minutes) {\n            revert TooEarlyToCompleteRebalance();\n        }\n        // if external trades are proposed and executed, finalize them and claim results from the trades\n        if (self.rebalanceStatus.status == Status.TOKEN_SWAP_EXECUTED) {\n            if (keccak256(abi.encode(externalTrades)) != self.externalTradesHash) {\n                revert ExternalTradeMismatch();\n            }\n            _processExternalTrades(self, externalTrades);\n        }\n\n        uint256 len = baskets.length;\n        uint256[] memory totalValue_ = new uint256[](len);\n        // 2d array of asset amounts for each basket after all trades are settled\n        uint256[][] memory afterTradeAmounts_ = new uint256[][](len);\n        _initializeBasketData(self, baskets, afterTradeAmounts_, totalValue_);\n        // Confirm that target weights have been met, if max retries is reached continue regardless\n        if (self.retryCount < _MAX_RETRIES) {\n            if (!_isTargetWeightMet(self, baskets, afterTradeAmounts_, totalValue_, basketTargetWeights)) {\n                // If target weights are not met and we have not reached max retries, revert to beginning of rebalance\n                // to allow for additional token swaps to be proposed and increment retryCount.\n                self.retryCount += 1;\n                self.rebalanceStatus.timestamp = uint40(block.timestamp);\n                self.externalTradesHash = bytes32(0);\n                self.rebalanceStatus.status = Status.REBALANCE_PROPOSED;\n                return;\n            }\n        }\n        _finalizeRebalance(self, baskets);\n    }\n\n    /// FALLBACK REDEEM LOGIC ///\n\n    /// @notice Fallback redeem function to redeem shares when the rebalance is not in progress. Redeems the shares for\n    /// each underlying asset in the basket pro-rata to the amount of shares redeemed.\n    /// @param totalSupplyBefore Total supply of the basket token before the shares were burned.\n    /// @param burnedShares Amount of shares burned.\n    /// @param to Address to send the redeemed assets to.\n    function proRataRedeem(\n        BasketManagerStorage storage self,\n        uint256 totalSupplyBefore,\n        uint256 burnedShares,\n        address to\n    )\n        external\n    {\n        // Checks\n        if (totalSupplyBefore == 0) {\n            revert ZeroTotalSupply();\n        }\n        if (burnedShares == 0) {\n            revert ZeroBurnedShares();\n        }\n        if (burnedShares > totalSupplyBefore) {\n            revert CannotBurnMoreSharesThanTotalSupply();\n        }\n        if (to == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        // Revert if the basket is currently rebalancing\n        if ((self.rebalanceStatus.basketMask & (1 << self.basketTokenToIndexPlusOne[msg.sender] - 1)) != 0) {\n            revert MustWaitForRebalanceToComplete();\n        }\n\n        address basket = msg.sender;\n        address[] storage assets = self.basketAssets[basket];\n        uint256 assetsLength = assets.length;\n\n        // Interactions\n        for (uint256 i = 0; i < assetsLength;) {\n            address asset = assets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            uint256 balance = self.basketBalanceOf[basket][asset];\n            // Rounding direction: down\n            // Division-by-zero is not possible: totalSupplyBefore is greater than 0\n            uint256 amountToWithdraw = FixedPointMathLib.fullMulDiv(burnedShares, balance, totalSupplyBefore);\n            if (amountToWithdraw > 0) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[basket][asset] = balance - amountToWithdraw;\n                // Asset is an allowlisted ERC20 with no reentrancy problem in transfer\n                // slither-disable-next-line reentrancy-no-eth\n                IERC20(asset).safeTransfer(to, amountToWithdraw);\n            }\n            unchecked {\n                // Overflow not possible: i is less than assetsLength\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the index of the asset in a given basket\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basketToken Basket token address.\n    /// @param asset Asset address.\n    /// @return index Index of the asset in the basket.\n    function basketTokenToRebalanceAssetToIndex(\n        BasketManagerStorage storage self,\n        address basketToken,\n        address asset\n    )\n        public\n        view\n        returns (uint256 index)\n    {\n        index = self.basketAssetToIndexPlusOne[basketToken][asset];\n        if (index == 0) {\n            revert AssetNotFoundInBasket();\n        }\n        unchecked {\n            // Overflow not possible: index is not 0\n            return index - 1;\n        }\n    }\n\n    /// @notice Returns the index of the basket token.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basketToken Basket token address.\n    /// @return index Index of the basket token.\n    function basketTokenToIndex(\n        BasketManagerStorage storage self,\n        address basketToken\n    )\n        public\n        view\n        returns (uint256 index)\n    {\n        index = self.basketTokenToIndexPlusOne[basketToken];\n        if (index == 0) {\n            revert BasketTokenNotFound();\n        }\n        unchecked {\n            // Overflow not possible: index is not 0\n            return index - 1;\n        }\n    }\n\n    /// INTERNAL FUNCTIONS ///\n\n    /// @notice Returns the index of the element in the array.\n    /// @dev Reverts if the element does not exist in the array.\n    /// @param array Array to find the element in.\n    /// @param element Element to find in the array.\n    /// @return index Index of the element in the array.\n    function _indexOf(address[] memory array, address element) internal pure returns (uint256 index) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length;) {\n            if (array[i] == element) {\n                return i;\n            }\n            unchecked {\n                // Overflow not possible: index is not 0\n                ++i;\n            }\n        }\n        revert ElementIndexNotFound();\n    }\n\n    /// PRIVATE FUNCTIONS ///\n\n    /// @notice Internal function to finalize the state changes for the current rebalance. Resets rebalance status and\n    /// attempts to process pending redeems. If all pending redeems cannot be fulfilled notifies basket token of a\n    /// failed rebalance.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    function _finalizeRebalance(BasketManagerStorage storage self, address[] calldata baskets) private {\n        // Advance the rebalance epoch and reset the status\n        uint40 epoch = self.rebalanceStatus.epoch;\n        self.rebalanceStatus.basketHash = bytes32(0);\n        self.rebalanceStatus.basketMask = 0;\n        self.rebalanceStatus.epoch += 1;\n        self.rebalanceStatus.timestamp = uint40(block.timestamp);\n        self.rebalanceStatus.status = Status.NOT_STARTED;\n        self.externalTradesHash = bytes32(0);\n        self.retryCount = 0;\n        // slither-disable-next-line reentrancy-events\n        emit RebalanceCompleted(epoch);\n\n        // Process the redeems for the given baskets\n        // slither-disable-start calls-loop\n        uint256 len = baskets.length;\n        for (uint256 i = 0; i < len;) {\n            // NOTE: Can be optimized by using calldata for the `baskets` parameter or by moving the\n            // redemption processing logic to a ZK coprocessor like Axiom for improved efficiency and scalability.\n            address basket = baskets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 assetsLength = assets.length;\n            uint256[] memory balances = new uint256[](assetsLength);\n            uint256 basketValue = 0;\n\n            // Calculate current basket value\n            for (uint256 j = 0; j < assetsLength;) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                balances[j] = self.basketBalanceOf[basket][assets[j]];\n                // Rounding direction: down\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                basketValue += self.eulerRouter.getQuote(balances[j], assets[j], _USD_ISO_4217_CODE);\n                unchecked {\n                    // Overflow not possible: j is less than assetsLength\n                    ++j;\n                }\n            }\n\n            // If there are pending redeems, process them\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            uint256 pendingRedeems = self.pendingRedeems[basket];\n            if (pendingRedeems > 0) {\n                // slither-disable-next-line costly-loop\n                delete self.pendingRedeems[basket]; // nosemgrep\n                // Assume the first asset listed in the basket is the base asset\n                // Rounding direction: down\n                // Division-by-zero is not possible: priceOfAssets[baseAssetIndex] is greater than 0, totalSupply is\n                // greater than 0\n                // when pendingRedeems is greater than 0\n                uint256 rawAmount =\n                    FixedPointMathLib.fullMulDiv(basketValue, pendingRedeems, BasketToken(basket).totalSupply());\n                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                uint256 withdrawAmount =\n                    self.eulerRouter.getQuote(rawAmount, _USD_ISO_4217_CODE, assets[baseAssetIndex]);\n                if (withdrawAmount <= balances[baseAssetIndex]) {\n                    unchecked {\n                        // Overflow not possible: withdrawAmount is less than or equal to balances[baseAssetIndex]\n                        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                        self.basketBalanceOf[basket][assets[baseAssetIndex]] = balances[baseAssetIndex] - withdrawAmount;\n                    }\n                    // slither-disable-next-line reentrancy-no-eth\n                    IERC20(assets[baseAssetIndex]).forceApprove(basket, withdrawAmount);\n                    // ERC20.transferFrom is called in BasketToken.fulfillRedeem\n                    // slither-disable-next-line reentrancy-no-eth\n                    BasketToken(basket).fulfillRedeem(withdrawAmount);\n                } else {\n                    BasketToken(basket).fallbackRedeemTrigger();\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is less than baskets.length\n                ++i;\n            }\n        }\n        // slither-disable-end calls-loop\n    }\n\n    /// @notice Internal function to complete proposed token swaps.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades to be completed.\n    /// @return claimedAmounts amounts claimed from the completed token swaps\n    function _completeTokenSwap(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades\n    )\n        private\n        returns (uint256[2][] memory claimedAmounts)\n    {\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) =\n            self.tokenSwapAdapter.delegatecall(abi.encodeCall(TokenSwapAdapter.completeTokenSwap, (externalTrades)));\n        // solhint-enable avoid-low-level-calls\n        if (!success) {\n            // assume this low-level call never fails\n            revert CompleteTokenSwapFailed();\n        }\n        claimedAmounts = abi.decode(data, (uint256[2][]));\n    }\n\n    /// @notice Internal function to update internal accounting with result of completed token swaps.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades to be completed.\n    function _processExternalTrades(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades\n    )\n        private\n    {\n        uint256 externalTradesLength = externalTrades.length;\n        uint256[2][] memory claimedAmounts = _completeTokenSwap(self, externalTrades);\n        // Update basketBalanceOf with amounts gained from swaps\n        for (uint256 i = 0; i < externalTradesLength;) {\n            ExternalTrade memory trade = externalTrades[i];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 tradeOwnershipLength = trade.basketTradeOwnership.length;\n            for (uint256 j; j < tradeOwnershipLength;) {\n                BasketTradeOwnership memory ownership = trade.basketTradeOwnership[j];\n                address basket = ownership.basket;\n                // Account for bought tokens\n                self.basketBalanceOf[basket][trade.buyToken] +=\n                    FixedPointMathLib.fullMulDiv(claimedAmounts[i][1], ownership.tradeOwnership, _WEIGHT_PRECISION);\n                // Account for sold tokens\n                self.basketBalanceOf[basket][trade.sellToken] = self.basketBalanceOf[basket][trade.sellToken]\n                    + FixedPointMathLib.fullMulDiv(claimedAmounts[i][0], ownership.tradeOwnership, _WEIGHT_PRECISION)\n                    - FixedPointMathLib.fullMulDiv(trade.sellAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);\n                unchecked {\n                    // Overflow not possible: i is less than tradeOwnerShipLength.length\n                    ++j;\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is less than externalTradesLength.length\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function to initialize basket data.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketBalances An empty array used for asset balances for each basket being rebalanced. Updated with\n    /// current balances at the end of the function.\n    /// @param totalValue_ An initialized array of total basket values for each basket being rebalanced.\n    function _initializeBasketData(\n        BasketManagerStorage storage self,\n        address[] calldata baskets,\n        uint256[][] memory basketBalances,\n        uint256[] memory totalValue_\n    )\n        private\n        view\n    {\n        uint256 numBaskets = baskets.length;\n        for (uint256 i = 0; i < numBaskets;) {\n            address basket = baskets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 assetsLength = assets.length;\n            basketBalances[i] = new uint256[](assetsLength);\n            for (uint256 j = 0; j < assetsLength;) {\n                address asset = assets[j];\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                uint256 currentAssetAmount = self.basketBalanceOf[basket][asset];\n                basketBalances[i][j] = currentAssetAmount;\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                totalValue_[i] += self.eulerRouter.getQuote(currentAssetAmount, asset, _USD_ISO_4217_CODE);\n                unchecked {\n                    // Overflow not possible: j is less than assetsLength\n                    ++j;\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is less than numBaskets\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function to settle internal trades.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param internalTrades Array of internal trades to execute.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketBalances An initialized array of asset amounts for each basket being rebalanced. Updated with\n    /// settled internal trades at the end of the function.\n    /// @dev If the result of an internal trade is not within the provided minAmount or maxAmount, this function will\n    /// revert.\n    function _processInternalTrades(\n        BasketManagerStorage storage self,\n        InternalTrade[] calldata internalTrades,\n        address[] calldata baskets,\n        uint256[][] memory basketBalances\n    )\n        private\n    {\n        uint256 swapFee = self.swapFee; // Fetch swapFee once for gas optimization\n        uint256 internalTradesLength = internalTrades.length;\n        for (uint256 i = 0; i < internalTradesLength;) {\n            InternalTrade memory trade = internalTrades[i];\n            InternalTradeInfo memory info = InternalTradeInfo({\n                fromBasketIndex: _indexOf(baskets, trade.fromBasket),\n                toBasketIndex: _indexOf(baskets, trade.toBasket),\n                sellTokenAssetIndex: basketTokenToRebalanceAssetToIndex(self, trade.fromBasket, trade.sellToken),\n                buyTokenAssetIndex: basketTokenToRebalanceAssetToIndex(self, trade.fromBasket, trade.buyToken),\n                toBasketBuyTokenIndex: basketTokenToRebalanceAssetToIndex(self, trade.toBasket, trade.buyToken),\n                toBasketSellTokenIndex: basketTokenToRebalanceAssetToIndex(self, trade.toBasket, trade.sellToken),\n                netBuyAmount: 0,\n                netSellAmount: 0,\n                feeOnBuy: 0,\n                feeOnSell: 0\n            });\n\n            // Calculate fee on sellAmount\n            if (swapFee > 0) {\n                info.feeOnSell = FixedPointMathLib.fullMulDiv(trade.sellAmount, swapFee, 20_000);\n                self.collectedSwapFees[trade.sellToken] += info.feeOnSell;\n                emit SwapFeeCharged(trade.sellToken, info.feeOnSell);\n            }\n            info.netSellAmount = trade.sellAmount - info.feeOnSell;\n\n            // Calculate initial buyAmount based on netSellAmount\n            uint256 initialBuyAmount = self.eulerRouter.getQuote(\n                self.eulerRouter.getQuote(info.netSellAmount, trade.sellToken, _USD_ISO_4217_CODE),\n                _USD_ISO_4217_CODE,\n                trade.buyToken\n            );\n\n            // Calculate fee on buyAmount\n            if (swapFee > 0) {\n                info.feeOnBuy = FixedPointMathLib.fullMulDiv(initialBuyAmount, swapFee, 20_000);\n                self.collectedSwapFees[trade.buyToken] += info.feeOnBuy;\n                emit SwapFeeCharged(trade.buyToken, info.feeOnBuy);\n            }\n            info.netBuyAmount = initialBuyAmount - info.feeOnBuy;\n\n            if (info.netBuyAmount < trade.minAmount || trade.maxAmount < info.netBuyAmount) {\n                revert InternalTradeMinMaxAmountNotReached();\n            }\n            if (trade.sellAmount > basketBalances[info.fromBasketIndex][info.sellTokenAssetIndex]) {\n                revert IncorrectTradeTokenAmount();\n            }\n            if (info.netBuyAmount > basketBalances[info.toBasketIndex][info.toBasketBuyTokenIndex]) {\n                revert IncorrectTradeTokenAmount();\n            }\n\n            // Settle the internal trades and track the balance changes.\n            // This unchecked block is safe because:\n            // - The subtraction operations can't underflow since the if checks above ensure the values being\n            //   subtracted are less than or equal to the corresponding values in basketBalances.\n            // - The addition operations can't overflow since the total supply of each token is limited and the\n            //   amounts being added are always less than the total supply.\n            unchecked {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.fromBasket][trade.sellToken] =\n                    basketBalances[info.fromBasketIndex][info.sellTokenAssetIndex] -= trade.sellAmount; // nosemgrep\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.fromBasket][trade.buyToken] =\n                    basketBalances[info.fromBasketIndex][info.buyTokenAssetIndex] += info.netBuyAmount; // nosemgrep\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.toBasket][trade.buyToken] =\n                    basketBalances[info.toBasketIndex][info.toBasketBuyTokenIndex] -= initialBuyAmount; // nosemgrep\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.toBasket][trade.sellToken] =\n                    basketBalances[info.toBasketIndex][info.toBasketSellTokenIndex] += info.netSellAmount; // nosemgrep\n                ++i;\n            }\n            emit InternalTradeSettled(trade, info.netBuyAmount);\n        }\n    }\n\n    /// @notice Internal function to validate the results of external trades.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades to be validated.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param totalValue_ Array of total basket values in USD.\n    /// @param afterTradeAmounts_ An initialized array of asset amounts for each basket being rebalanced.\n    /// @dev If the result of an external trade is not within the _MAX_SLIPPAGE threshold of the minAmount, this\n    /// function will revert.\n    function _validateExternalTrades(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata baskets,\n        uint256[] memory totalValue_,\n        uint256[][] memory afterTradeAmounts_\n    )\n        private\n        view\n    {\n        for (uint256 i = 0; i < externalTrades.length;) {\n            ExternalTrade memory trade = externalTrades[i];\n            // slither-disable-start uninitialized-local\n            ExternalTradeInfo memory info;\n            BasketOwnershipInfo memory ownershipInfo;\n            // slither-disable-end uninitialized-local\n\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            for (uint256 j = 0; j < trade.basketTradeOwnership.length;) {\n                BasketTradeOwnership memory ownership = trade.basketTradeOwnership[j];\n                ownershipInfo.basketIndex = _indexOf(baskets, ownership.basket);\n                ownershipInfo.buyTokenAssetIndex =\n                    basketTokenToRebalanceAssetToIndex(self, ownership.basket, trade.buyToken);\n                ownershipInfo.sellTokenAssetIndex =\n                    basketTokenToRebalanceAssetToIndex(self, ownership.basket, trade.sellToken);\n                uint256 ownershipSellAmount =\n                    FixedPointMathLib.fullMulDiv(trade.sellAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);\n                uint256 ownershipBuyAmount =\n                    FixedPointMathLib.fullMulDiv(trade.minAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);\n                // Record changes in basket asset holdings due to the external trade\n                if (\n                    ownershipSellAmount\n                        > afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.sellTokenAssetIndex]\n                ) {\n                    revert IncorrectTradeTokenAmount();\n                }\n                // solhint-disable-next-line max-line-length\n                afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.sellTokenAssetIndex] = afterTradeAmounts_[ownershipInfo\n                    .basketIndex][ownershipInfo.sellTokenAssetIndex] - ownershipSellAmount;\n                afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.buyTokenAssetIndex] =\n                    afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.buyTokenAssetIndex] + ownershipBuyAmount;\n                // Update total basket value\n                totalValue_[ownershipInfo.basketIndex] = totalValue_[ownershipInfo.basketIndex]\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                - self.eulerRouter.getQuote(ownershipSellAmount, trade.sellToken, _USD_ISO_4217_CODE)\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                + self.eulerRouter.getQuote(ownershipBuyAmount, trade.buyToken, _USD_ISO_4217_CODE);\n                unchecked {\n                    // Overflow not possible: j is bounded by trade.basketTradeOwnership.length\n                    ++j;\n                }\n            }\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            info.sellValue = self.eulerRouter.getQuote(trade.sellAmount, trade.sellToken, _USD_ISO_4217_CODE);\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            info.internalMinAmount = self.eulerRouter.getQuote(info.sellValue, _USD_ISO_4217_CODE, trade.buyToken);\n            info.diff = MathUtils.diff(info.internalMinAmount, trade.minAmount);\n\n            // Check if the given minAmount is within the _MAX_SLIPPAGE threshold of internalMinAmount\n            if (info.internalMinAmount < trade.minAmount) {\n                if (info.diff * _WEIGHT_PRECISION / info.internalMinAmount > _MAX_SLIPPAGE) {\n                    revert ExternalTradeSlippage();\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is bounded by baskets.length\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Validate the basket hash based on the given baskets and target weights.\n    function _validateBasketHash(\n        BasketManagerStorage storage self,\n        address[] calldata baskets,\n        uint64[][] calldata basketsTargetWeights\n    )\n        private\n        view\n    {\n        // Validate the calldata hashes\n        bytes32 basketHash = keccak256(abi.encode(baskets, basketsTargetWeights));\n        if (self.rebalanceStatus.basketHash != basketHash) {\n            revert BasketsMismatch();\n        }\n    }\n\n    /// @notice Checks if weight deviations after trades are within the acceptable _MAX_WEIGHT_DEVIATION threshold.\n    /// Returns true if all deviations are within bounds for each asset in every basket.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketBalances 2D array of asset balances for each basket. Rows are baskets, columns are assets.\n    /// @param totalValues Array of total basket values in USD.\n    /// @param basketsTargetWeights Array of target weights for each basket.\n    function _isTargetWeightMet(\n        BasketManagerStorage storage self,\n        address[] calldata baskets,\n        uint256[][] memory basketBalances,\n        uint256[] memory totalValues,\n        uint64[][] calldata basketsTargetWeights\n    )\n        private\n        view\n        returns (bool)\n    {\n        // Check if total weight change due to all trades is within the _MAX_WEIGHT_DEVIATION threshold\n        uint256 len = baskets.length;\n        for (uint256 i = 0; i < len;) {\n            address basket = baskets[i];\n            // slither-disable-next-line calls-loop\n            uint64[] memory proposedTargetWeights = basketsTargetWeights[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 proposedTargetWeightsLength = proposedTargetWeights.length;\n            for (uint256 j = 0; j < proposedTargetWeightsLength;) {\n                address asset = assets[j];\n                uint256 assetValueInUSD =\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                 self.eulerRouter.getQuote(basketBalances[i][j], asset, _USD_ISO_4217_CODE);\n                // Rounding direction: down\n                uint256 afterTradeWeight =\n                    FixedPointMathLib.fullMulDiv(assetValueInUSD, _WEIGHT_PRECISION, totalValues[i]);\n                if (MathUtils.diff(proposedTargetWeights[j], afterTradeWeight) > _MAX_WEIGHT_DEVIATION) {\n                    return false;\n                }\n                unchecked {\n                    // Overflow not possible: j is bounded by proposedTargetWeightsLength\n                    ++j;\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is bounded by len\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Internal function to process pending deposits and fulfill them.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param basketValue Current value of the basket in USD.\n    /// @param baseAssetBalance Current balance of the base asset in the basket.\n    /// @param pendingDeposit Current assets pending deposit in the given basket.\n    /// @return totalSupply Total supply of the basket token after processing pending deposits.\n    /// @return pendingDepositValue Value of the pending deposits in USD.\n    // slither-disable-next-line calls-loop\n    function _processPendingDeposits(\n        BasketManagerStorage storage self,\n        address basket,\n        uint256 basketValue,\n        uint256 baseAssetBalance,\n        uint256 pendingDeposit,\n        uint256 baseAssetIndex\n    )\n        private\n        returns (uint256 totalSupply, uint256 pendingDepositValue)\n    {\n        totalSupply = BasketToken(basket).totalSupply();\n\n        if (pendingDeposit > 0) {\n            // Assume the first asset listed in the basket is the base asset\n            // Round direction: down\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            pendingDepositValue =\n                self.eulerRouter.getQuote(pendingDeposit, self.basketAssets[basket][baseAssetIndex], _USD_ISO_4217_CODE);\n            // Rounding direction: down\n            // Division-by-zero is not possible: basketValue is greater than 0\n            uint256 requiredDepositShares = basketValue > 0\n                ? FixedPointMathLib.fullMulDiv(pendingDepositValue, totalSupply, basketValue)\n                : pendingDeposit;\n            totalSupply += requiredDepositShares;\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            self.basketBalanceOf[basket][self.basketAssets[basket][baseAssetIndex]] = baseAssetBalance + pendingDeposit;\n            // slither-disable-next-line reentrancy-no-eth,reentrancy-benign\n            BasketToken(basket).fulfillDeposit(requiredDepositShares);\n        }\n    }\n\n    /// @notice Internal function to calculate the target balances for each asset in a given basket.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param basketValue Current value of the basket in USD.\n    /// @param requiredWithdrawValue Value of the assets to be withdrawn from the basket.\n    /// @param assets Array of asset addresses in the basket.\n    /// @return targetBalances Array of target balances for each asset in the basket.\n    // slither-disable-next-line calls-loop,naming-convention\n    function _calculateTargetBalances(\n        BasketManagerStorage storage self,\n        address basket,\n        uint256 basketValue,\n        uint256 requiredWithdrawValue,\n        address[] memory assets,\n        uint64[] memory proposedTargetWeights\n    )\n        private\n        view\n        returns (uint256[] memory targetBalances)\n    {\n        uint256 assetsLength = assets.length;\n        targetBalances = new uint256[](assetsLength);\n        // Rounding direction: down\n        // Division-by-zero is not possible: priceOfAssets[j] is greater than 0\n        for (uint256 j = 0; j < assetsLength;) {\n            if (proposedTargetWeights[j] > 0) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                targetBalances[j] = self.eulerRouter.getQuote(\n                    FixedPointMathLib.fullMulDiv(proposedTargetWeights[j], basketValue, _WEIGHT_PRECISION),\n                    _USD_ISO_4217_CODE,\n                    assets[j]\n                );\n            }\n            unchecked {\n                // Overflow not possible: j is less than assetsLength\n                ++j;\n            }\n        }\n        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n        uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;\n        if (requiredWithdrawValue > 0) {\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            targetBalances[baseAssetIndex] +=\n                self.eulerRouter.getQuote(requiredWithdrawValue, _USD_ISO_4217_CODE, assets[baseAssetIndex]);\n        }\n    }\n\n    /// @notice Internal function to calculate the current value of all assets in a given basket.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param assets Array of asset addresses in the basket.\n    /// @return balances Array of balances of each asset in the basket.\n    /// @return basketValue Current value of the basket in USD.\n    // slither-disable-next-line calls-loop\n    function _calculateBasketValue(\n        BasketManagerStorage storage self,\n        address basket,\n        address[] memory assets\n    )\n        private\n        view\n        returns (uint256[] memory balances, uint256 basketValue)\n    {\n        uint256 assetsLength = assets.length;\n        balances = new uint256[](assetsLength);\n        for (uint256 j = 0; j < assetsLength;) {\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            balances[j] = self.basketBalanceOf[basket][assets[j]];\n            // Rounding direction: down\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            if (balances[j] > 0) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                basketValue += self.eulerRouter.getQuote(balances[j], assets[j], _USD_ISO_4217_CODE);\n            }\n            unchecked {\n                // Overflow not possible: j is less than assetsLength\n                ++j;\n            }\n        }\n    }\n\n    /// @notice Internal function to check if a rebalance is required for the given basket.\n    /// @dev A rebalance is required if the difference between the current asset balances and the target balances is\n    /// greater than 0. We assume the permissioned caller has already validated the condition to call this function\n    /// optimally.\n    /// @param assets Array of asset addresses in the basket.\n    /// @param balances Array of balances of each asset in the basket.\n    /// @param targetBalances Array of target balances for each asset in the basket.\n    /// @return shouldRebalance Boolean indicating if a rebalance is required.\n    function _isRebalanceRequired(\n        address[] memory assets,\n        uint256[] memory balances,\n        uint256[] memory targetBalances\n    )\n        private\n        view\n        returns (bool shouldRebalance)\n    {\n        uint256 assetsLength = assets.length;\n        for (uint256 j = 0; j < assetsLength;) {\n            // slither-disable-start calls-loop\n            if (\n                MathUtils.diff(balances[j], targetBalances[j]) > 0 // nosemgrep\n            ) {\n                shouldRebalance = true;\n                break;\n            }\n            // slither-disable-end calls-loop\n            unchecked {\n                // Overflow not possible: j is less than assetsLength\n                ++j;\n            }\n        }\n    }\n\n    /// @notice Internal function to store the index of the base asset for a given basket. Reverts if the base asset is\n    /// not present in the basket's assets.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param assets Array of asset addresses in the basket.\n    /// @param baseAsset Base asset address.\n    /// @dev If the base asset is not present in the basket, this function will revert.\n    function _setBaseAssetIndex(\n        BasketManagerStorage storage self,\n        address basket,\n        address[] memory assets,\n        address baseAsset\n    )\n        private\n    {\n        uint256 len = assets.length;\n        for (uint256 i = 0; i < len;) {\n            if (assets[i] == baseAsset) {\n                self.basketTokenToBaseAssetIndexPlusOne[basket] = i + 1;\n                return;\n            }\n            unchecked {\n                // Overflow not possible: i is less than len\n                ++i;\n            }\n        }\n        revert BaseAssetMismatch();\n    }\n\n    /// @notice Internal function to create a bitmask for baskets being rebalanced.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @return basketMask Bitmask for baskets being rebalanced.\n    /// @dev A bitmask like 00000011 indicates that the first two baskets are being rebalanced.\n    function _createRebalanceBitMask(\n        BasketManagerStorage storage self,\n        address[] memory baskets\n    )\n        private\n        view\n        returns (uint256 basketMask)\n    {\n        // Create the bitmask for baskets being rebalanced\n        basketMask = 0;\n        uint256 len = baskets.length;\n        for (uint256 i = 0; i < len;) {\n            uint256 indexPlusOne = self.basketTokenToIndexPlusOne[baskets[i]];\n            if (indexPlusOne == 0) {\n                revert BasketTokenNotFound();\n            }\n            basketMask |= (1 << indexPlusOne - 1);\n            unchecked {\n                // Overflow not possible: i is less than len\n                ++i;\n            }\n        }\n    }\n}\n"
    }
}