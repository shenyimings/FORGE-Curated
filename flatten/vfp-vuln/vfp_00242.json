{
    "vfp_id": "vfp_00242",
    "project_name": "cantina_honeyjar_february2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Admin can lock funds",
            "description": "1. **Description:** The admin (or reward notifier) can set reward parameters in a way that effectively locks user funds by misconfiguring the reward system, particularly in the notifyRewardAmount function.\n2. **Cause:** The function lacks validation checks to ensure the reward token is not the zero address or the contract itself, which could lead to incorrect reward distribution or locking of funds.\n3. **Exploitation:** An attacker with admin privileges could set a malicious reward token address, preventing proper reward distribution and effectively locking user funds by disrupting the expected functionality.\n4. **Impact:** Users may be unable to claim their rightful rewards, leading to loss of trust and potential financial loss if the system becomes unusable.\n",
            "severity": "Medium",
            "location": [
                "fatBERA.sol#L206",
                "fatBERA.sol#L252"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Deposits and Mints to Whitelisted Vaults Result in Lost Rewards",
            "description": "1. **Description:** Depositing or minting directly to a whitelisted vault results in lost rewards because such vaults are treated as having zero effective balance.\n2. **Cause:** The contract does not prevent deposits or mints to whitelisted vaults, which bypass the reward tracking mechanism since these vaults do not accumulate shares in the expected way.\n3. **Exploitation:** A user could deposit funds into a whitelisted vault, causing their shares to be recorded without proper reward synchronization, leading to permanent loss of accrued rewards.\n4. **Impact:** Users lose out on expected rewards, undermining the incentive model of the protocol and potentially leading to financial loss.\n",
            "severity": "Medium",
            "location": [
                "fatBERA.sol#L323-L343",
                "fatBERA.sol#L352-L359",
                "fatBERA.sol#L368-L376"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Whitelisted Vaults Not Receiving Accumulated Rewards",
            "description": "1. **Description:** When a vault is added to the whitelist after having been active, it does not receive rewards that accrued while it was not whitelisted.\n2. **Cause:** The setWhitelistedVault function does not update rewards before changing the vault's status, so any potential rewards during the non-whitelisted period are lost.\n3. **Exploitation:** An attacker could delay whitelisting a vault they control to manipulate reward accrual timing, or users may simply lose out due to the missing update.\n4. **Impact:** Loss of expected rewards for vault operators, reducing fairness and economic integrity of the system.\n",
            "severity": "Medium",
            "location": [
                "fatBERA.sol#L262-L264"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        }
    ],
    "affected_files": {
        "fatBERA.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC4626Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                          INTERFACES                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\ncontract fatBERA is\n    ERC4626Upgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          ERRORS                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error ZeroPrincipal();\n    error ExceedsPrincipal();\n    error ZeroRewards();\n    error ExceedsMaxDeposits();\n    error ExceedsAvailableRewards();\n    error InvalidToken();\n    error ZeroShares();\n    error ExceedsMaxRewardsTokens();\n    error RewardsDurationNotSet();\n    error RewardPeriodStillActive();\n    error ZeroRewardDuration();\n    error CannotDepositToVault();\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    struct RewardData {\n        uint256 rewardPerShareStored;\n        uint256 totalRewards;\n        uint256 rewardsDuration;\n        uint256 periodFinish;\n        uint256 rewardRate;\n        uint256 lastUpdateTime;\n        uint256 remainingRewards;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          Events                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event RewardAdded(address indexed token, uint256 rewardAmount);\n    event RewardsDurationUpdated(address indexed token, uint256 newDuration);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    uint256 public depositPrincipal;\n    uint256 public maxDeposits;\n\n    mapping(address => RewardData) public rewardData;\n    mapping(address => mapping(address => uint256)) public userRewardPerSharePaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    address[] public rewardTokens;\n    mapping(address => bool) public isRewardToken;\n    uint256 public MAX_REWARDS_TOKENS;\n\n    bytes32 public constant REWARD_NOTIFIER_ROLE = keccak256(\"REWARD_NOTIFIER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    mapping(address => uint256) public vaultedShares;\n    mapping(address => bool) public isWhitelistedVault;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          CONSTRUCTOR                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Contract constructor.\n     * @dev Disables initializers to prevent misuse.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          Events                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Initializes the contract variables and parent contracts.\n     * @param _asset The address of the underlying asset.\n     * @param _owner The admin owner address.\n     * @param _maxDeposits The maximum deposit limit.\n     * @dev Calls initializer functions from parent contracts and sets up admin roles.\n     */\n    function initialize(address _asset, address _owner, uint256 _maxDeposits) external initializer {\n        __ERC4626_init(IERC20(_asset));\n        __ERC20_init(\"fatBERA\", \"fatBERA\");\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n\n        // Set up roles\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n        _grantRole(REWARD_NOTIFIER_ROLE, _owner);\n        _grantRole(PAUSER_ROLE, _owner);\n\n        MAX_REWARDS_TOKENS = 10;\n\n        maxDeposits = _maxDeposits;\n        _pause();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          OWNER LOGIC                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Pauses contract operations.\n     * @dev Can be called by accounts with PAUSER_ROLE for quick emergency response.\n     */\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses contract operations.\n     * @dev Only callable by admin after thorough review of the emergency situation.\n     */\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Sets the maximum number of allowed reward tokens.\n     * @param newMax The new maximum reward tokens.\n     * @dev Only callable by admin.\n     */\n    function setMaxRewardsTokens(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        MAX_REWARDS_TOKENS = newMax;\n    }\n\n    /**\n     * @notice Withdraws the accumulated rounding losses for a specific reward token.\n     * @param token The address of the reward token.\n     * @param receiver The address receiving the rounded lost rewards.\n     * @dev Only callable by admin.\n     */\n    function withdrawRemainingRewards(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = rewardData[token].remainingRewards;\n        rewardData[token].remainingRewards = 0;\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n    /**\n     * @notice Authorizes an upgrade of the contract implementation.\n     * @param newImplementation The address of the new implementation.\n     * @dev Only callable by admin.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    /**\n     * @notice Updates the maximum deposit limit.\n     * @param newMax The new maximum deposit limit.\n     * @dev If newMax is less than depositPrincipal, maxDeposits is set to depositPrincipal to halt deposits.\n     */\n    function setMaxDeposits(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        maxDeposits = newMax < depositPrincipal ? depositPrincipal : newMax;\n    }\n\n    /**\n     * @notice Allows admin to withdraw principal deposits.\n     * @param assets The amount of principal tokens to withdraw.\n     * @param receiver The address receiving the withdrawn tokens.\n     * @dev Reverts if assets is zero or exceeds the deposit principal.\n     */\n    function withdrawPrincipal(uint256 assets, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (assets == 0) revert ZeroPrincipal();\n        if (assets > depositPrincipal) revert ExceedsPrincipal();\n\n        depositPrincipal -= assets;\n        IERC20(asset()).safeTransfer(receiver, assets);\n    }\n\n    /**\n     * @notice Notifies the contract of new reward tokens.\n     * @param token The address of the reward token.\n     * @param rewardAmount The amount of reward tokens to distribute.\n     * @dev Updates reward rate and accumulates any rounding losses, ensuring exact division when reward period has ended.\n     */\n    function notifyRewardAmount(address token, uint256 rewardAmount) external onlyRole(REWARD_NOTIFIER_ROLE) {\n        if (rewardAmount == 0) revert ZeroRewards();\n        if (token == address(0) || token == address(this)) revert InvalidToken();\n\n        uint256 totalSharesCurrent = totalSupply();\n        if (totalSharesCurrent == 0) revert ZeroShares();\n\n        IERC20 rewardToken = IERC20(token);\n        rewardToken.safeTransferFrom(msg.sender, address(this), rewardAmount);\n\n        // Add to reward tokens list if new\n        if (!isRewardToken[token]) {\n            rewardTokens.push(token);\n            if (rewardTokens.length > MAX_REWARDS_TOKENS) revert ExceedsMaxRewardsTokens();\n            isRewardToken[token] = true;\n        }\n\n        RewardData storage data = rewardData[token];\n        // Ensure rewards duration is set\n        if (data.rewardsDuration == 0) revert RewardsDurationNotSet();\n\n        _updateReward(token);\n\n        if (block.timestamp >= data.periodFinish) {\n            data.rewardRate = rewardAmount / data.rewardsDuration;\n            data.remainingRewards += rewardAmount - data.rewardRate * data.rewardsDuration;\n        } else {\n            uint256 remaining = data.periodFinish - block.timestamp;\n            uint256 leftover = remaining * data.rewardRate;\n            data.rewardRate = (rewardAmount + leftover) / data.rewardsDuration;\n            data.remainingRewards += (rewardAmount + leftover) - data.rewardRate * data.rewardsDuration;\n        }\n\n        data.lastUpdateTime = block.timestamp;\n        data.periodFinish = block.timestamp + data.rewardsDuration;\n        data.totalRewards += rewardAmount;\n        emit RewardAdded(token, rewardAmount);\n    }\n\n    /**\n     * @notice Sets the rewards duration for a given reward token.\n     * @param token The address of the reward token.\n     * @param duration The new rewards duration.\n     * @dev Only callable by admin after the current reward period has ended.\n     */\n    function setRewardsDuration(address token, uint256 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        RewardData storage data = rewardData[token];\n        if (block.timestamp <= data.periodFinish) revert RewardPeriodStillActive();\n        if (duration == 0) revert ZeroRewardDuration();\n        data.rewardsDuration = duration;\n        emit RewardsDurationUpdated(token, duration);\n    }\n\n    /**\n     * @dev Admin function to set a whitelisted vault address.\n     * Vaults are considered external contracts that hold fatBERA and\n     * should not accrue rewards.\n     */\n    function setWhitelistedVault(address vaultAddress, bool status) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (!isWhitelistedVault[vaultAddress]) {\n            _updateRewards(vaultAddress);\n        }\n        isWhitelistedVault[vaultAddress] = status;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        EXTERNAL LOGIC                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Returns the total assets in the vault.\n     * @return The total assets, equal to the total supply.\n     * @dev Overrides default behavior to ignore yield-related tokens.\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        return totalSupply();\n    }\n\n    /**\n     * @notice Returns the maximum amount of assets that can be deposited.\n     * @return The available deposit amount.\n     * @dev The input parameter is unused; functionality is based solely on maxDeposits.\n     */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        if (totalSupply() >= maxDeposits) return 0;\n        return maxDeposits - totalSupply();\n    }\n\n    /**\n     * @notice Returns the maximum number of shares that can be minted.\n     * @param receiver The address for which to query.\n     * @return The maximum shares that can be minted.\n     * @dev Since shares map 1:1 to assets, this is equal to maxDeposit.\n     */\n    function maxMint(address receiver) public view virtual override returns (uint256) {\n        return maxDeposit(receiver);\n    }\n\n    /**\n     * @notice Returns the maximum amount of assets that can be withdrawn.\n     * @return Always returns 0.\n     * @dev The input parameter is unused; withdrawals are currently disabled.\n     */\n    function maxWithdraw(address) public view virtual override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Returns the maximum number of shares that can be redeemed.\n     * @return Always returns 0.\n     * @dev The input parameter is unused; withdrawals are currently disabled.\n     */\n    function maxRedeem(address) public view virtual override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Deposits native ETH, wraps it, and mints vault shares.\n     * @param receiver The address receiving the minted shares.\n     * @return The number of shares minted.\n     * @dev Wraps ETH to WBERA and bypasses ERC4626 deposit since assets are already provided.\n     */\n    function depositNative(address receiver) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroPrincipal();\n        if (msg.value > maxDeposit(receiver)) revert ExceedsMaxDeposits();\n        if (isWhitelistedVault[receiver]) revert CannotDepositToVault();\n        _updateRewards(receiver);\n\n        // Wrap native token\n        IWETH weth = IWETH(asset());\n        weth.deposit{value: msg.value}();\n\n        // Calculate shares using previewDeposit\n        uint256 shares = previewDeposit(msg.value);\n\n        // Bypass ERC4626 deposit and mint directly (assets already held)\n        _mint(receiver, shares);\n        depositPrincipal += msg.value;\n\n        // Emit Deposit event to match ERC4626 spec\n        emit Deposit(msg.sender, receiver, msg.value, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Deposits assets into the vault and updates rewards.\n     * @param assets The amount of assets to deposit.\n     * @param receiver The address receiving the shares.\n     * @return The number of shares minted.\n     * @dev Overrides the parent deposit function and increments depositPrincipal.\n     */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        if (isWhitelistedVault[receiver]) revert CannotDepositToVault();\n        _updateRewards(receiver);\n\n        uint256 sharesMinted = super.deposit(assets, receiver);\n        depositPrincipal += assets;\n\n        return sharesMinted;\n    }\n\n    /**\n     * @notice Mints shares by depositing assets.\n     * @param shares The number of shares to mint.\n     * @param receiver The address receiving the minted shares.\n     * @return The amount of assets required.\n     * @dev Overrides the parent mint function and increments depositPrincipal.\n     */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        if (isWhitelistedVault[receiver]) revert CannotDepositToVault();\n        _updateRewards(receiver);\n\n        uint256 assetsRequired = super.previewMint(shares);\n        assetsRequired = super.mint(shares, receiver);\n        depositPrincipal += assetsRequired;\n\n        return assetsRequired;\n    }\n    /**\n     * @notice Claims accrued rewards for a specific reward token.\n     * @param token The address of the reward token.\n     * @param receiver The address receiving the claimed rewards.\n     * @dev Updates rewards prior to claiming and resets the user's reward balance.\n     */\n\n    function claimRewards(address token, address receiver) public nonReentrant {\n        _updateRewards(msg.sender, token);\n\n        uint256 reward = rewards[token][msg.sender];\n        if (reward > 0) {\n            rewards[token][msg.sender] = 0;\n            IERC20(token).safeTransfer(receiver, reward);\n        }\n    }\n\n    /**\n     * @notice Claims accrued rewards for all reward tokens.\n     * @param receiver The address receiving the claimed rewards.\n     * @dev Iterates through all reward tokens and claims each one.\n     */\n    function claimRewards(address receiver) public {\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            claimRewards(rewardTokens[i], receiver);\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                WITHDRAWALS ARENT ENABLED YET               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Withdraws assets from the vault.\n     * @param assets The amount of assets to withdraw.\n     * @param receiver The address receiving the assets.\n     * @param owner The owner of the shares to be withdrawn.\n     * @return The number of burned shares.\n     * @dev Updates rewards and decrements depositPrincipal. Withdrawals are subject to pause conditions.\n     */\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        _updateRewards(owner);\n\n        uint256 burnedShares = super.withdraw(assets, receiver, owner);\n        depositPrincipal -= assets;\n\n        return burnedShares;\n    }\n\n    /**\n     * @notice Redeems shares for the underlying assets.\n     * @param shares The number of shares to redeem.\n     * @param receiver The address receiving the assets.\n     * @param owner The owner of the shares.\n     * @return The amount of redeemed assets.\n     * @dev Updates rewards and decrements depositPrincipal. Withdrawals are subject to pause conditions.\n     */\n    function redeem(uint256 shares, address receiver, address owner) public override whenNotPaused returns (uint256) {\n        _updateRewards(owner);\n\n        uint256 redeemedAssets = super.redeem(shares, receiver, owner);\n        depositPrincipal -= redeemedAssets;\n\n        return redeemedAssets;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          VIEW LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Simulates the effects of withdrawing assets at the current block.\n     * @return Returns 0 if paused, otherwise returns the standard ERC4626 preview calculation.\n     * @dev Overridden to maintain consistency with maxWithdraw when paused.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        if (paused()) return 0;\n        return super.previewWithdraw(assets);\n    }\n\n    /**\n     * @notice Simulates the effects of redeeming shares at the current block.\n     * @return Returns 0 if paused, otherwise returns the standard ERC4626 preview calculation.\n     * @dev Overridden to maintain consistency with maxRedeem when paused.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        if (paused()) return 0;\n        return super.previewRedeem(shares);\n    }\n\n    /**\n     * @dev Returns the effective balance of an account for reward calculations.\n     * For a regular (non-vault) user, effective balance = wallet balance + vaultedShares.\n     * For a whitelisted vault, effective balance is 0.\n     */\n    function effectiveBalance(address account) public view returns (uint256) {\n        if (isWhitelistedVault[account]) return 0;\n        return balanceOf(account) + vaultedShares[account];\n    }\n\n    function previewRewards(address account, address token) external view returns (uint256) {\n        RewardData storage data = rewardData[token];\n        uint256 currentRewardPerShare = data.rewardPerShareStored;\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            uint256 lastApplicable = block.timestamp < data.periodFinish ? block.timestamp : data.periodFinish;\n            uint256 elapsed = lastApplicable - data.lastUpdateTime;\n            uint256 additional = FixedPointMathLib.fullMulDiv(elapsed * data.rewardRate, 1e36, supply);\n            currentRewardPerShare += additional;\n        }\n        return rewards[token][account]\n            + FixedPointMathLib.fullMulDiv(\n                effectiveBalance(account), currentRewardPerShare - userRewardPerSharePaid[token][account], 1e36\n            );\n    }\n\n    /**\n     * @notice Retrieves the list of reward tokens.\n     * @return An array containing the addresses of all reward tokens.\n     * @dev Helper function for frontend and external integrations.\n     */\n    function getRewardTokens() external view returns (address[] memory) {\n        return rewardTokens;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       INTERNAL LOGIC                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Hook to update rewards during token transfers.\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @dev Only updates rewards if both addresses are non-zero.\n     */\n    function _update(address from, address to, uint256 amount) internal override {\n        if (from != address(0) && to != address(0)) {\n            if (!isWhitelistedVault[from] && isWhitelistedVault[to]) {\n                // Depositing to a whitelisted vault.\n                _updateRewards(from);\n                vaultedShares[from] += amount;\n            } else if (isWhitelistedVault[from] && !isWhitelistedVault[to]) {\n                // Withdrawing from a whitelisted vault.\n                _updateRewards(to);\n                if (vaultedShares[to] < amount) revert(\"Insufficient vaulted shares\");\n                vaultedShares[to] -= amount;\n            } else {\n                // Normal transfer between non‑vault addresses (or vault <-> vault, though vaults have no effective balance).\n                _updateRewards(from);\n                _updateRewards(to);\n            }\n        }\n        super._update(from, to, amount);\n    }\n\n    /**\n     * @notice Updates rewards for all reward tokens for a given account.\n     * @param account The address for which rewards are updated.\n     * @dev Iterates over each reward token and calls _updateRewards for individual tokens.\n     */\n    function _updateRewards(address account) internal {\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            _updateRewards(account, rewardTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Updates rewards for a specific reward token for an account.\n     * @param account The address for which rewards are updated.\n     * @param token The reward token address.\n     * @dev Updates global reward data before calculating and storing user-specific rewards.\n     */\n    function _updateRewards(address account, address token) internal {\n        _updateReward(token);\n        RewardData storage data = rewardData[token];\n        uint256 effectiveBal = effectiveBalance(account);\n        if (effectiveBal > 0) {\n            uint256 earned = data.rewardPerShareStored - userRewardPerSharePaid[token][account];\n            rewards[token][account] += FixedPointMathLib.fullMulDiv(effectiveBal, earned, 1e36);\n        }\n        userRewardPerSharePaid[token][account] = data.rewardPerShareStored;\n    }\n\n    /**\n     * @notice Updates the global reward data for a specific token.\n     * @param token The reward token address.\n     * @dev Computes additional reward per share based on elapsed time and updates last update time.\n     */\n    function _updateReward(address token) internal {\n        RewardData storage data = rewardData[token];\n        uint256 lastApplicable = block.timestamp < data.periodFinish ? block.timestamp : data.periodFinish;\n        if (totalSupply() > 0) {\n            uint256 elapsed = lastApplicable - data.lastUpdateTime;\n            if (elapsed > 0) {\n                uint256 additional = FixedPointMathLib.fullMulDiv(elapsed * data.rewardRate, 1e36, totalSupply());\n                data.rewardPerShareStored += additional;\n            }\n        }\n        data.lastUpdateTime = lastApplicable;\n    }\n}\n"
    }
}