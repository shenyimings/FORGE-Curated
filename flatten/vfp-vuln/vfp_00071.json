{
    "vfp_id": "vfp_00071",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Inaccuracies in Gas Benchmarking Logic",
            "description": "The gas benchmarking logic in `TransferBenchmarkLib` and `TransferLib` inaccurately measures the gas cost of ERC-20 token transfers because the gas sampling includes operations before and after the actual `transfer` call, such as `mstore` and success evaluation logic. This causes the benchmarked gas values to be inflated and imprecise. The root cause is incorrect placement of gas measurement instructions in inline assembly, which fails to isolate the target `call` operation. As a result, the `ensureBenchmarkExceeded` function may accept insufficient gas for actual transfers, leading to potential transaction failures or underestimation of required gas. The impact is reduced reliability of gas enforcement mechanisms, which could result in DoS conditions or failed token transfers when actual gas usage exceeds the flawed benchmark.\n",
            "severity": "Medium",
            "location": [
                "TransferBenchmarkLib.sol#L148-L169",
                "TransferLib.sol#L121-L144"
            ],
            "files": [
                "the-compact/src/lib/TransferBenchmarkLib.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1335"
                ]
            },
            "title": "Target Address in `setNativeTokenBenchmark` Is Always the Zero Address",
            "description": "The `setNativeTokenBenchmark` function is intended to derive a 20-byte recipient address by hashing a salt with the contract address and shifting the result right by 96 bits. However, the implementation reverses the operands of the `shr` opcode, shifting the literal `96` by the hash value instead of the hash by `96`.\nSince the shift distance exceeds 96 for nearly all hash values, the result is zero, causing the target address to always be the zero address. A pre-check that the balance of this address must be zero then causes the benchmark to revert, as the zero address holds a non-zero balance on Ethereum.\nThis prevents the benchmark from initializing, causing `ensureBenchmarkExceeded` to compare zero against `gas()`, which always passes. Attackers could exploit this to bypass intended gas checks, leading to incorrect gas benchmarking.\nThe impact includes failure of the gas benchmarking mechanism, potentially allowing inefficient or exploitable transfer paths to be used without detection.\n",
            "severity": "Medium",
            "location": [
                "TransferBenchmarkLib.sol#48",
                "TransferBenchmarkLib.sol#51",
                "TransferBenchmarkLib.sol::ensureBenchmarkExceeded#197"
            ],
            "files": [
                "the-compact/src/lib/TransferBenchmarkLib.sol"
            ]
        }
    ],
    "affected_files": {
        "TransferBenchmarkLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\nimport { IdLib } from \"./IdLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\nimport { BenchmarkERC20 } from \"./BenchmarkERC20.sol\";\n\n/**\n * @title TransferBenchmarkLib\n * @notice Library contract implementing logic for benchmarking the approximate\n * cost of both native token withdrawals as well as generic ERC20 token withdrawals.\n * Designed to account for the idiosyncracies of gas pricing across various chains,\n * as well as to have functionality for updating the benchmarks should gas prices\n * change on a given chain.\n */\nlibrary TransferBenchmarkLib {\n    // Storage scope for native token benchmarks:\n    // slot: _NATIVE_TOKEN_BENCHMARK_SCOPE => benchmark.\n    uint32 private constant _NATIVE_TOKEN_BENCHMARK_SCOPE = 0x655e83a8;\n\n    // Storage scope for erc20 token benchmarks:\n    // slot: _ERC20_TOKEN_BENCHMARK_SCOPE => benchmark.\n    uint32 private constant _ERC20_TOKEN_BENCHMARK_SCOPE = 0x824664ed;\n\n    // Storage scope for erc20 token benchmark transaction uniqueness.\n    // slot: _ERC20_TOKEN_BENCHMARK_SENTINEL => block.number\n    uint32 private constant _ERC20_TOKEN_BENCHMARK_SENTINEL = 0x83ceba49;\n\n    error InvalidBenchmark();\n\n    error InsufficientStipendForWithdrawalFallback();\n\n    /**\n     * @notice Internal function for benchmarking the cost of native token transfers.\n     * Uses a deterministic address derived from the contract address and provided salt\n     * to measure the gas cost to transfer native tokens to a cold address with no balance.\n     * @param salt A bytes32 value used to derive a cold account for benchmarking.\n     * @return benchmark The measured gas cost of the native token transfer.\n     */\n    function setNativeTokenBenchmark(bytes32 salt) internal returns (uint256 benchmark) {\n        assembly (\"memory-safe\") {\n            // Derive the target for  native token transfer using address.this & salt.\n            mstore(0, address())\n            mstore(0x20, salt)\n            let target := shr(keccak256(0x0c, 0x34), 96)\n\n            // Ensure callvalue is exactly 2 wei and the target balance is zero.\n            if or(iszero(eq(callvalue(), 2)), iszero(iszero(balance(target)))) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            // Get gas before first call.\n            let firstStart := gas()\n\n            // Perform the first call, sending 1 wei.\n            let success1 := call(gas(), target, 1, codesize(), 0, codesize(), 0)\n\n            // Get gas before second call.\n            let secondStart := gas()\n\n            // Perform the second call, sending 1 wei.\n            let success2 := call(gas(), target, 1, codesize(), 0, codesize(), 0)\n\n            // Get gas after second call.\n            let secondEnd := gas()\n\n            // Derive the benchmark cost using the first call.\n            benchmark := sub(firstStart, secondStart)\n\n            // Ensure that both calls succeeded and that the cost of the first call\n            // exceeded that of the second, indicating that the account was not warm.\n            if or(or(iszero(success1), iszero(success2)), iszero(gt(benchmark, sub(secondStart, secondEnd)))) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            // Store the benchmark in the appropriate scope.\n            sstore(_NATIVE_TOKEN_BENCHMARK_SCOPE, benchmark)\n        }\n    }\n\n    /**\n     * @notice Internal function for benchmarking the cost of ERC20 token transfers.\n     * Measures the gas cost of transferring tokens to a zero-balance account and\n     * includes the overhead of interacting with a cold token contract.\n     * @param token The address of the ERC20 token to benchmark.\n     * @return benchmark The measured gas cost of the ERC20 token transfer.\n     */\n    function setERC20TokenBenchmark(address token) internal returns (uint256 benchmark) {\n        // Set the caller as the target.\n        address target = msg.sender;\n\n        assembly (\"memory-safe\") {\n            {\n                // Retrieve sentinel value.\n                let sentinel := sload(_ERC20_TOKEN_BENCHMARK_SENTINEL)\n\n                // Ensure it is not set to the current block number.\n                if eq(sentinel, number()) {\n                    mstore(0, 0x9f608b8a)\n                    revert(0x1c, 4)\n                }\n\n                // Store the current block number for the sentinel value.\n                // Note that TSTORE could be used here assuming it is supported;\n                // consider using Tstorish as in the reentrancy lock.\n                sstore(_ERC20_TOKEN_BENCHMARK_SENTINEL, number())\n            }\n\n            // Store function selector for name().\n            mstore(0, 0x06fdde03)\n\n            let firstCallCost\n            let secondCallCost\n\n            {\n                // Get gas before first call.\n                let firstStart := gas()\n\n                // Perform the first call.\n                let success1 := call(gas(), token, 0, 0x1c, 4, codesize(), 0)\n\n                // Get gas before second call.\n                let secondStart := gas()\n\n                // Perform the second call.\n                let success2 := call(gas(), token, 0, 0x1c, 4, codesize(), 0)\n\n                // Get gas after second call.\n                let secondEnd := gas()\n\n                // Derive the benchmark cost of the call.\n                firstCallCost := sub(firstStart, secondStart)\n                secondCallCost := sub(secondStart, secondEnd)\n\n                // Ensure that both calls succeeded and that the cost of the first call\n                // exceeded that of the second, indicating that the account was not warm.\n                if or(or(iszero(success1), iszero(success2)), iszero(gt(firstCallCost, secondCallCost))) {\n                    mstore(0, 0x9f608b8a)\n                    revert(0x1c, 4)\n                }\n            }\n\n            // Get gas before third call.\n            let thirdStart := gas()\n\n            mstore(0x14, target) // Store target `to` argument in memory.\n            mstore(0x34, 1) // Store an `amount` argument of 1 in memory.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n\n            // Perform the third call and ensure it succeeds.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0, 0x20)\n                )\n            ) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n\n            // Get gas after third call.\n            let thirdEnd := gas()\n\n            // Derive the execution benchmark cost using the difference.\n            let thirdCallCost := sub(thirdStart, thirdEnd)\n\n            // Combine cost of first and third calls, and remove the second call due\n            // to the fact that a single call is performed, to derive the benchmark.\n            benchmark := sub(add(firstCallCost, thirdCallCost), secondCallCost)\n\n            // Burn the transferred tokens from the target.\n            mstore(0, 0x89afcb44)\n            mstore(0x20, target)\n            if iszero(call(gas(), token, 0, 0x1c, 0x24, codesize(), 0)) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            // Store the benchmark in the appropriate scope.\n            sstore(_ERC20_TOKEN_BENCHMARK_SCOPE, benchmark)\n        }\n    }\n\n    /**\n     * @notice Internal view function to ensure there is sufficient gas remaining to\n     * cover the benchmarked cost of a token withdrawal. Reverts if the remaining gas\n     * is less than the benchmark for the specified token type.\n     * @param token The address of the token (address(0) for native tokens).\n     */\n    function ensureBenchmarkExceeded(address token) internal view {\n        assembly (\"memory-safe\") {\n            // Select the appropriate scope based on the token in question.\n            let scope :=\n                xor(\n                    _ERC20_TOKEN_BENCHMARK_SCOPE,\n                    mul(xor(_ERC20_TOKEN_BENCHMARK_SCOPE, _NATIVE_TOKEN_BENCHMARK_SCOPE), iszero(token))\n                )\n\n            // Load benchmarked value and ensure it does not exceed available gas.\n            if gt(sload(scope), gas()) {\n                // revert InsufficientStipendForWithdrawalFallback();\n                mstore(0, 0xc5274598)\n                revert(0x1c, 4)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function for retrieving the benchmarked gas costs for\n     * both native token and ERC20 token withdrawals.\n     * @return nativeTokenBenchmark The benchmarked gas cost for native token withdrawals.\n     * @return erc20TokenBenchmark  The benchmarked gas cost for ERC20 token withdrawals.\n     */\n    function getTokenWithdrawalBenchmarks()\n        internal\n        view\n        returns (uint256 nativeTokenBenchmark, uint256 erc20TokenBenchmark)\n    {\n        assembly (\"memory-safe\") {\n            nativeTokenBenchmark := sload(_NATIVE_TOKEN_BENCHMARK_SCOPE)\n            erc20TokenBenchmark := sload(_ERC20_TOKEN_BENCHMARK_SCOPE)\n        }\n    }\n}\n"
    }
}