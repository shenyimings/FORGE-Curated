{
    "vfp_id": "vfp_00281",
    "project_name": "DIA Lumina Staking Security Audit Report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "Missing Reward Accumulator Initialization in Stake Creation",
            "description": "In the DIAStakingCommons contract's _internalStakeForAddress function, the rewardAccumulator is not initialized when a new stake is created. This allows stakers to claim all historical rewards accumulated by the contract, not just those accrued since their deposit, due to the calculation `stakerDelta = rewardAccumulator - currentStore.rewardAccumulator` where the uninitialized currentStore.rewardAccumulator defaults to zero. A similar flaw exists in DIAWhitelistedStaking._getTotalRewards. The root cause is the omission of proper initialization of rewardAccumulator during stake creation. An attacker can exploit this by creating a new stake and immediately claiming rewards, receiving an unfairly large amount. The impact is incorrect reward distribution and potential loss of funds from the rewards pool due to unauthorized claims.\n",
            "severity": "Critical",
            "location": [
                "DIAStakingCommons.sol::_internalStakeForAddress",
                "DIAWhitelistedStaking.sol::_getTotalRewards"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAStakingCommons.sol"
            ]
        }
    ],
    "affected_files": {
        "DIAStakingCommons.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.29;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./StakingErrorsAndEvents.sol\";\nimport \"forge-std/console.sol\";\n// Events\n\nabstract contract DIAStakingCommons is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    mapping(address => uint256[]) internal stakingIndicesByBeneficiary;\n    mapping(address => uint256[]) internal stakingIndicesByPrincipalUnstaker;\n    mapping(address => uint256[]) internal stakingIndicesByPayoutWallet;\n\n    uint256 public stakingIndex;\n\n    struct PendingShareUpdate {\n        uint32 newShareBps;\n        uint64 requestTime;\n    }\n\n    mapping(uint256 => PendingShareUpdate) public pendingShareUpdates;\n    uint64 public constant SHARE_UPDATE_GRACE_PERIOD = 1 days;\n\n    /// @notice ERC20 token used for staking.\n    IERC20 public immutable STAKING_TOKEN;\n\n    struct StakingStore {\n        address beneficiary;\n        address principalPayoutWallet;\n        address principalUnstaker;\n        uint256 principal;\n        uint256 reward;\n        uint256 paidOutReward;\n        uint64 stakingStartTime;\n        uint64 unstakingRequestTime;\n        uint32 principalWalletShareBps;\n    }\n\n    uint256 public tokensStaked;\n\n    uint256 public stakingLimit;\n\n    /// @notice How long (in seconds) for unstaking to take place\n    uint256 public unstakingDuration;\n\n    uint256 public totalDailyWithdrawals;\n\n    uint256 public lastWithdrawalResetDay;\n    uint256 public dailyWithdrawalThreshold = 100000 * 10 ** 18; // Set threshold as needed\n    uint256 public withdrawalCapBps = 1000; // 1000 bps = 10%\n\n    /// @notice Mapping of staking index to corresponding staking store.\n    mapping(uint256 => DIAStakingCommons.StakingStore) public stakingStores;\n\n    modifier onlyBeneficiaryOrPayoutWallet(uint256 stakingStoreIndex) {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n\n        if (\n            msg.sender != currentStore.beneficiary &&\n            msg.sender != currentStore.principalPayoutWallet\n        ) {\n            revert AccessDenied();\n        }\n        _;\n    }\n\n    /**\n     * @notice Updates the duration required before unstaking can be completed.\n     * @dev Only callable by the contract owner.\n     * @param newDuration The new unstaking duration, in seconds.\n     * @custom:revert UnstakingDurationTooShort() if the new duration is less than 1 day.\n     * @custom:revert UnstakingDurationTooLong() if the new duration exceeds 20 days.\n     */\n    function setUnstakingDuration(uint256 newDuration) external onlyOwner {\n        if (newDuration < 1 days) {\n            revert UnstakingDurationTooShort();\n        }\n\n        if (newDuration > 20 days) {\n            revert UnstakingDurationTooLong();\n        }\n        emit UnstakingDurationUpdated(unstakingDuration, newDuration);\n\n        unstakingDuration = newDuration;\n    }\n\n    function setWithdrawalCapBps(uint256 newBps) external onlyOwner {\n        if (newBps > 10000) {\n            revert InvalidWithdrawalCap(newBps);\n        }\n\n        uint256 oldCap = withdrawalCapBps;\n        withdrawalCapBps = newBps;\n\n        emit WithdrawalCapUpdated(oldCap, newBps); // Emit event with old and new values\n    }\n\n    function setDailyWithdrawalThreshold(\n        uint256 newThreshold\n    ) external onlyOwner {\n        if (newThreshold <= 0) {\n            revert InvalidDailyWithdrawalThreshold(newThreshold);\n        }\n\n        uint256 oldThreshold = dailyWithdrawalThreshold;\n        dailyWithdrawalThreshold = newThreshold;\n\n        emit DailyWithdrawalThresholdUpdated(oldThreshold, newThreshold);\n    }\n\n    function getStakingIndicesByBeneficiary(\n        address beneficiary\n    ) external view returns (uint256[] memory) {\n        return stakingIndicesByBeneficiary[beneficiary];\n    }\n\n    function getStakingIndicesByPrincipalUnstaker(\n        address unstaker\n    ) external view returns (uint256[] memory) {\n        return stakingIndicesByPrincipalUnstaker[unstaker];\n    }\n\n    function getStakingIndicesByPayoutWallet(\n        address payoutWallet\n    ) external view returns (uint256[] memory) {\n        return stakingIndicesByPayoutWallet[payoutWallet];\n    }\n\n    function _removeStakingIndexFromAddressMapping(\n        address user,\n        uint256 _stakingIndex,\n        mapping(address => uint256[]) storage indexMap\n    ) internal {\n        uint256[] storage indices = indexMap[user];\n        for (uint256 i = 0; i < indices.length; i++) {\n            if (indices[i] == _stakingIndex) {\n                indices[i] = indices[indices.length - 1];\n                indices.pop();\n                break;\n            }\n        }\n    }\n\n    function _internalStakeForAddress(\n        address sender,\n        address beneficiaryAddress,\n        uint256 amount,\n        uint32 principalWalletShareBps\n    ) internal returns (uint256 index) {\n        if (principalWalletShareBps > 10000)\n            revert InvalidPrincipalWalletShare();\n\n        if (amount < minimumStake) {\n            revert AmountBelowMinimumStake(amount);\n        }\n\n        // Transfer tokens\n        STAKING_TOKEN.safeTransferFrom(sender, address(this), amount);\n\n        // Create staking entry\n        stakingIndex++;\n        StakingStore storage newStore = stakingStores[stakingIndex];\n        newStore.beneficiary = beneficiaryAddress;\n        newStore.principalPayoutWallet = sender;\n        newStore.principal = amount;\n        newStore.stakingStartTime = uint64(block.timestamp);\n        newStore.principalWalletShareBps = principalWalletShareBps;\n        newStore.principalUnstaker = sender;\n\n        // Track stake info\n        tokensStaked += amount;\n        stakingIndicesByBeneficiary[beneficiaryAddress].push(stakingIndex);\n        stakingIndicesByPrincipalUnstaker[sender].push(stakingIndex);\n        stakingIndicesByPayoutWallet[sender].push(stakingIndex);\n\n        emit Staked(beneficiaryAddress, stakingIndex, amount);\n\n        return stakingIndex;\n    }\n\n    /**\n     * @notice Updates the principal payout wallet for a given staking index.\n     * @dev Only callable by the contract owner.\n     * @param newWallet New wallet address for receiving the principal.\n     * @param stakingStoreIndex Index of the staking store.\n     */\n    function updatePrincipalPayoutWallet(\n        address newWallet,\n        uint256 stakingStoreIndex\n    ) external {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n\n        address oldWallet = currentStore.principalPayoutWallet;\n\n        currentStore.principalPayoutWallet = newWallet;\n\n        if (currentStore.principalUnstaker != msg.sender) {\n            revert NotPrincipalUnstaker();\n        }\n\n        _removeStakingIndexFromAddressMapping(\n            oldWallet,\n            stakingStoreIndex,\n            stakingIndicesByPayoutWallet\n        );\n        stakingIndicesByPayoutWallet[newWallet].push(stakingStoreIndex);\n\n        emit PrincipalPayoutWalletUpdated(\n            currentStore.principalPayoutWallet,\n            newWallet,\n            stakingStoreIndex\n        );\n    }\n\n    /**\n     * @notice Allows the current unstaker to update the unstaker.\n     * @param newUnstaker New address allowed to unstake the principal.\n     * @param stakingStoreIndex Index of the staking store.\n     */\n    function updatePrincipalUnstaker(\n        address newUnstaker,\n        uint256 stakingStoreIndex\n    ) external {\n        if (newUnstaker == address(0)) revert ZeroAddress();\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n        if (currentStore.principalUnstaker != msg.sender) {\n            revert NotPrincipalUnstaker();\n        }\n\n        currentStore.principalUnstaker = newUnstaker;\n    }\n\n    /**\n     * @notice Requests unstaking, starting the waiting period.\n     * @dev Can only be called by the beneficiary.\n     * @param stakingStoreIndex Index of the staking store.\n     */\n    function requestUnstake(\n        uint256 stakingStoreIndex\n    ) external nonReentrant onlyBeneficiaryOrPayoutWallet(stakingStoreIndex) {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n        if (currentStore.unstakingRequestTime != 0) {\n            revert AlreadyRequestedUnstake();\n        }\n\n        currentStore.unstakingRequestTime = uint64(block.timestamp);\n        emit UnstakeRequested(msg.sender, stakingStoreIndex);\n    }\n\n    function _getCurrentPrincipalWalletShareBps(\n        uint256 stakeId\n    ) internal view returns (uint32) {\n        PendingShareUpdate memory pending = pendingShareUpdates[stakeId];\n\n        if (\n            pending.requestTime > 0 &&\n            block.timestamp >= pending.requestTime + SHARE_UPDATE_GRACE_PERIOD\n        ) {\n            return pending.newShareBps;\n        }\n\n        return stakingStores[stakeId].principalWalletShareBps;\n    }\n\n    function requestPrincipalWalletShareUpdate(\n        uint256 stakeId,\n        uint32 newShareBps\n    ) external {\n        if (msg.sender != stakingStores[stakeId].beneficiary) {\n            revert NotBeneficiary();\n        }\n\n        if (newShareBps > 10000) revert InvalidPrincipalWalletShare();\n\n        pendingShareUpdates[stakeId] = PendingShareUpdate({\n            newShareBps: newShareBps,\n            requestTime: uint64(block.timestamp)\n        });\n\n        emit PrincipalWalletShareUpdateRequested(\n            stakeId,\n            newShareBps,\n            block.timestamp\n        );\n    }\n}\n"
    }
}