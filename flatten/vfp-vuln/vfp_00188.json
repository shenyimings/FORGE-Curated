{
    "vfp_id": "vfp_00188",
    "project_name": "OIF Contracts Diff Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Multi-Output Orders Can Be Manipulated",
            "description": "The vulnerability arises in the handling of multi-output orders, where the first filler of an output is designated as the order owner, granting them significant control over the order's execution. This design choice creates two potential risks: a Denial of Service (DoS) attack, where the first filler intentionally delays or fails to complete subsequent outputs, thereby locking user funds until cancellation; and manipulation of Dutch auction orders, where the first filler can wait for the auction price to decrease before fulfilling later outputs, securing a more favorable rate. The root cause is the lack of a mechanism to bind all outputs to a consistent pricing or timing model, such as using the timestamp of the first fill for all subsequent outputs. An attacker could exploit this by strategically claiming the first output and delaying fulfillment of others, especially in time-sensitive or price-varying contexts. The impact includes potential financial loss for users due to unfavorable execution prices and reduced reliability of the order settlement system, undermining trust in multi-output orders.\n",
            "severity": "Medium",
            "location": [
                "OutputSettlerBase.sol::L195",
                "OutputSettlerSimple.sol::L105-L112"
            ],
            "files": [
                "oif-contracts/src/output/BaseOutputSettler.sol"
            ]
        }
    ],
    "affected_files": {
        "BaseOutputSettler.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\nimport { IOutputCallback } from \"../interfaces/IOutputCallback.sol\";\nimport { IPayloadCreator } from \"../interfaces/IPayloadCreator.sol\";\n\nimport { AssemblyLib } from \"../libs/AssemblyLib.sol\";\nimport { LibAddress } from \"../libs/LibAddress.sol\";\nimport { MandateOutput, MandateOutputEncodingLib } from \"../libs/MandateOutputEncodingLib.sol\";\nimport { OutputVerificationLib } from \"../libs/OutputVerificationLib.sol\";\n\nimport { BaseInputOracle } from \"../oracles/BaseInputOracle.sol\";\n\n/**\n * @notice Base Output Settler implementing logic for settling outputs.\n * Does not support native coins.\n * This base output settler implements logic to work as both a PayloadCreator (for oracles) and as an oracle itself.\n *\n * @dev **Fill Function Patterns:**\n * This contract provides two distinct fill patterns with different semantics:\n *\n * 1. **Single Fill (`fill`)** - Idempotent Operation:\n *    - Safe to call multiple times\n *    - Returns existing fill record if already filled\n *    - Suitable for retry mechanisms and concurrent filling attempts\n *    - Use when you want graceful handling of already-filled outputs\n *\n * 2. **Batch Fill (`fillOrderOutputs`)** - Atomic Competition Operation:\n *    - Implements solver competition semantics\n *    - Reverts if first output already filled by different solver\n *    - Ensures atomic all-or-nothing batch filling\n *    - Use when you need to atomically claim an entire multi-output order\n *\n * Choose the appropriate pattern based on your use case requirements.\n */\nabstract contract BaseOutputSettler is IPayloadCreator, BaseInputOracle {\n    using LibAddress for address;\n\n    error FillDeadline();\n    error AlreadyFilled();\n    error InvalidAttestation(bytes32 storedFillRecordHash, bytes32 givenFillRecordHash);\n    error ZeroValue();\n    error PayloadTooSmall();\n\n    /**\n     * @dev Validates that the fill deadline has not passed.\n     * @param fillDeadline The deadline timestamp to check against.\n     */\n    modifier checkFillDeadline(\n        uint32 fillDeadline\n    ) {\n        if (fillDeadline < block.timestamp) revert FillDeadline();\n        _;\n    }\n\n    /**\n     * @notice Sets outputs as filled by their solver identifier, such that outputs won't be filled twice.\n     */\n    mapping(bytes32 orderId => mapping(bytes32 outputHash => bytes32 payloadHash)) internal _fillRecords;\n\n    /**\n     * @notice Output has been filled.\n     */\n    event OutputFilled(\n        bytes32 indexed orderId, bytes32 solver, uint32 timestamp, MandateOutput output, uint256 finalAmount\n    );\n\n    function _getFillRecordHash(bytes32 solver, uint32 timestamp) internal pure returns (bytes32 fillRecordHash) {\n        fillRecordHash = keccak256(abi.encodePacked(solver, timestamp));\n    }\n\n    function getFillRecord(bytes32 orderId, bytes32 outputHash) public view returns (bytes32 payloadHash) {\n        payloadHash = _fillRecords[orderId][outputHash];\n    }\n\n    function getFillRecord(bytes32 orderId, MandateOutput calldata output) public view returns (bytes32 payloadHash) {\n        payloadHash = _fillRecords[orderId][MandateOutputEncodingLib.getMandateOutputHash(output)];\n    }\n\n    /**\n     * @dev Virtual function for extensions to implement output resolution logic.\n     * @param output The given output to resolve.\n     * @param proposedSolver The proposed solver to check exclusivity against.\n     * @return amount The computed amount for the output.\n     */\n    function _resolveOutput(\n        MandateOutput calldata output,\n        bytes32 proposedSolver\n    ) internal view virtual returns (uint256 amount) {\n        // Default implementation returns the output amount\n        return output.amount;\n    }\n\n    /**\n     * @notice Performs basic validation and fills output if unfilled.\n     * If an order has already been filled given the output & fillDeadline, then this function does not \"re\"fill the\n     * order but returns early.\n     * @dev This fill function links the fill to the outcome of the external call. If the external call cannot execute,\n     * the output is not fillable.\n     * Does not automatically submit the order (send the proof).\n     *                          !Do not make orders with repeated outputs!.\n     * The implementation strategy (verify then fill) means that an order with repeat outputs\n     * (say 1 Ether to Alice & 1 Ether to Alice) can be filled by sending 1 Ether to Alice ONCE.\n     * @param orderId Input chain order identifier. Is used as is, not checked for validity.\n     * @param output The given output to fill. Is expected to belong to a greater order identified by orderId\n     * @param proposedSolver Solver identifier to be sent to input chain.\n     * @return fillRecordHash Hash of the fill record. Returns existing hash if already filled, new hash if successfully\n     * filled.\n     */\n    function _fill(\n        bytes32 orderId,\n        MandateOutput calldata output,\n        bytes32 proposedSolver\n    ) internal returns (bytes32 fillRecordHash) {\n        if (proposedSolver == bytes32(0)) revert ZeroValue();\n        OutputVerificationLib._isThisChain(output.chainId);\n        OutputVerificationLib._isThisOutputSettler(output.settler);\n\n        bytes32 outputHash = MandateOutputEncodingLib.getMandateOutputHash(output);\n        bytes32 existingFillRecordHash = _fillRecords[orderId][outputHash];\n        // Return existing record hash if already solved.\n        if (existingFillRecordHash != bytes32(0)) return existingFillRecordHash;\n        // The above and below lines act as a local re-entry check.\n        uint32 fillTimestamp = uint32(block.timestamp);\n        fillRecordHash = _getFillRecordHash(proposedSolver, fillTimestamp);\n        _fillRecords[orderId][outputHash] = fillRecordHash;\n\n        // Storage has been set. Fill the output.\n        uint256 outputAmount = _resolveOutput(output, proposedSolver);\n        address recipient = address(uint160(uint256(output.recipient)));\n        SafeTransferLib.safeTransferFrom(address(uint160(uint256(output.token))), msg.sender, recipient, outputAmount);\n        if (output.call.length > 0) IOutputCallback(recipient).outputFilled(output.token, outputAmount, output.call);\n\n        emit OutputFilled(orderId, proposedSolver, fillTimestamp, output, outputAmount);\n        return fillRecordHash;\n    }\n\n    // --- External Solver Interface --- //\n\n    /**\n     * @notice External fill interface for filling a single output (idempotent operation).\n     * @dev This function is idempotent - it can be called multiple times safely. If the output is already filled,\n     * it returns the existing fill record hash without reverting. This makes it suitable for retry mechanisms\n     * and scenarios where multiple parties might attempt to fill the same output.\n     *\n     * @param fillDeadline If the transaction is executed after this timestamp, the call will fail.\n     * @param orderId Input chain order identifier. Is used as is, not checked for validity.\n     * @param output Given output to fill. Is expected to belong to a greater order identified by orderId.\n     * @param proposedSolver Solver identifier to be sent to input chain.\n     * @return bytes32 Fill record hash. Returns existing hash if already filled, new hash if successfully filled.\n     */\n    function fill(\n        uint32 fillDeadline,\n        bytes32 orderId,\n        MandateOutput calldata output,\n        bytes32 proposedSolver\n    ) external virtual checkFillDeadline(fillDeadline) returns (bytes32) {\n        return _fill(orderId, output, proposedSolver);\n    }\n\n    // -- Batch Solving -- //\n\n    /**\n     * @notice Atomic batch fill interface for filling multiple outputs (non-idempotent operation).\n     * @dev This function implements atomic batch filling with solver competition semantics. Unlike the single\n     * `fill()` function, this is NOT idempotent - it will revert if the first output has already been filled\n     * by another solver. This ensures that only one solver can \"win\" the entire order.\n     *\n     * **Behavioral differences from single fill():**\n     * - REVERTS with `AlreadyFilled()` if the first output is already filled (solver competition)\n     * - Subsequent outputs can be already filled (they are skipped)\n     * - All fills in the batch succeed or the entire transaction reverts (atomicity)\n     *\n     * **Solver Selection Logic:**\n     * The first output determines which solver \"wins\" the entire order. This prevents solver conflicts\n     * and ensures consistent solver attribution across all outputs in a multi-output order.\n     *\n     * @param fillDeadline If the transaction is executed after this timestamp, the call will fail.\n     * @param orderId Input chain order identifier. Is used as is, not checked for validity.\n     * @param outputs Given outputs to fill. Ensure that the **first** order output is the first output for this call.\n     * @param proposedSolver Solver to be sent to origin chain. If the first output has a different solver, reverts.\n     */\n    function fillOrderOutputs(\n        uint32 fillDeadline,\n        bytes32 orderId,\n        MandateOutput[] calldata outputs,\n        bytes32 proposedSolver\n    ) external checkFillDeadline(fillDeadline) {\n        // Atomic check: first output must not be already filled (solver competition)\n        bytes32 fillRecordHash = _fill(orderId, outputs[0], proposedSolver);\n        bytes32 expectedFillRecordHash = _getFillRecordHash(proposedSolver, uint32(block.timestamp));\n        if (fillRecordHash != expectedFillRecordHash) revert AlreadyFilled();\n\n        // Fill remaining outputs (can skip if already filled)\n        uint256 numOutputs = outputs.length;\n        for (uint256 i = 1; i < numOutputs; ++i) {\n            _fill(orderId, outputs[i], proposedSolver);\n        }\n    }\n\n    // --- External Calls --- //\n\n    /**\n     * @notice Allows estimating the gas used for an external call.\n     * @dev To call, set msg.sender to address(0). This call can never be executed on-chain. It should also be noted\n     * that application can cheat and implement special logic for tx.origin == 0.\n     * @param trueAmount Amount computed for the order.\n     * @param output Order output to simulate the call for.\n     */\n    function call(uint256 trueAmount, MandateOutput calldata output) external {\n        // Disallow calling on-chain.\n        require(msg.sender == address(0));\n\n        IOutputCallback(address(uint160(uint256(output.recipient)))).outputFilled(output.token, trueAmount, output.call);\n    }\n\n    // --- IPayloadCreator --- //\n\n    /**\n     * @notice Helper function to check whether a payload is valid.\n     * @dev Works by checking if the entirety of the payload has been recorded as valid. Every byte of the payload is\n     * checked to ensure the payload has been filled.\n     * @param payload keccak256 hash of the relevant payload.\n     * @return bool Whether or not the payload has been recorded as filled.\n     */\n    function _isPayloadValid(\n        bytes calldata payload\n    ) internal view virtual returns (bool) {\n        // Check if the payload is large enough for it to be a fill description.\n        if (payload.length < 168) revert PayloadTooSmall();\n        bytes32 outputHash = MandateOutputEncodingLib.getMandateOutputHashFromCommonPayload(\n            bytes32(uint256(uint160(msg.sender))), // Oracle\n            bytes32(uint256(uint160(address(this)))), // Settler\n            block.chainid,\n            payload[68:]\n        );\n        bytes32 payloadOrderId = MandateOutputEncodingLib.loadOrderIdFromFillDescription(payload);\n        bytes32 fillRecord = _fillRecords[payloadOrderId][outputHash];\n\n        // Get the expected record based on the fillDescription (payload).\n        bytes32 payloadSolver = MandateOutputEncodingLib.loadSolverFromFillDescription(payload);\n        uint32 payloadTimestamp = MandateOutputEncodingLib.loadTimestampFromFillDescription(payload);\n        bytes32 expectedFillRecord = _getFillRecordHash(payloadSolver, payloadTimestamp);\n\n        return fillRecord == expectedFillRecord;\n    }\n\n    /**\n     * @notice Returns whether a set of payloads have been approved by this contract.\n     */\n    function arePayloadsValid(\n        bytes[] calldata payloads\n    ) external view returns (bool accumulator) {\n        uint256 numPayloads = payloads.length;\n        accumulator = true;\n        for (uint256 i; i < numPayloads; ++i) {\n            accumulator = AssemblyLib.and(accumulator, _isPayloadValid(payloads[i]));\n        }\n    }\n\n    // --- Oracle Interfaces --- //\n\n    function setAttestation(\n        bytes32 orderId,\n        bytes32 solver,\n        uint32 timestamp,\n        MandateOutput calldata output\n    ) external {\n        bytes32 outputHash = MandateOutputEncodingLib.getMandateOutputHash(output);\n        bytes32 existingFillRecordHash = _fillRecords[orderId][outputHash];\n        bytes32 givenFillRecordHash = _getFillRecordHash(solver, timestamp);\n        if (existingFillRecordHash != givenFillRecordHash) {\n            revert InvalidAttestation(existingFillRecordHash, givenFillRecordHash);\n        }\n\n        bytes32 dataHash = keccak256(MandateOutputEncodingLib.encodeFillDescription(solver, orderId, timestamp, output));\n\n        // Check that we set the mapping correctly.\n        bytes32 application = output.settler;\n        OutputVerificationLib._isThisOutputSettler(application);\n        bytes32 oracle = output.oracle;\n        OutputVerificationLib._isThisOutputOracle(oracle);\n        uint256 chainId = output.chainId;\n        OutputVerificationLib._isThisChain(chainId);\n        _attestations[chainId][application][oracle][dataHash] = true;\n    }\n}\n"
    }
}