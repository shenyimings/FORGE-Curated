{
    "vfp_id": "vfp_00041",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "PendlePTOracle._getPTRate returns incorrect decimals for some markets",
            "description": "The vulnerability is in the PendlePTOracle._getPTRate function, which assumes that all ptRate values are returned in 1e18 decimals, but this is not true for all markets when using getPtToSyRate. The root cause is the lack of decimal normalization between different Pendle oracle functions: getPtToAssetRate returns 1e18 decimals, but getPtToSyRate can return higher decimals for certain markets. This leads to incorrect price calculations when useSyOracleRate is true and the market has non-standard decimals. The impact is that the oracle returns inaccurate prices for PT tokens, which can lead to incorrect valuation of collateral or debt, potentially causing undercollateralized positions, incorrect liquidation decisions, or unfair trading outcomes. This undermines the reliability of the entire pricing mechanism for affected markets.\n",
            "severity": "Medium",
            "location": [
                "PendlePTOracle.sol#L60-L66",
                "IPendle.sol#L411"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/oracles/PendlePTOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "PendlePTOracle.sol": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity >=0.8.29;\n\nimport {IPMarket, IPOracle, PENDLE_ORACLE} from \"../interfaces/IPendle.sol\";\nimport {AggregatorV2V3Interface} from \"../interfaces/AggregatorV2V3Interface.sol\";\nimport {AbstractCustomOracle} from \"./AbstractCustomOracle.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TypeConvert} from \"../utils/TypeConvert.sol\";\n\ncontract PendlePTOracle is AbstractCustomOracle {\n    using TypeConvert for uint256;\n\n    address public immutable pendleMarket;\n    uint32 public immutable twapDuration;\n    bool public immutable useSyOracleRate;\n\n    AggregatorV2V3Interface public immutable baseToUSDOracle;\n    int256 public immutable baseToUSDDecimals;\n    int256 public immutable ptDecimals;\n    bool public immutable invertBase;\n\n    constructor (\n        address pendleMarket_,\n        AggregatorV2V3Interface baseToUSDOracle_,\n        bool invertBase_,\n        bool useSyOracleRate_,\n        uint32 twapDuration_,\n        string memory description_,\n        address sequencerUptimeOracle_\n    ) AbstractCustomOracle(\n        description_,\n        sequencerUptimeOracle_\n    ) {\n        pendleMarket = pendleMarket_;\n        twapDuration = twapDuration_;\n        useSyOracleRate = useSyOracleRate_;\n\n        baseToUSDOracle = baseToUSDOracle_;\n        invertBase = invertBase_;\n\n        uint8 _baseDecimals = baseToUSDOracle_.decimals();\n        (/* */, address pt, /* */) = IPMarket(pendleMarket_).readTokens();\n        uint8 _ptDecimals = ERC20(pt).decimals();\n\n        require(_baseDecimals <= 18);\n        require(_ptDecimals <= 18);\n\n        baseToUSDDecimals = int256(10**_baseDecimals);\n        ptDecimals = int256(10**_ptDecimals);\n\n        (\n            bool increaseCardinalityRequired,\n            /* */,\n            bool oldestObservationSatisfied\n        ) = PENDLE_ORACLE.getOracleState(pendleMarket, twapDuration);\n        // If this fails then we need to increase the cardinality in the Pendle system\n        require(!increaseCardinalityRequired && oldestObservationSatisfied, \"Oracle Init\");\n    }\n\n    /// @dev ptRate is always returned in 1e18 decimals\n    function _getPTRate() internal view returns (int256) {\n        uint256 ptRate = useSyOracleRate ?\n            PENDLE_ORACLE.getPtToSyRate(pendleMarket, twapDuration) :\n            PENDLE_ORACLE.getPtToAssetRate(pendleMarket, twapDuration);\n        return ptRate.toInt();\n    }\n\n    function _calculateBaseToQuote() internal view override returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        int256 baseToUSD;\n        (\n            roundId,\n            baseToUSD,\n            startedAt,\n            updatedAt,\n            answeredInRound\n        ) = baseToUSDOracle.latestRoundData();\n        require(baseToUSD > 0, \"Chainlink Rate Error\");\n        // Overflow and div by zero not possible\n        if (invertBase) baseToUSD = (baseToUSDDecimals * baseToUSDDecimals) / baseToUSD;\n\n        int256 ptRate = _getPTRate();\n        answer = (ptRate * baseToUSD) / baseToUSDDecimals;\n    }\n}"
    }
}