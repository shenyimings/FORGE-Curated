{
    "vfp_id": "vfp_00129",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Inconsistent Inheritance Patterns and Defective Initialization Logic",
            "description": "The protocol's upgradeability architecture suffers from inconsistent inheritance patterns and defective initialization logic, particularly in `AnchorForkRouter` and `Anchor` contracts. The design uses complex and brittle inheritance chains to maintain storage compatibility, with some contracts using `EssentialContract` while others directly inherit `UUPSUpgradeable` and `Ownable2StepUpgradeable`, leading to confusion and audit difficulty.\n\nA critical flaw is the lack of a functional mechanism to initialize the `owner` address in the proxy's storage, rendering access control ineffective. The `_transferOwnership` call in the `Anchor` constructor only affects the implementation contract, not the proxy. Additionally, constructors do not consistently call `_disableInitializers()`, leaving implementation contracts vulnerable to reinitialization.\n\nThis creates risks of ownership loss, broken upgradeability, and potential reinitialization attacks. The impact includes compromised access control, inability to upgrade contracts securely, and increased attack surface due to unclear initialization responsibilities. The structural complexity also reduces code maintainability and increases the likelihood of future bugs.\n",
            "severity": "Medium",
            "location": [
                "AnchorForkRouter.sol::#56",
                "Anchor.sol::#26",
                "Anchor.sol::_transferOwnership#206",
                "EssentialContract.sol::#10",
                "ForkRouter.sol::#22"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/AnchorForkRouter.sol",
                "taiko-mono/packages/protocol/contracts/layer2/core/Anchor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-228"
                ],
                "3": [
                    "CWE-237"
                ]
            },
            "title": "Denial of Service via Unsafe ABI Decoding in Anchor Contract",
            "description": "The Anchor contract's anchorV4 function processes a ProverAuth struct passed as ABI-encoded calldata, which is decoded using abi.decode in validateProverAuth without prior validation of the encoding's correctness. Malformed input that meets length requirements but fails decoding will cause the abi.decode call to revert, making the entire transaction invalid. Since anchorV4 is required for L2 block validity, this causes the execution engine to reject the block, leading the off-chain driver to enter an infinite retry loop. This results in a permanent halt of the L2 chain, preventing further state progression and blocking the finalization of dependent proposals. The system loses liveness due to an unhandled low-level revert in a critical path.\n",
            "severity": "Critical",
            "location": [
                "Anchor.sol::anchorV4#221",
                "Anchor.sol::validateProverAuth#346",
                "LibManifest.sol#50"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/Anchor.sol"
            ]
        }
    ],
    "affected_files": {
        "Anchor.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IBondManager } from \"./IBondManager.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { EssentialContract } from \"src/shared/common/EssentialContract.sol\";\nimport { LibAddress } from \"src/shared/libs/LibAddress.sol\";\nimport { LibBonds } from \"src/shared/libs/LibBonds.sol\";\nimport { ICheckpointStore } from \"src/shared/signal/ICheckpointStore.sol\";\n\nimport \"./Anchor_Layout.sol\"; // DO NOT DELETE\n\n/// @title Anchor\n/// @notice Implements the Shasta fork's anchoring mechanism with advanced bond management,\n/// prover designation and checkpoint management.\n/// @dev IMPORTANT: This contract will be deployed behind the `AnchorRouter` contract, and that's why\n/// it's not upgradable itself.\n/// @dev This contract implements:\n///      - Bond-based economic security for proposals and proofs\n///      - Prover designation with signature authentication\n///      - Cumulative bond instruction processing with integrity verification\n///      - State tracking for multi-block proposals\n/// @custom:security-contact security@taiko.xyz\ncontract Anchor is EssentialContract {\n    using LibAddress for address;\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------\n    // Structs\n    // ---------------------------------------------------------------\n\n    /// @notice Authentication data for prover designation.\n    /// @dev Used to allow a proposer to designate another address as the prover.\n    struct ProverAuth {\n        uint48 proposalId; // The proposal ID this auth is for\n        address proposer; // The original proposer address\n        uint256 provingFee; // Fee (Wei) that prover will receive\n        bytes signature; // ECDSA signature from the designated prover\n    }\n\n    /// @notice Proposal-level data that applies to the entire batch of blocks.\n    struct ProposalParams {\n        uint48 proposalId; // Unique identifier of the proposal\n        address proposer; // Address of the entity that proposed this batch\n        bytes proverAuth; // Encoded ProverAuth for prover designation\n        bytes32 bondInstructionsHash; // Expected hash of bond instructions\n        LibBonds.BondInstruction[] bondInstructions; // Bond credit instructions to process\n    }\n\n    /// @notice Block-level data specific to a single block within a proposal.\n    struct BlockParams {\n        uint48 anchorBlockNumber; // L1 block number to anchor (0 to skip)\n        bytes32 anchorBlockHash; // L1 block hash at anchorBlockNumber\n        bytes32 anchorStateRoot; // L1 state root at anchorBlockNumber\n    }\n\n    /// @notice Stored proposal-level state for the ongoing batch.\n    struct ProposalState {\n        bytes32 bondInstructionsHash;\n        address designatedProver;\n        bool isLowBondProposal;\n        uint48 proposalId;\n    }\n\n    /// @notice Stored block-level state for the latest anchor.\n    /// @dev 2 slots\n    struct BlockState {\n        uint48 anchorBlockNumber;\n        bytes32 ancestorsHash;\n    }\n\n    // ---------------------------------------------------------------\n    // Constants\n    // ---------------------------------------------------------------\n\n    /// @notice Golden touch address is the only address that can do the anchor transaction.\n    address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;\n\n    /// @notice Gas limit for anchor transactions (must be enforced).\n    uint64 public constant ANCHOR_GAS_LIMIT = 1_000_000;\n\n    /// @dev Minimum calldata length for decoding a `ProverAuth` payload safely.\n    /// This equals the ABI-encoded size of:\n    ///   - uint48 proposalId: 32 bytes (padded)\n    ///   - address proposer: 32 bytes (padded)\n    ///   - uint256 provingFee: 32 bytes (padded)\n    ///   - bytes offset: 32 bytes\n    ///   - bytes length: 32 bytes\n    ///   - minimum signature data: 65 bytes (r, s, v for ECDSA)\n    /// Total: 32 + 32 + 32 + 32 + 32 + 65 = 225 bytes\n    uint256 private constant MIN_PROVER_AUTH_LENGTH = 225;\n\n    /// @dev Length of a standard ECDSA signature (r: 32 bytes, s: 32 bytes, v: 1 byte).\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\n\n    /// @dev EIP-712 domain/type hashes for prover authorization signatures.\n    bytes32 private constant PROVER_AUTH_DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n    bytes32 private constant PROVER_AUTH_TYPEHASH =\n        keccak256(\"ProverAuth(uint48 proposalId,address proposer,uint256 provingFee)\");\n    bytes32 private constant PROVER_AUTH_DOMAIN_NAME_HASH = keccak256(\"TaikoAnchorProverAuth\");\n    bytes32 private constant PROVER_AUTH_DOMAIN_VERSION_HASH = keccak256(\"1\");\n\n    // ---------------------------------------------------------------\n    // Immutables\n    // ---------------------------------------------------------------\n\n    /// @notice Contract managing bond deposits, withdrawals, and transfers.\n    IBondManager public immutable bondManager;\n\n    /// @notice Checkpoint store for storing L1 block data.\n    ICheckpointStore public immutable checkpointStore;\n\n    /// @notice Bond amount in Wei for liveness guarantees.\n    uint256 public immutable livenessBond;\n\n    /// @notice Bond amount in Wei for provability guarantees.\n    uint256 public immutable provabilityBond;\n\n    /// @notice The L1's chain ID.\n    uint64 public immutable l1ChainId;\n\n    // ---------------------------------------------------------------\n    // State variables\n    // ---------------------------------------------------------------\n\n    /// @notice Mapping from block number to block hash.\n    mapping(uint256 blockNumber => bytes32 blockHash) public blockHashes;\n\n    /// @dev Slots used by the Pacaya anchor contract itself.\n    /// slot1: publicInputHash\n    /// slot2: parentGasExcess, lastSyncedBlock, parentTimestamp, parentGasTarget\n    /// slot3: l1ChainId\n    uint256[3] private _pacayaSlots;\n\n    /// @notice Latest proposal-level state, updated only on the first block of a proposal.\n    ProposalState internal _proposalState;\n\n    /// @notice Latest block-level state, updated on every processed block.\n    BlockState internal _blockState;\n\n    /// @notice Storage gap for upgrade safety.\n    uint256[41] private __gap;\n\n    // ---------------------------------------------------------------\n    // Events\n    // ---------------------------------------------------------------\n\n    event Anchored(\n        bytes32 bondInstructionsHash,\n        address designatedProver,\n        bool isLowBondProposal,\n        uint48 prevAnchorBlockNumber,\n        uint48 anchorBlockNumber,\n        bytes32 ancestorsHash\n    );\n\n    event Withdrawn(address token, address to, uint256 amount);\n\n    // ---------------------------------------------------------------\n    // Modifiers\n    // ---------------------------------------------------------------\n\n    modifier onlyValidSender() {\n        require(msg.sender == GOLDEN_TOUCH_ADDRESS, InvalidSender());\n        _;\n    }\n\n    // ---------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------\n\n    /// @notice Initializes the Anchor contract.\n    /// @param _checkpointStore The address of the checkpoint store.\n    /// @param _bondManager The address of the bond manager.\n    /// @param _livenessBond The liveness bond amount in Wei.\n    /// @param _provabilityBond The provability bond amount in Wei.\n    /// @param _l1ChainId The L1 chain ID.\n    constructor(\n        ICheckpointStore _checkpointStore,\n        IBondManager _bondManager,\n        uint256 _livenessBond,\n        uint256 _provabilityBond,\n        uint64 _l1ChainId,\n        address _owner\n    ) {\n        // Validate addresses\n        require(address(_checkpointStore) != address(0), InvalidAddress());\n        require(address(_bondManager) != address(0), InvalidAddress());\n        require(_owner != address(0), InvalidAddress());\n\n        // Validate chain IDs\n        require(_l1ChainId != 0 && _l1ChainId != block.chainid, InvalidL1ChainId());\n        require(block.chainid > 1 && block.chainid <= type(uint64).max, InvalidL2ChainId());\n\n        // Assign immutables\n        checkpointStore = _checkpointStore;\n        bondManager = _bondManager;\n        livenessBond = _livenessBond;\n        provabilityBond = _provabilityBond;\n        l1ChainId = _l1ChainId;\n\n        _transferOwnership(_owner);\n    }\n\n    // ---------------------------------------------------------------\n    // External Functions\n    // ---------------------------------------------------------------\n\n    /// @notice Processes a block within a proposal, handling bond instructions and L1 data\n    /// anchoring.\n    /// @dev Core function that processes blocks sequentially within a proposal:\n    ///      1. Designates prover when a new proposal starts (i.e. the first block of a proposal)\n    ///      2. Processes bond transfers with cumulative hash verification\n    ///      3. Anchors L1 block data for cross-chain verification\n    /// @param _proposalParams Proposal-level parameters that define the overall batch.\n    /// @param _blockParams Block-level parameters specific to this block in the proposal.\n    function anchorV4(\n        ProposalParams calldata _proposalParams,\n        BlockParams calldata _blockParams\n    )\n        external\n        onlyValidSender\n        nonReentrant\n    {\n        uint48 lastProposalId = _proposalState.proposalId;\n\n        if (_proposalParams.proposalId < lastProposalId) {\n            // Proposal ID cannot go backward\n            revert ProposalIdMismatch();\n        }\n\n        // We do not need to account for proposalId = 0, since that's genesis\n        if (_proposalParams.proposalId > lastProposalId) {\n            _validateProposal(_proposalParams);\n        }\n        uint48 prevAnchorBlockNumber = _blockState.anchorBlockNumber;\n        _validateBlock(_blockParams);\n\n        uint256 parentNumber = block.number - 1;\n        blockHashes[parentNumber] = blockhash(parentNumber);\n\n        emit Anchored(\n            _proposalState.bondInstructionsHash,\n            _proposalState.designatedProver,\n            _proposalState.isLowBondProposal,\n            prevAnchorBlockNumber,\n            _blockState.anchorBlockNumber,\n            _blockState.ancestorsHash\n        );\n    }\n\n    /// @notice Withdraw token or Ether from this address.\n    /// Note: This contract receives a portion of L2 base fees, while the remainder is directed to\n    /// L2 block's coinbase address.\n    /// @param _token Token address or address(0) if Ether.\n    /// @param _to Withdraw to address.\n    function withdraw(address _token, address _to) external onlyOwner nonReentrant {\n        require(_to != address(0), InvalidAddress());\n        uint256 amount;\n        if (_token == address(0)) {\n            amount = address(this).balance;\n            _to.sendEtherAndVerify(amount);\n        } else {\n            amount = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransfer(_to, amount);\n        }\n        emit Withdrawn(_token, _to, amount);\n    }\n\n    // ---------------------------------------------------------------\n    // Public View Functions\n    // ---------------------------------------------------------------\n\n    /// @notice Returns the designated prover for a proposal.\n    /// @param _proposalId The proposal ID.\n    /// @param _proposer The proposer address.\n    /// @param _proverAuth Encoded prover authentication data.\n    /// @param _currentDesignatedProver The current designated prover from state.\n    /// @return isLowBondProposal_ True if proposer has insufficient bonds.\n    /// @return designatedProver_ The designated prover address.\n    /// @return provingFeeToTransfer_ The proving fee (Wei) to transfer from the proposer to the\n    /// designated prover.\n    function getDesignatedProver(\n        uint48 _proposalId,\n        address _proposer,\n        bytes calldata _proverAuth,\n        address _currentDesignatedProver\n    )\n        public\n        view\n        returns (bool isLowBondProposal_, address designatedProver_, uint256 provingFeeToTransfer_)\n    {\n        (address candidate, uint256 provingFee) =\n            validateProverAuth(_proposalId, _proposer, _proverAuth);\n\n        bool proposerHasBond = bondManager.hasSufficientBond(_proposer, provingFee);\n\n        if (!proposerHasBond) {\n            return (true, _currentDesignatedProver, 0);\n        }\n\n        if (candidate == _proposer) {\n            return (false, _proposer, 0);\n        }\n\n        if (!bondManager.hasSufficientBond(candidate, 0)) {\n            return (false, _proposer, 0);\n        }\n\n        return (false, candidate, provingFee);\n    }\n\n    /// @notice Returns the current proposal-level state snapshot.\n    function getProposalState() external view returns (ProposalState memory) {\n        return _proposalState;\n    }\n\n    /// @notice Returns the current block-level state snapshot.\n    function getBlockState() external view returns (BlockState memory) {\n        return _blockState;\n    }\n\n    /// @dev Validates prover authentication and extracts signer.\n    /// @param _proposalId The proposal ID to validate against.\n    /// @param _proposer The proposer address to validate against.\n    /// @param _proverAuth Encoded prover authentication data.\n    /// @return signer_ The recovered signer address (proposer if validation fails).\n    /// @return provingFee_ The proving fee in Wei (0 if validation fails).\n    function validateProverAuth(\n        uint48 _proposalId,\n        address _proposer,\n        bytes calldata _proverAuth\n    )\n        public\n        view\n        returns (address signer_, uint256 provingFee_)\n    {\n        if (_proverAuth.length < MIN_PROVER_AUTH_LENGTH) {\n            return (_proposer, 0);\n        }\n\n        ProverAuth memory proverAuth = abi.decode(_proverAuth, (ProverAuth));\n\n        if (!_isMatchingProverAuthContext(proverAuth, _proposalId, _proposer)) {\n            return (_proposer, 0);\n        }\n\n        // Verify signature has correct length for ECDSA (r: 32 bytes, s: 32 bytes, v: 1 byte)\n        if (proverAuth.signature.length != ECDSA_SIGNATURE_LENGTH) {\n            return (_proposer, 0);\n        }\n\n        (address recovered, ECDSA.RecoverError error) =\n            ECDSA.tryRecover(_hashProverAuthMessage(proverAuth), proverAuth.signature);\n\n        if (error != ECDSA.RecoverError.NoError || recovered == address(0)) {\n            return (_proposer, 0);\n        }\n\n        signer_ = recovered;\n        if (signer_ != _proposer) {\n            provingFee_ = proverAuth.provingFee;\n        }\n    }\n\n    // ---------------------------------------------------------------\n    // Private Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Validates and processes proposal-level data on the first block.\n    /// @param _proposalParams Proposal-level parameters containing all proposal data.\n    function _validateProposal(ProposalParams calldata _proposalParams) private {\n        uint256 proverFee;\n        (_proposalState.isLowBondProposal, _proposalState.designatedProver, proverFee) =\n            getDesignatedProver(\n                _proposalParams.proposalId,\n                _proposalParams.proposer,\n                _proposalParams.proverAuth,\n                _proposalState.designatedProver\n            );\n\n        if (proverFee > 0) {\n            bondManager.debitBond(_proposalParams.proposer, proverFee);\n            bondManager.creditBond(_proposalState.designatedProver, proverFee);\n        }\n\n        _proposalState.bondInstructionsHash = _processBondInstructions(\n            _proposalState.bondInstructionsHash,\n            _proposalParams.bondInstructions,\n            _proposalParams.bondInstructionsHash\n        );\n\n        _proposalState.proposalId = _proposalParams.proposalId;\n    }\n\n    /// @dev Validates and processes block-level data.\n    /// @param _blockParams Block-level parameters containing anchor data.\n    function _validateBlock(BlockParams calldata _blockParams) private {\n        // Verify and update ancestors hash\n        (bytes32 oldAncestorsHash, bytes32 newAncestorsHash) = _calcAncestorsHash();\n        if (_blockState.ancestorsHash != bytes32(0)) {\n            require(_blockState.ancestorsHash == oldAncestorsHash, AncestorsHashMismatch());\n        }\n        _blockState.ancestorsHash = newAncestorsHash;\n\n        // Anchor checkpoint data if a fresher L1 block is provided\n        if (_blockParams.anchorBlockNumber > _blockState.anchorBlockNumber) {\n            checkpointStore.saveCheckpoint(\n                ICheckpointStore.Checkpoint({\n                    blockNumber: _blockParams.anchorBlockNumber,\n                    blockHash: _blockParams.anchorBlockHash,\n                    stateRoot: _blockParams.anchorStateRoot\n                })\n            );\n            _blockState.anchorBlockNumber = _blockParams.anchorBlockNumber;\n        }\n    }\n\n    /// @dev Processes bond instructions with cumulative hash verification.\n    /// @param _currentHash Current cumulative hash from storage.\n    /// @param _bondInstructions Bond instructions to process.\n    /// @param _expectedHash Expected cumulative hash after processing.\n    /// @return newHash_ The new cumulative hash.\n    function _processBondInstructions(\n        bytes32 _currentHash,\n        LibBonds.BondInstruction[] calldata _bondInstructions,\n        bytes32 _expectedHash\n    )\n        private\n        returns (bytes32 newHash_)\n    {\n        newHash_ = _currentHash;\n\n        uint256 length = _bondInstructions.length;\n        for (uint256 i; i < length; ++i) {\n            LibBonds.BondInstruction calldata instruction = _bondInstructions[i];\n\n            uint256 bondAmount = _bondAmountFor(instruction.bondType);\n            if (bondAmount != 0) {\n                uint256 bondDebited = bondManager.debitBond(instruction.payer, bondAmount);\n                bondManager.creditBond(instruction.payee, bondDebited);\n            }\n\n            newHash_ = LibBonds.aggregateBondInstruction(newHash_, instruction);\n        }\n\n        require(newHash_ == _expectedHash, BondInstructionsHashMismatch());\n    }\n\n    /// @dev Maps a bond type to the configured bond amount in Wei.\n    function _bondAmountFor(LibBonds.BondType _bondType) private view returns (uint256) {\n        if (_bondType == LibBonds.BondType.LIVENESS) {\n            return livenessBond;\n        }\n        if (_bondType == LibBonds.BondType.PROVABILITY) {\n            return provabilityBond;\n        }\n        return 0;\n    }\n\n    /// @dev Calculates the aggregated ancestor block hash for the current block's parent.\n    /// @dev This function computes two public input hashes: one for the previous state and one for\n    /// the new state.\n    /// It uses a ring buffer to store the previous 255 block hashes and the current chain ID.\n    /// @return oldAncestorsHash_ The public input hash for the previous state.\n    /// @return newAncestorsHash_ The public input hash for the new state.\n    function _calcAncestorsHash()\n        private\n        view\n        returns (bytes32 oldAncestorsHash_, bytes32 newAncestorsHash_)\n    {\n        uint256 parentId = block.number - 1;\n\n        // 255 bytes32 ring buffer + 1 bytes32 for chainId\n        bytes32[256] memory inputs;\n        inputs[255] = bytes32(block.chainid);\n\n        // Unchecked is safe because it cannot overflow.\n        unchecked {\n            // Put the previous 255 blockhashes (excluding the parent's) into a\n            // ring buffer.\n            for (uint256 i; i < 255 && parentId >= i + 1; ++i) {\n                uint256 j = parentId - i - 1;\n                inputs[j % 255] = blockhash(j);\n            }\n        }\n\n        assembly {\n            oldAncestorsHash_ := keccak256(\n                inputs,\n                8192 /*mul(256, 32)*/\n            )\n        }\n\n        inputs[parentId % 255] = blockhash(parentId);\n        assembly {\n            newAncestorsHash_ := keccak256(\n                inputs,\n                8192 /*mul(256, 32)*/\n            )\n        }\n    }\n\n    /// @dev Checks whether a decoded `ProverAuth` payload targets the expected proposal context.\n    function _isMatchingProverAuthContext(\n        ProverAuth memory _auth,\n        uint48 _proposalId,\n        address _proposer\n    )\n        private\n        pure\n        returns (bool)\n    {\n        return _auth.proposalId == _proposalId && _auth.proposer == _proposer;\n    }\n\n    /// @dev Hashes a `ProverAuth` payload into the message that must be signed by the prover.\n    /// @dev Uses EIP-712 structured data hashing for better security and wallet compatibility.\n    function _hashProverAuthMessage(ProverAuth memory _auth) private view returns (bytes32) {\n        bytes32 structHash = _hashProverAuthStruct(_auth);\n        return ECDSA.toTypedDataHash(_proverAuthDomainSeparator(), structHash);\n    }\n\n    /// @dev Returns the EIP-712 struct hash for a `ProverAuth` payload.\n    function _hashProverAuthStruct(ProverAuth memory _auth) private pure returns (bytes32) {\n        return keccak256(\n            abi.encode(PROVER_AUTH_TYPEHASH, _auth.proposalId, _auth.proposer, _auth.provingFee)\n        );\n    }\n\n    /// @dev Builds the EIP-712 domain separator for prover authorization signatures.\n    /// @dev Uses standard EIP-712 fields: name, version, chainId, and verifyingContract.\n    function _proverAuthDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                PROVER_AUTH_DOMAIN_TYPEHASH,\n                PROVER_AUTH_DOMAIN_NAME_HASH,\n                PROVER_AUTH_DOMAIN_VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    // ---------------------------------------------------------------\n    // Errors\n    // ---------------------------------------------------------------\n\n    error AncestorsHashMismatch();\n    error BondInstructionsHashMismatch();\n    error InvalidAddress();\n    error InvalidAnchorBlockNumber();\n    error InvalidBlockIndex();\n    error InvalidL1ChainId();\n    error InvalidL2ChainId();\n    error InvalidSender();\n    error NonZeroAnchorBlockHash();\n    error NonZeroAnchorStateRoot();\n    error NonZeroBlockIndex();\n    error ProposalIdMismatch();\n    error ProposerMismatch();\n    error ZeroBlockCount();\n}\n",
        "AnchorForkRouter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { ForkRouter } from \"src/shared/fork-router/ForkRouter.sol\";\n\n/// @notice Interface exposing the legacy Pacaya anchor functionality used pre-fork.\ninterface IPacayaAnchorLegacy {\n    struct BaseFeeConfig {\n        uint8 adjustmentQuotient;\n        uint8 sharingPctg;\n        uint32 gasIssuancePerSecond;\n        uint64 minGasExcess;\n        uint32 maxGasIssuancePerBlock;\n    }\n\n    function anchorV3(\n        uint64 _anchorBlockId,\n        bytes32 _anchorStateRoot,\n        uint32 _parentGasUsed,\n        BaseFeeConfig calldata _baseFeeConfig,\n        bytes32[] calldata _signalSlots\n    )\n        external;\n\n    function getBasefeeV2(\n        uint32 _parentGasUsed,\n        uint64 _blockTimestamp,\n        BaseFeeConfig calldata _baseFeeConfig\n    )\n        external\n        view\n        returns (uint256, uint64, uint64);\n\n    function getBlockHash(uint256 _blockId) external view returns (bytes32);\n\n    function skipFeeCheck() external pure returns (bool);\n\n    function publicInputHash() external view returns (bytes32);\n\n    function parentGasExcess() external view returns (uint64);\n\n    function lastSyncedBlock() external view returns (uint64);\n\n    function parentTimestamp() external view returns (uint64);\n\n    function parentGasTarget() external view returns (uint64);\n\n    function signalService() external view returns (address);\n\n    function pacayaForkHeight() external view returns (uint64);\n}\n\n/// @title AnchorForkRouter\n/// @notice Routes calls between the Pacaya and Shasta anchor implementations.\n/// @custom:security-contact security@taiko.xyz\ncontract AnchorForkRouter is ForkRouter {\n    constructor(address _oldFork, address _newFork) ForkRouter(_oldFork, _newFork) { }\n\n    function shouldRouteToOldFork(bytes4 _selector) public pure override returns (bool) {\n        return _selector == IPacayaAnchorLegacy.anchorV3.selector\n            || _selector == IPacayaAnchorLegacy.getBasefeeV2.selector\n            || _selector == IPacayaAnchorLegacy.getBlockHash.selector\n            || _selector == IPacayaAnchorLegacy.skipFeeCheck.selector\n            || _selector == IPacayaAnchorLegacy.publicInputHash.selector\n            || _selector == IPacayaAnchorLegacy.parentGasExcess.selector\n            || _selector == IPacayaAnchorLegacy.lastSyncedBlock.selector\n            || _selector == IPacayaAnchorLegacy.parentTimestamp.selector\n            || _selector == IPacayaAnchorLegacy.parentGasTarget.selector\n            || _selector == IPacayaAnchorLegacy.signalService.selector\n            || _selector == IPacayaAnchorLegacy.pacayaForkHeight.selector;\n    }\n}\n"
    }
}