{
    "vfp_id": "vfp_00129",
    "project_name": "Morpheus - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Updating rewardPoolLastCalculatedTimestamp early allows a griefer to deny reward distribution",
            "description": "In the `distributeRewards` function of `Distributor.sol`, the `rewardPoolLastCalculatedTimestamp` is updated to the current block timestamp before validating whether the minimum reward distribution period (`minRewardsDistributePeriod`) has passed. This creates a race condition where an attacker can repeatedly call `distributeRewards` before the period elapses, thereby updating the timestamp and resetting the cooldown. As a result, legitimate reward distributions are blocked because the condition `block.timestamp <= lastCalculatedTimestamp_ + minRewardsDistributePeriod` remains true, causing the function to return early without distributing rewards. The root cause is improper ordering of state updates and validation checks. An attacker can exploit this by front-running or spamming calls to `distributeRewards`, leading to a denial-of-service on reward distribution. The impact is high as it disrupts the economic incentive model of the protocol, potentially affecting user trust and participation.\n",
            "severity": "High",
            "location": [
                "Distributor.sol#L322"
            ],
            "files": [
                "SmartContracts/contracts/capital-protocol/Distributor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Using the same token in multiple DepositPools causes incorrect yield accounting",
            "description": "The `distributeRewards` function in `Distributor.sol` calculates yield for each deposit pool based on the change in token balance (either `token` or `aToken`) held by the `Distributor`. However, if the same token (or aToken) is used in multiple `DepositPool` instances, their balances are not tracked separately, leading to incorrect aggregation of yield. Specifically, the `lastUnderlyingBalance` is updated per-pool, but the total balance query does not account for overlapping tokens, resulting in double-counting or undercounting of yield. This leads to inaccurate reward distribution across pools. The root cause is the lack of validation in `addDepositPool` to ensure token uniqueness. An attacker or misconfigured deployment could register multiple pools with the same token, distorting yield calculations. The impact is medium, as it affects the fairness and accuracy of reward distribution, potentially disadvantaging honest stakers.\n",
            "severity": "Medium",
            "location": [
                "Distributor.sol#L358",
                "Distributor.sol#L172-L225"
            ],
            "files": [
                "SmartContracts/contracts/capital-protocol/Distributor.sol"
            ]
        }
    ],
    "affected_files": {
        "Distributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IPool as AaveIPool} from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\nimport {IPoolDataProvider as AaveIPoolDataProvider} from \"@aave/core-v3/contracts/interfaces/IPoolDataProvider.sol\";\n\nimport {DecimalsConverter} from \"@solarity/solidity-lib/libs/decimals/DecimalsConverter.sol\";\n\nimport {IDistributor, IERC165} from \"../interfaces/capital-protocol/IDistributor.sol\";\nimport {IL1SenderV2} from \"../interfaces/capital-protocol/IL1SenderV2.sol\";\nimport {IChainLinkDataConsumer} from \"../interfaces/capital-protocol/IChainLinkDataConsumer.sol\";\nimport {IDepositPool} from \"../interfaces/capital-protocol/IDepositPool.sol\";\nimport {IRewardPool} from \"../interfaces/capital-protocol/IRewardPool.sol\";\n\ncontract Distributor is IDistributor, OwnableUpgradeable, UUPSUpgradeable {\n    using SafeERC20 for IERC20;\n    using DecimalsConverter for uint256;\n    using Math for uint256;\n\n    /** @dev `reward_pool_index` => `deposit_pool_address` => `DepositPool` */\n    mapping(uint256 => mapping(address => DepositPool)) public depositPools;\n\n    /** @dev `reward_pool_index` => `deposit_pool_address` => `rewards` */\n    mapping(uint256 => mapping(address => uint256)) public distributedRewards;\n\n    /** @dev `reward_pool_index` => `deposit_pool_addresses` */\n    mapping(uint256 => address[]) public depositPoolAddresses;\n\n    mapping(uint256 => uint128) public rewardPoolLastCalculatedTimestamp;\n    mapping(uint256 => bool) public isPrivateDepositPoolAdded;\n\n    /**\n     * @dev The variable contain `ChainLinkDataConsumer` contract address.\n     * Is used to obtain prices.\n     */\n    address public chainLinkDataConsumer;\n\n    /**\n     * @dev The variable contain `RewardPool` contract address.\n     * Is used to obtain reward amount.\n     */\n    address public rewardPool;\n\n    /**\n     * @dev The variable contain `` contract address.\n     * Used to send messages to the token's mint and yield transfer.\n     */\n    address public l1Sender;\n\n    /**\n     * @dev https://aave.com/docs/resources/addresses\n     * See `Pool` and `AaveProtocolDataProvider`\n     */\n    address public aavePool;\n    address public aavePoolDataProvider;\n\n    /**\n     * @dev This variable contain undistributed rewards, e.g. the situation\n     * when the yield from all deposit pools are zero.\n     */\n    uint256 public undistributedRewards;\n\n    uint256 public minRewardsDistributePeriod;\n\n    /**********************************************************************************************/\n    /*** Init, IERC165                                                                          ***/\n    /**********************************************************************************************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function Distributor_init(\n        address chainLinkDataConsumer_,\n        address aavePool_,\n        address aavePoolDataProvider_,\n        address rewardPool_,\n        address l1Sender_\n    ) external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        setChainLinkDataConsumer(chainLinkDataConsumer_);\n        setAavePool(aavePool_);\n        setAavePoolDataProvider(aavePoolDataProvider_);\n        setRewardPool(rewardPool_);\n        setL1Sender(l1Sender_);\n    }\n\n    function supportsInterface(bytes4 interfaceId_) external pure returns (bool) {\n        return interfaceId_ == type(IDistributor).interfaceId || interfaceId_ == type(IERC165).interfaceId;\n    }\n\n    /**********************************************************************************************/\n    /*** Global contract management functionality for the contract `owner()`                    ***/\n    /**********************************************************************************************/\n\n    function setChainLinkDataConsumer(address value_) public onlyOwner {\n        require(\n            IERC165(value_).supportsInterface(type(IChainLinkDataConsumer).interfaceId),\n            \"DR: invalid data consumer\"\n        );\n\n        chainLinkDataConsumer = value_;\n\n        emit ChainLinkDataConsumerSet(value_);\n    }\n\n    function setL1Sender(address value_) public onlyOwner {\n        require(IERC165(value_).supportsInterface(type(IL1SenderV2).interfaceId), \"DR: invalid L1Sender address\");\n\n        l1Sender = value_;\n\n        emit L1SenderSet(value_);\n    }\n\n    /**\n     * @dev https://aave.com/docs/resources/addresses. See `Pool`.\n     */\n    function setAavePool(address value_) public onlyOwner {\n        require(value_ != address(0), \"DR: invalid Aave pool address\");\n\n        aavePool = value_;\n\n        emit AavePoolSet(value_);\n    }\n\n    /**\n     * @dev https://aave.com/docs/resources/addresses. See `AaveProtocolDataProvider`.\n     */\n    function setAavePoolDataProvider(address value_) public onlyOwner {\n        require(value_ != address(0), \"DR: invalid Aave pool data provider address\");\n\n        aavePoolDataProvider = value_;\n\n        emit AavePoolDataProviderSet(value_);\n    }\n\n    function setRewardPool(address value_) public onlyOwner {\n        require(IERC165(value_).supportsInterface(type(IRewardPool).interfaceId), \"DR: invalid reward pool address\");\n\n        rewardPool = value_;\n\n        emit RewardPoolSet(value_);\n    }\n\n    function setMinRewardsDistributePeriod(uint256 value_) public onlyOwner {\n        minRewardsDistributePeriod = value_;\n\n        emit MinRewardsDistributePeriodSet(value_);\n    }\n\n    function setRewardPoolLastCalculatedTimestamp(uint256 rewardPoolIndex_, uint128 value_) public onlyOwner {\n        IRewardPool(rewardPool).onlyExistedRewardPool(rewardPoolIndex_);\n        require(value_ <= block.timestamp, \"DR: invalid last calculated timestamp\");\n\n        rewardPoolLastCalculatedTimestamp[rewardPoolIndex_] = value_;\n\n        emit RewardPoolLastCalculatedTimestampSet(rewardPoolIndex_, value_);\n    }\n\n    /**********************************************************************************************/\n    /*** `DepositPoolDetails` management functionality                                          ***/\n    /**********************************************************************************************/\n\n    function addDepositPool(\n        uint256 rewardPoolIndex_,\n        address depositPoolAddress_,\n        address token_,\n        string memory chainLinkPath_,\n        Strategy strategy_\n    ) external onlyOwner {\n        IRewardPool rewardPool_ = IRewardPool(rewardPool);\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n\n        require(\n            IERC165(depositPoolAddress_).supportsInterface(type(IDepositPool).interfaceId),\n            \"DR: the deposit pool address is invalid\"\n        );\n\n        // Validate that pool is public in other cases.\n        if (strategy_ == Strategy.NO_YIELD) {\n            // Validate that pool is private.\n            rewardPool_.onlyNotPublicRewardPool(rewardPoolIndex_);\n            // Validate that deposit pool is not added for this `rewardPoolIndex_`.\n            require(\n                depositPoolAddresses[rewardPoolIndex_].length == 0,\n                \"DR: the deposit pool for this index already added\"\n            );\n\n            // Skip `token_` and `chainLinkPath_` when `Strategy.NO_YIELD`.\n            token_ = address(0);\n            chainLinkPath_ = \"\";\n        } else {\n            rewardPool_.onlyPublicRewardPool(rewardPoolIndex_);\n        }\n\n        // Set `aToken_` when `Strategy.AAVE`. Add allowance for Aave to transfer `token_` from the current\n        // contract.\n        address aToken_ = address(0);\n        if (strategy_ == Strategy.AAVE) {\n            (aToken_, , ) = AaveIPoolDataProvider(aavePoolDataProvider).getReserveTokensAddresses(token_);\n\n            IERC20(token_).safeApprove(aavePool, type(uint256).max);\n            IERC20(aToken_).approve(aavePool, type(uint256).max);\n        }\n\n        DepositPool memory depositPool_ = DepositPool(token_, chainLinkPath_, 0, 0, 0, strategy_, aToken_, true);\n\n        depositPoolAddresses[rewardPoolIndex_].push(depositPoolAddress_);\n        depositPools[rewardPoolIndex_][depositPoolAddress_] = depositPool_;\n\n        // Update prices for all `depositPools` by `rewardPoolIndex_`\n        if (strategy_ != Strategy.NO_YIELD) {\n            updateDepositTokensPrices(rewardPoolIndex_);\n        }\n\n        emit DepositPoolAdded(rewardPoolIndex_, depositPool_);\n    }\n\n    function _onlyExistedDepositPool(uint256 rewardPoolIndex_, address depositPoolAddress_) private view {\n        require(depositPools[rewardPoolIndex_][depositPoolAddress_].isExist, \"DR: deposit pool doesn't exist\");\n    }\n\n    /**********************************************************************************************/\n    /*** Functionality to update prices for all deposit pools                                   ***/\n    /**********************************************************************************************/\n\n    function updateDepositTokensPrices(uint256 rewardPoolIndex_) public {\n        IRewardPool(rewardPool).onlyPublicRewardPool(rewardPoolIndex_);\n\n        uint256 length_ = depositPoolAddresses[rewardPoolIndex_].length;\n        IChainLinkDataConsumer chainLinkDataConsumer_ = IChainLinkDataConsumer(chainLinkDataConsumer);\n\n        address[] storage addressesForIndex = depositPoolAddresses[rewardPoolIndex_];\n        mapping(address => DepositPool) storage poolsForIndex = depositPools[rewardPoolIndex_];\n\n        for (uint256 i = 0; i < length_; i++) {\n            address depositPoolAddress_ = addressesForIndex[i];\n            DepositPool storage depositPool = poolsForIndex[depositPoolAddress_];\n\n            bytes32 chainLinkPathId_ = chainLinkDataConsumer_.getPathId(depositPool.chainLinkPath);\n            uint256 price_ = chainLinkDataConsumer_.getChainLinkDataFeedLatestAnswer(chainLinkPathId_);\n\n            require(price_ > 0, \"DR: price for pair is zero\");\n            depositPool.tokenPrice = price_;\n\n            emit TokenPriceSet(depositPool.chainLinkPath, price_);\n        }\n    }\n\n    /**********************************************************************************************/\n    /*** Yield logic functionality                                                              ***/\n    /**********************************************************************************************/\n\n    function supply(uint256 rewardPoolIndex_, uint256 amount_) external {\n        address depositPoolAddress_ = _msgSender();\n        _onlyExistedDepositPool(rewardPoolIndex_, depositPoolAddress_);\n\n        DepositPool storage depositPool = depositPools[rewardPoolIndex_][depositPoolAddress_];\n        require(depositPool.strategy != Strategy.NO_YIELD, \"DR: invalid strategy for the deposit pool\");\n\n        distributeRewards(rewardPoolIndex_);\n        _withdrawYield(rewardPoolIndex_, depositPoolAddress_);\n\n        IERC20(depositPool.token).safeTransferFrom(depositPoolAddress_, address(this), amount_);\n        if (depositPool.strategy == Strategy.AAVE) {\n            AaveIPool(aavePool).supply(depositPool.token, amount_, address(this), 0);\n        }\n\n        depositPool.deposited += amount_;\n        depositPool.lastUnderlyingBalance += amount_;\n    }\n\n    function withdraw(uint256 rewardPoolIndex_, uint256 amount_) external returns (uint256) {\n        address depositPoolAddress_ = _msgSender();\n        _onlyExistedDepositPool(rewardPoolIndex_, depositPoolAddress_);\n\n        DepositPool storage depositPool = depositPools[rewardPoolIndex_][depositPoolAddress_];\n        require(depositPool.strategy != Strategy.NO_YIELD, \"DR: invalid strategy for the deposit pool\");\n\n        distributeRewards(rewardPoolIndex_);\n\n        amount_ = amount_.min(depositPool.deposited);\n        require(amount_ > 0, \"DR: nothing to withdraw\");\n\n        depositPool.deposited -= amount_;\n        depositPool.lastUnderlyingBalance -= amount_;\n\n        _withdrawYield(rewardPoolIndex_, depositPoolAddress_);\n\n        if (depositPool.strategy == Strategy.AAVE) {\n            AaveIPool(aavePool).withdraw(depositPool.token, amount_, depositPoolAddress_);\n        } else {\n            IERC20(depositPool.token).safeTransfer(depositPoolAddress_, amount_);\n        }\n\n        return amount_;\n    }\n\n    function distributeRewards(uint256 rewardPoolIndex_) public {\n        //// Base validation\n        IRewardPool rewardPool_ = IRewardPool(rewardPool);\n        rewardPool_.onlyExistedRewardPool(rewardPoolIndex_);\n\n        uint128 lastCalculatedTimestamp_ = rewardPoolLastCalculatedTimestamp[rewardPoolIndex_];\n        require(lastCalculatedTimestamp_ != 0, \"DR: `rewardPoolLastCalculatedTimestamp` isn't set\");\n        //// End\n\n        //// Calculate the reward amount\n        uint256 rewards_ = IRewardPool(rewardPool).getPeriodRewards(\n            rewardPoolIndex_,\n            lastCalculatedTimestamp_,\n            uint128(block.timestamp)\n        );\n        rewardPoolLastCalculatedTimestamp[rewardPoolIndex_] = uint128(block.timestamp);\n        if (rewards_ == 0) return;\n        //// End\n\n        // Stop execution when the reward pool is private\n        if (!rewardPool_.isRewardPoolPublic(rewardPoolIndex_)) {\n            _onlyExistedDepositPool(rewardPoolIndex_, depositPoolAddresses[rewardPoolIndex_][0]);\n            distributedRewards[rewardPoolIndex_][depositPoolAddresses[rewardPoolIndex_][0]] += rewards_;\n\n            return;\n        }\n\n        // Validate that public reward pools await `minRewardsDistributePeriod`\n        if (block.timestamp <= lastCalculatedTimestamp_ + minRewardsDistributePeriod) return;\n\n        //// Update prices\n        updateDepositTokensPrices(rewardPoolIndex_);\n        //// End\n\n        //// Calculate `yield` from all deposit pools\n        uint256 length_ = depositPoolAddresses[rewardPoolIndex_].length;\n        uint256 totalYield_ = 0;\n        uint256[] memory yields_ = new uint256[](length_);\n\n        for (uint256 i = 0; i < length_; i++) {\n            DepositPool storage depositPool = depositPools[rewardPoolIndex_][depositPoolAddresses[rewardPoolIndex_][i]];\n\n            address yieldToken_;\n            if (depositPool.strategy == Strategy.AAVE) {\n                yieldToken_ = depositPool.aToken;\n            } else if (depositPool.strategy == Strategy.NONE) {\n                // The current condition coverage cannot be achieved in the current version.\n                // Added to avoid errors in the future.\n                yieldToken_ = depositPool.token;\n            }\n\n            uint256 balance_ = IERC20(yieldToken_).balanceOf(address(this));\n            uint256 decimals_ = IERC20Metadata(yieldToken_).decimals();\n            uint256 underlyingYield_ = (balance_ - depositPool.lastUnderlyingBalance).to18(decimals_);\n            uint256 yield_ = underlyingYield_ * depositPool.tokenPrice;\n\n            depositPool.lastUnderlyingBalance = balance_;\n\n            yields_[i] = yield_;\n            totalYield_ += yield_;\n        }\n\n        if (totalYield_ == 0) {\n            undistributedRewards += rewards_;\n            return;\n        }\n        //// End\n\n        //// Calculate `depositPools` shares and reward amount for each `depositPool`\n        for (uint256 i = 0; i < length_; i++) {\n            if (yields_[i] == 0) continue;\n\n            distributedRewards[rewardPoolIndex_][depositPoolAddresses[rewardPoolIndex_][i]] +=\n                (yields_[i] * rewards_) /\n                totalYield_;\n        }\n        //// End\n    }\n\n    /**********************************************************************************************/\n    /*** Yield and rewards transfer functionality                                               ***/\n    /**********************************************************************************************/\n\n    function withdrawYield(uint256 rewardPoolIndex_, address depositPoolAddress_) external {\n        _onlyExistedDepositPool(rewardPoolIndex_, depositPoolAddress_);\n\n        DepositPool storage depositPool = depositPools[rewardPoolIndex_][depositPoolAddress_];\n        require(depositPool.strategy != Strategy.NO_YIELD, \"DR: invalid strategy for the deposit pool\");\n\n        distributeRewards(rewardPoolIndex_);\n        _withdrawYield(rewardPoolIndex_, depositPoolAddress_);\n    }\n\n    function withdrawUndistributedRewards(address user_, address refundTo_) external payable onlyOwner {\n        require(undistributedRewards > 0, \"DR: nothing to withdraw\");\n\n        IL1SenderV2(l1Sender).sendMintMessage{value: msg.value}(user_, undistributedRewards, refundTo_);\n\n        undistributedRewards = 0;\n    }\n\n    /**\n     * @dev Used as a universal proxy for all `DepositPool` so that the `msg.sender` of the message to the\n     * reward mint is one.\n     */\n    function sendMintMessage(\n        uint256 rewardPoolIndex_,\n        address user_,\n        uint256 amount_,\n        address refundTo_\n    ) external payable {\n        address depositPoolAddress_ = _msgSender();\n        _onlyExistedDepositPool(rewardPoolIndex_, depositPoolAddress_);\n\n        IL1SenderV2(l1Sender).sendMintMessage{value: msg.value}(user_, amount_, refundTo_);\n    }\n\n    /**\n     * @dev Move yield to the `l1Sender`. The current contract merely collects the yield and passes\n     * it on, for further distribution. Since the logic of yield transfer (e.g. using bridges) for\n     * each token may be different.\n     */\n    function _withdrawYield(uint256 rewardPoolIndex_, address depositPoolAddress_) private {\n        DepositPool storage depositPool = depositPools[rewardPoolIndex_][depositPoolAddress_];\n\n        uint256 yield_ = depositPool.lastUnderlyingBalance - depositPool.deposited;\n        if (yield_ == 0) return;\n\n        if (depositPool.strategy == Strategy.AAVE) {\n            AaveIPool(aavePool).withdraw(depositPool.token, yield_, l1Sender);\n        } else {\n            IERC20(depositPool.token).safeTransfer(l1Sender, yield_);\n        }\n\n        depositPool.lastUnderlyingBalance -= yield_;\n    }\n\n    /**********************************************************************************************/\n    /*** Contracts getters                                                                      ***/\n    /**********************************************************************************************/\n\n    function getDistributedRewards(\n        uint256 rewardPoolIndex_,\n        address depositPoolAddress_\n    ) external view returns (uint256) {\n        return distributedRewards[rewardPoolIndex_][depositPoolAddress_];\n    }\n\n    /**********************************************************************************************/\n    /*** UUPS                                                                                   ***/\n    /**********************************************************************************************/\n\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}\n"
    }
}