{
    "vfp_id": "vfp_00115",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "The protocol exhibits a critical discrepancy between how an agent's health factor is calculated and how slashable collateral is determined. This inconsistency arises because the health factor evaluation uses all current collateral, including recent deposits, while the slashing mechanism only considers deposits made before the most recent epoch or the agent's last borrow time. The root cause is the misalignment in time bases used by the coverage and slashTimestamp functions. An attacker can exploit this by adding fresh collateral just before a liquidation event to improve their health factor, knowing that these new deposits will not be subject to slashing. As a result, during liquidation, the protocol cannot recover sufficient collateral from these recent deposits, leading to a shortfall that the protocol must absorb. This undermines the financial stability and security model of the system, potentially resulting in significant protocol losses, especially if all existing delegations are from the current epoch.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/Delegation.sol#L73-L76",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L195-L206",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        }
    ],
    "affected_files": {
        "Delegation.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IDelegation } from \"../interfaces/IDelegation.sol\";\nimport { INetworkMiddleware } from \"../interfaces/INetworkMiddleware.sol\";\n\nimport { DelegationStorageUtils } from \"../storage/DelegationStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title Cap Delegation Contract\n/// @author Cap Labs\n/// @notice This contract manages delegation and slashing.\ncontract Delegation is IDelegation, UUPSUpgradeable, Access, DelegationStorageUtils {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract\n    /// @param _accessControl Access control address\n    /// @param _oracle Oracle address\n    /// @param _epochDuration Epoch duration in seconds\n    function initialize(address _accessControl, address _oracle, uint256 _epochDuration) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        DelegationStorage storage $ = getDelegationStorage();\n        $.oracle = _oracle;\n        $.epochDuration = _epochDuration;\n        $.ltvBuffer = 0.05e27; // 5%\n    }\n\n    /// @notice Get the epoch duration\n    /// @return duration Epoch duration in seconds\n    function epochDuration() external view returns (uint256 duration) {\n        DelegationStorage storage $ = getDelegationStorage();\n        duration = $.epochDuration;\n    }\n\n    /// @notice Get the current epoch\n    /// @return currentEpoch Current epoch\n    function epoch() public view returns (uint256 currentEpoch) {\n        DelegationStorage storage $ = getDelegationStorage();\n        currentEpoch = block.timestamp / $.epochDuration;\n    }\n\n    /// @notice Get the ltv buffer\n    /// @return buffer LTV buffer\n    function ltvBuffer() external view returns (uint256 buffer) {\n        buffer = getDelegationStorage().ltvBuffer;\n    }\n\n    /// @notice Get the timestamp that is most recent between the last borrow and the epoch -1\n    /// @param _agent The agent address\n    /// @return _slashTimestamp Timestamp that is most recent between the last borrow and the epoch -1\n    function slashTimestamp(address _agent) public view returns (uint48 _slashTimestamp) {\n        DelegationStorage storage $ = getDelegationStorage();\n        _slashTimestamp = uint48(Math.max((epoch() - 1) * $.epochDuration, $.agentData[_agent].lastBorrow));\n    }\n\n    /// @notice How much delegation and agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return delegation Amount in USD (8 decimals) that a agent has provided as delegation from the delegators\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        DelegationStorage storage $ = getDelegationStorage();\n        delegation = INetworkMiddleware($.agentData[_agent].network).coverage(_agent);\n    }\n\n    /// @notice How much slashable coverage an agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return _slashableCollateral Amount in USD (8 decimals) that a agent has provided as slashable collateral from the delegators\n    function slashableCollateral(address _agent) public view returns (uint256 _slashableCollateral) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n        _slashableCollateral =\n            INetworkMiddleware($.agentData[_agent].network).slashableCollateral(_agent, _slashTimestamp);\n    }\n\n    /// @notice Fetch active network address\n    /// @param _agent Agent address\n    /// @return networkAddress network address\n    function networks(address _agent) external view returns (address networkAddress) {\n        networkAddress = getDelegationStorage().agentData[_agent].network;\n    }\n\n    /// @notice Fetch active agent addresses\n    /// @return agentAddresses Agent addresses\n    function agents() external view returns (address[] memory agentAddresses) {\n        agentAddresses = getDelegationStorage().agents.values();\n    }\n\n    /// @notice The LTV of a specific agent\n    /// @param _agent Agent who we are querying\n    /// @return currentLtv Loan to value ratio of the agent\n    function ltv(address _agent) external view returns (uint256 currentLtv) {\n        currentLtv = getDelegationStorage().agentData[_agent].ltv;\n    }\n\n    /// @notice Liquidation threshold of the agent\n    /// @param _agent Agent who we are querying\n    /// @return lt Liquidation threshold of the agent\n    function liquidationThreshold(address _agent) external view returns (uint256 lt) {\n        lt = getDelegationStorage().agentData[_agent].liquidationThreshold;\n    }\n\n    /// @notice The slash function. Calls the underlying networks to slash the delegated capital\n    /// @dev Called only by the lender during liquidation\n    /// @param _agent The agent who is unhealthy\n    /// @param _liquidator The liquidator who receives the funds\n    /// @param _amount The USD value of the delegation needed to cover the debt\n    function slash(address _agent, address _liquidator, uint256 _amount) external checkAccess(this.slash.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n\n        address network = $.agentData[_agent].network;\n        uint256 networkSlashableCollateral = INetworkMiddleware(network).slashableCollateral(_agent, _slashTimestamp);\n        if (networkSlashableCollateral == 0) revert NoSlashableCollateral();\n        uint256 slashShare = _amount * 1e18 / networkSlashableCollateral;\n        if (slashShare > 1e18) slashShare = 1e18;\n\n        INetworkMiddleware(network).slash(_agent, _liquidator, slashShare, _slashTimestamp);\n        emit SlashNetwork(network, _amount);\n    }\n\n    /// @notice Distribute rewards to networks covering an agent proportionally to their coverage\n    /// @param _agent The agent address\n    /// @param _asset The reward token address\n    function distributeRewards(address _agent, address _asset) external {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint256 _amount = IERC20(_asset).balanceOf(address(this));\n\n        uint256 totalCoverage = coverage(_agent);\n        // here we cannot revert because the agent might not have any coverage\n        // in case we are liquidating the current agent due to 0 coverage\n        if (totalCoverage == 0) return;\n\n        address network = $.agentData[_agent].network;\n        IERC20(_asset).safeTransfer(network, _amount);\n        INetworkMiddleware(network).distributeRewards(_agent, _asset);\n\n        emit DistributeReward(_agent, _asset, _amount);\n    }\n\n    /// @notice Set the last borrow timestamp for an agent\n    /// @param _agent Agent address\n    function setLastBorrow(address _agent) external checkAccess(this.setLastBorrow.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        $.agentData[_agent].lastBorrow = block.timestamp;\n    }\n\n    /// @notice Add agent to be delegated to\n    /// @param _agent Agent address\n    /// @param _network Network address\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function addAgent(address _agent, address _network, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.addAgent.selector)\n    {\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // if ltv is greater than 100% then agent could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv != 0 && _liquidationThreshold < _ltv + $.ltvBuffer) revert LiquidationThresholdTooCloseToLtv();\n\n        // If the agent already exists, we revert\n        if ($.agents.contains(_agent)) revert DuplicateAgent();\n        if (!$.networks.contains(_network)) revert NetworkDoesntExist();\n\n        $.agents.add(_agent);\n        $.agentData[_agent].network = _network;\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        emit AddAgent(_agent, _network, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Modify an agents config only callable by the operator\n    /// @param _agent the agent to modify\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function modifyAgent(address _agent, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.modifyAgent.selector)\n    {\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // if ltv is greater than 100% then agent could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv != 0 && _liquidationThreshold < _ltv + $.ltvBuffer) revert LiquidationThresholdTooCloseToLtv();\n\n        // Check that the agent exists\n        if (!$.agents.contains(_agent)) revert AgentDoesNotExist();\n\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        emit ModifyAgent(_agent, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Register a new network\n    /// @param _network Network address\n    function registerNetwork(address _network) external checkAccess(this.registerNetwork.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        if (_network == address(0)) revert InvalidNetwork();\n\n        // Check for duplicates\n        if ($.networks.contains(_network)) revert DuplicateNetwork();\n\n        $.networks.add(_network);\n        emit RegisterNetwork(_network);\n    }\n\n    /// @notice Check if a network is registered\n    /// @param _network Network address\n    /// @return _exists Whether the network is registered\n    function networkExists(address _network) external view returns (bool) {\n        return getDelegationStorage().networks.contains(_network);\n    }\n\n    /// @notice Set the ltv buffer\n    /// @param _ltvBuffer LTV buffer\n    function setLtvBuffer(uint256 _ltvBuffer) external checkAccess(this.setLtvBuffer.selector) {\n        if (_ltvBuffer > 1e27) revert InvalidLtvBuffer();\n        getDelegationStorage().ltvBuffer = _ltvBuffer;\n        emit SetLtvBuffer(_ltvBuffer);\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n"
    }
}