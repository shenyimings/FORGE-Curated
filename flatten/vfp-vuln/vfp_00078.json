{
    "vfp_id": "vfp_00078",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Lack of reserve updates when collecting fees allows anyone to drain the Vault",
            "description": "The Vault fails to update its internal reserves after collecting fees, leading to a discrepancy between the recorded reserves and actual token balance. When fees are collected via collectAggregateFees, the tokens are transferred out but the Vault's reserve accounting remains unchanged. This causes the Vault to believe it holds more tokens than it actually does. The root cause is the omission of a reserve update step after fee collection. An attacker can exploit this by using the erc4626BufferWrapOrUnwrap function, which relies on reserve accounting to determine how many tokens to credit. By manipulating this discrepancy with a malicious wrapper contract, the attacker can withdraw tokens corresponding to the difference. The impact is high, as this can be repeated to drain the entire Vault of all its assets.\n",
            "severity": "High",
            "location": [
                "VaultAdmin.sol::collectAggregateFees#273-295",
                "Vault.sol::_updateReservesAfterWrapping#1367-1390",
                "https://github.com/balancer/balancer-v3-monorepo/pull/857"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Yield fees collected when exiting recovery mode will be lost",
            "description": "When a pool exits recovery mode, yield fees that are accrued during the disableRecoveryMode call are removed from the pool balance but not credited to the aggregate fee balance, resulting in permanent loss. The issue arises because _setPoolRecoveryMode sets the recovery mode flag to false before updating balances, causing _loadPoolData to accrue yield fees. However, there is no mechanism to transfer these fees to the ProtocolFeeController. The root cause is incorrect ordering of state updates. An attacker cannot directly exploit this for profit, but can trigger the condition by forcing a pool into recovery mode and waiting for yield accumulation. The impact is medium, as it leads to loss of fees that should have been distributed to stakeholders, affecting economic fairness.\n",
            "severity": "Medium",
            "location": [
                "VaultAdmin.sol::disableRecoveryMode#352-355",
                "VaultAdmin.sol::_setPoolRecoveryMode#374-383",
                "PoolDataLib.sol::load#31-64",
                "PoolDataLib.sol::load#49-91",
                "https://github.com/balancer/balancer-v3-monorepo/pull/880"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultAdmin.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { PoolFunctionPermission, Rounding } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { Authentication } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/Authentication.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { VaultStateBits, VaultStateLib } from \"./lib/VaultStateLib.sol\";\nimport { VaultExtensionsLib } from \"./lib/VaultExtensionsLib.sol\";\nimport { PoolConfigLib, PoolConfigBits } from \"./lib/PoolConfigLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\n/**\n * @dev Bytecode extension for the Vault containing permissioned functions. Complementary to `VaultExtension`,\n * it has access to the same storage layout as the main vault.\n *\n * The functions in this contract are not meant to be called directly. They must only be called by the Vault\n * via delegate calls, so that any state modifications produced by this contract's code will actually target\n * the main Vault's state.\n *\n * The storage of this contract is in practice unused.\n */\ncontract VaultAdmin is IVaultAdmin, VaultCommon, Authentication {\n    using PackedTokenBalance for bytes32;\n    using PoolConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using VaultExtensionsLib for IVault;\n    using SafeERC20 for IERC20;\n\n    IVault private immutable _vault;\n\n    /// @dev Functions with this modifier can only be delegate-called by the vault.\n    modifier onlyVaultDelegateCall() {\n        _vault.ensureVaultDelegateCall();\n        _;\n    }\n\n    /// @dev Functions with this modifier can only be called by the pool creator.\n    modifier onlyProtocolFeeController() {\n        if (msg.sender != address(_protocolFeeController)) {\n            revert SenderNotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Validate aggregate percentage values.\n    modifier withValidPercentage(uint256 aggregatePercentage) {\n        if (aggregatePercentage > FixedPoint.ONE) {\n            revert ProtocolFeesExceedTotalCollected();\n        }\n        _;\n    }\n\n    /// @dev Use with permissioned functions that use `PoolRoleAccounts`.\n    modifier authenticateByRole(address pool) {\n        _ensureAuthenticatedByRole(pool);\n        _;\n    }\n\n    function _ensureAuthenticatedByRole(address pool) private view {\n        bytes32 actionId = getActionId(msg.sig);\n\n        PoolFunctionPermission memory roleAssignment = _poolFunctionPermissions[pool][actionId];\n\n        // If there is no role assignment, fall through and delegate to governance.\n        if (roleAssignment.account != address(0)) {\n            // If the sender matches the permissioned account, all good; just return.\n            if (msg.sender == roleAssignment.account) {\n                return;\n            }\n\n            // If it doesn't, check whether it's onlyOwner. onlyOwner means *only* the permissioned account\n            // may call the function, so revert if this is the case. Otherwise, fall through and check\n            // governance.\n            if (roleAssignment.onlyOwner) {\n                revert SenderNotAllowed();\n            }\n        }\n\n        // Delegate to governance.\n        if (_canPerform(actionId, msg.sender, pool) == false) {\n            revert SenderNotAllowed();\n        }\n    }\n\n    constructor(\n        IVault mainVault,\n        uint32 pauseWindowDuration,\n        uint32 bufferPeriodDuration\n    ) Authentication(bytes32(uint256(uint160(address(mainVault))))) {\n        if (pauseWindowDuration > _MAX_PAUSE_WINDOW_DURATION) {\n            revert VaultPauseWindowDurationTooLarge();\n        }\n        if (bufferPeriodDuration > _MAX_BUFFER_PERIOD_DURATION) {\n            revert PauseBufferPeriodDurationTooLarge();\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint32 pauseWindowEndTime = uint32(block.timestamp) + pauseWindowDuration;\n\n        _vaultPauseWindowEndTime = pauseWindowEndTime;\n        _vaultBufferPeriodDuration = bufferPeriodDuration;\n        _vaultBufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n\n        _vault = mainVault;\n    }\n\n    /*******************************************************************************\n                               Constants and immutables\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function vault() external view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getPauseWindowEndTime() external view returns (uint32) {\n        return _vaultPauseWindowEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodDuration() external view returns (uint32) {\n        return _vaultBufferPeriodDuration;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodEndTime() external view returns (uint32) {\n        return _vaultBufferPeriodEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMinimumPoolTokens() external pure returns (uint256) {\n        return _MIN_TOKENS;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMaximumPoolTokens() external pure returns (uint256) {\n        return _MAX_TOKENS;\n    }\n\n    /*******************************************************************************\n                                    Vault Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function isVaultPaused() external view onlyVaultDelegateCall returns (bool) {\n        return _isVaultPaused();\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getVaultPausedState() external view onlyVaultDelegateCall returns (bool, uint32, uint32) {\n        return (_isVaultPaused(), _vaultPauseWindowEndTime, _vaultBufferPeriodEndTime);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(false);\n    }\n\n    /**\n     * @dev The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     */\n    function _setVaultPaused(bool pausing) internal {\n        if (_isVaultPaused()) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert VaultPaused();\n            }\n\n            // The Vault can always be unpaused while it's paused.\n            // When the buffer period expires, `_isVaultPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= _vaultPauseWindowEndTime) {\n                    revert VaultPauseWindowExpired();\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert VaultNotPaused();\n            }\n        }\n\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setVaultPaused(pausing);\n        _vaultStateBits = vaultState;\n\n        emit VaultPausedStateChanged(pausing);\n    }\n\n    /*******************************************************************************\n                                     Pool Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pausePool(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpausePool(\n        address pool\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, false);\n    }\n\n    function _setPoolPaused(address pool, bool pausing) internal {\n        PoolConfigBits config = _poolConfigBits[pool];\n\n        if (_isPoolPaused(pool)) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert PoolPaused(pool);\n            }\n\n            // The pool can always be unpaused while it's paused.\n            // When the buffer period expires, `_isPoolPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= config.getPauseWindowEndTime()) {\n                    revert PoolPauseWindowExpired(pool);\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert PoolNotPaused(pool);\n            }\n        }\n\n        // Update poolConfigBits.\n        _poolConfigBits[pool] = config.setPoolPaused(pausing);\n\n        emit PoolPausedStateChanged(pool, pausing);\n    }\n\n    /*******************************************************************************\n                                        Fees\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setStaticSwapFeePercentage(\n        address pool,\n        uint256 swapFeePercentage\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        // Saving bits by not implementing a new modifier.\n        _ensureUnpaused(pool);\n        _setStaticSwapFeePercentage(pool, swapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function collectAggregateFees(address pool) public onlyVaultDelegateCall nonReentrant withRegisteredPool(pool) {\n        IERC20[] memory poolTokens = _vault.getPoolTokens(pool);\n        address feeController = address(_protocolFeeController);\n        uint256 numTokens = poolTokens.length;\n\n        uint256[] memory totalSwapFees = new uint256[](numTokens);\n        uint256[] memory totalYieldFees = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < poolTokens.length; ++i) {\n            IERC20 token = poolTokens[i];\n\n            (totalSwapFees[i], totalYieldFees[i]) = _aggregateFeeAmounts[pool][token].fromPackedBalance();\n\n            if (totalSwapFees[i] > 0 || totalYieldFees[i] > 0) {\n                // The ProtocolFeeController will pull tokens from the Vault.\n                token.forceApprove(feeController, totalSwapFees[i] + totalYieldFees[i]);\n\n                _aggregateFeeAmounts[pool][token] = 0;\n            }\n        }\n\n        _protocolFeeController.receiveAggregateFees(pool, totalSwapFees, totalYieldFees);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateSwapFeePercentage(\n        address pool,\n        uint256 newAggregateSwapFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateSwapFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateSwapFeePercentage(newAggregateSwapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateYieldFeePercentage(\n        address pool,\n        uint256 newAggregateYieldFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateYieldFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateYieldFeePercentage(newAggregateYieldFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function setProtocolFeeController(\n        IProtocolFeeController newProtocolFeeController\n    ) external onlyVaultDelegateCall authenticate nonReentrant {\n        _protocolFeeController = newProtocolFeeController;\n\n        emit ProtocolFeeControllerChanged(newProtocolFeeController);\n    }\n\n    /*******************************************************************************\n                                    Recovery Mode\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function enableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) {\n        _ensurePoolNotInRecoveryMode(pool);\n\n        // If the Vault or pool is pausable (and currently paused), this call is permissionless.\n        if (_isPoolPaused(pool) == false && _isVaultPaused() == false) {\n            // If not permissionless, authenticate with governance.\n            _authenticateCaller();\n        }\n\n        _setPoolRecoveryMode(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function disableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticate {\n        _ensurePoolInRecoveryMode(pool);\n        _setPoolRecoveryMode(pool, false);\n    }\n\n    /**\n     * @dev Reverts if the pool is in recovery mode.\n     * @param pool The pool\n     */\n    function _ensurePoolNotInRecoveryMode(address pool) internal view {\n        if (_isPoolInRecoveryMode(pool)) {\n            revert PoolInRecoveryMode(pool);\n        }\n    }\n\n    /**\n     * @dev Change the recovery mode state of a pool, and emit an event. Assumes any validation (e.g., whether\n     * the proposed state change is consistent) has already been done.\n     *\n     * @param pool The pool\n     * @param recoveryMode The desired recovery mode state\n     */\n    function _setPoolRecoveryMode(address pool, bool recoveryMode) internal {\n        // Update poolConfigBits\n        _poolConfigBits[pool] = _poolConfigBits[pool].setPoolInRecoveryMode(recoveryMode);\n\n        if (recoveryMode == false) {\n            _writePoolBalancesToStorage(pool, _loadPoolData(pool, Rounding.ROUND_DOWN));\n        }\n\n        emit PoolRecoveryModeStateChanged(pool, recoveryMode);\n    }\n\n    /*******************************************************************************\n                                        Queries\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function disableQuery() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setQueryDisabled(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /*******************************************************************************\n                                Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(false);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function addLiquidityToBuffer(\n        IERC4626 wrappedToken,\n        uint256 amountUnderlying,\n        uint256 amountWrapped,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 issuedShares)\n    {\n        address underlyingToken = wrappedToken.asset();\n\n        // Amount of shares to issue is the total underlying token that the user is depositing.\n        issuedShares = wrappedToken.convertToAssets(amountWrapped) + amountUnderlying;\n\n        if (_bufferAssets[wrappedToken] == address(0)) {\n            // Buffer is not initialized yet, so we initialize it.\n\n            // Register asset of wrapper, so it cannot change.\n            _bufferAssets[wrappedToken] = underlyingToken;\n\n            // Burn MINIMUM_TOTAL_SUPPLY shares, so the buffer can never go back to zero liquidity\n            // (avoids rounding issues with low liquidity).\n            _bufferTotalShares[wrappedToken] = _MINIMUM_TOTAL_SUPPLY;\n            issuedShares -= _MINIMUM_TOTAL_SUPPLY;\n        } else if (_bufferAssets[wrappedToken] != underlyingToken) {\n            // Asset was changed since the first bufferAddLiquidity call.\n            revert WrongWrappedTokenAsset(address(wrappedToken));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        // Adds the issued shares to the total shares of the liquidity pool.\n        _bufferLpShares[wrappedToken][sharesOwner] += issuedShares;\n        _bufferTotalShares[wrappedToken] += issuedShares;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() + amountUnderlying,\n            bufferBalances.getBalanceDerived() + amountWrapped\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _takeDebt(IERC20(underlyingToken), amountUnderlying);\n        _takeDebt(wrappedToken, amountWrapped);\n\n        emit LiquidityAddedToBuffer(wrappedToken, sharesOwner, amountWrapped, amountUnderlying, issuedShares);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function removeLiquidityFromBuffer(\n        IERC4626 wrappedToken,\n        uint256 sharesToRemove,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        authenticate\n        nonReentrant\n        returns (uint256 removedUnderlyingBalance, uint256 removedWrappedBalance)\n    {\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (sharesToRemove > _bufferLpShares[wrappedToken][sharesOwner]) {\n            revert NotEnoughBufferShares();\n        }\n        uint256 totalShares = _bufferTotalShares[wrappedToken];\n\n        removedUnderlyingBalance = (bufferBalances.getBalanceRaw() * sharesToRemove) / totalShares;\n        removedWrappedBalance = (bufferBalances.getBalanceDerived() * sharesToRemove) / totalShares;\n\n        _bufferLpShares[wrappedToken][sharesOwner] -= sharesToRemove;\n        _bufferTotalShares[wrappedToken] -= sharesToRemove;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() - removedUnderlyingBalance,\n            bufferBalances.getBalanceDerived() - removedWrappedBalance\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _supplyCredit(IERC20(_bufferAssets[wrappedToken]), removedUnderlyingBalance);\n        _supplyCredit(wrappedToken, removedWrappedBalance);\n\n        emit LiquidityRemovedFromBuffer(\n            wrappedToken,\n            sharesOwner,\n            removedWrappedBalance,\n            removedUnderlyingBalance,\n            sharesToRemove\n        );\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferOwnerShares(\n        IERC4626 token,\n        address user\n    ) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferLpShares[token][user];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferTotalShares(IERC4626 token) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferTotalShares[token];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferBalance(IERC4626 token) external view onlyVaultDelegateCall returns (uint256, uint256) {\n        // The first balance is underlying, and the last is wrapped balance.\n        return (_bufferTokenBalances[token].getBalanceRaw(), _bufferTokenBalances[token].getBalanceDerived());\n    }\n\n    /*******************************************************************************\n                                Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setAuthorizer(IAuthorizer newAuthorizer) external onlyVaultDelegateCall authenticate {\n        _authorizer = newAuthorizer;\n\n        emit AuthorizerChanged(newAuthorizer);\n    }\n\n    /// @dev Access control is delegated to the Authorizer.\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\n        return _authorizer.canPerform(actionId, user, address(this));\n    }\n\n    /// @dev Access control is delegated to the Authorizer. `where` refers to the target contract.\n    function _canPerform(bytes32 actionId, address user, address where) internal view returns (bool) {\n        return _authorizer.canPerform(actionId, user, where);\n    }\n}\n"
    }
}