{
    "vfp_id": "vfp_00286",
    "project_name": "report_cantinacode_eco_may2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Incorrect IPROVER_INTERFACE_ID constant allows malicious solvers to steal funds during fulfillment",
            "description": "The IPROVER_INTERFACE_ID constant in Inbox.sol is hardcoded to an incorrect value (0xd8e1f34f), which is intended to represent the interface ID of the IProver contract. The root cause is the manual assignment instead of deriving it via `type(IProver).interfaceId`, leading to a mismatch in interface identification. An attacker could deploy a malicious contract that mimics the prover interface but bypasses the check, allowing unauthorized calls to be treated as legitimate prover interactions. This could result in the theft of funds from solvers during intent fulfillment, as the system fails to correctly identify and block non-prover contracts.\n",
            "severity": "High",
            "location": [
                "Inbox.sol#L29"
            ],
            "files": [
                "eco-routes/contracts/Inbox.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Incorrect check for prover calls may lead to DoS for intent fulfillment",
            "description": "The current logic in Inbox.sol to prevent direct calls to prover contracts uses a low-level `.call` to check for `supportsInterface`, but does not properly handle the return data or potential reverts. The cause is the incorrect handling of the success boolean and return data from the external call, which can lead to false negatives. If an intent target contract implements IERC165 but reverts during the interface check, the entire fulfillment may be blocked. This creates a denial-of-service vector where valid intents fail to execute, especially when interacting with legitimate IERC165-compliant contracts that do not support arbitrary interface queries.\n",
            "severity": "Medium",
            "location": [
                "Inbox.sol#L211-L220"
            ],
            "files": [
                "eco-routes/contracts/Inbox.sol"
            ]
        }
    ],
    "affected_files": {
        "Inbox.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IProver} from \"./interfaces/IProver.sol\";\nimport {IInbox} from \"./interfaces/IInbox.sol\";\nimport {IExecutor} from \"./interfaces/IExecutor.sol\";\n\nimport {Route, Call, TokenAmount} from \"./types/Intent.sol\";\nimport {Semver} from \"./libs/Semver.sol\";\nimport {Refund} from \"./libs/Refund.sol\";\n\nimport {DestinationSettler} from \"./ERC7683/DestinationSettler.sol\";\nimport {Executor} from \"./Executor.sol\";\n\n/**\n * @title Inbox\n * @notice Main entry point for fulfilling intents on the destination chain\n * @dev Validates intent hash authenticity, executes calldata, and enables provers\n * to claim rewards on the source chain by checking the claimants mapping\n */\nabstract contract Inbox is DestinationSettler, IInbox {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Mapping of intent hashes to their claimant identifiers\n     * @dev Stores the cross-VM compatible claimant identifier for each fulfilled intent\n     */\n    mapping(bytes32 => bytes32) public claimants;\n\n    IExecutor public immutable executor;\n\n    /**\n     * @notice Chain ID stored as immutable for gas efficiency\n     * @dev Used to prepend to proof messages for cross-chain identification\n     */\n    uint64 private immutable CHAIN_ID;\n\n    /**\n     * @notice Initializes the Inbox contract\n     * @dev Sets up the base contract for handling intent fulfillment on destination chains\n     */\n    constructor() {\n        executor = new Executor();\n\n        // Validate that chain ID fits in uint64 and store it\n        if (block.chainid > type(uint64).max) {\n            revert ChainIdTooLarge(block.chainid);\n        }\n        CHAIN_ID = uint64(block.chainid);\n    }\n\n    /**\n     * @notice Fulfills an intent to be proven via storage proofs\n     * @dev Validates intent hash, executes calls, and marks as fulfilled\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route of the intent\n     * @param rewardHash The hash of the reward details\n     * @param claimant Cross-VM compatible claimant identifier\n     * @return Array of execution results from each call\n     */\n    function fulfill(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant\n    ) external payable returns (bytes[] memory) {\n        bytes[] memory result = _fulfill(\n            intentHash,\n            route,\n            rewardHash,\n            claimant\n        );\n\n        // Refund any remaining balance (excess ETH)\n        Refund.excessNative();\n\n        return result;\n    }\n\n    /**\n     * @notice Fulfills an intent and initiates proving in one transaction\n     * @dev Executes intent actions and sends proof message to source chain\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route of the intent\n     * @param rewardHash The hash of the reward details\n     * @param claimant Cross-VM compatible claimant identifier\n     * @param prover Address of prover on the destination chain\n     * @param sourceChainDomainID Domain ID of the source chain where the intent was created\n     * @param data Additional data for message formatting\n     * @return Array of execution results\n     *\n     * @dev WARNING: sourceChainDomainID is NOT necessarily the same as chain ID.\n     *      Each bridge provider uses their own domain ID mapping system:\n     *      - Hyperlane: Uses custom domain IDs that may differ from chain IDs\n     *      - LayerZero: Uses endpoint IDs that map to chains differently\n     *      - Metalayer: Uses domain IDs specific to their routing system\n     *      - Polymer: Uses chain IDs\n     *      You MUST consult the specific bridge provider's documentation to determine\n     *      the correct domain ID for the source chain.\n     */\n    function fulfillAndProve(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant,\n        address prover,\n        uint64 sourceChainDomainID,\n        bytes memory data\n    )\n        public\n        payable\n        override(DestinationSettler, IInbox)\n        returns (bytes[] memory)\n    {\n        bytes[] memory result = _fulfill(\n            intentHash,\n            route,\n            rewardHash,\n            claimant\n        );\n\n        // Create array with single intent hash\n        bytes32[] memory intentHashes = new bytes32[](1);\n        intentHashes[0] = intentHash;\n\n        // Call prove with the intent hash array\n        // This will also refund any excess ETH\n        prove(prover, sourceChainDomainID, intentHashes, data);\n\n        return result;\n    }\n\n    /**\n     * @notice Initiates proving process for fulfilled intents\n     * @dev Sends message to source chain to verify intent execution\n     * @param prover Address of prover on the destination chain\n     * @param sourceChainDomainID Domain ID of the source chain\n     * @param intentHashes Array of intent hashes to prove\n     * @param data Additional data for message formatting\n     *\n     * @dev WARNING: sourceChainDomainID is NOT necessarily the same as chain ID.\n     *      Each bridge provider uses their own domain ID mapping system:\n     *      - Hyperlane: Uses custom domain IDs that may differ from chain IDs\n     *      - LayerZero: Uses endpoint IDs that map to chains differently\n     *      - Metalayer: Uses domain IDs specific to their routing system\n     *      - Polymer: Uses chainIDs\n     *      You MUST consult the specific bridge provider's documentation to determine\n     *      the correct domain ID for the source chain.\n     */\n    function prove(\n        address prover,\n        uint64 sourceChainDomainID,\n        bytes32[] memory intentHashes,\n        bytes memory data\n    ) public payable {\n        uint256 size = intentHashes.length;\n\n        // Encode chain ID followed by intent hash/claimant pairs as bytes\n        // 8 bytes for chain ID + (32 bytes for intent hash + 32 bytes for claimant) * size\n        bytes memory encodedClaimants = new bytes(8 + size * 64);\n\n        // Prepend chain ID to the encoded data\n        uint64 chainId = CHAIN_ID;\n        assembly {\n            mstore(add(encodedClaimants, 0x20), shl(192, chainId))\n        }\n\n        for (uint256 i = 0; i < size; ++i) {\n            bytes32 claimantBytes = claimants[intentHashes[i]];\n\n            if (claimantBytes == bytes32(0)) {\n                revert IntentNotFulfilled(intentHashes[i]);\n            }\n\n            // Pack intent hash and claimant into encodedData (after 8-byte chain ID)\n            assembly {\n                let offset := add(8, mul(i, 64))\n                mstore(\n                    add(add(encodedClaimants, 0x20), offset),\n                    mload(add(intentHashes, add(0x20, mul(i, 32))))\n                )\n                mstore(\n                    add(add(encodedClaimants, 0x20), add(offset, 32)),\n                    claimantBytes\n                )\n            }\n\n            // Emit IntentProven event\n            emit IntentProven(intentHashes[i], claimantBytes);\n        }\n\n        // Provide left over balance to the prover\n        IProver(prover).prove{value: address(this).balance}(\n            msg.sender,\n            sourceChainDomainID,\n            encodedClaimants,\n            data\n        );\n    }\n\n    /**\n     * @notice Internal function to fulfill intents\n     * @dev Validates intent and executes calls\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route of the intent\n     * @param rewardHash The hash of the reward\n     * @param claimant Cross-VM compatible claimant identifier\n     * @return Array of execution results\n     */\n    function _fulfill(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant\n    ) internal returns (bytes[] memory) {\n        // Check if the route has expired\n        if (block.timestamp > route.deadline) {\n            revert IntentExpired();\n        }\n\n        bytes32 routeHash = keccak256(abi.encode(route));\n        bytes32 computedIntentHash = keccak256(\n            abi.encodePacked(CHAIN_ID, routeHash, rewardHash)\n        );\n\n        if (route.portal != address(this)) {\n            revert InvalidPortal(route.portal);\n        }\n        if (computedIntentHash != intentHash) {\n            revert InvalidHash(intentHash);\n        }\n        if (claimants[intentHash] != bytes32(0)) {\n            revert IntentAlreadyFulfilled(intentHash);\n        }\n        if (claimant == bytes32(0)) {\n            revert ZeroClaimant();\n        }\n\n        claimants[intentHash] = claimant;\n\n        emit IntentFulfilled(intentHash, claimant);\n\n        // Transfer ERC20 tokens to the executor\n        uint256 tokensLength = route.tokens.length;\n\n        // Validate that msg.value is at least the route's nativeAmount\n        // Allow extra value for cross-chain message fees when using fulfillAndProve\n        if (msg.value < route.nativeAmount) {\n            revert InsufficientNativeAmount(msg.value, route.nativeAmount);\n        }\n\n        for (uint256 i = 0; i < tokensLength; ++i) {\n            TokenAmount memory token = route.tokens[i];\n\n            IERC20(token.token).safeTransferFrom(\n                msg.sender,\n                address(executor),\n                token.amount\n            );\n        }\n\n        return executor.execute{value: route.nativeAmount}(route.calls);\n    }\n}\n"
    }
}