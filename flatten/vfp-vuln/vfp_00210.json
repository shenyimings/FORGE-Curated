{
    "vfp_id": "vfp_00210",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "M1: processExitDelayReport griefing",
            "description": "The processExitDelayReport function in CSExitPenalties.sol reverts when a validator has already been reported for exit delay, which prevents batch reporting transactions from succeeding if any single validator in the batch has already been reported. This behavior enables a griefing attack where an attacker can front-run a batch report transaction by submitting a report for one validator in the batch, causing the entire batch to revert and waste gas. The root cause is the use of a revert instead of a silent skip when a validator is already reported. This increases the cost and risk of reporting for honest actors and can be abused to disrupt the penalty enforcement mechanism.\n",
            "severity": "Medium",
            "location": [
                "CSExitPenalties.sol::processExitDelayReport",
                "ValidatorExitDelayVerifier.sol::verifyValidatorExitDelay#178-196"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSExitPenalties.sol"
            ]
        }
    ],
    "affected_files": {
        "CSExitPenalties.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ExitTypes } from \"./abstract/ExitTypes.sol\";\n\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSExitPenalties, MarkedUint248, ExitPenaltyInfo } from \"./interfaces/ICSExitPenalties.sol\";\nimport { ICSModule } from \"./interfaces/ICSModule.sol\";\nimport { ICSParametersRegistry } from \"./interfaces/ICSParametersRegistry.sol\";\n\ncontract CSExitPenalties is ICSExitPenalties, ExitTypes {\n    using SafeCast for uint256;\n\n    ICSModule public immutable MODULE;\n    ICSParametersRegistry public immutable PARAMETERS_REGISTRY;\n    ICSAccounting public immutable ACCOUNTING;\n    address public immutable STRIKES;\n\n    mapping(bytes32 keyPointer => ExitPenaltyInfo) private _exitPenaltyInfo;\n\n    modifier onlyModule() {\n        if (msg.sender != address(MODULE)) {\n            revert SenderIsNotModule();\n        }\n\n        _;\n    }\n\n    modifier onlyStrikes() {\n        if (msg.sender != STRIKES) {\n            revert SenderIsNotStrikes();\n        }\n\n        _;\n    }\n\n    constructor(address module, address parametersRegistry, address strikes) {\n        if (module == address(0)) {\n            revert ZeroModuleAddress();\n        }\n        if (parametersRegistry == address(0)) {\n            revert ZeroParametersRegistryAddress();\n        }\n        if (strikes == address(0)) {\n            revert ZeroStrikesAddress();\n        }\n\n        MODULE = ICSModule(module);\n        PARAMETERS_REGISTRY = ICSParametersRegistry(parametersRegistry);\n        ACCOUNTING = MODULE.accounting();\n        STRIKES = strikes;\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function processExitDelayReport(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external onlyModule {\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n\n        uint256 allowedExitDelay = PARAMETERS_REGISTRY.getAllowedExitDelay(\n            curveId\n        );\n        if (eligibleToExitInSec <= allowedExitDelay) {\n            revert ValidatorExitDelayNotApplicable();\n        }\n\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        ExitPenaltyInfo storage exitPenaltyInfo = _exitPenaltyInfo[keyPointer];\n        if (exitPenaltyInfo.delayPenalty.isValue) {\n            revert ValidatorExitDelayAlreadyReported();\n        }\n\n        uint256 delayPenalty = PARAMETERS_REGISTRY.getExitDelayPenalty(curveId);\n        exitPenaltyInfo.delayPenalty = MarkedUint248(\n            delayPenalty.toUint248(),\n            true\n        );\n        emit ValidatorExitDelayProcessed(\n            nodeOperatorId,\n            publicKey,\n            delayPenalty\n        );\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function processTriggeredExit(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 withdrawalRequestPaidFee,\n        uint256 exitType\n    ) external onlyModule {\n        if (exitType == VOLUNTARY_EXIT_TYPE_ID) {\n            return;\n        }\n\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        ExitPenaltyInfo storage exitPenaltyInfo = _exitPenaltyInfo[keyPointer];\n        // don't update the fee if it was already set to prevent hypothetical manipulations\n        //    with double reporting to get lower/higher fee.\n        if (exitPenaltyInfo.withdrawalRequestFee.isValue) {\n            return;\n        }\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n        uint256 maxFee = PARAMETERS_REGISTRY.getMaxWithdrawalRequestFee(\n            curveId\n        );\n\n        uint256 fee = Math.min(withdrawalRequestPaidFee, maxFee);\n\n        exitPenaltyInfo.withdrawalRequestFee = MarkedUint248(\n            fee.toUint248(),\n            true\n        );\n        emit TriggeredExitFeeRecorded({\n            nodeOperatorId: nodeOperatorId,\n            exitType: exitType,\n            pubkey: publicKey,\n            withdrawalRequestPaidFee: withdrawalRequestPaidFee,\n            withdrawalRequestRecordedFee: fee\n        });\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function processStrikesReport(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey\n    ) external onlyStrikes {\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        ExitPenaltyInfo storage exitPenaltyInfo = _exitPenaltyInfo[keyPointer];\n        if (exitPenaltyInfo.strikesPenalty.isValue) {\n            return;\n        }\n\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n        uint256 penalty = PARAMETERS_REGISTRY.getBadPerformancePenalty(curveId);\n        exitPenaltyInfo.strikesPenalty = MarkedUint248(\n            penalty.toUint248(),\n            true\n        );\n        emit StrikesPenaltyProcessed(nodeOperatorId, publicKey, penalty);\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    /// @dev there is a `onlyModule` modifier to prevent using it from outside\n    ///     as it gives a false-positive information for non-existent node operators.\n    ///     use `isValidatorExitDelayPenaltyApplicable` in the CSModule.sol instead\n    function isValidatorExitDelayPenaltyApplicable(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external view onlyModule returns (bool) {\n        uint256 curveId = ACCOUNTING.getBondCurveId(nodeOperatorId);\n        uint256 allowedExitDelay = PARAMETERS_REGISTRY.getAllowedExitDelay(\n            curveId\n        );\n        if (eligibleToExitInSec <= allowedExitDelay) {\n            return false;\n        }\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        bool isPenaltySet = _exitPenaltyInfo[keyPointer].delayPenalty.isValue;\n        return !isPenaltySet;\n    }\n\n    /// @inheritdoc ICSExitPenalties\n    function getExitPenaltyInfo(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey\n    ) external view returns (ExitPenaltyInfo memory) {\n        bytes32 keyPointer = _keyPointer(nodeOperatorId, publicKey);\n        return _exitPenaltyInfo[keyPointer];\n    }\n\n    function _keyPointer(\n        uint256 nodeOperatorId,\n        bytes memory publicKey\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(nodeOperatorId, publicKey));\n    }\n}\n"
    }
}