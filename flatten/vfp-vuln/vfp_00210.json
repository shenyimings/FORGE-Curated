{
    "vfp_id": "vfp_00210",
    "project_name": "ackee-blockchain-let's-get-hai-new-core-features-report.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "RewardPool._totalStaked variable updates incorrectly",
            "description": "The RewardPool contract maintains a _totalStaked variable to track the total amount of staked tokens in the StakingManager contract. This variable is updated when StakingManager stakes or withdraws tokens via the stake, increaseStake, and decreaseStake functions. However, when a new RewardPool contract connects to StakingManager after tokens are already staked, the _totalStaked variable in the new pool starts at zero and does not reflect the correct total staked amount. This leads to two potential exploit scenarios: first, a user's withdrawal may revert due to an incorrect balance check (when _wad > _totalStaked), and second, users may receive zero rewards from the new pool because reward calculations depend on _totalStaked being accurate. The root cause is the lack of initialization of _totalStaked with the actual total supply from the StakingToken contract upon deployment. This results in incorrect state tracking and potential denial of service for withdrawals or incorrect reward distribution.\n",
            "severity": "Medium",
            "location": [
                "RewardPool.sol::stake#100-104",
                "RewardPool.sol::increaseStake#107-110",
                "RewardPool.sol::decreaseStake#114-119"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardPool.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {IRewardPool} from '@interfaces/tokens/IRewardPool.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\nimport {Math, RAY, WAD} from '@libraries/Math.sol';\n\n/**\n * @title  RewardPool\n * @notice This contract constitutes a reward pool for a given reward token\n */\ncontract RewardPool is Authorizable, Modifiable, IRewardPool {\n  using Encoding for bytes;\n  using Assertions for uint256;\n  using Assertions for address;\n  using Math for uint256;\n  using SafeERC20 for IERC20;\n\n  // --- Registry ---\n\n  /// @inheritdoc IRewardPool\n  IERC20 public rewardToken;\n\n  // --- Params ---\n\n  /// @inheritdoc IRewardPool\n  // solhint-disable-next-line private-vars-leading-underscore\n  RewardPoolParams public _params;\n\n  /// @inheritdoc IRewardPool\n  function params() external view returns (RewardPoolParams memory _rewardPoolParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  uint256 private _totalStaked;\n\n  /// @inheritdoc IRewardPool\n  function totalStaked() external view returns (uint256 _totalStakedAmt) {\n    return _totalStaked;\n  }\n\n  /// @inheritdoc IRewardPool\n  uint256 public rewardPerTokenStored;\n  /// @inheritdoc IRewardPool\n  uint256 public periodFinish = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewardRate = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public lastUpdateTime;\n  /// @inheritdoc IRewardPool\n  uint256 public queuedRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public currentRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public historicalRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewardPerTokenPaid = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewards = 0;\n\n  // --- Init ---\n\n  /**\n   * @param _rewardToken Address of the reward token\n   */\n  constructor(\n    address _rewardToken,\n    address _stakingManager,\n    uint256 _duration,\n    uint256 _newRewardRatio,\n    address _deployer\n  ) Authorizable(msg.sender) validParams {\n    if (_rewardToken == address(0)) revert RewardPool_InvalidRewardToken();\n    rewardToken = IERC20(_rewardToken);\n    _params.stakingManager = _stakingManager;\n    _params.duration = _duration;\n    _params.newRewardRatio = _newRewardRatio;\n    _addAuthorization(_deployer);\n    _addAuthorization(_stakingManager);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IRewardPool\n  function lastTimeRewardApplicable() public view returns (uint256 _lastTime) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  /// @inheritdoc IRewardPool\n  function stake(uint256 _wad) external updateReward isAuthorized {\n    if (_wad == 0) revert RewardPool_StakeNullAmount();\n    _totalStaked += _wad;\n    emit RewardPoolStaked(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function increaseStake(uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_IncreaseStakeNullAmount();\n    _totalStaked += _wad;\n    emit RewardPoolIncreaseStake(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function decreaseStake(uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_DecreaseStakeNullAmount();\n    if (_wad > _totalStaked) revert RewardPool_InsufficientBalance();\n    _totalStaked -= _wad;\n    emit RewardPoolDecreaseStake(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function withdraw(uint256 _wad, bool _claim) external updateReward isAuthorized {\n    if (_wad == 0) revert RewardPool_WithdrawNullAmount();\n    if (_wad > _totalStaked) revert RewardPool_InsufficientBalance();\n    if (_claim) {\n      _getReward();\n    }\n    _totalStaked -= _wad;\n    emit RewardPoolWithdrawn(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function getReward() external updateReward isAuthorized {\n    _getReward();\n  }\n\n  function _getReward() internal {\n    uint256 _reward = earned();\n    if (_reward > 0) {\n      rewards = 0;\n      rewardToken.safeTransfer(_params.stakingManager, _reward);\n      emit RewardPoolRewardPaid(_params.stakingManager, _reward);\n    }\n  }\n\n  /// @inheritdoc IRewardPool\n  function rewardPerToken() public view returns (uint256 _rewardPerToken) {\n    if (_totalStaked == 0) return rewardPerTokenStored;\n    uint256 _timeElapsed = lastTimeRewardApplicable() - lastUpdateTime;\n    return rewardPerTokenStored + ((_timeElapsed * rewardRate * 1e18) / _totalStaked);\n  }\n\n  /// @inheritdoc IRewardPool\n  function earned() public view returns (uint256 _earned) {\n    return ((_totalStaked * (rewardPerToken() - rewardPerTokenPaid)) / 1e18) + rewards;\n  }\n\n  /// @inheritdoc IRewardPool\n  function queueNewRewards(uint256 _rewardsToQueue) external isAuthorized {\n    uint256 _totalRewards = _rewardsToQueue + queuedRewards;\n\n    if (block.timestamp >= periodFinish) {\n      notifyRewardAmount(_totalRewards);\n      queuedRewards = 0;\n      return;\n    }\n\n    uint256 _elapsedTime = block.timestamp - (periodFinish - _params.duration);\n    uint256 _currentAtNow = rewardRate * _elapsedTime;\n    uint256 _queuedRatio = (_currentAtNow * 1000) / _totalRewards;\n\n    if (_queuedRatio < _params.newRewardRatio) {\n      notifyRewardAmount(_totalRewards);\n      queuedRewards = 0;\n    } else {\n      queuedRewards = _totalRewards;\n    }\n  }\n\n  /// @inheritdoc IRewardPool\n  function notifyRewardAmount(uint256 _reward) public updateReward isAuthorized {\n    if (_reward == 0) revert RewardPool_InvalidRewardAmount();\n    historicalRewards = historicalRewards + _reward;\n    if (block.timestamp >= periodFinish) {\n      rewardRate = _reward / _params.duration;\n    } else {\n      uint256 _remaining = periodFinish - block.timestamp;\n      uint256 _leftover = _remaining * rewardRate;\n      _reward = _reward + _leftover;\n      rewardRate = _reward / _params.duration;\n    }\n    currentRewards = _reward;\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp + _params.duration;\n    emit RewardPoolRewardAdded(_reward);\n  }\n\n  /// @inheritdoc IRewardPool\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_WithdrawNullAmount();\n    IERC20(rewardToken).safeTransfer(_rescueReceiver, _wad);\n    emit RewardPoolEmergencyWithdrawal(msg.sender, _wad);\n  }\n\n  function updateRewardHelper() public updateReward isAuthorized {\n    // Empty function that just applies the modifier\n  }\n\n  // --- Modifiers ---\n\n  modifier updateReward() {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (msg.sender == _params.stakingManager) {\n      rewards = earned();\n      rewardPerTokenPaid = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    if (_param == 'stakingManager') {\n      _params.stakingManager = _data.toAddress();\n    } else if (_param == 'duration') {\n      _params.duration = _data.toUint256();\n    } else if (_param == 'newRewardRatio') {\n      _params.newRewardRatio = _data.toUint256();\n    } else {\n      revert UnrecognizedParam();\n    }\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    _params.duration.assertNonNull().assertGt(0);\n    _params.newRewardRatio.assertNonNull().assertGt(0);\n    address(_params.stakingManager).assertHasCode();\n  }\n}\n"
    }
}