{
    "vfp_id": "vfp_00063",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-128"
                ]
            },
            "title": "Potential overflow when applying delta to Reserves",
            "description": "In Reserves.sol, the applyDelta() function performs unchecked additions when delta values are negative (i.e., adding liquidity). Specifically, lines 104 and 118 add uint128(-d0) and uint128(-d1) without overflow checks, which can wrap around due to the unchecked block. This could result in underflow-like behavior where large negative deltas cause the reserve values to wrap to near-zero, corrupting the reserve state. This could be exploited to manipulate prices, drain funds, or cause denial of service in critical operations.\n",
            "severity": "Medium",
            "location": [
                "Reserves.sol#L104",
                "Reserves.sol#L118"
            ],
            "files": [
                "likwid-margin/src/types/Reserves.sol"
            ]
        }
    ],
    "affected_files": {
        "Reserves.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Math} from \"../libraries/Math.sol\";\nimport {FixedPoint96} from \"../libraries/FixedPoint96.sol\";\nimport {BalanceDelta} from \"./BalanceDelta.sol\";\n\n/// @dev Two `uint128` values packed into a single `uint256` where the upper 128 bits represent reserve0\n/// and the lower 128 bits represent reserve1.\ntype Reserves is uint256;\n\nusing ReservesLibrary for Reserves global;\n\n/// @notice Creates a Reserves object from two uint128 values.\n/// @param _reserve0 The value for the upper 128 bits.\n/// @param _reserve1 The value for the lower 128 bits.\n/// @return A Reserves object.\nfunction toReserves(uint128 _reserve0, uint128 _reserve1) pure returns (Reserves) {\n    return Reserves.wrap((uint256(_reserve0) << 128) | _reserve1);\n}\n\nenum ReservesType {\n    REAL,\n    MIRROR,\n    PAIR,\n    LEND\n}\n\n/// @notice A library for handling the Reserves type, which packs two uint128 values into a single uint256.\nlibrary ReservesLibrary {\n    struct UpdateParam {\n        ReservesType _type;\n        BalanceDelta delta;\n    }\n\n    error NotEnoughReserves();\n\n    error InvalidReserves();\n\n    /// @notice Retrieves the reserve0 value from a Reserves object.\n    /// @param self The Reserves object.\n    /// @return The reserve0 value (upper 128 bits).\n    function reserve0(Reserves self) internal pure returns (uint128) {\n        return uint128(Reserves.unwrap(self) >> 128);\n    }\n\n    /// @notice Retrieves the reserve1 value from a Reserves object.\n    /// @param self The Reserves object.\n    /// @return The reserve1 value (lower 128 bits).\n    function reserve1(Reserves self) internal pure returns (uint128) {\n        return uint128(Reserves.unwrap(self));\n    }\n\n    /// @notice Retrieves one of the reserves based on a boolean flag.\n    /// @param self The Reserves object.\n    /// @param forOne If true, returns reserve1; otherwise, returns reserve0.\n    /// @return The selected reserve value.\n    function reserve01(Reserves self, bool forOne) internal pure returns (uint128) {\n        return forOne ? self.reserve1() : self.reserve0();\n    }\n\n    /// @notice Retrieves both reserve values from a Reserves object.\n    /// @param self The Reserves object.\n    /// @return _reserve0 The reserve0 value.\n    /// @return _reserve1 The reserve1 value.\n    function reserves(Reserves self) internal pure returns (uint128 _reserve0, uint128 _reserve1) {\n        _reserve0 = self.reserve0();\n        _reserve1 = self.reserve1();\n    }\n\n    /// @notice Updates the reserve0 value in a Reserves object.\n    /// @param self The Reserves object to update.\n    /// @param newReserve0 The new value for reserve0.\n    /// @return The updated Reserves object.\n    function updateReserve0(Reserves self, uint128 newReserve0) internal pure returns (Reserves) {\n        return toReserves(newReserve0, self.reserve1());\n    }\n\n    /// @notice Updates the reserve1 value in a Reserves object.\n    /// @param self The Reserves object to update.\n    /// @param newReserve1 The new value for reserve1.\n    /// @return The updated Reserves object.\n    function updateReserve1(Reserves self, uint128 newReserve1) internal pure returns (Reserves) {\n        return toReserves(self.reserve0(), newReserve1);\n    }\n\n    function applyDelta(Reserves self, BalanceDelta delta, bool enableOverflow) internal pure returns (Reserves) {\n        (uint128 r0, uint128 r1) = self.reserves();\n        int128 d0 = delta.amount0();\n        int128 d1 = delta.amount1();\n\n        unchecked {\n            if (d0 > 0) {\n                uint128 amount0 = uint128(d0);\n                if (r0 < amount0) {\n                    if (enableOverflow) {\n                        r0 = amount0;\n                    } else {\n                        revert NotEnoughReserves();\n                    }\n                }\n                r0 -= amount0;\n            } else if (d0 < 0) {\n                r0 += uint128(-d0);\n            }\n\n            if (d1 > 0) {\n                uint128 amount1 = uint128(d1);\n                if (r1 < amount1) {\n                    if (enableOverflow) {\n                        r1 = amount1;\n                    } else {\n                        revert NotEnoughReserves();\n                    }\n                }\n                r1 -= amount1;\n            } else if (d1 < 0) {\n                r1 += uint128(-d1);\n            }\n        }\n\n        return toReserves(r0, r1);\n    }\n\n    /// @notice Applies a balance delta to the reserves.\n    /// @param self The Reserves object.\n    /// @param delta The balance delta to apply.\n    /// @return The updated Reserves object.\n    function applyDelta(Reserves self, BalanceDelta delta) internal pure returns (Reserves) {\n        return applyDelta(self, delta, false);\n    }\n\n    /// @notice Calculates the price of token0 in terms of token1, scaled by Q96.\n    /// @param self The Reserves object.\n    /// @return The price of token0, scaled by Q96.\n    function getPrice0X96(Reserves self) internal pure returns (uint256) {\n        (uint128 r0, uint128 r1) = self.reserves();\n        if (r0 == 0 || r1 == 0) revert InvalidReserves();\n        return Math.mulDiv(r1, FixedPoint96.Q96, r0);\n    }\n\n    /// @notice Calculates the price of token1 in terms of token0, scaled by Q96.\n    /// @param self The Reserves object.\n    /// @return The price of token1, scaled by Q96.\n    function getPrice1X96(Reserves self) internal pure returns (uint256) {\n        (uint128 r0, uint128 r1) = self.reserves();\n        if (r0 == 0 || r1 == 0) revert InvalidReserves();\n        return Math.mulDiv(r0, FixedPoint96.Q96, r1);\n    }\n\n    /// @notice Checks if both reserves are positive.\n    /// @param self The Reserves object.\n    /// @return True if both reserves are positive, false otherwise.\n    function bothPositive(Reserves self) internal pure returns (bool) {\n        (uint128 r0, uint128 r1) = self.reserves();\n        return r0 > 0 && r1 > 0;\n    }\n}\n"
    }
}