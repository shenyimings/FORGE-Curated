{
    "vfp_id": "vfp_00153",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "FERC20 onlyOwner functions are unreachable",
            "description": "The FERC20 token, when deployed via the Bonding contract, transfers ownership to the Bonding contract itself in the constructor, but there is no mechanism for the original deployer or owner to invoke owner-only functions such as updateMaxTx or excludeFromMaxTx. The root cause is the absence of wrapper functions in the Bonding contract to forward these calls. This renders critical configuration functions inaccessible, making it impossible to adjust transaction limits or exclude addresses post-deployment. While the impact is mitigated by the fact that these features are currently unused (as acknowledged by the team), the vulnerability remains in the design. An attacker cannot directly exploit this, but it reduces protocol flexibility and could lead to operational issues if owner functions are needed in the future.\n",
            "severity": "Medium",
            "location": [
                "FERC20.sol#33"
            ],
            "files": [
                "protocol-contracts/contracts/fun/FERC20.sol"
            ]
        }
    ],
    "affected_files": {
        "FERC20.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract FERC20 is Context, IERC20, Ownable {\n    uint8 private constant _decimals = 18;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n\n    string private _symbol;\n\n    uint public maxTx;\n\n    uint256 private _maxTxAmount;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(address => bool) private isExcludedFromMaxTx;\n\n    event MaxTxUpdated(uint _maxTx);\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 supply,\n        uint _maxTx\n    ) Ownable(msg.sender) {\n        _name = name_;\n\n        _symbol = symbol_;\n\n        _totalSupply = supply * 10 ** _decimals;\n\n        _balances[_msgSender()] = _totalSupply;\n\n        isExcludedFromMaxTx[_msgSender()] = true;\n\n        isExcludedFromMaxTx[address(this)] = true;\n\n        _updateMaxTx(_maxTx);\n\n        emit Transfer(address(0), _msgSender(), _totalSupply);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()] - amount\n        );\n\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (!isExcludedFromMaxTx[from]) {\n            require(amount <= _maxTxAmount, \"Exceeds MaxTx\");\n        }\n\n        _balances[from] = _balances[from] - amount;\n        _balances[to] = _balances[to] + amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n    function _updateMaxTx(uint _maxTx) internal {\n        maxTx = _maxTx;\n        _maxTxAmount = (maxTx * _totalSupply) / 100;\n\n        emit MaxTxUpdated(_maxTx);\n    }\n\n    function updateMaxTx(uint256 _maxTx) public onlyOwner {\n        _updateMaxTx(_maxTx);\n    }\n\n    function excludeFromMaxTx(address user) public onlyOwner {\n        require(\n            user != address(0),\n            \"ERC20: Exclude Max Tx from the zero address\"\n        );\n\n        isExcludedFromMaxTx[user] = true;\n    }\n\n    function _burn(address user, uint256 amount) internal {\n        require(user != address(0), \"Invalid address\");\n        _balances[user] = _balances[user] - amount;\n    }\n\n    function burnFrom(address user, uint256 amount) public onlyOwner {\n        require(user != address(0), \"Invalid address\");\n        _balances[user] = _balances[user] - amount;\n        emit Transfer(user, address(0), amount);\n    }\n}\n"
    }
}