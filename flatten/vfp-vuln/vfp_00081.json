{
    "vfp_id": "vfp_00081",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Net repayments can be counted across multiple solverOps",
            "description": "1. **Description:** The _isBalanceReconciled() function in GasAccounting.sol incorrectly considers a solverOp's balance as reconciled when multipleSuccessfulSolvers == true, because it does not track how much of the net repayment has already been used by previous solverOps.\n2. **Cause:** The logic allows the same net repayment to be reused across multiple solverOps, as it does not deduct used repayments from a shared pool.\n3. **Exploitation:** An attacker could construct multiple solverOps that each claim the same net repayment, falsely satisfying the reconciliation check.\n4. **Impact:** This can result in a gas reimbursement shortfall during the final settle() call, forcing the bundler to cover the difference, potentially leading to financial loss.\n",
            "severity": "Medium",
            "location": [
                "GasAccounting.sol#L605"
            ],
            "files": [
                "atlas/src/contracts/atlas/GasAccounting.sol"
            ]
        }
    ],
    "affected_files": {
        "GasAccounting.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\nimport { SafeCast } from \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport { SafetyLocks } from \"./SafetyLocks.sol\";\nimport { EscrowBits } from \"../libraries/EscrowBits.sol\";\nimport { AccountingMath } from \"../libraries/AccountingMath.sol\";\nimport { GasAccLib, GasLedger, BorrowsLedger } from \"../libraries/GasAccLib.sol\";\nimport { SolverOperation } from \"../types/SolverOperation.sol\";\nimport { DAppConfig } from \"../types/ConfigTypes.sol\";\nimport { IL2GasCalculator } from \"../interfaces/IL2GasCalculator.sol\";\nimport \"../types/EscrowTypes.sol\";\nimport \"../types/LockTypes.sol\";\n\n/// @title GasAccounting\n/// @author FastLane Labs\n/// @notice GasAccounting manages the accounting of gas surcharges and escrow balances for the Atlas protocol.\nabstract contract GasAccounting is SafetyLocks {\n    using EscrowBits for uint256;\n    using AccountingMath for uint256;\n    using SafeCast for uint256;\n    using GasAccLib for uint256;\n    using GasAccLib for GasLedger;\n    using GasAccLib for BorrowsLedger;\n    using FixedPointMathLib for uint256;\n\n    constructor(\n        uint256 escrowDuration,\n        uint256 atlasSurchargeRate,\n        address verification,\n        address simulator,\n        address initialSurchargeRecipient,\n        address l2GasCalculator\n    )\n        SafetyLocks(escrowDuration, atlasSurchargeRate, verification, simulator, initialSurchargeRecipient, l2GasCalculator)\n    { }\n\n    /// @notice Sets the initial gas accounting values for the metacall transaction in transient storage.\n    /// @dev Resets `t_gasLedger`, `t_borrowsLedger`, `t_solverLock`, and `t_solverTo` at the start of each metacall.\n    ///      Initializes `remainingMaxGas` with the overall gas estimate and `unreachedSolverGas` with the precalculated\n    ///      gas for all potential solver operations. Sets initial `repays` based on `msg.value`.\n    /// @param gasMarker The gas measurement at the start of the metacall, which includes Execution gas limits, Calldata\n    /// gas costs, and an additional buffer for safety.\n    /// @param allSolverOpsGas The sum of (C + E) gas limits for all solverOps in the metacall.\n    function _initializeAccountingValues(\n        uint256 gasMarker,\n        uint256 allSolverOpsGas,\n        uint24 bundlerSurchargeRate\n    )\n        internal\n    {\n        t_gasLedger = GasLedger({\n            remainingMaxGas: uint40(gasMarker),\n            writeoffsGas: 0,\n            solverFaultFailureGas: 0,\n            unreachedSolverGas: uint40(allSolverOpsGas),\n            maxApprovedGasSpend: 0,\n            atlasSurchargeRate: _atlasSurchargeRate(),\n            bundlerSurchargeRate: bundlerSurchargeRate\n        }).pack();\n\n        // If any native token sent in the metacall, add to the repays account\n        t_borrowsLedger = BorrowsLedger({ borrows: 0, repays: uint128(msg.value) }).pack();\n\n        t_solverLock = 0;\n        t_solverTo = address(0);\n\n        // The Lock slot is cleared at the end of the metacall, so no need to zero again here.\n    }\n\n    /// @notice Contributes ETH to the contract, increasing the deposits if a non-zero value is sent.\n    function contribute() external payable {\n        address _activeEnv = _activeEnvironment();\n        if (_activeEnv != msg.sender) revert InvalidExecutionEnvironment(_activeEnv);\n        _contribute();\n    }\n\n    /// @notice Borrows ETH from the contract, transferring the specified amount to the caller if available.\n    /// @dev Borrowing is only available until the end of the SolverOperation phase, for solver protection.\n    /// @param amount The amount of ETH to borrow.\n    function borrow(uint256 amount) external {\n        if (amount == 0) return;\n\n        // borrow() can only be called by the Execution Environment (by delegatecalling a DAppControl hook), and only\n        // during or before the SolverOperation phase.\n        (address _activeEnv,, uint8 _currentPhase) = _lock();\n        if (_activeEnv != msg.sender) revert InvalidExecutionEnvironment(_activeEnv);\n        if (_currentPhase > uint8(ExecutionPhase.SolverOperation)) revert WrongPhase();\n\n        // borrow() will revert if called after solver calls reconcile()\n        (, bool _calledBack,) = _solverLockData();\n        if (_calledBack) revert WrongPhase();\n\n        if (_borrow(amount)) {\n            SafeTransferLib.safeTransferETH(msg.sender, amount);\n        } else {\n            revert InsufficientAtlETHBalance(address(this).balance, amount);\n        }\n    }\n\n    /// @notice Calculates the current shortfall currently owed by the winning solver.\n    /// @dev The shortfall is calculated `(claims + withdrawals + fees - writeoffs) - deposits`. If this value is less\n    /// than zero, shortfall returns 0 as there is no shortfall because the solver is in surplus.\n    /// @return gasLiability The total gas charge (base + surcharges) owed by the solver. Can be repaid using bonded\n    /// balance or native token.\n    /// @return borrowLiability The total value of ETH borrowed but not yet repaid, only repayable using native token.\n    function shortfall() external view returns (uint256 gasLiability, uint256 borrowLiability) {\n        gasLiability = t_gasLedger.toGasLedger().solverGasLiability();\n\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        borrowLiability = (_bL.borrows < _bL.repays) ? 0 : _bL.borrows - _bL.repays;\n    }\n\n    /// @notice Allows a solver to settle any outstanding ETH owed, either to repay gas used by their solverOp or to\n    /// repay any ETH borrowed from Atlas. This debt can be paid either by sending ETH when calling this function\n    /// (msg.value) or by approving Atlas to use a certain amount of the solver's bonded AtlETH.\n    /// @param maxApprovedGasSpend The maximum amount of the solver's bonded AtlETH that Atlas can deduct to cover the\n    /// solver's debt.\n    /// @return owed The gas and borrow liability owed by the solver. The full gasLiability + borrowLiability amount is\n    /// returned, unless the fulfilled, in which case 0 is returned.\n    /// @dev The solver can call this function multiple times until the owed amount is zero.\n    /// @dev Note: `reconcile()` must be called by the solver to avoid a `CallbackNotCalled` error in `solverCall()`.\n    function reconcile(uint256 maxApprovedGasSpend) external payable returns (uint256 owed) {\n        // NOTE: maxApprovedGasSpend is the amount of the solver's atlETH that the solver is allowing\n        // to be used to cover what they owe. Assuming they're successful, a value up to this amount\n        // will be subtracted from the solver's bonded AtlETH during _settle().\n\n        // NOTE: After reconcile is called for the first time by the solver, neither the claims nor the borrows values\n        // can be increased.\n\n        // NOTE: While anyone can call this function, it can only be called in the SolverOperation phase. Because Atlas\n        // calls directly to the solver contract in this phase, the solver should be careful to not call malicious\n        // contracts which may call reconcile() on their behalf, with an excessive maxApprovedGasSpend.\n        if (_phase() != uint8(ExecutionPhase.SolverOperation)) revert WrongPhase();\n        if (msg.sender != t_solverTo) revert InvalidAccess();\n\n        (address _currentSolver, bool _calledBack,) = _solverLockData();\n        uint256 _bondedBalance = uint256(S_accessData[_currentSolver].bonded);\n\n        // Solver can only approve up to their bonded balance, not more\n        if (maxApprovedGasSpend > _bondedBalance) maxApprovedGasSpend = _bondedBalance;\n\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n\n        uint256 _borrows = _bL.borrows; // total native borrows\n        uint256 _repays = _bL.repays; // total native repayments of borrows\n        uint256 _maxGasLiability = _gL.solverGasLiability(); // max gas liability of winning solver\n\n        // Store update to repays in t_borrowLedger, if any msg.value sent\n        if (msg.value > 0) {\n            _repays += msg.value;\n            _bL.repays = _repays.toUint128();\n            t_borrowsLedger = _bL.pack();\n        }\n\n        // Store solver's maxApprovedGasSpend for use in the _isBalanceReconciled() check\n        if (maxApprovedGasSpend > 0) {\n            // Convert maxApprovedGasSpend from wei (native token) units to gas units\n            _gL.maxApprovedGasSpend = uint40(maxApprovedGasSpend / tx.gasprice);\n            t_gasLedger = _gL.pack();\n        }\n\n        // Check if fullfilled:\n        // - native borrows must be repaid (using only native token)\n        // - gas liabilities must be repaid (using bonded AtlETH or native token)\n\n        if (_borrows > _repays) {\n            if (!_calledBack) t_solverLock = (uint256(uint160(_currentSolver)) | _SOLVER_CALLED_BACK_MASK);\n            return _maxGasLiability + (_borrows - _repays);\n        } else {\n            uint256 _excess = _repays - _borrows;\n            if (maxApprovedGasSpend + _excess < _maxGasLiability) {\n                if (!_calledBack) t_solverLock = (uint256(uint160(_currentSolver)) | _SOLVER_CALLED_BACK_MASK);\n                return _maxGasLiability - _excess;\n            }\n        }\n\n        // If we get here, native borrows have been repaid, and enough approved to cover gas liabilities\n        t_solverLock = (uint256(uint160(_currentSolver)) | _SOLVER_CALLED_BACK_MASK | _SOLVER_FULFILLED_MASK);\n        return 0;\n    }\n\n    /// @notice Internal function to handle ETH contribution, increasing deposits if a non-zero value is sent.\n    function _contribute() internal {\n        if (msg.value == 0) return;\n\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        _bL.repays += msg.value.toUint128();\n        t_borrowsLedger = _bL.pack();\n    }\n\n    /// @notice Borrows ETH from the contract, transferring the specified amount to the caller if available.\n    /// @dev Borrowing should never be allowed after the SolverOperation phase, for solver safety. This is enforced in\n    /// the external `borrow` function, and the only other time this internal `_borrow` function is called is in\n    /// `_solverOpInner` which happens at the beginning of the SolverOperation phase.\n    /// @param amount The amount of ETH to borrow.\n    /// @return valid A boolean indicating whether the borrowing operation was successful.\n    function _borrow(uint256 amount) internal returns (bool valid) {\n        if (amount == 0) return true;\n        if (address(this).balance < amount) return false;\n\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        _bL.borrows += amount.toUint128();\n        t_borrowsLedger = _bL.pack();\n\n        return true;\n    }\n\n    /// @notice Takes AtlETH from the owner's bonded balance and, if necessary, from the owner's unbonding balance.\n    /// @dev No GasLedger accounting changes are made in this function - should be done separately.\n    /// @param accountData The EscrowAccountAccessData memory struct of the account being charged.\n    /// @param account The address of the account from which AtlETH is taken.\n    /// @param amount The amount of AtlETH to be taken.\n    /// @return deficit The amount of AtlETH that was not repaid, if any.\n    function _assign(\n        EscrowAccountAccessData memory accountData,\n        address account,\n        uint256 amount\n    )\n        internal\n        returns (uint256 deficit)\n    {\n        uint112 _amt = amount.toUint112();\n\n        if (_amt > accountData.bonded) {\n            // The bonded balance does not cover the amount owed. Check if there is enough unbonding balance to\n            // make up for the missing difference. If not, there is a deficit. Atlas does not consider drawing from\n            // the regular AtlETH balance (not bonded nor unbonding) to cover the remaining deficit because it is\n            // not meant to be used within an Atlas transaction, and must remain independent.\n\n            EscrowAccountBalance memory _bData = s_balanceOf[account];\n            uint256 _total = uint256(_bData.unbonding) + uint256(accountData.bonded);\n\n            if (_amt > _total) {\n                // The unbonding balance is insufficient to cover the remaining amount owed. There is a deficit. Set\n                // both bonded and unbonding balances to 0 and adjust the \"amount\" variable to reflect the amount\n                // that was actually deducted.\n                deficit = amount - _total;\n\n                s_balanceOf[account].unbonding = 0;\n                accountData.bonded = 0;\n                amount -= deficit; // Set amount equal to total to accurately track the changing bondedTotalSupply\n            } else {\n                // The unbonding balance is sufficient to cover the remaining amount owed. Draw everything from the\n                // bonded balance, and adjust the unbonding balance accordingly.\n                s_balanceOf[account].unbonding = _total.toUint112() - _amt;\n                accountData.bonded = 0;\n            }\n        } else {\n            // The bonded balance is sufficient to cover the amount owed.\n            accountData.bonded -= _amt;\n        }\n\n        S_bondedTotalSupply -= amount;\n\n        // update lastAccessedBlock since bonded balance is decreasing\n        accountData.lastAccessedBlock = uint32(block.number);\n        // NOTE: accountData changes must be persisted to storage separately\n    }\n\n    /// @notice Increases the owner's bonded balance by the specified amount.\n    /// @param accountData The EscrowAccountAccessData memory struct of the account being credited.\n    /// @param amount The amount by which to increase the owner's bonded balance.\n    function _credit(EscrowAccountAccessData memory accountData, uint256 amount) internal {\n        accountData.bonded += SafeCast.toUint112(amount);\n        S_bondedTotalSupply += amount;\n        // NOTE: accountData changes must be persisted to storage separately\n    }\n\n    /// @notice Accounts for the gas cost of a failed SolverOperation, either by increasing writeoffs (if the bundler is\n    /// blamed for the failure) or by assigning the gas cost to the solver's bonded AtlETH balance (if the solver is\n    /// blamed for the failure).\n    /// @param solverOp The current SolverOperation for which to account.\n    /// @param dConfigSolverGasLimit The gas limit for the solver operation, as specified in the DAppConfig.\n    /// @param gasWaterMark The `gasleft()` watermark taken at the start of executing the SolverOperation.\n    /// @param result The result bitmap of the SolverOperation execution.\n    /// @param exPostBids A boolean indicating whether exPostBids is set to true in the current metacall.\n    function _handleSolverFailAccounting(\n        SolverOperation calldata solverOp,\n        uint256 dConfigSolverGasLimit,\n        uint256 gasWaterMark,\n        uint256 result,\n        bool exPostBids\n    )\n        internal\n    {\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n\n        // Solvers do not pay for calldata gas in exPostBids mode.\n        uint256 _calldataGas;\n        if (!exPostBids) {\n            _calldataGas = GasAccLib.solverOpCalldataGas(solverOp.data.length, L2_GAS_CALCULATOR);\n        }\n\n        // Solver execution max gas is calculated as solverOp.gas, with a max of dConfig.solverGasLimit\n        uint256 _executionMaxGas = (solverOp.gas > dConfigSolverGasLimit) ? dConfigSolverGasLimit : solverOp.gas;\n\n        // Deduct solver's max (C + E) gas from remainingMaxGas, for future solver gas liability calculations\n        _gL.remainingMaxGas -= uint40(_executionMaxGas + _calldataGas);\n\n        uint256 _gasUsed = _calldataGas + (gasWaterMark - gasleft());\n\n        // Calculate what the solver owes\n        // NOTE: This will cause an error if you are simulating with a gasPrice of 0\n        if (result.bundlersFault()) {\n            // CASE: Solver is not responsible for the failure of their operation, so we blame the bundler\n            // and reduce the total amount refunded to the bundler\n            _gasUsed += _BUNDLER_FAULT_OFFSET;\n            _gL.writeoffsGas += uint40(_gasUsed);\n        } else {\n            // CASE: Solver failed, so we calculate what they owe.\n            _gasUsed += _SOLVER_FAULT_OFFSET;\n            uint256 _gasValueWithSurcharges = _gasUsed.withSurcharge(_gL.totalSurchargeRate()) * tx.gasprice;\n\n            EscrowAccountAccessData memory _solverAccountData = S_accessData[solverOp.from];\n\n            // In `_assign()`, the solver's bonded AtlETH balance is reduced by `_gasValueWithSurcharges`. Any deficit\n            // from that operation is returned as `_assignDeficit` below. GasLedger is not modified in _assign().\n            uint256 _assignDeficit = _assign(_solverAccountData, solverOp.from, _gasValueWithSurcharges);\n\n            // Solver's analytics updated:\n            // - increment auctionFails\n            // - increase totalGasValueUsed by gas cost + surcharges paid by solver, less any deficit\n            _updateAnalytics(_solverAccountData, false, _gasValueWithSurcharges - _assignDeficit);\n\n            // Persist the updated solver account data to storage\n            S_accessData[solverOp.from] = _solverAccountData;\n\n            if (_assignDeficit > 0) {\n                // If any deficit, calculate the gas units unpaid for due to assign deficit.\n                // Gas units written off = gas used * (deficit / gas value with surcharges) ratio.\n                // `mulDivUp()` rounds in favor of writeoffs, so we don't overestimate gas that was actually paid for\n                // and end up reimbursing the bundler for more than was actually taken from the solvers.\n                uint256 _gasWrittenOff = _gasUsed.mulDivUp(_assignDeficit, _gasValueWithSurcharges);\n\n                // No risk of underflow in subtraction below, because:\n                // _assignDeficit is <= _gasValueWithSurcharges, so _gasWrittenOff is <= _gasUsed.\n\n                // Deduct gas written off from gas tracked as \"paid for\" by failed solver\n                _gasUsed -= _gasWrittenOff;\n                _gL.writeoffsGas += uint40(_gasWrittenOff); // add to writeoffs in gasLedger\n            }\n\n            // The gas paid for here by failed solver, and gas written off due to shortfall in `_assign()`, will offset\n            // what the winning solver owes in `_settle()`.\n            _gL.solverFaultFailureGas += uint40(_gasUsed);\n        }\n\n        // Persist the updated gas ledger to transient storage\n        t_gasLedger = _gL.pack();\n    }\n\n    /// @notice Records the gas used during the `bidFind` phase of exPostBids as a write-off.\n    /// @dev Gas used for `bidFind` is considered an overhead paid by the bundler (via reduced refund)\n    ///      and is not charged to any specific solver. It's added to `writeoffsGas` in the GasLedger.\n    /// @param gasUsed The amount of gas consumed during the `bidFind` phase.\n    function _writeOffBidFindGas(uint256 gasUsed) internal {\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n        _gL.writeoffsGas += uint40(gasUsed);\n        t_gasLedger = _gL.pack();\n    }\n\n    /// @notice Charges solvers that were not reached during the metacall for the calldata gas cost of their solverOps.\n    /// @dev Iterates through `solverOps` starting from the index *after* `winningSolverIdx`. For each unreached\n    /// operation, `VERIFICATION.verifySolverOp` is called to determine fault.\n    ///      - If bundler fault: The calldata gas is added to `gL.writeoffsGas` (reducing bundler's refund).\n    ///      - If solver fault: Attempts to charge the solver's bonded `AtlETH` using `_assign` for the calldata\n    ///        gas cost (no surcharges added). Any deficit is added to `gL.writeoffsGas`.\n    ///      The gas cost of executing this loop is also added to `gL.writeoffsGas` to ensure the bundler pays for it.\n    /// @param solverOps The SolverOperation array containing the solvers' transaction data.\n    /// @param gL The GasLedger struct (memory); `gL.writeoffsGas` is updated within this function.\n    /// @param winningSolverIdx Index of the winning/last attempted solver; the loop starts after this index.\n    /// @param userOpHash Hash of the UserOperation, used for verification.\n    /// @param maxFeePerGas userOp.maxFeePerGas, used for verification.\n    /// @param bundler The metacall caller (msg.sender), used for verification.\n    /// @param allowsTrustedOpHash Flag indicating with trustedOpHash is enabled in the metacall.\n    /// @return unreachedCalldataValuePaid Total value successfully charged to unreached solvers (cost - deficits).\n    function _chargeUnreachedSolversForCalldata(\n        SolverOperation[] calldata solverOps,\n        GasLedger memory gL,\n        uint256 winningSolverIdx,\n        bytes32 userOpHash,\n        uint256 maxFeePerGas,\n        address bundler,\n        bool allowsTrustedOpHash\n    )\n        internal\n        returns (uint256 unreachedCalldataValuePaid)\n    {\n        uint256 _writeoffGasMarker = gasleft();\n\n        // Start at the solver after the current solverIdx, because current solverIdx is the winner\n        for (uint256 i = winningSolverIdx + 1; i < solverOps.length; ++i) {\n            address _from = solverOps[i].from;\n            uint256 _calldataGasCost =\n                GasAccLib.solverOpCalldataGas(solverOps[i].data.length, L2_GAS_CALCULATOR) * tx.gasprice;\n\n            // Verify the solverOp, and write off solver's calldata gas if included due to bundler fault\n            uint256 _result =\n                VERIFICATION.verifySolverOp(solverOps[i], userOpHash, maxFeePerGas, bundler, allowsTrustedOpHash);\n\n            if (_result.bundlersFault()) {\n                gL.writeoffsGas += _calldataGasCost.divUp(tx.gasprice).toUint40();\n                continue;\n            }\n\n            // If solverOp inclusion was not bundler fault, charge solver for calldata gas\n            EscrowAccountAccessData memory _solverData = S_accessData[_from];\n\n            // No surcharges added to calldata cost for unreached solvers\n            uint256 _deficit = _assign(_solverData, _from, _calldataGasCost);\n\n            // Persist _assign() changes to solver account data to storage\n            S_accessData[_from] = _solverData;\n\n            // The sum of value paid less deficits is tracked and used in `_settle()`\n            unreachedCalldataValuePaid += _calldataGasCost - _deficit;\n\n            // Any deficits from the `_assign()` operations are converted to gas units and written off so as not to\n            // charge the winning solver for calldata that is not their responsibility, in `_settle()`.\n            if (_deficit > 0) gL.writeoffsGas += _deficit.divUp(tx.gasprice).toUint40();\n        }\n\n        // The gas cost of this loop is always paid by the bundler so as not to charge the winning solver for an\n        // excessive number of loops and SSTOREs via `_assign()`. This gas is therefore added to writeoffs.\n        gL.writeoffsGas += (_writeoffGasMarker - gasleft()).toUint40();\n    }\n\n    /// @notice Finalizes gas accounting at the end of the metacall, settles balances, and pays refunds/surcharges.\n    /// @param ctx The context struct (memory), used for ctx.bundler and ctx.solverSuccessful.\n    /// @param gL The final state of the GasLedger struct (memory), used for gas calculations.\n    /// @param gasMarker The initial gas measurement taken at the start of the metacall.\n    /// @param gasRefundBeneficiary The address designated to receive the bundler's gas refund. Defaults to\n    /// `ctx.bundler`.\n    /// @param unreachedCalldataValuePaid The total value successfully collected from unreached solvers for their\n    /// calldata costs (from `_chargeUnreachedSolversForCalldata`).\n    /// @return claimsPaidToBundler The net amount of ETH transferred to the `gasRefundBeneficiary`.\n    /// @return netAtlasGasSurcharge The net amount of ETH taken as Atlas surcharge during the metacall.\n    function _settle(\n        Context memory ctx,\n        GasLedger memory gL,\n        uint256 gasMarker,\n        address gasRefundBeneficiary,\n        uint256 unreachedCalldataValuePaid,\n        bool multipleSuccessfulSolvers\n    )\n        internal\n        returns (uint256 claimsPaidToBundler, uint256 netAtlasGasSurcharge)\n    {\n        EscrowAccountAccessData memory _winningSolverData;\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        (address _winningSolver,,) = _solverLockData();\n\n        // No need to SLOAD bonded balance etc. if no winning solver\n        if (ctx.solverSuccessful) _winningSolverData = S_accessData[_winningSolver];\n\n        // Send gas refunds to bundler if no gas refund beneficiary specified\n        if (gasRefundBeneficiary == address(0)) gasRefundBeneficiary = ctx.bundler;\n\n        // First check if all borrows have been repaid.\n        // Borrows can only be repaid in native token, not bonded AtlETH.\n        // This is also done at end of solverCall(), so check here only needed for zero solvers case.\n        int256 _netRepayments = _bL.netRepayments();\n        if (_netRepayments < 0) revert BorrowsNotRepaid(_bL.borrows, _bL.repays);\n\n        uint256 _winnerGasCharge;\n        uint256 _gasLeft = gasleft();\n\n        // NOTE: Trivial for bundler to run a different EOA for solver so no bundler == solver carveout.\n        if (ctx.solverSuccessful) {\n            // CASE: Winning solver.\n\n            // Winning solver should pay for:\n            // - Gas (C + E) used by their solverOp\n            // - Gas (C + E) used by userOp, dapp hooks, and other metacall overhead\n            // Winning solver should not pay for:\n            // - Gas (C + E) used by other reached solvers (bundler or solver fault failures)\n            // - Gas (C only) used by unreached solvers\n            // - Gas (E only) used during the bid-finding or unreached solver calldata charge loops\n            _winnerGasCharge = gasMarker - gL.writeoffsGas - gL.solverFaultFailureGas\n                - (unreachedCalldataValuePaid / tx.gasprice) - _gasLeft;\n            uint256 _surchargedGasPaidBySolvers = gL.solverFaultFailureGas + _winnerGasCharge;\n\n            // Bundler gets base gas cost + bundler surcharge of (solver fault fails + winning solver charge)\n            // Bundler also gets reimbursed for the calldata of unreached solvers (only base, no surcharge)\n            claimsPaidToBundler = (_surchargedGasPaidBySolvers.withSurcharge(gL.bundlerSurchargeRate) * tx.gasprice)\n                + unreachedCalldataValuePaid;\n\n            // Atlas gets only the Atlas surcharge of (solver fault fails + winning solver charge)\n            netAtlasGasSurcharge = _surchargedGasPaidBySolvers.getSurcharge(gL.atlasSurchargeRate) * tx.gasprice;\n\n            // Calculate what winning solver pays: add surcharges and multiply by gas price\n            _winnerGasCharge = _winnerGasCharge.withSurcharge(gL.totalSurchargeRate()) * tx.gasprice;\n\n            uint256 _deficit; // Any shortfall that the winning solver is not able to repay from bonded balance\n            if (_winnerGasCharge < uint256(_netRepayments)) {\n                // CASE: solver recieves more than they pay --> net credit to account\n                _credit(_winningSolverData, uint256(_netRepayments) - _winnerGasCharge);\n            } else {\n                // CASE: solver pays more than they recieve --> net assign to account\n                _deficit = _assign(_winningSolverData, _winningSolver, _winnerGasCharge - uint256(_netRepayments));\n            }\n\n            if (_deficit > claimsPaidToBundler) revert AssignDeficitTooLarge(_deficit, claimsPaidToBundler);\n            claimsPaidToBundler -= _deficit;\n\n            _updateAnalytics(_winningSolverData, true, _winnerGasCharge);\n\n            // Persist the updated winning solver account data to storage\n            S_accessData[_winningSolver] = _winningSolverData;\n        } else {\n            // CASE: No winning solver.\n\n            // Bundler may still recover a partial refund (from solver fault failure charges) up to 80% of the gas cost\n            // of the metacall. The remaining 20% could be recovered through storage refunds, and it is important that\n            // metacalls with no winning solver are not profitable for the bundler.\n            // The exception to this rule is when multipleSuccessfulSolvers is set to true. In this case, all solvers\n            // should be able to execute and pay for their own gas + surcharges, but the bundler refund should not be\n            // capped.\n\n            uint256 _maxRefund;\n            if (multipleSuccessfulSolvers) {\n                _maxRefund = type(uint256).max;\n            } else {\n                _maxRefund = (gasMarker - gL.writeoffsGas - _gasLeft).maxBundlerRefund() * tx.gasprice;\n            }\n\n            // Bundler gets (base gas cost + bundler surcharge) of solver fault failures, plus base gas cost of\n            // unreached solver calldata. This is compared to _maxRefund below. Net repayments is added after the 80%\n            // cap has been applied to the gas refund components.\n            // `unreachedCalldataValuePaid` is not added here as it should always be 0 when solverSuccessful = false,\n            // because there should then be no unreached solvers.\n            uint256 _bundlerCutBeforeLimit =\n                uint256(gL.solverFaultFailureGas).withSurcharge(gL.bundlerSurchargeRate) * tx.gasprice;\n\n            // Atlas only keeps the Atlas surcharge of solver fault failures, and any gas due to bundler that exceeds\n            // the 80% limit.\n            netAtlasGasSurcharge = uint256(gL.solverFaultFailureGas).getSurcharge(gL.atlasSurchargeRate) * tx.gasprice;\n\n            if (_bundlerCutBeforeLimit > _maxRefund) {\n                // More than max gas refund was taken by failed/unreached solvers, excess goes to Atlas\n                claimsPaidToBundler = _maxRefund;\n                netAtlasGasSurcharge += _bundlerCutBeforeLimit - _maxRefund;\n            } else {\n                // Otherwise, the bundler can receive the full solver fault failure gas\n                claimsPaidToBundler = _bundlerCutBeforeLimit;\n            }\n\n            // Finally, add any net repayments, which should not be subject to the 80% cap, to the bundler's claims\n            claimsPaidToBundler += uint256(_netRepayments);\n        }\n\n        S_cumulativeSurcharge += netAtlasGasSurcharge;\n\n        // Set lock to FullyLocked to prevent any reentrancy possibility in refund transfer below\n        _setLockPhase(uint8(ExecutionPhase.FullyLocked));\n\n        if (claimsPaidToBundler != 0) SafeTransferLib.safeTransferETH(gasRefundBeneficiary, claimsPaidToBundler);\n    }\n\n    /// @notice Updates auctionWins, auctionFails, and totalGasUsed values of a solver's EscrowAccountAccessData.\n    /// @dev This function is only ever called in the context of bidFind = false so no risk of doublecounting changes.\n    /// @param aData The Solver's EscrowAccountAccessData struct to update.\n    /// @param auctionWon A boolean indicating whether the solver's solverOp won the auction.\n    /// @param gasValueUsed The ETH value of gas used by the solverOp. Should be calculated as gasUsed * tx.gasprice.\n    function _updateAnalytics(\n        EscrowAccountAccessData memory aData,\n        bool auctionWon,\n        uint256 gasValueUsed\n    )\n        internal\n        pure\n    {\n        if (auctionWon) {\n            unchecked {\n                ++aData.auctionWins;\n            }\n        } else {\n            unchecked {\n                ++aData.auctionFails;\n            }\n        }\n\n        // Track total ETH value of gas spent by solver in metacalls. Measured in gwei (1e9 digits truncated).\n        aData.totalGasValueUsed += SafeCast.toUint64(gasValueUsed / _GAS_VALUE_DECIMALS_TO_DROP);\n    }\n\n    /// @notice Checks all obligations have been reconciled: native borrows AND gas liabilities.\n    /// @return True if both dimensions are reconciled, false otherwise.\n    function _isBalanceReconciled() internal view returns (bool) {\n        GasLedger memory gL = t_gasLedger.toGasLedger();\n        BorrowsLedger memory bL = t_borrowsLedger.toBorrowsLedger();\n\n        // DApp's excess repayments via `contribute()` can offset solverGasLiability\n        uint256 _netRepayments;\n        if (bL.repays > bL.borrows) _netRepayments = bL.repays - bL.borrows;\n\n        // gL.maxApprovedGasSpend only stores the gas units, must be scaled by tx.gasprice\n        uint256 _maxApprovedGasValue = gL.maxApprovedGasSpend * tx.gasprice;\n\n        return (bL.repays >= bL.borrows) && (_maxApprovedGasValue + _netRepayments >= gL.solverGasLiability());\n    }\n}\n"
    }
}