{
    "vfp_id": "vfp_00081",
    "project_name": "Spectral (Autonomus Agents Contracts) - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-348"
                ]
            },
            "title": "Incorrect Token Symbol Check Leads to Bypassing Special Distribution Logic",
            "description": "The transferTradingRewards function in OctoDistributor.sol checks for the token symbol \"SPECTRA\" using a keccak256 hash comparison to determine whether to apply special distribution logic. However, the actual Spectral token (0x96419929d7949D6A801A6909c145C8EEf6A40431) uses the symbol \"SPEC\", causing the condition to always fail. This results in the fallback to generic distribution logic (20% treasury, 80% creator) instead of the intended special logic (20% treasury, 20% spectra wallet, 60% employees). The root cause is the incorrect assumption about the token symbol rather than using a secure address-based check. An attacker could exploit this by deploying a malicious token with the symbol \"SPECTRA\" to trigger the special distribution rules illegitimately. The impact includes incorrect fund allocation and potential manipulation of the reward distribution mechanism, leading to financial loss or unfair advantages.\n",
            "severity": "High",
            "location": [
                "OctoDistributor.sol::transferTradingRewards"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "The bonus amount of Agent tokens is not calculated correctly",
            "description": "When transferring Agent tokens to the AgenticCompany contract, a fee-on-transfer mechanism is applied, meaning the actual received amount is less than the requested transfer amount due to a tax. However, the _depositHiringBonuses function in AgenticCompany.sol increases the hiringBonusAgentToken by the full agentTokenAmount without accounting for this tax. This discrepancy leads to an overstatement of available tokens for distribution. Similarly, the transferHiringDistributions function in OctoDistributor.sol assumes the full amount is received, but it does not verify the actual balance change after transfer. The root cause is the lack of post-transfer balance validation when handling fee-on-transfer tokens. An attacker or user could exploit this by triggering distributions where the contract lacks sufficient tokens to fulfill obligations, resulting in failed transactions or shortfalls during bonus payouts. The impact is operational disruption and potential loss of user trust due to failed or incorrect bonus distributions.\n",
            "severity": "High",
            "location": [
                "AgenticCompany.sol::_depositHiringBonuses#553-556",
                "OctoDistributor.sol::transferHiringDistributions#325"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "The OctoDistributor doesn't work when the agent token is set to address(0)",
            "description": "The OctoDistributor contract reverts when the agentToken parameter is address(0) due to a require statement in the transferHiringDistributions function. However, the AgenticCompany contract allows agentToken to be address(0) in certain cases, such as during company creation or dissolution, and handles it with conditional logic. This inconsistency causes a compatibility issue where valid states in one contract lead to reverts in another. The root cause is the strict validation in OctoDistributor without considering design compatibility with AgenticCompany's behavior. An attacker cannot directly exploit this, but legitimate operations may fail unexpectedly when interacting with companies that use address(0) as a valid agent token placeholder. The impact is reduced functionality and potential blocking of valid business logic flows, especially during company lifecycle events.\n",
            "severity": "Medium",
            "location": [
                "OctoDistributor.sol::transferHiringDistributions#322",
                "AgenticCompany.sol::_dissolveCompany#606"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The withdrawAllAgentTokens function works incorrectly in OctoDistributor",
            "description": "The withdrawAllAgentTokens function removes tokens from the user's list during iteration using _removeAgentToken, which modifies the array by replacing the removed element with the last one and then popping it. When withdrawing a range of tokens starting from a middle index, this shifting causes subsequent indices to become invalid, leading to out-of-bounds errors. For example, removing token C at index 2 shifts D into its place, but the loop continues to index 3, which is now out of bounds. The root cause is modifying the array while iterating over it without adjusting the indices or deferring removal. An attacker cannot directly profit, but users attempting to withdraw multiple tokens in a single call may face transaction failures without clear error messages. The impact is degraded user experience and potential lock-up of funds until corrected via alternative withdrawal methods.\n",
            "severity": "Medium",
            "location": [
                "OctoDistributor.sol::withdrawAllAgentTokens#223",
                "OctoDistributor.sol::_removeAgentToken#308"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "OctoDistributor.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IAutonomousAgentDeployer.sol\";\nimport \"../interfaces/IAgenticCompany.sol\";\nimport \"../interfaces/IAgenticCompanyFactory.sol\";\nimport \"../interfaces/IANSReverseRegistrar.sol\";\nimport \"../interfaces/IANSResolver.sol\";\nimport \"../interfaces/IAgentBalances.sol\";\nimport \"../interfaces/IAgentToken.sol\";\n\ncontract OctoDistributor is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    UUPSUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20 for IERC20;\n\n    struct SystemAddresses {\n        IAutonomousAgentDeployer autonomousDeployer;\n        IAgenticCompanyFactory agenticCompanyFactory;\n        IANSResolver ansResolver;\n        IANSReverseRegistrar ansReverseRegistrar;\n        address spectralTreasury;\n    }\n\n    uint256 public spectraCompanyIndex;\n\n    IERC20Upgradeable public spectral_token;\n    IERC20 public usdc_token;\n\n    uint8 public version;\n    address public admin;\n    uint256 public constant PRECISION = 10**4;\n\n    enum Parameter {\n        TRADING_REWARDS_TREASURY_CUT,\n        TRADING_REWARDS_CREATOR_CUT,\n        TRADING_REWARDS_SPECTRA_CUT,\n        TRADING_REWARDS_EMPLOYEES_CUT\n    }\n\n    struct UserBalances {\n        uint256 spectral;\n        uint256 usdc;\n        mapping(address => uint256 balance) agent_tokens_list;\n        mapping(address => uint256 index) agent_tokens_indecies;\n        address[] agent_tokens;\n    }\n\n    struct HiringDistribution {\n        bytes32 recipientAnsNode;\n        uint256 specAmount;\n        uint256 agentTokenAmount;\n        uint256 usdcAmount;\n    }\n\n    SystemAddresses public systemAddresses;\n    mapping(Parameter => uint256) public parameters;\n    mapping(address => UserBalances) public userBalances;\n    mapping(address => address) public agentCreators;\n\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n    event DistributeHiringBonuses(\n        address company,\n        uint256 count,\n        address agentToken,\n        uint256 totalSpec,\n        uint256 totalAgentToken,\n        uint256 totalUsdc,\n        HiringDistribution[] distributions\n    );\n    event DistributeSpectraTradingRewards (\n        address agentToken,\n        uint256 usdcAmount,\n        address[] beneficiaries,\n        uint256[] amounts\n    );\n    event DistributeGenericTradingRewards (\n        address agentToken,\n        uint256 usdcAmount\n    );\n    event SetParameter(Parameter parameter, uint256 value);\n    event SetAgentCreator(address agentToken, address creator);\n    event SetAdmin(address admin);\n    event SetSpectraCompanyIndex(uint256 index);\n    event UpdateSystemAddress(uint8 index, address newAddress);\n    event Upgrade(address newImplementation, uint8 version);\n\n    modifier onlyAutonomousDeployer() {\n        require(\n            msg.sender == address(systemAddresses.autonomousDeployer),\n            \"ONLY_AUTONOMOUS_DEPLOYER\"\n        );\n        _;\n    }\n    modifier onlyAgenticCompany() {\n        require(\n            systemAddresses.agenticCompanyFactory.isCompany(msg.sender),\n            \"ONLY_AGENTIC_COMPANY_CAN_DISTRIBUTE\"\n        );\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"ONLY_ADMIN\");\n        _;\n    }\n\n    modifier onlyAdminOrOwner() {\n        require(msg.sender == admin || msg.sender == owner(), \"ONLY_ADMIN_OR_OWNER\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _autonomousDeployer,\n        address _agenticCompanyFactory,\n        address _ansResolver,\n        address _ansReverseRegistrar,\n        address _spectralTreasury,\n        uint256 _spectraCompanyIndex,\n        address _usdc_token,\n        address _spectral_token\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        admin = msg.sender;\n        require(_autonomousDeployer != address(0), \"AUTONOMOUS_ZERO_ADDRESS\");\n        require(_ansResolver != address(0), \"ANS_RESOLVER_ZERO_ADDRESS\");\n        require(_ansReverseRegistrar != address(0), \"ANS_REVERSE_REGISTRY_ZERO_ADDRESS\");\n        require(_spectralTreasury != address(0), \"SPECTRAL_TREASURY_ZERO_ADDRESS\");\n        require(_usdc_token != address(0), \"USDC_ZERO_ADDRESS\");\n        require(_spectral_token != address(0), \"SPEC_ZERO_ADDRESS\");\n        // We don't check the _agenticCompanyFactory since both contracts depend on each other and will deploy this contract first then set the factory address\n        systemAddresses.autonomousDeployer = IAutonomousAgentDeployer(_autonomousDeployer);\n        systemAddresses.agenticCompanyFactory = IAgenticCompanyFactory(_agenticCompanyFactory);\n        systemAddresses.ansResolver = IANSResolver(_ansResolver);\n        systemAddresses.ansReverseRegistrar = IANSReverseRegistrar(_ansReverseRegistrar);\n        systemAddresses.spectralTreasury = _spectralTreasury;\n        usdc_token = IERC20(_usdc_token);\n        spectral_token = IERC20Upgradeable(_spectral_token);\n        spectraCompanyIndex = _spectraCompanyIndex;\n        parameters[Parameter.TRADING_REWARDS_TREASURY_CUT] = 2000;\n        parameters[Parameter.TRADING_REWARDS_CREATOR_CUT] = 8000;\n        parameters[Parameter.TRADING_REWARDS_SPECTRA_CUT] = 2000;\n        parameters[Parameter.TRADING_REWARDS_EMPLOYEES_CUT] = 6000;\n        version = 1;\n    }\n\n    function setAgenticCompanyFactory(address _agenticCompanyFactory) external onlyOwner {\n        require(_agenticCompanyFactory != address(0), \"ZERO_ADDRESS\");\n        systemAddresses.agenticCompanyFactory = IAgenticCompanyFactory(_agenticCompanyFactory);\n        emit UpdateSystemAddress(1, _agenticCompanyFactory);\n    }\n\n    function withdraw(address _token, uint256 _amount) external nonReentrant {\n        require(_amount > 0, \"AMOUNT_ZERO\");\n        require(_token != address(0), \"ZERO_ADDRESS\");\n        UserBalances storage user = userBalances[msg.sender];\n        if (_token == address(spectral_token)) {\n            require(user.spectral >= _amount, \"INSUFFICIENT_BALANCE\");\n            user.spectral -= _amount;\n        } else if (_token == address(usdc_token)) {\n            require(user.usdc >= _amount, \"INSUFFICIENT_BALANCE\");\n            user.usdc -= _amount;\n        } else {\n            require(\n                user.agent_tokens_list[_token] >= _amount,\n                \"INSUFFICIENT_BALANCE\"\n            );\n            user.agent_tokens_list[_token] -= _amount;\n            if (user.agent_tokens_list[_token] == 0) {\n                _removeAgentToken(user, _token);\n            }\n        }\n        IERC20Upgradeable(_token).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _token, _amount);\n    }\n\n    function getUserAgentTokensCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userBalances[user].agent_tokens.length;\n    }\n\n    function setParameters(\n        Parameter[] calldata _parameters,\n        uint256[] calldata _values\n    ) external onlyOwner {\n        require(_parameters.length == _values.length, \"INVALID_LENGTH\");\n        for (uint256 i = 0; i < _parameters.length; i++) {\n            require(_values[i] <= PRECISION, \"PARAMETER_OUT_OF_RANGE\");\n            parameters[_parameters[i]] = _values[i];\n            emit SetParameter(_parameters[i], _values[i]);\n        }\n    }\n\n    function withdrawAllAgentTokens(uint256 start_index, uint256 end_index) external nonReentrant {\n        require(start_index < end_index, \"INVALID_INDEX\");\n        require(end_index <= userBalances[msg.sender].agent_tokens.length, \"INVALID_INDEX\");\n        for (uint256 i = start_index; i < end_index; i++) {\n            address token = userBalances[msg.sender].agent_tokens[i];\n            uint256 amount = userBalances[msg.sender].agent_tokens_list[token];\n            require(amount > 0, \"AMOUNT_ZERO\");\n            userBalances[msg.sender].agent_tokens_list[token] = 0;\n            _removeAgentToken(userBalances[msg.sender], token);\n            IERC20Upgradeable(token).safeTransfer(msg.sender, amount);\n            emit Withdraw(msg.sender, token, amount);\n        }\n    }\n\n    function withdrawAllAgentTokensByAddresses(address[] calldata tokens) external nonReentrant {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 amount = userBalances[msg.sender].agent_tokens_list[tokens[i]];\n            require(amount > 0, \"AMOUNT_ZERO\");\n            userBalances[msg.sender].agent_tokens_list[tokens[i]] = 0;\n            _removeAgentToken(userBalances[msg.sender], tokens[i]);\n            IERC20Upgradeable(tokens[i]).safeTransfer(msg.sender, amount);\n            emit Withdraw(msg.sender, tokens[i], amount);\n        }\n    }\n\n    function transferTradingRewards(\n        address agentToken,\n        uint256 usdcAmount\n    ) external nonReentrant onlyAdmin() {\n        require(agentToken != address(0), \"ZERO_ADDRESS\");\n        require(usdcAmount > 0, \"AMOUNT_ZERO\");\n        address[] memory beneficiaries;\n        uint256[] memory amounts;\n        usdc_token.safeTransferFrom(msg.sender, address(this), usdcAmount);\n        uint256 treasuryAmount = (usdcAmount * parameters[Parameter.TRADING_REWARDS_TREASURY_CUT]) / PRECISION;\n        usdc_token.safeTransfer(systemAddresses.spectralTreasury, treasuryAmount);\n        if(keccak256(abi.encodePacked(\"SPECTRA\")) == keccak256(abi.encodePacked(IAgentToken(agentToken).symbol()))) {\n            uint256 spectraAmount = (usdcAmount * parameters[Parameter.TRADING_REWARDS_SPECTRA_CUT]) / PRECISION;\n            uint256 employeesAmount = (usdcAmount * parameters[Parameter.TRADING_REWARDS_EMPLOYEES_CUT]) / PRECISION;\n            address spectraWallet = IAgentBalances(systemAddresses.autonomousDeployer.agentBalances()).agentWallets(agentToken);\n            uint256 employeeCount = IAgenticCompany(systemAddresses.agenticCompanyFactory.getCompanyAddressAtIndex(spectraCompanyIndex)).employeeCount();\n            require(employeeCount > 0, \"NO_EMPLOYEES\");\n            beneficiaries = new address[](employeeCount);\n            amounts = new uint256[](employeeCount);\n            uint256 perEmployeeAmount = employeesAmount / employeeCount;\n            for (uint256 i = 0; i < employeeCount; i++) {\n                address employee = \n                systemAddresses.ansResolver.addr(IAgenticCompany(systemAddresses.agenticCompanyFactory.getCompanyAddressAtIndex(spectraCompanyIndex)).getEmployeeAtIndex(i));\n                userBalances[employee].usdc += perEmployeeAmount;\n                beneficiaries[i] = employee;\n                amounts[i] = perEmployeeAmount;\n            }\n            usdc_token.safeTransfer(spectraWallet, spectraAmount);\n            emit DistributeSpectraTradingRewards(agentToken, usdcAmount, beneficiaries, amounts);\n        } else {\n            uint256 creatorAmount = (usdcAmount * parameters[Parameter.TRADING_REWARDS_CREATOR_CUT]) / PRECISION;\n            require(agentCreators[agentToken] != address(0), \"CREATOR_NOT_SET\");\n            usdc_token.safeTransfer(agentCreators[agentToken], creatorAmount);\n            emit DistributeGenericTradingRewards(agentToken, usdcAmount);\n        }\n    }\n    \n    \n    function _addOrGetAgentToken(UserBalances storage user, address token) internal returns (uint256) {\n        uint256 index = user.agent_tokens_indecies[token];\n        \n        if (index >= user.agent_tokens.length || user.agent_tokens[index] != token) {\n            // Add to array\n            user.agent_tokens.push(token);\n            // Store and return new array index\n            index = user.agent_tokens.length - 1;\n            user.agent_tokens_indecies[token] = index;\n        }\n        \n        return index;\n    }\n\n    function _removeAgentToken(UserBalances storage user, address token) internal {\n        uint256 index = user.agent_tokens_indecies[token];\n        require(index < user.agent_tokens.length, \"Token not found\");\n        \n        // Get the last element\n        address lastToken = user.agent_tokens[user.agent_tokens.length - 1];\n\n        // Move last element to the position we're deleting\n        user.agent_tokens[index] = lastToken;\n        // Update the index mapping for the moved token\n        user.agent_tokens_indecies[lastToken] = index;\n        \n        // Remove token's index from mapping\n        delete user.agent_tokens_indecies[token];\n        \n        // Remove last element\n        user.agent_tokens.pop();\n    }\n\n    function transferHiringDistributions(\n        HiringDistribution[] calldata distributions,\n        address agentToken,\n        uint256 totalSpec,\n        uint256 totalAgentToken,\n        uint256 totalUsdc\n    ) external nonReentrant onlyAgenticCompany() {\n        require(\n            distributions.length > 0,\n            \"DISTRIBUTIONS_MUST_BE_PROVIDED\"\n        );\n        require(agentToken != address(0), \"ZERO_ADDRESS\");\n        usdc_token.safeTransferFrom(msg.sender, address(this), totalUsdc);\n        spectral_token.safeTransferFrom(msg.sender, address(this), totalSpec);\n        IERC20Upgradeable(agentToken).safeTransferFrom(msg.sender, address(this), totalAgentToken);\n        uint256 accSpecAmount = 0;\n        uint256 accAgentTokenAmount = 0;\n        uint256 accUsdcAmount = 0;\n        for (uint256 i = 0; i < distributions.length; i++) {\n            UserBalances storage user = userBalances[\n                systemAddresses.ansResolver.addr(distributions[i].recipientAnsNode)\n            ];\n            user.spectral += distributions[i].specAmount;\n            accSpecAmount += distributions[i].specAmount;\n            _addOrGetAgentToken(user, agentToken);\n            user.agent_tokens_list[agentToken] += distributions[i].agentTokenAmount;\n            accAgentTokenAmount += distributions[i].agentTokenAmount;\n            user.usdc += distributions[i].usdcAmount;\n            accUsdcAmount += distributions[i].usdcAmount;\n        }\n        require(accSpecAmount == totalSpec, \"INCORRECT_SPEC_AMOUNT\");\n        require(accAgentTokenAmount == totalAgentToken, \"INCORRECT_AGENT_TOKEN_AMOUNT\");\n        require(accUsdcAmount == totalUsdc, \"INCORRECT_USDC_AMOUNT\");\n        emit DistributeHiringBonuses(\n            msg.sender,\n            distributions.length,\n            agentToken,\n            totalSpec,\n            totalAgentToken,\n            totalUsdc,\n            distributions\n        );\n    }\n\n    function setAgentCreator(address agentToken, address creator)\n        external\n        onlyAutonomousDeployer\n    {\n        require(agentToken != address(0), \"ZERO_ADDRESS\");\n        require(creator != address(0), \"ZERO_ADDRESS\");\n        agentCreators[agentToken] = creator;\n        emit SetAgentCreator(agentToken, creator);\n    }\n\n    function setAgentCreatorsBatch(\n        address[] calldata agentTokens,\n        address[] calldata creators\n    ) external onlyOwner {\n        require(agentTokens.length == creators.length, \"INVALID_LENGTH\");\n        for (uint256 i = 0; i < agentTokens.length; i++) {\n            require(agentTokens[i] != address(0), \"ZERO_ADDRESS\");\n            require(creators[i] != address(0), \"ZERO_ADDRESS\");\n            agentCreators[agentTokens[i]] = creators[i];\n            emit SetAgentCreator(agentTokens[i], creators[i]);\n        }\n    }\n\n    function setAdmin(address _admin) external onlyOwner {\n        require(_admin != address(0), \"ZERO_ADDRESS\");\n        admin = _admin;\n        emit SetAdmin(_admin);\n    }\n\n    function updateSystemAddress(\n    uint8 index,\n    address newAddress\n    ) external onlyOwner {\n        require(index < 5, \"INVALID_INDEX\");\n        require(newAddress != address(0), \"ZERO_ADDRESS\");\n        \n        assembly {\n            // Store new address at the correct slot\n            sstore(add(systemAddresses.slot, index), newAddress)\n        }\n        emit UpdateSystemAddress(index, newAddress);\n    }\n\n    function setSpectraCompanyIndex(uint256 index) external onlyOwner {\n        require(index < systemAddresses.agenticCompanyFactory.companyCount(), \"INVALID_INDEX\");\n        spectraCompanyIndex = index;\n        emit SetSpectraCompanyIndex(index);\n    }\n\n    function _authorizeUpgrade(\n        address newImplementation\n    ) internal override onlyOwner {\n        require(newImplementation != address(0), \"ZERO_ADDRESS\");\n        ++version;\n        emit Upgrade(newImplementation, version);\n    }\n}\n"
    }
}