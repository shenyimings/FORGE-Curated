{
    "vfp_id": "vfp_00035",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect assumption that one (1) Pendle Standard Yield (SY) token is equal to one (1) Yield Token when computing the price in the oracle",
            "description": "The vulnerability stems from the assumption in PendlePTOracle that one Pendle Standard Yield (SY) token is always equivalent to one underlying Yield Token when calculating prices. The root cause is the use of PENDLE_ORACLE.getPtToSyRate() when useSyOracleRate_ is true, which returns SY per PT, combined with Chainlink price feeds for the Yield Token, under the false assumption that 1 SY == 1 Yield Token. However, SY contracts may involve slippage or fees during redemption, meaning 1 SY can be worth less than 1 Yield Token. This discrepancy leads to inflated price calculations when computing baseToQuote, as the oracle multiplies ptRate and baseToUSD without adjusting for potential SY devaluation. The impact is overvaluation of collateral, allowing users to borrow more than they should, increasing the risk of bad debt and threatening protocol solvency.\n",
            "severity": "High",
            "location": [
                "PendlePTOracle.sol#L63",
                "PendlePTOracle.sol#L68",
                "IStandardizedYield.sol#L87"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/leveraged-vaults/contracts/oracles/PendlePTOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "PendlePTOracle.sol": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity 0.8.24;\n\nimport {Deployments} from \"@deployments/Deployments.sol\";\nimport {TypeConvert} from \"@contracts/global/TypeConvert.sol\";\nimport {IPMarket, IPOracle} from \"@interfaces/pendle/IPendle.sol\";\nimport \"@interfaces/chainlink/AggregatorV2V3Interface.sol\";\nimport \"@interfaces/IERC20.sol\";\n\ncontract PendlePTOracle is AggregatorV2V3Interface {\n    using TypeConvert for uint256;\n\n    address public immutable pendleMarket;\n    uint32 public immutable twapDuration;\n    bool public immutable useSyOracleRate;\n\n    uint8 public override constant decimals = 18;\n    uint256 public override constant version = 1;\n    int256 public constant rateDecimals = 10**18;\n\n    string public override description;\n    // Grace period after a sequencer downtime has occurred\n    uint256 public constant SEQUENCER_UPTIME_GRACE_PERIOD = 1 hours;\n\n    AggregatorV2V3Interface public immutable baseToUSDOracle;\n    int256 public immutable baseToUSDDecimals;\n    int256 public immutable ptDecimals;\n    bool public immutable invertBase;\n    AggregatorV2V3Interface public immutable sequencerUptimeOracle;\n    uint256 public immutable expiry;\n\n    constructor (\n        address pendleMarket_,\n        AggregatorV2V3Interface baseToUSDOracle_,\n        bool invertBase_,\n        bool useSyOracleRate_,\n        uint32 twapDuration_,\n        string memory description_,\n        AggregatorV2V3Interface sequencerUptimeOracle_\n    ) {\n        description = description_;\n        pendleMarket = pendleMarket_;\n        twapDuration = twapDuration_;\n        useSyOracleRate = useSyOracleRate_;\n\n        baseToUSDOracle = baseToUSDOracle_;\n        invertBase = invertBase_;\n        sequencerUptimeOracle = sequencerUptimeOracle_;\n\n        uint8 _baseDecimals = baseToUSDOracle_.decimals();\n        (/* */, address pt, /* */) = IPMarket(pendleMarket_).readTokens();\n        uint8 _ptDecimals = IERC20(pt).decimals();\n\n        require(_baseDecimals <= 18);\n        require(_ptDecimals <= 18);\n\n        baseToUSDDecimals = int256(10**_baseDecimals);\n        ptDecimals = int256(10**_ptDecimals);\n\n        (\n            bool increaseCardinalityRequired,\n            /* */,\n            bool oldestObservationSatisfied\n        ) = Deployments.PENDLE_ORACLE.getOracleState(pendleMarket, twapDuration);\n        require(!increaseCardinalityRequired && oldestObservationSatisfied, \"Oracle Init\");\n\n        expiry = IPMarket(pendleMarket).expiry();\n    }\n\n    function _checkSequencer() private view {\n        // See: https://docs.chain.link/data-feeds/l2-sequencer-feeds/\n        if (address(sequencerUptimeOracle) != address(0)) {\n            (\n                /*uint80 roundID*/,\n                int256 answer,\n                uint256 startedAt,\n                /*uint256 updatedAt*/,\n                /*uint80 answeredInRound*/\n            ) = sequencerUptimeOracle.latestRoundData();\n            require(answer == 0, \"Sequencer Down\");\n            require(SEQUENCER_UPTIME_GRACE_PERIOD < block.timestamp - startedAt, \"Sequencer Grace Period\");\n        }\n    }\n\n    function _getPTRate() internal view returns (int256) {\n        uint256 ptRate = useSyOracleRate ? \n            Deployments.PENDLE_ORACLE.getPtToSyRate(pendleMarket, twapDuration) :\n            Deployments.PENDLE_ORACLE.getPtToAssetRate(pendleMarket, twapDuration);\n        return ptRate.toInt();\n    }\n\n    function _calculateBaseToQuote() internal view returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        _checkSequencer();\n\n        int256 baseToUSD;\n        (\n            roundId,\n            baseToUSD,\n            startedAt,\n            updatedAt,\n            answeredInRound\n        ) = baseToUSDOracle.latestRoundData();\n        require(baseToUSD > 0, \"Chainlink Rate Error\");\n        // Overflow and div by zero not possible\n        if (invertBase) baseToUSD = (baseToUSDDecimals * baseToUSDDecimals) / baseToUSD;\n\n        int256 ptRate = _getPTRate();\n        // ptRate is always returned in 1e18 decimals (rateDecimals)\n        answer = (ptRate * baseToUSD) / baseToUSDDecimals;\n    }\n\n    function latestRoundData() external view override returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        return _calculateBaseToQuote();\n    }\n\n    function latestAnswer() external view override returns (int256 answer) {\n        (/* */, answer, /* */, /* */, /* */) = _calculateBaseToQuote();\n    }\n\n    function latestTimestamp() external view override returns (uint256 updatedAt) {\n        (/* */, /* */, /* */, updatedAt, /* */) = _calculateBaseToQuote();\n    }\n\n    function latestRound() external view override returns (uint256 roundId) {\n        (roundId, /* */, /* */, /* */, /* */) = _calculateBaseToQuote();\n    }\n\n    function getRoundData(uint80 /* _roundId */) external pure override returns (\n        uint80 /* roundId */,\n        int256 /* answer */,\n        uint256 /* startedAt */,\n        uint256 /* updatedAt */,\n        uint80 /* answeredInRound */\n    ) {\n        revert();\n    }\n\n    function getAnswer(uint256 /* roundId */) external pure override returns (int256) { revert(); }\n    function getTimestamp(uint256 /* roundId */) external pure override returns (uint256) { revert(); }\n}"
    }
}