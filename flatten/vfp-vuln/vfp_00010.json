{
    "vfp_id": "vfp_00010",
    "project_name": "Matter Labs Guardian Recovery Validator Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Front-Running Scenarios During Key Registration",
            "description": "The `WebAuthValidator` contract is vulnerable to front-running attacks during key registration because it checks for duplicate `originDomain` and `credentialId` combinations without associating them securely with the initiating account. The root cause is the lack of account-specific binding in the registration check, allowing any user to preempt a pending registration. An attacker can monitor the mempool for registration transactions and submit their own with the same `originDomain` and `credentialId` but a different `publicKey`, thereby occupying the slot. The impact is that legitimate users' transactions will revert, preventing them from attaching their validator to their account. Additionally, the commit-reveal pattern in `GuardianRecoveryValidator` may be weakened if attackers can correlate hashed values with known account data.\n",
            "severity": "Medium",
            "location": [
                "WebAuthValidator.sol::onInstall#63",
                "WebAuthValidator.sol#104",
                "GuardianRecoveryValidator.sol#204-206"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol"
            ]
        }
    ],
    "affected_files": {
        "WebAuthValidator.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\nimport { VerifierCaller } from \"../helpers/VerifierCaller.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { Base64 } from \"solady/src/utils/Base64.sol\";\nimport { JSONParserLib } from \"solady/src/utils/JSONParserLib.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title WebAuthValidator\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract allows secure user authentication using WebAuthn public keys.\ncontract WebAuthValidator is VerifierCaller, IModuleValidator {\n  using JSONParserLib for JSONParserLib.Item;\n  using JSONParserLib for string;\n\n  /// @dev P256Verify precompile implementation, as defined in RIP-7212, is found at\n  /// https://github.com/matter-labs/era-contracts/blob/main/system-contracts/contracts/precompiles/P256Verify.yul\n  address private constant P256_VERIFIER = address(0x100);\n\n  error NOT_KEY_OWNER(address account);\n\n  // check for secure validation: bit 0 = 1 (user present), bit 2 = 1 (user verified)\n  bytes1 private constant AUTH_DATA_MASK = 0x05;\n  bytes32 private constant LOW_S_MAX = 0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8;\n  bytes32 private constant HIGH_R_MAX = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551;\n\n  event PasskeyCreated(address indexed keyOwner, string originDomain, bytes credentialId);\n  event PasskeyRemoved(address indexed keyOwner, string originDomain, bytes credentialId);\n\n  mapping(string originDomain => mapping(bytes credentialId => mapping(address accountAddress => bytes32[2] publicKey)))\n    public publicKeys;\n\n  function getAccountKey(\n    string calldata originDomain,\n    bytes calldata credentialId,\n    address accountAddress\n  ) external view returns (bytes32[2] memory) {\n    return publicKeys[originDomain][credentialId][accountAddress];\n  }\n\n  mapping(string originDomain => mapping(bytes credentialId => address accountAddress)) public registeredAddress;\n\n  struct PasskeyId {\n    string domain;\n    bytes credentialId;\n  }\n\n  /// @notice Runs on module install\n  /// @param data ABI-encoded WebAuthn passkey to add immediately, or empty if not needed\n  function onInstall(bytes calldata data) external override {\n    if (data.length > 0) {\n      (bytes memory credentialId, bytes32[2] memory rawPublicKey, string memory originDomain) = abi.decode(\n        data,\n        (bytes, bytes32[2], string)\n      );\n      if (!addValidationKey(credentialId, rawPublicKey, originDomain)) {\n        revert Errors.WEBAUTHN_KEY_EXISTS();\n      }\n    }\n  }\n\n  /// @notice Runs on module uninstall\n  /// @param data ABI-encoded array of origin domains to remove keys for\n  function onUninstall(bytes calldata data) external override {\n    PasskeyId[] memory passkeyIds = abi.decode(data, (PasskeyId[]));\n    for (uint256 i = 0; i < passkeyIds.length; i++) {\n      PasskeyId memory passkeyId = passkeyIds[i];\n      removeValidationKey(passkeyId.credentialId, passkeyId.domain);\n    }\n  }\n\n  function removeValidationKey(bytes memory credentialId, string memory domain) public {\n    if (registeredAddress[domain][credentialId] != msg.sender) {\n      revert NOT_KEY_OWNER(registeredAddress[domain][credentialId]);\n    }\n    registeredAddress[domain][credentialId] = address(0);\n    publicKeys[domain][credentialId][msg.sender] = [bytes32(0), bytes32(0)];\n\n    emit PasskeyRemoved(msg.sender, domain, credentialId);\n  }\n\n  /// @notice Adds a WebAuthn passkey for the caller\n  /// @param credentialId unique public identifier for the key\n  /// @param rawPublicKey ABI-encoded WebAuthn public key to add\n  /// @param originDomain the domain this associated with\n  /// @return true if the key was added, false if one already exists\n  function addValidationKey(\n    bytes memory credentialId,\n    bytes32[2] memory rawPublicKey,\n    string memory originDomain\n  ) public returns (bool) {\n    bytes32[2] memory initialAccountKey = publicKeys[originDomain][credentialId][msg.sender];\n    if (uint256(initialAccountKey[0]) != 0 || uint256(initialAccountKey[1]) != 0) {\n      // only allow adding new keys, no overwrites/updates\n      return false;\n    }\n    if (registeredAddress[originDomain][credentialId] != address(0)) {\n      // this key already exists on the domain for an existing account\n      return false;\n    }\n    if (rawPublicKey[0] == 0 && rawPublicKey[1] == 0) {\n      // empty keys aren't valid\n      return false;\n    }\n\n    publicKeys[originDomain][credentialId][msg.sender] = rawPublicKey;\n    registeredAddress[originDomain][credentialId] = msg.sender;\n\n    emit PasskeyCreated(msg.sender, originDomain, credentialId);\n\n    return true;\n  }\n\n  /// @notice Validates a WebAuthn signature\n  /// @param signedHash The hash of the signed message\n  /// @param signature The signature to validate\n  /// @return true if the signature is valid\n  function validateSignature(bytes32 signedHash, bytes calldata signature) external view returns (bool) {\n    return webAuthVerify(signedHash, signature);\n  }\n\n  /// @notice Validates a transaction signed with a passkey\n  /// @dev Does not validate the transaction signature field, which is expected to be different due to the modular format\n  /// @param signedHash The hash of the signed transaction\n  /// @param transaction The transaction to validate\n  /// @return true if the signature is valid\n  function validateTransaction(bytes32 signedHash, Transaction calldata transaction) external view returns (bool) {\n    (bytes memory signature, , ) = abi.decode(transaction.signature, (bytes, address, bytes));\n    return webAuthVerify(signedHash, signature);\n  }\n\n  /// @notice Validates a WebAuthn signature\n  /// @dev Performs r & s range validation to prevent signature malleability\n  /// @dev Checks passkey authenticator data flags (valid number of credentials)\n  /// @dev Requires that the transaction signature hash was the signed challenge\n  /// @dev Verifies that the signature was performed by a 'get' request\n  /// @param transactionHash The hash of the signed message\n  /// @param fatSignature The signature to validate (authenticator data, client data, [r, s])\n  /// @return true if the signature is valid\n  function webAuthVerify(bytes32 transactionHash, bytes memory fatSignature) internal view returns (bool) {\n    (\n      bytes memory authenticatorData,\n      string memory clientDataJSON,\n      bytes32[2] memory rs,\n      bytes memory credentialId\n    ) = _decodeFatSignature(fatSignature);\n\n    // prevent signature replay https://yondon.blog/2019/01/01/how-not-to-use-ecdsa/\n    if (uint256(rs[0]) == 0 || rs[0] > HIGH_R_MAX || uint256(rs[1]) == 0 || rs[1] > LOW_S_MAX) {\n      return false;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#attestedcredentialdata\n    if (authenticatorData[32] & AUTH_DATA_MASK != AUTH_DATA_MASK) {\n      return false;\n    }\n\n    // parse out the required fields (type, challenge, crossOrigin): https://goo.gl/yabPex\n    JSONParserLib.Item memory root = JSONParserLib.parse(clientDataJSON);\n    // challenge should contain the transaction hash, ensuring that the transaction is signed\n    string memory challenge = root.at('\"challenge\"').value().decodeString();\n    bytes memory challengeData = Base64.decode(challenge);\n    if (challengeData.length != 32) {\n      return false; // wrong hash size\n    }\n    if (bytes32(challengeData) != transactionHash) {\n      return false;\n    }\n\n    // type ensures the signature was created from a validation request\n    string memory type_ = root.at('\"type\"').value().decodeString();\n    if (!Strings.equal(\"webauthn.get\", type_)) {\n      return false;\n    }\n\n    // the origin determines which key to validate against\n    // as passkeys are linked to domains, so the storage mapping reflects that\n    string memory origin = root.at('\"origin\"').value().decodeString();\n    bytes32[2] memory publicKey = publicKeys[origin][credentialId][msg.sender];\n    if (uint256(publicKey[0]) == 0 && uint256(publicKey[1]) == 0) {\n      // no key found!\n      return false;\n    }\n\n    // cross-origin validation is optional, but explicitly not supported.\n    // cross-origin requests would be from embedding the auth request\n    // from another domain. The current SSO setup uses a pop-up instead of\n    // an i-frame, so we're rejecting these until the implemention supports it\n    JSONParserLib.Item memory crossOriginItem = root.at('\"crossOrigin\"');\n    if (!crossOriginItem.isUndefined()) {\n      string memory crossOrigin = crossOriginItem.value();\n      if (!Strings.equal(\"false\", crossOrigin)) {\n        return false;\n      }\n    }\n\n    bytes32 message = _createMessage(authenticatorData, bytes(clientDataJSON));\n    return callVerifier(P256_VERIFIER, message, rs, publicKey);\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return\n      interfaceId == type(IERC165).interfaceId ||\n      interfaceId == type(IModuleValidator).interfaceId ||\n      interfaceId == type(IModule).interfaceId;\n  }\n\n  function _createMessage(\n    bytes memory authenticatorData,\n    bytes memory clientData\n  ) private pure returns (bytes32 message) {\n    bytes32 clientDataHash = sha256(clientData);\n    message = sha256(bytes.concat(authenticatorData, clientDataHash));\n  }\n\n  function _decodeFatSignature(\n    bytes memory fatSignature\n  )\n    private\n    pure\n    returns (\n      bytes memory authenticatorData,\n      string memory clientDataSuffix,\n      bytes32[2] memory rs,\n      bytes memory credentialId\n    )\n  {\n    (authenticatorData, clientDataSuffix, rs, credentialId) = abi.decode(\n      fatSignature,\n      (bytes, string, bytes32[2], bytes)\n    );\n  }\n}\n"
    }
}