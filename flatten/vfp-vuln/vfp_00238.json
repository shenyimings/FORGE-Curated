{
    "vfp_id": "vfp_00238",
    "project_name": "SSO Account OIDC Recovery Solidity Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "Unauthorized Control via Manipulated pendingPasskeyHash in startRecovery Process",
            "description": "The `startRecovery` function in the `OidcRecoveryValidator` contract does not validate the `pendingPasskeyHash` parameter before storing it, even though it is critical for determining who can complete the recovery. While the ZK proof verifies ownership of the OIDC identity, the `pendingPasskeyHash` is not bound to the proof. This allows an attacker who possesses a valid ZK proof (e.g., a malicious third party or compromised prover) to set a `pendingPasskeyHash` for which they control the private key, thereby hijacking the recovery process and taking control of the target account. The impact is full unauthorized account takeover. The root cause is the lack of cryptographic binding between the `pendingPasskeyHash` and the ZK proof.\n",
            "severity": "Medium",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#201",
                "OidcRecoveryValidator.sol#L239C58-L239C76"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ],
                "3": [
                    "CWE-198"
                ]
            },
            "title": "Endianness Mismatch in senderHash Representation Between Contract and Circuit",
            "description": "The `startRecovery` function in the `OidcRecoveryValidator` contract splits the 32-byte `senderHash` into two parts for circuit input, but uses inconsistent endianness: the first part is processed in little-endian format after a right shift, while the second part (the least significant byte) is used without reversal. This results in a mixed byte order representation of the same logical value. The root cause is the inconsistent handling of byte order during serialization, particularly the use of `_reverse` on part of the hash but not the whole. An attacker could potentially exploit this by crafting inputs that cause the circuit to reconstruct an incorrect `senderHash`, leading to failed proof verification or unexpected behavior in the recovery process. The impact includes potential denial of service for legitimate recovery attempts or, in worst-case scenarios, successful recovery by an unauthorized party if the mismatch leads to an exploitable logic flaw in the circuit validation.\n",
            "severity": "Medium",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#231-233",
                "OidcRecoveryValidator.sol::_reverse"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        }
    ],
    "affected_files": {
        "OidcRecoveryValidator.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { WebAuthValidator } from \"./WebAuthValidator.sol\";\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\nimport { VerifierCaller } from \"../helpers/VerifierCaller.sol\";\nimport { OidcKeyRegistry } from \"../OidcKeyRegistry.sol\";\nimport { Groth16Verifier } from \"../autogenerated/JwtTxValidationVerifier.sol\";\nimport { Utils } from \"../helpers/Utils.sol\";\nimport { IValidatorManager } from \"../interfaces/IValidatorManager.sol\";\n\n/// @title OidcRecoveryValidator\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract allows secure account recovery for an SSO account using OIDC (Open Id Connect) protocol.\ncontract OidcRecoveryValidator is VerifierCaller, IModuleValidator, Initializable {\n  /// @notice The number of public inputs for the zk proof.\n  uint8 constant PUB_SIGNALS_LENGTH = 20;\n\n  /// @notice Emitted when an SSO account updates their associated OIDC account.\n  /// @param account The address of the SSO account that updated their OIDC data.\n  /// @param oidcDigest Digest generated from data that identifies the user. Calculated as: PoseidonHash(sub || aud || iss || salt).\n  /// @param iss The OIDC issuer.\n  /// @param isNew True if the OIDC key is new, false if it is an update.\n  event OidcAccountUpdated(address indexed account, bytes32 oidcDigest, string iss, bool isNew);\n\n  /// @notice Emitted when an OIDC account is deleted.\n  /// @param account The address of the SSO account that deleted the associated OIDC data.\n  /// @param oidcDigest The PoseidonHash(sub || aud || iss || salt) of the OIDC key.\n  event OidcAccountDeleted(address indexed account, bytes32 oidcDigest);\n\n  /// @notice Thrown when calling `validateSignature` since it is not implemented.\n  error ValidateSignatureNotImplemented();\n\n  /// @notice Thrown when no address is found for a given OIDC digest.\n  /// @param digest The OIDC digest.\n  error AddressNotFoundForDigest(bytes32 digest);\n\n  /// @notice Thrown when trying to add an OIDC account with an OIDC digest that is already registered in another account.\n  /// @param digest The OIDC digest.\n  error OidcDigestAlreadyRegisteredInAnotherAccount(bytes32 digest);\n\n  /// @notice Thrown when there is no OIDC data for a given address.\n  /// @param account The address.\n  error NoOidcDataForGivenAddress(address account);\n\n  /// @notice Thrown when the zk proof verification fails.\n  error ZkProofVerificationFailed();\n\n  /// @notice Thrown when the time limit has expired.\n  error TimeLimitExpired();\n\n  error WebAuthValidatorNotPresentInAccount(address account);\n\n  /// @notice The data for an OIDC account.\n  /// @param oidcDigest Digest that identifies an account. It's calculated as: PoseidonHash(sub || aud || iss || salt) of the OIDC key.\n  /// @param iss The OIDC issuer.\n  /// @param readyToRecover Indicating if recovery is active (true after `startRecovery` and false once recovery is completed).\n  /// @param pendingPasskeyHash The hash of the pending passkey.\n  /// @param recoverNonce The value is used to build the jwt nonce, and gets incremented each time a zk proof is successfully verified to prevent replay attacks.\n  /// @param addedOn The timestamp when the OIDC account was added.\n  struct OidcData {\n    bytes32 oidcDigest;\n    string iss;\n    bool readyToRecover;\n    bytes32 pendingPasskeyHash;\n    uint256 recoverNonce;\n    uint256 addedOn;\n  }\n\n  /// @notice Data needed to associate a new oidc account to an sso account.\n  /// @param oidcDigest The PoseidonHash(sub || aud || iss || salt) of the OIDC key.\n  /// @param iss The OIDC issuer. See https://openid.net/specs/openid-connect-core-1_0.html#IDToken\n  struct OidcCreationData {\n    bytes32 oidcDigest;\n    string iss;\n  }\n\n  /// @notice The data for a zk proof. pB is expected to be already in the order needed for the verifier.\n  struct ZkProof {\n    uint[2] pA;\n    uint[2][2] pB;\n    uint[2] pC;\n  }\n\n  /// @notice The data for starting a recovery process.\n  /// @param zkProof The zk proof.\n  /// @param issHash The hash of the OIDC issuer.\n  /// @param kid The key id (kid) of the OIDC key.\n  /// @param pendingPasskeyHash The hash of the pending passkey to be added.\n  /// @param timeLimit If the recovery process is started after this moment it will fail.\n  struct StartRecoveryData {\n    ZkProof zkProof;\n    bytes32 kid;\n    bytes32 pendingPasskeyHash;\n    uint256 timeLimit;\n  }\n\n  /// @notice The mapping of account addresses to their OIDC data.\n  mapping(address account => OidcData oidcData) accountData;\n\n  /// @notice The mapping of OIDC digests to their corresponding account addresses, used to retrieve the user's address during the recovery process.\n  mapping(bytes32 oidcDigest => address account) digestIndex;\n\n  /// @notice The address of the OIDC key registry.\n  address public keyRegistry;\n\n  /// @notice The address of the zk verifier.\n  address public verifier;\n\n  /// @notice The address of the web authentication validator.\n  address public webAuthValidator;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the validator.\n  /// @param _keyRegistry The address of the OIDC key registry.\n  /// @param _verifier The address of the zk verifier.\n  /// @param _webAuthValidator The address of the web authentication validator.\n  function initialize(address _keyRegistry, address _verifier, address _webAuthValidator) external initializer {\n    require(_keyRegistry != address(0), \"_keyRegistry cannot be zero address\");\n    require(_verifier != address(0), \"_verifier cannot be zero address\");\n    require(_webAuthValidator != address(0), \"_webAuthValidator cannot be zero address\");\n\n    keyRegistry = _keyRegistry;\n    verifier = _verifier;\n    webAuthValidator = _webAuthValidator;\n  }\n\n  /// @notice Runs on module install\n  /// @param data ABI-encoded OidcCreationData key to add immediately, or empty if not needed\n  function onInstall(bytes calldata data) external override {\n    IValidatorManager asValidator = IValidatorManager(msg.sender);\n\n    bool passKeyModuleIsPresent = asValidator.isModuleValidator(webAuthValidator);\n    if (!passKeyModuleIsPresent) {\n      revert WebAuthValidatorNotPresentInAccount(msg.sender);\n    }\n\n    if (data.length > 0) {\n      OidcCreationData memory oidcCreationData = abi.decode(data, (OidcCreationData));\n      addOidcAccount(oidcCreationData.oidcDigest, oidcCreationData.iss);\n    }\n  }\n\n  /// @notice Runs on module uninstall\n  /// @dev Deletes the OIDC account for the caller, freeing it for use by another SSO account.\n  function onUninstall(bytes calldata) external override {\n    _deleteOidcAccount();\n  }\n\n  /// @notice Adds an `OidcData` for the caller.\n  /// @param oidcDigest PoseidonHash(sub || aud || iss || salt).\n  /// @param iss The OIDC issuer.\n  /// @return true if the key was added, false if it was updated.\n  function addOidcAccount(bytes32 oidcDigest, string memory iss) public returns (bool) {\n    require(oidcDigest != bytes32(0), \"oidcDigest cannot be empty\");\n    require(bytes(iss).length > 0, \"oidcDigest cannot be empty\");\n\n    bool isNew = accountData[msg.sender].oidcDigest.length == 0;\n    if (digestIndex[oidcDigest] != address(0)) {\n      revert OidcDigestAlreadyRegisteredInAnotherAccount(oidcDigest);\n    }\n\n    accountData[msg.sender].oidcDigest = oidcDigest;\n    accountData[msg.sender].iss = iss;\n    accountData[msg.sender].addedOn = block.timestamp;\n    digestIndex[oidcDigest] = msg.sender;\n\n    emit OidcAccountUpdated(msg.sender, oidcDigest, iss, isNew);\n    return isNew;\n  }\n\n  /// @notice Deletes the OIDC account for the caller, freeing it for use by another SSO account.\n  function deleteOidcAccount() external {\n    _deleteOidcAccount();\n  }\n\n  /// @notice Deletes the OIDC account for the caller, freeing it for use by another SSO account.\n  function _deleteOidcAccount() private {\n    bytes32 digest = accountData[msg.sender].oidcDigest;\n    delete digestIndex[digest];\n    delete accountData[msg.sender];\n\n    emit OidcAccountDeleted(msg.sender, digest);\n  }\n\n  /// @notice Starts the recovery process for the target account.\n  /// @param data The data for starting a recovery process.\n  /// @param targetAccount The address of the account to start the recovery process for.\n  /// @dev Queries the OIDC key registry for the provider's public key (`pkop`).\n  /// @dev Calls the verifier contract to validate the zk proof.\n  /// @dev If the proof is valid, it sets the recovery data for the target account.\n  function startRecovery(StartRecoveryData calldata data, address targetAccount) external {\n    if (data.timeLimit < block.timestamp) {\n      revert TimeLimitExpired();\n    }\n\n    OidcKeyRegistry keyRegistryContract = OidcKeyRegistry(keyRegistry);\n    Groth16Verifier verifierContract = Groth16Verifier(verifier);\n\n    OidcData memory oidcData = accountData[targetAccount];\n    bytes32 issHash = keyRegistryContract.hashIssuer(oidcData.iss);\n    OidcKeyRegistry.Key memory key = keyRegistryContract.getKey(issHash, data.kid);\n\n    bytes32 senderHash = keccak256(abi.encode(msg.sender, oidcData.recoverNonce, data.timeLimit));\n\n    // Fill public inputs\n    uint8 index = 0;\n    uint[PUB_SIGNALS_LENGTH] memory publicInputs;\n\n    // First CIRCOM_BIGINT_CHUNKS elements are the oidc provider public key.\n    for (uint8 i = 0; i < key.n.length; ++i) {\n      publicInputs[index] = uint(key.n[i]);\n      ++index;\n    }\n\n    // Then the digest\n    publicInputs[index] = uint(oidcData.oidcDigest);\n    ++index;\n\n    // Lastly the sender hash split into two 31-byte chunks (fields)\n    // Reverse ensures correct little-endian representation\n    publicInputs[index] = _reverse(uint256(senderHash) >> 8) >> 8;\n    ++index;\n    publicInputs[index] = (uint256(senderHash) << 248) >> 248;\n\n    if (!verifierContract.verifyProof(data.zkProof.pA, data.zkProof.pB, data.zkProof.pC, publicInputs)) {\n      revert ZkProofVerificationFailed();\n    }\n\n    accountData[targetAccount].pendingPasskeyHash = data.pendingPasskeyHash;\n    accountData[targetAccount].recoverNonce += 1;\n    accountData[targetAccount].readyToRecover = true;\n  }\n\n  /// @notice Only allows transaction setting a new passkey for the sender, and only if `startRecovery` was successfully\n  ///         called before\n  /// @dev Only allows calls to `addValidationKey` on the `WebAuthValidator` contract.\n  /// @dev Validates that the transaction adds the pending passkey to the account.\n  /// @dev It only allows to use passkeys previously set in `startRecovery`\n  /// @param transaction The transaction data being validated.\n  /// @return true if the transaction is valid and authorized, false otherwise.\n  function validateTransaction(bytes32, Transaction calldata transaction) external returns (bool) {\n    address target = Utils.safeCastToAddress(transaction.to);\n    if (target != webAuthValidator) {\n      return false;\n    }\n\n    if (transaction.data.length < 4) {\n      return false;\n    }\n\n    bytes4 selector = bytes4(transaction.data[:4]);\n\n    // Check for calling \"addValidationKey\" method by anyone on WebAuthValidator contract\n    if (selector != WebAuthValidator.addValidationKey.selector) {\n      return false;\n    }\n\n    // Decode the key from the transaction data and check against the pending passkey hash\n    (, bytes32[2] memory newPasskeyPubKey, ) = abi.decode(transaction.data[4:], (bytes, bytes32[2], string));\n    bytes32 passkeyHash = keccak256(abi.encode(newPasskeyPubKey[0], newPasskeyPubKey[1]));\n    OidcData memory oidcData = accountData[msg.sender];\n\n    if (!oidcData.readyToRecover) {\n      return false;\n    }\n\n    if (oidcData.pendingPasskeyHash != passkeyHash) {\n      return false;\n    }\n\n    // Reset pending passkey hash\n    accountData[msg.sender].pendingPasskeyHash = bytes32(0);\n    accountData[msg.sender].readyToRecover = false;\n    return true;\n  }\n\n  /// @notice Unimplemented because signature validation is not required.\n  /// @dev This module is only used to set new passkeys, arbitrary signature validation is out of the scope of this module.\n  function validateSignature(bytes32, bytes memory) external pure returns (bool) {\n    revert ValidateSignatureNotImplemented();\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return\n      interfaceId == type(IERC165).interfaceId ||\n      interfaceId == type(IModuleValidator).interfaceId ||\n      interfaceId == type(IModule).interfaceId;\n  }\n\n  /// @notice Returns the address for a given OIDC digest.\n  /// @param digest The OIDC digest.\n  /// @return account The address for the given OIDC digest.\n  function addressForDigest(bytes32 digest) external view returns (address) {\n    address addr = digestIndex[digest];\n    if (addr == address(0)) {\n      revert AddressNotFoundForDigest(digest);\n    }\n\n    return addr;\n  }\n\n  /// @notice Returns the OIDC data for a given address.\n  /// @param account The address to get the OIDC data for.\n  /// @return data The OIDC data for the given address.\n  function oidcDataForAddress(address account) external view returns (OidcData memory) {\n    OidcData memory data = accountData[account];\n\n    if (data.oidcDigest == bytes32(0)) {\n      revert NoOidcDataForGivenAddress(account);\n    }\n\n    return data;\n  }\n\n  /// @notice Reverses the byte order of a given uint256.\n  /// @param input The uint256 to reverse.\n  /// @return uint256 The reversed version of the input.\n  function _reverse(uint256 input) private pure returns (uint256) {\n    uint256 res = 0;\n    uint256 shifted = input;\n    uint256 mask = 0xff;\n\n    for (uint i = 0; i < 32; ++i) {\n      uint256 oneByte = (shifted & mask) << ((32 - i - 1) * 8);\n      shifted = shifted >> 8;\n      res = res + oneByte;\n    }\n\n    return res;\n  }\n}\n"
    }
}