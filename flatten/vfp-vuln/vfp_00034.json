{
    "vfp_id": "vfp_00034",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect assumption that one (1) Pendle Standard Yield (SY) token is equal to one (1) Yield Token when computing the price in the oracle",
            "description": "The vulnerability stems from the assumption in PendlePTOracle that one Pendle Standard Yield (SY) token is always equivalent to one underlying Yield Token when calculating prices. The root cause is the use of PENDLE_ORACLE.getPtToSyRate() when useSyOracleRate_ is true, which returns SY per PT, combined with Chainlink price feeds for the Yield Token, under the false assumption that 1 SY == 1 Yield Token. However, SY contracts may involve slippage or fees during redemption, meaning 1 SY can be worth less than 1 Yield Token. This discrepancy leads to inflated price calculations when computing baseToQuote, as the oracle multiplies ptRate and baseToUSD without adjusting for potential SY devaluation. The impact is overvaluation of collateral, allowing users to borrow more than they should, increasing the risk of bad debt and threatening protocol solvency.\n",
            "severity": "High",
            "location": [
                "PendlePTOracle.sol#L63",
                "PendlePTOracle.sol#L68",
                "IStandardizedYield.sol#L87"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/contracts/oracles/PendlePTOracle.sol",
                "0096f1f64071cafbf20062a7c092c6ec89c28275/src/interfaces/IPendle.sol"
            ]
        }
    ],
    "affected_files": {
        "PendlePTOracle.sol": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity 0.8.24;\n\nimport {Deployments} from \"@deployments/Deployments.sol\";\nimport {TypeConvert} from \"@contracts/global/TypeConvert.sol\";\nimport {IPMarket, IPOracle} from \"@interfaces/pendle/IPendle.sol\";\nimport \"@interfaces/chainlink/AggregatorV2V3Interface.sol\";\nimport \"@interfaces/IERC20.sol\";\n\ncontract PendlePTOracle is AggregatorV2V3Interface {\n    using TypeConvert for uint256;\n\n    address public immutable pendleMarket;\n    uint32 public immutable twapDuration;\n    bool public immutable useSyOracleRate;\n\n    uint8 public override constant decimals = 18;\n    uint256 public override constant version = 1;\n    int256 public constant rateDecimals = 10**18;\n\n    string public override description;\n    // Grace period after a sequencer downtime has occurred\n    uint256 public constant SEQUENCER_UPTIME_GRACE_PERIOD = 1 hours;\n\n    AggregatorV2V3Interface public immutable baseToUSDOracle;\n    int256 public immutable baseToUSDDecimals;\n    int256 public immutable ptDecimals;\n    bool public immutable invertBase;\n    AggregatorV2V3Interface public immutable sequencerUptimeOracle;\n    uint256 public immutable expiry;\n\n    constructor (\n        address pendleMarket_,\n        AggregatorV2V3Interface baseToUSDOracle_,\n        bool invertBase_,\n        bool useSyOracleRate_,\n        uint32 twapDuration_,\n        string memory description_,\n        AggregatorV2V3Interface sequencerUptimeOracle_\n    ) {\n        description = description_;\n        pendleMarket = pendleMarket_;\n        twapDuration = twapDuration_;\n        useSyOracleRate = useSyOracleRate_;\n\n        baseToUSDOracle = baseToUSDOracle_;\n        invertBase = invertBase_;\n        sequencerUptimeOracle = sequencerUptimeOracle_;\n\n        uint8 _baseDecimals = baseToUSDOracle_.decimals();\n        (/* */, address pt, /* */) = IPMarket(pendleMarket_).readTokens();\n        uint8 _ptDecimals = IERC20(pt).decimals();\n\n        require(_baseDecimals <= 18);\n        require(_ptDecimals <= 18);\n\n        baseToUSDDecimals = int256(10**_baseDecimals);\n        ptDecimals = int256(10**_ptDecimals);\n\n        (\n            bool increaseCardinalityRequired,\n            /* */,\n            bool oldestObservationSatisfied\n        ) = Deployments.PENDLE_ORACLE.getOracleState(pendleMarket, twapDuration);\n        require(!increaseCardinalityRequired && oldestObservationSatisfied, \"Oracle Init\");\n\n        expiry = IPMarket(pendleMarket).expiry();\n    }\n\n    function _checkSequencer() private view {\n        // See: https://docs.chain.link/data-feeds/l2-sequencer-feeds/\n        if (address(sequencerUptimeOracle) != address(0)) {\n            (\n                /*uint80 roundID*/,\n                int256 answer,\n                uint256 startedAt,\n                /*uint256 updatedAt*/,\n                /*uint80 answeredInRound*/\n            ) = sequencerUptimeOracle.latestRoundData();\n            require(answer == 0, \"Sequencer Down\");\n            require(SEQUENCER_UPTIME_GRACE_PERIOD < block.timestamp - startedAt, \"Sequencer Grace Period\");\n        }\n    }\n\n    function _getPTRate() internal view returns (int256) {\n        uint256 ptRate = useSyOracleRate ? \n            Deployments.PENDLE_ORACLE.getPtToSyRate(pendleMarket, twapDuration) :\n            Deployments.PENDLE_ORACLE.getPtToAssetRate(pendleMarket, twapDuration);\n        return ptRate.toInt();\n    }\n\n    function _calculateBaseToQuote() internal view returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        _checkSequencer();\n\n        int256 baseToUSD;\n        (\n            roundId,\n            baseToUSD,\n            startedAt,\n            updatedAt,\n            answeredInRound\n        ) = baseToUSDOracle.latestRoundData();\n        require(baseToUSD > 0, \"Chainlink Rate Error\");\n        // Overflow and div by zero not possible\n        if (invertBase) baseToUSD = (baseToUSDDecimals * baseToUSDDecimals) / baseToUSD;\n\n        int256 ptRate = _getPTRate();\n        // ptRate is always returned in 1e18 decimals (rateDecimals)\n        answer = (ptRate * baseToUSD) / baseToUSDDecimals;\n    }\n\n    function latestRoundData() external view override returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        return _calculateBaseToQuote();\n    }\n\n    function latestAnswer() external view override returns (int256 answer) {\n        (/* */, answer, /* */, /* */, /* */) = _calculateBaseToQuote();\n    }\n\n    function latestTimestamp() external view override returns (uint256 updatedAt) {\n        (/* */, /* */, /* */, updatedAt, /* */) = _calculateBaseToQuote();\n    }\n\n    function latestRound() external view override returns (uint256 roundId) {\n        (roundId, /* */, /* */, /* */, /* */) = _calculateBaseToQuote();\n    }\n\n    function getRoundData(uint80 /* _roundId */) external pure override returns (\n        uint80 /* roundId */,\n        int256 /* answer */,\n        uint256 /* startedAt */,\n        uint256 /* updatedAt */,\n        uint80 /* answeredInRound */\n    ) {\n        revert();\n    }\n\n    function getAnswer(uint256 /* roundId */) external pure override returns (int256) { revert(); }\n    function getTimestamp(uint256 /* roundId */) external pure override returns (uint256) { revert(); }\n}",
        "IPendle.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nevent OrderFilledV2(\n    bytes32 indexed orderHash,\n    IPRouter.OrderType indexed orderType,\n    address indexed YT,\n    address token,\n    uint256 netInputFromMaker,\n    uint256 netOutputToMaker,\n    uint256 feeAmount,\n    uint256 notionalVolume,\n    address maker,\n    address taker\n);\n\ninterface IPOracle {\n    function getPtToAssetRate(address market, uint32 duration) external view returns (uint256);\n\n    function getPtToSyRate(address market, uint32 duration) external view returns (uint256);\n\n    function getOracleState(address market, uint32 duration) external view returns (\n        bool increaseCardinalityRequired, uint16 cardinalityRequired, bool oldestObservationSatisfied\n    );\n}\n\ninterface IPRouter {\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n        // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    function swapExactTokenForPt(\n        address receiver,\n        address market,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netPtOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function swapExactPtForToken(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function redeemPyToToken(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        TokenOutput calldata output\n    ) external returns (uint256 netTokenOut, uint256 netSyInterm);\n}\n\ninterface IPMarket {\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    // function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (address _SY, address _PT, address _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IStandardizedYield is IERC20Metadata {\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}\n\ninterface IPPrincipalToken is IERC20Metadata {\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}\n\ninterface IPYieldToken is IERC20Metadata {\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}\n\nIPRouter constant PENDLE_ROUTER = IPRouter(0x888888888889758F76e7103c6CbF23ABbF58F946);\nIPOracle constant PENDLE_ORACLE = IPOracle(0x66a1096C6366b2529274dF4f5D8247827fe4CEA8);"
    }
}