{
    "vfp_id": "vfp_00124",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "BalancerFlashLoan Missing Access Control",
            "description": "The BalancerFlashLoan contract lacks proper access control on its makeFlashLoan function, allowing any external caller to trigger flash loans and bypass the intended authorization checks in the leverage zapper contracts. The cause is the absence of a modifier or check to ensure only authorized zappers can initiate flash loans. An attacker could exploit this by directly calling makeFlashLoan with arbitrary parameters, including targeting troves they do not control, thereby adjusting troves without proper rights. This could lead to unauthorized trove modifications, potential liquidation risks, and financial gain via sandwich attacks on associated swaps. The impact includes loss of user funds and unauthorized manipulation of trove positions.\n",
            "severity": "High",
            "location": [
                "BalancerFlashLoan.sol::makeFlashLoan",
                "BalancerFlashLoan.sol::receiveFlashLoan"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        }
    ],
    "affected_files": {
        "BalancerFlashLoan.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Balancer/vault/IVault.sol\";\nimport \"./Balancer/vault/IFlashLoanRecipient.sol\";\n\nimport \"../../Interfaces/ILeverageZapper.sol\";\nimport \"../../Interfaces/IFlashLoanReceiver.sol\";\nimport \"../../Interfaces/IFlashLoanProvider.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract BalancerFlashLoan is IFlashLoanRecipient, IFlashLoanProvider {\n    using SafeERC20 for IERC20;\n\n    IVault private constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    function makeFlashLoan(\n        IERC20 _token,\n        uint256 _amount,\n        IFlashLoanReceiver _caller, // TODO: should it always be msg.sender?\n        Operation _operation,\n        bytes calldata _params\n    ) external {\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n\n        // Data for the callback receiveFlashLoan\n        bytes memory userData;\n        if (_operation == Operation.OpenTrove) {\n            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =\n                abi.decode(_params, (ILeverageZapper.OpenLeveragedTroveParams));\n            userData = abi.encode(_caller, _operation, openTroveParams);\n        } else if (_operation == Operation.LeverUpTrove) {\n            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =\n                abi.decode(_params, (ILeverageZapper.LeverUpTroveParams));\n            userData = abi.encode(_caller, _operation, leverUpTroveParams);\n        } else if (_operation == Operation.LeverDownTrove) {\n            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =\n                abi.decode(_params, (ILeverageZapper.LeverDownTroveParams));\n            userData = abi.encode(_caller, _operation, leverDownTroveParams);\n        } else {\n            revert(\"LZ: Wrong Operation\");\n        }\n\n        vault.flashLoan(this, tokens, amounts, userData);\n    }\n\n    function receiveFlashLoan(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata feeAmounts,\n        bytes calldata userData\n    ) external override {\n        require(msg.sender == address(vault), \"Caller is not Vault\");\n\n        // decode receiver and operation\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(abi.decode(userData[0:32], (address)));\n        Operation operation = abi.decode(userData[32:64], (Operation));\n\n        if (operation == Operation.OpenTrove) {\n            // Open\n            // decode params\n            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =\n                abi.decode(userData[64:], (ILeverageZapper.OpenLeveragedTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiver), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiver.receiveFlashLoanOnOpenLeveragedTrove(openTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.LeverUpTrove) {\n            // Lever up\n            // decode params\n            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =\n                abi.decode(userData[64:], (ILeverageZapper.LeverUpTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiver), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiver.receiveFlashLoanOnLeverUpTrove(leverUpTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.LeverDownTrove) {\n            // Lever down\n            // decode params\n            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =\n                abi.decode(userData[64:], (ILeverageZapper.LeverDownTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiver), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiver.receiveFlashLoanOnLeverDownTrove(leverDownTroveParams, effectiveFlashLoanAmount);\n        } else {\n            revert(\"LZ: Wrong Operation\");\n        }\n\n        // Return flash loan\n        tokens[0].safeTransfer(address(vault), amounts[0] + feeAmounts[0]);\n    }\n}\n"
    }
}