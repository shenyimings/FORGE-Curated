{
    "vfp_id": "vfp_00287",
    "project_name": "report_cantinacode_eco_may2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Incorrect equivalence assumption on chain IDs and prover domain IDs may lead to loss of solver funds",
            "description": "The protocol incorrectly assumes that chain IDs are equivalent to prover domain IDs in HyperProver.sol and MetaProver.sol, using them interchangeably when formatting prover calls. This is a flawed assumption because cross-chain frameworks like Hyperlane and Metalayer use distinct domain ID systems that do not always align with EVM chain IDs. An attacker could exploit this by crafting a malicious fulfillment request on a chain where the domain ID and chain ID differ, causing incorrect routing or execution. This leads to the loss of solver funds used to fulfill intents, as the system may reject valid proofs or route them incorrectly.\n",
            "severity": "High",
            "location": [
                "HyperProver.sol#L297",
                "MetaProver.sol#L251"
            ],
            "files": [
                "eco-routes/contracts/prover/HyperProver.sol",
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Assumed instant finality may lead to loss of intent creator funds in reorg scenarios",
            "description": "The MetaProver contract assumes instant finality by using FinalityState.INSTANT when verifying proofs, without accounting for blockchain reorganizations. The root cause is the lack of delay or confirmation checks before accepting a proof as valid. In the event of a chain reorg, a previously accepted proof could become invalid, but the system has already processed the fulfillment on the destination chain. This allows a solver to receive rewards on the source chain while the corresponding fulfillment is rolled back, resulting in a loss of funds for the intent creator. While deep reorgs are rare on chains like Ethereum, the impact is high when they occur.\n",
            "severity": "Medium",
            "location": [
                "MetaProver.sol#L143-L150"
            ],
            "files": [
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        }
    ],
    "affected_files": {
        "MetaProver.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IMetalayerRecipient, ReadOperation} from \"@metalayer/contracts/src/interfaces/IMetalayerRecipient.sol\";\nimport {FinalityState} from \"@metalayer/contracts/src/lib/MetalayerMessage.sol\";\nimport {TypeCasts} from \"@hyperlane-xyz/core/contracts/libs/TypeCasts.sol\";\nimport {MessageBridgeProver} from \"./MessageBridgeProver.sol\";\n// Import Semver for versioning support\nimport {Semver} from \"../libs/Semver.sol\";\nimport {StandardHookMetadata} from \"@hyperlane-xyz/core/contracts/hooks/libs/StandardHookMetadata.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IMetalayerRouterExt} from \"../interfaces/IMetalayerRouterExt.sol\";\n\n/**\n * @title MetaProver\n * @notice Prover implementation using Caldera Metalayer's cross-chain messaging system\n * @notice the terms \"source\" and \"destination\" are used in reference to a given intent: created on source chain, fulfilled on destination chain\n * @dev Processes proof messages from Metalayer router and records proven intents\n */\ncontract MetaProver is IMetalayerRecipient, MessageBridgeProver, Semver {\n    using TypeCasts for bytes32;\n    using TypeCasts for address;\n    using SafeCast for uint256;\n\n    /**\n     * @notice Struct for unpacked data from _data parameter\n     * @dev Contains fields decoded from the _data parameter\n     */\n    struct UnpackedData {\n        bytes32 sourceChainProver; // Address of prover on source chain\n        uint256 gasLimit; // Gas limit for execution\n    }\n\n    /**\n     * @notice Constant indicating this contract uses Metalayer for proving\n     */\n    string public constant PROOF_TYPE = \"Meta\";\n\n    /**\n     * @notice ETH message value used in fee calculation metadata\n     * @dev Set to very high value (1e36) to avoid fee calculation failures\n     *      in the Metalayer router's quote dispatch function\n     */\n    uint256 private immutable ETH_QUOTE_VALUE = 1e36;\n\n    /**\n     * @notice Address of local Metalayer router\n     */\n    IMetalayerRouterExt public immutable ROUTER;\n\n    /**\n     * @notice Initializes the MetaProver contract\n     * @param router Address of local Metalayer router\n     * @param portal Address of Portal contract\n     * @param provers Array of trusted prover addresses (as bytes32 for cross-VM compatibility)\n     * @param minGasLimit Minimum gas limit for cross-chain messages (200k if zero)\n     */\n    constructor(\n        address router,\n        address portal,\n        bytes32[] memory provers,\n        uint256 minGasLimit\n    ) MessageBridgeProver(portal, provers, minGasLimit) {\n        if (router == address(0)) revert MessengerContractCannotBeZeroAddress();\n\n        ROUTER = IMetalayerRouterExt(router);\n    }\n\n    /**\n     * @notice Handles incoming Metalayer messages containing proof data\n     * @dev Processes batch updates to proven intents from valid sources\n     * @dev called by the Metalayer Router on the source chain\n     * @param origin Origin chain ID from the destination chain\n     * @param sender Address that dispatched the message on destination chain\n     * @param message Encoded array of intent hashes and claimants\n     */\n    function handle(\n        uint32 origin,\n        bytes32 sender,\n        bytes calldata message,\n        ReadOperation[] calldata /* operations */,\n        bytes[] calldata /* operationsData */\n    ) external payable only(address(ROUTER)) {\n        // Verify origin and sender are valid\n        if (origin == 0) revert MessageOriginChainDomainIDCannotBeZero();\n\n        // Validate sender is not zero\n        if (sender == bytes32(0)) revert MessageSenderCannotBeZeroAddress();\n\n        _handleCrossChainMessage(sender, message);\n    }\n\n    /**\n     * @notice Decodes the raw cross-chain message data into a structured format\n     * @dev Parses ABI-encoded parameters into the UnpackedData struct and enforces minimum gas limit\n     * @param data Raw message data containing source chain information\n     * @return unpacked Structured representation of the decoded parameters with validated gas limit\n     */\n    function _unpackData(\n        bytes calldata data\n    ) internal view returns (UnpackedData memory unpacked) {\n        unpacked = abi.decode(data, (UnpackedData));\n\n        // Enforce minimum gas limit to prevent underfunded transactions\n        if (unpacked.gasLimit < MIN_GAS_LIMIT) {\n            unpacked.gasLimit = MIN_GAS_LIMIT;\n        }\n    }\n\n    /**\n     * @notice Implementation of message dispatch for Metalayer\n     * @dev Called by base prove() function after common validations\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data for message formatting\n     * @param fee Fee amount for message dispatch\n     */\n    function _dispatchMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data,\n        uint256 fee\n    ) internal override {\n        // Parse incoming data into a structured format\n        UnpackedData memory unpacked = _unpackData(data);\n\n        // Format message for dispatch using pre-decoded value\n        (\n            uint32 sourceChainDomain,\n            bytes32 recipient,\n            bytes memory message\n        ) = _formatMetalayerMessage(\n                domainID,\n                encodedProofs,\n                unpacked.sourceChainProver\n            );\n\n        // Call Metalayer router's send message function\n        ROUTER.dispatch{value: fee}(\n            sourceChainDomain,\n            recipient,\n            new ReadOperation[](0),\n            message,\n            FinalityState.INSTANT,\n            unpacked.gasLimit\n        );\n    }\n\n    /**\n     * @notice Fetches fee required for message dispatch\n     * @dev Uses custom hook metadata with actual gas limit to ensure accurate fee estimation.\n     *      Fixes issue where 3-parameter quoteDispatch used hardcoded 100k gas limit.\n     * @param domainID Domain ID of source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data containing gas limit that will be used in dispatch\n     * @return Fee amount required for message dispatch\n     */\n    function fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data\n    ) public view override returns (uint256) {\n        // Delegate to internal function with pre-decoded value\n        return _fetchFee(domainID, encodedProofs, _unpackData(data));\n    }\n\n    /**\n     * @notice Internal function to calculate fee with pre-decoded data\n     * @dev Uses actual gas limit from unpacked data to ensure accurate fee estimation\n     * @param domainID Domain ID of source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param unpacked Pre-decoded data including actual gas limit that will be used\n     * @return Fee amount required for message dispatch\n     */\n    function _fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        UnpackedData memory unpacked\n    ) internal view returns (uint256) {\n        (\n            uint32 sourceChainDomain,\n            bytes32 recipient,\n            bytes memory message\n        ) = _formatMetalayerMessage(\n                domainID,\n                encodedProofs,\n                unpacked.sourceChainProver\n            );\n\n        // Create custom hook metadata with the actual gas limit that will be used in dispatch\n        bytes memory feeHookMetadata = StandardHookMetadata.formatMetadata(\n            ETH_QUOTE_VALUE,\n            unpacked.gasLimit, // Use actual gas limit (min 200k)\n            msg.sender, // Refund address\n            bytes(\"\") // Optional custom metadata\n        );\n\n        return\n            ROUTER.quoteDispatch(\n                sourceChainDomain,\n                recipient,\n                message,\n                feeHookMetadata\n            );\n    }\n\n    /**\n     * @notice Returns the proof type used by this prover\n     * @return ProofType indicating Metalayer proving mechanism\n     */\n    function getProofType() external pure override returns (string memory) {\n        return PROOF_TYPE;\n    }\n\n    /**\n     * @notice Formats data for Metalayer message dispatch with encoded proofs\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param sourceChainProver Pre-decoded prover address on source chain\n     * @return domain Metalayer domain ID\n     * @return recipient Recipient address encoded as bytes32\n     * @return message Encoded message body with intent hashes and claimants\n     */\n    function _formatMetalayerMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes32 sourceChainProver\n    )\n        internal\n        pure\n        returns (uint32 domain, bytes32 recipient, bytes memory message)\n    {\n        // Convert domain ID to domain with overflow check\n        if (domainID > type(uint32).max) {\n            revert DomainIdTooLarge(domainID);\n        }\n        domain = uint32(domainID);\n\n        // Use pre-decoded source chain prover address as recipient\n        recipient = sourceChainProver;\n\n        message = encodedProofs;\n    }\n}\n",
        "HyperProver.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IMessageRecipient} from \"@hyperlane-xyz/core/contracts/interfaces/IMessageRecipient.sol\";\nimport {TypeCasts} from \"@hyperlane-xyz/core/contracts/libs/TypeCasts.sol\";\nimport {MessageBridgeProver} from \"./MessageBridgeProver.sol\";\nimport {Semver} from \"../libs/Semver.sol\";\nimport {IMailbox, IPostDispatchHook} from \"@hyperlane-xyz/core/contracts/interfaces/IMailbox.sol\";\n\n/**\n * @title HyperProver\n * @notice Prover implementation using Hyperlane's cross-chain messaging system\n * @dev Processes proof messages from Hyperlane mailbox and records proven intents\n */\ncontract HyperProver is IMessageRecipient, MessageBridgeProver, Semver {\n    using TypeCasts for bytes32;\n\n    /**\n     * @notice Struct for unpacked data from _data parameter\n     * @dev Only contains fields decoded from the _data parameter\n     */\n    struct UnpackedData {\n        bytes32 sourceChainProver; // Address of prover on source chain\n        bytes metadata; // Metadata for Hyperlane message\n        address hookAddr; // Address of post-dispatch hook\n    }\n\n    /**\n     * @notice Struct for Hyperlane dispatch parameters\n     * @dev Consolidates message dispatch parameters to reduce stack usage\n     */\n    struct DispatchParams {\n        uint32 destinationDomain; // Hyperlane domain ID\n        bytes32 recipientAddress; // Recipient address encoded as bytes32\n        bytes messageBody; // Encoded message body with intent hashes and claimants\n        bytes metadata; // Additional metadata for the message\n        IPostDispatchHook hook; // Post-dispatch hook contract\n    }\n\n    /**\n     * @notice Constant indicating this contract uses Hyperlane for proving\n     */\n    string public constant PROOF_TYPE = \"Hyperlane\";\n\n    /**\n     * @notice Address of local Hyperlane mailbox\n     */\n    address public immutable MAILBOX;\n\n    /**\n     * @param mailbox Address of local Hyperlane mailbox\n     * @param portal Address of Portal contract\n     * @param provers Array of trusted prover addresses (as bytes32 for cross-VM compatibility)\n     */\n    constructor(\n        address mailbox,\n        address portal,\n        bytes32[] memory provers\n    ) MessageBridgeProver(portal, provers, 0) {\n        if (mailbox == address(0)) revert MessengerContractCannotBeZeroAddress();\n        MAILBOX = mailbox;\n    }\n\n    /**\n     * @notice Handles incoming Hyperlane messages containing proof data\n     * @dev Processes batch updates to proven intents from valid sources\n     * @param origin Origin chain ID from the source chain\n     * @param sender Address that dispatched the message on source chain\n     * @param messageBody Encoded array of intent hashes and claimants\n     */\n    function handle(\n        uint32 origin,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) public payable only(MAILBOX) {\n        // Verify origin and sender are valid\n        if (origin == 0) revert MessageOriginChainDomainIDCannotBeZero();\n\n        // Validate sender is not zero\n        if (sender == bytes32(0)) revert MessageSenderCannotBeZeroAddress();\n\n        _handleCrossChainMessage(sender, messageBody);\n    }\n\n    /**\n     * @notice Implementation of message dispatch for Hyperlane\n     * @dev Called by base prove() function after common validations\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data for message formatting\n     * @param fee Fee amount for message dispatch\n     */\n    function _dispatchMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data,\n        uint256 fee\n    ) internal override {\n        // Parse incoming data into a structured format for processing\n        UnpackedData memory unpacked = _unpackData(data);\n\n        // Prepare parameters for cross-chain message dispatch using a struct\n        // to reduce stack usage and improve code maintainability\n        DispatchParams memory params = _formatHyperlaneMessage(\n            domainID,\n            encodedProofs,\n            unpacked\n        );\n\n        // Send the message through Hyperlane mailbox using params from the struct\n        // Note: Some Hyperlane versions have different dispatch signatures.\n        // This matches the expected signature for testing.\n        IMailbox(MAILBOX).dispatch{value: fee}(\n            params.destinationDomain,\n            params.recipientAddress,\n            params.messageBody,\n            params.metadata,\n            params.hook\n        );\n    }\n\n    /**\n     * @notice Calculates the fee required for Hyperlane message dispatch\n     * @dev Queries the Mailbox contract for accurate fee estimation\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data for message formatting\n     * @return Fee amount required for message dispatch\n     */\n    function fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data\n    ) public view override returns (uint256) {\n        // Decode structured data from the raw input\n        UnpackedData memory unpacked = _unpackData(data);\n\n        // Process fee calculation using the decoded struct\n        // This architecture separates decoding from core business logic\n        return _fetchFee(domainID, encodedProofs, unpacked);\n    }\n\n    /**\n     * @notice Decodes the raw cross-chain message data into a structured format\n     * @dev Parses ABI-encoded parameters into the UnpackedData struct\n     * @param data Raw message data containing source chain information\n     * @return unpacked Structured representation of the decoded parameters\n     */\n    function _unpackData(\n        bytes calldata data\n    ) internal pure returns (UnpackedData memory unpacked) {\n        unpacked = abi.decode(data, (UnpackedData));\n    }\n\n    /**\n     * @notice Internal function to calculate the fee with pre-decoded data\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param unpacked Struct containing decoded data from data parameter\n     * @return Fee amount required for message dispatch\n     */\n    function _fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        UnpackedData memory unpacked\n    ) internal view returns (uint256) {\n        // Format and prepare message parameters for dispatch\n        DispatchParams memory params = _formatHyperlaneMessage(\n            domainID,\n            encodedProofs,\n            unpacked\n        );\n\n        // Query Hyperlane mailbox for accurate fee estimate\n        return\n            IMailbox(MAILBOX).quoteDispatch(\n                params.destinationDomain,\n                params.recipientAddress,\n                params.messageBody,\n                params.metadata,\n                params.hook\n            );\n    }\n\n    /**\n     * @notice Returns the proof type used by this prover\n     * @return ProofType indicating Hyperlane proving mechanism\n     */\n    function getProofType() external pure override returns (string memory) {\n        return PROOF_TYPE;\n    }\n\n    /**\n     * @notice Formats data for Hyperlane message dispatch with encoded proofs\n     * @dev Prepares all parameters needed for the Mailbox dispatch call\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param unpacked Struct containing decoded data from data parameter\n     * @return params Structured dispatch parameters for Hyperlane message\n     */\n    function _formatHyperlaneMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        UnpackedData memory unpacked\n    ) internal view returns (DispatchParams memory params) {\n        // Convert domain ID to Hyperlane domain ID format with overflow check\n        if (domainID > type(uint32).max) {\n            revert DomainIdTooLarge(domainID);\n        }\n        params.destinationDomain = uint32(domainID);\n\n        // Use the source chain prover address as the message recipient\n        params.recipientAddress = unpacked.sourceChainProver;\n\n        params.messageBody = encodedProofs;\n\n        // Pass through metadata as provided\n        params.metadata = unpacked.metadata;\n\n        // Default to mailbox's hook if none provided, following Hyperlane best practices\n        params.hook = (unpacked.hookAddr == address(0))\n            ? IMailbox(MAILBOX).defaultHook()\n            : IPostDispatchHook(unpacked.hookAddr);\n    }\n}\n"
    }
}