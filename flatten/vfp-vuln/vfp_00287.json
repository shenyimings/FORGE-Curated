{
    "vfp_id": "vfp_00287",
    "project_name": "ackee-blockchain-lido-stonks-2.0-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Flawed ETH/USD routing",
            "description": "The vulnerability arises in the OracleRouter contract's getPricesAndDecimals function, which reverts when the requested quote denomination (ETH or USD) does not match the configured primary quote for either token in a pair. This flawed logic prevents the use of an ETH/USD bridge to route prices when tokens are configured with different denominations. As a result, when a user attempts to swap tokens where one is USD-quoted and the other is ETH-quoted, the function call reverts. This leads to a denial of service for users trying to create orders for such token pairs, effectively blocking functionality for mixed-denomination swaps. The root cause is the lack of fallback logic to use the ETH/USD price bridge when direct denomination matching fails.\n",
            "severity": "Medium",
            "location": [
                "OracleRouter.sol::getPricesAndDecimals",
                "AmountConverter.sol::getExpectedOut"
            ],
            "files": [
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "OracleRouter.sol": "// SPDX-FileCopyrightText: 2024 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {Ownable} from \"../Ownable.sol\";\nimport {IOracleRouter} from \"../interfaces/IOracleRouter.sol\";\nimport {IFeedRegistry} from \"../interfaces/IFeedRegistry.sol\";\n\n/**\n * @title OracleRouter\n * @notice Price router based on Chainlink Feed Registry with two hop options:\n *         - TOKEN/USD (preferred), or\n *         - TOKEN/ETH bridged via ETH/USD.\n *         All outputs are normalized to PRICE_UNIT (10 ** PRICE_DECIMALS).\n */\ncontract OracleRouter is IOracleRouter, Ownable {\n    // ==================== Immutables ====================\n\n    /// @notice Number of decimals used for price normalization (typically 8 or 18).\n    uint8 public immutable PRICE_DECIMALS;\n    /// @notice Price unit calculated as 10 ** PRICE_DECIMALS.\n    uint256 public immutable PRICE_UNIT;\n    /// @notice Address of the Chainlink Feed Registry contract.\n    address public immutable FEED_REGISTRY;\n\n    // ==================== Constants ====================\n\n    /// @notice Address representing USD denomination in Chainlink Feed Registry.\n    address private constant USD_DENOMINATION = 0x0000000000000000000000000000000000000348;\n    /// @notice Address representing ETH denomination in Chainlink Feed Registry.\n    address private constant ETH_DENOMINATION = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Maximum supported decimals for feeds and tokens.\n    uint128 public constant MAX_DECIMALS = 38;\n\n    // ==================== Type Definitions ====================\n\n    struct FeedConfig {\n        address aggregator;\n        uint128 scaleNumerator;\n        uint128 scaleDenominator;\n        uint32 maxStalenessSeconds;\n        uint8 aggregatorDecimals;\n    }\n\n    struct TokenConfig {\n        IOracleRouter.QuoteDenomination primaryQuote;\n        FeedConfig primaryFeed;\n        uint8 tokenDecimals;\n        bool isActive;\n        uint32 ethUsdMaxStalenessOverrideSeconds; // 0 => use global bridge staleness\n    }\n\n    struct BridgeCache {\n        uint256 price;\n        uint32 capSeconds;\n    }\n\n    // ==================== Storage Variables ====================\n\n    /// @notice Mapping from token address to its price feed configuration.\n    mapping(address => TokenConfig) public tokenConfig;\n    /// @notice Configuration for the ETH/USD bridge feed used for tokens quoted in ETH.\n    FeedConfig public ethUsdBridge;\n\n    // ==================== Events ====================\n\n    event TokenConfigured(\n        address indexed token,\n        IOracleRouter.QuoteDenomination primaryQuote,\n        address indexed aggregator,\n        uint8 aggregatorDecimals,\n        uint32 maxStalenessSeconds,\n        uint8 tokenDecimals,\n        uint128 scaleNumerator,\n        uint128 scaleDenominator,\n        bool isActive\n    );\n    event TokenActiveUpdated(address indexed token, bool isActive);\n    event EthUsdBridgeConfigured(\n        address indexed aggregator,\n        uint8 aggregatorDecimals,\n        uint32 maxStalenessSeconds,\n        uint128 scaleNumerator,\n        uint128 scaleDenominator\n    );\n    event TokenEthUsdStalenessOverridden(address indexed token, uint32 overrideSeconds);\n\n    // ==================== Errors ====================\n\n    error InvalidFeedRegistryAddress(address feedRegistry);\n    error InvalidTokenAddress(address token);\n    error InvalidStaleness();\n    error InvalidAggregatorDecimals();\n    error InvalidUnitDecimals();\n    error InvalidTokenDecimals();\n    error TokenNotConfigured(address token);\n    error TokenDecimalsMismatch(uint8 erc20Decimals, uint8 providedDecimals);\n    error TokenStateUnchanged(address token, bool currentState);\n    error EthUsdBridgeMissing();\n    error FeedMissing(address base, address quote);\n    error FeedConfigOutOfSync(\n        address expectedAggregator,\n        address actualAggregator,\n        uint8 expectedDecimals,\n        uint8 actualDecimals\n    );\n    error OracleStale(address aggregator, uint256 lastUpdate);\n    error OracleBadAnswer(address aggregator, int256 answer);\n    error OracleUnanswered(address aggregator, uint80 roundId, uint80 answeredInRound);\n    error OracleQuantizedToZero(address aggregator, uint8 feedDecimals, uint8 unitDecimals);\n\n    // ==================== Constructor ====================\n\n    /**\n     * @notice Constructor\n     * @param agent_ Address of the owner agent.\n     * @param unitDecimals_ Number of decimals for price normalization.\n     * @param feedRegistry_ Address of the Chainlink Feed Registry.\n     */\n    constructor(address agent_, uint8 unitDecimals_, address feedRegistry_) Ownable(agent_) {\n        if (unitDecimals_ == 0 || unitDecimals_ > MAX_DECIMALS) {\n            revert InvalidUnitDecimals();\n        }\n\n        if (feedRegistry_ == address(0)) {\n            revert InvalidFeedRegistryAddress(feedRegistry_);\n        }\n\n        FEED_REGISTRY = feedRegistry_;\n        PRICE_DECIMALS = unitDecimals_;\n\n        unchecked {\n            PRICE_UNIT = 10 ** unitDecimals_;\n        }\n    }\n\n    // ==================== External Functions ====================\n\n    /**\n     * @notice Sets the ETH/USD bridge configuration for token price routing.\n     * @param maxStalenessSeconds_ Maximum allowed staleness for ETH/USD price feed.\n     */\n    function setEthUsdBridge(uint32 maxStalenessSeconds_) external onlyAgentOrManager {\n        if (maxStalenessSeconds_ == 0) {\n            revert InvalidStaleness();\n        }\n\n        _updateEthUsdBridge(maxStalenessSeconds_);\n    }\n\n    /**\n     * @notice Synchronizes the ETH/USD bridge configuration with current feed registry state.\n     * @dev Preserves the existing staleness threshold while updating feed metadata.\n     */\n    function syncEthUsdBridge() external onlyAgentOrManager {\n        _updateEthUsdBridge(ethUsdBridge.maxStalenessSeconds);\n    }\n\n    /**\n     * @notice Sets the feed configuration for a token.\n     * @param token_ Address of the token to configure.\n     * @param primaryQuote_ Primary quote denomination (USD or ETH).\n     * @param maxStalenessSeconds_ Maximum allowed staleness for the price feed.\n     * @param tokenDecimals_ Number of decimals for the token.\n     * @param isActive_ Whether the token should be active for price queries.\n     */\n    function setTokenFeed(\n        address token_,\n        IOracleRouter.QuoteDenomination primaryQuote_,\n        uint32 maxStalenessSeconds_,\n        uint8 tokenDecimals_,\n        bool isActive_\n    ) external onlyAgentOrManager {\n        _setTokenFeed(token_, primaryQuote_, maxStalenessSeconds_, tokenDecimals_, isActive_);\n    }\n\n    /**\n     * @notice Sets a custom staleness override for ETH/USD bridge when used for a specific token.\n     * @param token_ Address of the token to configure.\n     * @param overrideSeconds_ Custom staleness threshold for this token's ETH/USD bridge usage.\n     */\n    function setTokenEthUsdStalenessOverride(\n        address token_,\n        uint32 overrideSeconds_\n    ) external onlyAgentOrManager {\n        if (token_ == address(0)) {\n            revert InvalidTokenAddress(token_);\n        }\n\n        tokenConfig[token_].ethUsdMaxStalenessOverrideSeconds = overrideSeconds_;\n\n        emit TokenEthUsdStalenessOverridden(token_, overrideSeconds_);\n    }\n\n    /**\n     * @notice Sets the active status of a token configuration.\n     * @param token_ Address of the token to configure.\n     * @param isActive_ Whether the token should be active for price queries.\n     */\n    function setTokenActive(address token_, bool isActive_) external onlyAgentOrManager {\n        if (token_ == address(0)) {\n            revert InvalidTokenAddress(token_);\n        }\n\n        TokenConfig storage config = tokenConfig[token_];\n\n        if (config.isActive == isActive_) {\n            revert TokenStateUnchanged(token_, config.isActive);\n        }\n\n        if (isActive_) {\n            if (config.tokenDecimals == 0) {\n                revert TokenNotConfigured(token_);\n            }\n        }\n\n        config.isActive = isActive_;\n        emit TokenActiveUpdated(token_, isActive_);\n    }\n\n    /**\n     * @notice Synchronizes a token's feed configuration with current feed registry state.\n     * @param token_ Address of the token to synchronize.\n     */\n    function syncTokenFeed(address token_) external onlyAgentOrManager {\n        TokenConfig storage config = tokenConfig[token_];\n\n        if (config.tokenDecimals == 0) {\n            revert TokenNotConfigured(token_);\n        }\n\n        address quote;\n        if (config.primaryQuote == IOracleRouter.QuoteDenomination.USD) {\n            quote = USD_DENOMINATION;\n        } else {\n            quote = ETH_DENOMINATION;\n        }\n\n        (\n            address aggregator,\n            uint8 decimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        ) = _resolveFeedAndScale(token_, quote);\n\n        FeedConfig storage primaryFeed = config.primaryFeed;\n        primaryFeed.aggregator = aggregator;\n        primaryFeed.aggregatorDecimals = decimals;\n        primaryFeed.scaleNumerator = scaleNumerator;\n        primaryFeed.scaleDenominator = scaleDenominator;\n\n        emit TokenConfigured(\n            token_,\n            config.primaryQuote,\n            aggregator,\n            decimals,\n            primaryFeed.maxStalenessSeconds,\n            config.tokenDecimals,\n            scaleNumerator,\n            scaleDenominator,\n            config.isActive\n        );\n    }\n\n    // ==================== External View Functions ====================\n\n    /**\n     * @notice Gets USD prices for two tokens.\n     * @param baseToken_ Address of the base token.\n     * @param quoteToken_ Address of the quote token.\n     * @return baseUsdPrice USD price of the base token.\n     * @return quoteUsdPrice USD price of the quote token.\n     */\n    function getUsdPrices(\n        address baseToken_,\n        address quoteToken_\n    ) external view returns (uint256 baseUsdPrice, uint256 quoteUsdPrice) {\n        return _getUsdPrices(baseToken_, quoteToken_);\n    }\n\n    /**\n     * @notice Gets prices and decimal places for two tokens in the requested quote denomination.\n     * @dev Tokens can have different primary quote denominations (USD or ETH). If a token's\n     *      primary quote doesn't match the requested quote, the price will be bridged through\n     *      ETH/USD to convert to the requested denomination.\n     * @param baseToken_ Address of the base token.\n     * @param quoteToken_ Address of the quote token.\n     * @param quote_ Requested quote denomination (USD or ETH) for the returned prices.\n     * @return basePrice Price of the base token in the requested quote (normalized to PRICE_UNIT).\n     * @return quotePrice Price of the quote token in the requested quote (normalized to PRICE_UNIT).\n     * @return baseTokenDecimals Number of decimals for the base token.\n     * @return quoteTokenDecimals Number of decimals for the quote token.\n     */\n    function getPricesAndDecimals(\n        address baseToken_,\n        address quoteToken_,\n        IOracleRouter.QuoteDenomination quote_\n    )\n        external\n        view\n        returns (\n            uint256 basePrice,\n            uint256 quotePrice,\n            uint8 baseTokenDecimals,\n            uint8 quoteTokenDecimals\n        )\n    {\n        TokenConfig storage baseConfig = tokenConfig[baseToken_];\n        baseTokenDecimals = baseConfig.tokenDecimals;\n\n        if (!baseConfig.isActive || baseTokenDecimals == 0) {\n            revert TokenNotConfigured(baseToken_);\n        }\n\n        TokenConfig storage quoteConfig = tokenConfig[quoteToken_];\n        quoteTokenDecimals = quoteConfig.tokenDecimals;\n\n        if (!quoteConfig.isActive || quoteTokenDecimals == 0) {\n            revert TokenNotConfigured(quoteToken_);\n        }\n\n        BridgeCache memory sharedBridge = _sharedBridgeIfSameCap(\n            baseConfig.primaryQuote != quote_,\n            quoteConfig.primaryQuote != quote_,\n            baseConfig,\n            quoteConfig\n        );\n\n        // Get prices in the requested quote denomination, bridging through ETH/USD if needed\n        basePrice = _getPriceInQuote(baseToken_, baseConfig, quote_, sharedBridge);\n        quotePrice = _getPriceInQuote(quoteToken_, quoteConfig, quote_, sharedBridge);\n    }\n\n    /**\n     * @notice Checks if the ETH/USD bridge configuration is synchronized with the feed registry.\n     * @return True if the bridge configuration matches the current feed registry state.\n     */\n    function isBridgeInSync() external view returns (bool) {\n        (address aggregator, uint8 decimals) = _currentFeedMeta(ETH_DENOMINATION, USD_DENOMINATION);\n        FeedConfig storage bridge = ethUsdBridge;\n\n        return (aggregator == bridge.aggregator && decimals == bridge.aggregatorDecimals);\n    }\n\n    /**\n     * @notice Checks if a token's feed configuration is synchronized with the feed registry.\n     * @param token_ Address of the token to check.\n     * @return True if the token configuration matches the current feed registry state.\n     */\n    function isFeedInSync(address token_) external view returns (bool) {\n        TokenConfig storage configEntry = tokenConfig[token_];\n\n        if (configEntry.tokenDecimals == 0) {\n            return false;\n        }\n\n        address quote;\n        if (configEntry.primaryQuote == IOracleRouter.QuoteDenomination.USD) {\n            quote = USD_DENOMINATION;\n        } else {\n            quote = ETH_DENOMINATION;\n        }\n\n        (address aggregator, uint8 decimals) = _currentFeedMeta(token_, quote);\n\n        return (aggregator == configEntry.primaryFeed.aggregator &&\n            decimals == configEntry.primaryFeed.aggregatorDecimals);\n    }\n\n    // ==================== Internal Functions ====================\n\n    /**\n     * @dev Updates ETH/USD bridge configuration. Consolidates logic for setEthUsdBridge and syncEthUsdBridge.\n     * @param maxStalenessSeconds_ Maximum allowed staleness for ETH/USD price feed.\n     */\n    function _updateEthUsdBridge(uint32 maxStalenessSeconds_) internal {\n        (\n            address aggregator,\n            uint8 decimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        ) = _resolveFeedAndScale(ETH_DENOMINATION, USD_DENOMINATION);\n\n        ethUsdBridge = FeedConfig({\n            aggregator: aggregator,\n            maxStalenessSeconds: maxStalenessSeconds_,\n            aggregatorDecimals: decimals,\n            scaleNumerator: scaleNumerator,\n            scaleDenominator: scaleDenominator\n        });\n\n        emit EthUsdBridgeConfigured(\n            aggregator,\n            decimals,\n            maxStalenessSeconds_,\n            scaleNumerator,\n            scaleDenominator\n        );\n    }\n\n    /**\n     * @dev Gets USD price for a token, optionally reusing a shared ETH/USD bridge price.\n     * @param token_ Address of the token to price.\n     * @param config_ Token configuration.\n     * @param sharedBridge_ Cached ETH/USD bridge price and cap (if available).\n     * @return price USD price of the token, normalized to PRICE_UNIT.\n     */\n    function _getUsdPrice(\n        address token_,\n        TokenConfig storage config_,\n        BridgeCache memory sharedBridge_\n    ) internal view returns (uint256 price) {\n        if (!config_.isActive || config_.tokenDecimals == 0) {\n            revert TokenNotConfigured(token_);\n        }\n\n        return\n            _getPriceInQuote(token_, config_, IOracleRouter.QuoteDenomination.USD, sharedBridge_);\n    }\n\n    /**\n     * @dev Gets USD prices for two tokens with gas optimization for shared ETH/USD bridge.\n     * When both tokens are ETH-quoted with same staleness cap, fetches ETH/USD once.\n     */\n    function _getUsdPrices(\n        address baseToken_,\n        address quoteToken_\n    ) internal view returns (uint256 baseUsdPrice, uint256 quoteUsdPrice) {\n        TokenConfig storage baseConfig = tokenConfig[baseToken_];\n        TokenConfig storage quoteConfig = tokenConfig[quoteToken_];\n\n        BridgeCache memory sharedBridge = _sharedBridgeIfSameCap(\n            baseConfig.primaryQuote == IOracleRouter.QuoteDenomination.ETH,\n            quoteConfig.primaryQuote == IOracleRouter.QuoteDenomination.ETH,\n            baseConfig,\n            quoteConfig\n        );\n\n        baseUsdPrice = _getUsdPrice(baseToken_, baseConfig, sharedBridge);\n        quoteUsdPrice = _getUsdPrice(quoteToken_, quoteConfig, sharedBridge);\n    }\n\n    function _sharedBridgeIfSameCap(\n        bool firstNeedsBridge_,\n        bool secondNeedsBridge_,\n        TokenConfig storage firstConfig_,\n        TokenConfig storage secondConfig_\n    ) internal view returns (BridgeCache memory cache) {\n        if (!firstNeedsBridge_ || !secondNeedsBridge_) {\n            return cache;\n        }\n\n        uint32 firstCap = _effectiveEthUsdStaleness(firstConfig_);\n        uint32 secondCap = _effectiveEthUsdStaleness(secondConfig_);\n\n        if (firstCap != secondCap) {\n            return cache;\n        }\n\n        uint256 price = _readEthUsdWithCap(firstCap);\n\n        if (price == 0) {\n            return cache;\n        }\n\n        cache = BridgeCache({price: price, capSeconds: firstCap});\n    }\n\n    function _readEthUsdWithCap(uint32 capSeconds_) internal view returns (uint256) {\n        FeedConfig storage bridge = ethUsdBridge;\n\n        if (bridge.aggregatorDecimals == 0) {\n            revert EthUsdBridgeMissing();\n        }\n\n        FeedConfig memory bridgeCopy = bridge;\n        bridgeCopy.maxStalenessSeconds = capSeconds_;\n\n        return _readNormalizedPrice(ETH_DENOMINATION, USD_DENOMINATION, bridgeCopy);\n    }\n\n    function _effectiveEthUsdStaleness(TokenConfig storage config) internal view returns (uint32) {\n        uint32 overrideSeconds = config.ethUsdMaxStalenessOverrideSeconds;\n        uint32 maxStaleness = ethUsdBridge.maxStalenessSeconds;\n\n        if (overrideSeconds == 0) {\n            return maxStaleness;\n        }\n\n        if (overrideSeconds < maxStaleness) {\n            return overrideSeconds;\n        } else {\n            return maxStaleness;\n        }\n    }\n\n    function _getPriceInQuote(\n        address token_,\n        TokenConfig storage config_,\n        IOracleRouter.QuoteDenomination requestedQuote_,\n        BridgeCache memory sharedBridge_\n    ) internal view returns (uint256 price) {\n        // If the token's primary quote matches the requested quote, use it directly\n        if (config_.primaryQuote == requestedQuote_) {\n            if (requestedQuote_ == IOracleRouter.QuoteDenomination.USD) {\n                return _readNormalizedPrice(token_, USD_DENOMINATION, config_.primaryFeed);\n            } else {\n                return _readNormalizedPrice(token_, ETH_DENOMINATION, config_.primaryFeed);\n            }\n        }\n\n        // Need to bridge through ETH/USD\n        // Get the token's price in its primary quote\n        uint256 tokenInPrimaryQuote;\n        if (config_.primaryQuote == IOracleRouter.QuoteDenomination.USD) {\n            tokenInPrimaryQuote = _readNormalizedPrice(\n                token_,\n                USD_DENOMINATION,\n                config_.primaryFeed\n            );\n        } else {\n            tokenInPrimaryQuote = _readNormalizedPrice(\n                token_,\n                ETH_DENOMINATION,\n                config_.primaryFeed\n            );\n        }\n\n        // Get ETH/USD price for bridging\n        uint32 cap = _effectiveEthUsdStaleness(config_);\n        uint256 ethUsdPrice;\n\n        if (sharedBridge_.price != 0 && sharedBridge_.capSeconds == cap) {\n            ethUsdPrice = sharedBridge_.price;\n        } else {\n            ethUsdPrice = _readEthUsdWithCap(cap);\n        }\n\n        // Convert to requested quote\n        if (requestedQuote_ == IOracleRouter.QuoteDenomination.USD) {\n            // Token is ETH-quoted, need USD: token/ETH * ETH/USD = token/USD\n            price = Math.mulDiv(tokenInPrimaryQuote, ethUsdPrice, PRICE_UNIT);\n        } else {\n            // Token is USD-quoted, need ETH: token/USD / ETH/USD = token/ETH\n            price = Math.mulDiv(tokenInPrimaryQuote, PRICE_UNIT, ethUsdPrice);\n        }\n    }\n\n    function _readNormalizedPrice(\n        address baseToken_,\n        address quoteToken_,\n        FeedConfig memory feedConfig_\n    ) internal view returns (uint256 normalizedPrice) {\n        IFeedRegistry registry = IFeedRegistry(FEED_REGISTRY);\n\n        address liveAggregator = registry.getFeed(baseToken_, quoteToken_);\n        uint8 liveDecimals = registry.decimals(baseToken_, quoteToken_);\n\n        if (\n            liveAggregator != feedConfig_.aggregator ||\n            liveDecimals != feedConfig_.aggregatorDecimals\n        ) {\n            revert FeedConfigOutOfSync(\n                feedConfig_.aggregator,\n                liveAggregator,\n                feedConfig_.aggregatorDecimals,\n                liveDecimals\n            );\n        }\n\n        (uint80 roundId, int256 rawAnswer, , uint256 updatedAt, uint80 answeredInRound) = registry\n            .latestRoundData(baseToken_, quoteToken_);\n\n        if (rawAnswer <= 0) {\n            revert OracleBadAnswer(feedConfig_.aggregator, rawAnswer);\n        }\n\n        if (answeredInRound < roundId) {\n            revert OracleUnanswered(feedConfig_.aggregator, roundId, answeredInRound);\n        }\n\n        if (block.timestamp - updatedAt > feedConfig_.maxStalenessSeconds) {\n            revert OracleStale(feedConfig_.aggregator, updatedAt);\n        }\n\n        normalizedPrice = Math.mulDiv(\n            uint256(rawAnswer),\n            feedConfig_.scaleNumerator,\n            feedConfig_.scaleDenominator\n        );\n\n        if (normalizedPrice == 0) {\n            revert OracleQuantizedToZero(feedConfig_.aggregator, liveDecimals, PRICE_DECIMALS);\n        }\n    }\n\n    function _setTokenFeed(\n        address token_,\n        IOracleRouter.QuoteDenomination primaryQuote_,\n        uint32 maxStalenessSeconds_,\n        uint8 tokenDecimals_,\n        bool isActive_\n    ) internal {\n        if (token_ == address(0)) {\n            revert InvalidTokenAddress(token_);\n        }\n\n        if (maxStalenessSeconds_ == 0) {\n            revert InvalidStaleness();\n        }\n\n        uint8 erc20Decimals;\n        if (tokenDecimals_ != 0) {\n            erc20Decimals = tokenDecimals_;\n        } else {\n            erc20Decimals = IERC20Metadata(token_).decimals();\n        }\n\n        if (erc20Decimals == 0 || erc20Decimals > MAX_DECIMALS) {\n            revert InvalidTokenDecimals();\n        }\n\n        if (tokenDecimals_ != 0) {\n            uint8 onchain = IERC20Metadata(token_).decimals();\n            if (onchain != erc20Decimals) {\n                revert TokenDecimalsMismatch(onchain, erc20Decimals);\n            }\n        }\n\n        address quote;\n        if (primaryQuote_ == IOracleRouter.QuoteDenomination.USD) {\n            quote = USD_DENOMINATION;\n        } else {\n            quote = ETH_DENOMINATION;\n        }\n\n        (\n            address aggregator,\n            uint8 feedDecimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        ) = _resolveFeedAndScale(token_, quote);\n\n        tokenConfig[token_] = TokenConfig({\n            primaryQuote: primaryQuote_,\n            primaryFeed: FeedConfig({\n                aggregator: aggregator,\n                maxStalenessSeconds: maxStalenessSeconds_,\n                aggregatorDecimals: feedDecimals,\n                scaleNumerator: scaleNumerator,\n                scaleDenominator: scaleDenominator\n            }),\n            tokenDecimals: erc20Decimals,\n            isActive: isActive_,\n            ethUsdMaxStalenessOverrideSeconds: 0\n        });\n\n        emit TokenConfigured(\n            token_,\n            primaryQuote_,\n            aggregator,\n            feedDecimals,\n            maxStalenessSeconds_,\n            erc20Decimals,\n            scaleNumerator,\n            scaleDenominator,\n            isActive_\n        );\n    }\n\n    function _resolveFeedAndScale(\n        address baseToken_,\n        address quoteToken_\n    )\n        internal\n        view\n        returns (\n            address aggregator,\n            uint8 decimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        )\n    {\n        IFeedRegistry registry = IFeedRegistry(FEED_REGISTRY);\n\n        aggregator = registry.getFeed(baseToken_, quoteToken_);\n\n        if (aggregator == address(0)) {\n            revert FeedMissing(baseToken_, quoteToken_);\n        }\n\n        decimals = registry.decimals(baseToken_, quoteToken_);\n\n        if (decimals == 0 || decimals > MAX_DECIMALS) {\n            revert InvalidAggregatorDecimals();\n        }\n\n        (scaleNumerator, scaleDenominator) = _computeScaleFactors(decimals);\n    }\n\n    function _currentFeedMeta(\n        address baseToken_,\n        address quoteToken_\n    ) internal view returns (address aggregator, uint8 decimals) {\n        IFeedRegistry registry = IFeedRegistry(FEED_REGISTRY);\n\n        aggregator = registry.getFeed(baseToken_, quoteToken_);\n        decimals = registry.decimals(baseToken_, quoteToken_);\n    }\n\n    function _computeScaleFactors(\n        uint8 feedDecimals_\n    ) internal view returns (uint128 numerator, uint128 denominator) {\n        if (feedDecimals_ == PRICE_DECIMALS) {\n            return (1, 1);\n        }\n\n        if (feedDecimals_ < PRICE_DECIMALS) {\n            uint8 upDiff = PRICE_DECIMALS - feedDecimals_;\n\n            if (upDiff > MAX_DECIMALS) {\n                revert InvalidAggregatorDecimals();\n            }\n\n            unchecked {\n                return (uint128(10 ** upDiff), 1);\n            }\n        }\n\n        uint8 downDiff = feedDecimals_ - PRICE_DECIMALS;\n\n        if (downDiff > MAX_DECIMALS) {\n            revert InvalidAggregatorDecimals();\n        }\n\n        unchecked {\n            return (1, uint128(10 ** downDiff));\n        }\n    }\n}\n"
    }
}