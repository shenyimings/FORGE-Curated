{
    "vfp_id": "vfp_00066",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Bypassing Element Verification Allows for Unauthorized Manipulation of Exogenous Claim Data",
            "description": "The protocol uses cryptographic hashes to validate exogenous multichain claim requests, which include arbiter addresses, token IDs, and allocated amounts. These are signed by the sponsor to ensure integrity. However, the `toExogenousMultichainClaimMessageHash` function skips inserting the current element's hash if the `chainIndex` is out of bounds.\nThe cause is a flaw in boundary checking logic, which allows an attacker to manipulate the hash computation by providing an invalid `chainIndex`. This omission creates a gap that can be exploited using the `witness` field, which is placed at a predictable memory offset.\nThe attacker can manually insert the last `additionalChain` hash via the `witness` field to reconstruct the original sponsor-signed hash, while substituting malicious data (e.g., their own arbiter address and arbitrary allocations) into the current element. By front-running a legitimate claim with valid allocator authorization, the attacker can execute unauthorized payouts.\nThe impact includes full control over claim parameters, enabling theft of funds or misdirection of token transfers, even without compromising the sponsor's private key.\n",
            "severity": "High",
            "location": [
                "HashLib.sol::toExogenousMultichainClaimMessageHash#413",
                "HashLib.sol#459-462",
                "HashLib.sol#466",
                "HashLib.sol#433"
            ],
            "files": [
                "the-compact/src/lib/HashLib.sol"
            ]
        }
    ],
    "affected_files": {
        "HashLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { TransferComponent, Component, ComponentsById, BatchClaimComponent } from \"../types/Components.sol\";\nimport {\n    COMPACT_TYPEHASH,\n    COMPACT_TYPESTRING_FRAGMENT_ONE,\n    COMPACT_TYPESTRING_FRAGMENT_TWO,\n    COMPACT_TYPESTRING_FRAGMENT_THREE,\n    COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    BATCH_COMPACT_TYPEHASH,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SIX,\n    PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH\n} from \"../types/EIP712Types.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { TransferFunctionCastLib } from \"./TransferFunctionCastLib.sol\";\n\n/**\n * @title HashLib\n * @notice Library contract implementing logic for deriving hashes as part of processing\n * claims, allocated transfers, and withdrawals, including deriving typehashes when\n * witness data is utilized and qualification hashes when claims have been qualified by\n * the allocator.\n */\nlibrary HashLib {\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using HashLib for uint256;\n    using HashLib for uint256[2][];\n    using HashLib for AllocatedBatchTransfer;\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a transfer or withdrawal.\n     * @param transfer     An AllocatedTransfer struct containing the transfer details.\n     * @return messageHash The EIP-712 compliant message hash.\n     */\n    function toTransferMessageHash(AllocatedTransfer calldata transfer) internal view returns (bytes32 messageHash) {\n        // Declare variables for tracking, total amount, current amount, and errors.\n        uint256 amount = 0;\n        uint256 currentAmount;\n        uint256 errorBuffer;\n\n        // Navigate to the components array in calldata.\n        Component[] calldata recipients = transfer.recipients;\n\n        // Retrieve the length of the array.\n        uint256 totalRecipients = recipients.length;\n\n        unchecked {\n            // Iterate over each component.\n            for (uint256 i = 0; i < totalRecipients; ++i) {\n                // Retrieve the current amount of the component.\n                currentAmount = recipients[i].amount;\n\n                // Add current amount to total amount and check for overflow.\n                amount += currentAmount;\n                errorBuffer |= (amount < currentAmount).asUint256();\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Revert if an arithmetic overflow was detected.\n            if errorBuffer {\n                // Revert Panic(0x11) (arithmetic overflow)\n                mstore(0, 0x4e487b71)\n                mstore(0x20, 0x11)\n                revert(0x1c, 0x24)\n            }\n\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare initial components of message data: typehash, arbiter, & sponsor.\n            mstore(m, COMPACT_TYPEHASH)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n            mstore(add(m, 0x40), caller()) // sponsor: msg.sender\n\n            // Subsequent data copied from calldata: nonce, expires & id.\n            calldatacopy(add(m, 0x60), add(transfer, 0x20), 0x60)\n\n            // Prepare final component of message data: aggregate amount.\n            mstore(add(m, 0xc0), amount)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xe0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch transfer or withdrawal.\n     * @param transfer     An AllocatedBatchTransfer struct containing the transfer details.\n     * @return messageHash The EIP-712 compliant message hash.\n     */\n    function toBatchTransferMessageHash(AllocatedBatchTransfer calldata transfer) internal view returns (bytes32) {\n        // Navigate to the transfer components array in calldata.\n        ComponentsById[] calldata transfers = transfer.transfers;\n\n        // Retrieve the length of the array.\n        uint256 totalIds = transfers.length;\n\n        // Allocate memory region for ids and amounts.\n        bytes memory idsAndAmounts = new bytes(totalIds * 0x40);\n\n        // Declare a buffer for arithmetic errors.\n        uint256 errorBuffer;\n\n        unchecked {\n            // Iterate over each transfer component.\n            for (uint256 i = 0; i < totalIds; ++i) {\n                // Navigate to the current transfer component.\n                ComponentsById calldata transferComponent = transfers[i];\n\n                // Retrieve the id from the current transfer component.\n                uint256 id = transferComponent.id;\n\n                // Declare a variable for the aggregate amount.\n                uint256 amount = 0;\n\n                // Declare a variable for the current amount.\n                uint256 singleAmount;\n\n                // Navigate to the portions array in the current transfer component.\n                Component[] calldata portions = transferComponent.portions;\n\n                // Retrieve the length of the portions array.\n                uint256 portionsLength = portions.length;\n\n                // Iterate over each portion.\n                for (uint256 j = 0; j < portionsLength; ++j) {\n                    // Retrieve the current amount of the portion.\n                    singleAmount = portions[j].amount;\n\n                    // Add current amount to aggregate amount and check for overflow.\n                    amount += singleAmount;\n                    errorBuffer |= (amount < singleAmount).asUint256();\n                }\n\n                assembly (\"memory-safe\") {\n                    // Derive offset to id and amount based on total components.\n                    let extraOffset := add(add(idsAndAmounts, 0x20), shl(6, i))\n\n                    // Store the id and aggregate amount at the derived offset.\n                    mstore(extraOffset, id)\n                    mstore(add(extraOffset, 0x20), amount)\n                }\n            }\n        }\n\n        // Declare a variable for the ids and amounts hash.\n        uint256 idsAndAmountsHash;\n        assembly (\"memory-safe\") {\n            // Revert if an arithmetic overflow was detected.\n            if errorBuffer {\n                // Revert Panic(0x11) (arithmetic overflow)\n                mstore(0, 0x4e487b71)\n                mstore(0x20, 0x11)\n                revert(0x1c, 0x24)\n            }\n\n            // Derive the ids and amounts hash from the stored data.\n            idsAndAmountsHash := keccak256(add(idsAndAmounts, 0x20), mload(idsAndAmounts))\n        }\n\n        // Derive message hash from transfer data and idsAndAmounts hash.\n        return toBatchTransferMessageHashUsingIdsAndAmountsHash(transfer, idsAndAmountsHash);\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a claim with a witness.\n     * @param claim               Pointer to the claim location in calldata.\n     * @return messageHash        The EIP-712 compliant message hash.\n     * @return typehash           The EIP-712 typehash.\n     */\n    function toMessageHashWithWitness(uint256 claim) internal view returns (bytes32 messageHash, bytes32 typehash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Derive the pointer to the witness typestring.\n            let witnessTypestringPtr := add(claim, calldataload(add(claim, 0xc0)))\n\n            // Retrieve the length of the witness typestring.\n            let witnessTypestringLength := calldataload(witnessTypestringPtr)\n\n            // Prepare first component of typestring from four one-word fragments.\n            mstore(m, COMPACT_TYPESTRING_FRAGMENT_ONE)\n            mstore(add(m, 0x20), COMPACT_TYPESTRING_FRAGMENT_TWO)\n            mstore(add(m, 0x58), COMPACT_TYPESTRING_FRAGMENT_FOUR)\n            mstore(add(m, 0x40), COMPACT_TYPESTRING_FRAGMENT_THREE)\n\n            // Copy remaining typestring data from calldata to memory.\n            let witnessStart := add(m, 0x78)\n            calldatacopy(witnessStart, add(0x20, witnessTypestringPtr), witnessTypestringLength)\n\n            // Prepare closing \")\" parenthesis at the very end of the memory region.\n            mstore8(add(witnessStart, witnessTypestringLength), 0x29)\n\n            // Derive the typehash from the prepared data.\n            typehash := keccak256(m, add(0x79, witnessTypestringLength))\n\n            // Prepare initial components of message data: typehash & arbiter.\n            mstore(m, typehash)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n            // Next data segment copied from calldata: sponsor, nonce, expires.\n            calldatacopy(add(m, 0x40), add(claim, 0x40), 0x60)\n\n            // Prepare final components of message data: id, amount, & witness.\n            mstore(add(m, 0xa0), calldataload(add(claim, 0xe0))) // id\n            mstore(add(m, 0xc0), calldataload(add(claim, 0x100))) // amount\n            mstore(add(m, 0xe0), calldataload(add(claim, 0xa0))) // witness\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0x100)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch transfer or withdrawal once an idsAndAmounts hash is available.\n     * @param transfer          An AllocatedBatchTransfer struct containing the transfer details.\n     * @param idsAndAmountsHash A hash of the ids and amounts.\n     * @return messageHash      The EIP-712 compliant message hash.\n     */\n    function toBatchTransferMessageHashUsingIdsAndAmountsHash(\n        AllocatedBatchTransfer calldata transfer,\n        uint256 idsAndAmountsHash\n    ) internal view returns (bytes32 messageHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare initial components of message data: typehash, arbiter, & sponsor.\n            mstore(m, BATCH_COMPACT_TYPEHASH)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n            mstore(add(m, 0x40), caller()) // sponsor: msg.sender\n\n            // Next data segment copied from calldata: nonce & expires.\n            mstore(add(m, 0x60), calldataload(add(transfer, 0x20))) // nonce\n            mstore(add(m, 0x80), calldataload(add(transfer, 0x40))) // expires\n\n            // Prepare final component of message data: idsAndAmountsHash.\n            mstore(add(m, 0xa0), idsAndAmountsHash)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xc0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch transfer or withdrawal.\n     * @param claim             Pointer to the claim location in calldata.\n     * @param idsAndAmountsHash A hash of the ids and amounts.\n     * @return messageHash      The EIP-712 compliant message hash.\n     */\n    function toBatchMessageHash(uint256 claim, uint256 idsAndAmountsHash) internal view returns (bytes32 messageHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare initial components of message data: typehash & arbiter.\n            mstore(m, BATCH_COMPACT_TYPEHASH)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n            // Next data segment copied from calldata: sponsor, nonce, expires.\n            calldatacopy(add(m, 0x40), add(claim, 0x40), 0x60) // sponsor, nonce, expires\n\n            // Prepare final component of message data: idsAndAmountsHash.\n            mstore(add(m, 0xa0), idsAndAmountsHash)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xc0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch claim with a witness.\n     * @param claim             Pointer to the claim location in calldata.\n     * @param idsAndAmountsHash A hash of the ids and amounts.\n     * @return messageHash      The EIP-712 compliant message hash.\n     * @return typehash         The EIP-712 typehash.\n     */\n    function toBatchClaimWithWitnessMessageHash(uint256 claim, uint256 idsAndAmountsHash)\n        internal\n        view\n        returns (bytes32 messageHash, bytes32 typehash)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Derive the pointer to the witness typestring.\n            let witnessTypestringPtr := add(claim, calldataload(add(claim, 0xc0)))\n\n            // Retrieve the length of the witness typestring.\n            let witnessTypestringLength := calldataload(witnessTypestringPtr)\n\n            // Prepare first component of typestring from four one-word fragments.\n            mstore(m, BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE)\n            mstore(add(m, 0x20), BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO)\n            mstore(add(m, 0x5e), BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n            mstore(add(m, 0x40), BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE)\n\n            // Copy remaining typestring data from calldata to memory.\n            let witnessStart := add(m, 0x7e)\n            calldatacopy(witnessStart, add(0x20, witnessTypestringPtr), witnessTypestringLength)\n\n            // Prepare closing \")\" parenthesis at the very end of the memory region.\n            mstore8(add(witnessStart, witnessTypestringLength), 0x29)\n\n            // Derive the typehash from the prepared data.\n            typehash := keccak256(m, add(0x7f, witnessTypestringLength))\n\n            // Prepare initial components of message data: typehash & arbiter.\n            mstore(m, typehash)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n            // Next data segment copied from calldata: sponsor, nonce, expires.\n            calldatacopy(add(m, 0x40), add(claim, 0x40), 0x60)\n\n            // Prepare final components of message data: idsAndAmountsHash & witness.\n            mstore(add(m, 0xa0), idsAndAmountsHash)\n            mstore(add(m, 0xc0), calldataload(add(claim, 0xa0))) // witness\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xe0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a multichain claim.\n     * @param claim                     Pointer to the claim location in calldata.\n     * @param additionalOffset          Additional offset from claim pointer to ID from most compact case.\n     * @param elementTypehash           The element typehash.\n     * @param multichainCompactTypehash The multichain compact typehash.\n     * @param idsAndAmountsHash         A hash of the ids and amounts.\n     * @return messageHash              The EIP-712 compliant message hash.\n     */\n    function toMultichainClaimMessageHash(\n        uint256 claim,\n        uint256 additionalOffset,\n        bytes32 elementTypehash,\n        bytes32 multichainCompactTypehash,\n        uint256 idsAndAmountsHash\n    ) internal view returns (bytes32 messageHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Store the idsAndAmounts hash at the beginning of the memory region.\n            mstore(add(m, 0x60), idsAndAmountsHash)\n\n            // Prepare initial components of element data: element typehash, arbiter, & chainid.\n            mstore(m, elementTypehash)\n            mstore(add(m, 0x20), caller()) // arbiter\n            mstore(add(m, 0x40), chainid())\n\n            // Store the witness in memory.\n            mstore(add(m, 0x80), calldataload(add(claim, 0xa0))) // witness\n\n            // Derive the first element hash from the prepared data and write it to memory.\n            mstore(m, keccak256(m, 0xa0))\n\n            // Derive the pointer to the additional chains and retrieve the length.\n            let additionalChainsPtr := add(claim, calldataload(add(add(claim, additionalOffset), 0xa0)))\n            let additionalChainsLength := shl(5, calldataload(additionalChainsPtr))\n\n            // Copy the element hashes in the additional chains array from calldata to memory.\n            calldatacopy(add(m, 0x20), add(0x20, additionalChainsPtr), additionalChainsLength)\n\n            // Derive hash of element hashes from prepared data and write it to memory.\n            mstore(add(m, 0x80), keccak256(m, add(0x20, additionalChainsLength)))\n\n            // Prepare next component of message data: multichain compact typehash.\n            mstore(m, multichainCompactTypehash)\n\n            // Copy final message data components from calldata: sponsor, nonce & expires.\n            calldatacopy(add(m, 0x20), add(claim, 0x40), 0x60)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xa0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * an exogenous multichain claim.\n     * @param claim                     Pointer to the claim location in calldata.\n     * @param additionalOffset          Additional offset from claim pointer to ID from most compact case.\n     * @param elementTypehash           The element typehash.\n     * @param multichainCompactTypehash The multichain compact typehash.\n     * @param idsAndAmountsHash         A hash of the ids and amounts.\n     * @return messageHash              The EIP-712 compliant message hash.\n     */\n    function toExogenousMultichainClaimMessageHash(\n        uint256 claim,\n        uint256 additionalOffset,\n        bytes32 elementTypehash,\n        bytes32 multichainCompactTypehash,\n        uint256 idsAndAmountsHash\n    ) internal view returns (bytes32 messageHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Store the idsAndAmounts hash at the beginning of the memory region.\n            mstore(add(m, 0x60), idsAndAmountsHash)\n\n            // Prepare initial components of element data: element typehash, arbiter, & chainid.\n            mstore(m, elementTypehash)\n            mstore(add(m, 0x20), caller()) // arbiter\n            mstore(add(m, 0x40), chainid())\n\n            // Store the witness in memory.\n            mstore(add(m, 0x80), calldataload(add(claim, 0xa0))) // witness\n\n            // Derive the element hash from the prepared data and write it to memory.\n            let elementHash := keccak256(m, 0xa0)\n\n            // Derive the pointer to the additional chains and retrieve the length.\n            let claimWithAdditionalOffset := add(claim, additionalOffset)\n            let additionalChainsPtr := add(claim, calldataload(add(claimWithAdditionalOffset, 0xa0)))\n\n            // Retrieve the length of the additional chains array.\n            let additionalChainsLength := shl(5, calldataload(additionalChainsPtr))\n\n            // Derive the pointer to the additional chains data array in calldata.\n            let additionalChainsData := add(0x20, additionalChainsPtr)\n\n            // Retrieve the chain index from calldata.\n            let chainIndex := shl(5, calldataload(add(claimWithAdditionalOffset, 0xc0)))\n\n            // NOTE: rather than using extraOffset, consider breaking into two distinct\n            // loops or potentially even two calldatacopy operations based on chainIndex\n            let extraOffset := 0\n\n            // Iterate over the additional chains array and store each element hash in memory.\n            for { let i := 0 } lt(i, additionalChainsLength) { i := add(i, 0x20) } {\n                mstore(add(add(m, i), extraOffset), calldataload(add(additionalChainsData, i)))\n                // If current index matches chain index, store derived hash and increment offset.\n                if eq(i, chainIndex) {\n                    extraOffset := 0x20\n                    mstore(add(m, add(i, extraOffset)), elementHash)\n                }\n            }\n\n            // Derive the hash of the element hashes from the prepared data and write it to memory.\n            mstore(add(m, 0x80), keccak256(m, add(0x20, additionalChainsLength)))\n\n            // Prepare next component of message data: multichain compact typehash.\n            mstore(m, multichainCompactTypehash)\n\n            // Copy final message data components from calldata: sponsor, nonce & expires.\n            calldatacopy(add(m, 0x20), add(claim, 0x40), 0x60)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xa0)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the EIP-712 typehashes for\n     * multichain claims.\n     * @param claim                      Pointer to the claim location in calldata.\n     * @return elementTypehash           The element typehash.\n     * @return multichainCompactTypehash The multichain compact typehash.\n     */\n    function toMultichainTypehashes(uint256 claim)\n        internal\n        pure\n        returns (bytes32 elementTypehash, bytes32 multichainCompactTypehash)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Derive the pointer to the witness typestring and retrieve the length.\n            let witnessTypestringPtr := add(claim, calldataload(add(claim, 0xc0)))\n            let witnessTypestringLength := calldataload(witnessTypestringPtr)\n\n            // Prepare the first five fragments of the multichain compact typehash.\n            mstore(m, MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_ONE)\n            mstore(add(m, 0x20), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_TWO)\n            mstore(add(m, 0x40), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_THREE)\n            mstore(add(m, 0x60), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n            mstore(add(m, 0x8e), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SIX)\n            mstore(add(m, 0x80), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FIVE)\n\n            // Copy remaining witness typestring from calldata to memory.\n            let witnessStart := add(m, 0xae)\n            calldatacopy(witnessStart, add(0x20, witnessTypestringPtr), witnessTypestringLength)\n\n            // Prepare closing \")\" parenthesis at the very end of the memory region.\n            mstore8(add(witnessStart, witnessTypestringLength), 0x29)\n\n            // Derive the element typehash and multichain compact typehash from the prepared data.\n            elementTypehash := keccak256(add(m, 0x53), add(0x5c, witnessTypestringLength))\n            multichainCompactTypehash := keccak256(m, add(0xaf, witnessTypestringLength))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the EIP-712 message hash for\n     * a single id and amount.\n     * @param claim              Pointer to the claim location in calldata.\n     * @param additionalOffset   Additional offset from claim pointer to ID from most compact case.\n     * @return idsAndAmountsHash The hash of the id and amount.\n     */\n    function toSingleIdAndAmountHash(uint256 claim, uint256 additionalOffset)\n        internal\n        pure\n        returns (uint256 idsAndAmountsHash)\n    {\n        assembly (\"memory-safe\") {\n            // Derive the pointer to the claim with additional offset.\n            let claimWithAdditionalOffset := add(claim, additionalOffset)\n\n            // Store the id and amount at the beginning of the memory region.\n            mstore(0, calldataload(add(claimWithAdditionalOffset, 0xc0)))\n            mstore(0x20, calldataload(add(claimWithAdditionalOffset, 0xe0)))\n\n            // Derive the idsAndAmounts hash from the stored data.\n            idsAndAmountsHash := keccak256(0, 0x40)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the hash of ids and amounts provided.\n     * @param idsAndAmounts      An array of ids and amounts.\n     * @param replacementAmounts An optional array of replacement amounts.\n     * @return idsAndAmountsHash The hash of the ids and amounts.\n     * @dev This function expects that the calldata of idsAndAmounts will have bounds\n     * checked elsewhere; using it without this check occurring elsewhere can result in\n     * erroneous hash values. This function also assumes that replacementAmounts.length\n     * does not exceed replacementAmounts.length and will break if the invariant is not\n     * upheld.\n     */\n    function toIdsAndAmountsHash(uint256[2][] calldata idsAndAmounts, uint256[] memory replacementAmounts)\n        internal\n        pure\n        returns (bytes32 idsAndAmountsHash)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let ptr := mload(0x40)\n\n            // Get the total length of the calldata slice.\n            // Each element of the array consists of 2 words.\n            let len := shl(6, idsAndAmounts.length)\n\n            // Copy calldata into memory at the free memory pointer.\n            calldatacopy(ptr, idsAndAmounts.offset, len)\n\n            let amountDataStart := add(ptr, 0x20)\n            let replacementDataStart := add(replacementAmounts, 0x20)\n            let amountsToReplace := mload(replacementAmounts)\n\n            // Iterate over the replacementAmounts array, splicing in the updated amounts.\n            for { let i := 0 } lt(i, amountsToReplace) { i := add(i, 1) } {\n                mstore(add(amountDataStart, shl(6, i)), mload(add(replacementDataStart, shl(5, i))))\n            }\n\n            // Compute the hash of the calldata that has been copied into memory.\n            idsAndAmountsHash := keccak256(ptr, len)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the hash of the ids and amounts.\n     * @param claims             An array of BatchClaimComponent structs.\n     * @return idsAndAmountsHash The hash of the ids and amounts.\n     */\n    function toIdsAndAmountsHash(BatchClaimComponent[] calldata claims)\n        internal\n        pure\n        returns (uint256 idsAndAmountsHash)\n    {\n        // Retrieve the total number of ids in the claims array.\n        uint256 totalIds = claims.length;\n\n        // Prepare a memory region for storing the ids and amounts.\n        bytes memory idsAndAmounts = new bytes(totalIds << 6);\n\n        unchecked {\n            // Iterate over the claims array.\n            for (uint256 i = 0; i < totalIds; ++i) {\n                // Navigate to the current claim component in calldata.\n                BatchClaimComponent calldata claimComponent = claims[i];\n\n                assembly (\"memory-safe\") {\n                    // Derive the offset to the current position in the memory region,\n                    // then retrieve and store the id and amount at the current position.\n                    calldatacopy(add(add(idsAndAmounts, 0x20), shl(6, i)), claimComponent, 0x40)\n                }\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Derive the hash of the ids and amounts from the prepared data.\n            idsAndAmountsHash := keccak256(add(idsAndAmounts, 0x20), mload(idsAndAmounts))\n        }\n    }\n\n    //// Registration Hashes ////\n\n    /**\n     * @notice Internal pure function for retrieving an EIP-712 claim hash.\n     * @param sponsor      The account sponsoring the claimed compact.\n     * @param tokenId      Identifier for the associated token & lock.\n     * @param amount       Claim's associated number of tokens.\n     * @param arbiter      Account verifying and initiating the settlement of the claim.\n     * @param nonce        Allocator replay protection nonce.\n     * @param expires      Timestamp when the claim expires.\n     * @param typehash     Typehash of the entire compact. Including the subtypes.\n     * @param witness      EIP712 structured hash of witness.\n     * @return messageHash The corresponding EIP-712 messagehash.\n     */\n    function toFlatMessageHashWithWitness(\n        address sponsor,\n        uint256 tokenId,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) internal pure returns (bytes32 messageHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            mstore(m, typehash)\n            mstore(add(m, 0x20), arbiter)\n            mstore(add(m, 0x40), sponsor)\n            mstore(add(m, 0x60), nonce)\n            mstore(add(m, 0x80), expires)\n            mstore(add(m, 0xa0), tokenId)\n            mstore(add(m, 0xc0), amount)\n            mstore(add(m, 0xe0), witness)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0x100)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for retrieving an EIP-712 claim hash.\n     * @param sponsor            The account sponsoring the claimed compact.\n     * @param idsAndAmounts      An array with IDs and aggregate transfer amounts.\n     * @param arbiter            Account verifying and initiating the settlement of the claim.\n     * @param nonce              Allocator replay protection nonce.\n     * @param expires            Timestamp when the claim expires.\n     * @param typehash           Typehash of the entire compact. Including the subtypes.\n     * @param witness            EIP712 structured hash of witness.\n     * @param replacementAmounts An optional array of replacement amounts.\n     * @return messageHash       The corresponding EIP-712 messagehash.\n     */\n    function toFlatBatchClaimWithWitnessMessageHash(\n        address sponsor,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness,\n        uint256[] memory replacementAmounts\n    ) internal pure returns (bytes32 messageHash) {\n        bytes32 idsAndAmountsHash = idsAndAmounts.toIdsAndAmountsHash(replacementAmounts);\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            mstore(m, typehash)\n            mstore(add(m, 0x20), arbiter)\n            mstore(add(m, 0x40), sponsor)\n            mstore(add(m, 0x60), nonce)\n            mstore(add(m, 0x80), expires)\n            mstore(add(m, 0xa0), idsAndAmountsHash)\n            mstore(add(m, 0xc0), witness)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xe0)\n        }\n    }\n}\n"
    }
}