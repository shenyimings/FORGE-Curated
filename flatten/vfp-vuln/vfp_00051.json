{
    "vfp_id": "vfp_00051",
    "project_name": "Virtuals Protocol Genesis - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-282"
                ],
                "3": [
                    "CWE-708"
                ]
            },
            "title": "Wrong creator address is set during Agent token launch",
            "description": "The vulnerability occurs when the Bonding.launch() function sets msg.sender (the Genesis contract) as the creator of a new Agent token, instead of the actual user who initiated the Genesis creation. This happens because the function does not accept an explicit creator address parameter, defaulting to msg.sender. As a result, the Genesis contract becomes the recorded creator, which is problematic because it cannot interact with the Agent Factory or voting systems. This leads to a situation where the creator—supposed to have proposer privileges such as withdrawing an application or becoming an LP staker via veToken—is an inoperable contract. An attacker could potentially exploit this by launching a token and then preventing proper governance actions due to the invalid creator, undermining the intended permission model and decentralization goals.\n",
            "severity": "High",
            "location": [
                "Bonding.sol#L250",
                "AgentFactoryV3.sol#L555"
            ],
            "files": [
                "2f51fc99606d83d7d8ca00d14f52d43e08c873dc/protocol-contracts/contracts/fun/Bonding.sol",
                "2f51fc99606d83d7d8ca00d14f52d43e08c873dc/protocol-contracts/contracts/virtualPersona/AgentFactoryV3.sol"
            ]
        }
    ],
    "affected_files": {
        "Bonding.sol": "// SPDX-License-Identifier: MIT\n// Modified from https://github.com/sourlodine/Pump.fun-Smart-Contract/blob/main/contracts/PumpFun.sol\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FFactory.sol\";\nimport \"./IFPair.sol\";\nimport \"./FRouter.sol\";\nimport \"./FERC20.sol\";\nimport \"../virtualPersona/IAgentFactoryV3.sol\";\n\ncontract Bonding is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    address private _feeTo;\n\n    FFactory public factory;\n    FRouter public router;\n    uint256 public initialSupply;\n    uint256 public fee;\n    uint256 public constant K = 3_000_000_000_000;\n    uint256 public assetRate;\n    uint256 public gradThreshold;\n    uint256 public maxTx;\n    address public agentFactory;\n    struct Profile {\n        address user;\n        address[] tokens;\n    }\n\n    struct Token {\n        address creator;\n        address token;\n        address pair;\n        address agentToken;\n        Data data;\n        string description;\n        uint8[] cores;\n        string image;\n        string twitter;\n        string telegram;\n        string youtube;\n        string website;\n        bool trading;\n        bool tradingOnUniswap;\n    }\n\n    struct Data {\n        address token;\n        string name;\n        string _name;\n        string ticker;\n        uint256 supply;\n        uint256 price;\n        uint256 marketCap;\n        uint256 liquidity;\n        uint256 volume;\n        uint256 volume24H;\n        uint256 prevPrice;\n        uint256 lastUpdated;\n    }\n\n    struct DeployParams {\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n    }\n\n    DeployParams private _deployParams;\n\n    mapping(address => Profile) public profile;\n    address[] public profiles;\n\n    mapping(address => Token) public tokenInfo;\n    address[] public tokenInfos;\n\n    event Launched(address indexed token, address indexed pair, uint);\n    event Deployed(address indexed token, uint256 amount0, uint256 amount1);\n    event Graduated(address indexed token, address agentToken);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address factory_,\n        address router_,\n        address feeTo_,\n        uint256 fee_,\n        uint256 initialSupply_,\n        uint256 assetRate_,\n        uint256 maxTx_,\n        address agentFactory_,\n        uint256 gradThreshold_\n    ) external initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n\n        factory = FFactory(factory_);\n        router = FRouter(router_);\n\n        _feeTo = feeTo_;\n        fee = (fee_ * 1 ether) / 1000;\n\n        initialSupply = initialSupply_;\n        assetRate = assetRate_;\n        maxTx = maxTx_;\n\n        agentFactory = agentFactory_;\n        gradThreshold = gradThreshold_;\n    }\n\n    function _createUserProfile(address _user) internal returns (bool) {\n        address[] memory _tokens;\n\n        Profile memory _profile = Profile({user: _user, tokens: _tokens});\n\n        profile[_user] = _profile;\n\n        profiles.push(_user);\n\n        return true;\n    }\n\n    function _checkIfProfileExists(address _user) internal view returns (bool) {\n        return profile[_user].user == _user;\n    }\n\n    function _approval(\n        address _spender,\n        address _token,\n        uint256 amount\n    ) internal returns (bool) {\n        IERC20(_token).forceApprove(_spender, amount);\n\n        return true;\n    }\n\n    function setInitialSupply(uint256 newSupply) public onlyOwner {\n        initialSupply = newSupply;\n    }\n\n    function setGradThreshold(uint256 newThreshold) public onlyOwner {\n        gradThreshold = newThreshold;\n    }\n\n    function setFee(uint256 newFee, address newFeeTo) public onlyOwner {\n        fee = newFee;\n        _feeTo = newFeeTo;\n    }\n\n    function setMaxTx(uint256 maxTx_) public onlyOwner {\n        maxTx = maxTx_;\n    }\n\n    function setAssetRate(uint256 newRate) public onlyOwner {\n        require(newRate > 0, \"Rate err\");\n\n        assetRate = newRate;\n    }\n\n    function setDeployParams(DeployParams memory params) public onlyOwner {\n        _deployParams = params;\n    }\n\n    function getUserTokens(\n        address account\n    ) public view returns (address[] memory) {\n        require(_checkIfProfileExists(account), \"User Profile dose not exist.\");\n\n        Profile memory _profile = profile[account];\n\n        return _profile.tokens;\n    }\n\n    function launch(\n        string memory _name,\n        string memory _ticker,\n        uint8[] memory cores,\n        string memory desc,\n        string memory img,\n        string[4] memory urls,\n        uint256 purchaseAmount\n    ) public nonReentrant returns (address, address, uint) {\n        require(\n            purchaseAmount > fee,\n            \"Purchase amount must be greater than fee\"\n        );\n        address assetToken = router.assetToken();\n        require(\n            IERC20(assetToken).balanceOf(msg.sender) >= purchaseAmount,\n            \"Insufficient amount\"\n        );\n        uint256 initialPurchase = (purchaseAmount - fee);\n        IERC20(assetToken).safeTransferFrom(msg.sender, _feeTo, fee);\n        IERC20(assetToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            initialPurchase\n        );\n\n        FERC20 token = new FERC20(string.concat(\"fun \", _name), _ticker, initialSupply, maxTx);\n        uint256 supply = token.totalSupply();\n\n        address _pair = factory.createPair(address(token), assetToken);\n\n        bool approved = _approval(address(router), address(token), supply);\n        require(approved);\n\n        uint256 k = ((K * 10000) / assetRate);\n        uint256 liquidity = (((k * 10000 ether) / supply) * 1 ether) / 10000;\n\n        router.addInitialLiquidity(address(token), supply, liquidity);\n\n        Data memory _data = Data({\n            token: address(token),\n            name: string.concat(\"fun \", _name),\n            _name: _name,\n            ticker: _ticker,\n            supply: supply,\n            price: supply / liquidity,\n            marketCap: liquidity,\n            liquidity: liquidity * 2,\n            volume: 0,\n            volume24H: 0,\n            prevPrice: supply / liquidity,\n            lastUpdated: block.timestamp\n        });\n        Token memory tmpToken = Token({\n            creator: msg.sender,\n            token: address(token),\n            agentToken: address(0),\n            pair: _pair,\n            data: _data,\n            description: desc,\n            cores: cores,\n            image: img,\n            twitter: urls[0],\n            telegram: urls[1],\n            youtube: urls[2],\n            website: urls[3],\n            trading: true, // Can only be traded once creator made initial purchase\n            tradingOnUniswap: false\n        });\n        tokenInfo[address(token)] = tmpToken;\n        tokenInfos.push(address(token));\n\n        bool exists = _checkIfProfileExists(msg.sender);\n\n        if (exists) {\n            Profile storage _profile = profile[msg.sender];\n\n            _profile.tokens.push(address(token));\n        } else {\n            bool created = _createUserProfile(msg.sender);\n\n            if (created) {\n                Profile storage _profile = profile[msg.sender];\n\n                _profile.tokens.push(address(token));\n            }\n        }\n\n        uint n = tokenInfos.length;\n\n        emit Launched(address(token), _pair, n);\n\n        // Make initial purchase\n        IERC20(assetToken).forceApprove(address(router), initialPurchase);\n        router.buy(initialPurchase, address(token), address(this));\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n\n        return (address(token), _pair, n);\n    }\n\n    function sell(\n        uint256 amountIn,\n        address tokenAddress\n    ) public returns (bool) {\n        require(tokenInfo[tokenAddress].trading, \"Token not trading\");\n\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        (uint256 amount0In, uint256 amount1Out) = router.sell(\n            amountIn,\n            tokenAddress,\n            msg.sender\n        );\n\n        uint256 newReserveA = reserveA + amount0In;\n        uint256 newReserveB = reserveB - amount1Out;\n        uint256 duration = block.timestamp -\n            tokenInfo[tokenAddress].data.lastUpdated;\n\n        uint256 liquidity = newReserveB * 2;\n        uint256 mCap = (tokenInfo[tokenAddress].data.supply * newReserveB) /\n            newReserveA;\n        uint256 price = newReserveA / newReserveB;\n        uint256 volume = duration > 86400\n            ? amount1Out\n            : tokenInfo[tokenAddress].data.volume24H + amount1Out;\n        uint256 prevPrice = duration > 86400\n            ? tokenInfo[tokenAddress].data.price\n            : tokenInfo[tokenAddress].data.prevPrice;\n\n        tokenInfo[tokenAddress].data.price = price;\n        tokenInfo[tokenAddress].data.marketCap = mCap;\n        tokenInfo[tokenAddress].data.liquidity = liquidity;\n        tokenInfo[tokenAddress].data.volume =\n            tokenInfo[tokenAddress].data.volume +\n            amount1Out;\n        tokenInfo[tokenAddress].data.volume24H = volume;\n        tokenInfo[tokenAddress].data.prevPrice = prevPrice;\n\n        if (duration > 86400) {\n            tokenInfo[tokenAddress].data.lastUpdated = block.timestamp;\n        }\n\n        return true;\n    }\n\n    function buy(\n        uint256 amountIn,\n        address tokenAddress\n    ) public payable returns (bool) {\n        require(tokenInfo[tokenAddress].trading, \"Token not trading\");\n\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        (uint256 amount1In, uint256 amount0Out) = router.buy(\n            amountIn,\n            tokenAddress,\n            msg.sender\n        );\n\n        uint256 newReserveA = reserveA - amount0Out;\n        uint256 newReserveB = reserveB + amount1In;\n        uint256 duration = block.timestamp -\n            tokenInfo[tokenAddress].data.lastUpdated;\n\n        uint256 liquidity = newReserveB * 2;\n        uint256 mCap = (tokenInfo[tokenAddress].data.supply * newReserveB) /\n            newReserveA;\n        uint256 price = newReserveA / newReserveB;\n        uint256 volume = duration > 86400\n            ? amount1In\n            : tokenInfo[tokenAddress].data.volume24H + amount1In;\n        uint256 _price = duration > 86400\n            ? tokenInfo[tokenAddress].data.price\n            : tokenInfo[tokenAddress].data.prevPrice;\n\n        tokenInfo[tokenAddress].data.price = price;\n        tokenInfo[tokenAddress].data.marketCap = mCap;\n        tokenInfo[tokenAddress].data.liquidity = liquidity;\n        tokenInfo[tokenAddress].data.volume =\n            tokenInfo[tokenAddress].data.volume +\n            amount1In;\n        tokenInfo[tokenAddress].data.volume24H = volume;\n        tokenInfo[tokenAddress].data.prevPrice = _price;\n\n        if (duration > 86400) {\n            tokenInfo[tokenAddress].data.lastUpdated = block.timestamp;\n        }\n\n        if (newReserveA <= gradThreshold && tokenInfo[tokenAddress].trading) {\n            _openTradingOnUniswap(tokenAddress);\n        }\n\n        return true;\n    }\n\n    function _openTradingOnUniswap(address tokenAddress) private {\n        FERC20 token_ = FERC20(tokenAddress);\n\n        Token storage _token = tokenInfo[tokenAddress];\n\n        require(\n            _token.trading && !_token.tradingOnUniswap,\n            \"trading is already open\"\n        );\n\n        _token.trading = false;\n        _token.tradingOnUniswap = true;\n\n        // Transfer asset tokens to bonding contract\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        uint256 assetBalance = pair.assetBalance();\n        uint256 tokenBalance = pair.balance();\n\n        router.graduate(tokenAddress);\n\n        IERC20(router.assetToken()).forceApprove(agentFactory, assetBalance);\n        uint256 id = IAgentFactoryV3(agentFactory).initFromBondingCurve(\n            string.concat(_token.data._name, \" by Virtuals\"),\n            _token.data.ticker,\n            _token.cores,\n            _deployParams.tbaSalt,\n            _deployParams.tbaImplementation,\n            _deployParams.daoVotingPeriod,\n            _deployParams.daoThreshold,\n            assetBalance,\n            _token.creator\n        );\n\n        address agentToken = IAgentFactoryV3(agentFactory)\n            .executeBondingCurveApplication(\n                id,\n                _token.data.supply / (10 ** token_.decimals()),\n                tokenBalance / (10 ** token_.decimals()),\n                pairAddress\n            );\n        _token.agentToken = agentToken;\n\n        router.approval(\n            pairAddress,\n            agentToken,\n            address(this),\n            IERC20(agentToken).balanceOf(pairAddress)\n        );\n\n        token_.burnFrom(pairAddress, tokenBalance);\n\n        emit Graduated(tokenAddress, agentToken);\n    }\n\n    function unwrapToken(\n        address srcTokenAddress,\n        address[] memory accounts\n    ) public {\n        Token memory info = tokenInfo[srcTokenAddress];\n        require(info.tradingOnUniswap, \"Token is not graduated yet\");\n\n        FERC20 token = FERC20(srcTokenAddress);\n        IERC20 agentToken = IERC20(info.agentToken);\n        address pairAddress = factory.getPair(\n            srcTokenAddress,\n            router.assetToken()\n        );\n        for (uint i = 0; i < accounts.length; i++) {\n            address acc = accounts[i];\n            uint256 balance = token.balanceOf(acc);\n            if (balance > 0) {\n                token.burnFrom(acc, balance);\n                agentToken.transferFrom(pairAddress, acc, balance);\n            }\n        }\n    }\n}\n",
        "AgentFactoryV3.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"./IAgentFactoryV3.sol\";\nimport \"./IAgentToken.sol\";\nimport \"./IAgentVeToken.sol\";\nimport \"./IAgentDAO.sol\";\nimport \"./IAgentNft.sol\";\nimport \"../libs/IERC6551Registry.sol\";\n\ncontract AgentFactoryV3 is\n    IAgentFactoryV3,\n    Initializable,\n    AccessControl,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 private _nextId;\n    address public tokenImplementation;\n    address public daoImplementation;\n    address public nft;\n    address public tbaRegistry; // Token bound account\n    uint256 public applicationThreshold;\n\n    address[] public allTokens;\n    address[] public allDAOs;\n\n    address public assetToken; // Base currency\n    uint256 public maturityDuration; // Staking duration in seconds for initial LP. eg: 10years\n\n    bytes32 public constant WITHDRAW_ROLE = keccak256(\"WITHDRAW_ROLE\"); // Able to withdraw and execute applications\n\n    event NewPersona(\n        uint256 virtualId,\n        address token,\n        address dao,\n        address tba,\n        address veToken,\n        address lp\n    );\n    event NewApplication(uint256 id);\n\n    enum ApplicationStatus {\n        Active,\n        Executed,\n        Withdrawn\n    }\n\n    struct Application {\n        string name;\n        string symbol;\n        string tokenURI;\n        ApplicationStatus status;\n        uint256 withdrawableAmount;\n        address proposer;\n        uint8[] cores;\n        uint256 proposalEndBlock;\n        uint256 virtualId;\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n    }\n\n    mapping(uint256 => Application) private _applications;\n\n    address public gov; // Deprecated in v2, execution of application does not require DAO decision anymore\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Only DAO can execute proposal\");\n        _;\n    }\n\n    event ApplicationThresholdUpdated(uint256 newThreshold);\n    event GovUpdated(address newGov);\n    event ImplContractsUpdated(address token, address dao);\n\n    address private _vault; // Vault to hold all Virtual NFTs\n\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"cannot reenter\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    ///////////////////////////////////////////////////////////////\n    // V2 Storage\n    ///////////////////////////////////////////////////////////////\n    address[] public allTradingTokens;\n    address private _uniswapRouter;\n    address public veTokenImplementation;\n    address private _minter; // Unused\n    address private _tokenAdmin;\n    address public defaultDelegatee;\n\n    // Default agent token params\n    bytes private _tokenSupplyParams;\n    bytes private _tokenTaxParams;\n    uint16 private _tokenMultiplier; // Unused\n\n    bytes32 public constant BONDING_ROLE = keccak256(\"BONDING_ROLE\");\n\n    ///////////////////////////////////////////////////////////////\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address tokenImplementation_,\n        address veTokenImplementation_,\n        address daoImplementation_,\n        address tbaRegistry_,\n        address assetToken_,\n        address nft_,\n        uint256 applicationThreshold_,\n        address vault_,\n        uint256 nextId_\n    ) public initializer {\n        __Pausable_init();\n\n        tokenImplementation = tokenImplementation_;\n        veTokenImplementation = veTokenImplementation_;\n        daoImplementation = daoImplementation_;\n        assetToken = assetToken_;\n        tbaRegistry = tbaRegistry_;\n        nft = nft_;\n        applicationThreshold = applicationThreshold_;\n        _nextId = nextId_;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _vault = vault_;\n    }\n\n    function getApplication(\n        uint256 proposalId\n    ) public view returns (Application memory) {\n        return _applications[proposalId];\n    }\n\n    function proposeAgent(\n        string memory name,\n        string memory symbol,\n        string memory tokenURI,\n        uint8[] memory cores,\n        bytes32 tbaSalt,\n        address tbaImplementation,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold\n    ) public whenNotPaused returns (uint256) {\n        address sender = _msgSender();\n        require(\n            IERC20(assetToken).balanceOf(sender) >= applicationThreshold,\n            \"Insufficient asset token\"\n        );\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >=\n                applicationThreshold,\n            \"Insufficient asset token allowance\"\n        );\n        require(cores.length > 0, \"Cores must be provided\");\n\n        IERC20(assetToken).safeTransferFrom(\n            sender,\n            address(this),\n            applicationThreshold\n        );\n\n        uint256 id = _nextId++;\n        uint256 proposalEndBlock = block.number; // No longer required in v2\n        Application memory application = Application(\n            name,\n            symbol,\n            tokenURI,\n            ApplicationStatus.Active,\n            applicationThreshold,\n            sender,\n            cores,\n            proposalEndBlock,\n            0,\n            tbaSalt,\n            tbaImplementation,\n            daoVotingPeriod,\n            daoThreshold\n        );\n        _applications[id] = application;\n        emit NewApplication(id);\n\n        return id;\n    }\n\n    function withdraw(uint256 id) public noReentrant {\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        require(\n            application.status == ApplicationStatus.Active,\n            \"Application is not active\"\n        );\n\n        require(\n            block.number > application.proposalEndBlock,\n            \"Application is not matured yet\"\n        );\n\n        uint256 withdrawableAmount = application.withdrawableAmount;\n\n        application.withdrawableAmount = 0;\n        application.status = ApplicationStatus.Withdrawn;\n\n        IERC20(assetToken).safeTransfer(\n            application.proposer,\n            withdrawableAmount\n        );\n    }\n\n    function _executeApplication(\n        uint256 id,\n        bool canStake,\n        bytes memory tokenSupplyParams_\n    ) internal {\n        require(\n            _applications[id].status == ApplicationStatus.Active,\n            \"Application is not active\"\n        );\n\n        require(_tokenAdmin != address(0), \"Token admin not set\");\n\n        Application storage application = _applications[id];\n\n        uint256 initialAmount = application.withdrawableAmount;\n        application.withdrawableAmount = 0;\n        application.status = ApplicationStatus.Executed;\n\n        // C1\n        address token = _createNewAgentToken(\n            application.name,\n            application.symbol,\n            tokenSupplyParams_\n        );\n\n        // C2\n        address lp = IAgentToken(token).liquidityPools()[0];\n        IERC20(assetToken).safeTransfer(token, initialAmount);\n        IAgentToken(token).addInitialLiquidity(address(this));\n\n        // C3\n        address veToken = _createNewAgentVeToken(\n            string.concat(\"Staked \", application.name),\n            string.concat(\"s\", application.symbol),\n            lp,\n            application.proposer,\n            canStake\n        );\n\n        // C4\n        string memory daoName = string.concat(application.name, \" DAO\");\n        address payable dao = payable(\n            _createNewDAO(\n                daoName,\n                IVotes(veToken),\n                application.daoVotingPeriod,\n                application.daoThreshold\n            )\n        );\n\n        // C5\n        uint256 virtualId = IAgentNft(nft).nextVirtualId();\n        IAgentNft(nft).mint(\n            virtualId,\n            _vault,\n            application.tokenURI,\n            dao,\n            application.proposer,\n            application.cores,\n            lp,\n            token\n        );\n        application.virtualId = virtualId;\n\n        // C6\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        address tbaAddress = IERC6551Registry(tbaRegistry).createAccount(\n            application.tbaImplementation,\n            application.tbaSalt,\n            chainId,\n            nft,\n            virtualId\n        );\n        IAgentNft(nft).setTBA(virtualId, tbaAddress);\n\n        // C7\n        IERC20(lp).approve(veToken, type(uint256).max);\n        IAgentVeToken(veToken).stake(\n            IERC20(lp).balanceOf(address(this)),\n            application.proposer,\n            defaultDelegatee\n        );\n\n        emit NewPersona(virtualId, token, dao, tbaAddress, veToken, lp);\n    }\n\n    function executeApplication(uint256 id, bool canStake) public noReentrant {\n        // This will bootstrap an Agent with following components:\n        // C1: Agent Token\n        // C2: LP Pool + Initial liquidity\n        // C3: Agent veToken\n        // C4: Agent DAO\n        // C5: Agent NFT\n        // C6: TBA\n        // C7: Stake liquidity token to get veToken\n\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        _executeApplication(id, canStake, _tokenSupplyParams);\n    }\n\n    function _createNewDAO(\n        string memory name,\n        IVotes token,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold\n    ) internal returns (address instance) {\n        instance = Clones.clone(daoImplementation);\n        IAgentDAO(instance).initialize(\n            name,\n            token,\n            nft,\n            daoThreshold,\n            daoVotingPeriod\n        );\n\n        allDAOs.push(instance);\n        return instance;\n    }\n\n    function _createNewAgentToken(\n        string memory name,\n        string memory symbol,\n        bytes memory tokenSupplyParams_\n    ) internal returns (address instance) {\n        instance = Clones.clone(tokenImplementation);\n        IAgentToken(instance).initialize(\n            [_tokenAdmin, _uniswapRouter, assetToken],\n            abi.encode(name, symbol),\n            tokenSupplyParams_,\n            _tokenTaxParams\n        );\n\n        allTradingTokens.push(instance);\n        return instance;\n    }\n\n    function _createNewAgentVeToken(\n        string memory name,\n        string memory symbol,\n        address stakingAsset,\n        address founder,\n        bool canStake\n    ) internal returns (address instance) {\n        instance = Clones.clone(veTokenImplementation);\n        IAgentVeToken(instance).initialize(\n            name,\n            symbol,\n            founder,\n            stakingAsset,\n            block.timestamp + maturityDuration,\n            address(nft),\n            canStake\n        );\n\n        allTokens.push(instance);\n        return instance;\n    }\n\n    function totalAgents() public view returns (uint256) {\n        return allTokens.length;\n    }\n\n    function setApplicationThreshold(\n        uint256 newThreshold\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        applicationThreshold = newThreshold;\n        emit ApplicationThresholdUpdated(newThreshold);\n    }\n\n    function setVault(address newVault) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _vault = newVault;\n    }\n\n    function setImplementations(\n        address token,\n        address veToken,\n        address dao\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        tokenImplementation = token;\n        daoImplementation = dao;\n        veTokenImplementation = veToken;\n    }\n\n    function setMaturityDuration(\n        uint256 newDuration\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        maturityDuration = newDuration;\n    }\n\n    function setUniswapRouter(\n        address router\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _uniswapRouter = router;\n    }\n\n    function setTokenAdmin(\n        address newTokenAdmin\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenAdmin = newTokenAdmin;\n    }\n\n    function setTokenSupplyParams(\n        uint256 maxSupply,\n        uint256 lpSupply,\n        uint256 vaultSupply,\n        uint256 maxTokensPerWallet,\n        uint256 maxTokensPerTxn,\n        uint256 botProtectionDurationInSeconds,\n        address vault\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenSupplyParams = abi.encode(\n            maxSupply,\n            lpSupply,\n            vaultSupply,\n            maxTokensPerWallet,\n            maxTokensPerTxn,\n            botProtectionDurationInSeconds,\n            vault\n        );\n    }\n\n    function setTokenTaxParams(\n        uint256 projectBuyTaxBasisPoints,\n        uint256 projectSellTaxBasisPoints,\n        uint256 taxSwapThresholdBasisPoints,\n        address projectTaxRecipient\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenTaxParams = abi.encode(\n            projectBuyTaxBasisPoints,\n            projectSellTaxBasisPoints,\n            taxSwapThresholdBasisPoints,\n            projectTaxRecipient\n        );\n    }\n\n    function setAssetToken(\n        address newToken\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        assetToken = newToken;\n    }\n\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (address sender)\n    {\n        sender = ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ContextUpgradeable._msgData();\n    }\n\n    function initFromBondingCurve(\n        string memory name,\n        string memory symbol,\n        uint8[] memory cores,\n        bytes32 tbaSalt,\n        address tbaImplementation,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold,\n        uint256 applicationThreshold_,\n        address creator\n    ) public whenNotPaused onlyRole(BONDING_ROLE) returns (uint256) {\n        address sender = _msgSender();\n        require(\n            IERC20(assetToken).balanceOf(sender) >= applicationThreshold_,\n            \"Insufficient asset token\"\n        );\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >=\n                applicationThreshold_,\n            \"Insufficient asset token allowance\"\n        );\n        require(cores.length > 0, \"Cores must be provided\");\n\n        IERC20(assetToken).safeTransferFrom(\n            sender,\n            address(this),\n            applicationThreshold_\n        );\n\n        uint256 id = _nextId++;\n        uint256 proposalEndBlock = block.number; // No longer required in v2\n        Application memory application = Application(\n            name,\n            symbol,\n            \"\",\n            ApplicationStatus.Active,\n            applicationThreshold_,\n            creator,\n            cores,\n            proposalEndBlock,\n            0,\n            tbaSalt,\n            tbaImplementation,\n            daoVotingPeriod,\n            daoThreshold\n        );\n        _applications[id] = application;\n        emit NewApplication(id);\n\n        return id;\n    }\n\n    function executeBondingCurveApplication(\n        uint256 id,\n        uint256 totalSupply,\n        uint256 lpSupply,\n        address vault\n    ) public onlyRole(BONDING_ROLE) noReentrant returns (address) {\n        bytes memory tokenSupplyParams = abi.encode(\n            totalSupply,\n            lpSupply,\n            totalSupply - lpSupply,\n            totalSupply,\n            totalSupply,\n            0,\n            vault\n        );\n\n        _executeApplication(id, true, tokenSupplyParams);\n\n        Application memory application = _applications[id];\n\n        return IAgentNft(nft).virtualInfo(application.virtualId).token;\n    }\n\n    function setDefaultDelegatee(\n        address newDelegatee\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        defaultDelegatee = newDelegatee;\n    }\n}\n"
    }
}