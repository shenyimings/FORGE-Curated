{
    "vfp_id": "vfp_00051",
    "project_name": "cantina_liminal_oct2025.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Critical Oracle Parameters Lack Timelock Protection",
            "description": "The setPriceId and setPriceIds functions in PythPriceOracle.sol, which configure Pyth price feed IDs and decimals, are only protected by PRICE_MANAGER_ROLE and lack timelock protection. A compromised or malicious price manager could instantly change price feed configurations, enabling manipulation of all price conversions within the system.\nThe root cause is the absence of the onlyTimelock modifier on critical configuration functions, deviating from security best practices used elsewhere in the system.\nAn attacker with PRICE_MANAGER_ROLE could change price feeds to manipulated ones or set incorrect decimals, leading to incorrect share calculations and enabling fund siphoning from DepositPipe and RedemptionPipe.\nThe impact includes systemic financial manipulation, incorrect valuation of assets, and potential draining of protocol funds through frontrunning or artificial price manipulation.\n",
            "severity": "Medium",
            "location": [
                "PythPriceOracle.sol#L101-L117",
                "PythPriceOracle.sol#L119-L143"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Oracle Manipulation Enables Attackers Unfair Share Minting and Inflated Redemptions",
            "description": "The protocol uses spot prices from PythPriceOracle for asset valuation, making it vulnerable to price manipulation via flash loans or other means. Attackers can exploit this during deposits (to mint excessive shares) or redemptions (to withdraw inflated amounts).\nThe root cause is reliance on volatile spot prices without using time-averaged prices (like EMA) or confidence interval checks, which are necessary defenses against manipulation.\nIn Attack Vector 1, an attacker manipulates the price upward, deposits a small amount, and receives disproportionately high shares. In Attack Vector 2, they inflate NAV before redeeming to extract more assets than deserved.\nThe impact includes unfair dilution of existing holders, loss of funds from the vault, and systemic risk from oracle manipulation, undermining the integrity of share pricing and redemption.\n",
            "severity": "Medium",
            "location": [
                "PythPriceOracle.sol#L219-L237"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "PythPriceOracle.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IPyth} from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/**\n * @title PythPriceOracle\n * @notice Oracle integration with Pyth Network price feeds\n * @dev Uses Pyth's pull-based price model with real-time updates\n */\ncontract PythPriceOracle is AccessControlUpgradeable, IPriceOracle {\n    /// @notice Role for managing price IDs\n    bytes32 public constant PRICE_MANAGER_ROLE = keccak256(\"PRICE_MANAGER_ROLE\");\n\n    /// @notice Maximum confidence interval threshold in basis points\n    uint256 public constant BASIS_POINTS = 10_000;\n\n    /// @custom:storage-location erc7201:liminal.pythPriceOracle.v1\n    struct PythPriceOracleStorage {\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Asset address to Pyth price ID mapping\n        mapping(address => bytes32) priceIds;\n        /// @notice Asset decimals for conversion\n        mapping(address => uint8) assetDecimals;\n        /// @notice Underlying asset of the vault (for redemptions)\n        address underlyingAsset;\n        /// @notice Pyth Network oracle contract\n        IPyth pyth;\n        /// @notice Maximum price age for staleness check (default 60 seconds)\n        uint96 maxPriceAge;\n        /// @notice Maximum confidence interval threshold in basis points (default 50 bps = 0.5%)\n        uint256 maxConfidenceBps;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.pythPriceOracle.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PYTH_PRICE_ORACLE_STORAGE_LOCATION =\n        0x79f8fe64cf697304b8736b5ceebe50109f667154b58cb0fe6be0d930c76b5e00;\n\n    function _getPythPriceOracleStorage() private pure returns (PythPriceOracleStorage storage $) {\n        assembly {\n            $.slot := PYTH_PRICE_ORACLE_STORAGE_LOCATION\n        }\n    }\n\n    /// Events\n    event PriceIdSet(address indexed asset, bytes32 priceId, uint8 decimals);\n    event UnderlyingAssetSet(address indexed asset);\n    event MaxPriceAgeUpdated(uint96 newMaxAge);\n    event PythContractUpdated(address indexed newPyth);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n    event MaxConfidenceBpsUpdated(uint256 newMaxConfidenceBps);\n\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        require(msg.sender == $.timeLockController, \"PythOracle: only timelock\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the oracle\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param _deployer Deployer address (receives DEFAULT_ADMIN_ROLE)\n     * @param _priceManager Initial price manager for setting price IDs\n     * @param _pyth Pyth Network contract address\n     * @param _underlyingAsset Vault's underlying asset for redemptions\n     * @param _timeLockController Timelock controller for critical operations\n     * @param _maxConfidenceBps Maximum confidence interval threshold in basis points (default 50 bps = 0.5%)\n     */\n    function initialize(\n        address _deployer,\n        address _priceManager,\n        address _pyth,\n        address _underlyingAsset,\n        address _timeLockController,\n        uint256 _maxConfidenceBps\n    ) external initializer {\n        require(_deployer != address(0), \"PythOracle: zero deployer\");\n        require(_priceManager != address(0), \"PythOracle: zero manager\");\n        require(_pyth != address(0), \"PythOracle: zero pyth\");\n        require(_underlyingAsset != address(0), \"PythOracle: zero underlying\");\n        require(_timeLockController != address(0), \"PythOracle: zero timelock\");\n        require(_maxConfidenceBps > 0, \"PythOracle: zero confidence threshold\");\n        require(_maxConfidenceBps <= BASIS_POINTS, \"PythOracle: confidence threshold too high\");\n\n        __AccessControl_init();\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(PRICE_MANAGER_ROLE, _priceManager);\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.pyth = IPyth(_pyth);\n        $.underlyingAsset = _underlyingAsset;\n        $.maxPriceAge = 3600; // 1 hour default\n        $.timeLockController = _timeLockController;\n        $.maxConfidenceBps = _maxConfidenceBps;\n\n        emit UnderlyingAssetSet(_underlyingAsset);\n    }\n\n    /**\n     * @notice Set Pyth price ID for an asset\n     * @param asset Asset address\n     * @param priceId Pyth price feed ID (32 bytes)\n     * @param decimals Asset token decimals\n     */\n    function setPriceId(address asset, bytes32 priceId, uint8 decimals) external onlyTimelock {\n        require(asset != address(0), \"PythOracle: zero asset\");\n        require(priceId != bytes32(0), \"PythOracle: zero price ID\");\n        require(decimals <= 18, \"PythOracle: invalid decimals\");\n        require(decimals == IERC20Metadata(asset).decimals(), \"PythOracle: decimals mismatch\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.priceIds[asset] = priceId;\n        $.assetDecimals[asset] = decimals;\n\n        emit PriceIdSet(asset, priceId, decimals);\n    }\n\n    /**\n     * @notice Batch set price IDs for multiple assets\n     * @param assets Array of asset addresses\n     * @param _priceIds Array of Pyth price feed IDs\n     * @param decimalsArray Array of token decimals\n     */\n    function setPriceIds(address[] calldata assets, bytes32[] calldata _priceIds, uint8[] calldata decimalsArray)\n        external\n        onlyTimelock\n    {\n        require(assets.length == _priceIds.length, \"PythOracle: length mismatch\");\n        require(assets.length == decimalsArray.length, \"PythOracle: decimals mismatch\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(assets[i] != address(0), \"PythOracle: zero asset\");\n            require(_priceIds[i] != bytes32(0), \"PythOracle: zero price ID\");\n            require(decimalsArray[i] <= 18, \"PythOracle: invalid decimals\");\n            require(decimalsArray[i] == IERC20Metadata(assets[i]).decimals(), \"PythOracle: decimals mismatch\");\n\n            $.priceIds[assets[i]] = _priceIds[i];\n            $.assetDecimals[assets[i]] = decimalsArray[i];\n\n            emit PriceIdSet(assets[i], _priceIds[i], decimalsArray[i]);\n        }\n    }\n\n    /**\n     * @notice Get price of asset in terms of underlying asset\n     * @param asset Asset to price\n     * @return Price scaled to 18 decimals\n     */\n    function getPrice(address asset) external view override returns (uint256) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        if (asset == $.underlyingAsset) {\n            return 1e18; // 1:1 for underlying asset\n        }\n\n        PythStructs.Price memory assetPrice = _getPythPrice(asset);\n        PythStructs.Price memory underlyingPrice = _getPythPrice($.underlyingAsset);\n\n        // Convert Pyth prices (with expo) to 18 decimal format\n        uint256 assetPriceUSD = _convertPythPrice(assetPrice);\n        uint256 underlyingPriceUSD = _convertPythPrice(underlyingPrice);\n\n        // Price = (asset price in USD / underlying price in USD) * 1e18\n        return (assetPriceUSD * 1e18) / underlyingPriceUSD;\n    }\n\n    /**\n     * @notice Get USD price of an asset\n     * @param asset Asset address\n     * @return Price in USD with 8 decimals (Pyth standard)\n     */\n    function getPriceInUSD(address asset) external view override returns (uint256) {\n        PythStructs.Price memory price = _getPythPrice(asset);\n        return _convertPythPrice(price);\n    }\n\n    /**\n     * @notice Convert amount between assets using Pyth prices\n     * @param fromAsset Source asset\n     * @param toAsset Target asset\n     * @param amount Amount in source asset\n     * @return Converted amount in target asset's native decimals (eg: USDC 6 decimals, WETH 18 decimals)\n     */\n    function convertAmount(address fromAsset, address toAsset, uint256 amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n\n        if (fromAsset == toAsset) {\n            // Same asset conversion - always return the same amount\n            return amount;\n        }\n\n        PythStructs.Price memory fromPrice = _getPythPrice(fromAsset);\n        PythStructs.Price memory toPrice = _getPythPrice(toAsset);\n\n        uint8 fromDecimals = $.assetDecimals[fromAsset];\n        uint8 toDecimals = $.assetDecimals[toAsset];\n\n        require(amount > 0, \"PythOracle: zero amount\");\n\n        // Convert prices to 18 decimals for high precision calculation\n        uint256 fromPrice18 = _convertPythPriceTo18Decimals(fromPrice);\n        uint256 toPrice18 = _convertPythPriceTo18Decimals(toPrice);\n\n        // Normalize amount to 18 decimals\n        uint256 amount18 = _normalizeDecimals(amount, fromDecimals, 18);\n\n        // Calculate: (amount18 * fromPrice18) / toPrice18\n        uint256 result18 = (amount18 * fromPrice18) / toPrice18;\n\n        // Always return in the target asset's native decimals\n        return _normalizeDecimals(result18, 18, toDecimals);\n    }\n\n    /**\n     * @notice Get Pyth price with staleness check\n     * @param asset Asset address\n     * @return Pyth price struct\n     */\n    function _getPythPrice(address asset) internal view returns (PythStructs.Price memory) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        bytes32 priceId = $.priceIds[asset];\n        require(priceId != bytes32(0), \"PythOracle: price ID not set\");\n\n        // Check staleness\n        PythStructs.Price memory price = $.pyth.getPriceNoOlderThan(priceId, $.maxPriceAge);\n        // Check that price is positive (price.price is int64)\n        require(price.price > 0, \"PythOracle: invalid price\");\n\n        // Check confidence interval\n        _validateConfidence(price, $.maxConfidenceBps);\n\n\n        return price;\n    }\n\n     /**\n     * @notice Validate price confidence interval against threshold\n     * @param price Pyth price struct\n     * @param maxConfThreshold Maximum allowed confidence interval in basis points\n     * @dev Reverts if conf/price ratio exceeds the threshold\n     */\n    function _validateConfidence(PythStructs.Price memory price, uint256 maxConfThreshold) internal pure {\n        // Calculate confidence ratio: (conf / price) * BASIS_POINTS\n        // Both conf and price have the same exponent, so we can compare them directly\n        uint256 confidenceRatioBps = (uint256(price.conf) * BASIS_POINTS) / uint256(uint64(price.price));\n\n        require(\n            confidenceRatioBps <= maxConfThreshold,\n            \"PythOracle: confidence interval too wide\"\n        );\n    }\n\n    /**\n     * @notice Convert Pyth price to standard 8-decimal format\n     * @param price Pyth price struct\n     * @return Price in 8 decimals\n     */\n    function _convertPythPrice(PythStructs.Price memory price) internal pure returns (uint256) {\n        require(price.price > 0, \"PythOracle: invalid price\");\n\n        // Convert to 8 decimal places\n        // If expo = -6 and we want -8, we need to multiply by 10^2\n        // If expo = -10 and we want -8, we need to divide by 10^2\n\n        int256 normalizedPrice;\n        int32 targetExpo = -8;\n\n        if (price.expo == targetExpo) {\n            normalizedPrice = price.price;\n        } else if (price.expo > targetExpo) {\n            // expo is less negative (fewer decimals), need to add decimals\n            // expo=-6, target=-8: multiply by 10^2\n            uint256 scaleFactor = 10 ** uint256(int256(price.expo - targetExpo));\n            normalizedPrice = price.price * int256(scaleFactor);\n        } else {\n            // expo is more negative (more decimals), need to remove decimals\n            // expo=-10, target=-8: divide by 10^2\n            uint256 scaleFactor = 10 ** uint256(int256(targetExpo - price.expo));\n            normalizedPrice = price.price / int256(scaleFactor);\n        }\n\n        require(normalizedPrice > 0, \"PythOracle: price conversion failed\");\n        return uint256(normalizedPrice);\n    }\n\n    /**\n     * @notice Convert Pyth price to 18-decimal format for high precision calculations\n     * @param price Pyth price struct\n     * @return Price in 18 decimals\n     */\n    function _convertPythPriceTo18Decimals(PythStructs.Price memory price) internal pure returns (uint256) {\n        require(price.price > 0, \"PythOracle: invalid price\");\n\n        // First convert to 8 decimals using existing logic\n        uint256 price8Decimals = _convertPythPrice(price);\n\n        // Then convert from 8 decimals to 18 decimals\n        return price8Decimals * 1e10; // 18 - 8 = 10\n    }\n\n    /**\n     * @notice Get maximum of two values\n     * @param a First value\n     * @param b Second value\n     * @return Maximum value\n     */\n    function max(uint8 a, uint8 b) internal pure returns (uint8) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @notice Normalize decimals for calculations\n     * @param amount Amount to normalize\n     * @param fromDecimals Current decimals\n     * @param toDecimals Target decimals\n     * @return Normalized amount\n     */\n    function _normalizeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n\n        if (fromDecimals > toDecimals) {\n            return amount / (10 ** (fromDecimals - toDecimals));\n        } else {\n            return amount * (10 ** (toDecimals - fromDecimals));\n        }\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Update Pyth contract address\n     * @param _pyth New Pyth contract address\n     */\n    function setPythContract(address _pyth) external onlyTimelock {\n        require(_pyth != address(0), \"PythOracle: zero address\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.pyth = IPyth(_pyth);\n        emit PythContractUpdated(_pyth);\n    }\n\n    /**\n     * @notice Update underlying asset\n     * @param _underlyingAsset New underlying asset address\n     */\n    function setUnderlyingAsset(address _underlyingAsset) external onlyTimelock {\n        require(_underlyingAsset != address(0), \"PythOracle: zero address\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.underlyingAsset = _underlyingAsset;\n        emit UnderlyingAssetSet(_underlyingAsset);\n    }\n\n    /**\n     * @notice Update maximum price age\n     * @param _maxPriceAge New maximum age in seconds\n     */\n    function setMaxPriceAge(uint96 _maxPriceAge) external onlyTimelock {\n        require(_maxPriceAge > 0, \"PythOracle: zero max age\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.maxPriceAge = _maxPriceAge;\n        emit MaxPriceAgeUpdated(_maxPriceAge);\n    }\n\n    /**\n     * @notice Set the timelock controller\n     * @param _timeLockController New timelock controller address\n     * @dev Can only be called by the current timelock (with delay enforced by VaultTimelockController)\n     */\n    function setTimelockController(address _timeLockController) external onlyTimelock {\n        require(_timeLockController != address(0), \"PythOracle: zero timelock\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        address oldTimelock = $.timeLockController;\n        $.timeLockController = _timeLockController;\n\n        emit TimelockControllerSet(oldTimelock, _timeLockController);\n    }\n\n     /**\n     * @notice Update maximum confidence interval threshold\n     * @param _maxConfidenceBps New maximum confidence interval in basis points\n     */\n    function setMaxConfidenceBps(uint256 _maxConfidenceBps) external onlyTimelock {\n        require(_maxConfidenceBps > 0, \"PythOracle: zero confidence threshold\");\n        require(_maxConfidenceBps <= BASIS_POINTS, \"PythOracle: confidence threshold too high\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.maxConfidenceBps = _maxConfidenceBps;\n        emit MaxConfidenceBpsUpdated(_maxConfidenceBps);\n    }\n\n\n    /**\n     * @notice Check if asset has price feed configured\n     * @param asset Asset address\n     * @return True if price ID is set\n     */\n    function hasPriceFeed(address asset) external view returns (bool) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        return $.priceIds[asset] != bytes32(0);\n    }\n\n    /**\n     * @notice Get the latest price update fee for Pyth\n     * @param updateData Array of price update data\n     * @return fee Update fee in wei\n     */\n    function getUpdateFee(bytes[] calldata updateData) external view returns (uint256) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        return $.pyth.getUpdateFee(updateData);\n    }\n\n    // ========== GETTER FUNCTIONS ==========\n\n    /// @notice Get timelock controller address\n    function timeLockController() external view returns (address) {\n        return _getPythPriceOracleStorage().timeLockController;\n    }\n\n    /// @notice Get Pyth contract address\n    function pyth() external view returns (IPyth) {\n        return _getPythPriceOracleStorage().pyth;\n    }\n\n    /// @notice Get price ID for an asset\n    function priceIds(address asset) external view returns (bytes32) {\n        return _getPythPriceOracleStorage().priceIds[asset];\n    }\n\n    /// @notice Get asset decimals\n    function assetDecimals(address asset) external view returns (uint8) {\n        return _getPythPriceOracleStorage().assetDecimals[asset];\n    }\n\n    /// @notice Get underlying asset address\n    function underlyingAsset() external view returns (address) {\n        return _getPythPriceOracleStorage().underlyingAsset;\n    }\n\n    /// @notice Get maximum price age\n    function maxPriceAge() external view returns (uint96) {\n        return _getPythPriceOracleStorage().maxPriceAge;\n    }\n\n    /// @notice Get maximum confidence interval threshold\n    function maxConfidenceBps() external view returns (uint256) {\n        return _getPythPriceOracleStorage().maxConfidenceBps;\n    }\n}\n"
    }
}