{
    "vfp_id": "vfp_00103",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Updating a Rate Keeper Will Freeze the Epoch",
            "description": "In RateKeeperFactory.onUpdateRateKeeper(), when upgrading to a new GAUGE-type RateKeeper, the epoch is unfrozen on the old RateKeeper instead of the new one. This leaves the new RateKeeper's epoch frozen, preventing it from updating rates. Attackers could exploit this during an upgrade to freeze rate adjustments, disrupting incentive mechanisms. The impact is functional disruption of the ratekeeping system, affecting staking and reward distribution.\n",
            "severity": "High",
            "location": [
                "RateKeeperFactory.sol::onUpdateRateKeeper"
            ],
            "files": [
                "permissionless/contracts/factories/RateKeeperFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "RateKeeperFactory.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IRateKeeper} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IRateKeeper.sol\";\nimport {IGaugeV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IGaugeV3.sol\";\n\nimport {IFactory} from \"../interfaces/factories/IFactory.sol\";\nimport {IMarketFactory} from \"../interfaces/factories/IMarketFactory.sol\";\nimport {IRateKeeperFactory} from \"../interfaces/factories/IRateKeeperFactory.sol\";\nimport {Call, DeployParams, DeployResult} from \"../interfaces/Types.sol\";\n\nimport {CallBuilder} from \"../libraries/CallBuilder.sol\";\nimport {\n    DOMAIN_RATE_KEEPER,\n    AP_RATE_KEEPER_FACTORY,\n    NO_VERSION_CONTROL,\n    AP_GEAR_STAKING\n} from \"../libraries/ContractLiterals.sol\";\n\nimport {AbstractFactory} from \"./AbstractFactory.sol\";\nimport {AbstractMarketFactory} from \"./AbstractMarketFactory.sol\";\n\ncontract RateKeeperFactory is AbstractMarketFactory, IRateKeeperFactory {\n    using CallBuilder for Call[];\n\n    /// @notice Contract version\n    uint256 public constant override version = 3_10;\n\n    /// @notice Contract type\n    bytes32 public constant override contractType = AP_RATE_KEEPER_FACTORY;\n\n    /// @notice Address of the GEAR staking contract\n    address public immutable gearStaking;\n\n    /// @notice Constructor\n    /// @param addressProvider_ Address provider contract address\n    constructor(address addressProvider_) AbstractFactory(addressProvider_) {\n        gearStaking = _getAddressOrRevert(AP_GEAR_STAKING, NO_VERSION_CONTROL);\n    }\n\n    // ---------- //\n    // DEPLOYMENT //\n    // ---------- //\n\n    function deployRateKeeper(address pool, DeployParams calldata params)\n        external\n        override\n        onlyMarketConfigurators\n        returns (DeployResult memory)\n    {\n        if (params.postfix == \"GAUGE\") {\n            (address decodedPool, address decodedGearStaking) = abi.decode(params.constructorParams, (address, address));\n            if (decodedPool != pool || decodedGearStaking != gearStaking) revert InvalidConstructorParamsException();\n        } else if (params.postfix == \"TUMBLER\") {\n            (address decodedPool,) = abi.decode(params.constructorParams, (address, uint256));\n            if (decodedPool != pool) revert InvalidConstructorParamsException();\n        } else {\n            _validateDefaultConstructorParams(pool, params.constructorParams);\n        }\n\n        address rateKeeper = _deployLatestPatch({\n            contractType: _getContractType(DOMAIN_RATE_KEEPER, params.postfix),\n            minorVersion: version,\n            constructorParams: params.constructorParams,\n            salt: keccak256(abi.encode(params.salt, msg.sender))\n        });\n\n        return DeployResult({\n            newContract: rateKeeper,\n            onInstallOps: CallBuilder.build(_authorizeFactory(msg.sender, pool, rateKeeper))\n        });\n    }\n\n    // ------------ //\n    // MARKET HOOKS //\n    // ------------ //\n\n    function onCreateMarket(address, address, address, address rateKeeper, address, address)\n        external\n        view\n        override(AbstractMarketFactory, IMarketFactory)\n        returns (Call[] memory)\n    {\n        if (_getRateKeeperType(rateKeeper) == \"RATE_KEEPER::GAUGE\") {\n            return CallBuilder.build(_setFrozenEpoch(rateKeeper, false));\n        }\n        return CallBuilder.build();\n    }\n\n    function onShutdownMarket(address pool)\n        external\n        view\n        override(AbstractMarketFactory, IMarketFactory)\n        returns (Call[] memory)\n    {\n        address rateKeeper = _rateKeeper(_quotaKeeper(pool));\n        if (_getRateKeeperType(rateKeeper) == \"RATE_KEEPER::GAUGE\") {\n            return CallBuilder.build(_setFrozenEpoch(rateKeeper, true));\n        }\n        return CallBuilder.build();\n    }\n\n    function onUpdateRateKeeper(address pool, address newRateKeeper, address oldRateKeeper)\n        external\n        view\n        override(AbstractMarketFactory, IMarketFactory)\n        returns (Call[] memory calls)\n    {\n        address[] memory tokens = _quotedTokens(_quotaKeeper(pool));\n        uint256 numTokens = tokens.length;\n        calls = new Call[](numTokens);\n        bytes32 type_ = _getRateKeeperType(newRateKeeper);\n        for (uint256 i; i < numTokens; ++i) {\n            calls[i] = _addToken(newRateKeeper, tokens[i], type_);\n        }\n        if (_getRateKeeperType(oldRateKeeper) == \"RATE_KEEPER::GAUGE\") {\n            calls = calls.append(_setFrozenEpoch(oldRateKeeper, true));\n        }\n        if (type_ == \"RATE_KEEPER::GAUGE\") {\n            calls = calls.append(_setFrozenEpoch(oldRateKeeper, false));\n        }\n        calls = calls.append(_unauthorizeFactory(msg.sender, pool, oldRateKeeper));\n    }\n\n    function onAddToken(address pool, address token, address)\n        external\n        view\n        override(AbstractMarketFactory, IMarketFactory)\n        returns (Call[] memory)\n    {\n        address rateKeeper = _rateKeeper(_quotaKeeper(pool));\n        return CallBuilder.build(_addToken(rateKeeper, token, _getRateKeeperType(rateKeeper)));\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function configure(address pool, bytes calldata callData)\n        external\n        view\n        override(AbstractFactory, IFactory)\n        returns (Call[] memory)\n    {\n        address rateKeeper = _rateKeeper(_quotaKeeper(pool));\n        bytes4 selector = bytes4(callData);\n        if (_isForbiddenConfigurationCall(rateKeeper, selector)) revert ForbiddenConfigurationCallException(selector);\n        return CallBuilder.build(Call(rateKeeper, callData));\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    function _getRateKeeperType(address rateKeeper) internal view returns (bytes32) {\n        try IRateKeeper(rateKeeper).contractType() returns (bytes32 type_) {\n            return type_;\n        } catch {\n            return \"RATE_KEEPER::GAUGE\";\n        }\n    }\n\n    function _isForbiddenConfigurationCall(address rateKeeper, bytes4 selector) internal view returns (bool) {\n        if (_getRateKeeperType(rateKeeper) == \"RATE_KEEPER::GAUGE\") {\n            return selector == IRateKeeper.addToken.selector || selector == IGaugeV3.addQuotaToken.selector\n                || selector == IGaugeV3.setFrozenEpoch.selector || selector == bytes4(keccak256(\"setController(address)\"));\n        }\n        return selector == IRateKeeper.addToken.selector;\n    }\n\n    function _addToken(address rateKeeper, address token, bytes32 type_) internal pure returns (Call memory) {\n        return Call(\n            rateKeeper,\n            type_ == \"RATE_KEEPER::GAUGE\"\n                ? abi.encodeCall(IGaugeV3.addQuotaToken, (token, 1, 1))\n                : abi.encodeCall(IRateKeeper.addToken, token)\n        );\n    }\n\n    function _setFrozenEpoch(address gauge, bool status) internal pure returns (Call memory) {\n        return Call(gauge, abi.encodeCall(IGaugeV3.setFrozenEpoch, status));\n    }\n}\n"
    }
}