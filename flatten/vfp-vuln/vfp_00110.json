{
    "vfp_id": "vfp_00110",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "Incorrect oracle staleness period leads to price feed DoS",
            "description": "The price oracle used a single global staleness period, which could lead to a denial-of-service (DoS) condition if the global setting was too strict or too lenient for certain assets. The cause was a lack of per-asset configurability for staleness checks. An attacker could exploit this by manipulating or delaying price updates for specific assets, causing the system to reject valid prices or accept stale ones. This could halt operations that depend on fresh price data, such as liquidations or borrowing.\n",
            "severity": "High",
            "location": [
                "PriceOracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Incorrect oracle staleness period leads to price feed DoS",
            "description": "The PriceOracle contract uses a single staleness period for all price feeds, despite different assets having different update frequencies (e.g., stablecoins updated every 24 hours vs. ETH/BTC every hour). This misconfiguration causes the oracle to either reject valid prices from slow-updating assets or accept stale prices from fast-updating ones. The root cause is the use of a global staleness threshold without per-asset customization. An attacker or system failure could exploit this by manipulating the timing of price updates, leading to denial of service in price retrieval. The impact is that critical functions relying on price feeds may revert or operate with incorrect data, disrupting lending, borrowing, and liquidation mechanisms.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/PriceOracle.sol::__PriceOracle_init_unchained#21-25",
                "contracts/deploy/service/DeployInfra.sol::_deployInfra#36-40",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        },
        {
            "id": 63,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Oracle update front-running allows extraction of value from vaults",
            "description": "Oracle updates can be front-run by attackers who anticipate price changes and trade ahead of the update. The cause is the lack of commit-reveal schemes or time locks in oracle updates. An attacker could exploit this by monitoring mempool transactions and submitting trades just before an update to extract value from vaults. This leads to wealth transfer from the protocol to malicious actors.\n",
            "severity": "Medium",
            "location": [
                "PriceOracle.sol::update"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "PriceOracle.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IPriceOracle } from \"../interfaces/IPriceOracle.sol\";\nimport { PriceOracleStorageUtils } from \"../storage/PriceOracleStorageUtils.sol\";\n\n/// @title Oracle for fetching prices\n/// @author kexley, @capLabs\n/// @dev Payloads are stored on this contract and calculation logic is hosted on external libraries\nabstract contract PriceOracle is IPriceOracle, Access, PriceOracleStorageUtils {\n    /// @dev Initialize the price oracle\n    /// @param _accessControl Access control address\n    function __PriceOracle_init(address _accessControl) internal onlyInitializing {\n        __Access_init(_accessControl);\n        __PriceOracle_init_unchained();\n    }\n\n    /// @dev Initialize unchained\n    function __PriceOracle_init_unchained() internal onlyInitializing { }\n\n    /// @notice Fetch the price for an asset\n    /// @dev If initial price fetch fails then a backup source is used\n    /// @param _asset Asset address\n    /// @return price Price of the asset\n    function getPrice(address _asset) external view returns (uint256 price, uint256 lastUpdated) {\n        PriceOracleStorage storage $ = getPriceOracleStorage();\n        IOracle.OracleData memory data = $.oracleData[_asset];\n\n        (price, lastUpdated) = _getPrice(data.adapter, data.payload);\n\n        if (price == 0 || _isStale(_asset, lastUpdated)) {\n            data = $.backupOracleData[_asset];\n            (price, lastUpdated) = _getPrice(data.adapter, data.payload);\n\n            if (price == 0 || _isStale(_asset, lastUpdated)) revert PriceError(_asset);\n        }\n    }\n\n    /// @notice View the oracle data for an asset\n    /// @param _asset Asset address\n    /// @return data Oracle data for an asset\n    function priceOracleData(address _asset) external view returns (IOracle.OracleData memory data) {\n        data = getPriceOracleStorage().oracleData[_asset];\n    }\n\n    /// @notice View the backup oracle data for an asset\n    /// @param _asset Asset address\n    /// @return data Backup oracle data for an asset\n    function priceBackupOracleData(address _asset) external view returns (IOracle.OracleData memory data) {\n        data = getPriceOracleStorage().backupOracleData[_asset];\n    }\n\n    /// @notice View the staleness period for asset prices\n    /// @param _asset Asset address\n    /// @return assetStaleness Staleness period in seconds for asset prices\n    function staleness(address _asset) external view returns (uint256 assetStaleness) {\n        assetStaleness = getPriceOracleStorage().staleness[_asset];\n    }\n\n    /// @notice Set a price source for an asset\n    /// @param _asset Asset address\n    /// @param _oracleData Oracle data\n    function setPriceOracleData(address _asset, IOracle.OracleData calldata _oracleData)\n        external\n        checkAccess(this.setPriceOracleData.selector)\n    {\n        getPriceOracleStorage().oracleData[_asset] = _oracleData;\n        emit SetPriceOracleData(_asset, _oracleData);\n    }\n\n    /// @notice Set a backup price source for an asset\n    /// @param _asset Asset address\n    /// @param _oracleData Oracle data\n    function setPriceBackupOracleData(address _asset, IOracle.OracleData calldata _oracleData)\n        external\n        checkAccess(this.setPriceBackupOracleData.selector)\n    {\n        getPriceOracleStorage().backupOracleData[_asset] = _oracleData;\n        emit SetPriceBackupOracleData(_asset, _oracleData);\n    }\n\n    /// @notice Set the staleness period for asset prices\n    /// @param _asset Asset address\n    /// @param _staleness Staleness period in seconds for asset prices\n    function setStaleness(address _asset, uint256 _staleness) external checkAccess(this.setStaleness.selector) {\n        getPriceOracleStorage().staleness[_asset] = _staleness;\n        emit SetStaleness(_asset, _staleness);\n    }\n\n    /// @dev Calculate price using an adapter and payload but do not revert on errors\n    /// @param _adapter Adapter for calculation logic\n    /// @param _payload Encoded call to adapter with all required data\n    /// @return price Calculated price\n    /// @return lastUpdated Last updated timestamp\n    function _getPrice(address _adapter, bytes memory _payload)\n        private\n        view\n        returns (uint256 price, uint256 lastUpdated)\n    {\n        (bool success, bytes memory returnedData) = _adapter.staticcall(_payload);\n        if (success) (price, lastUpdated) = abi.decode(returnedData, (uint256, uint256));\n    }\n\n    /// @dev Check if a price is stale\n    /// @param _asset Asset address\n    /// @param _lastUpdated Last updated timestamp\n    /// @return isStale True if the price is stale\n    function _isStale(address _asset, uint256 _lastUpdated) internal view returns (bool isStale) {\n        isStale = block.timestamp - _lastUpdated > getPriceOracleStorage().staleness[_asset];\n    }\n}\n"
    }
}