{
    "vfp_id": "vfp_00004",
    "project_name": "Zenith - SSI Protocol Audit Report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "setIssuer() Missing change issuers[assetID] to newest",
            "description": "1. **Description:** The setIssuer function does not update the issuers mapping to the newest issuer for a given assetID.\n2. **Cause:** The function logic fails to assign the new issuer value to the storage variable.\n3. **Exploitation:** An old or unauthorized issuer may retain control over asset issuance.\n4. **Impact:** This could allow unauthorized minting or management of assets, compromising the integrity of the system.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "AssetFactory.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport \"./Interface.sol\";\nimport \"./AssetToken.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"forge-std/console.sol\";\n\ncontract AssetFactory is Initializable, OwnableUpgradeable, UUPSUpgradeable, IAssetFactory {\n    using EnumerableSet for EnumerableSet.UintSet;\n    EnumerableSet.UintSet assetIDs;\n    mapping(uint => address) public assetTokens;\n\n    mapping(uint => address) public issuers;\n    mapping(uint => address) public rebalancers;\n    mapping(uint => address) public feeManagers;\n\n    address public swap;\n    address public vault;\n    string public chain;\n    address public tokenImpl;\n\n    event AssetTokenCreated(address assetTokenAddress);\n    event SetVault(address vault);\n    event SetSwap(address swap);\n    event SetTokenImpl(address tokenImpl);\n    event UpgradeAssetToken(uint256 assetID, address tokenImpl);\n    event SetIssuer(uint256 assetID, address oldIssuer, address issuer);\n    event SetRebalancer(uint256 assetID, address oldRebalancer, address rebalancer);\n    event SetFeeManager(uint256 assetID, address oldFeeManager, address feeManager);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address owner, address swap_, address vault_, string memory chain_, address tokenImpl_) public initializer {\n        __Ownable_init(owner);\n        __UUPSUpgradeable_init();\n        require(swap_ != address(0), \"swap address is zero\");\n        require(vault_ != address(0), \"vault address is zero\");\n        require(tokenImpl_ != address(0), \"token impl address is zero\");\n        swap = swap_;\n        vault = vault_;\n        chain = chain_;\n        tokenImpl = tokenImpl_;\n        emit SetVault(vault);\n        emit SetSwap(swap);\n        emit SetTokenImpl(tokenImpl);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function setSwap(address swap_) external onlyOwner {\n        require(swap_ != address(0), \"swap address is zero\");\n        swap = swap_;\n        emit SetSwap(swap);\n    }\n\n    function setVault(address vault_) external onlyOwner {\n        require(vault_ != address(0), \"vault address is zero\");\n        vault = vault_;\n        emit SetVault(vault);\n    }\n\n    function setTokenImpl(address tokenImpl_) external onlyOwner {\n        require(tokenImpl_ != address(0), \"token impl address is zero\");\n        require(tokenImpl_ != tokenImpl, \"token impl is not change\");\n        tokenImpl = tokenImpl_;\n        emit SetTokenImpl(tokenImpl);\n        for (uint i = 0; i < assetIDs.length(); i++) {\n            address assetToken = assetTokens[assetIDs.at(i)];\n            UUPSUpgradeable(assetToken).upgradeToAndCall(tokenImpl, new bytes(0));\n            emit UpgradeAssetToken(assetIDs.at(i), tokenImpl);\n        }\n    }\n\n    function createAssetToken(Asset memory asset, uint maxFee, address issuer, address rebalancer, address feeManager) external onlyOwner returns (address) {\n        require(issuer != address(0) && rebalancer != address(0) && feeManager != address(0), \"controllers not set\");\n        require(!assetIDs.contains(asset.id), \"asset exists\");\n        address assetTokenAddress = address(new ERC1967Proxy(\n            tokenImpl,\n            abi.encodeCall(AssetToken.initialize, (asset.id, asset.name, asset.symbol, maxFee, address(this)))\n        ));\n        IAssetToken assetToken = IAssetToken(assetTokenAddress);\n        assetToken.grantRole(assetToken.ISSUER_ROLE(), issuer);\n        assetToken.grantRole(assetToken.REBALANCER_ROLE(), rebalancer);\n        assetToken.grantRole(assetToken.FEEMANAGER_ROLE(), feeManager);\n        assetToken.initTokenset(asset.tokenset);\n        assetTokens[asset.id] = address(assetToken);\n        issuers[asset.id] = issuer;\n        rebalancers[asset.id] = rebalancer;\n        feeManagers[asset.id] = feeManager;\n        assetIDs.add(asset.id);\n        emit AssetTokenCreated(address(assetToken));\n        return address(assetToken);\n    }\n\n    function setIssuer(uint256 assetID, address issuer) external onlyOwner {\n        require(issuer != address(0), \"issuer is zero address\");\n        require(assetIDs.contains(assetID), \"assetID not exists\");\n        IAssetToken assetToken = IAssetToken(assetTokens[assetID]);\n        require(!assetToken.issuing(), \"is issuing\");\n        address oldIssuer = issuers[assetID];\n        assetToken.revokeRole(assetToken.ISSUER_ROLE(), oldIssuer);\n        assetToken.grantRole(assetToken.ISSUER_ROLE(), issuer);\n        emit SetIssuer(assetID, oldIssuer, issuer);\n    }\n\n    function setRebalancer(uint256 assetID, address rebalancer) external onlyOwner {\n        require(rebalancer != address(0), \"rebalancer is zero address\");\n        require(assetIDs.contains(assetID), \"assetID not exists\");\n        IAssetToken assetToken = IAssetToken(assetTokens[assetID]);\n        require(!assetToken.rebalancing(), \"is rebalancing\");\n        address oldRebalancer = rebalancers[assetID];\n        assetToken.revokeRole(assetToken.REBALANCER_ROLE(), oldRebalancer);\n        assetToken.grantRole(assetToken.REBALANCER_ROLE(), rebalancer);\n        emit SetRebalancer(assetID, oldRebalancer, rebalancer);\n    }\n\n    function setFeeManager(uint256 assetID, address feeManager) external onlyOwner {\n        require(feeManager != address(0), \"feeManager is zero address\");\n        require(assetIDs.contains(assetID), \"assetID not exists\");\n        IAssetToken assetToken = IAssetToken(assetTokens[assetID]);\n        address oldFeeManager = feeManagers[assetID];\n        assetToken.revokeRole(assetToken.FEEMANAGER_ROLE(), oldFeeManager);\n        assetToken.grantRole(assetToken.FEEMANAGER_ROLE(), feeManager);\n        emit SetFeeManager(assetID, oldFeeManager, feeManager);\n    }\n\n    function hasAssetID(uint assetID) external view returns (bool) {\n        return assetIDs.contains(assetID);\n    }\n\n    function getAssetIDs() external view returns (uint[] memory) {\n        return assetIDs.values();\n    }\n}"
    }
}