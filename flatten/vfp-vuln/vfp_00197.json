{
    "vfp_id": "vfp_00197",
    "project_name": "cantina_panoptic_sep2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Anyone can call claim for any account",
            "description": "1. **Description:** The `claim` function in the MerkleDistributor contract allows any third party to initiate a claim on behalf of any account, as long as they provide a valid Merkle proof. The tokens are sent to the account specified in the Merkle leaf, not necessarily the caller.\n2. **Cause:** The function does not require the caller (`msg.sender`) to be the same as the account receiving the tokens, enabling permissionless claiming.\n3. **Exploitation:** A malicious actor or griefer could monitor the distribution and front-run intended recipients by submitting claims for accounts they believe are inactive or unwilling to claim, sending funds to potentially incorrect or unintended addresses.\n4. **Impact:** If a leaf contains an incorrect account address, a third party could claim tokens to that address, permanently preventing recovery via the admin's `withdrawUnclaimed` function after the clawback period, leading to loss of user funds.\n",
            "severity": "Medium",
            "location": [
                "MerkleDistributor.sol::claim#61"
            ],
            "files": [
                "multitoken-merkle-distributor/contracts/MerkleDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "MerkleDistributor.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.22;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {IMultiTokenMerkleDistributor} from \"./interfaces/IMerkleDistributor.sol\";\n\nerror AlreadyClaimed();\nerror InvalidProof();\nerror TokensAmountsMismatch();\nerror OnlyAdmin();\nerror WithdrawTooEarly();\n\ncontract MerkleDistributor is IMultiTokenMerkleDistributor {\n    using SafeERC20 for IERC20;\n\n    mapping(address => bool) public supportedTokens;\n    address[] public tokenList;\n    bytes32 public immutable override merkleRoot;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    address public immutable admin;\n    uint256 public immutable withdrawableAt;\n\n    constructor(bytes32 merkleRoot_, address[] memory tokens_, uint256 withdrawableAt_, address admin_) {\n        merkleRoot = merkleRoot_;\n\n        for (uint256 i = 0; i < tokens_.length; i++) {\n            if (!supportedTokens[tokens_[i]]) {\n                supportedTokens[tokens_[i]] = true;\n                tokenList.push(tokens_[i]);\n            }\n        }\n\n        admin = admin_;\n        withdrawableAt = withdrawableAt_;\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        unchecked {\n            uint256 claimedWordIndex = index / 256;\n            uint256 claimedBitIndex = index % 256;\n            uint256 claimedWord = claimedBitMap[claimedWordIndex];\n            uint256 mask = (1 << claimedBitIndex);\n            return claimedWord & mask == mask;\n        }\n    }\n\n    function _setClaimed(uint256 index) private {\n        unchecked {\n            uint256 claimedWordIndex = index / 256;\n            uint256 claimedBitIndex = index % 256;\n            claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n        }\n    }\n\n    function claim(\n        uint256 index,\n        address account,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[] calldata merkleProof\n    ) public virtual override {\n        if (isClaimed(index)) revert AlreadyClaimed();\n        if (tokens.length != amounts.length) revert TokensAmountsMismatch();\n        require(msg.sender == account, \"Only the claim owner may execute their claim\");\n\n        // Verify the merkle proof with the new leaf structure\n        bytes32 node = keccak256(abi.encodePacked(index, account, tokens, amounts));\n        if (!MerkleProof.verifyCalldata(merkleProof, merkleRoot, node)) revert InvalidProof();\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            // No need to check for presence in supportedTokens - this is done implicitly in the MerkleProof.verify,\n            // so long as the supported tokens supplied to the constructor correctly included all tokens found in each claim\n            // require(supportedTokens[tokens[i]], \"Token not supported\");\n            if (amounts[i] > 0) {\n                IERC20(tokens[i]).safeTransfer(account, amounts[i]);\n            }\n        }\n\n        emit Claimed(index, account, tokens, amounts);\n    }\n\n    function withdrawUnclaimed(address[] calldata tokens, address to) external {\n        if (msg.sender != admin) revert OnlyAdmin();\n        if (block.number < withdrawableAt) revert WithdrawTooEarly();\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20 token = IERC20(tokens[i]);\n            uint256 balance = token.balanceOf(address(this));\n            if (balance > 0) {\n                token.safeTransfer(to, balance);\n            }\n        }\n    }\n}\n"
    }
}