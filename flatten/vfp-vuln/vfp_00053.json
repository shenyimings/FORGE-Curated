{
    "vfp_id": "vfp_00053",
    "project_name": "cantina_liminal_oct2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Custom Fees Settable up to 100% in fulfillFastRedeems Can Seize Redemptions",
            "description": "The fulfillFastRedeems function allows a caller with the FULFILL_MANAGER_ROLE to specify a customFees array. While the code checks that the fee does not exceed 100% (feeBps <= BASIS_POINTS), it lacks a stricter, more reasonable upper bound. This allows a privileged manager to set a punitive fee of up to almost 100%, which could be used to unfairly seize the majority or almost all of a user's redemption value.\nThe root cause is the absence of a configurable or hardcoded sane maximum fee limit enforced on-chain. An attacker with the FULFILL_MANAGER_ROLE could exploit this by setting an excessively high fee during redemption processing.\nThe exploitation would occur when the attacker calls fulfillFastRedeems with a near-100% fee, causing users to lose most of their redemption value to the fee recipient.\nThe impact is financial loss for users during fast redemption, undermining trust in the system's fairness and potentially enabling abuse by privileged actors.\n",
            "severity": "Medium",
            "location": [
                "RedemptionPipe.sol#L439-L466"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        }
    ],
    "affected_files": {
        "RedemptionPipe.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {INAVOracle} from \"./interfaces/INAVOracle.sol\";\nimport {IShareManager} from \"./interfaces/IShareManager.sol\";\n\ninterface IFeeManager {\n    function accruePerformanceFee() external;\n}\n\n/**\n * @title RedemptionPipe\n * @notice Handles all redemptions (instant, fast, standard) for the vault\n * @dev Implements ERC7540-like interface with multiple redemption types\n * Does not strictly follow the ERC7540 spec as it has short-circuits and \n * pushes the async request's assets on users instead of allowing for claim/pull.\n */\ncontract RedemptionPipe is\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /// @notice Roles\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n    bytes32 public constant FULFILL_MANAGER_ROLE = keccak256(\"FULFILL_MANAGER_ROLE\");\n    bytes32 public constant SAFE_MANAGER_ROLE = keccak256(\"SAFE_MANAGER_ROLE\");\n\n    /// @notice Basis points constant (100% = 10000 basis points)\n    uint256 public constant BASIS_POINTS = 10_000;\n\n    /// @notice Request ID (ERC7540 compatibility)\n    uint256 internal constant REQUEST_ID = 0;\n\n    /// @custom:storage-location erc7201:liminal.redemptionPipe.v1\n    struct RedemptionPipeStorage {\n        /// @notice Share manager contract\n        IShareManager shareManager;\n        /// @notice NAV oracle contract\n        INAVOracle navOracle;\n        /// @notice Underlying asset for redemptions\n        IERC20Metadata underlyingAsset;\n        /// @notice Liquidity provider for fulfillments\n        address liquidityProvider;\n        /// @notice Fee configuration\n        FeeConfig fees;\n        uint256 lastNAVForPerformance;\n        /// @notice Recovery delay period (configurable) - uint24 safely fits 194 days in seconds\n        uint24 recoveryDelay;\n        /// @notice Last redemption timestamp for recovery check \n        uint72 lastRedemptionTime;\n        /// @notice Treasury address for recovered assets\n        address treasury;\n        /// @notice Standard redemption mappings\n        mapping(address => PendingRedeemRequest) pendingRedeem;\n        /// @notice Fast redemption mappings\n        mapping(address => PendingFastRedeemRequest) pendingFastRedeem;\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Minimum shares to prevent rounding to zero assets (OZ recommendation: 1000 units)\n        /// Calculated as 1000 * 10^(18 - assetDecimals)\n        uint256 MIN_AMOUNT_SHARES;\n        /// @notice Fee manager for performance fee accrual\n        IFeeManager feeManager;\n        /// @notice Maximum custom fee in basis points for fast redeems\n        uint256 maxCustomFeeBps;\n        /// @notice Whether fast redemption is enabled\n        bool fastRedeemEnabled;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.redemptionPipe.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REDEMPTION_PIPE_STORAGE_LOCATION =\n        0x29501c6d0a5cf7bef3f2db502c4a21ddfa1dc6ae30f842b9bba4cfdd2f8c2a00;\n\n    function _getRedemptionPipeStorage() private pure returns (RedemptionPipeStorage storage $) {\n        assembly {\n            $.slot := REDEMPTION_PIPE_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Fee structure\n    struct FeeConfig {\n        uint256 instantRedeemFeeBps; // Basis points for instant redemption\n        uint256 fastRedeemFeeBps; // Basis points for fast redemption\n    }\n\n    /// @notice Standard redemption request\n    struct PendingRedeemRequest {\n        uint256 shares;\n        address receiver;\n    }\n\n    /// @notice Fast redemption request\n    struct PendingFastRedeemRequest {\n        uint256 shares;\n        uint256 timestamp;\n        address receiver;\n    }\n\n    /// Events\n    event InstantRedeem(address indexed user, address indexed receiver, uint256 shares, uint256 assets, uint256 fee);\n    event FastRedeemRequested(address indexed owner, address indexed receiver, uint256 shares, uint256 timestamp);\n    event FastRedeemFulfilled(address indexed owner, address indexed receiver, uint256 assets, uint256 shares, uint256 fee);\n    event RedeemRequested(address indexed owner, address indexed receiver, uint256 shares);\n    event RedeemFulfilled(address indexed owner, address indexed receiver, uint256 assets, uint256 shares);\n    event FeesUpdated(FeeConfig newFees);\n    event RecoveryDelayUpdated(uint256 newDelay);\n    event TreasuryUpdated(address indexed newTreasury);\n    event AssetsRecovered(address indexed token, uint256 amount, address indexed treasury);\n    event LiquidityProviderUpdated(address indexed oldProvider, address indexed newProvider);\n    event MaxCustomFeeBpsUpdated(uint256 newMaxCustomFeeBps);\n    event FastRedeemEnabledUpdated(bool enabled);\n    event TimeLockControllerUpdated(address indexed oldTimeLockController, address indexed newTimeLockController);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require(msg.sender == $.timeLockController, \"RedemptionPipe: only timelock\");\n        _;\n    }\n\n    /// @notice Modifier to accrue performance fees before operations\n    modifier accruePerformanceFee() {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.feeManager.accruePerformanceFee();\n        _;\n    }\n\n    /// @notice Modifier to check if fast redemption is enabled\n    modifier fastRedeemEnabledCheck() {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require($.fastRedeemEnabled, \"RedemptionPipe: fast redeem disabled\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Parameters for initialization\n    struct InitializeParams {\n        address shareManager;\n        address navOracle;\n        address underlyingAsset;\n        address liquidityProvider;\n        address deployer;\n        address safeManager;\n        address emergencyManager;\n        address requestManager;\n        address treasury;\n        uint256 recoveryDelay;\n        address timeLockController;\n        address feeManager;\n        uint256 maxCustomFeeBps;\n    }\n\n    /**\n     * @notice Initialize the redemption pipe\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param params Struct containing all initialization parameters\n     */\n    function initialize(InitializeParams calldata params) external initializer {\n        require(params.shareManager != address(0), \"RedemptionPipe: zero share manager\");\n        require(params.navOracle != address(0), \"RedemptionPipe: zero nav oracle\");\n        require(params.underlyingAsset != address(0), \"RedemptionPipe: zero underlying\");\n        require(params.deployer != address(0), \"RedemptionPipe: zero deployer\");\n        require(params.safeManager != address(0), \"RedemptionPipe: zero safe manager\");\n        require(params.liquidityProvider != address(0), \"RedemptionPipe: zero liquidity provider\");\n        require(params.emergencyManager != address(0), \"RedemptionPipe: zero emergency manager\");\n        require(params.timeLockController != address(0), \"RedemptionPipe: zero timelock\");\n        require(params.requestManager != address(0), \"RedemptionPipe: zero request manager\");\n        require(params.treasury != address(0), \"RedemptionPipe: zero treasury address\");\n        require(params.recoveryDelay > 0, \"RedemptionPipe: zero delay\");\n        require(params.feeManager != address(0), \"RedemptionPipe: zero fee manager\");\n        require(params.maxCustomFeeBps <= BASIS_POINTS, \"RedemptionPipe: max custom fee exceeds 100%\");\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.shareManager = IShareManager(params.shareManager);\n        $.navOracle = INAVOracle(params.navOracle);\n        $.underlyingAsset = IERC20Metadata(params.underlyingAsset);\n        $.liquidityProvider = params.liquidityProvider;\n        $.treasury = params.treasury;\n        $.recoveryDelay = uint24(params.recoveryDelay);\n        $.timeLockController = params.timeLockController;\n        $.feeManager = IFeeManager(params.feeManager);\n        $.maxCustomFeeBps = params.maxCustomFeeBps;\n        $.fastRedeemEnabled = false; // Default to disabled\n\n        // Calculate minimum shares based on underlying asset decimals\n        // MIN_AMOUNT = 1000 * 10^(18 - assetDecimals) to ensure at least 1000 units of assets\n        uint8 assetDecimals = IERC20Metadata(params.underlyingAsset).decimals();\n        require(assetDecimals <= 18, \"RedemptionPipe: unsupported decimals\");\n        $.MIN_AMOUNT_SHARES = 1000 * 10 ** (18 - assetDecimals);\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, params.deployer);\n        _grantRole(SAFE_MANAGER_ROLE, params.safeManager);\n        _grantRole(EMERGENCY_MANAGER_ROLE, params.emergencyManager);\n        _grantRole(FULFILL_MANAGER_ROLE, params.requestManager);\n\n        $.lastNAVForPerformance = $.navOracle.getNAV();\n    }\n\n    /**\n     * @notice Recover stuck assets after recovery delay\n     * @dev Can only be called when paused and after recovery delay since last redemption\n     * @param token Address of token to recover\n     * @param amount Amount to recover\n     */\n    function recoverAssets(address token, uint256 amount)\n        external\n        onlyRole(SAFE_MANAGER_ROLE)\n        whenPaused\n        nonReentrant\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require($.treasury != address(0), \"RedemptionPipe: treasury not set\");\n        require(block.timestamp > $.lastRedemptionTime + $.recoveryDelay, \"RedemptionPipe: recovery delay not met\");\n        require(token != address(0), \"RedemptionPipe: zero token address\");\n        require(amount > 0, \"RedemptionPipe: zero amount\");\n\n        // Check balance\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance >= amount, \"RedemptionPipe: insufficient balance\");\n\n        // Transfer to treasury\n        IERC20(token).safeTransfer($.treasury, amount);\n\n        emit AssetsRecovered(token, amount, $.treasury);\n    }\n\n    /**\n     * @notice Update recovery delay\n     * @param _recoveryDelay New recovery delay in seconds\n     */\n    function setRecoveryDelay(uint256 _recoveryDelay) external onlyTimelock {\n        require(_recoveryDelay >= 7 days, \"RedemptionPipe: delay too short\");\n        require(_recoveryDelay <= 90 days, \"RedemptionPipe: delay too long\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.recoveryDelay = uint24(_recoveryDelay);\n        emit RecoveryDelayUpdated(_recoveryDelay);\n    }\n\n    /**\n     * @notice Update treasury address\n     * @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) external onlyTimelock {\n        require(_treasury != address(0), \"RedemptionPipe: zero address\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// @notice Get current fee configuration (returns individual values for backward compatibility)\n    function fees() public view returns (uint256 _instantRedeemFeeBps, uint256 _fastRedeemFeeBps) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        return ($.fees.instantRedeemFeeBps, $.fees.fastRedeemFeeBps);\n    }\n\n    /// @notice Get individual fee components for backward compatibility\n    function instantRedeemFeeBps() public view returns (uint256) {\n        return _getRedemptionPipeStorage().fees.instantRedeemFeeBps;\n    }\n\n    function fastRedeemFeeBps() public view returns (uint256) {\n        return _getRedemptionPipeStorage().fees.fastRedeemFeeBps;\n    }\n\n    /// @notice Get recovery delay\n    function recoveryDelay() public view returns (uint256) {\n        return _getRedemptionPipeStorage().recoveryDelay;\n    }\n\n    /// @notice Get treasury address\n    function treasury() public view returns (address) {\n        return _getRedemptionPipeStorage().treasury;\n    }\n\n    /// @notice Get liquidity provider address\n    function liquidityProvider() public view returns (address) {\n        return _getRedemptionPipeStorage().liquidityProvider;\n    }\n\n    /// @notice Get minimum amount required for redemption\n    function MIN_AMOUNT_SHARES() public view returns (uint256) {\n        return _getRedemptionPipeStorage().MIN_AMOUNT_SHARES;\n    }\n\n    /// @notice Get maximum custom fee in basis points\n    function maxCustomFeeBps() public view returns (uint256) {\n        return _getRedemptionPipeStorage().maxCustomFeeBps;\n    }\n\n    /// @notice Get fast redemption enabled status\n    function fastRedeemEnabled() public view returns (bool) {\n        return _getRedemptionPipeStorage().fastRedeemEnabled;\n    }\n\n    /// @notice Get timelock controller address\n    function timeLockController() public view returns (address) {\n        return _getRedemptionPipeStorage().timeLockController;\n    }\n\n    /**\n     * @notice Update liquidity provider\n     * @param _liquidityProvider New liquidity provider address\n     */\n    function setLiquidityProvider(address _liquidityProvider) external onlyTimelock {\n        require(_liquidityProvider != address(0), \"RedemptionPipe: zero address\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        address oldProvider = $.liquidityProvider;\n        $.liquidityProvider = _liquidityProvider;\n        emit LiquidityProviderUpdated(oldProvider, _liquidityProvider);\n    }\n\n    /**\n     * @notice Update maximum custom fee for fast redeems\n     * @param _maxCustomFeeBps New maximum custom fee in basis points\n     */\n    function setMaxCustomFeeBps(uint256 _maxCustomFeeBps) external onlyTimelock {\n        require(_maxCustomFeeBps <= BASIS_POINTS, \"RedemptionPipe: max custom fee exceeds 100%\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.maxCustomFeeBps = _maxCustomFeeBps;\n        emit MaxCustomFeeBpsUpdated(_maxCustomFeeBps);\n    }\n\n    // ========== INSTANT REDEMPTION ==========\n\n    /**\n     * @notice Instant redemption using vault liquidity\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive assets\n     * @param controller Address that controls the shares\n     * @return assets Amount of assets received\n     */\n    function redeem(uint256 shares, address receiver, address controller)\n        external\n        whenNotPaused\n        nonReentrant\n        accruePerformanceFee\n        returns (uint256 assets)\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(\n            controller == msg.sender || $.shareManager.isOperator(controller, msg.sender),\n            \"RedemptionPipe: unauthorized\"\n        );\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require($.shareManager.balanceOf(controller) >= shares, \"RedemptionPipe: insufficient shares\");\n\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n\n\n        // Calculate assets based on NAV\n        assets = convertToAssets(shares);\n\n        // Calculate fee in basis points (fee = assets * feeBps / BASIS_POINTS)\n        uint256 fee = (assets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n        uint256 assetsAfterFee = assets - fee;\n\n\n        // Update NAV. Fees stay with liquidityProvider, only decrease NAV by user's portion\n        uint256 navDecrease = assetsAfterFee;\n        $.navOracle.decreaseTotalAssets(navDecrease);\n\n        // Burn shares\n        $.shareManager.burnShares(controller, shares);\n\n        uint256 lpBalance = $.underlyingAsset.balanceOf($.liquidityProvider);\n        require(lpBalance >= assetsAfterFee, \"RedemptionPipe: insufficient liquidity\");\n\n        // Transfer assets to user (fee stays with liquidity provider)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, receiver, assetsAfterFee);\n\n        // Check if transfer was successful\n        uint256 expectedLpBalance = lpBalance - assetsAfterFee; // Only user assets left LP\n        require(\n            $.underlyingAsset.balanceOf($.liquidityProvider) == expectedLpBalance,\n            \"RedemptionPipe: liquidity provider balance mismatch\"\n        );\n        $.lastRedemptionTime = uint72(block.timestamp);\n\n        emit InstantRedeem(controller, receiver, shares, assetsAfterFee, fee);\n\n        return assetsAfterFee;\n    }\n\n    /**\n     * @notice Instant withdrawal of specific asset amount\n     * @param assets Amount of assets to withdraw\n     * @param receiver Address to receive assets\n     * @param controller Address that controls the shares\n     * @return shares Amount of shares burned\n     */\n    function withdraw(\n        uint256 assets,  // NET amount user wants to receive\n        address receiver,\n        address controller\n    ) external whenNotPaused nonReentrant accruePerformanceFee returns (uint256 shares) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        \n        require(\n            controller == msg.sender ||\n                $.shareManager.isOperator(controller, msg.sender),\n            \"RedemptionPipe: unauthorized\"\n        );\n        require(assets > 0, \"RedemptionPipe: zero assets\");\n        \n        \n        // Calculate gross assets needed (same calculation as redeem() but in reverse)\n        uint256 grossAssets = assets.mulDiv(\n            BASIS_POINTS, \n            BASIS_POINTS - $.fees.instantRedeemFeeBps,\n            Math.Rounding.Floor\n        );\n        \n        // Calculate shares needed based on gross assets (before fee)\n        shares = convertToShares(grossAssets);\n\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require(\n            $.shareManager.balanceOf(controller) >= shares,\n            \"RedemptionPipe: insufficient shares\"\n        );\n        \n        // Calculate the actual assets and fee that this shares amount would produce\n        uint256 actualAssets = convertToAssets(shares);\n        uint256 fee = (actualAssets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n        uint256 actualNetAssets = actualAssets - fee;\n        \n        \n        // Update NAV by user's net portion (fees stay with liquidity provider)\n        $.navOracle.decreaseTotalAssets(actualNetAssets);\n        \n        // Burn shares\n        $.shareManager.burnShares(controller, shares);\n        \n        // Transfer NET assets to user (what they requested)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, receiver, actualNetAssets);\n        $.lastRedemptionTime = uint72(block.timestamp);\n        \n        emit InstantRedeem(controller, receiver, shares, actualNetAssets, fee);\n        \n        return shares;\n    }\n\n    // ========== FAST REDEMPTION ==========\n\n    /**\n     * @notice Request fast redemption\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive assets when fulfilled\n     * @param controller Address that will control the redemption\n     * @param owner Owner of the shares\n     * @return requestId Always returns 0 (single request per owner)\n     */\n    function requestRedeemFast(uint256 shares, address receiver, address controller, address owner)\n        external\n        whenNotPaused\n        fastRedeemEnabledCheck\n        returns (uint256 requestId)\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(owner == msg.sender || $.shareManager.isOperator(owner, msg.sender), \"RedemptionPipe: unauthorized\");\n        require(\n            controller == msg.sender || $.shareManager.isOperator(controller, msg.sender),\n            \"RedemptionPipe: unauthorized controller\"\n        );\n        require(receiver != address(0), \"RedemptionPipe: zero receiver\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require($.shareManager.balanceOf(owner) >= shares, \"RedemptionPipe: insufficient shares\");\n\n        // Check total pending shares (existing + new request) against maxWithdraw\n        uint256 totalPendingAfter = _getTotalPendingShares(owner) + shares;\n        require(totalPendingAfter <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n\n        // Transfer shares to this contract for custody\n        $.shareManager.transferFrom(owner, address(this), shares);\n\n        uint256 currentPendingShares = $.pendingFastRedeem[owner].shares;\n        $.pendingFastRedeem[owner] = PendingFastRedeemRequest(shares + currentPendingShares, block.timestamp, receiver);\n\n        emit FastRedeemRequested(owner, receiver, shares, block.timestamp);\n        return REQUEST_ID;\n    }\n\n    /**\n     * @notice Fulfill fast redemption requests\n     * @param owners Array of owners\n     * @param shares Array of share amounts\n     * @param customFees Array of custom _getRedemptionPipeStorage().fees (or use default)\n     */\n    function fulfillFastRedeems(address[] calldata owners, uint256[] calldata shares, uint256[] calldata customFees)\n        external\n        onlyRole(FULFILL_MANAGER_ROLE)\n        fastRedeemEnabledCheck\n        accruePerformanceFee\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        uint256 length = owners.length;\n        require(length == shares.length, \"RedemptionPipe: length mismatch\");\n\n        for (uint256 i = 0; i < length; i++) {\n            if (shares[i] > 0) {\n                // Calculate assets for fee calculation\n                uint256 assets = convertToAssets(shares[i]);\n                // Use custom fee basis points if provided, otherwise use default\n                uint256 feeBps = customFees.length > i ? customFees[i] : $.fees.fastRedeemFeeBps;\n                require(feeBps <= BASIS_POINTS, \"RedemptionPipe: Incorrect Custom Fee\");\n                require(feeBps <= $.maxCustomFeeBps, \"RedemptionPipe: Custom fee exceeds maximum\");\n                uint256 fee = (assets * feeBps) / BASIS_POINTS;\n                _fulfillFastRedeem(owners[i], shares[i], fee);\n            }\n        }\n        $.lastRedemptionTime = uint72(block.timestamp);\n    }\n\n    /**\n     * @notice Internal fast redeem fulfillment\n     */\n    function _fulfillFastRedeem(address owner, uint256 shares, uint256 fee) internal {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(!$.shareManager.isBlacklisted(owner), \"RedemptionPipe: owner is blacklisted\");\n\n        PendingFastRedeemRequest storage request = $.pendingFastRedeem[owner];\n        require(request.shares >= shares, \"RedemptionPipe: insufficient pending\");\n\n        // Performance fees are accrued via modifier\n\n        // Calculate assets based on current NAV\n        uint256 assets = convertToAssets(shares);\n\n        uint256 assetsAfterFee = assets - fee;\n\n        // Update NAV. Fees stay with liquidityProvider, only decrease NAV by user's portion\n        uint256 navDecrease = assetsAfterFee;\n        $.navOracle.decreaseTotalAssets(navDecrease);\n\n        // Update pending\n        request.shares -= shares;\n\n        // Burn shares held in custody\n        $.shareManager.burnSharesFromSelf(shares);\n\n        // Transfer assets to receiver (fee stays with liquidity provider)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, request.receiver, assetsAfterFee);\n\n        emit FastRedeemFulfilled(owner, request.receiver, assetsAfterFee, shares, fee);\n    }\n\n    // ========== STANDARD REDEMPTION ==========\n\n    /**\n     * @notice Request standard redemption\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive assets when fulfilled\n     * @param controller Address that will control the redemption (for ERC7540 compatibility)\n     * @param owner Owner of the shares\n     * @return requestId Always returns 0\n     */\n    function requestRedeem(uint256 shares, address receiver, address controller, address owner)\n        external\n        whenNotPaused\n        returns (uint256 requestId)\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        PendingRedeemRequest storage request = $.pendingRedeem[owner];\n\n        require(owner != address(0), \"RedemptionPipe: unauthorized\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require($.shareManager.balanceOf(msg.sender) >= shares, \"RedemptionPipe: insufficient shares\");\n\n        // Check authorization: msg.sender must be owner or operator of owner\n        require(\n            msg.sender == owner || $.shareManager.isOperator(owner, msg.sender),\n            \"RedemptionPipe: unauthorized\"\n        );\n\n        // Check controller authorization\n        require(controller != address(0), \"RedemptionPipe: unauthorized controller\");\n        require(\n            controller == owner || $.shareManager.isOperator(owner, controller),\n            \"RedemptionPipe: unauthorized controller\"\n        );\n\n        require(receiver != address(0), \"RedemptionPipe: zero receiver\");\n\n        // Check maximum withdraw limit\n        uint256 currentPendingShares = request.shares;\n        uint256 totalPendingAfterRequest = currentPendingShares + shares + $.pendingFastRedeem[owner].shares;\n        require(\n            totalPendingAfterRequest <= $.shareManager.maxWithdraw(),\n            \"RedemptionPipe: maximum redeem per user exceeded\"\n        );\n\n        // Transfer shares to this contract for custody\n        $.shareManager.transferFrom(msg.sender, address(this), shares);\n\n        // Add to pending\n        request.shares = shares + currentPendingShares;\n        request.receiver = receiver;\n\n        emit RedeemRequested(owner, receiver, shares);\n        return REQUEST_ID;\n    }\n\n    /**\n     * @notice Fulfill standard redemption requests\n     * @param owners Array of owners\n     * @param shares Array of share amounts\n     */\n    function fulfillRedeems(address[] calldata owners, uint256[] calldata shares)\n        external\n        onlyRole(FULFILL_MANAGER_ROLE)\n        accruePerformanceFee\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        uint256 length = owners.length;\n        require(length == shares.length, \"RedemptionPipe: length mismatch\");\n\n        for (uint256 i = 0; i < length; i++) {\n            if (shares[i] > 0) {\n                _fulfillRedeem(owners[i], shares[i]);\n            }\n        }\n        $.lastRedemptionTime = uint72(block.timestamp);\n    }\n\n    /**\n     * @notice Internal standard redeem fulfillment\n     */\n    function _fulfillRedeem(address owner, uint256 shares) internal {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(!$.shareManager.isBlacklisted(owner), \"RedemptionPipe: owner is blacklisted\");\n\n        PendingRedeemRequest storage request = $.pendingRedeem[owner];\n        require(request.shares >= shares, \"RedemptionPipe: insufficient pending\");\n\n        // Performance fees are accrued via modifier\n\n        // Calculate assets\n        uint256 assets = convertToAssets(shares);\n\n        // Update NAV - full amount leaves system (no fees)\n        $.navOracle.decreaseTotalAssets(assets);\n\n        // Update pending\n        request.shares -= shares;\n\n        // Burn shares\n        $.shareManager.burnSharesFromSelf(shares);\n\n        // Transfer full assets to receiver (no fees)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, request.receiver, assets);\n\n        emit RedeemFulfilled(owner, request.receiver, assets, shares);\n    }\n\n    // ========== VIEW FUNCTIONS ==========\n\n    /**\n     * @notice Get total pending shares for a user (both standard and fast redemptions)\n     * @param owner Owner address\n     * @return Total pending shares\n     */\n    function _getTotalPendingShares(address owner) internal view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        return $.pendingRedeem[owner].shares + $.pendingFastRedeem[owner].shares;\n    }\n\n    /**\n     * @notice Preview redeem - converts shares to underlying assets after instant fees\n     * @param shares Amount of shares to redeem\n     * @return assets Expected underlying assets received (after instant fees)\n     */\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require(shares > 0, \"RedemptionPipe: zero shares\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares less than min amount\");\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n\n        // Convert shares to underlying assets (in native decimals)\n        uint256 assets = convertToAssets(shares);\n        \n        // Calculate instant redemption fee in basis points\n        uint256 fee = (assets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n        \n        // Return assets after fee (what user actually receives from instant redemption)\n        return assets - fee;\n    }\n\n    /**\n     * @notice Preview withdraw - calculates required shares for net asset amount\n     * @param assets Net asset amount (what user wants to receive after fees)\n     * @return shares Required shares to burn\n     */\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require(assets > 0, \"RedemptionPipe: zero assets\");\n\n        // Calculate gross assets needed (same calculation as withdraw() but in reverse)\n        uint256 grossAssets = assets.mulDiv(\n            BASIS_POINTS, \n            BASIS_POINTS - $.fees.instantRedeemFeeBps,\n            Math.Rounding.Floor\n        );\n        \n        uint256 shares = convertToShares(grossAssets);\n\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares less than min amount\");\n        return shares;\n    }\n\n    /**\n     * @notice Convert shares to assets\n     * @param shares Amount of shares\n     * @return assets Equivalent asset amount\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        uint256 totalSupply = $.shareManager.totalSupply();\n        uint256 totalAssets = $.navOracle.getNAV();\n\n        uint8 underlyingDecimals = $.underlyingAsset.decimals();\n        uint256 decimalsDiff = 18 - underlyingDecimals;\n        uint256 scaleFactor = 10 ** decimalsDiff;\n\n        if (totalSupply == 0) {\n            // When no supply, convert decimals directly\n            return shares / scaleFactor;\n        }\n\n        // Calculate value in 18 decimals\n        uint256 value18 = shares.mulDiv(totalAssets, totalSupply, Math.Rounding.Floor);\n\n        // Convert from 18 decimals to underlying asset decimals\n        return value18 / scaleFactor;\n    }\n\n    /**\n     * @notice Convert assets to shares\n     * @param assets Amount of assets\n     * @return shares Equivalent share amount\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        if (assets == 0) {\n            return 0;\n        }\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        uint256 totalSupply = $.shareManager.totalSupply();\n        uint256 totalAssets = $.navOracle.getNAV();\n\n        uint8 underlyingDecimals = $.underlyingAsset.decimals();\n        uint256 decimalsDiff = 18 - underlyingDecimals;\n        uint256 scaleFactor = 10 ** decimalsDiff;\n\n        if (totalSupply == 0) {\n            // When no supply, convert decimals directly\n            return assets * scaleFactor;\n        }\n\n        // Convert from underlying asset decimals to 18 decimals\n        uint256 value18 = assets * scaleFactor;\n\n        // Calculate shares\n        return value18.mulDiv(totalSupply, totalAssets, Math.Rounding.Ceil);\n    }\n\n    /**\n     * @notice Get pending fast redeem request\n     * @param owner Owner address\n     * @return shares Amount of pending shares\n     * @return timestamp Request timestamp\n     * @return receiver Address that will receive the assets\n     */\n    function pendingFastRedeemRequest(address owner) external view returns (uint256 shares, uint256 timestamp, address receiver) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        PendingFastRedeemRequest memory request = $.pendingFastRedeem[owner];\n        return (request.shares, request.timestamp, request.receiver);\n    }\n\n    /**\n     * @notice Get pending standard redeem request\n     * @param owner Owner address\n     * @return shares Amount of pending shares\n     * @return receiver Address that will receive the assets\n     */\n    function pendingRedeemRequest(address owner) external view returns (uint256 shares, address receiver) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        PendingRedeemRequest memory request = $.pendingRedeem[owner];\n        return (request.shares, request.receiver);\n    }\n\n    /**\n     * @notice Maximum amount of shares that can be redeemed from the owner balance through a redeem call\n     * @param owner Address of the owner\n     * @return Maximum amount of shares that can be redeemed\n     * @dev ERC4626 compliant - considers balance, pending requests, and maxWithdraw limit\n     */\n    function maxRedeem(address owner) external view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        // Get owner's balance\n        uint256 balance = $.shareManager.balanceOf(owner);\n        if (balance == 0) {\n            return 0;\n        }\n\n        // Get total pending shares (both standard and fast redemptions)\n        uint256 totalPending = _getTotalPendingShares(owner);\n\n        // Get maximum shares allowed by ShareManager policy\n        uint256 maxWithdrawShares = $.shareManager.maxWithdraw();\n\n        // Calculate remaining capacity for new redemptions\n        uint256 remainingCapacity = maxWithdrawShares > totalPending ? maxWithdrawShares - totalPending : 0;\n\n        // Return the minimum of owner's balance and remaining capacity\n        uint256 maxShares = balance < remainingCapacity ? balance : remainingCapacity;\n\n        // Ensure it meets minimum requirement, otherwise return 0\n        if (maxShares < $.MIN_AMOUNT_SHARES) {\n            return 0;\n        }\n\n        return maxShares;\n    }\n\n    /**\n     * @notice Maximum amount of underlying assets that can be withdrawn from the owner balance through a withdraw call\n     * @param owner Address of the owner\n     * @return Maximum amount of assets that can be withdrawn\n     * @dev ERC4626 compliant - converts maxRedeem to assets after accounting for instant redemption fees\n     */\n    function maxWithdraw(address owner) external view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        // Return 0 if contract is paused\n        if (paused()) {\n            return 0;\n        }\n\n        // Get owner's balance\n        uint256 balance = $.shareManager.balanceOf(owner);\n        if (balance == 0) {\n            return 0;\n        }\n\n        // Get total pending shares (both standard and fast redemptions)\n        uint256 totalPending = _getTotalPendingShares(owner);\n\n        // Get maximum shares allowed by ShareManager policy\n        uint256 maxWithdrawShares = $.shareManager.maxWithdraw();\n\n        // Calculate remaining capacity for new redemptions\n        uint256 remainingCapacity = maxWithdrawShares > totalPending ? maxWithdrawShares - totalPending : 0;\n\n        // Return the minimum of owner's balance and remaining capacity\n        uint256 maxAllowedShares = balance < remainingCapacity ? balance : remainingCapacity;\n\n        // Ensure it meets minimum requirement, otherwise return 0\n        if (maxAllowedShares < $.MIN_AMOUNT_SHARES) {\n            return 0;\n        }\n\n        // Convert to assets and apply instant redemption fee\n        uint256 assets = convertToAssets(maxAllowedShares);\n        uint256 fee = (assets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n\n        return assets - fee;\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Update timelock controller address\n     * @param _timelockController New timelock controller address\n     */\n    function setTimelockController(address _timelockController) external onlyTimelock {\n        require(_timelockController != address(0), \"RedemptionPipe: zero timelock\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        address oldTimeLockController = $.timeLockController;\n        $.timeLockController = _timelockController;\n        emit TimeLockControllerUpdated(oldTimeLockController, _timelockController);\n    }\n\n    /**\n     * @notice Update fee configuration\n     * @param _fees New fee configuration\n     */\n    function setFees(FeeConfig calldata _fees) external onlyTimelock {\n        require(_fees.instantRedeemFeeBps <= BASIS_POINTS, \"RedemptionPipe: instant fee exceeds 100%\");\n        require(_fees.fastRedeemFeeBps <= BASIS_POINTS, \"RedemptionPipe: fast fee exceeds 100%\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.fees = _fees;\n        emit FeesUpdated(_fees);\n    }\n\n    /**\n     * @notice Emergency pause\n     */\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause operations\n     */\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Update fast redemption enabled status\n     * @param _enabled New fast redemption enabled status\n     */\n    function setFastRedeemEnabled(bool _enabled) external onlyRole(SAFE_MANAGER_ROLE) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.fastRedeemEnabled = _enabled;\n        emit FastRedeemEnabledUpdated(_enabled);\n    }\n}\n"
    }
}