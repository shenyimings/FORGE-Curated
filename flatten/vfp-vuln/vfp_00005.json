{
    "vfp_id": "vfp_00005",
    "project_name": "2025-10-radiustechnology-evmauth-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Incorrect account assignment in token burning logic",
            "description": "The token burning logic incorrectly assigns the wrong account address when burning tokens. Specifically, during a burn operation, the code sets `_account = to`, which is `address(0)` when burning, instead of using the `from` address representing the token holder. This causes the contract to attempt to burn tokens from the zero address, which has no balance, leading to transaction reverts.\n\nThe root cause lies in the `_update` function within the `_burnGroupBalances` and `_pruneGroups` calls, where the `to` address is used instead of `from` during burn operations. This improper account assignment violates the expected semantics of ERC-1155 token burning.\n\nAn attacker or even a legitimate admin attempting to burn tokens on behalf of a user will find the operation failing silently or reverting, as the burn is incorrectly sourced from the zero address. This exploitation does not require malicious intent but occurs naturally during intended administrative actions.\n\nThe impact is that tokens cannot be properly burned, allowing users to retain access privileges even after intended revocation. This undermines the authentication mechanism of the system and results in a denial of service for administrative token management.\n",
            "severity": "High",
            "location": [
                "src/base/EVMAuthExpiringERC1155.sol::_update",
                "src/base/EVMAuthExpiringERC1155.sol::_burnGroupBalances",
                "src/base/EVMAuthExpiringERC1155.sol::_pruneGroups"
            ],
            "files": [
                "evmauth-core/src/base/EVMAuthExpiringERC1155.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "Expired token groups not synchronized with ERC1155 balance tracking",
            "description": "The `_pruneGroups` function removes expired token groups from the custom group array but fails to update the underlying ERC1155 `_balances` mapping. This creates a critical data inconsistency between the two balance tracking systems: the group-based expiration system and the standard ERC1155 balance.\n\nThe cause is the omission of a call to the parent contract's `_burn` function within `_pruneGroups`. While expired tokens are removed from the group array and an `ExpiredTokensBurned` event is emitted, the actual ERC1155 balance remains unchanged because no balance deduction occurs.\n\nAn attacker can exploit this by holding tokens past expiration and transferring them to another account. Since the ERC1155 balance is not reduced during pruning, these \"zombie\" expired tokens retain transferability despite being logically invalid.\n\nThe impact is severe: expired tokens remain usable for transfers and potentially for authentication, breaking the intended time-based access control. This undermines the entire expiration mechanism and allows indefinite access extension without re-authentication.\n",
            "severity": "High",
            "location": [
                "src/base/EVMAuthExpiringERC1155.sol::_pruneGroups"
            ],
            "files": [
                "evmauth-core/src/base/EVMAuthExpiringERC1155.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Missing debt validation in group transfer function",
            "description": "The `_transferGroups` function fails to validate that the full transfer amount (debt) is satisfied after processing all valid (non-expired) token groups. It skips expired groups during iteration but does not ensure that `debt == 0` after the loop completes. If expired groups are encountered and skipped, the function may exit early with a non-zero debt, yet still allow the transfer to proceed at the ERC1155 level.\n\nThe root cause is the absence of a final check confirming that all requested tokens were transferred. Expired groups are skipped, and only non-expired tokens are used to satisfy the transfer amount, but no enforcement ensures completeness.\n\nAn attacker can exploit this by structuring their token holdings to include expired groups, then initiating a transfer. The function will partially transfer only the non-expired tokens while the ERC1155 balance is fully deducted, creating a discrepancy between on-chain balances and group state.\n\nThe impact is data inconsistency between the group accounting system and ERC1155 balances, leading to incorrect access control decisions and potential loss of tokens. Users may lose tokens without receiving the expected amount, and system integrity is compromised.\n",
            "severity": "High",
            "location": [
                "src/base/EVMAuthExpiringERC1155.sol::_transferGroups"
            ],
            "files": [
                "evmauth-core/src/base/EVMAuthExpiringERC1155.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Missing debt validation in group burn function",
            "description": "The `_burnGroupBalances` function does not verify that the full burn amount was processed. Similar to the transfer issue, it skips expired groups but fails to check whether the `debt` variable reaches zero after processing all applicable groups.\n\nThe cause is the lack of a post-loop validation that all requested tokens were burned. Expired groups are skipped, and only non-expired tokens are used to satisfy the burn amount, but no enforcement ensures completeness.\n\nAn attacker (or system process) attempting to burn tokens may believe the operation succeeded, but only a partial burn occurs. For example, if a user has both expired and valid tokens, the burn will consume only the valid ones up to the available balance, leaving the debt unmet but unenforced.\n\nThe impact is a mismatch between the ERC1155 balance (which is correctly reduced) and the group state (which reflects an incomplete burn). This leads to inconsistent accounting, potential access control flaws, and undermines trust in the token lifecycle management.\n",
            "severity": "High",
            "location": [
                "src/base/EVMAuthExpiringERC1155.sol::_burnGroupBalances"
            ],
            "files": [
                "evmauth-core/src/base/EVMAuthExpiringERC1155.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-770"
                ],
                "4": [
                    "CWE-1325"
                ]
            },
            "title": "Unbounded group array growth causes gas limit exceeded",
            "description": "The contract allows unbounded growth of the `_group[account][id]` array, where each token purchase with a unique expiration time creates a new entry. Functions like `_transferGroups`, `_pruneGroups`, and `_upsertGroup` perform linear iterations over this array, leading to increasing gas costs.\n\nThe root cause is the use of an unbounded dynamic array with ordered insertion (by expiration time), which requires O(n) operations for insertion, pruning, and transfers. As the number of groups grows, these operations can exceed the block gas limit.\n\nAn attacker can exploit this by repeatedly transferring small token amounts with different expiration times to a target account, forcing the creation of thousands of groups. Once the array is large enough, legitimate operations like transfers or balance checks will fail due to gas exhaustion.\n\nThe impact is a denial of service for affected users, who become unable to interact with their tokens. Their assets are effectively frozen, breaking core functionality and availability of the system.\n",
            "severity": "Medium",
            "location": [
                "src/base/EVMAuthExpiringERC1155.sol::_upsertGroup",
                "src/base/EVMAuthExpiringERC1155.sol::_transferGroups",
                "src/base/EVMAuthExpiringERC1155.sol::_pruneGroups"
            ],
            "files": [
                "evmauth-core/src/base/EVMAuthExpiringERC1155.sol"
            ]
        }
    ],
    "affected_files": {
        "EVMAuthExpiringERC1155.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./EVMAuthPurchasableERC1155.sol\";\n\n/**\n * @title EVMAuthExpiringERC1155\n * @dev Extension of the EVMAuthPurchasableERC1155 contract that adds expiration logic and management to tokens\n */\nabstract contract EVMAuthExpiringERC1155 is EVMAuthPurchasableERC1155 {\n    // Batch of tokens that expire at the same time\n    struct Group {\n        uint256 balance;\n        uint256 expiresAt;\n    }\n\n    // Mapping from account -> token ID -> Group[]\n    mapping(address => mapping(uint256 => Group[])) private _group;\n\n    // Mapping from token ID to token time-to-live (TTL) in seconds\n    mapping(uint256 => uint256) private _ttls;\n\n    // Events\n    event ExpiredTokensBurned(address indexed account, uint256 indexed id, uint256 amount);\n\n    /**\n     * @dev Constructor\n     * @param _name Name of the EIP-712 signing domain\n     * @param _version Current major version of the EIP-712 signing domain\n     * @param _uri URI for ERC-1155 token metadata\n     * @param _delay Delay (in seconds) for transfer of contract ownership\n     * @param _owner Address of the contract owner\n     */\n    constructor(string memory _name, string memory _version, string memory _uri, uint48 _delay, address _owner)\n        EVMAuthPurchasableERC1155(_name, _version, _uri, _delay, _owner)\n    {}\n\n    /**\n     * @dev Override to exclude expired tokens\n     */\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\n        Group[] storage groups = _group[account][id];\n        uint256 netBalance = super.balanceOf(account, id);\n        uint256 _now = block.timestamp;\n\n        // Exclude expired token balances\n        for (uint256 i = 0; i < groups.length; i++) {\n            if (groups[i].expiresAt <= _now) {\n                netBalance -= groups[i].balance;\n            }\n        }\n\n        return netBalance;\n    }\n\n    /**\n     * @dev Get the balance of all tokens for a given account\n     * @param account The address to check\n     * @return Array of balances for each token ID\n     */\n    function balanceOfAll(address account) public view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](nextTokenId);\n        for (uint256 i = 0; i < nextTokenId; i++) {\n            balances[i] = balanceOf(account, i);\n        }\n        return balances;\n    }\n\n    /**\n     * @dev Override to exclude expired tokens\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"Length mismatch\");\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev Get expiration details of token holdings for an account\n     * @param account The address to check\n     * @param id The token ID to check\n     * @return Array of Group structs, with amount and expiration of each batch\n     */\n    function balanceDetailsOf(address account, uint256 id) external view returns (Group[] memory) {\n        return _validGroups(account, id);\n    }\n\n    /**\n     * @dev Get expiration details of token holdings for all tokens of an account\n     * @param account The address to check\n     * @return Array of Group arrays, with amount and expiration of each batch for each token ID\n     */\n    function balanceDetailsOfAll(address account) external view returns (Group[][] memory) {\n        Group[][] memory result = new Group[][](nextTokenId);\n        for (uint256 i = 0; i < nextTokenId; i++) {\n            result[i] = _validGroups(account, i);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Get expiration details of token holdings for multiple accounts\n     * @param accounts Array of addresses to check\n     * @param ids Array of token IDs to check\n     * @return result Array of Group arrays, with amount and expiration of each batch for each account\n     */\n    function balanceDetailsOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (Group[][] memory result)\n    {\n        require(accounts.length == ids.length, \"Length mismatch\");\n        result = new Group[][](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            result[i] = _validGroups(accounts[i], ids[i]);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Adjust the token group balances in first-in-first-out (FIFO) order (earliest expiration first)\n     * @param account The address of the account\n     * @param id The ID of the token\n     * @param amount The amount of tokens to burn\n     */\n    function _burnGroupBalances(address account, uint256 id, uint256 amount) internal {\n        Group[] storage groups = _group[account][id];\n        uint256 _now = block.timestamp;\n        uint256 debt = amount;\n\n        uint256 i = 0;\n        while (i < groups.length && debt > 0) {\n            if (groups[i].expiresAt <= _now) {\n                i++;\n                continue;\n            }\n\n            if (groups[i].balance > debt) {\n                // Burn partial token group\n                groups[i].balance -= debt;\n                debt = 0;\n            } else {\n                // Burn entire token group\n                debt -= groups[i].balance;\n                groups[i].balance = 0;\n            }\n            i++;\n        }\n    }\n\n    /**\n     * @dev Generate the expiration timestamp for a token ID\n     * @param id The ID of the token\n     * @return The expiration timestamp (in seconds) for the token\n     */\n    function expirationFor(uint256 id) public view returns (uint256) {\n        return ttlOf(id) == 0 ? type(uint256).max : block.timestamp + ttlOf(id);\n    }\n\n    /**\n     * @dev Delete token groups that are expired or have no balance\n     * @param account The address whose token groups need pruning\n     * @param id The ID of the token\n     */\n    function _pruneGroups(address account, uint256 id) internal {\n        Group[] storage groups = _group[account][id];\n        uint256 _now = block.timestamp;\n\n        // Shift valid groups to the front of the array\n        uint256 index = 0;\n        uint256 expiredAmount = 0;\n        for (uint256 i = 0; i < groups.length; i++) {\n            bool isValid = groups[i].balance > 0 && groups[i].expiresAt > _now;\n            if (isValid) {\n                if (i != index) {\n                    groups[index] = groups[i];\n                }\n                index++;\n            } else {\n                expiredAmount += groups[i].balance;\n            }\n        }\n\n        // Remove invalid groups from the end of the array\n        while (groups.length > index) {\n            groups.pop();\n        }\n\n        // If any expired groups were removed, emit an event with the total amount of expired tokens\n        if (expiredAmount > 0) {\n            emit ExpiredTokensBurned(account, id, expiredAmount);\n        }\n    }\n\n    /**\n     * @dev Transfer token groups from one account to another\n     * @param from The source address\n     * @param to The destination address\n     * @param id The ID of the token\n     * @param amount The amount of tokens to transfer\n     */\n    function _transferGroups(address from, address to, uint256 id, uint256 amount) internal {\n        // Exit early if the transfer is to the same account or if the amount is zero\n        if (from == to || amount == 0) return;\n\n        Group[] storage groups = _group[from][id];\n        uint256 _now = block.timestamp;\n        uint256 debt = amount;\n\n        // First pass: Reduce balances from sender's groups (FIFO order)\n        for (uint256 i = 0; i < groups.length && debt > 0; i++) {\n            // Skip token groups that are expired or have no balance\n            if (groups[i].expiresAt <= _now || groups[i].balance == 0) {\n                continue;\n            }\n\n            if (groups[i].balance > debt) {\n                // Transfer partial token group\n                _upsertGroup(to, id, debt, groups[i].expiresAt);\n                groups[i].balance -= debt;\n                debt = 0;\n            } else {\n                // Transfer entire token group\n                _upsertGroup(to, id, groups[i].balance, groups[i].expiresAt);\n                debt -= groups[i].balance;\n                groups[i].balance = 0;\n            }\n        }\n\n        // Clean up from account token groups that are expired or have zero balance\n        _pruneGroups(from, id);\n    }\n\n    /**\n     * @dev Set the time-to-live (TTL) for a token\n     * @param id The ID of the token\n     * @param value The TTL (in seconds) for the token; set to 0 (default) for perpetual tokens\n     */\n    function setTTL(uint256 id, uint256 value) public {\n        require(hasRole(TOKEN_MANAGER_ROLE, _msgSender()), \"Unauthorized token manager\");\n        require(burnable(id), \"Token is not burnable, so it cannot expire\");\n        _ttls[id] = value;\n    }\n\n    /**\n     * @dev Get the time-to-live (TTL) for a token\n     * @param id The ID of the token\n     * @return The TTL (in seconds) for the token\n     */\n    function ttlOf(uint256 id) public view returns (uint256) {\n        return _ttls[id];\n    }\n\n    /**\n     * @dev Get the time-to-live (TTL) for all tokens\n     * @return result The TTL (in seconds) for each token\n     */\n    function ttlOfAll() public view returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](nextTokenId);\n        for (uint256 i = 0; i < nextTokenId; i++) {\n            result[i] = _ttls[i];\n        }\n        return result;\n    }\n\n    /**\n     * @dev Get the time-to-live (TTL) for a batch of tokens\n     * @param ids The IDs of the tokens\n     * @return result The TTL (in seconds) for each token in the batch\n     */\n    function ttlOfBatch(uint256[] memory ids) public view returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            result[i] = _ttls[ids[i]];\n        }\n        return result;\n    }\n\n    /**\n     * @dev Override to update token expiration data on mint, burn, and transfer\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values)\n        internal\n        virtual\n        override\n    {\n        super._update(from, to, ids, values);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 _id = ids[i];\n            uint256 _amount = values[i];\n\n            // Minting\n            if (from == address(0)) {\n                address _account = to;\n                uint256 _expiresAt = expirationFor(_id);\n                _upsertGroup(_account, _id, _amount, _expiresAt);\n            }\n            // Burning\n            else if (to == address(0)) {\n                address _account = to;\n                _burnGroupBalances(_account, _id, _amount);\n                _pruneGroups(_account, _id);\n            }\n            // Transferring\n            else {\n                _transferGroups(from, to, _id, _amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Insert (or update) a token group for a given account and token ID\n     * @param account The address of the account\n     * @param id The ID of the token\n     * @param amount The amount of tokens in the batch\n     * @param expiresAt The expiration timestamp of the batch\n     */\n    function _upsertGroup(address account, uint256 id, uint256 amount, uint256 expiresAt) internal {\n        Group[] storage groups = _group[account][id];\n\n        // Find the correct position to insert the group (ordered by expiration, oldest to newest)\n        uint256 insertIndex = groups.length;\n        for (uint256 i = 0; i < groups.length; i++) {\n            // Check if this is an insert or an update\n            if (groups[i].expiresAt > expiresAt) {\n                // Insert the new token group at this position\n                insertIndex = i;\n                break;\n            } else if (groups[i].expiresAt == expiresAt) {\n                // If a token group with same expiration exists, combine the balances and return\n                groups[i].balance += amount;\n                return;\n            }\n        }\n\n        // If the new token group expires later than all the others, add it to the end of the array and return\n        if (insertIndex == groups.length) {\n            groups.push(Group({balance: amount, expiresAt: expiresAt}));\n            return;\n        }\n\n        // Shift array elements to make room for the new token group\n        groups.push(Group({balance: 0, expiresAt: 0})); // Add space at the end\n        for (uint256 i = groups.length - 1; i > insertIndex; i--) {\n            groups[i] = groups[i - 1];\n        }\n\n        // Insert the new Group at the correct position\n        groups[insertIndex] = Group({balance: amount, expiresAt: expiresAt});\n    }\n\n    /**\n     * @dev Get a filtered array of token groups for a given account and token ID, without expired or empty groups\n     * @param account The address to check\n     * @param id The token ID to check\n     * @return Array of Group structs, with amount and expiration of each batch\n     */\n    function _validGroups(address account, uint256 id) internal view returns (Group[] memory) {\n        // First, check if the account has any tokens\n        uint256 balance = super.balanceOf(account, id);\n        if (balance == 0) {\n            // Return an empty array\n            return new Group[](0);\n        }\n\n        Group[] storage groups = _group[account][id];\n        uint256 _now = block.timestamp;\n\n        // Count the groups that are not expired and have a balance\n        uint256 validBatchCount = 0;\n        for (uint256 i = 0; i < groups.length; i++) {\n            if (groups[i].expiresAt > _now && groups[i].balance > 0) {\n                validBatchCount++;\n            }\n        }\n\n        // Create a new array of the correct size for valid groups\n        Group[] memory details = new Group[](validBatchCount);\n        uint256 index = 0;\n\n        // Fill the array with valid groups, in the correct order (earliest expiration first)\n        for (uint256 i = 0; i < groups.length; i++) {\n            if (groups[i].expiresAt > _now && groups[i].balance > 0) {\n                details[index] = groups[i];\n                index++;\n            }\n        }\n\n        return details;\n    }\n}\n"
    }
}