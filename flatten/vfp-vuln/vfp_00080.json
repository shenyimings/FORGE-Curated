{
    "vfp_id": "vfp_00080",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-649"
                ]
            },
            "title": "Solvers may receive less gas than they expect",
            "description": "1. **Description:** In Atlas v1.6, the gas limit forwarded to solvers is set to the minimum of solverOp.gas and dConfig.solverGasLimit. This change introduces a risk where solvers may receive less gas than expected if dConfig.solverGasLimit is lowered after the solver signs the operation.\n2. **Cause:** The userOp hash does not include dConfig.solverGasLimit, so changes to this value after signing are not reflected in the solver's expectations.\n3. **Exploitation:** A malicious DAppControl could intentionally lower dConfig.solverGasLimit after a solver has signed, causing the solver to receive less gas than required for execution.\n4. **Impact:** Solvers may fail to execute their operations due to insufficient gas, leading to financial loss or operational disruption.\n",
            "severity": "Medium",
            "location": [
                "Escrow.sol#L367-L368"
            ],
            "files": [
                "atlas/src/contracts/atlas/Escrow.sol"
            ]
        }
    ],
    "affected_files": {
        "Escrow.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { SafeCast } from \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport { AtlETH } from \"./AtlETH.sol\";\nimport { IExecutionEnvironment } from \"../interfaces/IExecutionEnvironment.sol\";\nimport { IAtlas } from \"../interfaces/IAtlas.sol\";\nimport { ISolverContract } from \"../interfaces/ISolverContract.sol\";\nimport { IAtlasVerification } from \"../interfaces/IAtlasVerification.sol\";\nimport { IDAppControl } from \"../interfaces/IDAppControl.sol\";\n\nimport { SafeCall } from \"../libraries/SafeCall/SafeCall.sol\";\nimport { EscrowBits } from \"../libraries/EscrowBits.sol\";\nimport { CallBits } from \"../libraries/CallBits.sol\";\nimport { SafetyBits } from \"../libraries/SafetyBits.sol\";\nimport { AccountingMath } from \"../libraries/AccountingMath.sol\";\nimport { GasAccLib, GasLedger } from \"../libraries/GasAccLib.sol\";\nimport { DAppConfig } from \"../types/ConfigTypes.sol\";\nimport \"../types/SolverOperation.sol\";\nimport \"../types/UserOperation.sol\";\nimport \"../types/EscrowTypes.sol\";\nimport \"../types/LockTypes.sol\";\n\n/// @title Escrow\n/// @author FastLane Labs\n/// @notice This Escrow component of Atlas handles execution of stages by calling corresponding functions on the\n/// Execution Environment contract.\nabstract contract Escrow is AtlETH {\n    using EscrowBits for uint256;\n    using CallBits for uint32;\n    using SafetyBits for Context;\n    using SafeCall for address;\n    using SafeCast for uint256;\n    using AccountingMath for uint256;\n    using GasAccLib for uint256;\n    using GasAccLib for GasLedger;\n\n    constructor(\n        uint256 escrowDuration,\n        uint256 atlasSurchargeRate,\n        address verification,\n        address simulator,\n        address initialSurchargeRecipient,\n        address l2GasCalculator\n    )\n        AtlETH(escrowDuration, atlasSurchargeRate, verification, simulator, initialSurchargeRecipient, l2GasCalculator)\n    {\n        if (escrowDuration == 0) revert InvalidEscrowDuration();\n    }\n\n    /// @notice Executes the preOps logic defined in the Execution Environment.\n    /// @param ctx Metacall context data from the Context struct.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @return preOpsData The data returned by the preOps call, if successful.\n    function _executePreOpsCall(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp\n    )\n        internal\n        withLockPhase(ExecutionPhase.PreOps)\n        returns (bytes memory)\n    {\n        uint256 _dappGasWaterMark = gasleft();\n\n        (bool _success, bytes memory _data) = ctx.executionEnvironment.call{ gas: ctx.dappGasLeft }(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.preOpsWrapper, userOp), ctx.setAndPack(ExecutionPhase.PreOps)\n            )\n        );\n\n        _updateDAppGasLeft(ctx, _dappGasWaterMark);\n\n        if (_success) {\n            if (dConfig.callConfig.needsPreOpsReturnData()) {\n                return abi.decode(_data, (bytes));\n            } else {\n                return new bytes(0);\n            }\n        }\n\n        if (ctx.isSimulation) revert PreOpsSimFail();\n        revert PreOpsFail();\n    }\n\n    /// @notice Executes the user operation logic defined in the Execution Environment.\n    /// @param ctx Metacall context data from the Context struct.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct containing the user's transaction data.\n    /// @param returnData Data returned from previous call phases.\n    /// @return userData Data returned from executing the UserOperation, if the call was successful.\n    function _executeUserOperation(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        bytes memory returnData\n    )\n        internal\n        withLockPhase(ExecutionPhase.UserOperation)\n        returns (bytes memory)\n    {\n        bool _success;\n        bytes memory _data;\n\n        if (!_borrow(userOp.value)) {\n            revert InsufficientEscrow();\n        }\n\n        (_success, _data) = ctx.executionEnvironment.call{ value: userOp.value, gas: userOp.gas }(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.userWrapper, userOp), ctx.setAndPack(ExecutionPhase.UserOperation)\n            )\n        );\n\n        if (_success) {\n            // Handle formatting of returnData\n            if (dConfig.callConfig.needsUserReturnData()) {\n                return abi.decode(_data, (bytes));\n            } else {\n                return returnData;\n            }\n        }\n\n        // revert for failed\n        if (ctx.isSimulation) revert UserOpSimFail();\n        revert UserOpFail();\n    }\n\n    /// @notice Checks if the trusted operation hash matches and sets the appropriate error bit if it doesn't.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param prevalidated Boolean flag indicating whether the SolverOperation has been prevalidated to skip certain\n    /// checks.\n    /// @param userOp UserOperation struct containing the user's transaction data relevant to this SolverOperation.\n    /// @param solverOp SolverOperation struct containing the solver's bid and execution data.\n    /// @param result The current result bitmask that tracks the status of various checks and validations.\n    /// @return The updated result bitmask with the AltOpHashMismatch bit set if the operation hash does not match.\n    function _checkTrustedOpHash(\n        DAppConfig memory dConfig,\n        bool prevalidated,\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp,\n        uint256 result\n    )\n        internal\n        returns (uint256)\n    {\n        if (dConfig.callConfig.allowsTrustedOpHash() && !prevalidated && !_handleAltOpHash(userOp, solverOp)) {\n            result |= 1 << uint256(SolverOutcome.AltOpHashMismatch);\n        }\n        return result;\n    }\n\n    /// @notice Attempts to execute a SolverOperation and determine if it wins the auction.\n    /// @param ctx Context struct containing the current state of the escrow lock.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct containing the user's transaction data relevant to this SolverOperation.\n    /// @param solverOp SolverOperation struct containing the solver's bid and execution data.\n    /// @param bidAmount The amount of bid submitted by the solver for this operation.\n    /// @param gasWaterMark The gas left at the start of the current solverOp's execution, to be used to charge/write\n    /// off solverOp gas.\n    /// @param prevalidated Boolean flag indicating if the solverOp has been prevalidated in bidFind (exPostBids).\n    /// @param returnData Data returned from UserOp execution, used as input if necessary.\n    /// @return bidAmount The determined bid amount for the SolverOperation if all validations pass and the operation is\n    /// executed successfully; otherwise, returns 0.\n    function _executeSolverOperation(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp,\n        uint256 bidAmount,\n        uint256 gasWaterMark,\n        bool prevalidated,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256)\n    {\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n        uint256 _result;\n\n        // Decrease unreachedSolverGas and reset maxApprovedGasSpend at the start of each solverOp\n        _adjustGasLedgerAtSolverOpStart(_gL, dConfig, solverOp);\n        t_gasLedger = _gL.pack(); // Persist changes to transient storage\n\n        if (!prevalidated) {\n            _result = VERIFICATION.verifySolverOp(\n                solverOp, ctx.userOpHash, userOp.maxFeePerGas, ctx.bundler, dConfig.callConfig.allowsTrustedOpHash()\n            );\n            _result = _checkSolverBidToken(solverOp.bidToken, dConfig.bidToken, _result);\n        }\n\n        // Verify the transaction.\n        if (_result.canExecute()) {\n            uint256 _gasLimit;\n            // Verify gasLimit again\n            (_result, _gasLimit) = _validateSolverOpGasAndValue(_gL, dConfig, solverOp, gasWaterMark, _result);\n            _result |= _validateSolverOpDeadline(solverOp, dConfig);\n\n            // Check for trusted operation hash\n            _result = _checkTrustedOpHash(dConfig, prevalidated, userOp, solverOp, _result);\n\n            // If there are no errors, attempt to execute\n            if (_result.canExecute()) {\n                SolverTracker memory _solverTracker;\n\n                // Execute the solver call\n                (_result, _solverTracker) = _solverOpWrapper(ctx, solverOp, bidAmount, _gasLimit, returnData);\n\n                // First successful solver call that paid what it bid\n                if (_result.executionSuccessful()) {\n                    // Logic done above `_handleSolverFailAccounting()` is to charge solver for gas used here\n                    ctx.solverOutcome = uint24(_result);\n\n                    emit SolverTxResult(\n                        solverOp.solver,\n                        solverOp.from,\n                        dConfig.to,\n                        solverOp.bidToken,\n                        _solverTracker.bidAmount,\n                        true,\n                        true,\n                        _result\n                    );\n\n                    // Keep executing solvers without ending the auction if multipleSuccessfulSolvers is set\n                    if (dConfig.callConfig.multipleSuccessfulSolvers()) {\n                        // multipleSuccessfulSolvers mode:\n                        // - `ctx.solverSuccessful` is implicitly left as false\n                        // - `_result` should be 0 (successful) below, which should charge the solver for their own\n                        //   gas + surcharges, as 0 is not captured in the bundler fault block.\n                        // - exPostBids is not supported in multipleSuccessfulSolvers mode, so exPostBids = false here.\n                        _handleSolverFailAccounting(solverOp, dConfig.solverGasLimit, gasWaterMark, _result, false);\n                    } else {\n                        // If not in multipleSuccessfulSolvers mode, end the auction with the first successful solver\n                        // that paid what it bid.\n                        // We intentionally do not change GasLedger here as we have found a winning solver and don't\n                        // need it anymore\n                        ctx.solverSuccessful = true;\n                    }\n\n                    return _solverTracker.bidAmount;\n                }\n            }\n        }\n\n        // If we reach this point, the solver call did not execute successfully.\n        ctx.solverOutcome = uint24(_result);\n\n        emit SolverTxResult(\n            solverOp.solver,\n            solverOp.from,\n            dConfig.to,\n            solverOp.bidToken,\n            bidAmount,\n            _result.executedWithError(),\n            false,\n            _result\n        );\n\n        // Account for failed SolverOperation gas costs\n        _handleSolverFailAccounting(\n            solverOp, dConfig.solverGasLimit, gasWaterMark, _result, dConfig.callConfig.exPostBids()\n        );\n\n        return 0;\n    }\n\n    /// @notice Allocates the winning bid amount after a successful SolverOperation execution.\n    /// @dev This function handles the allocation of the bid amount to the appropriate recipients as defined in the\n    /// DApp's configuration. It calls the allocateValue function in the Execution Environment, which is responsible for\n    /// distributing the bid amount. Note that balance discrepancies leading to payment failures are typically due to\n    /// issues in the DAppControl contract, not the execution environment itself.\n    /// @param ctx Context struct containing the current state of the escrow lock.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param bidAmount The winning solver's bid amount, to be allocated.\n    /// @param returnData Data returned from the execution of the UserOperation, which may influence how the bid amount\n    /// is allocated.\n    function _allocateValue(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        uint256 bidAmount,\n        bytes memory returnData\n    )\n        internal\n        withLockPhase(ExecutionPhase.AllocateValue)\n    {\n        uint256 _dappGasWaterMark = gasleft();\n\n        (bool _success,) = ctx.executionEnvironment.call{ gas: ctx.dappGasLeft }(\n            abi.encodePacked(\n                abi.encodeCall(\n                    IExecutionEnvironment.allocateValue, (ctx.solverSuccessful, dConfig.bidToken, bidAmount, returnData)\n                ),\n                ctx.setAndPack(ExecutionPhase.AllocateValue)\n            )\n        );\n\n        _updateDAppGasLeft(ctx, _dappGasWaterMark);\n\n        // Revert if allocateValue failed at any point.\n        if (!_success) {\n            if (ctx.isSimulation) revert AllocateValueSimFail();\n            revert AllocateValueFail();\n        }\n    }\n\n    /// @notice Adjusts the gas ledger before evaluating a SolverOperation.\n    /// @dev Updates the in-memory `gL` by decreasing `unreachedSolverGas` based on the current solverOp's max potential\n    /// gas (execution + calldata if not exPostBids) and resets `maxApprovedGasSpend` to 0. Caller must persist `gL`\n    /// changes to transient storage separately.\n    /// @param gL The GasLedger struct (in memory) to modify.\n    /// @param dConfig DApp configuration containing `solverGasLimit` and `callConfig`.\n    /// @param solverOp The SolverOperation being evaluated.\n    function _adjustGasLedgerAtSolverOpStart(\n        GasLedger memory gL,\n        DAppConfig memory dConfig,\n        SolverOperation calldata solverOp\n    )\n        internal\n        view\n    {\n        // Decrease unreachedSolverGas by the current solverOp's (C + E) max gas\n        uint256 _calldataGas;\n\n        // Solver's execution gas is solverOp.gas with a max of dConfig.solverGasLimit\n        uint256 _executionGas = (solverOp.gas > dConfig.solverGasLimit) ? dConfig.solverGasLimit : solverOp.gas;\n\n        // Calldata gas is only included if NOT in exPostBids mode.\n        if (!dConfig.callConfig.exPostBids()) {\n            _calldataGas = GasAccLib.solverOpCalldataGas(solverOp.data.length, L2_GAS_CALCULATOR);\n        }\n\n        // Reset solver's max approved gas spend to 0 at start of each new solver execution\n        gL.maxApprovedGasSpend = 0;\n        gL.unreachedSolverGas -= (_executionGas + _calldataGas).toUint40();\n\n        // NOTE: GasLedger changes must be persisted to transient storage separately after this function call\n    }\n\n    /// @notice Validates a SolverOperation's gas requirements against the escrow state.\n    /// @dev Performs a series of checks to ensure that a SolverOperation can be executed within the defined parameters\n    /// and limits. This includes verifying that the operation is within the gas limit and that the solver has\n    /// sufficient balance in escrow to cover the gas costs.\n    /// @param gL The GasLedger memory struct containing the current gas accounting state.\n    /// @param dConfig DApp configuration data, including solver gas limits and operation parameters.\n    /// @param solverOp The SolverOperation being validated.\n    /// @param gasWaterMark The initial gas measurement before validation begins, used to ensure enough gas remains for\n    /// validation logic.\n    /// @param result The current result bitmap, which will be updated with the outcome of the gas validation checks.\n    /// @return result Updated result flags after performing the validation checks, including any new errors\n    /// encountered.\n    /// @return gasLimit The calculated gas limit for the SolverOperation, considering the operation's gas usage and\n    /// the protocol's gas buffers.\n    function _validateSolverOpGasAndValue(\n        GasLedger memory gL,\n        DAppConfig memory dConfig,\n        SolverOperation calldata solverOp,\n        uint256 gasWaterMark,\n        uint256 result\n    )\n        internal\n        view\n        returns (uint256, uint256 gasLimit)\n    {\n        // gasLimit is solverOp.gas, with a max of dConfig.solverGasLimit\n        gasLimit = (solverOp.gas > dConfig.solverGasLimit) ? dConfig.solverGasLimit : solverOp.gas;\n\n        if (gasWaterMark < _VALIDATION_GAS_LIMIT + gasLimit) {\n            // Make sure to leave enough gas for dApp validation calls\n            result |= 1 << uint256(SolverOutcome.UserOutOfGas);\n            return (result, gasLimit);\n        }\n\n        // Verify that we can lend the solver their tx value\n        if (solverOp.value > address(this).balance) {\n            result |= 1 << uint256(SolverOutcome.CallValueTooHigh);\n            return (result, gasLimit);\n        }\n\n        uint256 _solverBalance = S_accessData[solverOp.from].bonded;\n\n        // Checks if solver's bonded balance is enough to cover the max charge should they win, including surcharges\n        if (_solverBalance < gL.solverGasLiability()) {\n            result |= 1 << uint256(SolverOutcome.InsufficientEscrow);\n        }\n\n        return (result, gasLimit);\n    }\n\n    /// @notice Validates a SolverOperation's deadline against the current block.\n    /// @param solverOp The SolverOperation being validated.\n    /// @param dConfig DApp configuration data, including solver gas limits and operation parameters.\n    /// @return result Updated result flags after performing the validation checks, including any new errors\n    function _validateSolverOpDeadline(\n        SolverOperation calldata solverOp,\n        DAppConfig memory dConfig\n    )\n        internal\n        view\n        returns (uint256 result)\n    {\n        if (solverOp.deadline != 0 && block.number > solverOp.deadline) {\n            result |= (\n                1\n                    << uint256(\n                        dConfig.callConfig.allowsTrustedOpHash()\n                            ? uint256(SolverOutcome.DeadlinePassedAlt)\n                            : uint256(SolverOutcome.DeadlinePassed)\n                    )\n            );\n            return result;\n        }\n\n        uint256 lastAccessedBlock = S_accessData[solverOp.from].lastAccessedBlock;\n\n        if (lastAccessedBlock >= block.number) {\n            result |= 1 << uint256(SolverOutcome.PerBlockLimit);\n        }\n    }\n\n    /// @notice Determines the bid amount for a SolverOperation based on verification and validation results.\n    /// @dev This function assesses whether a SolverOperation meets the criteria for execution by verifying it against\n    /// the Atlas protocol's rules and the current Context lock state. It checks for valid execution based on the\n    /// SolverOperation's specifics, like gas usage and deadlines. The function aims to protect against malicious\n    /// bundlers by ensuring solvers are not unfairly charged for on-chain bid finding gas usage. If the operation\n    /// passes verification and validation, and if it's eligible for bid amount determination, the function\n    /// attempts to execute and determine the bid amount.\n    /// @param ctx The Context struct containing the current state of the escrow lock.\n    /// @param dConfig The DApp configuration data, including parameters relevant to solver bid validation.\n    /// @param userOp The UserOperation associated with this SolverOperation, providing context for the bid amount\n    /// determination.\n    /// @param solverOp The SolverOperation being assessed, containing the solver's bid amount.\n    /// @param returnData Data returned from the execution of the UserOp call.\n    /// @return bidAmount The determined bid amount for the SolverOperation if all validations pass and the operation is\n    /// executed successfully; otherwise, returns 0.\n    function _getBidAmount(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256 bidAmount)\n    {\n        // NOTE: To prevent a malicious bundler from aggressively collecting storage refunds,\n        // solvers should not be on the hook for any 'onchain bid finding' gas usage.\n\n        uint256 _gasWaterMark = gasleft();\n        uint256 _gasLimit;\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n\n        // Decrease unreachedSolverGas and reset maxApprovedGasSpend at the start of each solverOp\n        _adjustGasLedgerAtSolverOpStart(_gL, dConfig, solverOp);\n        t_gasLedger = _gL.pack(); // Persist changes to transient storage\n\n        uint256 _result = VERIFICATION.verifySolverOp(\n            solverOp, ctx.userOpHash, userOp.maxFeePerGas, ctx.bundler, dConfig.callConfig.allowsTrustedOpHash()\n        );\n\n        _result = _checkSolverBidToken(solverOp.bidToken, dConfig.bidToken, _result);\n        (_result, _gasLimit) = _validateSolverOpGasAndValue(_gL, dConfig, solverOp, _gasWaterMark, _result);\n        _result |= _validateSolverOpDeadline(solverOp, dConfig);\n\n        // Verify the transaction.\n        if (!_result.canExecute()) return 0;\n\n        if (dConfig.callConfig.allowsTrustedOpHash()) {\n            if (!_handleAltOpHash(userOp, solverOp)) {\n                return (0);\n            }\n        }\n\n        (bool _success, bytes memory _data) = address(this).call{ gas: _gasLimit }(\n            abi.encodeCall(this.solverCall, (ctx, solverOp, solverOp.bidAmount, returnData))\n        );\n\n        // The `solverCall()` above should always revert as key.bidFind is always true when it's called in the context\n        // of this function. Therefore `success` should always be false below, and the revert should be unreachable.\n        if (_success) {\n            revert Unreachable();\n        }\n\n        if (bytes4(_data) == BidFindSuccessful.selector) {\n            // Get the uint256 from the memory array\n            assembly {\n                let dataLocation := add(_data, 0x20)\n                bidAmount := mload(add(dataLocation, sub(mload(_data), 32)))\n            }\n            return bidAmount;\n        }\n\n        return 0;\n    }\n\n    /// @notice Validates UserOp hashes provided by the SolverOperation, using the alternative set of hashed parameters.\n    /// @param userOp The UserOperation struct, providing the baseline parameters for comparison.\n    /// @param solverOp The SolverOperation struct being validated against the UserOperation.\n    /// @return A boolean value indicating whether the SolverOperation passed the alternative hash check, with `true`\n    /// meaning it is considered valid\n    function _handleAltOpHash(\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp\n    )\n        internal\n        returns (bool)\n    {\n        // These failures should be attributed to bundler maliciousness\n        if (userOp.control != solverOp.control) {\n            return false;\n        }\n        if (!(userOp.deadline == 0 || solverOp.deadline == 0 || solverOp.deadline == userOp.deadline)) {\n            return false;\n        }\n        bytes32 _hashId = keccak256(abi.encodePacked(solverOp.userOpHash, solverOp.from, solverOp.deadline));\n        if (S_solverOpHashes[_hashId]) {\n            return false;\n        }\n        S_solverOpHashes[_hashId] = true;\n        return true;\n    }\n\n    /// @notice Checks if the solver's bid token matches the dApp's bid token.\n    /// @param solverBidToken The solver's bid token address.\n    /// @param dConfigBidToken The dApp's bid token address.\n    /// @param result The current result bitmap, which will be updated with the outcome of the bid token check.\n    /// @return The updated result bitmap, with the SolverOutcome.InvalidBidToken flag set if the bid token check fails.\n    function _checkSolverBidToken(\n        address solverBidToken,\n        address dConfigBidToken,\n        uint256 result\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (solverBidToken != dConfigBidToken) {\n            return result | 1 << uint256(SolverOutcome.InvalidBidToken);\n        }\n        return result;\n    }\n\n    /// @notice Wraps the execution of a SolverOperation and handles potential errors.\n    /// @param ctx The current lock data.\n    /// @param solverOp The SolverOperation struct containing the operation's execution data.\n    /// @param bidAmount The bid amount associated with the SolverOperation.\n    /// @param gasLimit The gas limit for executing the SolverOperation, calculated based on the operation's\n    /// requirements and protocol buffers.\n    /// @param returnData Data returned from the execution of the associated UserOperation, which may be required\n    /// for the SolverOperation's logic.\n    /// @return result SolverOutcome enum value encoded as a uint256 bitmap, representing the result of the\n    /// SolverOperation\n    /// @return solverTracker Tracking data for the solver's bid\n    function _solverOpWrapper(\n        Context memory ctx,\n        SolverOperation calldata solverOp,\n        uint256 bidAmount,\n        uint256 gasLimit,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256 result, SolverTracker memory solverTracker)\n    {\n        // Calls the solverCall function, just below this function, which will handle calling solverPreTryCatch and\n        // solverPostTryCatch via the ExecutionEnvironment, and in between those two hooks, the actual solver call\n        // directly from Atlas to the solver contract (not via the ExecutionEnvironment).\n        (bool _success, bytes memory _data) =\n            address(this).call{ gas: gasLimit }(abi.encodeCall(this.solverCall, (ctx, solverOp, bidAmount, returnData)));\n\n        if (_success) {\n            // If solverCall() was successful, intentionally leave uint256 result unset as 0 indicates success.\n            solverTracker = abi.decode(_data, (SolverTracker));\n        } else {\n            // If solverCall() failed, catch the error and encode the failure case in the result uint accordingly.\n            bytes4 _errorSwitch = bytes4(_data);\n            if (_errorSwitch == AlteredControl.selector) {\n                result = 1 << uint256(SolverOutcome.AlteredControl);\n            } else if (_errorSwitch == InsufficientEscrow.selector) {\n                result = 1 << uint256(SolverOutcome.InsufficientEscrow);\n            } else if (_errorSwitch == PreSolverFailed.selector) {\n                result = 1 << uint256(SolverOutcome.PreSolverFailed);\n            } else if (_errorSwitch == SolverOpReverted.selector) {\n                result = 1 << uint256(SolverOutcome.SolverOpReverted);\n            } else if (_errorSwitch == PostSolverFailed.selector) {\n                result = 1 << uint256(SolverOutcome.PostSolverFailed);\n            } else if (_errorSwitch == BidNotPaid.selector) {\n                result = 1 << uint256(SolverOutcome.BidNotPaid);\n            } else if (_errorSwitch == InvalidSolver.selector) {\n                result = 1 << uint256(SolverOutcome.InvalidSolver);\n            } else if (_errorSwitch == BalanceNotReconciled.selector) {\n                result = 1 << uint256(SolverOutcome.BalanceNotReconciled);\n            } else if (_errorSwitch == CallbackNotCalled.selector) {\n                result = 1 << uint256(SolverOutcome.CallbackNotCalled);\n            } else if (_errorSwitch == InvalidEntry.selector) {\n                // DAppControl is attacking solver contract - treat as AlteredControl\n                result = 1 << uint256(SolverOutcome.AlteredControl);\n            } else {\n                result = 1 << uint256(SolverOutcome.EVMError);\n            }\n        }\n    }\n\n    /// @notice Executes the SolverOperation logic, including preSolver and postSolver hooks via the Execution\n    /// Environment, as well as the actual solver call directly from Atlas to the solver contract.\n    /// @param ctx The Context struct containing lock data and the Execution Environment address.\n    /// @param solverOp The SolverOperation to be executed.\n    /// @param bidAmount The bid amount associated with the SolverOperation.\n    /// @param returnData Data returned from previous call phases.\n    /// @return solverTracker Additional data for handling the solver's bid in different scenarios.\n    function solverCall(\n        Context memory ctx,\n        SolverOperation calldata solverOp,\n        uint256 bidAmount,\n        bytes calldata returnData\n    )\n        external\n        payable\n        returns (SolverTracker memory solverTracker)\n    {\n        if (msg.sender != address(this)) revert InvalidEntry();\n\n        bytes memory _data;\n        bool _success;\n\n        // Set the solver lock and solver address at the beginning to ensure reliability\n        t_solverLock = uint256(uint160(solverOp.from));\n        t_solverTo = solverOp.solver;\n\n        // ------------------------------------- //\n        //             Pre-Solver Call           //\n        // ------------------------------------- //\n\n        _setLockPhase(uint8(ExecutionPhase.PreSolver));\n\n        (_success, _data) = ctx.executionEnvironment.call(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.solverPreTryCatch, (bidAmount, solverOp, returnData)),\n                ctx.setAndPack(ExecutionPhase.PreSolver)\n            )\n        );\n\n        // If ExecutionEnvironment.solverPreTryCatch() failed, bubble up the error\n        if (!_success) {\n            assembly {\n                revert(add(_data, 32), mload(_data))\n            }\n        }\n\n        // Update solverTracker with returned data\n        solverTracker = abi.decode(_data, (SolverTracker));\n\n        // ------------------------------------- //\n        //              Solver Call              //\n        // ------------------------------------- //\n\n        _setLockPhase(uint8(ExecutionPhase.SolverOperation));\n\n        // Make sure there's enough value in Atlas for the Solver\n        if (!_borrow(solverOp.value)) revert InsufficientEscrow();\n\n        // Load callConfig from transient storage once here, to be used below.\n        uint32 _callConfig = _activeCallConfig();\n\n        // NOTE: The solver's bidAmount is always sent to their solver contract during the solver call. In exPostBids\n        // mode, it is possible for a solver to encode some infomation calculated during the bid-finding process, which\n        // the bundler pays for as that gas cost is written off, in the least significant bits of their bidAmount. This\n        // information can be used to minimize the gas cost a solver is charged for during real execution. This is seen\n        // as a feature, because the decrease in gas cost paid by the solver should result in a higher bid they are able\n        // to make - a better outcome for the bid recipient.\n\n        // Optimism's SafeCall lib allows us to limit how much returndata gets copied to memory, to prevent OOG attacks.\n        _success = solverOp.solver.safeCall(\n            gasleft(),\n            solverOp.value,\n            abi.encodeCall(\n                ISolverContract.atlasSolverCall,\n                (\n                    solverOp.from,\n                    ctx.executionEnvironment,\n                    solverOp.bidToken,\n                    bidAmount,\n                    solverOp.data,\n                    // Only pass the returnData (either from userOp or preOps) if the dApp requires it\n                    _callConfig.forwardReturnData() ? returnData : new bytes(0)\n                )\n            )\n        );\n\n        if (!_success) revert SolverOpReverted();\n\n        // ------------------------------------- //\n        //            Post-Solver Call           //\n        // ------------------------------------- //\n\n        _setLockPhase(uint8(ExecutionPhase.PostSolver));\n\n        (_success, _data) = ctx.executionEnvironment.call(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.solverPostTryCatch, (solverOp, returnData, solverTracker)),\n                ctx.setAndPack(ExecutionPhase.PostSolver)\n            )\n        );\n\n        // If ExecutionEnvironment.solverPostTryCatch() failed, bubble up the error\n        if (!_success) {\n            assembly {\n                revert(add(_data, 32), mload(_data))\n            }\n        }\n\n        // Update solverTracker with returned data\n        solverTracker = abi.decode(_data, (SolverTracker));\n\n        // ------------------------------------- //\n        //              Final Checks             //\n        // ------------------------------------- //\n\n        // Verify that the solver repaid their borrowed solverOp.value by calling `reconcile()`. If `reconcile()` did\n        // not fully repay the borrowed amount, the `postSolverCall` might have covered the outstanding debt via\n        // `contribute()`. This final check ensures that the solver has fulfilled their repayment obligations before\n        // proceeding.\n        (, bool _calledback, bool _fulfilled) = _solverLockData();\n        if (!_calledback) revert CallbackNotCalled();\n        if (!_fulfilled && !_isBalanceReconciled()) revert BalanceNotReconciled();\n\n        // Check if this is an on-chain, ex post bid search by verifying the `ctx.bidFind` flag.\n        // If the flag is set, revert with `BidFindSuccessful` and include the solver's bid amount in `solverTracker`.\n        // This indicates that the bid search process has completed successfully.\n        if (ctx.bidFind) revert BidFindSuccessful(solverTracker.bidAmount);\n    }\n\n    /// Updates ctx.dappGasLeft based on the gas used in the DApp hook call just performed.\n    /// @dev Measure the gasWaterMarkBefore using `gasleft()` just before performing the DApp hook call.\n    /// @dev Will revert if the gas used exceeds the remaining dappGasLeft.\n    /// @param ctx Memory pointer to the metacalls' Context object.\n    /// @param gasWaterMarkBefore The gasleft() value just before the DApp hook call.\n    function _updateDAppGasLeft(Context memory ctx, uint256 gasWaterMarkBefore) internal view {\n        uint256 _gasUsed = gasWaterMarkBefore - gasleft();\n\n        if (_gasUsed > ctx.dappGasLeft) revert DAppGasLimitReached();\n\n        // No need to SafeCast - will revert above if too large for uint32\n        ctx.dappGasLeft -= uint32(_gasUsed);\n    }\n\n    receive() external payable { }\n}\n"
    }
}