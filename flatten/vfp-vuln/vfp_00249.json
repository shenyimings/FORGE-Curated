{
    "vfp_id": "vfp_00249",
    "project_name": "2025.08.14 - Final - Malda Audit Report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "mErc20Host: Permissionless calls to external endpoints fail when source chain is Eth mainnet",
            "description": "The mErc20Host contract requires the l1Inclusion flag to be set for permissionless proof submission, but attempting to set this flag for data originating from Ethereum mainnet causes a panic in viewcalls.rs. The root cause is a missing handling for Ethereum in the get_env_input_for_l1_inclusion_and_l2_block_number function, which does not return a default value for ETH_MAINNET. This makes it impossible for users who are not proof forwarders to trigger external actions on the host chain when the source is Ethereum mainnet. The exploitation occurs simply by attempting a valid permissionless call, which inevitably fails. The impact is a denial of service for permissionless operations like liquidateExternal from Ethereum mainnet, undermining a key use case of the protocol.\n",
            "severity": "Medium",
            "location": [
                "mErc20Host.sol::_verifyProof#378-399",
                "viewcalls.rs#get_env_input_for_l1_inclusion_and_l2_block_number#933-970",
                "validators.rs#195"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/host/mErc20Host.sol"
            ]
        }
    ],
    "affected_files": {
        "mErc20Host.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\n// interfaces\nimport {Steel} from \"risc0/steel/Steel.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// contracts\nimport {IZkVerifier} from \"src/verifier/ZkVerifier.sol\";\nimport {mErc20Upgradable} from \"src/mToken/mErc20Upgradable.sol\";\n\nimport {mTokenProofDecoderLib} from \"src/libraries/mTokenProofDecoderLib.sol\";\n\nimport {IRoles} from \"src/interfaces/IRoles.sol\";\nimport {ImErc20Host} from \"src/interfaces/ImErc20Host.sol\";\nimport {IOperatorDefender} from \"src/interfaces/IOperator.sol\";\nimport {ImTokenOperationTypes} from \"src/interfaces/ImToken.sol\";\nimport {IGasFeesHelper} from \"src/interfaces/IGasFeesHelper.sol\";\nimport {CommonLib} from \"src/libraries/CommonLib.sol\";\n\nimport {Migrator} from \"src/migration/Migrator.sol\";\n\ncontract mErc20Host is mErc20Upgradable, ImErc20Host, ImTokenOperationTypes {\n    using SafeERC20 for IERC20;\n\n    // Add migrator address\n    address public migrator;\n\n    // Add modifier for migrator only\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, mErc20Host_CallerNotAllowed());\n        _;\n    }\n\n    // ----------- STORAGE ------------\n    struct Accumulated {\n        mapping(address => uint256) inPerChain;\n        mapping(address => uint256) outPerChain;\n    }\n\n    mapping(uint32 => Accumulated) internal acc;\n\n    mapping(address => mapping(address => bool)) public allowedCallers;\n    mapping(uint32 => bool) public allowedChains;\n    IZkVerifier public verifier;\n    IGasFeesHelper public gasHelper;\n\n    /**\n     * @notice Initializes the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param operator_ The address of the Operator\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param zkVerifier_ The IZkVerifier address\n     */\n    function initialize(\n        address underlying_,\n        address operator_,\n        address interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address zkVerifier_,\n        address roles_\n    ) external initializer {\n        require(underlying_ != address(0), mErc20Host_AddressNotValid());\n        require(operator_ != address(0), mErc20Host_AddressNotValid());\n        require(interestRateModel_ != address(0), mErc20Host_AddressNotValid());\n        require(zkVerifier_ != address(0), mErc20Host_AddressNotValid());\n        require(roles_ != address(0), mErc20Host_AddressNotValid());\n        require(admin_ != address(0), mErc20Host_AddressNotValid());\n\n        // Initialize the base contract\n        _proxyInitialize(\n            underlying_, operator_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_\n        );\n       \n        verifier = IZkVerifier(zkVerifier_);\n\n        rolesOperator = IRoles(roles_);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    // ----------- VIEW ------------\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function getProofData(address user, uint32 dstId) external view returns (uint256, uint256) {\n        return (acc[dstId].inPerChain[user], acc[dstId].outPerChain[user]);\n    }\n\n    // ----------- OWNER ------------\n    /**\n     * @notice Updates an allowed chain status\n     * @param _chainId the chain id\n     * @param _status the new status\n     */\n    function updateAllowedChain(uint32 _chainId, bool _status) external {\n        _onlyAdminOrRole(_getChainsManagerRole());\n\n        allowedChains[_chainId] = _status;\n        emit mErc20Host_ChainStatusUpdated(_chainId, _status);\n    }\n\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function extractForRebalancing(uint256 amount) external {\n        IOperatorDefender(operator).beforeRebalancing(address(this));\n\n        if (!_isAllowedFor(msg.sender, rolesOperator.REBALANCER())) revert mErc20Host_NotRebalancer();\n        IERC20(underlying).safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Sets the migrator address\n     * @param _migrator The new migrator address\n     */\n    function setMigrator(address _migrator) external onlyAdmin {\n        require(_migrator != address(0), mErc20Host_AddressNotValid());\n        migrator = _migrator;\n    }\n\n    /**\n     * @notice Sets the gas fees helper address\n     * @param _helper The new helper address\n     */\n    function setGasHelper(address _helper) external onlyAdmin {\n        require(_helper != address(0), mErc20Host_AddressNotValid());\n        gasHelper = IGasFeesHelper(_helper);\n    }\n\n    /**\n     * @notice Withdraw gas received so far\n     * @param receiver the receiver address\n     */\n    function withdrawGasFees(address payable receiver) external {\n        _onlyAdminOrRole(_getSequencerRole());\n\n        uint256 balance = address(this).balance;\n        receiver.transfer(balance);\n    }\n\n    /**\n     * @notice Updates IZkVerifier address\n     * @param _zkVerifier the verifier address\n     */\n    function updateZkVerifier(address _zkVerifier) external onlyAdmin {\n        require(_zkVerifier != address(0), mErc20Host_AddressNotValid());\n        emit ZkVerifierUpdated(address(verifier), _zkVerifier);\n        verifier = IZkVerifier(_zkVerifier);\n    }\n\n    // ----------- PUBLIC ------------\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function updateAllowedCallerStatus(address caller, bool status) external override {\n        allowedCallers[msg.sender][caller] = status;\n        emit AllowedCallerUpdated(msg.sender, caller, status);\n    }\n\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function liquidateExternal(\n        bytes calldata journalData,\n        bytes calldata seal,\n        address[] calldata userToLiquidate,\n        uint256[] calldata liquidateAmount,\n        address[] calldata collateral,\n        address receiver\n    ) external override {\n        // verify received data\n        if (!_isAllowedFor(msg.sender, _getBatchProofForwarderRole())) {\n            _verifyProof(journalData, seal);\n        }\n\n        bytes[] memory journals = _decodeJournals(journalData);\n        uint256 length = journals.length;\n        CommonLib.checkLengthMatch(length, liquidateAmount.length);\n        CommonLib.checkLengthMatch(length, userToLiquidate.length);\n        CommonLib.checkLengthMatch(length, collateral.length);\n\n        for (uint256 i; i < length;) {\n            _liquidateExternal(journals[i], userToLiquidate[i], liquidateAmount[i], collateral[i], receiver);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function mintExternal(\n        bytes calldata journalData,\n        bytes calldata seal,\n        uint256[] calldata mintAmount,\n        uint256[] calldata minAmountsOut,\n        address receiver\n    ) external override {\n        if (!_isAllowedFor(msg.sender, _getBatchProofForwarderRole())) {\n            _verifyProof(journalData, seal);\n        }\n\n        _checkOutflow(CommonLib.computeSum(mintAmount));\n\n        bytes[] memory journals = _decodeJournals(journalData);\n        uint256 length = journals.length;\n        CommonLib.checkLengthMatch(length, mintAmount.length);\n\n        for (uint256 i; i < length;) {\n            _mintExternal(journals[i], mintAmount[i], minAmountsOut[i], receiver);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function repayExternal(\n        bytes calldata journalData,\n        bytes calldata seal,\n        uint256[] calldata repayAmount,\n        address receiver\n    ) external override {\n        if (!_isAllowedFor(msg.sender, _getBatchProofForwarderRole())) {\n            _verifyProof(journalData, seal);\n        }\n\n        _checkOutflow(CommonLib.computeSum(repayAmount));\n\n        bytes[] memory journals = _decodeJournals(journalData);\n        uint256 length = journals.length;\n        CommonLib.checkLengthMatch(length, repayAmount.length);\n\n        for (uint256 i; i < length;) {\n            _repayExternal(journals[i], repayAmount[i], receiver);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function performExtensionCall(uint256 actionType, uint256 amount, uint32 dstChainId) external payable override {\n        //actionType:\n        // 1 - withdraw\n        // 2 - borrow\n        CommonLib.checkHostToExtension(amount, dstChainId, msg.value, allowedChains, gasHelper);\n        _checkOutflow(amount);\n\n        uint256 _amount = amount;\n        if (actionType == 1) {\n            _amount = _redeem(msg.sender, amount, false);\n            emit mErc20Host_WithdrawOnExtensionChain(msg.sender, dstChainId, _amount);\n        } else if (actionType == 2) {\n            _borrow(msg.sender, amount, false);\n            emit mErc20Host_BorrowOnExtensionChain(msg.sender, dstChainId, _amount);\n        } else {\n            revert mErc20Host_ActionNotAvailable();\n        }\n        acc[dstChainId].outPerChain[msg.sender] += _amount;\n    }\n\n    /**\n     * @inheritdoc ImErc20Host\n     */\n    function mintOrBorrowMigration(bool mint, uint256 amount, address receiver, address borrower, uint256 minAmount)\n        external\n        onlyMigrator\n    {\n        require(amount > 0, mErc20Host_AmountNotValid());\n\n        if (mint) {\n            _mint(receiver, receiver, amount, minAmount, false);\n            emit mErc20Host_MintMigration(receiver, amount);\n        } else {\n            _borrowWithReceiver(borrower, receiver, amount);\n            emit mErc20Host_BorrowMigration(borrower, amount);\n        }\n    }\n\n    // ----------- PRIVATE ------------\n    function _onlyAdminOrRole(bytes32 _role) internal view {\n        if (msg.sender != admin && !_isAllowedFor(msg.sender, _role)) {\n            revert mErc20Host_CallerNotAllowed();\n        }\n    }\n\n    function _decodeJournals(bytes calldata data) internal pure returns (bytes[] memory) {\n        return abi.decode(data, (bytes[]));\n    }\n\n    function _checkOutflow(uint256 amount) internal {\n        IOperatorDefender(operator).checkOutflowVolumeLimit(amount);\n    }\n\n    function _checkProofCall(uint32 dstChainId, uint32 chainId, address market, address sender) internal view {\n        _checkSender(msg.sender, sender);\n        require(dstChainId == uint32(block.chainid), mErc20Host_DstChainNotValid());\n        require(market == address(this), mErc20Host_AddressNotValid());\n        require(allowedChains[chainId], mErc20Host_ChainNotValid());\n    }\n\n    function _checkSender(address msgSender, address srcSender) internal view {\n        if (msgSender != srcSender) {\n            require(\n                allowedCallers[srcSender][msgSender] || msgSender == admin\n                    || _isAllowedFor(msgSender, _getProofForwarderRole())\n                    || _isAllowedFor(msgSender, _getBatchProofForwarderRole()),\n                mErc20Host_CallerNotAllowed()\n            );\n        }\n    }\n\n    function _getGasFees(uint32 dstChain) internal view returns (uint256) {\n        if (address(gasHelper) == address(0)) return 0;\n        return gasHelper.gasFees(dstChain);\n    }\n\n    function _isAllowedFor(address _sender, bytes32 role) internal view returns (bool) {\n        return rolesOperator.isAllowedFor(_sender, role);\n    }\n\n    function _getChainsManagerRole() internal view returns (bytes32) {\n        return rolesOperator.CHAINS_MANAGER();\n    }\n\n    function _getProofForwarderRole() internal view returns (bytes32) {\n        return rolesOperator.PROOF_FORWARDER();\n    }\n\n    function _getBatchProofForwarderRole() internal view returns (bytes32) {\n        return rolesOperator.PROOF_BATCH_FORWARDER();\n    }\n\n    function _getSequencerRole() internal view returns (bytes32) {\n        return rolesOperator.SEQUENCER();\n    }\n\n    function _verifyProof(bytes calldata journalData, bytes calldata seal) internal view {\n        require(journalData.length > 0, mErc20Host_JournalNotValid());\n\n        // Decode the dynamic array of journals.\n        bytes[] memory journals = _decodeJournals(journalData);\n\n        // Check the L1Inclusion flag for each journal.\n        bool isSequencer = _isAllowedFor(msg.sender, _getProofForwarderRole())\n            || _isAllowedFor(msg.sender, _getBatchProofForwarderRole());\n\n        if (!isSequencer) {\n            for (uint256 i = 0; i < journals.length; i++) {\n                (,,,,,, bool L1Inclusion) = mTokenProofDecoderLib.decodeJournal(journals[i]);\n                if (!L1Inclusion) {\n                    revert mErc20Host_L1InclusionRequired();\n                }\n            }\n        }\n\n        // verify it using the IZkVerifier contract\n        verifier.verifyInput(journalData, seal);\n    }\n\n    function _liquidateExternal(\n        bytes memory singleJournal,\n        address userToLiquidate,\n        uint256 liquidateAmount,\n        address collateral,\n        address receiver\n    ) internal {\n        (address _sender, address _market, uint256 _accAmountIn,, uint32 _chainId, uint32 _dstChainId,) =\n            mTokenProofDecoderLib.decodeJournal(singleJournal);\n\n        // temporary overwrite; will be removed in future implementations\n        receiver = _sender;\n\n        // base checks\n        _checkProofCall(_dstChainId, _chainId, _market, _sender);\n\n        // operation checks\n        {\n            require(liquidateAmount > 0, mErc20Host_AmountNotValid());\n            require(liquidateAmount <= _accAmountIn - acc[_chainId].inPerChain[_sender], mErc20Host_AmountTooBig());\n            require(userToLiquidate != msg.sender && userToLiquidate != _sender, mErc20Host_CallerNotAllowed());\n        }\n        collateral = collateral == address(0) ? address(this) : collateral;\n\n        // actions\n        acc[_chainId].inPerChain[_sender] += liquidateAmount;\n        _liquidate(receiver, userToLiquidate, liquidateAmount, collateral, false);\n\n        emit mErc20Host_LiquidateExternal(\n            msg.sender, _sender, userToLiquidate, receiver, collateral, _chainId, liquidateAmount\n        );\n    }\n\n    function _mintExternal(bytes memory singleJournal, uint256 mintAmount, uint256 minAmountOut, address receiver)\n        internal\n    {\n        (address _sender, address _market, uint256 _accAmountIn,, uint32 _chainId, uint32 _dstChainId,) =\n            mTokenProofDecoderLib.decodeJournal(singleJournal);\n\n        // temporary overwrite; will be removed in future implementations\n        receiver = _sender;\n\n        // base checks\n        _checkProofCall(_dstChainId, _chainId, _market, _sender);\n\n        // operation checks\n        {\n            require(mintAmount > 0, mErc20Host_AmountNotValid());\n            require(mintAmount <= _accAmountIn - acc[_chainId].inPerChain[_sender], mErc20Host_AmountTooBig());\n        }\n\n        // actions\n        acc[_chainId].inPerChain[_sender] += mintAmount;\n        _mint(receiver, receiver, mintAmount, minAmountOut, false);\n\n        emit mErc20Host_MintExternal(msg.sender, _sender, receiver, _chainId, mintAmount);\n    }\n\n    function _repayExternal(bytes memory singleJournal, uint256 repayAmount, address receiver) internal {\n        (address _sender, address _market, uint256 _accAmountIn,, uint32 _chainId, uint32 _dstChainId,) =\n            mTokenProofDecoderLib.decodeJournal(singleJournal);\n\n        // temporary overwrite; will be removed in future implementations\n        receiver = _sender;\n\n        // base checks\n        _checkProofCall(_dstChainId, _chainId, _market, _sender);\n\n        uint256 actualRepayAmount = _repayBehalf(receiver, repayAmount, false);\n\n        // operation checks\n        {\n            require(repayAmount > 0, mErc20Host_AmountNotValid());\n            require(actualRepayAmount <= _accAmountIn - acc[_chainId].inPerChain[_sender], mErc20Host_AmountTooBig());\n        }\n\n        // actions\n        acc[_chainId].inPerChain[_sender] += actualRepayAmount;\n\n        emit mErc20Host_RepayExternal(msg.sender, _sender, receiver, _chainId, actualRepayAmount);\n    }\n}\n"
    }
}