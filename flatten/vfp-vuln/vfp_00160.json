{
    "vfp_id": "vfp_00160",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Bonding/:buy() and Bonding/:sell() lack slippage parameters",
            "description": "The Bonding::buy and Bonding::sell functions do not include slippage controls, meaning users cannot specify a minimum amount of tokens they expect to receive. The root cause is the absence of minAmountOut parameters in these functions. While the Base chain's private mempool reduces the risk of sandwich attacks, users can still suffer losses due to execution ordering, especially when large trades are processed ahead of smaller ones. This leads to a suboptimal user experience and potential economic loss, even in the absence of malicious actors, reducing trust in the fairness of the bonding curve mechanism.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol",
                "protocol-contracts/contracts/fun/FRouter.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "FERC20 creator can launch a sale with faulty parameters",
            "description": "The Bonding contract allows a token creator to launch a bonding sale with an empty cores array, which later causes the AgentFactoryV3::initFromBondingCurve function to revert due to a requirement that cores.length > 0. The root cause is the lack of input validation in the Bonding::launch function. An attacker or malicious creator could exploit this by launching a sale with an empty cores array, causing the sale to proceed until graduation, at which point the transaction reverts and traps user funds in the FPair contract. This leads to a loss of user funds and a denial of service for the sale process, undermining trust in the protocol's reliability.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol#191",
                "AgentFactoryV3.sol#531"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small amount of AgentToken will be locked in the FPair after graduating",
            "description": "When an agent graduates via Bonding::_openTradingOnUniswap(), the amount of FERC20 tokens in the FPair is divided by 1e18 to normalize decimals. If the balance is not a multiple of 1e18, precision is lost due to truncation. This rounded-down value is used to mint AgentToken for Uniswap liquidity, while the remainder is sent to the FPair. As a result, slightly more AgentToken than intended ends up in the FPair, where it cannot be retrieved. The root cause is improper handling of decimal precision in token amount calculations. This can be exploited to cause permanent loss of tokens, though the amount per incident is small. The impact is gradual erosion of token supply, with up to 1e18-1 tokens locked per graduation event.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "FERC20 tokens lose value when they graduate to AgentTokens",
            "description": "During agent graduation, the FERC20 tokens are converted 1:1 to AgentToken and migrated to a real Uniswap pool. However, the VIRTUAL liquidity in the new pool comes from actual reserves, whereas the FPair used a \"virtual\" reserve of 6000e18 VIRTUAL tokens that were never actually deposited. This results in a lower VIRTUAL liquidity in the Uniswap pool compared to the FPair, reducing the exchange rate for AgentToken. The root cause is the discrepancy between virtual and real liquidity models. This is not directly exploitable by an attacker but creates economic loss for FERC20 holders. The impact is devaluation of user holdings upon graduation, undermining trust and creating misaligned incentives.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        }
    ],
    "affected_files": {
        "Bonding.sol": "// SPDX-License-Identifier: MIT\n// Modified from https://github.com/sourlodine/Pump.fun-Smart-Contract/blob/main/contracts/PumpFun.sol\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FFactory.sol\";\nimport \"./IFPair.sol\";\nimport \"./FRouter.sol\";\nimport \"./FERC20.sol\";\nimport \"../virtualPersona/IAgentFactoryV3.sol\";\n\ncontract Bonding is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    address private _feeTo;\n\n    FFactory public factory;\n    FRouter public router;\n    uint256 public initialSupply;\n    uint256 public fee;\n    uint256 public constant K = 3_000_000_000_000;\n    uint256 public assetRate;\n    uint256 public gradThreshold;\n    uint256 public maxTx;\n    address public agentFactory;\n    struct Profile {\n        address user;\n        address[] tokens;\n    }\n\n    struct Token {\n        address creator;\n        address token;\n        address pair;\n        address agentToken;\n        Data data;\n        string description;\n        uint8[] cores;\n        string image;\n        string twitter;\n        string telegram;\n        string youtube;\n        string website;\n        bool trading;\n        bool tradingOnUniswap;\n    }\n\n    struct Data {\n        address token;\n        string name;\n        string _name;\n        string ticker;\n        uint256 supply;\n        uint256 price;\n        uint256 marketCap;\n        uint256 liquidity;\n        uint256 volume;\n        uint256 volume24H;\n        uint256 prevPrice;\n        uint256 lastUpdated;\n    }\n\n    struct DeployParams {\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n    }\n\n    DeployParams private _deployParams;\n\n    mapping(address => Profile) public profile;\n    address[] public profiles;\n\n    mapping(address => Token) public tokenInfo;\n    address[] public tokenInfos;\n\n    event Launched(address indexed token, address indexed pair, uint);\n    event Deployed(address indexed token, uint256 amount0, uint256 amount1);\n    event Graduated(address indexed token, address agentToken);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address factory_,\n        address router_,\n        address feeTo_,\n        uint256 fee_,\n        uint256 initialSupply_,\n        uint256 assetRate_,\n        uint256 maxTx_,\n        address agentFactory_,\n        uint256 gradThreshold_\n    ) external initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n\n        factory = FFactory(factory_);\n        router = FRouter(router_);\n\n        _feeTo = feeTo_;\n        fee = (fee_ * 1 ether) / 1000;\n\n        initialSupply = initialSupply_;\n        assetRate = assetRate_;\n        maxTx = maxTx_;\n\n        agentFactory = agentFactory_;\n        gradThreshold = gradThreshold_;\n    }\n\n    function _createUserProfile(address _user) internal returns (bool) {\n        address[] memory _tokens;\n\n        Profile memory _profile = Profile({user: _user, tokens: _tokens});\n\n        profile[_user] = _profile;\n\n        profiles.push(_user);\n\n        return true;\n    }\n\n    function _checkIfProfileExists(address _user) internal view returns (bool) {\n        return profile[_user].user == _user;\n    }\n\n    function _approval(\n        address _spender,\n        address _token,\n        uint256 amount\n    ) internal returns (bool) {\n        IERC20(_token).forceApprove(_spender, amount);\n\n        return true;\n    }\n\n    function setInitialSupply(uint256 newSupply) public onlyOwner {\n        initialSupply = newSupply;\n    }\n\n    function setGradThreshold(uint256 newThreshold) public onlyOwner {\n        gradThreshold = newThreshold;\n    }\n\n    function setFee(uint256 newFee, address newFeeTo) public onlyOwner {\n        fee = newFee;\n        _feeTo = newFeeTo;\n    }\n\n    function setMaxTx(uint256 maxTx_) public onlyOwner {\n        maxTx = maxTx_;\n    }\n\n    function setAssetRate(uint256 newRate) public onlyOwner {\n        require(newRate > 0, \"Rate err\");\n\n        assetRate = newRate;\n    }\n\n    function setDeployParams(DeployParams memory params) public onlyOwner {\n        _deployParams = params;\n    }\n\n    function getUserTokens(\n        address account\n    ) public view returns (address[] memory) {\n        require(_checkIfProfileExists(account), \"User Profile dose not exist.\");\n\n        Profile memory _profile = profile[account];\n\n        return _profile.tokens;\n    }\n\n    function launch(\n        string memory _name,\n        string memory _ticker,\n        uint8[] memory cores,\n        string memory desc,\n        string memory img,\n        string[4] memory urls,\n        uint256 purchaseAmount\n    ) public nonReentrant returns (address, address, uint) {\n        require(\n            purchaseAmount > fee,\n            \"Purchase amount must be greater than fee\"\n        );\n        address assetToken = router.assetToken();\n        require(\n            IERC20(assetToken).balanceOf(msg.sender) >= purchaseAmount,\n            \"Insufficient amount\"\n        );\n        uint256 initialPurchase = (purchaseAmount - fee);\n        IERC20(assetToken).safeTransferFrom(msg.sender, _feeTo, fee);\n        IERC20(assetToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            initialPurchase\n        );\n\n        FERC20 token = new FERC20(string.concat(\"fun \", _name), _ticker, initialSupply, maxTx);\n        uint256 supply = token.totalSupply();\n\n        address _pair = factory.createPair(address(token), assetToken);\n\n        bool approved = _approval(address(router), address(token), supply);\n        require(approved);\n\n        uint256 k = ((K * 10000) / assetRate);\n        uint256 liquidity = (((k * 10000 ether) / supply) * 1 ether) / 10000;\n\n        router.addInitialLiquidity(address(token), supply, liquidity);\n\n        Data memory _data = Data({\n            token: address(token),\n            name: string.concat(\"fun \", _name),\n            _name: _name,\n            ticker: _ticker,\n            supply: supply,\n            price: supply / liquidity,\n            marketCap: liquidity,\n            liquidity: liquidity * 2,\n            volume: 0,\n            volume24H: 0,\n            prevPrice: supply / liquidity,\n            lastUpdated: block.timestamp\n        });\n        Token memory tmpToken = Token({\n            creator: msg.sender,\n            token: address(token),\n            agentToken: address(0),\n            pair: _pair,\n            data: _data,\n            description: desc,\n            cores: cores,\n            image: img,\n            twitter: urls[0],\n            telegram: urls[1],\n            youtube: urls[2],\n            website: urls[3],\n            trading: true, // Can only be traded once creator made initial purchase\n            tradingOnUniswap: false\n        });\n        tokenInfo[address(token)] = tmpToken;\n        tokenInfos.push(address(token));\n\n        bool exists = _checkIfProfileExists(msg.sender);\n\n        if (exists) {\n            Profile storage _profile = profile[msg.sender];\n\n            _profile.tokens.push(address(token));\n        } else {\n            bool created = _createUserProfile(msg.sender);\n\n            if (created) {\n                Profile storage _profile = profile[msg.sender];\n\n                _profile.tokens.push(address(token));\n            }\n        }\n\n        uint n = tokenInfos.length;\n\n        emit Launched(address(token), _pair, n);\n\n        // Make initial purchase\n        IERC20(assetToken).forceApprove(address(router), initialPurchase);\n        router.buy(initialPurchase, address(token), address(this));\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n\n        return (address(token), _pair, n);\n    }\n\n    function sell(\n        uint256 amountIn,\n        address tokenAddress\n    ) public returns (bool) {\n        require(tokenInfo[tokenAddress].trading, \"Token not trading\");\n\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        (uint256 amount0In, uint256 amount1Out) = router.sell(\n            amountIn,\n            tokenAddress,\n            msg.sender\n        );\n\n        uint256 newReserveA = reserveA + amount0In;\n        uint256 newReserveB = reserveB - amount1Out;\n        uint256 duration = block.timestamp -\n            tokenInfo[tokenAddress].data.lastUpdated;\n\n        uint256 liquidity = newReserveB * 2;\n        uint256 mCap = (tokenInfo[tokenAddress].data.supply * newReserveB) /\n            newReserveA;\n        uint256 price = newReserveA / newReserveB;\n        uint256 volume = duration > 86400\n            ? amount1Out\n            : tokenInfo[tokenAddress].data.volume24H + amount1Out;\n        uint256 prevPrice = duration > 86400\n            ? tokenInfo[tokenAddress].data.price\n            : tokenInfo[tokenAddress].data.prevPrice;\n\n        tokenInfo[tokenAddress].data.price = price;\n        tokenInfo[tokenAddress].data.marketCap = mCap;\n        tokenInfo[tokenAddress].data.liquidity = liquidity;\n        tokenInfo[tokenAddress].data.volume =\n            tokenInfo[tokenAddress].data.volume +\n            amount1Out;\n        tokenInfo[tokenAddress].data.volume24H = volume;\n        tokenInfo[tokenAddress].data.prevPrice = prevPrice;\n\n        if (duration > 86400) {\n            tokenInfo[tokenAddress].data.lastUpdated = block.timestamp;\n        }\n\n        return true;\n    }\n\n    function buy(\n        uint256 amountIn,\n        address tokenAddress\n    ) public payable returns (bool) {\n        require(tokenInfo[tokenAddress].trading, \"Token not trading\");\n\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        (uint256 amount1In, uint256 amount0Out) = router.buy(\n            amountIn,\n            tokenAddress,\n            msg.sender\n        );\n\n        uint256 newReserveA = reserveA - amount0Out;\n        uint256 newReserveB = reserveB + amount1In;\n        uint256 duration = block.timestamp -\n            tokenInfo[tokenAddress].data.lastUpdated;\n\n        uint256 liquidity = newReserveB * 2;\n        uint256 mCap = (tokenInfo[tokenAddress].data.supply * newReserveB) /\n            newReserveA;\n        uint256 price = newReserveA / newReserveB;\n        uint256 volume = duration > 86400\n            ? amount1In\n            : tokenInfo[tokenAddress].data.volume24H + amount1In;\n        uint256 _price = duration > 86400\n            ? tokenInfo[tokenAddress].data.price\n            : tokenInfo[tokenAddress].data.prevPrice;\n\n        tokenInfo[tokenAddress].data.price = price;\n        tokenInfo[tokenAddress].data.marketCap = mCap;\n        tokenInfo[tokenAddress].data.liquidity = liquidity;\n        tokenInfo[tokenAddress].data.volume =\n            tokenInfo[tokenAddress].data.volume +\n            amount1In;\n        tokenInfo[tokenAddress].data.volume24H = volume;\n        tokenInfo[tokenAddress].data.prevPrice = _price;\n\n        if (duration > 86400) {\n            tokenInfo[tokenAddress].data.lastUpdated = block.timestamp;\n        }\n\n        if (newReserveA <= gradThreshold && tokenInfo[tokenAddress].trading) {\n            _openTradingOnUniswap(tokenAddress);\n        }\n\n        return true;\n    }\n\n    function _openTradingOnUniswap(address tokenAddress) private {\n        FERC20 token_ = FERC20(tokenAddress);\n\n        Token storage _token = tokenInfo[tokenAddress];\n\n        require(\n            _token.trading && !_token.tradingOnUniswap,\n            \"trading is already open\"\n        );\n\n        _token.trading = false;\n        _token.tradingOnUniswap = true;\n\n        // Transfer asset tokens to bonding contract\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        uint256 assetBalance = pair.assetBalance();\n        uint256 tokenBalance = pair.balance();\n\n        router.graduate(tokenAddress);\n\n        IERC20(router.assetToken()).forceApprove(agentFactory, assetBalance);\n        uint256 id = IAgentFactoryV3(agentFactory).initFromBondingCurve(\n            string.concat(_token.data._name, \" by Virtuals\"),\n            _token.data.ticker,\n            _token.cores,\n            _deployParams.tbaSalt,\n            _deployParams.tbaImplementation,\n            _deployParams.daoVotingPeriod,\n            _deployParams.daoThreshold,\n            assetBalance\n        );\n\n        address agentToken = IAgentFactoryV3(agentFactory)\n            .executeBondingCurveApplication(\n                id,\n                _token.data.supply / (10 ** token_.decimals()),\n                tokenBalance / (10 ** token_.decimals()),\n                pairAddress\n            );\n        _token.agentToken = agentToken;\n\n        router.approval(\n            pairAddress,\n            agentToken,\n            address(this),\n            IERC20(agentToken).balanceOf(pairAddress)\n        );\n\n        token_.burnFrom(pairAddress, tokenBalance);\n\n        emit Graduated(tokenAddress, agentToken);\n    }\n\n    function unwrapToken(\n        address srcTokenAddress,\n        address[] memory accounts\n    ) public {\n        Token memory info = tokenInfo[srcTokenAddress];\n        require(info.tradingOnUniswap, \"Token is not graduated yet\");\n\n        FERC20 token = FERC20(srcTokenAddress);\n        IERC20 agentToken = IERC20(info.agentToken);\n        address pairAddress = factory.getPair(\n            srcTokenAddress,\n            router.assetToken()\n        );\n        for (uint i = 0; i < accounts.length; i++) {\n            address acc = accounts[i];\n            uint256 balance = token.balanceOf(acc);\n            if (balance > 0) {\n                token.burnFrom(acc, balance);\n                agentToken.transferFrom(pairAddress, acc, balance);\n            }\n        }\n    }\n}\n",
        "FRouter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FFactory.sol\";\nimport \"./IFPair.sol\";\nimport \"../tax/IBondingTax.sol\";\n\ncontract FRouter is\n    Initializable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\n    FFactory public factory;\n    address public assetToken;\n    address public taxManager;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address factory_,\n        address assetToken_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        require(factory_ != address(0), \"Zero addresses are not allowed.\");\n        require(assetToken_ != address(0), \"Zero addresses are not allowed.\");\n\n        factory = FFactory(factory_);\n        assetToken = assetToken_;\n    }\n\n    function getAmountsOut(\n        address token,\n        address assetToken_,\n        uint256 amountIn\n    ) public view returns (uint256 _amountOut) {\n        require(token != address(0), \"Zero addresses are not allowed.\");\n\n        address pairAddress = factory.getPair(token, assetToken);\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        uint256 k = pair.kLast();\n\n        uint256 amountOut;\n\n        if (assetToken_ == assetToken) {\n            uint256 newReserveB = reserveB + amountIn;\n\n            uint256 newReserveA = k / newReserveB;\n\n            amountOut = reserveA - newReserveA;\n        } else {\n            uint256 newReserveA = reserveA + amountIn;\n\n            uint256 newReserveB = k / newReserveA;\n\n            amountOut = reserveB - newReserveB;\n        }\n\n        return amountOut;\n    }\n\n    function addInitialLiquidity(\n        address token_,\n        uint256 amountToken_,\n        uint256 amountAsset_\n    ) public onlyRole(EXECUTOR_ROLE) returns (uint256, uint256) {\n        require(token_ != address(0), \"Zero addresses are not allowed.\");\n\n        address pairAddress = factory.getPair(token_, assetToken);\n\n        IFPair pair = IFPair(pairAddress);\n\n        IERC20 token = IERC20(token_);\n\n        token.safeTransferFrom(msg.sender, pairAddress, amountToken_);\n\n        pair.mint(amountToken_, amountAsset_);\n\n        return (amountToken_, amountAsset_);\n    }\n\n    function sell(\n        uint256 amountIn,\n        address tokenAddress,\n        address to\n    ) public nonReentrant onlyRole(EXECUTOR_ROLE) returns (uint256, uint256) {\n        require(tokenAddress != address(0), \"Zero addresses are not allowed.\");\n        require(to != address(0), \"Zero addresses are not allowed.\");\n\n        address pairAddress = factory.getPair(tokenAddress, assetToken);\n\n        IFPair pair = IFPair(pairAddress);\n\n        IERC20 token = IERC20(tokenAddress);\n\n        uint256 amountOut = getAmountsOut(tokenAddress, address(0), amountIn);\n\n        token.safeTransferFrom(to, pairAddress, amountIn);\n\n        uint fee = factory.sellTax();\n        uint256 txFee = (fee * amountOut) / 100;\n\n        uint256 amount = amountOut - txFee;\n        address feeTo = factory.taxVault();\n\n        pair.transferAsset(to, amount);\n        pair.transferAsset(feeTo, txFee);\n\n        pair.swap(amountIn, 0, 0, amountOut);\n\n        if (feeTo == taxManager) {\n            IBondingTax(taxManager).swapForAsset();\n        }\n\n        return (amountIn, amountOut);\n    }\n\n    function buy(\n        uint256 amountIn,\n        address tokenAddress,\n        address to\n    ) public onlyRole(EXECUTOR_ROLE) nonReentrant returns (uint256, uint256) {\n        require(tokenAddress != address(0), \"Zero addresses are not allowed.\");\n        require(to != address(0), \"Zero addresses are not allowed.\");\n        require(amountIn > 0, \"amountIn must be greater than 0\");\n\n        address pair = factory.getPair(tokenAddress, assetToken);\n\n        uint fee = factory.buyTax();\n        uint256 txFee = (fee * amountIn) / 100;\n        address feeTo = factory.taxVault();\n\n        uint256 amount = amountIn - txFee;\n\n        IERC20(assetToken).safeTransferFrom(to, pair, amount);\n\n        IERC20(assetToken).safeTransferFrom(to, feeTo, txFee);\n\n        uint256 amountOut = getAmountsOut(tokenAddress, assetToken, amount);\n\n        IFPair(pair).transferTo(to, amountOut);\n\n        IFPair(pair).swap(0, amountOut, amount, 0);\n\n        if (feeTo == taxManager) {\n            IBondingTax(taxManager).swapForAsset();\n        }\n\n        return (amount, amountOut);\n    }\n\n    function graduate(\n        address tokenAddress\n    ) public onlyRole(EXECUTOR_ROLE) nonReentrant {\n        require(tokenAddress != address(0), \"Zero addresses are not allowed.\");\n        address pair = factory.getPair(tokenAddress, assetToken);\n        uint256 assetBalance = IFPair(pair).assetBalance();\n        FPair(pair).transferAsset(msg.sender, assetBalance);\n    }\n\n    function approval(\n        address pair,\n        address asset,\n        address spender,\n        uint256 amount\n    ) public onlyRole(EXECUTOR_ROLE) nonReentrant {\n        require(spender != address(0), \"Zero addresses are not allowed.\");\n\n        IFPair(pair).approval(spender, asset, amount);\n    }\n\n    function setTaxManager(address newManager) public onlyRole(ADMIN_ROLE) {\n        taxManager = newManager;\n    }\n}\n"
    }
}