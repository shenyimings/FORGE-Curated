{
    "vfp_id": "vfp_00018",
    "project_name": "OP Succinct - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Anyone could submit a malicious output via the optimistic function proposeL2Output",
            "description": "1. **Description:** When optimistic mode is enabled, the `proposeL2Output` function allows anyone to propose an L2 output root if the fallback timeout has elapsed since the last proposal. This creates a permissionless proposal window even without proper verification.\n2. **Cause:** The vulnerability arises from the logic in `proposeL2Output`, which permits any address to propose an output root when `block.timestamp - lastProposalTimestamp() > fallbackTimeout`, regardless of whether the proposer is approved or the output is valid.\n3. **Exploitation:** A malicious actor could exploit this by waiting for the fallback timeout to expire and then submitting an invalid output root through `proposeL2Output`, taking advantage of the permissionless fallback mechanism.\n4. **Impact:** If the invalid output root is not challenged and deleted within the limited challenge period, it may become finalized, leading to incorrect state assumptions and potential consensus divergence or financial loss.\n",
            "severity": "Medium",
            "location": [
                "OPSuccinctL2OutputOracle.sol::proposeL2Output"
            ],
            "files": [
                "op-succinct/contracts/src/validity/OPSuccinctL2OutputOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "OPSuccinctL2OutputOracle.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {ISemver} from \"interfaces/universal/ISemver.sol\";\nimport {Types} from \"@optimism/src/libraries/Types.sol\";\nimport {AggregationOutputs} from \"../lib/Types.sol\";\nimport {Constants} from \"@optimism/src/libraries/Constants.sol\";\nimport {ISP1Verifier} from \"@sp1-contracts/src/ISP1Verifier.sol\";\n\n/// @custom:proxied\n/// @title OPSuccinctL2OutputOracle\n/// @notice The OPSuccinctL2OutputOracle contains an array of L2 state outputs, where each output is a\n///         commitment to the state of the L2 chain. Other contracts like the OptimismPortal use\n///         these outputs to verify information about the state of L2. The outputs posted to this contract\n///         are proved to be valid with `op-succinct`.\ncontract OPSuccinctL2OutputOracle is Initializable, ISemver {\n    /// @notice Configuration parameters for OP Succinct verification.\n    struct OpSuccinctConfig {\n        /// @notice The verification key of the aggregation SP1 program.\n        bytes32 aggregationVkey;\n        /// @notice The 32 byte commitment to the BabyBear representation of the verification key of\n        /// the range SP1 program. Specifically, this verification key is the output of converting\n        /// the [u32; 8] range BabyBear verification key to a [u8; 32] array.\n        bytes32 rangeVkeyCommitment;\n        /// @notice The hash of the chain's rollup config, which ensures the proofs submitted are for\n        /// the correct chain. This is used to prevent replay attacks.\n        bytes32 rollupConfigHash;\n    }\n\n    /// @notice Parameters to initialize the OPSuccinctL2OutputOracle contract.\n    struct InitParams {\n        address challenger;\n        address proposer;\n        address owner;\n        uint256 finalizationPeriodSeconds;\n        uint256 l2BlockTime;\n        bytes32 aggregationVkey;\n        bytes32 rangeVkeyCommitment;\n        bytes32 rollupConfigHash;\n        bytes32 startingOutputRoot;\n        uint256 startingBlockNumber;\n        uint256 startingTimestamp;\n        uint256 submissionInterval;\n        address verifier;\n        uint256 fallbackTimeout;\n    }\n\n    /// @notice The number of the first L2 block recorded in this contract.\n    uint256 public startingBlockNumber;\n\n    /// @notice The timestamp of the first L2 block recorded in this contract.\n    uint256 public startingTimestamp;\n\n    /// @notice An array of L2 output proposals.\n    Types.OutputProposal[] internal l2Outputs;\n\n    /// @notice The minimum interval in L2 blocks at which checkpoints must be submitted.\n    /// @custom:network-specific\n    uint256 public submissionInterval;\n\n    /// @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\n    /// @custom:network-specific\n    uint256 public l2BlockTime;\n\n    /// @notice The address of the challenger. Can be updated via upgrade.\n    /// @custom:network-specific\n    address public challenger;\n\n    /// @notice The address of the proposer. Can be updated via upgrade. DEPRECATED: Use approvedProposers mapping instead.\n    /// @custom:network-specific\n    /// @custom:deprecated\n    address public proposer;\n\n    /// @notice The minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n    /// @custom:network-specific\n    uint256 public finalizationPeriodSeconds;\n\n    /// @notice The verification key of the aggregation SP1 program.\n    /// @custom:deprecated\n    bytes32 public aggregationVkey;\n\n    /// @notice The 32 byte commitment to the BabyBear representation of the verification key of the range SP1 program. Specifically,\n    /// this verification is the output of converting the [u32; 8] range BabyBear verification key to a [u8; 32] array.\n    /// @custom:deprecated\n    bytes32 public rangeVkeyCommitment;\n\n    /// @notice The deployed SP1Verifier contract to verify proofs.\n    address public verifier;\n\n    /// @notice The hash of the chain's rollup config, which ensures the proofs submitted are for the correct chain.\n    /// @custom:deprecated\n    bytes32 public rollupConfigHash;\n\n    /// @notice The owner of the contract, who has admin permissions.\n    address public owner;\n\n    /// @notice The proposers that can propose new proofs.\n    mapping(address => bool) public approvedProposers;\n\n    /// @notice A trusted mapping of block numbers to block hashes.\n    mapping(uint256 => bytes32) public historicBlockHashes;\n\n    /// @notice Activate optimistic mode. When true, the contract will accept outputs without verification.\n    bool public optimisticMode;\n\n    /// @notice The time threshold (in seconds) after which anyone can submit a proposal if no proposal has been submitted.\n    ///         Only applies in permissioned mode.\n    /// @custom:network-specific\n    uint256 public fallbackTimeout;\n\n    /// @notice Mapping of configuration names to OpSuccinctConfig structs.\n    mapping(bytes32 => OpSuccinctConfig) public opSuccinctConfigs;\n\n    /// @notice The genesis configuration name.\n    bytes32 public constant GENESIS_CONFIG_NAME = keccak256(\"opsuccinct_genesis\");\n\n    ////////////////////////////////////////////////////////////\n    //                         Events                         //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when an output is proposed.\n    /// @param outputRoot    The output root.\n    /// @param l2OutputIndex The index of the output in the l2Outputs array.\n    /// @param l2BlockNumber The L2 block number of the output root.\n    /// @param l1Timestamp   The L1 timestamp when proposed.\n    event OutputProposed(\n        bytes32 indexed outputRoot, uint256 indexed l2OutputIndex, uint256 indexed l2BlockNumber, uint256 l1Timestamp\n    );\n\n    /// @notice Emitted when outputs are deleted.\n    /// @param prevNextOutputIndex Next L2 output index before the deletion.\n    /// @param newNextOutputIndex  Next L2 output index after the deletion.\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\n\n    /// @notice Emitted when an OP Succinct configuration is updated.\n    /// @param configName The name of the configuration.\n    /// @param aggregationVkey The aggregation verification key.\n    /// @param rangeVkeyCommitment The range verification key commitment.\n    /// @param rollupConfigHash The rollup config hash.\n    event OpSuccinctConfigUpdated(\n        bytes32 indexed configName, bytes32 aggregationVkey, bytes32 rangeVkeyCommitment, bytes32 rollupConfigHash\n    );\n\n    /// @notice Emitted when an OP Succinct configuration is deleted.\n    /// @param configName The name of the configuration that was deleted.\n    event OpSuccinctConfigDeleted(bytes32 indexed configName);\n\n    /// @notice Emitted when the owner address is updated.\n    /// @param previousOwner The previous owner address.\n    /// @param newOwner The new owner address.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Emitted when a proposer address is added.\n    /// @param proposer The proposer address.\n    /// @param added Whether the proposer was added or removed.\n    event ProposerUpdated(address indexed proposer, bool added);\n\n    /// @notice Emitted when the submission interval is updated.\n    /// @param oldSubmissionInterval The old submission interval.\n    /// @param newSubmissionInterval The new submission interval.\n    event SubmissionIntervalUpdated(uint256 oldSubmissionInterval, uint256 newSubmissionInterval);\n\n    /// @notice Emitted when the optimistic mode is toggled.\n    /// @param enabled Indicates whether optimistic mode is enabled or disabled.\n    /// @param finalizationPeriodSeconds The new finalization period in seconds.\n    event OptimisticModeToggled(bool indexed enabled, uint256 finalizationPeriodSeconds);\n\n    ////////////////////////////////////////////////////////////\n    //                         Errors                         //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice The L1 block hash is not available. If the block hash requested is not in the last 256 blocks,\n    ///         it is not available.\n    error L1BlockHashNotAvailable();\n\n    /// @notice The L1 block hash is not checkpointed.\n    error L1BlockHashNotCheckpointed();\n\n    /// @notice Semantic version.\n    /// @custom:semver v3.0.0-rc.1\n    string public constant version = \"v3.0.0-rc.1\";\n\n    /// @notice The version of the initializer on the contract. Used for managing upgrades.\n    uint8 public constant initializerVersion = 3;\n\n    ////////////////////////////////////////////////////////////\n    //                        Modifiers                       //\n    ////////////////////////////////////////////////////////////\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"L2OutputOracle: caller is not the owner\");\n        _;\n    }\n\n    modifier whenOptimistic() {\n        require(optimisticMode, \"L2OutputOracle: optimistic mode is not enabled\");\n        _;\n    }\n\n    modifier whenNotOptimistic() {\n        require(!optimisticMode, \"L2OutputOracle: optimistic mode is enabled\");\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                        Functions                       //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice Constructs the OPSuccinctL2OutputOracle contract. Disables initializers.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializer.\n    /// @param _initParams The initialization parameters for the contract.\n    function initialize(InitParams memory _initParams) public reinitializer(initializerVersion) {\n        require(_initParams.submissionInterval > 0, \"L2OutputOracle: submission interval must be greater than 0\");\n        require(_initParams.l2BlockTime > 0, \"L2OutputOracle: L2 block time must be greater than 0\");\n        require(\n            _initParams.startingTimestamp <= block.timestamp,\n            \"L2OutputOracle: starting L2 timestamp must be less than current time\"\n        );\n\n        submissionInterval = _initParams.submissionInterval;\n        l2BlockTime = _initParams.l2BlockTime;\n\n        // For proof verification to work, there must be an initial output.\n        // Disregard the _startingBlockNumber and _startingTimestamp parameters during upgrades, as they're already set.\n        if (l2Outputs.length == 0) {\n            l2Outputs.push(\n                Types.OutputProposal({\n                    outputRoot: _initParams.startingOutputRoot,\n                    timestamp: uint128(_initParams.startingTimestamp),\n                    l2BlockNumber: uint128(_initParams.startingBlockNumber)\n                })\n            );\n\n            startingBlockNumber = _initParams.startingBlockNumber;\n            startingTimestamp = _initParams.startingTimestamp;\n        }\n\n        challenger = _initParams.challenger;\n        finalizationPeriodSeconds = _initParams.finalizationPeriodSeconds;\n\n        // Add the initial proposer.\n        approvedProposers[_initParams.proposer] = true;\n\n        // Initialize the permissionless fallback timeout.\n        fallbackTimeout = _initParams.fallbackTimeout;\n\n        // Initialize genesis configuration\n        opSuccinctConfigs[GENESIS_CONFIG_NAME] = OpSuccinctConfig({\n            aggregationVkey: _initParams.aggregationVkey,\n            rangeVkeyCommitment: _initParams.rangeVkeyCommitment,\n            rollupConfigHash: _initParams.rollupConfigHash\n        });\n\n        verifier = _initParams.verifier;\n\n        owner = _initParams.owner;\n    }\n\n    /// @notice Deletes all output proposals after and including the proposal that corresponds to\n    ///         the given output index. Only the challenger address can delete outputs.\n    /// @param _l2OutputIndex Index of the first L2 output to be deleted.\n    ///                       All outputs after this output will also be deleted.\n    function deleteL2Outputs(uint256 _l2OutputIndex) external {\n        require(msg.sender == challenger, \"L2OutputOracle: only the challenger address can delete outputs\");\n\n        // Make sure we're not *increasing* the length of the array.\n        require(\n            _l2OutputIndex < l2Outputs.length, \"L2OutputOracle: cannot delete outputs after the latest output index\"\n        );\n\n        // Do not allow deleting any outputs that have already been finalized.\n        require(\n            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < finalizationPeriodSeconds,\n            \"L2OutputOracle: cannot delete outputs that have already been finalized\"\n        );\n\n        uint256 prevNextL2OutputIndex = nextOutputIndex();\n\n        // Use assembly to delete the array elements because Solidity doesn't allow it.\n        assembly {\n            sstore(l2Outputs.slot, _l2OutputIndex)\n        }\n\n        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\n    }\n\n    /// @notice Accepts an outputRoot and the timestamp of the corresponding L2 block.\n    ///         The timestamp must be equal to the current value returned by `nextTimestamp()` in\n    ///         order to be accepted. This function may only be called by the Proposer.\n    /// @param _configName The name of the OP Succinct configuration to use.\n    /// @param _outputRoot    The L2 output of the checkpoint block.\n    /// @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n    /// @param _l1BlockNumber The block number with the specified block hash.\n    /// @param _proof The aggregation proof that proves the transition from the latest L2 output to the new L2 output.\n    /// @param _proverAddress The address of the prover that submitted the proof. Note: proverAddress is not required to be the tx.origin as there is no reason to front-run the prover in the full validity setting.\n    /// @dev Modified the function signature to exclude the `_l1BlockHash` parameter, as it's redundant\n    ///      for OP Succinct given the `_l1BlockNumber` parameter.\n    /// @dev Security Note: This contract uses `tx.origin` for proposer permission control due to usage of this contract\n    ///      in the OPSuccinctDisputeGame, created via DisputeGameFactory using the Clone With Immutable Arguments (CWIA) pattern.\n    ///\n    ///      In this setup:\n    ///      - `msg.sender` is the newly created game contract, not an approved proposer.\n    ///      - `tx.origin` identifies the actual user initiating the transaction.\n    ///\n    ///      While `tx.origin` can be vulnerable in general, it is safe here because:\n    ///      - Only trusted proposers/relayers call this contract.\n    ///      - Proposers are expected to interact solely with trusted contracts.\n    ///\n    ///      As long as proposers avoid untrusted contracts, `tx.origin` is as secure as `msg.sender` in this context.\n    function proposeL2Output(\n        bytes32 _configName,\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        uint256 _l1BlockNumber,\n        bytes memory _proof,\n        address _proverAddress\n    ) external whenNotOptimistic {\n        // The proposer must be explicitly approved, or the zero address must be approved (permissionless proposing),\n        // or the fallback timeout has been exceeded allowing anyone to propose.\n        require(\n            approvedProposers[tx.origin] || approvedProposers[address(0)]\n                || (block.timestamp - lastProposalTimestamp() > fallbackTimeout),\n            \"L2OutputOracle: only approved proposers can propose new outputs\"\n        );\n\n        require(\n            _l2BlockNumber >= nextBlockNumber(),\n            \"L2OutputOracle: block number must be greater than or equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot propose L2 output in the future\"\n        );\n\n        require(_outputRoot != bytes32(0), \"L2OutputOracle: L2 output proposal cannot be the zero hash\");\n\n        OpSuccinctConfig memory config = opSuccinctConfigs[_configName];\n        require(isValidOpSuccinctConfig(config), \"L2OutputOracle: invalid OP Succinct configuration\");\n\n        bytes32 l1BlockHash = historicBlockHashes[_l1BlockNumber];\n        if (l1BlockHash == bytes32(0)) {\n            revert L1BlockHashNotCheckpointed();\n        }\n\n        AggregationOutputs memory publicValues = AggregationOutputs({\n            l1Head: l1BlockHash,\n            l2PreRoot: l2Outputs[latestOutputIndex()].outputRoot,\n            claimRoot: _outputRoot,\n            claimBlockNum: _l2BlockNumber,\n            rollupConfigHash: config.rollupConfigHash,\n            rangeVkeyCommitment: config.rangeVkeyCommitment,\n            proverAddress: _proverAddress\n        });\n\n        ISP1Verifier(verifier).verifyProof(config.aggregationVkey, abi.encode(publicValues), _proof);\n\n        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\n\n        l2Outputs.push(\n            Types.OutputProposal({\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    /// @notice Accepts an outputRoot and the timestamp of the corresponding L2 block.\n    ///         The timestamp must be equal to the current value returned by `nextTimestamp()` in\n    ///         order to be accepted. This function may only be called by the Proposer.\n    /// @param _outputRoot    The L2 output of the checkpoint block.\n    /// @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n    /// @param _l1BlockHash   A block hash which must be included in the current chain.\n    /// @param _l1BlockNumber The block number with the specified block hash.\n    /// @dev This function is sourced from the original L2OutputOracle contract. The only modification is that the proposer address must be in the approvedProposers mapping, or permissionless proposing is enabled.\n    /// @dev This function is not compatible with the `OPSuccinctDisputeGame` contract as it uses `msg.sender` for proposer permission control.\n    ///      See `whenNotOptimistic` implementation of `proposeL2Output` for more details.\n    ///      If the functionality for optimistic mode is needed in the `OPSuccinctDisputeGame` contract, use mock mode instead.\n    function proposeL2Output(bytes32 _outputRoot, uint256 _l2BlockNumber, bytes32 _l1BlockHash, uint256 _l1BlockNumber)\n        external\n        payable\n        whenOptimistic\n    {\n        // The proposer must be explicitly approved, or the zero address must be approved (permissionless proposing),\n        // or the fallback timeout has been exceeded allowing anyone to propose.\n        require(\n            approvedProposers[msg.sender] || approvedProposers[address(0)]\n                || (block.timestamp - lastProposalTimestamp() > fallbackTimeout),\n            \"L2OutputOracle: only approved proposers can propose new outputs\"\n        );\n\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot propose L2 output in the future\"\n        );\n\n        require(_outputRoot != bytes32(0), \"L2OutputOracle: L2 output proposal cannot be the zero hash\");\n\n        if (_l1BlockHash != bytes32(0)) {\n            // This check allows the proposer to propose an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the proposer's submission is censored until the block is no longer\n            // retrievable, if the proposer is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"L2OutputOracle: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\n\n        l2Outputs.push(\n            Types.OutputProposal({\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    /// @notice Checkpoints a block hash at a given block number.\n    /// @param _blockNumber Block number to checkpoint the hash at.\n    /// @dev If the block hash is not available, this will revert.\n    function checkpointBlockHash(uint256 _blockNumber) external {\n        bytes32 blockHash = blockhash(_blockNumber);\n        if (blockHash == bytes32(0)) {\n            revert L1BlockHashNotAvailable();\n        }\n        historicBlockHashes[_blockNumber] = blockHash;\n    }\n\n    /// @notice Returns an output by index. Needed to return a struct instead of a tuple.\n    /// @param _l2OutputIndex Index of the output to return.\n    /// @return The output at the given index.\n    function getL2Output(uint256 _l2OutputIndex) external view returns (Types.OutputProposal memory) {\n        return l2Outputs[_l2OutputIndex];\n    }\n\n    /// @notice Returns the index of the L2 output that checkpoints a given L2 block number.\n    ///         Uses a binary search to find the first output greater than or equal to the given\n    ///         block.\n    /// @param _l2BlockNumber L2 block number to find a checkpoint for.\n    /// @return Index of the first checkpoint that commits to the given L2 block number.\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\n        // Make sure an output for this block number has actually been proposed.\n        require(\n            _l2BlockNumber <= latestBlockNumber(),\n            \"L2OutputOracle: cannot get output for a block that has not been proposed\"\n        );\n\n        // Make sure there's at least one output proposed.\n        require(l2Outputs.length > 0, \"L2OutputOracle: cannot get output as no outputs have been proposed yet\");\n\n        // Find the output via binary search, guaranteed to exist.\n        uint256 lo = 0;\n        uint256 hi = l2Outputs.length;\n        while (lo < hi) {\n            uint256 mid = (lo + hi) / 2;\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    /// @notice Returns the L2 output proposal that checkpoints a given L2 block number.\n    ///         Uses a binary search to find the first output greater than or equal to the given\n    ///         block.\n    /// @param _l2BlockNumber L2 block number to find a checkpoint for.\n    /// @return First checkpoint that commits to the given L2 block number.\n    function getL2OutputAfter(uint256 _l2BlockNumber) external view returns (Types.OutputProposal memory) {\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\n    }\n\n    /// @notice Returns the number of outputs that have been proposed.\n    ///         Will revert if no outputs have been proposed yet.\n    /// @return The number of outputs that have been proposed.\n    function latestOutputIndex() public view returns (uint256) {\n        return l2Outputs.length - 1;\n    }\n\n    /// @notice Returns the index of the next output to be proposed.\n    /// @return The index of the next output to be proposed.\n    function nextOutputIndex() public view returns (uint256) {\n        return l2Outputs.length;\n    }\n\n    /// @notice Returns the block number of the latest submitted L2 output proposal.\n    ///         If no proposals been submitted yet then this function will return the starting\n    ///         block number.\n    /// @return Latest submitted L2 block number.\n    function latestBlockNumber() public view returns (uint256) {\n        return l2Outputs.length == 0 ? startingBlockNumber : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\n    }\n\n    /// @notice Computes the block number of the next L2 block that needs to be checkpointed.\n    /// @return Next L2 block number.\n    function nextBlockNumber() public view returns (uint256) {\n        return latestBlockNumber() + submissionInterval;\n    }\n\n    /// @notice Returns the timestamp of the last submitted L2 output proposal.\n    ///         If no proposals have been submitted yet, returns the starting timestamp.\n    /// @return Timestamp of the latest submitted L2 output proposal.\n    function lastProposalTimestamp() public view returns (uint256) {\n        return l2Outputs.length == 0 ? startingTimestamp : l2Outputs[l2Outputs.length - 1].timestamp;\n    }\n\n    /// @notice Returns the L2 timestamp corresponding to a given L2 block number.\n    /// @param _l2BlockNumber The L2 block number of the target block.\n    /// @return L2 timestamp of the given block.\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * l2BlockTime);\n    }\n\n    /// @notice Validates that an OpSuccinctConfig has all non-zero parameters.\n    /// @param _config The OpSuccinctConfig to validate.\n    /// @return True if all parameters are non-zero, false otherwise.\n    function isValidOpSuccinctConfig(OpSuccinctConfig memory _config) public pure returns (bool) {\n        return _config.aggregationVkey != bytes32(0) && _config.rangeVkeyCommitment != bytes32(0)\n            && _config.rollupConfigHash != bytes32(0);\n    }\n\n    /// @notice Update the submission interval.\n    /// @param _submissionInterval The new submission interval.\n    function updateSubmissionInterval(uint256 _submissionInterval) external onlyOwner {\n        emit SubmissionIntervalUpdated(submissionInterval, _submissionInterval);\n        submissionInterval = _submissionInterval;\n    }\n\n    /// @notice Updates or creates an OP Succinct configuration.\n    /// @param _configName The name of the configuration.\n    /// @param _rollupConfigHash The rollup config hash.\n    /// @param _aggregationVkey The aggregation verification key.\n    /// @param _rangeVkeyCommitment The range verification key commitment.\n    function addOpSuccinctConfig(\n        bytes32 _configName,\n        bytes32 _rollupConfigHash,\n        bytes32 _aggregationVkey,\n        bytes32 _rangeVkeyCommitment\n    ) external onlyOwner {\n        require(_configName != bytes32(0), \"L2OutputOracle: config name cannot be empty\");\n        require(!isValidOpSuccinctConfig(opSuccinctConfigs[_configName]), \"L2OutputOracle: config already exists\");\n\n        OpSuccinctConfig memory newConfig = OpSuccinctConfig({\n            aggregationVkey: _aggregationVkey,\n            rangeVkeyCommitment: _rangeVkeyCommitment,\n            rollupConfigHash: _rollupConfigHash\n        });\n\n        require(isValidOpSuccinctConfig(newConfig), \"L2OutputOracle: invalid OP Succinct configuration parameters\");\n\n        opSuccinctConfigs[_configName] = newConfig;\n\n        emit OpSuccinctConfigUpdated(_configName, _aggregationVkey, _rangeVkeyCommitment, _rollupConfigHash);\n    }\n\n    /// @notice Deletes an OP Succinct configuration.\n    /// @param _configName The name of the configuration to delete.\n    function deleteOpSuccinctConfig(bytes32 _configName) external onlyOwner {\n        delete opSuccinctConfigs[_configName];\n        emit OpSuccinctConfigDeleted(_configName);\n    }\n\n    /// Updates the owner address.\n    /// @param _owner The new owner address.\n    function transferOwnership(address _owner) external onlyOwner {\n        emit OwnershipTransferred(owner, _owner);\n        owner = _owner;\n    }\n\n    /// @notice Adds a new proposer address.\n    /// @param _proposer The new proposer address.\n    function addProposer(address _proposer) external onlyOwner {\n        approvedProposers[_proposer] = true;\n        emit ProposerUpdated(_proposer, true);\n    }\n\n    /// @notice Removes a proposer address.\n    /// @param _proposer The proposer address to remove.\n    function removeProposer(address _proposer) external onlyOwner {\n        approvedProposers[_proposer] = false;\n        emit ProposerUpdated(_proposer, false);\n    }\n\n    /// @notice Enables optimistic mode.\n    /// @param _finalizationPeriodSeconds The new finalization window.\n    function enableOptimisticMode(uint256 _finalizationPeriodSeconds) external onlyOwner whenNotOptimistic {\n        finalizationPeriodSeconds = _finalizationPeriodSeconds;\n        optimisticMode = true;\n        emit OptimisticModeToggled(true, _finalizationPeriodSeconds);\n    }\n\n    /// @notice Disables optimistic mode.\n    /// @param _finalizationPeriodSeconds The new finalization window.\n    function disableOptimisticMode(uint256 _finalizationPeriodSeconds) external onlyOwner whenOptimistic {\n        finalizationPeriodSeconds = _finalizationPeriodSeconds;\n        optimisticMode = false;\n        emit OptimisticModeToggled(false, _finalizationPeriodSeconds);\n    }\n}\n"
    }
}