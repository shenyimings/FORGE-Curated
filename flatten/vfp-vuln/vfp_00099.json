{
    "vfp_id": "vfp_00099",
    "project_name": "2024.12.09 - Final - Oku's New Order Types Contract Contest Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-182"
                ]
            },
            "title": "Unsafe Type Casting in Token Amount Handling",
            "description": "The contracts in the Oku protocol perform unsafe downcasting from uint256 to uint160 when handling token amounts in Permit2 transfers. This occurs in functions such as StopLimit::createOrder(), modifyOrder(), and others in Bracket.sol and OracleLess.sol. The root cause is that Solidity 0.8.x does not protect against data loss during type casting, only during arithmetic operations. As a result, if a user provides an amount greater than type(uint160).max, the value will overflow and wrap around to a much smaller number. An attacker can exploit this by creating an order with a very large amount (above uint160 limit) but only transferring a minimal amount due to the overflow. The contract records the large amount but receives only the small amount, allowing the attacker to manipulate the system and potentially drain funds by modifying or canceling the order. This leads to a mismatch between expected and actual token balances, resulting in financial loss for the protocol.\n",
            "severity": "High",
            "location": [
                "StopLimit.sol::createOrder",
                "StopLimit.sol::modifyOrder",
                "Bracket.sol::procureTokens",
                "Bracket.sol::modifyOrder",
                "OracleLess.sol::procureTokens"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Attackers can drain the OracleLess contract by creating an order with a malicious tokenIn and executing it with a malicious target",
            "description": "The OracleLess contract's createOrder() function does not validate whether the provided tokenIn is a legitimate ERC20 token, allowing attackers to use a malicious token. Additionally, the fillOrder() function does not validate the target address or txData, enabling arbitrary execution. The root cause is the lack of input validation and trust assumptions on external inputs. An attacker can create a malicious token that, when approved, transfers a small amount of a valuable token (e.g., WETH) to the contract. Then, by calling fillOrder() with a target set to a valuable token contract (e.g., USDT) and txData that encodes a transfer of all funds to the attacker, the execute() function will carry out the call. Due to the malicious approve logic, the contract receives 1 wei of WETH, satisfying the minAmountOut check (if set to 0), while the attacker drains all USDT from the contract. This results in a complete loss of funds held by the OracleLess contract for certain tokens.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::createOrder",
                "OracleLess.sol::fillOrder",
                "OracleLess.sol::execute"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Lack of nonReentrant modifier in fillOrder() and modifyOrder() allows attacker to steal funds",
            "description": "The fillOrder() and modifyOrder() functions in OracleLess.sol are vulnerable to reentrancy attacks because they lack a nonReentrant modifier. The root cause is the absence of reentrancy protection despite performing external calls (via target.call(txData)) before state changes are fully secured. An attacker can create two orders and use a malicious contract as the recipient. When fillOrder() is called on the first order, the attacker's contract is triggered via the external call, allowing it to re-enter the OracleLess contract and call modifyOrder() to reduce the first order's size (receiving funds back) and increase the second order's size (parking the stolen funds). This manipulation allows the attacker to bypass the final balance checks because the net token balance appears unchanged. After the reentrancy, the attacker cancels the second order and withdraws all stolen funds. The impact is high, as attackers can steal user and protocol funds at minimal cost, undermining the financial integrity of the system.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::fillOrder",
                "OracleLess.sol::modifyOrder"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "Double Withdrawal via Canceled Order Modification",
            "description": "Users can withdraw tokens from a canceled order and then modify the same order to withdraw the tokens a second time. This occurs because the contracts (Bracket, OracleLess, and StopLimit) do not validate whether an order has already been canceled before allowing modification. An attacker can cancel an order to withdraw the full amount of tokens, then modify the order (e.g., reducing amountIn to 1), triggering another withdrawal of nearly the full original amount. This flaw allows repeated exploitation, enabling an attacker to drain the contract of all its tokens.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::modifyOrder#171-225",
                "Bracket.sol",
                "StopLimit.sol"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-668"
                ],
                "3": [
                    "CWE-402"
                ]
            },
            "title": "Excessive Allowance Granting Leading to Fund Drain",
            "description": "The StopLimit contract grants the Bracket contract an allowance of type(uint256).max for the input token during the performUpkeep function. This excessive approval allows the Bracket contract to transfer tokens from the StopLimit contract without sufficient restriction. An attacker can exploit this by creating a malicious order in the Bracket contract where the tokenOut is one for which the Bracket contract already has a high allowance. By calling performUpkeep with crafted calldata that triggers a transferFrom from the StopLimit contract, the attacker can drain nearly all funds. The root cause is the use of safeIncreaseAllowance to set allowances to maximum values instead of the exact required amount.\n",
            "severity": "High",
            "location": [
                "StopLimit.sol::performUpkeep#100-104",
                "StopLimit.sol::updateApproval#397-411",
                "Bracket.sol::fillStopLimitOrder#147-165",
                "Bracket.sol::performUpkeep#85-101",
                "Bracket.sol::execute#526-568"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Failure to Reset Unspent Approval Leading to Contract Balance Theft",
            "description": "When filling orders, the contract grants arbitrary approvals to untrusted target contracts but fails to reset the allowance to zero after the external call. If the target contract does not use the full approved amount, the remaining allowance persists, allowing the target to later withdraw the unspent tokens. This is particularly dangerous because the order creator is refunded the full amountIn regardless of actual usage, enabling an attacker to create a malicious target contract that reuses leftover approvals to steal funds repeatedly. The root cause is the absence of a post-call approval reset (e.g., setting allowance to 0) after the interaction with the target.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::procureTokens#240",
                "Bracket.sol"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-340"
                ],
                "4": [
                    "CWE-341"
                ]
            },
            "title": "OrderId Collision Between StopLimit and Bracket Contracts Enabling Double Refund",
            "description": "The orderId generation function lacks contract-specific entropy, relying only on block.number and user address, which makes it deterministic and prone to collisions across different contracts (StopLimit and Bracket) within the same block. An attacker can exploit this by creating orders in both contracts in the same block, resulting in identical orderIds. After the StopLimit order is filled (which internally uses Bracket), the attacker can cancel the same orderId twice on the Bracket contract, receiving double refunds. This leads to direct financial loss, order state corruption, and compromise of the accounting system due to shared orderId space without isolation.\n",
            "severity": "High",
            "location": [
                "AutomationMaster.sol::generateOrderId",
                "Bracket.sol::createOrder",
                "StopLimit.sol::createOrder"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Insecure Use of Recipient in safeTransferFrom Leading to Unauthorized Token Transfers",
            "description": "The contracts (OracleLess, StopLimit, Bracket) use the order.recipient as the from address in safeTransferFrom calls when creating or modifying orders. This allows an attacker to create an order with a victim as the recipient, provided the victim has previously approved more tokens than used in a prior trade (leaving residual allowance). The protocol then transfers tokens from the victim to fulfill the order, which the attacker can immediately fill for profit. The root cause is the use of order.recipient instead of msg.sender in the transfer logic, enabling unauthorized token movement from users who have leftover allowances. This issue affects multiple functions across contracts and enables unfair order exploitation.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::procureTokens#280",
                "StopLimit.sol::createOrder#171",
                "StopLimit.sol::modifyOrder#226-230",
                "Bracket.sol::modifyOrder#250-254"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "DoS via Uncancellable Orders with Zero Address Recipient",
            "description": "Users can create orders with recipient set to address(0), which makes the order impossible to cancel due to USDT's (and other similar tokens) restriction on transfers to the zero address. When such an order is canceled, the safeTransfer call reverts, preventing cancellation. Since the pendingOrderIds array has a maximum size enforced by AutomationMaster, an attacker can fill it with uncancellable orders, blocking legitimate orders. Admins cannot cancel these orders, only increase the limit, which can be exploited again. This leads to a complete denial of service for the Bracket and StopLimit contracts.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::_cancelOrder#501-520",
                "StopLimit.sol",
                "USDT::_transfer"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Order Executed with Wrong Slippage Due to Dynamic Direction Logic",
            "description": "The order's execution direction is determined dynamically at creation time based on the current exchange rate relative to the takeProfit price. The root cause is the logic in the `createOrder` function that sets the direction using `MASTER.getExchangeRate(tokenIn, tokenOut) > takeProfit`, which is evaluated only once during order creation. If the market price moves beyond the takeProfit level by the time the order is executed, the order may be executed as a stop instead of a take-profit, due to both stopPrice and takeProfit being on the same side of the current price. This results in the use of stopSlippage (e.g., 15%) instead of the intended takeProfitSlippage (e.g., 5%), exposing the user to significantly worse execution prices and unexpected losses. The impact is incorrect slippage application leading to user fund loss.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::createOrder#492"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "User Can Brick Bracket Contract via Malicious txData and safeApprove Revert",
            "description": "Users can render the Bracket contract unusable for specific tokens by providing malicious `txData` during order creation that leaves a non-zero, non-full allowance (e.g., 1 wei) after a swap. The root cause is the use of an outdated `safeApprove` function from an old OpenZeppelin version, which reverts when attempting to approve a non-zero amount if the current allowance is also non-zero. This behavior is triggered when a malicious user crafts a swap that consumes `amountIn - 1` tokens, leaving a 1 wei allowance. Subsequent attempts to use `safeApprove` for that token will fail, blocking all future swaps involving that token. The impact is a denial-of-service (DoS) condition where the contract's swapping functionality is bricked for affected tokens, potentially locking user funds.\n",
            "severity": "Medium",
            "location": [
                "SafeERC20.sol::safeApprove#45-54",
                "Bracket.sol::execute"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/interfaces/openzeppelin/SafeERC20.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing feeBips Validation in OracleLess.createOrder",
            "description": "The `createOrder` function in the OracleLess contract does not validate the `feeBips` parameter, allowing users to set values greater than 10000 (which represents 100%). The root cause is the absence of a validation check such as `require(feeBips <= 10000)`. While orders with `feeBips > 10000` will eventually revert during execution, a malicious user can create numerous such orders. If the user also uses a blacklisted token or manipulates their recipient address, these orders can become non-cancelable. This allows an attacker to fill the `pendingOrderIds` queue, leading to a denial-of-service (DoS) for other users who cannot create new orders once `maxPendingOrders` is reached.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::createOrder#38-67"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Creation of Uncancelable Orders Using Malicious Token Contracts",
            "description": "The OracleLess contract does not restrict the `tokenIn` parameter in the `createOrder` function, allowing users to specify any contract that implements the IERC20 interface. The root cause is the lack of a token whitelist or sanity checks on the token contract. A malicious actor can deploy a token contract that reverts on transfer and use it as `tokenIn` to create an order. When the admin or another user attempts to cancel this order, the `_cancelOrder` function will try to refund the `tokenIn` to the user, causing a revert due to the malicious token's behavior. This results in uncancelable orders that permanently occupy space in the order queue, enabling a griefing attack.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::createOrder#38",
                "OracleLess.sol::_cancelOrder#160"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Malicious User Can Poison Bracket.sol with Blacklisted Recipient",
            "description": "Users can create orders in the Bracket contract with a recipient address that is blacklisted in the underlying token contract. The root cause is the lack of validation during order creation to check whether the recipient can receive tokens. While the order creator (a non-blacklisted address) can pay for and create the order, cancellation becomes impossible because the `_cancelOrder` function attempts to send tokens back to the blacklisted recipient, causing a revert. An attacker can flood the system with such orders, filling the `pendingOrderIds` array and causing a denial-of-service when `maxPendingOrders` is reached. This also increases gas costs for array operations.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::createOrder#362-368",
                "Bracket.sol::_cancelOrder#510-511"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-770"
                ]
            },
            "title": "DoS on Order Creation Due to Lack of Anti-Spam Fees",
            "description": "The protocol does not charge any fees for creating or canceling orders, making it economically viable for an attacker to spam the system. The root cause is the absence of a mandatory fee mechanism. A malicious user can create the maximum number of pending orders (e.g., 25) with conditions that will never be met (e.g., prices set to uint256.max). When the admin cancels these orders, the funds are refunded, allowing the attacker to reuse them to recreate orders. On low-cost chains like Optimism, this loop can be repeated indefinitely, preventing legitimate users from creating orders due to the \"Max Order Count Reached\" error. The impact is a persistent denial-of-service with low attack cost.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::_createOrder#444-465",
                "StopLimit.sol::_createOrder#300-323"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "StopLimit Order Fails to Execute Due to Repeated Minimum Size Check",
            "description": "A StopLimit order may fail to execute even when in range because the system performs a minimum order size check twice: once at creation and again when converting to a Bracket order. The root cause is the lack of a bypass mechanism for internal order creations initiated by the StopLimit contract. For example, an order created with 100 USDC at $1.10 (value $110) passes the initial check, but if the USDC price drops to $0.90, the value becomes $90, below the $100 minimum. When `fillStopLimitOrder` tries to create a Bracket order, the second size check reverts the transaction. This breaks core functionality, preventing valid StopLimit orders from being filled under price volatility.\n",
            "severity": "Medium",
            "location": [
                "StopLimit.sol::performUpkeep#126",
                "Bracket.sol::_createOrder#473"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "cancelOrder Vulnerable to DoS from Unbounded Loop",
            "description": "The `cancelOrder` function contains an unbounded loop or array operation that can consume excessive gas as the number of pending orders increases. The root cause is inefficient data structure management, likely involving linear search or removal in an array without gas cost mitigation. An attacker can exploit this by filling the `pendingOrderIds` array to its maximum, causing the `cancelOrder` function to hit gas limits when attempting to remove an order. This renders order cancellation impossible, contributing to a denial-of-service condition and preventing cleanup of invalid or stale orders.\n",
            "severity": "Medium",
            "location": [
                "ArrayMutation::removeFromArray"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/libraries/ArrayMutation.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Unbounded Iteration in _cancelOrder Leading to DoS",
            "description": "The _cancelOrder function iterates through the pendingOrderIds array to locate and remove an order, but this array has no upper bound on its size. The root cause is the lack of a mechanism to limit or efficiently manage the size of pendingOrderIds, combined with the O(n) removal operation. An attacker can exploit this by creating a large number of pending orders, forcing the loop to consume excessive gas. This results in a denial-of-service condition where legitimate users and even admins cannot cancel orders due to hitting the block gas limit, effectively paralyzing order management functionality.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::pendingOrderIds#L151",
                "OracleLess.sol::_cancelOrder"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Malicious users can createOrder with 0 amount and make DOS for all",
            "description": "Malicious users can repeatedly call createOrder with a zero amountIn, creating a large number of invalid orders. The root cause is the absence of input validation to prevent zero-amount orders in the createOrder function. This leads to an ever-growing pendingOrderIds array, which is iterated during fillOrder and cancelOrder via the removeFromArray function. When the array becomes sufficiently large, legitimate users will run out of gas when attempting to fill or cancel orders, resulting in a denial-of-service for all users relying on these functions.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::createOrder#L38C1-L67C6"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        }
    ],
    "affected_files": {
        "Bracket.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IAutomation.sol\";\nimport \"../libraries/ArrayMutation.sol\";\nimport \"../interfaces/uniswapV3/UniswapV3Pool.sol\";\nimport \"../interfaces/uniswapV3/IPermit2.sol\";\nimport \"../interfaces/uniswapV3/ISwapRouter02.sol\";\nimport \"../interfaces/openzeppelin/Ownable.sol\";\nimport \"../interfaces/openzeppelin/IERC20.sol\";\nimport \"../interfaces/openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/openzeppelin/ReentrancyGuard.sol\";\n\n///@notice This contract owns and handles all logic associated with the following order types:\n/// BRACKET_ORDER - automated fill at a fixed takeProfit price OR stop price, with independant slippapge for each option\n/// LIMIT_ORDER - BRACKET_ORDER at specified take profit price, with STOP set to 0\n/// STOP_ORDER - BRACKET_ORDER at specified stop price, with take profit set to 2 ** 256 - 1\n/// In order to configure a LIMIT_ORDER or STOP_ORDER, simply set the take profit or stop price to either 0 for the lower bound or 2^256 - 1 for the upper bound\ncontract Bracket is Ownable, IBracket, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IAutomationMaster public immutable MASTER;\n    IPermit2 public immutable permit2;\n\n    uint96[] public pendingOrderIds;\n\n    mapping(uint96 => Order) public orders;\n\n    constructor(IAutomationMaster _master, IPermit2 _permit2) {\n        MASTER = _master;\n        permit2 = _permit2;\n    }\n\n    function getPendingOrders() external view returns (uint96[] memory) {\n        return pendingOrderIds;\n    }\n\n    //check upkeep\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        for (uint96 i = 0; i < pendingOrderIds.length; i++) {\n            Order memory order = orders[pendingOrderIds[i]];\n            (\n                bool inRange,\n                bool takeProfit,\n                uint256 exchangeRate\n            ) = checkInRange(order);\n            if (inRange) {\n                return (\n                    true,\n                    abi.encode(\n                        MasterUpkeepData({\n                            orderType: OrderType.BRACKET,\n                            target: address(this),\n                            txData: \"0x\",\n                            pendingOrderIdx: i,\n                            orderId: order.orderId,\n                            tokenIn: order.tokenIn,\n                            tokenOut: order.tokenOut,\n                            slippage: takeProfit\n                                ? order.takeProfitSlippage\n                                : order.stopSlippage, //bips based on take profit or stop fill\n                            amountIn: order.amountIn,\n                            exchangeRate: exchangeRate\n                        })\n                    )\n                );\n            }\n        }\n    }\n\n    ///@notice recipient of swap should be this contract,\n    ///as we need to account for tokens received.\n    ///This contract will then forward the tokens to the user\n    /// target refers to some contract where when we send @param performData,\n    ///that contract will exchange our tokenIn for tokenOut with at least minAmountReceived\n    /// pendingOrderIdx is the index of the pending order we are executing,\n    ///this pending order is removed from the array via array mutation\n    function performUpkeep(\n        bytes calldata performData\n    ) external override nonReentrant {\n        MasterUpkeepData memory data = abi.decode(\n            performData,\n            (MasterUpkeepData)\n        );\n        Order memory order = orders[pendingOrderIds[data.pendingOrderIdx]];\n\n        require(\n            order.orderId == pendingOrderIds[data.pendingOrderIdx],\n            \"Order Fill Mismatch\"\n        );\n\n        //deduce if we are filling stop or take profit\n        (bool inRange, bool takeProfit, ) = checkInRange(order);\n        require(inRange, \"order ! in range\");\n\n        //deduce bips\n        uint16 bips;\n        takeProfit ? bips = order.takeProfitSlippage : bips = order\n            .stopSlippage;\n\n        (uint256 swapAmountOut, uint256 tokenInRefund) = execute(\n            data.target,\n            data.txData,\n            order.amountIn,\n            order.tokenIn,\n            order.tokenOut,\n            bips\n        );\n\n        //handle accounting\n        //remove from pending array\n        pendingOrderIds = ArrayMutation.removeFromArray(\n            data.pendingOrderIdx,\n            pendingOrderIds\n        );\n\n        //handle fee\n        (uint256 feeAmount, uint256 adjustedAmount) = applyFee(\n            swapAmountOut,\n            order.feeBips\n        );\n\n        if (feeAmount != 0) {\n            order.tokenOut.safeTransfer(address(MASTER), feeAmount);\n        }\n\n        //send tokenOut to recipient\n        order.tokenOut.safeTransfer(order.recipient, adjustedAmount);\n\n        //refund any unspent tokenIn\n        //this should generally be 0 when using exact input for swaps, which is recommended\n        if (tokenInRefund != 0) {\n            order.tokenIn.safeTransfer(order.recipient, tokenInRefund);\n        }\n\n        //emit\n        emit OrderProcessed(order.orderId);\n    }\n\n    function fillStopLimitOrder(\n        bytes calldata swapPayload,\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint256 amountIn,\n        uint96 existingOrderId,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 existingFeeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage,\n        bool permit,\n        bytes calldata permitPayload\n    ) external override nonReentrant {\n        require(\n            msg.sender == address(MASTER.STOP_LIMIT_CONTRACT()),\n            \"Only Stop Limit\"\n        );\n        _initializeOrder(\n            swapPayload,\n            takeProfit,\n            stopPrice,\n            amountIn,\n            existingOrderId,\n            tokenIn,\n            tokenOut,\n            recipient,\n            existingFeeBips,\n            takeProfitSlippage,\n            stopSlippage,\n            permit,\n            permitPayload\n        );\n    }\n\n    ///@notice see @IBracket\n    function createOrder(\n        bytes calldata swapPayload,\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint256 amountIn,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 feeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage,\n        bool permit,\n        bytes calldata permitPayload\n    ) external override nonReentrant {\n        _initializeOrder(\n            swapPayload,\n            takeProfit,\n            stopPrice,\n            amountIn,\n            0, //no existing order id\n            tokenIn,\n            tokenOut,\n            recipient,\n            feeBips,\n            takeProfitSlippage,\n            stopSlippage,\n            permit,\n            permitPayload\n        );\n    }\n\n    ///@notice see @IBracket\n    function modifyOrder(\n        uint96 orderId,\n        uint256 _takeProfit,\n        uint256 _stopPrice,\n        uint256 amountInDelta,\n        IERC20 _tokenOut,\n        address _recipient,\n        uint16 _takeProfitSlippage,\n        uint16 _stopSlippage,\n        bool permit,\n        bool increasePosition,\n        bytes calldata permitPayload\n    ) external override nonReentrant {\n        //get order\n        Order memory order = orders[orderId];\n\n        //only order owner\n        require(msg.sender == order.recipient, \"only order owner\");\n\n        //deduce any amountIn changes\n        uint256 newAmountIn = order.amountIn;\n        if (amountInDelta != 0) {\n            if (increasePosition) {\n                newAmountIn += amountInDelta;\n                //take funds via permit2\n                if (permit) {\n                    handlePermit(\n                        order.recipient,\n                        permitPayload,\n                        uint160(amountInDelta),\n                        address(order.tokenIn)\n                    );\n                } else {\n                    //legacy transfer, assume prior approval\n                    order.tokenIn.safeTransferFrom(\n                        order.recipient,\n                        address(this),\n                        amountInDelta\n                    );\n                }\n            } else {\n                //ensure delta is valid\n                require(amountInDelta < order.amountIn, \"invalid delta\");\n\n                //set new amountIn for accounting\n                newAmountIn -= amountInDelta;\n\n                //check min order size for new amount\n                MASTER.checkMinOrderSize(order.tokenIn, newAmountIn);\n\n                //refund position partially\n                order.tokenIn.safeTransfer(order.recipient, amountInDelta);\n            }\n        }\n\n        //check for oracles\n        if (_tokenOut != order.tokenOut) {\n            require(\n                address(MASTER.oracles(_tokenOut)) != address(0x0),\n                \"Oracle !exist\"\n            );\n        }\n\n        //construct new order\n        Order memory newOrder = Order({\n            orderId: orderId,\n            takeProfit: _takeProfit,\n            stopPrice: _stopPrice,\n            amountIn: newAmountIn,\n            tokenIn: order.tokenIn,\n            tokenOut: _tokenOut,\n            feeBips: order.feeBips,\n            takeProfitSlippage: _takeProfitSlippage,\n            stopSlippage: _stopSlippage,\n            recipient: _recipient,\n            direction: MASTER.getExchangeRate(order.tokenIn, _tokenOut) >\n                _takeProfit\n        });\n\n        //store new order\n        orders[orderId] = newOrder;\n    }\n\n    ///@notice allow administrator to cancel any order\n    ///@notice once cancelled, any funds assocaiated with the order are returned to the order recipient\n    ///@notice only pending orders can be cancelled\n    function adminCancelOrder(uint96 orderId) external onlyOwner {\n        Order memory order = orders[orderId];\n        require(_cancelOrder(order), \"Order not active\");\n    }\n\n    ///@notice only the order recipient can cancel their order\n    ///@notice only pending orders can be cancelled\n    function cancelOrder(uint96 orderId) external {\n        Order memory order = orders[orderId];\n        require(msg.sender == order.recipient, \"Only Order Owner\");\n        require(_cancelOrder(order), \"Order not active\");\n    }\n\n    function procureTokens(\n        IERC20 token,\n        uint256 amount,\n        address owner,\n        bool permit,\n        bytes calldata permitPayload\n    ) internal {\n        if (permit) {\n            IAutomation.Permit2Payload memory payload = abi.decode(\n                permitPayload,\n                (IAutomation.Permit2Payload)\n            );\n\n            permit2.permit(owner, payload.permitSingle, payload.signature);\n            permit2.transferFrom(\n                owner,\n                address(this),\n                uint160(amount),\n                address(token)\n            );\n        } else {\n            token.safeTransferFrom(owner, address(this), amount);\n        }\n    }\n\n    function _initializeOrder(\n        bytes calldata swapPayload,\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint256 amountIn,\n        uint96 existingOrderId,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 feeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage,\n        bool permit,\n        bytes calldata permitPayload\n    ) internal {\n        //determine if we are doing a swap first\n        if (swapPayload.length != 0) {\n            SwapParams memory swapParams = abi.decode(\n                swapPayload,\n                (SwapParams)\n            );\n            //procure swap token in\n            procureTokens(\n                swapParams.swapTokenIn,\n                swapParams.swapAmountIn,\n                msg.sender,\n                permit,\n                permitPayload\n            );\n\n            _createOrderWithSwap(\n                swapParams,\n                takeProfit,\n                stopPrice,\n                existingOrderId,\n                tokenIn,\n                tokenOut,\n                recipient,\n                feeBips,\n                takeProfitSlippage,\n                stopSlippage\n            );\n        } else {\n            //no swap\n            procureTokens(tokenIn, amountIn, msg.sender, permit, permitPayload);\n\n            _createOrder(\n                takeProfit,\n                stopPrice,\n                amountIn,\n                existingOrderId,\n                tokenIn,\n                tokenOut,\n                recipient,\n                feeBips,\n                takeProfitSlippage,\n                stopSlippage\n            );\n        }\n    }\n\n    function _createOrderWithSwap(\n        SwapParams memory swapParams,\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint96 existingOrderId,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 feeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage\n    ) internal {\n        require(swapParams.swapSlippage <= 10000, \"BIPS > 10k\");\n\n        //execute the swap\n        (uint256 swapAmountOut, uint256 tokenInRefund) = execute(\n            swapParams.swapTarget,\n            swapParams.txData,\n            swapParams.swapAmountIn,\n            swapParams.swapTokenIn,\n            tokenIn,\n            swapParams.swapSlippage\n        );\n\n        _createOrder(\n            takeProfit,\n            stopPrice,\n            swapAmountOut,\n            existingOrderId,\n            tokenIn,\n            tokenOut,\n            recipient,\n            feeBips,\n            takeProfitSlippage,\n            stopSlippage\n        );\n        //refund any unspent tokenIn\n        //this should generally be 0 when using exact input for swaps, which is recommended\n        if (tokenInRefund != 0) {\n            swapParams.swapTokenIn.safeTransfer(recipient, tokenInRefund);\n        }\n    }\n\n    function _createOrder(\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint256 amountIn,\n        uint96 existingOrderId,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 feeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage\n    ) internal {\n        //verify both oracles exist, as we need both to calc the exchange rate\n        require(\n            address(MASTER.oracles(tokenIn)) != address(0x0) &&\n                address(MASTER.oracles(tokenIn)) != address(0x0),\n            \"Oracle !exist\"\n        );\n        require(\n            pendingOrderIds.length < MASTER.maxPendingOrders(),\n            \"Max Order Count Reached\"\n        );\n        require(\n            stopSlippage <= 10000 &&\n                takeProfitSlippage <= 10000 &&\n                feeBips <= 10000,\n            \"BIPS > 10k\"\n        );\n\n        MASTER.checkMinOrderSize(tokenIn, amountIn);\n\n        //generate random but unique order id if there is not an existing orderId from a stop limit order\n        if (existingOrderId == 0) {\n            existingOrderId = MASTER.generateOrderId(msg.sender);\n        }\n\n        //construct order\n        orders[existingOrderId] = Order({\n            orderId: existingOrderId,\n            takeProfit: takeProfit,\n            stopPrice: stopPrice,\n            amountIn: amountIn,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            recipient: recipient,\n            takeProfitSlippage: takeProfitSlippage,\n            feeBips: feeBips,\n            stopSlippage: stopSlippage,\n            direction: MASTER.getExchangeRate(tokenIn, tokenOut) > takeProfit //exchangeRate in/out > takeProfit\n        });\n\n        //store pending order\n        pendingOrderIds.push(existingOrderId);\n\n        emit OrderCreated(existingOrderId);\n    }\n\n    function _cancelOrder(Order memory order) internal returns (bool) {\n        for (uint96 i = 0; i < pendingOrderIds.length; i++) {\n            if (pendingOrderIds[i] == order.orderId) {\n                //remove from pending array\n                pendingOrderIds = ArrayMutation.removeFromArray(\n                    i,\n                    pendingOrderIds\n                );\n\n                //refund tokenIn amountIn to recipient\n                order.tokenIn.safeTransfer(order.recipient, order.amountIn);\n\n                //emit event\n                emit OrderCancelled(order.orderId);\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    ///@notice execute swap transaction\n    ///@param target is the contract to which we are sending @param txData to perform the swap\n    ///@param tokenIn is the token to sell for @param tokenOut\n    ///@param bips ensures that we received at least the minimum amount of @param tokenOut after the swap\n    function execute(\n        address target,\n        bytes memory txData,\n        uint256 amountIn,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint16 bips\n    ) internal returns (uint256 swapAmountOut, uint256 tokenInRefund) {\n        //update accounting\n        uint256 initialTokenIn = tokenIn.balanceOf(address(this));\n        uint256 initialTokenOut = tokenOut.balanceOf(address(this));\n\n        //approve\n        tokenIn.safeApprove(target, amountIn);\n\n        //perform the call\n        (bool success, bytes memory result) = target.call(txData);\n\n        if (success) {\n            uint256 finalTokenIn = tokenIn.balanceOf(address(this));\n            require(finalTokenIn >= initialTokenIn - amountIn, \"over spend\");\n            uint256 finalTokenOut = tokenOut.balanceOf(address(this));\n\n            //if success, we expect tokenIn balance to decrease by amountIn\n            //and tokenOut balance to increase by at least minAmountReceived\n            require(\n                finalTokenOut - initialTokenOut >\n                    MASTER.getMinAmountReceived(\n                        amountIn,\n                        tokenIn,\n                        tokenOut,\n                        bips\n                    ),\n                \"Too Little Received\"\n            );\n\n            swapAmountOut = finalTokenOut - initialTokenOut;\n            tokenInRefund = amountIn - (initialTokenIn - finalTokenIn);\n        } else {\n            //force revert\n            revert TransactionFailed(result);\n        }\n    }\n\n    ///@notice handle signature and acquisition of asset with permit2\n    function handlePermit(\n        address owner,\n        bytes calldata permitPayload,\n        uint160 amount,\n        address token\n    ) internal {\n        Permit2Payload memory payload = abi.decode(\n            permitPayload,\n            (Permit2Payload)\n        );\n\n        permit2.permit(owner, payload.permitSingle, payload.signature);\n        permit2.transferFrom(owner, address(this), amount, token);\n    }\n    ///@notice determine @param order order is fillable\n    ///\n    function checkInRange(\n        Order memory order\n    )\n        internal\n        view\n        returns (bool inRange, bool takeProfit, uint256 exchangeRate)\n    {\n        exchangeRate = MASTER.getExchangeRate(order.tokenIn, order.tokenOut);\n        if (order.direction) {\n            //check for take profit price\n            if (exchangeRate <= order.takeProfit) {\n                return (true, true, exchangeRate);\n            }\n            //check for stop price\n            if (exchangeRate >= order.stopPrice) {\n                return (true, false, exchangeRate);\n            }\n        } else {\n            //check for take profit price\n            if (exchangeRate >= order.takeProfit) {\n                return (true, true, exchangeRate);\n            }\n            //check for stop price\n            if (exchangeRate <= order.stopPrice) {\n                return (true, false, exchangeRate);\n            }\n        }\n    }\n\n    ///@notice apply the protocol fee to @param amount\n    ///@notice fee is in the form of tokenOut after a successful performUpkeep\n    function applyFee(\n        uint256 amount,\n        uint16 feeBips\n    ) internal pure returns (uint256 feeAmount, uint256 adjustedAmount) {\n        if (feeBips != 0) {\n            //determine adjusted amount and fee amount\n            adjustedAmount = (amount * (10000 - feeBips)) / 10000;\n            feeAmount = amount - adjustedAmount;\n        } else {\n            return (0, amount);\n        }\n    }\n}\n",
        "AutomationMaster.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IAutomation.sol\";\nimport \"../libraries/ArrayMutation.sol\";\nimport \"../interfaces/openzeppelin/Ownable.sol\";\nimport \"../interfaces/openzeppelin/ERC20.sol\";\nimport \"../interfaces/openzeppelin/IERC20.sol\";\nimport \"../interfaces/openzeppelin/SafeERC20.sol\";\nimport \"../oracle/IPythRelay.sol\";\n\n///@notice This contract owns and handles all of the settings and accounting logic for automated swaps\n///@notice This contract should not hold any user funds, only collected fees\ncontract AutomationMaster is IAutomationMaster, Ownable {\n    using SafeERC20 for IERC20;\n\n    ///@notice maximum pending orders that may exist at a time, limiting the compute requriement for checkUpkeep\n    uint16 public maxPendingOrders;\n\n    ///@notice minumum USD value required to create a new order, in 1e8 terms\n    uint256 public minOrderSize;\n\n    ///sub keeper contracts\n    IStopLimit public STOP_LIMIT_CONTRACT;\n    IBracket public BRACKET_CONTRACT;\n\n    ///each token must have a registered oracle in order to be tradable\n    mapping(IERC20 => IPythRelay) public oracles;\n    mapping(IERC20 => bytes32) public pythIds;\n\n    ///@notice register Stop Limit and Bracket order contracts\n    function registerSubKeepers(\n        IStopLimit stopLimitContract,\n        IBracket bracketContract\n    ) external onlyOwner {\n        STOP_LIMIT_CONTRACT = stopLimitContract;\n        BRACKET_CONTRACT = bracketContract;\n    }\n\n    ///@notice Registered Oracles are expected to return the USD price in 1e8 terms\n    function registerOracle(\n        IERC20[] calldata _tokens,\n        IPythRelay[] calldata _oracles\n    ) external onlyOwner {\n        require(_tokens.length == _oracles.length, \"Array Length Mismatch\");\n        for (uint i = 0; i < _tokens.length; i++) {\n            oracles[_tokens[i]] = _oracles[i];\n        }\n    }\n\n    ///@notice set max pending orders, limiting checkUpkeep compute requirement\n    function setMaxPendingOrders(uint16 _max) external onlyOwner {\n        maxPendingOrders = _max;\n    }\n\n    ///@param usdValue must be in 1e8 terms\n    function setMinOrderSize(uint256 usdValue) external onlyOwner {\n        minOrderSize = usdValue;\n    }\n\n    ///@notice sweep the entire balance of @param token to the owner\n    ///@notice this contract should not hold funds other than collected fees,\n    ///which are forwarded here after each transaction\n    function sweep(IERC20 token) external onlyOwner {\n        token.safeTransfer(owner(), token.balanceOf(address(this)));\n    }\n\n    ///@notice Registered Oracles are expected to return the USD price in 1e8 terms\n    ///@return exchangeRate should always be in 1e8 terms\n    function getExchangeRate(\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) external view override returns (uint256 exchangeRate) {\n        return _getExchangeRate(tokenIn, tokenOut);\n    }\n\n    function _getExchangeRate(\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) internal view returns (uint256 exchangeRate) {\n        // Retrieve USD prices from oracles, scaled to 1e8\n        uint256 priceIn = oracles[tokenIn].currentValue();\n        uint256 priceOut = oracles[tokenOut].currentValue();\n\n        // Return the exchange rate in 1e8 terms\n        return (priceIn * 1e8) / priceOut;\n    }\n\n    ///@notice generate a random and unique order id\n    function generateOrderId(address sender) external view override returns (uint96) {\n        uint256 hashedValue = uint256(\n            keccak256(abi.encodePacked(sender, block.timestamp))\n        );\n        return uint96(hashedValue);\n    }\n\n    ///@notice compute minumum amount received\n    ///@return minAmountReceived is in @param tokenOut terms\n    ///@param slippageBips is in raw basis points\n    function getMinAmountReceived(\n        uint256 amountIn,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint96 slippageBips\n    ) external view override returns (uint256 minAmountReceived) {\n        uint256 exchangeRate = _getExchangeRate(tokenIn, tokenOut);\n\n        // Adjust for decimal differences between tokens\n        uint256 adjustedAmountIn = adjustForDecimals(\n            amountIn,\n            tokenIn,\n            tokenOut\n        );\n\n        // Calculate the fair amount out without slippage\n        uint256 fairAmountOut = (adjustedAmountIn * exchangeRate) / 1e8;\n\n        // Apply slippage - 10000 bips is equivilant to 100% slippage\n        return (fairAmountOut * (10000 - slippageBips)) / 10000;\n    }\n\n    ///@notice account for token scale when computing token amounts based on slippage bips\n    function adjustForDecimals(\n        uint256 amountIn,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) internal view returns (uint256 adjustedAmountIn) {\n        uint8 decimalIn = ERC20(address(tokenIn)).decimals();\n        uint8 decimalOut = ERC20(address(tokenOut)).decimals();\n\n        if (decimalIn > decimalOut) {\n            // Reduce amountIn to match the lower decimals of tokenOut\n            return amountIn / (10 ** (decimalIn - decimalOut));\n        } else if (decimalIn < decimalOut) {\n            // Increase amountIn to match the higher decimals of tokenOut\n            return amountIn * (10 ** (decimalOut - decimalIn));\n        }\n        // If decimals are the same, no adjustment needed\n        return amountIn;\n    }\n\n    ///@notice determine if a new order meets the minimum order size requirement\n    ///Value of @param amountIn of @param tokenIn must meed the minimum USD value\n    function checkMinOrderSize(IERC20 tokenIn, uint256 amountIn) external view override {\n        uint256 currentPrice = oracles[tokenIn].currentValue();\n        uint256 usdValue = (currentPrice * amountIn) /\n            (10 ** ERC20(address(tokenIn)).decimals());\n\n        require(usdValue > minOrderSize, \"order too small\");\n    }\n\n    ///@notice check upkeep on all order types\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        //check stop limit order\n        (upkeepNeeded, performData) = STOP_LIMIT_CONTRACT.checkUpkeep(\"0x\");\n        if (upkeepNeeded) {\n            return (true, performData);\n        }\n\n        //check bracket order\n        (upkeepNeeded, performData) = BRACKET_CONTRACT.checkUpkeep(\"0x\");\n        if (upkeepNeeded) {\n            return (true, performData);\n        }\n    }\n\n    ///@notice perform upkeep on any order type\n    function performUpkeep(bytes calldata performData) external override {\n        //decode into masterUpkeepData\n        MasterUpkeepData memory data = abi.decode(\n            performData,\n            (MasterUpkeepData)\n        );\n\n        //if stop order, we directly pass the upkeep data to the stop order contract\n        if (data.orderType == OrderType.STOP_LIMIT) {\n            STOP_LIMIT_CONTRACT.performUpkeep(performData);\n        }\n\n        //if stop order, we directly pass the upkeep data to the stop order contract\n        if (data.orderType == OrderType.BRACKET) {\n            BRACKET_CONTRACT.performUpkeep(performData);\n        }\n    }\n}\n",
        "OracleLess.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\nimport \"../interfaces/openzeppelin/Ownable.sol\";\nimport \"../interfaces/openzeppelin/IERC20.sol\";\nimport \"../interfaces/openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/openzeppelin/ReentrancyGuard.sol\";\nimport \"./AutomationMaster.sol\";\nimport \"../libraries/ArrayMutation.sol\";\n\ncontract OracleLess is IOracleLess, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    AutomationMaster public immutable MASTER;\n    IPermit2 public immutable permit2;\n\n    uint96[] public pendingOrderIds;\n\n    mapping(uint96 => Order) public orders;\n\n    constructor(AutomationMaster _master, IPermit2 _permit2) {\n        MASTER = _master;\n        permit2 = _permit2;\n    }\n\n    ///@return pendingOrders a full list of all pending orders with full order details\n    ///@notice this should not be called in a write function due to gas usage\n    function getPendingOrders()\n        external\n        view\n        returns (Order[] memory pendingOrders)\n    {\n        pendingOrders = new Order[](pendingOrderIds.length);\n        for (uint96 i = 0; i < pendingOrderIds.length; i++) {\n            Order memory order = orders[pendingOrderIds[i]];\n            pendingOrders[i] = order;\n        }\n    }\n\n    function createOrder(\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint16 feeBips,\n        bool permit,\n        bytes calldata permitPayload\n    ) external override returns (uint96 orderId) {\n        //procure tokens\n        procureTokens(tokenIn, amountIn, recipient, permit, permitPayload);\n\n        //construct and store order\n        orderId = MASTER.generateOrderId(recipient);\n        orders[orderId] = Order({\n            orderId: orderId,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            amountIn: amountIn,\n            minAmountOut: minAmountOut,\n            recipient: recipient,\n            feeBips: feeBips\n        });\n\n        //store pending order\n        pendingOrderIds.push(orderId);\n\n        emit OrderCreated(orderId);\n    }\n\n    function adminCancelOrder(uint96 orderId) external onlyOwner {\n        Order memory order = orders[orderId];\n        require(_cancelOrder(order), \"Order not active\");\n    }\n\n    function cancelOrder(uint96 orderId) external override {\n        Order memory order = orders[orderId];\n        require(msg.sender == order.recipient, \"Only Order Owner\");\n        require(_cancelOrder(order), \"Order not active\");\n    }\n\n    function modifyOrder(\n        uint96 orderId,\n        IERC20 _tokenOut,\n        uint256 amountInDelta,\n        uint256 _minAmountOut,\n        address _recipient,\n        bool increasePosition,\n        bool permit,\n        bytes calldata permitPayload\n    ) external override {\n        _modifyOrder(\n            orderId,\n            _tokenOut,\n            amountInDelta,\n            _minAmountOut,\n            _recipient,\n            increasePosition,\n            permit,\n            permitPayload\n        );\n        emit OrderModified(orderId);\n    }\n\n    function fillOrder(\n        uint96 pendingOrderIdx,\n        uint96 orderId,\n        address target,\n        bytes calldata txData\n    ) external override {\n        //fetch order\n        Order memory order = orders[orderId];\n\n        require(\n            order.orderId == pendingOrderIds[pendingOrderIdx],\n            \"Order Fill Mismatch\"\n        );\n\n        //perform swap\n        (uint256 amountOut, uint256 tokenInRefund) = execute(\n            target,\n            txData,\n            order\n        );\n\n        //handle accounting\n        //remove from array\n        pendingOrderIds = ArrayMutation.removeFromArray(\n            pendingOrderIdx,\n            pendingOrderIds\n        );\n\n        //handle fee\n        (uint256 feeAmount, uint256 adjustedAmount) = applyFee(\n            amountOut,\n            order.feeBips\n        );\n        if (feeAmount != 0) {\n            order.tokenOut.safeTransfer(address(MASTER), feeAmount);\n        }\n\n        //send tokenOut to recipient\n        order.tokenOut.safeTransfer(order.recipient, adjustedAmount);\n\n        //refund any unspent tokenIn\n        //this should generally be 0 when using exact input for swaps, which is recommended\n        if (tokenInRefund != 0) {\n            order.tokenIn.safeTransfer(order.recipient, tokenInRefund);\n        }\n    }\n\n    function _cancelOrder(Order memory order) internal returns (bool) {\n        for (uint96 i = 0; i < pendingOrderIds.length; i++) {\n            if (pendingOrderIds[i] == order.orderId) {\n                //remove from pending array\n                pendingOrderIds = ArrayMutation.removeFromArray(\n                    i,\n                    pendingOrderIds\n                );\n\n                //refund tokenIn amountIn to recipient\n                order.tokenIn.safeTransfer(order.recipient, order.amountIn);\n\n                //emit event\n                emit OrderCancelled(order.orderId);\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _modifyOrder(\n        uint96 orderId,\n        IERC20 _tokenOut,\n        uint256 amountInDelta,\n        uint256 _minAmountOut,\n        address _recipient,\n        bool increasePosition,\n        bool permit,\n        bytes calldata permitPayload\n    ) internal {\n        //fetch order\n        Order memory order = orders[orderId];\n\n        require(msg.sender == order.recipient, \"only order owner\");\n\n        //deduce any amountIn changes\n        uint256 newAmountIn = order.amountIn;\n        if (amountInDelta != 0) {\n            if (increasePosition) {\n                //take more tokens from order recipient\n                newAmountIn += amountInDelta;\n                procureTokens(\n                    order.tokenIn,\n                    amountInDelta,\n                    order.recipient,\n                    permit,\n                    permitPayload\n                );\n            } else {\n                //refund some tokens\n                //ensure delta is valid\n                require(amountInDelta < order.amountIn, \"invalid delta\");\n\n                //set new amountIn for accounting\n                newAmountIn -= amountInDelta;\n\n                //refund position partially\n                order.tokenIn.safeTransfer(order.recipient, amountInDelta);\n            }\n        }\n\n        //construct new order\n        Order memory newOrder = Order({\n            orderId: orderId,\n            tokenIn: order.tokenIn,\n            tokenOut: _tokenOut,\n            amountIn: newAmountIn,\n            minAmountOut: _minAmountOut,\n            feeBips: order.feeBips,\n            recipient: _recipient\n        });\n\n        //store new order\n        orders[orderId] = newOrder;\n    }\n\n    function execute(\n        address target,\n        bytes calldata txData,\n        Order memory order\n    ) internal returns (uint256 amountOut, uint256 tokenInRefund) {\n        //update accounting\n        uint256 initialTokenIn = order.tokenIn.balanceOf(address(this));\n        uint256 initialTokenOut = order.tokenOut.balanceOf(address(this));\n\n        //approve\n        order.tokenIn.safeApprove(target, order.amountIn);\n\n        //perform the call\n        (bool success, bytes memory reason) = target.call(txData);\n\n        if (!success) {\n            revert TransactionFailed(reason);\n        }\n\n        uint256 finalTokenIn = order.tokenIn.balanceOf(address(this));\n        require(finalTokenIn >= initialTokenIn - order.amountIn, \"over spend\");\n        uint256 finalTokenOut = order.tokenOut.balanceOf(address(this));\n\n        require(\n            finalTokenOut - initialTokenOut > order.minAmountOut,\n            \"Too Little Received\"\n        );\n\n        amountOut = finalTokenOut - initialTokenOut;\n        tokenInRefund = order.amountIn - (initialTokenIn - finalTokenIn);\n    }\n\n    function procureTokens(\n        IERC20 token,\n        uint256 amount,\n        address owner,\n        bool permit,\n        bytes calldata permitPayload\n    ) internal {\n        if (permit) {\n            IAutomation.Permit2Payload memory payload = abi.decode(\n                permitPayload,\n                (IAutomation.Permit2Payload)\n            );\n\n            permit2.permit(owner, payload.permitSingle, payload.signature);\n            permit2.transferFrom(\n                owner,\n                address(this),\n                uint160(amount),\n                address(token)\n            );\n        } else {\n            token.safeTransferFrom(owner, address(this), amount);\n        }\n    }\n\n    ///@notice apply the protocol fee to @param amount\n    ///@notice fee is in the form of tokenOut after a successful performUpkeep\n    function applyFee(\n        uint256 amount,\n        uint16 feeBips\n    ) internal pure returns (uint256 feeAmount, uint256 adjustedAmount) {\n        if (feeBips != 0) {\n            //determine adjusted amount and fee amount\n            adjustedAmount = (amount * (10000 - feeBips)) / 10000;\n            feeAmount = amount - adjustedAmount;\n        } else {\n            return (0, amount);\n        }\n    }\n}\n",
        "ArrayMutation.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport \"../interfaces/uniswapV3/UniswapV3Pool.sol\";\n\nlibrary ArrayMutation {\n    ///@param idx the element to remove from @param inputArray\n    function removeFromArray(\n        uint96 idx,\n        uint96[] memory inputArray\n    ) internal pure returns (uint96[] memory newList) {\n        // Check that inputArray is not empty and idx is valid\n        require(inputArray.length > 0, \"inputArray length == 0\");\n        require(idx < inputArray.length, \"index out of bounds\");\n\n        // Create a new array of the appropriate size\n        newList = new uint96[](inputArray.length - 1);\n\n        // Copy elements before the index\n        for (uint96 i = 0; i < idx; i++) {\n            newList[i] = inputArray[i];\n        }\n\n        // Copy elements after the index\n        for (uint96 i = idx + 1; i < inputArray.length; i++) {\n            newList[i - 1] = inputArray[i];\n        }\n\n        return newList;\n    }\n}\n",
        "StopLimit.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IAutomation.sol\";\nimport \"../libraries/ArrayMutation.sol\";\nimport \"../interfaces/uniswapV3/IPermit2.sol\";\nimport \"../interfaces/openzeppelin/Ownable.sol\";\nimport \"../interfaces/openzeppelin/IERC20.sol\";\nimport \"../interfaces/openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/openzeppelin/ReentrancyGuard.sol\";\n\n///@notice This contract owns and handles all logic associated with STOP_LIMIT orders\n///STOP_LIMIT orders create a new Bracket order order with the same order ID once filled\ncontract StopLimit is Ownable, IStopLimit, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IAutomationMaster public immutable MASTER;\n    IBracket public immutable BRACKET_CONTRACT;\n    IPermit2 public immutable permit2;\n\n    uint96[] public pendingOrderIds;\n\n    mapping(uint96 => Order) public orders;\n\n    constructor(\n        IAutomationMaster _master,\n        IBracket _bracket,\n        IPermit2 _permit2\n    ) {\n        MASTER = _master;\n        BRACKET_CONTRACT = _bracket;\n        permit2 = _permit2;\n    }\n\n    function getPendingOrders() external view returns (uint96[] memory) {\n        return pendingOrderIds;\n    }\n\n    ///@notice this should never be called inside of a write function due to high gas usage\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        for (uint96 i = 0; i < pendingOrderIds.length; i++) {\n            Order memory order = orders[pendingOrderIds[i]];\n            (bool inRange, uint256 exchangeRate) = checkInRange(order);\n            if (inRange) {\n                return (\n                    true,\n                    abi.encode(\n                        MasterUpkeepData({\n                            orderType: OrderType.STOP_LIMIT,\n                            target: address(this),\n                            txData: order.swapOnFill\n                                ? abi.encodePacked(true)\n                                : abi.encodePacked(false), //specify if swapOnFill is true\n                            pendingOrderIdx: i,\n                            orderId: order.orderId,\n                            tokenIn: order.tokenIn,\n                            tokenOut: order.tokenOut,\n                            slippage: order.swapSlippage,\n                            amountIn: order.amountIn,\n                            exchangeRate: exchangeRate\n                        })\n                    )\n                );\n            }\n        }\n    }\n\n    function performUpkeep(\n        bytes calldata performData\n    ) external override nonReentrant {\n        MasterUpkeepData memory data = abi.decode(\n            performData,\n            (MasterUpkeepData)\n        );\n        Order memory order = orders[pendingOrderIds[data.pendingOrderIdx]];\n\n        require(\n            order.orderId == pendingOrderIds[data.pendingOrderIdx],\n            \"Order Fill Mismatch\"\n        );\n\n        //confirm order is in range to prevent improper fill\n        (bool inRange, ) = checkInRange(order);\n        require(inRange, \"order ! in range\");\n\n        //remove from pending array\n        pendingOrderIds = ArrayMutation.removeFromArray(\n            data.pendingOrderIdx,\n            pendingOrderIds\n        );\n\n        //approve\n        updateApproval(\n            address(BRACKET_CONTRACT),\n            order.tokenIn,\n            order.amountIn\n        );\n\n        bytes memory swapPayload;\n        IERC20 tokenIn = order.tokenIn;\n        IERC20 tokenOut = order.tokenOut;\n        if (order.swapOnFill) {\n            //for swap on fill, we expect to be paid out in the same asset we provided\n            //so the resulting order tokenIn and tokenOut are inverted relative to our original swap limit order\n            SwapParams memory params = SwapParams({\n                swapTokenIn: order.tokenIn, //asset provided\n                swapAmountIn: order.amountIn,\n                swapTarget: data.target,\n                swapSlippage: order.swapSlippage,\n                txData: data.txData\n            });\n            swapPayload = abi.encode(params);\n\n            tokenIn = order.tokenOut;\n            tokenOut = order.tokenIn;\n        }\n\n        //create bracket order\n        BRACKET_CONTRACT.fillStopLimitOrder(\n            swapPayload,\n            order.takeProfit,\n            order.stopPrice,\n            order.amountIn,\n            order.orderId,\n            tokenIn,\n            tokenOut,\n            order.recipient,\n            order.feeBips,\n            order.takeProfitSlippage,\n            order.stopSlippage,\n            false, //permit\n            \"0x\" //permitPayload\n        );\n\n        emit OrderProcessed(order.orderId);\n    }\n\n    ///@notice see @IStopLimit\n    function createOrder(\n        uint256 stopLimitPrice,\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint256 amountIn,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 feeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage,\n        uint16 swapSlippage,\n        bool swapOnFill,\n        bool permit,\n        bytes calldata permitPayload\n    ) external override nonReentrant {\n        if (permit) {\n            handlePermit(\n                recipient,\n                permitPayload,\n                uint160(amountIn),\n                address(tokenIn)\n            );\n        } else {\n            //take asset, assume prior approval\n            tokenIn.safeTransferFrom(recipient, address(this), amountIn);\n        }\n\n        _createOrder(\n            stopLimitPrice,\n            takeProfit,\n            stopPrice,\n            amountIn,\n            tokenIn,\n            tokenOut,\n            recipient,\n            feeBips,\n            takeProfitSlippage,\n            stopSlippage,\n            swapSlippage,\n            swapOnFill\n        );\n    }\n\n    ///@notice see @IStopLimit\n    function modifyOrder(\n        uint96 orderId,\n        uint256 _stopLimitPrice,\n        uint256 _takeProfit,\n        uint256 _stopPrice,\n        uint256 _amountInDelta,\n        IERC20 _tokenOut,\n        address _recipient,\n        uint16 _takeProfitSlippage,\n        uint16 _stopSlippage,\n        uint16 _swapSlippage,\n        bool _swapOnFill,\n        bool permit,\n        bool increasePosition,\n        bytes calldata permitPayload\n    ) external override nonReentrant {\n        //get existing order\n        Order memory order = orders[orderId];\n        //only order owner\n        require(msg.sender == order.recipient, \"only order owner\");\n        //deduce any amountIn changes\n        uint256 newAmountIn = order.amountIn;\n        if (_amountInDelta != 0) {\n            if (increasePosition) {\n                newAmountIn += _amountInDelta;\n                //take funds via permit2\n                if (permit) {\n                    handlePermit(\n                        order.recipient,\n                        permitPayload,\n                        uint160(_amountInDelta),\n                        address(order.tokenIn)\n                    );\n                } else {\n                    //legacy transfer, assume prior approval\n                    order.tokenIn.safeTransferFrom(\n                        order.recipient,\n                        address(this),\n                        _amountInDelta\n                    );\n                }\n            } else {\n                //ensure delta is valid\n                require(_amountInDelta < order.amountIn, \"invalid delta\");\n\n                //set new amountIn for accounting\n                newAmountIn -= _amountInDelta;\n\n                //check min order size for new amount\n                MASTER.checkMinOrderSize(order.tokenIn, newAmountIn);\n\n                //refund position partially\n                order.tokenIn.safeTransfer(order.recipient, _amountInDelta);\n\n                //check slippage\n                require(\n                    _takeProfitSlippage <= 10000 &&\n                        _stopSlippage <= 10000 &&\n                        _swapSlippage <= 10000,\n                    \"BIPS > 10k\"\n                );\n            }\n        }\n\n        //check for oracles\n        if (_tokenOut != order.tokenOut) {\n            require(\n                address(MASTER.oracles(_tokenOut)) != address(0x0),\n                \"Oracle !exist\"\n            );\n        }\n\n        //construct order\n        Order memory newOrder = Order({\n            orderId: orderId,\n            stopLimitPrice: _stopLimitPrice,\n            takeProfit: _takeProfit,\n            stopPrice: _stopPrice,\n            amountIn: newAmountIn,\n            tokenIn: order.tokenIn,\n            tokenOut: _tokenOut,\n            feeBips: order.feeBips,\n            takeProfitSlippage: _takeProfitSlippage,\n            stopSlippage: _stopSlippage,\n            swapSlippage: _swapSlippage,\n            recipient: _recipient,\n            direction: MASTER.getExchangeRate(order.tokenIn, _tokenOut) >\n                _stopLimitPrice,\n            swapOnFill: _swapOnFill\n        });\n\n        //store new order\n        orders[orderId] = newOrder;\n    }\n\n    ///@notice contract owner can cancel any order\n    ///@notice cancelled orders refund the order recipient\n    function adminCancelOrder(uint96 orderId) external onlyOwner {\n        _cancelOrder(orderId);\n    }\n\n    ///@notice only the order recipient can cancel their order\n    ///@notice only pending orders can be cancelled\n    function cancelOrder(uint96 orderId) external {\n        Order memory order = orders[orderId];\n        require(msg.sender == order.recipient, \"Only Order Owner\");\n        require(_cancelOrder(orderId), \"Order not active\");\n    }\n\n    function _createOrder(\n        uint256 stopLimitPrice,\n        uint256 takeProfit,\n        uint256 stopPrice,\n        uint256 amountIn,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        address recipient,\n        uint16 feeBips,\n        uint16 takeProfitSlippage,\n        uint16 stopSlippage,\n        uint16 swapSlippage,\n        bool swapOnFill\n    ) internal {\n        //verify both oracles exist, as we need both to calc the exchange rate\n        require(\n            address(MASTER.oracles(tokenIn)) != address(0x0) &&\n                address(MASTER.oracles(tokenOut)) != address(0x0),\n            \"Oracle !exist\"\n        );\n        require(\n            pendingOrderIds.length < MASTER.maxPendingOrders(),\n            \"Max Order Count Reached\"\n        );\n        require(\n            takeProfitSlippage <= 10000 &&\n                stopSlippage <= 10000 &&\n                swapSlippage <= 10000 &&\n                feeBips <= 10000,\n            \"BIPS > 10k\"\n        );\n\n        MASTER.checkMinOrderSize(tokenIn, amountIn);\n\n        uint96 orderId = MASTER.generateOrderId(msg.sender);\n\n        orders[orderId] = Order({\n            orderId: orderId,\n            stopLimitPrice: stopLimitPrice,\n            stopPrice: stopPrice,\n            takeProfit: takeProfit,\n            amountIn: amountIn,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            takeProfitSlippage: takeProfitSlippage,\n            feeBips: feeBips,\n            stopSlippage: stopSlippage,\n            swapSlippage: swapSlippage,\n            recipient: recipient,\n            direction: MASTER.getExchangeRate(tokenIn, tokenOut) >\n                stopLimitPrice, //compare to stop price for this order's direction\n            swapOnFill: swapOnFill\n        });\n        pendingOrderIds.push(uint96(orderId));\n        //emit\n        emit OrderCreated(orderId);\n    }\n\n    function _cancelOrder(uint96 orderId) internal returns (bool) {\n        Order memory order = orders[orderId];\n        for (uint96 i = 0; i < pendingOrderIds.length; i++) {\n            if (pendingOrderIds[i] == orderId) {\n                //remove from pending array\n                pendingOrderIds = ArrayMutation.removeFromArray(\n                    i,\n                    pendingOrderIds\n                );\n                order.tokenIn.safeTransfer(order.recipient, order.amountIn);\n\n                //emit event\n                emit OrderCancelled(orderId);\n\n                //short circuit loop\n                return true;\n            }\n        }\n        return false;\n    }\n\n    ///@notice handle signature and acquisition of asset with permit2\n    function handlePermit(\n        address owner,\n        bytes calldata permitPayload,\n        uint160 amount,\n        address token\n    ) internal {\n        Permit2Payload memory payload = abi.decode(\n            permitPayload,\n            (Permit2Payload)\n        );\n\n        permit2.permit(owner, payload.permitSingle, payload.signature);\n        permit2.transferFrom(owner, address(this), amount, token);\n    }\n\n    ///@notice if current approval is insufficient, approve max\n    ///@notice oz safeIncreaseAllowance controls for tokens that require allowance to be reset to 0 before increasing again\n    function updateApproval(\n        address spender,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        // get current allowance\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            // amount is a delta, so need to pass max - current to avoid overflow\n            token.safeIncreaseAllowance(\n                spender,\n                type(uint256).max - currentAllowance\n            );\n        }\n    }\n\n    ///@notice check if the order is fillable\n    function checkInRange(\n        Order memory order\n    ) internal view returns (bool inRange, uint256 exchangeRate) {\n        exchangeRate = MASTER.getExchangeRate(order.tokenIn, order.tokenOut);\n        if (order.direction) {\n            if (exchangeRate <= order.stopLimitPrice) {\n                inRange = true;\n            }\n        } else {\n            if (exchangeRate >= order.stopLimitPrice) {\n                inRange = true;\n            }\n        }\n    }\n}\n",
        "SafeERC20.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    }
}