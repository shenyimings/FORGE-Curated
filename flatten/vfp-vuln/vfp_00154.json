{
    "vfp_id": "vfp_00154",
    "project_name": "ChainSecurity_Polymarket_UMASportsOracle_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "UMA Oracle Allows Creating Undisputable Games",
            "description": "A vulnerability exists in the integration between UmaSportsOracle and UMA's OptimisticOracleV2, where oracle requests with more than 8066 bytes of ancillary data can be created but not disputed. The root cause lies in the fact that while OptimisticOracleV2 allows up to 8139 bytes of ancillary data, the dispute process fails due to size constraints in the cross-chain bridging mechanism (OracleChildTunnel), which appends metadata and causes the total size to exceed the 8192-byte limit enforced by OracleBaseTunnel. As a result, disputes revert, making such oracle requests effectively undisputable. An attacker could exploit this by creating a game with large ancillary data, proposing an incorrect result, and ensuring it is accepted without dispute due to the inability to challenge it. This leads to incorrect resolution of sports markets tied to the game, resulting in unfair payouts and loss of user funds.\n",
            "severity": "Medium",
            "location": [
                "UmaSportsOracle.sol",
                "OptimisticOracleV2.sol::disputePrice#",
                "OracleChildTunnel.sol::_requestPrice",
                "OracleBaseTunnel.sol::_requestPrice"
            ],
            "files": [
                "bcdad43734cf94a3a8c0a5020b10edc7df4f2450/protocol/packages/monitor-v2/src/monitor-polymarket/abi/umaSportsOracle.json",
                "bcdad43734cf94a3a8c0a5020b10edc7df4f2450/protocol/packages/core/contracts/polygon-cross-chain-oracle/OracleChildTunnel.sol",
                "bcdad43734cf94a3a8c0a5020b10edc7df4f2450/protocol/packages/core/contracts/polygon-cross-chain-oracle/OracleBaseTunnel.sol"
            ]
        }
    ],
    "affected_files": {
        "OracleChildTunnel.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseChildTunnel.sol\";\nimport \"../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\nimport \"../data-verification-mechanism/interfaces/RegistryInterface.sol\";\nimport \"./OracleBaseTunnel.sol\";\nimport \"../common/implementation/AncillaryData.sol\";\nimport \"../common/implementation/Lockable.sol\";\n\n/**\n * @title Adapter deployed on sidechain to give financial contracts the ability to trigger cross-chain price requests to\n * the mainnet DVM. Also has the ability to receive published prices from mainnet. This contract can be treated as the\n * \"DVM\" for this network, because a calling contract can request and access a resolved price request from this\n * contract.\n * @dev The intended client of this contract is an OptimisticOracle on sidechain that needs price\n * resolution secured by the DVM on mainnet.\n */\ncontract OracleChildTunnel is OracleBaseTunnel, OracleAncillaryInterface, FxBaseChildTunnel, Lockable {\n    constructor(address _fxChild, address _finderAddress)\n        OracleBaseTunnel(_finderAddress)\n        FxBaseChildTunnel(_fxChild)\n    {}\n\n    // This assumes that the local network has a Registry that resembles the mainnet registry.\n    modifier onlyRegisteredContract() {\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\n        require(registry.isContractRegistered(msg.sender), \"Caller must be registered\");\n        _;\n    }\n\n    /**\n     * @notice This should be called to bridge a price request to mainnet.\n     * @dev Can be called only by a registered contract that is allowed to make DVM price requests. Will mark this\n     * price request as Requested, and therefore able to receive the price resolution data from mainnet. Emits a message\n     * that will be included in regular checkpoint of all sidechain transactions to mainnet.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request.\n     * @param ancillaryData extra data of price request.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override nonReentrant() onlyRegisteredContract() {\n        // This implementation allows duplicate price requests to emit duplicate MessageSent events via\n        // _sendMessageToRoot. The DVM will not have a problem handling duplicate requests (it will just ignore them).\n        // This is potentially a fallback in case the checkpointing to mainnet is missing the `requestPrice` transaction\n        // for some reason. There is little risk in duplicating MessageSent emissions because the sidechain bridge\n        // does not impose any rate-limiting and this method is only callable by registered callers.\n        _requestPrice(identifier, time, _stampAncillaryData(ancillaryData, msg.sender));\n        _sendMessageToRoot(abi.encode(identifier, time, _stampAncillaryData(ancillaryData, msg.sender)));\n    }\n\n    /**\n     * @notice Resolves a price request.\n     * @dev The data will be received automatically from the state receiver when the state is synced between Ethereum\n     * and Polygon. This will revert if the Root chain sender is not the `fxRootTunnel` contract.\n     * @param sender The sender of `data` from the Root chain.\n     * @param data ABI encoded params with which to call `_publishPrice`.\n     */\n    function _processMessageFromRoot(\n        uint256, /* stateId */\n        address sender,\n        bytes memory data\n    ) internal override validateSender(sender) {\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData, int256 price) =\n            abi.decode(data, (bytes32, uint256, bytes, int256));\n        _publishPrice(identifier, time, ancillaryData, price);\n    }\n\n    /**\n     * @notice Returns whether a price has resolved for the request.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request\n     * @param ancillaryData extra data of price request.\n     * @return True if a price is available, False otherwise. If true, then getPrice will succeed for the request.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (bool) {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(ancillaryData, msg.sender));\n        return prices[priceRequestId].state == RequestState.Resolved;\n    }\n\n    /**\n     * @notice Returns resolved price for the request.\n     * @dev Reverts if price is not available.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request\n     * @param ancillaryData extra data of price request.\n     * @return int256 Price, or reverts if no resolved price for any reason.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (int256) {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(ancillaryData, msg.sender));\n        Price storage lookup = prices[priceRequestId];\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\n        return lookup.price;\n    }\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        view\n        nonReentrantView()\n        returns (bytes memory)\n    {\n        return _stampAncillaryData(ancillaryData, requester);\n    }\n\n    /**\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translatable in utf8.\n     * For those cases, we assume that the client will be able to strip out the utf8-translatable part of the\n     * ancillary data that this contract stamps.\n     */\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal view returns (bytes memory) {\n        // Price requests that originate from this method, on Polygon, will ultimately be submitted to the DVM on\n        // Ethereum via the OracleRootTunnel. Therefore this contract should stamp its requester's address in the\n        // ancillary data so voters can conveniently track the requests path to the DVM.\n        return\n            AncillaryData.appendKeyValueUint(\n                AncillaryData.appendKeyValueAddress(ancillaryData, \"childRequester\", requester),\n                \"childChainId\",\n                block.chainid\n            );\n    }\n}\n",
        "OracleBaseTunnel.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\n\n/**\n * @notice Enforces lifecycle of price requests for deriving contract.\n */\nabstract contract OracleBaseTunnel {\n    enum RequestState { NeverRequested, Requested, Resolved }\n\n    struct Price {\n        RequestState state;\n        int256 price;\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be resolved by the DVM which refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    // Mapping of encoded price requests {identifier, time, ancillaryData} to Price objects.\n    mapping(bytes32 => Price) internal prices;\n\n    // Finder to provide addresses for DVM system contracts.\n    FinderInterface public finder;\n\n    event PriceRequestAdded(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bytes32 indexed requestHash);\n    event PushedPrice(\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        int256 price,\n        bytes32 indexed requestHash\n    );\n\n    /**\n     * @notice Constructor.\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\n     */\n    constructor(address _finderAddress) {\n        finder = FinderInterface(_finderAddress);\n    }\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given (identifier, time,\n     * ancillary data) combination. Will only emit an event if the request has never been requested.\n     */\n    function _requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) internal {\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        Price storage lookup = prices[priceRequestId];\n        if (lookup.state == RequestState.NeverRequested) {\n            lookup.state = RequestState.Requested;\n            emit PriceRequestAdded(identifier, time, ancillaryData, priceRequestId);\n        }\n    }\n\n    /**\n     * @notice Publishes price for a requested query. Will only emit an event if the request has never been resolved.\n     */\n    function _publishPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        int256 price\n    ) internal {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        Price storage lookup = prices[priceRequestId];\n        if (lookup.state == RequestState.Requested) {\n            lookup.price = price;\n            lookup.state = RequestState.Resolved;\n            emit PushedPrice(identifier, time, ancillaryData, lookup.price, priceRequestId);\n        }\n    }\n\n    /**\n     * @notice Returns the convenient way to store price requests, uniquely identified by {identifier, time,\n     * ancillaryData }.\n     */\n    function _encodePriceRequest(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(identifier, time, ancillaryData));\n    }\n}\n"
    }
}