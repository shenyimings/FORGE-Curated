{
    "vfp_id": "vfp_00026",
    "project_name": "OIF Broadcaster Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-346"
                ],
                "4": [
                    "CWE-940"
                ]
            },
            "title": "Potential for Arbitrary Application in Message Verification",
            "description": "This vulnerability allows an attacker to manipulate the application identifier during message verification. The issue arises because the broadcast message does not include the application address in its hash, despite the `source` field in the proof referencing it. As a result, when a user verifies a message on a destination chain, they can supply an arbitrary application address in the `messageData`, which is then stored in the `_attestations` mapping without validation against the original message. This could lead to message spoofing, where a malicious actor makes it appear as if a message originated from a trusted application. The impact includes loss of message authenticity, potential for unauthorized actions, and compromise of cross-chain trust assumptions.\n",
            "severity": "Critical",
            "location": [
                "BroadcasterOracle.sol::submit#108",
                "BroadcasterOracle.sol::verify#144-152",
                "BroadcasterOracle.sol::verify#82-83",
                "BroadcasterOracle.sol::verify#96"
            ],
            "files": [
                "acc7f9ca32ccd9e133f00c644251d7ff976edb24/src/integrations/oracles/broadcaster/BroadcasterOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "BroadcasterOracle.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { IAttester } from \"../../../interfaces/IAttester.sol\";\nimport { LibAddress } from \"../../../libs/LibAddress.sol\";\nimport { MessageEncodingLib } from \"../../../libs/MessageEncodingLib.sol\";\nimport { BaseInputOracle } from \"../../../oracles/BaseInputOracle.sol\";\nimport { ChainMap } from \"../../../oracles/ChainMap.sol\";\n\nimport { IBroadcaster } from \"broadcaster/interfaces/IBroadcaster.sol\";\nimport { IReceiver } from \"broadcaster/interfaces/IReceiver.sol\";\n\n/**\n * @notice Broadcaster Oracle\n * Implements a transparent oracle that allows both for broadcasting messages and verifying them at the destination,\n * relying on storage proofs. This oracle only works for communication between chains that are in the Ethereum\n * ecosystem, i.e., Ethereum and its rollups.\n * @dev In this oracle, `ChainMap` maps EVM `chainId` to `broadcasterId` (not to chain identifiers).\n * The `broadcasterId` depends on the configured `BlockHashProverPointer`; for each remote chain, only one pointer\n * (and thus one broadcasterId) is supported.\n */\ncontract BroadcasterOracle is BaseInputOracle, ChainMap {\n    using LibAddress for address;\n\n    /// @dev The receiver contract that will be used to verify the messages. ERC 7888 compliant.\n    IReceiver private immutable _receiver;\n    /// @dev The broadcaster contract that will be used to broadcast the messages. ERC 7888 compliant.\n    IBroadcaster private immutable _broadcaster;\n\n    /// @dev Error thrown when the payloads are not valid.\n    error NotAllPayloadsValid();\n    /// @dev Error thrown when the broadcaster id is invalid.\n    error InvalidBroadcasterId();\n    /// @dev Error thrown when the broadcaster is invalid.\n    error InvalidBroadcaster();\n    /// @dev Error thrown when the receiver is invalid.\n    error InvalidReceiver();\n\n    constructor(\n        IReceiver receiver_,\n        IBroadcaster broadcaster_,\n        address owner_\n    ) ChainMap(owner_) {\n        if (address(receiver_) == address(0)) revert InvalidReceiver();\n        if (address(broadcaster_) == address(0)) revert InvalidBroadcaster();\n        _receiver = receiver_;\n        _broadcaster = broadcaster_;\n    }\n\n    /**\n     * @notice Returns the receiver contract.\n     * @return The receiver contract.\n     */\n    function receiver() public view returns (IReceiver) {\n        return _receiver;\n    }\n\n    /**\n     * @notice Returns the broadcaster contract.\n     * @return The broadcaster contract.\n     */\n    function broadcaster() public view returns (IBroadcaster) {\n        return _broadcaster;\n    }\n\n    /**\n     * @notice Verifies a message broadcasted in a remote chain.\n     * @param broadcasterReadArgs The arguments required to read the broadcaster's account on the remote chain.\n     * @param remoteChainId The chain id of the remote chain.\n     * @param remoteOracle The address of the remote oracle.\n     * @param messageData The data of the message to verify.\n     * @dev In this oracle, `ChainMap` maps EVM `chainId` to `broadcasterId` (not to chain identifiers).\n     * The `broadcasterId` depends on the configured `BlockHashProverPointer`; for each remote chain, only one pointer\n     * (and thus one broadcasterId) is supported.\n     */\n    function verifyMessage(\n        IReceiver.RemoteReadArgs calldata broadcasterReadArgs,\n        uint256 remoteChainId,\n        address remoteOracle, // publisher\n        bytes calldata messageData\n    ) external {\n        (bytes32 application, bytes32[] memory payloadHashes) =\n            MessageEncodingLib.getHashesOfEncodedPayloads(messageData);\n\n        bytes32 message = _hashPayloadHashes(payloadHashes);\n\n        bytes32 broadcasterId = bytes32(reverseChainIdMap[remoteChainId]);\n\n        (bytes32 actualBroadcasterId,) = receiver().verifyBroadcastMessage(broadcasterReadArgs, message, remoteOracle);\n\n        if (actualBroadcasterId != broadcasterId) revert InvalidBroadcasterId();\n\n        uint256 numPayloads = payloadHashes.length;\n        for (uint256 i = 0; i < numPayloads; i++) {\n            bytes32 payloadHash = payloadHashes[i];\n            _attestations[remoteChainId][remoteOracle.toIdentifier()][application][payloadHash] = true;\n\n            emit OutputProven(remoteChainId, remoteOracle.toIdentifier(), application, payloadHash);\n        }\n    }\n\n    /**\n     * @notice Submits a proof of filled payloads as a message to the broadcaster.\n     * @param source The address of the application that has attested the payloads.\n     * @param payloads The payloads to submit.\n     */\n    function submit(\n        address source,\n        bytes[] calldata payloads\n    ) public {\n        if (!IAttester(source).hasAttested(payloads)) revert NotAllPayloadsValid();\n\n        bytes32 message = _getMessage(payloads);\n\n        broadcaster().broadcastMessage(message);\n    }\n\n    /**\n     * @notice Hashes an array of payload hashes.\n     * @param payloadHashes The payload hashes to hash.\n     * @return digest The hashed payload hashes.\n     */\n    function _hashPayloadHashes(\n        bytes32[] memory payloadHashes\n    ) internal pure returns (bytes32 digest) {\n        assembly {\n            // len = payloadHashes.length\n            let len := mload(payloadHashes)\n            // pointer to first element (skip the length word)\n            let start := add(payloadHashes, 0x20)\n            // total bytes = len * 32\n            let size := mul(len, 0x20)\n            // keccak256 over the packed elements\n            digest := keccak256(start, size)\n        }\n        return digest;\n    }\n\n    /**\n     * @notice Generates a message from the payloads.\n     * @param payloads The payloads to generate the message from.\n     * @return message The message generated from the payloads.\n     */\n    function _getMessage(\n        bytes[] calldata payloads\n    ) internal pure returns (bytes32 message) {\n        bytes32[] memory payloadHashes = new bytes32[](payloads.length);\n        for (uint256 i = 0; i < payloads.length; i++) {\n            payloadHashes[i] = keccak256(payloads[i]);\n        }\n        return _hashPayloadHashes(payloadHashes);\n    }\n}\n\n"
    }
}