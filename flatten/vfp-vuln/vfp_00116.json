{
    "vfp_id": "vfp_00116",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Unaccounted external vault investment losses can create withdrawal shortfalls",
            "description": "The protocol invests idle assets in external vaults such as Yearn but fails to account for losses incurred during divestment. When the protocol changes the address of an external vault, it divests from the current vault regardless of any losses, and these losses are not tracked or reflected in the system's accounting. The root cause is the absence of loss tracking during divestment operations. This creates a \"first out\" advantage where early withdrawers can redeem their full amounts while later withdrawers may face shortfalls because the physical assets no longer exist to back their balances. The protocol continues to report the original total supply despite having fewer physical tokens, leading to an inability to fulfill withdrawal requests. This threatens the solvency of the system and creates an unfair distribution of losses among users.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol",
                "contracts/vault/FractionalReserve.sol",
                "FractionalReserve.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "FractionalReserveLogic.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { IFractionalReserve } from \"../../interfaces/IFractionalReserve.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Fractional Reserve Logic\n/// @author kexley, @capLabs\n/// @notice Idle capital is put to work in fractional reserve vaults and can be recalled when\n/// withdrawing, redeeming or borrowing.\nlibrary FractionalReserveLogic {\n    using SafeERC20 for IERC20;\n\n    /// @dev Loss not allowed from fractional reserve\n    error LossFromFractionalReserve(address asset, address vault, uint256 loss);\n\n    /// @notice Invest unborrowed capital in a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    function invest(IFractionalReserve.FractionalReserveStorage storage $, address _asset) external {\n        uint256 assetBalance = IERC20(_asset).balanceOf(address(this));\n        uint256 reserveBalance = $.reserve[_asset];\n\n        if (assetBalance > reserveBalance) {\n            uint256 investAmount = assetBalance - reserveBalance;\n            $.loaned[_asset] += investAmount;\n            IERC20(_asset).forceApprove($.vault[_asset], investAmount);\n            IERC4626($.vault[_asset]).deposit(investAmount, address(this));\n        }\n    }\n\n    /// @notice Divest all from a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    function divest(IFractionalReserve.FractionalReserveStorage storage $, address _asset) external {\n        if ($.vault[_asset] != address(0)) {\n            uint256 loanedAssets = $.loaned[_asset];\n            $.loaned[_asset] = 0;\n\n            uint256 vaultBalance = IERC20($.vault[_asset]).balanceOf(address(this));\n            if (vaultBalance > 0) {\n                uint256 redeemedAssets = IERC4626($.vault[_asset]).redeem(vaultBalance, address(this), address(this));\n                if (redeemedAssets > loanedAssets) {\n                    IERC20(_asset).safeTransfer($.feeAuction, redeemedAssets - loanedAssets);\n                } else if (redeemedAssets < loanedAssets) {\n                    revert LossFromFractionalReserve(_asset, $.vault[_asset], loanedAssets - redeemedAssets);\n                }\n            }\n        }\n    }\n\n    /// @notice Divest capital from a fractional reserve vault when not enough funds are held in reserve\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @param _withdrawAmount Amount to withdraw to fulfil\n    function divest(IFractionalReserve.FractionalReserveStorage storage $, address _asset, uint256 _withdrawAmount)\n        external\n    {\n        if ($.vault[_asset] != address(0)) {\n            uint256 assetBalance = IERC20(_asset).balanceOf(address(this));\n\n            if (_withdrawAmount > assetBalance) {\n                /// Divest both the withdrawal amount and the buffer reserve for later withdrawals\n                uint256 divestAmount = _withdrawAmount + $.reserve[_asset] - assetBalance;\n                if (divestAmount > $.loaned[_asset]) divestAmount = $.loaned[_asset];\n                if (divestAmount > 0) {\n                    $.loaned[_asset] -= divestAmount;\n\n                    IERC4626($.vault[_asset]).withdraw(divestAmount, address(this), address(this));\n\n                    if (IERC20(_asset).balanceOf(address(this)) < divestAmount + assetBalance) {\n                        uint256 loss = divestAmount + assetBalance - IERC20(_asset).balanceOf(address(this));\n                        revert LossFromFractionalReserve(_asset, $.vault[_asset], loss);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Set the fractional reserve vault for an asset\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @param _vault Fractional reserve vault\n    function setFractionalReserveVault(\n        IFractionalReserve.FractionalReserveStorage storage $,\n        address _asset,\n        address _vault\n    ) external {\n        $.vault[_asset] = _vault;\n    }\n\n    /// @notice Set the reserve level for an asset\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @param _reserve Reserve level in asset decimals\n    function setReserve(IFractionalReserve.FractionalReserveStorage storage $, address _asset, uint256 _reserve)\n        external\n    {\n        $.reserve[_asset] = _reserve;\n    }\n\n    /// @notice Realize interest from a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    function realizeInterest(IFractionalReserve.FractionalReserveStorage storage $, address _asset) external {\n        IERC4626($.vault[_asset]).withdraw(claimableInterest($, _asset), $.feeAuction, address(this));\n    }\n\n    /// @notice Interest from a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @return interest Claimable amount of asset\n    function claimableInterest(IFractionalReserve.FractionalReserveStorage storage $, address _asset)\n        public\n        view\n        returns (uint256 interest)\n    {\n        uint256 vaultShares = IERC4626($.vault[_asset]).balanceOf(address(this));\n        uint256 vaultAssets = IERC4626($.vault[_asset]).convertToAssets(vaultShares);\n        interest = vaultAssets > $.loaned[_asset] ? vaultAssets - $.loaned[_asset] : 0;\n    }\n}\n"
    }
}