{
    "vfp_id": "vfp_00295",
    "project_name": "cantina_clearpool_aug2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Invalid Exchange Rate Causes Permanent State Corruption in Fee Calculations",
            "description": "The updateExchangeRate() function stores invalid exchange rates that are later used as the base for future interest and fee calculations. Even if the rate is out of bounds and causes a pause, the invalid rate is still stored and used in subsequent _checkpointInterestAndFees() calls. The cause is the lack of validation before storage and the absence of a mechanism to reject invalid rates during pauses. An attacker could exploit this by submitting an out-of-bounds rate, triggering a pause but still corrupting the stored _exchangeRate, which then skews all future interest accruals. The impact is long-term state corruption affecting fee calculations and potentially leading to incorrect distributions or insolvency.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        }
    ],
    "affected_files": {
        "AccountantWithRateProviders.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { FixedPointMathLib } from \"@solmate/utils/FixedPointMathLib.sol\";\nimport { IRateProvider } from \"src/interfaces/IRateProvider.sol\";\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { BoringVault } from \"src/base/BoringVault.sol\";\nimport { Auth, Authority } from \"@solmate/auth/Auth.sol\";\n\n/**\n * @title AccountantWithRateProviders\n */\ncontract AccountantWithRateProviders is Auth, IRateProvider {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    // ========================================= STRUCTS =========================================\n\n    /**\n     * @param payoutAddress the address `claimFees` sends fees to\n     * @param feesOwedInBase total pending fees owed in terms of base\n     * @param totalSharesLastUpdate total amount of shares the last exchange rate update\n     * @param exchangeRate the current exchange rate in terms of base\n     * @param _allowedExchangeRateChangeUpper the max allowed change to exchange rate from an update\n     * @param _allowedExchangeRateChangeLower the min allowed change to exchange rate from an update\n     * @param _lastUpdateTimestamp the block timestamp of the last exchange rate update\n     * @param _isPaused whether or not this contract is paused\n     * @param _minimumUpdateDelayInSeconds the minimum amount of time that must pass between\n     *        exchange rate updates, such that the update won't trigger the contract to be paused\n     * @param _managementFee the management fee\n     */\n    struct AccountantState {\n        address _payoutAddress;\n        uint128 _feesOwedInBase;\n        uint128 _totalSharesLastUpdate;\n        uint96 _exchangeRate;\n        uint16 _allowedExchangeRateChangeUpper;\n        uint16 _allowedExchangeRateChangeLower;\n        uint64 _lastUpdateTimestamp;\n        bool _isPaused;\n        uint32 _minimumUpdateDelayInSeconds;\n        uint16 _managementFee;\n    }\n\n    /**\n     * @notice Lending specific state\n     * @param _lendingRate Annual lending interest rate in basis points (1000 = 10%)\n     * @param _lastAccrualTime Timestamp of last interest accrual\n     */\n    struct LendingInfo {\n        uint256 _lendingRate; // Rate for vault growth\n        uint256 _lastAccrualTime; // Last checkpoint\n    }\n\n    /**\n     * @param isPeggedToBase whether or not the asset is 1:1 with the base asset\n     * @param rateProvider the rate provider for this asset if `isPeggedToBase` is false\n     */\n    struct RateProviderData {\n        bool isPeggedToBase;\n        IRateProvider rateProvider;\n    }\n\n    // ========================================= CONSTANTS =========================================\n    // Constants for calculations\n    uint256 constant SECONDS_PER_YEAR = 365 days;\n    uint256 constant BASIS_POINTS = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /**\n     * @notice Store the accountant state in 3 packed slots.\n     */\n    AccountantState public accountantState;\n    LendingInfo public lendingInfo;\n    uint256 public maxLendingRate;\n\n    /**\n     * @notice Maps ERC20s to their RateProviderData.\n     */\n    mapping(ERC20 => RateProviderData) public rateProviderData;\n\n    //============================== ERRORS ===============================\n\n    error AccountantWithRateProviders__UpperBoundTooSmall();\n    error AccountantWithRateProviders__LowerBoundTooLarge();\n    error AccountantWithRateProviders__ManagementFeeTooLarge();\n    error AccountantWithRateProviders__Paused();\n    error AccountantWithRateProviders__ZeroFeesOwed();\n    error AccountantWithRateProviders__OnlyCallableByBoringVault();\n    error AccountantWithRateProviders__UpdateDelayTooLarge();\n    error AccountantWithRateProviders__UpperMustExceedLower();\n\n    //============================== EVENTS ===============================\n\n    event Paused();\n    event Unpaused();\n    event DelayInSecondsUpdated(uint32 oldDelay, uint32 newDelay);\n    event UpperBoundUpdated(uint16 oldBound, uint16 newBound);\n    event LowerBoundUpdated(uint16 oldBound, uint16 newBound);\n    event PayoutAddressUpdated(address oldPayout, address newPayout);\n    event RateProviderUpdated(address asset, bool isPegged, address rateProvider);\n    event ExchangeRateUpdated(uint96 oldRate, uint96 newRate, uint64 currentTime);\n    event FeesClaimed(address indexed feeAsset, uint256 amount);\n    event LendingRateUpdated(uint256 newRate, uint256 timestamp);\n    event ManagementFeeRateUpdated(uint16 newRate, uint256 timestamp);\n    event MaxLendingRateUpdated(uint256 newMaxRate);\n    event Checkpoint(uint256 indexed timestamp);\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The base asset rates are provided in.\n     */\n    ERC20 public immutable base;\n\n    /**\n     * @notice The decimals rates are provided in.\n     */\n    uint8 public immutable decimals;\n\n    /**\n     * @notice The BoringVault this accountant is working with.\n     *         Used to determine share supply for fee calculation.\n     */\n    BoringVault public immutable vault;\n\n    /**\n     * @notice One share of the BoringVault.\n     */\n    uint256 internal immutable ONE_SHARE;\n\n    constructor(\n        address _owner,\n        address _vault,\n        address _payoutAddress,\n        uint96 _startingExchangeRate,\n        address _base,\n        uint16 _allowedExchangeRateChangeUpper,\n        uint16 _allowedExchangeRateChangeLower,\n        uint32 _minimumUpdateDelayInSeconds,\n        uint16 _managementFee\n    )\n        Auth(_owner, Authority(address(0)))\n    {\n        base = ERC20(_base);\n        decimals = ERC20(_base).decimals();\n        vault = BoringVault(payable(_vault));\n        ONE_SHARE = 10 ** vault.decimals();\n        accountantState = AccountantState({\n            _payoutAddress: _payoutAddress,\n            _feesOwedInBase: 0,\n            _totalSharesLastUpdate: uint128(vault.totalSupply()),\n            _exchangeRate: _startingExchangeRate,\n            _allowedExchangeRateChangeUpper: _allowedExchangeRateChangeUpper,\n            _allowedExchangeRateChangeLower: _allowedExchangeRateChangeLower,\n            _lastUpdateTimestamp: uint64(block.timestamp),\n            _isPaused: false,\n            _minimumUpdateDelayInSeconds: _minimumUpdateDelayInSeconds,\n            _managementFee: _managementFee\n        });\n        lendingInfo._lastAccrualTime = block.timestamp;\n        maxLendingRate = 5000;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n    /**\n     * @notice Pause this contract, which prevents future calls to `updateExchangeRate`, and any safe rate\n     *         calls will revert.\n     * @dev Pausing only prevents state changes, not time-based calculations\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function pause() public requiresAuth {\n        accountantState._isPaused = true;\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpause this contract, which allows future calls to `updateExchangeRate`, and any safe rate\n     *         calls will stop reverting.\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function unpause() external requiresAuth {\n        accountantState._isPaused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @notice Update the minimum time delay between `updateExchangeRate` calls.\n     * @dev There are no input requirements, as it is possible the admin would want\n     *      the exchange rate updated as frequently as needed.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateDelay(uint32 _minimumUpdateDelayInSeconds) external requiresAuth {\n        if (_minimumUpdateDelayInSeconds > 14 days) revert AccountantWithRateProviders__UpdateDelayTooLarge();\n        uint32 oldDelay = accountantState._minimumUpdateDelayInSeconds;\n        accountantState._minimumUpdateDelayInSeconds = _minimumUpdateDelayInSeconds;\n        emit DelayInSecondsUpdated(oldDelay, _minimumUpdateDelayInSeconds);\n    }\n\n    /**\n     * @notice Update the allowed upper bound change of exchange rate between `updateExchangeRateCalls`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateUpper(uint16 _allowedExchangeRateChangeUpper) external requiresAuth {\n        if (_allowedExchangeRateChangeUpper <= accountantState._allowedExchangeRateChangeLower) {\n            revert AccountantWithRateProviders__UpperMustExceedLower();\n        }\n        if (_allowedExchangeRateChangeUpper < BASIS_POINTS) revert AccountantWithRateProviders__UpperBoundTooSmall();\n        uint16 oldBound = accountantState._allowedExchangeRateChangeUpper;\n        accountantState._allowedExchangeRateChangeUpper = _allowedExchangeRateChangeUpper;\n        emit UpperBoundUpdated(oldBound, _allowedExchangeRateChangeUpper);\n    }\n\n    /**\n     * @notice Update the allowed lower bound change of exchange rate between `updateExchangeRateCalls`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateLower(uint16 _allowedExchangeRateChangeLower) external requiresAuth {\n        if (_allowedExchangeRateChangeLower >= accountantState._allowedExchangeRateChangeUpper) {\n            revert AccountantWithRateProviders__UpperMustExceedLower();\n        }\n        if (_allowedExchangeRateChangeLower > BASIS_POINTS) revert AccountantWithRateProviders__LowerBoundTooLarge();\n        uint16 oldBound = accountantState._allowedExchangeRateChangeLower;\n        accountantState._allowedExchangeRateChangeLower = _allowedExchangeRateChangeLower;\n        emit LowerBoundUpdated(oldBound, _allowedExchangeRateChangeLower);\n    }\n\n    /**\n     * @notice Update the payout address fees are sent to.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updatePayoutAddress(address _payoutAddress) external requiresAuth {\n        address oldPayout = accountantState._payoutAddress;\n        accountantState._payoutAddress = _payoutAddress;\n        emit PayoutAddressUpdated(oldPayout, _payoutAddress);\n    }\n\n    /**\n     * @notice Update the rate provider data for a specific `asset`.\n     * @dev Rate providers must return rates in terms of `base` or\n     * an asset pegged to base and they must use the same decimals\n     * as `asset`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function setRateProviderData(ERC20 _asset, bool _isPeggedToBase, address _rateProvider) external requiresAuth {\n        rateProviderData[_asset] =\n            RateProviderData({ isPeggedToBase: _isPeggedToBase, rateProvider: IRateProvider(_rateProvider) });\n        emit RateProviderUpdated(address(_asset), _isPeggedToBase, _rateProvider);\n    }\n\n    // ========================================= UPDATE EXCHANGE RATE/FEES FUNCTIONS\n    // =========================================\n\n    /**\n     * @notice Updates this contract exchangeRate.\n     * @dev If new exchange rate is outside of accepted bounds, or if not enough time has passed, this\n     *      will pause the contract, and this function will NOT calculate fees owed.\n     * @dev Callable by UPDATE_EXCHANGE_RATE_ROLE.\n     */\n    function updateExchangeRate(uint96 _newExchangeRate) external requiresAuth {\n        AccountantState storage state = accountantState;\n\n        uint64 currentTime = uint64(block.timestamp);\n        (uint96 currentRateWithInterest,) = calculateExchangeRateWithInterest();\n\n        uint96 oldExchangeRate = state._exchangeRate;\n\n        _checkpointInterestAndFees();\n\n        uint256 currentTotalShares = vault.totalSupply();\n\n        if (\n            currentTime < state._lastUpdateTimestamp + state._minimumUpdateDelayInSeconds\n                || _newExchangeRate\n                    > uint256(currentRateWithInterest).mulDivDown(state._allowedExchangeRateChangeUpper, BASIS_POINTS)\n                || _newExchangeRate\n                    < uint256(currentRateWithInterest).mulDivDown(state._allowedExchangeRateChangeLower, BASIS_POINTS)\n        ) {\n            pause();\n        }\n\n        // Always update the rate and timestamp\n        state._exchangeRate = _newExchangeRate;\n        state._totalSharesLastUpdate = uint128(currentTotalShares);\n        state._lastUpdateTimestamp = currentTime;\n\n        emit ExchangeRateUpdated(oldExchangeRate, _newExchangeRate, currentTime);\n    }\n\n    /**\n     * @notice Set lending rate\n     * @dev Checkpoints current interest and management fees before changing rate\n     * @dev This prevents loss of accrued value when rate changes\n     * @param _lendingRate New lending rate in basis points (1000 = 10% APY)\n     */\n    function setLendingRate(uint256 _lendingRate) external requiresAuth {\n        require(_lendingRate <= maxLendingRate, \"Lending rate exceeds maximum\");\n\n        // Checkpoint both interest and fees before rate change\n        _checkpointInterestAndFees();\n\n        lendingInfo._lendingRate = _lendingRate;\n        emit LendingRateUpdated(_lendingRate, block.timestamp);\n    }\n\n    /**\n     * @notice Set management fee rate (requires checkpoint)\n     * @dev Checkpoints current management fees at old rate before changing\n     * @dev This ensures fees are correctly attributed to each rate period\n     * @param _managementFeeRate New management fee rate in basis points\n     */\n    function setManagementFeeRate(uint16 _managementFeeRate) external requiresAuth {\n        if (_managementFeeRate > 0.2e4) revert AccountantWithRateProviders__ManagementFeeTooLarge();\n        _checkpointInterestAndFees();\n\n        accountantState._managementFee = _managementFeeRate;\n        emit ManagementFeeRateUpdated(_managementFeeRate, block.timestamp);\n    }\n\n    /**\n     * @notice Set maximum lending rate\n     * @dev Callable by OWNER_ROLE\n     */\n    function setMaxLendingRate(uint256 _maxLendingRate) external requiresAuth {\n        _checkpointInterestAndFees();\n        maxLendingRate = _maxLendingRate;\n\n        // Adjust current rate if needed\n        if (lendingInfo._lendingRate > _maxLendingRate) {\n            lendingInfo._lendingRate = _maxLendingRate;\n            emit LendingRateUpdated(_maxLendingRate, block.timestamp);\n        }\n\n        emit MaxLendingRateUpdated(_maxLendingRate);\n    }\n\n    /**\n     * @notice Claim pending fees.\n     * @dev This function must be called by the BoringVault.\n     * @dev This function will lose precision if the exchange rate\n     *      decimals is greater than the _feeAsset's decimals.\n     */\n    function claimFees(ERC20 _feeAsset) external {\n        if (msg.sender != address(vault)) revert AccountantWithRateProviders__OnlyCallableByBoringVault();\n\n        AccountantState storage state = accountantState;\n        if (state._isPaused) revert AccountantWithRateProviders__Paused();\n\n        _checkpointInterestAndFees();\n\n        if (state._feesOwedInBase == 0) revert AccountantWithRateProviders__ZeroFeesOwed();\n\n        // Determine amount of fees owed in _feeAsset\n        uint256 feesOwedInFeeAsset;\n        RateProviderData memory data = rateProviderData[_feeAsset];\n        if (address(_feeAsset) == address(base)) {\n            feesOwedInFeeAsset = state._feesOwedInBase;\n        } else {\n            uint8 feeAssetDecimals = ERC20(_feeAsset).decimals();\n            uint256 feesOwedInBaseUsingFeeAssetDecimals =\n                _changeDecimals(state._feesOwedInBase, decimals, feeAssetDecimals);\n            if (data.isPeggedToBase) {\n                feesOwedInFeeAsset = feesOwedInBaseUsingFeeAssetDecimals;\n            } else {\n                uint256 rate = data.rateProvider.getRate();\n                feesOwedInFeeAsset = feesOwedInBaseUsingFeeAssetDecimals.mulDivDown(10 ** feeAssetDecimals, rate);\n            }\n        }\n\n        // Zero out fees owed\n        state._feesOwedInBase = 0;\n\n        // Transfer fee asset to payout address\n        _feeAsset.safeTransferFrom(msg.sender, state._payoutAddress, feesOwedInFeeAsset);\n\n        emit FeesClaimed(address(_feeAsset), feesOwedInFeeAsset);\n    }\n\n    // ========================================= RATE FUNCTIONS =========================================\n\n    /**\n     * @notice Get this BoringVault's current rate in the base (real-time with interest).\n     */\n    function getRate() public view returns (uint256 rate) {\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n        return currentRate;\n    }\n\n    /**\n     * @notice Calculate current exchange rate including accrued interest\n     * @dev This is a view function - interest continues accruing even when paused\n     * @return newRate The exchange rate including accrued interest\n     * @return interestAccrued The amount of interest accrued since last checkpoint\n     */\n    function calculateExchangeRateWithInterest() public view returns (uint96 newRate, uint256 interestAccrued) {\n        newRate = accountantState._exchangeRate;\n\n        if (lendingInfo._lendingRate > 0) {\n            uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n\n            // always update the rate (even when TVL = 0)\n            uint256 rateIncrease = uint256(accountantState._exchangeRate).mulDivDown(\n                lendingInfo._lendingRate * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS\n            );\n            newRate = accountantState._exchangeRate + uint96(rateIncrease);\n\n            // Interest accrued is only for actual deposits\n            if (vault.totalSupply() > 0) {\n                uint256 totalDeposits = vault.totalSupply().mulDivDown(accountantState._exchangeRate, ONE_SHARE);\n                interestAccrued =\n                    totalDeposits.mulDivDown(lendingInfo._lendingRate * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n            }\n        }\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     * @dev Revert if paused.\n     */\n    function getRateSafe() external view returns (uint256 rate) {\n        if (accountantState._isPaused) revert AccountantWithRateProviders__Paused();\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n        rate = currentRate;\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the provided quote.\n     * @dev `quote` must have its RateProviderData set, else this will revert.\n     * @dev This function will lose precision if the exchange rate\n     *      decimals is greater than the _quote's decimals.\n     */\n    function getRateInQuote(ERC20 _quote) public view returns (uint256 rateInQuote) {\n        // Get real-time rate first\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n\n        if (address(_quote) == address(base)) {\n            rateInQuote = currentRate;\n        } else {\n            RateProviderData memory data = rateProviderData[_quote];\n            uint8 quoteDecimals = ERC20(_quote).decimals();\n            uint256 exchangeRateInQuoteDecimals = _changeDecimals(currentRate, decimals, quoteDecimals);\n            if (data.isPeggedToBase) {\n                rateInQuote = exchangeRateInQuoteDecimals;\n            } else {\n                uint256 quoteRate = data.rateProvider.getRate();\n                uint256 oneQuote = 10 ** quoteDecimals;\n                rateInQuote = oneQuote.mulDivDown(exchangeRateInQuoteDecimals, quoteRate);\n            }\n        }\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the provided quote.\n     * @dev `quote` must have its RateProviderData set, else this will revert.\n     * @dev Revert if paused.\n     */\n    function getRateInQuoteSafe(ERC20 _quote) external view returns (uint256 rateInQuote) {\n        if (accountantState._isPaused) revert AccountantWithRateProviders__Paused();\n        rateInQuote = getRateInQuote(_quote);\n    }\n\n    /**\n     * @notice Get total rate paid by borrower\n     * @dev This is the sum of lending rate (for depositors) and management fee rate\n     * @return Total borrower rate in basis points\n     */\n    function getBorrowerRate() public view returns (uint256) {\n        return lendingInfo._lendingRate + accountantState._managementFee;\n    }\n\n    /**\n     * @notice Preview total management fees owed including unclaimed\n     * @dev Calculates real-time fees without modifying state\n     * @dev Includes both stored fees and fees accrued since last checkpoint\n     * @return totalFees Total management fees owed in base asset\n     */\n    function previewFeesOwed() external view returns (uint256 totalFees) {\n        totalFees = accountantState._feesOwedInBase;\n\n        if (vault.totalSupply() > 0 && accountantState._managementFee > 0) {\n            uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n\n            // Use current rate including interest\n            (uint96 currentRate,) = calculateExchangeRateWithInterest();\n            uint256 totalDeposits = vault.totalSupply().mulDivDown(currentRate, ONE_SHARE);\n\n            uint256 managementFees =\n                totalDeposits.mulDivDown(accountantState._managementFee * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n            totalFees += managementFees;\n        }\n    }\n\n    // ========================================= INTERNAL HELPER FUNCTIONS =========================================\n    /**\n     * @notice Checkpoint both interest and management fees\n     * @dev Updates exchange rate with interest and feesOwedInBase with management fees\n     */\n    function _checkpointInterestAndFees() internal {\n        uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n        if (timeElapsed > 0) {\n            (uint96 newRate,) = calculateExchangeRateWithInterest();\n            accountantState._exchangeRate = newRate;\n\n            // Only calculate management fees when there are actual deposits\n            if (vault.totalSupply() > 0 && accountantState._managementFee > 0) {\n                uint256 totalValue = vault.totalSupply().mulDivDown(newRate, ONE_SHARE);\n                uint256 managementFees =\n                    totalValue.mulDivDown(accountantState._managementFee * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n                accountantState._feesOwedInBase += uint128(managementFees);\n            }\n            lendingInfo._lastAccrualTime = block.timestamp;\n            emit Checkpoint(block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Updates the stored exchange rate and accrues management fees\n     * @dev Should be called before any operation that depends on the current exchange rate\n     * @dev This includes deposits, withdrawals, and fee calculations\n     * @dev Callable by authorized contracts (Teller) to ensure rate consistency\n     */\n    function checkpoint() external requiresAuth {\n        require(!accountantState._isPaused, \"Cannot checkpoint when paused\");\n        _checkpointInterestAndFees();\n    }\n\n    /**\n     * @notice Used to change the decimals of precision used for an amount.\n     */\n    function _changeDecimals(uint256 _amount, uint8 _fromDecimals, uint8 _toDecimals) internal pure returns (uint256) {\n        if (_fromDecimals == _toDecimals) {\n            return _amount;\n        } else if (_fromDecimals < _toDecimals) {\n            return _amount * 10 ** (_toDecimals - _fromDecimals);\n        } else {\n            return _amount / 10 ** (_fromDecimals - _toDecimals);\n        }\n    }\n}\n"
    }
}