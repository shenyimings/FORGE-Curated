{
    "vfp_id": "vfp_00295",
    "project_name": "Metamask Delegation Framework April 2025 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Missing Slippage Protection in Token Swap Execution",
            "description": "The `swapTokens` function in the `DelegationMetaSwapAdapter` contract performs token swaps via the MetaSwap API but does not enforce a minimum output amount (slippage protection). This is due to the absence of a `_minAmountOut` parameter and corresponding validation after the swap. An attacker or market fluctuation could exploit this by executing swaps when prices are unfavorable, causing the user to receive significantly fewer tokens than expected. Additionally, in the case of deflationary tokens, the extra transfer step from MetaSwap to the adapter could consume more tokens than anticipated. The impact includes potential financial loss for users, reduced trust in the system, and increased vulnerability to front-running or manipulation, especially if the MetaSwap API data is delayed or manipulated.\n",
            "severity": "Medium",
            "location": [
                "src/helpers/DelegationMetaSwapAdapter.sol::swapTokens#280-317",
                "src/helpers/DelegationMetaSwapAdapter.sol#481-499",
                "metaSwap::swap"
            ],
            "files": [
                "delegation-framework/src/helpers/DelegationMetaSwapAdapter.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Re-Entrancy Risk in swapTokens()",
            "description": "The `swapTokens()` function in the `DelegationMetaSwapAdapter` contract is susceptible to re-entrancy attacks due to an external call made during the token transfer process. Specifically, when handling native tokens (e.g., ETH), the `_sendTokens()` function uses a low-level `.call()` to transfer funds to the recipient, which could allow a malicious contract to re-enter the `swapTokens()` function before the current execution is complete.\n\nThe root cause of this vulnerability lies in the absence of a re-entrancy guard during a critical state-changing operation that involves external calls. Although the function is restricted to `onlySelf`, the recipient address could still be a contract controlled by the root delegator, enabling a re-entrant call.\n\nAn attacker could exploit this by registering a malicious contract as the recipient, which would re-enter the `swapTokens()` function during the `.call()` execution. This could lead to unintended behavior such as multiple swaps being executed using the same initial balance, potentially manipulating state or draining funds if combined with other vulnerabilities.\n\nWhile the audit team acknowledges that the risk is limited—since re-entrancy would originate from the root delegator and no major attack vector was identified—the potential for unexpected re-entrant behavior remains. Without a re-entrancy guard, the contract deviates from secure coding best practices and introduces unnecessary risk.\n",
            "severity": "Medium",
            "location": [
                "src/helpers/DelegationMetaSwapAdapter.sol::swapTokens#280-297",
                "src/helpers/DelegationMetaSwapAdapter.sol::_sendTokens#421-431"
            ],
            "files": [
                "delegation-framework/src/helpers/DelegationMetaSwapAdapter.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Metamask Aggregator Signature for Swap API Data Can Be Re-Used",
            "description": "The `_validateSignature` function in the `DelegationMetaSwapAdapter` contract verifies the authenticity and expiration of swap data signatures but does not prevent replay of the same signature. This is caused by the lack of a nonce or a used-signature mapping to track and block repeated use. An attacker could reuse a valid signature to replay a previously executed swap, potentially draining funds if the delegation allows multiple executions. Although the expiration check limits the window, reuse within the same block or across different contexts could still occur. The impact includes potential duplication of swaps, unexpected token movements, and increased risk of fund loss, especially in high-frequency or automated scenarios.\n",
            "severity": "Medium",
            "location": [
                "src/helpers/DelegationMetaSwapAdapter.sol::swapByDelegation#215-222",
                "src/helpers/DelegationMetaSwapAdapter.sol::_validateSignature#522-534"
            ],
            "files": [
                "delegation-framework/src/helpers/DelegationMetaSwapAdapter.sol"
            ]
        }
    ],
    "affected_files": {
        "DelegationMetaSwapAdapter.sol": "// SPDX-License-Identifier: MIT AND Apache-2.0\npragma solidity 0.8.23;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { MessageHashUtils } from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable2Step, Ownable } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ModeLib } from \"@erc7579/lib/ModeLib.sol\";\nimport { ExecutionLib } from \"@erc7579/lib/ExecutionLib.sol\";\nimport { ExecutionHelper } from \"@erc7579/core/ExecutionHelper.sol\";\n\nimport { IMetaSwap } from \"./interfaces/IMetaSwap.sol\";\nimport { IDelegationManager } from \"../interfaces/IDelegationManager.sol\";\nimport { CallType, ExecType, Delegation, ModeCode } from \"../utils/Types.sol\";\nimport { CALLTYPE_SINGLE, EXECTYPE_DEFAULT } from \"../utils/Constants.sol\";\n\n/**\n * @title DelegationMetaSwapAdapter\n * @notice Acts as a middleman to orchestrate token swaps using delegations and an aggregator (MetaSwap).\n * @dev This contract depends on an ArgsEqualityCheckEnforcer. The root delegation must include a caveat\n *      with this enforcer as its first element. Its arguments indicate whether the swap should enforce the token\n *      whitelist (\"Token-Whitelist-Enforced\") or not (\"Token-Whitelist-Not-Enforced\"). The root delegator is\n *      responsible for including this enforcer to signal the desired behavior.\n *\n * @dev This adapter is intended to be used with the Swaps API. Accordingly, all API requests must include a valid\n *      signature that incorporates an expiration timestamp. The signature is verified during swap execution to ensure\n *      that it is still valid.\n */\ncontract DelegationMetaSwapAdapter is ExecutionHelper, Ownable2Step {\n    using ModeLib for ModeCode;\n    using ExecutionLib for bytes;\n    using SafeERC20 for IERC20;\n\n    struct SignatureData {\n        bytes apiData;\n        uint256 expiration;\n        bytes signature;\n    }\n\n    ////////////////////////////// State //////////////////////////////\n\n    /// @dev Constant value used to enforce the token whitelist\n    string public constant WHITELIST_ENFORCED = \"Token-Whitelist-Enforced\";\n\n    /// @dev Constant value used to avoid enforcing the token whitelist\n    string public constant WHITELIST_NOT_ENFORCED = \"Token-Whitelist-Not-Enforced\";\n\n    /// @dev The DelegationManager contract that has root access to this contract\n    IDelegationManager public immutable delegationManager;\n\n    /// @dev The MetaSwap contract used to swap tokens\n    IMetaSwap public immutable metaSwap;\n\n    /// @dev The enforcer used to compare args and terms\n    address public immutable argsEqualityCheckEnforcer;\n\n    /// @dev Address of the API signer account.\n    address public swapApiSigner;\n\n    /// @dev Indicates if a token is allowed to be used in the swaps\n    mapping(IERC20 token => bool allowed) public isTokenAllowed;\n\n    /// @dev A mapping indicating if an aggregator ID hash is allowed.\n    mapping(bytes32 aggregatorIdHash => bool allowed) public isAggregatorAllowed;\n\n    ////////////////////////////// Events //////////////////////////////\n\n    /// @dev Emitted when the DelegationManager contract address is set.\n    event SetDelegationManager(IDelegationManager indexed newDelegationManager);\n\n    /// @dev Emitted when the MetaSwap contract address is set.\n    event SetMetaSwap(IMetaSwap indexed newMetaSwap);\n\n    /// @dev Emitted when the Args Equality Check Enforcer contract address is set.\n    event SetArgsEqualityCheckEnforcer(address indexed newArgsEqualityCheckEnforcer);\n\n    /// @dev Emitted when the contract sends tokens (or native tokens) to a recipient.\n    event SentTokens(IERC20 indexed token, address indexed recipient, uint256 amount);\n\n    /// @dev Emitted when the allowed token status changes for a token.\n    event ChangedTokenStatus(IERC20 token, bool status);\n\n    /// @dev Emitted when the allowed aggregator ID status changes.\n    event ChangedAggregatorIdStatus(bytes32 indexed aggregatorIdHash, string aggregatorId, bool status);\n\n    /// @dev Emitted when the Signer API is updated.\n    event SwapApiSignerUpdated(address indexed newSigner);\n\n    ////////////////////////////// Errors //////////////////////////////\n\n    /// @dev Error thrown when the caller is not the delegation manager\n    error NotDelegationManager();\n\n    /// @dev Error thrown when the call is not made by this contract itself.\n    error NotSelf();\n\n    /// @dev Error thrown when msg.sender is not the leaf delegator.\n    error NotLeafDelegator();\n\n    /// @dev Error thrown when an execution with an unsupported CallType is made.\n    error UnsupportedCallType(CallType callType);\n\n    /// @dev Error thrown when an execution with an unsupported ExecType is made.\n    error UnsupportedExecType(ExecType execType);\n\n    /// @dev Error thrown when the input and output tokens are the same.\n    error InvalidIdenticalTokens();\n\n    /// @dev Error thrown when delegations input is an empty array.\n    error InvalidEmptyDelegations();\n\n    /// @dev Error while transferring the native token to the recipient.\n    error FailedNativeTokenTransfer(address recipient);\n\n    /// @dev Error when the tokenFrom is not in the allow list.\n    error TokenFromIsNotAllowed(IERC20 token);\n\n    /// @dev Error when the tokenTo is not in the allow list.\n    error TokenToIsNotAllowed(IERC20 token);\n\n    /// @dev Error when the aggregator ID is not in the allow list.\n    error AggregatorIdIsNotAllowed(string aggregatorId);\n\n    /// @dev Error when the input arrays of a function have different lengths.\n    error InputLengthsMismatch();\n\n    /// @dev Error when the contract did not receive enough tokens to perform the swap.\n    error InsufficientTokens();\n\n    /// @dev Error when the api data comes with an invalid swap function selector.\n    error InvalidSwapFunctionSelector();\n\n    /// @dev Error when the tokenFrom in the api data and swap data do not match.\n    error TokenFromMismath();\n\n    /// @dev Error when the amountFrom in the api data and swap data do not match.\n    error AmountFromMismath();\n\n    /// @dev Error when the delegations do not include the ArgsEqualityCheckEnforcer\n    error MissingArgsEqualityCheckEnforcer();\n\n    /// @dev Error thrown when API signature is invalid.\n    error InvalidApiSignature();\n\n    /// @dev Error thrown when the signature expiration has passed.\n    error SignatureExpired();\n\n    ////////////////////////////// Modifiers //////////////////////////////\n\n    /**\n     * @notice Require the function call to come from the DelegationManager.\n     */\n    modifier onlyDelegationManager() {\n        if (msg.sender != address(delegationManager)) revert NotDelegationManager();\n        _;\n    }\n\n    /**\n     * @notice Require the function call to come from the this contract itself.\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    ////////////////////////////// Constructor //////////////////////////////\n\n    /**\n     * @notice Initializes the DelegationMetaSwapAdapter contract.\n     * @param _owner The initial owner of the contract.\n     * @param _swapApiSigner The initial swap API signer.\n     * @param _delegationManager The address of the trusted DelegationManager contract has privileged access to call\n     *        executeByExecutor based on a given delegation.\n     * @param _metaSwap The address of the trusted MetaSwap contract.\n     * @param _argsEqualityCheckEnforcer The address of the ArgsEqualityCheckEnforcer contract.\n     */\n    constructor(\n        address _owner,\n        address _swapApiSigner,\n        IDelegationManager _delegationManager,\n        IMetaSwap _metaSwap,\n        address _argsEqualityCheckEnforcer\n    )\n        Ownable(_owner)\n    {\n        swapApiSigner = _swapApiSigner;\n        delegationManager = _delegationManager;\n        metaSwap = _metaSwap;\n        argsEqualityCheckEnforcer = _argsEqualityCheckEnforcer;\n        emit SwapApiSignerUpdated(_swapApiSigner);\n        emit SetDelegationManager(_delegationManager);\n        emit SetMetaSwap(_metaSwap);\n        emit SetArgsEqualityCheckEnforcer(_argsEqualityCheckEnforcer);\n    }\n\n    ////////////////////////////// External Methods //////////////////////////////\n\n    /**\n     * @notice Allows this contract to receive the chain's native token.\n     */\n    receive() external payable { }\n\n    /**\n     * @notice Executes a token swap using a delegation and transfers the swapped tokens to the root delegator, after validating\n     * signature and expiration.\n     * @dev The msg.sender must be the leaf delegator\n     * @param _signatureData Includes:\n     * - apiData Encoded swap parameters, used by the aggregator.\n     * - expiration Timestamp after which the signature is invalid.\n     * - signature Signature validating the provided apiData.\n     * @param _delegations Array of Delegation objects containing delegation-specific data, sorted leaf to root.\n     * @param _useTokenWhitelist Indicates whether the tokens must be validated or not.\n     */\n    function swapByDelegation(\n        SignatureData calldata _signatureData,\n        Delegation[] memory _delegations,\n        bool _useTokenWhitelist\n    )\n        external\n    {\n        _validateSignature(_signatureData);\n\n        (string memory aggregatorId_, IERC20 tokenFrom_, IERC20 tokenTo_, uint256 amountFrom_, bytes memory swapData_) =\n            _decodeApiData(_signatureData.apiData);\n        uint256 delegationsLength_ = _delegations.length;\n\n        if (delegationsLength_ == 0) revert InvalidEmptyDelegations();\n        if (tokenFrom_ == tokenTo_) revert InvalidIdenticalTokens();\n\n        _validateTokens(tokenFrom_, tokenTo_, _delegations, _useTokenWhitelist);\n\n        if (!isAggregatorAllowed[keccak256(abi.encode(aggregatorId_))]) revert AggregatorIdIsNotAllowed(aggregatorId_);\n        if (_delegations[0].delegator != msg.sender) revert NotLeafDelegator();\n\n        // Prepare the call that will be executed internally via onlySelf\n        bytes memory encodedSwap_ = abi.encodeWithSelector(\n            this.swapTokens.selector,\n            aggregatorId_,\n            tokenFrom_,\n            tokenTo_,\n            _delegations[delegationsLength_ - 1].delegator,\n            amountFrom_,\n            _getSelfBalance(tokenFrom_),\n            swapData_\n        );\n\n        bytes[] memory permissionContexts_ = new bytes[](2);\n        permissionContexts_[0] = abi.encode(_delegations);\n        permissionContexts_[1] = abi.encode(new Delegation[](0));\n\n        ModeCode[] memory encodedModes_ = new ModeCode[](2);\n        encodedModes_[0] = ModeLib.encodeSimpleSingle();\n        encodedModes_[1] = ModeLib.encodeSimpleSingle();\n\n        bytes[] memory executionCallDatas_ = new bytes[](2);\n\n        if (address(tokenFrom_) == address(0)) {\n            executionCallDatas_[0] = ExecutionLib.encodeSingle(address(this), amountFrom_, hex\"\");\n        } else {\n            bytes memory encodedTransfer_ = abi.encodeWithSelector(IERC20.transfer.selector, address(this), amountFrom_);\n            executionCallDatas_[0] = ExecutionLib.encodeSingle(address(tokenFrom_), 0, encodedTransfer_);\n        }\n        executionCallDatas_[1] = ExecutionLib.encodeSingle(address(this), 0, encodedSwap_);\n\n        delegationManager.redeemDelegations(permissionContexts_, encodedModes_, executionCallDatas_);\n    }\n\n    /**\n     * @notice Executes the actual token swap via the MetaSwap contract and transfer the output tokens to the recipient.\n     * @dev This function can only be called internally by this contract (`onlySelf`).\n     * @param _aggregatorId The identifier for the swap aggregator/DEX aggregator.\n     * @param _tokenFrom The input token of the swap.\n     * @param _tokenTo The output token of the swap.\n     * @param _recipient The address that will receive the swapped tokens.\n     * @param _amountFrom The amount of tokens to be swapped.\n     * @param _balanceFromBefore The contract’s balance of _tokenFrom before the incoming token transfer is credited.\n     * @param _swapData Arbitrary data required by the aggregator (e.g. encoded swap params).\n     */\n    function swapTokens(\n        string calldata _aggregatorId,\n        IERC20 _tokenFrom,\n        IERC20 _tokenTo,\n        address _recipient,\n        uint256 _amountFrom,\n        uint256 _balanceFromBefore,\n        bytes calldata _swapData\n    )\n        external\n        onlySelf\n    {\n        uint256 tokenFromObtained_ = _getSelfBalance(_tokenFrom) - _balanceFromBefore;\n        if (tokenFromObtained_ < _amountFrom) revert InsufficientTokens();\n\n        if (tokenFromObtained_ > _amountFrom) {\n            _sendTokens(_tokenFrom, tokenFromObtained_ - _amountFrom, _recipient);\n        }\n\n        uint256 balanceToBefore_ = _getSelfBalance(_tokenTo);\n\n        uint256 value_ = 0;\n\n        if (address(_tokenFrom) == address(0)) {\n            value_ = _amountFrom;\n        } else {\n            uint256 allowance_ = _tokenFrom.allowance(address(this), address(metaSwap));\n            if (allowance_ < _amountFrom) {\n                _tokenFrom.safeIncreaseAllowance(address(metaSwap), type(uint256).max);\n            }\n        }\n\n        metaSwap.swap{ value: value_ }(_aggregatorId, _tokenFrom, _amountFrom, _swapData);\n\n        uint256 obtainedAmount_ = _getSelfBalance(_tokenTo) - balanceToBefore_;\n\n        _sendTokens(_tokenTo, obtainedAmount_, _recipient);\n    }\n\n    /**\n     * @notice Updates the address authorized to sign API requests.\n     * @param _newSigner The new authorized signer address.\n     */\n    function setSwapApiSigner(address _newSigner) external onlyOwner {\n        swapApiSigner = _newSigner;\n        emit SwapApiSignerUpdated(_newSigner);\n    }\n\n    /**\n     * @notice Executes one calls on behalf of this contract,\n     *         authorized by the DelegationManager.\n     * @dev Only callable by the DelegationManager. Supports single-call execution,\n     *         and handles the revert logic via ExecType.\n     * @dev Related: @erc7579/MSAAdvanced.sol\n     * @param _mode The encoded execution mode of the transaction (CallType, ExecType, etc.).\n     * @param _executionCalldata The encoded call data (single) to be executed.\n     * @return returnData_ An array of returned data from each executed call.\n     */\n    function executeFromExecutor(\n        ModeCode _mode,\n        bytes calldata _executionCalldata\n    )\n        external\n        payable\n        onlyDelegationManager\n        returns (bytes[] memory returnData_)\n    {\n        (CallType callType_, ExecType execType_,,) = _mode.decode();\n\n        // Only support single call type with default execution\n        if (CallType.unwrap(CALLTYPE_SINGLE) != CallType.unwrap(callType_)) revert UnsupportedCallType(callType_);\n        if (ExecType.unwrap(EXECTYPE_DEFAULT) != ExecType.unwrap(execType_)) revert UnsupportedExecType(execType_);\n        // Process single execution directly without additional checks\n        (address target_, uint256 value_, bytes calldata callData_) = _executionCalldata.decodeSingle();\n        returnData_ = new bytes[](1);\n        returnData_[0] = _execute(target_, value_, callData_);\n        return returnData_;\n    }\n\n    /**\n     * @notice Withdraws a specified token from the contract to a recipient.\n     * @dev Only callable by the contract owner.\n     * @param _token The token to be withdrawn (use address(0) for native token).\n     * @param _amount The amount of tokens (or native) to withdraw.\n     * @param _recipient The address to receive the withdrawn tokens.\n     */\n    function withdraw(IERC20 _token, uint256 _amount, address _recipient) external onlyOwner {\n        _sendTokens(_token, _amount, _recipient);\n    }\n\n    /**\n     * @notice Updates the allowed (whitelist) status of multiple tokens in a single call.\n     * @dev Only callable by the contract owner.\n     * @param _tokens Array of tokens to modify.\n     * @param _statuses Corresponding array of booleans to set each token's allowed status.\n     */\n    function updateAllowedTokens(IERC20[] calldata _tokens, bool[] calldata _statuses) external onlyOwner {\n        uint256 tokensLength_ = _tokens.length;\n        if (tokensLength_ != _statuses.length) revert InputLengthsMismatch();\n\n        for (uint256 i = 0; i < tokensLength_; ++i) {\n            IERC20 token = _tokens[i];\n            bool status_ = _statuses[i];\n            if (isTokenAllowed[token] != status_) {\n                isTokenAllowed[token] = status_;\n\n                emit ChangedTokenStatus(token, status_);\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the allowed (whitelist) status of multiple aggregator IDs in a single call.\n     * @dev Only callable by the contract owner.\n     * @param _aggregatorIds Array of aggregator ID strings.\n     * @param _statuses Corresponding array of booleans (true = allowed, false = disallowed).\n     */\n    function updateAllowedAggregatorIds(string[] calldata _aggregatorIds, bool[] calldata _statuses) external onlyOwner {\n        uint256 aggregatorsLength_ = _aggregatorIds.length;\n        if (aggregatorsLength_ != _statuses.length) revert InputLengthsMismatch();\n\n        for (uint256 i = 0; i < aggregatorsLength_; ++i) {\n            bytes32 aggregatorIdHash_ = keccak256(abi.encode(_aggregatorIds[i]));\n            bool status_ = _statuses[i];\n            if (isAggregatorAllowed[aggregatorIdHash_] != status_) {\n                isAggregatorAllowed[aggregatorIdHash_] = status_;\n\n                emit ChangedAggregatorIdStatus(aggregatorIdHash_, _aggregatorIds[i], status_);\n            }\n        }\n    }\n\n    ////////////////////////////// Private/Internal Methods //////////////////////////////\n\n    /**\n     * @notice Sends tokens or native token to a specified recipient.\n     * @param _token ERC20 token to send or address(0) for native token.\n     * @param _amount Amount of tokens or native token to send.\n     * @param _recipient Address to receive the funds.\n     * @dev Reverts if native token transfer fails.\n     */\n    function _sendTokens(IERC20 _token, uint256 _amount, address _recipient) private {\n        if (address(_token) == address(0)) {\n            (bool success_,) = _recipient.call{ value: _amount }(\"\");\n\n            if (!success_) revert FailedNativeTokenTransfer(_recipient);\n        } else {\n            IERC20(_token).safeTransfer(_recipient, _amount);\n        }\n\n        emit SentTokens(_token, _recipient, _amount);\n    }\n\n    /**\n     * @dev Validates that the tokens are whitelisted or not based on the _useTokenWhitelist flag.\n     * @dev Adds the argsCheckEnforcer args to later validate if the token whitelist must be have been used or not.\n     * @param _tokenFrom The input token of the swap.\n     * @param _tokenTo The output token of the swap.\n     * @param _delegations The delegation chain; the last delegation must include the ArgsEqualityCheckEnforcer.\n     * @param _useTokenWhitelist Flag indicating whether token whitelist checks should be enforced.\n     */\n    function _validateTokens(\n        IERC20 _tokenFrom,\n        IERC20 _tokenTo,\n        Delegation[] memory _delegations,\n        bool _useTokenWhitelist\n    )\n        private\n        view\n    {\n        // The Args Enforcer must be the first caveat in the root delegation\n        uint256 lastIndex_ = _delegations.length - 1;\n        if (\n            _delegations[lastIndex_].caveats.length == 0\n                || _delegations[lastIndex_].caveats[0].enforcer != argsEqualityCheckEnforcer\n        ) {\n            revert MissingArgsEqualityCheckEnforcer();\n        }\n\n        // The args are set by this contract depending on the useTokenWhitelist flag\n        if (_useTokenWhitelist) {\n            if (!isTokenAllowed[_tokenFrom]) revert TokenFromIsNotAllowed(_tokenFrom);\n            if (!isTokenAllowed[_tokenTo]) revert TokenToIsNotAllowed(_tokenTo);\n            _delegations[lastIndex_].caveats[0].args = abi.encode(WHITELIST_ENFORCED);\n        } else {\n            _delegations[lastIndex_].caveats[0].args = abi.encode(WHITELIST_NOT_ENFORCED);\n        }\n    }\n\n    /**\n     * @dev Internal helper to decode aggregator data from `apiData`.\n     * @param _apiData Bytes that includes aggregatorId, tokenFrom, amountFrom, and the aggregator swap data.\n     */\n    function _decodeApiData(bytes calldata _apiData)\n        private\n        pure\n        returns (string memory aggregatorId_, IERC20 tokenFrom_, IERC20 tokenTo_, uint256 amountFrom_, bytes memory swapData_)\n    {\n        bytes4 functionSelector_ = bytes4(_apiData[:4]);\n        if (functionSelector_ != IMetaSwap.swap.selector) revert InvalidSwapFunctionSelector();\n\n        // Excluding the function selector\n        bytes memory paramTerms_ = _apiData[4:];\n        (aggregatorId_, tokenFrom_, amountFrom_, swapData_) = abi.decode(paramTerms_, (string, IERC20, uint256, bytes));\n\n        // Note: Prepend address(0) to format the data correctly because of the Swaps API. See internal docs.\n        (\n            , // address(0)\n            IERC20 swapTokenFrom_,\n            IERC20 swapTokenTo_,\n            uint256 swapAmountFrom_,\n            , // AmountTo\n            , // Metadata\n            uint256 feeAmount_,\n            , // FeeWallet\n            bool feeTo_\n        ) = abi.decode(\n            abi.encodePacked(abi.encode(address(0)), swapData_),\n            (address, IERC20, IERC20, uint256, uint256, bytes, uint256, address, bool)\n        );\n\n        if (swapTokenFrom_ != tokenFrom_) revert TokenFromMismath();\n\n        // When the fee is deducted from the tokenFrom the (feeAmount) plus the amount actually swapped (swapAmountFrom)\n        // must equal the total provided (amountFrom); otherwise, the input is inconsistent.\n        if (!feeTo_ && (feeAmount_ + swapAmountFrom_ != amountFrom_)) revert AmountFromMismath();\n\n        tokenTo_ = swapTokenTo_;\n    }\n\n    /**\n     * @dev Returns this contract's balance of the specified ERC20 token.\n     *      If `_token` is address(0), it returns the native token balance.\n     * @param _token The token to check balance for.\n     * @return balance_ The balance of the specified token.\n     */\n    function _getSelfBalance(IERC20 _token) private view returns (uint256 balance_) {\n        if (address(_token) == address(0)) return address(this).balance;\n\n        return _token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Validates the expiration and signature of the provided apiData.\n     * @param _signatureData Contains the apiData, the expiration and signature.\n     */\n    function _validateSignature(SignatureData memory _signatureData) private view {\n        if (block.timestamp > _signatureData.expiration) revert SignatureExpired();\n\n        bytes32 messageHash_ = keccak256(abi.encodePacked(_signatureData.apiData, _signatureData.expiration));\n        bytes32 ethSignedMessageHash_ = MessageHashUtils.toEthSignedMessageHash(messageHash_);\n\n        address recoveredSigner_ = ECDSA.recover(ethSignedMessageHash_, _signatureData.signature);\n        if (recoveredSigner_ != swapApiSigner) revert InvalidApiSignature();\n    }\n}\n"
    }
}