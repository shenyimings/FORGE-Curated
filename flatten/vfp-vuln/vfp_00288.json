{
    "vfp_id": "vfp_00288",
    "project_name": "Lido V3 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Bypassing Quarantine and Reusing the Same Report Allows Minting Uncollateralized stETH",
            "description": "This vulnerability enables an attacker to mint uncollateralized stETH by exploiting flaws in the quarantine mechanism and report reuse logic during vault disconnect/reconnect cycles. The root cause stems from multiple issues: the quarantine state is not cleared upon vault disconnection, outdated reports can be reused after reconnection, and there is no validation preventing the reuse of the same oracle report across multiple update cycles. An attacker can deposit a large amount of ETH directly to the vault (bypassing inOutDelta tracking), trigger a report that places the excess value into quarantine, disconnect and reconnect the vault multiple times while reusing stale reports, and eventually apply the same report after withdrawal of funds to falsely inflate the vault's total value. This allows the attacker to mint stETH against phantom collateral that no longer exists, resulting in severe protocol insolvency and loss of funds for stETH holders.\n",
            "severity": "Critical",
            "location": [
                "LazyOracle::updateVaultData",
                "VaultHub::voluntaryDisconnect",
                "VaultHub::_deleteVault"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/LazyOracle.sol",
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "Incorrect Maximum Liability Shares Validation in LazyOracle",
            "description": "The `_handleSanityChecks` function in the `LazyOracle` contract incorrectly reverts when the on-chain `maxLiabilityShares` is greater than the oracle-reported `_maxLiabilityShares`. This validation assumes that the oracle-reported value must always be greater than or equal to the current on-chain value, which fails to account for legitimate share mints that can occur between the time the oracle observes the state and when the report is submitted. As a result, valid oracle reports may be rejected if shares were minted during this window. This can disrupt normal vault operations, prevent state updates, and block critical recovery mechanisms such as force rebalancing and validator exits, effectively freezing the vault until a new report is submitted.\n",
            "severity": "Critical",
            "location": [
                "LazyOracle.sol::L445-L448"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/LazyOracle.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Quarantine State Not Cleared on Vault Disconnection",
            "description": "When a vault is voluntarily disconnected via `VaultHub.voluntaryDisconnect`, the `_deleteVault` function deletes various on-chain records but fails to clear the corresponding `vaultQuarantine` state in the `LazyOracle` contract. This leaves behind stale quarantine data for the disconnected vault. If the same vault is later reconnected, this residual quarantine state can be exploited to bypass intended safeguards. Specifically, an expired quarantine can be instantly reported and applied, allowing the vault to recognize an inflated total value without undergoing the required quarantine period. This behavior was leveraged in another finding to enable the minting of uncollateralized stETH, leading to potential loss of funds.\n",
            "severity": "Critical",
            "location": [
                "VaultHub.sol::L665-L671",
                "VaultHub.sol::L1223-L1235",
                "LazyOracle.sol::L82-L85"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol",
                "core/contracts/0.8.25/vaults/LazyOracle.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Quarantine Bypass Allows Using Reported Value Instantly",
            "description": "The quarantine mechanism is designed to delay the recognition of large increases in a vault’s reported value by quarantining excess amounts for a cooldown period. However, due to flawed logic in the `_processTotalValue` function, an expired quarantine entry is not properly cleared. If a slashing event occurs after a value increase is quarantined, subsequent reports within the allowed threshold do not trigger the quarantine branch, leaving the quarantine active but expired. Later, when a new large increase is reported, the system checks against the old `pendingTotalValueIncrease` and may incorrectly allow the full value to be applied immediately—bypassing the quarantine entirely. This allows an attacker to manipulate the vault’s total value without waiting for the cooldown, potentially leading to the minting of unbacked stETH and resulting in significant financial loss.\n",
            "severity": "Critical",
            "location": [
                "LazyOracle.sol::L316-L361"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/LazyOracle.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "A Vault Can Submit an Outdated Report After Reconnection",
            "description": "A vault can disconnect and reconnect to the `VaultHub` in quick succession, during which it can apply the same outdated oracle report twice—once to finalize disconnection and again after reconnection. Since the latest oracle report remains valid (timestamp-wise) after reconnection, it can be reused even though the vault’s actual balance has changed significantly (e.g., after withdrawing 99 ETH). Although the difference should be quarantined, the previously identified issue (quarantine state not cleared) allows bypassing this safeguard. As a result, the vault can falsely report a much higher total value than its actual on-chain balance, leading to incorrect accounting and potential exploitation of the system for uncollateralized minting.\n",
            "severity": "Critical",
            "location": [],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-460"
                ]
            },
            "title": "Broken Disconnection Flow Enables CONNECT_DEPOSIT Bypass and Tier Accounting Drift",
            "description": "During the disconnection process in `VaultHub`, the `CONNECT_DEPOSIT` is unlocked early by setting `_record.locked = 0`, allowing it to be used for fee settlement. However, if a slashing event occurs before disconnection finalization, the process is aborted, but the deposit is not restored. This allows the vault to operate without the required collateral. Additionally, the vault is immediately demoted to the default Tier in `OperatorGrid` upon initiating disconnection, but if disconnection fails, it continues operating under its original Tier rules in `VaultHub`, creating a desynchronization. This mismatch enables the vault to retain favorable parameters from a higher Tier while being subject to looser limits in `OperatorGrid`, potentially allowing it to bypass share and group limits and disrupt system-wide accounting integrity.\n",
            "severity": "Critical",
            "location": [
                "VaultHub.sol::L1018-L1019",
                "VaultHub.sol::L524-L525",
                "VaultHub.sol::L1021-L1023"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Rebalance Doesn’t Take Into Account locked Amount and Obligations",
            "description": "The `_rebalance` function in `VaultHub` allows a vault to withdraw funds via rebalancing without verifying that sufficient funds remain to cover the `locked` amount (such as the connection deposit) and unsettled obligations (like slashing reserve or fees). While other withdrawal paths enforce these checks, rebalancing only ensures that the rebalanced amount does not exceed the total value. This gap allows a vault owner to drain funds below required reserve levels, undermining the system’s safety mechanisms. After rebalancing the full amount, additional shares can be minted, increasing liability beyond what is properly backed, which could lead to insolvency or bad debt in the event of slashing or withdrawal demands.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::L1469-L1480",
                "VaultHub.sol::L1050-L1061"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Vault Fees Can Be Indefinitely Deferred",
            "description": "A vault owner can avoid paying Lido fees indefinitely by maintaining a zero balance in the vault while keeping all funds staked on the Consensus Layer. The `_planLidoTransfer` function uses `_vault.balance` to determine how much can be transferred for fees; if the balance is zero, no transfer occurs, and fees accumulate in `unsettledLidoFees`. Although beacon chain deposits are paused when unsettled fees exceed 1 ETH, this restriction can be circumvented using validator consolidations, which do not require new deposits. This allows vault owners to delay fee payments strategically based on market conditions, reducing their overall cost and increasing systemic risk due to accumulating unpaid obligations.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::L859-L865",
                "VaultHub.sol::L559"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Fresh Report Requirements Enable Operations on Stale Vault Data",
            "description": "Several critical functions in the `VaultHub` contract, such as `disconnect`, `voluntaryDisconnect`, `forceValidatorExit`, and others, do not require a recent oracle report before execution. This allows operations to proceed based on outdated vault state, potentially leading to incorrect decisions based on stale data. For example, a forced validator exit could be triggered without up-to-date knowledge of the vault’s actual health or obligations. This increases the risk of erroneous actions that could harm the vault or the broader system. While some functions were later updated to include freshness checks, the absence of such validations in key flows originally created a window for manipulation and inconsistent state handling.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol",
                "core/contracts/0.8.25/vaults/OperatorGrid.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Multiple functions in `VaultHub` and `OperatorGrid` lack fresh Oracle report validation",
            "description": "Several functions in the `VaultHub` and `OperatorGrid` contracts do not validate that an Oracle report is fresh before proceeding, allowing operations based on outdated vault state. This leads to multiple vulnerabilities.\n\nThe root cause is the absence of a `_requireFreshReport` check in critical functions, which allows stale data to be used for decision-making. For example, `disconnect` and `voluntaryDisconnect` can be initiated using stale `VaultRecord` data, leading to a soft-lock if fee settlement fails due to insufficient EL balance when a fresh report is finally applied. Similarly, `changeTier` allows manipulation of fee obligations by changing tiers before reporting, and `triggerValidatorWithdrawals` and `forceValidatorExit` can be called on unhealthy vaults due to stale health checks.\n\nAn attacker could exploit this by delaying Oracle report submissions while accruing fees, then initiating disconnection to trigger a revert during fee settlement, leaving the vault in a soft-locked state. They could also manipulate fee tiers before reporting to reduce their fee obligations retroactively, or execute validator exits on unhealthy vaults.\n\nThe impact includes vault soft-locking, potential loss of staking rewards, incorrect fee calculations, and unintended validator exits, all of which compromise the system's reliability and economic security.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::disconnect#L524-L529",
                "VaultHub.sol::voluntaryDisconnect",
                "OperatorGrid.sol::changeTier",
                "VaultHub.sol::triggerValidatorWithdrawals",
                "VaultHub.sol::forceValidatorExit",
                "VaultHub.sol::pauseBeaconChainDeposits",
                "VaultHub.sol::resumeBeaconChainDeposits",
                "VaultHub.sol::requestValidatorExit"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol",
                "core/contracts/0.8.25/vaults/OperatorGrid.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Force Disconnect Does Not Enforce Fee Distribution",
            "description": "When a vault is disconnected forcefully via `VaultHub.disconnect`, the node operator fees are not disbursed, unlike in `voluntaryDisconnect`, which explicitly calls `disburseNodeOperatorFee()`.\n\nThe root cause is the absence of a fee disbursement step in the `disconnect` function, creating an inconsistency between voluntary and forced disconnection flows.\n\nA malicious vault owner could initiate a forced disconnect to avoid paying accrued NO fees, especially if the vault is under governance control and the disconnect is triggered without prior fee settlement.\n\nThe impact is financial loss for node operators who are denied their rightful fees, potentially discouraging participation and reducing protocol security.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::disconnect#L494-L498",
                "VaultHub.sol::voluntaryDisconnect#L665-L671",
                "Dashboard.sol::voluntaryDisconnect#L254-L258"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Inconsistent share limit applied during debt socialization",
            "description": "In the `socializeVaultDebt` function, the receiving vault's `_shareLimit` is set based on its current locked amount in shares rather than using the configured `shareLimit` from its Tier parameters. Additionally, `_maxMintableRatioBP` is set to 100%, contradicting the reserve ratio safety buffer.\n\nThe root cause is the incorrect assignment of `_shareLimit` and `_maxMintableRatioBP` parameters during debt transfer, which reduces the destination vault's capacity to absorb bad debt and risks over-leveraging.\n\nAn attacker could exploit this by manipulating the timing of debt socialization to force unhealthy absorption of bad debt, potentially destabilizing the receiving vault.\n\nThe impact is increased risk of insolvency for the receiving vault and potential systemic instability due to improper risk distribution.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::socializeVaultDebt#L596-L597"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Disconnect Can Happen Instantly",
            "description": "The `disconnect` and `voluntaryDisconnect` functions allow disconnection to complete immediately upon the next Oracle report, potentially in the same or next block, without a cooldown period.\n\nThe root cause is the lack of a timestamp check requiring the Oracle report to be newer than the disconnection initiation time, allowing instant completion.\n\nAn attacker could exploit this by triggering disconnection and immediately submitting a fresh report to finalize it, bypassing any observation window for delayed slashing updates or debt socialization.\n\nThe impact is reduced operational safety, as there is no time to detect and respond to post-disconnect risks, potentially leading to premature release of ownership and state clearance.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::disconnect",
                "VaultHub.sol::voluntaryDisconnect",
                "VaultHub.sol::applyVaultReport"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "`slashingReserve` Is Not Accounted for When Applying a Report",
            "description": "The `applyVaultReport` function does not include the `slashingReserve` when calculating the `lockedEther` value, only considering `connect_deposit` and `mint_collateral`.\n\nThe root cause is the omission of `slashingReserve` in the `Math256.max` calculation, undermining the intended safety mechanism for validator slashing protection.\n\nAn attacker could exploit this by operating a vault near the edge of collateralization, relying on the missing reserve to appear healthy while being under-secured against slashing events.\n\nThe impact is increased protocol risk exposure to slashing events, potentially leading to under-collateralized positions and losses for stETH holders.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::applyVaultReport#L1037-L1040"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "New Redemptions Don’t Take Into Account the Current Status",
            "description": "The `setVaultRedemptions` function overwrites the `redemptions` value without checking its current state, creating a race condition that can lead to over-redemption.\n\nThe root cause is the lack of reconciliation between new and existing redemption values before assignment.\n\nAn attacker could exploit this by timing a redemption update just after the current redemptions are processed, causing the new value to be treated as entirely new, leading to double redemption.\n\nThe impact is over-rebalancing of the vault, potentially leading to incorrect stETH minting or burning and financial loss.\n",
            "severity": "Medium",
            "location": [
                "VaultHub.sol::setVaultRedemptions#L892-L907"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultHub.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Report Reuse Validation",
            "description": "The `updateVaultData` function in `LazyOracle` does not prevent replay of the same Oracle report, allowing an attacker to reapply a report after disconnection.\n\nThe root cause is the lack of a nonce or timestamp validation to ensure reports are used only once.\n\nAn attacker could exploit this by disconnecting, withdrawing funds, reconnecting, and replaying an old report to mint stETH against a higher total value.\n\nThe impact is potential minting of uncollateralized stETH, leading to direct financial loss for the protocol.\n",
            "severity": "Medium",
            "location": [
                "LazyOracle.sol::updateVaultData#L248-L289"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/LazyOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultHub.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {Math256} from \"contracts/common/lib/Math256.sol\";\nimport {ILidoLocator} from \"contracts/common/interfaces/ILidoLocator.sol\";\nimport {ILido} from \"contracts/common/interfaces/ILido.sol\";\nimport {IHashConsensus} from \"contracts/common/interfaces/IHashConsensus.sol\";\n\nimport {IStakingVault} from \"./interfaces/IStakingVault.sol\";\nimport {IPredepositGuarantee} from \"./interfaces/IPredepositGuarantee.sol\";\n\nimport {OperatorGrid} from \"./OperatorGrid.sol\";\nimport {LazyOracle} from \"./LazyOracle.sol\";\n\nimport {PausableUntilWithRoles} from \"../utils/PausableUntilWithRoles.sol\";\nimport {RefSlotCache} from \"./lib/RefSlotCache.sol\";\n\n/// @notice VaultHub is a contract that manages StakingVaults connected to the Lido protocol\n/// It allows to connect and disconnect vaults, mint and burn stETH using vaults as collateral\n/// Also, it facilitates the individual per-vault reports from the lazy oracle to the vaults and charges Lido fees\n/// @author folkyatina\ncontract VaultHub is PausableUntilWithRoles {\n    using RefSlotCache for RefSlotCache.Uint112WithRefSlotCache;\n    using RefSlotCache for RefSlotCache.Int112WithRefSlotCache;\n\n    // -----------------------------\n    //           STORAGE STRUCTS\n    // -----------------------------\n    /// @custom:storage-location erc7201:VaultHub\n    struct Storage {\n        /// @notice vault proxy contract codehashes allowed for connecting\n        mapping(bytes32 codehash => bool allowed) codehashes;\n        /// @notice accounting records for each vault\n        mapping(address vault => VaultRecord) records;\n        /// @notice connection parameters for each vault\n        mapping(address vault => VaultConnection) connections;\n        /// @notice obligation values for each vault\n        mapping(address vault => VaultObligations) obligations;\n        /// @notice 1-based array of vaults connected to the hub. index 0 is reserved for not connected vaults\n        address[] vaults;\n        /// @notice amount of bad debt that was internalized from the vault to become the protocol loss\n        RefSlotCache.Uint112WithRefSlotCache badDebtToInternalize;\n    }\n\n    struct VaultConnection {\n        // ### 1st slot\n        /// @notice address of the vault owner\n        address owner;\n        /// @notice maximum number of stETH shares that can be minted by vault owner\n        uint96 shareLimit;\n        // ### 2nd slot\n        /// @notice index of the vault in the list of vaults. Indexes is guaranteed to be stable only if there was no deletions.\n        /// @dev vaultIndex is always greater than 0\n        uint96 vaultIndex;\n        /// @notice if true, vault is disconnected and fee is not accrued\n        bool pendingDisconnect;\n        /// @notice share of ether that is locked on the vault as an additional reserve\n        /// e.g RR=30% means that for 1stETH minted 1/(1-0.3)=1.428571428571428571 ETH is locked on the vault\n        uint16 reserveRatioBP;\n        /// @notice if vault's reserve decreases to this threshold, it should be force rebalanced\n        uint16 forcedRebalanceThresholdBP;\n        /// @notice infra fee in basis points\n        uint16 infraFeeBP;\n        /// @notice liquidity fee in basis points\n        uint16 liquidityFeeBP;\n        /// @notice reservation fee in basis points\n        uint16 reservationFeeBP;\n        /// @notice if true, vault owner manually paused the beacon chain deposits\n        bool isBeaconDepositsManuallyPaused;\n        /// 64 bits gap\n    }\n\n    struct VaultRecord {\n        // ### 1st slot\n        /// @notice latest report for the vault\n        Report report;\n        // ### 2nd slot\n        /// @notice amount of ether that is locked from withdrawal on the vault\n        uint128 locked;\n        /// @notice liability shares of the vault\n        uint96 liabilityShares;\n        // ### 3rd slot\n        /// @notice inOutDelta of the vault (all deposits - all withdrawals)\n        RefSlotCache.Int112WithRefSlotCache inOutDelta;\n    }\n\n    struct Report {\n        /// @notice total value of the vault\n        uint112 totalValue;\n        /// @notice inOutDelta of the report\n        int112 inOutDelta;\n        /// @notice last 32 bits of the timestamp (in seconds)\n        uint32 timestamp;\n    }\n\n    /**\n     *  Obligations of the vaults towards the Lido protocol.\n     *  While any part of those obligations remains unsettled, VaultHub may want to limit what the vault can do.\n     *\n     *  Obligations have two types:\n     *  1. Redemptions. Under extreme conditions Lido protocol may rebalance the part of the vault's liability to serve\n     *     the Lido Core withdrawal queue requests to guarantee that every stETH is redeemable. Calculated in ether.\n     *  2. Lido fees. Record of infra, liquidity and reservation fees charged to the vault. Charged in ether on every\n     *     oracle report.\n     *\n     *  Obligations settlement:\n     *  - Lido fees are settled by transferring ether to the Lido protocol treasury\n     *  - Redemptions are settled by rebalancing the vault or by burning stETH on the vault\n     *  - Obligations may be settled manually using the `settleVaultObligations` function\n     *  - Obligations try to automatically settle:\n     *    - every time oracle report is applied to the vault\n     *    - on resume of the beacon chain deposits\n     *    - on disconnect initiation\n     *  - Lido fees are automatically settled on the final report that completes the disconnection process\n     *\n     *  Constraints until obligations settled:\n     *  - Beacon chain deposits are paused while unsettled obligations ≥ OBLIGATIONS_THRESHOLD (1 ETH)\n     *  - Unsettled obligations can't be withdrawn\n     *  - Minting new stETH is limited by unsettled Lido fees (NB: redemptions do not affect minting capacity)\n     *  - Vault disconnect is refused until both unsettled redemptions and Lido fees obligations hit zero\n     *\n     * @dev NB: Under extreme conditions, Lido protocol may trigger validator exits to withdraw ether to the vault and\n     *          rebalance it to settle redemptions.\n     */\n    struct VaultObligations {\n        /// @notice cumulative value for Lido fees that were settled on the vault\n        uint128 settledLidoFees;\n        /// @notice current unsettled Lido fees amount\n        uint128 unsettledLidoFees;\n        /// @notice current unsettled redemptions amount\n        uint128 redemptions;\n    }\n\n    // -----------------------------\n    //           CONSTANTS\n    // -----------------------------\n\n    // keccak256(abi.encode(uint256(keccak256(\"VaultHub\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant STORAGE_LOCATION = 0xb158a1a9015c52036ff69e7937a7bb424e82a8c4cbec5c5309994af06d825300;\n\n    /// @notice role that allows to connect vaults to the hub\n    bytes32 public constant VAULT_MASTER_ROLE = keccak256(\"vaults.VaultHub.VaultMasterRole\");\n    /// @notice role that allows to set allowed codehashes\n    bytes32 public constant VAULT_CODEHASH_SET_ROLE = keccak256(\"vaults.VaultHub.VaultCodehashSetRole\");\n    /// @notice role that allows to accrue Lido Core redemptions on the vault\n    bytes32 public constant REDEMPTION_MASTER_ROLE = keccak256(\"vaults.VaultHub.RedemptionMasterRole\");\n    /// @notice role that allows to trigger validator exits under extreme conditions\n    bytes32 public constant VALIDATOR_EXIT_ROLE = keccak256(\"vaults.VaultHub.ValidatorExitRole\");\n    /// @notice role that allows to bail out vaults with bad debt\n    bytes32 public constant BAD_DEBT_MASTER_ROLE = keccak256(\"vaults.VaultHub.BadDebtMasterRole\");\n    /// @notice amount of ETH that is locked on the vault on connect and can be withdrawn on disconnect only\n    uint256 public constant CONNECT_DEPOSIT = 1 ether;\n\n    /// @notice The time delta for report freshness check\n    uint256 public constant REPORT_FRESHNESS_DELTA = 2 days;\n\n    /// @dev basis points base\n    uint256 internal constant TOTAL_BASIS_POINTS = 100_00;\n    /// @notice length of the validator pubkey in bytes\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n    /// @dev max value for fees in basis points - it's about 650%\n    uint256 internal constant MAX_FEE_BP = type(uint16).max;\n\n    /// @notice codehash of the account with no code\n    bytes32 private constant EMPTY_CODEHASH = keccak256(\"\");\n\n    /// @notice no limit for the unsettled obligations on settlement\n    uint256 internal constant MAX_UNSETTLED_ALLOWED = type(uint256).max;\n    /// @notice threshold for the unsettled obligations that will activate the beacon chain deposits pause\n    uint256 internal constant UNSETTLED_THRESHOLD = 1 ether;\n    /// @notice no unsettled obligations allowed on settlement\n    uint256 internal constant NO_UNSETTLED_ALLOWED = 0;\n\n    // -----------------------------\n    //           IMMUTABLES\n    // -----------------------------\n\n    /// @notice limit for a single vault share limit relative to Lido TVL in basis points\n    uint256 public immutable MAX_RELATIVE_SHARE_LIMIT_BP;\n\n    ILido public immutable LIDO;\n    ILidoLocator public immutable LIDO_LOCATOR;\n    IHashConsensus public immutable CONSENSUS_CONTRACT;\n\n    /// @param _locator Lido Locator contract\n    /// @param _lido Lido stETH contract\n    /// @param _consensusContract Hash consensus contract\n    /// @param _maxRelativeShareLimitBP Maximum share limit relative to TVL in basis points\n    constructor(ILidoLocator _locator, ILido _lido, IHashConsensus _consensusContract, uint256 _maxRelativeShareLimitBP) {\n        _requireNotZero(_maxRelativeShareLimitBP);\n        _requireLessThanBP(_maxRelativeShareLimitBP, TOTAL_BASIS_POINTS);\n\n        MAX_RELATIVE_SHARE_LIMIT_BP = _maxRelativeShareLimitBP;\n\n        LIDO_LOCATOR = _locator;\n        LIDO = _lido;\n        CONSENSUS_CONTRACT = _consensusContract;\n\n        _disableInitializers();\n    }\n\n    /// @dev used to perform rebalance operations\n    receive() external payable {}\n\n    /// @notice initialize the vault hub\n    /// @param _admin default admin address\n    function initialize(address _admin) external initializer {\n        _requireNotZero(_admin);\n\n        __AccessControlEnumerable_init();\n\n        // the stone in the elevator. index 0 is reserved for not connected vaults\n        _storage().vaults.push(address(0));\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n\n    /// @notice returns the number of vaults connected to the hub\n    /// @dev since index 0 is reserved for not connected vaults, it's always 1 less than the vaults array length\n    function vaultsCount() external view returns (uint256) {\n        return _storage().vaults.length - 1;\n    }\n\n    /// @notice returns the vault address by its index\n    /// @param _index index of the vault in the 1-based list of vaults. possible range [1, vaultsCount()]\n    /// @dev Indexes is guaranteed to be stable only in one transaction.\n    function vaultByIndex(uint256 _index) external view returns (address) {\n        _requireNotZero(_index);\n        return _storage().vaults[_index];\n    }\n\n    /// @return connection parameters struct for the given vault\n    /// @dev it returns empty struct if the vault is not connected to the hub\n    /// @dev it may return connection even if it's pending to be disconnected\n    function vaultConnection(address _vault) external view returns (VaultConnection memory) {\n        return _vaultConnection(_vault);\n    }\n\n    /// @return the accounting record struct for the given vault\n    /// @dev it returns empty struct if the vault is not connected to the hub\n    function vaultRecord(address _vault) external view returns (VaultRecord memory) {\n        return _vaultRecord(_vault);\n    }\n\n    /// @return the obligations struct for the given vault\n    /// @dev returns empty struct if the vault is not connected to the hub\n    function vaultObligations(address _vault) external view returns (VaultObligations memory) {\n        return _vaultObligations(_vault);\n    }\n\n    /// @return true if the vault is connected to the hub\n    function isVaultConnected(address _vault) external view returns (bool) {\n        return _vaultConnection(_vault).vaultIndex != 0;\n    }\n\n    /// @return total value of the vault\n    /// @dev returns 0 if the vault is not connected\n    function totalValue(address _vault) external view returns (uint256) {\n        return _totalValue(_vaultRecord(_vault));\n    }\n\n    /// @return liability shares of the vault\n    /// @dev returns 0 if the vault is not connected\n    function liabilityShares(address _vault) external view returns (uint256) {\n        return _vaultRecord(_vault).liabilityShares;\n    }\n\n    /// @return locked amount of ether for the vault\n    /// @dev returns 0 if the vault is not connected\n    function locked(address _vault) external view returns (uint256) {\n        return _vaultRecord(_vault).locked;\n    }\n\n    /// @return the amount of ether that can be locked in the vault given the current total value\n    /// @dev returns 0 if the vault is not connected\n    function maxLockableValue(address _vault) external view returns (uint256) {\n        return _maxLockableValue(_vaultRecord(_vault), _vaultObligations(_vault));\n    }\n\n    /// @return the amount of ether that can be instantly withdrawn from the staking vault\n    /// @dev returns 0 if the vault is not connected\n    /// @dev check for `pendingDisconnect = false` before using this function to avoid reverts\n    function withdrawableValue(address _vault) external view returns (uint256) {\n        return _withdrawableValue(_vault, _vaultRecord(_vault));\n    }\n\n    /// @return latest report for the vault\n    /// @dev returns empty struct if the vault is not connected\n    function latestReport(address _vault) external view returns (Report memory) {\n        return _vaultRecord(_vault).report;\n    }\n\n    /// @return true if the report for the vault is fresh, false otherwise\n    /// @dev returns false if the vault is not connected\n    function isReportFresh(address _vault) external view returns (bool) {\n        return _isReportFresh(_vaultRecord(_vault));\n    }\n\n    /// @notice checks if the vault is healthy by comparing its total value after applying forced rebalance threshold\n    ///         against current liability shares\n    /// @param _vault vault address\n    /// @return true if vault is healthy, false otherwise\n    /// @dev returns true if the vault is not connected\n    function isVaultHealthy(address _vault) external view returns (bool) {\n        return _isVaultHealthy(_vaultConnection(_vault), _vaultRecord(_vault));\n    }\n\n    /// @notice calculate shares amount to make the vault healthy using rebalance\n    /// @param _vault vault address\n    /// @return amount of shares to rebalance or UINT256_MAX if it's impossible to make the vault healthy using rebalance\n    /// @dev returns 0 if the vault is not connected\n    function rebalanceShortfall(address _vault) external view returns (uint256) {\n        return _rebalanceShortfall(_vaultConnection(_vault), _vaultRecord(_vault));\n    }\n\n    /// @notice amount of bad debt to be internalized to become the protocol loss\n    function badDebtToInternalizeAsOfLastRefSlot() external view returns (uint256) {\n        return _storage().badDebtToInternalize.getValueForLastRefSlot(CONSENSUS_CONTRACT);\n    }\n\n    /// @notice inOutDelta of the vault as of the last refSlot\n    /// @param _vault vault address\n    /// @return inOutDelta of the vault as of the last refSlot\n    /// @dev returns 0 if the vault is not connected\n    function inOutDeltaAsOfLastRefSlot(address _vault) external view returns (int256) {\n        return _vaultRecord(_vault).inOutDelta.getValueForLastRefSlot(CONSENSUS_CONTRACT);\n    }\n\n    /// @notice Set if a vault proxy codehash is allowed to be connected to the hub\n    /// @param _codehash vault proxy codehash\n    /// @param _allowed true to add, false to remove\n    /// @dev msg.sender must have VAULT_CODEHASH_SET_ROLE\n    function setAllowedCodehash(bytes32 _codehash, bool _allowed) external onlyRole(VAULT_CODEHASH_SET_ROLE) {\n        _requireNotZero(uint256(_codehash));\n        if (_codehash == EMPTY_CODEHASH) revert ZeroCodehash();\n\n        _storage().codehashes[_codehash] = _allowed;\n\n        emit AllowedCodehashUpdated(_codehash, _allowed);\n    }\n\n    /// @notice connects a vault to the hub in permissionless way, get limits from the Operator Grid\n    /// @param _vault vault address\n    /// @dev vault should have transferred ownership to the VaultHub contract\n    function connectVault(address _vault) external whenResumed {\n        _requireNotZero(_vault);\n\n        IStakingVault vault_ = IStakingVault(_vault);\n        if (vault_.pendingOwner() != address(this)) revert VaultHubNotPendingOwner(_vault);\n        if (vault_.isOssified()) revert VaultOssified(_vault);\n        if (vault_.depositor() != address(_predepositGuarantee())) revert PDGNotDepositor(_vault);\n\n        (\n            , // nodeOperatorInTier\n            , // tierId\n            uint256 shareLimit,\n            uint256 reserveRatioBP,\n            uint256 forcedRebalanceThresholdBP,\n            uint256 infraFeeBP,\n            uint256 liquidityFeeBP,\n            uint256 reservationFeeBP\n        ) = _operatorGrid().vaultInfo(_vault);\n\n        _connectVault(_vault,\n            shareLimit,\n            reserveRatioBP,\n            forcedRebalanceThresholdBP,\n            infraFeeBP,\n            liquidityFeeBP,\n            reservationFeeBP\n        );\n\n        IStakingVault(_vault).acceptOwnership();\n\n        emit VaultConnected({\n            vault: _vault,\n            shareLimit: shareLimit,\n            reserveRatioBP: reserveRatioBP,\n            forcedRebalanceThresholdBP: forcedRebalanceThresholdBP,\n            infraFeeBP: infraFeeBP,\n            liquidityFeeBP: liquidityFeeBP,\n            reservationFeeBP: reservationFeeBP\n        });\n    }\n\n    /// @notice updates share limit for the vault\n    /// Setting share limit to zero actually pause the vault's ability to mint\n    /// @param _vault vault address\n    /// @param _shareLimit new share limit\n    /// @dev msg.sender must have VAULT_MASTER_ROLE\n    function updateShareLimit(address _vault, uint256 _shareLimit) external onlyRole(VAULT_MASTER_ROLE) {\n        _requireNotZero(_vault);\n        _requireSaneShareLimit(_shareLimit);\n\n        VaultConnection storage connection = _checkConnection(_vault);\n        connection.shareLimit = uint96(_shareLimit);\n\n        emit VaultShareLimitUpdated(_vault, _shareLimit);\n    }\n\n    /// @notice updates fees for the vault\n    /// @param _vault vault address\n    /// @param _infraFeeBP new infra fee in basis points\n    /// @param _liquidityFeeBP new liquidity fee in basis points\n    /// @param _reservationFeeBP new reservation fee in basis points\n    /// @dev msg.sender must have VAULT_MASTER_ROLE\n    function updateVaultFees(\n        address _vault,\n        uint256 _infraFeeBP,\n        uint256 _liquidityFeeBP,\n        uint256 _reservationFeeBP\n    ) external onlyRole(VAULT_MASTER_ROLE) {\n        _requireNotZero(_vault);\n        _requireLessThanBP(_infraFeeBP, MAX_FEE_BP);\n        _requireLessThanBP(_liquidityFeeBP, MAX_FEE_BP);\n        _requireLessThanBP(_reservationFeeBP, MAX_FEE_BP);\n\n        VaultConnection storage connection = _checkConnection(_vault);\n        uint16 preInfraFeeBP = connection.infraFeeBP;\n        uint16 preLiquidityFeeBP = connection.liquidityFeeBP;\n        uint16 preReservationFeeBP = connection.reservationFeeBP;\n\n        connection.infraFeeBP = uint16(_infraFeeBP);\n        connection.liquidityFeeBP = uint16(_liquidityFeeBP);\n        connection.reservationFeeBP = uint16(_reservationFeeBP);\n\n        emit VaultFeesUpdated({\n            vault: _vault,\n            preInfraFeeBP: preInfraFeeBP,\n            preLiquidityFeeBP: preLiquidityFeeBP,\n            preReservationFeeBP: preReservationFeeBP,\n            infraFeeBP: _infraFeeBP,\n            liquidityFeeBP: _liquidityFeeBP,\n            reservationFeeBP: _reservationFeeBP\n        });\n    }\n\n    /// @notice updates the vault's connection parameters\n    /// @dev Reverts if the vault is not healthy as of latest report\n    /// @param _vault vault address\n    /// @param _shareLimit new share limit\n    /// @param _reserveRatioBP new reserve ratio\n    /// @param _forcedRebalanceThresholdBP new forced rebalance threshold\n    /// @param _infraFeeBP new infra fee\n    /// @param _liquidityFeeBP new liquidity fee\n    /// @param _reservationFeeBP new reservation fee\n    function updateConnection(\n        address _vault,\n        uint256 _shareLimit,\n        uint256 _reserveRatioBP,\n        uint256 _forcedRebalanceThresholdBP,\n        uint256 _infraFeeBP,\n        uint256 _liquidityFeeBP,\n        uint256 _reservationFeeBP\n    ) external {\n        _requireSender(address(_operatorGrid()));\n        _requireSaneShareLimit(_shareLimit);\n\n        VaultConnection storage connection = _checkConnection(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n\n        uint256 totalValue_ = _totalValue(record);\n        uint256 liabilityShares_ = record.liabilityShares;\n\n        if (_isThresholdBreached(totalValue_, liabilityShares_, _reserveRatioBP)) {\n            revert VaultMintingCapacityExceeded(_vault, totalValue_, liabilityShares_, _reserveRatioBP);\n        }\n\n        connection.shareLimit = uint96(_shareLimit);\n        connection.reserveRatioBP = uint16(_reserveRatioBP);\n        connection.forcedRebalanceThresholdBP = uint16(_forcedRebalanceThresholdBP);\n        connection.infraFeeBP = uint16(_infraFeeBP);\n        connection.liquidityFeeBP = uint16(_liquidityFeeBP);\n        connection.reservationFeeBP = uint16(_reservationFeeBP);\n\n        emit VaultConnectionUpdated({\n            vault: _vault,\n            shareLimit: _shareLimit,\n            reserveRatioBP: _reserveRatioBP,\n            forcedRebalanceThresholdBP: _forcedRebalanceThresholdBP,\n            infraFeeBP: _infraFeeBP,\n            liquidityFeeBP: _liquidityFeeBP,\n            reservationFeeBP: _reservationFeeBP\n        });\n    }\n\n    /// @notice disconnect a vault from the hub\n    /// @param _vault vault address\n    /// @dev msg.sender must have VAULT_MASTER_ROLE\n    /// @dev vault's `liabilityShares` should be zero\n    function disconnect(address _vault) external onlyRole(VAULT_MASTER_ROLE) {\n        _initiateDisconnection(_vault, _checkConnection(_vault), _vaultRecord(_vault));\n\n        emit VaultDisconnectInitiated(_vault);\n    }\n\n    /// @notice update of the vault data by the lazy oracle report\n    /// @param _vault the address of the vault\n    /// @param _reportTimestamp the timestamp of the report (last 32 bits of it)\n    /// @param _reportTotalValue the total value of the vault\n    /// @param _reportInOutDelta the inOutDelta of the vault\n    /// @param _reportCumulativeLidoFees the cumulative Lido fees of the vault\n    /// @param _reportLiabilityShares the liabilityShares of the vault\n    function applyVaultReport(\n        address _vault,\n        uint256 _reportTimestamp,\n        uint256 _reportTotalValue,\n        int256 _reportInOutDelta,\n        uint256 _reportCumulativeLidoFees,\n        uint256 _reportLiabilityShares,\n        uint256 _reportSlashingReserve\n    ) external whenResumed {\n        _requireSender(address(_lazyOracle()));\n\n        VaultConnection storage connection = _vaultConnection(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n        VaultObligations storage obligations = _vaultObligations(_vault);\n\n        _checkAndUpdateLidoFeesObligations(_vault, obligations, _reportCumulativeLidoFees);\n\n        if (connection.pendingDisconnect) {\n            if (_reportSlashingReserve == 0 && record.liabilityShares == 0) {\n                _settleObligations(_vault, record, obligations, NO_UNSETTLED_ALLOWED);\n\n                IStakingVault(_vault).transferOwnership(connection.owner);\n                _deleteVault(_vault, connection);\n\n                emit VaultDisconnectCompleted(_vault);\n                return;\n            } else {\n                // we abort the disconnect process as there is a slashing conflict yet to be resolved\n                connection.pendingDisconnect = false;\n                emit VaultDisconnectAborted(_vault, _reportSlashingReserve);\n            }\n        }\n\n        _applyVaultReport(\n            record,\n            connection,\n            _reportTimestamp,\n            _reportTotalValue,\n            _reportLiabilityShares,\n            _reportInOutDelta\n        );\n\n        emit VaultReportApplied({\n            vault: _vault,\n            reportTimestamp: _reportTimestamp,\n            reportTotalValue: _reportTotalValue,\n            reportInOutDelta: _reportInOutDelta,\n            reportCumulativeLidoFees: _reportCumulativeLidoFees,\n            reportLiabilityShares: _reportLiabilityShares,\n            reportSlashingReserve: _reportSlashingReserve\n        });\n\n        _settleObligations(_vault, record, obligations, MAX_UNSETTLED_ALLOWED);\n        _checkAndUpdateBeaconChainDepositsPause(_vault, connection, record);\n    }\n\n    /// @notice Transfer the bad debt from the donor vault to the acceptor vault\n    /// @param _badDebtVault address of the vault that has the bad debt\n    /// @param _vaultAcceptor address of the vault that will accept the bad debt\n    /// @param _maxSharesToSocialize maximum amount of shares to socialize\n    /// @dev msg.sender must have BAD_DEBT_MASTER_ROLE\n    function socializeBadDebt(\n        address _badDebtVault,\n        address _vaultAcceptor,\n        uint256 _maxSharesToSocialize\n    ) external onlyRole(BAD_DEBT_MASTER_ROLE) {\n        _requireNotZero(_badDebtVault);\n        _requireNotZero(_vaultAcceptor);\n        _requireNotZero(_maxSharesToSocialize);\n        if (_nodeOperator(_vaultAcceptor) != _nodeOperator(_badDebtVault)) revert BadDebtSocializationNotAllowed();\n\n        VaultConnection storage badDebtConnection = _vaultConnection(_badDebtVault);\n        _requireConnected(badDebtConnection, _badDebtVault); // require connected but may be pending disconnect\n\n        uint256 badDebtToSocialize = _writeOffBadDebt({\n            _vault: _badDebtVault,\n            _record: _vaultRecord(_badDebtVault),\n            _maxSharesToWriteOff: _maxSharesToSocialize\n        });\n\n        VaultConnection storage connectionAcceptor = _vaultConnection(_vaultAcceptor);\n        _requireConnected(connectionAcceptor, _vaultAcceptor);\n\n        VaultRecord storage recordAcceptor = _vaultRecord(_vaultAcceptor);\n        _increaseLiability({\n            _vault: _vaultAcceptor,\n            _record: recordAcceptor,\n            _amountOfShares: badDebtToSocialize,\n            _reserveRatioBP: connectionAcceptor.reserveRatioBP,\n            _maxMintableRatioBP: TOTAL_BASIS_POINTS, // maxMintableRatio up to 100% of total value\n            _shareLimit: _getSharesByPooledEth(recordAcceptor.locked) // we can occupy all the locked amount\n        });\n\n        emit BadDebtSocialized(_badDebtVault, _vaultAcceptor, badDebtToSocialize);\n    }\n\n    /// @notice Internalize the bad debt to the protocol\n    /// @param _badDebtVault address of the vault that has the bad debt\n    /// @param _maxSharesToInternalize maximum amount of shares to internalize\n    /// @dev msg.sender must have BAD_DEBT_MASTER_ROLE\n    function internalizeBadDebt(\n        address _badDebtVault,\n        uint256 _maxSharesToInternalize\n    ) external onlyRole(BAD_DEBT_MASTER_ROLE) {\n        _requireNotZero(_badDebtVault);\n        _requireNotZero(_maxSharesToInternalize);\n\n        VaultConnection storage badDebtConnection = _vaultConnection(_badDebtVault);\n        _requireConnected(badDebtConnection, _badDebtVault);\n\n        uint256 badDebtToInternalize = _writeOffBadDebt({\n            _vault: _badDebtVault,\n            _record: _vaultRecord(_badDebtVault),\n            _maxSharesToWriteOff: _maxSharesToInternalize\n        });\n\n        // internalize the bad debt to the protocol\n        _storage().badDebtToInternalize = _storage().badDebtToInternalize.withValueIncrease({\n            _consensus: CONSENSUS_CONTRACT,\n            _increment: uint112(badDebtToInternalize)\n        });\n\n        emit BadDebtWrittenOffToBeInternalized(_badDebtVault, badDebtToInternalize);\n    }\n\n    /// @notice Reset the internalized bad debt to zero\n    /// @dev msg.sender must be the accounting contract\n    function decreaseInternalizedBadDebt(uint256 _amountOfShares) external {\n        _requireSender(LIDO_LOCATOR.accounting());\n\n        // don't cache previous value, we don't need it for sure\n        _storage().badDebtToInternalize.value -= uint112(_amountOfShares);\n    }\n\n    /// @notice transfer the ownership of the vault to a new owner without disconnecting it from the hub\n    /// @param _vault vault address\n    /// @param _newOwner new owner address\n    /// @dev msg.sender should be vault's owner\n    function transferVaultOwnership(address _vault, address _newOwner) external {\n        _requireNotZero(_newOwner);\n        VaultConnection storage connection = _checkConnection(_vault);\n        address oldOwner = connection.owner;\n\n        _requireSender(oldOwner);\n\n        connection.owner = _newOwner;\n\n        emit VaultOwnershipTransferred({\n            vault: _vault,\n            newOwner: _newOwner,\n            oldOwner: oldOwner\n        });\n    }\n\n    /// @notice disconnects a vault from the hub\n    /// @param _vault vault address\n    /// @dev msg.sender should be vault's owner\n    /// @dev vault's `liabilityShares` should be zero\n    function voluntaryDisconnect(address _vault) external whenResumed {\n        VaultConnection storage connection = _checkConnectionAndOwner(_vault);\n\n        _initiateDisconnection(_vault, connection, _vaultRecord(_vault));\n\n        emit VaultDisconnectInitiated(_vault);\n    }\n\n    /// @notice funds the vault passing ether as msg.value\n    /// @param _vault vault address\n    /// @dev msg.sender should be vault's owner\n    function fund(address _vault) external payable whenResumed {\n        _requireNotZero(_vault);\n        VaultConnection storage connection = _vaultConnection(_vault);\n        if (connection.vaultIndex == 0) revert NotConnectedToHub(_vault);\n        if (msg.sender != connection.owner) revert NotAuthorized();\n\n        _updateInOutDelta(_vault, _vaultRecord(_vault), int112(int256(msg.value)));\n\n        IStakingVault(_vault).fund{value: msg.value}();\n    }\n\n    /// @notice withdraws ether from the vault to the recipient address\n    /// @param _vault vault address\n    /// @param _recipient recipient address\n    /// @param _ether amount of ether to withdraw\n    /// @dev msg.sender should be vault's owner\n    function withdraw(address _vault, address _recipient, uint256 _ether) external whenResumed {\n        _checkConnectionAndOwner(_vault);\n\n        VaultRecord storage record = _vaultRecord(_vault);\n        _requireFreshReport(_vault, record);\n\n        uint256 withdrawable = _withdrawableValue(_vault, record);\n        if (_ether > withdrawable) revert AmountExceedsWithdrawableValue(_vault, withdrawable, _ether);\n\n        _withdraw(_vault, record, _recipient, _ether);\n    }\n\n    /// @notice Rebalances StakingVault by withdrawing ether to VaultHub\n    /// @param _vault vault address\n    /// @param _shares amount of shares to rebalance\n    /// @dev msg.sender should be vault's owner\n    function rebalance(address _vault, uint256 _shares) external whenResumed {\n        _requireNotZero(_shares);\n        _checkConnectionAndOwner(_vault);\n\n        _rebalance(_vault, _vaultRecord(_vault), _shares);\n    }\n\n    /// @notice mint StETH shares backed by vault external balance to the receiver address\n    /// @param _vault vault address\n    /// @param _recipient address of the receiver\n    /// @param _amountOfShares amount of stETH shares to mint\n    function mintShares(address _vault, address _recipient, uint256 _amountOfShares) external whenResumed {\n        _requireNotZero(_recipient);\n        _requireNotZero(_amountOfShares);\n\n        VaultConnection storage connection = _checkConnectionAndOwner(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n\n        _requireFreshReport(_vault, record);\n\n        uint256 reserveRatioBP = connection.reserveRatioBP;\n        _increaseLiability({\n            _vault: _vault,\n            _record: record,\n            _amountOfShares: _amountOfShares,\n            _reserveRatioBP: reserveRatioBP,\n            _maxMintableRatioBP: TOTAL_BASIS_POINTS - reserveRatioBP,\n            _shareLimit: connection.shareLimit\n        });\n\n        LIDO.mintExternalShares(_recipient, _amountOfShares);\n\n        emit MintedSharesOnVault(_vault, _amountOfShares, record.locked);\n    }\n\n    /// @notice burn steth shares from the balance of the VaultHub contract\n    /// @param _vault vault address\n    /// @param _amountOfShares amount of shares to burn\n    /// @dev msg.sender should be vault's owner\n    /// @dev this function is designed to be used by the smart contract, for EOA see `transferAndBurnShares`\n    function burnShares(address _vault, uint256 _amountOfShares) public whenResumed {\n        _requireNotZero(_amountOfShares);\n        _checkConnectionAndOwner(_vault);\n\n        VaultRecord storage record = _vaultRecord(_vault);\n\n        _decreaseLiability(_vault, record, _amountOfShares);\n\n        LIDO.burnExternalShares(_amountOfShares);\n\n        emit BurnedSharesOnVault(_vault, _amountOfShares);\n    }\n\n    /// @notice separate burn function for EOA vault owners; requires vaultHub to be approved to transfer stETH\n    /// @param _vault vault address\n    /// @param _amountOfShares amount of shares to transfer and burn\n    /// @dev msg.sender should be vault's owner\n    function transferAndBurnShares(address _vault, uint256 _amountOfShares) external {\n        LIDO.transferSharesFrom(msg.sender, address(this), _amountOfShares);\n\n        burnShares(_vault, _amountOfShares);\n    }\n\n    /// @notice pauses beacon chain deposits for the vault\n    /// @param _vault vault address\n    /// @dev msg.sender should be vault's owner\n    function pauseBeaconChainDeposits(address _vault) external {\n        VaultConnection storage connection = _checkConnectionAndOwner(_vault);\n\n        connection.isBeaconDepositsManuallyPaused = true;\n        IStakingVault(_vault).pauseBeaconChainDeposits();\n    }\n\n    /// @notice resumes beacon chain deposits for the vault\n    /// @param _vault vault address\n    /// @dev msg.sender should be vault's owner\n    function resumeBeaconChainDeposits(address _vault) external {\n        VaultConnection storage connection = _checkConnectionAndOwner(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n        if (!_isVaultHealthy(connection, record)) revert UnhealthyVaultCannotDeposit(_vault);\n\n        _settleObligations(_vault, record, _vaultObligations(_vault), UNSETTLED_THRESHOLD);\n\n        connection.isBeaconDepositsManuallyPaused = false;\n        IStakingVault(_vault).resumeBeaconChainDeposits();\n    }\n\n    /// @notice Emits a request event for the node operator to perform validator exit\n    /// @param _vault vault address\n    /// @param _pubkeys array of public keys of the validators to exit\n    /// @dev msg.sender should be vault's owner\n    function requestValidatorExit(address _vault, bytes calldata _pubkeys) external {\n        _checkConnectionAndOwner(_vault);\n\n        IStakingVault(_vault).requestValidatorExit(_pubkeys);\n    }\n\n    /// @notice Triggers validator withdrawals for the vault using EIP-7002\n    /// @param _vault vault address\n    /// @param _pubkeys array of public keys of the validators to withdraw from\n    /// @param _amounts array of amounts to withdraw from each validator (0 for full withdrawal)\n    /// @param _refundRecipient address that will receive the refund for transaction costs\n    /// @dev msg.sender should be vault's owner\n    function triggerValidatorWithdrawals(\n        address _vault,\n        bytes calldata _pubkeys,\n        uint64[] calldata _amounts,\n        address _refundRecipient\n    ) external payable {\n        VaultConnection storage connection = _checkConnectionAndOwner(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n        VaultObligations storage obligations = _vaultObligations(_vault);\n\n        /// @dev NB: Disallow partial withdrawals when the vault is unhealthy or has redemptions over the threshold\n        ///          in order to prevent the vault owner from clogging the consensus layer withdrawal queue\n        ///          front-running and delaying the forceful validator exits required for rebalancing the vault,\n        ///          unless the requested amount of withdrawals is enough to recover the vault to healthy state and\n        ///          settle the unsettled obligations\n        if (!_isVaultHealthy(connection, record) || obligations.redemptions >= UNSETTLED_THRESHOLD) {\n            uint256 minPartialAmount = type(uint256).max;\n            for (uint256 i = 0; i < _amounts.length; i++) {\n                if (_amounts[i] > 0 && _amounts[i] < minPartialAmount) minPartialAmount = _amounts[i];\n            }\n\n            if (minPartialAmount < type(uint256).max) {\n                uint256 currentVaultBalance = _vault.balance;\n                uint256 required = _totalUnsettledObligations(obligations) + _rebalanceShortfall(connection, record);\n                uint256 amountToCover = required > currentVaultBalance ? required - currentVaultBalance : 0;\n\n                if (minPartialAmount < amountToCover) revert PartialValidatorWithdrawalNotAllowed();\n            }\n        }\n\n        IStakingVault(_vault).triggerValidatorWithdrawals{value: msg.value}(_pubkeys, _amounts, _refundRecipient);\n    }\n\n    /// @notice Triggers validator full withdrawals for the vault using EIP-7002 permissionlessly if the vault is\n    ///         unhealthy or has redemptions obligation over the threshold\n    /// @param _vault address of the vault to exit validators from\n    /// @param _pubkeys array of public keys of the validators to exit\n    /// @param _refundRecipient address that will receive the refund for transaction costs\n    /// @dev    When the vault becomes unhealthy, trusted actor with the role can force its validators to exit the beacon chain\n    ///         This returns the vault's deposited ETH back to vault's balance and allows to rebalance the vault\n    function forceValidatorExit(\n        address _vault,\n        bytes calldata _pubkeys,\n        address _refundRecipient\n    ) external payable onlyRole(VALIDATOR_EXIT_ROLE) {\n        VaultConnection storage connection = _checkConnection(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n\n        if (\n            _isVaultHealthy(connection, record) &&\n            // Check if the vault has redemptions under the threshold, or enough balance to cover the redemptions fully\n            _vaultObligations(_vault).redemptions < Math256.max(UNSETTLED_THRESHOLD, _vault.balance)\n        ) {\n            revert ForcedValidatorExitNotAllowed();\n        }\n\n        uint64[] memory amounts = new uint64[](0);\n        IStakingVault(_vault).triggerValidatorWithdrawals{value: msg.value}(_pubkeys, amounts, _refundRecipient);\n\n        emit ForcedValidatorExitTriggered(_vault, _pubkeys, _refundRecipient);\n    }\n\n    /// @notice Permissionless rebalance for unhealthy vaults\n    /// @param _vault vault address\n    /// @dev rebalance all available amount of ether until the vault is healthy\n    function forceRebalance(address _vault) external {\n        VaultConnection storage connection = _checkConnection(_vault);\n        VaultRecord storage record = _vaultRecord(_vault);\n\n        uint256 sharesToRebalance = Math256.min(\n            _rebalanceShortfall(connection, record),\n            _getSharesByPooledEth(_vault.balance)\n        );\n        if (sharesToRebalance == 0) revert AlreadyHealthy(_vault);\n\n        _rebalance(_vault, record, sharesToRebalance);\n    }\n\n    /// @notice Accrues a redemption obligation on the vault under extreme conditions\n    /// @param _vault The address of the vault\n    /// @param _redemptionsValue The value of the redemptions obligation\n    function setVaultRedemptions(address _vault, uint256 _redemptionsValue) external onlyRole(REDEMPTION_MASTER_ROLE) {\n        VaultRecord storage record = _vaultRecord(_vault);\n\n        uint256 liabilityShares_ = record.liabilityShares;\n\n        // This function may intentionally perform no action in some cases, as these are EasyTrack motions\n        if (liabilityShares_ > 0) {\n            uint256 newRedemptions = Math256.min(_redemptionsValue, _getPooledEthBySharesRoundUp(liabilityShares_));\n            _vaultObligations(_vault).redemptions = uint128(newRedemptions);\n            emit RedemptionsUpdated(_vault, newRedemptions);\n\n            _checkAndUpdateBeaconChainDepositsPause(_vault, _vaultConnection(_vault), record);\n        } else {\n            emit RedemptionsNotSet(_vault, _redemptionsValue);\n        }\n    }\n\n    /// @notice Allows permissionless full or partial settlement of unsettled obligations on the vault\n    /// @param _vault The address of the vault\n    function settleVaultObligations(address _vault) external whenResumed {\n        if (_vault.balance == 0) revert ZeroBalance();\n\n        VaultRecord storage record = _vaultRecord(_vault);\n        _settleObligations(_vault, record, _vaultObligations(_vault), MAX_UNSETTLED_ALLOWED);\n\n        _checkAndUpdateBeaconChainDepositsPause(_vault, _vaultConnection(_vault), record);\n    }\n\n    /// @notice Proves that validators unknown to PDG have correct WC to participate in the vault\n    /// @param _vault vault address\n    /// @param _witness ValidatorWitness struct proving validator WC belonging to staking vault\n    function proveUnknownValidatorToPDG(\n        address _vault,\n        IPredepositGuarantee.ValidatorWitness calldata _witness\n    ) external {\n        _checkConnectionAndOwner(_vault);\n\n        _predepositGuarantee().proveUnknownValidator(_witness, IStakingVault(_vault));\n    }\n\n    /// @notice Compensates disproven predeposit from PDG to the recipient\n    /// @param _vault vault address\n    /// @param _pubkey pubkey of the validator\n    /// @param _recipient address to compensate the disproven validator predeposit to\n    /// @return amount of compensated ether\n    function compensateDisprovenPredepositFromPDG(\n        address _vault,\n        bytes calldata _pubkey,\n        address _recipient\n    ) external returns (uint256) {\n        _checkConnectionAndOwner(_vault);\n\n        return _predepositGuarantee().compensateDisprovenPredeposit(_pubkey, _recipient);\n    }\n\n    function _connectVault(\n        address _vault,\n        uint256 _shareLimit,\n        uint256 _reserveRatioBP,\n        uint256 _forcedRebalanceThresholdBP,\n        uint256 _infraFeeBP,\n        uint256 _liquidityFeeBP,\n        uint256 _reservationFeeBP\n    ) internal {\n        _requireSaneShareLimit(_shareLimit);\n        _requireNotZero(_reserveRatioBP);\n        _requireLessThanBP(_reserveRatioBP, TOTAL_BASIS_POINTS);\n        _requireNotZero(_forcedRebalanceThresholdBP);\n        _requireLessThanBP(_forcedRebalanceThresholdBP, _reserveRatioBP);\n\n        _requireLessThanBP(_infraFeeBP, MAX_FEE_BP);\n        _requireLessThanBP(_liquidityFeeBP, MAX_FEE_BP);\n        _requireLessThanBP(_reservationFeeBP, MAX_FEE_BP);\n\n        VaultConnection memory connection = _vaultConnection(_vault);\n        if (connection.pendingDisconnect) revert VaultIsDisconnecting(_vault);\n        if (connection.vaultIndex != 0) revert AlreadyConnected(_vault, connection.vaultIndex);\n\n        bytes32 codehash = address(_vault).codehash;\n        if (!_storage().codehashes[codehash]) revert CodehashNotAllowed(_vault, codehash);\n\n        uint256 vaultBalance = _vault.balance;\n        if (vaultBalance < CONNECT_DEPOSIT) revert VaultInsufficientBalance(_vault, vaultBalance, CONNECT_DEPOSIT);\n\n        // Connecting a new vault with totalValue == balance\n        VaultRecord memory record = VaultRecord({\n            report: Report({\n                totalValue: uint112(vaultBalance),\n                inOutDelta: int112(int256(vaultBalance)),\n                timestamp: uint32(_lazyOracle().latestReportTimestamp())\n            }),\n            locked: uint128(CONNECT_DEPOSIT),\n            liabilityShares: 0,\n            inOutDelta: RefSlotCache.Int112WithRefSlotCache({\n                value: int112(int256(vaultBalance)),\n                valueOnRefSlot: 0,\n                refSlot: 0\n            })\n        });\n\n        connection = VaultConnection({\n            owner: IStakingVault(_vault).owner(),\n            shareLimit: uint96(_shareLimit),\n            vaultIndex: uint96(_storage().vaults.length),\n            pendingDisconnect: false,\n            reserveRatioBP: uint16(_reserveRatioBP),\n            forcedRebalanceThresholdBP: uint16(_forcedRebalanceThresholdBP),\n            infraFeeBP: uint16(_infraFeeBP),\n            liquidityFeeBP: uint16(_liquidityFeeBP),\n            reservationFeeBP: uint16(_reservationFeeBP),\n            isBeaconDepositsManuallyPaused: false\n        });\n\n        _addVault(_vault, connection, record);\n    }\n\n    function _initiateDisconnection(\n        address _vault,\n        VaultConnection storage _connection,\n        VaultRecord storage _record\n    ) internal {\n        uint256 liabilityShares_ = _record.liabilityShares;\n        if (liabilityShares_ > 0) {\n            revert NoLiabilitySharesShouldBeLeft(_vault, liabilityShares_);\n        }\n\n        _record.locked = 0; // unlock the connection deposit to allow fees settlement\n        _settleObligations(_vault, _record, _vaultObligations(_vault), NO_UNSETTLED_ALLOWED);\n\n        _connection.pendingDisconnect = true;\n\n        _operatorGrid().resetVaultTier(_vault);\n    }\n\n    function _applyVaultReport(\n        VaultRecord storage _record,\n        VaultConnection storage _connection,\n        uint256 _reportTimestamp,\n        uint256 _reportTotalValue,\n        uint256 _reportLiabilityShares,\n        int256 _reportInOutDelta\n    ) internal {\n        uint256 liabilityShares_ = Math256.max(_record.liabilityShares, _reportLiabilityShares);\n        uint256 liability = _getPooledEthBySharesRoundUp(liabilityShares_);\n\n        uint256 lockedEther = Math256.max(\n            liability * TOTAL_BASIS_POINTS / (TOTAL_BASIS_POINTS - _connection.reserveRatioBP),\n            CONNECT_DEPOSIT\n        );\n\n        _record.locked = uint128(lockedEther);\n        _record.report = Report({\n            totalValue: uint112(_reportTotalValue),\n            inOutDelta: int112(_reportInOutDelta),\n            timestamp: uint32(_reportTimestamp)\n        });\n    }\n\n    function _rebalance(address _vault, VaultRecord storage _record, uint256 _shares) internal {\n        uint256 valueToRebalance = _getPooledEthBySharesRoundUp(_shares);\n\n        uint256 totalValue_ = _totalValue(_record);\n        if (valueToRebalance > totalValue_) revert RebalanceAmountExceedsTotalValue(totalValue_, valueToRebalance);\n\n        _decreaseLiability(_vault, _record, _shares);\n        _withdraw(_vault, _record, address(this), valueToRebalance);\n        _rebalanceExternalEtherToInternal(valueToRebalance);\n\n        emit VaultRebalanced(_vault, _shares, valueToRebalance);\n    }\n\n    function _withdraw(\n        address _vault,\n        VaultRecord storage _record,\n        address _recipient,\n        uint256 _amount\n    ) internal {\n        _updateInOutDelta(_vault, _record, -int112(int256(_amount)));\n\n        IStakingVault(_vault).withdraw(_recipient, _amount);\n    }\n\n    function _increaseLiability(\n        address _vault,\n        VaultRecord storage _record,\n        uint256 _amountOfShares,\n        uint256 _reserveRatioBP,\n        uint256 _maxMintableRatioBP,\n        uint256 _shareLimit\n    ) internal {\n        uint256 sharesAfterMint = _record.liabilityShares + _amountOfShares;\n        if (sharesAfterMint > _shareLimit) revert ShareLimitExceeded(_vault, sharesAfterMint, _shareLimit);\n\n        uint256 stETHAfterMint = _getPooledEthBySharesRoundUp(sharesAfterMint);\n        uint256 maxLockableValue_ = _maxLockableValue(_record, _vaultObligations(_vault));\n        uint256 maxMintableEther = (maxLockableValue_ * _maxMintableRatioBP) / TOTAL_BASIS_POINTS;\n        if (stETHAfterMint > maxMintableEther) {\n            revert InsufficientValueToMint(_vault, maxLockableValue_);\n        }\n\n        // Calculate the minimum ETH that needs to be locked in the vault to maintain the reserve ratio\n        uint256 etherToLock = (stETHAfterMint * TOTAL_BASIS_POINTS) / (TOTAL_BASIS_POINTS - _reserveRatioBP);\n        if (etherToLock > _record.locked) {\n            _record.locked = uint128(etherToLock);\n        }\n\n        _record.liabilityShares = uint96(sharesAfterMint);\n\n        _operatorGrid().onMintedShares(_vault, _amountOfShares);\n    }\n\n    function _decreaseLiability(address _vault, VaultRecord storage _record, uint256 _amountOfShares) internal {\n        uint256 liabilityShares_ = _record.liabilityShares;\n        if (liabilityShares_ < _amountOfShares) revert InsufficientSharesToBurn(_vault, liabilityShares_);\n\n        _record.liabilityShares = uint96(liabilityShares_ - _amountOfShares);\n\n        _decreaseRedemptions(_vault, _amountOfShares);\n        _operatorGrid().onBurnedShares(_vault, _amountOfShares);\n    }\n\n    function _writeOffBadDebt(\n        address _vault,\n        VaultRecord storage _record,\n        uint256 _maxSharesToWriteOff\n    ) internal returns (uint256 badDebtWrittenOff) {\n        uint256 liabilityShares_ = _record.liabilityShares;\n        uint256 totalValueShares = _getSharesByPooledEth(_totalValue(_record));\n        if (totalValueShares > liabilityShares_) {\n            revert NoBadDebtToWriteOff(_vault, totalValueShares, liabilityShares_);\n        }\n\n        badDebtWrittenOff = Math256.min(liabilityShares_ - totalValueShares, _maxSharesToWriteOff);\n\n        _decreaseLiability(_vault, _record, badDebtWrittenOff);\n    }\n\n    function _rebalanceShortfall(\n        VaultConnection storage _connection,\n        VaultRecord storage _record\n    ) internal view returns (uint256) {\n        uint256 totalValue_ = _totalValue(_record);\n        uint256 liabilityShares_ = _record.liabilityShares;\n\n        bool isHealthy = !_isThresholdBreached(\n            totalValue_,\n            liabilityShares_,\n            _connection.forcedRebalanceThresholdBP\n        );\n\n        // Health vault do not need to rebalance\n        if (isHealthy) {\n            return 0;\n        }\n\n        uint256 reserveRatioBP = _connection.reserveRatioBP;\n        uint256 maxMintableRatio = (TOTAL_BASIS_POINTS - reserveRatioBP);\n        uint256 sharesByTotalValue = _getSharesByPooledEth(totalValue_);\n\n        // Impossible to rebalance a vault with bad debt\n        if (liabilityShares_ >= sharesByTotalValue) {\n            // return MAX_UINT_256\n            return type(uint256).max;\n        }\n\n        // Solve the equation for X:\n        // LS - liabilityShares, TV - sharesByTotalValue\n        // MR - maxMintableRatio, 100 - TOTAL_BASIS_POINTS, RR - reserveRatio\n        // X - amount of shares that should be withdrawn (TV - X) and used to repay the debt (LS - X)\n        // to reduce the LS/TVS ratio back to MR\n\n        // (LS - X) / (TV - X) = MR / 100\n        // (LS - X) * 100 = (TV - X) * MR\n        // LS * 100 - X * 100 = TV * MR - X * MR\n        // X * MR - X * 100 = TV * MR - LS * 100\n        // X * (MR - 100) = TV * MR - LS * 100\n        // X = (TV * MR - LS * 100) / (MR - 100)\n        // X = (LS * 100 - TV * MR) / (100 - MR)\n        // RR = 100 - MR\n        // X = (LS * 100 - TV * MR) / RR\n\n        return (liabilityShares_ * TOTAL_BASIS_POINTS - sharesByTotalValue * maxMintableRatio) / reserveRatioBP;\n    }\n\n    function _totalValue(VaultRecord storage _record) internal view returns (uint256) {\n        Report memory report = _record.report;\n        return uint256(int256(uint256(report.totalValue)) + _record.inOutDelta.value - report.inOutDelta);\n    }\n\n    function _maxLockableValue(VaultRecord storage _record, VaultObligations storage _obligations) internal view returns (uint256) {\n        return _totalValue(_record) - _obligations.unsettledLidoFees;\n    }\n\n    function _isReportFresh(VaultRecord storage _record) internal view returns (bool) {\n        uint256 latestReportTimestamp = _lazyOracle().latestReportTimestamp();\n        return\n            // check if AccountingOracle brought fresh report\n            uint32(latestReportTimestamp) == _record.report.timestamp &&\n            // if Accounting Oracle stop bringing the report, last report is fresh for 2 days\n            block.timestamp - latestReportTimestamp < REPORT_FRESHNESS_DELTA;\n    }\n\n    function _isVaultHealthy(\n        VaultConnection storage _connection,\n        VaultRecord storage _record\n    ) internal view returns (bool) {\n        return !_isThresholdBreached(\n            _totalValue(_record),\n            _record.liabilityShares,\n            _connection.forcedRebalanceThresholdBP\n        );\n    }\n\n    /// @dev Returns true if the vault liability breached the given threshold (inverted)\n    function _isThresholdBreached(\n        uint256 _vaultTotalValue,\n        uint256 _vaultLiabilityShares,\n        uint256 _thresholdBP\n    ) internal view returns (bool) {\n        uint256 liability = _getPooledEthBySharesRoundUp(_vaultLiabilityShares);\n        return liability > _vaultTotalValue * (TOTAL_BASIS_POINTS - _thresholdBP) / TOTAL_BASIS_POINTS;\n    }\n\n    function _addVault(address _vault, VaultConnection memory _connection, VaultRecord memory _record) internal {\n        Storage storage $ = _storage();\n        $.vaults.push(_vault);\n\n        $.connections[_vault] = _connection;\n        $.records[_vault] = _record;\n    }\n\n    function _deleteVault(address _vault, VaultConnection storage _connection) internal {\n        Storage storage $ = _storage();\n        uint96 vaultIndex = _connection.vaultIndex;\n\n        address lastVault = $.vaults[$.vaults.length - 1];\n        $.connections[lastVault].vaultIndex = vaultIndex;\n        $.vaults[vaultIndex] = lastVault;\n        $.vaults.pop();\n\n        delete $.connections[_vault];\n        delete $.records[_vault];\n        delete $.obligations[_vault];\n    }\n\n    function _checkConnectionAndOwner(address _vault) internal view returns (VaultConnection storage connection) {\n        connection = _checkConnection(_vault);\n        _requireSender(connection.owner);\n    }\n\n    function _checkConnection(address _vault) internal view returns (VaultConnection storage) {\n        _requireNotZero(_vault);\n\n        VaultConnection storage connection = _vaultConnection(_vault);\n        _requireConnected(connection, _vault);\n        if (connection.pendingDisconnect) revert VaultIsDisconnecting(_vault);\n\n        return connection;\n    }\n\n    /// @dev Caches the inOutDelta of the latest refSlot and updates the value\n    function _updateInOutDelta(address _vault, VaultRecord storage _record, int112 _increment) internal {\n        _record.inOutDelta = _record.inOutDelta.withValueIncrease({\n            _consensus: CONSENSUS_CONTRACT,\n            _increment: _increment\n        });\n\n        emit VaultInOutDeltaUpdated(_vault, _record.inOutDelta.value);\n    }\n\n    /**\n     * @notice Updates the unsettled Lido fees obligations based on the report cumulative Lido fees\n     * @param _vault The address of the vault\n     * @param _reportCumulativeLidoFees The cumulative Lido fees reported in the report\n     */\n    function _checkAndUpdateLidoFeesObligations(\n        address _vault,\n        VaultObligations storage _obligations,\n        uint256 _reportCumulativeLidoFees\n    ) internal {\n        uint256 cumulativeSettledLidoFees = _obligations.settledLidoFees;\n        uint256 cumulativeLidoFees = cumulativeSettledLidoFees + _obligations.unsettledLidoFees;\n        if (_reportCumulativeLidoFees < cumulativeLidoFees) {\n            revert InvalidFees(_vault, _reportCumulativeLidoFees, cumulativeLidoFees);\n        }\n\n        // update unsettled lido fees\n        uint256 unsettledLidoFees = _reportCumulativeLidoFees - cumulativeSettledLidoFees;\n        if (unsettledLidoFees != _obligations.unsettledLidoFees) {\n            _obligations.unsettledLidoFees = uint128(unsettledLidoFees);\n            emit LidoFeesUpdated(_vault, unsettledLidoFees, cumulativeSettledLidoFees);\n        }\n    }\n\n    /**\n     * @notice Calculates a settlement plan based on vault balance and obligations\n     * @param _vault The address of the vault\n     * @param _record The record of the vault\n     * @param _obligations The obligations of the vault to be settled\n     * @return valueToRebalance The ETH amount to be rebalanced for redemptions\n     * @return sharesToRebalance The shares to be rebalanced for redemptions\n     * @return valueToTransferToLido The ETH amount to be sent to the Lido\n     * @return unsettledRedemptions The remaining redemptions after the planned settlement\n     * @return unsettledLidoFees The remaining Lido fees after the planned settlement\n     * @return totalUnsettled The total ETH value of obligations remaining after the planned settlement\n     */\n    function _planSettlement(\n        address _vault,\n        VaultRecord storage _record,\n        VaultObligations storage _obligations\n    ) internal view returns (\n        uint256 valueToRebalance,\n        uint256 sharesToRebalance,\n        uint256 valueToTransferToLido,\n        uint256 unsettledRedemptions,\n        uint256 unsettledLidoFees,\n        uint256 totalUnsettled\n    ) {\n        (valueToRebalance, sharesToRebalance, unsettledRedemptions) = _planRebalance(_vault, _record, _obligations);\n        (valueToTransferToLido, unsettledLidoFees) = _planLidoTransfer(_vault, _record, _obligations, valueToRebalance);\n        totalUnsettled = unsettledRedemptions + unsettledLidoFees;\n    }\n\n    /**\n     * @notice Plans the amounts and shares to rebalance for redemptions\n     * @param _vault The address of the vault\n     * @param _record The record of the vault\n     * @param _obligations The obligations of the vault\n     * @return valueToRebalance The ETH amount to be rebalanced for redemptions\n     * @return sharesToRebalance The shares to be rebalanced for redemptions\n     * @return unsettledRedemptions The remaining redemptions after the planned settlement\n     */\n    function _planRebalance(\n        address _vault,\n        VaultRecord storage _record,\n        VaultObligations storage _obligations\n    ) internal view returns (uint256 valueToRebalance, uint256 sharesToRebalance, uint256 unsettledRedemptions) {\n        uint256 redemptionShares = _getSharesByPooledEth(_obligations.redemptions);\n        uint256 maxRedemptionsValue = _getPooledEthBySharesRoundUp(redemptionShares);\n        // if the max redemptions value is less than the redemptions, we need to round up the redemptions shares\n        if (maxRedemptionsValue < _obligations.redemptions) redemptionShares += 1;\n\n        uint256 cappedRedemptionsShares = Math256.min(_record.liabilityShares, redemptionShares);\n        sharesToRebalance = Math256.min(cappedRedemptionsShares, _getSharesByPooledEth(_vault.balance));\n        valueToRebalance = _getPooledEthBySharesRoundUp(sharesToRebalance);\n        unsettledRedemptions = _getPooledEthBySharesRoundUp(redemptionShares - sharesToRebalance);\n    }\n\n    /**\n     * @notice Plans the amount to transfer to Lido for fees\n     * @param _vault The address of the vault\n     * @param _record The record of the vault\n     * @param _obligations The obligations of the vault\n     * @param _valueToRebalance The ETH amount already allocated for rebalancing\n     * @return valueToTransferToLido The ETH amount to be sent to the Lido\n     * @return unsettledLidoFees The remaining Lido fees after the planned settlement\n     */\n    function _planLidoTransfer(\n        address _vault,\n        VaultRecord storage _record,\n        VaultObligations storage _obligations,\n        uint256 _valueToRebalance\n    ) internal view returns (uint256 valueToTransferToLido, uint256 unsettledLidoFees) {\n        uint256 vaultBalance = _vault.balance;\n        uint256 remainingBalance = vaultBalance - _valueToRebalance;\n\n        if (_vaultConnection(_vault).pendingDisconnect) {\n            /// @dev connection deposit is unlocked, so it's available for fees\n            valueToTransferToLido = Math256.min(_obligations.unsettledLidoFees, remainingBalance);\n        } else {\n            /// @dev connection deposit is permanently locked, so it's not available for fees\n            /// @dev NB: Fees are deducted from the vault's current balance, which reduces the total value, so the\n            ///          current locked value must be considered to prevent the vault from entering an unhealthy state\n            uint256 lockedValue = _record.locked;\n            uint256 totalValue_ = _totalValue(_record);\n            uint256 unlockedValue = totalValue_ > lockedValue ? totalValue_ - lockedValue : 0;\n            uint256 availableForFees = Math256.min(\n                unlockedValue > _valueToRebalance ? unlockedValue - _valueToRebalance : 0,\n                remainingBalance\n            );\n            valueToTransferToLido = Math256.min(_obligations.unsettledLidoFees, availableForFees);\n        }\n\n        unsettledLidoFees = _obligations.unsettledLidoFees - valueToTransferToLido;\n    }\n\n    /**\n     * @notice Settles redemptions and Lido fee obligations for a vault\n     * @param _vault The address of the vault to settle obligations for\n     * @param _record The record of the vault to settle obligations for\n     * @param _obligations The obligations of the vault to be settled\n     * @param _allowedUnsettled The maximum allowable unsettled obligations post-settlement (triggers reverts)\n     */\n    function _settleObligations(\n        address _vault,\n        VaultRecord storage _record,\n        VaultObligations storage _obligations,\n        uint256 _allowedUnsettled\n    ) internal {\n        (\n            uint256 valueToRebalance,\n            uint256 sharesToRebalance,\n            uint256 valueToTransferToLido,\n            uint256 unsettledRedemptions,\n            uint256 unsettledLidoFees,\n            uint256 totalUnsettled\n        ) = _planSettlement(_vault, _record, _obligations);\n\n        // Enforce requirement for settlement completeness\n        if (totalUnsettled > _allowedUnsettled) {\n            revert VaultHasUnsettledObligations(_vault, totalUnsettled, _allowedUnsettled);\n        }\n\n        // Skip if no changes to obligations\n        if (valueToTransferToLido == 0 && valueToRebalance == 0) {\n            return;\n        }\n\n        if (valueToRebalance > 0) {\n            _decreaseLiability(_vault, _record, sharesToRebalance);\n            _withdraw(_vault, _record, address(this), valueToRebalance);\n            _rebalanceExternalEtherToInternal(valueToRebalance);\n        }\n\n        if (valueToTransferToLido > 0) {\n            _withdraw(_vault, _record, LIDO_LOCATOR.treasury(), valueToTransferToLido);\n            _obligations.settledLidoFees += uint128(valueToTransferToLido);\n        }\n\n        _obligations.redemptions = uint128(unsettledRedemptions);\n        _obligations.unsettledLidoFees = uint128(unsettledLidoFees);\n\n        emit VaultObligationsSettled({\n            vault: _vault,\n            rebalanced: valueToRebalance,\n            transferredToLido: valueToTransferToLido,\n            unsettledRedemptions: unsettledRedemptions,\n            unsettledLidoFees: unsettledLidoFees,\n            settledLidoFees: _obligations.settledLidoFees\n        });\n    }\n\n    function _decreaseRedemptions(address _vault, uint256 _shares) internal {\n        VaultObligations storage obligations = _vaultObligations(_vault);\n\n        if (obligations.redemptions > 0) {\n            uint256 redemptionsValue = _getPooledEthBySharesRoundUp(_shares);\n            uint256 decrease = Math256.min(obligations.redemptions, redemptionsValue);\n            if (decrease > 0) {\n                obligations.redemptions -= uint128(decrease);\n                emit RedemptionsUpdated(_vault, obligations.redemptions);\n            }\n        }\n    }\n\n    function _totalUnsettledObligations(VaultObligations storage _obligations) internal view returns (uint256) {\n        return _obligations.unsettledLidoFees + _obligations.redemptions;\n    }\n\n    function _checkAndUpdateBeaconChainDepositsPause(\n        address _vault,\n        VaultConnection storage _connection,\n        VaultRecord storage _record\n    ) internal {\n        IStakingVault vault_ = IStakingVault(_vault);\n        bool isHealthy = _isVaultHealthy(_connection, _record);\n        bool isBeaconDepositsPaused = vault_.beaconChainDepositsPaused();\n\n        if (_totalUnsettledObligations(_vaultObligations(_vault)) >= UNSETTLED_THRESHOLD || !isHealthy) {\n            if (!isBeaconDepositsPaused) vault_.pauseBeaconChainDeposits();\n        } else if (!_connection.isBeaconDepositsManuallyPaused) {\n            if (isBeaconDepositsPaused) vault_.resumeBeaconChainDeposits();\n        }\n    }\n\n    /// @return the amount of ether that can be instantly withdrawn from the staking vault\n    /// @dev this amount already accounts locked value and unsettled obligations\n    function _withdrawableValue(\n        address _vault,\n        VaultRecord storage _record\n    ) internal view returns (uint256) {\n        uint256 totalValue_ = _totalValue(_record);\n        uint256 lockedPlusUnsettled = _record.locked + _totalUnsettledObligations(_vaultObligations(_vault));\n\n        return Math256.min(\n            _vault.balance,\n            totalValue_ > lockedPlusUnsettled ? totalValue_ - lockedPlusUnsettled : 0\n        );\n    }\n\n    function _storage() internal pure returns (Storage storage $) {\n        assembly {\n            $.slot := STORAGE_LOCATION\n        }\n    }\n\n    function _vaultConnection(address _vault) internal view returns (VaultConnection storage) {\n        return _storage().connections[_vault];\n    }\n\n    function _vaultRecord(address _vault) internal view returns (VaultRecord storage) {\n        return _storage().records[_vault];\n    }\n\n    function _vaultObligations(address _vault) internal view returns (VaultObligations storage) {\n        return _storage().obligations[_vault];\n    }\n\n    function _operatorGrid() internal view returns (OperatorGrid) {\n        return OperatorGrid(LIDO_LOCATOR.operatorGrid());\n    }\n\n    function _lazyOracle() internal view returns (LazyOracle) {\n        return LazyOracle(LIDO_LOCATOR.lazyOracle());\n    }\n\n    function _predepositGuarantee() internal view returns (IPredepositGuarantee) {\n        return IPredepositGuarantee(LIDO_LOCATOR.predepositGuarantee());\n    }\n\n    function _getSharesByPooledEth(uint256 _ether) internal view returns (uint256) {\n        return LIDO.getSharesByPooledEth(_ether);\n    }\n\n    function _getPooledEthByShares(uint256 _ether) internal view returns (uint256) {\n        return LIDO.getPooledEthByShares(_ether);\n    }\n\n    function _getPooledEthBySharesRoundUp(uint256 _shares) internal view returns (uint256) {\n        return LIDO.getPooledEthBySharesRoundUp(_shares);\n    }\n\n    function _rebalanceExternalEtherToInternal(uint256 _ether) internal {\n        LIDO.rebalanceExternalEtherToInternal{value: _ether}();\n    }\n\n    function _nodeOperator(address _vault) internal view returns (address) {\n        return IStakingVault(_vault).nodeOperator();\n    }\n\n    function _requireNotZero(uint256 _value) internal pure {\n        if (_value == 0) revert ZeroArgument();\n    }\n\n    function _requireNotZero(address _address) internal pure {\n        if (_address == address(0)) revert ZeroAddress();\n    }\n\n    function _requireSender(address _sender) internal view {\n        if (msg.sender != _sender) revert NotAuthorized();\n    }\n\n    function _requireLessThanBP(uint256 _valueBP, uint256 _maxValueBP) internal pure {\n        if (_valueBP > _maxValueBP) revert InvalidBasisPoints(_valueBP, _maxValueBP);\n    }\n\n    function _requireSaneShareLimit(uint256 _shareLimit) internal view {\n        uint256 maxSaneShareLimit = (LIDO.getTotalShares() * MAX_RELATIVE_SHARE_LIMIT_BP) / TOTAL_BASIS_POINTS;\n        if (_shareLimit > maxSaneShareLimit) revert ShareLimitTooHigh(_shareLimit, maxSaneShareLimit);\n    }\n\n    function _requireConnected(VaultConnection storage _connection, address _vault) internal view {\n        if (_connection.vaultIndex == 0) revert NotConnectedToHub(_vault);\n    }\n\n    function _requireFreshReport(address _vault, VaultRecord storage _record) internal view {\n        if (!_isReportFresh(_record)) revert VaultReportStale(_vault);\n    }\n\n    // -----------------------------\n    //           EVENTS\n    // -----------------------------\n\n    event AllowedCodehashUpdated(bytes32 indexed codehash, bool allowed);\n\n    event VaultConnected(\n        address indexed vault,\n        uint256 shareLimit,\n        uint256 reserveRatioBP,\n        uint256 forcedRebalanceThresholdBP,\n        uint256 infraFeeBP,\n        uint256 liquidityFeeBP,\n        uint256 reservationFeeBP\n    );\n\n    event VaultConnectionUpdated(\n        address indexed vault,\n        uint256 shareLimit,\n        uint256 reserveRatioBP,\n        uint256 forcedRebalanceThresholdBP,\n        uint256 infraFeeBP,\n        uint256 liquidityFeeBP,\n        uint256 reservationFeeBP\n    );\n    event VaultShareLimitUpdated(address indexed vault, uint256 newShareLimit);\n    event VaultFeesUpdated(\n        address indexed vault,\n        uint256 preInfraFeeBP,\n        uint256 preLiquidityFeeBP,\n        uint256 preReservationFeeBP,\n        uint256 infraFeeBP,\n        uint256 liquidityFeeBP,\n        uint256 reservationFeeBP\n    );\n    event VaultDisconnectInitiated(address indexed vault);\n    event VaultDisconnectCompleted(address indexed vault);\n    event VaultDisconnectAborted(address indexed vault, uint256 slashingReserve);\n    event VaultReportApplied(\n        address indexed vault,\n        uint256 reportTimestamp,\n        uint256 reportTotalValue,\n        int256 reportInOutDelta,\n        uint256 reportCumulativeLidoFees,\n        uint256 reportLiabilityShares,\n        uint256 reportSlashingReserve\n    );\n\n    event MintedSharesOnVault(address indexed vault, uint256 amountOfShares, uint256 lockedAmount);\n    event BurnedSharesOnVault(address indexed vault, uint256 amountOfShares);\n    event VaultRebalanced(address indexed vault, uint256 sharesBurned, uint256 etherWithdrawn);\n    event VaultInOutDeltaUpdated(address indexed vault, int112 inOutDelta);\n    event ForcedValidatorExitTriggered(address indexed vault, bytes pubkeys, address refundRecipient);\n\n    /**\n     * @notice Emitted when the manager is set\n     * @param vault The address of the vault\n     * @param newOwner The address of the new owner\n     * @param oldOwner The address of the old owner\n     */\n    event VaultOwnershipTransferred(address indexed vault, address indexed newOwner, address indexed oldOwner);\n\n    event LidoFeesUpdated(address indexed vault, uint256 unsettledLidoFees, uint256 settledLidoFees);\n    event RedemptionsUpdated(address indexed vault, uint256 unsettledRedemptions);\n    event RedemptionsNotSet(address indexed vault, uint256 redemptionsValue);\n    event VaultObligationsSettled(\n        address indexed vault,\n        uint256 rebalanced,\n        uint256 transferredToLido,\n        uint256 unsettledRedemptions,\n        uint256 unsettledLidoFees,\n        uint256 settledLidoFees\n    );\n\n    // -----------------------------\n    //           ERRORS\n    // -----------------------------\n\n    event BadDebtSocialized(address indexed vaultDonor, address indexed vaultAcceptor, uint256 badDebtShares);\n    event BadDebtWrittenOffToBeInternalized(address indexed vault, uint256 badDebtShares);\n\n    error ZeroBalance();\n\n    /**\n     * @notice Thrown when attempting to rebalance more ether than the current total value of the vault\n     * @param totalValue Current total value of the vault\n     * @param rebalanceAmount Amount attempting to rebalance (in ether)\n     */\n    error RebalanceAmountExceedsTotalValue(uint256 totalValue, uint256 rebalanceAmount);\n\n    /**\n     * @notice Thrown when attempting to withdraw more ether than the available value of the vault\n     * @param vault The address of the vault\n     * @param withdrawable The available value of the vault\n     * @param requested The amount attempting to withdraw\n     */\n    error AmountExceedsWithdrawableValue(address vault, uint256 withdrawable, uint256 requested);\n\n    error AlreadyHealthy(address vault);\n    error VaultMintingCapacityExceeded(\n        address vault,\n        uint256 totalValue,\n        uint256 liabilityShares,\n        uint256 newRebalanceThresholdBP\n    );\n    error InsufficientSharesToBurn(address vault, uint256 amount);\n    error ShareLimitExceeded(address vault, uint256 expectedSharesAfterMint, uint256 shareLimit);\n    error AlreadyConnected(address vault, uint256 index);\n    error NotConnectedToHub(address vault);\n    error NotAuthorized();\n    error ZeroAddress();\n    error ZeroArgument();\n    error InvalidBasisPoints(uint256 valueBP, uint256 maxValueBP);\n    error ShareLimitTooHigh(uint256 shareLimit, uint256 maxShareLimit);\n    error InsufficientValueToMint(address vault, uint256 maxLockableValue);\n    error NoLiabilitySharesShouldBeLeft(address vault, uint256 liabilityShares);\n    error CodehashNotAllowed(address vault, bytes32 codehash);\n    error InvalidFees(address vault, uint256 newFees, uint256 oldFees);\n    error VaultOssified(address vault);\n    error VaultInsufficientBalance(address vault, uint256 currentBalance, uint256 expectedBalance);\n    error VaultReportStale(address vault);\n    error PDGNotDepositor(address vault);\n    error ZeroCodehash();\n    error VaultHubNotPendingOwner(address vault);\n    error UnhealthyVaultCannotDeposit(address vault);\n    error VaultIsDisconnecting(address vault);\n    error VaultHasUnsettledObligations(address vault, uint256 unsettledObligations, uint256 allowedUnsettled);\n    error PartialValidatorWithdrawalNotAllowed();\n    error ForcedValidatorExitNotAllowed();\n    error NoBadDebtToWriteOff(address vault, uint256 totalValueShares, uint256 liabilityShares);\n    error BadDebtSocializationNotAllowed();\n}\n",
        "OperatorGrid.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {AccessControlEnumerableUpgradeable} from \"contracts/openzeppelin/5.2/upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\n\nimport {Math256} from \"contracts/common/lib/Math256.sol\";\nimport {ILidoLocator} from \"contracts/common/interfaces/ILidoLocator.sol\";\n\nimport {Confirmable2Addresses} from \"../utils/Confirmable2Addresses.sol\";\n\nimport {IStakingVault} from \"./interfaces/IStakingVault.sol\";\nimport {VaultHub} from \"./VaultHub.sol\";\n\nstruct TierParams {\n    uint256 shareLimit;\n    uint256 reserveRatioBP;\n    uint256 forcedRebalanceThresholdBP;\n    uint256 infraFeeBP;\n    uint256 liquidityFeeBP;\n    uint256 reservationFeeBP;\n}\n\n/**\n * @title OperatorGrid\n * @author loga4\n * @notice\n * OperatorGrid is a contract that manages mint parameters for vaults when they are connected to the VaultHub.\n * These parameters include:\n * - shareLimit: maximum amount of shares that can be minted\n * - reserveRatioBP: reserve ratio in basis points\n * - forcedRebalanceThresholdBP: forced rebalance threshold in basis points\n * - infraFeeBP: infra fee in basis points\n * - liquidityFeeBP: liquidity fee in basis points\n * - reservationFeeBP: reservation fee in basis points\n *\n * These parameters are determined by the Tier in which the Vault is registered.\n *\n */\ncontract OperatorGrid is AccessControlEnumerableUpgradeable, Confirmable2Addresses {\n    /*\n      Key concepts:\n      1. Default Registration:\n         - All Vaults initially have default tier (DEFAULT_TIER_ID = 0)\n         - The default tier has no group\n\n         DEFAULT_TIER_ID = 0\n        ┌──────────────────────┐\n        │        Tier 1        │\n        │  tierShareLimit = z  │\n        │  Vault_1 ... Vault_m │\n        └──────────────────────┘\n\n       2. Tier Change Process:\n         - To predefine vaults tier or modify the existing vault's connection parameters to VaultHub, a tier change must be requested\n         - Both vault owner and node operator must confirm the change (doesn't matter who confirms first)\n         - The confirmation has an expiry time (default 1 hour)\n\n       3. Tier Reset:\n         - When a vault is disconnected from VaultHub, its tier is automatically reset to the default tier (DEFAULT_TIER_ID)\n\n       4. Tier Capacity:\n         - Tiers are not limited by the number of vaults\n         - Tiers are limited by the sum of vaults' liability shares\n\n        ┌──────────────────────────────────────────────────────┐\n        │                 Group 1 = operator 1                 │\n        │  ┌────────────────────────────────────────────────┐  │\n        │  │  groupShareLimit = 1kk                         │  │\n        │  └────────────────────────────────────────────────┘  │\n        │  ┌──────────────────────┐  ┌──────────────────────┐  │\n        │  │       Tier 1         │  │       Tier 2         │  │\n        │  │  tierShareLimit = x  │  │  tierShareLimit = y  │  │\n        │  │  Vault_2 ... Vault_k │  │                      │  │\n        │  └──────────────────────┘  └──────────────────────┘  │\n        └──────────────────────────────────────────────────────┘\n     */\n\n    bytes32 public constant REGISTRY_ROLE = keccak256(\"vaults.OperatorsGrid.Registry\");\n\n    /// @notice Lido Locator contract\n    ILidoLocator public immutable LIDO_LOCATOR;\n\n    uint256 public constant DEFAULT_TIER_ID = 0;\n\n    // Special address to denote that default tier is not linked to any real operator\n    address public constant DEFAULT_TIER_OPERATOR = address(uint160(type(uint160).max));\n\n    /// @dev basis points base\n    uint256 internal constant TOTAL_BASIS_POINTS = 100_00;\n    /// @dev max value for fees in basis points - it's about 650%\n    uint256 internal constant MAX_FEE_BP = type(uint16).max;\n\n    // -----------------------------\n    //            STRUCTS\n    // -----------------------------\n    struct Group {\n        address operator;\n        uint96 shareLimit;\n        uint96 liabilityShares;\n        uint256[] tierIds;\n    }\n\n    struct Tier {\n        address operator;\n        uint96 shareLimit;\n        uint96 liabilityShares;\n        uint16 reserveRatioBP;\n        uint16 forcedRebalanceThresholdBP;\n        uint16 infraFeeBP;\n        uint16 liquidityFeeBP;\n        uint16 reservationFeeBP;\n    }\n\n    /**\n     * @notice ERC-7201 storage namespace for the OperatorGrid\n     * @dev ERC-7201 namespace is used to prevent upgrade collisions\n     * @custom:storage-location erc7201:Lido.Vaults.OperatorGrid\n     * @custom:tiers Tiers\n     * @custom:vaultTier Vault tier\n     * @custom:groups Groups\n     * @custom:nodeOperators Node operators\n     */\n    struct ERC7201Storage {\n        Tier[] tiers;\n        mapping(address vault => uint256 tierId) vaultTier;\n        mapping(address nodeOperator => Group) groups;\n        address[] nodeOperators;\n    }\n\n    /**\n     * @notice Storage offset slot for ERC-7201 namespace\n     *         The storage namespace is used to prevent upgrade collisions\n     *         keccak256(abi.encode(uint256(keccak256(\"Lido.Vaults.OperatorGrid\")) - 1)) & ~bytes32(uint256(0xff))\n     */\n    bytes32 private constant OPERATOR_GRID_STORAGE_LOCATION =\n        0x6b64617c951381e2c1eff2be939fe368ab6d76b7d335df2e47ba2309eba1c700;\n\n\n    /// @notice Initializes the contract with a LidoLocator\n    /// @param _locator LidoLocator contract\n    constructor(ILidoLocator _locator) {\n        LIDO_LOCATOR = _locator;\n\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with an admin\n    /// @param _admin Address of the admin\n    /// @param _defaultTierParams Default tier params for the default tier\n    function initialize(address _admin, TierParams calldata _defaultTierParams) external initializer {\n        if (_admin == address(0)) revert ZeroArgument(\"_admin\");\n\n        __AccessControlEnumerable_init();\n        __Confirmations_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n\n        ERC7201Storage storage $ = _getStorage();\n\n        //create default tier with default share limit\n        $.tiers.push(\n            Tier({\n                operator: DEFAULT_TIER_OPERATOR,\n                shareLimit: uint96(_defaultTierParams.shareLimit),\n                reserveRatioBP: uint16(_defaultTierParams.reserveRatioBP),\n                forcedRebalanceThresholdBP: uint16(_defaultTierParams.forcedRebalanceThresholdBP),\n                infraFeeBP: uint16(_defaultTierParams.infraFeeBP),\n                liquidityFeeBP: uint16(_defaultTierParams.liquidityFeeBP),\n                reservationFeeBP: uint16(_defaultTierParams.reservationFeeBP),\n                liabilityShares: 0\n            })\n        );\n    }\n\n    /// @notice Registers a new group\n    /// @param _nodeOperator address of the node operator\n    /// @param _shareLimit Maximum share limit for the group\n    function registerGroup(address _nodeOperator, uint256 _shareLimit) external onlyRole(REGISTRY_ROLE) {\n        if (_nodeOperator == address(0)) revert ZeroArgument(\"_nodeOperator\");\n\n        ERC7201Storage storage $ = _getStorage();\n        if ($.groups[_nodeOperator].operator != address(0)) revert GroupExists();\n\n        $.groups[_nodeOperator] = Group({\n            operator: _nodeOperator,\n            shareLimit: uint96(_shareLimit),\n            liabilityShares: 0,\n            tierIds: new uint256[](0)\n        });\n        $.nodeOperators.push(_nodeOperator);\n\n        emit GroupAdded(_nodeOperator, uint96(_shareLimit));\n    }\n\n    /// @notice Updates the share limit of a group\n    /// @param _nodeOperator address of the node operator\n    /// @param _shareLimit New share limit value\n    function updateGroupShareLimit(address _nodeOperator, uint256 _shareLimit) external onlyRole(REGISTRY_ROLE) {\n        if (_nodeOperator == address(0)) revert ZeroArgument(\"_nodeOperator\");\n\n        ERC7201Storage storage $ = _getStorage();\n        Group storage group_ = $.groups[_nodeOperator];\n        if (group_.operator == address(0)) revert GroupNotExists();\n\n        group_.shareLimit = uint96(_shareLimit);\n\n        emit GroupShareLimitUpdated(_nodeOperator, uint96(_shareLimit));\n    }\n\n    /// @notice Returns a group by node operator address\n    /// @param _nodeOperator address of the node operator\n    /// @return Group\n    function group(address _nodeOperator) external view returns (Group memory) {\n        return _getStorage().groups[_nodeOperator];\n    }\n\n    /// @notice Returns a node operator address by index\n    /// @param _index index of the node operator\n    /// @return Node operator address\n    function nodeOperatorAddress(uint256 _index) external view returns (address) {\n        ERC7201Storage storage $ = _getStorage();\n        if (_index >= $.nodeOperators.length) revert NodeOperatorNotExists();\n        return $.nodeOperators[_index];\n    }\n\n    /// @notice Returns a node operator count\n    /// @return Node operator count\n    function nodeOperatorCount() external view returns (uint256) {\n        return _getStorage().nodeOperators.length;\n    }\n\n    /// @notice Registers a new tier\n    /// @param _nodeOperator address of the node operator\n    /// @param _tiers array of tiers to register\n    function registerTiers(\n        address _nodeOperator,\n        TierParams[] calldata _tiers\n    ) external onlyRole(REGISTRY_ROLE) {\n        if (_nodeOperator == address(0)) revert ZeroArgument(\"_nodeOperator\");\n\n        ERC7201Storage storage $ = _getStorage();\n        Group storage group_ = $.groups[_nodeOperator];\n        if (group_.operator == address(0)) revert GroupNotExists();\n\n        uint256 tierId = $.tiers.length;\n        uint256 length = _tiers.length;\n        for (uint256 i = 0; i < length; i++) {\n            _validateParams(\n                tierId,\n                _tiers[i].reserveRatioBP,\n                _tiers[i].forcedRebalanceThresholdBP,\n                _tiers[i].infraFeeBP,\n                _tiers[i].liquidityFeeBP,\n                _tiers[i].reservationFeeBP\n            );\n\n            Tier memory tier_ = Tier({\n                operator: _nodeOperator,\n                shareLimit: uint96(_tiers[i].shareLimit),\n                reserveRatioBP: uint16(_tiers[i].reserveRatioBP),\n                forcedRebalanceThresholdBP: uint16(_tiers[i].forcedRebalanceThresholdBP),\n                infraFeeBP: uint16(_tiers[i].infraFeeBP),\n                liquidityFeeBP: uint16(_tiers[i].liquidityFeeBP),\n                reservationFeeBP: uint16(_tiers[i].reservationFeeBP),\n                liabilityShares: 0\n            });\n            $.tiers.push(tier_);\n            group_.tierIds.push(tierId);\n\n            emit TierAdded(\n                _nodeOperator,\n                tierId,\n                uint96(tier_.shareLimit),\n                uint16(tier_.reserveRatioBP),\n                uint16(tier_.forcedRebalanceThresholdBP),\n                uint16(tier_.infraFeeBP),\n                uint16(tier_.liquidityFeeBP),\n                uint16(tier_.reservationFeeBP)\n            );\n\n            tierId++;\n        }\n    }\n\n    /// @notice Returns a tier by ID\n    /// @param _tierId id of the tier\n    /// @return Tier\n    function tier(uint256 _tierId) external view returns (Tier memory) {\n        ERC7201Storage storage $ = _getStorage();\n        if (_tierId >= $.tiers.length) revert TierNotExists();\n        return $.tiers[_tierId];\n    }\n\n    /// @notice Returns a tiers count\n    /// @return Tiers count\n    function tiersCount() external view returns (uint256) {\n        return _getStorage().tiers.length;\n    }\n\n    /// @notice Alters multiple tiers\n    /// @dev We do not enforce to update old vaults with the new tier params, only new ones.\n    /// @param _tierIds array of tier ids to alter\n    /// @param _tierParams array of new tier params\n    function alterTiers(\n        uint256[] calldata _tierIds,\n        TierParams[] calldata _tierParams\n    ) external onlyRole(REGISTRY_ROLE) {\n        if (_tierIds.length != _tierParams.length) revert ArrayLengthMismatch();\n\n        ERC7201Storage storage $ = _getStorage();\n        uint256 length = _tierIds.length;\n        uint256 tiersLength = $.tiers.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            if (_tierIds[i] >= tiersLength) revert TierNotExists();\n\n            _validateParams(\n                _tierIds[i],\n                _tierParams[i].reserveRatioBP,\n                _tierParams[i].forcedRebalanceThresholdBP,\n                _tierParams[i].infraFeeBP,\n                _tierParams[i].liquidityFeeBP,\n                _tierParams[i].reservationFeeBP\n            );\n\n            Tier storage tier_ = $.tiers[_tierIds[i]];\n\n            tier_.shareLimit = uint96(_tierParams[i].shareLimit);\n            tier_.reserveRatioBP = uint16(_tierParams[i].reserveRatioBP);\n            tier_.forcedRebalanceThresholdBP = uint16(_tierParams[i].forcedRebalanceThresholdBP);\n            tier_.infraFeeBP = uint16(_tierParams[i].infraFeeBP);\n            tier_.liquidityFeeBP = uint16(_tierParams[i].liquidityFeeBP);\n            tier_.reservationFeeBP = uint16(_tierParams[i].reservationFeeBP);\n\n            emit TierUpdated(\n                _tierIds[i],\n                tier_.shareLimit,\n                tier_.reserveRatioBP,\n                tier_.forcedRebalanceThresholdBP,\n                tier_.infraFeeBP,\n                tier_.liquidityFeeBP,\n                tier_.reservationFeeBP\n            );\n        }\n    }\n\n    /// @notice Vault tier change with multi-role confirmation\n    /// @param _vault address of the vault\n    /// @param _requestedTierId id of the tier\n    /// @param _requestedShareLimit share limit to set\n    /// @return bool Whether the tier change was confirmed.\n    /*\n\n    Legend:\n    V = Vault1.liabilityShares\n    LS = liabilityShares\n\n    Scheme1 - transfer Vault from default tier to Tier2\n\n                                         ┌──────────────────────────────┐\n                                         │           Group 1            │\n                                         │                              │\n    ┌────────────────────┐               │  ┌─────────┐  ┌───────────┐  │\n    │  Tier 1 (default)  │   confirm     │  │ Tier 2  │  │ Tier 3    │  │\n    │  LS: -V            │    ─────>     │  │ LS:+V   │  │           │  │\n    └────────────────────┘               │  └─────────┘  └───────────┘  │\n                                         │                              │\n                                         │   Group1.liabilityShares: +V │\n                                         └──────────────────────────────┘\n\n    After confirmation:\n    - Tier 1.liabilityShares   = -V\n    - Tier 2.liabilityShares   = +V\n    - Group1.liabilityShares   = +V\n\n    --------------------------------------------------------------------------\n    Scheme2 - transfer Vault from Tier2 to Tier3, no need to change group minted shares\n\n    ┌────────────────────────────────┐     ┌────────────────────────────────┐\n    │           Group 1              │     │           Group 2              │\n    │                                │     │                                │\n    │  ┌───────────┐  ┌───────────┐  │     │  ┌───────────┐                 │\n    │  │ Tier 2    │  │ Tier 3    │  │     │  │ Tier 4    │                 │\n    │  │ LS:-V     │  │ LS:+V     │  │     │  │           │                 │\n    │  └───────────┘  └───────────┘  │     │  └───────────┘                 │\n    │  operator1                     │     │  operator2                     │\n    └────────────────────────────────┘     └────────────────────────────────┘\n\n    After confirmation:\n    - Tier 2.liabilityShares   = -V\n    - Tier 3.liabilityShares   = +V\n\n    NB: Cannot change from Tier2 to Tier1, because Tier1 has no group\n    NB: Cannot change from Tier2 to Tier4, because Tier4 has different operator.\n\n    */\n    function changeTier(address _vault, uint256 _requestedTierId, uint256 _requestedShareLimit) external returns (bool) {\n        if (_vault == address(0)) revert ZeroArgument(\"_vault\");\n\n        ERC7201Storage storage $ = _getStorage();\n        if (_requestedTierId >= $.tiers.length) revert TierNotExists();\n        if (_requestedTierId == DEFAULT_TIER_ID) revert CannotChangeToDefaultTier();\n\n        VaultHub vaultHub = _vaultHub();\n        bool isVaultConnected = vaultHub.isVaultConnected(_vault);\n\n        address vaultOwner = isVaultConnected\n            ? vaultHub.vaultConnection(_vault).owner\n            : IStakingVault(_vault).owner();\n\n        address nodeOperator = IStakingVault(_vault).nodeOperator();\n\n        uint256 vaultTierId = $.vaultTier[_vault];\n        if (vaultTierId == _requestedTierId) revert TierAlreadySet();\n\n        Tier storage requestedTier = $.tiers[_requestedTierId];\n        if (nodeOperator != requestedTier.operator) revert TierNotInOperatorGroup();\n        if (_requestedShareLimit > requestedTier.shareLimit) revert RequestedShareLimitTooHigh(_requestedShareLimit, requestedTier.shareLimit);\n\n        // store the caller's confirmation; only proceed if the required number of confirmations is met.\n        if (!_collectAndCheckConfirmations(msg.data, vaultOwner, nodeOperator)) return false;\n        uint256 vaultLiabilityShares = vaultHub.liabilityShares(_vault);\n\n        //check if tier limit is exceeded\n        if (requestedTier.liabilityShares + vaultLiabilityShares > requestedTier.shareLimit) revert TierLimitExceeded();\n\n        // if the vault was in the default tier:\n        // - that mean that the vault has no group, so we decrease only the minted shares of the default tier\n        // - but need to check requested group limit exceeded\n        if (vaultTierId == DEFAULT_TIER_ID) {\n            Group storage requestedGroup = $.groups[nodeOperator];\n            if (requestedGroup.liabilityShares + vaultLiabilityShares > requestedGroup.shareLimit) {\n                revert GroupLimitExceeded();\n            }\n            requestedGroup.liabilityShares += uint96(vaultLiabilityShares);\n        }\n\n        Tier storage currentTier = $.tiers[vaultTierId];\n\n        currentTier.liabilityShares -= uint96(vaultLiabilityShares);\n        requestedTier.liabilityShares += uint96(vaultLiabilityShares);\n\n        $.vaultTier[_vault] = _requestedTierId;\n\n        // Vault may not be connected to VaultHub yet.\n        // There are two possible flows:\n        // 1. Vault is created and connected to VaultHub immediately with the default tier.\n        //    In this case, `VaultConnection` is non-zero and updateConnection must be called.\n        // 2. Vault is created, its tier is changed before connecting to VaultHub.\n        //    In this case, `VaultConnection` is still zero, and updateConnection must be skipped.\n        // Hence, we update the VaultHub connection only if the vault is already connected.\n        vaultHub.updateConnection(\n            _vault,\n            _requestedShareLimit,\n            requestedTier.reserveRatioBP,\n            requestedTier.forcedRebalanceThresholdBP,\n            requestedTier.infraFeeBP,\n            requestedTier.liquidityFeeBP,\n            requestedTier.reservationFeeBP\n        );\n\n        emit TierChanged(_vault, _requestedTierId, _requestedShareLimit);\n\n        return true;\n    }\n\n    /// @notice Reset vault's tier to default\n    /// @param _vault address of the vault\n    /// @dev Requires vault's liabilityShares to be zero before resetting the tier\n    function resetVaultTier(address _vault) external {\n        if (msg.sender != LIDO_LOCATOR.vaultHub()) revert NotAuthorized(\"resetVaultTier\", msg.sender);\n\n        ERC7201Storage storage $ = _getStorage();\n\n        if ($.vaultTier[_vault] != DEFAULT_TIER_ID) {\n            $.vaultTier[_vault] = DEFAULT_TIER_ID;\n\n            emit TierChanged(_vault, DEFAULT_TIER_ID, $.tiers[DEFAULT_TIER_ID].shareLimit);\n        }\n    }\n\n   // -----------------------------\n   //     MINT / BURN\n   // -----------------------------\n\n    /// @notice Mint shares limit check\n    /// @param _vault address of the vault\n    /// @param _amount amount of shares will be minted\n    function onMintedShares(\n        address _vault,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LIDO_LOCATOR.vaultHub()) revert NotAuthorized(\"onMintedShares\", msg.sender);\n\n        ERC7201Storage storage $ = _getStorage();\n\n        uint256 tierId = $.vaultTier[_vault];\n        Tier storage tier_ = $.tiers[tierId];\n\n        uint96 tierLiabilityShares = tier_.liabilityShares;\n        if (tierLiabilityShares + _amount > tier_.shareLimit) revert TierLimitExceeded();\n\n        tier_.liabilityShares = tierLiabilityShares + uint96(_amount);\n\n        if (tierId != DEFAULT_TIER_ID) {\n            Group storage group_ = $.groups[tier_.operator];\n            uint96 groupMintedShares = group_.liabilityShares;\n            if (groupMintedShares + _amount > group_.shareLimit) revert GroupLimitExceeded();\n\n            group_.liabilityShares = groupMintedShares + uint96(_amount);\n        }\n    }\n\n    /// @notice Burn shares limit check\n    /// @param _vault address of the vault\n    /// @param _amount amount of shares to burn\n    function onBurnedShares(\n        address _vault,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LIDO_LOCATOR.vaultHub()) revert NotAuthorized(\"burnShares\", msg.sender);\n\n        ERC7201Storage storage $ = _getStorage();\n\n        uint256 tierId = $.vaultTier[_vault];\n\n        Tier storage tier_ = $.tiers[tierId];\n\n        // we skip the check for minted shared underflow, because it's done in the VaultHub.burnShares()\n\n        tier_.liabilityShares -= uint96(_amount);\n\n        if (tierId != DEFAULT_TIER_ID) {\n            Group storage group_ = $.groups[tier_.operator];\n            group_.liabilityShares -= uint96(_amount);\n        }\n    }\n\n    /// @notice Get vault limits\n    /// @param _vault address of the vault\n    /// @return nodeOperator node operator of the vault\n    /// @return tierId tier id of the vault\n    /// @return shareLimit share limit of the vault\n    /// @return reserveRatioBP reserve ratio of the vault\n    /// @return forcedRebalanceThresholdBP forced rebalance threshold of the vault\n    /// @return infraFeeBP infra fee of the vault\n    /// @return liquidityFeeBP liquidity fee of the vault\n    /// @return reservationFeeBP reservation fee of the vault\n    function vaultInfo(address _vault)\n        external\n        view\n        returns (\n            address nodeOperator,\n            uint256 tierId,\n            uint256 shareLimit,\n            uint256 reserveRatioBP,\n            uint256 forcedRebalanceThresholdBP,\n            uint256 infraFeeBP,\n            uint256 liquidityFeeBP,\n            uint256 reservationFeeBP\n        )\n    {\n        ERC7201Storage storage $ = _getStorage();\n\n        tierId = $.vaultTier[_vault];\n\n        Tier memory t = $.tiers[tierId];\n        nodeOperator = t.operator;\n\n        shareLimit = t.shareLimit;\n        reserveRatioBP = t.reserveRatioBP;\n        forcedRebalanceThresholdBP = t.forcedRebalanceThresholdBP;\n        infraFeeBP = t.infraFeeBP;\n        liquidityFeeBP = t.liquidityFeeBP;\n        reservationFeeBP = t.reservationFeeBP;\n    }\n\n    /// @notice Returns the effective share limit of a vault according to the OperatorGrid and vault share limits\n    /// @param _vault address of the vault\n    /// @return shareLimit effective share limit of the vault\n    function effectiveShareLimit(address _vault) public view returns (uint256) {\n        VaultHub vaultHub = _vaultHub();\n        uint256 shareLimit = vaultHub.vaultConnection(_vault).shareLimit;\n        uint256 liabilityShares = vaultHub.liabilityShares(_vault);\n\n        uint256 gridShareLimit = _gridRemainingShareLimit(_vault) + liabilityShares;\n        return Math256.min(gridShareLimit, shareLimit);\n    }\n\n    /// @notice Returns the remaining share limit in a given tier and group\n    /// @param _vault address of the vault\n    /// @return remaining share limit\n    /// @dev remaining share limit inherits the limits of the vault tier and group,\n    ///      and accounts liabilities of other vaults belonging to the same tier and group\n    function _gridRemainingShareLimit(address _vault) internal view returns (uint256) {\n        ERC7201Storage storage $ = _getStorage();\n        uint256 tierId = $.vaultTier[_vault];\n        Tier storage t = $.tiers[tierId];\n\n        uint256 tierLimit = t.shareLimit;\n        uint256 tierRemaining = tierLimit > t.liabilityShares ? tierLimit - t.liabilityShares : 0;\n\n        if (tierId == DEFAULT_TIER_ID) return tierRemaining;\n\n        Group storage g = $.groups[t.operator];\n        uint256 groupLimit = g.shareLimit;\n        uint256 groupRemaining = groupLimit > g.liabilityShares ? groupLimit - g.liabilityShares : 0;\n        return Math256.min(tierRemaining, groupRemaining);\n    }\n\n    /// @notice Validates tier parameters\n    /// @param _reserveRatioBP Reserve ratio\n    /// @param _forcedRebalanceThresholdBP Forced rebalance threshold\n    /// @param _infraFeeBP Infra fee\n    /// @param _liquidityFeeBP Liquidity fee\n    /// @param _reservationFeeBP Reservation fee\n    function _validateParams(\n      uint256 _tierId,\n      uint256 _reserveRatioBP,\n      uint256 _forcedRebalanceThresholdBP,\n      uint256 _infraFeeBP,\n      uint256 _liquidityFeeBP,\n      uint256 _reservationFeeBP\n    ) internal pure {\n        if (_reserveRatioBP == 0) revert ZeroArgument(\"_reserveRatioBP\");\n        if (_reserveRatioBP > TOTAL_BASIS_POINTS)\n            revert ReserveRatioTooHigh(_tierId, _reserveRatioBP, TOTAL_BASIS_POINTS);\n\n        if (_forcedRebalanceThresholdBP == 0) revert ZeroArgument(\"_forcedRebalanceThresholdBP\");\n        if (_forcedRebalanceThresholdBP > _reserveRatioBP)\n            revert ForcedRebalanceThresholdTooHigh(_tierId, _forcedRebalanceThresholdBP, _reserveRatioBP);\n\n        if (_infraFeeBP > MAX_FEE_BP)\n            revert InfraFeeTooHigh(_tierId, _infraFeeBP, MAX_FEE_BP);\n\n        if (_liquidityFeeBP > MAX_FEE_BP)\n            revert LiquidityFeeTooHigh(_tierId, _liquidityFeeBP, MAX_FEE_BP);\n\n        if (_reservationFeeBP > MAX_FEE_BP)\n            revert ReservationFeeTooHigh(_tierId, _reservationFeeBP, MAX_FEE_BP);\n    }\n\n    function _vaultHub() internal view returns (VaultHub) {\n        return VaultHub(payable(LIDO_LOCATOR.vaultHub()));\n    }\n\n    function _getStorage() private pure returns (ERC7201Storage storage $) {\n        assembly {\n            $.slot := OPERATOR_GRID_STORAGE_LOCATION\n        }\n    }\n\n    // -----------------------------\n    //            EVENTS\n    // -----------------------------\n    event GroupAdded(address indexed nodeOperator, uint256 shareLimit);\n    event GroupShareLimitUpdated(address indexed nodeOperator, uint256 shareLimit);\n    event TierAdded(\n        address indexed nodeOperator,\n        uint256 indexed tierId,\n        uint256 shareLimit,\n        uint256 reserveRatioBP,\n        uint256 forcedRebalanceThresholdBP,\n        uint256 infraFeeBP,\n        uint256 liquidityFeeBP,\n        uint256 reservationFeeBP\n    );\n    event TierChanged(address indexed vault, uint256 indexed tierId, uint256 shareLimit);\n    event TierUpdated(\n      uint256 indexed tierId,\n      uint256 shareLimit,\n      uint256 reserveRatioBP,\n      uint256 forcedRebalanceThresholdBP,\n      uint256 infraFeeBP,\n      uint256 liquidityFeeBP,\n      uint256 reservationFeeBP\n    );\n\n    // -----------------------------\n    //            ERRORS\n    // -----------------------------\n    error NotAuthorized(string operation, address sender);\n    error ZeroArgument(string argument);\n    error GroupExists();\n    error GroupNotExists();\n    error GroupLimitExceeded();\n    error NodeOperatorNotExists();\n    error TierLimitExceeded();\n\n    error TierNotExists();\n    error TierAlreadySet();\n    error TierNotInOperatorGroup();\n    error CannotChangeToDefaultTier();\n\n    error ReserveRatioTooHigh(uint256 tierId, uint256 reserveRatioBP, uint256 maxReserveRatioBP);\n    error ForcedRebalanceThresholdTooHigh(uint256 tierId, uint256 forcedRebalanceThresholdBP, uint256 reserveRatioBP);\n    error InfraFeeTooHigh(uint256 tierId, uint256 infraFeeBP, uint256 maxInfraFeeBP);\n    error LiquidityFeeTooHigh(uint256 tierId, uint256 liquidityFeeBP, uint256 maxLiquidityFeeBP);\n    error ReservationFeeTooHigh(uint256 tierId, uint256 reservationFeeBP, uint256 maxReservationFeeBP);\n    error ArrayLengthMismatch();\n    error RequestedShareLimitTooHigh(uint256 requestedShareLimit, uint256 tierShareLimit);\n}\n",
        "LazyOracle.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {MerkleProof} from \"@openzeppelin/contracts-v5.2/utils/cryptography/MerkleProof.sol\";\n\nimport {AccessControlEnumerableUpgradeable} from \"contracts/openzeppelin/5.2/upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\n\nimport {Math256} from \"contracts/common/lib/Math256.sol\";\nimport {ILazyOracle} from \"contracts/common/interfaces/ILazyOracle.sol\";\nimport {ILidoLocator} from \"contracts/common/interfaces/ILidoLocator.sol\";\nimport {ILido} from \"contracts/common/interfaces/ILido.sol\";\nimport {IHashConsensus} from \"contracts/common/interfaces/IHashConsensus.sol\";\n\nimport {VaultHub} from \"./VaultHub.sol\";\nimport {OperatorGrid} from \"./OperatorGrid.sol\";\n\nimport {IStakingVault} from \"./interfaces/IStakingVault.sol\";\n\ncontract LazyOracle is ILazyOracle, AccessControlEnumerableUpgradeable {\n    /// @custom:storage-location erc7201:LazyOracle\n    struct Storage {\n        /// @notice root of the vaults data tree\n        bytes32 vaultsDataTreeRoot;\n        /// @notice CID of the vaults data tree\n        string vaultsDataReportCid;\n        /// @notice timestamp of the vaults data\n        uint64 vaultsDataTimestamp;\n        /// @notice total value increase quarantine period\n        uint64 quarantinePeriod;\n        /// @notice max reward ratio for refSlot-observed total value, basis points\n        uint16 maxRewardRatioBP;\n        /// @notice deposit quarantines for each vault\n        mapping(address vault => Quarantine) vaultQuarantines;\n    }\n\n    /*\n        A quarantine is a timelock applied to any sudden jump in a vault's reported total value\n        that cannot be immediately confirmed on-chain (via the inOutDelta difference). If the\n        reported total value exceeds the expected routine EL/CL rewards, the excess is pushed\n        into a quarantine buffer for a predefined cooldown period. Only after this delay is the\n        quarantined value released into VaultHub's total value.\n\n        Normal top-ups — where the vault owner funds the contract directly using the `fund()`\n        function — do not go through quarantine, as they can be verified on-chain via the\n        inOutDelta value. These direct fundings are reflected immediately. In contrast,\n        consolidations or deposits that bypass the vault's balance must sit in quarantine.\n\n        Example flow:\n\n        Time 0: Total Value = 100 ETH\n        ┌────────────────────────────────────┐\n        │            100 ETH Active          │\n        └────────────────────────────────────┘\n\n        Time 1: Sudden jump of +50 ETH → start quarantine for 50 ETH\n        ┌────────────────────────────────────┐\n        │            100 ETH Active          │\n        │            50 ETH Quarantined      │\n        └────────────────────────────────────┘\n\n        Time 2: Another jump of +70 ETH → wait for current quarantine to expire\n        ┌────────────────────────────────────┐\n        │            100 ETH Active          │\n        │            50 ETH Quarantined      │\n        │            70 ETH Quarantine Queue │\n        └────────────────────────────────────┘\n\n        Time 3: First quarantine expires → add 50 ETH to active value, start new quarantine for 70 ETH\n        ┌────────────────────────────────────┐\n        │            150 ETH Active          │\n        │            70 ETH Quarantined      │\n        └────────────────────────────────────┘\n\n        Time 4: Second quarantine expires → add 70 ETH to active value\n        ┌────────────────────────────────────┐\n        │            220 ETH Active          │\n        └────────────────────────────────────┘\n    */\n    struct Quarantine {\n        uint128 pendingTotalValueIncrease;\n        uint64 startTimestamp;\n    }\n\n    struct QuarantineInfo {\n        bool isActive;\n        uint256 pendingTotalValueIncrease;\n        uint256 startTimestamp;\n        uint256 endTimestamp;\n    }\n\n    struct VaultInfo {\n        address vault;\n        uint96 vaultIndex;\n        uint256 balance;\n        bytes32 withdrawalCredentials;\n        uint256 liabilityShares;\n        uint256 mintableStETH;\n        uint96 shareLimit;\n        uint16 reserveRatioBP;\n        uint16 forcedRebalanceThresholdBP;\n        uint16 infraFeeBP;\n        uint16 liquidityFeeBP;\n        uint16 reservationFeeBP;\n        bool pendingDisconnect;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"LazyOracle\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant LAZY_ORACLE_STORAGE_LOCATION =\n        0xe5459f2b48ec5df2407caac4ec464a5cb0f7f31a1f22f649728a9579b25c1d00;\n\n    bytes32 public constant UPDATE_SANITY_PARAMS_ROLE = keccak256(\"UPDATE_SANITY_PARAMS_ROLE\");\n\n    ILidoLocator public immutable LIDO_LOCATOR;\n\n    /// @dev basis points base\n    uint256 private constant TOTAL_BASIS_POINTS = 100_00;\n    uint256 private constant MAX_SANE_TOTAL_VALUE = type(uint96).max;\n\n    constructor(address _lidoLocator) {\n        LIDO_LOCATOR = ILidoLocator(payable(_lidoLocator));\n\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param _admin Address of the admin\n    /// @param _quarantinePeriod the quarantine period, seconds\n    /// @param _maxRewardRatioBP the max reward ratio, basis points\n    function initialize(address _admin, uint64 _quarantinePeriod, uint16 _maxRewardRatioBP) external initializer {\n        if (_admin == address(0)) revert AdminCannotBeZero();\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n\n        _updateSanityParams(_quarantinePeriod, _maxRewardRatioBP);\n    }\n\n    /// @notice returns the latest report data\n    /// @return timestamp of the report\n    /// @return treeRoot merkle root of the report\n    /// @return reportCid IPFS CID for the report JSON file\n    function latestReportData() external view returns (uint64 timestamp, bytes32 treeRoot, string memory reportCid) {\n        Storage storage $ = _storage();\n        return ($.vaultsDataTimestamp, $.vaultsDataTreeRoot, $.vaultsDataReportCid);\n    }\n\n    /// @notice returns the latest report timestamp\n    function latestReportTimestamp() external view returns (uint64) {\n        return _storage().vaultsDataTimestamp;\n    }\n\n    /// @notice returns the quarantine period\n    function quarantinePeriod() external view returns (uint64) {\n        return _storage().quarantinePeriod;\n    }\n\n    /// @notice returns the max reward ratio for refSlot total value, basis points\n    function maxRewardRatioBP() external view returns (uint16) {\n        return _storage().maxRewardRatioBP;\n    }\n\n    /// @notice returns the quarantine info for the vault\n    /// @param _vault the address of the vault\n    // @dev returns zeroed structure if there is no active quarantine\n    function vaultQuarantine(address _vault) external view returns (QuarantineInfo memory) {\n        Quarantine storage q = _storage().vaultQuarantines[_vault];\n        if (q.pendingTotalValueIncrease == 0) {\n            return QuarantineInfo(false, 0, 0, 0);\n        }\n\n        return QuarantineInfo({\n            isActive: true,\n            pendingTotalValueIncrease: q.pendingTotalValueIncrease,\n            startTimestamp: q.startTimestamp,\n            endTimestamp: q.startTimestamp + _storage().quarantinePeriod\n        });\n    }\n\n    /// @notice returns batch of vaults info\n    /// @param _offset in the vaults list [0, vaultsCount)\n    /// @param _limit maximum number of vaults to return\n    /// @return batch of vaults info\n    function batchVaultsInfo(uint256 _offset, uint256 _limit) external view returns (VaultInfo[] memory) {\n        VaultHub vaultHub = _vaultHub();\n        uint256 vaultCount = vaultHub.vaultsCount();\n        uint256 batchSize;\n        if (_offset > vaultCount) {\n            batchSize = 0;\n        } else {\n            batchSize = _offset + _limit > vaultCount ? vaultCount - _offset : _limit;\n        }\n\n        VaultInfo[] memory batch = new VaultInfo[](batchSize);\n        for (uint256 i = 0; i < batchSize; i++) {\n            address vaultAddress = vaultHub.vaultByIndex(_offset + i + 1);\n            IStakingVault vault = IStakingVault(vaultAddress);\n            VaultHub.VaultConnection memory connection = vaultHub.vaultConnection(vaultAddress);\n            VaultHub.VaultRecord memory record = vaultHub.vaultRecord(vaultAddress);\n            batch[i] = VaultInfo(\n                vaultAddress,\n                connection.vaultIndex,\n                address(vault).balance,\n                vault.withdrawalCredentials(),\n                record.liabilityShares,\n                _mintableStETH(vaultAddress),\n                connection.shareLimit,\n                connection.reserveRatioBP,\n                connection.forcedRebalanceThresholdBP,\n                connection.infraFeeBP,\n                connection.liquidityFeeBP,\n                connection.reservationFeeBP,\n                connection.pendingDisconnect\n            );\n        }\n        return batch;\n    }\n\n    /// @notice update the sanity parameters\n    /// @param _quarantinePeriod the quarantine period\n    /// @param _maxRewardRatioBP the max EL CL rewards\n    function updateSanityParams(\n        uint64 _quarantinePeriod,\n        uint16 _maxRewardRatioBP\n    ) external onlyRole(UPDATE_SANITY_PARAMS_ROLE) {\n        _updateSanityParams(_quarantinePeriod, _maxRewardRatioBP);\n    }\n\n    /// @notice Store the report root and its meta information\n    /// @param _vaultsDataTimestamp the timestamp of the report\n    /// @param _vaultsDataTreeRoot the root of the report\n    /// @param _vaultsDataReportCid the CID of the report\n    function updateReportData(\n        uint256 _vaultsDataTimestamp,\n        bytes32 _vaultsDataTreeRoot,\n        string memory _vaultsDataReportCid\n    ) external override(ILazyOracle) {\n        if (msg.sender != LIDO_LOCATOR.accountingOracle()) revert NotAuthorized();\n\n        Storage storage $ = _storage();\n        $.vaultsDataTimestamp = uint64(_vaultsDataTimestamp);\n        $.vaultsDataTreeRoot = _vaultsDataTreeRoot;\n        $.vaultsDataReportCid = _vaultsDataReportCid;\n\n        emit VaultsReportDataUpdated(_vaultsDataTimestamp, _vaultsDataTreeRoot, _vaultsDataReportCid);\n    }\n\n    /// @notice Permissionless update of the vault data\n    /// @param _vault the address of the vault\n    /// @param _totalValue the total value of the vault\n    /// @param _cumulativeLidoFees the cumulative Lido fees accrued on the vault (nominated in ether)\n    /// @param _liabilityShares the liabilityShares of the vault\n    /// @param _proof the proof of the reported data\n    function updateVaultData(\n        address _vault,\n        uint256 _totalValue,\n        uint256 _cumulativeLidoFees,\n        uint256 _liabilityShares,\n        uint256 _slashingReserve,\n        bytes32[] calldata _proof\n    ) external {\n        bytes32 leaf = keccak256(\n            bytes.concat(\n                keccak256(\n                    abi.encode(\n                        _vault,\n                        _totalValue,\n                        _cumulativeLidoFees,\n                        _liabilityShares,\n                        _slashingReserve\n                    )\n                )\n            )\n        );\n        if (!MerkleProof.verify(_proof, _storage().vaultsDataTreeRoot, leaf)) revert InvalidProof();\n\n        int256 inOutDelta;\n        (_totalValue, inOutDelta) = _handleSanityChecks(_vault, _totalValue);\n\n        _vaultHub().applyVaultReport(\n            _vault,\n            _storage().vaultsDataTimestamp,\n            _totalValue,\n            inOutDelta,\n            _cumulativeLidoFees,\n            _liabilityShares,\n            _slashingReserve\n        );\n    }\n\n    /// @notice handle sanity checks for the vault lazy report data\n    /// @param _vault the address of the vault\n    /// @param _totalValue the total value of the vault in refSlot\n    /// @return totalValueWithoutQuarantine the smoothed total value of the vault after sanity checks\n    /// @return inOutDeltaOnRefSlot the inOutDelta in the refSlot\n    function _handleSanityChecks(\n        address _vault,\n        uint256 _totalValue\n    ) public returns (uint256 totalValueWithoutQuarantine, int256 inOutDeltaOnRefSlot) {\n        VaultHub vaultHub = _vaultHub();\n        VaultHub.VaultRecord memory record = vaultHub.vaultRecord(_vault);\n\n        // 1. Calculate inOutDelta in the refSlot\n        int256 currentInOutDelta = record.inOutDelta.value;\n        inOutDeltaOnRefSlot = vaultHub.inOutDeltaAsOfLastRefSlot(_vault);\n\n        // 2. Sanity check for total value increase\n        totalValueWithoutQuarantine = _processTotalValue(_vault, _totalValue, inOutDeltaOnRefSlot, record);\n\n        // 3. Sanity check for dynamic total value underflow\n        if (int256(totalValueWithoutQuarantine) + currentInOutDelta - inOutDeltaOnRefSlot < 0) {\n            revert UnderflowInTotalValueCalculation();\n        }\n    }\n\n    function _processTotalValue(\n        address _vault,\n        uint256 _reportedTotalValue,\n        int256 _inOutDeltaOnRefSlot,\n        VaultHub.VaultRecord memory record\n    ) internal returns (uint256 totalValueWithoutQuarantine) {\n        if (_reportedTotalValue > MAX_SANE_TOTAL_VALUE) {\n            revert TotalValueTooLarge();\n        }\n\n        Storage storage $ = _storage();\n\n        // total value from the previous report with inOutDelta correction till the current refSlot\n        // it does not include CL difference and EL rewards for the period\n        uint256 onchainTotalValueOnRefSlot =\n            uint256(int256(uint256(record.report.totalValue)) + _inOutDeltaOnRefSlot - record.report.inOutDelta);\n        // some percentage of funds hasn't passed through the vault's balance is allowed for the EL and CL rewards handling\n        uint256 maxSaneTotalValue = onchainTotalValueOnRefSlot *\n            (TOTAL_BASIS_POINTS + $.maxRewardRatioBP) / TOTAL_BASIS_POINTS;\n\n        if (_reportedTotalValue > maxSaneTotalValue) {\n            Quarantine storage q = $.vaultQuarantines[_vault];\n            uint64 reportTs = $.vaultsDataTimestamp;\n            uint128 quarDelta = q.pendingTotalValueIncrease;\n            uint128 delta = uint128(_reportedTotalValue - onchainTotalValueOnRefSlot);\n\n            if (quarDelta == 0) { // first overlimit report\n                _reportedTotalValue = onchainTotalValueOnRefSlot;\n                q.pendingTotalValueIncrease = delta;\n                q.startTimestamp = reportTs;\n                emit QuarantinedDeposit(_vault, delta);\n            } else if (reportTs - q.startTimestamp < $.quarantinePeriod) { // quarantine not expired\n                _reportedTotalValue = onchainTotalValueOnRefSlot;\n            } else if (delta <= quarDelta + onchainTotalValueOnRefSlot * $.maxRewardRatioBP / TOTAL_BASIS_POINTS) { // quarantine expired\n                q.pendingTotalValueIncrease = 0;\n                emit QuarantineExpired(_vault, delta);\n            } else { // start new quarantine\n                _reportedTotalValue = onchainTotalValueOnRefSlot + quarDelta;\n                q.pendingTotalValueIncrease = delta - quarDelta;\n                q.startTimestamp = reportTs;\n                emit QuarantinedDeposit(_vault, delta - quarDelta);\n            }\n        }\n\n        return _reportedTotalValue;\n    }\n\n    function _updateSanityParams(uint64 _quarantinePeriod, uint16 _maxRewardRatioBP) internal {\n        Storage storage $ = _storage();\n        $.quarantinePeriod = _quarantinePeriod;\n        $.maxRewardRatioBP = _maxRewardRatioBP;\n        emit SanityParamsUpdated(_quarantinePeriod, _maxRewardRatioBP);\n    }\n\n    function _mintableStETH(address _vault) internal view returns (uint256) {\n        VaultHub vaultHub = _vaultHub();\n        uint256 maxLockableValue = vaultHub.maxLockableValue(_vault);\n        uint256 reserveRatioBP = vaultHub.vaultConnection(_vault).reserveRatioBP;\n        uint256 mintableStETHByRR = maxLockableValue * (TOTAL_BASIS_POINTS - reserveRatioBP) / TOTAL_BASIS_POINTS;\n\n        uint256 effectiveShareLimit = _operatorGrid().effectiveShareLimit(_vault);\n        uint256 mintableStEthByShareLimit = ILido(LIDO_LOCATOR.lido()).getPooledEthBySharesRoundUp(effectiveShareLimit);\n\n        return Math256.min(mintableStETHByRR, mintableStEthByShareLimit);\n    }\n\n    function _storage() internal pure returns (Storage storage $) {\n        assembly {\n            $.slot := LAZY_ORACLE_STORAGE_LOCATION\n        }\n    }\n\n    function _vaultHub() internal view returns (VaultHub) {\n        return VaultHub(payable(LIDO_LOCATOR.vaultHub()));\n    }\n\n    function _operatorGrid() internal view returns (OperatorGrid) {\n        return OperatorGrid(LIDO_LOCATOR.operatorGrid());\n    }\n\n    event VaultsReportDataUpdated(uint256 indexed timestamp, bytes32 indexed root, string cid);\n    event QuarantinedDeposit(address indexed vault, uint128 delta);\n    event SanityParamsUpdated(uint64 quarantinePeriod, uint16 maxRewardRatioBP);\n    event QuarantineExpired(address indexed vault, uint128 delta);\n    error AdminCannotBeZero();\n    error NotAuthorized();\n    error InvalidProof();\n    error UnderflowInTotalValueCalculation();\n    error TotalValueTooLarge();\n}\n"
    }
}