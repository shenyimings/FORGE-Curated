{
    "vfp_id": "vfp_00139",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Allowing extra upper bits for indexes allows invalid proofs to pass in BeaconStateVerifier",
            "description": "The vulnerability stems from using uint256 for index parameters in BeaconStateVerifier functions when smaller types (uint40 and uint16) should be used, given the fixed sizes of the underlying data structures.\n\nThe root cause is improper type enforcement in pathBeaconStateToValidator() and pathBlockToWithdrawal(), where _validatorIndex and _withdrawalNum are declared as uint256 instead of being restricted to 40 and 4 bits respectively. This allows attackers to craft indices with extra upper bits that overflow into the gIndex calculation.\n\nAn attacker can manipulate the gIndex to point to unintended fields in the BeaconState, effectively forging invalid Merkle proofs. For example, by setting _validatorIndex > 2^40, the attacker can shift the path from the validators list to another field, bypassing validation checks.\n\nThe impact is the acceptance of invalid beacon chain state proofs, which could lead to incorrect reward distributions, false validator exits, or theft of user funds through fraudulent state transitions.\n",
            "severity": "High",
            "location": [
                "BeaconStateVerifier.sol::pathBeaconStateToValidator#125-129",
                "BeaconStateVerifier.sol::pathBlockToWithdrawal#147-153"
            ],
            "files": [
                "rocketpool/contracts/contract/util/BeaconStateVerifier.sol"
            ]
        }
    ],
    "affected_files": {
        "BeaconStateVerifier.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {SSZ} from \"./SSZ.sol\";\nimport {BlockRootsInterface} from \"../../interface/util/BlockRootsInterface.sol\";\nimport {BeaconStateVerifierInterface, ValidatorProof, Validator, WithdrawalProof, Withdrawal} from \"../../interface/util/BeaconStateVerifierInterface.sol\";\n\ncontract BeaconStateVerifier is RocketBase, BeaconStateVerifierInterface {\n    // Immutables\n    uint256 internal immutable slotsPerHistoricalRoot;\n    uint256 internal immutable historicalSummaryOffset;\n    uint64 internal immutable slotPhase0;\n    uint64 internal immutable slotAltair;\n    uint64 internal immutable slotBellatrix;\n    uint64 internal immutable slotCapella;\n    uint64 internal immutable slotDeneb;\n    uint64 internal immutable slotElectra;\n\n    // Enums\n    enum Fork {\n        PHASE_0,\n        ALTAIR,\n        BELLATRIX,\n        CAPELLA,\n        DENEB,\n        ELECTRA\n    }\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress, uint256 _slotsPerHistoricalRoot, uint64[5] memory _forkSlots) RocketBase(_rocketStorageAddress) {\n        version = 1;\n        slotsPerHistoricalRoot = _slotsPerHistoricalRoot;\n        // Set fork slots\n        slotPhase0 = 0;\n        slotAltair = _forkSlots[0];\n        slotBellatrix = _forkSlots[1];\n        slotCapella = _forkSlots[2];\n        slotDeneb = _forkSlots[3];\n        slotElectra = _forkSlots[4];\n        // Historical summaries started being appended from Capella onwards, depending on the chain we might need an offset\n        historicalSummaryOffset = slotCapella / slotsPerHistoricalRoot;\n    }\n\n    /// @notice Verifies a proof about a validator on the beacon chain\n    function verifyValidator(ValidatorProof calldata _proof) override external view returns(bool) {\n        // Only support post-electra state proofs\n        require(_proof.slot >= slotElectra, \"Invalid proof\");\n        // Construct gindex\n        SSZ.Path memory path = pathBeaconBlockHeaderToStateRoot();\n        path = SSZ.concat(path, pathBeaconStateToValidator(_proof.validatorIndex));\n        // Restore the block root for the supplied slot\n        bytes32 computedRoot = SSZ.restoreMerkleRoot(merkleiseValidator(_proof.validator), SSZ.toIndex(path), _proof.witnesses);\n        // Retrieve and compare the root with what we determined it should be from the given proof\n        bytes32 root = getBlockRoot(_proof.slot);\n        return computedRoot == root;\n    }\n\n    /// @notice Verifies a proof about the existence of a withdrawal on the beacon chain\n    function verifyWithdrawal(WithdrawalProof calldata _proof) override external view returns(bool) {\n        // Only support post-electra state proofs\n        require(_proof.slot >= slotElectra, \"Invalid proof\");\n        require(_proof.withdrawalSlot >= slotElectra, \"Invalid proof\");\n        // Construct gindex\n        SSZ.Path memory path = pathBeaconBlockHeaderToStateRoot();\n        path = SSZ.concat(path, pathBeaconStateToPastBlockRoot(_proof.slot, _proof.withdrawalSlot));\n        path = SSZ.concat(path, pathBlockToWithdrawal(_proof.withdrawalNum));\n        // Merkleise the withdrawal struct\n        bytes32 leaf = merkleiseWithdrawal(_proof.withdrawal);\n        // Restore the block root for the supplied slot\n        bytes32 computedRoot = SSZ.restoreMerkleRoot(leaf, SSZ.toIndex(path), _proof.witnesses);\n        // Retrieve and compare the root with what we determined it should be from the given proof\n        bytes32 root = getBlockRoot(_proof.slot);\n        return computedRoot == root;\n    }\n\n    /// @dev Gets the block root for a given slot\n    function getBlockRoot(uint64 _slot) internal view returns (bytes32) {\n        BlockRootsInterface blockRoots = BlockRootsInterface(getContractAddress(\"blockRoots\"));\n        return blockRoots.getBlockRoot(_slot);\n    }\n\n    /// @dev Returns whether the target slot is older than SLOTS_PER_HISTORICAL_ROOT indicating a proof must be for an older slot\n    function isHistoricalProof(uint64 proofSlot, uint64 targetSlot) internal view returns (bool) {\n        require(proofSlot >= targetSlot, \"Invalid slot for proof\");\n        return targetSlot + slotsPerHistoricalRoot < proofSlot;\n    }\n\n    /// @dev Returns the SSZ merkle root of a given withdrawal container\n    function merkleiseWithdrawal(Withdrawal calldata withdrawal) internal view returns (bytes32) {\n        bytes32 left = SSZ.efficientSha256(SSZ.toLittleEndian(withdrawal.index), SSZ.toLittleEndian(withdrawal.validatorIndex));\n        bytes32 right = SSZ.efficientSha256(withdrawal.withdrawalCredentials, SSZ.toLittleEndian(withdrawal.amountInGwei));\n        return SSZ.efficientSha256(left, right);\n    }\n\n    /// @dev Returns the SSZ merkle root of a given validator\n    function merkleiseValidator(Validator calldata validator) internal view returns (bytes32) {\n        bytes32 a = SSZ.efficientSha256(SSZ.merkleisePubkey(validator.pubkey), validator.withdrawalCredentials);\n        bytes32 b = SSZ.efficientSha256(SSZ.toLittleEndian(validator.effectiveBalance), SSZ.toLittleEndian(validator.slashed ? 1 : 0));\n        bytes32 c = SSZ.efficientSha256(SSZ.toLittleEndian(uint256(validator.activationEligibilityEpoch)), SSZ.toLittleEndian(uint256(validator.activationEpoch)));\n        bytes32 d = SSZ.efficientSha256(SSZ.toLittleEndian(uint256(validator.exitEpoch)), SSZ.toLittleEndian(uint256(validator.withdrawableEpoch)));\n        a = SSZ.efficientSha256(a, b);\n        b = SSZ.efficientSha256(c, d);\n        return SSZ.efficientSha256(a,b);\n    }\n\n    /// @dev Returns the fork at a given slot\n    function slotToFork(uint64 _slot) internal view returns (Fork) {\n        if (_slot >= slotElectra) return Fork.ELECTRA;\n        if (_slot >= slotDeneb) return Fork.DENEB;\n        if (_slot >= slotCapella) return Fork.CAPELLA;\n        if (_slot >= slotBellatrix) return Fork.BELLATRIX;\n        if (_slot >= slotAltair) return Fork.ALTAIR;\n        return Fork.PHASE_0;\n    }\n\n    /// @dev Returns a partial gindex from a BeaconBlockHeader -> state_root\n    function pathBeaconBlockHeaderToStateRoot() internal view returns (SSZ.Path memory) {\n        SSZ.Path memory path = SSZ.from(3, 3); // 0b011 (BeaconBlockHeader -> state_root)\n        return path;\n    }\n\n    /// @dev Returns a partial gindex from a BeaconState -> validators[n]\n    function pathBeaconStateToValidator(uint256 _validatorIndex) internal view returns (SSZ.Path memory) {\n        SSZ.Path memory path = SSZ.from(11, 6); // 0b001011 (BeaconState -> validators)\n        path = SSZ.concat(path, SSZ.intoVector(_validatorIndex, 40)); // validators -> validators[n]\n        return path;\n    }\n\n    /// @dev Returns a partial gindex from BeaconState -> block_roots[n] (via historical_summaries if required)\n    function pathBeaconStateToPastBlockRoot(uint64 _slot, uint64 _pastSlot) internal view returns (SSZ.Path memory) {\n        bool isHistorical = isHistoricalProof(_slot, _pastSlot);\n        SSZ.Path memory path;\n        if (isHistorical) {\n            path = SSZ.concat(path, SSZ.from(27, 6)); // 0b001011 (BeaconState -> historical_summaries)\n            path = SSZ.concat(path, SSZ.intoVector(uint256(_pastSlot) / slotsPerHistoricalRoot - historicalSummaryOffset, 24)); // historical_summaries -> historical_summaries[n]\n            path = SSZ.concat(path, SSZ.from(0, 1)); // 0b0 (HistoricalSummary -> block_summary_root)\n        } else {\n            path = SSZ.concat(path, SSZ.from(5, 6)); // 0b000101 (BeaconState -> block_roots)\n        }\n        path = SSZ.concat(path, SSZ.intoList(uint256(_pastSlot) % slotsPerHistoricalRoot, 13)); // block_roots -> block_roots[n]\n        return path;\n    }\n\n    /// @dev Returns a partial gindex from BeaconBlockHeader -> withdrwals[n]\n    function pathBlockToWithdrawal(uint256 _withdrawalNum) internal view returns (SSZ.Path memory) {\n        SSZ.Path memory path = SSZ.from(4, 3); // 0b100 (BeaconBlockHeader -> body_root)\n        path = SSZ.concat(path, SSZ.from(9, 4)); // 0b1001 (BeaconBlockBody -> execution_payload)\n        path = SSZ.concat(path, SSZ.from(14, 5)); // 0b01110 (ExecutionPayload -> withdrawals)\n        path = SSZ.concat(path, SSZ.intoList(_withdrawalNum, 5)); // withdrawals -> withdrawals[n]\n        return path;\n    }\n}\n"
    }
}