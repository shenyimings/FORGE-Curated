{
    "vfp_id": "vfp_00209",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "H1: Deposits denial of service",
            "description": "The migrateToPriorityQueue function in the CSModule contract allows permissionless migration of validator keys into a higher priority queue. The function increments the Community Staking Module (CSM) nonce even if the node operator has no keys to migrate or does not exist. This behavior is a vulnerability because the nonce is used by the Deposit Security Module (DSM) to validate deposit data signatures. An attacker can repeatedly call this function with invalid or non-existent node operator IDs, causing the nonce to increment and invalidate existing DSM signatures. This would prevent new validators from being deposited, resulting in a denial of service for the staking process. The root cause is the lack of validation on the existence and eligibility of the node operator before incrementing the nonce.\n",
            "severity": "High",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#589-614"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "H2: Incorrect enqueued keys accounting",
            "description": "The migrateToPriorityQueue function in CSModule.sol computes the number of keys to migrate and then subtracts that number from the enqueued count as a \"hack\" to ensure correct behavior in the subsequent _enqueueNodeOperatorKeys call. However, this subtraction is not reverted or compensated, and the legacy queue slots remain in place. As a result, the enqueued count becomes inconsistent with the actual number of queue slots, leading to a logic error. This discrepancy can cause an underflow in the QueueLib.clean function or prevent node operators from depositing new keys because the enqueued count appears higher than the depositable count. The root cause is the incorrect accounting due to an unbalanced decrement operation. An attacker can exploit this by calling the function for any node operator with queue slots, breaking the accounting system.\n",
            "severity": "High",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#603-609"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        }
    ],
    "affected_files": {
        "CSModule.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { AssetRecoverer } from \"./abstract/AssetRecoverer.sol\";\n\nimport { IStakingModule } from \"./interfaces/IStakingModule.sol\";\nimport { ILidoLocator } from \"./interfaces/ILidoLocator.sol\";\nimport { IStETH } from \"./interfaces/IStETH.sol\";\nimport { ICSParametersRegistry } from \"./interfaces/ICSParametersRegistry.sol\";\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSExitPenalties } from \"./interfaces/ICSExitPenalties.sol\";\nimport { ICSModule, NodeOperator, NodeOperatorManagementProperties, ValidatorWithdrawalInfo } from \"./interfaces/ICSModule.sol\";\nimport { ExitPenaltyInfo } from \"./interfaces/ICSExitPenalties.sol\";\n\nimport { PausableUntil } from \"./lib/utils/PausableUntil.sol\";\nimport { QueueLib, Batch } from \"./lib/QueueLib.sol\";\nimport { ValidatorCountsReport } from \"./lib/ValidatorCountsReport.sol\";\nimport { NOAddresses } from \"./lib/NOAddresses.sol\";\nimport { TransientUintUintMap, TransientUintUintMapLib } from \"./lib/TransientUintUintMapLib.sol\";\nimport { SigningKeys } from \"./lib/SigningKeys.sol\";\n\ncontract CSModule is\n    ICSModule,\n    Initializable,\n    AccessControlEnumerableUpgradeable,\n    PausableUntil,\n    AssetRecoverer\n{\n    using QueueLib for QueueLib.Queue;\n\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n    bytes32 public constant STAKING_ROUTER_ROLE =\n        keccak256(\"STAKING_ROUTER_ROLE\");\n    bytes32 public constant REPORT_EL_REWARDS_STEALING_PENALTY_ROLE =\n        keccak256(\"REPORT_EL_REWARDS_STEALING_PENALTY_ROLE\");\n    bytes32 public constant SETTLE_EL_REWARDS_STEALING_PENALTY_ROLE =\n        keccak256(\"SETTLE_EL_REWARDS_STEALING_PENALTY_ROLE\");\n    bytes32 public constant VERIFIER_ROLE = keccak256(\"VERIFIER_ROLE\");\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n    bytes32 public constant CREATE_NODE_OPERATOR_ROLE =\n        keccak256(\"CREATE_NODE_OPERATOR_ROLE\");\n\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n    // @dev see IStakingModule.sol\n    uint8 private constant FORCED_TARGET_LIMIT_MODE_ID = 2;\n    // keccak256(abi.encode(uint256(keccak256(\"OPERATORS_CREATED_IN_TX_MAP_TSLOT\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OPERATORS_CREATED_IN_TX_MAP_TSLOT =\n        0x1b07bc0838fdc4254cbabb5dd0c94d936f872c6758547168d513d8ad1dc3a500;\n\n    bytes32 private immutable MODULE_TYPE;\n    ILidoLocator public immutable LIDO_LOCATOR;\n    IStETH public immutable STETH;\n    ICSParametersRegistry public immutable PARAMETERS_REGISTRY;\n    ICSAccounting public immutable ACCOUNTING;\n    ICSExitPenalties public immutable EXIT_PENALTIES;\n    address public immutable FEE_DISTRIBUTOR;\n\n    /// @dev QUEUE_LOWEST_PRIORITY identifies the range of available priorities: [0; QUEUE_LOWEST_PRIORITY].\n    uint256 public immutable QUEUE_LOWEST_PRIORITY;\n    /// @dev QUEUE_LEGACY_PRIORITY is the priority for the CSM v1 queue.\n    uint256 public immutable QUEUE_LEGACY_PRIORITY;\n\n    ////////////////////////\n    // State variables below\n    ////////////////////////\n\n    /// @custom:oz-renamed-from keyRemovalCharge\n    /// @custom:oz-retyped-from uint256\n    mapping(uint256 queuePriority => QueueLib.Queue queue)\n        internal _queueByPriority;\n\n    /// @dev Legacy queue (priority=QUEUE_LEGACY_PRIORITY), that should be removed in the future once there are no more batches in it.\n    /// @custom:oz-renamed-from depositQueue\n    QueueLib.Queue internal _legacyQueue;\n\n    /// @dev Unused. Nullified in the finalizeUpgradeV2\n    /// @custom:oz-renamed-from accounting\n    ICSAccounting internal _accountingOld;\n\n    /// @dev Unused. Nullified in the finalizeUpgradeV2\n    /// @custom:oz-renamed-from earlyAdoption\n    address internal _earlyAdoption;\n    /// @dev deprecated. Nullified in the finalizeUpgradeV2\n    /// @custom:oz-renamed-from publicRelease\n    bool internal _publicRelease;\n\n    uint256 private _nonce;\n    mapping(uint256 => NodeOperator) private _nodeOperators;\n    /// @dev see _keyPointer function for details of noKeyIndexPacked structure\n    mapping(uint256 noKeyIndexPacked => bool) private _isValidatorWithdrawn;\n    /// @dev DEPRECATED! No writes expected after CSM v2\n    mapping(uint256 noKeyIndexPacked => bool) private _isValidatorSlashed;\n\n    uint64 private _totalDepositedValidators;\n    uint64 private _totalExitedValidators;\n    uint64 private _depositableValidatorsCount;\n    uint64 private _nodeOperatorsCount;\n\n    constructor(\n        bytes32 moduleType,\n        address lidoLocator,\n        address parametersRegistry,\n        address _accounting,\n        address exitPenalties\n    ) {\n        if (lidoLocator == address(0)) {\n            revert ZeroLocatorAddress();\n        }\n\n        if (parametersRegistry == address(0)) {\n            revert ZeroParametersRegistryAddress();\n        }\n\n        if (_accounting == address(0)) {\n            revert ZeroAccountingAddress();\n        }\n\n        if (exitPenalties == address(0)) {\n            revert ZeroExitPenaltiesAddress();\n        }\n\n        MODULE_TYPE = moduleType;\n        LIDO_LOCATOR = ILidoLocator(lidoLocator);\n        STETH = IStETH(LIDO_LOCATOR.lido());\n        PARAMETERS_REGISTRY = ICSParametersRegistry(parametersRegistry);\n        QUEUE_LOWEST_PRIORITY = PARAMETERS_REGISTRY.QUEUE_LOWEST_PRIORITY();\n        QUEUE_LEGACY_PRIORITY = PARAMETERS_REGISTRY.QUEUE_LEGACY_PRIORITY();\n        ACCOUNTING = ICSAccounting(_accounting);\n        EXIT_PENALTIES = ICSExitPenalties(exitPenalties);\n        FEE_DISTRIBUTOR = address(ACCOUNTING.feeDistributor());\n\n        _disableInitializers();\n    }\n\n    /// @notice initialize the module from scratch\n    function initialize(address admin) external reinitializer(2) {\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(STAKING_ROUTER_ROLE, address(LIDO_LOCATOR.stakingRouter()));\n\n        // CSM is on pause initially and should be resumed during the vote\n        _pauseFor(PausableUntil.PAUSE_INFINITELY);\n    }\n\n    /// @dev should be called after update on the proxy\n    function finalizeUpgradeV2() external reinitializer(2) {\n        assembly (\"memory-safe\") {\n            sstore(_queueByPriority.slot, 0x00)\n            sstore(_earlyAdoption.slot, 0x00)\n            sstore(_accountingOld.slot, 0x00)\n        }\n    }\n\n    /// @inheritdoc ICSModule\n    function resume() external onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /// @inheritdoc ICSModule\n    function pauseFor(uint256 duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(duration);\n    }\n\n    /// @inheritdoc ICSModule\n    function createNodeOperator(\n        address from,\n        NodeOperatorManagementProperties calldata managementProperties,\n        address referrer\n    )\n        external\n        onlyRole(CREATE_NODE_OPERATOR_ROLE)\n        whenResumed\n        returns (uint256 nodeOperatorId)\n    {\n        if (from == address(0)) {\n            revert ZeroSenderAddress();\n        }\n\n        nodeOperatorId = _nodeOperatorsCount;\n        _markOperatorIsCreatedInTX(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        address managerAddress = managementProperties.managerAddress ==\n            address(0)\n            ? from\n            : managementProperties.managerAddress;\n        address rewardAddress = managementProperties.rewardAddress == address(0)\n            ? from\n            : managementProperties.rewardAddress;\n        no.managerAddress = managerAddress;\n        no.rewardAddress = rewardAddress;\n        if (managementProperties.extendedManagerPermissions) {\n            no.extendedManagerPermissions = true;\n        }\n\n        unchecked {\n            ++_nodeOperatorsCount;\n        }\n\n        emit NodeOperatorAdded(\n            nodeOperatorId,\n            managerAddress,\n            rewardAddress,\n            managementProperties.extendedManagerPermissions\n        );\n\n        if (referrer != address(0)) {\n            emit ReferrerSet(nodeOperatorId, referrer);\n        }\n\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function addValidatorKeysETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures\n    ) external payable whenResumed {\n        _checkCanAddKeys(nodeOperatorId, from);\n\n        if (\n            msg.value <\n            accounting().getRequiredBondForNextKeys(nodeOperatorId, keysCount)\n        ) {\n            revert InvalidAmount();\n        }\n\n        if (msg.value != 0) {\n            accounting().depositETH{ value: msg.value }(from, nodeOperatorId);\n        }\n\n        _addKeysAndUpdateDepositableValidatorsCount(\n            nodeOperatorId,\n            keysCount,\n            publicKeys,\n            signatures\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function addValidatorKeysStETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        ICSAccounting.PermitInput calldata permit\n    ) external whenResumed {\n        _checkCanAddKeys(nodeOperatorId, from);\n\n        uint256 amount = accounting().getRequiredBondForNextKeys(\n            nodeOperatorId,\n            keysCount\n        );\n\n        if (amount != 0) {\n            accounting().depositStETH(from, nodeOperatorId, amount, permit);\n        }\n\n        _addKeysAndUpdateDepositableValidatorsCount(\n            nodeOperatorId,\n            keysCount,\n            publicKeys,\n            signatures\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function addValidatorKeysWstETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        ICSAccounting.PermitInput calldata permit\n    ) external whenResumed {\n        _checkCanAddKeys(nodeOperatorId, from);\n\n        uint256 amount = accounting().getRequiredBondForNextKeysWstETH(\n            nodeOperatorId,\n            keysCount\n        );\n\n        if (amount != 0) {\n            accounting().depositWstETH(from, nodeOperatorId, amount, permit);\n        }\n\n        _addKeysAndUpdateDepositableValidatorsCount(\n            nodeOperatorId,\n            keysCount,\n            publicKeys,\n            signatures\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function proposeNodeOperatorManagerAddressChange(\n        uint256 nodeOperatorId,\n        address proposedAddress\n    ) external {\n        NOAddresses.proposeNodeOperatorManagerAddressChange(\n            _nodeOperators,\n            nodeOperatorId,\n            proposedAddress\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function confirmNodeOperatorManagerAddressChange(\n        uint256 nodeOperatorId\n    ) external {\n        NOAddresses.confirmNodeOperatorManagerAddressChange(\n            _nodeOperators,\n            nodeOperatorId\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function proposeNodeOperatorRewardAddressChange(\n        uint256 nodeOperatorId,\n        address proposedAddress\n    ) external {\n        NOAddresses.proposeNodeOperatorRewardAddressChange(\n            _nodeOperators,\n            nodeOperatorId,\n            proposedAddress\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function confirmNodeOperatorRewardAddressChange(\n        uint256 nodeOperatorId\n    ) external {\n        NOAddresses.confirmNodeOperatorRewardAddressChange(\n            _nodeOperators,\n            nodeOperatorId\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function resetNodeOperatorManagerAddress(uint256 nodeOperatorId) external {\n        NOAddresses.resetNodeOperatorManagerAddress(\n            _nodeOperators,\n            nodeOperatorId\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function changeNodeOperatorRewardAddress(\n        uint256 nodeOperatorId,\n        address newAddress\n    ) external {\n        NOAddresses.changeNodeOperatorRewardAddress(\n            _nodeOperators,\n            nodeOperatorId,\n            newAddress\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @dev Passes through the minted stETH shares to the fee distributor\n    function onRewardsMinted(\n        uint256 totalShares\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        STETH.transferShares(FEE_DISTRIBUTOR, totalShares);\n    }\n\n    /// @inheritdoc IStakingModule\n    function updateExitedValidatorsCount(\n        bytes calldata nodeOperatorIds,\n        bytes calldata exitedValidatorsCounts\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        uint256 operatorsInReport = ValidatorCountsReport.safeCountOperators(\n            nodeOperatorIds,\n            exitedValidatorsCounts\n        );\n\n        for (uint256 i = 0; i < operatorsInReport; ++i) {\n            (\n                uint256 nodeOperatorId,\n                uint256 exitedValidatorsCount\n            ) = ValidatorCountsReport.next(\n                    nodeOperatorIds,\n                    exitedValidatorsCounts,\n                    i\n                );\n            _updateExitedValidatorsCount({\n                nodeOperatorId: nodeOperatorId,\n                exitedValidatorsCount: exitedValidatorsCount,\n                allowDecrease: false\n            });\n        }\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    function updateTargetValidatorsLimits(\n        uint256 nodeOperatorId,\n        uint256 targetLimitMode,\n        uint256 targetLimit\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        if (targetLimitMode > FORCED_TARGET_LIMIT_MODE_ID) {\n            revert InvalidInput();\n        }\n        if (targetLimit > type(uint32).max) {\n            revert InvalidInput();\n        }\n        _onlyExistingNodeOperator(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        if (targetLimitMode == 0) {\n            targetLimit = 0;\n        }\n\n        // NOTE: Bytecode saving trick; increased gas cost in rare cases is fine.\n        // if (\n        //     no.targetLimitMode == targetLimitMode &&\n        //     no.targetLimit == targetLimit\n        // ) {\n        //     return;\n        // }\n\n        // @dev No need to safe cast due to conditions above\n        no.targetLimitMode = uint8(targetLimitMode);\n        no.targetLimit = uint32(targetLimit);\n\n        emit TargetValidatorsCountChanged(\n            nodeOperatorId,\n            targetLimitMode,\n            targetLimit\n        );\n\n        // Nonce will be updated below even if depositable count was not changed\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: false\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @dev This method is not used in CSM, hence it is do nothing\n    /// @dev NOTE: No role checks because of empty body to save bytecode.\n    function onExitedAndStuckValidatorsCountsUpdated() external {\n        // solhint-disable-previous-line no-empty-blocks\n        // Nothing to do, rewards are distributed by a performance oracle.\n    }\n\n    /// @inheritdoc IStakingModule\n    function unsafeUpdateValidatorsCount(\n        uint256 nodeOperatorId,\n        uint256 exitedValidatorsKeysCount\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        _updateExitedValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            exitedValidatorsCount: exitedValidatorsKeysCount,\n            allowDecrease: true\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    function decreaseVettedSigningKeysCount(\n        bytes calldata nodeOperatorIds,\n        bytes calldata vettedSigningKeysCounts\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        uint256 operatorsInReport = ValidatorCountsReport.safeCountOperators(\n            nodeOperatorIds,\n            vettedSigningKeysCounts\n        );\n\n        for (uint256 i = 0; i < operatorsInReport; ++i) {\n            (\n                uint256 nodeOperatorId,\n                uint256 vettedSigningKeysCount\n            ) = ValidatorCountsReport.next(\n                    nodeOperatorIds,\n                    vettedSigningKeysCounts,\n                    i\n                );\n\n            _onlyExistingNodeOperator(nodeOperatorId);\n\n            NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n            if (vettedSigningKeysCount >= no.totalVettedKeys) {\n                revert InvalidVetKeysPointer();\n            }\n\n            if (vettedSigningKeysCount < no.totalDepositedKeys) {\n                revert InvalidVetKeysPointer();\n            }\n\n            // @dev No need to safe cast due to conditions above\n            no.totalVettedKeys = uint32(vettedSigningKeysCount);\n            emit VettedSigningKeysCountChanged(\n                nodeOperatorId,\n                vettedSigningKeysCount\n            );\n\n            // @dev separate event for intentional decrease from Staking Router\n            emit VettedSigningKeysCountDecreased(nodeOperatorId);\n\n            // Nonce will be updated below once\n            _updateDepositableValidatorsCount({\n                nodeOperatorId: nodeOperatorId,\n                incrementNonceIfUpdated: false\n            });\n        }\n\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function removeKeys(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) external {\n        _onlyNodeOperatorManager(nodeOperatorId, msg.sender);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        if (startIndex < no.totalDepositedKeys) {\n            revert SigningKeysInvalidOffset();\n        }\n\n        // solhint-disable-next-line func-named-parameters\n        uint256 newTotalSigningKeys = SigningKeys.removeKeysSigs(\n            nodeOperatorId,\n            startIndex,\n            keysCount,\n            no.totalAddedKeys\n        );\n\n        // The Node Operator is charged for the every removed key. It's motivated by the fact that the DAO should cleanup\n        // the queue from the empty batches related to the Node Operator. It's possible to have multiple batches with only one\n        // key in it, so it means the DAO should be able to cover removal costs for as much batches as keys removed in this case.\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        uint256 amountToCharge = PARAMETERS_REGISTRY.getKeyRemovalCharge(\n            curveId\n        ) * keysCount;\n        if (amountToCharge != 0) {\n            accounting().chargeFee(nodeOperatorId, amountToCharge);\n            emit KeyRemovalChargeApplied(nodeOperatorId);\n        }\n\n        // @dev No need to safe cast due to checks in the func above\n        no.totalAddedKeys = uint32(newTotalSigningKeys);\n        emit TotalSigningKeysCountChanged(nodeOperatorId, newTotalSigningKeys);\n\n        // @dev No need to safe cast due to checks in the func above\n        no.totalVettedKeys = uint32(newTotalSigningKeys);\n        emit VettedSigningKeysCountChanged(nodeOperatorId, newTotalSigningKeys);\n\n        // Nonce is updated below due to keys state change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: false\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function updateDepositableValidatorsCount(uint256 nodeOperatorId) external {\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @dev TODO: Remove the method in the next major release.\n    /// @inheritdoc ICSModule\n    function migrateToPriorityQueue(uint256 nodeOperatorId) external {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        if (no.usedPriorityQueue) {\n            revert PriorityQueueAlreadyUsed();\n        }\n\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        (uint32 priority, uint32 maxDeposits) = PARAMETERS_REGISTRY\n            .getQueueConfig(curveId);\n\n        if (priority < QUEUE_LEGACY_PRIORITY) {\n            uint32 deposited = no.totalDepositedKeys;\n\n            if (maxDeposits > deposited) {\n                uint32 toMigrate = uint32(\n                    Math.min(maxDeposits - deposited, no.enqueuedCount)\n                );\n\n                unchecked {\n                    no.enqueuedCount -= toMigrate;\n                }\n                _enqueueNodeOperatorKeys(nodeOperatorId, priority, toMigrate);\n            }\n\n            no.usedPriorityQueue = true;\n        }\n        _incrementModuleNonce();\n\n        // An alternative version to fit into the bytecode requirements is below. Please consider\n        // the described caveat of the approach.\n\n        // NOTE: We allow a node operator (NO) to reset their enqueued counter to zero only once to\n        // migrate their keys from the legacy queue to a priority queue, if any. As a downside, the\n        // node operator effectively can have their seats doubled in the queue.\n        // Let's say we have a priority queue with a maximum of 10 deposits. Imagine a NO has 20\n        // keys queued in the legacy queue. Then, the NO calls this method and gets their enqueued\n        // counter reset to zero. As a result, the module will place 10 keys into the priority queue\n        // and 10 more keys at the end of the overall queue. The original batches are kept in the\n        // queue, so in total, the NO will have batches with 40 keys queued altogether.\n        // _nodeOperators[nodeOperatorId].enqueuedCount = 0;\n        // _enqueueNodeOperatorKeys(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSModule\n    function reportELRewardsStealingPenalty(\n        uint256 nodeOperatorId,\n        bytes32 blockHash,\n        uint256 amount\n    ) external onlyRole(REPORT_EL_REWARDS_STEALING_PENALTY_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        if (amount == 0) {\n            revert InvalidAmount();\n        }\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        uint256 additionalFine = PARAMETERS_REGISTRY\n            .getElRewardsStealingAdditionalFine(curveId);\n        accounting().lockBondETH(nodeOperatorId, amount + additionalFine);\n\n        emit ELRewardsStealingPenaltyReported(\n            nodeOperatorId,\n            blockHash,\n            amount\n        );\n\n        // Nonce should be updated if depositableValidators change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @inheritdoc ICSModule\n    function cancelELRewardsStealingPenalty(\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) external onlyRole(REPORT_EL_REWARDS_STEALING_PENALTY_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        accounting().releaseLockedBondETH(nodeOperatorId, amount);\n\n        emit ELRewardsStealingPenaltyCancelled(nodeOperatorId, amount);\n\n        // Nonce should be updated if depositableValidators change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @inheritdoc ICSModule\n    function settleELRewardsStealingPenalty(\n        uint256[] calldata nodeOperatorIds\n    ) external onlyRole(SETTLE_EL_REWARDS_STEALING_PENALTY_ROLE) {\n        for (uint256 i; i < nodeOperatorIds.length; ++i) {\n            uint256 nodeOperatorId = nodeOperatorIds[i];\n            _onlyExistingNodeOperator(nodeOperatorId);\n\n            // Settled amount might be zero either if the lock expired, or the bond is zero so we\n            // need to check if the penalty was applied.\n            bool applied = accounting().settleLockedBondETH(nodeOperatorId);\n            if (applied) {\n                emit ELRewardsStealingPenaltySettled(nodeOperatorId);\n\n                // Nonce should be updated if depositableValidators change\n                _updateDepositableValidatorsCount({\n                    nodeOperatorId: nodeOperatorId,\n                    incrementNonceIfUpdated: true\n                });\n            }\n        }\n    }\n\n    /// @inheritdoc ICSModule\n    function compensateELRewardsStealingPenalty(\n        uint256 nodeOperatorId\n    ) external payable {\n        _onlyNodeOperatorManager(nodeOperatorId, msg.sender);\n        accounting().compensateLockedBondETH{ value: msg.value }(\n            nodeOperatorId\n        );\n\n        emit ELRewardsStealingPenaltyCompensated(nodeOperatorId, msg.value);\n\n        // Nonce should be updated if depositableValidators change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @inheritdoc ICSModule\n    function submitWithdrawals(\n        ValidatorWithdrawalInfo[] calldata withdrawalsInfo\n    ) external onlyRole(VERIFIER_ROLE) {\n        for (uint256 i; i < withdrawalsInfo.length; ++i) {\n            ValidatorWithdrawalInfo memory withdrawalInfo = withdrawalsInfo[i];\n\n            _onlyExistingNodeOperator(withdrawalInfo.nodeOperatorId);\n            NodeOperator storage no = _nodeOperators[\n                withdrawalInfo.nodeOperatorId\n            ];\n\n            if (withdrawalInfo.keyIndex >= no.totalDepositedKeys) {\n                revert SigningKeysInvalidOffset();\n            }\n\n            uint256 pointer = _keyPointer(\n                withdrawalInfo.nodeOperatorId,\n                withdrawalInfo.keyIndex\n            );\n            if (_isValidatorWithdrawn[pointer]) {\n                revert AlreadyWithdrawn();\n            }\n\n            _isValidatorWithdrawn[pointer] = true;\n            unchecked {\n                ++no.totalWithdrawnKeys;\n            }\n\n            bytes memory pubkey = SigningKeys.loadKeys(\n                withdrawalInfo.nodeOperatorId,\n                withdrawalInfo.keyIndex,\n                1\n            );\n\n            emit WithdrawalSubmitted(\n                withdrawalInfo.nodeOperatorId,\n                withdrawalInfo.keyIndex,\n                withdrawalInfo.amount,\n                pubkey\n            );\n\n            // It is safe to use unchecked for penalty sum, due to it's limited to uint248 in the\n            // structure.\n            uint256 penaltySum;\n            bool chargeWithdrawalRequestFee;\n\n            ExitPenaltyInfo memory exitPenaltyInfo = EXIT_PENALTIES\n                .getExitPenaltyInfo(withdrawalInfo.nodeOperatorId, pubkey);\n            if (exitPenaltyInfo.delayPenalty.isValue) {\n                unchecked {\n                    penaltySum += exitPenaltyInfo.delayPenalty.value;\n                }\n                chargeWithdrawalRequestFee = true;\n            }\n            if (exitPenaltyInfo.strikesPenalty.isValue) {\n                unchecked {\n                    penaltySum += exitPenaltyInfo.strikesPenalty.value;\n                }\n                chargeWithdrawalRequestFee = true;\n            }\n            // The withdrawal request fee is taken only if the penalty is applied if no penalty, the\n            // fee has been paid by the node operator on the withdrawal trigger, or it is the DAO\n            // decision to withdraw the validator before that the withdrawal request becomes\n            // delayed.\n            if (\n                chargeWithdrawalRequestFee &&\n                exitPenaltyInfo.withdrawalRequestFee.value != 0\n            ) {\n                accounting().chargeFee(\n                    withdrawalInfo.nodeOperatorId,\n                    exitPenaltyInfo.withdrawalRequestFee.value\n                );\n            }\n\n            if (DEPOSIT_SIZE > withdrawalInfo.amount) {\n                unchecked {\n                    penaltySum += DEPOSIT_SIZE - withdrawalInfo.amount;\n                }\n            }\n            if (penaltySum > 0) {\n                accounting().penalize(\n                    withdrawalInfo.nodeOperatorId,\n                    penaltySum\n                );\n            }\n\n            // Nonce will be updated below even if depositable count was not changed\n            _updateDepositableValidatorsCount({\n                nodeOperatorId: withdrawalInfo.nodeOperatorId,\n                incrementNonceIfUpdated: false\n            });\n        }\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @dev Changing the WC means that the current deposit data in the queue is not valid anymore and can't be deposited.\n    ///      DSM will unvet current keys.\n    ///      The key removal charge should be reset to 0 to allow Node Operators to remove the keys without any charge.\n    ///      After keys removal the DAO should set the new key removal charge.\n    function onWithdrawalCredentialsChanged()\n        external\n        onlyRole(STAKING_ROUTER_ROLE)\n    {\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    function reportValidatorExitDelay(\n        uint256 nodeOperatorId,\n        uint256 /* proofSlotTimestamp */,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        EXIT_PENALTIES.processExitDelayReport(\n            nodeOperatorId,\n            publicKey,\n            eligibleToExitInSec\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    function onValidatorExitTriggered(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 withdrawalRequestPaidFee,\n        uint256 exitType\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        EXIT_PENALTIES.processTriggeredExit(\n            nodeOperatorId,\n            publicKey,\n            withdrawalRequestPaidFee,\n            exitType\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @notice Get the next `depositsCount` of depositable keys with signatures from the queue\n    /// @dev Second param `depositCalldata` is not used\n    function obtainDepositData(\n        uint256 depositsCount,\n        bytes calldata /* depositCalldata */\n    )\n        external\n        onlyRole(STAKING_ROUTER_ROLE)\n        returns (bytes memory publicKeys, bytes memory signatures)\n    {\n        (publicKeys, signatures) = SigningKeys.initKeysSigsBuf(depositsCount);\n        if (depositsCount == 0) {\n            return (publicKeys, signatures);\n        }\n\n        uint256 depositsLeft = depositsCount;\n        uint256 loadedKeysCount = 0;\n\n        QueueLib.Queue storage queue;\n        // Note: The highest priority to start iterations with. Priorities are ordered like 0, 1, 2, ...\n        uint256 priority = 0;\n\n        while (true) {\n            if (priority > QUEUE_LOWEST_PRIORITY || depositsLeft == 0) {\n                break;\n            }\n\n            queue = _getQueue(priority);\n            unchecked {\n                // Note: unused below\n                ++priority;\n            }\n\n            for (\n                Batch item = queue.peek();\n                !item.isNil();\n                item = queue.peek()\n            ) {\n                // NOTE: see the `enqueuedCount` note below.\n                unchecked {\n                    uint256 noId = item.noId();\n                    uint256 keysInBatch = item.keys();\n                    NodeOperator storage no = _nodeOperators[noId];\n\n                    uint256 keysCount = Math.min(\n                        Math.min(no.depositableValidatorsCount, keysInBatch),\n                        depositsLeft\n                    );\n                    // `depositsLeft` is non-zero at this point all the time, so the check `depositsLeft > keysCount`\n                    // covers the case when no depositable keys on the Node Operator have been left.\n                    if (depositsLeft > keysCount || keysCount == keysInBatch) {\n                        // NOTE: `enqueuedCount` >= keysInBatch invariant should be checked.\n                        // @dev No need to safe cast due to internal logic\n                        no.enqueuedCount -= uint32(keysInBatch);\n                        // We've consumed all the keys in the batch, so we dequeue it.\n                        queue.dequeue();\n                    } else {\n                        // This branch covers the case when we stop in the middle of the batch.\n                        // We release the amount of keys consumed only, the rest will be kept.\n                        // @dev No need to safe cast due to internal logic\n                        no.enqueuedCount -= uint32(keysCount);\n                        // NOTE: `keysInBatch` can't be less than `keysCount` at this point.\n                        // We update the batch with the remaining keys.\n                        item = item.setKeys(keysInBatch - keysCount);\n                        // Store the updated batch back to the queue.\n                        queue.queue[queue.head] = item;\n                    }\n\n                    // Note: This condition is located here to allow for the correct removal of the batch for the Node Operators with no depositable keys\n                    if (keysCount == 0) {\n                        continue;\n                    }\n\n                    // solhint-disable-next-line func-named-parameters\n                    SigningKeys.loadKeysSigs(\n                        noId,\n                        no.totalDepositedKeys,\n                        keysCount,\n                        publicKeys,\n                        signatures,\n                        loadedKeysCount\n                    );\n\n                    // It's impossible in practice to reach the limit of these variables.\n                    loadedKeysCount += keysCount;\n                    // @dev No need to safe cast due to internal logic\n                    uint32 totalDepositedKeys = no.totalDepositedKeys +\n                        uint32(keysCount);\n                    no.totalDepositedKeys = totalDepositedKeys;\n\n                    emit DepositedSigningKeysCountChanged(\n                        noId,\n                        totalDepositedKeys\n                    );\n\n                    // No need for `_updateDepositableValidatorsCount` call since we update the number directly.\n                    // `keysCount` is min of `depositableValidatorsCount` and `depositsLeft`.\n                    // @dev No need to safe cast due to internal logic\n                    uint32 newCount = no.depositableValidatorsCount -\n                        uint32(keysCount);\n                    no.depositableValidatorsCount = newCount;\n                    emit DepositableSigningKeysCountChanged(noId, newCount);\n\n                    depositsLeft -= keysCount;\n                    if (depositsLeft == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (loadedKeysCount != depositsCount) {\n            revert NotEnoughKeys();\n        }\n\n        unchecked {\n            // @dev depositsCount can not overflow in practice due to memory and gas limits\n            _depositableValidatorsCount -= uint64(depositsCount);\n            _totalDepositedValidators += uint64(depositsCount);\n        }\n\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function cleanDepositQueue(\n        uint256 maxItems\n    ) external returns (uint256 removed, uint256 lastRemovedAtDepth) {\n        removed = 0;\n        lastRemovedAtDepth = 0;\n\n        if (maxItems == 0) {\n            return (0, 0);\n        }\n\n        // NOTE: We need one unique hash map per function invocation to be able to track batches of\n        // the same operator across multiple queues.\n        TransientUintUintMap queueLookup = TransientUintUintMapLib.create();\n\n        QueueLib.Queue storage queue;\n\n        uint256 totalVisited = 0;\n        // Note: The highest priority to start iterations with. Priorities are ordered like 0, 1, 2, ...\n        uint256 priority = 0;\n\n        while (true) {\n            if (priority > QUEUE_LOWEST_PRIORITY) {\n                break;\n            }\n\n            queue = _getQueue(priority);\n            unchecked {\n                ++priority;\n            }\n\n            (\n                uint256 removedPerQueue,\n                uint256 lastRemovedAtDepthPerQueue,\n                uint256 visitedPerQueue,\n                bool reachedOutOfQueue\n            ) = queue.clean(_nodeOperators, maxItems, queueLookup);\n\n            if (removedPerQueue > 0) {\n                unchecked {\n                    // 1234 56 789A     <- cumulative depth (A=10)\n                    // 1234 12 1234     <- depth per queue\n                    // **R*|**|**R*     <- queue with [R]emoved elements\n                    //\n                    // Given that we observed all 3 queues:\n                    // totalVisited: 4+2=6\n                    // lastRemovedAtDepthPerQueue: 3\n                    // lastRemovedAtDepth: 6+3=9\n\n                    lastRemovedAtDepth =\n                        totalVisited +\n                        lastRemovedAtDepthPerQueue;\n                    removed += removedPerQueue;\n                }\n            }\n\n            // NOTE: If `maxItems` is set to the total length of the queue(s), `reachedOutOfQueue` is equal\n            // to `false`, effectively breaking the cycle, because in `QueueLib.clean` we don't reach\n            // an empty batch after the end of a queue.\n            if (!reachedOutOfQueue) {\n                break;\n            }\n\n            unchecked {\n                totalVisited += visitedPerQueue;\n                maxItems -= visitedPerQueue;\n            }\n        }\n    }\n\n    /// @inheritdoc ICSModule\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /// @inheritdoc ICSModule\n    function depositQueuePointers(\n        uint256 queuePriority\n    ) external view returns (uint128 head, uint128 tail) {\n        QueueLib.Queue storage q = _getQueue(queuePriority);\n        return (q.head, q.tail);\n    }\n\n    /// @inheritdoc ICSModule\n    function depositQueueItem(\n        uint256 queuePriority,\n        uint128 index\n    ) external view returns (Batch) {\n        return _getQueue(queuePriority).at(index);\n    }\n\n    /// @inheritdoc ICSModule\n    function isValidatorWithdrawn(\n        uint256 nodeOperatorId,\n        uint256 keyIndex\n    ) external view returns (bool) {\n        return _isValidatorWithdrawn[_keyPointer(nodeOperatorId, keyIndex)];\n    }\n\n    /// @inheritdoc IStakingModule\n    function getType() external view returns (bytes32) {\n        return MODULE_TYPE;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getStakingModuleSummary()\n        external\n        view\n        returns (\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n        )\n    {\n        totalExitedValidators = _totalExitedValidators;\n        totalDepositedValidators = _totalDepositedValidators;\n        depositableValidatorsCount = _depositableValidatorsCount;\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperator(\n        uint256 nodeOperatorId\n    ) external view returns (NodeOperator memory) {\n        return _nodeOperators[nodeOperatorId];\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorManagementProperties(\n        uint256 nodeOperatorId\n    ) external view returns (NodeOperatorManagementProperties memory) {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        return (\n            NodeOperatorManagementProperties(\n                no.managerAddress,\n                no.rewardAddress,\n                no.extendedManagerPermissions\n            )\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorOwner(\n        uint256 nodeOperatorId\n    ) external view returns (address) {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        return\n            no.extendedManagerPermissions\n                ? no.managerAddress\n                : no.rewardAddress;\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorNonWithdrawnKeys(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        unchecked {\n            return no.totalAddedKeys - no.totalWithdrawnKeys;\n        }\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @notice depositableValidatorsCount depends on:\n    ///      - totalVettedKeys\n    ///      - totalDepositedKeys\n    ///      - totalExitedKeys\n    ///      - targetLimitMode\n    ///      - targetValidatorsCount\n    ///      - totalUnbondedKeys\n    function getNodeOperatorSummary(\n        uint256 nodeOperatorId\n    )\n        external\n        view\n        returns (\n            uint256 targetLimitMode,\n            uint256 targetValidatorsCount,\n            uint256 stuckValidatorsCount,\n            uint256 refundedValidatorsCount,\n            uint256 stuckPenaltyEndTimestamp,\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n        )\n    {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint256 totalUnbondedKeys = accounting().getUnbondedKeysCountToEject(\n            nodeOperatorId\n        );\n        uint256 totalNonDepositedKeys = no.totalAddedKeys -\n            no.totalDepositedKeys;\n        // Force mode enabled and unbonded deposited keys\n        if (\n            totalUnbondedKeys > totalNonDepositedKeys &&\n            no.targetLimitMode == FORCED_TARGET_LIMIT_MODE_ID\n        ) {\n            targetLimitMode = FORCED_TARGET_LIMIT_MODE_ID;\n            unchecked {\n                targetValidatorsCount = Math.min(\n                    no.targetLimit,\n                    no.totalAddedKeys -\n                        no.totalWithdrawnKeys -\n                        totalUnbondedKeys\n                );\n            }\n            // No force mode enabled but unbonded deposited keys\n        } else if (totalUnbondedKeys > totalNonDepositedKeys) {\n            targetLimitMode = FORCED_TARGET_LIMIT_MODE_ID;\n            unchecked {\n                targetValidatorsCount =\n                    no.totalAddedKeys -\n                    no.totalWithdrawnKeys -\n                    totalUnbondedKeys;\n            }\n        } else {\n            targetLimitMode = no.targetLimitMode;\n            targetValidatorsCount = no.targetLimit;\n        }\n        stuckValidatorsCount = 0;\n        refundedValidatorsCount = 0;\n        stuckPenaltyEndTimestamp = 0;\n        totalExitedValidators = no.totalExitedKeys;\n        totalDepositedValidators = no.totalDepositedKeys;\n        depositableValidatorsCount = no.depositableValidatorsCount;\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorTotalDepositedKeys(\n        uint256 nodeOperatorId\n    ) external view returns (uint256 totalDepositedKeys) {\n        totalDepositedKeys = _nodeOperators[nodeOperatorId].totalDepositedKeys;\n    }\n\n    /// @inheritdoc ICSModule\n    function getSigningKeys(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) external view returns (bytes memory) {\n        _onlyValidIndexRange(nodeOperatorId, startIndex, keysCount);\n\n        return SigningKeys.loadKeys(nodeOperatorId, startIndex, keysCount);\n    }\n\n    /// @inheritdoc ICSModule\n    function getSigningKeysWithSignatures(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) external view returns (bytes memory keys, bytes memory signatures) {\n        _onlyValidIndexRange(nodeOperatorId, startIndex, keysCount);\n\n        (keys, signatures) = SigningKeys.initKeysSigsBuf(keysCount);\n        // solhint-disable-next-line func-named-parameters\n        SigningKeys.loadKeysSigs(\n            nodeOperatorId,\n            startIndex,\n            keysCount,\n            keys,\n            signatures,\n            0\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNonce() external view returns (uint256) {\n        return _nonce;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNodeOperatorsCount() external view returns (uint256) {\n        return _nodeOperatorsCount;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getActiveNodeOperatorsCount() external view returns (uint256) {\n        return _nodeOperatorsCount;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNodeOperatorIsActive(\n        uint256 nodeOperatorId\n    ) external view returns (bool) {\n        return nodeOperatorId < _nodeOperatorsCount;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNodeOperatorIds(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory nodeOperatorIds) {\n        uint256 nodeOperatorsCount = _nodeOperatorsCount;\n        if (offset >= nodeOperatorsCount || limit == 0) {\n            return new uint256[](0);\n        }\n\n        uint256 idsCount = limit < nodeOperatorsCount - offset\n            ? limit\n            : nodeOperatorsCount - offset;\n        nodeOperatorIds = new uint256[](idsCount);\n        for (uint256 i = 0; i < nodeOperatorIds.length; ++i) {\n            nodeOperatorIds[i] = offset + i;\n        }\n    }\n\n    /// @inheritdoc IStakingModule\n    function isValidatorExitDelayPenaltyApplicable(\n        uint256 nodeOperatorId,\n        uint256 /* proofSlotTimestamp */,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external view returns (bool) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        return\n            EXIT_PENALTIES.isValidatorExitDelayPenaltyApplicable(\n                nodeOperatorId,\n                publicKey,\n                eligibleToExitInSec\n            );\n    }\n\n    /// @inheritdoc IStakingModule\n    function exitDeadlineThreshold(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        return\n            PARAMETERS_REGISTRY.getAllowedExitDelay(\n                accounting().getBondCurveId(nodeOperatorId)\n            );\n    }\n\n    /// @dev This function is used to get the accounting contract from immutables to save bytecode and for backwards compatibility\n    function accounting() public view returns (ICSAccounting) {\n        return ACCOUNTING;\n    }\n\n    function _incrementModuleNonce() internal {\n        unchecked {\n            emit NonceChanged(++_nonce);\n        }\n    }\n\n    function _addKeysAndUpdateDepositableValidatorsCount(\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures\n    ) internal {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint256 totalAddedKeys = no.totalAddedKeys;\n\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        uint256 keysLimit = PARAMETERS_REGISTRY.getKeysLimit(curveId);\n\n        unchecked {\n            if (\n                totalAddedKeys + keysCount - no.totalWithdrawnKeys > keysLimit\n            ) {\n                revert KeysLimitExceeded();\n            }\n\n            // solhint-disable-next-line func-named-parameters\n            uint256 newTotalAddedKeys = SigningKeys.saveKeysSigs(\n                nodeOperatorId,\n                totalAddedKeys,\n                keysCount,\n                publicKeys,\n                signatures\n            );\n            // Optimistic vetting takes place.\n            if (totalAddedKeys == no.totalVettedKeys) {\n                // @dev No need to safe cast due to internal logic\n                uint32 totalVettedKeys = no.totalVettedKeys + uint32(keysCount);\n                no.totalVettedKeys = totalVettedKeys;\n                emit VettedSigningKeysCountChanged(\n                    nodeOperatorId,\n                    totalVettedKeys\n                );\n            }\n\n            // @dev No need to safe cast due to internal logic\n            no.totalAddedKeys = uint32(newTotalAddedKeys);\n\n            emit TotalSigningKeysCountChanged(\n                nodeOperatorId,\n                newTotalAddedKeys\n            );\n        }\n\n        // Nonce is updated below since in case of target limit depositable keys might not change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: false\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @dev Update exited validators count for a single Node Operator\n    /// @dev Allows decrease the count for unsafe updates\n    function _updateExitedValidatorsCount(\n        uint256 nodeOperatorId,\n        uint256 exitedValidatorsCount,\n        bool allowDecrease\n    ) internal {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint32 totalExitedKeys = no.totalExitedKeys;\n        if (exitedValidatorsCount == totalExitedKeys) {\n            return;\n        }\n        if (exitedValidatorsCount > no.totalDepositedKeys) {\n            revert ExitedKeysHigherThanTotalDeposited();\n        }\n        if (!allowDecrease && exitedValidatorsCount < totalExitedKeys) {\n            revert ExitedKeysDecrease();\n        }\n\n        unchecked {\n            // @dev Invariat sum(no.totalExitedKeys for no in nos) == _totalExitedValidators.\n            _totalExitedValidators =\n                (_totalExitedValidators - totalExitedKeys) +\n                uint64(exitedValidatorsCount);\n        }\n        // @dev No need to safe cast due to conditions above\n        no.totalExitedKeys = uint32(exitedValidatorsCount);\n\n        emit ExitedSigningKeysCountChanged(\n            nodeOperatorId,\n            exitedValidatorsCount\n        );\n    }\n\n    function _updateDepositableValidatorsCount(\n        uint256 nodeOperatorId,\n        bool incrementNonceIfUpdated\n    ) internal {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        uint32 totalDepositedKeys = no.totalDepositedKeys;\n        uint256 newCount = no.totalVettedKeys - totalDepositedKeys;\n        uint256 unbondedKeys = accounting().getUnbondedKeysCount(\n            nodeOperatorId\n        );\n\n        {\n            uint256 nonDeposited = no.totalAddedKeys - totalDepositedKeys;\n            if (unbondedKeys >= nonDeposited) {\n                newCount = 0;\n            } else if (unbondedKeys > no.totalAddedKeys - no.totalVettedKeys) {\n                newCount = nonDeposited - unbondedKeys;\n            }\n        }\n\n        if (no.targetLimitMode > 0 && newCount > 0) {\n            unchecked {\n                uint256 nonWithdrawnValidators = totalDepositedKeys -\n                    no.totalWithdrawnKeys;\n                newCount = Math.min(\n                    no.targetLimit > nonWithdrawnValidators\n                        ? no.targetLimit - nonWithdrawnValidators\n                        : 0,\n                    newCount\n                );\n            }\n        }\n\n        if (no.depositableValidatorsCount != newCount) {\n            // Updating the global counter.\n            // @dev No need to safe cast due to internal logic\n            unchecked {\n                _depositableValidatorsCount =\n                    _depositableValidatorsCount -\n                    no.depositableValidatorsCount +\n                    uint64(newCount);\n            }\n            // @dev No need to safe cast due to internal logic\n            no.depositableValidatorsCount = uint32(newCount);\n            emit DepositableSigningKeysCountChanged(nodeOperatorId, newCount);\n            if (incrementNonceIfUpdated) {\n                _incrementModuleNonce();\n            }\n            _enqueueNodeOperatorKeys(nodeOperatorId);\n        }\n    }\n\n    function _enqueueNodeOperatorKeys(uint256 nodeOperatorId) internal {\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        (uint32 priority, uint32 maxDeposits) = PARAMETERS_REGISTRY\n            .getQueueConfig(curveId);\n        // TODO Replace QUEUE_LEGACY_PRIORITY with QUEUE_LOWEST_PRIORITY after legacy queue removal in CSM v3\n        if (priority < QUEUE_LEGACY_PRIORITY) {\n            unchecked {\n                NodeOperator storage no = _nodeOperators[nodeOperatorId];\n                uint32 enqueuedSoFar = no.totalDepositedKeys + no.enqueuedCount;\n\n                if (maxDeposits > enqueuedSoFar) {\n                    uint32 leftForQueue = maxDeposits - enqueuedSoFar;\n                    _enqueueNodeOperatorKeys(\n                        nodeOperatorId,\n                        priority,\n                        leftForQueue\n                    );\n                    if (!no.usedPriorityQueue) {\n                        no.usedPriorityQueue = true;\n                    }\n                }\n            }\n        }\n\n        _enqueueNodeOperatorKeys(\n            nodeOperatorId,\n            QUEUE_LOWEST_PRIORITY,\n            type(uint32).max\n        );\n    }\n\n    // TODO refactor this method after removing migrateToPriorityQueue\n    function _enqueueNodeOperatorKeys(\n        uint256 nodeOperatorId,\n        uint256 queuePriority,\n        uint32 maxKeys\n    ) internal {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint32 depositable = no.depositableValidatorsCount;\n        uint32 enqueued = no.enqueuedCount;\n\n        if (enqueued < depositable) {\n            unchecked {\n                uint32 count = depositable - enqueued;\n                count = uint32(Math.min(count, maxKeys));\n\n                no.enqueuedCount = enqueued + count;\n\n                QueueLib.Queue storage q = _getQueue(queuePriority);\n                q.enqueue(nodeOperatorId, count);\n                emit BatchEnqueued(queuePriority, nodeOperatorId, count);\n            }\n        }\n    }\n\n    function _markOperatorIsCreatedInTX(uint256 nodeOperatorId) internal {\n        TransientUintUintMap map = TransientUintUintMapLib.load(\n            OPERATORS_CREATED_IN_TX_MAP_TSLOT\n        );\n        map.set(nodeOperatorId, 1);\n    }\n\n    function _isOperatorCreatedInTX(\n        uint256 nodeOperatorId\n    ) internal view returns (bool) {\n        TransientUintUintMap map = TransientUintUintMapLib.load(\n            OPERATORS_CREATED_IN_TX_MAP_TSLOT\n        );\n        return map.get(nodeOperatorId) == 1;\n    }\n\n    /// @dev Acts as a proxy to `_queueByPriority` till `_legacyQueue` deprecation.\n    /// @dev TODO: Remove the method in the next major release.\n    function _getQueue(\n        uint256 priority\n    ) internal view returns (QueueLib.Queue storage q) {\n        if (priority == QUEUE_LEGACY_PRIORITY) {\n            assembly {\n                q.slot := _legacyQueue.slot\n            }\n        } else {\n            q = _queueByPriority[priority];\n        }\n    }\n\n    function _checkCanAddKeys(\n        uint256 nodeOperatorId,\n        address who\n    ) internal view {\n        // Most likely a direct call, so check the sender is a manager.\n        if (who == msg.sender) {\n            _onlyNodeOperatorManager(nodeOperatorId, msg.sender);\n        } else {\n            // We're trying to add keys via gate, check if we can do it.\n            _checkRole(CREATE_NODE_OPERATOR_ROLE);\n            if (!_isOperatorCreatedInTX(nodeOperatorId)) {\n                revert CannotAddKeys();\n            }\n        }\n    }\n\n    function _onlyNodeOperatorManager(\n        uint256 nodeOperatorId,\n        address from\n    ) internal view {\n        address managerAddress = _nodeOperators[nodeOperatorId].managerAddress;\n        if (managerAddress == address(0)) {\n            revert NodeOperatorDoesNotExist();\n        }\n\n        if (managerAddress != from) {\n            revert SenderIsNotEligible();\n        }\n    }\n\n    function _onlyExistingNodeOperator(uint256 nodeOperatorId) internal view {\n        if (nodeOperatorId < _nodeOperatorsCount) {\n            return;\n        }\n\n        revert NodeOperatorDoesNotExist();\n    }\n\n    function _onlyValidIndexRange(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) internal view {\n        if (\n            startIndex + keysCount >\n            _nodeOperators[nodeOperatorId].totalAddedKeys\n        ) {\n            revert SigningKeysInvalidOffset();\n        }\n    }\n\n    function _onlyRecoverer() internal view override {\n        _checkRole(RECOVERER_ROLE);\n    }\n\n    /// @dev Both nodeOperatorId and keyIndex are limited to uint64 by the contract\n    function _keyPointer(\n        uint256 nodeOperatorId,\n        uint256 keyIndex\n    ) internal pure returns (uint256) {\n        return (nodeOperatorId << 128) | keyIndex;\n    }\n}\n"
    }
}