{
    "vfp_id": "vfp_00244",
    "project_name": "2025.08.14 - Final - Malda Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Rebalancer can steal funds from markets by sending to custom receiver through Everclear Bridge",
            "description": "The Rebalancer contract allows the EverclearBridge to accept an unchecked `receiver` field in the IntentParams struct, which is a bytes32 value derived from user input. This field is used as the destination for rebalanced funds but is not validated against known or legitimate market addresses. As a result, a malicious rebalancer EOA can set this receiver to an address they control, thereby diverting user funds intended for rebalancing to their own wallet. The root cause is the lack of validation on the `receiver` parameter in the bridge logic. An attacker could exploit this by crafting a malicious intent with a controlled receiver address, leading to theft of funds during cross-chain rebalancing operations. The impact is direct loss of user funds, making this a critical vulnerability.\n",
            "severity": "High",
            "location": [
                "EverclearBridge.sol::IntentParams#40-50",
                "EverclearBridge.sol#111-121"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/EverclearBridge.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Rebalancer can send to unallowed destination chains through EverclearBridge",
            "description": "The EverclearBridge allows multiple destination chains to be specified in the IntentParams. It only verifies that the current _dstChainId is among them, but the intent can be fulfilled on any chain in the list. If a destination chain is not supported by Malda, funds sent there may be lost. The root cause is the lack of strict validation that only one destination is allowed and that it must match the current chain. An attacker or malicious rebalancer could include an unsupported chain in the destinations array, leading to irreversible loss of funds. The impact is potential loss of funds due to routing to invalid or unsupported chains.\n",
            "severity": "Medium",
            "location": [
                "EverclearBridge.sol#40-50",
                "EverclearBridge.sol#95-102"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/EverclearBridge.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "EverclearBridge does not pull tokens from the Rebalancer, causing all rebalancing operations to fail",
            "description": "The EverclearBridge contract assumes it has custody of tokens when performing bridging operations but does not actually pull them from the Rebalancer via safeTransferFrom. It relies on the Rebalancer to have already transferred the tokens, which is not enforced. The root cause is the missing token transfer call in the sendMsg function. As a result, even if the Rebalancer has approved the bridge, no tokens are transferred, and the bridging logic fails. The impact is a complete denial of service for all rebalancing operations, preventing cross-chain liquidity movement and potentially causing liquidity fragmentation.\n",
            "severity": "Medium",
            "location": [
                "EverclearBridge.sol#79-123"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/EverclearBridge.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Incorrect transfer size validation after time window reset can lead to rebalancing DoS",
            "description": "The Rebalancer's sendMsg function uses stale TransferInfo data after a time window reset. Even though the transfer size is reset for a new window, the contract may still revert due to checks on the previous window's limits. This can cause legitimate rebalancing transactions to fail unexpectedly. The root cause is the improper handling of transfer size state across time window boundaries. An attacker could potentially trigger this condition to disrupt rebalancing operations. The impact is a denial of service for rebalancing, which can affect the protocol's ability to maintain balanced liquidity across chains.\n",
            "severity": "Medium",
            "location": [
                "Rebalancer.sol::sendMsg",
                "Rebalancer.sol::sendMsg#141-152"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/Rebalancer.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Rebalancing fails with EverclearBridge due to insufficient allowance for fee",
            "description": "The sendMsg function in EverclearBridge.sol only approves the transfer amount (excluding the fee) for the FeeAdapter, but the FeeAdapter's newIntent function attempts to pull both the amount and the fee from the bridge contract. The root cause is a mismatch in the expected and approved amounts, where the fee is added on top rather than deducted. An authorized rebalancer triggers the issue by invoking sendMsg, which leads to the FeeAdapter pulling more tokens than approved. This results in a revert during the token transfer, causing the entire rebalancing operation to fail. The impact is that all cross-chain rebalancing using the EverclearBridge will fail, leading to a denial of service for liquidity management.\n",
            "severity": "Medium",
            "location": [
                "EverclearBridge.sol#110",
                "FeeAdapter#newIntent"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/EverclearBridge.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Unenforced maxFee and ttl parameters in sendMsg function",
            "description": "The sendMsg function in EverclearBridge.sol does not validate that maxFee and ttl parameters are set to 0, as required for the netting pathway. The root cause is the absence of input validation before passing these parameters to everclearFeeAdapter.newIntent. A rebalancer can set non-zero values for maxFee or ttl, which may cause the intent to be misrouted to the unsupported solver pathway. The exploitation path involves a rebalancer calling sendMsg with non-zero parameters, leading to intent misrouting. The impact includes potential settlement failure, delays in rebalancing, unexpected fees, loss of funds, and the inability to benefit from cost-saving netting, resulting in a denial of service and financial loss.\n",
            "severity": "Medium",
            "location": [
                "EverclearBridge.sol#79",
                "EverclearBridge.sol#111-117"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/EverclearBridge.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Rebalancer can drain market funds via excessive bridge fees",
            "description": "The REBALANCER_EOA can specify an arbitrarily high maxFee in the _message parameter when calling sendMsg, which is passed unchecked to the EverclearFeeAdapter. The root cause is the lack of validation on the maxFee parameter in EverclearBridge.sendMsg. A malicious or compromised rebalancer can set a maxFee close to the entire transfer amount. The attack path involves the rebalancer extracting funds from a market, setting a high maxFee, and causing most of the bridged amount to be taken as fees by the bridge relayer. The impact is permanent loss of protocol funds, as user liquidity is drained from market contracts and paid to third parties, violating the trust assumption that the rebalancer cannot transfer user funds.\n",
            "severity": "Medium",
            "location": [
                "Rebalancer.sol#129",
                "EverclearBridge.sol#111-117"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/Rebalancer.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Across bridging failure locks funds in Rebalancer contract",
            "description": "When Across bridging fails, funds are refunded to the Rebalancer contract, which is set as the depositor in depositV3Now. The root cause is the lack of a mechanism to rescue these refunded funds. Since the Rebalancer has no function to return these tokens to the market, they become permanently locked. The attack path involves a rebalancer initiating a bridging operation that fails or expires, triggering a refund to the Rebalancer. The impact is that funds become completely inaccessible, leading to permanent loss of liquidity.\n",
            "severity": "Medium",
            "location": [
                "AcrossBridge.sol#168"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/Rebalancer.sol",
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/AcrossBridge.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Bridges don't support all of the listed assets",
            "description": "The bridges (Across and Everclear) do not support all the assets that are listed as supported by the protocol. This discrepancy creates operational limitations within the system.\nCause: The root cause is the mismatch between the assets listed as supported and those actually handled by the bridge integrations, likely due to incomplete integration or outdated asset lists.\nExploitation: There is no direct attack path since the issue does not involve malicious exploitation, but it can be triggered organically when attempting to rebalance markets using unsupported tokens.\nImpact: The primary impact is that rebalancing operations will be impossible for markets associated with the unsupported assets, leading to potential inefficiencies or imbalances in the protocol's lending markets.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/AcrossBridge.sol",
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/rebalancer/bridges/EverclearBridge.sol"
            ]
        }
    ],
    "affected_files": {
        "Rebalancer.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\nimport {IRoles} from \"src/interfaces/IRoles.sol\";\nimport {IBridge} from \"src/interfaces/IBridge.sol\";\nimport {IOperator} from \"src/interfaces/IOperator.sol\";\nimport {ImTokenMinimal, ImToken} from \"src/interfaces/ImToken.sol\";\nimport {IRebalancer, IRebalanceMarket} from \"src/interfaces/IRebalancer.sol\";\n\nimport {SafeApprove} from \"src/libraries/SafeApprove.sol\";\n\ncontract Rebalancer is IRebalancer {\n    // ----------- STORAGE ------------\n    IRoles public roles;\n    uint256 public nonce;\n    mapping(uint32 => mapping(uint256 => Msg)) public logs;\n    mapping(address => bool) public whitelistedBridges;\n    mapping(uint32 => bool) public whitelistedDestinations;\n    mapping(address => bool) public allowedList;\n\n    address public saveAddress;\n\n    struct TransferInfo {\n        uint256 size;\n        uint256 timestamp;\n    }\n\n    mapping(uint32 => mapping(address => uint256)) public maxTransferSizes;\n    mapping(uint32 => mapping(address => uint256)) public minTransferSizes;\n    mapping(uint32 => mapping(address => TransferInfo)) public currentTransferSize;\n    uint256 public transferTimeWindow;\n\n    constructor(address _roles, address _saveAddress) {\n        require(_roles != address(0), Rebalancer_AddressNotValid());\n        require(_saveAddress != address(0), Rebalancer_AddressNotValid());\n        \n        roles = IRoles(_roles);\n        transferTimeWindow = 86400;\n        saveAddress = _saveAddress;\n    }\n\n    // ----------- OWNER METHODS ------------\n    function setAllowList(address[] calldata list, bool status) external {\n        if (!roles.isAllowedFor(msg.sender, roles.GUARDIAN_BRIDGE())) revert Rebalancer_NotAuthorized();\n\n        uint256 len = list.length;\n        for (uint256 i; i < len; i++) {\n            allowedList[list[i]] = status;\n        }\n        emit AllowedListUpdated(list, status);\n    }\n\n    function setWhitelistedBridgeStatus(address _bridge, bool _status) external {\n        if (!roles.isAllowedFor(msg.sender, roles.GUARDIAN_BRIDGE())) revert Rebalancer_NotAuthorized();\n        require(_bridge != address(0), Rebalancer_AddressNotValid());\n        whitelistedBridges[_bridge] = _status;\n        emit BridgeWhitelistedStatusUpdated(_bridge, _status);\n    }\n\n    function setWhitelistedDestination(uint32 _dstId, bool _status) external {\n        if (!roles.isAllowedFor(msg.sender, roles.GUARDIAN_BRIDGE())) revert Rebalancer_NotAuthorized();\n        emit DestinationWhitelistedStatusUpdated(_dstId, _status);\n        whitelistedDestinations[_dstId] = _status;\n    }\n\n    function saveEth() external {\n        if (!roles.isAllowedFor(msg.sender, roles.GUARDIAN_BRIDGE())) revert Rebalancer_NotAuthorized();\n\n        uint256 amount = address(this).balance;\n        // no need to check return value\n        (bool success,) = saveAddress.call{value: amount}(\"\");\n        require(success, Rebalancer_RequestNotValid());\n        emit EthSaved(amount);\n    }\n\n    function setMinTransferSize(uint32 _dstChainId, address _token, uint256 _limit) external {\n        if (!roles.isAllowedFor(msg.sender, roles.GUARDIAN_BRIDGE())) revert Rebalancer_NotAuthorized();\n        minTransferSizes[_dstChainId][_token] = _limit;\n        emit MinTransferSizeUpdated(_dstChainId, _token, _limit);\n    }\n\n    function setMaxTransferSize(uint32 _dstChainId, address _token, uint256 _limit) external {\n        if (!roles.isAllowedFor(msg.sender, roles.GUARDIAN_BRIDGE())) revert Rebalancer_NotAuthorized();\n        maxTransferSizes[_dstChainId][_token] = _limit;\n        emit MaxTransferSizeUpdated(_dstChainId, _token, _limit);\n    }\n\n    // ----------- VIEW METHODS ------------\n    /**\n     * @inheritdoc IRebalancer\n     */\n    function isBridgeWhitelisted(address bridge) external view returns (bool) {\n        return whitelistedBridges[bridge];\n    }\n\n    /**\n     * @inheritdoc IRebalancer\n     */\n    function isDestinationWhitelisted(uint32 dstId) external view returns (bool) {\n        return whitelistedDestinations[dstId];\n    }\n\n    // ----------- EXTERNAL METHODS ------------\n    /**\n     * @inheritdoc IRebalancer\n     */\n    function sendMsg(address _bridge, address _market, uint256 _amount, Msg calldata _msg) external payable {\n        // checks\n        if (!roles.isAllowedFor(msg.sender, roles.REBALANCER_EOA())) revert Rebalancer_NotAuthorized();\n        require(whitelistedBridges[_bridge], Rebalancer_BridgeNotWhitelisted());\n        require(whitelistedDestinations[_msg.dstChainId], Rebalancer_DestinationNotWhitelisted());\n        address _underlying = ImTokenMinimal(_market).underlying();\n        require(_underlying == _msg.token, Rebalancer_RequestNotValid());\n\n        // min transfer size check\n        require(_amount > minTransferSizes[_msg.dstChainId][_msg.token], Rebalancer_TransferSizeMinNotMet());\n\n        // max transfer size checks\n        TransferInfo memory transferInfo = currentTransferSize[_msg.dstChainId][_msg.token];\n        uint256 transferSizeDeadline = transferInfo.timestamp + transferTimeWindow;\n        if (transferSizeDeadline < block.timestamp) {\n            currentTransferSize[_msg.dstChainId][_msg.token] = TransferInfo(_amount, block.timestamp);\n        } else {\n            currentTransferSize[_msg.dstChainId][_msg.token].size += _amount;\n        }\n\n        uint256 _maxTransferSize = maxTransferSizes[_msg.dstChainId][_msg.token];\n        if (_maxTransferSize > 0) {\n            require(transferInfo.size + _amount < _maxTransferSize, Rebalancer_TransferSizeExcedeed());\n        }\n\n        // retrieve amounts (make sure to check min and max for that bridge)\n        require(allowedList[_market], Rebalancer_MarketNotValid());\n        IRebalanceMarket(_market).extractForRebalancing(_amount);\n\n        // log\n        unchecked {\n            ++nonce;\n        }\n        logs[_msg.dstChainId][nonce] = _msg;\n\n        // approve and trigger send\n        SafeApprove.safeApprove(_msg.token, _bridge, _amount);\n        IBridge(_bridge).sendMsg{value: msg.value}(\n            _amount, _market, _msg.dstChainId, _msg.token, _msg.message, _msg.bridgeData\n        );\n\n        emit MsgSent(_bridge, _msg.dstChainId, _msg.token, _msg.message, _msg.bridgeData);\n    }\n}\n",
        "EverclearBridge.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {SafeApprove} from \"src/libraries/SafeApprove.sol\";\nimport {BytesLib} from \"src/libraries/BytesLib.sol\";\n\nimport {IBridge} from \"src/interfaces/IBridge.sol\";\nimport {IFeeAdapter} from \"src/interfaces/external/everclear/IFeeAdapter.sol\";\n\nimport {BaseBridge} from \"src/rebalancer/bridges/BaseBridge.sol\";\n\ncontract EverclearBridge is BaseBridge, IBridge {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ----------- STORAGE ------------\n    IFeeAdapter public everclearFeeAdapter;\n\n    struct IntentParams {\n        uint32[] destinations;\n        bytes32 receiver;\n        address inputAsset;\n        bytes32 outputAsset;\n        uint256 amount;\n        uint24 maxFee;\n        uint48 ttl;\n        bytes data;\n        IFeeAdapter.FeeParams feeParams;\n    }\n\n    // ----------- EVENTS ------------\n    event MsgSent(uint256 indexed dstChainId, address indexed market, uint256 amountLD, bytes32 id);\n    event RebalancingReturnedToMarket(address indexed market, uint256 toReturn, uint256 extracted);\n\n    // ----------- ERRORS ------------\n    error Everclear_TokenMismatch();\n    error Everclear_NotImplemented();\n    error Everclear_AddressNotValid();\n    error Everclear_DestinationNotValid();\n    error Everclear_DestinationsLengthMismatch();\n\n    constructor(address _roles, address _feeAdapter) BaseBridge(_roles) {\n        require(_feeAdapter != address(0), Everclear_AddressNotValid());\n\n        everclearFeeAdapter = IFeeAdapter(_feeAdapter);\n    }\n\n    // ----------- VIEW ------------\n    /**\n     * @inheritdoc IBridge\n     */\n    function getFee(uint32, bytes memory, bytes memory) external pure returns (uint256) {\n        // need to use Everclear API\n        revert Everclear_NotImplemented();\n    }\n\n    // ----------- EXTERNAL ------------\n    function sendMsg(\n        uint256 _extractedAmount,\n        address _market,\n        uint32 _dstChainId,\n        address _token,\n        bytes memory _message,\n        bytes memory // unused\n    ) external payable onlyRebalancer {\n        IntentParams memory params = _decodeIntent(_message);\n\n        require(params.inputAsset == _token, Everclear_TokenMismatch());\n        require(_extractedAmount >= params.amount, BaseBridge_AmountMismatch());\n\n        uint256 destinationsLength = params.destinations.length;\n        require(destinationsLength > 0, Everclear_DestinationsLengthMismatch());\n\n        bool found;\n        for (uint256 i; i < destinationsLength; ++i) {\n            if (params.destinations[i] == _dstChainId) {\n                found = true;\n                break;\n            }\n        }\n        require(found, Everclear_DestinationNotValid());\n\n        if (_extractedAmount > params.amount) {\n            uint256 toReturn = _extractedAmount - params.amount;\n            IERC20(_token).safeTransfer(_market, toReturn);\n            emit RebalancingReturnedToMarket(_market, toReturn, _extractedAmount);\n        }\n\n        SafeApprove.safeApprove(params.inputAsset, address(everclearFeeAdapter), params.amount);\n        (bytes32 id,) = everclearFeeAdapter.newIntent(\n            params.destinations,\n            params.receiver,\n            params.inputAsset,\n            params.outputAsset,\n            params.amount,\n            params.maxFee,\n            params.ttl,\n            params.data,\n            params.feeParams\n        );\n        emit MsgSent(_dstChainId, _market, params.amount, id);\n    }\n\n    // ----------- INTERNAL ------------\n    function _decodeIntent(bytes memory message) internal pure returns (IntentParams memory) {\n        // message contains data obtained from `https://api.everclear.org/intents` call\n        // data can be decoded into `FeeAdapter.newIntent` call params\n\n        // skip selector\n        bytes memory intentData = BytesLib.slice(message, 4, message.length - 4);\n        (\n            uint32[] memory destinations,\n            bytes32 receiver,\n            address inputAsset,\n            bytes32 outputAsset,\n            uint256 amount,\n            uint24 maxFee,\n            uint48 ttl,\n            bytes memory data,\n            IFeeAdapter.FeeParams memory feeParams\n        ) = abi.decode(\n            intentData, (uint32[], bytes32, address, bytes32, uint256, uint24, uint48, bytes, IFeeAdapter.FeeParams)\n        );\n\n        return IntentParams(destinations, receiver, inputAsset, outputAsset, amount, maxFee, ttl, data, feeParams);\n    }\n}\n",
        "AcrossBridge.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {SafeApprove} from \"src/libraries/SafeApprove.sol\";\n\nimport {IBridge} from \"src/interfaces/IBridge.sol\";\nimport {ImTokenMinimal} from \"src/interfaces/ImToken.sol\";\nimport {IAcrossSpokePoolV3} from \"src/interfaces/external/across/IAcrossSpokePoolV3.sol\";\n\nimport {BaseBridge} from \"src/rebalancer/bridges/BaseBridge.sol\";\n\ncontract AccrossBridge is BaseBridge, IBridge, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ----------- STORAGE ------------\n    address public immutable acrossSpokePool;\n    uint256 public immutable maxSlippage;\n    mapping(uint32 => mapping(address => bool)) public whitelistedRelayers;\n\n    uint256 private constant SLIPPAGE_PRECISION = 1e5;\n\n    struct DecodedMessage {\n        uint256 inputAmount;\n        uint256 outputAmount;\n        address relayer;\n        uint32 deadline;\n        uint32 exclusivityDeadline;\n    }\n\n    // ----------- EVENTS ------------\n    event Rebalanced(address indexed market, uint256 amount);\n    event WhitelistedRelayerStatusUpdated(\n        address indexed sender, uint32 indexed dstId, address indexed delegate, bool status\n    );\n\n    // ----------- ERRORS ------------\n    error AcrossBridge_TokenMismatch();\n    error AcrossBridge_NotAuthorized();\n    error AcrossBridge_NotImplemented();\n    error AcrossBridge_AddressNotValid();\n    error AcrossBridge_SlippageNotValid();\n    error AcrossBridge_RelayerNotValid();\n\n    constructor(address _roles, address _spokePool) BaseBridge(_roles) {\n        require(_spokePool != address(0), AcrossBridge_AddressNotValid());\n        acrossSpokePool = _spokePool;\n        maxSlippage = 1e4;\n    }\n\n    modifier onlySpokePool() {\n        require(msg.sender == acrossSpokePool, AcrossBridge_NotAuthorized());\n        _;\n    }\n\n    // ----------- OWNER ------------\n    /**\n     * @notice Whitelists a delegate address\n     */\n    function setWhitelistedRelayer(uint32 _dstId, address _relayer, bool status) external onlyBridgeConfigurator {\n        whitelistedRelayers[_dstId][_relayer] = status;\n        emit WhitelistedRelayerStatusUpdated(msg.sender, _dstId, _relayer, status);\n    }\n\n    // ----------- VIEW ------------\n    /**\n     * @inheritdoc IBridge\n     */\n    function getFee(uint32, bytes memory, bytes memory) external pure returns (uint256) {\n        // need to use Across API\n        revert AcrossBridge_NotImplemented();\n    }\n\n    /**\n     * @notice returns if an address represents a whitelisted delegates\n     */\n    function isRelayerWhitelisted(uint32 dstChain, address relayer) external view returns (bool) {\n        return whitelistedRelayers[dstChain][relayer];\n    }\n\n    // ----------- EXTERNAL ------------\n    /**\n     * @inheritdoc IBridge\n     */\n    function sendMsg(\n        uint256 _extractedAmount,\n        address _market,\n        uint32 _dstChainId,\n        address _token,\n        bytes memory _message,\n        bytes memory\n    ) external payable onlyRebalancer {\n        // decode message & checks\n        DecodedMessage memory msgData = _decodeMessage(_message);\n        require(_extractedAmount == msgData.inputAmount, BaseBridge_AmountMismatch());\n        require(whitelistedRelayers[_dstChainId][msgData.relayer], AcrossBridge_RelayerNotValid());\n\n        // retrieve tokens from `Rebalancer`\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), msgData.inputAmount);\n\n        if (msgData.inputAmount > msgData.outputAmount) {\n            uint256 maxSlippageInputAmount = msgData.inputAmount * maxSlippage / SLIPPAGE_PRECISION;\n            require(\n                msgData.inputAmount - msgData.outputAmount <= maxSlippageInputAmount, AcrossBridge_SlippageNotValid()\n            );\n        }\n\n        // approve and send with Across\n        _depositV3Now(_message, _token, _dstChainId, _market);\n    }\n\n    /**\n     * @notice handles AcrossV3 SpokePool message\n     * @param tokenSent the token address received\n     * @param amount the token amount\n     * @param message the custom message sent from source\n     */\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address, // relayer is unused\n        bytes memory message\n    ) external onlySpokePool nonReentrant {\n        address market = abi.decode(message, (address));\n        address _underlying = ImTokenMinimal(market).underlying();\n        require(_underlying == tokenSent, AcrossBridge_TokenMismatch());\n        if (amount > 0) {\n            IERC20(tokenSent).safeTransfer(market, amount);\n        }\n\n        emit Rebalanced(market, amount);\n    }\n\n    // ----------- PRIVATE ------------\n    function _decodeMessage(bytes memory _message) private pure returns (DecodedMessage memory) {\n        (uint256 inputAmount, uint256 outputAmount, address relayer, uint32 deadline, uint32 exclusivityDeadline) =\n            abi.decode(_message, (uint256, uint256, address, uint32, uint32));\n\n        return DecodedMessage(inputAmount, outputAmount, relayer, deadline, exclusivityDeadline);\n    }\n\n    function _depositV3Now(bytes memory _message, address _token, uint32 _dstChainId, address _market) private {\n        DecodedMessage memory msgData = _decodeMessage(_message);\n        // approve and send with Across\n        SafeApprove.safeApprove(_token, address(acrossSpokePool), msgData.inputAmount);\n        IAcrossSpokePoolV3(acrossSpokePool).depositV3Now( // no need for `msg.value`; fee is taken from amount\n            msg.sender, //depositor\n            address(this), //recipient\n            _token,\n            address(0), //outputToken is automatically resolved to the same token on destination\n            msgData.inputAmount,\n            msgData.outputAmount, //outputAmount should be set as the inputAmount - relay fees; use Across API\n            uint256(_dstChainId),\n            msgData.relayer, //exclusiveRelayer\n            msgData.deadline, //fillDeadline\n            msgData.exclusivityDeadline, //can use Across API/suggested-fees or 0 to disable\n            abi.encode(_market)\n        );\n    }\n}\n"
    }
}