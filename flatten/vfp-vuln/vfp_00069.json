{
    "vfp_id": "vfp_00069",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-193"
                ]
            },
            "title": "Activation and Compact Typehashes Differ from Typestring Used in `writeWitnessAndGetTypehashes`",
            "description": "The `writeWitnessAndGetTypehashes` function in `DepositViaPermit2Lib` incorrectly constructs the EIP-712 typestring when no witness is provided, appending \")TokenPermissions(address token,\" one byte too early. This results in an invalid typestring ending with \"Mandate)TokenPermissions...\" instead of \"Mandate()\".\nThe root cause is a string concatenation error in memory, combined with mismatched constant pre-images used to derive `activationTypehash` and `compactTypehash`. These constants omit the mandate reference, causing a discrepancy between the typehashes computed during deposit and those used during claim validation.\nAn attacker could exploit this by crafting a permit signature based on the incorrect typestring, leading to inconsistent hash validation across protocol phases. This undermines the integrity of the permit system and may allow invalid signatures to pass or valid ones to fail.\nThe impact includes potential denial of service for legitimate users or, in edge cases, unauthorized execution of transfers if signature validation is bypassed due to hash mismatches.\n",
            "severity": "Medium",
            "location": [
                "DepositViaPermit2Lib.sol::writeWitnessAndGetTypehashes#135",
                "DepositViaPermit2Lib.sol#218",
                "DepositViaPermit2Lib.sol#224",
                "EIP712Types.sol#114-115",
                "EIP712Types.sol#18-19",
                "DepositViaPermit2Lib.sol#230-251",
                "HashLib.sol::toMessageHashWithWitness#189"
            ],
            "files": [
                "the-compact/src/lib/DepositViaPermit2Lib.sol"
            ]
        }
    ],
    "affected_files": {
        "DepositViaPermit2Lib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport {\n    COMPACT_TYPEHASH,\n    BATCH_COMPACT_TYPEHASH,\n    PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH,\n    PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_THREE,\n    TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE,\n    TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO,\n    COMPACT_ACTIVATION_TYPEHASH,\n    BATCH_COMPACT_ACTIVATION_TYPEHASH,\n    COMPACT_BATCH_ACTIVATION_TYPEHASH,\n    BATCH_COMPACT_BATCH_ACTIVATION_TYPEHASH,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_ONE,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_TWO,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_THREE,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_FOUR\n} from \"../types/EIP712Types.sol\";\n\n/**\n * @title DepositViaPermit2Lib\n * @notice Library contract implementing internal functions with logic for processing\n * token deposits via permit2. These deposits leverage Permit2 witness data to either\n * indicate the parameters of the lock to deposit into and the recipient of the deposit,\n * or the parameters of the compact to register alongside the deposit. Deposits can also\n * involve a single ERC20 token or a batch of tokens in a single Permit2 authorization.\n * @dev IMPORTANT NOTE: this logic operates directly on unallocated memory, and reads\n * directly from fixed calldata offsets; proceed with EXTREME caution when making any\n * modifications to either this logic contract (including the insertion of new logic) or\n * to the associated permit2 deposit function interfaces!\n */\nlibrary DepositViaPermit2Lib {\n    // Selector for the batch `permit2.permitWitnessTransferFrom` function.\n    uint256 private constant _BATCH_PERMIT_WITNESS_TRANSFER_FROM_SELECTOR = 0xfe8ec1a7;\n\n    error InvalidCompactCategory();\n\n    /**\n     * @notice Internal view function for preparing batch deposit permit2 calldata.\n     * Prepares known arguments and offsets in memory and returns pointers to the start\n     * of the prepared calldata as well as to the start of the witness typestring.\n     * @param totalTokensLessInitialNative The number of non-native tokens to deposit.\n     * @param firstUnderlyingTokenIsNative Whether the first underlying token is native.\n     * @return m The memory pointer to the start of the prepared calldata.\n     * @return typestringMemoryLocation The memory pointer to the start of the typestring.\n     */\n    function beginPreparingBatchDepositPermit2Calldata(\n        uint256 totalTokensLessInitialNative,\n        bool firstUnderlyingTokenIsNative\n    ) internal view returns (uint256 m, uint256 typestringMemoryLocation) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            m := mload(0x40)\n\n            // Derive size of each token chunk (2 words per token).\n            let tokenChunk := shl(6, totalTokensLessInitialNative)\n\n            // Derive size of two token chunks (4 words per token).\n            let twoTokenChunks := shl(1, tokenChunk)\n\n            // Derive memory location of the `permitted` calldata struct.\n            let permittedCalldataLocation := add(add(0x24, calldataload(0x24)), shl(6, firstUnderlyingTokenIsNative))\n\n            // Prepare the initial fragment of the witness typestring.\n            mstore(m, _BATCH_PERMIT_WITNESS_TRANSFER_FROM_SELECTOR)\n            mstore(add(m, 0x20), 0xc0) // permitted offset\n            mstore(add(m, 0x40), add(0x140, tokenChunk)) // details offset\n            mstore(add(m, 0x60), calldataload(0x04)) // depositor\n            // Skip witnessHash at 0x80 as it is not yet known.\n            mstore(add(m, 0xa0), add(0x160, twoTokenChunks)) // witness offset\n            // Skip signatureOffset at 0xc0 as it is not yet known.\n            mstore(add(m, 0xe0), 0x60) // permitted tokens relative offset\n            mstore(add(m, 0x100), calldataload(0x44)) // nonce\n            mstore(add(m, 0x120), calldataload(0x64)) // deadline\n            mstore(add(m, 0x140), totalTokensLessInitialNative) // permitted.length\n\n            // Copy permitted data from calldata to memory.\n            calldatacopy(add(m, 0x160), permittedCalldataLocation, tokenChunk)\n\n            // Derive memory location of the `details` calldata struct.\n            let detailsOffset := add(add(m, 0x160), tokenChunk)\n\n            // Store the length of the `details` array.\n            mstore(detailsOffset, totalTokensLessInitialNative)\n\n            // Derive start, next, & end locations for iterating through `details` array.\n            let starting := add(detailsOffset, 0x20)\n            let next := add(detailsOffset, 0x40)\n            let end := shl(6, totalTokensLessInitialNative)\n\n            // Iterate through `details` array and copy data from calldata to memory.\n            for { let i := 0 } lt(i, end) { i := add(i, 0x40) } {\n                // Copy this contract as the recipient address.\n                mstore(add(starting, i), address())\n\n                // Copy full token amount as the requested amount.\n                mstore(add(next, i), calldataload(add(permittedCalldataLocation, add(0x20, i))))\n            }\n\n            // Derive memory location of the witness typestring.\n            typestringMemoryLocation := add(m, add(0x180, twoTokenChunks))\n\n            // NOTE: strongly consider allocating memory here as the inline assembly scope\n            // is being left (it *should* be fine for now as the function between assembly\n            // blocks does not allocate any new memory).\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving typehashes and simultaneously\n     * preparing the witness typestring component of the call to permit2.\n     * @param memoryLocation      The memory pointer to the start of the typestring.\n     * @param category            The CompactCategory of the deposit. Must be Compact or BatchCompact.\n     * @param witness             The witness string to insert.\n     * @param usingBatch          Whether the deposit involves a batch.\n     * @return activationTypehash The derived activation typehash.\n     * @return compactTypehash    The derived compact typehash.\n     */\n    function writeWitnessAndGetTypehashes(\n        uint256 memoryLocation,\n        CompactCategory category,\n        string calldata witness,\n        bool usingBatch\n    ) internal pure returns (bytes32 activationTypehash, bytes32 compactTypehash) {\n        assembly (\"memory-safe\") {\n            // Internal assembly function for writing the witness and typehashes.\n            // Used to enable leaving the inline assembly scope early when the\n            // witness is empty (no-witness case).\n            function writeWitnessAndGetTypehashes(memLocation, c, witnessOffset, witnessLength, usesBatch) ->\n                derivedActivationTypehash,\n                derivedCompactTypehash\n            {\n                // Derive memory offset for the witness typestring data.\n                let memoryOffset := add(memLocation, 0x20)\n\n                // Declare variables for start of Activation and Category-specific data.\n                let activationStart\n                let categorySpecificStart\n\n                // Handle non-batch cases.\n                if iszero(usesBatch) {\n                    // Prepare initial Activation witness typestring fragment.\n                    mstore(add(memoryOffset, 0x1b), PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO)\n                    mstore(memoryOffset, PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE)\n\n                    // Set memory pointers for Activation and Category-specific data start.\n                    activationStart := add(memoryOffset, 0x13)\n                    categorySpecificStart := add(memoryOffset, 0x3b)\n                }\n\n                // Proceed with batch case if preparation of activation has not begun.\n                if iszero(activationStart) {\n                    // Prepare initial BatchActivation witness typestring fragment.\n                    mstore(memoryOffset, PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE)\n                    mstore(add(memoryOffset, 0x28), PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_THREE)\n                    mstore(add(memoryOffset, 0x20), PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO)\n\n                    // Set memory pointers for Activation and Category-specific data.\n                    activationStart := add(memoryOffset, 0x18)\n                    categorySpecificStart := add(memoryOffset, 0x48)\n                }\n\n                // Declare variable for end of Category-specific data.\n                let categorySpecificEnd\n\n                // Handle Compact (non-batch, single-chain) case.\n                if iszero(c) {\n                    // Prepare next typestring fragment using Compact witness typestring.\n                    mstore(categorySpecificStart, PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_ONE)\n                    mstore(add(categorySpecificStart, 0x20), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_TWO)\n                    mstore(add(categorySpecificStart, 0x40), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_THREE)\n                    mstore(add(categorySpecificStart, 0x68), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FIVE)\n                    mstore(add(categorySpecificStart, 0x60), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n\n                    // Set memory pointers for Activation and Category-specific data end.\n                    categorySpecificEnd := add(categorySpecificStart, 0x88)\n                    categorySpecificStart := add(categorySpecificStart, 0x10)\n                }\n\n                // Handle BatchCompact (single-chain) case.\n                if iszero(sub(c, 1)) {\n                    // Prepare next typestring fragment using BatchCompact witness typestring.\n                    mstore(categorySpecificStart, PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE)\n                    mstore(add(categorySpecificStart, 0x20), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO)\n                    mstore(add(categorySpecificStart, 0x40), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE)\n                    mstore(add(categorySpecificStart, 0x73), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE)\n                    mstore(add(categorySpecificStart, 0x60), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n\n                    // Set memory pointers for Activation and Category-specific data end.\n                    categorySpecificEnd := add(categorySpecificStart, 0x93)\n                    categorySpecificStart := add(categorySpecificStart, 0x15)\n                }\n\n                // Revert on MultichainCompact case or above (registration only applies to the current chain).\n                if iszero(categorySpecificEnd) {\n                    // revert InvalidCompactCategory();\n                    mstore(0, 0xdae3f108)\n                    revert(0x1c, 4)\n                }\n\n                // Handle no-witness cases.\n                if iszero(witnessLength) {\n                    // Derive memory offset for region used to retrieve typestring fragment by index.\n                    let indexWords := shl(5, c)\n\n                    // Prepare token permissions typestring fragment.\n                    mstore(add(categorySpecificEnd, 0x0e), TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO)\n                    mstore(sub(categorySpecificEnd, 1), TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE)\n\n                    // Derive total length of typestring and store at start of memory.\n                    mstore(memLocation, sub(add(categorySpecificEnd, 0x2e), memoryOffset))\n\n                    // Derive activation typehash based on the compact category for non-batch cases.\n                    if iszero(usesBatch) {\n                        // Prepare typehashes for Activation.\n                        mstore(0, COMPACT_ACTIVATION_TYPEHASH)\n                        mstore(0x20, BATCH_COMPACT_ACTIVATION_TYPEHASH)\n\n                        // Retrieve respective typehash by index.\n                        derivedActivationTypehash := mload(indexWords)\n                    }\n\n                    // Derive activation typehash for batch cases if typehash is not yet derived.\n                    if iszero(derivedActivationTypehash) {\n                        // Prepare typehashes for BatchActivation.\n                        mstore(0, COMPACT_BATCH_ACTIVATION_TYPEHASH)\n                        mstore(0x20, BATCH_COMPACT_BATCH_ACTIVATION_TYPEHASH)\n\n                        // Retrieve respective typehash by index.\n                        derivedActivationTypehash := mload(indexWords)\n                    }\n\n                    // Prepare compact typehashes.\n                    mstore(0, COMPACT_TYPEHASH)\n                    mstore(0x20, BATCH_COMPACT_TYPEHASH)\n\n                    // Retrieve respective typehash by index.\n                    derivedCompactTypehash := mload(indexWords)\n\n                    // Leave the inline assembly scope early.\n                    leave\n                }\n\n                // Copy the supplied compact witness from calldata.\n                calldatacopy(categorySpecificEnd, witnessOffset, witnessLength)\n\n                // Insert tokenPermissions typestring fragment.\n                let tokenPermissionsFragmentStart := add(categorySpecificEnd, witnessLength)\n                mstore(add(tokenPermissionsFragmentStart, 0x0f), TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO)\n                mstore(tokenPermissionsFragmentStart, TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE)\n\n                // Derive total length of typestring and store at start of memory.\n                mstore(memLocation, sub(add(tokenPermissionsFragmentStart, 0x2f), memoryOffset))\n\n                // Derive activation typehash.\n                derivedActivationTypehash :=\n                    keccak256(activationStart, sub(add(tokenPermissionsFragmentStart, 1), activationStart))\n\n                // Derive compact typehash.\n                derivedCompactTypehash :=\n                    keccak256(categorySpecificStart, sub(add(tokenPermissionsFragmentStart, 1), categorySpecificStart))\n            }\n\n            // Execute internal assembly function and store derived typehashes.\n            activationTypehash, compactTypehash :=\n                writeWitnessAndGetTypehashes(memoryLocation, category, witness.offset, witness.length, usingBatch)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the activation witness hash and\n     * writing it to a specified memory location. Depends on the \"activator\" or caller.\n     * @param activationTypehash The derived activation typehash.\n     * @param idOrIdsHash        Resource lock ID or uint256 representation of the hash of each ID.\n     * @param claimHash          The claim hash.\n     * @param memoryPointer      The memory pointer to the start of the memory region.\n     * @param offset             The offset within the memory region to write the witness hash.\n     */\n    function deriveAndWriteWitnessHash(\n        bytes32 activationTypehash,\n        uint256 idOrIdsHash,\n        bytes32 claimHash,\n        uint256 memoryPointer,\n        uint256 offset\n    ) internal view {\n        assembly (\"memory-safe\") {\n            // Retrieve and cache free memory pointer.\n            let m := mload(0x40)\n\n            // Prepare witness hash data: activationTypehash, activator, idOrIdsHash, & claimHash.\n            mstore(0, activationTypehash)\n            mstore(0x20, caller())\n            mstore(0x40, idOrIdsHash)\n            mstore(0x60, claimHash)\n\n            // Derive activation witness hash and write it to specified memory location.\n            mstore(add(memoryPointer, offset), keccak256(0, 0x80))\n\n            // Restore the free memory pointer and the zero slot.\n            mstore(0x40, m)\n            mstore(0x60, 0)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the CompactDeposit witness hash.\n     * @param calldataOffset The offset of the CompactDeposit calldata.\n     * @return witnessHash   The derived CompactDeposit witness hash.\n     */\n    function deriveCompactDepositWitnessHash(uint256 calldataOffset) internal pure returns (bytes32 witnessHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare the initial fragment of the witness typestring.\n            mstore(m, PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH)\n\n            // Copy lockTag & recipient directly from calldata.\n            // NOTE: none of these arguments are sanitized; the assumption is that they have to\n            // match the signed values anyway, so *should* be fine not to sanitize them but could\n            // optionally check that there are no dirty upper bits on any of them.\n            calldatacopy(add(m, 0x20), calldataOffset, 0x40)\n\n            // Derive the CompactDeposit witness hash from the prepared data.\n            witnessHash := keccak256(m, 0x60)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for inserting the CompactDeposit typestring\n     * (used for deposits that do not involve a compact registration) into memory.\n     * @param memoryLocation The memory pointer to the start of the typestring.\n     */\n    function insertCompactDepositTypestring(uint256 memoryLocation) internal pure {\n        assembly (\"memory-safe\") {\n            // Write the length of the typestring.\n            mstore(memoryLocation, 0x76)\n\n            // Write the data for the typestring.\n            mstore(add(memoryLocation, 0x20), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_ONE)\n            mstore(add(memoryLocation, 0x40), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_TWO)\n            mstore(add(memoryLocation, 0x76), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_FOUR)\n            mstore(add(memoryLocation, 0x60), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_THREE)\n        }\n    }\n}\n"
    }
}