{
    "vfp_id": "vfp_00192",
    "project_name": "Uniswap Hooks Library Milestone 1 Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Non-Explicit Multiple-Pool Support Allows Overwriting Hook State",
            "description": "The BaseCustomAccounting hook is designed to support only a single Uniswap V4 pool, identified by the `poolKey` state variable, which is set during the `_beforeInitialize` callback. However, the hook does not prevent re-initialization with a different pool, allowing the `poolKey` to be overwritten by registering the same hook with another pool. This occurs because Uniswap V4 allows any pool to use any hook without the hook's explicit consent unless actively rejected.\n\nThe root cause is the lack of a guard in the `_beforeInitialize` function to ensure `poolKey` is set only once. As a result, an attacker or any user can register the hook with a new pool, overwriting the original `poolKey`. This causes all subsequent operations (like liquidity additions or removals) to target the new pool, while the original pool's liquidity remains locked and inaccessible through the hook.\n\nAn attacker could exploit this by registering the hook with a new pool after users have deposited liquidity, effectively freezing their funds in the original pool. The impact is loss of access to user funds and potential permanent loss if no external mechanism exists to recover the liquidity.\n",
            "severity": "Critical",
            "location": [
                "BaseCustomAccounting.sol::poolKey#35",
                "BaseCustomAccounting.sol::_beforeInitialize#220",
                "BaseCustomAccounting.sol#196"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Insufficient Slippage Check",
            "description": "The BaseCustomAccounting hook lacks sufficient slippage protection during liquidity operations. When removing liquidity, there is no slippage check at all, leaving users exposed to front-running via swaps that alter the pool's tick and token balances. When adding liquidity, the slippage check uses the total delta (principal + fees), which can be manipulated.\n\nThe root cause is the incorrect use of the full delta returned by `PoolManager.modifyLiquidity`, which includes accrued fees. If fees exceed the principal delta, the net delta can be positive, leading to an unsafe cast of `-amount` to `uint256`, which results in a very large number and bypasses the slippage check entirely.\n\nAn attacker can exploit this by front-running add/remove liquidity calls with swaps that shift the tick or accrue large fees. The impact includes users receiving far fewer tokens than expected when removing liquidity, or being forced to deposit significantly more than intended when adding liquidity, leading to economic loss.\n",
            "severity": "High",
            "location": [
                "BaseCustomAccounting.sol::addLiquidity#132",
                "BaseCustomAccounting.sol::removeLiquidity#151-162",
                "BaseCustomAccounting.sol#199"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Unsafe Casting Due to Accrued Fees",
            "description": "In the BaseCustomAccounting hook, the delta returned from `PoolManager.modifyLiquidity` includes both principal and accrued fees. When processing this delta, the code assumes negative amounts for deposits, but accrued fees can make one or both token amounts positive. The code then performs an unsafe cast of `-amount` to `uint256`, which can result in extremely large values.\n\nThe root cause is the incorrect assumption that delta amounts are always negative when adding liquidity. If fees are large, the net delta can be positive, leading to a large unsigned value when negated, which may either cause a revert or result in the user paying far more than intended.\n\nAn attacker can exploit this by increasing fees (e.g., via concentrated liquidity or time-based accrual) before a user's liquidity operation. The impact is either a failed transaction or a significant overpayment by the user, leading to loss of funds.\n",
            "severity": "Medium",
            "location": [
                "BaseCustomAccounting.sol#199",
                "BaseCustomAccounting.sol#208",
                "BaseCustomAccounting.sol#184"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        }
    ],
    "affected_files": {
        "BaseCustomAccounting.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseCustomAccounting.sol)\n\npragma solidity ^0.8.24;\n\nimport {BaseHook} from \"src/base/BaseHook.sol\";\nimport {CurrencySettler} from \"src/utils/CurrencySettler.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"v4-core/src/interfaces/callback/IUnlockCallback.sol\";\nimport {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {StateLibrary} from \"v4-core/src/libraries/StateLibrary.sol\";\n\n/**\n * @dev Base implementation for custom accounting and hook-owned liquidity.\n *\n * To enable hook-owned liquidity, tokens must be deposited via the hook to allow control and flexibility\n * over the liquidity. The implementation inheriting this hook must implement the respective functions\n * to calculate the liquidity modification parameters and the amount of liquidity shares to mint or burn.\n *\n * Additionally, the implementer must consider that the hook is the sole owner of the liquidity and\n * manage fees over liquidity shares accordingly.\n *\n * NOTE: This base hook is designed to work with a single pool key. If you want to use the same custom\n * accounting hook for multiple pools, you must have multiple storage instances of this contract and\n * initialize them via the `PoolManager` with their respective pool keys.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseCustomAccounting is BaseHook, IUnlockCallback {\n    using CurrencySettler for Currency;\n    using CurrencyLibrary for Currency;\n    using StateLibrary for IPoolManager;\n\n    /**\n     * @dev A liquidity modification order was attempted to be executed after the deadline.\n     */\n    error ExpiredPastDeadline();\n\n    /**\n     * @dev Pool was not initialized.\n     */\n    error PoolNotInitialized();\n\n    /**\n     * @dev Principal delta of liquidity modification resulted in too much slippage.\n     */\n    error TooMuchSlippage();\n\n    /**\n     * @dev Liquidity was attempted to be added or removed via the `PoolManager` instead of the hook.\n     */\n    error LiquidityOnlyViaHook();\n\n    /**\n     * @dev Native currency was not sent with the correct amount.\n     */\n    error InvalidNativeValue();\n\n    /**\n     * @dev Hook was already initialized.\n     */\n    error AlreadyInitialized();\n\n    struct AddLiquidityParams {\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n        int24 tickLower;\n        int24 tickUpper;\n        bytes32 userInputSalt;\n    }\n\n    struct RemoveLiquidityParams {\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n        int24 tickLower;\n        int24 tickUpper;\n        bytes32 userInputSalt;\n    }\n\n    struct CallbackData {\n        address sender;\n        IPoolManager.ModifyLiquidityParams params;\n    }\n\n    /**\n     * @notice The hook's pool key.\n     */\n    PoolKey public poolKey;\n\n    /**\n     * @dev Ensure the deadline of a liquidity modification request is not expired.\n     *\n     * @param deadline Deadline of the request, passed in by the caller.\n     */\n    modifier ensure(uint256 deadline) {\n        if (deadline < block.timestamp) revert ExpiredPastDeadline();\n        _;\n    }\n\n    /**\n     * @dev Set the pool `PoolManager` address.\n     */\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    /**\n     * @notice Adds liquidity to the hook's pool.\n     *\n     * @dev To cover all possible scenarios, `msg.sender` should have already given the hook an allowance\n     * of at least amount0Desired/amount1Desired on token0/token1. Always adds assets at the ideal ratio,\n     * according to the price when the transaction is executed.\n     *\n     * NOTE: The `amount0Min` and `amount1Min` parameters are relative to the principal delta, which excludes\n     * fees accrued from the liquidity modification delta.\n     *\n     * @param params The parameters for the liquidity addition.\n     * @return delta The principal delta of the liquidity addition.\n     */\n    function addLiquidity(AddLiquidityParams calldata params)\n        external\n        payable\n        virtual\n        ensure(params.deadline)\n        returns (BalanceDelta delta)\n    {\n        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());\n\n        if (sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        // Revert if msg.value is non-zero but currency0 is not native\n        bool isNative = poolKey.currency0.isAddressZero();\n        if (!isNative && msg.value > 0) revert InvalidNativeValue();\n\n        // Get the liquidity modification parameters and the amount of liquidity shares to mint\n        (bytes memory modifyParams, uint256 shares) = _getAddLiquidity(sqrtPriceX96, params);\n\n        // Apply the liquidity modification\n        (BalanceDelta callerDelta, BalanceDelta feesAccrued) = _modifyLiquidity(modifyParams);\n\n        // Mint the liquidity shares to sender\n        _mint(params, callerDelta, feesAccrued, shares);\n\n        // Get the principal delta by subtracting the fee delta from the caller delta (-= is not supported)\n        delta = callerDelta - feesAccrued;\n\n        // Check for slippage on principal delta\n        uint128 amount0 = uint128(-delta.amount0());\n        if (amount0 < params.amount0Min || uint128(-delta.amount1()) < params.amount1Min) {\n            revert TooMuchSlippage();\n        }\n\n        // If the currency0 is native, refund any remaining msg.value that wasn't used based on the principal delta\n        if (isNative) {\n            // Check that delta amount was covered by msg.value given that settle would be valid if hook can pay for difference\n            // It also allows users to provide more native value than the desired amount\n            if (msg.value < amount0) revert InvalidNativeValue();\n\n            // Previous check prevents underflow revert\n            poolKey.currency0.transfer(msg.sender, msg.value - amount0);\n        }\n    }\n\n    /**\n     * @notice Removes liquidity from the hook's pool.\n     *\n     * NOTE: The `amount0Min` and `amount1Min` parameters are relative to the principal delta, which\n     * excludes fees accrued from the liquidity modification delta.\n     *\n     * @param params The parameters for the liquidity removal.\n     * @return delta The principal delta of the liquidity removal.\n     */\n    function removeLiquidity(RemoveLiquidityParams calldata params)\n        external\n        virtual\n        ensure(params.deadline)\n        returns (BalanceDelta delta)\n    {\n        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());\n\n        if (sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        // Get the liquidity modification parameters and the amount of liquidity shares to burn\n        (bytes memory modifyParams, uint256 shares) = _getRemoveLiquidity(params);\n\n        // Apply the liquidity modification\n        (BalanceDelta callerDelta, BalanceDelta feesAccrued) = _modifyLiquidity(modifyParams);\n\n        // Burn the liquidity shares from the sender\n        _burn(params, callerDelta, feesAccrued, shares);\n\n        // Get the principal delta by subtracting the fee delta from the caller delta (-= is not supported)\n        delta = callerDelta - feesAccrued;\n\n        // Check for slippage\n        if (uint128(delta.amount0()) < params.amount0Min || uint128(delta.amount1()) < params.amount1Min) {\n            revert TooMuchSlippage();\n        }\n    }\n\n    /**\n     * @dev Calls the `PoolManager` to unlock and call back the hook's `unlockCallback` function.\n     *\n     * @param params The encoded parameters for the liquidity modification based on the `ModifyLiquidityParams` struct.\n     * @return callerDelta The balance delta from the liquidity modification. This is the total of both principal and fee deltas.\n     * @return feesAccrued The balance delta of the fees generated in the liquidity range.\n     */\n    // slither-disable-next-line dead-code\n    function _modifyLiquidity(bytes memory params)\n        internal\n        virtual\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued)\n    {\n        (callerDelta, feesAccrued) = abi.decode(\n            poolManager.unlock(\n                abi.encode(CallbackData(msg.sender, abi.decode(params, (IPoolManager.ModifyLiquidityParams))))\n            ),\n            (BalanceDelta, BalanceDelta)\n        );\n    }\n\n    /**\n     * @dev Callback from the `PoolManager` when liquidity is modified, either adding or removing.\n     *\n     * @param rawData The encoded `CallbackData` struct.\n     * @return returnData The encoded caller and fees accrued deltas.\n     */\n    function unlockCallback(bytes calldata rawData)\n        external\n        virtual\n        override\n        onlyPoolManager\n        returns (bytes memory returnData)\n    {\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n        PoolKey memory key = poolKey;\n\n        // Set the salt value of the liquidity position, which is the keccak256 hash of the sender and salt from the callback data\n        // This ensures that each liquidity position is unique and cannot be accessed by other users\n        data.params.salt = keccak256(abi.encode(data.sender, data.params.salt));\n\n        // Get liquidity modification deltas\n        (BalanceDelta callerDelta, BalanceDelta feesAccrued) = poolManager.modifyLiquidity(key, data.params, \"\");\n\n        // Calculate the principal delta\n        BalanceDelta principalDelta = callerDelta - feesAccrued;\n\n        // Handle each currency amount based on its sign after applying the liquidity modification\n        if (principalDelta.amount0() < 0) {\n            // If amount0 is negative, send tokens from the sender to the pool\n            key.currency0.settle(poolManager, data.sender, uint256(int256(-principalDelta.amount0())), false);\n        } else {\n            // If amount0 is positive, send tokens from the pool to the sender\n            key.currency0.take(poolManager, data.sender, uint256(int256(principalDelta.amount0())), false);\n        }\n\n        if (principalDelta.amount1() < 0) {\n            // If amount1 is negative, send tokens from the sender to the pool\n            key.currency1.settle(poolManager, data.sender, uint256(int256(-principalDelta.amount1())), false);\n        } else {\n            // If amount1 is positive, send tokens from the pool to the sender\n            key.currency1.take(poolManager, data.sender, uint256(int256(principalDelta.amount1())), false);\n        }\n\n        // Handle any accrued fees (by default, transfer all fees to the sender)\n        _handleAccruedFees(data, callerDelta, feesAccrued);\n\n        // Return both deltas so that slippage checks can be done on the principal delta\n        return abi.encode(callerDelta, feesAccrued);\n    }\n\n    /**\n     * @dev Handle any fees accrued in a liquidity position. By default, this function transfers the tokens to the\n     * owner of the liquidity position. However, this function can be overriden to take fees accrued in the position,\n     * or any other desired logic.\n     *\n     * @param data The encoded `CallbackData` struct, including the sender and the parameters for the liquidity modification.\n     * @param callerDelta The balance delta from the liquidity modification.\n     * @param feesAccrued The balance delta of the fees generated in the liquidity range.\n     */\n    function _handleAccruedFees(CallbackData memory data, BalanceDelta callerDelta, BalanceDelta feesAccrued)\n        internal\n        virtual\n    {\n        // Send any accrued fees to the sender\n        poolKey.currency0.take(poolManager, data.sender, uint256(int256(feesAccrued.amount0())), false);\n        poolKey.currency1.take(poolManager, data.sender, uint256(int256(feesAccrued.amount1())), false);\n    }\n\n    /**\n     * @dev Initialize the hook's pool key. The stored key should act immutably so that\n     * it can safely be used across the hook's functions.\n     */\n    function _beforeInitialize(address, PoolKey calldata key, uint160) internal override returns (bytes4) {\n        // Check if the pool key is already initialized\n        if (address(poolKey.hooks) != address(0)) revert AlreadyInitialized();\n\n        // Store the pool key to be used in other functions\n        poolKey = key;\n        return this.beforeInitialize.selector;\n    }\n\n    /**\n     * @dev Revert when liquidity is attempted to be added via the `PoolManager`.\n     */\n    function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        override\n        returns (bytes4)\n    {\n        revert LiquidityOnlyViaHook();\n    }\n\n    /**\n     * @dev Revert when liquidity is attempted to be removed via the `PoolManager`.\n     */\n    function _beforeRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) internal virtual override returns (bytes4) {\n        revert LiquidityOnlyViaHook();\n    }\n\n    /**\n     * @dev Get the liquidity modification to apply for a given liquidity addition,\n     * and the amount of liquidity shares would be minted to the sender.\n     *\n     * @param sqrtPriceX96 The current square root price of the pool.\n     * @param params The parameters for the liquidity addition.\n     * @return modify The encoded parameters for the liquidity addition, which must follow the\n     * same encoding structure as in `_getRemoveLiquidity` and `_modifyLiquidity`.\n     * @return shares The liquidity shares to mint.\n     *\n     * IMPORTANT: The salt returned in `modify` indicates which position of the sender the liquidity\n     * modification is applied given that the `unlockCallback` function uses the keccak256 hash of\n     * the sender and the salt returned here to determine the liquidity position. By default, we\n     * recommend using the `userInputSalt` parameter from the `AddLiquidityParams` struct as the salt\n     * here.\n     */\n    function _getAddLiquidity(uint160 sqrtPriceX96, AddLiquidityParams memory params)\n        internal\n        virtual\n        returns (bytes memory modify, uint256 shares);\n\n    /**\n     * @dev Get the liquidity modification to apply for a given liquidity removal,\n     * and the amount of liquidity shares would be burned from the sender.\n     *\n     * @param params The parameters for the liquidity removal.\n     * @return modify The encoded parameters for the liquidity removal, which must follow the\n     * same encoding structure as in `_getAddLiquidity` and `_modifyLiquidity`.\n     * @return shares The liquidity shares to burn.\n     *\n     * IMPORTANT: The salt returned in `modify` indicates which position of the sender the liquidity\n     * modification is applied given that the `unlockCallback` function uses the keccak256 hash of\n     * the sender and the salt returned here to determine the liquidity position. By default, we\n     * recommend using the `userInputSalt` parameter from the `AddLiquidityParams` struct as the salt\n     * here.\n     */\n    function _getRemoveLiquidity(RemoveLiquidityParams memory params)\n        internal\n        virtual\n        returns (bytes memory modify, uint256 shares);\n\n    /**\n     * @dev Mint liquidity shares to the sender.\n     *\n     * @param params The parameters for the liquidity addition.\n     * @param callerDelta The balance delta from the liquidity addition. This is the total of both principal and fee delta.\n     * @param feesAccrued The balance delta of the fees generated in the liquidity range.\n     * @param shares The liquidity shares to mint.\n     */\n    function _mint(AddLiquidityParams memory params, BalanceDelta callerDelta, BalanceDelta feesAccrued, uint256 shares)\n        internal\n        virtual;\n\n    /**\n     * @dev Burn liquidity shares from the sender.\n     *\n     * @param params The parameters for the liquidity removal.\n     * @param callerDelta The balance delta from the liquidity removal. This is the total of both principal and fee delta.\n     * @param feesAccrued The balance delta of the fees generated in the liquidity range.\n     * @param shares The liquidity shares to burn.\n     */\n    function _burn(\n        RemoveLiquidityParams memory params,\n        BalanceDelta callerDelta,\n        BalanceDelta feesAccrued,\n        uint256 shares\n    ) internal virtual;\n\n    /**\n     * @dev Set the hook permissions, specifically `beforeInitialize`, `beforeAddLiquidity` and `beforeRemoveLiquidity`.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            beforeRemoveLiquidity: true,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n"
    }
}