{
    "vfp_id": "vfp_00165",
    "project_name": "Flare FAsset Review - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1285"
                ]
            },
            "title": "Payments before the first redemption block can be challenged",
            "description": "1. **Description:** Previously, an agent could submit a redemption request before the underlying payment was proven illegal, allowing them to exploit timing by anticipating the required payment reference and making transfers on the underlying chain early. This could prevent the system from correctly identifying and rejecting illegal payments.\n\n2. **Cause:** The vulnerability stemmed from the lack of a validation check ensuring that the payment on the underlying chain occurred on or after the firstUnderlyingBlock of the redemption request. Without this check, payments made too early could not be flagged as illegal.\n\n3. **Exploitation:** An attacker could submit a redemption request before the actual payment was made on the underlying chain, thereby bypassing the system's ability to prove the payment as illegal, potentially leading to unauthorized redemptions.\n\n4. **Impact:** This could result in incorrect redemption processing, undermining the integrity of the redemption mechanism and potentially allowing agents to extract value without fulfilling proper payment conditions.\n",
            "severity": "High",
            "location": [
                "ChallengesFacet.sol::redemptionActive#(unknown line)"
            ],
            "files": [
                "fassets/contracts/assetManager/facets/ChallengesFacet.sol"
            ]
        }
    ],
    "affected_files": {
        "ChallengesFacet.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IBalanceDecreasingTransaction} from \"@flarenetwork/flare-periphery-contracts/flare/IFdcVerification.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {AssetManagerBase} from \"./AssetManagerBase.sol\";\nimport {ReentrancyGuard} from \"../../openzeppelin/security/ReentrancyGuard.sol\";\nimport {AgentCollateral} from \"../library/AgentCollateral.sol\";\nimport {Agents} from \"../library/Agents.sol\";\nimport {AgentPayout} from \"../library/AgentPayout.sol\";\nimport {Conversion} from \"../library/Conversion.sol\";\nimport {Globals} from \"../library/Globals.sol\";\nimport {Liquidation} from \"../library/Liquidation.sol\";\nimport {Redemptions} from \"../library/Redemptions.sol\";\nimport {TransactionAttestation} from \"../library/TransactionAttestation.sol\";\nimport {UnderlyingBalance} from \"../library/UnderlyingBalance.sol\";\nimport {Agent} from \"../library/data/Agent.sol\";\nimport {AssetManagerState} from \"../library/data/AssetManagerState.sol\";\nimport {Collateral} from \"../library/data/Collateral.sol\";\nimport {PaymentConfirmations} from \"../library/data/PaymentConfirmations.sol\";\nimport {PaymentReference} from \"../library/data/PaymentReference.sol\";\nimport {Redemption} from \"../library/data/Redemption.sol\";\nimport {AssetManagerSettings} from \"../../userInterfaces/data/AssetManagerSettings.sol\";\nimport {IAssetManagerEvents} from \"../../userInterfaces/IAssetManagerEvents.sol\";\nimport {SafePct} from \"../../utils/library/SafePct.sol\";\n\n\ncontract ChallengesFacet is AssetManagerBase, ReentrancyGuard {\n    using SafeCast for uint256;\n    using SafePct for uint256;\n    using PaymentConfirmations for PaymentConfirmations.State;\n\n    error ChallengeNotAgentsAddress();\n    error ChallengeAlreadyLiquidating();\n    error ChallengeInvalidAgentStatus();\n    error ChallengeNotDuplicate();\n    error ChallengeTransactionAlreadyConfirmed();\n    error ChallengeSameTransactionRepeated();\n    error MatchingAnnouncedPaymentActive();\n    error MatchingRedemptionActive();\n    error MultiplePaymentsChallengeEnoughBalance();\n\n    /**\n     * Called with a proof of payment made from agent's underlying address, for which\n     * no valid payment reference exists (valid payment references are from redemption and\n     * underlying withdrawal announcement calls).\n     * On success, immediately triggers full agent liquidation and rewards the caller.\n     * @param _payment proof of a transaction from the agent's underlying address\n     * @param _agentVault agent vault address\n     */\n    function illegalPaymentChallenge(\n        IBalanceDecreasingTransaction.Proof calldata _payment,\n        address _agentVault\n    )\n        external\n        notFullyEmergencyPaused\n        nonReentrant\n    {\n        AssetManagerState.State storage state = AssetManagerState.get();\n        Agent.State storage agent = Agent.get(_agentVault);\n        _validateAgentStatus(agent);\n        // verify transaction\n        TransactionAttestation.verifyBalanceDecreasingTransaction(_payment);\n        // check the payment originates from agent's address\n        require(_payment.data.responseBody.sourceAddressHash == agent.underlyingAddressHash,\n            ChallengeNotAgentsAddress());\n        // check that proof of this tx wasn't used before - otherwise we could\n        // trigger liquidation for already proved redemption payments\n        require(!state.paymentConfirmations.transactionConfirmed(_payment), ChallengeTransactionAlreadyConfirmed());\n        // check that payment reference is invalid (paymentReference == 0 is always invalid payment)\n        bytes32 paymentReference = _payment.data.responseBody.standardPaymentReference;\n        if (paymentReference != 0) {\n            if (PaymentReference.isValid(paymentReference, PaymentReference.REDEMPTION)) {\n                uint256 redemptionId = PaymentReference.decodeId(paymentReference);\n                Redemption.Request storage redemption = state.redemptionRequests[redemptionId];\n                // Redemption must be for the correct agent, must not be rejected and\n                // only statuses ACTIVE and DEFAULTED mean that redemption is still missing a payment proof.\n                // Payments must not be made before the current underlying block when redemption was requested.\n                // We do not check that the payment is not too late, because on UTXO chains legal payments can be\n                // delayed by arbitrary time due to high fees and cannot be canceled, which could lead to\n                // unnecessary full liquidations.\n                bool redemptionActive = redemption.agentVault == _agentVault\n                    && Redemptions.isOpen(redemption)\n                    && _payment.data.responseBody.blockNumber >= redemption.firstUnderlyingBlock;\n                require(!redemptionActive, MatchingRedemptionActive());\n            }\n            if (PaymentReference.isValid(paymentReference, PaymentReference.ANNOUNCED_WITHDRAWAL)) {\n                uint256 announcementId = PaymentReference.decodeId(paymentReference);\n                // valid announced withdrawal cannot have announcementId == 0 and must match the agent's announced id\n                // but PaymentReference.isValid already checks that id in the reference != 0, so no extra check needed\n                require(announcementId != agent.announcedUnderlyingWithdrawalId, MatchingAnnouncedPaymentActive());\n            }\n        }\n        // start liquidation and reward challengers\n        _liquidateAndRewardChallenger(agent, msg.sender, agent.mintedAMG);\n        // emit events\n        emit IAssetManagerEvents.IllegalPaymentConfirmed(_agentVault, _payment.data.requestBody.transactionId);\n    }\n\n    /**\n     * Called with proofs of two payments made from agent's underlying address\n     * with the same payment reference (each payment reference is valid for only one payment).\n     * On success, immediately triggers full agent liquidation and rewards the caller.\n     * @param _payment1 proof of first payment from the agent's underlying address\n     * @param _payment2 proof of second payment from the agent's underlying address\n     * @param _agentVault agent vault address\n     */\n    function doublePaymentChallenge(\n        IBalanceDecreasingTransaction.Proof calldata _payment1,\n        IBalanceDecreasingTransaction.Proof calldata _payment2,\n        address _agentVault\n    )\n        external\n        notFullyEmergencyPaused\n        nonReentrant\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        _validateAgentStatus(agent);\n        // verify transactions\n        TransactionAttestation.verifyBalanceDecreasingTransaction(_payment1);\n        TransactionAttestation.verifyBalanceDecreasingTransaction(_payment2);\n        // check the payments are unique and originate from agent's address\n        require(_payment1.data.requestBody.transactionId != _payment2.data.requestBody.transactionId,\n            ChallengeSameTransactionRepeated());\n        require(_payment1.data.responseBody.sourceAddressHash == agent.underlyingAddressHash,\n            ChallengeNotAgentsAddress());\n        require(_payment2.data.responseBody.sourceAddressHash == agent.underlyingAddressHash,\n            ChallengeNotAgentsAddress());\n        // payment references must be equal\n        require(_payment1.data.responseBody.standardPaymentReference ==\n            _payment2.data.responseBody.standardPaymentReference, ChallengeNotDuplicate());\n        // ! no need to check that transaction wasn't confirmed - this is always illegal\n        // start liquidation and reward challengers\n        _liquidateAndRewardChallenger(agent, msg.sender, agent.mintedAMG);\n        // emit events\n        emit IAssetManagerEvents.DuplicatePaymentConfirmed(_agentVault, _payment1.data.requestBody.transactionId,\n            _payment2.data.requestBody.transactionId);\n    }\n\n    /**\n     * Called with proofs of several (otherwise legal) payments, which together make agent's\n     * underlying free balance negative (i.e. the underlying address balance is less than\n     * the total amount of backed f-assets).\n     * On success, immediately triggers full agent liquidation and rewards the caller.\n     * @param _payments proofs of several distinct payments from the agent's underlying address\n     * @param _agentVault agent vault address\n     */\n    function freeBalanceNegativeChallenge(\n        IBalanceDecreasingTransaction.Proof[] calldata _payments,\n        address _agentVault\n    )\n        external\n        notFullyEmergencyPaused\n        nonReentrant\n    {\n        AssetManagerState.State storage state = AssetManagerState.get();\n        Agent.State storage agent = Agent.get(_agentVault);\n        _validateAgentStatus(agent);\n        // check the payments originates from agent's address, are not confirmed already and calculate total\n        int256 total = 0;\n        for (uint256 i = 0; i < _payments.length; i++) {\n            IBalanceDecreasingTransaction.Proof calldata pmi = _payments[i];\n            TransactionAttestation.verifyBalanceDecreasingTransaction(pmi);\n            // check there are no duplicate transactions\n            for (uint256 j = 0; j < i; j++) {\n                require(_payments[j].data.requestBody.transactionId != pmi.data.requestBody.transactionId,\n                    ChallengeSameTransactionRepeated());\n            }\n            require(pmi.data.responseBody.sourceAddressHash == agent.underlyingAddressHash,\n                ChallengeNotAgentsAddress());\n            if (state.paymentConfirmations.transactionConfirmed(pmi)) {\n                continue;   // ignore payments that have already been confirmed\n            }\n            bytes32 paymentReference = pmi.data.responseBody.standardPaymentReference;\n            if (PaymentReference.isValid(paymentReference, PaymentReference.REDEMPTION)) {\n                // for open redemption, we don't count the value that should be paid to free balance deduction.\n                // Note that we don't need to check that the redemption is for this agent, because payments\n                // with redemption reference for other agent can be immediatelly challenged as illegal.\n                uint256 redemptionId = PaymentReference.decodeId(pmi.data.responseBody.standardPaymentReference);\n                Redemption.Request storage request = state.redemptionRequests[redemptionId];\n                uint256 redemptionValue = Redemptions.isOpen(request) ? request.underlyingValueUBA : 0;\n                total += pmi.data.responseBody.spentAmount - SafeCast.toInt256(redemptionValue);\n            } else {\n                // for other payment types (announced withdrawal), everything is paid from free balance\n                total += pmi.data.responseBody.spentAmount;\n            }\n        }\n        // check that total spent free balance is more than actual free underlying balance\n        int256 balanceAfterPayments = agent.underlyingBalanceUBA - total;\n        uint256 requiredBalance = UnderlyingBalance.requiredUnderlyingUBA(agent);\n        require(balanceAfterPayments < requiredBalance.toInt256(), MultiplePaymentsChallengeEnoughBalance());\n        // start liquidation and reward challengers\n        _liquidateAndRewardChallenger(agent, msg.sender, agent.mintedAMG);\n        // emit events\n        emit IAssetManagerEvents.UnderlyingBalanceTooLow(_agentVault, balanceAfterPayments, requiredBalance);\n    }\n\n    function _validateAgentStatus(Agent.State storage _agent)\n        private view\n    {\n        // If the agent is already being fully liquidated, no need for more challenges; this also prevents\n        // double challenges.\n        Agent.Status status = _agent.status;\n        require(status != Agent.Status.FULL_LIQUIDATION, ChallengeAlreadyLiquidating());\n        // For agents in status destroying, the challenges are pointless (but would still reward the\n        // challenger, so they are better forbidden).\n        require(status != Agent.Status.DESTROYING, ChallengeInvalidAgentStatus());\n    }\n\n    function _liquidateAndRewardChallenger(\n        Agent.State storage _agent,\n        address _challenger,\n        uint256 _backingAMGAtChallenge\n    )\n        private\n    {\n        AssetManagerSettings.Data storage settings = Globals.getSettings();\n        // start full liquidation\n        Liquidation.startFullLiquidation(_agent);\n        // calculate the reward\n        Collateral.Data memory collateralData =\n            AgentCollateral.agentVaultCollateralData(_agent);\n        uint256 rewardAMG = _backingAMGAtChallenge.mulBips(settings.paymentChallengeRewardBIPS);\n        uint256 rewardC1Wei = Conversion.convertAmgToTokenWei(rewardAMG, collateralData.amgToTokenWeiPrice)\n            + Agents.convertUSD5ToVaultCollateralWei(_agent, settings.paymentChallengeRewardUSD5);\n        AgentPayout.payoutFromVault(_agent, _challenger, rewardC1Wei);\n    }\n}"
    }
}