{
    "vfp_id": "vfp_00253",
    "project_name": "cantina_eco_february2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-172"
                ]
            },
            "title": "ERC-7683 intents can never be filled because of an incorrectly encoded contract address",
            "description": "The Eco7683OriginSettler contract incorrectly sets the `FillInstruction.destinationSettler` field by using `bytes20(uint160(Eco7683DestinationSettler))`, which does not resolve to the correct contract address. This breaks the ERC-7683 compliance, as the destination settler address must point to a contract that implements the `fill()` function.\n\nThe cause is a hardcoded or incorrectly referenced address in the struct assignment, which results in the `destinationSettler` pointing to an invalid or non-existent contract on the destination chain.\n\nWhen an ERC-7683-aware filler attempts to fill an intent, it calls the `fill()` function on the address specified in `destinationSettler`. Since this address does not implement the required function, the call reverts, making it impossible to fulfill any ERC-7683-compliant intent.\n\nThe impact is high because it renders the entire ERC-7683 integration non-functional, preventing interoperability with external fillers and limiting the protocol's utility.\n",
            "severity": "High",
            "location": [
                "Eco7683OriginSettler.sol#L186-L190",
                "Eco7683OriginSettler.sol#L280-L282",
                "ERC7683.sol#L96"
            ],
            "files": [
                "eco-routes/contracts/Eco7683OriginSettler.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing enforcement of route.destination check may allow fillers to solve intents on other supported chains",
            "description": "The protocol does not enforce that `route.destination` matches the current chain ID (`block.chainid`) in either `Eco7683DestinationSettler.fill()` or `Inbox._fulfill()`. This allows fillers to fulfill intents on chains different from the intended destination, as long as the required contracts exist at the same addresses.\n\nThe cause is the absence of a validation check comparing `route.destination` with `block.chainid`, which is a critical security control for cross-chain systems.\n\nAn attacker can exploit this by fulfilling an intent on a different chain than specified, potentially leading to unexpected outcomes such as incorrect asset transfers or arbitrage manipulation. This is especially dangerous for native gas tokens, where the economic impact is direct.\n\nThe impact is high for native tokens due to potential profit from misrouted intents, and lower for ERC20s depending on address consistency across chains. However, it violates the expected behavior of cross-chain routing and undermines system integrity.\n",
            "severity": "High",
            "location": [
                "Eco7683DestinationSettler.sol#L46-L107",
                "Inbox.sol#L380-L446"
            ],
            "files": [
                "eco-routes/contracts/Eco7683DestinationSettler.sol",
                "eco-routes/contracts/Inbox.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Missing enforcement of openDeadline check breaks ERC-7683 requirement and user expectations",
            "description": "The `openFor()` function in `Eco7683OriginSettler` does not enforce the `openDeadline` timestamp, which is a required field in the `GaslessCrossChainOrder` struct per ERC-7683. This allows fillers to open intents beyond the user-specified deadline.\n\nThe cause is the omission of a `block.timestamp <= openDeadline` check in the `openFor()` function, which should be present to comply with the standard and protect user intent validity.\n\nAn attacker or careless filler can exploit this by opening time-sensitive intents (e.g., arbitrage opportunities) after the intended deadline, potentially capturing value that should no longer be available.\n\nThe impact is medium, as it primarily affects time-sensitive intents and may lead to user dissatisfaction or financial loss in specific scenarios, but does not result in direct fund loss from the protocol.\n",
            "severity": "Medium",
            "location": [
                "Eco7683OriginSettler.sol#L88-L122",
                "Eco7683OriginSettler.sol#L211",
                "Eco7683OriginSettler.sol#L310"
            ],
            "files": [
                "eco-routes/contracts/Eco7683OriginSettler.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing enforcement of fillDeadline check breaks ERC-7683 requirement and may lead to loss of filler rewards",
            "description": "The `fill()` function in `Eco7683DestinationSettler` does not enforce the `fillDeadline` check against `block.timestamp`, allowing fillers to attempt fulfillment after the deadline has passed. Although rewards are not claimable due to checks in `withdrawRewards()`, the filler still incurs gas costs for a futile transaction.\n\nThe root cause is the lack of a defensive `block.timestamp <= order.fillDeadline` check in the `fill()` function, which is required by ERC-7683 and necessary for user and filler protection.\n\nA filler may accidentally or intentionally call `fill()` after the deadline. While the protocol eventually prevents reward withdrawal, the filler loses gas and time due to the missing early validation.\n\nThe impact is medium, as it breaks ERC-7683 compliance and may lead to economic loss for fillers, though funds are not permanently lost from the system.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "eco-routes/contracts/Eco7683DestinationSettler.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-116"
                ]
            },
            "title": "ERC-7683 intents can never be filled because of incorrectly encoded originData",
            "description": "The `resolve()` and `resolveFor()` functions in `Eco7683OriginSettler` incorrectly encode `onchainCrosschainOrderData.route.calls[j]` into `FillInstruction.originData`, instead of the full `onchainCrosschainOrderData` struct. This causes the `Eco7683DestinationSettler.fill()` function to fail when attempting to decode the data.\n\nThe cause is a logic error in data serialization, where only a subset of the required data is encoded, violating the expected format defined in ERC-7683.\n\nWhen a filler calls `fill()` on the destination chain, the contract attempts to decode `originData` as a full `OnchainCrosschainOrderData` struct, but receives only a fragment, leading to decoding failure and transaction revert.\n\nThe impact is medium, as it prevents ERC-7683-compliant intents from being fulfilled, reducing interoperability. However, sophisticated fillers might work around it by re-encoding correctly.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "eco-routes/contracts/Eco7683OriginSettler.sol",
                "eco-routes/contracts/Eco7683DestinationSettler.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing nonce tracking in EIP-7683 integration allows for duplicate intent openings",
            "description": "The `openFor()` function in `Eco7683OriginSettler` does not track or validate nonces, allowing a relayer to reuse a valid user signature to open the same intent multiple times.\n\nThe nonce is used only as a salt in the `Route` struct but is not stored or checked for uniqueness, enabling replay attacks.\n\nA malicious relayer can obtain a single signature and repeatedly call `openFor()` to create duplicate intents, potentially draining user funds or causing unintended side effects.\n\nThe impact is medium, as users may lose excess funds transferred, though they can eventually recover them. The likelihood is low due to specific conditions required for exploitation.\n",
            "severity": "Medium",
            "location": [
                "Eco7683OriginSettler.sol#L319-L339"
            ],
            "files": [
                "eco-routes/contracts/Eco7683OriginSettler.sol"
            ]
        }
    ],
    "affected_files": {
        "Eco7683DestinationSettler.sol": "/* -*- c-basic-offset: 4 -*- */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {OnchainCrossChainOrder, ResolvedCrossChainOrder, GaslessCrossChainOrder, Output, FillInstruction} from \"./types/ERC7683.sol\";\nimport {IOriginSettler} from \"./interfaces/ERC7683/IOriginSettler.sol\";\nimport {IDestinationSettler} from \"./interfaces/ERC7683/IDestinationSettler.sol\";\nimport {Intent, Reward, Route, TokenAmount} from \"./types/Intent.sol\";\nimport {IntentSource} from \"./IntentSource.sol\";\nimport {IProver} from \"./interfaces/IProver.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nabstract contract Eco7683DestinationSettler is IDestinationSettler {\n    using ECDSA for bytes32;\n\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev _originData is of type OnchainCrossChainOrder\n     * @dev _fillerData is encoded bytes consisting of the uint256 prover type and the address claimant if the prover type is Storage (0)\n     * and the address claimant, the address postDispatchHook, and the bytes metadata if the prover type is Hyperlane (1)\n     * @param _orderId Unique order identifier for this order\n     * @param _originData Data emitted on the origin to parameterize the fill: an encoded Intent struct, or the originData from the fillInstruction of the ResolvedCrossChainOrder\n     * @param _fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(\n        bytes32 _orderId,\n        bytes calldata _originData,\n        bytes calldata _fillerData\n    ) external payable {\n        Intent memory intent = abi.decode(_originData, (Intent));\n        if (block.timestamp > intent.reward.deadline) {\n            revert FillDeadlinePassed();\n        }\n\n        emit OrderFilled(_orderId, msg.sender);\n\n        bytes32 rewardHash = keccak256(abi.encode(intent.reward));\n        IProver.ProofType proofType = abi.decode(\n            _fillerData,\n            (IProver.ProofType)\n        );\n        if (proofType == IProver.ProofType.Storage) {\n            (, address claimant) = abi.decode(\n                _fillerData,\n                (IProver.ProofType, address)\n            );\n            fulfillStorage(intent.route, rewardHash, claimant, _orderId);\n        } else if (proofType == IProver.ProofType.Hyperlane) {\n            (\n                ,\n                address claimant,\n                address postDispatchHook,\n                bytes memory metadata\n            ) = abi.decode(\n                    _fillerData,\n                    (IProver.ProofType, address, address, bytes)\n                );\n            fulfillHyperInstantWithRelayer(\n                intent.route,\n                rewardHash,\n                claimant,\n                _orderId,\n                intent.reward.prover,\n                metadata,\n                postDispatchHook\n            );\n        }\n    }\n\n    function fulfillStorage(\n        Route memory _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash\n    ) public payable virtual returns (bytes[] memory);\n\n    function fulfillHyperInstantWithRelayer(\n        Route memory _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash,\n        address _prover,\n        bytes memory _metadata,\n        address _postDispatchHook\n    ) public payable virtual returns (bytes[] memory);\n}\n",
        "Eco7683OriginSettler.sol": "/* -*- c-basic-offset: 4 -*- */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {OnchainCrossChainOrder, ResolvedCrossChainOrder, GaslessCrossChainOrder, Output, FillInstruction} from \"./types/ERC7683.sol\";\nimport {IOriginSettler} from \"./interfaces/ERC7683/IOriginSettler.sol\";\nimport {Intent, Reward, Route, Call, TokenAmount} from \"./types/Intent.sol\";\nimport {OnchainCrosschainOrderData, GaslessCrosschainOrderData, ONCHAIN_CROSSCHAIN_ORDER_DATA_TYPEHASH, GASLESS_CROSSCHAIN_ORDER_DATA_TYPEHASH} from \"./types/EcoERC7683.sol\";\nimport {IntentSource} from \"./IntentSource.sol\";\nimport {Semver} from \"./libs/Semver.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Eco7683OriginSettler\n * @notice Entry point to Eco Protocol via EIP-7683\n * @dev functionality is somewhat limited compared to interacting with Eco Protocol directly\n */\ncontract Eco7683OriginSettler is IOriginSettler, Semver, EIP712 {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n\n    /// @notice typehash for gasless crosschain _order\n    bytes32 public GASLESS_CROSSCHAIN_ORDER_TYPEHASH =\n        keccak256(\n            \"GaslessCrossChainOrder(address originSettler,address user,uint256 nonce,uint256 originChainId,uint32 openDeadline,uint32 fillDeadline,bytes32 orderDataType,bytes32 orderDataHash)\"\n        );\n\n    /// @notice address of IntentSource contract where intents are actually published\n    address public immutable INTENT_SOURCE;\n\n    /**\n     * @notice Initializes the Eco7683OriginSettler\n     * @param _name the name of the contract for EIP712\n     * @param _version the version of the contract for EIP712\n     * @param _intentSource the address of the IntentSource contract\n     */\n    constructor(\n        string memory _name,\n        string memory _version,\n        address _intentSource\n    ) EIP712(_name, _version) {\n        INTENT_SOURCE = _intentSource;\n    }\n\n    /**\n     * @notice Opens an Eco intent directly on chain\n     * @dev to be called by the user\n     * @dev assumes user has erc20 funds approved for the intent, and includes any reward native token in msg.value\n     * @dev transfers the reward tokens at time of open\n     * @param _order the OnchainCrossChainOrder that will be opened as an eco intent\n     */\n    function open(\n        OnchainCrossChainOrder calldata _order\n    ) external payable override {\n        if (_order.orderDataType != ONCHAIN_CROSSCHAIN_ORDER_DATA_TYPEHASH) {\n            revert TypeSignatureMismatch();\n        }\n\n        OnchainCrosschainOrderData memory onchainCrosschainOrderData = abi\n            .decode(_order.orderData, (OnchainCrosschainOrderData));\n\n        if (onchainCrosschainOrderData.route.source != block.chainid) {\n            revert OriginChainIDMismatch();\n        }\n\n        Intent memory intent = Intent(\n            onchainCrosschainOrderData.route,\n            Reward(\n                onchainCrosschainOrderData.creator,\n                onchainCrosschainOrderData.prover,\n                _order.fillDeadline,\n                onchainCrosschainOrderData.nativeValue,\n                onchainCrosschainOrderData.rewardTokens\n            )\n        );\n\n        bytes32 orderId = _openEcoIntent(intent, msg.sender);\n\n        emit Open(orderId, resolve(_order));\n    }\n\n    /**\n     * @notice Opens an Eco intent on behalf of a user\n     * @notice This method is made payable in the event that the caller of this method (a solver) wants to open\n     * an intent that has native token as a reward. In this case, the solver would need to send the native\n     * token as part of the transaction. How the intent's creator pays the solver is not covered by this method.\n     * @dev to be called by the intent's solver\n     * @dev assumes user has erc20 funds approved for the intent, and includes any reward native token in msg.value\n     * @dev transfers the reward tokens at time of open\n     * @param _order the GaslessCrossChainOrder that will be opened as an eco intent\n     * @param _signature the signature of the user authorizing the intent to be opened\n     * @param _originFillerData filler data for the origin chain (vestigial, not used)\n     */\n    function openFor(\n        GaslessCrossChainOrder calldata _order,\n        bytes calldata _signature,\n        bytes calldata _originFillerData\n    ) external payable override {\n        if (block.timestamp > _order.openDeadline) {\n            revert OpenDeadlinePassed();\n        }\n        if (!_verifyOpenFor(_order, _signature)) {\n            revert BadSignature();\n        }\n\n        if (_order.orderDataType != GASLESS_CROSSCHAIN_ORDER_DATA_TYPEHASH) {\n            revert TypeSignatureMismatch();\n        }\n\n        GaslessCrosschainOrderData memory gaslessCrosschainOrderData = abi\n            .decode(_order.orderData, (GaslessCrosschainOrderData));\n\n        if (_order.originChainId != block.chainid) {\n            revert OriginChainIDMismatch();\n        }\n\n        Intent memory intent = Intent(\n            Route(\n                bytes32(_order.nonce),\n                _order.originChainId,\n                gaslessCrosschainOrderData.destination,\n                gaslessCrosschainOrderData.inbox,\n                gaslessCrosschainOrderData.routeTokens,\n                gaslessCrosschainOrderData.calls\n            ),\n            Reward(\n                _order.user,\n                gaslessCrosschainOrderData.prover,\n                _order.fillDeadline,\n                gaslessCrosschainOrderData.nativeValue,\n                gaslessCrosschainOrderData.rewardTokens\n            )\n        );\n\n        bytes32 orderId = _openEcoIntent(intent, _order.user);\n\n        emit Open(orderId, resolveFor(_order, _originFillerData));\n    }\n\n    /**\n     * @notice resolves an OnchainCrossChainOrder to a ResolvedCrossChainOrder\n     * @param _order the OnchainCrossChainOrder to be resolved\n     */\n    function resolve(\n        OnchainCrossChainOrder calldata _order\n    ) public view override returns (ResolvedCrossChainOrder memory) {\n        OnchainCrosschainOrderData memory onchainCrosschainOrderData = abi\n            .decode(_order.orderData, (OnchainCrosschainOrderData));\n        uint256 routeTokenCount = onchainCrosschainOrderData\n            .route\n            .tokens\n            .length;\n        Output[] memory maxSpent = new Output[](routeTokenCount);\n        for (uint256 i = 0; i < routeTokenCount; ++i) {\n            TokenAmount memory approval = onchainCrosschainOrderData\n                .route\n                .tokens[i];\n            maxSpent[i] = Output(\n                bytes32(uint256(uint160(approval.token))),\n                approval.amount,\n                bytes32(uint256(uint160(address(0)))), //filler is not known\n                onchainCrosschainOrderData.route.destination\n            );\n        }\n        uint256 rewardTokenCount = onchainCrosschainOrderData\n            .rewardTokens\n            .length;\n        Output[] memory minReceived = new Output[](\n            rewardTokenCount +\n                (onchainCrosschainOrderData.nativeValue > 0 ? 1 : 0)\n        ); //rewards are fixed\n\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            minReceived[i] = Output(\n                bytes32(\n                    uint256(\n                        uint160(\n                            onchainCrosschainOrderData.rewardTokens[i].token\n                        )\n                    )\n                ),\n                onchainCrosschainOrderData.rewardTokens[i].amount,\n                bytes32(uint256(uint160(address(0)))), //filler is not known\n                onchainCrosschainOrderData.route.destination\n            );\n        }\n        if (onchainCrosschainOrderData.nativeValue > 0) {\n            minReceived[rewardTokenCount] = Output(\n                bytes32(uint256(uint160(address(0)))),\n                onchainCrosschainOrderData.nativeValue,\n                bytes32(uint256(uint160(address(0)))),\n                onchainCrosschainOrderData.route.destination\n            );\n        }\n\n        Intent memory intent = Intent(\n            onchainCrosschainOrderData.route,\n            Reward(\n                onchainCrosschainOrderData.creator,\n                onchainCrosschainOrderData.prover,\n                _order.fillDeadline,\n                onchainCrosschainOrderData.nativeValue,\n                onchainCrosschainOrderData.rewardTokens\n            )\n        );\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        fillInstructions[0] = FillInstruction(\n            uint64(onchainCrosschainOrderData.route.destination),\n            bytes32(uint256(uint160(onchainCrosschainOrderData.route.inbox))),\n            abi.encode(intent)\n        );\n\n        (bytes32 intentHash, , ) = IntentSource(INTENT_SOURCE).getIntentHash(\n            intent\n        );\n        return\n            ResolvedCrossChainOrder(\n                onchainCrosschainOrderData.creator,\n                onchainCrosschainOrderData.route.source,\n                _order.fillDeadline,\n                _order.fillDeadline,\n                intentHash,\n                maxSpent,\n                minReceived,\n                fillInstructions\n            );\n    }\n\n    /**\n     * @notice resolves GaslessCrossChainOrder to a ResolvedCrossChainOrder\n     * @param _order the GaslessCrossChainOrder to be resolved\n     * param _originFillerData filler data for the origin chain (not used)\n     */\n    function resolveFor(\n        GaslessCrossChainOrder calldata _order,\n        bytes calldata // _originFillerData keeping it for purpose of interface\n    ) public view override returns (ResolvedCrossChainOrder memory) {\n        GaslessCrosschainOrderData memory gaslessCrosschainOrderData = abi\n            .decode(_order.orderData, (GaslessCrosschainOrderData));\n        uint256 routeTokenCount = gaslessCrosschainOrderData.routeTokens.length;\n        Output[] memory maxSpent = new Output[](routeTokenCount);\n        for (uint256 i = 0; i < routeTokenCount; ++i) {\n            TokenAmount memory requirement = gaslessCrosschainOrderData\n                .routeTokens[i];\n            maxSpent[i] = Output(\n                bytes32(uint256(uint160(requirement.token))),\n                requirement.amount,\n                bytes32(uint256(uint160(address(0)))), //filler is not known\n                gaslessCrosschainOrderData.destination\n            );\n        }\n        uint256 rewardTokenCount = gaslessCrosschainOrderData\n            .rewardTokens\n            .length;\n        Output[] memory minReceived = new Output[](\n            rewardTokenCount +\n                (gaslessCrosschainOrderData.nativeValue > 0 ? 1 : 0)\n        ); //rewards are fixed\n\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            minReceived[i] = Output(\n                bytes32(\n                    uint256(\n                        uint160(\n                            gaslessCrosschainOrderData.rewardTokens[i].token\n                        )\n                    )\n                ),\n                gaslessCrosschainOrderData.rewardTokens[i].amount,\n                bytes32(uint256(uint160(address(0)))), //filler is not known\n                gaslessCrosschainOrderData.destination\n            );\n        }\n        if (gaslessCrosschainOrderData.nativeValue > 0) {\n            minReceived[rewardTokenCount] = Output(\n                bytes32(uint256(uint160(address(0)))),\n                gaslessCrosschainOrderData.nativeValue,\n                bytes32(uint256(uint160(address(0)))),\n                gaslessCrosschainOrderData.destination\n            );\n        }\n\n        Intent memory intent = Intent(\n            Route(\n                bytes32(_order.nonce),\n                _order.originChainId,\n                gaslessCrosschainOrderData.destination,\n                gaslessCrosschainOrderData.inbox,\n                gaslessCrosschainOrderData.routeTokens,\n                gaslessCrosschainOrderData.calls\n            ),\n            Reward(\n                _order.user,\n                gaslessCrosschainOrderData.prover,\n                _order.fillDeadline,\n                gaslessCrosschainOrderData.nativeValue,\n                gaslessCrosschainOrderData.rewardTokens\n            )\n        );\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        fillInstructions[0] = FillInstruction(\n            uint64(gaslessCrosschainOrderData.destination),\n            bytes32(uint256(uint160(gaslessCrosschainOrderData.inbox))),\n            abi.encode(intent)\n        );\n\n        (bytes32 intentHash, , ) = IntentSource(INTENT_SOURCE).getIntentHash(\n            intent\n        );\n        return\n            ResolvedCrossChainOrder(\n                _order.user,\n                _order.originChainId,\n                _order.openDeadline,\n                _order.fillDeadline,\n                intentHash,\n                maxSpent,\n                minReceived,\n                fillInstructions\n            );\n    }\n\n    /// @notice helper method for signature verification\n    function _verifyOpenFor(\n        GaslessCrossChainOrder calldata _order,\n        bytes calldata _signature\n    ) internal view returns (bool) {\n        if (_order.originSettler != address(this)) {\n            return false;\n        }\n        bytes32 structHash = keccak256(\n            abi.encode(\n                GASLESS_CROSSCHAIN_ORDER_TYPEHASH,\n                _order.originSettler,\n                _order.user,\n                _order.nonce,\n                _order.originChainId,\n                _order.openDeadline,\n                _order.fillDeadline,\n                _order.orderDataType,\n                keccak256(_order.orderData)\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n        address signer = hash.recover(_signature);\n\n        return signer == _order.user;\n    }\n\n    /// @notice helper method that actually opens the intent\n    function _openEcoIntent(\n        Intent memory _intent,\n        address _user\n    ) internal returns (bytes32 intentHash) {\n        if (!IntentSource(INTENT_SOURCE).isIntentFunded(_intent)) {\n            address vault = IntentSource(INTENT_SOURCE).intentVaultAddress(\n                _intent\n            );\n\n            if (_intent.reward.nativeValue > 0) {\n                if (msg.value < _intent.reward.nativeValue) {\n                    revert InsufficientNativeReward();\n                }\n\n                payable(vault).transfer(_intent.reward.nativeValue);\n            }\n            uint256 rewardsLength = _intent.reward.tokens.length;\n            for (uint256 i = 0; i < rewardsLength; ++i) {\n                address token = _intent.reward.tokens[i].token;\n                uint256 amount = _intent.reward.tokens[i].amount;\n\n                IERC20(token).safeTransferFrom(_user, vault, amount);\n            }\n        }\n\n        payable(msg.sender).transfer(address(this).balance);\n\n        return IntentSource(INTENT_SOURCE).publish(_intent);\n    }\n\n    /// @notice EIP712 domain separator\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n",
        "Inbox.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IMailbox, IPostDispatchHook} from \"@hyperlane-xyz/core/contracts/interfaces/IMailbox.sol\";\nimport {Eco7683DestinationSettler} from \"./Eco7683DestinationSettler.sol\";\nimport {TypeCasts} from \"@hyperlane-xyz/core/contracts/libs/TypeCasts.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IInbox} from \"./interfaces/IInbox.sol\";\nimport {Intent, Route, Call, TokenAmount} from \"./types/Intent.sol\";\nimport {Semver} from \"./libs/Semver.sol\";\n\n/**\n * @title Inbox\n * @notice Main entry point for fulfilling intents\n * @dev Validates intent hash authenticity and executes calldata. Enables provers\n * to claim rewards on the source chain by checking the fulfilled mapping\n */\ncontract Inbox is IInbox, Eco7683DestinationSettler, Ownable, Semver {\n    using TypeCasts for address;\n    using SafeERC20 for IERC20;\n\n    // Mapping of intent hash on the src chain to its fulfillment\n    mapping(bytes32 => address) public fulfilled;\n\n    // Mapping of solvers to if they are whitelisted\n    mapping(address => bool) public solverWhitelist;\n\n    // address of local hyperlane mailbox\n    address public mailbox;\n\n    // Is solving public\n    bool public isSolvingPublic;\n\n    /**\n     * @notice Initializes the Inbox contract\n     * @param _owner Address with access to privileged functions\n     * @param _isSolvingPublic Whether solving is public at start\n     * @param _solvers Initial whitelist of solvers (only relevant if solving is not public)\n     */\n    constructor(\n        address _owner,\n        bool _isSolvingPublic,\n        address[] memory _solvers\n    ) Ownable(_owner) {\n        isSolvingPublic = _isSolvingPublic;\n        for (uint256 i = 0; i < _solvers.length; ++i) {\n            solverWhitelist[_solvers[i]] = true;\n            emit SolverWhitelistChanged(_solvers[i], true);\n        }\n    }\n\n    /**\n     * @notice Fulfills an intent to be proven via storage proofs\n     * @param _route The route of the intent\n     * @param _rewardHash The hash of the reward\n     * @param _claimant The address that will receive the reward on the source chain\n     * @param _expectedHash The hash of the intent as created on the source chain\n     * @return Array of execution results from each call\n     */\n    function fulfillStorage(\n        Route memory _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash\n    )\n        public\n        payable\n        override(IInbox, Eco7683DestinationSettler)\n        returns (bytes[] memory)\n    {\n        bytes[] memory result = _fulfill(\n            _route,\n            _rewardHash,\n            _claimant,\n            _expectedHash\n        );\n\n        emit ToBeProven(_expectedHash, _route.source, _claimant);\n\n        return result;\n    }\n\n    /**\n     * @notice Fulfills an intent to be proven immediately via Hyperlane's mailbox\n     * @dev More expensive but faster than hyperbatched. Requires fee for Hyperlane infrastructure\n     * @param _route The route of the intent\n     * @param _rewardHash The hash of the reward\n     * @param _claimant The address that will receive the reward on the source chain\n     * @param _expectedHash The hash of the intent as created on the source chain\n     * @param _prover The address of the hyperprover on the source chain\n     * @return Array of execution results from each call\n     */\n    function fulfillHyperInstant(\n        Route memory _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash,\n        address _prover\n    ) external payable returns (bytes[] memory) {\n        return\n            fulfillHyperInstantWithRelayer(\n                _route,\n                _rewardHash,\n                _claimant,\n                _expectedHash,\n                _prover,\n                bytes(\"\"),\n                address(0)\n            );\n    }\n\n    /**\n     * @notice Fulfills an intent to be proven immediately via Hyperlane's mailbox with relayer support\n     * @dev More expensive but faster than hyperbatched. Requires fee for Hyperlane infrastructure\n     * @param _route The route of the intent\n     * @param _rewardHash The hash of the reward\n     * @param _claimant The address that will receive the reward on the source chain\n     * @param _expectedHash The hash of the intent as created on the source chain\n     * @param _prover The address of the hyperprover on the source chain\n     * @param _metadata Metadata for postDispatchHook (empty bytes if not applicable)\n     * @param _postDispatchHook Address of postDispatchHook (zero address if not applicable)\n     * @return Array of execution results from each call\n     */\n    function fulfillHyperInstantWithRelayer(\n        Route memory _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash,\n        address _prover,\n        bytes memory _metadata,\n        address _postDispatchHook\n    )\n        public\n        payable\n        override(IInbox, Eco7683DestinationSettler)\n        returns (bytes[] memory)\n    {\n        bytes32[] memory hashes = new bytes32[](1);\n        address[] memory claimants = new address[](1);\n        hashes[0] = _expectedHash;\n        claimants[0] = _claimant;\n\n        bytes memory messageBody = abi.encode(hashes, claimants);\n        bytes32 _prover32 = _prover.addressToBytes32();\n\n        emit HyperInstantFulfillment(_expectedHash, _route.source, _claimant);\n\n        uint256 fee = fetchFee(\n            _route.source,\n            _prover32,\n            messageBody,\n            _metadata,\n            _postDispatchHook\n        );\n        bytes[] memory results = _fulfill(\n            _route,\n            _rewardHash,\n            _claimant,\n            _expectedHash\n        );\n\n        uint256 currentBalance = address(this).balance;\n        if (currentBalance < fee) {\n            revert InsufficientFee(fee);\n        }\n        if (currentBalance > fee) {\n            (bool success, ) = payable(msg.sender).call{\n                value: currentBalance - fee\n            }(\"\");\n            if (!success) {\n                revert NativeTransferFailed();\n            }\n        }\n        if (_postDispatchHook == address(0)) {\n            IMailbox(mailbox).dispatch{value: fee}(\n                uint32(_route.source),\n                _prover32,\n                messageBody\n            );\n        } else {\n            IMailbox(mailbox).dispatch{value: fee}(\n                uint32(_route.source),\n                _prover32,\n                messageBody,\n                _metadata,\n                IPostDispatchHook(_postDispatchHook)\n            );\n        }\n        return results;\n    }\n\n    /**\n     * @notice Fulfills an intent to be proven in a batch via Hyperlane's mailbox\n     * @dev Less expensive but slower than hyperinstant. Batch dispatched when sendBatch is called.\n     * @param _route The route of the intent\n     * @param _rewardHash The hash of the reward\n     * @param _claimant The address that will receive the reward on the source chain\n     * @param _expectedHash The hash of the intent as created on the source chain\n     * @param _prover The address of the hyperprover on the source chain\n     * @return Array of execution results from each call\n     */\n    function fulfillHyperBatched(\n        Route calldata _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash,\n        address _prover\n    ) external payable returns (bytes[] memory) {\n        emit AddToBatch(_expectedHash, _route.source, _claimant, _prover);\n\n        bytes[] memory results = _fulfill(\n            _route,\n            _rewardHash,\n            _claimant,\n            _expectedHash\n        );\n\n        return results;\n    }\n\n    /**\n     * @notice Sends a batch of fulfilled intents to the mailbox\n     * @dev Intent hashes must correspond to fulfilled intents from specified source chain\n     * @param _sourceChainID Chain ID of the source chain\n     * @param _prover Address of the hyperprover on the source chain\n     * @param _intentHashes Hashes of the intents to be proven\n     */\n    function sendBatch(\n        uint256 _sourceChainID,\n        address _prover,\n        bytes32[] calldata _intentHashes\n    ) external payable {\n        sendBatchWithRelayer(\n            _sourceChainID,\n            _prover,\n            _intentHashes,\n            bytes(\"\"),\n            address(0)\n        );\n    }\n\n    /**\n     * @notice Sends a batch of fulfilled intents to the mailbox with relayer support\n     * @dev Intent hashes must correspond to fulfilled intents from specified source chain\n     * @param _sourceChainID Chain ID of the source chain\n     * @param _prover Address of the hyperprover on the source chain\n     * @param _intentHashes Hashes of the intents to be proven\n     * @param _metadata Metadata for postDispatchHook\n     * @param _postDispatchHook Address of postDispatchHook\n     */\n    function sendBatchWithRelayer(\n        uint256 _sourceChainID,\n        address _prover,\n        bytes32[] calldata _intentHashes,\n        bytes memory _metadata,\n        address _postDispatchHook\n    ) public payable {\n        uint256 size = _intentHashes.length;\n        address[] memory claimants = new address[](size);\n        for (uint256 i = 0; i < size; ++i) {\n            address claimant = fulfilled[_intentHashes[i]];\n            if (claimant == address(0)) {\n                revert IntentNotFulfilled(_intentHashes[i]);\n            }\n            claimants[i] = claimant;\n        }\n\n        emit BatchSent(_intentHashes, _sourceChainID);\n\n        bytes memory messageBody = abi.encode(_intentHashes, claimants);\n        bytes32 _prover32 = _prover.addressToBytes32();\n        uint256 fee = fetchFee(\n            _sourceChainID,\n            _prover32,\n            messageBody,\n            _metadata,\n            _postDispatchHook\n        );\n        if (msg.value < fee) {\n            revert InsufficientFee(fee);\n        }\n        if (msg.value > fee) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - fee}(\n                \"\"\n            );\n            if (!success) {\n                revert NativeTransferFailed();\n            }\n        }\n        if (_postDispatchHook == address(0)) {\n            IMailbox(mailbox).dispatch{value: fee}(\n                uint32(_sourceChainID),\n                _prover32,\n                messageBody\n            );\n        } else {\n            IMailbox(mailbox).dispatch{value: fee}(\n                uint32(_sourceChainID),\n                _prover32,\n                messageBody,\n                _metadata,\n                IPostDispatchHook(_postDispatchHook)\n            );\n        }\n    }\n\n    /**\n     * @notice Quotes the fee required for message dispatch\n     * @dev Used to determine fees for fulfillHyperInstant or sendBatch\n     * @param _sourceChainID Chain ID of the source chain\n     * @param _prover Address of the hyperprover on the source chain\n     * @param _messageBody Message being sent over the bridge\n     * @param _metadata Metadata for postDispatchHook\n     * @param _postDispatchHook Address of postDispatchHook\n     * @return fee The required fee amount\n     */\n    function fetchFee(\n        uint256 _sourceChainID,\n        bytes32 _prover,\n        bytes memory _messageBody,\n        bytes memory _metadata,\n        address _postDispatchHook\n    ) public view returns (uint256 fee) {\n        return (\n            _postDispatchHook == address(0)\n                ? IMailbox(mailbox).quoteDispatch(\n                    uint32(_sourceChainID),\n                    _prover,\n                    _messageBody\n                )\n                : IMailbox(mailbox).quoteDispatch(\n                    uint32(_sourceChainID),\n                    _prover,\n                    _messageBody,\n                    _metadata,\n                    IPostDispatchHook(_postDispatchHook)\n                )\n        );\n    }\n\n    /**\n     * @notice Sets the mailbox address\n     * @dev Can only be called when mailbox is not set\n     * @param _mailbox Address of the Hyperlane mailbox\n     */\n    function setMailbox(address _mailbox) public onlyOwner {\n        if (mailbox == address(0)) {\n            mailbox = _mailbox;\n            emit MailboxSet(_mailbox);\n        }\n    }\n\n    /**\n     * @notice Makes solving public if currently restricted\n     * @dev Cannot be reversed once made public\n     */\n    function makeSolvingPublic() public onlyOwner {\n        if (!isSolvingPublic) {\n            isSolvingPublic = true;\n            emit SolvingIsPublic();\n        }\n    }\n\n    /**\n     * @notice Updates the solver whitelist\n     * @dev Whitelist is ignored if solving is public\n     * @param _solver Address of the solver\n     * @param _canSolve Whether solver should be whitelisted\n     */\n    function changeSolverWhitelist(\n        address _solver,\n        bool _canSolve\n    ) public onlyOwner {\n        solverWhitelist[_solver] = _canSolve;\n        emit SolverWhitelistChanged(_solver, _canSolve);\n    }\n\n    /**\n     * @notice Internal function to fulfill intents\n     * @dev Validates intent and executes calls\n     * @param _route The route of the intent\n     * @param _rewardHash The hash of the reward\n     * @param _claimant The reward recipient address\n     * @param _expectedHash The expected intent hash\n     * @return Array of execution results\n     */\n    function _fulfill(\n        Route memory _route,\n        bytes32 _rewardHash,\n        address _claimant,\n        bytes32 _expectedHash\n    ) internal returns (bytes[] memory) {\n        if (_route.destination != block.chainid) {\n            revert WrongChain(_route.destination);\n        }\n\n        if (!isSolvingPublic && !solverWhitelist[msg.sender]) {\n            revert UnauthorizedSolveAttempt(msg.sender);\n        }\n\n        bytes32 routeHash = keccak256(abi.encode(_route));\n        bytes32 intentHash = keccak256(\n            abi.encodePacked(routeHash, _rewardHash)\n        );\n\n        if (_route.inbox != address(this)) {\n            revert InvalidInbox(_route.inbox);\n        }\n\n        if (intentHash != _expectedHash) {\n            revert InvalidHash(_expectedHash);\n        }\n        if (fulfilled[intentHash] != address(0)) {\n            revert IntentAlreadyFulfilled(intentHash);\n        }\n        if (_claimant == address(0)) {\n            revert ZeroClaimant();\n        }\n\n        fulfilled[intentHash] = _claimant;\n        emit Fulfillment(_expectedHash, _route.source, _claimant);\n\n        uint256 routeTokenCount = _route.tokens.length;\n        // Transfer ERC20 tokens to the inbox\n        for (uint256 i = 0; i < routeTokenCount; ++i) {\n            TokenAmount memory approval = _route.tokens[i];\n            IERC20(approval.token).safeTransferFrom(\n                msg.sender,\n                address(this),\n                approval.amount\n            );\n        }\n\n        // Store the results of the calls\n        bytes[] memory results = new bytes[](_route.calls.length);\n\n        for (uint256 i = 0; i < _route.calls.length; ++i) {\n            Call memory call = _route.calls[i];\n            if (call.target.code.length == 0 && call.data.length > 0) {\n                // no code at this address\n                revert CallToEOA(call.target);\n            }\n            if (call.target == mailbox) {\n                // no executing calls on the mailbox\n                revert CallToMailbox();\n            }\n            (bool success, bytes memory result) = call.target.call{\n                value: call.value\n            }(call.data);\n            if (!success) {\n                revert IntentCallFailed(\n                    call.target,\n                    call.data,\n                    call.value,\n                    result\n                );\n            }\n            results[i] = result;\n        }\n        return results;\n    }\n\n    receive() external payable {}\n}\n"
    }
}