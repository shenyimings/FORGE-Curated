{
    "vfp_id": "vfp_00212",
    "project_name": "Cloak V1 - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "The function finalizeWithdrawERC20 does not implement the logic for forwarding data",
            "description": "The function finalizeWithdrawERC20 in L1ERC20GatewayValidium.sol includes a parameter `_data` intended to be optional data forwarded to the recipient. However, despite the comment indicating this functionality, the function does not actually implement any logic to forward the `_data` to the recipient address. This omission is a coding mistake where expected behavior described in documentation is not reflected in the implementation. An attacker cannot directly exploit this to steal funds, but users relying on the `_data` parameter for callbacks or integrations will find the feature non-functional. As a result, any intended post-withdrawal logic on the recipient side will fail to execute, leading to a degraded user experience and potential integration issues with external contracts.\n",
            "severity": "Medium",
            "location": [
                "L1ERC20GatewayValidium.sol::finalizeWithdrawERC20"
            ],
            "files": [
                "scroll-contracts/src/validium/L1ERC20GatewayValidium.sol"
            ]
        }
    ],
    "affected_files": {
        "L1ERC20GatewayValidium.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {ClonesUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IL1ScrollMessenger} from \"../L1/IL1ScrollMessenger.sol\";\nimport {IL1ERC20GatewayValidium} from \"./IL1ERC20GatewayValidium.sol\";\nimport {IL2ERC20GatewayValidium} from \"./IL2ERC20GatewayValidium.sol\";\nimport {IScrollChainValidium} from \"./IScrollChainValidium.sol\";\n\nimport {ScrollGatewayBase} from \"../libraries/gateway/ScrollGatewayBase.sol\";\n\n/// @title L1ERC20GatewayValidium\ncontract L1ERC20GatewayValidium is ScrollGatewayBase, IL1ERC20GatewayValidium {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Error thrown when msg.value is not zero.\n    error ErrorMsgValueNotZero();\n\n    /// @dev Error thrown when l2 token address is zero.\n    error ErrorL2TokenAddressIsZero();\n\n    /// @dev Error thrown when l2 token address mismatch.\n    error ErrorL2TokenMismatch();\n\n    /// @dev Error thrown when amount is zero.\n    error ErrorAmountIsZero();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of ScrollStandardERC20 implementation in L2.\n    address public immutable l2TokenImplementation;\n\n    /// @notice The address of ScrollStandardERC20Factory contract in L2.\n    address public immutable l2TokenFactory;\n\n    /// @notice The address of ScrollChainValidium contract in L2.\n    address public immutable scrollChainValidium;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l1 token address to l2 token address.\n    /// @dev This is not necessary, since we can compute the address directly. But, we use this mapping\n    /// to keep track on whether we have deployed the token in L2 using the L2ScrollStandardERC20Factory and\n    /// pass deploy data on first call to the token.\n    mapping(address => address) private tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Constructor for `L1StandardERC20Gateway` implementation contract.\n    ///\n    /// @param _counterpart The address of `L2StandardERC20Gateway` contract in L2.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _l2TokenImplementation The address of `ScrollStandardERC20` implementation in L2.\n    /// @param _l2TokenFactory The address of `ScrollStandardERC20Factory` contract in L2.\n    constructor(\n        address _counterpart,\n        address _messenger,\n        address _l2TokenImplementation,\n        address _l2TokenFactory,\n        address _scrollChainValidium\n    ) ScrollGatewayBase(_counterpart, address(0), _messenger) {\n        _disableInitializers();\n\n        l2TokenImplementation = _l2TokenImplementation;\n        l2TokenFactory = _l2TokenFactory;\n        scrollChainValidium = _scrollChainValidium;\n    }\n\n    /// @notice Initialize the storage of L1ERC20GatewayValidium.\n    function initialize() external initializer {\n        ScrollGatewayBase._initialize(address(0), address(0), address(0));\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20GatewayValidium\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        // In StandardERC20Gateway, all corresponding l2 tokens are depoyed by Create2 with salt,\n        // we can calculate the l2 address directly.\n        bytes32 _salt = keccak256(abi.encodePacked(counterpart, keccak256(abi.encodePacked(_l1Token))));\n\n        return ClonesUpgradeable.predictDeterministicAddress(l2TokenImplementation, _salt, l2TokenFactory);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20GatewayValidium\n    function depositERC20(\n        address _token,\n        bytes memory _to,\n        uint256 _amount,\n        uint256 _gasLimit,\n        uint256 _keyId\n    ) external payable override {\n        _deposit(_token, _msgSender(), _to, _amount, new bytes(0), _gasLimit, _keyId);\n    }\n\n    /// @inheritdoc IL1ERC20GatewayValidium\n    function depositERC20(\n        address _token,\n        address _realSender,\n        bytes memory _to,\n        uint256 _amount,\n        uint256 _gasLimit,\n        uint256 _keyId\n    ) external payable override {\n        _deposit(_token, _realSender, _to, _amount, new bytes(0), _gasLimit, _keyId);\n    }\n\n    /// @inheritdoc IL1ERC20GatewayValidium\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable virtual override onlyCallByCounterpart nonReentrant {\n        _beforeFinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount);\n\n        IERC20Upgradeable(_l1Token).safeTransfer(_to, _amount);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function hook to perform checks and actions before finalizing the withdrawal.\n    /// @param _l1Token The address of corresponding L1 token in L1.\n    /// @param _l2Token The address of corresponding L2 token in L2.\n    function _beforeFinalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address,\n        address,\n        uint256\n    ) internal virtual {\n        if (msg.value > 0) revert ErrorMsgValueNotZero();\n        if (_l2Token == address(0)) revert ErrorL2TokenAddressIsZero();\n        if (getL2ERC20Address(_l1Token) != _l2Token) revert ErrorL2TokenMismatch();\n\n        // update `tokenMapping` on first withdraw\n        address _storedL2Token = tokenMapping[_l1Token];\n        if (_storedL2Token == address(0)) {\n            tokenMapping[_l1Token] = _l2Token;\n        } else {\n            if (_storedL2Token != _l2Token) revert ErrorL2TokenMismatch();\n        }\n    }\n\n    /// @dev Internal function to transfer ERC20 token to this contract.\n    /// @param _token The address of token to transfer.\n    /// @param _amount The amount of token to transfer.\n    function _transferERC20In(\n        address _from,\n        address _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // common practice to handle fee on transfer token.\n        uint256 _before = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransferFrom(_from, address(this), _amount);\n        uint256 _after = IERC20Upgradeable(_token).balanceOf(address(this));\n        // no unchecked here, since some weird token may return arbitrary balance.\n        _amount = _after - _before;\n\n        return _amount;\n    }\n\n    /// @dev Internal function to do all the deposit operations.\n    ///\n    /// @param _token The token to deposit.\n    /// @param _to The recipient address to recieve the token in L2.\n    /// @param _amount The amount of token to deposit.\n    /// @param _data Optional data to forward to recipient's account. It is always empty for now.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function _deposit(\n        address _token,\n        address _from,\n        bytes memory _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit,\n        uint256 _keyId\n    ) internal virtual nonReentrant {\n        // Validate the encryption key with the given key-id.\n        IScrollChainValidium(scrollChainValidium).getEncryptionKey(_keyId);\n\n        // 1. Transfer token into this contract.\n        _amount = _transferERC20In(_msgSender(), _token, _amount);\n        if (_amount == 0) revert ErrorAmountIsZero();\n\n        // 2. Generate message passed to L2StandardERC20Gateway.\n        address _l2Token = tokenMapping[_token];\n        bytes memory _l2Data;\n        if (_l2Token == address(0)) {\n            // @note we won't update `tokenMapping` here but update the `tokenMapping` on\n            // first successful withdraw. This will prevent user to set arbitrary token\n            // metadata by setting a very small `_gasLimit` on the first tx.\n            _l2Token = getL2ERC20Address(_token);\n\n            // passing symbol/name/decimal in order to deploy in L2.\n            string memory _symbol = IERC20MetadataUpgradeable(_token).symbol();\n            string memory _name = IERC20MetadataUpgradeable(_token).name();\n            uint8 _decimals = IERC20MetadataUpgradeable(_token).decimals();\n            _l2Data = abi.encode(true, abi.encode(_data, abi.encode(_symbol, _name, _decimals)));\n        } else {\n            _l2Data = abi.encode(false, _data);\n        }\n        bytes memory _message = abi.encodeCall(\n            IL2ERC20GatewayValidium.finalizeDepositERC20Encrypted,\n            (_token, _l2Token, _from, _to, _amount, _l2Data)\n        );\n\n        // 3. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit, _from);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}\n"
    }
}