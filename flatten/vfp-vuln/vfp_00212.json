{
    "vfp_id": "vfp_00212",
    "project_name": "Across Protocol SVM Solidity Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Anyone Can Lock Relayer Refunds and Contract Can Be Drained",
            "description": "This vulnerability exists in the `claimRelayerRefund` function of the `SpokePool` contract, where a relayer can claim outstanding refunds when transfers fail due to edge cases like blacklisted tokens. The root cause is that the function uses `refundAddress` as the key to reset the `relayerRefund` mapping instead of `msg.sender`. This allows any malicious relayer to zero out another relayer's refund by specifying their address as the `refundAddress`, causing loss of funds for legitimate relayers. Furthermore, because the original `msg.sender`'s refund balance is never reset, the attacker can repeatedly call the function to drain the entire token balance of the contract associated with that `l2TokenAddress`. The impact is severe, potentially leading to complete loss of funds in the affected token pools and undermining trust in the relayer system.\n",
            "severity": "Critical",
            "location": [
                "SpokePool.sol::claimRelayerRefund#1265"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Duplicate Fill Execution",
            "description": "A critical issue was reported by the client where duplicate fills could be executed due to a change in the `_getV3RelayHash` function. Instead of hashing the entire `V3RelayData` struct, the updated version only hashed the `message` field. This creates two valid hash representations for the same deposit—one before and one after the upgrade—because contract upgrades happen asynchronously. The `filledStatuses` mapping uses this hash to prevent replays, but with differing hash methods, it fails to detect duplicate fills. The root cause is a breaking change in hash derivation logic without ensuring backward compatibility. Off-chain relayers or bundlers that use the hash as a unique identifier may not recognize a filled order, leading to a second fill. The impact is severe: the protocol could lose funds by paying out twice for a single deposit, resulting in direct financial loss.\n",
            "severity": "Critical",
            "location": [
                "SpokePool.sol::_getV3RelayHash#1641-1660",
                "SpokePool.sol#1702"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        }
    ],
    "affected_files": {
        "SpokePool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./erc7683/ERC7683.sol\";\nimport \"./erc7683/ERC7683Permit2Lib.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolMessageHandler.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./upgradeable/MultiCallerUpgradeable.sol\";\nimport \"./upgradeable/EIP712CrossChainUpgradeable.sol\";\nimport \"./upgradeable/AddressLibUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title SpokePool\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \"data worker\",\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\n * @custom:security-contact bugs@across.to\n */\nabstract contract SpokePool is\n    V3SpokePoolInterface,\n    SpokePoolInterface,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MultiCallerUpgradeable,\n    EIP712CrossChainUpgradeable,\n    IDestinationSettler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressLibUpgradeable for address;\n\n    // Address of the L1 contract that acts as the owner of this SpokePool. This should normally be set to the HubPool\n    // address. The crossDomainAdmin address is unused when the SpokePool is deployed to the same chain as the HubPool.\n    address public crossDomainAdmin;\n\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\n    // refunds and slow relays.\n    address public withdrawalRecipient;\n\n    // Note: The following two storage variables prefixed with DEPRECATED used to be variables that could be set by\n    // the cross-domain admin. Admins ended up not changing these in production, so to reduce\n    // gas in deposit/fill functions, we are converting them to private variables to maintain the contract\n    // storage layout and replacing them with immutable or constant variables, because retrieving a constant\n    // value is cheaper than retrieving a storage variable. Please see out the immutable/constant variable section.\n    WETH9Interface private DEPRECATED_wrappedNativeToken;\n    uint32 private DEPRECATED_depositQuoteTimeBuffer;\n\n    // Count of deposits is used to construct a unique deposit identifier for this spoke pool.\n    uint32 public numberOfDeposits;\n\n    // Whether deposits and fills are disabled.\n    bool public pausedFills;\n    bool public pausedDeposits;\n\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\n    RootBundle[] public rootBundles;\n\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\n    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;\n\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\n    // relay, the fees, and the agents are all parameters included in the hash key.\n    mapping(bytes32 => uint256) private DEPRECATED_relayFills;\n\n    // Note: We will likely un-deprecate the fill and deposit counters to implement a better\n    // dynamic LP fee mechanism but for now we'll deprecate it to reduce bytecode\n    // in deposit/fill functions. These counters are designed to implement a fee mechanism that is based on a\n    // canonical history of deposit and fill events and how they update a virtual running balance of liabilities and\n    // assets, which then determines the LP fee charged to relays.\n\n    // This keeps track of the worst-case liabilities due to fills.\n    // It is never reset. Users should only rely on it to determine the worst-case increase in liabilities between\n    // two points. This is used to provide frontrunning protection to ensure the relayer's assumptions about the state\n    // upon which their expected repayments are based will not change before their transaction is mined.\n    mapping(address => uint256) private DEPRECATED_fillCounter;\n\n    // This keeps track of the total running deposits for each token. This allows depositors to protect themselves from\n    // frontrunning that might change their worst-case quote.\n    mapping(address => uint256) private DEPRECATED_depositCounter;\n\n    // This tracks the number of identical refunds that have been requested.\n    // The intention is to allow an off-chain system to know when this could be a duplicate and ensure that the other\n    // requests are known and accounted for.\n    mapping(bytes32 => uint256) private DEPRECATED_refundsRequested;\n\n    // Mapping of V3 relay hashes to fill statuses. Distinguished from relayFills\n    // to eliminate any chance of collision between pre and post V3 relay hashes.\n    mapping(bytes32 => uint256) public fillStatuses;\n\n    /**************************************************************\n     *                CONSTANT/IMMUTABLE VARIABLES                *\n     **************************************************************/\n    // Constant and immutable variables do not take up storage slots and are instead added to the contract bytecode\n    // at compile time. The difference between them is that constant variables must be declared inline, meaning\n    // that they cannot be changed in production without changing the contract code, while immutable variables\n    // can be set in the constructor. Therefore we use the immutable keyword for variables that we might want to be\n    // different for each child contract (one obvious example of this is the wrappedNativeToken) or that we might\n    // want to update in the future like depositQuoteTimeBuffer. Constants are unlikely to ever be changed.\n\n    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can\n    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    WETH9Interface public immutable wrappedNativeToken;\n\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\n    // caller to use an approximately \"current\" realized fee.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable depositQuoteTimeBuffer;\n\n    // The fill deadline can only be set this far into the future from the timestamp of the deposit on this contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable fillDeadlineBuffer;\n\n    uint256 public constant MAX_TRANSFER_SIZE = 1e36;\n\n    bytes32 public constant UPDATE_V3_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint32 depositId,uint256 originChainId,uint256 updatedOutputAmount,address updatedRecipient,bytes updatedMessage)\"\n        );\n\n    // Default chain Id used to signify that no repayment is requested, for example when executing a slow fill.\n    uint256 public constant EMPTY_REPAYMENT_CHAIN_ID = 0;\n    // Default address used to signify that no relayer should be credited with a refund, for example\n    // when executing a slow fill.\n    address public constant EMPTY_RELAYER = address(0);\n    // This is the magic value that signals to the off-chain validator\n    // that this deposit can never expire. A deposit with this fill deadline should always be eligible for a\n    // slow fill, meaning that its output token and input token must be \"equivalent\". Therefore, this value is only\n    // used as a fillDeadline in deposit(), a soon to be deprecated function that also hardcodes outputToken to\n    // the zero address, which forces the off-chain validator to replace the output token with the equivalent\n    // token for the input token. By using this magic value, off-chain validators do not have to keep\n    // this event in their lookback window when querying for expired deposts.\n    uint32 public constant INFINITE_FILL_DEADLINE = type(uint32).max;\n\n    // One year in seconds. If `exclusivityParameter` is set to a value less than this, then the emitted\n    // exclusivityDeadline in a deposit event will be set to the current time plus this value.\n    uint32 public constant MAX_EXCLUSIVITY_PERIOD_SECONDS = 31_536_000;\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n    event SetXDomainAdmin(address indexed newAdmin);\n    event SetWithdrawalRecipient(address indexed newWithdrawalRecipient);\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\n    event RelayedRootBundle(\n        uint32 indexed rootBundleId,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 indexed slowRelayRoot\n    );\n    event ExecutedRelayerRefundRoot(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint256[] refundAmounts,\n        uint32 indexed rootBundleId,\n        uint32 indexed leafId,\n        address l2TokenAddress,\n        address[] refundAddresses,\n        address caller\n    );\n    event TokensBridged(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint32 indexed leafId,\n        address indexed l2TokenAddress,\n        address caller\n    );\n    event EmergencyDeleteRootBundle(uint256 indexed rootBundleId);\n    event PausedDeposits(bool isPaused);\n    event PausedFills(bool isPaused);\n\n    /**\n     * @notice Construct the SpokePool. Normally, logic contracts used in upgradeable proxies shouldn't\n     * have constructors since the following code will be executed within the logic contract's state, not the\n     * proxy contract's state. However, if we restrict the constructor to setting only immutable variables, then\n     * we are safe because immutable variables are included in the logic contract's bytecode rather than its storage.\n     * @dev Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be\n     * taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being\n     * used, you should invoke the _disableInitializers function in the constructor to automatically lock it when\n     * it is deployed:\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) {\n        wrappedNativeToken = WETH9Interface(_wrappedNativeTokenAddress);\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\n        fillDeadlineBuffer = _fillDeadlineBuffer;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct the base SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function __SpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public onlyInitializing {\n        numberOfDeposits = _initialDepositId;\n        __EIP712_init(\"ACROSS-V2\", \"1.0.0\");\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n        _setWithdrawalRecipient(_withdrawalRecipient);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     * @dev This should be set to cross domain admin for specific SpokePool.\n     */\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    modifier unpausedDeposits() {\n        if (pausedDeposits) revert DepositsArePaused();\n        _;\n    }\n\n    modifier unpausedFills() {\n        if (pausedFills) revert FillsArePaused();\n        _;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    // Allows cross domain admin to upgrade UUPS proxy implementation.\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {}\n\n    /**\n     * @notice Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects `deposit()` but not `speedUpV3Deposit()`, so that existing deposits can be sped up and still\n     * relayed.\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseDeposits(bool pause) public override onlyAdmin nonReentrant {\n        pausedDeposits = pause;\n        emit PausedDeposits(pause);\n    }\n\n    /**\n     * @notice Pauses fill-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects fillRelayWithUpdatedDeposit() and fillRelay().\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseFills(bool pause) public override onlyAdmin nonReentrant {\n        pausedFills = pause;\n        emit PausedFills(pause);\n    }\n\n    /**\n     * @notice Change cross domain admin address. Callable by admin only.\n     * @param newCrossDomainAdmin New cross domain admin.\n     */\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    /**\n     * @notice Change L1 withdrawal recipient address. Callable by admin only.\n     * @param newWithdrawalRecipient New withdrawal recipient address.\n     */\n    function setWithdrawalRecipient(address newWithdrawalRecipient) public override onlyAdmin nonReentrant {\n        _setWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    /**\n     * @notice Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\n     * @param originToken Token that depositor can deposit to this contract.\n     * @param destinationChainId Chain ID for where depositor wants to receive funds.\n     * @param enabled True to enable deposits, False otherwise.\n     */\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enabled\n    ) public override onlyAdmin nonReentrant {\n        enabledDepositRoutes[originToken][destinationChainId] = enabled;\n        emit EnabledDepositRoute(originToken, destinationChainId, enabled);\n    }\n\n    /**\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\n     * executeRelayerRefundLeaf().\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\n     * executeSlowRelayLeaf().\n     */\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {\n        uint32 rootBundleId = uint32(rootBundles.length);\n        RootBundle storage rootBundle = rootBundles.push();\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\n        rootBundle.slowRelayRoot = slowRelayRoot;\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\n    }\n\n    /**\n     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the\n     * SpokePool.\n     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256\n     * to ensure that a small input range doesn't limit which indices this method is able to reach.\n     */\n    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {\n        // Deleting a struct containing a mapping does not delete the mapping in Solidity, therefore the bitmap's\n        // data will still remain potentially leading to vulnerabilities down the line. The way around this would\n        // be to iterate through every key in the mapping and resetting the value to 0, but this seems expensive and\n        // would require a new list in storage to keep track of keys.\n        //slither-disable-next-line mapping-deletion\n        delete rootBundles[rootBundleId];\n        emit EmergencyDeleteRootBundle(rootBundleId);\n    }\n\n    /**************************************\n     *    LEGACY DEPOSITOR FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\n     * token mapping is stored on the L1 HubPool.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @dev Produces a V3FundsDeposited event with an infinite expiry, meaning that this deposit can never expire.\n     * Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function deposit(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable override nonReentrant unpausedDeposits {\n        _deposit(\n            msg.sender,\n            recipient,\n            originToken,\n            amount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message\n        );\n    }\n\n    /**\n     * @notice The only difference between depositFor and deposit is that the depositor address stored\n     * in the relay hash can be overridden by the caller. This means that the passed in depositor\n     * can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer\n     * contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @param depositor Address who is credited for depositing funds on origin chain and can speed up the deposit.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(depositor, recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp, message);\n    }\n\n    /********************************************\n     *            DEPOSITOR FUNCTIONS           *\n     ********************************************/\n\n    /**\n     * @notice Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the\n     * as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now,\n     * the caller is expected to pass in a number that will be interpreted either as an offset or a fixed\n     * timestamp depending on its value.\n     * @notice Request to bridge input token cross chain to a destination chain and receive a specified amount\n     * of output tokens. The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs,\n     * the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and the system fee that they'll be charged.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is\n     * greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be\n     * address(0), and vice versa if this is address(0).\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set between [currentTime, currentTime + fillDeadlineBuffer]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destinationchain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override nonReentrant unpausedDeposits {\n        _depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            // Increment count of deposits so that deposit ID for this spoke pool is unique.\n            numberOfDeposits++,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity\n     * deadlines as offsets added to the current time. This function is designed to be called by users\n     * such as Multisig contracts who do not have certainty when their transaction will mine.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline, which is the deadline for the\n     * relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the\n     * destination chain.\n     * @param exclusivityPeriod Added to the current time to set the exclusive relayer deadline,\n     * which is the deadline for the exclusiveRelayer to fill the deposit. After this destination chain timestamp,\n     * anyone can fill the deposit up to the fillDeadline timestamp.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityPeriod,\n        bytes calldata message\n    ) external payable {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityPeriod,\n            message\n        );\n    }\n\n    /**\n     * @notice DEPRECATED. Use depositV3() instead.\n     * @notice Submits deposit and sets exclusivityDeadline to current time plus some offset. This function is\n     * designed to be called by users who want to set an exclusive relayer for some amount of time after their deposit\n     * transaction is mined.\n     * @notice If exclusivtyDeadlineOffset > 0, then exclusiveRelayer must be set to a valid address, which is a\n     * requirement imposed by depositV3().\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set between [currentTime, currentTime + fillDeadlineBuffer]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityPeriod Added to the current time to set the exclusive reayer deadline,\n     * which is the deadline for the exclusiveRelayer to fill the deposit. After this destination chain timestamp,\n     * anyone can fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositExclusive(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityPeriod,\n        bytes calldata message\n    ) public payable {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityPeriod,\n            message\n        );\n    }\n\n    /**\n     * @notice Depositor can use this function to signal to relayer to use updated output amount, recipient,\n     * and/or message.\n     * @dev the depositor and depositId must match the params in a V3FundsDeposited event that the depositor\n     * wants to speed up. The relayer has the option but not the obligation to use this updated information\n     * when filling the deposit via fillV3RelayWithUpdatedDeposit().\n     * @param depositor Depositor that must sign the depositorSignature and was the original depositor.\n     * @param depositId Deposit ID to speed up.\n     * @param updatedOutputAmount New output amount to use for this deposit. Should be lower than previous value\n     * otherwise relayer has no incentive to use this updated value.\n     * @param updatedRecipient New recipient to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param updatedMessage New message to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See\n     * _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\n     */\n    function speedUpV3Deposit(\n        address depositor,\n        uint32 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant {\n        _verifyUpdateV3DepositMessage(\n            depositor,\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpV3Deposit(\n            updatedOutputAmount,\n            depositId,\n            depositor,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**************************************\n     *         RELAYER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\n     * @dev The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\n     * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and a system fee charged to relayers.\n     * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters passed to depositV3() on the origin chain along with that chain's chainId(). This chain's\n     * chainId() must therefore match the destinationChainId passed into depositV3.\n     * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\n     * origin SpokePool therefore the relayer should not modify any params in relayData.\n     * @dev Cannot fill more than once. Partial fills are not supported.\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\n     * all the same-named parameters emitted in the origin chain V3FundsDeposited event.\n     * - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\n     * token on the repayment chain will be sent as a refund to the caller.\n     * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\n     * following an optimistic challenge window in the HubPool.\n     * - outputAmount: The amount of output tokens that the caller will send to the recipient.\n     * - originChainId: The origin chain identifier.\n     * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\n     * the fill will revert on the destination chain.\n     * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\n     * timestamp, anyone can fill this deposit. Note that if this value was set in depositV3 by adding an offset\n     * to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's\n     * block.timestamp can change. Read the comments in `depositV3` about the `exclusivityParameter` for more details.\n     * - message The message to send to the recipient if the recipient is a contract that implements a\n     * handleV3AcrossMessage() public function\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\n     */\n    function fillV3Relay(V3RelayData calldata relayData, uint256 repaymentChainId)\n        public\n        override\n        nonReentrant\n        unpausedFills\n    {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: _getV3RelayHash(relayData),\n            updatedOutputAmount: relayData.outputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: repaymentChainId\n        });\n\n        _fillRelayV3(relayExecution, msg.sender, false);\n    }\n\n    /**\n     * @notice Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount,\n     * recipient, and/or message. The relayer should only use this function if they can supply a message signed\n     * by the depositor that contains the fill's matching deposit ID along with updated relay parameters.\n     * If the signature can be verified, then this function will emit a FilledV3Event that will be used by\n     * the system for refund verification purposes. In otherwords, this function is an alternative way to fill a\n     * a deposit than fillV3Relay.\n     * @dev Subject to same exclusivity deadline rules as fillV3Relay().\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. See fillV3Relay().\n     * @param updatedOutputAmount New output amount to use for this deposit.\n     * @param updatedRecipient New recipient to use for this deposit.\n     * @param updatedMessage New message to use for this deposit.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account.\n     */\n    function fillV3RelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: _getV3RelayHash(relayData),\n            updatedOutputAmount: updatedOutputAmount,\n            updatedRecipient: updatedRecipient,\n            updatedMessage: updatedMessage,\n            repaymentChainId: repaymentChainId\n        });\n\n        _verifyUpdateV3DepositMessage(\n            relayData.depositor,\n            relayData.depositId,\n            relayData.originChainId,\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n\n        _fillRelayV3(relayExecution, msg.sender, false);\n    }\n\n    /**\n     * @notice Request Across to send LP funds to this contract to fulfill a slow fill relay\n     * for a deposit in the next bundle.\n     * @dev Slow fills are not possible unless the input and output tokens are \"equivalent\", i.e.\n     * they route to the same L1 token via PoolRebalanceRoutes.\n     * @dev Slow fills are created by inserting slow fill objects into a merkle tree that is included\n     * in the next HubPool \"root bundle\". Once the optimistic challenge window has passed, the HubPool\n     * will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed,\n     * the slow fill can be executed by anyone who calls executeV3SlowRelayLeaf().\n     * @dev Cannot request a slow fill if the fill deadline has passed.\n     * @dev Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\n     * @param relayData struct containing all the data needed to identify the deposit that should be\n     * slow filled. If any of the params are missing or different from the origin chain deposit,\n     * then Across will not include a slow fill for the intended deposit.\n     */\n    function requestV3SlowFill(V3RelayData calldata relayData) public override nonReentrant unpausedFills {\n        uint32 currentTime = uint32(getCurrentTime());\n        // If a depositor has set an exclusivity deadline, then only the exclusive relayer should be able to\n        // fast fill within this deadline. Moreover, the depositor should expect to get *fast* filled within\n        // this deadline, not slow filled. As a simplifying assumption, we will not allow slow fills to be requested\n        // during this exclusivity period.\n        if (_fillIsExclusive(relayData.exclusivityDeadline, currentTime)) {\n            revert NoSlowFillsInExclusivityWindow();\n        }\n        if (relayData.fillDeadline < currentTime) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = _getV3RelayHash(relayData);\n        if (fillStatuses[relayHash] != uint256(FillStatus.Unfilled)) revert InvalidSlowFillRequest();\n        fillStatuses[relayHash] = uint256(FillStatus.RequestedSlowFill);\n\n        emit RequestedV3SlowFill(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayData.depositor,\n            relayData.recipient,\n            relayData.message\n        );\n    }\n\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev ERC-7683 fill function.\n     * @param orderId Unique order identifier for this order\n     * @param originData Data emitted on the origin to parameterize the fill\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external {\n        if (keccak256(abi.encode(originData, chainId())) != orderId) {\n            revert WrongERC7683OrderId();\n        }\n\n        // Ensure that the call is not malformed. If the call is malformed, abi.decode will fail.\n        V3SpokePoolInterface.V3RelayData memory relayData = abi.decode(originData, (V3SpokePoolInterface.V3RelayData));\n        AcrossDestinationFillerData memory destinationFillerData = abi.decode(\n            fillerData,\n            (AcrossDestinationFillerData)\n        );\n\n        // Must do a delegatecall because the function requires the inputs to be calldata.\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(V3SpokePoolInterface.fillV3Relay, (relayData, destinationFillerData.repaymentChainId))\n        );\n        if (!success) {\n            revert LowLevelCallFailed(data);\n        }\n    }\n\n    /**************************************\n     *         DATA WORKER FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\n     * @dev Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to\n     * double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed\n     * like any other fill sent through fillV3Relay().\n     * @dev There is no relayer credited with filling this relay since funds are sent directly out of this contract.\n     * @param slowFillLeaf Contains all data necessary to uniquely identify a relay for this chain. This struct is\n     * hashed and included in a merkle root that is relayed to all spoke pools.\n     * - relayData: struct containing all the data needed to identify the original deposit to be slow filled.\n     * - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's\n     * chainId, then this function will revert.\n     * - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently\n     * from relayData.outputAmount to charge a different fee because this deposit was \"slow\" filled. Usually,\n     * this will be set higher to reimburse the recipient for waiting for the slow fill.\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\n     */\n    function executeV3SlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) public override nonReentrant {\n        V3RelayData memory relayData = slowFillLeaf.relayData;\n\n        _preExecuteLeafHook(relayData.outputToken);\n\n        // @TODO In the future consider allowing way for slow fill leaf to be created with updated\n        // deposit params like outputAmount, message and recipient.\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: _getV3RelayHash(relayData),\n            updatedOutputAmount: slowFillLeaf.updatedOutputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: EMPTY_REPAYMENT_CHAIN_ID // Repayment not relevant for slow fills.\n        });\n\n        _verifyV3SlowFill(relayExecution, rootBundleId, proof);\n\n        // - No relayer to refund for slow fill executions.\n        _fillRelayV3(relayExecution, EMPTY_RELAYER, true);\n    }\n\n    /**\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\n     * sent to the recipient plus a relayer fee.\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\n     */\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable virtual override nonReentrant {\n        _preExecuteLeafHook(relayerRefundLeaf.l2TokenAddress);\n\n        if (relayerRefundLeaf.chainId != chainId()) revert InvalidChainId();\n\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Check that proof proves that relayerRefundLeaf is contained within the relayer refund root.\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\n        if (!MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof))\n            revert InvalidMerkleProof();\n\n        _setClaimedLeaf(rootBundleId, relayerRefundLeaf.leafId);\n\n        _distributeRelayerRefunds(\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.refundAmounts,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses\n        );\n\n        emit ExecutedRelayerRefundRoot(\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.refundAmounts,\n            rootBundleId,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses,\n            msg.sender\n        );\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns chain ID for this network.\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\n     */\n    function chainId() public view virtual override returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    function _depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) internal {\n        // Check that deposit route is enabled for the input token. There are no checks required for the output token\n        // which is pulled from the relayer at fill time and passed through this contract atomically to the recipient.\n        if (!enabledDepositRoutes[inputToken][destinationChainId]) revert DisabledRoute();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits/fills if this is undesirable.\n        // This will underflow if quoteTimestamp is more than depositQuoteTimeBuffer;\n        // this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        uint256 currentTime = getCurrentTime();\n        if (currentTime - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // fillDeadline is relative to the destination chain.\n        // Don’t allow fillDeadline to be more than several bundles into the future.\n        // This limits the maximum required lookback for dataworker and relayer instances.\n        // Also, don't allow fillDeadline to be in the past. This poses a potential UX issue if the destination\n        // chain time keeping and this chain's time keeping are out of sync but is not really a practical hurdle\n        // unless they are significantly out of sync or the depositor is setting very short fill deadlines. This latter\n        // situation won't be a problem for honest users.\n        if (fillDeadline < currentTime || fillDeadline > currentTime + fillDeadlineBuffer) revert InvalidFillDeadline();\n\n        // There are three cases for setting the exclusivity deadline using the exclusivity parameter:\n        // 1. If this parameter is 0, then there is no exclusivity period and emit 0 for the deadline. This\n        //    means that fillers of this deposit do not have to worry about the block.timestamp of this event changing\n        //    due to re-orgs when filling this deposit.\n        // 2. If the exclusivity parameter is less than or equal to MAX_EXCLUSIVITY_PERIOD_SECONDS, then the exclusivity\n        //    deadline is set to the block.timestamp of this event plus the exclusivity parameter. This means that the\n        //    filler of this deposit assumes re-org risk when filling this deposit because the block.timestamp of this\n        //    event affects the exclusivity deadline.\n        // 3. Otherwise, interpret this parameter as a timestamp and emit it as the exclusivity deadline. This means\n        //    that the filler of this deposit will not assume re-org risk related to the block.timestamp of this\n        //    event changing.\n        uint32 exclusivityDeadline = exclusivityParameter;\n        if (exclusivityDeadline > 0) {\n            if (exclusivityDeadline <= MAX_EXCLUSIVITY_PERIOD_SECONDS) {\n                exclusivityDeadline += uint32(currentTime);\n            }\n\n            // As a safety measure, prevent caller from inadvertently locking funds during exclusivity period\n            //  by forcing them to specify an exclusive relayer.\n            if (exclusiveRelayer == address(0)) revert InvalidExclusiveRelayer();\n        }\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending the native token. In this case, the native token should be\n        // wrapped.\n        if (inputToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != inputAmount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the caller as per normal.\n            // Note: this includes the case where the L2 caller has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            // msg.value should be 0 if input token isn't the wrapped native token.\n            if (msg.value != 0) revert MsgValueDoesNotMatchInputAmount();\n            IERC20Upgradeable(inputToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit V3FundsDeposited(\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            depositId,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityDeadline,\n            depositor,\n            recipient,\n            exclusiveRelayer,\n            message\n        );\n    }\n\n    function _deposit(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message\n    ) internal {\n        // Check that deposit route is enabled.\n        if (!enabledDepositRoutes[originToken][destinationChainId]) revert DisabledRoute();\n\n        // We limit the relay fees to prevent the user spending all their funds on fees.\n        if (SignedMath.abs(relayerFeePct) >= 0.5e18) revert InvalidRelayerFeePct();\n        if (amount > MAX_TRANSFER_SIZE) revert MaxTransferSizeExceeded();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits if this is undesirable. This will underflow if\n        // quoteTimestamp is more than depositQuoteTimeBuffer; this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        if (getCurrentTime() - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\n        uint32 newDepositId = numberOfDeposits++;\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.\n        if (originToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != amount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else IERC20Upgradeable(originToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit V3FundsDeposited(\n            originToken, // inputToken\n            address(0), // outputToken. Setting this to 0x0 means that the outputToken should be assumed to be the\n            // canonical token for the destination chain matching the inputToken. Therefore, this deposit\n            // can always be slow filled.\n            // - setting token to 0x0 will signal to off-chain validator that the \"equivalent\"\n            // token as the inputToken for the destination chain should be replaced here.\n            amount, // inputAmount\n            _computeAmountPostFees(amount, relayerFeePct), // outputAmount\n            // - output amount will be the deposit amount less relayerFeePct, which should now be set\n            // equal to realizedLpFeePct + gasFeePct + capitalCostFeePct where (gasFeePct + capitalCostFeePct)\n            // is equal to the old usage of `relayerFeePct`.\n            destinationChainId,\n            newDepositId,\n            quoteTimestamp,\n            INFINITE_FILL_DEADLINE, // fillDeadline. Default to infinite expiry because\n            // expired deposits refunds could be a breaking change for existing users of this function.\n            0, // exclusivityDeadline. Setting this to 0 along with the exclusiveRelayer to 0x0 means that there\n            // is no exclusive deadline\n            depositor,\n            recipient,\n            address(0), // exclusiveRelayer. Setting this to 0x0 will signal to off-chain validator that there\n            // is no exclusive relayer.\n            message\n        );\n    }\n\n    function _distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) internal {\n        if (refundAddresses.length != refundAmounts.length) revert InvalidMerkleLeaf();\n\n        // Send each relayer refund address the associated refundAmount for the L2 token address.\n        // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\n        uint256 length = refundAmounts.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 amount = refundAmounts[i];\n            if (amount > 0) IERC20Upgradeable(l2TokenAddress).safeTransfer(refundAddresses[i], amount);\n        }\n\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\n        // chain-specific bridging method.\n        if (amountToReturn > 0) {\n            _bridgeTokensToHubPool(amountToReturn, l2TokenAddress);\n\n            emit TokensBridged(amountToReturn, _chainId, leafId, l2TokenAddress, msg.sender);\n        }\n    }\n\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\n        if (newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = newCrossDomainAdmin;\n        emit SetXDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function _setWithdrawalRecipient(address newWithdrawalRecipient) internal {\n        if (newWithdrawalRecipient == address(0)) revert InvalidWithdrawalRecipient();\n        withdrawalRecipient = newWithdrawalRecipient;\n        emit SetWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    function _preExecuteLeafHook(address) internal virtual {\n        // This method by default is a no-op. Different child spoke pools might want to execute functionality here\n        // such as wrapping any native tokens owned by the contract into wrapped tokens before proceeding with\n        // executing the leaf.\n    }\n\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual;\n\n    function _setClaimedLeaf(uint32 rootBundleId, uint32 leafId) internal {\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Verify the leafId in the leaf has not yet been claimed.\n        if (MerkleLib.isClaimed(rootBundle.claimedBitmap, leafId)) revert ClaimedMerkleLeaf();\n\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, leafId);\n    }\n\n    function _verifyUpdateV3DepositMessage(\n        address depositor,\n        uint32 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) internal view {\n        // A depositor can request to modify an un-relayed deposit by signing a hash containing the updated\n        // details and information uniquely identifying the deposit to relay. This information ensures\n        // that this signature cannot be re-used for other deposits.\n        // Note: We use the EIP-712 (https://eips.ethereum.org/EIPS/eip-712) standard for hashing and signing typed data.\n        // Specifically, we use the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n        // `eth_signedTypedDataV4` in MetaMask (https://docs.metamask.io/guide/signing-data.html).\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            // EIP-712 compliant hash struct: https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct\n            keccak256(\n                abi.encode(\n                    UPDATE_V3_DEPOSIT_DETAILS_HASH,\n                    depositId,\n                    originChainId,\n                    updatedOutputAmount,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            // By passing in the origin chain id, we enable the verification of the signature on a different chain\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\n    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting\n    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the\n    // potential to forge a signature from the depositor using a different private key than the original depositor's.\n    function _verifyDepositorSignature(\n        address depositor,\n        bytes32 ethSignedMessageHash,\n        bytes memory depositorSignature\n    ) internal view virtual {\n        // Note:\n        // - We don't need to worry about reentrancy from a contract deployed at the depositor address since the method\n        //   `SignatureChecker.isValidSignatureNow` is a view method. Re-entrancy can happen, but it cannot affect state.\n        // - EIP-1271 signatures are supported. This means that a signature valid now, may not be valid later and vice-versa.\n        // - For an EIP-1271 signature to work, the depositor contract address must map to a deployed contract on the destination\n        //   chain that can validate the signature.\n        // - Regular signatures from an EOA are also supported.\n        bool isValid = SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature);\n        if (!isValid) revert InvalidDepositorSignature();\n    }\n\n    function _verifyV3SlowFill(\n        V3RelayExecutionParams memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        V3SlowFill memory slowFill = V3SlowFill({\n            relayData: relayExecution.relay,\n            chainId: chainId(),\n            updatedOutputAmount: relayExecution.updatedOutputAmount\n        });\n\n        if (!MerkleLib.verifyV3SlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof))\n            revert InvalidMerkleProof();\n    }\n\n    function _computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    function _getV3RelayHash(V3RelayData memory relayData) private view returns (bytes32) {\n        return keccak256(abi.encode(relayData, chainId()));\n    }\n\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.\n    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {\n        if (address(to).isContract()) {\n            IERC20Upgradeable(address(wrappedNativeToken)).safeTransfer(to, amount);\n        } else {\n            wrappedNativeToken.withdraw(amount);\n            AddressLibUpgradeable.sendValue(to, amount);\n        }\n    }\n\n    // @param relayer: relayer who is actually credited as filling this deposit. Can be different from\n    // exclusiveRelayer if passed exclusivityDeadline or if slow fill.\n    function _fillRelayV3(\n        V3RelayExecutionParams memory relayExecution,\n        address relayer,\n        bool isSlowFill\n    ) internal {\n        V3RelayData memory relayData = relayExecution.relay;\n\n        if (relayData.fillDeadline < getCurrentTime()) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = relayExecution.relayHash;\n\n        // If a slow fill for this fill was requested then the relayFills value for this hash will be\n        // FillStatus.RequestedSlowFill. Therefore, if this is the status, then this fast fill\n        // will be replacing the slow fill. If this is a slow fill execution, then the following variable\n        // is trivially true. We'll emit this value in the FilledV3Relay\n        // event to assist the Dataworker in knowing when to return funds back to the HubPool that can no longer\n        // be used for a slow fill execution.\n        FillType fillType = isSlowFill\n            ? FillType.SlowFill\n            : (\n                // The following is true if this is a fast fill that was sent after a slow fill request.\n                fillStatuses[relayExecution.relayHash] == uint256(FillStatus.RequestedSlowFill)\n                    ? FillType.ReplacedSlowFill\n                    : FillType.FastFill\n            );\n\n        // @dev This function doesn't support partial fills. Therefore, we associate the relay hash with\n        // an enum tracking its fill status. All filled relays, whether slow or fast fills, are set to the Filled\n        // status. However, we also use this slot to track whether this fill had a slow fill requested. Therefore\n        // we can include a bool in the FilledV3Relay event making it easy for the dataworker to compute if this\n        // fill was a fast fill that replaced a slow fill and therefore this SpokePool has excess funds that it\n        // needs to send back to the HubPool.\n        if (fillStatuses[relayHash] == uint256(FillStatus.Filled)) revert RelayFilled();\n        fillStatuses[relayHash] = uint256(FillStatus.Filled);\n\n        // @dev Before returning early, emit events to assist the dataworker in being able to know which fills were\n        // successful.\n        emit FilledV3Relay(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayExecution.repaymentChainId,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayer,\n            relayData.depositor,\n            relayData.recipient,\n            relayData.message,\n            V3RelayExecutionEventInfo({\n                updatedRecipient: relayExecution.updatedRecipient,\n                updatedMessage: relayExecution.updatedMessage,\n                updatedOutputAmount: relayExecution.updatedOutputAmount,\n                fillType: fillType\n            })\n        );\n\n        // If relayer and receiver are the same address, there is no need to do any transfer, as it would result in no\n        // net movement of funds.\n        // Note: this is important because it means that relayers can intentionally self-relay in a capital efficient\n        // way (no need to have funds on the destination).\n        // If this is a slow fill, we can't exit early since we still need to send funds out of this contract\n        // since there is no \"relayer\".\n        address recipientToSend = relayExecution.updatedRecipient;\n\n        if (msg.sender == recipientToSend && !isSlowFill) return;\n\n        // If relay token is wrappedNativeToken then unwrap and send native token.\n        address outputToken = relayData.outputToken;\n        uint256 amountToSend = relayExecution.updatedOutputAmount;\n        if (outputToken == address(wrappedNativeToken)) {\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\n            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the\n            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll\n            // need to unwrap it to native token before sending to the user.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, address(this), amountToSend);\n            _unwrapwrappedNativeTokenTo(payable(recipientToSend), amountToSend);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else {\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, recipientToSend, amountToSend);\n            else IERC20Upgradeable(outputToken).safeTransfer(recipientToSend, amountToSend);\n        }\n\n        bytes memory updatedMessage = relayExecution.updatedMessage;\n        if (updatedMessage.length > 0 && recipientToSend.isContract()) {\n            AcrossMessageHandler(recipientToSend).handleV3AcrossMessage(\n                outputToken,\n                amountToSend,\n                msg.sender,\n                updatedMessage\n            );\n        }\n    }\n\n    // Determine whether the exclusivityDeadline implies active exclusivity.\n    function _fillIsExclusive(uint32 exclusivityDeadline, uint32 currentTime) internal pure returns (bool) {\n        return exclusivityDeadline >= currentTime;\n    }\n\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\n    // L1, this would just be the same admin of the HubPool.\n    function _requireAdminSender() internal virtual;\n\n    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.\n    receive() external payable {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[999] private __gap;\n}\n"
    }
}