{
    "vfp_id": "vfp_00029",
    "project_name": "OpenZeppelin Uniswap Hooks v1.1.0 RC 2 Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ],
                "3": [
                    "CWE-835"
                ]
            },
            "title": "Infinite Loop in Tick Iteration Due to Misaligned Current Tick",
            "description": "The AntiSandwichHook contract implements an anti-MEV mechanism that stores a snapshot of the pool state at the beginning of each block. As part of this, the _beforeSwap function iterates over tick indices from the last checkpoint to the current tick using a step equal to the pool's tickSpacing. The loop condition checks whether the current tick index is not equal to the target currentTick. However, the currentTick may not be aligned with the tickSpacing, meaning that the loop increment may skip over the target tick, causing the loop condition to never be satisfied. This results in an infinite loop that consumes all available gas, leading to a denial-of-service condition where users cannot execute swaps in the affected pool. The impact is a complete disruption of pool functionality for the duration of the block, preventing legitimate transactions from being processed.\n",
            "severity": "High",
            "location": [
                "AntiSandwichHook.sol::_beforeSwap#98-105",
                "AntiSandwichHook.sol#L76"
            ],
            "files": [
                "uniswap-hooks/src/general/AntiSandwichHook.sol"
            ]
        }
    ],
    "affected_files": {
        "AntiSandwichHook.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v1.1.0) (src/general/AntiSandwichHook.sol)\n\npragma solidity ^0.8.24;\n\n// Internal imports\nimport {BaseDynamicAfterFee} from \"../fee/BaseDynamicAfterFee.sol\";\nimport {CurrencySettler} from \"../utils/CurrencySettler.sol\";\n\n// External imports\nimport {Pool} from \"v4-core/src/libraries/Pool.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {StateLibrary} from \"v4-core/src/libraries/StateLibrary.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {BeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {Slot0} from \"v4-core/src/types/Slot0.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {SwapParams} from \"v4-core/src/types/PoolOperation.sol\";\nimport {SafeCast} from \"openzeppelin/utils/math/SafeCast.sol\";\n\n/**\n * @dev This hook implements the sandwich-resistant AMM design introduced\n * https://www.umbraresearch.xyz/writings/sandwich-resistant-amm[here]. Specifically,\n * this hook guarantees that no swaps get filled at a price better than the price at\n * the beginning of the slot window (i.e. one block).\n *\n * Within a slot window, swaps impact the pool asymmetrically for buys and sells.\n * When a buy order is executed, the offer on the pool increases in accordance with\n * the xy=k curve. However, the bid price remains constant, instead increasing the\n * amount of liquidity on the bid. Subsequent sells eat into this liquidity, while\n * decreasing the offer price according to xy=k.\n *\n * In order to use this hook, the inheriting contract must implement the {_handleCollectedFees} function\n * to determine how to handle the collected fees from the anti-sandwich mechanism.\n *\n * NOTE: The Anti-sandwich mechanism only protects swaps in the zeroForOne swap direction.\n * Swaps in the !zeroForOne direction are not protected by this hook design.\n *\n * WARNING: Since this hook makes MEV not profitable, there's not as much arbitrage in\n * the pool, making prices at beginning of the block not necessarily close to market price.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v1.1.0_\n */\nabstract contract AntiSandwichHook is BaseDynamicAfterFee {\n    using Pool for *;\n    using StateLibrary for IPoolManager;\n    using CurrencySettler for Currency;\n    using SafeCast for *;\n\n    /// @dev Represents a checkpoint of the pool state at the beginning of a block.\n    struct Checkpoint {\n        uint48 blockNumber;\n        Pool.State state;\n    }\n\n    /// @dev Maps each pool to its last checkpoint.\n    mapping(PoolId id => Checkpoint) private _lastCheckpoints;\n\n    constructor(IPoolManager _poolManager) BaseDynamicAfterFee(_poolManager) {}\n\n    /**\n     * @dev Handles the before swap hook.\n     *\n     * For the first swap in a block, it saves the current pool state as a checkpoint.\n     *\n     * For subsequent swaps in the same block, it calculates a target output based on the beginning-of-block state,\n     * and sets the inherited `_targetOutput` and `_applyTargetOutput` variables to enforce price limits in {_afterSwap}.\n     */\n    function _beforeSwap(address sender, PoolKey calldata key, SwapParams calldata params, bytes calldata hookData)\n        internal\n        virtual\n        override\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        PoolId poolId = key.toId();\n        Checkpoint storage _lastCheckpoint = _lastCheckpoints[poolId];\n\n        uint48 currentBlock = _getBlockNumber();\n\n        // update the top-of-block `slot0` if new block\n        if (_lastCheckpoint.blockNumber != currentBlock) {\n            _lastCheckpoint.state.slot0 = Slot0.wrap(poolManager.extsload(StateLibrary._getPoolStateSlot(poolId)));\n            _lastCheckpoint.blockNumber = currentBlock;\n\n            // iterate over ticks\n            (, int24 currentTick,,) = poolManager.getSlot0(poolId);\n\n            int24 lastTick = _lastCheckpoint.state.slot0.tick();\n            int24 step = currentTick > lastTick ? key.tickSpacing : -key.tickSpacing;\n\n            for (int24 tick = lastTick; tick != currentTick; tick += step) {\n                (\n                    _lastCheckpoint.state.ticks[tick].liquidityGross,\n                    _lastCheckpoint.state.ticks[tick].liquidityNet,\n                    _lastCheckpoint.state.ticks[tick].feeGrowthOutside0X128,\n                    _lastCheckpoint.state.ticks[tick].feeGrowthOutside1X128\n                ) = poolManager.getTickInfo(poolId, tick);\n            }\n\n            (_lastCheckpoint.state.feeGrowthGlobal0X128, _lastCheckpoint.state.feeGrowthGlobal1X128) =\n                poolManager.getFeeGrowthGlobals(poolId);\n            _lastCheckpoint.state.liquidity = poolManager.getLiquidity(poolId);\n        }\n\n        return super._beforeSwap(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Handles the after swap hook.\n     *\n     * Caps the obtained output from the swap to the target output determined during the {_beforeSwap} hook.\n     * Handles the excess output afterwards via {_afterSwapHandler}.\n     */\n    function _afterSwap(\n        address sender,\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) internal virtual override returns (bytes4, int128) {\n        if (!_applyTargetOutput) {\n            return (this.afterSwap.selector, 0);\n        }\n\n        int128 unspecifiedAmount = (params.amountSpecified < 0 == params.zeroForOne) ? delta.amount1() : delta.amount0();\n        if (unspecifiedAmount < 0) unspecifiedAmount = -unspecifiedAmount;\n\n        Currency unspecified = (params.amountSpecified < 0 == params.zeroForOne) ? (key.currency1) : (key.currency0);\n        bool exactInput = params.amountSpecified < 0;\n\n        if (!exactInput && _targetOutput > unspecifiedAmount.toUint256()) {\n            // In this case, the swapper has a fixed output and `_targetOutput` is greater than the input amount.\n            // In order to protect against the sandwich attack, we increase the input amount to `_targetOutput`.\n            uint256 payAmount = _targetOutput - unspecifiedAmount.toUint256();\n\n            unspecified.take(poolManager, address(this), payAmount, true);\n\n            _afterSwapHandler(key, params, delta, _targetOutput, payAmount);\n\n            return (this.afterSwap.selector, payAmount.toInt256().toInt128());\n        }\n\n        return super._afterSwap(sender, key, params, delta, hookData);\n    }\n\n    /**\n     * @dev Returns the current block number.\n     */\n    function _getBlockNumber() internal view virtual returns (uint48) {\n        return uint48(block.number);\n    }\n\n    /**\n     * @dev Calculates the output amount based on the pool state at the beginning of the block.\n     * This prevents sandwich attacks by ensuring trades can't get better prices than what was available\n     * at the start of the block. Note that the calculated output could either be input or output, depending\n     * if it's an exactInput or outputOutput swap. In cases of zeroForOne == true, the target output is not\n     * applicable, and the max uint256 value is returned as a flag only.\n     *\n     * The anti-sandwich mechanism works such as:\n     *\n     * - For currency0 to currency1 swaps (zeroForOne = true): The pool behaves normally with xy=k curve.\n     * - For currency1 to currency0 swaps (zeroForOne = false): The price is fixed at the beginning-of-block\n     *   price, which prevents attackers from manipulating the price within a block.\n     */\n    function _getTargetOutput(address, PoolKey calldata key, SwapParams calldata params, bytes calldata)\n        internal\n        virtual\n        override\n        returns (uint256 targetOutput, bool applyTargetOutput)\n    {\n        if (params.zeroForOne) {\n            // when zeroForOne == true, the xy=k curve is used, so the target output doesn't matter, since it's not going to be used\n            // we return the max value to indicate that the target output is not applicable\n            return (type(uint256).max, false);\n        }\n\n        Checkpoint storage _lastCheckpoint = _lastCheckpoints[key.toId()];\n\n        // calculate target output\n        // NOTE: this functions does not execute the swap, it only calculates the output of a swap in the given state\n        (BalanceDelta targetDelta,,,) = Pool.swap(\n            _lastCheckpoint.state,\n            Pool.SwapParams({\n                tickSpacing: key.tickSpacing,\n                zeroForOne: params.zeroForOne,\n                amountSpecified: params.amountSpecified,\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96,\n                lpFeeOverride: 0\n            })\n        );\n\n        int128 target =\n            (params.amountSpecified < 0 == params.zeroForOne) ? targetDelta.amount1() : targetDelta.amount0();\n\n        if (target < 0) target = -target;\n\n        targetOutput = target.toUint256();\n        applyTargetOutput = true;\n    }\n\n    /**\n     * @dev Handles the excess tokens collected during the swap due to the anti-sandwich mechanism.\n     * When a swap executes at a worse price than what's currently available in the pool (due to\n     * enforcing the beginning-of-block price).\n     */\n    function _afterSwapHandler(\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta,\n        uint256,\n        uint256 feeAmount\n    ) internal virtual override {\n        Currency unspecified = (params.amountSpecified < 0 == params.zeroForOne) ? (key.currency1) : (key.currency0);\n\n        // reset apply flag\n        // slither-disable-next-line reentrancy-no-eth\n        _applyTargetOutput = false;\n\n        _handleCollectedFees(key, unspecified, feeAmount);\n    }\n\n    /**\n     * @dev Handles the fees collected via the anti-sandwich protection in {_afterSwap}.\n     *\n     * NOTE: Must be implemented by the inheriting contract.\n     */\n    function _handleCollectedFees(PoolKey calldata key, Currency currency, uint256 feeAmount) internal virtual;\n\n    /**\n     * @dev Set the hook permissions, specifically `beforeSwap`, `afterSwap`, and `afterSwapReturnDelta`.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: true,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n"
    }
}