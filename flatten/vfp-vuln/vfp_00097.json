{
    "vfp_id": "vfp_00097",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Cannot Forbid an Adapter With Normal Configuration",
            "description": "This vulnerability arises from incorrect logic in the CreditFactory.configure() function when attempting to forbid an adapter. Instead of calling unauthorizeFactory(), the code re-authorizes the factory, which reverts because the adapter is already authorized. This prevents the intended configuration change from being applied. An attacker or misconfigured governance proposal could exploit this to maintain unauthorized adapter access. The impact includes loss of configurability and potential security risks from unwanted adapters remaining active.\n",
            "severity": "High",
            "location": [
                "CreditFactory.sol::configure"
            ],
            "files": [
                "permissionless/contracts/factories/CreditFactory.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ],
                "4": [
                    "CWE-606"
                ]
            },
            "title": "Free Choice of maxEnabledTokens Can Be Dangerous",
            "description": "The system allows risk curators to set maxEnabledTokens to arbitrarily high values. If too many tokens are enabled, the gas cost of liquidating a credit account could exceed the block gas limit, making liquidations impossible. This could lead to bad debt accumulation in the protocol. Attackers could exploit this by proposing or setting excessively high values. The impact is financial risk due to unprocessable liquidations and potential insolvency.\n",
            "severity": "Medium",
            "location": [
                "CreditFactory.sol",
                "CreditManagerV3.sol"
            ],
            "files": [
                "permissionless/contracts/factories/CreditFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "CreditFactory.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IAccountFactory} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAccountFactory.sol\";\nimport {ICreditConfiguratorV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditConfiguratorV3.sol\";\nimport {ICreditFacadeV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {IPoolV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol\";\n\nimport {ICreditFactory} from \"../interfaces/factories/ICreditFactory.sol\";\nimport {IFactory} from \"../interfaces/factories/IFactory.sol\";\nimport {IContractsRegister} from \"../interfaces/IContractsRegister.sol\";\nimport {IMarketConfigurator} from \"../interfaces/IMarketConfigurator.sol\";\nimport {Call, DeployParams, DeployResult} from \"../interfaces/Types.sol\";\n\nimport {CallBuilder} from \"../libraries/CallBuilder.sol\";\nimport {\n    DOMAIN_ACCOUNT_FACTORY,\n    DOMAIN_ADAPTER,\n    DOMAIN_CREDIT_MANAGER,\n    DOMAIN_DEGEN_NFT,\n    AP_BOT_LIST,\n    AP_CREDIT_CONFIGURATOR,\n    AP_CREDIT_FACADE,\n    AP_CREDIT_FACTORY,\n    AP_INSTANCE_MANAGER_PROXY,\n    AP_WETH_TOKEN,\n    NO_VERSION_CONTROL\n} from \"../libraries/ContractLiterals.sol\";\n\nimport {AbstractFactory} from \"./AbstractFactory.sol\";\n\nstruct CreditManagerParams {\n    uint8 maxEnabledTokens;\n    uint16 feeInterest;\n    uint16 feeLiquidation;\n    uint16 liquidationPremium;\n    uint16 feeLiquidationExpired;\n    uint16 liquidationPremiumExpired;\n    uint128 minDebt;\n    uint128 maxDebt;\n    string name;\n    DeployParams accountFactoryParams;\n}\n\nstruct CreditFacadeParams {\n    address degenNFT;\n    bool expirable;\n    bool migrateBotList;\n}\n\ninterface IConfigureActions {\n    function upgradeCreditConfigurator() external;\n    function upgradeCreditFacade(CreditFacadeParams calldata params) external;\n    function allowAdapter(DeployParams calldata params) external;\n    function forbidAdapter(address adapter) external;\n    function configureAdapterFor(address targetContract, bytes calldata data) external;\n    function setFees(\n        uint16 feeLiquidation,\n        uint16 liquidationPremium,\n        uint16 feeLiquidationExpired,\n        uint16 liquidationPremiumExpired\n    ) external;\n    function setMaxDebtPerBlockMultiplier(uint8 newMaxDebtLimitPerBlockMultiplier) external;\n    function addCollateralToken(address token, uint16 liquidationThreshold) external;\n    function rampLiquidationThreshold(\n        address token,\n        uint16 liquidationThresholdFinal,\n        uint40 rampStart,\n        uint24 rampDuration\n    ) external;\n    function forbidToken(address token) external;\n    function allowToken(address token) external;\n    function setExpirationDate(uint40 newExpirationDate) external;\n    function pause() external;\n    function unpause() external;\n}\n\ninterface IEmergencyConfigureActions {\n    function forbidAdapter(address adapter) external;\n    function forbidToken(address token) external;\n    function forbidBorrowing() external;\n    function pause() external;\n}\n\ncontract CreditFactory is AbstractFactory, ICreditFactory {\n    /// @notice Contract version\n    uint256 public constant override version = 3_10;\n\n    /// @notice Contract type\n    bytes32 public constant override contractType = AP_CREDIT_FACTORY;\n\n    /// @notice Address of the bot list contract\n    address public immutable botList;\n\n    /// @notice Address of the WETH token\n    address public immutable weth;\n\n    error DegenNFTIsNotRegisteredException(address degenNFT);\n\n    error TargetContractIsNotAllowedException(address targetCotnract);\n\n    /// @notice Constructor\n    /// @param addressProvider_ Address provider contract address\n    constructor(address addressProvider_) AbstractFactory(addressProvider_) {\n        botList = _getAddressOrRevert(AP_BOT_LIST, NO_VERSION_CONTROL);\n        weth = _tryGetAddress(AP_WETH_TOKEN, NO_VERSION_CONTROL);\n    }\n\n    // ---------- //\n    // DEPLOYMENT //\n    // ---------- //\n\n    function deployCreditSuite(address pool, bytes calldata encodedParams)\n        external\n        override\n        onlyMarketConfigurators\n        returns (DeployResult memory)\n    {\n        (CreditManagerParams memory params, CreditFacadeParams memory facadeParams) =\n            abi.decode(encodedParams, (CreditManagerParams, CreditFacadeParams));\n\n        address accountFactory = _deployAccountFactory(msg.sender, params.accountFactoryParams);\n        address creditManager = _deployCreditManager(msg.sender, pool, accountFactory, params);\n        address creditConfigurator = _deployCreditConfigurator(msg.sender, creditManager);\n        address creditFacade = _deployCreditFacade(msg.sender, creditManager, facadeParams);\n\n        IAccountFactory(accountFactory).addCreditManager(creditManager);\n        ICreditManagerV3(creditManager).setCreditConfigurator(creditConfigurator);\n\n        return DeployResult({\n            newContract: creditManager,\n            onInstallOps: CallBuilder.build(\n                _authorizeFactory(msg.sender, creditManager, creditConfigurator),\n                _authorizeFactory(msg.sender, creditManager, creditFacade),\n                _setCreditFacade(creditConfigurator, creditFacade, false),\n                _setDebtLimits(creditConfigurator, params.minDebt, params.maxDebt)\n            )\n        });\n    }\n\n    function computeCreditManagerAddress(address marketConfigurator, address pool, bytes calldata encodedParams)\n        external\n        view\n        override\n        returns (address)\n    {\n        (CreditManagerParams memory params,) = abi.decode(encodedParams, (CreditManagerParams, CreditFacadeParams));\n        return _computeCreditManagerAddress(marketConfigurator, pool, params);\n    }\n\n    // ------------ //\n    // CREDIT HOOKS //\n    // ------------ //\n\n    function onUpdatePriceOracle(address creditManager, address newPriceOracle, address)\n        external\n        view\n        override\n        returns (Call[] memory)\n    {\n        return CallBuilder.build(_setPriceOracle(_creditConfigurator(creditManager), newPriceOracle));\n    }\n\n    function onUpdateLossPolicy(address creditManager, address newLossPolicy, address)\n        external\n        view\n        override\n        returns (Call[] memory)\n    {\n        return CallBuilder.build(_setLossPolicy(_creditConfigurator(creditManager), newLossPolicy));\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function configure(address creditManager, bytes calldata callData)\n        external\n        override(AbstractFactory, IFactory)\n        onlyMarketConfigurators\n        returns (Call[] memory)\n    {\n        bytes4 selector = bytes4(callData);\n        if (selector == IConfigureActions.upgradeCreditConfigurator.selector) {\n            address creditConfigurator = _creditConfigurator(creditManager);\n            address newCreditConfigurator = _deployCreditConfigurator(msg.sender, creditManager);\n            return CallBuilder.build(\n                _upgradeCreditConfigurator(creditConfigurator, newCreditConfigurator),\n                _unauthorizeFactory(msg.sender, creditManager, creditConfigurator),\n                _authorizeFactory(msg.sender, creditManager, newCreditConfigurator)\n            );\n        } else if (selector == IConfigureActions.upgradeCreditFacade.selector) {\n            CreditFacadeParams memory params = abi.decode(callData[4:], (CreditFacadeParams));\n            address creditFacade = _creditFacade(creditManager);\n            address newCreditFacade = _deployCreditFacade(msg.sender, creditManager, params);\n            return CallBuilder.build(\n                _setCreditFacade(_creditConfigurator(creditManager), newCreditFacade, true),\n                _unauthorizeFactory(msg.sender, creditManager, creditFacade),\n                _authorizeFactory(msg.sender, creditManager, newCreditFacade)\n            );\n        } else if (selector == IConfigureActions.allowAdapter.selector) {\n            DeployParams memory params = abi.decode(callData[4:], (DeployParams));\n            address adapter = _deployAdapter(msg.sender, creditManager, params);\n            return CallBuilder.build(\n                _authorizeFactory(msg.sender, creditManager, adapter),\n                _allowAdapter(_creditConfigurator(creditManager), adapter)\n            );\n        } else if (selector == IConfigureActions.forbidAdapter.selector) {\n            address adapter = abi.decode(callData[4:], (address));\n            return CallBuilder.build(\n                _authorizeFactory(msg.sender, creditManager, adapter),\n                _forbidAdapter(_creditConfigurator(creditManager), adapter)\n            );\n        } else if (selector == IConfigureActions.configureAdapterFor.selector) {\n            (address targetContract, bytes memory data) = abi.decode(callData[4:], (address, bytes));\n            address adapter = ICreditManagerV3(creditManager).contractToAdapter(targetContract);\n            if (adapter == address(0)) revert TargetContractIsNotAllowedException(targetContract);\n            return CallBuilder.build(Call(adapter, data));\n        } else if (\n            selector == IConfigureActions.setFees.selector\n                || selector == IConfigureActions.setMaxDebtPerBlockMultiplier.selector\n                || selector == IConfigureActions.addCollateralToken.selector\n                || selector == IConfigureActions.rampLiquidationThreshold.selector\n                || selector == IConfigureActions.forbidToken.selector || selector == IConfigureActions.allowToken.selector\n                || selector == IConfigureActions.setExpirationDate.selector\n        ) {\n            return CallBuilder.build(Call(_creditConfigurator(creditManager), callData));\n        } else if (selector == IConfigureActions.pause.selector || selector == IConfigureActions.unpause.selector) {\n            return CallBuilder.build(Call(_creditFacade(creditManager), callData));\n        } else {\n            revert ForbiddenConfigurationCallException(selector);\n        }\n    }\n\n    function emergencyConfigure(address creditManager, bytes calldata callData)\n        external\n        view\n        override(AbstractFactory, IFactory)\n        returns (Call[] memory)\n    {\n        bytes4 selector = bytes4(callData);\n        if (selector == IEmergencyConfigureActions.forbidAdapter.selector) {\n            address adapter = abi.decode(callData[4:], (address));\n            return CallBuilder.build(\n                _unauthorizeFactory(msg.sender, creditManager, adapter),\n                _forbidAdapter(_creditConfigurator(creditManager), adapter)\n            );\n        } else if (\n            selector == IEmergencyConfigureActions.forbidBorrowing.selector\n                || selector == IEmergencyConfigureActions.forbidToken.selector\n        ) {\n            return CallBuilder.build(Call(_creditConfigurator(creditManager), callData));\n        } else if (selector == IEmergencyConfigureActions.pause.selector) {\n            return CallBuilder.build(Call(_creditFacade(creditManager), callData));\n        } else {\n            revert ForbiddenEmergencyConfigurationCallException(selector);\n        }\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    function _deployAccountFactory(address marketConfigurator, DeployParams memory params) internal returns (address) {\n        address decodedAddressProvider = abi.decode(params.constructorParams, (address));\n        if (decodedAddressProvider != addressProvider) revert InvalidConstructorParamsException();\n\n        return _deployLatestPatch({\n            contractType: _getContractType(DOMAIN_ACCOUNT_FACTORY, params.postfix),\n            minorVersion: version,\n            constructorParams: params.constructorParams,\n            salt: keccak256(abi.encode(params.salt, marketConfigurator))\n        });\n    }\n\n    function _computeAccountFactoryAddress(address marketConfigurator, DeployParams memory params)\n        internal\n        view\n        returns (address)\n    {\n        return _computeAddressLatestPatch({\n            contractType: _getContractType(DOMAIN_ACCOUNT_FACTORY, params.postfix),\n            minorVersion: version,\n            constructorParams: params.constructorParams,\n            salt: keccak256(abi.encode(params.salt, marketConfigurator)),\n            deployer: address(this)\n        });\n    }\n\n    function _deployCreditManager(\n        address marketConfigurator,\n        address pool,\n        address accountFactory,\n        CreditManagerParams memory params\n    ) internal returns (address) {\n        bytes32 postfix = _getTokenSpecificPostfix(IPoolV3(pool).asset());\n        bytes memory constructorParams =\n            _buildCreditManagerConstructorParams(marketConfigurator, pool, accountFactory, params);\n        return _deployLatestPatch({\n            contractType: _getContractType(DOMAIN_CREDIT_MANAGER, postfix),\n            minorVersion: version,\n            constructorParams: constructorParams,\n            salt: bytes32(bytes20(marketConfigurator))\n        });\n    }\n\n    function _computeCreditManagerAddress(address marketConfigurator, address pool, CreditManagerParams memory params)\n        internal\n        view\n        returns (address)\n    {\n        address accountFactory = _computeAccountFactoryAddress(marketConfigurator, params.accountFactoryParams);\n        bytes32 postfix = _getTokenSpecificPostfix(IPoolV3(pool).asset());\n        bytes memory constructorParams =\n            _buildCreditManagerConstructorParams(marketConfigurator, pool, accountFactory, params);\n        return _computeAddressLatestPatch({\n            contractType: _getContractType(DOMAIN_CREDIT_MANAGER, postfix),\n            minorVersion: version,\n            constructorParams: constructorParams,\n            salt: bytes32(bytes20(marketConfigurator)),\n            deployer: address(this)\n        });\n    }\n\n    function _buildCreditManagerConstructorParams(\n        address marketConfigurator,\n        address pool,\n        address accountFactory,\n        CreditManagerParams memory params\n    ) internal view returns (bytes memory) {\n        address contractsRegister = IMarketConfigurator(marketConfigurator).contractsRegister();\n        address priceOracle = IContractsRegister(contractsRegister).getPriceOracle(pool);\n\n        return abi.encode(\n            pool,\n            accountFactory,\n            priceOracle,\n            params.maxEnabledTokens,\n            params.feeInterest,\n            params.feeLiquidation,\n            params.liquidationPremium,\n            params.feeLiquidationExpired,\n            params.liquidationPremiumExpired,\n            params.name\n        );\n    }\n\n    function _deployCreditConfigurator(address marketConfigurator, address creditManager) internal returns (address) {\n        address acl = IMarketConfigurator(marketConfigurator).acl();\n        bytes memory constructorParams = abi.encode(acl, creditManager);\n\n        return _deployLatestPatch({\n            contractType: AP_CREDIT_CONFIGURATOR,\n            minorVersion: version,\n            constructorParams: constructorParams,\n            salt: bytes32(bytes20(marketConfigurator))\n        });\n    }\n\n    function _deployCreditFacade(address marketConfigurator, address creditManager, CreditFacadeParams memory params)\n        internal\n        returns (address)\n    {\n        address acl = IMarketConfigurator(marketConfigurator).acl();\n        address contractsRegister = IMarketConfigurator(marketConfigurator).contractsRegister();\n        address lossPolicy = IContractsRegister(contractsRegister).getLossPolicy(ICreditManagerV3(creditManager).pool());\n\n        if (\n            params.degenNFT != address(0)\n                && !IMarketConfigurator(marketConfigurator).isPeripheryContract(DOMAIN_DEGEN_NFT, params.degenNFT)\n        ) {\n            revert DegenNFTIsNotRegisteredException(params.degenNFT);\n        }\n\n        address botList_ = botList;\n        if (params.migrateBotList) {\n            address prevCreditFacade = ICreditManagerV3(creditManager).creditFacade();\n            botList_ = ICreditFacadeV3(prevCreditFacade).botList();\n        }\n\n        bytes memory constructorParams =\n            abi.encode(acl, creditManager, lossPolicy, botList_, weth, params.degenNFT, params.expirable);\n\n        return _deployLatestPatch({\n            contractType: AP_CREDIT_FACADE,\n            minorVersion: version,\n            constructorParams: constructorParams,\n            salt: bytes32(bytes20(marketConfigurator))\n        });\n    }\n\n    function _deployAdapter(address marketConfigurator, address creditManager, DeployParams memory params)\n        internal\n        returns (address)\n    {\n        address decodedCreditManager = abi.decode(params.constructorParams, (address));\n        if (decodedCreditManager != creditManager) revert InvalidConstructorParamsException();\n\n        return _deployLatestPatch({\n            contractType: _getContractType(DOMAIN_ADAPTER, params.postfix),\n            minorVersion: version,\n            constructorParams: params.constructorParams,\n            salt: keccak256(abi.encode(params.salt, marketConfigurator))\n        });\n    }\n\n    function _creditConfigurator(address creditManager) internal view returns (address) {\n        return ICreditManagerV3(creditManager).creditConfigurator();\n    }\n\n    function _creditFacade(address creditManager) internal view returns (address) {\n        return ICreditManagerV3(creditManager).creditFacade();\n    }\n\n    function _upgradeCreditConfigurator(address creditConfigurator, address newCreditConfigurator)\n        internal\n        pure\n        returns (Call memory)\n    {\n        return Call(\n            creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.upgradeCreditConfigurator, (newCreditConfigurator))\n        );\n    }\n\n    function _setCreditFacade(address creditConfigurator, address creditFacade, bool migrateParams)\n        internal\n        pure\n        returns (Call memory)\n    {\n        return Call(\n            creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.setCreditFacade, (creditFacade, migrateParams))\n        );\n    }\n\n    function _setPriceOracle(address creditConfigurator, address priceOracle) internal pure returns (Call memory) {\n        return Call(creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.setPriceOracle, priceOracle));\n    }\n\n    function _setLossPolicy(address creditConfigurator, address lossPolicy) internal pure returns (Call memory) {\n        return Call(creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.setLossPolicy, lossPolicy));\n    }\n\n    function _allowAdapter(address creditConfigurator, address adapter) internal pure returns (Call memory) {\n        return Call(creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.allowAdapter, adapter));\n    }\n\n    function _forbidAdapter(address creditConfigurator, address adapter) internal pure returns (Call memory) {\n        return Call(creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.forbidAdapter, adapter));\n    }\n\n    function _setDebtLimits(address creditConfigurator, uint128 minDebt, uint128 maxDebt)\n        internal\n        pure\n        returns (Call memory)\n    {\n        return Call(creditConfigurator, abi.encodeCall(ICreditConfiguratorV3.setDebtLimits, (minDebt, maxDebt)));\n    }\n}\n"
    }
}