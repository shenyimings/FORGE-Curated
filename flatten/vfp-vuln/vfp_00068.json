{
    "vfp_id": "vfp_00068",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Improper Typecasting in `EfficiencyLib` Functions",
            "description": "The `EfficiencyLib` library contains low-level type conversion functions such as `asBool` and `asBytes12` that use inline assembly without proper bit cleaning. The `asBool` function casts a `uint256` to a `bool` but does not ensure that only the least significant bit is considered, potentially leaving \"dirty bits\" that persist if the value is later cast back. Similarly, `asBytes12` does not apply a mask to clear higher-order bits, risking unintended data leakage. This is caused by unsafe assembly-level typecasting without masking or normalization. If these dirty values are used in critical conditions or comparisons, they could lead to incorrect logic execution or state corruption. The impact includes potential manipulation of control flow or data integrity issues in functions relying on these conversions, especially in security-critical contexts.\n",
            "severity": "High",
            "location": [
                "EfficiencyLib.sol::asBool#64",
                "EfficiencyLib.sol::asBytes12#76"
            ],
            "files": [
                "the-compact/src/lib/EfficiencyLib.sol"
            ]
        }
    ],
    "affected_files": {
        "EfficiencyLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Scope } from \"../types/Scope.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\n/**\n * @title EfficiencyLib\n * @notice Library contract implementing logic for efficient value comparisons,\n * conversions, typecasting, and sanitization. Also provides functions to prevent\n * the function specializer from being triggered when using static arguments.\n */\nlibrary EfficiencyLib {\n    /**\n     * @notice Internal view function to convert the provided account address to the caller if that\n     *         address is the null address (0x0).\n     * @dev    Uses bitwise operations to avoid branching, making this function more gas efficient\n     *         than using a traditional if-else statement. The implementation follows the pattern:\n     *         result = xor(a, mul(xor(a, b), condition)) which resolves to either a or b based on\n     *         the condition.\n     * @param  account               The address to check and potentially replace.\n     * @return accountOrCallerIfNull The original address if non-zero, otherwise msg.sender.\n     */\n    function usingCallerIfNull(address account) internal view returns (address accountOrCallerIfNull) {\n        assembly (\"memory-safe\") {\n            accountOrCallerIfNull := xor(account, mul(xor(account, caller()), iszero(account)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that performs a bitwise AND on two booleans.\n     * Avoids Solidity's conditional evaluation of logical AND. Only safe when\n     * inputs are known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The first boolean value.\n     * @param b  The second boolean value.\n     * @return c The result of the bitwise AND.\n     */\n    function and(bool a, bool b) internal pure returns (bool c) {\n        assembly (\"memory-safe\") {\n            c := and(a, b)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that performs a bitwise OR on two booleans.\n     * Avoids Solidity's conditional evaluation of logical OR. Only safe when\n     * inputs are known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The first boolean value.\n     * @param b  The second boolean value.\n     * @return c The result of the bitwise OR.\n     */\n    function or(bool a, bool b) internal pure returns (bool c) {\n        assembly (\"memory-safe\") {\n            c := or(a, b)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint256 to a boolean. Only\n     * safe when the input is known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The uint256 to convert.\n     * @return b The resulting boolean.\n     */\n    function asBool(uint256 a) internal pure returns (bool b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint256 to a bytes12. Only\n     * safe when the input is known to have no dirty lower bits.\n     * @param a  The uint256 to convert.\n     * @return b The resulting bytes12 value.\n     */\n    function asBytes12(uint256 a) internal pure returns (bytes12 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that sanitizes an address by clearing the\n     * upper 96 bits. Used for ensuring consistent address handling.\n     * @param accountValue The value to sanitize.\n     * @return account     The sanitized address.\n     */\n    function asSanitizedAddress(uint256 accountValue) internal pure returns (address account) {\n        assembly (\"memory-safe\") {\n            account := shr(96, shl(96, accountValue))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that checks if an address has its lower 160\n     * bits set to zero.\n     * @param account The address to check.\n     * @return isNull Whether the address is null.\n     */\n    function isNullAddress(address account) internal pure returns (bool isNull) {\n        assembly (\"memory-safe\") {\n            isNull := iszero(shl(96, account))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a boolean to a uint256.\n     * @param a  The boolean to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(bool a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint96 to a uint256.\n     * @param a  The uint96 to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(uint96 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a bytes12 to a uint256.\n     * @param a  The bytes12 to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(bytes12 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a Scope enum to a uint256.\n     * @param a  The Scope enum to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(Scope a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts an address to a uint256.\n     * @param a  The address to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(address a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a ResetPeriod enum to a uint256.\n     * @param a  The ResetPeriod enum to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(ResetPeriod a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint256 to a ResetPeriod enum without\n     * performing any bounds checks. Do not use in cases where the reset period may be\n     * outside the acceptable bounds.\n     * @param a  The uint256 to convert.\n     * @return b The resulting ResetPeriod enum.\n     */\n    function asResetPeriod(uint256 a) internal pure returns (ResetPeriod b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * optimizing uint256 arguments. XORs the value with calldatasize(), which\n     * will always be non-zero in a real call.\n     * @param a  The uint256 value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(uint256 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * inlining functions that take fixed bytes32 arguments. Since calldatasize()\n     * will always be non-zero when making a standard function call, an OR\n     * against iszero(calldatasize()) will always result in the original value.\n     * @param a  The bytes32 value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(bytes32 a) internal pure returns (bytes32 b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * inlining functions that take fixed boolean arguments. Since calldatasize()\n     * will always be non-zero when making a standard function call, an OR\n     * against iszero(calldatasize()) will always result in the original value.\n     * @param a  The boolean value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(bool a) internal pure returns (bool b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n}\n"
    }
}