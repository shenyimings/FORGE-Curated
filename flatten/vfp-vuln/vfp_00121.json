{
    "vfp_id": "vfp_00121",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Leverage Zappers Do Not Return Swap Excess",
            "description": "The leverage zapper contracts fail to return excess tokens received from swap operations (e.g., UniV3Exchange and CurveExchange), leaving user funds stranded in the contract. The root cause is the lack of balance tracking before and after swaps and failure to refund leftover tokens. An attacker could exploit market volatility and slippage to generate excess tokens during swaps, which would remain in the zapper and could be drained by others. This leads to user fund loss, as excess BOLD or collateral tokens are not returned. The impact is direct financial loss for users and reduced trust in the system's fund handling.\n",
            "severity": "High",
            "location": [
                "UniV3Exchange.sol::swapFromBold",
                "CurveExchange.sol::swapFromBold",
                "Zapper contracts::openLeveragedTroveWithRawETH",
                "Zapper contracts::leverUpTrove",
                "Zapper contracts::leverDownTrove"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        }
    ],
    "affected_files": {
        "CurveExchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../Interfaces/IBoldToken.sol\";\nimport \"./Curve/ICurvePool.sol\";\nimport \"../../Interfaces/IExchange.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract CurveExchange is IExchange {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    ICurvePool public immutable curvePool;\n    uint256 public immutable COLL_TOKEN_INDEX;\n    uint256 public immutable BOLD_TOKEN_INDEX;\n\n    constructor(\n        IERC20 _collToken,\n        IBoldToken _boldToken,\n        ICurvePool _curvePool,\n        uint256 _collIndex,\n        uint256 _boldIndex\n    ) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        curvePool = _curvePool;\n        COLL_TOKEN_INDEX = _collIndex;\n        BOLD_TOKEN_INDEX = _boldIndex;\n    }\n\n    // Helper to get the actual bold we need, capped by a max value, to get flash loan amount\n    function getBoldAmountToSwap(uint256 _boldAmount, uint256 _maxBoldAmount, uint256 _minCollAmount)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 step = (_maxBoldAmount - _boldAmount) / 5; // In max 5 iterations we should reach the target, unless price is lower\n        uint256 dy;\n        // TODO: Optimizations: binary search, change the step depending on last dy, ...\n        // Or check if thereâ€™s any helper implemented anywhere\n        uint256 lastBoldAmount = _maxBoldAmount + step;\n        do {\n            lastBoldAmount -= step;\n            dy = curvePool.get_dy(BOLD_TOKEN_INDEX, COLL_TOKEN_INDEX, lastBoldAmount);\n        } while (dy > _minCollAmount && lastBoldAmount > step);\n\n        uint256 boldAmountToSwap = dy >= _minCollAmount ? lastBoldAmount : lastBoldAmount + step;\n        require(boldAmountToSwap <= _maxBoldAmount, \"Bold amount required too high\");\n\n        return boldAmountToSwap;\n    }\n\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount, address _zapper) external returns (uint256) {\n        ICurvePool curvePoolCached = curvePool;\n        IBoldToken boldTokenCached = boldToken;\n        boldTokenCached.transferFrom(_zapper, address(this), _boldAmount);\n        boldTokenCached.approve(address(curvePoolCached), _boldAmount);\n\n        // TODO: make this work\n        //return curvePoolCached.exchange(BOLD_TOKEN_INDEX, COLL_TOKEN_INDEX, _boldAmount, _minCollAmount, false, _zapper);\n        uint256 output = curvePoolCached.exchange(BOLD_TOKEN_INDEX, COLL_TOKEN_INDEX, _boldAmount, _minCollAmount);\n        collToken.safeTransfer(_zapper, output);\n\n        return output;\n    }\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount, address _zapper) external returns (uint256) {\n        ICurvePool curvePoolCached = curvePool;\n        IERC20 collTokenCached = collToken;\n        collTokenCached.safeTransferFrom(_zapper, address(this), _collAmount);\n        collTokenCached.approve(address(curvePoolCached), _collAmount);\n\n        //return curvePoolCached.exchange(COLL_TOKEN_INDEX, BOLD_TOKEN_INDEX, _collAmount, _minBoldAmount, false, _zapper);\n        uint256 output = curvePoolCached.exchange(COLL_TOKEN_INDEX, BOLD_TOKEN_INDEX, _collAmount, _minBoldAmount);\n        boldToken.transfer(_zapper, output);\n\n        return output;\n    }\n}\n",
        "UniV3Exchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"../../../Interfaces/IBoldToken.sol\";\nimport \"./UniswapV3/ISwapRouter.sol\";\nimport \"./UniswapV3/IQuoterV2.sol\";\nimport \"./UniswapV3/IUniswapV3SwapCallback.sol\";\nimport \"../../Interfaces/IExchange.sol\";\nimport {DECIMAL_PRECISION} from \"../../../Dependencies/Constants.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract UniV3Exchange is IExchange, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    uint24 public immutable fee;\n    ISwapRouter public immutable uniV3Router;\n    IQuoterV2 public immutable uniV3Quoter;\n\n    // From library TickMath\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    //uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    //uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    constructor(\n        IERC20 _collToken,\n        IBoldToken _boldToken,\n        uint24 _fee,\n        ISwapRouter _uniV3Router,\n        IQuoterV2 _uniV3Quoter\n    ) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        fee = _fee;\n        uniV3Router = _uniV3Router;\n        uniV3Quoter = _uniV3Quoter;\n    }\n\n    // See: https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IQuoterV2\n    // These functions are not marked view because they rely on calling non-view functions and reverting to compute the result.\n    // They are also not gas efficient and should not be called on-chain.\n    function getBoldAmountToSwap(uint256, /*_boldAmount*/ uint256 _maxBoldAmount, uint256 _minCollAmount)\n        external /* view */\n        returns (uint256)\n    {\n        // See: https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L608\n        //uint160 sqrtPriceLimitX96 = _zeroForOne(boldToken, collToken) ? MIN_SQRT_RATIO + 1: MAX_SQRT_RATIO - 1;\n        uint256 maxPrice = _maxBoldAmount * DECIMAL_PRECISION / _minCollAmount;\n        uint160 sqrtPriceLimitX96 = priceToSqrtPrice(boldToken, collToken, maxPrice);\n        IQuoterV2.QuoteExactOutputSingleParams memory params = IQuoterV2.QuoteExactOutputSingleParams({\n            tokenIn: address(boldToken),\n            tokenOut: address(collToken),\n            amount: _minCollAmount,\n            fee: fee,\n            sqrtPriceLimitX96: sqrtPriceLimitX96\n        });\n        (uint256 amountIn,,,) = uniV3Quoter.quoteExactOutputSingle(params);\n\n        return amountIn;\n    }\n\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount, address _zapper) external returns (uint256) {\n        ISwapRouter uniV3RouterCached = uniV3Router;\n        IBoldToken boldTokenCached = boldToken;\n        boldTokenCached.transferFrom(_zapper, address(this), _boldAmount);\n        boldTokenCached.approve(address(uniV3RouterCached), _boldAmount);\n\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({\n            tokenIn: address(boldTokenCached),\n            tokenOut: address(collToken),\n            fee: fee,\n            recipient: _zapper,\n            deadline: block.timestamp,\n            amountOut: _minCollAmount,\n            amountInMaximum: _boldAmount,\n            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205\n        });\n\n        return uniV3RouterCached.exactOutputSingle(params);\n    }\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount, address _zapper) external returns (uint256) {\n        ISwapRouter uniV3RouterCached = uniV3Router;\n        IERC20 collTokenCached = collToken;\n        collTokenCached.safeTransferFrom(_zapper, address(this), _collAmount);\n        collTokenCached.approve(address(uniV3RouterCached), _collAmount);\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(collTokenCached),\n            tokenOut: address(boldToken),\n            fee: fee,\n            recipient: _zapper,\n            deadline: block.timestamp,\n            amountIn: _collAmount,\n            amountOutMinimum: _minBoldAmount,\n            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205\n        });\n\n        return uniV3RouterCached.exactInputSingle(params);\n    }\n\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {\n        //_requireCallerIsUniV3Router();\n        IBoldToken boldTokenCached = boldToken;\n        IERC20 collTokenCached = collToken;\n        IERC20 token0;\n        IERC20 token1;\n        if (_zeroForOne(boldTokenCached, collTokenCached)) {\n            token0 = boldTokenCached;\n            token1 = collTokenCached;\n        } else {\n            token0 = collTokenCached;\n            token1 = boldTokenCached;\n        }\n\n        if (amount0Delta > 0) {\n            token0.transfer(msg.sender, uint256(amount0Delta));\n        }\n        if (amount1Delta > 0) {\n            token1.transfer(msg.sender, uint256(amount1Delta));\n        }\n    }\n\n    function priceToSqrtPrice(IBoldToken _boldToken, IERC20 _collToken, uint256 _price) public pure returns (uint160) {\n        // inverse price if Bold goes first\n        uint256 price = _zeroForOne(_boldToken, _collToken) ? DECIMAL_PRECISION * DECIMAL_PRECISION / _price : _price;\n        return uint160(Math.sqrt((price << 192) / DECIMAL_PRECISION));\n    }\n\n    // See: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol#L207C9-L207C60\n    function _zeroForOne(IBoldToken _boldToken, IERC20 _collToken) internal pure returns (bool) {\n        return address(_boldToken) < address(_collToken);\n    }\n\n    function _requireCallerIsUniV3Router() internal view {\n        require(msg.sender == address(uniV3Router), \"Not UniV3Router\");\n    }\n}\n"
    }
}