{
    "vfp_id": "vfp_00241",
    "project_name": "SoSoValue - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Lack of domain separation allows signature replay",
            "description": "The `checkOrderInfo` function in the Swap contract verifies order signatures using `SignatureChecker.isValidSignatureNow` but does not include the contract address or any domain separator in the hash. This means a valid signature for one Swap contract can be replayed on another.\n\nThe root cause is the absence of EIP-712-style domain separation. The order hash is computed solely from the order data, making it portable across contracts.\n\nAn attacker could replay a valid order signature from one asset's Swap contract to another, potentially triggering unauthorized mint, redeem, or fee-burn operations if the order parameters align.\n\nThe impact includes cross-contract order replay, allowing manipulation of multiple assets with a single signature. Although structures differ between Swap and USSI, preventing direct cross-contract replay, the lack of domain separation remains a security anti-pattern that increases risk.\n",
            "severity": "Medium",
            "location": [
                "Swap::checkOrderInfo",
                "USSI::checkHedgeOrder"
            ],
            "files": [
                "ssi-protocol/src/Swap.sol"
            ]
        }
    ],
    "affected_files": {
        "Swap.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport './Interface.sol';\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {Utils} from './Utils.sol';\n\ncontract Swap is Initializable, UUPSUpgradeable, PausableUpgradeable, AccessControlUpgradeable, ISwap {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    string public chain;\n    EnumerableSet.Bytes32Set orderHashs;\n    mapping(bytes32 => SwapRequest) swapRequests;\n\n    bytes32 public constant TAKER_ROLE = keccak256(\"TAKER_ROLE\");\n    bytes32 public constant MAKER_ROLE = keccak256(\"MAKER_ROLE\");\n\n    mapping(string => bool) outWhiteAddresses;\n    string[] public takerReceivers;\n    string[] public takerSenders;\n\n    uint256 public constant MAX_MARKER_CONFIRM_DELAY = 1 hours;\n    uint256 public constant EXPIRATION = 6 hours;\n\n    EnumerableSet.Bytes32Set whiteListTokenHashs;\n    mapping(bytes32 => Token) public whiteListTokens;\n\n    event AddSwapRequest(address indexed taker, bool inByContract, bool outByContract, OrderInfo orderInfo);\n    event MakerConfirmSwapRequest(address indexed maker, bytes32 orderHash);\n    event ConfirmSwapRequest(address indexed taker, bytes32 orderHash);\n    event MakerRejectSwapRequest(address indexed maker, bytes32 orderHash);\n    event RollbackSwapRequest(address indexed taker, bytes32 orderHash);\n    event SetTakerAddresses(string[] receivers, string[] senders);\n    event CancelSwapRequest(address indexed taker, bytes32 orderHash);\n    event ForceCancelSwapRequest(bytes32 orderHash);\n    event AddWhiteListToken(Token token);\n    event RemoveWhiteListToken(Token token);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address owner,\n        string memory chain_\n    ) public initializer {\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n        __Pausable_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n        chain = chain_;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function checkOrderInfo(OrderInfo memory orderInfo) public view returns (uint) {\n        if (block.timestamp >= orderInfo.order.deadline) {\n            return 1;\n        }\n        bytes32 orderHash = keccak256(abi.encode(orderInfo.order));\n        if (orderHash != orderInfo.orderHash) {\n            return 2;\n        }\n        if (!SignatureChecker.isValidSignatureNow(orderInfo.order.maker, orderHash, orderInfo.orderSign)) {\n            return 3;\n        }\n        if (orderHashs.contains(orderHash)) {\n            return 4;\n        }\n        if (orderInfo.order.inAddressList.length != orderInfo.order.inTokenset.length) {\n            return 5;\n        }\n        if (orderInfo.order.outAddressList.length != orderInfo.order.outTokenset.length) {\n            return 6;\n        }\n        if (!hasRole(MAKER_ROLE, orderInfo.order.maker)) {\n            return 7;\n        }\n        for (uint i = 0; i < orderInfo.order.outAddressList.length; i++) {\n            if (!outWhiteAddresses[orderInfo.order.outAddressList[i]]) {\n                return 8;\n            }\n        }\n        if (keccak256(abi.encode(orderInfo.order.chain)) != keccak256(abi.encode(chain))) {\n            return 9;\n        }\n        for (uint i = 0; i < orderInfo.order.inTokenset.length; i++) {\n            if (!whiteListTokenHashs.contains(Utils.calcTokenHash(orderInfo.order.inTokenset[i]))) {\n                return 10;\n            }\n        }\n        for (uint i = 0; i < orderInfo.order.outTokenset.length; i++) {\n            if (!whiteListTokenHashs.contains(Utils.calcTokenHash(orderInfo.order.outTokenset[i]))) {\n                return 11;\n            }\n        }\n        return 0;\n    }\n\n    function validateOrderInfo(OrderInfo memory orderInfo) internal view {\n        require(orderHashs.contains(orderInfo.orderHash), \"order hash not exists\");\n        require(orderInfo.orderHash == keccak256(abi.encode(orderInfo.order)), \"order hash invalid\");\n    }\n\n    function getOrderHashs() external view returns (bytes32[] memory) {\n        return orderHashs.values();\n    }\n\n    function getOrderHashLength() external view returns (uint256) {\n        return orderHashs.length();\n    }\n\n    function getOrderHash(uint256 idx) external view returns (bytes32) {\n        require(idx < orderHashs.length(), \"out of range\");\n        return orderHashs.at(idx);\n    }\n\n    function checkTokenset(Token[] memory tokenset, string[] memory addressList) internal view {\n        require(tokenset.length == addressList.length, \"tokenset length not match addressList length\");\n        for (uint i = 0; i < tokenset.length; i++) {\n            require(bytes32(bytes(tokenset[i].chain)) == bytes32(bytes(chain)), \"chain not match\");\n            address tokenAddress = Utils.stringToAddress(tokenset[i].addr);\n            require(tokenAddress != address(0), \"zero token address\");\n            address receiveAddress = Utils.stringToAddress(addressList[i]);\n            require(receiveAddress != address(0), \"zero receive address\");\n        }\n    }\n\n    function addSwapRequest(OrderInfo memory orderInfo, bool inByContract, bool outByContract) external onlyRole(TAKER_ROLE) whenNotPaused {\n        uint code = checkOrderInfo(orderInfo);\n        require(code == 0, \"order not valid\");\n        swapRequests[orderInfo.orderHash].status = SwapRequestStatus.PENDING;\n        swapRequests[orderInfo.orderHash].requester = msg.sender;\n        orderHashs.add(orderInfo.orderHash);\n        if (inByContract) {\n            checkTokenset(orderInfo.order.inTokenset, orderInfo.order.inAddressList);\n        }\n        if (outByContract) {\n            checkTokenset(orderInfo.order.outTokenset, orderInfo.order.outAddressList);\n        }\n        swapRequests[orderInfo.orderHash].inByContract = inByContract;\n        swapRequests[orderInfo.orderHash].outByContract = outByContract;\n        swapRequests[orderInfo.orderHash].blocknumber = block.number;\n        swapRequests[orderInfo.orderHash].requestTimestamp = block.timestamp;\n        emit AddSwapRequest(msg.sender, inByContract, outByContract, orderInfo);\n    }\n\n    function getSwapRequest(bytes32 orderHash) external view returns (SwapRequest memory) {\n        return swapRequests[orderHash];\n    }\n\n    function cancelSwapRequest(OrderInfo memory orderInfo) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].requester == msg.sender, \"not order taker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING, \"swap request status is not pending\");\n        require(swapRequests[orderHash].requestTimestamp + MAX_MARKER_CONFIRM_DELAY <= block.timestamp, \"swap request not timeout\");\n        swapRequests[orderHash].status = SwapRequestStatus.CANCEL;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit CancelSwapRequest(msg.sender, orderHash);\n    }\n\n    function forceCancelSwapRequest(OrderInfo memory orderInfo) external onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING || swapRequests[orderHash].status == SwapRequestStatus.MAKER_CONFIRMED, \"swap request status is not pending or maker confirmed\");\n        require(swapRequests[orderHash].requestTimestamp + EXPIRATION <= block.timestamp, \"swap request not expired\");\n        swapRequests[orderHash].status = SwapRequestStatus.FORCE_CANCEL;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit ForceCancelSwapRequest(orderHash);\n    }\n\n    function makerRejectSwapRequest(OrderInfo memory orderInfo) external onlyRole(MAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(orderInfo.order.maker == msg.sender, \"not order maker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING, \"swap request status is not pending\");\n        swapRequests[orderHash].status = SwapRequestStatus.REJECTED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit MakerRejectSwapRequest(msg.sender, orderHash);\n    }\n\n    function transferTokenset(address from, Token[] memory tokenset, uint256 amount, string[] memory toAddressList) internal {\n        for (uint i = 0; i < tokenset.length; i++) {\n            address tokenAddress = Utils.stringToAddress(tokenset[i].addr);\n            address to = Utils.stringToAddress(toAddressList[i]);\n            IERC20 token = IERC20(tokenAddress);\n            uint tokenAmount = tokenset[i].amount * amount / 10**8;\n            require(token.balanceOf(from) >= tokenAmount, \"not enough balance\");\n            require(token.allowance(from, address(this)) >= tokenAmount, \"not enough allowance\");\n            token.safeTransferFrom(from, to, tokenAmount);\n        }\n    }\n\n    function makerConfirmSwapRequest(OrderInfo memory orderInfo, bytes[] memory outTxHashs) external onlyRole(MAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        SwapRequest memory swapRequest = swapRequests[orderHash];\n        require(orderInfo.order.maker == msg.sender, \"not order maker\");\n        require(swapRequest.status == SwapRequestStatus.PENDING, \"status error\");\n        if (swapRequest.outByContract) {\n            transferTokenset(msg.sender, orderInfo.order.outTokenset, orderInfo.order.outAmount, orderInfo.order.outAddressList);\n        } else {\n            require(orderInfo.order.outTokenset.length == outTxHashs.length, \"wrong outTxHashs length\");\n            swapRequests[orderHash].outTxHashs = outTxHashs;\n        }\n        swapRequests[orderHash].status = SwapRequestStatus.MAKER_CONFIRMED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit MakerConfirmSwapRequest(msg.sender, orderHash);\n    }\n\n    function rollbackSwapRequest(OrderInfo memory orderInfo) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].requester == msg.sender, \"not order taker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.MAKER_CONFIRMED, \"swap request status is not maker_confirmed\");\n        require(!swapRequests[orderHash].outByContract, \"out by contract cannot rollback\");\n        swapRequests[orderHash].status = SwapRequestStatus.PENDING;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit RollbackSwapRequest(msg.sender, orderHash);\n    }\n\n    function confirmSwapRequest(OrderInfo memory orderInfo, bytes[] memory inTxHashs) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        SwapRequest memory swapRequest = swapRequests[orderHash];\n        require(swapRequest.requester == msg.sender, \"not order taker\");\n        require(swapRequest.status == SwapRequestStatus.MAKER_CONFIRMED, \"status error\");\n         if (swapRequest.inByContract) {\n            transferTokenset(msg.sender, orderInfo.order.inTokenset, orderInfo.order.inAmount, orderInfo.order.inAddressList);\n        } else {\n            require(orderInfo.order.inTokenset.length == inTxHashs.length, \"wrong inTxHashs length\");\n            swapRequests[orderHash].inTxHashs = inTxHashs;\n        }\n        swapRequests[orderHash].status = SwapRequestStatus.CONFIRMED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit ConfirmSwapRequest(msg.sender, orderHash);\n    }\n\n    function setTakerAddresses(string[] memory takerReceivers_, string[] memory takerSenders_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < takerReceivers.length; i++) {\n            outWhiteAddresses[takerReceivers[i]] = false;\n        }\n        delete takerReceivers;\n        for (uint i = 0; i < takerReceivers_.length; i++) {\n            takerReceivers.push(takerReceivers_[i]);\n            outWhiteAddresses[takerReceivers[i]] = true;\n        }\n        delete takerSenders;\n        for (uint i = 0; i < takerSenders_.length; i++) {\n            takerSenders.push(takerSenders_[i]);\n        }\n        emit SetTakerAddresses(takerReceivers, takerSenders);\n    }\n\n    function getTakerAddresses() external view returns (string[] memory receivers, string[] memory senders) {\n        return (takerReceivers, takerSenders);\n    }\n\n    function addWhiteListTokens(Token[] memory tokens) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < tokens.length; i++) {\n            bytes32 tokenHash = Utils.calcTokenHash(tokens[i]);\n            if (whiteListTokenHashs.add(tokenHash)) {\n                whiteListTokens[tokenHash].chain = tokens[i].chain;\n                whiteListTokens[tokenHash].symbol = tokens[i].symbol;\n                whiteListTokens[tokenHash].addr = tokens[i].addr;\n                whiteListTokens[tokenHash].decimals = tokens[i].decimals;\n                emit AddWhiteListToken(tokens[i]);\n            }\n        }\n    }\n\n    function removeWhiteListTokens(Token[] memory tokens) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < tokens.length; i++) {\n            bytes32 tokenHash = Utils.calcTokenHash(tokens[i]);\n            if (whiteListTokenHashs.remove(tokenHash)) {\n                delete whiteListTokens[tokenHash];\n                emit RemoveWhiteListToken(tokens[i]);\n            }\n        }\n    }\n\n    function getWhiteListTokens() external view returns (Token[] memory tokens) {\n        tokens = new Token[](whiteListTokenHashs.length());\n        for (uint i = 0; i < tokens.length; i++) {\n            tokens[i] = whiteListTokens[whiteListTokenHashs.at(i)];\n        }\n    }\n\n    function getWhiteListTokenLength() external view returns (uint256) {\n        return whiteListTokenHashs.length();\n    }\n\n    function getWhiteListToken(uint256 nonce) external view returns (Token memory token) {\n        return whiteListTokens[whiteListTokenHashs.at(nonce)];\n    }\n}\n"
    }
}