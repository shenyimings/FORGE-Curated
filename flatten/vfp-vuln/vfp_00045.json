{
    "vfp_id": "vfp_00045",
    "project_name": "cantina_coinbase_bridge_aug2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Unbounded message size could cause temporary fund lock due to Solana transaction limits",
            "description": "The Bridge contract allows users to send messages of arbitrary size from Base to Solana without enforcing size constraints that exist on the Solana side. This asymmetry allows users to send oversized messages that exceed Solana's 1232-byte transaction limit, making them unprocessable. The root cause is the lack of input validation on the Base side before locking funds or burning tokens. An attacker could exploit this by sending a message larger than 1232 bytes, which would fail on Solana, resulting in temporary fund lock. The impact is temporary loss of funds, which could be recovered via a program upgrade, hence classified as medium impact.\n",
            "severity": "Medium",
            "location": [
                "MessageStorageLib.sol#L157",
                "prove_message.rs#L55"
            ],
            "files": [
                "bridge/base/src/libraries/MessageStorageLib.sol"
            ]
        }
    ],
    "affected_files": {
        "MessageStorageLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {EfficientHashLib} from \"solady/utils/EfficientHashLib.sol\";\n\n/// @notice Storage layout used by this library.\n///\n/// @custom:storage-location erc7201:coinbase.storage.MessageStorageLib\n///\n/// @custom:field nextNonce Number of messages sent.\n/// @custom:field root Current MMR root hash.\n/// @custom:field nodes All nodes (leaves and internal) in the MMR.\nstruct MessageStorageLibStorage {\n    uint64 nextNonce;\n    bytes32 root;\n    bytes32[] nodes;\n}\n\n/// @notice Struct representing a message to the Solana bridge.\n///\n/// @custom:field nonce Unique nonce for the message.\n/// @custom:field sender Sender address.\n/// @custom:field data Message data to be passed to the Solana bridge.\nstruct Message {\n    uint64 nonce;\n    address sender;\n    bytes data;\n}\n\nlibrary MessageStorageLib {\n    //////////////////////////////////////////////////////////////\n    ///                       Constants                        ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice A bit to be used in bitshift operations\n    uint256 private constant _BIT = 1;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Events                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a message is registered.\n    ///\n    /// @param messageHash The message's hash.\n    /// @param mmrRoot The root of the MMR after the message is registered.\n    /// @param message The message.\n    event MessageRegistered(bytes32 indexed messageHash, bytes32 indexed mmrRoot, Message message);\n\n    //////////////////////////////////////////////////////////////\n    ///                       Errors                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when failing to locate a leaf in the MMR structure\n    error LeafNotFound();\n\n    /// @notice Thrown when trying to generate a proof for an empty MMR\n    error EmptyMMR();\n\n    /// @notice Thrown when the leaf index is out of bounds\n    error LeafIndexOutOfBounds();\n\n    /// @notice Thrown when a sibling node index is out of bounds\n    error SiblingNodeOutOfBounds();\n\n    //////////////////////////////////////////////////////////////\n    ///                       Constants                        ///\n    //////////////////////////////////////////////////////////////\n\n    /// @dev Slot for the `MessageStorageLibStorage` struct in storage.\n    ///      Computed from:\n    ///         keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MessageStorageLib\")) - 1)) &\n    ///         ~bytes32(uint256(0xff))\n    ///\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant _MESSAGE_STORAGE_LIB_STORAGE_LOCATION =\n        0x4f00c1a67879b7469d7dd58849b9cbcdedefec3f3b862c2933a36197db136100;\n\n    /// @notice Maximum number of peaks possible in the MMR\n    uint256 private constant _MAX_PEAKS = 64;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Internal Functions               ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Helper function to get a storage reference to the `MessageStorageLibStorage` struct.\n    ///\n    /// @return $ A storage reference to the `MessageStorageLibStorage` struct.\n    function getMessageStorageLibStorage() internal pure returns (MessageStorageLibStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := _MESSAGE_STORAGE_LIB_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Generates an MMR inclusion proof for a specific leaf.\n    ///\n    /// @dev This function may consume significant gas for large MMRs (O(log N) storage reads).\n    ///\n    /// @param leafIndex The 0-indexed position of the leaf to prove.\n    ///\n    /// @return proof Array of sibling hashes for the proof.\n    /// @return totalLeafCount The total number of leaves when proof was generated.\n    function generateProof(uint64 leafIndex) internal view returns (bytes32[] memory proof, uint64 totalLeafCount) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        require($.nextNonce != 0, EmptyMMR());\n        require(leafIndex < $.nextNonce, LeafIndexOutOfBounds());\n\n        (uint256 leafNodePos, uint256 mountainHeight, uint64 leafIdxInMountain, bytes32[] memory otherPeaks) =\n            _generateProofData(leafIndex);\n\n        // Generate intra-mountain proof directly\n        bytes32[] memory intraMountainProof = new bytes32[](mountainHeight);\n        uint256 currentPathNodePos = leafNodePos;\n\n        for (uint256 hClimb = 0; hClimb < mountainHeight; hClimb++) {\n            bool isRightChildInSubtree = (leafIdxInMountain >> hClimb) & 1 == 1;\n\n            uint256 siblingNodePos;\n            uint256 parentNodePos;\n\n            if (isRightChildInSubtree) {\n                parentNodePos = currentPathNodePos + 1;\n                siblingNodePos = parentNodePos - (_BIT << (hClimb + 1));\n            } else {\n                parentNodePos = currentPathNodePos + (_BIT << (hClimb + 1));\n                siblingNodePos = parentNodePos - 1;\n            }\n\n            require(siblingNodePos < $.nodes.length, SiblingNodeOutOfBounds());\n\n            intraMountainProof[hClimb] = $.nodes[siblingNodePos];\n            currentPathNodePos = parentNodePos;\n        }\n\n        // Combine proof elements\n        proof = new bytes32[](intraMountainProof.length + otherPeaks.length);\n        uint256 proofIndex = 0;\n\n        for (uint256 i = 0; i < intraMountainProof.length; i++) {\n            proof[proofIndex++] = intraMountainProof[i];\n        }\n\n        for (uint256 i = 0; i < otherPeaks.length; i++) {\n            proof[proofIndex++] = otherPeaks[i];\n        }\n\n        totalLeafCount = $.nextNonce;\n    }\n\n    /// @notice Sends a message to the Solana bridge.\n    ///\n    /// @param sender The message's sender address.\n    /// @param data Message data to be passed to the Solana bridge.\n    function sendMessage(address sender, bytes memory data) internal {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        Message memory message = Message({nonce: $.nextNonce, sender: sender, data: data});\n        bytes32 messageHash = _hashMessage(message);\n        bytes32 mmrRoot = _appendLeafToMmr({leafHash: messageHash, originalLeafCount: $.nextNonce});\n\n        unchecked {\n            ++$.nextNonce;\n        }\n\n        emit MessageRegistered({messageHash: messageHash, mmrRoot: mmrRoot, message: message});\n    }\n\n    //////////////////////////////////////////////////////////////\n    ///                     Private Functions                  ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Computes the hash of a message.\n    ///\n    /// @param message The message to hash.\n    ///\n    /// @return The keccak256 hash of the encoded message.\n    function _hashMessage(Message memory message) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(message.nonce, message.sender, message.data));\n    }\n\n    /// @notice Appends a new leaf to the MMR.\n    ///\n    /// @param leafHash The hash of the leaf to append.\n    /// @param originalLeafCount The amount of MMR leaves before the append.\n    ///\n    /// @return newRoot The new root of the MMR after the append is complete.\n    function _appendLeafToMmr(bytes32 leafHash, uint64 originalLeafCount) private returns (bytes32) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        // Add the leaf to the nodes array\n        $.nodes.push(leafHash);\n\n        // The MMR position of the leaf we just added\n        uint256 newLeafNodeIndex = $.nodes.length - 1;\n\n        // Form parent nodes by merging when possible\n        _createParentNodes(newLeafNodeIndex, originalLeafCount);\n\n        // Update and return the new root\n        bytes32 newRoot = _calculateRoot(originalLeafCount + 1);\n        $.root = newRoot;\n        return newRoot;\n    }\n\n    /// @notice Creates parent nodes by merging when the binary representation allows it.\n    ///\n    /// @param leafNodeIndex The index of the newly added leaf node.\n    /// @param originalLeafCount The original leaf count before adding the new leaf.\n    function _createParentNodes(uint256 leafNodeIndex, uint64 originalLeafCount) private {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        uint256 currentNodeIndex = leafNodeIndex;\n        uint256 currentHeight = 0;\n\n        // Loop to create parent nodes when merging is possible\n        while (_hasCompleteMountainAtHeight(originalLeafCount, currentHeight)) {\n            uint256 leftSiblingIndex = _calculateLeftSiblingIndex(currentNodeIndex, currentHeight);\n\n            // Get the hashes to merge\n            bytes32 leftNodeHash = $.nodes[leftSiblingIndex];\n            bytes32 rightNodeHash = $.nodes[currentNodeIndex];\n\n            // Create and store the parent node\n            bytes32 parentNodeHash = _hashInternalNode(leftNodeHash, rightNodeHash);\n            $.nodes.push(parentNodeHash);\n\n            // Update for next iteration\n            currentNodeIndex = $.nodes.length - 1;\n            currentHeight++;\n        }\n    }\n\n    /// @notice Optimized single traversal to get leaf position and other peaks.\n    ///\n    /// @param leafIndex The 0-indexed position of the leaf to prove.\n    ///\n    /// @return leafNodePos Position of the leaf in the _nodes array.\n    /// @return mountainHeight Height of the mountain containing the leaf.\n    /// @return leafIdxInMountain Position of leaf within its mountain.\n    /// @return otherPeaks Hashes of other mountain peaks.\n    function _generateProofData(uint64 leafIndex)\n        private\n        view\n        returns (uint256 leafNodePos, uint256 mountainHeight, uint64 leafIdxInMountain, bytes32[] memory otherPeaks)\n    {\n        // First pass: find the leaf mountain\n        (leafNodePos, mountainHeight, leafIdxInMountain) = _findLeafMountain(leafIndex);\n\n        // Second pass: collect other peaks\n        otherPeaks = _collectOtherPeaks(leafIndex);\n    }\n\n    /// @notice Finds leaf mountain with minimal local variables\n    ///\n    /// @param leafIndex The 0-indexed position of the leaf to prove.\n    ///\n    /// @return Position of the leaf in the _nodes array.\n    /// @return Height of the mountain containing the leaf.\n    /// @return Position of leaf within its mountain.\n    function _findLeafMountain(uint64 leafIndex) private view returns (uint256, uint256, uint64) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        uint256 nodeOffset = 0;\n        uint64 leafOffset = 0;\n        uint256 maxHeight = _calculateMaxPossibleHeight($.nextNonce);\n\n        for (uint256 h = maxHeight + 1; h > 0; h--) {\n            uint256 height = h - 1;\n\n            if (($.nextNonce >> height) & 1 == 1) {\n                uint64 mountainLeaves = uint64(_BIT << height);\n\n                if (leafIndex >= leafOffset && leafIndex < leafOffset + mountainLeaves) {\n                    // Found the mountain\n                    uint64 localLeafIdx = leafIndex - leafOffset;\n                    uint256 localNodePos = 2 * uint256(localLeafIdx) - _popcount(localLeafIdx);\n                    return (nodeOffset + localNodePos, height, localLeafIdx);\n                }\n\n                nodeOffset += _calculateTreeSize(height);\n                leafOffset += mountainLeaves;\n            }\n        }\n\n        revert LeafNotFound();\n    }\n\n    /// @notice Collects other mountain peaks.\n    ///\n    /// @param leafIndex The 0-indexed position of the leaf to prove.\n    ///\n    /// @return Hashes of other mountain peaks in left-to-right order.\n    function _collectOtherPeaks(uint64 leafIndex) private view returns (bytes32[] memory) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        bytes32[] memory tempPeaks = new bytes32[](_MAX_PEAKS);\n        uint256 peakCount = 0;\n        uint256 nodeOffset = 0;\n        uint64 leafOffset = 0;\n        uint256 maxHeight = _calculateMaxPossibleHeight($.nextNonce);\n\n        // Collect peaks in left-to-right order (largest to smallest mountain)\n        for (uint256 h = maxHeight + 1; h > 0; h--) {\n            uint256 height = h - 1;\n\n            if (($.nextNonce >> height) & 1 == 1) {\n                uint64 mountainLeaves = uint64(_BIT << height);\n                bool isLeafMountain = (leafIndex >= leafOffset && leafIndex < leafOffset + mountainLeaves);\n                uint256 treeSize = _calculateTreeSize(height);\n\n                if (!isLeafMountain) {\n                    uint256 peakPos = nodeOffset + treeSize - 1;\n                    tempPeaks[peakCount++] = $.nodes[peakPos];\n                }\n\n                nodeOffset += treeSize;\n                leafOffset += mountainLeaves;\n            }\n        }\n\n        // Use assembly to truncate tempPeaks to exact size\n        assembly (\"memory-safe\") {\n            mstore(tempPeaks, peakCount)\n        }\n\n        return tempPeaks;\n    }\n\n    /// @notice Calculates the current root by \"bagging the peaks\".\n    ///\n    /// @param currentLeafCount Number of leaves to compute the root for.\n    ///\n    /// @return The MMR root.\n    function _calculateRoot(uint64 currentLeafCount) private view returns (bytes32) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        uint256 nodeCount = $.nodes.length;\n\n        if (nodeCount == 0) {\n            return bytes32(0);\n        }\n\n        uint256[] memory peakIndices = _getPeakNodeIndicesForLeafCount(currentLeafCount);\n\n        if (peakIndices.length == 0) {\n            return bytes32(0);\n        }\n\n        // Single peak case: return the peak directly\n        if (peakIndices.length == 1) {\n            return $.nodes[peakIndices[0]];\n        }\n\n        return _hashPeaksSequentially(peakIndices);\n    }\n\n    /// @notice Hashes all peaks sequentially from left to right.\n    ///\n    /// @param peakIndices Array of peak node indices (ordered from leftmost to rightmost).\n    ///\n    /// @return The final root hash after hashing all peaks.\n    function _hashPeaksSequentially(uint256[] memory peakIndices) private view returns (bytes32) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n\n        // Start with the leftmost peak (first in our left-to-right list)\n        bytes32 currentRoot = $.nodes[peakIndices[0]];\n\n        // Sequentially hash with the next peak to the right\n        for (uint256 i = 1; i < peakIndices.length; i++) {\n            bytes32 nextPeakHash = $.nodes[peakIndices[i]];\n            // Bagging peaks must be ORDERED (non-commutative) to bind each\n            // peak to its mountain position/size. Do not sort here.\n            currentRoot = _hashOrderedPair(currentRoot, nextPeakHash);\n        }\n\n        return currentRoot;\n    }\n\n    /// @notice Gets the indices of all peak nodes in the MMR.\n    ///\n    /// @return The indices of the peak nodes ordered from leftmost to rightmost.\n    function _getPeakNodeIndices() private view returns (uint256[] memory) {\n        MessageStorageLibStorage storage $ = getMessageStorageLibStorage();\n        return _getPeakNodeIndicesForLeafCount($.nextNonce);\n    }\n\n    /// @notice Gets the indices of all peak nodes in the MMR for a specific leaf count.\n    ///\n    /// @param leafCount The number of leaves to calculate peaks for.\n    ///\n    /// @return The indices of the peak nodes ordered from leftmost to rightmost.\n    function _getPeakNodeIndicesForLeafCount(uint64 leafCount) private pure returns (uint256[] memory) {\n        if (leafCount == 0) {\n            return new uint256[](0);\n        }\n\n        uint256[] memory tempPeakIndices = new uint256[](_MAX_PEAKS);\n        uint256 peakCount = 0;\n        uint256 nodeOffset = 0;\n\n        uint256 maxHeight = _calculateMaxPossibleHeight(leafCount);\n\n        // Process each possible height from largest to smallest (left-to-right)\n        for (uint256 height = maxHeight + 1; height > 0; height--) {\n            uint256 currentHeight = height - 1;\n            if (_hasCompleteMountainAtHeight(leafCount, currentHeight)) {\n                uint256 peakIndex = _calculatePeakIndex(nodeOffset, currentHeight);\n                tempPeakIndices[peakCount] = peakIndex;\n                peakCount++;\n\n                // Update state for next iteration\n                nodeOffset += _calculateTreeSize(currentHeight);\n            }\n        }\n\n        // Use assembly to truncate tempPeakIndices to exact size\n        assembly (\"memory-safe\") {\n            mstore(tempPeakIndices, peakCount)\n        }\n\n        return tempPeakIndices;\n    }\n\n    /// @notice Calculates the index of the left sibling node\n    ///\n    /// @param currentNodeIndex The index of the current node\n    /// @param height The height of the current level\n    ///\n    /// @return leftSiblingIndex The index of the left sibling node\n    function _calculateLeftSiblingIndex(uint256 currentNodeIndex, uint256 height) private pure returns (uint256) {\n        uint256 leftSubtreeSize = _calculateTreeSize(height);\n        return currentNodeIndex - leftSubtreeSize;\n    }\n\n    /// @notice Calculates the maximum possible height for the given number of leaves.\n    ///\n    /// @param leafCount Number of leaves in the MMR.\n    ///\n    /// @return The maximum possible height.\n    function _calculateMaxPossibleHeight(uint64 leafCount) private pure returns (uint256) {\n        if (leafCount == 0) return 0;\n\n        uint256 maxHeight = 0;\n        uint64 temp = leafCount;\n        while (temp > 0) {\n            maxHeight++;\n            temp >>= 1;\n        }\n        return maxHeight > 0 ? maxHeight - 1 : 0;\n    }\n\n    /// @notice Checks if there's a complete mountain at the given height.\n    ///\n    /// @param leafCount Number of remaining leaves.\n    /// @param height Height to check.\n    ///\n    /// @return True if there's a complete mountain at this height.\n    function _hasCompleteMountainAtHeight(uint64 leafCount, uint256 height) private pure returns (bool) {\n        return (leafCount >> height) & 1 == 1;\n    }\n\n    /// @notice Calculates the peak index for a mountain at the given height.\n    ///\n    /// @param nodeOffset Current offset in the nodes array.\n    /// @param height Height of the mountain.\n    ///\n    /// @return Index of the peak node.\n    function _calculatePeakIndex(uint256 nodeOffset, uint256 height) private pure returns (uint256) {\n        uint256 mountainSize = _calculateTreeSize(height);\n        return nodeOffset + mountainSize - 1;\n    }\n\n    /// @notice Calculates the number of nodes in a complete mountain of given height.\n    ///\n    /// @param height Height of the mountain.\n    ///\n    /// @return Number of nodes in the mountain.\n    function _calculateTreeSize(uint256 height) private pure returns (uint256) {\n        return (_BIT << (height + 1)) - 1;\n    }\n\n    /// @notice Hashes two node hashes together for intra-mountain merges.\n    ///\n    /// @dev Uses sorted inputs for commutative hashing: H(left, right) == H(right, left).\n    ///      This is only used within a single mountain where sibling ordering\n    ///      may not be deterministic.\n    function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32) {\n        if (left < right) {\n            return EfficientHashLib.hash(left, right);\n        }\n        return EfficientHashLib.hash(right, left);\n    }\n\n    /// @notice Ordered hash for bagging peaks left-to-right (non-commutative).\n    ///\n    /// @dev The order is significant to bind each peak to its position and size.\n    function _hashOrderedPair(bytes32 left, bytes32 right) private pure returns (bytes32) {\n        return EfficientHashLib.hash(left, right);\n    }\n\n    /// @notice Calculates the population count (number of 1 bits) in a uint64.\n    ///\n    /// @param x The number to count bits in.\n    ///\n    /// @return The number of 1 bits.\n    function _popcount(uint64 x) private pure returns (uint256) {\n        uint256 count = 0;\n        while (x != 0) {\n            count += x & 1;\n            x >>= 1;\n        }\n        return count;\n    }\n}\n"
    }
}