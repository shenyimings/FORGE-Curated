{
    "vfp_id": "vfp_00175",
    "project_name": "cantina_eco_pr28_pr38_aug2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Signature validation incorrectly handles contract and short signatures",
            "description": "The _verifySignature() function in the NonceManager contract attempts to support 65-byte, 64-byte (ERC-2098), and ERC-1271 contract signatures but fails due to incorrect logic. First, 64-byte signatures are passed directly to ECDSA.recover(), which only accepts 65-byte signatures, causing valid 64-byte signatures to always fail. Second, when the owner is a contract, the function first attempts EOA-based recovery before checking ERC-1271, meaning contract signatures are never validated if they are 64 or 65 bytes long. This creates a critical flaw where valid signatures from both EOAs (64-byte) and contracts are rejected. The impact is that users relying on these signature schemes are locked out of their functionality, breaking core features of the permit system.\n",
            "severity": "High",
            "location": [
                "NonceManager.sol#L216-L233"
            ],
            "files": [
                "833b84f8/permit3/src/NonceManager.sol"
            ]
        }
    ],
    "affected_files": {
        "NonceManager.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { INonceManager } from \"./interfaces/INonceManager.sol\";\nimport { EIP712 } from \"./lib/EIP712.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title NonceManager\n * @notice Manages non-sequential nonces for replay protection in the Permit3 system\n * @dev Key features:\n * - Non-sequential nonces for concurrent operation support\n * - Signature-based nonce invalidation\n * - Cross-chain nonce management\n * - EIP-712 compliant signatures\n */\nabstract contract NonceManager is INonceManager, EIP712 {\n    using ECDSA for bytes32;\n    using SignatureChecker for address;\n\n    /// @dev Constant representing an unused nonce\n    uint256 private constant NONCE_NOT_USED = 0;\n\n    /// @dev Constant representing a used nonce\n    uint256 private constant NONCE_USED = 1;\n\n    /**\n     * @notice Maps owner address to their used nonces\n     * @dev Non-sequential nonces allow parallel operations without conflicts\n     */\n    mapping(address => mapping(bytes32 => uint256)) internal usedNonces;\n\n    /**\n     * @notice EIP-712 typehash for nonce invalidation\n     * @dev Includes chainId for cross-chain replay protection\n     */\n    bytes32 public constant NONCES_TO_INVALIDATE_TYPEHASH =\n        keccak256(\"NoncesToInvalidate(uint64 chainId,bytes32[] salts)\");\n\n    /**\n     * @notice EIP-712 typehash for invalidation signatures\n     * @dev Includes owner, deadline, and unbalanced root for batch operations\n     */\n    bytes32 public constant CANCEL_PERMIT3_TYPEHASH =\n        keccak256(\"CancelPermit3(address owner,uint48 deadline,bytes32 merkleRoot)\");\n\n    /**\n     * @notice Initialize EIP-712 domain separator\n     * @param name Contract name for EIP-712 domain\n     * @param version Contract version for EIP-712 domain\n     */\n    constructor(string memory name, string memory version) EIP712(name, version) { }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Check if a specific nonce has been used\n     * @param owner The address to check nonces for\n     * @param salt The salt value to verify\n     * @return True if nonce has been used, false otherwise\n     */\n    function isNonceUsed(address owner, bytes32 salt) external view returns (bool) {\n        return usedNonces[owner][salt] == NONCE_USED;\n    }\n\n    /**\n     * @notice Directly invalidate multiple nonces without signature\n     * @param salts Array of salts to mark as used\n     */\n    function invalidateNonces(\n        bytes32[] calldata salts\n    ) external {\n        _processNonceInvalidation(msg.sender, salts);\n    }\n\n    /**\n     * @notice Invalidate nonces using a signed message\n     * @param owner Address that signed the invalidation\n     * @param deadline Timestamp after which signature is invalid\n     * @param salts Array of nonce salts to invalidate\n     * @param signature EIP-712 signature authorizing invalidation\n     */\n    function invalidateNonces(\n        address owner,\n        uint48 deadline,\n        bytes32[] calldata salts,\n        bytes calldata signature\n    ) external {\n        if (owner == address(0)) {\n            revert ZeroOwner();\n        }\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (salts.length == 0) {\n            revert EmptyArray();\n        }\n\n        NoncesToInvalidate memory invalidations = NoncesToInvalidate({ chainId: uint64(block.chainid), salts: salts });\n\n        bytes32 signedHash =\n            keccak256(abi.encode(CANCEL_PERMIT3_TYPEHASH, owner, deadline, hashNoncesToInvalidate(invalidations)));\n\n        _verifySignature(owner, signedHash, signature);\n\n        _processNonceInvalidation(owner, invalidations.salts);\n    }\n\n    /**\n     * @notice Cross-chain nonce invalidation using the Unbalanced Merkle Tree approach\n     * @param owner Token owner\n     * @param deadline Signature expiration\n     * @param proof Unbalanced Merkle Tree invalidation proof\n     * @param signature Authorization signature\n     */\n    function invalidateNonces(\n        address owner,\n        uint48 deadline,\n        NoncesToInvalidate calldata invalidations,\n        bytes32[] calldata proof,\n        bytes calldata signature\n    ) external {\n        if (owner == address(0)) {\n            revert ZeroOwner();\n        }\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (invalidations.chainId != uint64(block.chainid)) {\n            revert WrongChainId(uint64(block.chainid), invalidations.chainId);\n        }\n\n        // Calculate the root from the invalidations and proof\n        // processProof performs validation internally and provides granular error messages\n        bytes32 invalidationsHash = hashNoncesToInvalidate(invalidations);\n        bytes32 merkleRoot = MerkleProof.processProof(proof, invalidationsHash);\n\n        bytes32 signedHash = keccak256(abi.encode(CANCEL_PERMIT3_TYPEHASH, owner, deadline, merkleRoot));\n\n        _verifySignature(owner, signedHash, signature);\n\n        _processNonceInvalidation(owner, invalidations.salts);\n    }\n\n    /**\n     * @notice Generate EIP-712 hash for nonce invalidation data\n     * @param invalidations Struct containing chain ID and nonces\n     * @return bytes32 Hash of the invalidation data\n     */\n    function hashNoncesToInvalidate(\n        NoncesToInvalidate memory invalidations\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(NONCES_TO_INVALIDATE_TYPEHASH, invalidations.chainId, invalidations.salts));\n    }\n\n    /**\n     * @dev Process batch nonce invalidation by marking all specified nonces as used\n     * @param owner Token owner whose nonces are being invalidated\n     * @param salts Array of salts to invalidate\n     * @notice This function iterates through all provided salts and:\n     *         1. Marks each nonce as NONCE_USED in the usedNonces mapping\n     *         2. Emits a NonceInvalidated event for each invalidated nonce\n     * @notice This is an internal helper used by the public invalidateNonces functions\n     *         to process the actual invalidation after signature verification\n     */\n    function _processNonceInvalidation(address owner, bytes32[] memory salts) internal {\n        uint256 saltsLength = salts.length;\n\n        require(saltsLength != 0, EmptyArray());\n\n        for (uint256 i = 0; i < saltsLength; i++) {\n            usedNonces[owner][salts[i]] = NONCE_USED;\n            emit NonceInvalidated(owner, salts[i]);\n        }\n    }\n\n    /**\n     * @dev Consume a nonce by marking it as used for replay protection\n     * @param owner Token owner whose nonce is being consumed\n     * @param salt Unique salt value identifying the nonce to consume\n     * @notice This function provides replay protection by:\n     *         1. Checking if the nonce has already been used (NONCE_NOT_USED = 0)\n     *         2. Marking the nonce as used (NONCE_USED = 1)\n     * @notice Reverts with NonceAlreadyUsed() if the nonce was previously consumed\n     * @notice This is called before processing permits to ensure each signature\n     *         can only be used once per salt value\n     */\n    function _useNonce(address owner, bytes32 salt) internal {\n        if (usedNonces[owner][salt] != NONCE_NOT_USED) {\n            revert NonceAlreadyUsed(owner, salt);\n        }\n        usedNonces[owner][salt] = NONCE_USED;\n    }\n\n    /**\n     * @dev Validate EIP-712 signature against expected signer using ECDSA recovery\n     * @param owner Expected message signer to validate against\n     * @param structHash Hash of the signed data structure (pre-hashed message)\n     * @param signature Raw signature bytes in (v, r, s) format for ECDSA recovery\n     * @notice This function:\n     *         1. Computes the EIP-712 compliant digest using _hashTypedDataV4\n     *         2. For short signatures (<=65 bytes), tries ECDSA recovery first\n     *         3. Falls back to ERC-1271 validation for contract wallets or if ECDSA fails\n     *         4. Handles EIP-7702 delegated EOAs correctly\n     * @notice Reverts with InvalidSignature() if the signature is invalid or\n     *         the recovered signer doesn't match the expected owner\n     */\n    function _verifySignature(address owner, bytes32 structHash, bytes calldata signature) internal view {\n        bytes32 digest = _hashTypedDataV4(structHash);\n\n        // For signatures <= 65 bytes (supporting ERC-2098 compact signatures),\n        // try ECDSA recovery first before falling back to ERC-1271\n        uint256 signatureLength = signature.length;\n        if (signatureLength == 64 || signatureLength == 65) {\n            if (digest.recover(signature) == owner) {\n                return;\n            }\n        }\n\n        // For longer signatures or when ECDSA failed with a contract/EIP-7702 EOA,\n        // use ERC-1271 validation\n        if (owner.code.length == 0 || !owner.isValidERC1271SignatureNow(digest, signature)) {\n            revert InvalidSignature(owner);\n        }\n    }\n}\n"
    }
}