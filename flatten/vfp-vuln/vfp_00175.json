{
    "vfp_id": "vfp_00175",
    "project_name": "USDKG _ Consensys Diligence.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-184"
                ]
            },
            "title": "transferFrom() Lacks notBlackListed Modifier on the Spender msg.sender",
            "description": "The USDKG token implements a blacklist mechanism to restrict certain users from interacting with the token, enforced via the `notBlackListed` modifier on functions like `transfer()` and `transferFrom()`. However, in the `transferFrom()` function, the modifier only checks the `_from` address (the token owner) but not the `msg.sender` (the spender). This omission allows a malicious or compromised contract, once approved by a user, to execute `transferFrom()` even if it has been blacklisted. For example, an exploited lending protocol with USDKG approval could be used to drain user funds. By not checking the spender, the system cannot proactively block such contracts from acting as intermediaries in token transfers. This reduces the effectiveness of the blacklist mechanism and allows attackers to bypass restrictions by using vulnerable or malicious smart contracts as conduits.\n",
            "severity": "Medium",
            "location": [
                "contracts/USDKG.sol::transferFrom#122",
                "contracts/USDKG.sol::notBlackListed#86-92"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation for Parameters in the Constructor",
            "description": "The constructor of the `USDKG` contract accepts `_owner` and `_compliance` address parameters but does not validate that these addresses are non-zero. If either parameter is set to the zero address during deployment, critical administrative functions tied to these roles (such as pausing, issuing, redeeming, or blacklisting) will become permanently inoperable, as no account can assume those roles. This creates a single point of failure during deployment. A mistaken or malicious deployment with zero addresses would render the contract partially or fully unusable, leading to a permanent loss of control and governance functionality. This issue stems from the lack of input validation, a common best practice in smart contract development.\n",
            "severity": "Medium",
            "location": [
                "contracts/USDKG.sol::constructor#45-52"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        }
    ],
    "affected_files": {
        "USDKG.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract USDKG is IERC20 {\n\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n\n    // ownable\n    address public owner;\n    address public compliance;\n\n    // ERC20 Basic\n    uint256 public _totalSupply;\n    mapping(address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    uint256 public constant MAX_BASIS_POINTS = 20;\n    uint256 public constant FEE_PRECISION = 10000;\n\n    // variables to manage optional transaction fees, if such functionality is enabled in the future\n    uint256 public basisPointsRate = 0;\n\n    // pausable\n    bool public paused = false;\n\n    // blacklist\n    mapping (address => bool) public isBlackListed;\n\n    event Pause();\n    event Unpause();\n    event DestroyedBlackFunds(address _blackListedUser, uint256 _balance);\n    event AddedBlackList(address _user);\n    event RemovedBlackList(address _user);\n    // called when new token are issued\n    event Issue(uint256 amount);\n    // called when tokens are redeemed\n    event Redeem(uint256 amount);\n    // called if contract ever adds fees\n    event Params(uint256 feeBasisPoints);\n\n    constructor (address _owner, address _compliance) {\n        owner = _owner;\n        compliance = _compliance;\n        _totalSupply = 0;\n        name = \"USDKG\";\n        symbol = \"USDKG\";\n        decimals = 6;\n    }\n\n    /**\n      * @dev Throws if called by any account other than the owner.\n      */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    /**\n      * @dev Throws if called by any account other than the owner.\n      */\n    modifier onlyCompliance() {\n        require(msg.sender == compliance, \"not compliance\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused, \"not paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when sender is not blacklisted.\n     */\n    modifier notBlackListed(address sender) {\n        require(!isBlackListed[sender], \"user blacklisted\");\n        _;\n    }\n\n    ////////////////////////\n    // PUBLIC FUNCTIONS\n    ////////////////////////\n\n    /**\n    * @dev transfer token for a specified address\n    * @param _to The address to transfer to\n    * @param _value The amount to be transferred\n    */\n    function transfer(address _to, uint256 _value) public whenNotPaused notBlackListed(msg.sender) returns (bool) {\n        uint256 fee = _value * basisPointsRate / FEE_PRECISION;\n        uint256 sendAmount = _value - fee;\n        balances[msg.sender] = balances[msg.sender] - _value;\n        balances[_to] = balances[_to] + sendAmount;\n        if (fee > 0) {\n            balances[owner] = balances[owner] + fee;\n            emit Transfer(msg.sender, owner, fee);\n        }\n        emit Transfer(msg.sender, _to, sendAmount);\n        return true;\n    }\n\n    /**\n    * @dev transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notBlackListed(_from) returns (bool) {\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        // check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n        // if (_value > _allowance) throw;\n\n        uint256 fee = _value * basisPointsRate / FEE_PRECISION;\n        if (_allowance < type(uint256).max) {\n            allowed[_from][msg.sender] = _allowance - _value;\n        }\n        uint256 sendAmount = _value - fee;\n        balances[_from] = balances[_from] - _value;\n        balances[_to] = balances[_to] + sendAmount;\n        if (fee > 0) {\n            balances[owner] = balances[owner] + fee;\n            emit Transfer(_from, owner, fee);\n        }\n        emit Transfer(_from, _to, sendAmount);\n        return true;\n    }\n\n    /**\n    * @dev approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n    * @param _spender the address which will spend the funds\n    * @param _value the amount of tokens to be spent\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(msg.sender != address(0), \"caller can't be zero address\");\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    ////////////////////////\n    // SERVICE FUNCTIONS\n    ////////////////////////\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n    function addBlackList (address _evilUser) public onlyCompliance {\n        isBlackListed[_evilUser] = true;\n        emit AddedBlackList(_evilUser);\n    }\n\n    function removeBlackList (address _clearedUser) public onlyCompliance {\n        isBlackListed[_clearedUser] = false;\n        emit RemovedBlackList(_clearedUser);\n    }\n\n    function destroyBlackFunds (address _blackListedUser) public onlyCompliance {\n        require(isBlackListed[_blackListedUser], \"user should be blacklisted\");\n        uint256 dirtyFunds = balanceOf(_blackListedUser);\n        balances[_blackListedUser] = 0;\n        _totalSupply -= dirtyFunds;\n        emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);\n    }\n\n    // issue a new amount of tokens\n    // @param _amount number of tokens to be issued\n    // @param _to address of tokens receiver\n    function issue(address _to, uint256 amount) public onlyOwner {\n        balances[_to] += amount;\n        _totalSupply += amount;\n        emit Issue(amount);\n    }\n\n    // redeem tokens\n    // these tokens are withdrawn from the owner address\n    // if the balance must be enough to cover the redeem\n    // or the call will fail\n    // @param _amount number of tokens to be burnt\n    function redeem(uint256 amount) public onlyOwner {\n        require(_totalSupply >= amount, \"not enough tokens to redeem\");\n        require(balances[owner] >= amount, \"not enough tokens to redeem\");\n\n        _totalSupply -= amount;\n        balances[owner] -= amount;\n        emit Redeem(amount);\n    }\n\n    function setParams(uint256 newBasisPoints) public onlyOwner {\n        // ensure transparency by hardcoding limit beyond which fees can never be added\n        require(newBasisPoints < MAX_BASIS_POINTS, \"basis points should be less then MAX_BASIS_POINTS\");\n\n        basisPointsRate = newBasisPoints;\n\n        emit Params(basisPointsRate);\n    }\n\n    ////////////////////////\n    // VIEW FUNCTIONS\n    ////////////////////////\n\n    /**\n    * @dev gets the balance of the specified address\n    * @param _owner the address to query the the balance of\n    * @return balance An uint256 representing the amount owned by the passed address\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n    * @dev function to check the amount of tokens than an owner allowed to a spender\n    * @param _owner address the address which owns the funds\n    * @param _spender address the address which will spend the funds\n    * @return remaining a uint256 specifying the amount of tokens still available for the spender\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    // getters to allow the same blacklist to be used also by other contracts (including upgraded Tether)\n    function getBlackListStatus(address _maker) external view returns (bool) {\n        return isBlackListed[_maker];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n}"
    }
}