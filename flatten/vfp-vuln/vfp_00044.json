{
    "vfp_id": "vfp_00044",
    "project_name": "cantina_erc_burner_march2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Swap execution can completely fail in some cases when tokens like BNB are involved",
            "description": "The swapExactInputMultiple() function in URBurner.sol uses OpenZeppelin's safeDecreaseAllowance() to handle failed swaps, which internally calls approve(0) before setting a new allowance. This behavior causes a revert when interacting with certain tokens like BNB, which explicitly revert on approve(0) calls. The root cause is the reliance on a library function that assumes all ERC20 tokens allow resetting approval to zero, which is not universally true. An attacker could potentially trigger this failure by initiating a swap with a BNB-like token, causing the entire transaction to revert even if the user intended a simple fallback. This leads to a denial of service for users attempting to use such tokens, resulting in failed transactions and potential loss of gas fees.\n",
            "severity": "Medium",
            "location": [
                "URBurner.sol::swapExactInputMultiple#291-301"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Bridge refunds could be lost if URBurner is not deployed at the same address on all supported chains",
            "description": "The ERCBurner protocol uses a relay bridge to transfer ETH across chains, but does not validate bridgeData in swapExactInputMultiple() or relayBridge(). In cases where both refundTo and recipient are unspecified, the refund is sent to the originating contract address on the destination chain. If URBurner is not deployed at the same address on all chains, the refund will be sent to an uncontrolled address, resulting in permanent loss of funds. The cause is the lack of address consistency validation across chains and reliance on the contract address as a refund destination. An attacker cannot directly exploit this, but users are at risk whenever bridging fails and refunds are issued to a non-existent or unowned address. The impact is loss of user funds in the event of a bridge failure when deployment addresses differ.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol",
                "ercburner-audit/contracts/burner/AVAXBurner.sol"
            ]
        }
    ],
    "affected_files": {
        "URBurner.sol": "// SPDX-License-Identifier: MIT\n/*\n * This contract uses:\n * - OpenZeppelin Contracts (MIT License)\n * - Uniswap V3 Contracts (GPL-3.0-or-later)\n *\n * For full license texts, see LICENSE file in the root directory\n*/\n/// @custom:security-contact security@ercburner.xyz\n/// @custom:security-contact contact@ercburner.xyz\npragma solidity 0.8.24;\n\nimport { Initializable } from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport { ReentrancyGuardUpgradeable } from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { AccessControlUpgradeable } from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n\nimport { IUniversalRouter } from \"./interfaces/IUniversalRouter.sol\";\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\n\nimport { BurnerEvents } from \"./libraries/BurnerEvents.sol\";\nimport { BurnerErrors } from \"./libraries/BurnerErrors.sol\";\n\n/// @title Universal Router Token Burner & Bridge\n/// @author ERC Burner Team\n/// @notice A contract that allows users to swap multiple tokens to ETH in a single transaction, and send to a different address, or through Relay's bridge.\n/// @dev Uses Uniswap's Universal Router for token swaps and implements security measures\n/// @dev Uses Relay's RelayReceiver contract for bridge calls\ncontract Burner is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n    using BurnerErrors for *;\n    using BurnerEvents for *;\n\n    /// @notice The parameters for a swap\n    /// @param tokenIn The token to swap\n    /// @param commands The command the router will execute\n    /// @param inputs The parameters to the command\n    struct SwapParams\n    {\n        address tokenIn;\n        bytes commands;\n        bytes[] inputs;\n    }\n    \n    /// @notice Role identifier for administrators\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    \n    /// @notice The Universal Router contract\n    IUniversalRouter public universalRouter;\n    /// @notice The Permit2 contract\n    IPermit2 public permit2;\n    /// @notice The bridge contract address\n    address public bridgeAddress;\n    /// @notice The wrapped native token address\n    address public WNATIVE;\n    /// @notice The USDC token address\n    address public USDC;\n    /// @notice The fee collector address\n    address public feeCollector;\n\n    /// @notice The burn fee divisor, as in 100/divisor = y%\n    uint256 public burnFeeDivisor;\n    /// @notice The bridge fee divisor, as in 100/divisor = y%\n    uint256 public bridgeFeeDivisor;\n    /// @notice The default referrer fee share, as in share/20 = y%\n    uint8 public referrerFeeShare;\n\n    /// @notice The partners addresses mapped to a specific fee share\n    mapping(address partner => uint8 feeShare) public partners;\n\n    /// @notice The minimum gas required for a swap\n    /// @dev This is to short circuit the burn function and prevent reverts cause by low gas.\n    uint32 public minGasForSwap;\n    \n    /// @notice The maximum number of tokens that can be burned in one transaction. \n    /// @dev Has been calculated based on the max gas limit of blocks. Should over around 50-70% of the max gas limit.\n    uint32 public maxTokensPerBurn;\n\n    /// @notice Whether to pause the bridge\n    bool public pauseBridge;\n    /// @notice Whether to pause the referral\n    bool public pauseReferral;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with required parameters\n    /// @param _universalRouter Address of Uniswap's Universal Router contract\n    /// @param _permit2 Address of the Permit2 contract\n    /// @param _bridgeAddress Address of the bridge contract\n    /// @param _WNATIVE Address of the wrapped native token (WETH)\n    /// @param _USDC Address of the USDC token\n    /// @param _feeCollector Address that will receive the fees\n    /// @param _burnFeeDivisor Burn fee divisor (100 = 1%, 200 = 0.5%)\n    /// @param _bridgeFeeDivisor Bridge fee divisor (1000 = 0.1%, 2000 = 0.05%)\n    /// @param _referrerFeeShare Referrer fee share (5 = 25%, 20 = 100%)\n    /// @param _minGasForSwap Minimum gas required for a single swap\n    /// @param _maxTokensPerBurn Maximum number of tokens that can be burned in one transaction\n    /// @param _pauseBridge Whether to pause bridge\n    /// @param _pauseReferral Whether to pause referral\n    /// @param _admin Address of the admin\n    function initialize(\n        IUniversalRouter _universalRouter,\n        IPermit2 _permit2,\n        address _bridgeAddress,\n        address _WNATIVE,\n        address _USDC,\n        address _feeCollector,\n        uint256 _burnFeeDivisor,\n        uint256 _bridgeFeeDivisor,\n        uint8 _referrerFeeShare,\n        uint32 _minGasForSwap,\n        uint32 _maxTokensPerBurn,\n        bool _pauseBridge,\n        bool _pauseReferral,\n        address _admin\n    ) \n        external \n        initializer \n    {\n        __ReentrancyGuard_init_unchained();\n        __Ownable_init_unchained(msg.sender);\n        __Pausable_init_unchained();\n        __AccessControl_init_unchained();\n\n        if(address(_universalRouter) == address(0)) revert BurnerErrors.ZeroAddress();\n        if(address(_permit2) == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_bridgeAddress == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_WNATIVE == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_USDC == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_feeCollector == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_admin == address(0)) revert BurnerErrors.ZeroAddress();\n\n        universalRouter = _universalRouter;\n        permit2 = _permit2;\n        bridgeAddress = _bridgeAddress;\n        WNATIVE = _WNATIVE;\n        USDC = _USDC;\n        feeCollector = _feeCollector;\n        referrerFeeShare = _referrerFeeShare;\n        burnFeeDivisor = _burnFeeDivisor;\n        bridgeFeeDivisor = _bridgeFeeDivisor;\n        minGasForSwap = _minGasForSwap;\n        maxTokensPerBurn = _maxTokensPerBurn;\n        pauseBridge = _pauseBridge;\n        pauseReferral = _pauseReferral;\n\n        // Setup administration roles\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, _admin);\n\n        emit BurnerEvents.RouterChanged(address(_universalRouter));\n        emit BurnerEvents.Permit2Changed(address(_permit2));\n        emit BurnerEvents.FeeCollectorChanged(_feeCollector);\n        emit BurnerEvents.BridgeAddressChanged(_bridgeAddress);\n        emit BurnerEvents.PauseBridgeChanged(_pauseBridge);\n        emit BurnerEvents.BurnFeeDivisorChanged(_burnFeeDivisor);\n        emit BurnerEvents.BridgeFeeDivisorChanged(_bridgeFeeDivisor);\n        emit BurnerEvents.ReferrerFeeShareChanged(_referrerFeeShare);\n        emit BurnerEvents.MinGasForSwapChanged(_minGasForSwap);\n        emit BurnerEvents.MaxTokensPerBurnChanged(_maxTokensPerBurn);\n        emit BurnerEvents.AdminChanged(_admin);\n    }\n\n    /// @notice Reinitializes the contract with a new version\n    /// @dev Future upgrade initialization logic\n    /// @param version The version number\n    function reinitialize(uint8 version) \n        external \n        reinitializer(version) \n        nonReentrant \n    {\n        // Future upgrade initialization logic\n    }\n\n    /// @notice Fallback function to allow the contract to receive ETH\n    fallback() external payable {}\n\n    /// @notice Receive function to allow the contract to receive ETH\n    receive() external payable {}\n\n    /// @notice Modifier to check if the referrer is valid\n    /// @param _referrer The referrer address\n    modifier referrerCheck(address _referrer) {\n        if (_referrer == msg.sender && partners[_referrer] == 0) revert BurnerErrors.ReferrerCannotBeSelf();\n        if (_referrer == feeCollector) revert BurnerErrors.ReferrerCannotBeFeeCollector();\n        if (_referrer == address(this)) revert BurnerErrors.ReferrerCannotBeContract();\n        _;\n    }\n\n    /// @notice Modifier to check if the recipient is valid\n    /// @param _to The recipient address\n    modifier toCheck(address _to) {\n        if (_to == address(this)) revert BurnerErrors.ToCannotBeContract();\n        if (_to == feeCollector) revert BurnerErrors.ToCannotBeFeeCollector();\n        _;\n    }\n\n    /// @notice Swaps multiple tokens for ETH in a single transaction\n    /// @dev Processes multiple swaps and charges a fee on the total output\n    /// @param params Array of swap parameters for each token\n    /// @param _to The recipient address\n    /// @param bridge Whether to bridge the ETH\n    /// @param bridgeData The data to be sent to the bridge contract\n    /// @param _referrer The referrer address\n    /// @return amountAfterFee The amount of ETH received after fees\n    function swapExactInputMultiple(\n        SwapParams[] calldata params,\n        address _to,\n        bool bridge,\n        bytes calldata bridgeData,\n        address _referrer\n    ) \n        external \n        payable \n        nonReentrant \n        whenNotPaused \n        referrerCheck(_referrer) \n        toCheck(_to) \n        returns (uint256 amountAfterFee) \n    {\n        if (bridge && pauseBridge) revert BurnerErrors.BridgePaused();\n        if (params.length == 0 || params.length > maxTokensPerBurn) revert BurnerErrors.MismatchedInputs(params.length);\n        if (!bridge && bridgeData.length > 0) revert BurnerErrors.BridgeDataMustBeEmpty(bridgeData);\n        if (bridge && _to != address(0)) revert BurnerErrors.BridgeAndRecipientBothSet(_to);\n        if (bridge && bridgeData.length == 0) revert BurnerErrors.InvalidBridgeData();\n        if (!bridge && msg.value > 0 && _to == address(0)) revert BurnerErrors.RecipientMustBeSet();\n\n        uint256 totalAmountOut = 0;\n        uint48 expiration = uint48(block.timestamp + 900);\n        uint256 len = params.length;\n\n        for (uint256 i; i < len; ) {\n            SwapParams calldata param = params[i];\n            uint256 amountIn = _validateAndDecodeSwapParams(param);\n\n            // Short circuit if insufficient gas.\n            if (gasleft() < minGasForSwap) {\n                emit BurnerEvents.SwapFailed(msg.sender, param.tokenIn, amountIn, \"Insufficient gas\");\n                break;\n            }\n            // Skip if amount is 0.\n            if (amountIn == 0) {\n                emit BurnerEvents.SwapFailed(msg.sender, param.tokenIn, amountIn, \"Zero amount\");\n                unchecked { ++i; }\n                continue;\n            }\n\n\n\n            // Get the pre-balance of WNATIVE in the contract.\n            uint256 preBalance = IERC20(WNATIVE).balanceOf(address(this));\n\n            // Transfer the token from the sender to the contract.\n            IERC20 token = IERC20(param.tokenIn);\n            token.safeTransferFrom(msg.sender, address(this), amountIn);\n\n            // If token is WNATIVE, skip the swap.\n            if (param.tokenIn == WNATIVE) {\n                totalAmountOut += amountIn;\n                emit BurnerEvents.SwapSuccess(msg.sender, param.tokenIn, amountIn, amountIn);\n                unchecked { ++i; }\n                continue;\n            }\n\n            // Increase the allowance of the permit2 contract.\n            token.safeIncreaseAllowance(address(permit2), amountIn);\n            // Approve router for the amount of tokens to be swapped.\n            permit2.approve(param.tokenIn, address(universalRouter), uint160(amountIn), expiration);\n\n            // Execute the swap.\n            try universalRouter.execute(param.commands, param.inputs, expiration) {\n                // Get the post-balance of WNATIVE in the contract.\n                uint256 postBalance = IERC20(WNATIVE).balanceOf(address(this));\n\n                // If the post-balance is less than the pre-balance, there was an issue with the swap.\n                if (postBalance < preBalance) revert BurnerErrors.SwapIssue(preBalance, postBalance);\n\n                // Calculate the actual amount received.\n                uint256 actualReceived = postBalance - preBalance;\n                totalAmountOut += actualReceived;\n\n                emit BurnerEvents.SwapSuccess(msg.sender, param.tokenIn, amountIn, actualReceived);\n            } catch {\n                // If the swap fails, decrease the allowance of the permit2 contract.\n                token.safeDecreaseAllowance(address(permit2), amountIn);\n                // Return the tokens to the sender.\n                token.safeTransfer(msg.sender, amountIn);\n\n                emit BurnerEvents.SwapFailed(msg.sender, param.tokenIn, amountIn, \"Router error\");\n\n                unchecked { ++i; }\n                continue;\n            }\n            unchecked { ++i; }\n        }\n        \n        // If the total amount out is 0, return 0.\n        if (totalAmountOut == 0) return 0;\n        // If the total amount out is less than the burn fee divisor * 20, revert.\n        if (totalAmountOut < burnFeeDivisor * 20) revert BurnerErrors.InsufficientTotalOutput(totalAmountOut, burnFeeDivisor * 20);\n\n        // Calculate the fee amount.\n        uint256 feeAmount = totalAmountOut / burnFeeDivisor;\n        // Calculate the amount after fee.\n        amountAfterFee = totalAmountOut - feeAmount;\n\n        // Convert WNATIVE to ETH.\n        IWETH(WNATIVE).withdraw(totalAmountOut);\n\n        // If msg.value is sent and less than the bridge fee divisor * 20 (Times 20 to ensure proper fee calculation), revert.\n        if (msg.value > 0 && msg.value < bridgeFeeDivisor * 20) revert BurnerErrors.InsufficientValue(msg.value, bridgeFeeDivisor * 20);\n\n        // If msg.value is sent, calculate the bridge fee and update amountAfterFee.\n        if (msg.value >= bridgeFeeDivisor * 20) {\n            uint256 bridgeFee = msg.value / bridgeFeeDivisor;\n            uint256 valueAfterFee = msg.value - bridgeFee;\n            feeAmount += bridgeFee;\n            amountAfterFee += valueAfterFee;\n        }\n\n        // If the referrer is not the zero address, calculate the referrer fee and update feeAmount.\n        uint256 referrerFee = 0;\n        if (_referrer != address(0)) {\n            referrerFee = _calculateReferrerFee(feeAmount, _referrer);\n            feeAmount -= referrerFee;\n            Address.sendValue(payable(_referrer), referrerFee);\n            emit BurnerEvents.ReferrerFeePaid(msg.sender, _referrer, referrerFee);\n        }\n\n        // Send the fee to the fee collector.\n        Address.sendValue(payable(feeCollector), feeAmount);\n\n        // If the bridge is true, send both the swapped ETH (net of fee) and the msg.value (net of fee) to the bridge contract.\n        if (bridge) {\n            // Send both the swapped ETH and the msg.value (net of fee) to the bridge contract.\n            bytes memory returnData = Address.functionCallWithValue(bridgeAddress, bridgeData, amountAfterFee);\n            // Redundant event, but kept for clarity and dashboards.\n            emit BurnerEvents.BridgeSuccess(msg.sender, returnData, amountAfterFee, feeAmount + referrerFee);\n        } else {\n            // Determine recipient: use _to if provided, otherwise default to msg.sender.\n            address recipient = _to == address(0) ? msg.sender : _to;\n            \n            // Send the swapped ETH (net of fee) to the recipient.\n            Address.sendValue(payable(recipient), amountAfterFee);\n        }\n\n        emit BurnerEvents.BurnSuccess(msg.sender, amountAfterFee, feeAmount + referrerFee);\n        return amountAfterFee;\n    }\n\n    /// @notice Calls the Relay Receiver bridge contract\n    /// @param _bridgeData The data to be sent to the bridge contract\n    /// @param _referrer The referrer address\n    function relayBridge(bytes calldata _bridgeData, address _referrer)\n        external \n        payable \n        nonReentrant \n        referrerCheck(_referrer) \n    {\n        if (msg.value == 0) revert BurnerErrors.ZeroValue();\n        if (_bridgeData.length == 0) revert BurnerErrors.InvalidBridgeData();\n        if (msg.value < bridgeFeeDivisor * 20) revert BurnerErrors.InsufficientValue(msg.value, bridgeFeeDivisor * 20);\n\n        // Calculate the bridge fee and amount after fee.\n        uint256 bridgeFee = msg.value / bridgeFeeDivisor;\n        uint256 amountAfterFee = msg.value - bridgeFee;\n\n        uint256 referrerFee = 0;\n        if (_referrer != address(0)) {\n            referrerFee = _calculateReferrerFee(bridgeFee, _referrer);\n            bridgeFee -= referrerFee;\n            Address.sendValue(payable(_referrer), referrerFee);\n            emit BurnerEvents.ReferrerFeePaid(msg.sender, _referrer, referrerFee);\n        }\n        // Send the fee to the fee collector.\n        Address.sendValue(payable(feeCollector), bridgeFee);\n\n        // Call the bridge contract.\n        bytes memory returnData = Address.functionCallWithValue(bridgeAddress, _bridgeData, amountAfterFee);\n        emit BurnerEvents.BridgeSuccess(msg.sender, returnData, amountAfterFee, bridgeFee + referrerFee);\n    }\n\n    /// @notice User can pay for a better referrer fee share.\n    /// @param _amount The amount of USDC to pay for the referrer fee share.\n    function paidReferrer(uint256 _amount) \n        external \n        nonReentrant \n    {\n        if (partners[msg.sender] > 0) revert BurnerErrors.ReferrerAlreadyPaid();\n        uint256 allowance = IERC20(USDC).allowance(msg.sender, address(this));\n        uint8 feeShare = 0;\n        \n        // 100 USDC = 50% share\n        // 50 USDC = 40% share\n        // 25 USDC = 30% share\n        if (_amount == 100 * 10 ** 6 && allowance >= 100 * 10 ** 6) {\n            feeShare = 10; // 50% share\n        } else if (_amount == 50 * 10 ** 6 && allowance >= 50 * 10 ** 6) {\n            feeShare = 8; // 40% share\n        } else if (_amount == 25 * 10 ** 6 && allowance >= 25 * 10 ** 6) {\n            feeShare = 6; // 30% share\n        } else {\n            revert BurnerErrors.InsufficientAllowanceOrAmount(allowance, _amount);\n        }\n        // Update the partner's fee share.\n        partners[msg.sender] = feeShare;\n        // Transfer the required amount.\n        IERC20(USDC).safeTransferFrom(msg.sender, feeCollector, _amount);\n\n        emit BurnerEvents.PartnerAdded(msg.sender);\n        emit BurnerEvents.PartnerFeeShareChanged(msg.sender, feeShare);\n    }\n\n    /// @notice User can upgrade their referrer fee share.\n    /// @param _amount The amount of USDC to pay for the referrer fee share.\n    function upgradeReferrer(uint256 _amount) \n        external \n        nonReentrant \n    {\n        uint256 currentShare = partners[msg.sender];\n        if (currentShare == 0) revert BurnerErrors.ReferrerNotRegistered();\n        \n        uint256 allowance = IERC20(USDC).allowance(msg.sender, address(this));\n        uint8 newFeeShare = 0;\n        uint256 requiredAmount = 0;\n\n        // For 30% tier, 75 USDC = 50% share\n        // For 30% tier, 25 USDC = 40% share\n        if (currentShare == 6) { // Current tier is 30%\n            if (_amount == 75 * 10 ** 6 && allowance >= 75 * 10 ** 6) {\n                newFeeShare = 10; // 50% share\n                requiredAmount = 75 * 10 ** 6;\n            } else if (_amount == 25 * 10 ** 6 && allowance >= 25 * 10 ** 6) {\n                newFeeShare = 8; // 40% share\n                requiredAmount = 25 * 10 ** 6;\n            } else {\n                revert BurnerErrors.InsufficientAllowanceOrAmount(allowance, _amount);\n            }\n        } else if (currentShare == 8) { // Current tier is 40%\n            // For 40% tier, 50 USDC = 50% share\n            if (_amount == 50 * 10 ** 6 && allowance >= 50 * 10 ** 6) {\n                newFeeShare = 10; // 50% share\n                requiredAmount = 50 * 10 ** 6;\n            } else {\n                revert BurnerErrors.InsufficientAllowanceOrAmount(allowance, _amount);\n            }\n        } else if (currentShare == 10) {\n            // If the current tier is 50%, the maximum tier is reached.\n            revert BurnerErrors.MaximumTierReached();\n        } else {\n            // If the current tier is not 30% or 40%, revert.\n            revert BurnerErrors.OnPartnerTier();\n        }\n        // Update the partner's fee share\n        partners[msg.sender] = newFeeShare;\n        \n        // Transfer the required amount\n        IERC20(USDC).safeTransferFrom(msg.sender, feeCollector, requiredAmount);\n\n        emit BurnerEvents.PartnerFeeShareChanged(msg.sender, newFeeShare);\n    }\n\n    /// @notice Validates and decodes swap parameters\n    /// @dev Ensures the swap parameters are valid and returns the input amount\n    /// @param param The swap parameters to validate\n    /// @return amountIn The amount of tokens to swap\n    function _validateAndDecodeSwapParams(SwapParams calldata param) \n        private \n        view \n        returns (uint256 amountIn) \n    {\n        // If the commands length is not 1, revert.\n        if (param.commands.length != 1) revert BurnerErrors.InvalidCommands(param.commands);\n        // If the inputs length is not 1, revert.\n        if (param.inputs.length != 1) revert BurnerErrors.MismatchedInputLength(param.inputs);\n        // Get the command.\n        bytes1 command = param.commands[0];\n        // If the command is not 0x00, 0x08, or 0x0c, revert.\n        if (command != 0x00 && command != 0x08 && command != 0x0c) {\n            revert BurnerErrors.InvalidCommand(command);\n        }\n        address recipient = address(0);\n        bool payerIsUser = false;\n        uint256 amountOutMinimum = 0;\n        \n        // Decode input based on command, to ensure the input is valid.\n        if (command == 0x00) {\n            bytes memory path;\n            (recipient, amountIn, amountOutMinimum, path, payerIsUser) = \n            abi.decode(param.inputs[0],(address, uint256, uint256, bytes, bool));\n        } else if (command == 0x08) {\n            address[] memory path;\n            (recipient, amountIn, amountOutMinimum, path, payerIsUser) = \n            abi.decode(param.inputs[0],(address, uint256, uint256, address[], bool));\n        } else if (command == 0x0c) {\n            (recipient, amountIn) =\n            abi.decode(param.inputs[0], (address, uint256));\n            amountOutMinimum = amountIn;\n        }\n        if (recipient != address(this)) {\n            revert BurnerErrors.InvalidRecipient(recipient);\n        }\n        return amountIn;\n    }\n\n    /// @notice Calculates the referrer fee\n    /// @param _amount The amount to calculate the referrer fee for\n    /// @return referrerFee The referrer fee\n    function _calculateReferrerFee(uint256 _amount, address _referrer) \n        private \n        view \n        returns (uint256 referrerFee) \n    {\n        // If the referral is paused, return 0.\n        if (pauseReferral) return 0;\n        // If the referrer is registered, calculate the partner's fee.\n        if (partners[_referrer] > 0) {\n            return _amount * partners[_referrer] / 20;\n        } else {\n            // If the referrer is not registered, calculate the referrer fee.\n            return _amount * referrerFeeShare / 20;\n        }\n    }\n\n    /// @notice Adds or modifies a partner share\n    /// @dev Can be called by the owner or by the ADMIN_ROLE\n    /// @param _partner The partner address\n    /// @param _feeShare The fee share, from 1 to 20 (1 = 5%, 20 = 100%)\n    function putPartner(address _partner, uint8 _feeShare) \n        external \n        nonReentrant \n        whenNotPaused \n    {\n        // If the caller is not the owner or the ADMIN_ROLE, revert.\n        if(!hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && !hasRole(ADMIN_ROLE, msg.sender)) revert BurnerErrors.CallerNotAdminOrOwner(msg.sender);\n        // If the partner is the zero address, revert.\n        if (_partner == address(0)) revert BurnerErrors.ZeroAddress();\n        if (_feeShare > 20) revert BurnerErrors.FeeShareTooHigh(_feeShare, 20);\n        if (_feeShare == 0) revert BurnerErrors.ZeroFeeShare();\n\n        // If the partner is not already registered, emit the event.\n        if (partners[_partner] == 0) emit BurnerEvents.PartnerAdded(_partner); \n        // Update the partner's fee share.\n        partners[_partner] = _feeShare;\n\n        emit BurnerEvents.PartnerFeeShareChanged(_partner, _feeShare);\n    }\n\n    /// @notice Removes a partner\n    /// @dev Can only be called by the owner\n    /// @param _partner The partner address\n    function removePartner(address _partner) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // Delete the partner's fee share.\n        delete partners[_partner];\n        emit BurnerEvents.PartnerRemoved(_partner);\n    }\n    \n    /// @notice Updates the burn fee divisor, 2.5% being the maximum\n    /// @dev Can only be called by the owner\n    /// @param _newBurnFeeDivisor New fee divisor\n    function setBurnFeeDivisor(uint16 _newBurnFeeDivisor) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // If the new burn fee divisor is less than 40, revert.\n        if (_newBurnFeeDivisor < 40) revert BurnerErrors.FeeDivisorTooLow(_newBurnFeeDivisor, 40);\n        // Update the burn fee divisor.\n        burnFeeDivisor = _newBurnFeeDivisor;\n        \n        emit BurnerEvents.BurnFeeDivisorChanged(_newBurnFeeDivisor);\n    }\n\n    /// @notice Updates the bridge fee divisor, 0.25% being the maximum\n    /// @dev Can only be called by the owner\n    /// @param _newBridgeFeeDivisor New fee divisor\n    function setBridgeFeeDivisor(uint16 _newBridgeFeeDivisor) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // If the new bridge fee divisor is less than 400, revert.\n        if (_newBridgeFeeDivisor < 400) revert BurnerErrors.FeeDivisorTooLow(_newBridgeFeeDivisor, 400);\n        // Update the bridge fee divisor.\n        bridgeFeeDivisor = _newBridgeFeeDivisor;\n\n        emit BurnerEvents.BridgeFeeDivisorChanged(_newBridgeFeeDivisor);\n    }\n\n    /// @notice Updates the referrer fee share\n    /// @dev Can only be called by the owner\n    /// @param _newReferrerFeeShare New fee share\n    function setReferrerFeeShare(uint8 _newReferrerFeeShare) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // If the new referrer fee share is greater than 20, revert.\n        if (_newReferrerFeeShare > 20) revert BurnerErrors.FeeShareTooHigh(_newReferrerFeeShare, 20);\n        // If the new referrer fee share is 0, revert.\n        if (_newReferrerFeeShare == 0) revert BurnerErrors.ZeroFeeShare();\n        // Update the referrer fee share.\n        referrerFeeShare = _newReferrerFeeShare;\n        emit BurnerEvents.ReferrerFeeShareChanged(_newReferrerFeeShare);\n    }\n\n    /// @notice Updates the universal router address\n    /// @dev Can only be called by the owner\n    /// @param _newUniversalRouter New address to universal router\n    function setUniversalRouter(address _newUniversalRouter) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        if (_newUniversalRouter == address(0)) revert BurnerErrors.ZeroAddress();\n        universalRouter = IUniversalRouter(_newUniversalRouter);\n        emit BurnerEvents.RouterChanged(_newUniversalRouter);\n    }\n\n    /// @notice Updates the permit2 address\n    /// @dev Can only be called by the owner\n    /// @param _newPermit2 New address to permit2\n    function setPermit2(address _newPermit2)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newPermit2 == address(0)) revert BurnerErrors.ZeroAddress();\n        permit2 = IPermit2(_newPermit2);\n        emit BurnerEvents.Permit2Changed(_newPermit2);\n    }\n\n    /// @notice Updates the bridge address\n    /// @dev Can only be called by the owner\n    /// @param _newBridgeAddress New address to bridge\n    function setBridgeAddress(address _newBridgeAddress)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newBridgeAddress == address(0)) revert BurnerErrors.ZeroAddress();\n        bridgeAddress = _newBridgeAddress;\n        emit BurnerEvents.BridgeAddressChanged(_newBridgeAddress);\n    }\n\n    /// @notice Updates the fee collector address\n    /// @dev Can only be called by the owner\n    /// @param _newFeeCollector New address to collect fees\n    function setFeeCollector(address _newFeeCollector)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newFeeCollector == address(0)) revert BurnerErrors.ZeroAddress();\n        feeCollector = _newFeeCollector;\n        emit BurnerEvents.FeeCollectorChanged(_newFeeCollector);\n    }\n\n    /// @notice Updates the admin address\n    /// @dev Can only be called by the owner\n    /// @param _oldAdmin The old admin address\n    /// @param _newAdmin New address to admin\n    function setAdmin(address _oldAdmin, address _newAdmin)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        // If the new admin is the zero address, revert.\n        if (_newAdmin == address(0)) revert BurnerErrors.ZeroAddress();\n        // If the old admin is the zero address, revert.\n        if (_oldAdmin == address(0)) revert BurnerErrors.ZeroAddress();\n        // If the old admin is the same as the new admin, revert.\n        if (_oldAdmin == _newAdmin) revert BurnerErrors.SameAdmin();\n        // If the new admin already has the ADMIN_ROLE, revert.\n        if (hasRole(ADMIN_ROLE, _newAdmin)) revert BurnerErrors.AdminAlreadyExists();\n        // If the old admin does not have the ADMIN_ROLE, revert.\n        if (!hasRole(ADMIN_ROLE, _oldAdmin)) revert BurnerErrors.AdminDoesNotExist();\n\n        // Revoke the old admin's ADMIN_ROLE.\n        _revokeRole(ADMIN_ROLE, _oldAdmin);\n        // Grant the new admin the ADMIN_ROLE.\n        _grantRole(ADMIN_ROLE, _newAdmin);\n        emit BurnerEvents.AdminChanged(_newAdmin);\n    }\n\n    /// @notice Updates the minimum gas required for a swap\n    /// @dev Can only be called by the owner\n    /// @param _newMinGasForSwap New minimum gas value\n    function setMinGasForSwap(uint32 _newMinGasForSwap)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newMinGasForSwap == 0) revert BurnerErrors.ZeroMinGasForSwap();\n        minGasForSwap = _newMinGasForSwap;\n        emit BurnerEvents.MinGasForSwapChanged(_newMinGasForSwap);\n    }\n\n    /// @notice Updates the maximum number of tokens that can be burned in one transaction\n    /// @dev Can only be called by the owner\n    /// @param _newMaxTokensPerBurn New maximum number of tokens\n    function setMaxTokensPerBurn(uint32 _newMaxTokensPerBurn)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newMaxTokensPerBurn == 0) revert BurnerErrors.ZeroMaxTokensPerBurn();\n        maxTokensPerBurn = _newMaxTokensPerBurn;\n        emit BurnerEvents.MaxTokensPerBurnChanged(_newMaxTokensPerBurn);\n    }\n\n    /// @notice Allows the owner to rescue stuck tokens\n    /// @dev Transfers any ERC20 tokens stuck in the contract\n    /// @dev Can only be called by the owner\n    /// @param _token Address of the token to rescue\n    /// @param _to Address to send the tokens to\n    /// @param _amount Amount of tokens to rescue\n    function rescueTokens(\n        address _token, \n        address _to, \n        uint256 _amount\n    )\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_token == address(0)) revert BurnerErrors.ZeroAddress();\n        if (_to == address(0)) revert BurnerErrors.ZeroAddress();\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    /// @notice Allows the owner to rescue stuck ETH\n    /// @dev Transfers any ETH stuck in the contract\n    /// @dev Can only be called by the owner\n    /// @param _to Address to send the ETH to\n    /// @param _amount Amount of ETH to rescue\n    function rescueETH(address _to, uint256 _amount)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_to == address(0)) revert BurnerErrors.ZeroAddress();\n        Address.sendValue(payable(_to), _amount);\n    }\n\n    /// @notice Pauses the bridge\n    /// @dev Can only be called by the owner\n    function changePauseBridge()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        pauseBridge = !pauseBridge;\n        emit BurnerEvents.PauseBridgeChanged(pauseBridge);\n    }\n\n    /// @notice Pauses the referral\n    /// @dev Can only be called by the owner\n    function changePauseReferral()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        pauseReferral = !pauseReferral;\n        emit BurnerEvents.PauseReferralChanged(pauseReferral);\n    }\n\n    /// @notice Pauses the contract\n    /// @dev Can only be called by the owner\n    function pause()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract\n    /// @dev Can only be called by the owner\n    function unpause()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        _unpause();\n    }\n\n    /// @dev To prevent upgradeability issues.\n    uint256[50] private __gap;\n}",
        "AVAXBurner.sol": "// SPDX-License-Identifier: MIT\n/*\n * This contract uses:\n * - OpenZeppelin Contracts (MIT License)\n * - Trader Joe's LB Router (MIT License)\n *\n * For full license texts, see LICENSE file in the root directory\n */\n/// @custom:security-contact security@ercburner.xyz\n/// @custom:security-contact contact@ercburner.xyz\npragma solidity 0.8.24;\n\nimport { Initializable } from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport { ReentrancyGuardUpgradeable } from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { AccessControlUpgradeable } from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n\nimport { ILBRouter } from './interfaces/ILBRouter.sol';\nimport { IWETH } from \"./interfaces/IWETH.sol\";\n\nimport { BurnerEvents } from \"./libraries/BurnerEvents.sol\";\nimport { BurnerErrors } from \"./libraries/BurnerErrors.sol\";\n\n/// @title Trader Joe's LB Router Token Burner\n/// @author ERC Burner Team\n/// @notice A contract that allows users to swap multiple tokens to AVAX in a single transaction\n/// @dev Uses Trader Joe's LB Router for token swaps and implements security measures\n/// @dev Uses Relay's RelayReceiver contract for bridge calls\ncontract Burner is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n    using BurnerErrors for *;\n    using BurnerEvents for *;\n\n    /// @notice The parameters for a swap\n    /// @param tokenIn The token to swap\n    /// @param amountIn The amount of tokens to swap\n    /// @param amountOutMinimum The minimum amount of tokens to receive\n    /// @param path The path of the swap\n    struct SwapParams \n    {\n        address tokenIn;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        ILBRouter.Path path;\n    }\n\n    /// @notice Role identifier for administrators\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    /// @notice The Trader Joe's LB Router contract\n    ILBRouter public swapRouter;\n    /// @notice The bridge contract address\n    address public bridgeAddress;\n    /// @notice The wrapped native token address\n    address public WNATIVE;\n    /// @notice The USDC token address\n    address public USDC;\n    /// @notice The fee collector address\n    address public feeCollector;\n\n    /// @notice The burn fee divisor, as in 100/divisor = y%\n    uint256 public burnFeeDivisor;\n    /// @notice The bridge fee divisor, as in 100/divisor = y%\n    uint256 public bridgeFeeDivisor;\n    /// @notice The default referrer fee share, as in share/20 = y%\n    uint8 public referrerFeeShare;\n\n    /// @notice The partners addresses mapped to a specific fee share\n    mapping(address partner => uint8 feeShare) public partners;\n\n    /// @notice The minimum gas required for a swap\n    /// @dev This is to short circuit the burn function and prevent reverts cause by low gas.\n    uint32 public minGasForSwap;\n    \n    /// @notice The maximum number of tokens that can be burned in one transaction\n    /// @dev Has been calculated based on the max gas limit of blocks. Should over around 50-70% of the max gas limit.\n    uint32 public maxTokensPerBurn;\n\n    /// @notice Whether to pause the bridge\n    bool public pauseBridge;\n    /// @notice Whether to pause the referral\n    bool public pauseReferral;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with required parameters\n    /// @dev Sets up the contract with initial configuration values\n    /// @param _swapRouter Address of the Swap Router contract\n    /// @param _bridgeAddress Address of the bridge contract\n    /// @param _WNATIVE Address of the wrapped native token (WETH)\n    /// @param _USDC Address of the USDC token\n    /// @param _feeCollector Address that will receive the fees\n    /// @param _burnFeeDivisor Burn fee divisor (100 = 1%, 200 = 0.5%)\n    /// @param _bridgeFeeDivisor Bridge fee divisor (1000 = 0.1%, 2000 = 0.05%)\n    /// @param _referrerFeeShare Referrer fee share (5 = 25%, 20 = 100%)\n    /// @param _minGasForSwap Minimum gas required for a single swap\n    /// @param _maxTokensPerBurn Maximum number of tokens that can be burned in one transaction\n    /// @param _pauseBridge Whether to pause bridge\n    /// @param _pauseReferral Whether to pause referral\n    /// @param _admin Address of the admin\n    function initialize(\n        ILBRouter _swapRouter,\n        address _bridgeAddress,\n        address _WNATIVE,\n        address _USDC,\n        address _feeCollector,\n        uint256 _burnFeeDivisor,\n        uint256 _bridgeFeeDivisor,\n        uint8 _referrerFeeShare,\n        uint32 _minGasForSwap,\n        uint32 _maxTokensPerBurn,\n        bool _pauseBridge,\n        bool _pauseReferral,\n        address _admin\n    ) \n        external \n        initializer \n    {\n        __ReentrancyGuard_init_unchained();\n        __Ownable_init_unchained(msg.sender);\n        __Pausable_init_unchained();\n        __AccessControl_init_unchained();\n\n        if(address(_swapRouter) == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_bridgeAddress == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_WNATIVE == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_USDC == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_feeCollector == address(0)) revert BurnerErrors.ZeroAddress();\n        if(_admin == address(0)) revert BurnerErrors.ZeroAddress();\n\n        swapRouter = _swapRouter;\n        bridgeAddress = _bridgeAddress;\n        WNATIVE = _WNATIVE;\n        USDC = _USDC;\n        feeCollector = _feeCollector;\n        referrerFeeShare = _referrerFeeShare;\n        burnFeeDivisor = _burnFeeDivisor;\n        bridgeFeeDivisor = _bridgeFeeDivisor;\n        minGasForSwap = _minGasForSwap;\n        maxTokensPerBurn = _maxTokensPerBurn;\n        pauseBridge = _pauseBridge;\n        pauseReferral = _pauseReferral;\n\n        // Setup administration roles\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, _admin);\n\n        emit BurnerEvents.RouterChanged(address(_swapRouter));\n        emit BurnerEvents.FeeCollectorChanged(_feeCollector);\n        emit BurnerEvents.BridgeAddressChanged(_bridgeAddress);\n        emit BurnerEvents.PauseBridgeChanged(_pauseBridge);\n        emit BurnerEvents.BurnFeeDivisorChanged(_burnFeeDivisor);\n        emit BurnerEvents.BridgeFeeDivisorChanged(_bridgeFeeDivisor);\n        emit BurnerEvents.ReferrerFeeShareChanged(_referrerFeeShare);\n        emit BurnerEvents.MinGasForSwapChanged(_minGasForSwap);\n        emit BurnerEvents.MaxTokensPerBurnChanged(_maxTokensPerBurn);\n        emit BurnerEvents.AdminChanged(_admin);\n    }\n\n    /// @notice Allows contract upgrade initialization\n    /// @dev Used for future upgrades to initialize new state variables\n    /// @param version Version number for the upgrade\n    function reinitialize(uint8 version) \n        external \n        reinitializer(version)\n        nonReentrant\n    {\n        // Add future upgrade initialization logic\n    }\n\n    \n    /// @notice Fallback function to allow the contract to receive ETH\n    fallback() external payable {}\n\n    /// @notice Receive function to allow the contract to receive ETH\n    receive() external payable {}\n\n\n    /// @notice Modifier to check if the referrer is valid\n    /// @param _referrer The referrer address\n    modifier referrerCheck(address _referrer) {\n        if (_referrer == msg.sender && partners[_referrer] == 0) revert BurnerErrors.ReferrerCannotBeSelf();\n        if (_referrer == feeCollector) revert BurnerErrors.ReferrerCannotBeFeeCollector();\n        if (_referrer == address(this)) revert BurnerErrors.ReferrerCannotBeContract();\n        _;\n    }\n\n    /// @notice Modifier to check if the recipient is valid\n    /// @param _to The recipient address\n    modifier toCheck(address _to) {\n        if (_to == address(this)) revert BurnerErrors.ToCannotBeContract();\n        if (_to == feeCollector) revert BurnerErrors.ToCannotBeFeeCollector();\n        _;\n    }\n    \n    /// @notice Swaps multiple tokens for ETH in a single transaction\n    /// @dev Processes multiple swaps and charges a fee on the total output\n    /// @param params Array of swap parameters for each token\n     /// @param _to The recipient address\n    /// @param bridge Whether to bridge the ETH\n    /// @param bridgeData The data to be sent to the bridge contract\n    /// @param _referrer The referrer address\n    /// @return amountAfterFee The amount of ETH received after fees\n    function swapExactInputMultiple(\n        SwapParams[] calldata params,\n        address _to,\n        bool bridge,\n        bytes calldata bridgeData,\n        address _referrer\n    ) \n        external \n        payable \n        nonReentrant \n        whenNotPaused \n        referrerCheck(_referrer) \n        toCheck(_to) \n        returns (uint256 amountAfterFee) \n    {\n        if (bridge && pauseBridge) revert BurnerErrors.BridgePaused();\n        if (params.length == 0 || params.length > maxTokensPerBurn) revert BurnerErrors.MismatchedInputs(params.length);\n        if (!bridge && bridgeData.length > 0) revert BurnerErrors.BridgeDataMustBeEmpty(bridgeData);\n        if (bridge && _to != address(0)) revert BurnerErrors.BridgeAndRecipientBothSet(_to);\n        if (bridge && bridgeData.length == 0) revert BurnerErrors.InvalidBridgeData();\n        if (!bridge && msg.value > 0 && _to == address(0)) revert BurnerErrors.RecipientMustBeSet();\n\n        uint256 totalAmountOut = 0;\n        uint48 expiration = uint48(block.timestamp + 900);\n        uint256 len = params.length;\n\n        for (uint256 i; i < len; ) {\n            SwapParams calldata param = params[i];\n\n            // Short circuit if insufficient gas.\n            if (gasleft() < minGasForSwap) {\n                emit BurnerEvents.SwapFailed(msg.sender, param.tokenIn, param.amountIn, \"Insufficient gas\");\n                break;\n            }\n            // Skip if amount is 0.\n            if (param.amountIn == 0) {\n                emit BurnerEvents.SwapFailed(msg.sender, param.tokenIn, param.amountIn, \"Zero amount\");\n                unchecked { ++i; }\n                continue;\n            }\n\n            // Transfer the tokens from the sender to the contract.\n            IERC20 token = IERC20(param.tokenIn);\n            token.safeTransferFrom(msg.sender, address(this), param.amountIn);\n\n            // If token is WNATIVE, skip the swap.\n            if (param.tokenIn == WNATIVE) {\n                totalAmountOut += param.amountIn;\n                emit BurnerEvents.SwapSuccess(msg.sender, param.tokenIn, param.amountIn, param.amountIn);\n                unchecked { ++i; }\n                continue;\n            }\n\n            // Increase allowance for the swap router.\n            token.safeIncreaseAllowance(address(swapRouter), param.amountIn);\n\n            // Execute the swap.\n            try swapRouter.swapExactTokensForTokens(param.amountIn, param.amountOutMinimum, param.path, address(this), expiration) returns (uint256 actualReceived) {\n                // If the amount received is 0, revert.\n                if (actualReceived <= 0) revert BurnerErrors.AvaxSwapIssue(msg.sender, param.tokenIn, param.amountIn, \"Zero amount received\");\n                // Add the amount received to the total amount out.\n                totalAmountOut += actualReceived;\n\n                emit BurnerEvents.SwapSuccess(msg.sender, param.tokenIn, param.amountIn, actualReceived);\n            } catch {\n                // If the swap fails, decrease the allowance of the router contract.\n                token.safeDecreaseAllowance(address(swapRouter), param.amountIn);\n                // Return the tokens to the sender.\n                token.safeTransfer(msg.sender, param.amountIn);\n\n                emit BurnerEvents.SwapFailed(msg.sender, param.tokenIn, param.amountIn, \"Router error\");\n\n                unchecked { ++i; }\n                continue;\n            }\n            unchecked { ++i; }\n        }\n        \n        // If the total amount out is 0, return 0.\n        if (totalAmountOut == 0) return 0;\n        // If the total amount out is less than the burn fee divisor * 20, revert.\n        if (totalAmountOut < burnFeeDivisor * 20) revert BurnerErrors.InsufficientTotalOutput(totalAmountOut, burnFeeDivisor * 20);\n\n        // Calculate the fee amount.\n        uint256 feeAmount = totalAmountOut / burnFeeDivisor;\n        // Calculate the amount after fee.\n        amountAfterFee = totalAmountOut - feeAmount;\n\n        // Convert WNATIVE to ETH.\n        IWETH(WNATIVE).withdraw(totalAmountOut);\n\n        // If msg.value is sent and less than the bridge fee divisor * 20 (Times 20 to ensure proper fee calculation), revert.\n        if (msg.value > 0 && msg.value < bridgeFeeDivisor * 20) revert BurnerErrors.InsufficientValue(msg.value, bridgeFeeDivisor * 20);\n        \n        // If msg.value is sent, calculate the bridge fee and update amountAfterFee.\n        if (msg.value >= bridgeFeeDivisor * 20) {\n            uint256 bridgeFee = msg.value / bridgeFeeDivisor;\n            uint256 valueAfterFee = msg.value - bridgeFee;\n            feeAmount += bridgeFee;\n            amountAfterFee += valueAfterFee;\n        }\n\n        // If the referrer is not the zero address, calculate the referrer fee and update feeAmount.\n        uint256 referrerFee = 0;\n        if (_referrer != address(0)) {\n            referrerFee = _calculateReferrerFee(feeAmount, _referrer);\n            feeAmount -= referrerFee;\n            Address.sendValue(payable(_referrer), referrerFee);\n            emit BurnerEvents.ReferrerFeePaid(msg.sender, _referrer, referrerFee);\n        }\n\n        // Send the fee to the fee collector.\n        Address.sendValue(payable(feeCollector), feeAmount);\n\n        // If the bridge is true, send both the swapped ETH (net of fee) and the msg.value (net of fee) to the bridge contract.\n        if (bridge) {\n            // Send both the swapped ETH and the msg.value (net of fee) to the bridge contract.\n            bytes memory returnData = Address.functionCallWithValue(bridgeAddress, bridgeData, amountAfterFee);\n            //Redundant event, but kept for clarity and dashboards.\n            emit BurnerEvents.BridgeSuccess(msg.sender, returnData, amountAfterFee, feeAmount + referrerFee);\n        } else {\n            // Determine recipient: use _to if provided, otherwise default to msg.sender.\n            address recipient = _to == address(0) ? msg.sender : _to;\n            // Send the amount after fee to the recipient.\n            Address.sendValue(payable(recipient), amountAfterFee);\n        }\n\n        emit BurnerEvents.BurnSuccess(msg.sender, amountAfterFee, feeAmount + referrerFee);\n        return amountAfterFee;\n    }\n\n    /// @notice Calls the Relay Receiver bridge contract\n    /// @param _bridgeData The data to be sent to the bridge contract\n    /// @param _referrer The referrer address\n    function relayBridge(bytes calldata _bridgeData, address _referrer) \n        external \n        payable \n        nonReentrant \n        referrerCheck(_referrer) \n    {\n        if (msg.value == 0) revert BurnerErrors.ZeroValue();\n        if (_bridgeData.length == 0) revert BurnerErrors.InvalidBridgeData();\n        if (msg.value < bridgeFeeDivisor * 20) revert BurnerErrors.InsufficientValue(msg.value, bridgeFeeDivisor * 20);\n        \n        // Calculate the bridge fee and amount after fee.\n        uint256 bridgeFee = msg.value / bridgeFeeDivisor;\n        uint256 amountAfterFee = msg.value - bridgeFee;\n\n        uint256 referrerFee = 0;\n        if (_referrer != address(0)) {\n            referrerFee = _calculateReferrerFee(bridgeFee, _referrer);\n            bridgeFee -= referrerFee;\n            Address.sendValue(payable(_referrer), referrerFee);\n            emit BurnerEvents.ReferrerFeePaid(msg.sender, _referrer, referrerFee);\n        }\n        // Send the fee to the fee collector.\n        Address.sendValue(payable(feeCollector), bridgeFee);\n\n        // Call the bridge contract.\n        bytes memory returnData = Address.functionCallWithValue(bridgeAddress, _bridgeData, amountAfterFee);\n        emit BurnerEvents.BridgeSuccess(msg.sender, returnData, amountAfterFee, bridgeFee + referrerFee);\n    }\n\n    /// @notice User can pay for a better referrer fee share.\n    /// @param _amount The amount of USDC to pay for the referrer fee share.\n    function paidReferrer(uint256 _amount) \n        external \n        nonReentrant \n    {\n        if (partners[msg.sender] > 0) revert BurnerErrors.ReferrerAlreadyPaid();\n        uint256 allowance = IERC20(USDC).allowance(msg.sender, address(this));\n        uint8 feeShare = 0;\n        \n        // 100 USDC = 50% share\n        // 50 USDC = 40% share\n        // 25 USDC = 30% share\n        if (_amount == 100 * 10 ** 6 && allowance >= 100 * 10 ** 6) {\n            feeShare = 10; // 50% share\n        } else if (_amount == 50 * 10 ** 6 && allowance >= 50 * 10 ** 6) {\n            feeShare = 8; // 40% share\n        } else if (_amount == 25 * 10 ** 6 && allowance >= 25 * 10 ** 6) {\n            feeShare = 6; // 30% share\n        } else {\n            revert BurnerErrors.InsufficientAllowanceOrAmount(allowance, _amount);\n        }\n        // Update the partner's fee share.\n        partners[msg.sender] = feeShare;\n        // Transfer the required amount.\n        IERC20(USDC).safeTransferFrom(msg.sender, feeCollector, _amount);\n\n        emit BurnerEvents.PartnerAdded(msg.sender);\n        emit BurnerEvents.PartnerFeeShareChanged(msg.sender, feeShare);\n    }\n\n    /// @notice User can upgrade their referrer fee share.\n    /// @param _amount The amount of USDC to pay for the referrer fee share.\n    function upgradeReferrer(uint256 _amount) \n        external \n        nonReentrant \n    {\n        uint256 currentShare = partners[msg.sender];\n        if (currentShare == 0) revert BurnerErrors.ReferrerNotRegistered();\n        \n        uint256 allowance = IERC20(USDC).allowance(msg.sender, address(this));\n        uint8 newFeeShare = 0;\n        uint256 requiredAmount = 0;\n\n        // For 30% tier, 75 USDC = 50% share\n        // For 30% tier, 25 USDC = 40% share\n        if (currentShare == 6) { // Current tier is 30%\n            if (_amount == 75 * 10 ** 6 && allowance >= 75 * 10 ** 6) {\n                newFeeShare = 10; // 50% share\n                requiredAmount = 75 * 10 ** 6;\n            } else if (_amount == 25 * 10 ** 6 && allowance >= 25 * 10 ** 6) {\n                newFeeShare = 8; // 40% share\n                requiredAmount = 25 * 10 ** 6;\n            } else {\n                revert BurnerErrors.InsufficientAllowanceOrAmount(allowance, _amount);\n            }\n        } else if (currentShare == 8) { // Current tier is 40%\n            // For 40% tier, 50 USDC = 50% share\n            if (_amount == 50 * 10 ** 6 && allowance >= 50 * 10 ** 6) {\n                newFeeShare = 10; // 50% share\n                requiredAmount = 50 * 10 ** 6;\n            } else {\n                revert BurnerErrors.InsufficientAllowanceOrAmount(allowance, _amount);\n            }\n        } else if (currentShare == 10) {\n            // If the current tier is 50%, the maximum tier is reached.\n            revert BurnerErrors.MaximumTierReached();\n        } else {\n            // Update the partner's fee share\n            revert BurnerErrors.OnPartnerTier();\n        }\n        // Update the partner's fee share\n        partners[msg.sender] = newFeeShare;\n        \n        // Transfer the required amount\n        IERC20(USDC).safeTransferFrom(msg.sender, feeCollector, requiredAmount);\n\n        emit BurnerEvents.PartnerFeeShareChanged(msg.sender, newFeeShare);\n    }\n\n    /// @notice Calculates the referrer fee\n    /// @param _amount The amount to calculate the referrer fee for\n    /// @return referrerFee The referrer fee\n    function _calculateReferrerFee(uint256 _amount, address _referrer) \n        private \n        view \n        returns (uint256 referrerFee) \n    {\n        // If the referral is paused, return 0.\n        if (pauseReferral) return 0;\n        // If the referrer is registered, calculate the partner's fee.\n        if (partners[_referrer] > 0) {\n            return _amount * partners[_referrer] / 20;\n        } else {\n            // If the referrer is not registered, calculate the referrer fee.\n            return _amount * referrerFeeShare / 20;\n        }\n    }\n    \n    /// @notice Adds or modifies a partner share\n    /// @dev Can be called by the owner or by an account with the ADMIN_ROLE\n    /// @param _partner The partner address\n    /// @param _feeShare The fee share, from 1 to 20 (1 = 5%, 20 = 100%)\n    function putPartner(address _partner, uint8 _feeShare) \n        external \n        nonReentrant \n        whenNotPaused  \n    {\n        // If the caller is not the owner or the ADMIN_ROLE, revert.\n        if(!hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && !hasRole(ADMIN_ROLE, msg.sender)) revert BurnerErrors.CallerNotAdminOrOwner(msg.sender);\n        // If the partner is the zero address, revert.\n        if (_partner == address(0)) revert BurnerErrors.ZeroAddress();\n        if (_feeShare > 20) revert BurnerErrors.FeeShareTooHigh(_feeShare, 20);\n        if (_feeShare == 0) revert BurnerErrors.ZeroFeeShare();\n\n        // If the partner is not already registered, emit the event.\n        if (partners[_partner] == 0) emit BurnerEvents.PartnerAdded(_partner); \n        // Update the partner's fee share.\n        partners[_partner] = _feeShare;\n\n        emit BurnerEvents.PartnerFeeShareChanged(_partner, _feeShare);\n    }\n\n    /// @notice Removes a partner\n    /// @dev Can only be called by the owner\n    /// @param _partner The partner address\n    function removePartner(address _partner) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // Delete the partner's fee share.\n        delete partners[_partner];\n        emit BurnerEvents.PartnerRemoved(_partner);\n    }\n    \n    /// @notice Updates the burn fee divisor, 2.5% being the maximum\n    /// @dev Can only be called by the owner\n    /// @param _newBurnFeeDivisor New fee divisor\n    function setBurnFeeDivisor(uint16 _newBurnFeeDivisor) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        if (_newBurnFeeDivisor < 40) revert BurnerErrors.FeeDivisorTooLow(_newBurnFeeDivisor, 40);\n        burnFeeDivisor = _newBurnFeeDivisor;\n        emit BurnerEvents.BurnFeeDivisorChanged(_newBurnFeeDivisor);\n    }\n\n    /// @notice Updates the bridge fee divisor, 0.25% being the maximum\n    /// @dev Can only be called by the owner\n    /// @param _newBridgeFeeDivisor New fee divisor\n    function setBridgeFeeDivisor(uint16 _newBridgeFeeDivisor) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // If the new burn fee divisor is less than 40, revert.\n        if (_newBridgeFeeDivisor < 400) revert BurnerErrors.FeeDivisorTooLow(_newBridgeFeeDivisor, 400);\n        // Update the burn fee divisor.\n        bridgeFeeDivisor = _newBridgeFeeDivisor;\n        emit BurnerEvents.BridgeFeeDivisorChanged(_newBridgeFeeDivisor);\n    }\n\n    /// @notice Updates the referrer fee share\n    /// @dev Can only be called by the owner\n    /// @param _newReferrerFeeShare New fee share\n    function setReferrerFeeShare(uint8 _newReferrerFeeShare) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        // If the new referrer fee share is greater than 20, revert.\n        if (_newReferrerFeeShare > 20) revert BurnerErrors.FeeShareTooHigh(_newReferrerFeeShare, 20);\n        // If the new referrer fee share is 0, revert.\n        if (_newReferrerFeeShare == 0) revert BurnerErrors.ZeroFeeShare();\n        // Update the referrer fee share.\n        referrerFeeShare = _newReferrerFeeShare;\n        emit BurnerEvents.ReferrerFeeShareChanged(_newReferrerFeeShare);\n    }\n\n    /// @notice Updates the universal router address\n    /// @dev Can only be called by the owner\n    /// @param _newUniversalRouter New address to universal router\n    function setUniversalRouter(address _newUniversalRouter) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        if (_newUniversalRouter == address(0)) revert BurnerErrors.ZeroAddress();\n        swapRouter = ILBRouter(_newUniversalRouter);\n        emit BurnerEvents.RouterChanged(_newUniversalRouter);\n    }\n\n    /// @notice Updates the bridge address\n    /// @dev Can only be called by the owner\n    /// @param _newBridgeAddress New address to bridge\n    function setBridgeAddress(address _newBridgeAddress) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        if (_newBridgeAddress == address(0)) revert BurnerErrors.ZeroAddress();\n        bridgeAddress = _newBridgeAddress;\n        emit BurnerEvents.BridgeAddressChanged(_newBridgeAddress);\n    }\n\n    /// @notice Updates the fee collector address\n    /// @dev Can only be called by the owner\n    /// @param _newFeeCollector New address to collect fees\n    function setFeeCollector(address _newFeeCollector) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        if (_newFeeCollector == address(0)) revert BurnerErrors.ZeroAddress();\n        feeCollector = _newFeeCollector;\n        emit BurnerEvents.FeeCollectorChanged(_newFeeCollector);\n    }\n\n    /// @notice Updates the admin address\n    /// @dev Can only be called by the owner\n    /// @param _oldAdmin The old admin address\n    /// @param _newAdmin New address to admin\n    function setAdmin(address _oldAdmin, address _newAdmin)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        // If the new admin is the zero address, revert.\n        if (_newAdmin == address(0)) revert BurnerErrors.ZeroAddress();\n        // If the old admin is the zero address, revert.\n        if (_oldAdmin == address(0)) revert BurnerErrors.ZeroAddress();\n        // If the old admin is the same as the new admin, revert.\n        if (_oldAdmin == _newAdmin) revert BurnerErrors.SameAdmin();\n        // If the new admin already has the ADMIN_ROLE, revert.\n        if (hasRole(ADMIN_ROLE, _newAdmin)) revert BurnerErrors.AdminAlreadyExists();\n        // If the old admin does not have the ADMIN_ROLE, revert.\n        if (!hasRole(ADMIN_ROLE, _oldAdmin)) revert BurnerErrors.AdminDoesNotExist();\n\n        // Revoke the old admin's ADMIN_ROLE.\n        _revokeRole(ADMIN_ROLE, _oldAdmin);\n        // Grant the new admin the ADMIN_ROLE.\n        _grantRole(ADMIN_ROLE, _newAdmin);\n        emit BurnerEvents.AdminChanged(_newAdmin);\n    }\n\n    /// @notice Updates the minimum gas required for a swap\n    /// @dev Can only be called by the owner\n    /// @param _newMinGasForSwap New minimum gas value\n    function setMinGasForSwap(uint32 _newMinGasForSwap)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newMinGasForSwap == 0) revert BurnerErrors.ZeroMinGasForSwap();\n        minGasForSwap = _newMinGasForSwap;\n        emit BurnerEvents.MinGasForSwapChanged(_newMinGasForSwap);\n    }\n\n    /// @notice Updates the maximum number of tokens that can be burned in one transaction\n    /// @dev Can only be called by the owner\n    /// @param _newMaxTokensPerBurn New maximum number of tokens\n    function setMaxTokensPerBurn(uint32 _newMaxTokensPerBurn)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_newMaxTokensPerBurn == 0) revert BurnerErrors.ZeroMaxTokensPerBurn();\n        maxTokensPerBurn = _newMaxTokensPerBurn;\n        emit BurnerEvents.MaxTokensPerBurnChanged(_newMaxTokensPerBurn);\n    }\n\n    /// @notice Allows the owner to rescue stuck tokens\n    /// @dev Transfers any ERC20 tokens stuck in the contract\n    /// @dev Can only be called by the owner\n    /// @param _token Address of the token to rescue\n    /// @param _to Address to send the tokens to\n    /// @param _amount Amount of tokens to rescue\n    function rescueTokens(\n        address _token, \n        address _to, \n        uint256 _amount\n    )\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_token == address(0)) revert BurnerErrors.ZeroAddress();\n        if (_to == address(0)) revert BurnerErrors.ZeroAddress();\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    /// @notice Allows the owner to rescue stuck ETH\n    /// @dev Transfers any ETH stuck in the contract\n    /// @dev Can only be called by the owner\n    /// @param _to Address to send the ETH to\n    /// @param _amount Amount of ETH to rescue\n    function rescueETH(address _to, uint256 _amount)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (_to == address(0)) revert BurnerErrors.ZeroAddress();\n        Address.sendValue(payable(_to), _amount);\n    }\n\n    /// @notice Pauses the bridge\n    /// @dev Can only be called by the owner\n    function changePauseBridge()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        pauseBridge = !pauseBridge;\n        emit BurnerEvents.PauseBridgeChanged(pauseBridge);\n    }\n\n    /// @notice Pauses the referral\n    /// @dev Can only be called by the owner\n    function changePauseReferral()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        pauseReferral = !pauseReferral;\n        emit BurnerEvents.PauseReferralChanged(pauseReferral);\n    }\n\n\n    /// @notice Pauses the contract\n    /// @dev Can only be called by the owner\n    function pause()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract\n    /// @dev Can only be called by the owner\n    function unpause()\n        external\n        onlyOwner\n        nonReentrant\n    {\n        _unpause();\n    }\n\n    /// @dev To prevent upgradeability issues.\n    uint256[50] private __gap;\n}"
    }
}