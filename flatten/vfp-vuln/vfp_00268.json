{
    "vfp_id": "vfp_00268",
    "project_name": "cantina_eco_february2025.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Fund intent allows creation with invalid or incorrect route parameters",
            "description": "The `fundIntent()` function accepts a `routeHash` without validating the underlying parameters, and `publishIntent()` allows funding even when `route.source` does not match the current chain ID.\n\nThis allows creation of intents with invalid routes or on incorrect chains, potentially leading to funds being locked in vaults until expiration.\n\nThe cause is missing validation logic in both functions to ensure route integrity and chain correctness.\n\nAn attacker or user error can result in intents that cannot be fulfilled, locking funds until expiration. This undermines user trust and capital efficiency.\n\nThe impact is high due to potential fund lockup, and the likelihood is medium due to both malicious and accidental vectors.\n",
            "severity": "Medium",
            "location": [
                "IntentSource.sol#L120-L128"
            ],
            "files": [
                "eco-routes/contracts/IntentSource.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Intents can be published multiple times due to default claim state",
            "description": "The `publishIntent()` function in `IntentSource` checks if an intent is already published by comparing `claims[intentHash].status` to `ClaimStatus.Initiated`. However, since uninitialized mappings default to 0 (the same value as `Initiated`), new intents appear as already initiated.\n\nThe root cause is the lack of a dedicated `Uninitialized` state in the enum, leading to ambiguity between uninitialized and initiated intents.\n\nAn attacker can exploit this by publishing the same intent multiple times, potentially leading to duplicated processing or confusion in intent tracking.\n\nThe impact is low, as it does not lead to fund loss, but can cause operational issues and incorrect state tracking.\n",
            "severity": "Medium",
            "location": [
                "IntentSource.sol#L204-L206"
            ],
            "files": [
                "eco-routes/contracts/IntentSource.sol"
            ]
        }
    ],
    "affected_files": {
        "IntentSource.sol": "/* -*- c-basic-offset: 4 -*- */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IIntentSource} from \"./interfaces/IIntentSource.sol\";\nimport {BaseProver} from \"./prover/BaseProver.sol\";\nimport {Intent, Route, Reward, Call} from \"./types/Intent.sol\";\nimport {Semver} from \"./libs/Semver.sol\";\n\nimport {Vault} from \"./Vault.sol\";\n\n/**\n * @title IntentSource\n * @notice Source chain contract for the Eco Protocol's intent system\n * @dev Used to create intents and withdraw associated rewards. Works in conjunction with\n *      an inbox contract on the destination chain. Verifies intent fulfillment through\n *      a prover contract on the source chain\n * @dev This contract should not hold any funds or hold any roles for other contracts,\n *      as it executes arbitrary calls to other contracts when funding intents.\n */\ncontract IntentSource is IIntentSource, Semver {\n    using SafeERC20 for IERC20;\n\n    mapping(bytes32 intentHash => VaultStorage) public vaults;\n\n    constructor() {}\n\n    /**\n     * @notice Retrieves reward status for a given intent hash\n     * @param intentHash Hash of the intent to query\n     * @return status Current status of the intent\n     */\n    function getRewardStatus(\n        bytes32 intentHash\n    ) external view returns (RewardStatus status) {\n        return RewardStatus(vaults[intentHash].state.status);\n    }\n\n    /**\n     * @notice Retrieves vault state for a given intent hash\n     * @param intentHash Hash of the intent to query\n     * @return VaultState struct containing vault information\n     */\n    function getVaultState(\n        bytes32 intentHash\n    ) external view returns (VaultState memory) {\n        return vaults[intentHash].state;\n    }\n\n    /**\n     * @notice Retrieves the permitContact address funding an intent\n     */\n    function getPermitContract(\n        bytes32 intentHash\n    ) external view returns (address) {\n        return vaults[intentHash].permitContract;\n    }\n\n    /**\n     * @notice Calculates the hash of an intent and its components\n     * @param intent The intent to hash\n     * @return intentHash Combined hash of route and reward\n     * @return routeHash Hash of the route component\n     * @return rewardHash Hash of the reward component\n     */\n    function getIntentHash(\n        Intent calldata intent\n    )\n        public\n        pure\n        returns (bytes32 intentHash, bytes32 routeHash, bytes32 rewardHash)\n    {\n        routeHash = keccak256(abi.encode(intent.route));\n        rewardHash = keccak256(abi.encode(intent.reward));\n        intentHash = keccak256(abi.encodePacked(routeHash, rewardHash));\n    }\n\n    /**\n     * @notice Calculates the deterministic address of the intent vault\n     * @param intent Intent to calculate vault address for\n     * @return Address of the intent vault\n     */\n    function intentVaultAddress(\n        Intent calldata intent\n    ) external view returns (address) {\n        (bytes32 intentHash, bytes32 routeHash, ) = getIntentHash(intent);\n        return _getIntentVaultAddress(intentHash, routeHash, intent.reward);\n    }\n\n    /**\n     * @notice Creates an intent without funding\n     * @param intent The complete intent struct to be published\n     * @return intentHash Hash of the created intent\n     */\n    function publish(\n        Intent calldata intent\n    ) external returns (bytes32 intentHash) {\n        (intentHash, , ) = getIntentHash(intent);\n        VaultState memory state = vaults[intentHash].state;\n\n        _validateAndPublishIntent(intent, intentHash, state);\n    }\n\n    /**\n     * @notice Creates and funds an intent in a single transaction\n     * @param intent The complete intent struct to be published and funded\n     * @return intentHash Hash of the created and funded intent\n     */\n    function publishAndFund(\n        Intent calldata intent\n    ) external payable returns (bytes32 intentHash) {\n        bytes32 routeHash;\n        (intentHash, routeHash, ) = getIntentHash(intent);\n        VaultState memory state = vaults[intentHash].state;\n\n        _validateInitialFundingState(state, intentHash);\n        _validateSourceChain(intent.route.source, intentHash);\n        _validateAndPublishIntent(intent, intentHash, state);\n\n        address vault = _getIntentVaultAddress(\n            intentHash,\n            routeHash,\n            intent.reward\n        );\n        _fundIntent(intentHash, intent.reward, vault, msg.sender);\n\n        _returnExcessEth(intentHash, address(this).balance);\n    }\n\n    /**\n     * @notice Funds an existing intent\n     * @param routeHash Hash of the route component\n     * @param reward Reward structure containing distribution details\n     * @return intentHash Hash of the funded intent\n     */\n    function fund(\n        bytes32 routeHash,\n        Reward calldata reward\n    ) external payable returns (bytes32 intentHash) {\n        bytes32 rewardHash = keccak256(abi.encode(reward));\n        intentHash = keccak256(abi.encodePacked(routeHash, rewardHash));\n        VaultState memory state = vaults[intentHash].state;\n\n        _validateInitialFundingState(state, intentHash);\n\n        address vault = _getIntentVaultAddress(intentHash, routeHash, reward);\n        _fundIntent(intentHash, reward, vault, msg.sender);\n    }\n\n    /**\n     * @notice Funds an intent for a user with allowance/permit\n     * @param routeHash Hash of the route component\n     * @param reward Reward structure containing distribution details\n     * @param funder Address to fund the intent from\n     * @param permitContact Address of the permitContact instance\n     * @param allowPartial Whether to allow partial funding\n     * @return intentHash Hash of the funded intent\n     */\n    function fundFor(\n        bytes32 routeHash,\n        Reward calldata reward,\n        address funder,\n        address permitContact,\n        bool allowPartial\n    ) external returns (bytes32 intentHash) {\n        bytes32 rewardHash = keccak256(abi.encode(reward));\n        intentHash = keccak256(abi.encodePacked(routeHash, rewardHash));\n        VaultState memory state = vaults[intentHash].state;\n\n        address vault = _getIntentVaultAddress(intentHash, routeHash, reward);\n\n        _fundIntentFor(\n            state,\n            reward,\n            intentHash,\n            routeHash,\n            vault,\n            funder,\n            permitContact,\n            allowPartial\n        );\n    }\n\n    /**\n     * @notice Creates and funds an intent using permit/allowance\n     * @param intent The complete intent struct\n     * @return intentHash Hash of the created and funded intent\n     */\n    function publishAndFundFor(\n        Intent calldata intent,\n        address funder,\n        address permitContact,\n        bool allowPartial\n    ) external returns (bytes32 intentHash) {\n        bytes32 routeHash;\n        (intentHash, routeHash, ) = getIntentHash(intent);\n        VaultState memory state = vaults[intentHash].state;\n\n        _validateAndPublishIntent(intent, intentHash, state);\n        _validateSourceChain(intent.route.source, intentHash);\n\n        address vault = _getIntentVaultAddress(\n            intentHash,\n            routeHash,\n            intent.reward\n        );\n\n        _fundIntentFor(\n            state,\n            intent.reward,\n            intentHash,\n            routeHash,\n            vault,\n            funder,\n            permitContact,\n            allowPartial\n        );\n    }\n\n    /**\n     * @notice Checks if an intent is properly funded\n     * @param intent Intent to validate\n     * @return True if intent is properly funded, false otherwise\n     */\n    function isIntentFunded(\n        Intent calldata intent\n    ) external view returns (bool) {\n        if (intent.route.source != block.chainid) return false;\n\n        (bytes32 intentHash, bytes32 routeHash, ) = getIntentHash(intent);\n        address vault = _getIntentVaultAddress(\n            intentHash,\n            routeHash,\n            intent.reward\n        );\n\n        return _isRewardFunded(intent.reward, vault);\n    }\n\n    /**\n     * @notice Withdraws rewards associated with an intent to its claimant\n     * @param routeHash Hash of the intent's route\n     * @param reward Reward structure of the intent\n     */\n    function withdrawRewards(bytes32 routeHash, Reward calldata reward) public {\n        bytes32 rewardHash = keccak256(abi.encode(reward));\n        bytes32 intentHash = keccak256(abi.encodePacked(routeHash, rewardHash));\n\n        address claimant = BaseProver(reward.prover).provenIntents(intentHash);\n        VaultState memory state = vaults[intentHash].state;\n\n        // Claim the rewards if the intent has not been claimed\n        if (\n            claimant != address(0) &&\n            state.status != uint8(RewardStatus.Claimed) &&\n            state.status != uint8(RewardStatus.Refunded)\n        ) {\n            state.status = uint8(RewardStatus.Claimed);\n            state.mode = uint8(VaultMode.Claim);\n            state.allowPartialFunding = 0;\n            state.usePermit = 0;\n            state.target = claimant;\n            vaults[intentHash].state = state;\n\n            emit Withdrawal(intentHash, claimant);\n\n            new Vault{salt: routeHash}(intentHash, reward);\n\n            return;\n        }\n\n        if (claimant == address(0)) {\n            revert UnauthorizedWithdrawal(intentHash);\n        } else {\n            revert RewardsAlreadyWithdrawn(intentHash);\n        }\n    }\n\n    /**\n     * @notice Batch withdraws multiple intents\n     * @param routeHashes Array of route hashes for the intents\n     * @param rewards Array of reward structures for the intents\n     */\n    function batchWithdraw(\n        bytes32[] calldata routeHashes,\n        Reward[] calldata rewards\n    ) external {\n        uint256 length = routeHashes.length;\n\n        if (length != rewards.length) {\n            revert ArrayLengthMismatch();\n        }\n\n        for (uint256 i = 0; i < length; ++i) {\n            withdrawRewards(routeHashes[i], rewards[i]);\n        }\n    }\n\n    /**\n     * @notice Refunds rewards to the intent creator\n     * @param routeHash Hash of the intent's route\n     * @param reward Reward structure of the intent\n     */\n    function refund(bytes32 routeHash, Reward calldata reward) external {\n        bytes32 rewardHash = keccak256(abi.encode(reward));\n        bytes32 intentHash = keccak256(abi.encodePacked(routeHash, rewardHash));\n\n        VaultState memory state = vaults[intentHash].state;\n\n        if (\n            state.status != uint8(RewardStatus.Claimed) &&\n            state.status != uint8(RewardStatus.Refunded) &&\n            block.timestamp <= reward.deadline\n        ) {\n            revert IntentNotExpired(intentHash);\n        }\n\n        if (state.status != uint8(RewardStatus.Claimed)) {\n            state.status = uint8(RewardStatus.Refunded);\n        }\n\n        state.mode = uint8(VaultMode.Refund);\n        state.allowPartialFunding = 0;\n        state.usePermit = 0;\n        state.target = address(0);\n        vaults[intentHash].state = state;\n\n        emit Refund(intentHash, reward.creator);\n\n        new Vault{salt: routeHash}(intentHash, reward);\n    }\n\n    /**\n     * @notice Recover tokens that were sent to the intent vault by mistake\n     * @dev Must not be among the intent's rewards\n     * @param routeHash Hash of the intent's route\n     * @param reward Reward structure of the intent\n     * @param token Optional token address for handling incorrect vault transfers\n     */\n    function recoverToken(\n        bytes32 routeHash,\n        Reward calldata reward,\n        address token\n    ) external {\n        if (token == address(0)) {\n            revert InvalidRefundToken();\n        }\n\n        bytes32 rewardHash = keccak256(abi.encode(reward));\n        bytes32 intentHash = keccak256(abi.encodePacked(routeHash, rewardHash));\n\n        VaultState memory state = vaults[intentHash].state;\n\n        // selfdestruct() will refund all native tokens to the creator\n        // we can't refund native intents before the claim/refund happens\n        // because deploying and destructing the vault will refund the native reward prematurely\n        if (\n            state.status != uint8(RewardStatus.Claimed) &&\n            state.status != uint8(RewardStatus.Refunded) &&\n            reward.nativeValue > 0\n        ) {\n            revert IntentNotClaimed(intentHash);\n        }\n\n        // Check if the token is part of the reward\n        for (uint256 i = 0; i < reward.tokens.length; ++i) {\n            if (reward.tokens[i].token == token) {\n                revert InvalidRefundToken();\n            }\n        }\n\n        state.mode = uint8(VaultMode.RecoverToken);\n        state.allowPartialFunding = 0;\n        state.usePermit = 0;\n        state.target = token;\n        vaults[intentHash].state = state;\n\n        emit Refund(intentHash, reward.creator);\n\n        new Vault{salt: routeHash}(intentHash, reward);\n    }\n\n    /**\n     * @notice Validates that an intent's vault holds sufficient rewards\n     * @dev Checks both native token and ERC20 token balances\n     * @param reward Reward to validate\n     * @param vault Address of the intent's vault\n     * @return True if vault has sufficient funds, false otherwise\n     */\n    function _isRewardFunded(\n        Reward calldata reward,\n        address vault\n    ) internal view returns (bool) {\n        uint256 rewardsLength = reward.tokens.length;\n\n        if (vault.balance < reward.nativeValue) return false;\n\n        for (uint256 i = 0; i < rewardsLength; ++i) {\n            address token = reward.tokens[i].token;\n            uint256 amount = reward.tokens[i].amount;\n            uint256 balance = IERC20(token).balanceOf(vault);\n\n            if (balance < amount) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Calculates the deterministic address of an intent vault using CREATE2\n     * @dev Follows EIP-1014 for address calculation\n     * @param intentHash Hash of the full intent\n     * @param routeHash Hash of the route component\n     * @param reward Reward structure\n     * @return The calculated vault address\n     */\n    function _getIntentVaultAddress(\n        bytes32 intentHash,\n        bytes32 routeHash,\n        Reward calldata reward\n    ) internal view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.9/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                hex\"ff\",\n                                address(this),\n                                routeHash,\n                                keccak256(\n                                    abi.encodePacked(\n                                        type(Vault).creationCode,\n                                        abi.encode(intentHash, reward)\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Validates and publishes a new intent\n     * @param intent The intent to validate and publish\n     * @param intentHash Hash of the intent\n     * @param state Current vault state\n     */\n    function _validateAndPublishIntent(\n        Intent calldata intent,\n        bytes32 intentHash,\n        VaultState memory state\n    ) internal {\n        if (\n            state.status == uint8(RewardStatus.Claimed) ||\n            state.status == uint8(RewardStatus.Refunded)\n        ) {\n            revert IntentAlreadyExists(intentHash);\n        }\n\n        emit IntentCreated(\n            intentHash,\n            intent.route.salt,\n            intent.route.source,\n            intent.route.destination,\n            intent.route.inbox,\n            intent.route.tokens,\n            intent.route.calls,\n            intent.reward.creator,\n            intent.reward.prover,\n            intent.reward.deadline,\n            intent.reward.nativeValue,\n            intent.reward.tokens\n        );\n    }\n\n    /**\n     * @notice Disabling fundFor for native intents\n     * @dev Deploying vault in Fund mode might cause a loss of native reward\n     * @param reward Reward structure to validate\n     * @param vault Address of the intent vault\n     * @param intentHash Hash of the intent\n     */\n    function _disableNativeReward(\n        Reward calldata reward,\n        address vault,\n        bytes32 intentHash\n    ) internal view {\n        // selfdestruct() will refund all native tokens to the creator\n        // we can't use Fund mode for intents with native value\n        // because deploying and destructing the vault will refund the native reward prematurely\n        if (reward.nativeValue > 0 && vault.balance > 0) {\n            revert CannotFundForWithNativeReward(intentHash);\n        }\n    }\n\n    /**\n     * @notice Validates the initial funding state\n     * @param state Current vault state\n     * @param intentHash Hash of the intent\n     */\n    function _validateInitialFundingState(\n        VaultState memory state,\n        bytes32 intentHash\n    ) internal pure {\n        if (state.status != uint8(RewardStatus.Initial)) {\n            revert IntentAlreadyFunded(intentHash);\n        }\n    }\n\n    /**\n     * @notice Validates the funding state for partial funding\n     * @param state Current vault state\n     * @param intentHash Hash of the intent\n     */\n    function _validateFundingState(\n        VaultState memory state,\n        bytes32 intentHash\n    ) internal pure {\n        if (\n            state.status != uint8(RewardStatus.Initial) &&\n            state.status != uint8(RewardStatus.PartiallyFunded)\n        ) {\n            revert IntentAlreadyFunded(intentHash);\n        }\n    }\n\n    /**\n     * @notice Handles the funding of an intent\n     * @param intentHash Hash of the intent\n     * @param reward Reward structure to fund\n     * @param vault Address of the intent vault\n     * @param funder Address providing the funds\n     */\n    function _fundIntent(\n        bytes32 intentHash,\n        Reward calldata reward,\n        address vault,\n        address funder\n    ) internal {\n        emit IntentFunded(intentHash, msg.sender);\n\n        if (reward.nativeValue > 0) {\n            if (msg.value < reward.nativeValue) {\n                revert InsufficientNativeReward(intentHash);\n            }\n            payable(vault).transfer(reward.nativeValue);\n        }\n\n        for (uint256 i = 0; i < reward.tokens.length; ++i) {\n            IERC20(reward.tokens[i].token).safeTransferFrom(\n                funder,\n                vault,\n                reward.tokens[i].amount\n            );\n        }\n    }\n\n    function _fundIntentFor(\n        VaultState memory state,\n        Reward calldata reward,\n        bytes32 intentHash,\n        bytes32 routeHash,\n        address vault,\n        address funder,\n        address permitContact,\n        bool allowPartial\n    ) internal {\n        _disableNativeReward(reward, vault, intentHash);\n        _validateFundingState(state, intentHash);\n\n        if (state.status == uint8(RewardStatus.Initial)) {\n            state.status = allowPartial\n                ? uint8(RewardStatus.PartiallyFunded)\n                : uint8(RewardStatus.Funded);\n        }\n\n        state.mode = uint8(VaultMode.Fund);\n        state.allowPartialFunding = allowPartial ? 1 : 0;\n        state.usePermit = permitContact != address(0) ? 1 : 0;\n        state.target = funder;\n\n        if (permitContact != address(0)) {\n            vaults[intentHash].permitContract = permitContact;\n        }\n\n        vaults[intentHash].state = state;\n\n        new Vault{salt: routeHash}(intentHash, reward);\n\n        if (state.status == uint8(RewardStatus.Funded)) {\n            emit IntentFunded(intentHash, funder);\n        } else if (\n            state.status == uint8(RewardStatus.PartiallyFunded) &&\n            _isRewardFunded(reward, vault)\n        ) {\n            state.status = uint8(RewardStatus.Funded);\n            vaults[intentHash].state = state;\n\n            emit IntentFunded(intentHash, funder);\n        } else {\n            emit IntentPartiallyFunded(intentHash, funder);\n        }\n    }\n\n    /**\n     * @notice Validates that the intent is being published on correct chain\n     * @param sourceChain Chain ID specified in the intent\n     * @param intentHash Hash of the intent\n     */\n    function _validateSourceChain(\n        uint256 sourceChain,\n        bytes32 intentHash\n    ) internal view {\n        if (sourceChain != block.chainid) {\n            revert WrongSourceChain(intentHash);\n        }\n    }\n\n    /**\n     * @notice Returns excess ETH to the sender\n     * @param intentHash Hash of the intent\n     * @param amount Amount of ETH to return\n     */\n    function _returnExcessEth(bytes32 intentHash, uint256 amount) internal {\n        if (amount > 0) {\n            (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n            if (!success) revert NativeRewardTransferFailed(intentHash);\n        }\n    }\n}\n"
    }
}