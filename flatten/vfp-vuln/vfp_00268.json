{
    "vfp_id": "vfp_00268",
    "project_name": "DIA Lumina Staking Security Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "paidOutReward subtraction may lead to unstake and unstakePrincipal functions reverting",
            "description": "This vulnerability occurs in the DIAWhitelistedStaking contract where, upon a user's first reward claim, the currentStore.reward is zeroed out after payout. If the user then attempts to unstake after the unstaking period, the unstake function may revert during the calculation `rewardToSend = currentStore.reward - currentStore.paidOutReward`, because currentStore.reward could be less than currentStore.paidOutReward if insufficient time has passed since staking began. The root cause is improper accounting of reward and paidOutReward state variables, leading to an underflow condition. An attacker could exploit this by claiming rewards early and then initiating an unstake request, causing the transaction to revert. The impact is that users are permanently blocked from unstaking their principal and rewards, effectively locking their funds in the contract.\n",
            "severity": "Critical",
            "location": [
                "DIAWhitelistedStaking.sol::unstake#",
                "DIAWhitelistedStaking.sol::unstakePrincipal#"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Inflation Attack in DIAExternalStaking Allows Stealing First Depositor's Stake",
            "description": "The DIAExternalStaking contract is vulnerable to an inflation attack due to the permissionless addRewardToPool function and flawed share calculation logic. The attacker stakes a minimal amount, then unstakes all but one token, leaving total shares and total supply at 1. By frontrunning a victim's deposit and calling addRewardToPool with an amount equal to the victim's deposit, the attacker manipulates the pool state so the victim receives zero shares. The root cause is the lack of minimum share minting and unrestricted access to reward injection. This allows an attacker to repeatedly steal the first depositor's stake in a new or empty pool by manipulating share distribution. The impact is direct theft of user funds, leading to loss of deposited assets and undermining trust in the protocol.\n",
            "severity": "Critical",
            "location": [
                "DIAExternalStaking.sol::addRewardToPool",
                "DIAExternalStaking.sol::_stake"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "currentStore.principal is not subtracted after it was withdrawn, allowing users to claim it again infinitely",
            "description": "In the DIAWhitelistedStaking contract, the currentStore.principal value is not reset after a user withdraws their principal via the unstake function. This creates a vulnerability where a user can repeatedly call unstake and withdraw the same principal amount multiple times, as the contract does not track that the principal has already been withdrawn. The root cause is the missing update of the principal balance in storage post-withdrawal. An attacker can exploit this by calling unstake multiple times, draining more tokens than originally staked. The impact is severe financial loss to the protocol, potentially leading to complete depletion of the staking contract's token balance.\n",
            "severity": "Critical",
            "location": [
                "DIAWhitelistedStaking.sol::unstake"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "WDIA prohibits zero transfers, which will block rewards distribution to beneficiary address if 100% goes to principal unstaker",
            "description": "The DIAExternalStaking contract's unstake function calculates reward distribution based on principalWalletShareBps. When set to 100%, the entire reward goes to the principal unstaker, making the beneficiary's reward amount zero. However, the WDIA token reverts on zero-amount transfers (if (wad == 0) revert ZeroTransferAmount()), causing the entire transaction to fail. The root cause is the lack of a zero-amount check before the transfer and WDIA's strict zero-transfer prohibition. An attacker or misconfigured setup can trigger this by setting principalWalletShareBps to 100%, blocking all reward claims. The impact is that users cannot claim any rewards under this configuration, effectively freezing rewards and rendering the staking mechanism unusable for such stakes.\n",
            "severity": "Critical",
            "location": [
                "DIAExternalStaking.sol::unstake",
                "WDIA.sol::transfer"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rewards are lost if user requests unstake in less than one day",
            "description": "The DIAWhitelistedStaking contract's getRewardForStakingStore function calculates rewards based on full days using the formula passedDays = passedSeconds / (24 * 60 * 60). If a user requests unstake in less than one day, passedDays becomes 0, resulting in no reward being calculated for that period. This occurs due to integer division truncation in Solidity, which discards fractional days. An attacker could exploit this by repeatedly staking and unstaking within sub-daily intervals to manipulate reward accrual timing. The impact is that users lose accrued rewards for partial days, leading to unfair distribution and reduced user trust in the staking mechanism.\n",
            "severity": "High",
            "location": [
                "DIAWhitelistedStaking::getRewardForStakingStore"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Rewards claiming may fail due to potentially decreasing parameters used in calculation",
            "description": "In the DIAWhitelistedStaking contract, the updateReward function contains an assertion assert(reward >= currentStore.reward) that can fail if either rewardRatePerDay is decreased by the owner or currentStore.principal is reduced during partial unstaking. The getRewardForStakingStore function calculates rewards as (rewardRatePerDay * passedDays * currentStore.principal) / 10000, which may yield a value lower than currentStore.reward when inputs decrease. This causes the assertion to revert, blocking both reward and principal withdrawals for the user. The root cause is improper state validation when mutable parameters affect reward calculations. An attacker with ownership privileges could intentionally lower the reward rate to block user withdrawals. The impact is denial of service for reward and principal claiming, potentially locking user funds indefinitely.\n",
            "severity": "High",
            "location": [
                "DIAWhitelistedStaking::updateReward",
                "DIAWhitelistedStaking::getRewardForStakingStore"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ]
            },
            "title": "Pending principal wallet share BPS value is not saved in storage",
            "description": "In both DIAExternalStaking and DIAWhitelistedStaking contracts, the _getCurrentPrincipalWalletShareBps function reads from memory without persisting the pending BPS update to storage after the timeout period. This leads to outdated stakingStores[stakingStoreIndex].principalWalletShareBps values being used if new pending updates occur before the grace period ends. The cause is missing storage update logic in the BPS update mechanism. An attacker (or malicious beneficiary) could exploit this by timing BPS changes to manipulate reward distribution between principal and beneficiary wallets. The impact is loss of expected control over reward splits for beneficiaries, undermining the intended governance model and potentially causing financial loss.\n",
            "severity": "High",
            "location": [
                "DIAExternalStaking::_getCurrentPrincipalWalletShareBps",
                "DIAWhitelistedStaking::_getCurrentPrincipalWalletShareBps"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Reward Calculation When Reward Rate Changes",
            "description": "The getRewardForStakingStore function in DIAWhitelistedStaking uses the current rewardRatePerDay to calculate rewards regardless of historical rate changes. This means two identical stakes started at different times may receive different rewards depending on when they call unstake(), even if their staking duration is the same. The root cause is the lack of time-segmented reward accounting based on rate periods. A malicious user could exploit this by timing unstake calls to maximize gains under higher rates, while others receive less due to rate drops. The impact is unfair and inconsistent reward distribution, which undermines trust in the staking system and may lead to user disputes or loss of confidence.\n",
            "severity": "High",
            "location": [
                "DIAWhitelistedStaking::getRewardForStakingStore"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Incorrect Initialization of lastWithdrawalResetDay Causes Withdrawal Limits to Malfunction",
            "description": "In the DIAExternalStaking contract constructor, lastWithdrawalResetDay is initialized with block.timestamp instead of block.timestamp / SECONDS_IN_A_DAY. This causes the daily withdrawal reset logic to malfunction because the comparison block.timestamp / SECONDS_IN_A_DAY > lastWithdrawalResetDay will never be true. As a result, the daily withdrawal limit becomes a one-time limit, breaking the intended security mechanism. The cause is incorrect unit handling during initialization. An attacker could exploit this by making early withdrawals to exhaust the pool's daily limit, permanently blocking others. The impact is a critical failure of the withdrawal rate-limiting feature, potentially leading to fund lockouts and reduced security.\n",
            "severity": "High",
            "location": [
                "DIAExternalStaking::constructor"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Reward Accumulation Manipulation Through Frequent Claims",
            "description": "In the claim function of DIAWhitelistedStaking, a malicious user can repeatedly call claim() multiple times per day with minimal stake. Each call updates rewardLastUpdateTime but due to daysElapsed = (block.timestamp - rewardLastUpdateTime) / SECONDS_IN_A_DAY rounding down to zero, no rewards are accrued and rewardAccumulator remains unchanged. This prevents other stakers from receiving rewards, effectively freezing the entire reward distribution system. The root cause is insufficient precision in time-based reward accrual calculations. The impact is severe financial harm to honest stakers, as their rewards are withheld due to griefing attacks, undermining the economic model of the protocol.\n",
            "severity": "High",
            "location": [
                "DIAWhitelistedStaking::claim"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Daily withdrawal limit decreases with totalPoolSize reduction",
            "description": "In the DIAExternalStaking contract, the availableDailyLimit is calculated as (totalPoolSize * withdrawalCapBps) / 10000 inside the checkDailyWithdrawalLimit modifier. When totalPoolSize decreases due to unstaking, the daily limit shrinks proportionally, even if the remaining pool is large. This creates inconsistent behavior where users may be blocked from withdrawing later in the day despite sufficient liquidity. The root cause is dynamic dependency on a fluctuating totalPoolSize instead of a fixed daily baseline. An attacker could exploit this by unstaking large amounts early to reduce the limit for others. The impact is denial of access to funds and unpredictable withdrawal behavior, reducing user confidence.\n",
            "severity": "Medium",
            "location": [
                "DIAExternalStaking::checkDailyWithdrawalLimit"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Principal wallet pending share BPS usage is missed in getRewardForStakingStore function",
            "description": "In the DIAExternalStaking contract, the getRewardForStakingStore function uses the static store.principalWalletShareBps value instead of calling _getCurrentPrincipalWalletShareBps, which accounts for pending updates. This means pending BPS changes are not reflected in reward estimates, misleading users about expected payouts. The cause is failure to use the correct view function for dynamic state. An attacker could exploit this by initiating a BPS change and then quickly claiming rewards before the update takes effect, capturing more than intended. The impact is inaccurate reward reporting and potential for unfair distribution during transition periods.\n",
            "severity": "Medium",
            "location": [
                "DIAExternalStaking::getRewardForStakingStore"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "stakingIndicesByPrincipalUnstaker mapping not updated in updatePrincipalUnstaker function",
            "description": "In both DIAExternalStaking and DIAWhitelistedStaking contracts, the updatePrincipalUnstaker function fails to update the stakingIndicesByPrincipalUnstaker mapping when changing the principal unstaker. This results in stale indices for both old and new unstakers, leading to incorrect tracking of associated stakes. The cause is missing mapping maintenance logic in the update function. An attacker could exploit this by changing unstakers and then manipulating stake operations using outdated indices. The impact is corrupted internal accounting, which may lead to incorrect unstaking behavior or denial of service for legitimate unstake requests.\n",
            "severity": "Medium",
            "location": [
                "DIAExternalStaking::updatePrincipalUnstaker",
                "DIAWhitelistedStaking::updatePrincipalUnstaker"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAExternalStaking.sol",
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Whitelist can be bypassed in DIAWhitelistedStaking",
            "description": "The stakeForAddress function in DIAWhitelistedStaking allows specifying any whitelisted beneficiary while assigning 100% of rewards to the principal. Since the beneficiary can be a contract, this enables non-whitelisted users to effectively bypass the whitelist by using a whitelisted contract as a proxy. The cause is insufficient validation of reward share distribution during staking. An attacker could exploit this to gain unauthorized access to the staking mechanism by leveraging a whitelisted contract beneficiary. The impact is circumvention of access controls, allowing unapproved participants to stake and earn rewards, undermining the security model.\n",
            "severity": "Medium",
            "location": [
                "DIAWhitelistedStaking::stakeForAddress"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Principal withdrawal may be blocked by insufficient rewards wallet balance in DIAWhitelistedStaking",
            "description": "The unstake() and unstakePrincipal() functions in DIAWhitelistedStaking require transferring rewards from an external rewardsWallet before allowing principal withdrawal. If the rewardsWallet has insufficient balance or revoked allowances, the safeTransferFrom() call reverts, blocking the entire transaction and preventing principal withdrawal. The cause is tight coupling between reward payout and principal release. An attacker could exploit this by draining or revoking the rewardsWallet to freeze user withdrawals. The impact is permanent lockout of user principal funds despite the principal being available in the contract, leading to loss of user assets and trust.\n",
            "severity": "Medium",
            "location": [
                "DIAWhitelistedStaking::unstake",
                "DIAWhitelistedStaking::unstakePrincipal"
            ],
            "files": [
                "50b709199461ae48e3186d5a04cd22eff39ebcf5/lumina-staking/contracts/DIAWhitelistedStaking.sol"
            ]
        }
    ],
    "affected_files": {
        "DIAWhitelistedStaking.sol": "// SPDX-License-Identifier: GPL\n\npragma solidity 0.8.29;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./DIAStakingCommons.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./DIARewardsDistribution.sol\";\n\n/**\n * @title DIAWhitelistedStaking\n * @notice This contract allows whitelisted addresses to stake tokens and earn rewards.\n */\ncontract DIAWhitelistedStaking is\n    Ownable,\n    DIARewardsDistribution,\n    ReentrancyGuard,\n    DIAStakingCommons\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice Mapping of whitelisted addresses for staking\n    /// @dev Maps address to boolean indicating if address is whitelisted\n    mapping(address => bool) public stakingWhitelist;\n\n    /// @notice Emitted when a new staker is added to the whitelist\n    /// @param newStaker The address that was added to the whitelist\n    event StakerAddressAdded(address newStaker);\n\n    /// @notice Emitted when a staker is removed from the whitelist\n    /// @param removedStaker The address that was removed from the whitelist\n    event StakerAddressRemoved(address removedStaker);\n\n    /// @notice Emitted when daily withdrawal threshold is updated\n    /// @param oldThreshold The previous threshold value\n    /// @param newThreshold The new threshold value\n    event DailyWithdrawalThresholdUpdated(\n        uint256 oldThreshold,\n        uint256 newThreshold\n    );\n\n    /// @notice Emitted when withdrawal cap is updated\n    /// @param oldCap The previous cap value in basis points\n    /// @param newCap The new cap value in basis points\n    event WithdrawalCapUpdated(uint256 oldCap, uint256 newCap);\n\n    /// @notice Errors\n    error AlreadyWhitelisted();\n\n    /**\n     * @dev Initializes the contract with staking parameters.\n     * @param newUnstakingDuration Duration in seconds required before unstaking.\n     * @param stakingTokenAddress Address of the ERC20 token used for staking.\n     * @param rewardsWallet Address of the wallet that holds rewards.This wallet should appove tokens for this contract\n     * @param rewardRatePerDay Rate at which rewards accumulate daily.\n     */\n\n    constructor(\n        uint256 newUnstakingDuration,\n        address stakingTokenAddress,\n        address rewardsWallet,\n        uint256 rewardRatePerDay\n    )\n        Ownable(msg.sender)\n        DIARewardsDistribution(\n            stakingTokenAddress,\n            rewardsWallet,\n            rewardRatePerDay\n        )\n    {\n        unstakingDuration = newUnstakingDuration;\n        STAKING_TOKEN = IERC20(stakingTokenAddress);\n    }\n\n    /**\n     * @notice Stakes tokens on behalf of a given address\n     * @param beneficiaryAddress Address receiving the staking rewards\n     * @param amount Amount of tokens to be staked\n     * @param principalWalletShareBps Share of rewards going to principal wallet in basis points\n     * @custom:revert NotWhitelisted if beneficiary is not whitelisted\n     */\n    function stakeForAddress(\n        address beneficiaryAddress,\n        uint256 amount,\n        uint32 principalWalletShareBps\n    ) public nonReentrant {\n        if (!stakingWhitelist[beneficiaryAddress]) {\n            revert NotWhitelisted();\n        }\n\n        _internalStakeForAddress(\n            msg.sender,\n            beneficiaryAddress,\n            amount,\n            principalWalletShareBps\n        );\n    }\n\n    /**\n     * @notice Allows a user to stake tokens directly\n     * @param amount The amount of tokens to stake\n     * @custom:revert NotWhitelisted if caller is not whitelisted\n     */\n    function stake(uint256 amount) external nonReentrant {\n        if (!stakingWhitelist[msg.sender]) {\n            revert NotWhitelisted();\n        }\n        _internalStakeForAddress(msg.sender, msg.sender, amount, 10_000);\n    }\n\n    /**\n     * @notice Completes the unstaking process after the required duration\n     * @dev Checks daily withdrawal limits before processing\n     * @param stakingStoreIndex Index of the staking store\n     * @custom:revert DailyWithdrawalLimitExceeded if withdrawal would exceed daily limit\n     * @custom:revert UnstakingNotRequested if unstaking was not requested\n     * @custom:revert UnstakingPeriodNotElapsed if unstaking period has not elapsed\n     */\n    function unstake(\n        uint256 stakingStoreIndex\n    ) external onlyBeneficiaryOrPayoutWallet(stakingStoreIndex) nonReentrant {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n        if (currentStore.unstakingRequestTime == 0) {\n            revert UnstakingNotRequested();\n        }\n\n        if (\n            currentStore.unstakingRequestTime + unstakingDuration >\n            block.timestamp\n        ) {\n            revert UnstakingPeriodNotElapsed();\n        }\n\n        // Ensure the reward amount is up to date\n        updateReward(stakingStoreIndex);\n\n        uint256 rewardToSend = currentStore.reward - currentStore.paidOutReward;\n        currentStore.paidOutReward += rewardToSend;\n\n        uint256 principalWalletReward = (rewardToSend *\n            _getCurrentPrincipalWalletShareBps(stakingStoreIndex)) / 10000;\n        uint256 beneficiaryReward = rewardToSend - principalWalletReward;\n\n        if (principalWalletReward > 0) {\n            // Send tokens to delegator\n            STAKING_TOKEN.safeTransferFrom(\n                rewardsWallet,\n                currentStore.principalPayoutWallet,\n                principalWalletReward\n            );\n        }\n\n        STAKING_TOKEN.safeTransferFrom(\n            rewardsWallet,\n            currentStore.beneficiary,\n            beneficiaryReward\n        );\n        currentStore.unstakingRequestTime = 0;\n        currentStore.reward = 0;\n        currentStore.stakingStartTime = uint64(block.timestamp);\n\n        emit Unstaked(\n            stakingStoreIndex,\n            0,\n            principalWalletReward,\n            beneficiaryReward,\n            currentStore.principalPayoutWallet,\n            currentStore.beneficiary\n        );\n    }\n\n    /**\n     * @notice Unstakes the principal amount immediately\n     * @dev Only possible for the principal unstaker\n     * @param stakingStoreIndex Index of the staking store\n     * @param amount Amount of principal to unstake\n     * @custom:revert NotPrincipalUnstaker if caller is not the principal unstaker\n     * @custom:revert UnstakingNotRequested if unstaking was not requested\n     * @custom:revert UnstakingPeriodNotElapsed if unstaking period has not elapsed\n     * @custom:revert AmountExceedsStaked if amount exceeds staked principal\n     */\n    function unstakePrincipal(\n        uint256 stakingStoreIndex,\n        uint256 amount\n    ) external nonReentrant {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n\n        if (currentStore.unstakingRequestTime == 0) {\n            revert UnstakingNotRequested();\n        }\n        if (\n            currentStore.unstakingRequestTime + unstakingDuration >\n            block.timestamp\n        ) {\n            revert UnstakingPeriodNotElapsed();\n        }\n\n        if (currentStore.principalUnstaker != msg.sender) {\n            revert NotPrincipalUnstaker();\n        }\n\n        if (amount > currentStore.principal) {\n            revert AmountExceedsStaked();\n        }\n\n        updateReward(stakingStoreIndex);\n        uint256 principalToSend = amount;\n        currentStore.principal = currentStore.principal - amount;\n\n        uint256 rewardToSend = currentStore.reward - currentStore.paidOutReward;\n        currentStore.paidOutReward += rewardToSend;\n\n        currentStore.unstakingRequestTime = 0;\n        currentStore.stakingStartTime = uint64(block.timestamp);\n\n        uint256 principalWalletReward = (rewardToSend *\n            _getCurrentPrincipalWalletShareBps(stakingStoreIndex)) / 10000;\n        uint256 beneficiaryReward = rewardToSend - principalWalletReward;\n\n        if (principalWalletReward > 0) {\n            // Send tokens to delegator\n            STAKING_TOKEN.safeTransferFrom(\n                rewardsWallet,\n                currentStore.principalPayoutWallet,\n                principalWalletReward\n            );\n        }\n\n        // Pay out principal\n        STAKING_TOKEN.safeTransfer(\n            currentStore.principalPayoutWallet,\n            principalToSend\n        );\n\n        // Send remaining reward tokens to beneficiary\n        STAKING_TOKEN.safeTransferFrom(\n            rewardsWallet,\n            currentStore.beneficiary,\n            beneficiaryReward\n        );\n\n        emit Unstaked(\n            stakingStoreIndex,\n            principalToSend,\n            principalWalletReward,\n            beneficiaryReward,\n            currentStore.principalPayoutWallet,\n            currentStore.beneficiary\n        );\n    }\n\n    /**\n     * @notice Adds an address to the whitelist for staking\n     * @dev Only callable by the contract owner\n     * @param newStakerAddress The address to be whitelisted\n     * @custom:revert AlreadyWhitelisted if the address is already whitelisted\n     * @custom:event Emits StakerAddressAdded on success\n     */\n    function addWhitelistedStaker(address newStakerAddress) external onlyOwner {\n        if (stakingWhitelist[newStakerAddress]) {\n            revert AlreadyWhitelisted();\n        }\n        stakingWhitelist[newStakerAddress] = true;\n        emit StakerAddressAdded(newStakerAddress);\n    }\n\n    /**\n     * @notice Removes an address from the staking whitelist\n     * @dev Only callable by the contract owner\n     * @param stakerAddressToRemove The address to remove from the whitelist\n     * @custom:revert NotWhitelisted if the address is not currently whitelisted\n     * @custom:event Emits StakerAddressRemoved on success\n     */\n    function removeWhitelistedStaker(\n        address stakerAddressToRemove\n    ) external onlyOwner {\n        if (!stakingWhitelist[stakerAddressToRemove]) {\n            revert NotWhitelisted();\n        }\n        stakingWhitelist[stakerAddressToRemove] = false;\n        emit StakerAddressRemoved(stakerAddressToRemove);\n    }\n\n    /**\n     * @notice Calculates the accrued reward for a given staking store\n     * @dev The reward is calculated based on the number of full days passed since staking started\n     * @param stakingStoreIndex The index of the staking store\n     * @return The total reward accumulated so far\n     */\n    function getRewardForStakingStore(\n        uint256 stakingStoreIndex\n    ) public view override returns (uint256) {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n\n        // Calculate number of full days that passed for staking store\n        uint256 passedSeconds;\n        if (currentStore.unstakingRequestTime > 0) {\n            passedSeconds =\n                currentStore.unstakingRequestTime -\n                currentStore.stakingStartTime;\n        } else {\n            passedSeconds = block.timestamp - currentStore.stakingStartTime;\n        }\n        uint256 passedDays = passedSeconds / (24 * 60 * 60);\n\n        // assumption: reward rate is measured in bps\n        return (rewardRatePerDay * passedDays * currentStore.principal) / 10000;\n    }\n\n    /**\n     * @notice Updates the reward amount for a given staking store\n     * @dev Ensures the reward does not decrease\n     * @param stakingStoreIndex The index of the staking store\n     * @custom:assert The newly calculated reward must be greater than or equal to the current reward\n     */\n    function updateReward(uint256 stakingStoreIndex) internal {\n        StakingStore storage currentStore = stakingStores[stakingStoreIndex];\n        uint256 reward = getRewardForStakingStore(stakingStoreIndex);\n        assert(reward >= currentStore.reward);\n\n        currentStore.reward = reward;\n    }\n\n    /**\n     * @notice Get the current principal wallet share basis points for a stake\n     * @param stakeId The ID of the stake to check\n     * @return The current principal wallet share in basis points\n     */\n    function getCurrentPrincipalWalletShareBps(\n        uint256 stakeId\n    ) public view returns (uint32) {\n        return _getCurrentPrincipalWalletShareBps(stakeId);\n    }\n}\n",
        "DIAExternalStaking.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.29;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./StakingErrorsAndEvents.sol\";\n\n/**\n * @title DIAExternalStaking\n * @notice A staking contract that allows users to stake tokens and earn rewards\n * @dev Implements external staking functionality with principal/reward sharing and daily withdrawal limits\n */\ncontract DIAExternalStaking is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Mapping of beneficiary addresses to their staking indices\n    mapping(address => uint256[]) internal stakingIndicesByBeneficiary;\n\n    /// @notice Mapping of principal unstaker addresses to their staking indices\n    mapping(address => uint256[]) internal stakingIndicesByPrincipalUnstaker;\n\n    /// @notice Mapping of payout wallet addresses to their staking indices\n    mapping(address => uint256[]) internal stakingIndicesByPayoutWallet;\n\n    /// @notice Current staking index counter\n    uint256 public stakingIndex;\n\n    /// @notice Structure for pending share updates\n    struct PendingShareUpdate {\n        uint32 newShareBps; // New share in basis points\n        uint64 requestTime; // Time when update was requested\n    }\n\n    /// @notice Mapping of stake IDs to their pending share updates\n    mapping(uint256 => PendingShareUpdate) public pendingShareUpdates;\n\n    /// @notice Grace period for share updates (1 day)\n    uint64 public constant SHARE_UPDATE_GRACE_PERIOD = 1 days;\n\n    /// @notice ERC20 token used for staking\n    IERC20 public immutable STAKING_TOKEN;\n\n    /// @notice Structure for storing staking information\n    struct ExternalStakingStore {\n        address beneficiary; // Address receiving rewards\n        address principalPayoutWallet; // Address receiving principal\n        address principalUnstaker; // Address allowed to unstake principal\n        uint256 principal; // Amount of tokens staked\n        uint256 poolShares; // Share of the total pool\n        uint64 stakingStartTime; // When staking began\n        uint64 unstakingRequestTime; // When unstaking was requested\n        uint32 principalWalletShareBps; // Share of rewards going to principal wallet\n    }\n\n    /// @notice Total size of the staking pool\n    uint256 public totalPoolSize;\n\n    /// @notice Total amount of pool shares\n    uint256 public totalShareAmount;\n\n    /// @notice Total amount of tokens staked\n    uint256 public tokensStaked;\n\n    /// @notice Maximum amount of tokens that can be staked\n    uint256 public stakingLimit;\n\n    /// @notice Duration required before unstaking can be completed\n    uint256 public unstakingDuration;\n\n    /// @notice Total amount withdrawn in the current day\n    uint256 public totalDailyWithdrawals;\n\n    /// @notice Timestamp of the last day when withdrawals were reset\n    uint256 public lastWithdrawalResetDay;\n\n    /// @notice Minimum pool size required to trigger withdrawal limits\n    uint256 public dailyWithdrawalThreshold = 100000 * 10 ** 18;\n\n    /// @notice Maximum percentage of pool that can be withdrawn per day (in basis points)\n    uint256 public withdrawalCapBps = 1000; // 1000 bps = 10%\n\n    /// @notice Mapping of staking indices to their corresponding staking stores\n    mapping(uint256 => ExternalStakingStore) public stakingStores;\n\n    /**\n     * @notice Modifier to check if caller is beneficiary or payout wallet\n     * @param stakingStoreIndex Index of the staking store\n     * @custom:revert AccessDenied if caller is neither beneficiary nor payout wallet\n     */\n    modifier onlyBeneficiaryOrPayoutWallet(uint256 stakingStoreIndex) {\n        ExternalStakingStore storage currentStore = stakingStores[\n            stakingStoreIndex\n        ];\n        if (\n            msg.sender != currentStore.beneficiary &&\n            msg.sender != currentStore.principalUnstaker\n        ) {\n            revert AccessDenied();\n        }\n        _;\n    }\n\n    /**\n     * @notice Modifier to check daily withdrawal limits\n     * @param amount Amount to be withdrawn\n     * @custom:revert DailyWithdrawalLimitExceeded if withdrawal would exceed daily limit\n     */\n    modifier checkDailyWithdrawalLimit(uint256 amount) {\n        if (block.timestamp / SECONDS_IN_A_DAY > lastWithdrawalResetDay) {\n            totalDailyWithdrawals = 0;\n            lastWithdrawalResetDay = block.timestamp / SECONDS_IN_A_DAY;\n        }\n\n        if (totalPoolSize > dailyWithdrawalThreshold) {\n            uint256 availableDailyLimit = (totalPoolSize * withdrawalCapBps) /\n                10000;\n            if (totalDailyWithdrawals + amount > availableDailyLimit) {\n                revert DailyWithdrawalLimitExceeded();\n            }\n        }\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract with staking parameters\n     * @param _unstakingDuration Duration required before unstaking can be completed\n     * @param _stakingTokenAddress Address of the ERC20 token used for staking\n     * @param _stakingLimit Maximum amount of tokens that can be staked\n     * @custom:revert ZeroAddress if staking token address is zero\n     */\n    constructor(\n        uint256 _unstakingDuration,\n        address _stakingTokenAddress,\n        uint256 _stakingLimit\n    ) Ownable(msg.sender) {\n        if (_stakingTokenAddress == address(0)) revert ZeroAddress();\n        unstakingDuration = _unstakingDuration;\n        STAKING_TOKEN = IERC20(_stakingTokenAddress);\n        stakingLimit = _stakingLimit;\n        lastWithdrawalResetDay = block.timestamp;\n    }\n\n    /**\n     * @notice Allows a user to stake tokens directly\n     * @param amount Amount of tokens to stake\n     * @param principalWalletShareBps Share of rewards going to principal wallet in basis points\n     */\n    function stake(\n        uint256 amount,\n        uint32 principalWalletShareBps\n    ) public nonReentrant {\n        _stake(msg.sender, amount, principalWalletShareBps, msg.sender);\n    }\n\n    /**\n     * @notice Stakes tokens on behalf of a given address\n     * @param beneficiaryAddress Address receiving the staking rewards\n     * @param amount Amount of tokens to be staked\n     * @param principalWalletShareBps Share of rewards going to principal wallet in basis points\n     */\n    function stakeForAddress(\n        address beneficiaryAddress,\n        uint256 amount,\n        uint32 principalWalletShareBps\n    ) public nonReentrant {\n        _stake(beneficiaryAddress, amount, principalWalletShareBps, msg.sender);\n    }\n\n    /**\n     * @notice Internal function to handle staking logic\n     * @param beneficiaryAddress Address receiving the staking rewards\n     * @param amount Amount of tokens to be staked\n     * @param principalWalletShareBps Share of rewards going to principal wallet in basis points\n     * @param staker Address performing the stake operation\n     * @custom:revert AmountAboveStakingLimit if amount exceeds staking limit\n     * @custom:revert InvalidPrincipalWalletShare if share exceeds 100%\n     * @custom:revert AmountBelowMinimumStake if amount is below minimum stake\n     */\n    function _stake(\n        address beneficiaryAddress,\n        uint256 amount,\n        uint32 principalWalletShareBps,\n        address staker\n    ) internal {\n        if (amount > (stakingLimit - tokensStaked)) {\n            revert AmountAboveStakingLimit(amount);\n        }\n\n        if (principalWalletShareBps > 10000)\n            revert InvalidPrincipalWalletShare();\n\n        if (amount < minimumStake) {\n            revert AmountBelowMinimumStake(amount);\n        }\n\n        STAKING_TOKEN.safeTransferFrom(staker, address(this), amount);\n\n        uint256 poolSharesGiven = 0;\n        if (totalShareAmount == 0) {\n            poolSharesGiven = amount;\n        } else {\n            poolSharesGiven = (amount * totalShareAmount) / totalPoolSize;\n        }\n\n        totalPoolSize += amount;\n        totalShareAmount += poolSharesGiven;\n\n        stakingIndex++;\n        ExternalStakingStore storage newStore = stakingStores[stakingIndex];\n        newStore.beneficiary = beneficiaryAddress;\n        newStore.principalPayoutWallet = staker;\n        newStore.principal = amount;\n        newStore.poolShares = poolSharesGiven;\n        newStore.stakingStartTime = uint64(block.timestamp);\n        newStore.principalWalletShareBps = principalWalletShareBps;\n        newStore.principalUnstaker = staker;\n\n        tokensStaked += amount;\n        stakingIndicesByBeneficiary[beneficiaryAddress].push(stakingIndex);\n        stakingIndicesByPrincipalUnstaker[staker].push(stakingIndex);\n        stakingIndicesByPayoutWallet[staker].push(stakingIndex);\n\n        emit Staked(beneficiaryAddress, stakingIndex, amount);\n    }\n\n    /**\n     * @notice Updates the duration required before unstaking can be completed\n     * @param newDuration New unstaking duration in seconds\n     * @custom:revert UnstakingDurationTooShort if duration is less than 1 day\n     * @custom:revert UnstakingDurationTooLong if duration exceeds 20 days\n     */\n    function setUnstakingDuration(uint256 newDuration) external onlyOwner {\n        if (newDuration < 1 days) {\n            revert UnstakingDurationTooShort();\n        }\n        if (newDuration > 20 days) {\n            revert UnstakingDurationTooLong();\n        }\n        emit UnstakingDurationUpdated(unstakingDuration, newDuration);\n        unstakingDuration = newDuration;\n    }\n\n    /**\n     * @notice Updates the withdrawal cap in basis points\n     * @param newBps New cap value in basis points\n     * @custom:revert InvalidWithdrawalCap if new cap exceeds 10000 bps\n     */\n    function setWithdrawalCapBps(uint256 newBps) external onlyOwner {\n        if (newBps > 10000) {\n            revert InvalidWithdrawalCap(newBps);\n        }\n        uint256 oldCap = withdrawalCapBps;\n        withdrawalCapBps = newBps;\n        emit WithdrawalCapUpdated(oldCap, newBps);\n    }\n\n    /**\n     * @notice Updates the daily withdrawal threshold\n     * @param newThreshold New threshold value\n     * @custom:revert InvalidDailyWithdrawalThreshold if new threshold is 0\n     */\n    function setDailyWithdrawalThreshold(\n        uint256 newThreshold\n    ) external onlyOwner {\n        if (newThreshold <= 0) {\n            revert InvalidDailyWithdrawalThreshold(newThreshold);\n        }\n        uint256 oldThreshold = dailyWithdrawalThreshold;\n        dailyWithdrawalThreshold = newThreshold;\n        emit DailyWithdrawalThresholdUpdated(oldThreshold, newThreshold);\n    }\n\n    /**\n     * @notice Gets all staking indices for a beneficiary\n     * @param beneficiary Address of the beneficiary\n     * @return Array of staking indices\n     */\n    function getStakingIndicesByBeneficiary(\n        address beneficiary\n    ) external view returns (uint256[] memory) {\n        return stakingIndicesByBeneficiary[beneficiary];\n    }\n\n    /**\n     * @notice Gets all staking indices for a principal unstaker\n     * @param unstaker Address of the principal unstaker\n     * @return Array of staking indices\n     */\n    function getStakingIndicesByPrincipalUnstaker(\n        address unstaker\n    ) external view returns (uint256[] memory) {\n        return stakingIndicesByPrincipalUnstaker[unstaker];\n    }\n\n    /**\n     * @notice Gets all staking indices for a payout wallet\n     * @param payoutWallet Address of the payout wallet\n     * @return Array of staking indices\n     */\n    function getStakingIndicesByPayoutWallet(\n        address payoutWallet\n    ) external view returns (uint256[] memory) {\n        return stakingIndicesByPayoutWallet[payoutWallet];\n    }\n\n    /**\n     * @notice Internal function to remove a staking index from an address mapping\n     * @param user Address to remove index from\n     * @param _stakingIndex Index to remove\n     * @param indexMap Mapping to remove from\n     */\n    function _removeStakingIndexFromAddressMapping(\n        address user,\n        uint256 _stakingIndex,\n        mapping(address => uint256[]) storage indexMap\n    ) internal {\n        uint256[] storage indices = indexMap[user];\n        for (uint256 i = 0; i < indices.length; i++) {\n            if (indices[i] == _stakingIndex) {\n                indices[i] = indices[indices.length - 1];\n                indices.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the principal payout wallet for a stake\n     * @param newWallet New wallet address for receiving principal\n     * @param stakingStoreIndex Index of the staking store\n     * @custom:revert ZeroAddress if new wallet is zero address\n     * @custom:revert NotPrincipalUnstaker if caller is not the principal unstaker\n     */\n    function updatePrincipalPayoutWallet(\n        address newWallet,\n        uint256 stakingStoreIndex\n    ) external {\n        if (newWallet == address(0)) revert ZeroAddress();\n        ExternalStakingStore storage currentStore = stakingStores[\n            stakingStoreIndex\n        ];\n        address oldWallet = currentStore.principalPayoutWallet;\n        currentStore.principalPayoutWallet = newWallet;\n\n        if (currentStore.principalUnstaker != msg.sender) {\n            revert NotPrincipalUnstaker();\n        }\n\n        _removeStakingIndexFromAddressMapping(\n            oldWallet,\n            stakingStoreIndex,\n            stakingIndicesByPayoutWallet\n        );\n        stakingIndicesByPayoutWallet[newWallet].push(stakingStoreIndex);\n\n        emit PrincipalPayoutWalletUpdated(\n            oldWallet,\n            newWallet,\n            stakingStoreIndex\n        );\n    }\n\n    /**\n     * @notice Updates the principal unstaker for a stake\n     * @param newUnstaker New address allowed to unstake principal\n     * @param stakingStoreIndex Index of the staking store\n     * @custom:revert ZeroAddress if new unstaker is zero address\n     * @custom:revert NotPrincipalUnstaker if caller is not the current principal unstaker\n     */\n    function updatePrincipalUnstaker(\n        address newUnstaker,\n        uint256 stakingStoreIndex\n    ) external {\n        if (newUnstaker == address(0)) revert ZeroAddress();\n        ExternalStakingStore storage currentStore = stakingStores[\n            stakingStoreIndex\n        ];\n        if (currentStore.principalUnstaker != msg.sender) {\n            revert NotPrincipalUnstaker();\n        }\n        currentStore.principalUnstaker = newUnstaker;\n    }\n\n    /**\n     * @notice Requests unstaking, starting the waiting period\n     * @param stakingStoreIndex Index of the staking store\n     * @custom:revert AlreadyRequestedUnstake if unstaking was already requested\n     * @custom:revert AccessDenied if caller is not beneficiary or payout wallet\n     */\n    function requestUnstake(\n        uint256 stakingStoreIndex\n    ) external nonReentrant onlyBeneficiaryOrPayoutWallet(stakingStoreIndex) {\n        ExternalStakingStore storage currentStore = stakingStores[\n            stakingStoreIndex\n        ];\n        if (currentStore.unstakingRequestTime != 0) {\n            revert AlreadyRequestedUnstake();\n        }\n        currentStore.unstakingRequestTime = uint64(block.timestamp);\n        emit UnstakeRequested(msg.sender, stakingStoreIndex);\n    }\n\n    /**\n     * @notice Completes the unstaking process after the required duration\n     * @param stakingStoreIndex Index of the staking store\n     * @param amount Amount to unstake\n     * @custom:revert UnstakingNotRequested if unstaking was not requested\n     * @custom:revert UnstakingPeriodNotElapsed if unstaking period has not elapsed\n     * @custom:revert AmountExceedsStaked if amount exceeds staked amount\n     * @custom:revert DailyWithdrawalLimitExceeded if withdrawal would exceed daily limit\n     */\n    function unstake(\n        uint256 stakingStoreIndex,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyBeneficiaryOrPayoutWallet(stakingStoreIndex)\n        checkDailyWithdrawalLimit(amount)\n    {\n        ExternalStakingStore storage currentStore = stakingStores[\n            stakingStoreIndex\n        ];\n        if (currentStore.unstakingRequestTime == 0) {\n            revert UnstakingNotRequested();\n        }\n\n        if (\n            currentStore.unstakingRequestTime + unstakingDuration >\n            block.timestamp\n        ) {\n            revert UnstakingPeriodNotElapsed();\n        }\n\n        uint256 currentAmountOfPool = (currentStore.poolShares *\n            totalPoolSize) / totalShareAmount;\n        if (amount > currentAmountOfPool) {\n            revert AmountExceedsStaked();\n        }\n\n        uint256 poolSharesUnstakeAmount = (currentStore.poolShares * amount) /\n            currentAmountOfPool;\n        uint256 principalUnstakeAmount = (currentStore.principal * amount) /\n            currentAmountOfPool;\n        uint256 rewardUnstakeAmount = amount - principalUnstakeAmount;\n\n        uint256 principalToSend = principalUnstakeAmount;\n        uint256 rewardToSend = rewardUnstakeAmount;\n        currentStore.principal =\n            currentStore.principal -\n            principalUnstakeAmount;\n        tokensStaked -= principalUnstakeAmount;\n        currentStore.poolShares -= poolSharesUnstakeAmount;\n        currentStore.unstakingRequestTime = 0;\n        currentStore.stakingStartTime = uint64(block.timestamp);\n\n        totalDailyWithdrawals += amount;\n        totalPoolSize -= amount;\n        totalShareAmount -= poolSharesUnstakeAmount;\n\n        uint256 principalWalletReward = (rewardToSend *\n            _getCurrentPrincipalWalletShareBps(stakingStoreIndex)) / 10000;\n        uint256 beneficiaryReward = rewardToSend - principalWalletReward;\n\n        if (principalWalletReward > 0) {\n            STAKING_TOKEN.safeTransfer(\n                currentStore.principalPayoutWallet,\n                principalWalletReward\n            );\n        }\n\n        STAKING_TOKEN.safeTransfer(\n            currentStore.principalPayoutWallet,\n            principalToSend\n        );\n        STAKING_TOKEN.safeTransfer(currentStore.beneficiary, beneficiaryReward);\n\n        emit Unstaked(\n            stakingStoreIndex,\n            principalToSend,\n            principalWalletReward,\n            beneficiaryReward,\n            currentStore.principalPayoutWallet,\n            currentStore.beneficiary\n        );\n    }\n\n    function addRewardToPool(uint256 amount) public {\n        STAKING_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\n        totalPoolSize += amount;\n        emit RewardAdded(amount, msg.sender);\n    }\n\n    /**\n     * @notice Gets the current principal wallet share basis points for a stake\n     * @param stakingStoreIndex ID of the stake\n     * @return Current principal wallet share in basis points\n     */\n    function _getCurrentPrincipalWalletShareBps(\n        uint256 stakingStoreIndex\n    ) internal view returns (uint32) {\n        PendingShareUpdate memory pending = pendingShareUpdates[stakingStoreIndex];\n        if (\n            pending.requestTime > 0 &&\n            block.timestamp >= pending.requestTime + SHARE_UPDATE_GRACE_PERIOD\n        ) {\n            return pending.newShareBps;\n        }\n\n        return stakingStores[stakingStoreIndex].principalWalletShareBps;\n    }\n\n    /**\n     * @notice Gets the current principal wallet share basis points for a stake\n     * @param stakingStoreIndex of the stake\n     * @return Current principal wallet share in basis points\n     */\n    function getCurrentPrincipalWalletShareBps(\n        uint256 stakingStoreIndex\n    ) public view returns (uint32) {\n        return _getCurrentPrincipalWalletShareBps(stakingStoreIndex);\n    }\n\n    /**\n     * @notice Calculates the reward for a given staking store\n     * @param stakingStoreIndex Index of the staking store\n     * @return Amount of rewards available\n     */\n    function getRewardForStakingStore(\n        uint256 stakingStoreIndex\n    ) public view returns (uint256, uint256) {\n        ExternalStakingStore storage store = stakingStores[stakingStoreIndex];\n        uint256 claimableTokens = (store.poolShares * totalPoolSize) /\n            totalShareAmount;\n        uint256 fullReward = claimableTokens - store.principal;\n\t\t\t\tuint256 principalWalletReward = (fullReward * store.principalWalletShareBps) / 10000;\n\t\t\t\treturn (principalWalletReward, fullReward - principalWalletReward);\n    }\n\n    /**\n     * @notice Requests an update to the principal wallet share\n     * @param stakingStoreIndex of the stake\n     * @param newShareBps New share in basis points\n     * @custom:revert NotBeneficiary if caller is not the beneficiary\n     * @custom:revert InvalidPrincipalWalletShare if new share exceeds 100%\n     */\n    function requestPrincipalWalletShareUpdate(\n        uint256 stakingStoreIndex,\n        uint32 newShareBps\n    ) external {\n        if (msg.sender != stakingStores[stakingStoreIndex].principalUnstaker) {\n            revert NotPrincipalUnstaker();\n        }\n        if (newShareBps > 10000) revert InvalidPrincipalWalletShare();\n\n        pendingShareUpdates[stakingStoreIndex] = PendingShareUpdate({\n            newShareBps: newShareBps,\n            requestTime: uint64(block.timestamp)\n        });\n\n        emit PrincipalWalletShareUpdateRequested(\n            stakingStoreIndex,\n            newShareBps,\n            block.timestamp\n        );\n    }\n}\n"
    }
}