{
    "vfp_id": "vfp_00006",
    "project_name": "2025-06-reserveprotocol-solidity400-securityreview.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Denial of service allows blocking operations during Dutch auctions",
            "description": "A malicious actor can trigger a denial of service by creating a CowSwap filler at the beginning of a block and performing a minimal swap (e.g., 1 wei), causing the swapActive function to return true. This causes the sync modifier to revert, blocking all dependent functions. The root cause is the lack of a minimum threshold for swaps to be considered valid in the swapActive check. During Dutch auctions, where prices decrease over time, an attacker can exploit this to block other users' transactions and then bid at a lower price after the price drops. The impact is a temporary disruption of service and potential financial gain for the attacker at the expense of other users, undermining fair access to auctions.\n",
            "severity": "Medium",
            "location": [
                "CowSwapFiller.sol::swapActive#88-104"
            ],
            "files": [
                "20ec35af10212eefaa3963cefce7318231c20567/trusted-fillers/contracts/fillers/cowswap/CowSwapFiller.sol"
            ]
        }
    ],
    "affected_files": {
        "CowSwapFiller.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IBaseTrustedFiller } from \"../../interfaces/IBaseTrustedFiller.sol\";\n\nimport { GPv2OrderLib } from \"./GPv2OrderLib.sol\";\nimport { GPV2_SETTLEMENT, GPV2_VAULT_RELAYER, D27 } from \"./Constants.sol\";\n\n/// Swap MUST occur in the same block as initialization\n/// Expected to be newly deployed in the pre-hook of a CowSwap order\n/// Ideally `closeFiller()` is called in the end as a post-hook, but this is not relied upon\ncontract CowSwapFiller is Initializable, IBaseTrustedFiller {\n    using GPv2OrderLib for GPv2OrderLib.Data;\n    using SafeERC20 for IERC20;\n\n    error CowSwapFiller__Unauthorized();\n    error CowSwapFiller__OrderCheckFailed(uint256 errorCode);\n\n    address public fillCreator;\n\n    IERC20 public sellToken;\n    IERC20 public buyToken;\n\n    uint256 public sellAmount; // {sellTok}\n    uint256 public blockInitialized; // {block}\n\n    uint256 public price; // D27{buyTok/sellTok}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// Initialize the swap, transferring in `_sellAmount` of the `_sell` token\n    /// @dev Built for the pre-hook of a CowSwap order, must be called via using entity\n    function initialize(\n        address _creator,\n        IERC20 _sellToken,\n        IERC20 _buyToken,\n        uint256 _sellAmount,\n        uint256 _minBuyAmount\n    ) external initializer {\n        fillCreator = _creator;\n        sellToken = _sellToken;\n        buyToken = _buyToken;\n        sellAmount = _sellAmount;\n\n        blockInitialized = block.number;\n\n        // D27{buyTok/sellTok} = {buyTok} * D27 / {sellTok}\n        price = Math.mulDiv(_minBuyAmount, D27, _sellAmount, Math.Rounding.Ceil);\n\n        sellToken.forceApprove(GPV2_VAULT_RELAYER, _sellAmount);\n        sellToken.safeTransferFrom(_creator, address(this), _sellAmount);\n    }\n\n    /// @dev Validates CowSwap order for a fill via EIP-1271\n    function isValidSignature(bytes32 orderHash, bytes calldata signature) external view returns (bytes4) {\n        require(block.number == blockInitialized, CowSwapFiller__Unauthorized());\n\n        // Decode signature to get the CowSwap order\n        GPv2OrderLib.Data memory order = abi.decode(signature, (GPv2OrderLib.Data));\n\n        // Verify Order Hash\n        require(orderHash == order.hash(GPV2_SETTLEMENT.domainSeparator()), CowSwapFiller__OrderCheckFailed(0)); // Invalid Order Hash\n\n        require(order.sellToken == sellToken, CowSwapFiller__OrderCheckFailed(1)); // Invalid Sell Token\n        require(order.buyToken == buyToken, CowSwapFiller__OrderCheckFailed(2)); // Invalid Buy Token\n        require(order.feeAmount == 0, CowSwapFiller__OrderCheckFailed(3)); // Must be a Limit Order\n        require(order.receiver == address(this), CowSwapFiller__OrderCheckFailed(4)); // Receiver must be self\n        require(order.sellTokenBalance == GPv2OrderLib.BALANCE_ERC20, CowSwapFiller__OrderCheckFailed(5)); // Must use ERC20 Balance\n        require(order.buyTokenBalance == GPv2OrderLib.BALANCE_ERC20, CowSwapFiller__OrderCheckFailed(6)); // Must use ERC20 Balance\n        require(order.sellAmount != 0, CowSwapFiller__OrderCheckFailed(7)); // catch div-by-zero below\n\n        // Price check, just in case\n        // D27{buyTok/sellTok} = {buyTok} * D27 / {sellTok}\n        uint256 orderPrice = Math.mulDiv(order.buyAmount, D27, order.sellAmount, Math.Rounding.Floor);\n        require(order.sellAmount <= sellAmount && orderPrice >= price, CowSwapFiller__OrderCheckFailed(100));\n\n        // If all checks pass, return the magic value\n        return this.isValidSignature.selector;\n    }\n\n    /// @return true if the contract is mid-swap and funds have not yet settled\n    function swapActive() public view returns (bool) {\n        if (block.number != blockInitialized) {\n            return false;\n        }\n\n        uint256 sellTokenBalance = sellToken.balanceOf(address(this));\n\n        if (sellTokenBalance >= sellAmount) {\n            return false;\n        }\n\n        // {buyTok} = {sellTok} * D27{buyTok/sellTok} / D27\n        uint256 minimumExpectedIn = Math.mulDiv(sellAmount - sellTokenBalance, price, D27, Math.Rounding.Ceil);\n        \n        return minimumExpectedIn > buyToken.balanceOf(address(this));\n    }\n\n    /// Collect all balances back to the beneficiary\n    function closeFiller() external {\n        require(!swapActive(), IBaseTrustedFiller__SwapActive());\n\n        rescueToken(sellToken);\n        rescueToken(buyToken);\n    }\n\n    /// Rescue tokens in case any are left in the contract\n    function rescueToken(IERC20 token) public {\n        uint256 tokenBalance = token.balanceOf(address(this));\n\n        if (tokenBalance != 0) {\n            token.safeTransfer(fillCreator, tokenBalance);\n        }\n    }\n}\n"
    }
}