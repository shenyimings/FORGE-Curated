{
    "vfp_id": "vfp_00141",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect/repeated withdrawal from rocketSmoothingPool in executeRewardSnapshot() will lead to loss of ETH rewards",
            "description": "The vulnerability involves a redundant and incorrect withdrawal call in the _executeRewardSnapshot() function of RocketRewardsPool.sol, where ETH is withdrawn twice from the rocketSmoothingPool for the same reward distribution.\n\nThe root cause is a logic error where, after already withdrawing smoothingPoolETH into the contract, the function attempts to withdraw the same amount again directly to the relay. This second withdrawal is unnecessary and dangerous because it assumes the smoothing pool still has sufficient balance.\n\nAn attacker cannot directly exploit this, but the protocol itself will fail during reward distribution if the smoothing pool lacks sufficient balance, causing the entire transaction to revert. More likely, if the first withdrawal succeeds but the second is skipped due to logic flaws, ETH may become stuck in RocketRewardsPool.\n\nThe impact is a loss of ETH rewards for node operators who participate in the smoothing pool, as funds either get stuck or cause transaction reverts, disrupting the reward distribution process in every cycle.\n",
            "severity": "High",
            "location": [
                "RocketRewardsPool.sol::_executeRewardSnapshot#254-256",
                "RocketRewardsPool.sol::_executeRewardSnapshot#302-305"
            ],
            "files": [
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketRewardsPool.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketVaultInterface} from \"../../interface/RocketVaultInterface.sol\";\nimport {RocketDAONodeTrustedInterface} from \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport {RocketDAOProtocolSettingsNetworkInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport {RocketDAOProtocolSettingsRewardsInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol\";\nimport {RocketRewardsPoolInterface} from \"../../interface/rewards/RocketRewardsPoolInterface.sol\";\nimport {RocketRewardsRelayInterface} from \"../../interface/rewards/RocketRewardsRelayInterface.sol\";\nimport {RocketSmoothingPoolInterface} from \"../../interface/rewards/RocketSmoothingPoolInterface.sol\";\nimport {RocketTokenRPLInterface} from \"../../interface/token/RocketTokenRPLInterface.sol\";\nimport {IERC20} from \"../../interface/util/IERC20.sol\";\nimport {RewardSubmission} from \"../../types/RewardSubmission.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketVaultWithdrawerInterface} from \"../../interface/RocketVaultWithdrawerInterface.sol\";\n\n/// @notice Holds RPL and ETH generated by the network for distribution each reward cycle\ncontract RocketRewardsPool is RocketBase, RocketRewardsPoolInterface, RocketVaultWithdrawerInterface {\n    // Events\n    event RewardSnapshotSubmitted(address indexed from, uint256 indexed rewardIndex, RewardSubmission submission, uint256 time);\n    event RewardSnapshot(uint256 indexed rewardIndex, RewardSubmission submission, uint256 intervalStartTime, uint256 intervalEndTime, uint256 time);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 5;\n    }\n\n    /// @dev Needs to freely accept ETH withdrawn from the smoothing pool\n    receive() payable external {}\n\n    /// @dev Needs to freely accept ETH withdrawn from the vault\n    function receiveVaultWithdrawalETH() external payable {}\n\n    /// @notice Accepts incoming ETH from megapool distributions for voter share into vault\n    function depositVoterShare() override payable external {\n        // Transfer incoming ETH directly to the vault\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.depositEther{value: msg.value}();\n    }\n\n    /// @notice Returns the amount of ETH rewards waiting to be distributed\n    function getEthBalance() override external view returns (uint256) {\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        return rocketVault.balanceOf(\"rocketRewardsPool\");\n    }\n\n    /// @notice Get the reward index\n    function getRewardIndex() override public view returns (uint256) {\n        return getUint(keccak256(\"rewards.snapshot.index\"));\n    }\n\n    /// @notice Increment the reward index\n    function incrementRewardIndex() private {\n        addUint(keccak256(\"rewards.snapshot.index\"), 1);\n    }\n\n    /// @notice Get how much RPL the Rewards Pool contract currently has assigned to it as a whole\n    /// @return uint256 Returns rpl balance of rocket rewards contract\n    function getRPLBalance() override public view returns (uint256) {\n        // Get the vault contract instance\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Check contract RPL balance\n        return rocketVault.balanceOfToken(\"rocketRewardsPool\", IERC20(getContractAddress(\"rocketTokenRPL\")));\n    }\n\n    /// @notice Returns the total amount of RPL that needs to be distributed to claimers at the current block\n    function getPendingRPLRewards() override public view returns (uint256) {\n        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress(\"rocketTokenRPL\"));\n        uint256 pendingInflation = rplContract.inflationCalculate();\n        // Any inflation that has accrued so far plus any amount that would be minted if we called it now\n        return getRPLBalance() + pendingInflation;\n    }\n\n    /// @notice Returns the total amount of ETH in the smoothing pool ready to be distributed\n    function getPendingETHRewards() override public view returns (uint256) {\n        address rocketSmoothingPoolAddress = getContractAddress(\"rocketSmoothingPool\");\n        return rocketSmoothingPoolAddress.balance;\n    }\n\n    /// @notice Returns the amount of pending voter share ETH ready to be distributed\n    function getPendingVoterShare() override public view returns (uint256) {\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        return rocketVault.balanceOf(\"rocketRewardsPool\");\n    }\n\n    /// @notice Get the last set interval start time\n    /// @return uint256 Last set start timestamp for a claim interval\n    function getClaimIntervalTimeStart() override public view returns (uint256) {\n        return getUint(keccak256(\"rewards.pool.claim.interval.time.start\"));\n    }\n\n    /// @notice Get how many seconds in a claim interval\n    /// @return uint256 Number of seconds in a claim interval\n    function getClaimIntervalTime() override public view returns (uint256) {\n        // Get from the DAO settings\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        return daoSettingsRewards.getRewardsClaimIntervalTime();\n    }\n\n    /// @notice Compute intervals since last claim period\n    /// @return uint256 Time intervals since last update\n    function getClaimIntervalsPassed() override public view returns (uint256) {\n        return (block.timestamp - getClaimIntervalTimeStart()) / getClaimIntervalTime();\n    }\n\n    /// @notice Returns the block number that the given claim interval was executed at\n    /// @param _interval The interval for which to grab the execution block of\n    function getClaimIntervalExecutionBlock(uint256 _interval) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.block\", _interval)));\n    }\n\n    /// @notice Returns the address of the contract which was used to execute this reward interval\n    /// @param _interval The interval for which to grab the address of\n    function getClaimIntervalExecutionAddress(uint256 _interval) override external view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.address\", _interval)));\n    }\n\n    /// @notice Get the percentage this contract can claim in this interval\n    /// @return uint256 Rewards percentage this contract can claim in this interval\n    function getClaimingContractPerc(string memory _claimingContract) override public view returns (uint256) {\n        // Load contract\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        // Get the % amount allocated to this claim contract\n        return daoSettingsRewards.getRewardsClaimerPerc(_claimingContract);\n    }\n\n    /// @notice Get an array of percentages that the given contracts can claim in this interval\n    /// @return uint256[] Array of percentages in the order of the supplied contract names\n    function getClaimingContractsPerc(string[] memory _claimingContracts) override external view returns (uint256[] memory) {\n        // Load contract\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        // Get the % amount allocated to this claim contract\n        uint256[] memory percentages = new uint256[](_claimingContracts.length);\n        for (uint256 i = 0; i < _claimingContracts.length; ++i) {\n            percentages[i] = daoSettingsRewards.getRewardsClaimerPerc(_claimingContracts[i]);\n        }\n        return percentages;\n    }\n\n    /// @notice Returns whether a trusted node has submitted for a given reward index\n    function getTrustedNodeSubmitted(address _trustedNodeAddress, uint256 _rewardIndex) override external view returns (bool) {\n        return getBool(keccak256(abi.encode(\"rewards.snapshot.submitted.node\", _trustedNodeAddress, _rewardIndex)));\n    }\n\n    /// @notice Returns whether a trusted node has submitted a specific RewardSubmission\n    function getSubmissionFromNodeExists(address _trustedNodeAddress, RewardSubmission calldata _submission) override external view returns (bool) {\n        return getBool(keccak256(abi.encode(\"rewards.snapshot.submitted.node.key\", _trustedNodeAddress, _submission)));\n    }\n\n    /// @notice Returns the number of trusted nodes who have agreed to the given submission\n    function getSubmissionCount(RewardSubmission calldata _submission) override external view returns (uint256) {\n        return getUint(keccak256(abi.encode(\"rewards.snapshot.submitted.count\", _submission)));\n    }\n\n    /// @notice Submit a reward snapshot. Only accepts calls from trusted (oracle) nodes\n    function submitRewardSnapshot(RewardSubmission calldata _submission) override external onlyLatestContract(\"rocketRewardsPool\", address(this)) onlyTrustedNode(msg.sender) {\n        // Get contracts\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        // Check submission is currently enabled\n        require(rocketDAOProtocolSettingsNetwork.getSubmitRewardsEnabled(), \"Submitting rewards is currently disabled\");\n        // Validate inputs\n        uint256 rewardIndex = getRewardIndex();\n        require(_submission.rewardIndex <= rewardIndex, \"Can only submit snapshot for periods up to next\");\n        require(_submission.intervalsPassed > 0, \"Invalid number of intervals passed\");\n        require(_submission.nodeRPL.length == _submission.trustedNodeRPL.length && _submission.trustedNodeRPL.length == _submission.nodeETH.length, \"Invalid array length\");\n        // Calculate RPL reward total and validate\n        { // Scope to prevent stack too deep\n            uint256 totalRewardsRPL = _submission.treasuryRPL;\n            for (uint256 i = 0; i < _submission.nodeRPL.length; ++i) {\n                totalRewardsRPL = totalRewardsRPL + _submission.nodeRPL[i];\n            }\n            for (uint256 i = 0; i < _submission.trustedNodeRPL.length; ++i) {\n                totalRewardsRPL = totalRewardsRPL + _submission.trustedNodeRPL[i];\n            }\n            require(totalRewardsRPL <= getPendingRPLRewards(), \"Invalid RPL rewards\");\n        }\n        // Calculate ETH reward total and validate\n        { // Scope to prevent stack too deep\n            uint256 totalRewardsETH = _submission.treasuryETH + _submission.userETH;\n            for (uint256 i = 0; i < _submission.nodeETH.length; ++i) {\n                totalRewardsETH = totalRewardsETH + _submission.nodeETH[i];\n            }\n            uint256 smoothingPoolBalance = getPendingETHRewards();\n            require(totalRewardsETH <= smoothingPoolBalance + getPendingVoterShare(), \"Invalid ETH rewards\");\n            require(_submission.smoothingPoolETH <= smoothingPoolBalance, \"Invalid smoothing pool balance\");\n        }\n        // Store and increment vote\n        uint256 submissionCount;\n        { // Scope to prevent stack too deep\n            // Check & update node submission status\n            bytes32 nodeSubmissionKey = keccak256(abi.encode(\"rewards.snapshot.submitted.node.key\", msg.sender, _submission));\n            require(!getBool(nodeSubmissionKey), \"Duplicate submission from node\");\n            setBool(nodeSubmissionKey, true);\n            setBool(keccak256(abi.encode(\"rewards.snapshot.submitted.node\", msg.sender, _submission.rewardIndex)), true);\n        }\n        { // Scope to prevent stack too deep\n            // Increment submission count\n            bytes32 submissionCountKey = keccak256(abi.encode(\"rewards.snapshot.submitted.count\", _submission));\n            submissionCount = getUint(submissionCountKey) + 1;\n            setUint(submissionCountKey, submissionCount);\n        }\n        // Emit snapshot submitted event\n        emit RewardSnapshotSubmitted(msg.sender, _submission.rewardIndex, _submission, block.timestamp);\n        // Return if already executed\n        if (_submission.rewardIndex != rewardIndex) {\n            return;\n        }\n        // If consensus is reached, execute the snapshot\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        if (calcBase * submissionCount / rocketDAONodeTrusted.getMemberCount() >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n            _executeRewardSnapshot(_submission);\n        }\n    }\n\n    /// @notice Executes reward snapshot if consensus threshold is reached\n    function executeRewardSnapshot(RewardSubmission calldata _submission) override external onlyLatestContract(\"rocketRewardsPool\", address(this)) {\n        // Validate reward index of submission\n        require(_submission.rewardIndex == getRewardIndex(), \"Can only execute snapshot for next period\");\n        // Get submission count\n        bytes32 submissionCountKey = keccak256(abi.encode(\"rewards.snapshot.submitted.count\", _submission));\n        uint256 submissionCount = getUint(submissionCountKey);\n        // Confirm consensus and execute\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        require(calcBase * submissionCount / rocketDAONodeTrusted.getMemberCount() >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold(), \"Consensus has not been reached\");\n        _executeRewardSnapshot(_submission);\n    }\n\n    /// @notice Executes reward snapshot and sends assets to the relays for distribution to reward recipients\n    function _executeRewardSnapshot(RewardSubmission calldata _submission) private {\n        // Get contract\n        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress(\"rocketTokenRPL\"));\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Execute inflation if required\n        rplContract.inflationMintTokens();\n        // Increment the reward index and update the claim interval timestamp\n        incrementRewardIndex();\n        uint256 claimIntervalTimeStart = getClaimIntervalTimeStart();\n        uint256 claimIntervalTimeEnd = claimIntervalTimeStart + (getClaimIntervalTime() * _submission.intervalsPassed);\n        // Emit reward snapshot event\n        emit RewardSnapshot(_submission.rewardIndex, _submission, claimIntervalTimeStart, claimIntervalTimeEnd, block.timestamp);\n        setUint(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.block\", _submission.rewardIndex)), block.number);\n        setAddress(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.address\", _submission.rewardIndex)), address(this));\n        setUint(keccak256(\"rewards.pool.claim.interval.time.start\"), claimIntervalTimeEnd);\n        // Send out the treasury rewards\n        if (_submission.treasuryRPL > 0) {\n            rocketVault.transferToken(\"rocketClaimDAO\", rplContract, _submission.treasuryRPL);\n        }\n        // Get the smoothing pool instance\n        RocketSmoothingPoolInterface rocketSmoothingPool = RocketSmoothingPoolInterface(getContractAddress(\"rocketSmoothingPool\"));\n        // Send deposit pool user's ETH\n        if (_submission.smoothingPoolETH > 0) {\n            rocketSmoothingPool.withdrawEther(address(this), _submission.smoothingPoolETH);\n        }\n        // Calculate total amount of ETH required for this reward interval\n        uint256 totalETH = _submission.userETH + _submission.treasuryETH;\n        for (uint i = 0; i < _submission.nodeETH.length; ++i) {\n            totalETH += _submission.nodeETH[i];\n        }\n        // Withdraw required amount from the vault\n        uint256 vaultBalance = totalETH - _submission.smoothingPoolETH;\n        if (vaultBalance > 0) {\n            rocketVault.withdrawEther(vaultBalance);\n        }\n        // Send user share to rETH contract\n        if (_submission.userETH > 0) {\n            address rocketTokenRETHAddress = getContractAddress(\"rocketTokenRETH\");\n            (bool result,) = rocketTokenRETHAddress.call{value: _submission.userETH}(\"\");\n            require(result, \"Failed to send voter rewards\");\n        }\n        // Send pDAO share to treasury\n        if (_submission.treasuryETH > 0) {\n            address payable rocketClaimDAO = payable(getContractAddress(\"rocketClaimDAO\"));\n            (bool result,) = rocketClaimDAO.call{value: _submission.treasuryETH}(\"\");\n            require(result, \"Failed to send pDAO rewards\");\n        }\n        // Loop over each network and distribute rewards\n        for (uint i = 0; i < _submission.nodeRPL.length; ++i) {\n            // Quick out if no rewards for this network\n            uint256 rewardsRPL = _submission.nodeRPL[i] + _submission.trustedNodeRPL[i];\n            uint256 rewardsETH = _submission.nodeETH[i];\n            if (rewardsRPL == 0 && rewardsETH == 0) {\n                continue;\n            }\n            // Grab the relay address\n            RocketRewardsRelayInterface relay;\n            { // Scope to prevent stack too deep\n                address networkRelayAddress;\n                bytes32 networkRelayKey = keccak256(abi.encodePacked(\"rewards.relay.address\", i));\n                networkRelayAddress = getAddress(networkRelayKey);\n                // Validate network is valid\n                require(networkRelayAddress != address(0), \"Snapshot contains rewards for invalid network\");\n                relay = RocketRewardsRelayInterface(networkRelayAddress);\n            }\n            // Transfer rewards\n            if (rewardsRPL > 0) {\n                // RPL rewards are withdrawn from the vault\n                rocketVault.withdrawToken(address(relay), rplContract, rewardsRPL);\n            }\n            if (rewardsETH > 0) {\n                // ETH rewards are withdrawn from the smoothing pool\n                rocketSmoothingPool.withdrawEther(address(relay), rewardsETH);\n            }\n            // Call into relay contract to handle distribution of rewards\n            relay.relayRewards(_submission.rewardIndex, _submission.merkleRoot, rewardsRPL, rewardsETH);\n        }\n    }\n}\n"
    }
}