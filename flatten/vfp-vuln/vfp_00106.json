{
    "vfp_id": "vfp_00106",
    "project_name": "ChainSecurity_StudioV_Neulock_Audit.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Refund Mechanism Can Be Abused to DOS a Series",
            "description": "The refund mechanism allows users to refund their NEU NFT within 7 days of minting. An attacker can exploit this by purchasing all available tokens in a series and immediately refunding them, effectively preventing others from minting and forcing the project to create a new series. This costs the attacker only gas, making it a low-cost denial-of-service attack.\n\nThe cause is the combination of a finite token supply per series and a refund feature that does not penalize or limit bulk refunds.\n\nAn attacker can automate the purchase and refund of all tokens in a high-demand series, blocking legitimate users and disrupting the release schedule.\n\nThe impact is a denial of service for specific token series, reputational damage, and operational overhead from having to deploy new series.\n",
            "severity": "Medium",
            "location": [
                "NeuMetadataV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        }
    ],
    "affected_files": {
        "MetadataV2.sol": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {Series, TokenMetadata, INeuMetadataV2} from \"../interfaces/INeuMetadataV2.sol\";\nimport {NeuLogoV2} from \"../current/LogoV2.sol\";\nimport {Bytes8Utils} from \"../lib/Utils.sol\";\n\nusing Bytes8Utils for bytes8;\nusing Strings for uint256;\nusing SafeCast for uint256;\n\ncontract NeuMetadataV2 is\n    Initializable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable,\n    INeuMetadataV2\n{\n    uint256 private constant VERSION = 2;\n\n    bytes32 public constant NEU_ROLE = keccak256(\"NEU_ROLE\");\n    bytes32 public constant STORAGE_ROLE = keccak256(\"STORAGE_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    uint256 private constant REFUND_WINDOW = 7 days;\n\n    string _traitMetadataURI;\n    mapping(uint256 => TokenMetadata) private _tokenMetadata;\n    Series[] private _series;\n    uint16[] private _availableSeries;\n    NeuLogoV2 private _logo;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address defaultAdmin,\n        address upgrader,\n        address operator,\n        address neuContract,\n        address logoContract\n    ) public initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(UPGRADER_ROLE, upgrader);\n        _grantRole(OPERATOR_ROLE, operator);\n        _grantRole(NEU_ROLE, neuContract);\n\n        _logo = NeuLogoV2(logoContract);\n\n        emit InitializedMetadata(VERSION, defaultAdmin, upgrader, operator, neuContract, logoContract);\n    }\n\n    function createTokenMetadata(uint16 seriesIndex, uint256 originalPrice) external onlyRole(NEU_ROLE) returns (\n        uint256 tokenId,\n        bool governance\n    ) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n        require(_series[seriesIndex].mintedTokens < _series[seriesIndex].maxTokens, \"Series has been fully minted\");\n\n        tokenId = _series[seriesIndex].firstToken + _series[seriesIndex].mintedTokens;\n\n        _setTokenMetadata(tokenId, TokenMetadata({\n            originalPriceInGwei: uint64(originalPrice / 1e9),\n            sponsorPoints: 0,\n            mintedAt: uint40(block.timestamp)\n        }));\n\n        _series[seriesIndex].mintedTokens++;\n\n        if (_series[seriesIndex].mintedTokens == _series[seriesIndex].maxTokens) {\n            _removeAvailableSeries(seriesIndex);\n        }\n\n        governance = _givesGovernanceAccess(seriesIndex);\n    }\n\n    function deleteTokenMetadata(uint256 tokenId) external onlyRole(NEU_ROLE) {\n        require(_metadataExists(tokenId), \"Token metadata does not exist\");\n\n        uint16 seriesIndex = _seriesOfToken(tokenId);\n\n        _series[seriesIndex].burntTokens++;\n        delete _tokenMetadata[tokenId];\n\n        emit TokenMetadataDeleted(tokenId);\n    }\n\n    function setTraitMetadataURI(string calldata uri) external onlyRole(NEU_ROLE) {\n        _setTraitMetadataURI(uri);\n    }\n\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        return string.concat(\n            \"data:application/json;base64,\",\n            Base64.encode(_makeJsonMetadata(tokenId))\n        );\n    }\n\n    function isUserMinted(uint256 tokenId) external view returns (bool) {\n        // slither-disable-next-line timestamp (block miner cannot set timestamp in the past of previous block, so mintedAt == 0 can only mean the token does not exist)\n        return _metadataExists(tokenId) && _tokenMetadata[tokenId].originalPriceInGwei > 0;\n    }\n\n    function getTraitValue(uint256 tokenId, bytes32 traitKey) external view returns (bytes32) {\n        return _getTraitValue(tokenId, traitKey);\n    }\n\n    function getTraitValues(uint256 tokenId, bytes32[] calldata traitKeys) external view returns (bytes32[] memory traitValues) {\n        uint256 length = traitKeys.length;\n        traitValues = new bytes32[](length);\n\n        for (uint256 i = 0; i < length; ) {\n            bytes32 traitKey = traitKeys[i];\n            traitValues[i] = _getTraitValue(tokenId, traitKey);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getTraitMetadataURI() external view returns (string memory) {\n        // Return the trait metadata URI.\n        return _traitMetadataURI;\n    }\n\n    function addSeries(bytes8 name, uint64 priceInGwei, uint32 firstToken, uint32 maxTokens, uint16 fgColorRGB565, uint16 bgColorRGB565, uint16 accentColorRGB565, bool makeAvailable) external onlyRole(OPERATOR_ROLE) returns (uint16) {\n        uint16 seriesIndex = uint16(_series.length);\n        uint256 maxToken = firstToken + maxTokens - 1;\n        uint256 seriesLength = _series.length;\n\n        for (uint16 i = 0; i < seriesLength; i++) {\n            require(_series[i].name != name, \"Series name already exists\");\n            require(maxToken < _series[i].firstToken || firstToken >= _series[i].firstToken + _series[i].maxTokens, \"Series overlaps with existing\");\n        }\n\n        _series.push(Series({\n            name: name,\n            priceInGwei: priceInGwei,\n            firstToken: firstToken,\n            maxTokens: maxTokens,\n            mintedTokens: 0,\n            burntTokens: 0,\n            fgColorRGB565: fgColorRGB565,\n            bgColorRGB565: bgColorRGB565,\n            accentColorRGB565: accentColorRGB565\n        }));\n\n        if (makeAvailable) {\n            _availableSeries.push(seriesIndex);\n        }\n\n        emit SeriesAdded(seriesIndex, name, priceInGwei, firstToken, maxTokens, fgColorRGB565, bgColorRGB565, accentColorRGB565, makeAvailable);\n        return seriesIndex;\n    }\n\n    function getSeries(uint16 seriesIndex) external view returns (\n        bytes8 name,\n        uint256 priceInGwei,\n        uint256 firstToken,\n        uint256 maxTokens,\n        uint256 mintedTokens,\n        uint256 burntTokens,\n        bool isAvailable,\n        string memory logoSvg\n    ) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n\n        Series memory series = _series[seriesIndex];\n\n        name = series.name;\n        priceInGwei = series.priceInGwei;\n        firstToken = series.firstToken;\n        maxTokens = series.maxTokens;\n        mintedTokens = series.mintedTokens;\n        burntTokens = series.burntTokens;\n        isAvailable = _isSeriesAvailable(seriesIndex);\n        logoSvg = _logo.makeLogo(\n            _makeMaskedTokenId(series), series.name.toString(), series.fgColorRGB565, series.bgColorRGB565, series.accentColorRGB565);\n    }\n\n    function isSeriesAvailable(uint16 seriesIndex) external view returns (bool) {\n        return _isSeriesAvailable(seriesIndex);\n    }\n\n    function setSeriesAvailability(uint16 seriesIndex, bool available) external onlyRole(OPERATOR_ROLE) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n\n        if (available) {\n            Series memory series = _series[seriesIndex];\n\n            if (series.mintedTokens == series.maxTokens) {\n                revert(\"Series has been fully minted\");\n            }\n        }\n\n        bool isAlreadyAvailable = _isSeriesAvailable(seriesIndex);\n\n        if (available && !isAlreadyAvailable) {\n            _availableSeries.push(seriesIndex);\n\n            emit SeriesAvailabilityUpdated(seriesIndex, available);\n        } else if (!available && isAlreadyAvailable) {\n            _removeAvailableSeries(seriesIndex);\n\n            emit SeriesAvailabilityUpdated(seriesIndex, available);\n        }\n    }\n\n    function getAvailableSeries() external view returns(uint16[] memory) {\n        return _availableSeries;\n    }\n\n    function setPriceInGwei(uint16 seriesIndex, uint64 price) external onlyRole(OPERATOR_ROLE) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n        _series[seriesIndex].priceInGwei = price;\n\n        emit SeriesPriceUpdated(seriesIndex, price);\n    }\n\n    function getSeriesMintingPrice(uint16 seriesIndex) external view returns (uint256) {\n        require(_isSeriesAvailable(seriesIndex), \"Public minting not available\");\n\n        return uint256(_series[seriesIndex].priceInGwei) * 1e9;\n    }\n\n    function sumAllRefundableTokensValue() external view returns (uint256) {\n        uint256 totalValue = 0;\n        uint256 seriesLength = _series.length;\n\n        for (uint16 s = 0; s < seriesLength; s++) {\n            for (uint256 i = _series[s].firstToken + _series[s].mintedTokens - 1; i >= _series[s].firstToken; i--) {\n                TokenMetadata memory metadata = _tokenMetadata[i];\n\n                if (!_metadataExists(i)) {\n                    // Token has been burned\n                    continue;\n                }\n\n                // slither-disable-next-line timestamp (with a granularity of days for refunds, we can tolerate miner manipulation)\n                if (block.timestamp - metadata.mintedAt > REFUND_WINDOW) {\n                    // All tokens before this one in the series are also expired\n                    break;\n                }\n\n                totalValue += metadata.originalPriceInGwei;\n            }\n        }\n\n        return totalValue * 1e9;\n    }\n\n    function getRefundAmount(uint256 tokenId) external view returns (uint256) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n\n        require(metadata.originalPriceInGwei > 0, \"Token is not refundable\");\n        // slither-disable-next-line timestamp (with a granularity of days for refunds, we can tolerate miner manipulation)\n        require(block.timestamp - metadata.mintedAt < REFUND_WINDOW, \"Refund window has passed\");\n\n        return metadata.originalPriceInGwei * 1e9;\n    }\n\n    function setLogoContract(address logoContract) external onlyRole(OPERATOR_ROLE) {\n        _logo = NeuLogoV2(logoContract);\n        \n        emit LogoUpdated(logoContract);\n    }\n\n    function _setTokenMetadata(\n        uint256 tokenId,\n        TokenMetadata memory metadata\n    ) internal {\n        // This function is to be called only on token mint. Won't emit TraitUpdated event.\n        _tokenMetadata[tokenId] = metadata;\n\n        emit TokenMetadataUpdated(tokenId, metadata);\n    }\n\n    function increaseSponsorPoints(uint256 tokenId, uint256 sponsorPointsIncrease) external onlyRole(NEU_ROLE) returns (uint256) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n\n        uint256 newSponsorPoints = metadata.sponsorPoints + sponsorPointsIncrease;\n\n        _tokenMetadata[tokenId] = TokenMetadata({\n            originalPriceInGwei: metadata.originalPriceInGwei,\n            sponsorPoints: newSponsorPoints.toUint64(),\n            mintedAt: metadata.mintedAt\n        });\n\n        emit TraitUpdated(bytes32(\"points\"), tokenId, bytes32(newSponsorPoints));\n        return newSponsorPoints;\n    }\n    function isGovernanceToken(uint256 tokenId) external view returns (bool) {\n        // This doesn't check if token has been minted, just if its ID belongs to the range of a governance series\n        uint16 seriesIndex = _seriesOfToken(tokenId);\n        return _givesGovernanceAccess(seriesIndex);\n    }\n\n    function _isSeriesAvailable(uint16 seriesIndex) private view returns (bool) {\n        uint256 availableSeriesLength = _availableSeries.length;\n\n        for (uint256 i = 0; i < availableSeriesLength; i++) {\n            if (_availableSeries[i] == seriesIndex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _removeAvailableSeries(uint16 seriesIndex) private {\n        for (uint256 i = 0; i < _availableSeries.length; i++) {\n            if (_availableSeries[i] == seriesIndex) {\n                _availableSeries[i] = _availableSeries[_availableSeries.length - 1];\n                _availableSeries.pop();\n                return;\n            }\n        }\n    }\n\n    function _getTraitValue(uint256 tokenId, bytes32 traitKey) private view returns (bytes32) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n\n        if (traitKey == \"points\") {\n            return bytes32(uint256(metadata.sponsorPoints));\n        } else {\n            revert(\"Trait key not found\");\n        }\n    }\n\n    function _makeJsonMetadata(uint256 tokenId) internal view returns (bytes memory) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n        uint16 seriesIndex = _seriesOfToken(tokenId);\n        Series memory series = _series[seriesIndex];\n        string memory governance = _givesGovernanceAccess(seriesIndex) ? \"Yes\" : \"No\";\n        string memory seriesName = series.name.toString();\n        string memory tokenName = string.concat(tokenId.toString(), ' ', seriesName);\n        string memory logoSvg = Base64.encode(bytes(_logo.makeLogo(\n            tokenId.toString(), seriesName, series.fgColorRGB565, series.bgColorRGB565, series.accentColorRGB565)));\n\n        return bytes(string.concat(\n            '{\"description\": \"Neulock Password Manager membership NFT - neulock.app\", \"name\": \"NEU #',\n            tokenName,\n            '\", \"image\": \"data:image/svg+xml;base64,',\n            logoSvg,\n            '\", \"attributes\": [{\"trait_type\": \"Series\", \"value\": \"',\n            seriesName,\n            '\"},{\"trait_type\": \"Governance Access\", \"value\": \"',\n            governance,\n            '\"},{\"trait_type\": \"Series Max Supply\", \"value\": ',\n            uint256(series.maxTokens).toString(),\n            '},{\"trait_type\": \"Mint Date\", \"display_type\": \"date\", \"value\": ',\n            uint256(metadata.mintedAt).toString(),\n            '}]}'\n        ));\n    }\n\n    function _seriesOfToken(uint256 tokenId) private view returns (uint16) {\n        uint256 seriesLength = _series.length;\n\n        for (uint16 i = 0; i < seriesLength; i++) {\n            if (tokenId >= _series[i].firstToken && tokenId < _series[i].firstToken + _series[i].maxTokens) {\n                return i;\n            }\n        }\n\n        revert(\"Token does not belong to any series\");\n    }\n\n    function _makeMaskedTokenId(Series memory series) private pure returns (string memory) {\n        uint256 lastToken = series.firstToken + series.maxTokens - 1;\n        bytes memory lastTokenBytes = bytes(lastToken.toString());\n        bytes memory firstTokenBytes = bytes(uint256(series.firstToken).toString());\n\n        bool stoppedMatching = firstTokenBytes.length != lastTokenBytes.length;\n        bytes memory result = new bytes(lastTokenBytes.length);\n\n        for (uint256 i = 0; i < result.length; i++) {\n            if (!stoppedMatching && firstTokenBytes.length > i && lastTokenBytes[i] == firstTokenBytes[i]) {\n                result[i] = lastTokenBytes[i];\n            } else {\n                stoppedMatching = true;\n                result[i] = \"x\";\n            }\n        }\n\n        return string(result);\n    }\n\n    function _metadataExists(uint256 tokenId) private view returns (bool) {\n        // slither-disable-next-line timestamp (block miner cannot set timestamp in the past of previous block, so mintedAt == 0 can only mean the token does not exist)\n        return _tokenMetadata[tokenId].mintedAt != 0;\n    }\n\n    function _givesGovernanceAccess(uint16 seriesIndex) private view returns (bool) {\n        // Tokens whose name do not start with \"WAGMI\" give governance access\n        bytes32 wagmiNamePrefix = \"WAGMI\";\n\n        for (uint256 i = 0; i < 5; i++) {\n            if (_series[seriesIndex].name[i] != wagmiNamePrefix[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _setTraitMetadataURI(string memory uri) internal {\n        // Set the new trait metadata URI.\n        _traitMetadataURI = uri;\n\n        emit MetadataURIUpdated(uri);\n    }\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyRole(UPGRADER_ROLE)\n        override\n    {}\n}\n"
    }
}