{
    "vfp_id": "vfp_00106",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The NetworkMiddleware.registerVault function does not check if a vault has already been registered for a given agent, allowing duplicate entries. This leads to the same vault's delegation being counted multiple times when calculating coverage. The root cause is the lack of deduplication or uniqueness checks during vault registration. An attacker or user could exploit this by re-registering the same vault multiple times, especially after a transaction failure and replacement. The impact is an inflated delegation value, which can cause incorrect risk assessment and lead to under-collateralized liquidations, resulting in potential loss of funds for the senior tranche.\n",
            "severity": "Medium",
            "location": [
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::registerVault#58-69",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::coverage#195-206",
                "Delegation.sol::addVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "StakedCap yield distribution DoS through timer manipulation",
            "description": "The StakedCap contract's notify function is permissionless and resets the lastNotify timestamp upon any token deposit, which affects the lockedProfit calculation. An attacker can repeatedly call notify with minimal token transfers to reset the timer, keeping the elapsed time small and preventing yield from unlocking. The root cause is the lack of rate-limiting or time-based protection on the notify function. This allows an attacker to indefinitely delay the vesting of rewards. The impact is a denial of service for legitimate stakers who cannot withdraw their earned yield, effectively locking their rewards permanently.\n",
            "severity": "Medium",
            "location": [
                "contracts/token/StakedCap.sol::notify#58-69",
                "contracts/token/StakedCap.sol::lockedProfit#73-85",
                "contracts/token/StakedCap.sol::totalAssets#L73-85",
                "StakedCap.sol"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "The protocol exhibits a critical discrepancy between how an agent's health factor is calculated and how slashable collateral is determined. This inconsistency arises because the health factor evaluation uses all current collateral, including recent deposits, while the slashing mechanism only considers deposits made before the most recent epoch or the agent's last borrow time. The root cause is the misalignment in time bases used by the coverage and slashTimestamp functions. An attacker can exploit this by adding fresh collateral just before a liquidation event to improve their health factor, knowing that these new deposits will not be subject to slashing. As a result, during liquidation, the protocol cannot recover sufficient collateral from these recent deposits, leading to a shortfall that the protocol must absorb. This undermines the financial stability and security model of the system, potentially resulting in significant protocol losses, especially if all existing delegations are from the current epoch.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/Delegation.sol#L73-L76",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L195-L206",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Reward distribution enables front-running attacks and reward siphoning",
            "description": "The reward distribution mechanism allocates rewards to all vaults backing an agent at the time of loan repayment without considering the duration of their delegation. This creates a timing vulnerability where opportunistic actors can monitor pending repayment transactions in the mempool and front-run them by adding their own collateral just before repayment. The root cause is the lack of time-based eligibility criteria for reward distribution. By doing so, these actors can capture a disproportionate share of the accrued interest rewards despite having provided capital for only a minimal period. This allows them to systematically siphon rewards from long-term backers who actually bore the lending risk over time. The impact is an unfair redistribution of rewards that disincentivizes long-term participation and undermines the economic fairness of the protocol.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/NetworkMiddleware.sol",
                "contracts/delegation/Delegation.sol",
                "StakedCap.sol::distributeRewards"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Liquidation mechanism can be permanently disabled by misconfigured grace and expiry periods",
            "description": "The Lender contract does not validate that the grace period is less than the expiry period during initialization. If grace >= expiry, the liquidation mechanism becomes impossible to trigger because the validateLiquidation function requires block.timestamp to be both greater than start+grace and less than start+expiry, which cannot be satisfied simultaneously. The root cause is the lack of input validation for critical configuration parameters. Since these parameters cannot be reset after deployment, a misconfiguration would permanently disable liquidations. An attacker or negligent admin could deploy the contract with such invalid parameters, preventing any liquidation from occurring even when agents are severely undercollateralized. This leads to the accumulation of bad debt and potentially results in protocol insolvency as unhealthy positions remain outstanding indefinitely.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol#L98-L102",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Protocol lacks bad debt management mechanisms, risking permanent insolvency",
            "description": "The protocol has no mechanism to handle accumulated bad debt from failed or uneconomical liquidations. The root cause is the absence of insurance or loss-socialization mechanisms. When bad debt accumulates—especially in conjunction with small, unviable borrowing positions—the loss is not distributed fairly. Instead, it creates a \"last withdrawer\" problem where early withdrawers redeem their full amounts while later users face shortfalls as the protocol runs out of physical tokens. This leads to permanent insolvency and unfair loss distribution. The impact is a systemic risk to user funds, where the timing of withdrawal determines whether a user loses money, undermining trust in the protocol's solvency guarantees.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/Lender.sol",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        }
    ],
    "affected_files": {
        "NetworkMiddleware.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../../../access/Access.sol\";\nimport { IOracle } from \"../../../interfaces/IOracle.sol\";\nimport { IStakerRewards } from \"../../../interfaces/IStakerRewards.sol\";\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IBurnerRouter } from \"@symbioticfi/burners/src/interfaces/router/IBurnerRouter.sol\";\n\nimport { IMiddleware } from \"../../../interfaces/IMiddleware.sol\";\n\nimport { INetworkMiddleware } from \"../../../interfaces/INetworkMiddleware.sol\";\nimport { NetworkMiddlewareStorageUtils } from \"../../../storage/NetworkMiddlewareStorageUtils.sol\";\nimport { Subnetwork } from \"@symbioticfi/core/src/contracts/libraries/Subnetwork.sol\";\nimport { IEntity } from \"@symbioticfi/core/src/interfaces/common/IEntity.sol\";\nimport { IRegistry } from \"@symbioticfi/core/src/interfaces/common/IRegistry.sol\";\nimport { IBaseDelegator } from \"@symbioticfi/core/src/interfaces/delegator/IBaseDelegator.sol\";\nimport { ISlasher } from \"@symbioticfi/core/src/interfaces/slasher/ISlasher.sol\";\nimport { IVault } from \"@symbioticfi/core/src/interfaces/vault/IVault.sol\";\n\n/// @title Cap Symbiotic Network Middleware Contract\n/// @author Cap Labs\n/// @notice This contract manages the symbiotic collateral and slashing.\ncontract NetworkMiddleware is INetworkMiddleware, UUPSUpgradeable, Access, NetworkMiddlewareStorageUtils {\n    using SafeERC20 for IERC20;\n\n    /// @notice Initialize\n    /// @param _accessControl Access control address\n    /// @param _network Network address\n    /// @param _vaultRegistry Vault registry address\n    /// @param _oracle Oracle address\n    /// @param _requiredEpochDuration Required epoch duration in seconds\n    /// @param _feeAllowed Fee allowed to be charged on rewards by restakers\n    function initialize(\n        address _accessControl,\n        address _network,\n        address _vaultRegistry,\n        address _oracle,\n        uint48 _requiredEpochDuration,\n        uint256 _feeAllowed\n    ) external initializer {\n        __Access_init(_accessControl);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        $.network = _network;\n        $.vaultRegistry = _vaultRegistry;\n        $.oracle = _oracle;\n        $.requiredEpochDuration = _requiredEpochDuration;\n        $.feeAllowed = _feeAllowed;\n    }\n\n    /// @notice Register vault to be used as collateral within the CAP system\n    /// @param _vault Vault address\n    /// @param _agents Agents supported by the vault\n    function registerVault(address _vault, address _stakerRewarder, address[] calldata _agents)\n        external\n        checkAccess(this.registerVault.selector)\n    {\n        _verifyVault(_vault);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        $.stakerRewarders[_vault] = _stakerRewarder;\n        for (uint256 i; i < _agents.length; ++i) {\n            $.vaults[_agents[i]].push(_vault);\n        }\n        emit VaultRegistered(_vault);\n    }\n\n    /// @notice Set fee allowed\n    /// @param _feeAllowed Fee allowed to be charged on rewards by restakers\n    function setFeeAllowed(uint256 _feeAllowed) external checkAccess(this.setFeeAllowed.selector) {\n        getNetworkMiddlewareStorage().feeAllowed = _feeAllowed;\n    }\n\n    /// @notice Slash delegation and send to recipient\n    /// @param _agent Agent address\n    /// @param _recipient Recipient of the slashed assets\n    /// @param _slashShare Percentage of delegation to slash encoded with 18 decimals\n    /// @param _timestamp Timestamp to slash at\n    function slash(address _agent, address _recipient, uint256 _slashShare, uint48 _timestamp)\n        external\n        checkAccess(this.slash.selector)\n    {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n\n        for (uint256 i; i < $.vaults[_agent].length; ++i) {\n            IVault vault = IVault($.vaults[_agent][i]);\n\n            (, uint256 totalSlashableCollateral) =\n                slashableCollateralByVault($.network, _agent, address(vault), $.oracle, _timestamp);\n            if (totalSlashableCollateral == 0) continue;\n\n            // Round up in favor of the liquidator\n            uint256 slashShareOfCollateral = (totalSlashableCollateral * _slashShare / 1e18) + 1;\n\n            // If the slash share is greater than the total slashable collateral, set it to the total slashable collateral\n            if (slashShareOfCollateral > totalSlashableCollateral) {\n                slashShareOfCollateral = totalSlashableCollateral;\n            }\n\n            ISlasher(vault.slasher()).slash(\n                subnetwork(_agent), _agent, slashShareOfCollateral, _timestamp, new bytes(0)\n            );\n\n            // TODO: the burner could be a non routing burner, could add hooks?\n            IBurnerRouter(vault.burner()).triggerTransfer(address(this));\n            IERC20(vault.collateral()).safeTransfer(_recipient, slashShareOfCollateral);\n\n            emit Slash(_agent, _recipient, slashShareOfCollateral);\n        }\n    }\n\n    /// @dev Get vault info\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @return burnerRouter The burner router contract\n    /// @return decimals The collateral token decimals\n    /// @return collateralPrice The collateral token price\n    function _getVaultInfo(address _network, address _agent, address _vault, address _oracle)\n        private\n        view\n        returns (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice)\n    {\n        burnerRouter = IBurnerRouter(IVault(_vault).burner());\n\n        // Check pending receivers\n        (address pendingReceiver,) = burnerRouter.pendingNetworkReceiver(_network);\n        if (pendingReceiver != address(0) && pendingReceiver != address(this)) {\n            return (IBurnerRouter(address(0)), 0, 0);\n        }\n\n        (pendingReceiver,) = burnerRouter.pendingOperatorNetworkReceiver(_network, _agent);\n        if (pendingReceiver != address(0) && pendingReceiver != address(this)) {\n            return (IBurnerRouter(address(0)), 0, 0);\n        }\n\n        address collateralAddress = IVault(_vault).collateral();\n        decimals = IERC20Metadata(collateralAddress).decimals();\n        (collateralPrice,) = IOracle(_oracle).getPrice(collateralAddress);\n    }\n\n    /// @notice Coverage of an agent by a specific vault at a given timestamp\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @param _timestamp Timestamp to check coverage at\n    /// @return collateralValue Coverage value in USD (8 decimals)\n    /// @return collateral Coverage amount in the vault's collateral token decimals\n    function coverageByVault(address _network, address _agent, address _vault, address _oracle, uint48 _timestamp)\n        public\n        view\n        returns (uint256 collateralValue, uint256 collateral)\n    {\n        (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice) =\n            _getVaultInfo(_network, _agent, _vault, _oracle);\n\n        if (address(burnerRouter) == address(0)) return (0, 0);\n\n        collateral = IBaseDelegator(IVault(_vault).delegator()).stakeAt(subnetwork(_agent), _agent, _timestamp, \"\");\n        collateralValue = collateral * collateralPrice / (10 ** decimals);\n    }\n\n    /// @notice Slashable collateral of an agent by a specific vault at a given timestamp\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @param _timestamp Timestamp to check slashable collateral at\n    /// @return collateralValue Slashable collateral value in USD (8 decimals)\n    function slashableCollateralByVault(\n        address _network,\n        address _agent,\n        address _vault,\n        address _oracle,\n        uint48 _timestamp\n    ) public view returns (uint256 collateralValue, uint256 collateral) {\n        (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice) =\n            _getVaultInfo(_network, _agent, _vault, _oracle);\n\n        if (address(burnerRouter) == address(0)) return (0, 0);\n\n        ISlasher slasher = ISlasher(IVault(_vault).slasher());\n        collateral = slasher.slashableStake(subnetwork(_agent), _agent, _timestamp, \"\");\n        collateralValue = collateral * collateralPrice / (10 ** decimals);\n    }\n\n    /// @notice Coverage of an agent by Symbiotic vaults\n    /// @param _agent Agent address\n    /// @return delegation Delegation amount in USD (8 decimals)\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        address[] memory _vaults = $.vaults[_agent];\n        address _network = $.network;\n        address _oracle = $.oracle;\n        uint48 _timestamp = uint48(block.timestamp);\n\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            (uint256 value,) = coverageByVault(_network, _agent, _vaults[i], _oracle, _timestamp);\n            delegation += value;\n        }\n    }\n\n    /// @notice Slashable collateral of an agent by Symbiotic vaults\n    /// @param _agent Agent address\n    /// @param _timestamp Timestamp to check slashable collateral at\n    /// @return _slashableCollateral Slashable collateral amount in USD (8 decimals)\n    function slashableCollateral(address _agent, uint48 _timestamp)\n        external\n        view\n        returns (uint256 _slashableCollateral)\n    {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        address[] memory _vaults = $.vaults[_agent];\n        address _network = $.network;\n        address _oracle = $.oracle;\n\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            (uint256 value,) = slashableCollateralByVault(_network, _agent, _vaults[i], _oracle, _timestamp);\n            _slashableCollateral += value;\n        }\n    }\n\n    /// @notice Subnetwork id\n    /// @dev Creates a collision resistant uint96 identifier by taking keccak256 hash of agent address\n    /// and using the first 96 bits of the hash\n    /// @param _agent Agent address\n    /// @return id Subnetwork identifier (first 96 bits of keccak256 hash of agent address)\n    function subnetworkIdentifier(address _agent) public pure returns (uint96 id) {\n        bytes32 hash = keccak256(abi.encodePacked(_agent));\n        id = uint96(uint256(hash)); // Takes first 96 bits of hash\n    }\n\n    /// @notice Subnetwork id concatenated with network address\n    /// @return id Subnetwork id\n    function subnetwork(address _agent) public view returns (bytes32 id) {\n        id = Subnetwork.subnetwork(getNetworkMiddlewareStorage().network, subnetworkIdentifier(_agent));\n    }\n\n    /// @notice Registered vaults for an agent\n    /// @param _agent Agent address\n    /// @return vaultAddresses Vault addresses\n    function vaults(address _agent) external view returns (address[] memory vaultAddresses) {\n        vaultAddresses = getNetworkMiddlewareStorage().vaults[_agent];\n    }\n\n    /// @dev Verify a vault has the required specifications\n    /// @param _vault Vault address\n    function _verifyVault(address _vault) internal view {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n\n        if (!IRegistry($.vaultRegistry).isEntity(_vault)) {\n            revert NotVault();\n        }\n\n        if (!IVault(_vault).isInitialized()) revert VaultNotInitialized();\n\n        uint48 vaultEpoch = IVault(_vault).epochDuration();\n        if (vaultEpoch < $.requiredEpochDuration) revert InvalidEpochDuration($.requiredEpochDuration, vaultEpoch);\n\n        address slasher = IVault(_vault).slasher();\n        uint64 slasherType = IEntity(slasher).TYPE();\n        if (slasher == address(0)) revert NoSlasher();\n        if (slasherType != uint64(INetworkMiddleware.SlasherType.INSTANT)) revert InvalidSlasher();\n\n        address burner = IVault(_vault).burner();\n        if (burner == address(0)) revert NoBurner();\n        address receiver = IBurnerRouter(burner).networkReceiver($.network);\n        if (receiver != address(this)) revert InvalidBurnerRouter();\n\n        address delegator = IVault(_vault).delegator();\n        uint64 delegatorType = IEntity(delegator).TYPE();\n        if (delegatorType != uint64(INetworkMiddleware.DelegatorType.NETWORK_RESTAKE)) revert InvalidDelegator();\n    }\n\n    /// @notice Distribute rewards accumulated by the agent borrowing\n    /// @param _agent Agent address\n    /// @param _token Token address\n    function distributeRewards(address _agent, address _token) external checkAccess(this.distributeRewards.selector) {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        uint256 totalCollateralValue = coverage(_agent);\n        uint256 _amount = IERC20(_token).balanceOf(address(this));\n\n        // here, distribute proportionally to the collateral value of the vaults\n        address[] memory _vaults = $.vaults[_agent];\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            address vault = _vaults[i];\n            (uint256 collateralValue,) = coverageByVault($.network, _agent, vault, $.oracle, uint48(block.timestamp));\n            uint256 reward = _amount * collateralValue / totalCollateralValue;\n            address stakerRewarder = $.stakerRewarders[vault];\n            if (stakerRewarder == address(0)) revert NoStakerRewarder();\n\n            IERC20(_token).forceApprove(address(IStakerRewards(stakerRewarder)), reward);\n            IStakerRewards(stakerRewarder).distributeRewards(\n                $.network, _token, reward, abi.encode(uint48(block.timestamp - 1), $.feeAllowed, \"\", \"\")\n            );\n        }\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n",
        "StakedCap.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IStakedCap } from \"../interfaces/IStakedCap.sol\";\nimport { StakedCapStorageUtils } from \"../storage/StakedCapStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ERC20PermitUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {\n    ERC20Upgradeable,\n    ERC4626Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Staked Cap Token\n/// @author kexley, @capLabs\n/// @notice Slow releasing yield-bearing token that distributes the yield accrued from agents\n/// borrowing from the underlying assets.\n/// @dev Calling notify permissionlessly will start the linear unlock\ncontract StakedCap is\n    IStakedCap,\n    UUPSUpgradeable,\n    ERC4626Upgradeable,\n    ERC20PermitUpgradeable,\n    Access,\n    StakedCapStorageUtils\n{\n    /// @dev Disable initializers on the implementation\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the staked cap token by matching the name and symbol of the underlying\n    /// @param _accessControl Address of the access control\n    /// @param _asset Address of the cap token\n    /// @param _lockDuration Duration in seconds for profit locking\n    function initialize(address _accessControl, address _asset, uint256 _lockDuration) external initializer {\n        string memory _name = string.concat(\"s\", IERC20Metadata(_asset).name());\n        string memory _symbol = string.concat(\"s\", IERC20Metadata(_asset).symbol());\n\n        __ERC4626_init(IERC20(_asset));\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        getStakedCapStorage().lockDuration = _lockDuration;\n    }\n\n    /// @notice Override the decimals function to match underlying decimals\n    /// @return _decimals Decimals of the staked cap token\n    function decimals() public view override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8 _decimals) {\n        _decimals = ERC4626Upgradeable.decimals();\n    }\n\n    /// @notice Notify the yield to start vesting\n    function notify() external {\n        uint256 total = IERC20(asset()).balanceOf(address(this));\n        StakedCapStorage storage $ = getStakedCapStorage();\n        if (total > $.storedTotal) {\n            uint256 diff = total - $.storedTotal;\n            $.totalLocked = lockedProfit() + diff;\n            $.storedTotal = total;\n            $.lastNotify = block.timestamp;\n\n            emit Notify(msg.sender, diff);\n        }\n    }\n\n    /// @notice Remaining locked profit after a notification\n    /// @return locked Amount remaining to be vested\n    function lockedProfit() public view returns (uint256 locked) {\n        StakedCapStorage storage $ = getStakedCapStorage();\n        if ($.lockDuration == 0) return 0;\n        uint256 elapsed = block.timestamp - $.lastNotify;\n        uint256 remaining = elapsed < $.lockDuration ? $.lockDuration - elapsed : 0;\n        locked = $.totalLocked * remaining / $.lockDuration;\n    }\n\n    /// @notice Total vested cap tokens on this contract\n    /// @return total Total amount of vested cap tokens\n    function totalAssets() public view override returns (uint256 total) {\n        total = getStakedCapStorage().storedTotal - lockedProfit();\n    }\n\n    /// @dev Overridden to update the total assets including unvested tokens\n    /// @param _caller Caller of the deposit\n    /// @param _receiver Receiver of the staked cap tokens\n    /// @param _assets Amount of cap tokens to pull from the caller\n    /// @param _shares Amount of staked cap tokens to send to receiver\n    function _deposit(address _caller, address _receiver, uint256 _assets, uint256 _shares) internal override {\n        super._deposit(_caller, _receiver, _assets, _shares);\n        getStakedCapStorage().storedTotal += _assets;\n    }\n\n    /// @dev Overridden to reduce the total assets including unvested tokens\n    /// @param _caller Caller of the withdrawal\n    /// @param _receiver Receiver of the cap tokens\n    /// @param _owner Owner of the staked cap tokens being burnt\n    /// @param _assets Amount of cap tokens to send to the receiver\n    /// @param _shares Amount of staked cap tokens to burn from the owner\n    function _withdraw(address _caller, address _receiver, address _owner, uint256 _assets, uint256 _shares)\n        internal\n        override\n    {\n        super._withdraw(_caller, _receiver, _owner, _assets, _shares);\n        getStakedCapStorage().storedTotal -= _assets;\n    }\n\n    /// @dev Only admin can upgrade implementation\n    function _authorizeUpgrade(address) internal view override checkAccess(bytes4(0)) { }\n}\n",
        "Delegation.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IDelegation } from \"../interfaces/IDelegation.sol\";\nimport { INetworkMiddleware } from \"../interfaces/INetworkMiddleware.sol\";\n\nimport { IRestakerRewardReceiver } from \"../interfaces/IRestakerRewardReceiver.sol\";\n\nimport { DelegationStorageUtils } from \"../storage/DelegationStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Cap Delegation Contract\n/// @author Cap Labs\n/// @notice This contract manages delegation and slashing.\ncontract Delegation is IDelegation, UUPSUpgradeable, Access, DelegationStorageUtils {\n    using SafeERC20 for IERC20;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract\n    /// @param _accessControl Access control address\n    /// @param _oracle Oracle address\n    /// @param _epochDuration Epoch duration in seconds\n    function initialize(address _accessControl, address _oracle, uint256 _epochDuration) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        DelegationStorage storage $ = getDelegationStorage();\n        $.oracle = _oracle;\n        $.epochDuration = _epochDuration;\n    }\n\n    /// @notice How much global delegation we have in the system\n    /// @return delegation Delegation in USD\n    function globalDelegation() external view returns (uint256 delegation) {\n        DelegationStorage storage $ = getDelegationStorage();\n        for (uint i; i < $.agents.length; ++i) {\n            delegation += coverage($.agents[i]);\n        }\n    }\n\n    /// @notice Get the epoch duration\n    /// @return duration Epoch duration in seconds\n    function epochDuration() external view returns (uint256 duration) {\n        DelegationStorage storage $ = getDelegationStorage();\n        duration = $.epochDuration;\n    }\n\n    /// @notice Get the current epoch\n    /// @return currentEpoch Current epoch\n    function epoch() public view returns (uint256 currentEpoch) {\n        DelegationStorage storage $ = getDelegationStorage();\n        currentEpoch = block.timestamp / $.epochDuration;\n    }\n\n    /// @notice Get the timestamp that is most recent between the last borrow and the epoch -1\n    /// @param _agent The agent address\n    /// @return _slashTimestamp Timestamp that is most recent between the last borrow and the epoch -1\n    function slashTimestamp(address _agent) public view returns (uint48 _slashTimestamp) {\n        DelegationStorage storage $ = getDelegationStorage();\n        _slashTimestamp = uint48(Math.max((epoch() - 1) * $.epochDuration, $.agentData[_agent].lastBorrow));\n    }\n\n    /// @notice How much delegation and agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return delegation Amount in USD (8 decimals) that a agent has provided as delegation from the delegators\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        DelegationStorage storage $ = getDelegationStorage();\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            delegation += coverageByNetwork(_agent, $.networks[_agent][i]);\n        }\n    }\n\n    /// @notice How much slashable coverage an agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return _slashableCollateral Amount in USD (8 decimals) that a agent has provided as slashable collateral from the delegators\n    function slashableCollateral(address _agent) public view returns (uint256 _slashableCollateral) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            _slashableCollateral +=\n                INetworkMiddleware($.networks[_agent][i]).slashableCollateral(_agent, _slashTimestamp);\n        }\n    }\n\n    /// @notice How much delegation and agent has available to back their borrows\n    /// @param _agent The agent addres\n    /// @param _network The network covering the agent\n    /// @return delegation Amount in USD that a agent has as delegation from the networks, encoded with 8 decimals\n    function coverageByNetwork(address _agent, address _network) public view returns (uint256 delegation) {\n        delegation = INetworkMiddleware(_network).coverage(_agent);\n    }\n\n    /// @notice Slashable collateral of an agent by a specific network\n    /// @param _agent Agent address\n    /// @param _network Network address\n    /// @return _slashableCollateral Slashable collateral amount in USD (8 decimals)\n    function slashableCollateralByNetwork(address _agent, address _network)\n        public\n        view\n        returns (uint256 _slashableCollateral)\n    {\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n        _slashableCollateral = INetworkMiddleware(_network).slashableCollateral(_agent, _slashTimestamp);\n    }\n\n    /// @notice Fetch active network addresses\n    /// @param _agent Agent address\n    /// @return networkAddresses network addresses\n    function networks(address _agent) external view returns (address[] memory networkAddresses) {\n        networkAddresses = getDelegationStorage().networks[_agent];\n    }\n\n    /// @notice Fetch active agent addresses\n    /// @return agentAddresses Agent addresses\n    function agents() external view returns (address[] memory agentAddresses) {\n        agentAddresses = getDelegationStorage().agents;\n    }\n\n    /// @notice The LTV of a specific agent\n    /// @param _agent Agent who we are querying\n    /// @return currentLtv Loan to value ratio of the agent\n    function ltv(address _agent) external view returns (uint256 currentLtv) {\n        currentLtv = getDelegationStorage().agentData[_agent].ltv;\n    }\n\n    /// @notice Liquidation threshold of the agent\n    /// @param _agent Agent who we are querying\n    /// @return lt Liquidation threshold of the agent\n    function liquidationThreshold(address _agent) external view returns (uint256 lt) {\n        lt = getDelegationStorage().agentData[_agent].liquidationThreshold;\n    }\n\n    /// @notice The slash function. Calls the underlying networks to slash the delegated capital\n    /// @dev Called only by the lender during liquidation\n    /// @param _agent The agent who is unhealthy\n    /// @param _liquidator The liquidator who receives the funds\n    /// @param _amount The USD value of the delegation needed to cover the debt\n    function slash(address _agent, address _liquidator, uint256 _amount) external checkAccess(this.slash.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n\n        // Calculate each network's proportion of total delegation\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            address network = $.networks[_agent][i];\n            uint256 networkSlashableCollateral =\n                INetworkMiddleware(network).slashableCollateral(_agent, _slashTimestamp);\n            if (networkSlashableCollateral == 0) continue;\n\n            // Calculate this network's share of the total amount to slash\n            uint256 networkSlash = _amount * 1e18 / networkSlashableCollateral;\n            INetworkMiddleware(network).slash(_agent, _liquidator, networkSlash, _slashTimestamp);\n            emit SlashNetwork(network, networkSlash);\n        }\n    }\n\n    /// @notice Distribute rewards to networks covering an agent proportionally to their coverage\n    /// @param _agent The agent address\n    /// @param _asset The reward token address\n    function distributeRewards(address _agent, address _asset) external {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint256 _amount = IERC20(_asset).balanceOf(address(this));\n\n        uint256 totalCoverage = coverage(_agent);\n        // here we cannot revert because the agent might not have any coverage\n        // in case we are liquidating the current agent due to 0 coverage\n        if (totalCoverage == 0) return;\n\n        // Distribute to each network based on their coverage proportion\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            address network = $.networks[_agent][i];\n            uint256 networkCoverage = coverageByNetwork(_agent, network);\n            if (networkCoverage == 0) continue;\n\n            uint256 networkReward = _amount * networkCoverage / totalCoverage;\n            IERC20(_asset).safeTransfer(network, networkReward);\n            INetworkMiddleware(network).distributeRewards(_agent, _asset);\n            emit NetworkReward(network, _asset, networkReward);\n        }\n\n        emit DistributeReward(_agent, _asset, _amount);\n    }\n\n    /// @notice Set the last borrow timestamp for an agent\n    /// @param _agent Agent address\n    function setLastBorrow(address _agent) external checkAccess(this.setLastBorrow.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        $.agentData[_agent].lastBorrow = block.timestamp;\n    }\n\n    /// @notice Add agent to be delegated to\n    /// @param _agent Agent address\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function addAgent(address _agent, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.addAgent.selector)\n    {\n        // if liquidation threshold or ltv is greater than 100%, agent\n        // could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv > 1e27) revert InvalidLtv();\n\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // If the agent already exists, we revert\n        if ($.agentData[_agent].exists) revert DuplicateAgent();\n\n        $.agents.push(_agent);\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        $.agentData[_agent].exists = true;\n        emit AddAgent(_agent, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Modify an agents config only callable by the operator\n    /// @param _agent the agent to modify\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function modifyAgent(address _agent, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.modifyAgent.selector)\n    {\n        // if liquidation threshold or ltv is greater than 100%, agent\n        // could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv > 1e27) revert InvalidLtv();\n\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // Check that the agent exists\n        if (!$.agentData[_agent].exists) revert AgentDoesNotExist();\n\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        emit ModifyAgent(_agent, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Register a new network\n    /// @param _agent Agent address\n    /// @param _network Network address\n    function registerNetwork(address _agent, address _network) external checkAccess(this.registerNetwork.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // Check for duplicates\n        if ($.networkExistsForAgent[_agent][_network]) revert DuplicateNetwork();\n\n        $.networks[_agent].push(_network);\n        $.networkExistsForAgent[_agent][_network] = true;\n        emit RegisterNetwork(_agent, _network);\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n",
        "ValidationLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IDelegation } from \"../../interfaces/IDelegation.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ILender } from \"../../interfaces/ILender.sol\";\nimport { ViewLogic } from \"./ViewLogic.sol\";\n\n/// @title Validation Logic\n/// @author kexley, @capLabs\n/// @notice Validate actions before state is altered\nlibrary ValidationLogic {\n    /// @dev Collateral cannot cover new borrow\n    error CollateralCannotCoverNewBorrow();\n\n    /// @dev Health factor not below threshold\n    error HealthFactorNotBelowThreshold();\n\n    /// @dev Health factor lower than liquidation threshold\n    error HealthFactorLowerThanLiquidationThreshold(uint256 health);\n\n    /// @dev Already initiated\n    error AlreadyInitiated();\n\n    /// @dev Grace period not over\n    error GracePeriodNotOver();\n\n    /// @dev Liquidation expired\n    error LiquidationExpired();\n\n    /// @dev Reserve paused\n    error ReservePaused();\n\n    /// @dev Asset not listed\n    error AssetNotListed();\n\n    /// @dev Variable debt supply not zero\n    error VariableDebtSupplyNotZero();\n\n    /// @dev Zero address not valid\n    error ZeroAddressNotValid();\n\n    /// @dev Reserve already initialized\n    error ReserveAlreadyInitialized();\n\n    /// @dev Interest receiver not set\n    error InterestReceiverNotSet();\n\n    /// @dev Restaker interest receiver not set\n    error RestakerInterestReceiverNotSet();\n\n    /// @notice Validate the borrow of an agent\n    /// @dev Check the pause state of the reserve and the health of the agent before and after the\n    /// borrow.\n    /// @param $ Lender storage\n    /// @param params Validation parameters\n    function validateBorrow(ILender.LenderStorage storage $, ILender.BorrowParams memory params) external {\n        if (params.receiver == address(0) || params.asset == address(0)) revert ZeroAddressNotValid();\n        if ($.reservesData[params.asset].paused) revert ReservePaused();\n\n        uint256 borrowCapacity = ViewLogic.maxBorrowable($, params.agent, params.asset);\n\n        if (params.amount > borrowCapacity) revert CollateralCannotCoverNewBorrow();\n\n        IDelegation($.delegation).setLastBorrow(params.agent);\n    }\n\n    /// @notice Validate the initialization of the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    /// @param start Last liquidation start time\n    /// @param expiry Liquidation duration after which it expires\n    function validateInitiateLiquidation(uint256 health, uint256 start, uint256 expiry) external view {\n        if (health >= 1e27) revert HealthFactorNotBelowThreshold();\n        if (block.timestamp <= start + expiry) revert AlreadyInitiated();\n    }\n\n    /// @notice Validate the cancellation of the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    function validateCancelLiquidation(uint256 health) external pure {\n        if (health < 1e27) revert HealthFactorLowerThanLiquidationThreshold(health);\n    }\n\n    /// @notice Validate the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    /// @param emergencyHealth Emergency health below which the grace period is voided\n    /// @param start Last liquidation start time\n    /// @param grace Grace period duration\n    /// @param expiry Liquidation duration after which it expires\n    function validateLiquidation(uint256 health, uint256 emergencyHealth, uint256 start, uint256 grace, uint256 expiry)\n        external\n        view\n    {\n        if (health >= 1e27) revert HealthFactorNotBelowThreshold();\n        if (emergencyHealth >= 1e27) {\n            if (block.timestamp <= start + grace) revert GracePeriodNotOver();\n            if (block.timestamp >= start + expiry) revert LiquidationExpired();\n        }\n    }\n\n    /// TODO Check that the asset is borrowable from the vault\n    /// @notice Validate adding an asset as a reserve\n    /// @param $ Lender storage\n    /// @param params Parameters for adding an asset\n    function validateAddAsset(ILender.LenderStorage storage $, ILender.AddAssetParams memory params) external view {\n        if (params.asset == address(0) || params.vault == address(0)) revert ZeroAddressNotValid();\n        if (params.interestReceiver == address(0)) revert InterestReceiverNotSet();\n        if (params.restakerInterestReceiver == address(0)) revert RestakerInterestReceiverNotSet();\n        if ($.reservesData[params.asset].vault != address(0)) revert ReserveAlreadyInitialized();\n    }\n\n    /// @notice Validate dropping an asset as a reserve\n    /// @dev All principal borrows must be repaid, interest is ignored\n    /// @param $ Lender storage\n    /// @param _asset Asset to remove\n    function validateRemoveAsset(ILender.LenderStorage storage $, address _asset) external view {\n        if (IERC20($.reservesData[_asset].principalDebtToken).totalSupply() != 0) revert VariableDebtSupplyNotZero();\n    }\n\n    /// @notice Validate pausing a reserve\n    /// @param $ Lender storage\n    /// @param _asset Asset to pause\n    function validatePauseAsset(ILender.LenderStorage storage $, address _asset) external view {\n        if ($.reservesData[_asset].vault == address(0)) revert AssetNotListed();\n    }\n}\n",
        "Lender.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { ILender } from \"../interfaces/ILender.sol\";\nimport { LenderStorageUtils } from \"../storage/LenderStorageUtils.sol\";\nimport { BorrowLogic } from \"./libraries/BorrowLogic.sol\";\nimport { LiquidationLogic } from \"./libraries/LiquidationLogic.sol\";\nimport { ReserveLogic } from \"./libraries/ReserveLogic.sol\";\nimport { ViewLogic } from \"./libraries/ViewLogic.sol\";\n\n/// @title Lender for covered agents\n/// @author kexley, @capLabs\n/// @notice Whitelisted tokens are borrowed and repaid from this contract by covered agents.\n/// @dev Borrow interest rates are calculated from the underlying utilization rates of the assets\n/// in the vaults.\ncontract Lender is ILender, UUPSUpgradeable, Access, LenderStorageUtils {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the lender\n    /// @param _accessControl Access control address\n    /// @param _delegation Delegation address\n    /// @param _oracle Oracle address\n    /// @param _targetHealth Target health after liquidations (scaled by 1e27)\n    /// @param _grace Grace period in seconds before an agent becomes liquidatable\n    /// @param _expiry Expiry period in seconds after which an agent cannot be liquidated until called again\n    /// @param _bonusCap Bonus cap for liquidations (scaled by 1e27)\n    /// @param _emergencyLiquidationThreshold Liquidation threshold below which grace periods are voided (scaled by 1e27)\n    function initialize(\n        address _accessControl,\n        address _delegation,\n        address _oracle,\n        uint256 _targetHealth,\n        uint256 _grace,\n        uint256 _expiry,\n        uint256 _bonusCap,\n        uint256 _emergencyLiquidationThreshold\n    ) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n\n        if (_delegation == address(0) || _oracle == address(0)) revert ZeroAddressNotValid();\n\n        // TODO: remove this\n        LenderStorage storage $ = getLenderStorage();\n        $.delegation = _delegation;\n        $.oracle = _oracle;\n        $.targetHealth = _targetHealth;\n        $.grace = _grace;\n        $.expiry = _expiry;\n        $.bonusCap = _bonusCap;\n        $.emergencyLiquidationThreshold = _emergencyLiquidationThreshold;\n    }\n\n    /// @notice Borrow an asset\n    /// @param _asset Asset to borrow\n    /// @param _amount Amount to borrow\n    /// @param _receiver Receiver of the borrowed asset\n    function borrow(address _asset, uint256 _amount, address _receiver) external {\n        BorrowLogic.borrow(\n            getLenderStorage(), BorrowParams({ agent: msg.sender, asset: _asset, amount: _amount, receiver: _receiver })\n        );\n    }\n\n    /// @notice Repay an asset\n    /// @param _asset Asset to repay\n    /// @param _amount Amount to repay\n    /// @param _agent Repay on behalf of another borrower\n    /// @return repaid Actual amount repaid\n    function repay(address _asset, uint256 _amount, address _agent) external returns (uint256 repaid) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        repaid = BorrowLogic.repay(\n            getLenderStorage(), RepayParams({ agent: _agent, asset: _asset, amount: _amount, caller: msg.sender })\n        );\n    }\n\n    /// @notice Realize interest for an asset\n    /// @param _asset Asset to realize interest for\n    /// @param _amount Amount of interest to realize (type(uint).max for all available interest)\n    /// @return actualRealized Actual amount realized\n    function realizeInterest(address _asset, uint256 _amount) external returns (uint256 actualRealized) {\n        actualRealized =\n            BorrowLogic.realizeInterest(getLenderStorage(), RealizeInterestParams({ asset: _asset, amount: _amount }));\n    }\n\n    /// @notice Calculate the maximum interest that can be realized\n    /// @param _asset Asset to calculate max realization for\n    /// @return _maxRealization Maximum interest that can be realized\n    function maxRealization(address _asset) external view returns (uint256 _maxRealization) {\n        _maxRealization = BorrowLogic.maxRealization(getLenderStorage(), _asset);\n    }\n\n    /// @notice Initiate liquidation of an agent when the health is below 1\n    /// @param _agent Agent address\n    function initiateLiquidation(address _agent) external {\n        LiquidationLogic.initiateLiquidation(getLenderStorage(), _agent);\n    }\n\n    /// @notice Cancel liquidation of an agent when the health is above 1\n    /// @param _agent Agent address\n    function cancelLiquidation(address _agent) external {\n        LiquidationLogic.cancelLiquidation(getLenderStorage(), _agent);\n    }\n\n    /// @notice Liquidate an agent when the health is below 1\n    /// @param _agent Agent address\n    /// @param _asset Asset to repay\n    /// @param _amount Amount of asset to repay on behalf of the agent\n    /// @param liquidatedValue Value of the liquidation returned to the liquidator\n    function liquidate(address _agent, address _asset, uint256 _amount) external returns (uint256 liquidatedValue) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        liquidatedValue = LiquidationLogic.liquidate(\n            getLenderStorage(), RepayParams({ agent: _agent, asset: _asset, amount: _amount, caller: msg.sender })\n        );\n    }\n\n    /// @notice Calculate the agent data\n    /// @param _agent Address of agent\n    /// @return totalDelegation Total delegation of an agent in USD, encoded with 8 decimals\n    /// @return totalDebt Total debt of an agent in USD, encoded with 8 decimals\n    /// @return ltv Loan to value ratio, encoded in ray (1e27)\n    /// @return liquidationThreshold Liquidation ratio of an agent, encoded in ray (1e27)\n    /// @return health Health status of an agent, encoded in ray (1e27)\n    function agent(address _agent)\n        external\n        view\n        returns (uint256 totalDelegation, uint256 totalDebt, uint256 ltv, uint256 liquidationThreshold, uint256 health)\n    {\n        (totalDelegation, totalDebt, ltv, liquidationThreshold, health) = ViewLogic.agent(getLenderStorage(), _agent);\n    }\n\n    /// @notice Calculate the maximum amount that can be borrowed for a given asset\n    /// @param _agent Agent address\n    /// @param _asset Asset to borrow\n    /// @return maxBorrowableAmount Maximum amount that can be borrowed in asset decimals\n    function maxBorrowable(address _agent, address _asset) external view returns (uint256 maxBorrowableAmount) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        maxBorrowableAmount = ViewLogic.maxBorrowable(getLenderStorage(), _agent, _asset);\n    }\n\n    /// @notice Calculate the maximum amount that can be liquidated for a given asset\n    /// @param _agent Agent address\n    /// @param _asset Asset to liquidate\n    /// @return maxLiquidatableAmount Maximum amount that can be liquidated in asset decimals\n    function maxLiquidatable(address _agent, address _asset) external view returns (uint256 maxLiquidatableAmount) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        maxLiquidatableAmount = ViewLogic.maxLiquidatable(getLenderStorage(), _agent, _asset);\n    }\n\n    /// @notice Get the current debt balances for an agent for a specific asset\n    /// @param _agent Agent address to check debt for\n    /// @param _asset Asset to check debt for\n    /// @return principalDebt Principal debt amount in asset decimals\n    /// @return interestDebt Interest debt amount in asset decimals\n    /// @return restakerDebt Restaker debt amount in asset decimals\n    function debt(address _agent, address _asset)\n        external\n        view\n        returns (uint256 principalDebt, uint256 interestDebt, uint256 restakerDebt)\n    {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        (principalDebt, interestDebt, restakerDebt) = ViewLogic.debt(getLenderStorage(), _agent, _asset);\n    }\n\n    /// @notice Add an asset to the Lender\n    /// @param _params Parameters to add an asset\n    function addAsset(AddAssetParams calldata _params) external checkAccess(this.addAsset.selector) {\n        LenderStorage storage $ = getLenderStorage();\n        if (!ReserveLogic.addAsset($, _params)) ++$.reservesCount;\n    }\n\n    /// @notice Remove asset from lending when there is no borrows\n    /// @param _asset Asset address\n    function removeAsset(address _asset) external checkAccess(this.removeAsset.selector) {\n        if (_asset == address(0)) revert ZeroAddressNotValid();\n        ReserveLogic.removeAsset(getLenderStorage(), _asset);\n    }\n\n    /// @notice Pause an asset from being borrowed\n    /// @param _asset Asset address\n    /// @param _pause True if pausing or false if unpausing\n    function pauseAsset(address _asset, bool _pause) external checkAccess(this.pauseAsset.selector) {\n        if (_asset == address(0)) revert ZeroAddressNotValid();\n        ReserveLogic.pauseAsset(getLenderStorage(), _asset, _pause);\n    }\n\n    /// @notice The total number of reserves\n    /// @return count Number of reserves\n    function reservesCount() external view returns (uint256 count) {\n        count = getLenderStorage().reservesCount;\n    }\n\n    /// @notice The grace period duration\n    /// @return gracePeriod Grace period in seconds\n    function grace() external view returns (uint256 gracePeriod) {\n        gracePeriod = getLenderStorage().grace;\n    }\n\n    /// @notice The expiry period duration\n    /// @return expiryPeriod Expiry period in seconds\n    function expiry() external view returns (uint256 expiryPeriod) {\n        expiryPeriod = getLenderStorage().expiry;\n    }\n\n    /// @notice The target health factor\n    /// @return target Target health factor scaled to 1e27\n    function targetHealth() external view returns (uint256 target) {\n        target = getLenderStorage().targetHealth;\n    }\n\n    /// @notice The liquidation bonus cap\n    /// @return cap Bonus cap scaled to 1e27\n    function bonusCap() external view returns (uint256 cap) {\n        cap = getLenderStorage().bonusCap;\n    }\n\n    /// @notice The emergency liquidation threshold\n    /// @return threshold Threshold scaled to 1e27\n    function emergencyLiquidationThreshold() external view returns (uint256 threshold) {\n        threshold = getLenderStorage().emergencyLiquidationThreshold;\n    }\n\n    /// @notice The liquidation start time for an agent\n    /// @param _agent Address of the agent\n    /// @return startTime Timestamp when liquidation was initiated\n    function liquidationStart(address _agent) external view returns (uint256 startTime) {\n        startTime = getLenderStorage().liquidationStart[_agent];\n    }\n\n    /// @notice The reserve data for an asset\n    /// @param _asset Address of the asset\n    /// @return id Id of the reserve\n    /// @return vault Address of the vault\n    /// @return principalDebtToken Address of the principal debt token\n    /// @return restakerDebtToken Address of the restaker debt token\n    /// @return interestDebtToken Address of the interest debt token\n    /// @return interestReceiver Address of the interest receiver\n    /// @return decimals Decimals of the asset\n    /// @return paused True if the asset is paused, false otherwise\n    /// @return realizedInterest Realized interest of the asset\n    function reservesData(address _asset)\n        external\n        view\n        returns (\n            uint256 id,\n            address vault,\n            address principalDebtToken,\n            address restakerDebtToken,\n            address interestDebtToken,\n            address interestReceiver,\n            uint8 decimals,\n            bool paused,\n            uint256 realizedInterest\n        )\n    {\n        ReserveData storage reserve = getLenderStorage().reservesData[_asset];\n        id = reserve.id;\n        vault = reserve.vault;\n        principalDebtToken = reserve.principalDebtToken;\n        restakerDebtToken = reserve.restakerDebtToken;\n        interestDebtToken = reserve.interestDebtToken;\n        interestReceiver = reserve.interestReceiver;\n        decimals = reserve.decimals;\n        paused = reserve.paused;\n        realizedInterest = reserve.realizedInterest;\n    }\n\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n"
    }
}