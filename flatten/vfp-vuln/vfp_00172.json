{
    "vfp_id": "vfp_00172",
    "project_name": "ChainSecurity_M0_MExtensions_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "MYieldFee Can Be Forced Into Insolvency if Non Earning",
            "description": "The MYieldFee contract uses an internal index to track yield and fees, relying on the `latestRate` value to determine if it is earning. If the contract is removed from the earner whitelist but the index is not paused, the internal accounting continues to accrue yield that is never received, leading to insolvency. The root cause is that `updateIndex()` does not validate the current earning status before resuming index growth. An attacker or governance action could trigger `updateIndex()` after removal from the earners list, reactivating the index despite no actual yield generation. This would cause the contract to owe more than it holds, resulting in insolvency and potential loss of user funds.\n",
            "severity": "High",
            "location": [
                "MYieldFee::updateIndex"
            ],
            "files": [
                "evm-m-extensions/src/projects/yieldToAllWithFee/MYieldFee.sol"
            ]
        }
    ],
    "affected_files": {
        "MYieldFee.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport {\n    AccessControlUpgradeable\n} from \"../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\n\nimport { IERC20 } from \"../../../lib/common/src/interfaces/IERC20.sol\";\n\nimport { ContinuousIndexingMath } from \"../../../lib/common/src/libs/ContinuousIndexingMath.sol\";\nimport { UIntMath } from \"../../../lib/common/src/libs/UIntMath.sol\";\n\nimport { IndexingMath } from \"../../libs/IndexingMath.sol\";\n\nimport { IMExtension } from \"../../interfaces/IMExtension.sol\";\nimport { IMTokenLike } from \"../../interfaces/IMTokenLike.sol\";\n\nimport { IMYieldFee } from \"./interfaces/IMYieldFee.sol\";\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\n\nimport { MExtension } from \"../../MExtension.sol\";\n\nabstract contract MYieldFeeStorageLayout {\n    /// @custom:storage-location erc7201:M0.storage.MYieldFee\n    struct MYieldFeeStorageStruct {\n        // NOTE: Slot 1\n        uint256 totalSupply;\n        // NOTE: Slot 2\n        uint112 totalPrincipal;\n        uint128 latestIndex;\n        uint16 feeRate;\n        // NOTE: Slot 3\n        address feeRecipient;\n        uint40 latestUpdateTimestamp;\n        uint32 latestRate;\n        // NOTE: Slot 4\n        mapping(address account => uint256 balance) balanceOf;\n        // NOTE: Slot 5\n        mapping(address account => uint112 principal) principalOf;\n        // NOTE: Slot 6\n        mapping(address account => address claimRecipient) claimRecipients;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MYieldFee\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_YIELD_FEE_STORAGE_LOCATION =\n        0x9d728c135b5b2cd0ace61885d69c4f72215f10f82e77822fb7c6bf472237dd00;\n\n    function _getMYieldFeeStorageLocation() internal pure returns (MYieldFeeStorageStruct storage $) {\n        assembly {\n            $.slot := _M_YIELD_FEE_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title MYieldFee\n * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.\n *         Extended to take a fee from the yield generated by M.\n * @dev    All holders of this ERC20 token are earners.\n * @author M0 Labs\n */\ncontract MYieldFee is IContinuousIndexing, IMYieldFee, AccessControlUpgradeable, MYieldFeeStorageLayout, MExtension {\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMYieldFee\n    uint16 public constant ONE_HUNDRED_PERCENT = 10_000;\n\n    /// @inheritdoc IMYieldFee\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n\n    /// @inheritdoc IMYieldFee\n    bytes32 public constant CLAIM_RECIPIENT_MANAGER_ROLE = keccak256(\"CLAIM_RECIPIENT_MANAGER_ROLE\");\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @notice Initializes the generic M Yield Fee extension token.\n     * @param name             The name of the token (e.g. \"M Yield Fee\").\n     * @param symbol           The symbol of the token (e.g. \"MYF\").\n     * @param mToken           The address of an M Token.\n     * @param swapFacility     The address of the Swap Facility.\n     * @param feeRate_         The fee rate, in bps, that will be taken from the yield generated by M.\n     * @param feeRecipient_    The address of the recipient of the yield fee.\n     * @param admin            The address administrating the M extension. Can grant and revoke roles.\n     * @param feeManager       The address managing the fee rate and recipient.\n     * @param claimRecipientManager The address managing claim recipients for accounts.\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address mToken,\n        address swapFacility,\n        uint16 feeRate_,\n        address feeRecipient_,\n        address admin,\n        address feeManager,\n        address claimRecipientManager\n    ) public virtual initializer {\n        if (admin == address(0)) revert ZeroAdmin();\n        if (feeManager == address(0)) revert ZeroFeeManager();\n        if (claimRecipientManager == address(0)) revert ZeroClaimRecipientManager();\n\n        __MExtension_init(name, symbol, mToken, swapFacility);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(FEE_MANAGER_ROLE, feeManager);\n        _grantRole(CLAIM_RECIPIENT_MANAGER_ROLE, claimRecipientManager);\n\n        _setFeeRate(feeRate_);\n        _setFeeRecipient(feeRecipient_);\n\n        _getMYieldFeeStorageLocation().latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMYieldFee\n    function claimYieldFor(address account) external returns (uint256) {\n        if (account == address(0)) revert ZeroAccount();\n\n        uint256 yield_ = accruedYieldOf(account);\n\n        if (yield_ == 0) return 0;\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.\n        unchecked {\n            $.balanceOf[account] += yield_;\n            $.totalSupply += yield_;\n        }\n\n        address claimRecipient_ = claimRecipientFor(account);\n\n        // Emit the appropriate `YieldClaimed` and `Transfer` events, depending on the claim override recipient\n        emit YieldClaimed(account, claimRecipient_, yield_);\n        emit Transfer(address(0), claimRecipient_, yield_);\n\n        if (claimRecipient_ == account) return yield_;\n\n        // Distribute the yield to the claim recipient.\n        _update(account, claimRecipient_, yield_);\n\n        return yield_;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function claimFee() public returns (uint256) {\n        uint256 yieldFee_ = totalAccruedFee();\n\n        if (yieldFee_ == 0) return 0;\n\n        address recipient_ = _getMYieldFeeStorageLocation().feeRecipient;\n\n        emit FeeClaimed(msg.sender, recipient_, yieldFee_);\n\n        // NOTE: Round up to allow claiming the whole amount of yield fee.\n        _mint(recipient_, yieldFee_, IndexingMath.getPrincipalAmountRoundedUp(yieldFee_, currentIndex()));\n\n        return yieldFee_;\n    }\n\n    /// @inheritdoc IMExtension\n    function enableEarning() external override {\n        if (isEarningEnabled()) revert EarningIsEnabled();\n\n        // NOTE: update the index to store the latest state, current index won't accrue since `latestRate` is 0.\n        emit EarningEnabled(updateIndex());\n\n        IMTokenLike(mToken()).startEarning();\n    }\n\n    /// @inheritdoc IMExtension\n    function disableEarning() external override {\n        if (!isEarningEnabled()) revert EarningIsDisabled();\n\n        // NOTE: update the index to store the latest state.\n        emit EarningDisabled(updateIndex());\n\n        // NOTE: `latestRate` is set to 0 to indicate that earning is disabled.\n        delete _getMYieldFeeStorageLocation().latestRate;\n\n        IMTokenLike(mToken()).stopEarning(address(this));\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function updateIndex() public virtual returns (uint128 currentIndex_) {\n        // NOTE: Read the current M token rate adjusted by fee rate split.\n        uint32 rate_ = earnerRate();\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.latestUpdateTimestamp == block.timestamp && $.latestRate == rate_) return $.latestIndex;\n\n        // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.\n        $.latestIndex = currentIndex_ = currentIndex();\n        $.latestRate = rate_;\n        $.latestUpdateTimestamp = _latestEarnerRateAccrualTimestamp();\n\n        emit IndexUpdated(currentIndex_, rate_);\n    }\n\n    /// @inheritdoc IMYieldFee\n    function setFeeRate(uint16 feeRate_) external onlyRole(FEE_MANAGER_ROLE) {\n        _setFeeRate(feeRate_);\n\n        // NOTE: Update the index to store the new adjusted rate.\n        if (isEarningEnabled()) updateIndex();\n    }\n\n    /// @inheritdoc IMYieldFee\n    function setFeeRecipient(address feeRecipient_) external onlyRole(FEE_MANAGER_ROLE) {\n        // Claim fee for the previous fee recipient.\n        claimFee();\n\n        _setFeeRecipient(feeRecipient_);\n    }\n\n    /// @inheritdoc IMYieldFee\n    function setClaimRecipient(\n        address account,\n        address claimRecipient\n    ) external onlyRole(CLAIM_RECIPIENT_MANAGER_ROLE) {\n        if (account == address(0)) revert ZeroAccount();\n        if (claimRecipient == address(0)) revert ZeroClaimRecipient();\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.claimRecipients[account] == claimRecipient) return;\n\n        // Optionally consider claiming yield for the previous claim recipient.\n        // claimYieldFor(account);\n\n        $.claimRecipients[account] = claimRecipient;\n\n        emit ClaimRecipientSet(account, claimRecipient);\n    }\n\n    /* ============ External/Public view functions ============ */\n\n    /// @inheritdoc IMYieldFee\n    function accruedYieldOf(address account) public view returns (uint256) {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n        return _getAccruedYield($.balanceOf[account], $.principalOf[account], currentIndex());\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view override returns (uint256) {\n        return _getMYieldFeeStorageLocation().balanceOf[account];\n    }\n\n    /// @inheritdoc IMYieldFee\n    function balanceWithYieldOf(address account) external view returns (uint256) {\n        unchecked {\n            return balanceOf(account) + accruedYieldOf(account);\n        }\n    }\n\n    /// @inheritdoc IMYieldFee\n    function principalOf(address account) public view returns (uint112) {\n        return _getMYieldFeeStorageLocation().principalOf[account];\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function currentIndex() public view virtual override(IContinuousIndexing, MExtension) returns (uint128) {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if (!isEarningEnabled()) return $.latestIndex;\n\n        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.\n        unchecked {\n            return\n                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.\n                UIntMath.bound128(\n                    ContinuousIndexingMath.multiplyIndicesDown(\n                        $.latestIndex,\n                        ContinuousIndexingMath.getContinuousIndex(\n                            ContinuousIndexingMath.convertFromBasisPoints($.latestRate),\n                            uint32(_latestEarnerRateAccrualTimestamp() - $.latestUpdateTimestamp)\n                        )\n                    )\n                );\n        }\n    }\n\n    /// @inheritdoc IMYieldFee\n    function earnerRate() public view virtual returns (uint32) {\n        return UIntMath.safe32((uint256(ONE_HUNDRED_PERCENT - feeRate()) * _currentEarnerRate()) / ONE_HUNDRED_PERCENT);\n    }\n\n    /// @inheritdoc IMExtension\n    function isEarningEnabled() public view override returns (bool) {\n        return _getMYieldFeeStorageLocation().latestRate != 0;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function latestIndex() public view returns (uint128) {\n        return _getMYieldFeeStorageLocation().latestIndex;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function latestRate() public view returns (uint32) {\n        return _getMYieldFeeStorageLocation().latestRate;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function latestUpdateTimestamp() public view returns (uint40) {\n        return _getMYieldFeeStorageLocation().latestUpdateTimestamp;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function projectedTotalSupply() public view returns (uint256) {\n        return IndexingMath.getPresentAmountRoundedUp(_getMYieldFeeStorageLocation().totalPrincipal, currentIndex());\n    }\n\n    /// @inheritdoc IMYieldFee\n    function totalAccruedYield() public view returns (uint256) {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n        return _getAccruedYield($.totalSupply, $.totalPrincipal, currentIndex());\n    }\n\n    /// @inheritdoc IMYieldFee\n    function totalAccruedFee() public view returns (uint256) {\n        uint256 mBalance_ = _mBalanceOf(address(this));\n        uint256 projectedTotalSupply_ = projectedTotalSupply();\n\n        unchecked {\n            return mBalance_ > projectedTotalSupply_ ? mBalance_ - projectedTotalSupply_ : 0;\n        }\n    }\n\n    /// @inheritdoc IMYieldFee\n    function totalPrincipal() public view returns (uint112) {\n        return _getMYieldFeeStorageLocation().totalPrincipal;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view returns (uint256) {\n        return _getMYieldFeeStorageLocation().totalSupply;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function feeRate() public view returns (uint16) {\n        return _getMYieldFeeStorageLocation().feeRate;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function feeRecipient() public view returns (address) {\n        return _getMYieldFeeStorageLocation().feeRecipient;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function claimRecipientFor(address account) public view returns (address) {\n        address recipient_ = _getMYieldFeeStorageLocation().claimRecipients[account];\n\n        // If no claim recipient is set, return the account itself.\n        return recipient_ == address(0) ? account : recipient_;\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Mints `amount` tokens to `recipient`.\n     * @param recipient The address that will receive tokens.\n     * @param amount    The amount of tokens to mint.\n     */\n    function _mint(address recipient, uint256 amount) internal override {\n        _mint(recipient, amount, IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex()));\n    }\n\n    /**\n     * @dev   Mints `amount` tokens to `recipient` with a specified principal.\n     * @param recipient The address that will receive tokens.\n     * @param amount    The amount of tokens to mint.\n     * @param principal The principal amount to be associated with the minted tokens.\n     */\n    function _mint(address recipient, uint256 amount, uint112 principal) internal {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // NOTE: Can be `unchecked` because the max amount of  M is never greater than `type(uint240).max`.\n        //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `totalPrincipal`\n        unchecked {\n            $.balanceOf[recipient] += amount;\n            $.totalSupply += amount;\n\n            $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal);\n            // No need for `UIntMath.safe112`, `principalOf[recipient]` cannot be greater than `totalPrincipal`.\n            $.principalOf[recipient] += principal;\n        }\n\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev   Burns `amount` tokens from `account`.\n     * @param account The address whose account balance will be decremented.\n     * @param amount  The present amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal override {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in unchecked block\n        uint112 fromPrincipal_ = $.principalOf[account];\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and\n        //       `principalOf[account]` cannot be greater than `totalPrincipal`.\n        unchecked {\n            $.balanceOf[account] -= amount;\n            $.totalSupply -= amount;\n\n            $.principalOf[account] = fromPrincipal_ - principal_;\n            $.totalPrincipal -= principal_;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _update(address sender, address recipient, uint256 amount) internal override {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // Slightly overestimate the principal amount to be moved on transfer\n        uint112 fromPrincipal_ = $.principalOf[sender];\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because we check for insufficient sender balance above.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and\n        unchecked {\n            $.balanceOf[sender] -= amount;\n            $.balanceOf[recipient] += amount;\n\n            $.principalOf[sender] = fromPrincipal_ - principal_;\n            $.principalOf[recipient] += principal_;\n        }\n    }\n\n    /**\n     * @notice Sets the yield fee rate, in bps, that will be taken from the yield generated by M.\n     * @dev    Reverts if the yield fee rate is greater than ONE_HUNDRED_PERCENT.\n     * @dev    Returns early if the yield fee rate is the same as the current one.\n     * @param  feeRate_ The yield fee rate.\n     */\n    function _setFeeRate(uint16 feeRate_) internal {\n        if (feeRate_ > ONE_HUNDRED_PERCENT) revert FeeRateTooHigh(feeRate_, ONE_HUNDRED_PERCENT);\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.feeRate == feeRate_) return;\n\n        $.feeRate = feeRate_;\n\n        emit FeeRateSet(feeRate_);\n    }\n\n    /**\n     * @notice Sets the yield fee recipient that will receive part of the yield generated by M.\n     * @dev    Reverts if the yield fee recipient is address zero.\n     * @dev    Returns early if the yield fee recipient is the same as the current one.\n     * @param  feeRecipient_ The yield fee recipient address.\n     */\n    function _setFeeRecipient(address feeRecipient_) internal {\n        if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.feeRecipient == feeRecipient_) return;\n\n        $.feeRecipient = feeRecipient_;\n\n        emit FeeRecipientSet(feeRecipient_);\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev   Returns the timestamp when the earner rate was last accrued to accounts.\n     *        For L1: returns the current `block.timestamp` as the rate accrues continuously.\n     *        For L2: returns the `latestUpdateTimestamp` from the M token when the index was propagated from L1.\n     *        Can be overridden by the inheriting contract (for EVM L2 contracts with index propagation).\n     *        MUST return the current block timestamp for an M extension token deployed on the mainnet.\n     *        MUST return spoke M token's `latestUpdateTimestamp` for an M extension token deployed on a spoke chain.\n     * @return The current block timestamp.\n     */\n    function _latestEarnerRateAccrualTimestamp() internal view virtual returns (uint40) {\n        return uint40(block.timestamp);\n    }\n\n    /**\n     * @dev    Returns the current earner rate.\n     *         Needs to be overridden by the inheriting contract.\n     *         MUST return M token's earner rate for an M extension token deployed on the mainnet.\n     *         MUST return a rate oracle's earner rate for an M extension token deployed on a spoke chain.\n     * @return The current earner rate.\n     */\n    function _currentEarnerRate() internal view virtual returns (uint32) {\n        // NOTE: The behavior of M is known, so we can safely retrieve the earner rate.\n        return IMTokenLike(mToken()).earnerRate();\n    }\n\n    /**\n     * @dev    Compute the yield given a balance, principal and index.\n     * @param  balance   The current balance of the account.\n     * @param  principal The principal of the account.\n     * @param  index     The current index.\n     * @return The yield accrued since the last claim.\n     */\n    function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {\n        uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);\n        unchecked {\n            return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;\n        }\n    }\n}\n"
    }
}