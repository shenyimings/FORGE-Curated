{
    "vfp_id": "vfp_00056",
    "project_name": "cantina_liminal_oct2025.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Timelock Admin Can Instantly Change Delays, Bypassing Governance Safeguards",
            "description": "The VaultTimelockController's setFunctionDelay and setDefaultFunctionDelay functions are protected only by DEFAULT_ADMIN_ROLE without any timelock, allowing immediate changes to delay periods. This undermines the entire purpose of the timelock as a governance safeguard.\nThe root cause is the lack of self-enforced timelocking on the timelock's own configuration functions, enabling an admin to reduce delays instantly.\nAn attacker with DEFAULT_ADMIN_ROLE could reduce the delay of a critical function (e.g., contract upgrade) from 7 days to 1 hour and execute a malicious upgrade within that short window, leaving users no time to react.\nThe impact is complete bypass of governance safeguards, enabling rapid malicious upgrades and potential theft of all protocol funds, effectively negating the security model.\n",
            "severity": "Medium",
            "location": [
                "VaultTimelockController.sol#L314-L350"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultTimelockController.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {TimelockControllerUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\n\n/**\n * @title VaultTimelockController\n * @notice Enhanced timelock controller with per-function delay configuration\n * @dev Extends OpenZeppelin's TimelockControllerUpgradeable with intelligent delay detection\n */\ncontract VaultTimelockController is TimelockControllerUpgradeable {\n    // ERC-7201: Namespaced Storage Layout\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.vaultTimelock.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VAULT_TIMELOCK_STORAGE_POSITION =\n        0x58dfca5daecbbb3808b7a2399a82d70b8b7f873e64331c276767d397a9844400;\n\n    /**\n     * @dev Storage struct for VaultTimelockController-specific data\n     * @dev This struct is stored in a namespaced storage slot to prevent collisions\n     */\n    struct VaultTimelockStorage {\n        /// @notice Mapping of function selectors to their required delays\n        mapping(bytes4 => uint256) functionDelays;\n        /// @notice Mapping to track which functions have explicit delay configuration\n        mapping(bytes4 => bool) hasExplicitDelay;\n        /// @notice Default delay for functions without specific configuration\n        uint256 defaultFunctionDelay;\n    }\n\n    /**\n     * @dev Returns the storage struct at the namespaced storage position\n     * @return $ The VaultTimelockStorage struct\n     */\n    function _getVaultTimelockStorage() private pure returns (VaultTimelockStorage storage $) {\n        assembly {\n            $.slot := VAULT_TIMELOCK_STORAGE_POSITION\n        }\n    }\n    /// @notice Time delay constants\n\n    uint256 public constant MIN_FUNCTION_DELAY = 1 hours;\n    uint256 public constant RECOVERY_DELAY = 12 hours;\n    uint256 public constant MIN_DEFAULT_DELAY = 12 hours;\n    uint256 public constant PARAMETER_DELAY = 24 hours;\n    uint256 public constant ORACLE_DELAY = 36 hours;\n    uint256 public constant CONFIG_DELAY = 48 hours;\n    uint256 public constant ROLE_DELAY = 72 hours;\n    uint256 public constant MAX_DELAY = 7 days;\n\n    /// @notice Events\n    event FunctionDelaySet(bytes4 indexed selector, uint256 delay);\n    event DefaultDelayUpdated(uint256 newDelay);\n    event OperationScheduledWithAutoDelay(\n        bytes32 indexed id, address indexed target, bytes4 indexed selector, uint256 delay\n    );\n    event OperationExecuted(bytes32 indexed id, address indexed target, bytes4 indexed selector);\n    event OperationBatchExecuted(bytes32 indexed id, uint256 operationCount);\n\n    /**\n     * @notice Get the delay for a specific function selector\n     * @param selector Function selector\n     * @return delay The delay in seconds\n     */\n    function functionDelays(bytes4 selector) public view returns (uint256 delay) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        return $.functionDelays[selector];\n    }\n\n    /**\n     * @notice Check if a function selector has explicit delay configuration\n     * @param selector Function selector\n     * @return hasExplicit True if the function has explicit delay configuration\n     */\n    function hasExplicitDelay(bytes4 selector) public view returns (bool hasExplicit) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        return $.hasExplicitDelay[selector];\n    }\n\n    /**\n     * @notice Get the default delay for unconfigured functions\n     * @return delay The default delay in seconds\n     */\n    function defaultFunctionDelay() public view returns (uint256 delay) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        return $.defaultFunctionDelay;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the enhanced timelock controller\n     * @param minDelay Minimum delay for operations\n     * @param proposers Array of proposer addresses\n     * @param executors Array of executor addresses\n     * @param admin Optional admin address\n     */\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin)\n        public\n        override\n        initializer\n    {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n\n        // Set default delay for unconfigured functions\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        $.defaultFunctionDelay = CONFIG_DELAY;\n\n        // Configure critical function selectors with their specific delays\n        _configureCriticalFunctions();\n    }\n\n    /**\n     * @notice Configure function selectors with their specific delays\n     */\n    function _configureCriticalFunctions() internal {\n        // Role management functions - Most critical\n        _setFunctionDelay(bytes4(keccak256(\"addMinter(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"addBurner(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeMinter(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeBurner(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"grantRole(bytes32,address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"revokeRole(bytes32,address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"addFeeCollector(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeFeeCollector(address)\")), ROLE_DELAY);\n\n        // Critical config updates\n        _setFunctionDelay(bytes4(keccak256(\"setFees((uint256,uint256))\")), CONFIG_DELAY); // since it's a struct we must consider this as a tuple\n        _setFunctionDelay(bytes4(keccak256(\"setFees(uint256,uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setLiquidityProvider(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setPythContract(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setUnderlyingAsset(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"registerDepositPipe(address,address,address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeDepositPipe(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRedemptionPipe(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxDeposit(uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxSupply(uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxWithdraw(uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxPercentageIncrease(uint256)\")), CONFIG_DELAY);\n\n        // Oracle price feed configuration\n        _setFunctionDelay(bytes4(keccak256(\"setMaxPriceAge(uint256)\")), ORACLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setPriceId(address,bytes32,uint8)\")), ORACLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setPriceIds(address[],bytes32[],uint8[])\")), ORACLE_DELAY);\n\n        // OVaultComposerMulti functions\n        _setFunctionDelay(bytes4(keccak256(\"setOVaultComposerMulti(address,address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setOFTApproval(address,bool)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRemotePeer(address,uint32,bytes32)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRemotePeer(address,uint32,address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setTimelockController(address)\")), MAX_DELAY);\n\n        // Deposit forwarder\n        _setFunctionDelay(bytes4(keccak256(\"addDepositPipe(address)\")), CONFIG_DELAY);\n\n        // Proxy upgrade functions\n        // ProxyAdmin (TransparentUpgradeable)\n        _setFunctionDelay(bytes4(keccak256(\"upgradeAndCall(address,address,bytes)\")), CONFIG_DELAY);\n        // UUPS\n        _setFunctionDelay(bytes4(keccak256(\"upgradeToAndCall(address,bytes)\")), CONFIG_DELAY);\n\n        // Parameter changes\n        _setFunctionDelay(bytes4(keccak256(\"setStrategist(address)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setFeeReceiver(address)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setDepositFee(uint256)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRecoveryDelay(uint256)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setTreasury(address)\")), PARAMETER_DELAY);\n\n        // Token recovery\n        _setFunctionDelay(bytes4(keccak256(\"recoverToken(address,address,uint256)\")), RECOVERY_DELAY);\n\n        // Timelock configuration functions - self-referential protection\n        _setFunctionDelay(bytes4(keccak256(\"setFunctionDelay(bytes4,uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setDefaultFunctionDelay(uint256)\")), CONFIG_DELAY);\n    }\n    /**\n     * @notice Get suggested delay for a function\n     * @param data Function call data\n     * @return Suggested delay in seconds\n     */\n    function _getDelay(bytes calldata data) internal view returns (uint256) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n\n        if (data.length < 4) return $.defaultFunctionDelay;\n\n        bytes4 selector = bytes4(data[:4]);\n        uint256 functionDelay = $.functionDelays[selector];\n\n        // Return specific delay if explicitly configured, otherwise default delay\n        return $.hasExplicitDelay[selector] ? functionDelay : $.defaultFunctionDelay;\n    }\n\n    /**\n     * @notice Get suggested delay for a function (external version)\n     * @param data Function call data\n     * @return Suggested delay in seconds\n     */\n    function getDelay(bytes calldata data) external view returns (uint256) {\n        return _getDelay(data);\n    }\n\n    /**\n     * @notice Schedule operation with automatic delay detection\n     * @param target Target contract\n     * @param value ETH value\n     * @param data Function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     * @return Operation ID\n     */\n    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt)\n        external\n        returns (bytes32)\n    {\n        require(hasRole(PROPOSER_ROLE, msg.sender), \"VaultTimelock: not proposer\");\n\n        uint256 delay = _getDelay(data);\n\n        // Calculate operation ID and schedule\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        super.schedule(target, value, data, predecessor, salt, delay);\n\n        bytes4 selector = data.length >= 4 ? bytes4(data[:4]) : bytes4(0);\n        emit OperationScheduledWithAutoDelay(id, target, selector, delay);\n\n        return id;\n    }\n\n    /**\n     * @notice Schedule multiple operations with automatic delay detection\n     * @param targets Array of target contracts\n     * @param values Array of ETH values\n     * @param payloads Array of function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     * @return Operation ID for the batch\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external returns (bytes32) {\n        require(hasRole(PROPOSER_ROLE, msg.sender), \"VaultTimelock: not proposer\");\n        uint256 length = targets.length;\n        require(length == values.length, \"VaultTimelock: length mismatch\");\n        require(length == payloads.length, \"VaultTimelock: length mismatch\");\n        require(length > 0, \"VaultTimelock: empty batch\");\n\n        // Calculate the maximum delay required for all operations\n        uint256 maxDelay = 0;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 operationDelay = _getDelay(payloads[i]);\n            if (operationDelay > maxDelay) {\n                maxDelay = operationDelay;\n            }\n        }\n\n        // Schedule the batch with the maximum delay\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        super.scheduleBatch(targets, values, payloads, predecessor, salt, maxDelay);\n\n        // Emit events for each operation in the batch\n        for (uint256 i = 0; i < length; i++) {\n            bytes4 selector = payloads[i].length >= 4 ? bytes4(payloads[i][:4]) : bytes4(0);\n            emit OperationScheduledWithAutoDelay(id, targets[i], selector, maxDelay);\n        }\n\n        return id;\n    }\n\n    /**\n     * @notice Execute operation with automatic delay verification\n     * @param target Target contract\n     * @param value ETH value\n     * @param data Function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     */\n    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt)\n        public\n        payable\n        override\n    {\n        require(hasRole(EXECUTOR_ROLE, msg.sender), \"VaultTimelock: not executor\");\n\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        require(isOperationReady(id), \"VaultTimelock: operation not ready\");\n\n        super.execute(target, value, data, predecessor, salt);\n\n        bytes4 selector = data.length >= 4 ? bytes4(data[:4]) : bytes4(0);\n        emit OperationExecuted(id, target, selector);\n    }\n\n    /**\n     * @notice Execute multiple operations with automatic delay verification\n     * @param targets Array of target contracts\n     * @param values Array of ETH values\n     * @param payloads Array of function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable override {\n        require(hasRole(EXECUTOR_ROLE, msg.sender), \"VaultTimelock: not executor\");\n        uint256 length = targets.length;\n        require(length == values.length, \"VaultTimelock: length mismatch\");\n        require(length == payloads.length, \"VaultTimelock: length mismatch\");\n        require(length > 0, \"VaultTimelock: empty batch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        require(isOperationReady(id), \"VaultTimelock: operation not ready\");\n\n        super.executeBatch(targets, values, payloads, predecessor, salt);\n\n        emit OperationBatchExecuted(id, length);\n    }\n\n    /**\n     * @notice Set delay for a specific function\n     * @dev Must be called through the timelock itself (via schedule/execute) to enforce the configured delay\n     * @param selector Function selector\n     * @param delay Delay in seconds\n     */\n    function setFunctionDelay(bytes4 selector, uint256 delay) external {\n        require(msg.sender == address(this), \"VaultTimelock: must call through timelock\");\n        require(delay >= MIN_FUNCTION_DELAY, \"VaultTimelock: delay too short\");\n        require(delay <= MAX_DELAY, \"VaultTimelock: delay too long\");\n\n        _updateFunctionDelay(selector, delay);\n        emit FunctionDelaySet(selector, delay);\n    }\n\n    /**\n     * @notice Update default delay for unconfigured functions\n     * @dev Must be called through the timelock itself (via schedule/execute) to enforce the configured delay\n     * @param newDefaultDelay New default delay in seconds\n     */\n    function setDefaultFunctionDelay(uint256 newDefaultDelay) external {\n        require(msg.sender == address(this), \"VaultTimelock: must call through timelock\");\n        require(newDefaultDelay >= MIN_DEFAULT_DELAY, \"VaultTimelock: default delay too short\");\n        require(newDefaultDelay <= MAX_DELAY, \"VaultTimelock: default delay too long\");\n\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        require(newDefaultDelay != $.defaultFunctionDelay, \"VaultTimelock: same default delay\");\n\n        $.defaultFunctionDelay = newDefaultDelay;\n        emit DefaultDelayUpdated(newDefaultDelay);\n    }\n\n    /**\n     * @notice Internal helper to set function delay and mark as explicit\n     * @dev Reverts if a delay is already explicitly set for the selector to prevent collisions\n     * @param selector Function selector\n     * @param delay Delay in seconds\n     */\n    function _setFunctionDelay(bytes4 selector, uint256 delay) internal {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        require(!$.hasExplicitDelay[selector], \"VaultTimelock: Selector collision detected\");\n        $.functionDelays[selector] = delay;\n        $.hasExplicitDelay[selector] = true;\n    }\n\n    /**\n     * @notice Internal helper to update function delay (allows overwriting existing delay)\n     * @param selector Function selector\n     * @param delay Delay in seconds\n     */\n    function _updateFunctionDelay(bytes4 selector, uint256 delay) internal {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        $.functionDelays[selector] = delay;\n        $.hasExplicitDelay[selector] = true;\n    }\n}\n"
    }
}