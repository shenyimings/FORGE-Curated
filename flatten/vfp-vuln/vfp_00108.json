{
    "vfp_id": "vfp_00108",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Unvalidated _vault address in VaultAdapter allows interest rate manipulation",
            "description": "The rate function in VaultAdapter accepts any _vault address without validation and makes external calls to it. An attacker can pass a malicious contract that returns manipulated utilization values, which are then stored and used in interest rate calculations. The root cause is the lack of access control or allowlist validation on the _vault parameter. This allows an attacker to inflate or deflate interest rates across the protocol. The impact is financial loss for borrowers or lenders due to incorrect interest accrual, and potential manipulation of the entire lending market.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::rate#26-49",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultAdapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../../access/Access.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\nimport { IVaultAdapter } from \"../../interfaces/IVaultAdapter.sol\";\nimport { VaultAdapterStorageUtils } from \"../../storage/VaultAdapterStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Vault Adapter\n/// @author kexley, @capLabs\n/// @notice Market rates are sourced from the Vault\ncontract VaultAdapter is IVaultAdapter, UUPSUpgradeable, Access, VaultAdapterStorageUtils {\n    /// @notice Initialize the vault adapter with the access control\n    /// @param _accessControl Access control\n    function initialize(address _accessControl) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Fetch borrow rate for an asset from the Vault\n    /// @param _vault Vault address\n    /// @param _asset Asset to fetch rate for\n    /// @return latestAnswer Borrow rate\n    function rate(address _vault, address _asset) external returns (uint256 latestAnswer) {\n        VaultAdapterStorage storage $ = getVaultAdapterStorage();\n\n        uint256 elapsed;\n        uint256 utilization;\n        if (block.timestamp > $.utilizationData[_asset].lastUpdate) {\n            uint256 index = IVault(_vault).currentUtilizationIndex(_asset);\n            elapsed = block.timestamp - $.utilizationData[_asset].lastUpdate;\n\n            /// Use average utilization except on the first rate update\n            if (elapsed != block.timestamp) {\n                utilization = (index - $.utilizationData[_asset].index) / elapsed;\n            } else {\n                utilization = IVault(_vault).utilization(_asset);\n            }\n\n            $.utilizationData[_asset].index = index;\n            $.utilizationData[_asset].lastUpdate = block.timestamp;\n        } else {\n            utilization = IVault(_vault).utilization(_asset);\n        }\n\n        latestAnswer = _applySlopes(_asset, utilization, elapsed);\n    }\n\n    /// @notice Set utilization slopes for an asset\n    /// @param _asset Asset address\n    /// @param _slopes Slope data\n    function setSlopes(address _asset, SlopeData memory _slopes) external checkAccess(this.setSlopes.selector) {\n        getVaultAdapterStorage().slopeData[_asset] = _slopes;\n    }\n\n    /// @notice Set limits for the utilization multiplier\n    /// @param _maxMultiplier Maximum slope multiplier\n    /// @param _minMultiplier Minimum slope multiplier\n    /// @param _rate Rate at which the multiplier shifts\n    function setLimits(uint256 _maxMultiplier, uint256 _minMultiplier, uint256 _rate)\n        external\n        checkAccess(this.setLimits.selector)\n    {\n        VaultAdapterStorage storage $ = getVaultAdapterStorage();\n        $.maxMultiplier = _maxMultiplier;\n        $.minMultiplier = _minMultiplier;\n        $.rate = _rate;\n    }\n\n    /// @dev Interest is applied according to where on the slope the current utilization is and the\n    /// multiplier depends on the duration and distance the utilization is from the kink point.\n    /// All utilization values, kinks, and multipliers are in ray (1e27)\n    /// @param _asset Asset address\n    /// @param _utilization Utilization ratio in ray (1e27)\n    /// @param _elapsed Length of time at the utilization\n    /// @return interestRate Interest rate in ray (1e27)\n    function _applySlopes(address _asset, uint256 _utilization, uint256 _elapsed)\n        internal\n        returns (uint256 interestRate)\n    {\n        VaultAdapterStorage storage $ = getVaultAdapterStorage();\n        SlopeData memory slopes = $.slopeData[_asset];\n        if (_utilization > slopes.kink) {\n            uint256 excess = _utilization - slopes.kink;\n            $.utilizationData[_asset].utilizationMultiplier *=\n                (1e27 + (1e27 * excess / (1e27 - slopes.kink)) * (_elapsed * $.rate / 1e27));\n\n            if ($.utilizationData[_asset].utilizationMultiplier > $.maxMultiplier) {\n                $.utilizationData[_asset].utilizationMultiplier = $.maxMultiplier;\n            }\n\n            interestRate = (slopes.slope0 + (slopes.slope1 * excess / 1e27))\n                * $.utilizationData[_asset].utilizationMultiplier / 1e27;\n        } else {\n            $.utilizationData[_asset].utilizationMultiplier /=\n                (1e27 + (1e27 * (slopes.kink - _utilization) / slopes.kink) * (_elapsed * $.rate / 1e27));\n\n            if ($.utilizationData[_asset].utilizationMultiplier < $.minMultiplier) {\n                $.utilizationData[_asset].utilizationMultiplier = $.minMultiplier;\n            }\n\n            interestRate =\n                (slopes.slope0 * _utilization / slopes.kink) * $.utilizationData[_asset].utilizationMultiplier / 1e27;\n        }\n    }\n\n    /// @dev Only admin is allowed to upgrade implementation\n    function _authorizeUpgrade(address) internal view override checkAccess(bytes4(0)) { }\n}\n"
    }
}