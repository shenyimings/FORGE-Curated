{
    "vfp_id": "vfp_00086",
    "project_name": "Enjoyoors EVM Vaults Security Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ]
            },
            "title": "Stuck Rebase Rewards Due to Internal Balance Tracking",
            "description": "The contract uses internal balance tracking via userSupply[token][msg.sender] += amount in the _deposit function of EnjoyoorsVaultDeposits, which only records the initial deposit amount. This design fails to account for rebasing tokens (e.g., stETH, aTokens) that automatically increase balances over time through protocol rewards. Because withdrawals are limited to the originally tracked amount, any additional tokens generated by rebasing are permanently locked in the contract. An attacker cannot directly exploit this, but all users depositing rebasing tokens will permanently lose accrued rewards. The impact is systemic and irreversible, leading to a Critical severity classification due to guaranteed loss of user funds over time.\n",
            "severity": "Critical",
            "location": [
                "EnjoyoorsVaultDeposits.sol::_deposit"
            ],
            "files": [
                "EnjoyoorsVault/contracts/vault/actions/EnjoyoorsVaultDeposits.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Absence of Fee-on-transfer Protection in _deposit Function",
            "description": "The _deposit function in EnjoyoorsVaultDeposits does not verify the actual amount of tokens received after a transfer, making it vulnerable to fee-on-transfer tokens. These tokens deduct a fee during transfer, so the contract receives less than the amount reported by the user. The contract, however, credits the full user-reported amount, leading to an imbalance where users are credited more than the contract holds. Over time, this discrepancy accumulates, eventually preventing the last depositor from withdrawing their funds due to insufficient contract balance. This breaks the intended economic model and could lead to denial of service for late users, warranting a Medium severity rating.\n",
            "severity": "Medium",
            "location": [
                "EnjoyoorsVaultDeposits.sol::_deposit"
            ],
            "files": [
                "EnjoyoorsVault/contracts/vault/actions/EnjoyoorsVaultDeposits.sol"
            ]
        }
    ],
    "affected_files": {
        "EnjoyoorsVaultDeposits.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.26;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../access/Access.sol';\nimport '../../libraries/Asserts.sol';\n\n/// @title Abstract contract with Enjoyoors vaults deposit functionality\nabstract contract EnjoyoorsVaultDeposits is Access {\n  using SafeERC20 for IERC20;\n  using Asserts for uint256;\n\n  /**\n   * @notice Emitted in case of successful deposit call\n   * @param token Token that was transferred into the vault\n   * @param user User who performed deposit\n   * @param amount Deposit amount\n   */\n  event Deposit(address indexed token, address indexed user, uint256 amount);\n\n  /**\n   * @notice Revert reason if deposit amount exceeds maximum token capitalization\n   * @param tillLimit Max deposit allowed\n   */\n  error ExceedsLimit(uint256 tillLimit);\n  /**\n   * @notice Revert reason if deposit doesn't surpass minimal allowed deposit amount\n   * @param minDeposit Minimal allowed deposit amount\n   */\n  error LessThanMinDeposit(uint256 minDeposit);\n\n  /**\n   * @notice Internal method with deposits implementation\n   * @param token Token to deposit. Token must be listed in vault\n   * @param amount Amount to deposit\n   */\n  function _deposit(address token, uint256 amount) internal onlyWhitelistedToken(token) whenDepositsNotPaused(token) {\n    uint256 minAllowedDeposit = minDeposit[token];\n    if (minAllowedDeposit == 0) amount.assertNotZeroAmount();\n    if (amount < minAllowedDeposit) revert LessThanMinDeposit(minAllowedDeposit);\n\n    uint256 tillLimit = supplyTillLimit[token];\n    if (amount > tillLimit) revert ExceedsLimit(tillLimit);\n\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    totalSupply[token] += amount;\n    userSupply[token][msg.sender] += amount;\n    supplyTillLimit[token] -= amount;\n\n    emit Deposit(token, msg.sender, amount);\n  }\n}\n"
    }
}