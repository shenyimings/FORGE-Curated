{
    "vfp_id": "vfp_00086",
    "project_name": "Vultisig - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Users lose pending rewards when depositing additional tokens",
            "description": "The Stake.sol contract uses a reward debt accounting system to track user rewards based on their staked amount and a global accRewardPerShare variable. When a user makes an additional deposit, the _deposit() function recalculates the user's rewardDebt using the updated staking amount without first accounting for already accumulated pending rewards. This causes the previous rewardDebt to be overwritten with a value that includes the new deposit, effectively zeroing out any pending rewards the user had earned before the deposit. The root cause is the incorrect recalculation of rewardDebt instead of incrementing it based on the new deposit. An attacker could exploit this by repeatedly depositing and withdrawing to reset their reward debt and forfeit rewards, though the primary impact is on honest users who lose accrued rewards. The impact is loss of user rewards, undermining trust and fairness in the staking mechanism.\n",
            "severity": "High",
            "location": [
                "Stake.sol::189"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "Absence of minimum staking duration enables risk-free reward theft",
            "description": "The Stake.sol contract allows users to deposit and withdraw tokens without any minimum staking duration, enabling flash loan attacks to extract rewards. When minRewardUpdateDelay is 0 or can be triggered, an attacker can flash loan a large amount of VULT tokens, deposit them to become the dominant staker, trigger a reward update (e.g., via sweep() or by front-running a reward transfer), and immediately withdraw, capturing a disproportionate share of the rewards. The root cause is the lack of a time-based lock on staked funds, combined with the reward distribution logic that updates based on current stake without considering deposit timing. This allows for risk-free exploitation using flash loans, with the cost limited to gas and flash loan fees. The impact is theft of rewards from legitimate long-term stakers, undermining the fairness and economic model of the staking system.\n",
            "severity": "Medium",
            "location": [
                "Stake.sol"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        }
    ],
    "affected_files": {
        "Stake.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IERC1363Spender.sol\";\nimport \"./StakeSweeper.sol\";\n\n/**\n * @title Stake\n * @dev Contract for staking VULT tokens that distributes USDC rewards\n * Adapted from Sushiswap's Masterchef rewardDebt methodology\n * Users can deposit tokens in one transaction using approveAndCall\n * and claim their USDC rewards pro-rata to their stake.\n * Owner can withdraw unclaimed USDC and extra staking tokens.\n */\ncontract Stake is IERC1363Spender, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ================= Events =================\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event ForceWithdrawn(address indexed user, uint256 amount);\n    event RewardsUpdated(uint256 newAccRewardPerShare, uint256 rewardAmount);\n    event OwnerWithdrawnRewards(uint256 amount);\n    event OwnerWithdrawnExtraTokens(uint256 amount);\n    event TokenSwept(address indexed token, uint256 amountIn, uint256 amountOut);\n    event SweeperSet(address indexed sweeper);\n    event Migrated(address indexed user, address indexed newContract, uint256 amount);\n    event RewardDecayFactorSet(uint256 newFactor);\n    event MinRewardUpdateDelaySet(uint256 newDelay);\n    event Reinvested(address indexed user, uint256 rewardAmount, uint256 stakingTokensReceived);\n    event MinOutPercentageSet(uint8 percentage);\n\n    // ================= State Variables =================\n    /// @notice User staking information\n    struct UserInfo {\n        uint256 amount; // How many tokens the user has staked\n        uint256 rewardDebt; // Reward debt as per Masterchef logic\n    }\n\n    /// @notice Scaling factor for reward per share calculations\n    uint128 constant REWARD_DECAY_FACTOR_SCALING = 1e26;\n\n    /// @notice VULT token being staked\n    IERC20 public immutable stakingToken;\n\n    /// @notice USDC token for rewards\n    IERC20 public immutable rewardToken;\n\n    /// @notice Sweeper contract for sweeping tokens\n    StakeSweeper public sweeper;\n\n    /// @notice Accumulated reward tokens per share, scaled by REWARD_DECAY_FACTOR_SCALING\n    uint256 public accRewardPerShare;\n\n    /// @notice Last processed reward balance\n    uint256 public lastRewardBalance;\n\n    /// @notice Total tokens staked\n    uint256 public totalStaked;\n\n    /// @notice Last time rewards were updated\n    uint256 public lastRewardUpdateTime;\n\n    /// @notice Decay factor for releasing rewards (default is 10 = 10%)\n    uint256 public rewardDecayFactor = 10;\n\n    /// @notice Minimum time between reward updates in seconds (default is 1 day)\n    uint256 public minRewardUpdateDelay = 1 days;\n\n    /// @notice Mapping of user address to their staking info\n    mapping(address => UserInfo) public userInfo;\n\n    /**\n     * @dev Constructor sets the staking and reward tokens\n     * @param _stakingToken Address of the ERC20 token that can be staked (VULT)\n     * @param _rewardToken Address of the ERC20 token used for rewards (USDC)\n     */\n    constructor(address _stakingToken, address _rewardToken) Ownable(msg.sender) {\n        require(_stakingToken != address(0), \"Stake: staking token is the zero address\");\n        require(_rewardToken != address(0), \"Stake: reward token is the zero address\");\n\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**\n     * @dev Update reward variables with current token balances\n     * Must be called before any deposit or withdrawal\n     * Includes decay function to gradually release rewards\n     */\n    function updateRewards() public {\n        _updateRewards();\n    }\n\n    /**\n     * @dev Internal function to handle reward updates based on configured parameters\n     * The owner can configure minRewardUpdateDelay and rewardDecayFactor to control behavior\n     */\n    function _updateRewards() internal {\n        if (totalStaked == 0) {\n            lastRewardUpdateTime = block.timestamp;\n            return;\n        }\n\n        uint256 currentRewardBalance = rewardToken.balanceOf(address(this));\n        bool timeDelayMet = (block.timestamp >= lastRewardUpdateTime + minRewardUpdateDelay);\n\n        // If there are new rewards and enough time has passed (or delay is set to 0)\n        if (currentRewardBalance > lastRewardBalance && (timeDelayMet || minRewardUpdateDelay == 0)) {\n            uint256 totalNewRewards = currentRewardBalance - lastRewardBalance;\n\n            // Apply decay factor (if decay factor is 1, all rewards are released)\n            uint256 releasedRewards = rewardDecayFactor == 1 ? totalNewRewards : totalNewRewards / rewardDecayFactor;\n\n            // Update accRewardPerShare based on released rewards\n            // Scaled by REWARD_DECAY_FACTOR_SCALING to avoid precision loss when dividing small numbers\n            accRewardPerShare += (releasedRewards * REWARD_DECAY_FACTOR_SCALING) / totalStaked;\n\n            // Update the last reward balance - only account for released rewards\n            lastRewardBalance += releasedRewards;\n\n            // Update the last update time\n            lastRewardUpdateTime = block.timestamp;\n\n            emit RewardsUpdated(accRewardPerShare, releasedRewards);\n        }\n    }\n\n    /**\n     * @dev Returns pending rewards for a user\n     * @param _user Address of the user\n     * @return Pending reward amount\n     */\n    function pendingRewards(address _user) public view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        if (user.amount == 0 || totalStaked == 0) {\n            return 0;\n        }\n\n        uint256 currentRewardBalance = rewardToken.balanceOf(address(this));\n        uint256 additionalRewards = 0;\n        uint256 newAccRewardPerShare = accRewardPerShare;\n\n        // Check if there are additional rewards\n        if (currentRewardBalance > lastRewardBalance && totalStaked > 0) {\n            uint256 totalNewRewards = currentRewardBalance - lastRewardBalance;\n\n            // Apply decay and time check based on configured parameters\n            if (block.timestamp >= lastRewardUpdateTime + minRewardUpdateDelay || minRewardUpdateDelay == 0) {\n                // Apply decay - only consider a fraction of the new rewards unless decay factor is 1\n                additionalRewards = rewardDecayFactor == 1 ? totalNewRewards : totalNewRewards / rewardDecayFactor;\n            }\n\n            if (additionalRewards > 0) {\n                newAccRewardPerShare += (additionalRewards * REWARD_DECAY_FACTOR_SCALING) / totalStaked;\n            }\n        }\n\n        // Calculate pending rewards using the formula:\n        return (user.amount * newAccRewardPerShare) / REWARD_DECAY_FACTOR_SCALING - user.rewardDebt;\n    }\n\n    /**\n     * @dev Internal function to handle deposits, used by both normal deposits and approveAndCall\n     * @param _depositor Address transferring the tokens (may be different from _user in some cases)\n     * @param _user Address to attribute the deposit to\n     * @param _amount Amount of tokens to deposit\n     */\n    function _deposit(address _depositor, address _user, uint256 _amount) internal {\n        // Update reward variables\n        updateRewards();\n\n        // Get user info\n        UserInfo storage user = userInfo[_user];\n\n        // Transfer tokens from the depositor to this contract\n        stakingToken.safeTransferFrom(_depositor, address(this), _amount);\n\n        // Update user staking amount\n        user.amount += _amount;\n        totalStaked += _amount;\n\n        // Update user reward debt\n        user.rewardDebt = (user.amount * accRewardPerShare) / REWARD_DECAY_FACTOR_SCALING;\n\n        emit Deposited(_user, _amount);\n    }\n\n    /**\n     * @dev Allows an approved sender to deposit tokens on behalf of another user\n     * This is particularly useful for migration between staking contracts\n     * Sender must approve tokens first\n     * @param _user Address of the user to attribute the deposit to\n     * @param _amount Amount of tokens to deposit\n     * @return Amount of tokens deposited\n     */\n    function depositForUser(address _user, uint256 _amount) public nonReentrant returns (uint256) {\n        require(_amount > 0, \"Stake: amount must be greater than 0\");\n        require(_user != address(0), \"Stake: user is the zero address\");\n\n        _deposit(msg.sender, _user, _amount);\n        return _amount;\n    }\n\n    /**\n     * @dev Allows a user to deposit tokens without using approveAndCall\n     * User must approve tokens first\n     * @param amount Amount of tokens to deposit\n     * @return Amount of tokens deposited\n     */\n    function deposit(uint256 amount) external returns (uint256) {\n        // Simply call depositForUser with msg.sender as the user\n        return depositForUser(msg.sender, amount);\n    }\n\n    /**\n     * @dev Claims USDC rewards for the caller\n     * @return Amount of rewards claimed\n     */\n    function claim() public nonReentrant returns (uint256) {\n        return _claim(msg.sender);\n    }\n\n    /**\n     * @dev Internal function for claiming rewards\n     * This is used by functions that already have nonReentrant modifier\n     * @param _recipient Address to receive the claimed rewards\n     * @return Amount of rewards claimed\n     */\n    function _claim(address _recipient) internal returns (uint256) {\n        // Update rewards first to ensure all pending rewards are accounted for\n        updateRewards();\n\n        // Claim rewards internally and get the amount\n        uint256 rewardAmount = _claimRewards(msg.sender);\n\n        if (rewardAmount > 0) {\n            // Transfer the tokens to the recipient\n            rewardToken.safeTransfer(_recipient, rewardAmount);\n            emit RewardClaimed(msg.sender, rewardAmount);\n        }\n\n        return rewardAmount;\n    }\n\n    /**\n     * @dev Internal function to handle token withdrawals\n     * @param _user Address of the user withdrawing tokens\n     * @param _amount Amount of tokens to withdraw\n     * @param _shouldClaimRewards Whether to claim rewards before withdrawing\n     */\n    function _withdraw(address _user, uint256 _amount, bool _shouldClaimRewards) internal {\n        UserInfo storage user = userInfo[_user];\n        require(user.amount >= _amount, \"Stake: insufficient balance\");\n\n        // Claim rewards if requested\n        if (_shouldClaimRewards) {\n            _claim(_user);\n        } else {\n            // If not claiming rewards, still update reward variables\n            updateRewards();\n        }\n\n        // Update user staking amount\n        user.amount -= _amount;\n        totalStaked -= _amount;\n\n        // Update reward debt\n        user.rewardDebt = (user.amount * accRewardPerShare) / REWARD_DECAY_FACTOR_SCALING;\n\n        // Transfer staking tokens back to the user\n        stakingToken.safeTransfer(_user, _amount);\n    }\n\n    /**\n     * @dev Allows a user to withdraw their staked tokens after claiming rewards\n     * @param amount Amount of tokens to withdraw\n     */\n    function withdraw(uint256 amount) external nonReentrant {\n        require(amount > 0, \"Stake: amount must be greater than 0\");\n\n        _withdraw(msg.sender, amount, true);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     * @dev Emergency withdraw without claiming rewards\n     * @param amount Amount of tokens to withdraw\n     */\n    function forceWithdraw(uint256 amount) external nonReentrant {\n        require(amount > 0, \"Stake: amount must be greater than 0\");\n\n        _withdraw(msg.sender, amount, false);\n        emit ForceWithdrawn(msg.sender, amount);\n    }\n\n    /**\n     * @dev Implementation of IERC1363Spender onApprovalReceived to handle approveAndCall\n     * This function is called when a user calls approveAndCall on the token contract\n     * @param owner The address which called approveAndCall function and approved the tokens\n     * @param value The amount of tokens to be spent\n     * @return bytes4 The function selector to confirm the transaction is accepted\n     */\n    function onApprovalReceived(address owner, uint256 value, bytes calldata /* data */ )\n        external\n        override\n        returns (bytes4)\n    {\n        require(msg.sender == address(stakingToken), \"Stake: caller is not the staking token\");\n        require(value > 0, \"Stake: amount must be greater than 0\");\n\n        _deposit(owner, owner, value);\n\n        // Return the function selector to confirm transaction was accepted\n        return IERC1363Spender.onApprovalReceived.selector;\n    }\n\n    /**\n     * @dev Migrates user's entire stake to a new staking contract\n     * This function will:\n     * 1. Claim all pending rewards first\n     * 2. Withdraw all staked tokens\n     * 3. Approve the new staking contract to spend the tokens\n     * 4. Use depositForUser in the new contract to deposit on behalf of the user\n     * All in a single transaction\n     * @param _newStakingContract Address of the new Stake contract to migrate to\n     * @return migratedAmount Amount of tokens migrated to the new contract\n     */\n    function migrate(address _newStakingContract) external nonReentrant returns (uint256) {\n        require(_newStakingContract != address(0), \"Stake: new contract is the zero address\");\n        require(_newStakingContract != address(this), \"Stake: cannot migrate to self\");\n\n        address userAddress = msg.sender;\n\n        // Ensure the target is a valid Stake contract with the same staking token\n        Stake newStakingContract = Stake(_newStakingContract);\n        require(\n            address(newStakingContract.stakingToken()) == address(stakingToken), \"Stake: incompatible staking token\"\n        );\n\n        // Get user's current staked amount\n        UserInfo storage user = userInfo[userAddress];\n        uint256 stakedAmount = user.amount;\n        require(stakedAmount > 0, \"Stake: no tokens to migrate\");\n\n        // 1. Claim all pending rewards\n        _claim(userAddress);\n\n        // 2. Withdraw all staked tokens\n        // Update user staking amount\n        user.amount = 0;\n        totalStaked -= stakedAmount;\n\n        // Update reward debt\n        user.rewardDebt = 0;\n\n        // 3. Approve the new contract to spend our tokens (staking tokens are now in this contract)\n        stakingToken.approve(_newStakingContract, stakedAmount);\n\n        // 4. Call depositForUser on the new contract to deposit directly with proper attribution\n        bool migrationSuccess = false;\n        try newStakingContract.depositForUser(userAddress, stakedAmount) {\n            migrationSuccess = true;\n        } catch {\n            // If the depositForUser call fails, we need to transfer tokens back to the user\n            migrationSuccess = false;\n        }\n\n        if (!migrationSuccess) {\n            // If migration failed, return tokens to the user's wallet\n            stakingToken.safeTransfer(userAddress, stakedAmount);\n        }\n\n        // Clear the approval regardless of outcome\n        stakingToken.approve(_newStakingContract, 0);\n\n        // Emit events for withdrawal and migration\n        emit Withdrawn(userAddress, stakedAmount);\n        emit Migrated(userAddress, _newStakingContract, stakedAmount);\n\n        return stakedAmount;\n    }\n\n    /**\n     * @dev Sets the sweeper contract\n     * @param _sweeper The address of the sweeper contract to use\n     */\n    function setSweeper(address _sweeper) external onlyOwner {\n        require(_sweeper != address(0), \"Stake: sweeper is the zero address\");\n        sweeper = StakeSweeper(_sweeper);\n        emit SweeperSet(_sweeper);\n    }\n\n    /**\n     * @dev Sets the reward decay factor - determines what fraction of new rewards are released\n     * e.g. factor of 10 means 1/10 (10%) of rewards are released each update\n     * Setting factor to 1 releases all rewards at once (no decay)\n     * @param _newFactor The new decay factor (must be at least 1)\n     */\n    function setRewardDecayFactor(uint256 _newFactor) external onlyOwner {\n        require(_newFactor > 0, \"Stake: decay factor must be greater than 0\");\n        rewardDecayFactor = _newFactor;\n        emit RewardDecayFactorSet(_newFactor);\n    }\n\n    /**\n     * @dev Sets the minimum time between reward updates\n     * Setting to 0 means rewards can be updated at any time\n     * @param _newDelay The new minimum delay in seconds\n     */\n    function setMinRewardUpdateDelay(uint256 _newDelay) external onlyOwner {\n        minRewardUpdateDelay = _newDelay;\n        emit MinRewardUpdateDelaySet(_newDelay);\n    }\n\n    /**\n     * @dev Returns the staked amount for a user\n     * @param _user Address of the user\n     * @return The amount of tokens staked\n     */\n    function userAmount(address _user) external view returns (uint256) {\n        return userInfo[_user].amount;\n    }\n\n    /**\n     * @dev Sweeps a token from the contract and swaps it into the reward token using the sweeper contract\n     * @param _token Address of the token to sweep (can't be staking or reward token)\n     * @return The amount of reward tokens received from the swap\n     */\n    function sweep(address _token) external nonReentrant returns (uint256) {\n        require(address(sweeper) != address(0), \"Stake: sweeper not set\");\n        require(_token != address(stakingToken), \"Stake: cannot sweep staking token\");\n        require(_token != address(rewardToken), \"Stake: cannot sweep reward token\");\n\n        // Get the token balance\n        IERC20 token = IERC20(_token);\n        uint256 balance = token.balanceOf(address(this));\n        require(balance > 0, \"Stake: no tokens to sweep\");\n\n        // Transfer the token to the sweeper\n        token.safeTransfer(address(sweeper), balance);\n\n        // Execute the swap using our internal swap function\n        uint256 amountOut = sweeper.sweep(_token, address(this));\n\n        // Update the lastRewardBalance to account for the new rewards\n        updateRewards();\n\n        // Emit the sweep event\n        emit TokenSwept(_token, balance, amountOut);\n\n        return amountOut;\n    }\n\n    /**\n     * @dev Reinvests a user's rewards back into their stake\n     * 1. Claims rewards to this contract\n     * 2. Swaps reward tokens for staking tokens using Uniswap\n     * 3. Adds the new staking tokens to the user's stake\n     * @return stakingTokensReceived The amount of staking tokens received and reinvested\n     */\n    function reinvest() external nonReentrant returns (uint256) {\n        require(address(sweeper) != address(0), \"Stake: sweeper not set\");\n\n        address userAddress = msg.sender;\n\n        // Step 1: Update rewards to ensure all pending rewards are accounted for\n        updateRewards();\n\n        // Step 2: Check if user has pending rewards to reinvest\n        UserInfo storage user = userInfo[userAddress];\n        uint256 pending = (user.amount * accRewardPerShare) / REWARD_DECAY_FACTOR_SCALING - user.rewardDebt;\n        require(pending > 0, \"Stake: no rewards to reinvest\");\n\n        // Step 3: Claim rewards internally\n        uint256 rewardAmount = _claimRewards(userAddress);\n\n        // Emit RewardClaimed event\n        emit RewardClaimed(userAddress, rewardAmount);\n\n        // Transfer reward token to sweeper\n        rewardToken.safeTransfer(address(sweeper), rewardAmount);\n\n        // Check staking token balance before reinvest\n        uint256 stakingTokenBalanceBefore = stakingToken.balanceOf(address(this));\n\n        // Execute swap from reward tokens to staking tokens\n        sweeper.reinvest(address(stakingToken), address(this));\n\n        // Check staking token balance after reinvest\n        uint256 stakingTokenBalanceAfter = stakingToken.balanceOf(address(this));\n\n        uint256 stakingTokenBalanceDelta = stakingTokenBalanceAfter - stakingTokenBalanceBefore;\n\n        require(stakingTokenBalanceDelta > 0, \"Stake: swap did not yield any staking tokens\");\n\n        // Step 4: Re-use deposit logic to add tokens to user's stake\n        // No need to transfer tokens as they're already in this contract\n\n        // Update user staking amount\n        user.amount += stakingTokenBalanceDelta;\n        totalStaked += stakingTokenBalanceDelta;\n\n        // Update user reward debt\n        user.rewardDebt = (user.amount * accRewardPerShare) / REWARD_DECAY_FACTOR_SCALING;\n\n        emit Deposited(userAddress, stakingTokenBalanceDelta);\n        emit Reinvested(userAddress, rewardAmount, stakingTokenBalanceDelta);\n\n        return stakingTokenBalanceDelta;\n    }\n\n    /**\n     * @dev Internal function to claim rewards for a user\n     * @param _user Address of the user claiming rewards\n     * @return rewardAmount Amount of rewards claimed\n     */\n    function _claimRewards(address _user) internal returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 pending = (user.amount * accRewardPerShare) / REWARD_DECAY_FACTOR_SCALING - user.rewardDebt;\n\n        if (pending == 0) {\n            return 0;\n        }\n\n        // Check if we have enough reward token balance\n        uint256 currentRewardBalance = rewardToken.balanceOf(address(this));\n        uint256 rewardAmount = pending > currentRewardBalance ? currentRewardBalance : pending;\n\n        // Important: Update lastRewardBalance to track that these tokens are being claimed\n        lastRewardBalance -= rewardAmount;\n\n        // Update reward debt to reflect that rewards have been claimed\n        user.rewardDebt = (user.amount * accRewardPerShare) / REWARD_DECAY_FACTOR_SCALING;\n\n        return rewardAmount;\n    }\n}\n"
    }
}