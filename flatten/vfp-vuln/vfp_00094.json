{
    "vfp_id": "vfp_00094",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect integration of reserveVLF() and previewSync()",
            "description": "The `reserveVLF` function relies on `previewSync` to estimate the amount of assets that will be withdrawn during a sync operation. However, `previewSync` returns `min(totalAssetsOnRequest, totalAssetsOnReserve)`, while the actual `_sync` function withdraws up to `totalAssetsOnReserve` when there is excess. This discrepancy can cause `reserveVLF` to approve a withdrawal that exceeds the available idle funds in the VLF vault, leading to an underflow in `_vlfIdle` when `totalAssets` drops below `allocation`. This can permanently block `reserveVLF` and `allocateVLF` functions, disrupting liquidity management and potentially freezing funds.\n",
            "severity": "Medium",
            "location": [
                "AssetManager.sol#L217-L225",
                "ReclaimQueue.sol#L176-L180",
                "ReclaimQueue.sol#L545-L562"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/core/AssetManager.sol"
            ]
        }
    ],
    "affected_files": {
        "AssetManager.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { Time } from '@oz/utils/types/Time.sol';\nimport { AccessControlEnumerableUpgradeable } from '@ozu/access/extensions/AccessControlEnumerableUpgradeable.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { IAssetManager } from '../../interfaces/hub/core/IAssetManager.sol';\nimport { IAssetManagerEntrypoint } from '../../interfaces/hub/core/IAssetManagerEntrypoint.sol';\nimport { IHubAsset } from '../../interfaces/hub/core/IHubAsset.sol';\nimport { ITreasury } from '../../interfaces/hub/reward/ITreasury.sol';\nimport { IVLFVault } from '../../interfaces/hub/vlf/IVLFVault.sol';\nimport { IVLFVaultFactory } from '../../interfaces/hub/vlf/IVLFVaultFactory.sol';\nimport { Pausable } from '../../lib/Pausable.sol';\nimport { StdError } from '../../lib/StdError.sol';\nimport { Versioned } from '../../lib/Versioned.sol';\nimport { AssetManagerStorageV1 } from './AssetManagerStorageV1.sol';\n\ncontract AssetManager is\n  IAssetManager,\n  Pausable,\n  AccessControlEnumerableUpgradeable,\n  UUPSUpgradeable,\n  AssetManagerStorageV1,\n  Versioned\n{\n  // ============================ NOTE: ROLE DEFINITIONS ============================ //\n\n  /// @dev Role for managing liquidity thresholds and caps\n  bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256('LIQUIDITY_MANAGER_ROLE');\n\n  modifier onlyOwner() {\n    _checkRole(DEFAULT_ADMIN_ROLE);\n    _;\n  }\n\n  //=========== NOTE: INITIALIZATION FUNCTIONS ===========//\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address owner_, address treasury_) public initializer {\n    __Pausable_init();\n    __AccessControl_init();\n    __AccessControlEnumerable_init();\n    __UUPSUpgradeable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    _setTreasury(_getStorageV1(), treasury_);\n  }\n\n  //=========== NOTE: VIEW FUNCTIONS ===========//\n\n  function isOwner(address account) external view returns (bool) {\n    return hasRole(DEFAULT_ADMIN_ROLE, account);\n  }\n\n  function isLiquidityManager(address account) external view returns (bool) {\n    return hasRole(LIQUIDITY_MANAGER_ROLE, account);\n  }\n\n  //=========== NOTE: QUOTE FUNCTIONS ===========//\n\n  function quoteInitializeAsset(uint256 chainId, address branchAsset) external view returns (uint256) {\n    StorageV1 storage $ = _getStorageV1();\n    return $.entrypoint.quoteInitializeAsset(chainId, branchAsset);\n  }\n\n  function quoteInitializeVLF(uint256 chainId, address vlfVault, address branchAsset) external view returns (uint256) {\n    StorageV1 storage $ = _getStorageV1();\n    return $.entrypoint.quoteInitializeVLF(chainId, vlfVault, branchAsset);\n  }\n\n  function quoteWithdraw(uint256 chainId, address branchAsset, address to, uint256 amount)\n    external\n    view\n    returns (uint256)\n  {\n    StorageV1 storage $ = _getStorageV1();\n    return $.entrypoint.quoteWithdraw(chainId, branchAsset, to, amount);\n  }\n\n  function quoteAllocateVLF(uint256 chainId, address vlfVault, uint256 amount) external view returns (uint256) {\n    StorageV1 storage $ = _getStorageV1();\n    return $.entrypoint.quoteAllocateVLF(chainId, vlfVault, amount);\n  }\n\n  //=========== NOTE: ASSET FUNCTIONS ===========//\n\n  function deposit(uint256 chainId, address branchAsset, address to, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertBranchAssetPairExist($, chainId, branchAsset);\n\n    address hubAsset = _branchAssetState($, chainId, branchAsset).hubAsset;\n    amount = _scaleToHubDecimals(\n      amount, _hubAssetState($, hubAsset, chainId).branchAssetDecimals, IHubAsset(hubAsset).decimals()\n    );\n\n    _mint($, chainId, hubAsset, to, amount);\n\n    emit Deposited(chainId, hubAsset, to, amount);\n  }\n\n  function depositWithSupplyVLF(uint256 chainId, address branchAsset, address to, address vlfVault, uint256 amount)\n    external\n    whenNotPaused\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertBranchAssetPairExist($, chainId, branchAsset);\n    _assertVLFInitialized($, chainId, vlfVault);\n\n    // NOTE: We don't need to check if the vlfVault is registered instance of VLFVaultFactory\n\n    address hubAsset = _branchAssetState($, chainId, branchAsset).hubAsset;\n\n    amount = _scaleToHubDecimals(\n      amount, _hubAssetState($, hubAsset, chainId).branchAssetDecimals, IHubAsset(hubAsset).decimals()\n    );\n\n    uint256 supplyAmount = 0;\n\n    if (hubAsset != IVLFVault(vlfVault).asset()) {\n      // just transfer hubAsset if it's not the same as the VLFVault's asset\n      _mint($, chainId, hubAsset, to, amount);\n    } else {\n      _mint($, chainId, hubAsset, address(this), amount);\n\n      uint256 maxAssets = IVLFVault(vlfVault).maxDepositFromChainId(to, chainId);\n      supplyAmount = amount < maxAssets ? amount : maxAssets;\n\n      IHubAsset(hubAsset).approve(vlfVault, supplyAmount);\n      IVLFVault(vlfVault).depositFromChainId(supplyAmount, to, chainId);\n\n      // transfer remaining hub assets to `to` because there could be remaining hub assets due to the cap of VLFVault.\n      if (supplyAmount < amount) IHubAsset(hubAsset).transfer(to, amount - supplyAmount);\n    }\n\n    emit DepositedWithSupplyVLF(chainId, hubAsset, to, vlfVault, amount, supplyAmount);\n  }\n\n  function withdraw(uint256 chainId, address hubAsset, address to, uint256 amount) external payable whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(to != address(0), StdError.ZeroAddress('to'));\n    require(amount != 0, StdError.ZeroAmount());\n\n    address branchAsset = _hubAssetState($, hubAsset, chainId).branchAsset;\n    _assertBranchAssetPairExist($, chainId, branchAsset);\n\n    uint256 amountBranchUnit;\n    (amountBranchUnit, amount) = _scaleToBranchDecimals(\n      amount, _hubAssetState($, hubAsset, chainId).branchAssetDecimals, IHubAsset(hubAsset).decimals()\n    );\n\n    _assertBranchAvailableLiquiditySufficient($, hubAsset, chainId, amount);\n    _assertBranchLiquidityThresholdSatisfied($, hubAsset, chainId, amount);\n\n    _burn($, chainId, hubAsset, _msgSender(), amount);\n    $.entrypoint.withdraw{ value: msg.value }(chainId, branchAsset, to, amountBranchUnit);\n\n    emit Withdrawn(chainId, hubAsset, to, amount, amountBranchUnit);\n  }\n\n  //=========== NOTE: VLF FUNCTIONS ===========//\n\n  /// @dev only strategist\n  function allocateVLF(uint256 chainId, address vlfVault, uint256 amount) external payable whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyStrategist($, vlfVault);\n    _assertVLFInitialized($, chainId, vlfVault);\n\n    address hubAsset = IVLFVault(vlfVault).asset();\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, chainId);\n\n    uint256 amountBranchUnit;\n    (amountBranchUnit, amount) =\n      _scaleToBranchDecimals(amount, hubAssetState.branchAssetDecimals, IHubAsset(hubAsset).decimals());\n\n    uint256 idle = _vlfIdle($, vlfVault);\n    require(amount <= idle, IAssetManager__VLFLiquidityInsufficient(vlfVault));\n\n    $.entrypoint.allocateVLF{ value: msg.value }(chainId, vlfVault, amountBranchUnit);\n\n    _assertBranchAvailableLiquiditySufficient($, hubAsset, chainId, amount);\n    hubAssetState.branchAllocated += amount;\n    $.vlfStates[vlfVault].allocation += amount;\n\n    emit VLFAllocated(_msgSender(), chainId, vlfVault, amount, amountBranchUnit);\n  }\n\n  /// @dev only entrypoint\n  function deallocateVLF(uint256 chainId, address vlfVault, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n\n    address hubAsset = IVLFVault(vlfVault).asset();\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, chainId);\n\n    amount = _scaleToHubDecimals(amount, hubAssetState.branchAssetDecimals, IHubAsset(hubAsset).decimals());\n\n    hubAssetState.branchAllocated -= amount;\n    $.vlfStates[vlfVault].allocation -= amount;\n\n    emit VLFDeallocated(chainId, vlfVault, amount);\n  }\n\n  /// @dev only strategist\n  function reserveVLF(address vlfVault, uint256 claimCount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyStrategist($, vlfVault);\n\n    uint256 idle = _vlfIdle($, vlfVault);\n    (, uint256 simulatedTotalReservedAssets) = $.reclaimQueue.previewSync(vlfVault, claimCount);\n    require(simulatedTotalReservedAssets > 0, IAssetManager__NothingToVLFReserve(vlfVault));\n    require(simulatedTotalReservedAssets <= idle, IAssetManager__VLFLiquidityInsufficient(vlfVault));\n\n    (uint256 totalReservedShares, uint256 totalReservedAssets) = $.reclaimQueue.sync(_msgSender(), vlfVault, claimCount);\n\n    emit VLFReserved(_msgSender(), vlfVault, claimCount, totalReservedShares, totalReservedAssets);\n  }\n\n  /// @dev only entrypoint\n  function settleVLFYield(uint256 chainId, address vlfVault, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n\n    // Increase VLFVault's shares value.\n    address hubAsset = IVLFVault(vlfVault).asset();\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, chainId);\n\n    amount = _scaleToHubDecimals(amount, hubAssetState.branchAssetDecimals, IHubAsset(hubAsset).decimals());\n\n    _mint($, chainId, hubAsset, address(vlfVault), amount);\n\n    hubAssetState.branchAllocated += amount;\n    $.vlfStates[vlfVault].allocation += amount;\n\n    emit VLFRewardSettled(chainId, vlfVault, hubAsset, amount);\n  }\n\n  /// @dev only entrypoint\n  function settleVLFLoss(uint256 chainId, address vlfVault, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n\n    // Decrease VLFVault's shares value.\n    address hubAsset = IVLFVault(vlfVault).asset();\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, chainId);\n\n    amount = _scaleToHubDecimals(amount, hubAssetState.branchAssetDecimals, IHubAsset(hubAsset).decimals());\n\n    _burn($, chainId, hubAsset, vlfVault, amount);\n\n    hubAssetState.branchAllocated -= amount;\n    $.vlfStates[vlfVault].allocation -= amount;\n\n    emit VLFLossSettled(chainId, vlfVault, hubAsset, amount);\n  }\n\n  /// @dev only entrypoint\n  function settleVLFExtraRewards(uint256 chainId, address vlfVault, address branchReward, uint256 amount)\n    external\n    whenNotPaused\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertBranchAssetPairExist($, chainId, branchReward);\n    _assertTreasurySet($);\n\n    address hubAsset = _branchAssetState($, chainId, branchReward).hubAsset;\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, chainId);\n\n    amount = _scaleToHubDecimals(amount, hubAssetState.branchAssetDecimals, IHubAsset(hubAsset).decimals());\n\n    _mint($, chainId, hubAsset, address(this), amount);\n    emit VLFRewardSettled(chainId, vlfVault, hubAsset, amount);\n\n    IHubAsset(hubAsset).approve(address($.treasury), amount);\n    $.treasury.storeRewards(vlfVault, hubAsset, amount);\n  }\n\n  function setBranchLiquidityThreshold(uint256 chainId, address hubAsset, uint256 threshold)\n    external\n    onlyRole(LIQUIDITY_MANAGER_ROLE)\n  {\n    _setBranchLiquidityThreshold(_getStorageV1(), hubAsset, chainId, threshold);\n  }\n\n  function setBranchLiquidityThreshold(\n    uint256[] calldata chainIds,\n    address[] calldata hubAssets,\n    uint256[] calldata thresholds\n  ) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n    require(chainIds.length == hubAssets.length, StdError.InvalidParameter('hubAssets'));\n    require(chainIds.length == thresholds.length, StdError.InvalidParameter('thresholds'));\n\n    StorageV1 storage $ = _getStorageV1();\n    for (uint256 i = 0; i < chainIds.length; i++) {\n      _setBranchLiquidityThreshold($, hubAssets[i], chainIds[i], thresholds[i]);\n    }\n  }\n\n  //=========== NOTE: OWNABLE FUNCTIONS ===========//\n\n  function _authorizeUpgrade(address) internal override onlyOwner { }\n\n  function _authorizePause(address) internal view override onlyOwner { }\n\n  function initializeAsset(uint256 chainId, address hubAsset) external payable onlyOwner whenNotPaused {\n    _assertOnlyContract(hubAsset, 'hubAsset');\n\n    StorageV1 storage $ = _getStorageV1();\n\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, chainId);\n    address branchAsset = hubAssetState.branchAsset;\n    uint8 branchAssetDecimals = hubAssetState.branchAssetDecimals;\n    _assertBranchAssetPairExist($, chainId, branchAsset);\n\n    $.entrypoint.initializeAsset{ value: msg.value }(chainId, branchAsset);\n    emit AssetInitialized(hubAsset, chainId, branchAsset, branchAssetDecimals);\n  }\n\n  function initializeVLF(uint256 chainId, address vlfVault) external payable onlyOwner whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n    _assertVLFVaultFactorySet($);\n    _assertVLFVaultInstance($, vlfVault);\n\n    address hubAsset = IVLFVault(vlfVault).asset();\n    address branchAsset = _hubAssetState($, hubAsset, chainId).branchAsset;\n    _assertBranchAssetPairExist($, chainId, branchAsset);\n\n    _assertVLFNotInitialized($, chainId, vlfVault);\n    $.vlfInitialized[chainId][vlfVault] = true;\n\n    $.entrypoint.initializeVLF{ value: msg.value }(chainId, vlfVault, branchAsset);\n    emit VLFInitialized(hubAsset, chainId, vlfVault, branchAsset);\n  }\n\n  function setAssetPair(address hubAsset, uint256 branchChainId, address branchAsset, uint8 branchAssetDecimals)\n    external\n    onlyOwner\n  {\n    StorageV1 storage $ = _getStorageV1();\n    _assertHubAssetFactorySet($);\n    _assertHubAssetInstance($, hubAsset);\n    _assertBranchAssetPairNotExist($, branchChainId, branchAsset);\n\n    require(IHubAsset(hubAsset).decimals() >= branchAssetDecimals, StdError.InvalidParameter('branchAssetDecimals'));\n\n    HubAssetState storage hubAssetState = _hubAssetState($, hubAsset, branchChainId);\n    hubAssetState.branchAsset = branchAsset;\n    hubAssetState.branchAssetDecimals = branchAssetDecimals;\n    _branchAssetState($, branchChainId, branchAsset).hubAsset = hubAsset;\n    emit AssetPairSet(hubAsset, branchChainId, branchAsset, branchAssetDecimals);\n  }\n\n  function setEntrypoint(address entrypoint_) external onlyOwner {\n    _setEntrypoint(_getStorageV1(), entrypoint_);\n  }\n\n  function setReclaimQueue(address reclaimQueue_) external onlyOwner {\n    _setReclaimQueue(_getStorageV1(), reclaimQueue_);\n  }\n\n  function setTreasury(address treasury_) external onlyOwner {\n    _setTreasury(_getStorageV1(), treasury_);\n  }\n\n  function setHubAssetFactory(address hubAssetFactory_) external onlyOwner {\n    _setHubAssetFactory(_getStorageV1(), hubAssetFactory_);\n  }\n\n  function setVLFVaultFactory(address vlfVaultFactory_) external onlyOwner {\n    _setVLFVaultFactory(_getStorageV1(), vlfVaultFactory_);\n  }\n\n  function setStrategist(address vlfVault, address strategist) external onlyOwner {\n    _setStrategist(_getStorageV1(), vlfVault, strategist);\n  }\n\n  //=========== NOTE: INTERNAL FUNCTIONS ===========//\n\n  function _scaleToHubDecimals(uint256 amountBranchUnit, uint8 branchAssetDecimals, uint8 hubAssetDecimals)\n    internal\n    pure\n    returns (uint256)\n  {\n    require(hubAssetDecimals >= branchAssetDecimals, StdError.NotSupported());\n    return amountBranchUnit * (10 ** (hubAssetDecimals - branchAssetDecimals));\n  }\n\n  function _scaleToBranchDecimals(uint256 amountHubUnit, uint8 branchAssetDecimals, uint8 hubAssetDecimals)\n    internal\n    pure\n    returns (uint256 amountBranchUnit, uint256 adjustedAmountHubUnit)\n  {\n    require(hubAssetDecimals >= branchAssetDecimals, StdError.NotSupported());\n    amountBranchUnit = amountHubUnit / (10 ** (hubAssetDecimals - branchAssetDecimals));\n    // Convert back to hub decimals for precision loss detection.\n    adjustedAmountHubUnit = amountBranchUnit * (10 ** (hubAssetDecimals - branchAssetDecimals));\n  }\n\n  function _mint(StorageV1 storage $, uint256 chainId, address asset, address account, uint256 amount) internal {\n    IHubAsset(asset).mint(account, amount);\n    _hubAssetState($, asset, chainId).branchLiquidity += amount;\n  }\n\n  function _burn(StorageV1 storage $, uint256 chainId, address asset, address account, uint256 amount) internal {\n    IHubAsset(asset).burn(account, amount);\n    _hubAssetState($, asset, chainId).branchLiquidity -= amount;\n  }\n\n  //=========== NOTE: ASSERTIONS ===========//\n\n  function _assertOnlyContract(address addr, string memory paramName) internal view {\n    require(addr.code.length > 0, StdError.InvalidParameter(paramName));\n  }\n\n  function _assertBranchAssetPairNotExist(StorageV1 storage $, uint256 chainId, address branchAsset) internal view {\n    require(\n      _branchAssetState($, chainId, branchAsset).hubAsset == address(0),\n      IAssetManagerStorageV1__BranchAssetPairNotExist(chainId, branchAsset)\n    );\n  }\n}\n"
    }
}