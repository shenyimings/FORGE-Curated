{
    "vfp_id": "vfp_00211",
    "project_name": "ackee-blockchain-let's-get-hai-new-core-features-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "User can claim all rewards, that StakingManager received from RewardPool",
            "description": "The StakingManager contract uses a reward accounting mechanism based on the `rewardIntegralFor` mapping to track per-user reward integrals. However, this mapping is only updated when users check their rewards via the `earned` function, not when they claim rewards via `getReward`. As a result, after claiming rewards, the integral remains unchanged, allowing a malicious user to repeatedly call `getReward` and drain all accumulated rewards from the StakingManager. This flaw stems from incorrect state management in the reward claiming logic. An attacker can exploit this by staking a minimal amount and repeatedly calling `getReward` after rewards are distributed, thereby claiming all available rewards before other legitimate stakers can claim theirs. The impact is severe, leading to complete loss of distributed rewards for honest users and undermining the fairness and integrity of the staking system.\n",
            "severity": "Critical",
            "location": [
                "StakingManager.sol::getReward",
                "StakingManager.sol::earned"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "User can inflate number of rewards by staking additional amount of rewards right before claiming them",
            "description": "The `StakingManager.sol` contract calculates rewards using the `rewardIntegral` and `rewardIntegralFor` variables, but it fails to update the `rewardIntegralFor` mapping before modifying the user's staked balance during stake or withdraw operations. This allows a user to manipulate the reward calculation by staking additional tokens just before claiming rewards. The root cause is incorrect ordering of operations in the reward calculation logic. An attacker can exploit this by staking a large amount of tokens right before claiming, thereby inflating their reward integral and receiving disproportionately high rewards. The impact is significant, as it can lead to substantial reward token inflation and financial loss for the protocol.\n",
            "severity": "Critical",
            "location": [
                "StakingManager.sol::stake",
                "StakingManager.sol::withdraw"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "stakeToken can be transferred to any other address while it is still assumed staked",
            "description": "The `StakingManager.sol` contract tracks staked balances using the `stakedBalances` mapping, but it does not update this mapping when a user transfers their `stakeToken`. This creates a logic flaw where a user can sell or transfer their staked tokens while still retaining their staked balance record. The root cause is the lack of integration between token transfer events and staking balance updates. An attacker could exploit this by staking tokens, transferring them to another address (e.g., via a DEX), and still claiming rewards based on the original staked amount. This could lead to reward inflation and unfair distribution, allowing malicious actors to collect more rewards than they are entitled to.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Miscalculation of rewardToken distribution after withdrawal initiation in StakingManager",
            "description": "When a user initiates a withdrawal, their tokens enter a cooldown period during which they should no longer earn rewards. However, the reward distribution calculation still includes the total supply of staking tokens, including those in cooldown. This causes an incorrect distribution where part of the reward pool is not allocated and remains stuck in the contract. The root cause is the failure to exclude tokens in the withdrawal process from the reward calculation. While the impact is partially mitigated by the `emergencyWithdrawReward` function, this flaw still leads to inefficient reward distribution and potential loss of rewards for honest users.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect reward calculation when reward token is the same as staking token",
            "description": "When the staking token (KITE) is also used as a reward token, the `StakingManager.sol` contract fails to distinguish between staked tokens and reward tokens in its accounting. This leads to an inflation of rewards because the reward calculation erroneously includes staked tokens in the reward pool. The root cause is the lack of separate accounting for staked and reward balances when the tokens are the same. An attacker can exploit this by staking tokens and then claiming rewards, receiving a much larger amount than deserved due to the flawed calculation. This results in unfair reward distribution and potential depletion of the reward pool.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        }
    ],
    "affected_files": {
        "StakingManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {IProtocolToken} from '@interfaces/tokens/IProtocolToken.sol';\nimport {IStakingToken} from '@interfaces/tokens/IStakingToken.sol';\n\nimport {IRewardPool} from '@interfaces/tokens/IRewardPool.sol';\n\nimport {IStakingManager} from '@interfaces/tokens/IStakingManager.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\n/**\n * @title  StakingManager\n * @notice This contract is used to manage staking positions\n *         and to distribute staking rewards\n */\ncontract StakingManager is Authorizable, Modifiable, IStakingManager {\n  using Encoding for bytes;\n  using Assertions for uint256;\n  using Assertions for address;\n  using SafeERC20 for IProtocolToken;\n  using SafeERC20 for IERC20;\n\n  // --- Registry ---\n\n  /// @inheritdoc IStakingManager\n  IProtocolToken public protocolToken;\n\n  /// @inheritdoc IStakingManager\n  IStakingToken public stakingToken;\n\n  // --- Params ---\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  StakingManagerParams public _params;\n\n  /// @inheritdoc IStakingManager\n  function params() external view returns (StakingManagerParams memory _stakingManagerParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IStakingManager\n  mapping(address => uint256) public stakedBalances;\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  mapping(address _account => PendingWithdrawal) public _pendingWithdrawals;\n\n  /// @inheritdoc IStakingManager\n  function pendingWithdrawals(address _account) external view returns (PendingWithdrawal memory _pendingWithdrawal) {\n    return _pendingWithdrawals[_account];\n  }\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  mapping(uint256 _id => RewardType) public _rewardTypes;\n\n  /// @inheritdoc IStakingManager\n  function rewardTypes(uint256 _id) external view returns (RewardTypeInfo memory _rewardTypeInfo) {\n    RewardType storage _rewardType = _rewardTypes[_id];\n    return RewardTypeInfo({\n      rewardToken: _rewardType.rewardToken,\n      rewardPool: _rewardType.rewardPool,\n      isActive: _rewardType.isActive,\n      rewardIntegral: _rewardType.rewardIntegral,\n      rewardRemaining: _rewardType.rewardRemaining\n    });\n  }\n\n  /// @inheritdoc IStakingManager\n  function rewardIntegralFor(uint256 _id, address _user) external view returns (uint256 _rewardIntegral) {\n    return _rewardTypes[_id].rewardIntegralFor[_user];\n  }\n\n  /// @inheritdoc IStakingManager\n  function claimableReward(uint256 _id, address _user) external view returns (uint256 _claimableReward) {\n    return _rewardTypes[_id].claimableReward[_user];\n  }\n\n  /// @inheritdoc IStakingManager\n  uint256 public rewards;\n\n  // --- Init ---\n\n  /**\n   * @param  _protocolToken Address of the ProtocolToken contract\n   * @param  _stakingToken Address of the StakingToken contract\n   * @param  _cooldownPeriod Address of the StakingToken contract\n   */\n  constructor(\n    address _protocolToken,\n    address _stakingToken,\n    uint256 _cooldownPeriod\n  ) Authorizable(msg.sender) validParams {\n    stakingToken = IStakingToken(_stakingToken);\n    protocolToken = IProtocolToken(_protocolToken);\n    _params.cooldownPeriod = _cooldownPeriod;\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IStakingManager\n  function stake(address _account, uint256 _wad) external {\n    if (_account == address(0)) revert StakingManager_StakeNullReceiver();\n    if (_wad == 0) revert StakingManager_StakeNullAmount();\n\n    stakedBalances[_account] += _wad;\n\n    // Mint stKITE\n    stakingToken.mint(_account, _wad);\n\n    // transfer KITE\n    protocolToken.safeTransferFrom(msg.sender, address(this), _wad);\n\n    // Call stake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.stake(_wad);\n      }\n    }\n\n    emit StakingManagerStaked(_account, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function initiateWithdrawal(uint256 _wad) external {\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n    stakedBalances[msg.sender] -= _wad;\n\n    if (_existingWithdrawal.amount != 0) {\n      _existingWithdrawal.amount += _wad;\n      _existingWithdrawal.timestamp = block.timestamp;\n    } else {\n      _pendingWithdrawals[msg.sender] = PendingWithdrawal({amount: _wad, timestamp: block.timestamp});\n    }\n\n    // Call decreaseStake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.decreaseStake(_wad);\n      }\n    }\n\n    emit StakingManagerWithdrawalInitiated(msg.sender, _wad);\n  }\n  /// @inheritdoc IStakingManager\n\n  function cancelWithdrawal() external {\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n\n    if (_existingWithdrawal.amount == 0) {\n      revert StakingManager_NoPendingWithdrawal();\n    }\n\n    uint256 _withdrawalAmount = _existingWithdrawal.amount; // Store the amount before deleting\n\n    delete _pendingWithdrawals[msg.sender];\n\n    stakedBalances[msg.sender] += _withdrawalAmount; // use stored amount\n\n    // Call increaseStake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.increaseStake(_withdrawalAmount);\n      }\n    }\n\n    emit StakingManagerWithdrawalCancelled(msg.sender, _withdrawalAmount);\n  }\n\n  /// @inheritdoc IStakingManager\n  function withdraw() external {\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n\n    if (_existingWithdrawal.amount == 0) {\n      revert StakingManager_NoPendingWithdrawal();\n    }\n\n    if (block.timestamp - _existingWithdrawal.timestamp < _params.cooldownPeriod) {\n      revert StakingManager_CooldownPeriodNotElapsed();\n    }\n\n    uint256 _withdrawalAmount = _existingWithdrawal.amount; // Store amount first\n\n    delete _pendingWithdrawals[msg.sender];\n\n    stakingToken.burnFrom(msg.sender, _withdrawalAmount);\n\n    protocolToken.safeTransfer(msg.sender, _withdrawalAmount);\n\n    emit StakingManagerWithdrawn(msg.sender, _withdrawalAmount);\n  }\n\n  /// @inheritdoc IStakingManager\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    protocolToken.safeTransfer(_rescueReceiver, _wad);\n\n    emit StakingManagerEmergencyWithdrawal(_rescueReceiver, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function emergencyWithdrawReward(uint256 _id, address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    IERC20(_rewardTypes[_id].rewardToken).safeTransfer(_rescueReceiver, _wad);\n\n    // protocolToken.safeTransfer(_rescueReceiver, _wad);\n\n    emit StakingManagerEmergencyRewardWithdrawal(_rescueReceiver, _rewardTypes[_id].rewardToken, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function getReward(address _account) external {\n    _checkpointAndClaim([_account, _account]);\n  }\n\n  /// @inheritdoc IStakingManager\n  function getRewardAndForward(address _account, address _forwardTo) external {\n    if (msg.sender != _account) revert StakingManager_ForwardingOnly();\n\n    _checkpointAndClaim([_account, _forwardTo]);\n  }\n\n  /// @inheritdoc IStakingManager\n  function addRewardType(address _rewardToken, address _rewardPool) external isAuthorized {\n    if (_rewardToken == address(0)) revert StakingManager_NullRewardToken();\n    if (_rewardPool == address(0)) revert StakingManager_NullRewardPool();\n\n    uint256 _id = rewards;\n    rewards++;\n\n    RewardType storage _rewardType = _rewardTypes[_id];\n    _rewardType.rewardToken = _rewardToken;\n    _rewardType.rewardPool = _rewardPool;\n    _rewardType.isActive = true;\n    _rewardType.rewardIntegral = 0;\n    _rewardType.rewardRemaining = 0;\n\n    emit StakingManagerAddRewardType(_id, _rewardToken, _rewardPool);\n  }\n\n  /// @inheritdoc IStakingManager\n  function activateRewardType(uint256 _id) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    _rewardTypes[_id].isActive = true;\n    emit StakingManagerActivateRewardType(_id);\n  }\n\n  /// @inheritdoc IStakingManager\n  function deactivateRewardType(uint256 _id) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    _rewardTypes[_id].isActive = false;\n    emit StakingManagerDeactivateRewardType(_id);\n  }\n\n  /// @inheritdoc IStakingManager\n  function earned(address _account) external returns (EarnedData[] memory _claimable) {\n    _checkpoint([_account, address(0)]);\n    return _earned(_account);\n  }\n\n  /// @inheritdoc IStakingManager\n  function checkpoint(address[2] memory _accounts) external {\n    _checkpoint(_accounts);\n  }\n\n  /// @inheritdoc IStakingManager\n  function userCheckpoint(address _account) external {\n    _checkpoint([_account, address(0)]);\n  }\n\n  function _earned(address _account) internal view returns (EarnedData[] memory _claimable) {\n    _claimable = new EarnedData[](rewards);\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n\n      if (_rewardType.rewardToken == address(0)) {\n        continue;\n      }\n\n      _claimable[_i].rewardToken = _rewardType.rewardToken;\n      _claimable[_i].rewardAmount = _rewardType.claimableReward[_account];\n    }\n    return _claimable;\n  }\n\n  // TODO: Check decimals\n  function _calcRewardIntegral(\n    uint256 _id,\n    address[2] memory _accounts,\n    uint256[2] memory _balances,\n    uint256 _supply,\n    bool _isClaim\n  ) internal {\n    RewardType storage _rewardType = _rewardTypes[_id];\n\n    if (!_rewardType.isActive) return;\n\n    uint256 _balance = IERC20(_rewardType.rewardToken).balanceOf(address(this));\n\n    // Checks if new rewards have been added by comparing current balance with rewardRemaining\n    if (_balance > _rewardType.rewardRemaining) {\n      uint256 _newRewards = _balance - _rewardType.rewardRemaining;\n      // If there are new rewards and there are existing stakers\n      if (_supply > 0) {\n        _rewardType.rewardIntegral += (_newRewards * 1e18) / _supply;\n        _rewardType.rewardRemaining = _balance;\n      }\n    }\n\n    for (uint256 _i = 0; _i < _accounts.length; _i++) {\n      if (_accounts[_i] == address(0)) continue;\n      if (_isClaim && _i != 0) continue; //only update/claim for first address and use second as forwarding\n\n      uint256 _userBalance = _balances[_i];\n      uint256 _userIntegral = _rewardType.rewardIntegralFor[_accounts[_i]];\n\n      if (_isClaim || _userIntegral < _rewardType.rewardIntegral) {\n        if (_isClaim) {\n          // Calculate total receiveable rewards\n          uint256 _receiveable = _rewardType.claimableReward[_accounts[_i]]\n            + (_userBalance * (_rewardType.rewardIntegral - _userIntegral)) / 1e18;\n\n          if (_receiveable > 0) {\n            // Reset claimable rewards to 0\n            _rewardType.claimableReward[_accounts[_i]] = 0;\n\n            // Transfer rewards to the next address in the array (forwarding address)\n            IERC20(_rewardType.rewardToken).safeTransfer(_accounts[_i + 1], _receiveable);\n\n            emit StakingManagerRewardPaid(_accounts[_i], _rewardType.rewardToken, _receiveable, _accounts[_i + 1]);\n            // Update the remaining balance\n            _balance = _balance - _receiveable;\n          }\n        } else {\n          // Just accumulate rewards without claiming\n          _rewardType.claimableReward[_accounts[_i]] = _rewardType.claimableReward[_accounts[_i]]\n            + (_userBalance * (_rewardType.rewardIntegral - _userIntegral)) / 1e18;\n\n          // Update user's reward integral\n          _rewardType.rewardIntegralFor[_accounts[_i]] = _rewardType.rewardIntegral;\n        }\n      }\n    }\n\n    // Update remaining reward here since balance could have changed if claiming\n    if (_balance != _rewardType.rewardRemaining) {\n      _rewardType.rewardRemaining = uint256(_balance);\n    }\n  }\n\n  function _checkpoint(address[2] memory _accounts) internal {\n    uint256 _supply = stakingToken.totalSupply();\n    uint256[2] memory _depositedBalance;\n    _depositedBalance[0] = stakingToken.balanceOf(_accounts[0]);\n    _depositedBalance[1] = stakingToken.balanceOf(_accounts[1]);\n\n    _claimManagerRewards();\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      _calcRewardIntegral(_i, _accounts, _depositedBalance, _supply, false);\n    }\n  }\n\n  function _checkpointAndClaim(address[2] memory _accounts) internal {\n    uint256 _supply = stakingToken.totalSupply();\n    uint256[2] memory _depositedBalance;\n    _depositedBalance[0] = stakingToken.balanceOf(_accounts[0]); //only do first slot\n\n    _claimManagerRewards();\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      _calcRewardIntegral(_i, _accounts, _depositedBalance, _supply, true);\n    }\n  }\n\n  function _claimManagerRewards() internal {\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n      if (!_rewardType.isActive) continue;\n      _rewardPool.getReward();\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    if (_param == 'cooldownPeriod') _params.cooldownPeriod = _uint256;\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    _params.cooldownPeriod.assertNonNull().assertGt(0);\n    address(stakingToken).assertHasCode();\n    address(protocolToken).assertHasCode();\n  }\n}\n"
    }
}