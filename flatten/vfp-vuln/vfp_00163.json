{
    "vfp_id": "vfp_00163",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Attacker can sandwich the call to BondingTax/:swapForAsset() in order to steal taxes",
            "description": "The BondingTax::swapForAsset function uses getAmountsOut to determine the minimum output for a swap but does not enforce it with slippage protection during the actual swap. Because the price query and swap are not atomic, an attacker can sandwich the swap by manipulating the pool state before and after the tax swap. The root cause is the lack of a minimum output enforcement in the swap call. The attacker profits by causing the protocol to receive fewer cbBTC than expected, effectively stealing part of the tax revenue. This leads to direct financial loss for the protocol and undermines the sustainability of the tax collection mechanism.\n",
            "severity": "Medium",
            "location": [
                "BondingTax.sol"
            ],
            "files": [
                "protocol-contracts/contracts/tax/BondingTax.sol"
            ]
        }
    ],
    "affected_files": {
        "BondingTax.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./IBondingTax.sol\";\nimport \"../pool/IRouter.sol\";\n\ncontract BondingTax is\n    Initializable,\n    AccessControlUpgradeable,\n    IBondingTax\n{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public assetToken;\n    address public taxToken;\n    IRouter public router;\n    address public bondingRouter;\n    address public treasury;\n    uint256 public minSwapThreshold;\n    uint256 public maxSwapThreshold;\n    uint16 private _slippage;\n\n    event SwapParamsUpdated(\n        address oldRouter,\n        address newRouter,\n        address oldBondingRouter,\n        address newBondingRouter,\n        address oldAsset,\n        address newAsset\n    );\n    event SwapThresholdUpdated(\n        uint256 oldMinThreshold,\n        uint256 newMinThreshold,\n        uint256 oldMaxThreshold,\n        uint256 newMaxThreshold\n    );\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\n    event SwapExecuted(uint256 taxTokenAmount, uint256 assetTokenAmount);\n    event SwapFailed(uint256 taxTokenAmount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    modifier onlyBondingRouter() {\n        require(_msgSender() == address(bondingRouter), \"Only bonding router\");\n        _;\n    }\n\n    function initialize(\n        address defaultAdmin_,\n        address assetToken_,\n        address taxToken_,\n        address router_,\n        address bondingRouter_,\n        address treasury_,\n        uint256 minSwapThreshold_,\n        uint256 maxSwapThreshold_\n    ) external initializer {\n        __AccessControl_init();\n\n        _grantRole(ADMIN_ROLE, defaultAdmin_);\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin_);\n        assetToken = assetToken_;\n        taxToken = taxToken_;\n        router = IRouter(router_);\n        bondingRouter = bondingRouter_;\n        treasury = treasury_;\n        minSwapThreshold = minSwapThreshold_;\n        maxSwapThreshold = maxSwapThreshold_;\n        IERC20(taxToken).forceApprove(router_, type(uint256).max);\n\n        _slippage = 100; // default to 1%\n    }\n\n    function updateSwapParams(\n        address router_,\n        address bondingRouter_,\n        address assetToken_,\n        uint16 slippage_\n    ) public onlyRole(ADMIN_ROLE) {\n        address oldRouter = address(router);\n        address oldBondingRouter = bondingRouter;\n        address oldAsset = assetToken;\n\n        assetToken = assetToken_;\n        router = IRouter(router_);\n        bondingRouter = bondingRouter_;\n        _slippage = slippage_;\n\n        IERC20(taxToken).forceApprove(router_, type(uint256).max);\n        IERC20(taxToken).forceApprove(oldRouter, 0);\n\n        emit SwapParamsUpdated(\n            oldRouter,\n            router_,\n            oldBondingRouter,\n            bondingRouter_,\n            oldAsset,\n            assetToken_\n        );\n    }\n\n    function updateSwapThresholds(\n        uint256 minSwapThreshold_,\n        uint256 maxSwapThreshold_\n    ) public onlyRole(ADMIN_ROLE) {\n        uint256 oldMin = minSwapThreshold;\n        uint256 oldMax = maxSwapThreshold;\n\n        minSwapThreshold = minSwapThreshold_;\n        maxSwapThreshold = maxSwapThreshold_;\n\n        emit SwapThresholdUpdated(\n            oldMin,\n            minSwapThreshold_,\n            oldMax,\n            maxSwapThreshold_\n        );\n    }\n\n    function updateTreasury(address treasury_) public onlyRole(ADMIN_ROLE) {\n        address oldTreasury = treasury;\n        treasury = treasury_;\n\n        emit TreasuryUpdated(oldTreasury, treasury_);\n    }\n\n    function withdraw(address token) external onlyRole(ADMIN_ROLE) {\n        IERC20(token).safeTransfer(\n            treasury,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function swapForAsset() public onlyBondingRouter returns (bool, uint256) {\n        uint256 amount = IERC20(taxToken).balanceOf(address(this));\n\n        require(amount > 0, \"Nothing to be swapped\");\n\n        if (amount < minSwapThreshold) {\n            return (false, 0);\n        }\n\n        if (amount > maxSwapThreshold) {\n            amount = maxSwapThreshold;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = taxToken;\n        path[1] = assetToken;\n\n        uint256[] memory amountsOut = router.getAmountsOut(amount, path);\n        require(amountsOut.length > 1, \"Failed to fetch token price\");\n\n        uint256 expectedOutput = amountsOut[1];\n        uint256 minOutput = (expectedOutput * (10000 - _slippage)) / 10000;\n\n        try\n            router.swapExactTokensForTokens(\n                amount,\n                minOutput,\n                path,\n                treasury,\n                block.timestamp + 300\n            )\n        returns (uint256[] memory amounts) {\n            emit SwapExecuted(amount, amounts[1]);\n            return (true, amounts[1]);\n        } catch {\n            emit SwapFailed(amount);\n            return (false, 0);\n        }\n    }\n}\n"
    }
}