{
    "vfp_id": "vfp_00163",
    "project_name": "Polygon Staking - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect minimum unbond quantity calculation",
            "description": "The vulnerability arises in the `unbond` function of the PolygonStrategy contract, where the condition for claiming rewards relies on a miscalculated `rewards` value. The `rewards` variable is derived from `getTotalDeposits() - getPrincipalDeposits()`, which includes `token.balanceOf(address(this))`â€”a value that can be arbitrarily inflated by an attacker via token donations. However, the upstream `ValidatorShare` contract's `minRewardClaimAmount` check only considers actual staking rewards, not external token balances. This discrepancy causes the local check to pass even when the upstream withdrawal would revert due to insufficient actual rewards.\n\nThe root cause is the incorrect inclusion of the contract's token balance in the rewards calculation, which does not align with the upstream contract's logic. An attacker can exploit this by front-running an `unbond` call and donating tokens to the vault, causing the `rewards >= vault.minRewardClaimAmount()` check to pass locally. However, when `vault.withdrawRewards()` is called, the upstream contract reverts due to insufficient actual rewards, causing the entire `unbond` transaction to fail.\n\nThe impact is that legitimate `unbond` requests can be permanently reverted if the attacker's donation keeps the balance above the threshold without triggering actual reward withdrawal. This leads to user inconvenience and potential need for governance intervention to resolve the stuck state.\n",
            "severity": "High",
            "location": [
                "PolygonStrategy.sol::unbond"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "The rewards quantity is not deducted if the unbond quantity is lesser",
            "description": "In the `unbond` function of the PolygonStrategy contract, when a vault's rewards are below the minimum claim threshold, the rewards are not deducted from the `toUnbondRemaining` amount even though they will be automatically claimed upon unbonding principal deposits. This occurs because the logic only subtracts rewards when `toUnbondRemaining > rewards`, but fails to account for cases where the `minRewardClaimAmount` condition fails. As a result, the function unbonds more principal than necessary.\n\nThe root cause is a flaw in the accounting logic that does not consistently treat reward claims during unbonding. The contract assumes that rewards are only claimed when explicitly withdrawn, but the upstream `ValidatorShare` contract automatically claims rewards when unstaking. This leads to a misalignment in expected vs. actual behavior.\n\nAn attacker or user could exploit this by structuring unbonding operations across multiple vaults to cause excess unbonding, which distorts the staking distribution and causes earlier-than-necessary unbonding of subsequent vaults. This could slightly reduce the overall rewards rate and disrupt the intended staking strategy.\n\nThe impact is a financial inefficiency and misallocation of staked assets, leading to suboptimal yield for users and potential imbalance in the staking pool distribution.\n",
            "severity": "Medium",
            "location": [
                "PolygonStrategy.sol::unbond"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "PolygonStrategy.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"../core/base/Strategy.sol\";\nimport \"../core/interfaces/IRewardsPool.sol\";\nimport \"./interfaces/IPolygonVault.sol\";\nimport \"./interfaces/IPolygonStakeManager.sol\";\n\n/**\n * @title Polygon Strategy\n * @notice Strategy for managing multiple Polygon staking vaults\n */\ncontract PolygonStrategy is Strategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Validator {\n        // address of validator shares pool\n        address pool;\n        // address to receive validator share of MEV rewards\n        address rewardsReceiver;\n    }\n\n    struct ValidatorRemoval {\n        // whether a validator is queued for removal\n        bool isActive;\n        // id of validator\n        uint64 validatorId;\n        // total queued withdrawals for validator\n        uint128 queuedWithdrawals;\n    }\n\n    struct Fee {\n        // address to recieve fee\n        address receiver;\n        // value of fee in basis points\n        uint256 basisPoints;\n    }\n\n    // list of fees that are paid on rewards\n    Fee[] private fees;\n\n    // address of polygon stake manager\n    address public stakeManager;\n    // address of fund flow controller\n    address public fundFlowController;\n\n    // address of MEV rewards pool\n    IRewardsPool public validatorMEVRewardsPool;\n    // percentage of MEV rewards validators will receive\n    uint256 public validatorMEVRewardsPercentage;\n\n    // list of validators\n    Validator[] private validators;\n    // list of vaults\n    IPolygonVault[] private vaults;\n    // address of vault implementation contract to be used when deploying new vaults\n    address public vaultImplementation;\n\n    // queued validator removal state\n    ValidatorRemoval public validatorRemoval;\n\n    // total number of tokens staked in this strategy\n    uint256 private totalDeposits;\n    // total number of tokens queued for deposit into vaults\n    uint256 public totalQueued;\n    // total number of vaults currently unbonding\n    uint256 public numVaultsUnbonding;\n    // index of validator to withdraw from on next withdrawal\n    uint256 public validatorWithdrawalIndex;\n\n    event DepositQueuedTokens(int256 balanceChange);\n    event Unbond(uint256 amount);\n    event ForceUnbond(uint256 amount);\n    event UnstakeClaim(uint256 amount);\n    event RestakeRewards();\n    event AddValidator(address indexed pool, address rewardsReceiver);\n    event QueueValidatorRemoval(address indexed pool, address rewardsReceiver);\n    event FinalizeValidatorRemoval(address indexed pool);\n    event UpgradedVaults(address[] vaults);\n    event AddFee(address receiver, uint256 feeBasisPoints);\n    event UpdateFee(uint256 index, address receiver, uint256 feeBasisPoints);\n    event RemoveFee(uint256 index, address receiver, uint256 feeBasisPoints);\n    event SetValidatorMEVRewardsPercentage(uint256 validatorMEVRewardsPercentage);\n    event SetVaultImplementation(address vaultImplementation);\n\n    error FeesTooLarge();\n    error SenderNotAuthorized();\n    error UnbondingInProgress();\n    error MustWithdrawAllVaults();\n    error ValidatorAlreadyAdded();\n    error RemovalAlreadyQueued();\n    error NoRemovalQueued();\n    error InvalidVaultIds();\n    error InvalidAmount();\n    error NoVaultsUnbonding();\n    error InvalidAddress();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes contract\n     * @param _token address of POL token\n     * @param _stakingPool address of the staking pool that controls this strategy\n     * @param _stakeManager address of the Polygon stake manager\n     * @param _vaultImplementation address of the implementation contract to use when deploying new vaults\n     * @param _validatorMEVRewardsPercentage basis point amount of MEV fees that validators will receive\n     * @param _fees list of fees to be paid on rewards\n     **/\n    function initialize(\n        address _token,\n        address _stakingPool,\n        address _stakeManager,\n        address _vaultImplementation,\n        uint256 _validatorMEVRewardsPercentage,\n        Fee[] memory _fees\n    ) public initializer {\n        __Strategy_init(_token, _stakingPool);\n\n        stakeManager = _stakeManager;\n        vaultImplementation = _vaultImplementation;\n\n        if (_validatorMEVRewardsPercentage > 5000) revert FeesTooLarge();\n        validatorMEVRewardsPercentage = _validatorMEVRewardsPercentage;\n\n        for (uint256 i = 0; i < _fees.length; ++i) {\n            fees.push(_fees[i]);\n        }\n        if (_totalFeesBasisPoints() > 3000) revert FeesTooLarge();\n    }\n\n    /**\n     * @notice Reverts if sender is not fund flow controller\n     */\n    modifier onlyFundFlowController() {\n        if (msg.sender != fundFlowController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Returns a list of all validators\n     * @return list of validators\n     */\n    function getValidators() external view returns (Validator[] memory) {\n        return validators;\n    }\n\n    /**\n     * @notice Returns a list of all vaults controlled by this contract\n     * @return list of vault addresses\n     */\n    function getVaults() external view returns (IPolygonVault[] memory) {\n        return vaults;\n    }\n\n    /**\n     * @notice Deposits tokens from the staking pool into this strategy\n     * @param _amount amount to deposit\n     */\n    function deposit(uint256 _amount, bytes calldata) external onlyStakingPool {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        totalDeposits += _amount;\n        totalQueued += _amount;\n    }\n\n    /**\n     * @notice Withdraws tokens from this strategy and sends them to staking pool\n     * @param _amount amount to withdraw\n     */\n    function withdraw(uint256 _amount, bytes calldata) external onlyStakingPool {\n        token.safeTransfer(msg.sender, _amount);\n        totalDeposits -= _amount;\n        totalQueued -= _amount;\n    }\n\n    /**\n     * @notice Deposits queued tokens into vaults\n     * @param _vaultIds list of vaults to deposit into\n     * @param _amounts list of amounts to deposit into each vault\n     */\n    function depositQueuedTokens(\n        uint256[] calldata _vaultIds,\n        uint256[] calldata _amounts\n    ) external onlyFundFlowController {\n        if (numVaultsUnbonding != 0) revert UnbondingInProgress();\n\n        uint256 preBalance = token.balanceOf(address(this));\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            if (_vaultIds[i] == skipIndex) revert InvalidVaultIds();\n\n            uint256 amount = _amounts[i];\n            if (amount == 0) revert InvalidAmount();\n\n            vaults[_vaultIds[i]].deposit(amount);\n        }\n\n        // balance change could be positive if many rewards are claimed while depositing\n        int256 balanceChange = int256(token.balanceOf(address(this))) - int256(preBalance);\n        if (balanceChange < 0) {\n            totalQueued -= uint256(-1 * balanceChange);\n        } else if (balanceChange > 0) {\n            totalQueued += uint256(balanceChange);\n        }\n\n        emit DepositQueuedTokens(balanceChange);\n    }\n\n    /**\n     * @notice Unbonds token deposits in vaults\n     * @dev there are some edge cases caused by the reward claim mechanism where the\n     * amount unbonded will be slightly less than _toUnbond\n     * @param _toUnbond amount to unbond\n     */\n    function unbond(uint256 _toUnbond) external onlyFundFlowController {\n        if (numVaultsUnbonding != 0) revert UnbondingInProgress();\n        if (_toUnbond == 0) revert InvalidAmount();\n\n        uint256 toUnbondRemaining = _toUnbond;\n\n        uint256 i = validatorWithdrawalIndex;\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n        uint256 numVaultsUnbonded;\n        uint256 preBalance = token.balanceOf(address(this));\n\n        while (toUnbondRemaining != 0) {\n            if (i != skipIndex) {\n                IPolygonVault vault = vaults[i];\n                uint256 deposits = vault.getTotalDeposits();\n\n                if (deposits != 0) {\n                    uint256 principalDeposits = vault.getPrincipalDeposits();\n                    uint256 rewards = deposits - principalDeposits;\n\n                    if (rewards >= toUnbondRemaining && rewards >= vault.minRewardClaimAmount()) {\n                        vault.withdrawRewards();\n                        toUnbondRemaining = 0;\n                        break;\n                    } else if (principalDeposits != 0) {\n                        if (toUnbondRemaining > rewards) {\n                            toUnbondRemaining -= rewards;\n                        }\n\n                        uint256 vaultToUnbond = principalDeposits >= toUnbondRemaining\n                            ? toUnbondRemaining\n                            : principalDeposits;\n\n                        vault.unbond(vaultToUnbond);\n\n                        toUnbondRemaining -= vaultToUnbond;\n                        ++numVaultsUnbonded;\n                    }\n                }\n            }\n\n            ++i;\n            if (i >= vaults.length) i = 0;\n            if (i == validatorWithdrawalIndex) break;\n        }\n\n        if (numVaultsUnbonded != 0) {\n            validatorWithdrawalIndex = i;\n            numVaultsUnbonding = numVaultsUnbonded;\n        }\n\n        uint256 rewardsClaimed = token.balanceOf(address(this)) - preBalance;\n        if (rewardsClaimed != 0) totalQueued += rewardsClaimed;\n\n        emit Unbond(_toUnbond);\n    }\n\n    /**\n     * @notice Unbonds token deposits in vaults\n     * @dev used to rebalance deposits between vaults if necessary\n     * @param _vaultIds list of vaults to unbond\n     * @param _amounts list of amounts to unbond\n     */\n    function forceUnbond(\n        uint256[] calldata _vaultIds,\n        uint256[] calldata _amounts\n    ) external onlyFundFlowController {\n        if (numVaultsUnbonding != 0) revert UnbondingInProgress();\n\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n        uint256 totalUnbonded;\n        uint256 preBalance = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            if (_vaultIds[i] == skipIndex) revert InvalidVaultIds();\n            if (i > 0 && _vaultIds[i] <= _vaultIds[i - 1]) revert InvalidVaultIds();\n            if (_amounts[i] == 0) revert InvalidAmount();\n\n            vaults[_vaultIds[i]].unbond(_amounts[i]);\n            totalUnbonded += _amounts[i];\n        }\n\n        numVaultsUnbonding = _vaultIds.length;\n\n        uint256 rewardsClaimed = token.balanceOf(address(this)) - preBalance;\n        if (rewardsClaimed != 0) totalQueued += rewardsClaimed;\n\n        emit ForceUnbond(totalUnbonded);\n    }\n\n    /**\n     * @notice Claims and withdraws tokens from vaults that are unbonded\n     * @param _vaultIds list of vaults to withdraw from\n     */\n    function unstakeClaim(uint256[] calldata _vaultIds) external onlyFundFlowController {\n        if (numVaultsUnbonding == 0) revert NoVaultsUnbonding();\n\n        uint256 preBalance = token.balanceOf(address(this));\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n        uint256 vaultsWithdrawn;\n\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            if (_vaultIds[i] == skipIndex) revert InvalidVaultIds();\n\n            vaults[_vaultIds[i]].withdraw();\n            ++vaultsWithdrawn;\n        }\n\n        if (vaultsWithdrawn != numVaultsUnbonding) revert MustWithdrawAllVaults();\n        numVaultsUnbonding = 0;\n\n        uint256 amountWithdrawn = token.balanceOf(address(this)) - preBalance;\n        totalQueued += amountWithdrawn;\n\n        emit UnstakeClaim(amountWithdrawn);\n    }\n\n    /**\n     * @notice Returns the deposit change since deposits were last updated\n     * @dev deposit change could be positive or negative depending on reward rate and whether\n     * any slashing occurred\n     * @return deposit change\n     */\n    function getDepositChange() public view returns (int) {\n        uint256 totalBalance = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            totalBalance += vaults[i].getTotalDeposits();\n        }\n        return int(totalBalance) - int(totalDeposits);\n    }\n\n    /**\n     * @notice Updates deposit accounting and calculates fees on newly earned rewards\n     * @return depositChange change in deposits since last update\n     * @return receivers list of fee receivers\n     * @return amounts list of fee amounts\n     */\n    function updateDeposits(\n        bytes calldata\n    )\n        external\n        onlyStakingPool\n        returns (int256 depositChange, address[] memory receivers, uint256[] memory amounts)\n    {\n        depositChange = getDepositChange();\n        uint256 balance = token.balanceOf(address(this));\n\n        if (depositChange > 0) {\n            totalDeposits += uint256(depositChange);\n\n            uint256 validatorMEVRewards = ((balance - totalQueued) *\n                validatorMEVRewardsPercentage) / 10000;\n\n            receivers = new address[](fees.length + (validatorMEVRewards != 0 ? 1 : 0));\n            amounts = new uint256[](receivers.length);\n\n            for (uint256 i = 0; i < fees.length; ++i) {\n                receivers[i] = fees[i].receiver;\n                amounts[i] = (uint256(depositChange) * fees[i].basisPoints) / 10000;\n            }\n\n            if (validatorMEVRewards != 0) {\n                receivers[receivers.length - 1] = address(validatorMEVRewardsPool);\n                amounts[amounts.length - 1] = validatorMEVRewards;\n            }\n        } else if (depositChange < 0) {\n            totalDeposits -= uint256(depositChange * -1);\n        }\n\n        totalQueued = balance;\n    }\n\n    /**\n     * @notice Restakes rewards in the polygon staking contract\n     * @param _vaultIds list of vaults to restake rewards for\n     */\n    function restakeRewards(uint256[] calldata _vaultIds) external {\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            vaults[_vaultIds[i]].restakeRewards();\n        }\n\n        emit RestakeRewards();\n    }\n\n    /**\n     * @notice Returns the total amount of deposits as tracked in this strategy\n     * @return total deposits\n     */\n    function getTotalDeposits() public view override returns (uint256) {\n        return totalDeposits;\n    }\n\n    /**\n     * @notice Returns the maximum amount of tokens this strategy can hold\n     * @return maximum deposits\n     */\n    function getMaxDeposits() public view override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Returns the minimum amount of tokens that must remain in this strategy\n     * @return minimum deposits\n     */\n    function getMinDeposits() public view override returns (uint256) {\n        return totalDeposits > totalQueued ? totalDeposits - totalQueued : 0;\n    }\n\n    /**\n     * @notice Returns whether an account should receive validator rewards\n     * @dev used by the validator MEV rewards pool\n     * @return 1 for accounts that should receive rewards, 0 otherwise\n     */\n    function staked(address _account) public view returns (uint256) {\n        for (uint256 i = 0; i < validators.length; ++i) {\n            if (validators[i].rewardsReceiver == _account) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Returns the total number of active validators\n     * @dev used by the validator MEV rewards pool\n     * @return total number of active validators\n     */\n    function totalStaked() public view returns (uint256) {\n        uint256 totalValidators = validators.length;\n        if (validatorRemoval.isActive) --totalValidators;\n        return totalValidators;\n    }\n\n    /**\n     * @notice Adds a new validator\n     * @param _pool address of validator shares pool\n     * @param _rewardsReceiver address to receive validator share of MEV rewards\n     */\n    function addValidator(address _pool, address _rewardsReceiver) external onlyOwner {\n        for (uint256 i = 0; i < validators.length; ++i) {\n            if (validators[i].pool == _pool) revert ValidatorAlreadyAdded();\n        }\n        validatorMEVRewardsPool.updateReward(_rewardsReceiver);\n        validators.push(Validator(_pool, _rewardsReceiver));\n\n        address vault = address(\n            new ERC1967Proxy(\n                vaultImplementation,\n                abi.encodeWithSignature(\n                    \"initialize(address,address,address,address)\",\n                    address(token),\n                    address(this),\n                    stakeManager,\n                    _pool\n                )\n            )\n        );\n        token.safeApprove(vault, type(uint256).max);\n        vaults.push(IPolygonVault(vault));\n\n        emit AddValidator(_pool, _rewardsReceiver);\n    }\n\n    /**\n     * @notice Queues a validator for removal\n     * @param _validatorId id of validator to remove\n     */\n    function queueValidatorRemoval(uint256 _validatorId) external onlyOwner {\n        if (validatorRemoval.isActive) revert RemovalAlreadyQueued();\n\n        IPolygonVault vault = vaults[_validatorId];\n        uint256 principalDeposits = vault.getPrincipalDeposits();\n\n        if (vault.isUnbonding() || vault.isWithdrawable()) {\n            --numVaultsUnbonding;\n        }\n\n        if (principalDeposits != 0) {\n            uint256 preBalance = token.balanceOf(address(this));\n            vault.unbond(principalDeposits);\n            uint256 rewardsClaimed = token.balanceOf(address(this)) - preBalance;\n            if (rewardsClaimed != 0) totalQueued += rewardsClaimed;\n        }\n\n        validatorMEVRewardsPool.updateReward(validators[_validatorId].rewardsReceiver);\n\n        uint256 queuedWithdrawals = vault.getQueuedWithdrawals();\n        validatorRemoval = ValidatorRemoval(true, uint64(_validatorId), uint128(queuedWithdrawals));\n\n        emit QueueValidatorRemoval(\n            validators[_validatorId].pool,\n            validators[_validatorId].rewardsReceiver\n        );\n\n        delete validators[_validatorId].rewardsReceiver;\n    }\n\n    /**\n     * @notice Finalizes a queued validator removal\n     * @dev all vaults must be empty or unbonded\n     */\n    function finalizeValidatorRemoval() external onlyOwner {\n        if (!validatorRemoval.isActive) revert NoRemovalQueued();\n\n        uint256 validatorId = validatorRemoval.validatorId;\n        uint256 preBalance = token.balanceOf(address(this));\n\n        IPolygonVault vault = vaults[validatorId];\n        if (vault.getQueuedWithdrawals() != 0) {\n            vault.withdraw();\n        }\n\n        uint256 amountWithdrawn = token.balanceOf(address(this)) - preBalance;\n        totalQueued += amountWithdrawn;\n\n        token.safeApprove(address(vault), 0);\n\n        emit FinalizeValidatorRemoval(validators[validatorId].pool);\n\n        if (\n            validatorId == validators.length - 1 &&\n            validatorWithdrawalIndex == validators.length - 1\n        ) {\n            validatorWithdrawalIndex = 0;\n        } else if (validatorWithdrawalIndex > validatorId) {\n            --validatorWithdrawalIndex;\n        }\n\n        for (uint256 i = validatorId; i < validators.length - 1; ++i) {\n            validators[i] = validators[i + 1];\n            vaults[i] = vaults[i + 1];\n        }\n\n        validators.pop();\n        vaults.pop();\n\n        delete validatorRemoval;\n    }\n\n    /**\n     * @notice Upgrades vaults to a new implementation contract\n     * @param _vaults list of vauls to upgrade\n     * @param _data list of encoded function calls to be executed for each vault after upgrade\n     */\n    function upgradeVaults(address[] calldata _vaults, bytes[] memory _data) external onlyOwner {\n        for (uint256 i = 0; i < _vaults.length; ++i) {\n            if (_data.length == 0 || _data[i].length == 0) {\n                IPolygonVault(_vaults[i]).upgradeTo(vaultImplementation);\n            } else {\n                IPolygonVault(_vaults[i]).upgradeToAndCall(vaultImplementation, _data[i]);\n            }\n        }\n        emit UpgradedVaults(_vaults);\n    }\n\n    /**\n     * @notice Returns a list of all fees and fee receivers\n     * @return list of fees\n     */\n    function getFees() external view returns (Fee[] memory) {\n        return fees;\n    }\n\n    /**\n     * @notice Adds a new fee\n     * @dev stakingPool.updateStrategyRewards is called to credit all past fees at\n     * the old rate before the percentage changes\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function addFee(address _receiver, uint256 _feeBasisPoints) external onlyOwner {\n        _updateStrategyRewards();\n        fees.push(Fee(_receiver, _feeBasisPoints));\n        if (_totalFeesBasisPoints() > 3000) revert FeesTooLarge();\n        emit AddFee(_receiver, _feeBasisPoints);\n    }\n\n    /**\n     * @notice Updates an existing fee\n     * @dev stakingPool.updateStrategyRewards is called to credit all past fees at\n     * the old rate before the percentage changes\n     * @param _index index of fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function updateFee(\n        uint256 _index,\n        address _receiver,\n        uint256 _feeBasisPoints\n    ) external onlyOwner {\n        _updateStrategyRewards();\n\n        if (_feeBasisPoints == 0) {\n            Fee memory toRemove = fees[_index];\n            fees[_index] = fees[fees.length - 1];\n            fees.pop();\n            emit RemoveFee(_index, toRemove.receiver, toRemove.basisPoints);\n        } else {\n            fees[_index].receiver = _receiver;\n            fees[_index].basisPoints = _feeBasisPoints;\n            if (_totalFeesBasisPoints() > 3000) revert FeesTooLarge();\n            emit UpdateFee(_index, _receiver, _feeBasisPoints);\n        }\n    }\n\n    /**\n     * @notice Sets the validator MEV rewards pool\n     * @param _validatorMEVRewardsPool address of rewards pool\n     */\n    function setValidatorMEVRewardsPool(address _validatorMEVRewardsPool) external onlyOwner {\n        if (_validatorMEVRewardsPool == address(0)) revert InvalidAddress();\n        validatorMEVRewardsPool = IRewardsPool(_validatorMEVRewardsPool);\n    }\n\n    /**\n     * @notice Sets the percentage of MEV rewards that validators receiver\n     * @param _validatorMEVRewardsPercentage basis point amount\n     */\n    function setValidatorMEVRewardsPercentage(\n        uint256 _validatorMEVRewardsPercentage\n    ) external onlyOwner {\n        if (_validatorMEVRewardsPercentage > 5000) revert FeesTooLarge();\n\n        validatorMEVRewardsPercentage = _validatorMEVRewardsPercentage;\n        emit SetValidatorMEVRewardsPercentage(_validatorMEVRewardsPercentage);\n    }\n\n    /**\n     * @notice Sets a new vault implementation contract to be used when deploying/upgrading vaults\n     * @param _vaultImplementation address of implementation contract\n     */\n    function setVaultImplementation(address _vaultImplementation) external onlyOwner {\n        if (_vaultImplementation == address(0)) revert InvalidAddress();\n        vaultImplementation = _vaultImplementation;\n        emit SetVaultImplementation(_vaultImplementation);\n    }\n\n    /**\n     * @notice Sets the fund flow controller\n     * @param _fundFlowController address of fund flow controller\n     */\n    function setFundFlowController(address _fundFlowController) external onlyOwner {\n        if (_fundFlowController == address(0)) revert InvalidAddress();\n        fundFlowController = _fundFlowController;\n    }\n\n    /**\n     * @notice Updates rewards for all strategies controlled by the staking pool\n     * @dev called before fees are changed to credit any past rewards at the old rate\n     */\n    function _updateStrategyRewards() internal {\n        address[] memory strategies = stakingPool.getStrategies();\n        uint256[] memory strategyIdxs = new uint256[](strategies.length);\n        for (uint256 i = 0; i < strategies.length; ++i) {\n            strategyIdxs[i] = i;\n        }\n        stakingPool.updateStrategyRewards(strategyIdxs, \"\");\n    }\n\n    /**\n     * @notice Returns the sum of all fees\n     * @return sum of fees in basis points\n     **/\n    function _totalFeesBasisPoints() private view returns (uint256) {\n        uint256 totalFees;\n        for (uint i = 0; i < fees.length; ++i) {\n            totalFees += fees[i].basisPoints;\n        }\n        return totalFees;\n    }\n}\n"
    }
}