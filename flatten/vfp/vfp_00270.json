{
    "vfp_id": "vfp_00270",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-546"
                ]
            },
            "title": "Remove TODOs from the code",
            "description": "The codebase contains multiple \"// TODO:\" comments that indicate incomplete or pending work. Leaving such comments in production code can lead to confusion, overlooked issues, or accidental deployment of unfinished logic. These comments may signal areas where assumptions were made or where security checks were intended but not implemented. While not directly exploitable, they increase technical debt and risk. Their presence violates secure development best practices, which recommend that all TODOs be resolved or removed before deployment. The impact is reduced code clarity and potential introduction of vulnerabilities if TODOs are ignored during future maintenance.\n",
            "severity": null,
            "location": [
                "Multiple files"
            ],
            "files": [
                "cap-contracts/test/deploy/TestDeployer.sol",
                "cap-contracts/test/vault/Vault.invariants.t.sol",
                "cap-contracts/contracts/deploy/service/DeployLibs.sol"
            ]
        }
    ],
    "affected_files": {
        "TestDeployer.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Delegation } from \"../../contracts/delegation/Delegation.sol\";\nimport { NetworkMiddleware } from \"../../contracts/delegation/providers/symbiotic/NetworkMiddleware.sol\";\nimport { FeeConfig, VaultConfig } from \"../../contracts/deploy/interfaces/DeployConfigs.sol\";\n\nimport { MockChainlinkPriceFeed } from \"../mocks/MockChainlinkPriceFeed.sol\";\n\nimport { AccessControl } from \"../../contracts/access/AccessControl.sol\";\nimport { SymbioticVaultParams } from \"../../contracts/deploy/interfaces/SymbioticsDeployConfigs.sol\";\nimport { SymbioticNetworkAdapterParams } from \"../../contracts/deploy/interfaces/SymbioticsDeployConfigs.sol\";\nimport {\n    SymbioticNetworkRewardsConfig,\n    SymbioticUsersConfig,\n    SymbioticVaultConfig\n} from \"../../contracts/deploy/interfaces/SymbioticsDeployConfigs.sol\";\nimport { ConfigureAccessControl } from \"../../contracts/deploy/service/ConfigureAccessControl.sol\";\nimport { ConfigureDelegation } from \"../../contracts/deploy/service/ConfigureDelegation.sol\";\nimport { ConfigureOracle } from \"../../contracts/deploy/service/ConfigureOracle.sol\";\nimport { DeployImplems } from \"../../contracts/deploy/service/DeployImplems.sol\";\nimport { DeployInfra } from \"../../contracts/deploy/service/DeployInfra.sol\";\nimport { DeployLibs } from \"../../contracts/deploy/service/DeployLibs.sol\";\nimport { DeployVault } from \"../../contracts/deploy/service/DeployVault.sol\";\nimport { ConfigureSymbioticOptIns } from\n    \"../../contracts/deploy/service/providers/symbiotic/ConfigureSymbioticOptIns.sol\";\nimport { DeployCapNetworkAdapter } from \"../../contracts/deploy/service/providers/symbiotic/DeployCapNetworkAdapter.sol\";\nimport { DeploySymbioticVault } from \"../../contracts/deploy/service/providers/symbiotic/DeploySymbioticVault.sol\";\nimport { ProxyUtils } from \"../../contracts/deploy/utils/ProxyUtils.sol\";\nimport { SymbioticAddressbook, SymbioticUtils } from \"../../contracts/deploy/utils/SymbioticUtils.sol\";\nimport { FeeAuction } from \"../../contracts/feeAuction/FeeAuction.sol\";\nimport { Lender } from \"../../contracts/lendingPool/Lender.sol\";\nimport { CapToken } from \"../../contracts/token/CapToken.sol\";\nimport { StakedCap } from \"../../contracts/token/StakedCap.sol\";\nimport { MockERC20 } from \"../mocks/MockERC20.sol\";\nimport { SymbioticTestEnvConfig, TestEnvConfig } from \"./interfaces/TestDeployConfig.sol\";\nimport { VaultConfigHelpers } from \"./service/VaultConfigHelpers.sol\";\n\nimport { LzAddressbook, LzUtils } from \"../../contracts/deploy/utils/LzUtils.sol\";\nimport { ZapAddressbook, ZapUtils } from \"../../contracts/deploy/utils/ZapUtils.sol\";\nimport { DeployMocks } from \"./service/DeployMocks.sol\";\nimport { DeployTestUsers } from \"./service/DeployTestUsers.sol\";\nimport { InitTestVaultLiquidity } from \"./service/InitTestVaultLiquidity.sol\";\nimport { InitSymbioticVaultLiquidity } from \"./service/provider/symbiotic/InitSymbioticVaultLiquidity.sol\";\nimport { TimeUtils } from \"./utils/TimeUtils.sol\";\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\nimport { console } from \"forge-std/console.sol\";\n\ncontract TestDeployer is\n    Test,\n    LzUtils,\n    SymbioticUtils,\n    TimeUtils,\n    ZapUtils,\n    DeployMocks,\n    DeployInfra,\n    DeployVault,\n    DeployImplems,\n    DeployLibs,\n    ConfigureOracle,\n    ConfigureDelegation,\n    ConfigureAccessControl,\n    DeployTestUsers,\n    InitTestVaultLiquidity,\n    DeploySymbioticVault,\n    DeployCapNetworkAdapter,\n    ConfigureSymbioticOptIns,\n    InitSymbioticVaultLiquidity,\n    VaultConfigHelpers\n{\n    TestEnvConfig env;\n\n    LzAddressbook lzAb;\n    SymbioticAddressbook symbioticAb;\n    ZapAddressbook zapAb;\n\n    /// set to true to use the mock backing network\n    /// makes the tests faster but does not test the full functionality\n    /// TODO: remove this and create a different deployer method for each environment we need to create\n    ///       this is not great as it makes the deployer harder to understand\n    function useMockBackingNetwork() internal view virtual returns (bool) {\n        return false;\n    }\n\n    function _deployCapTestEnvironment() internal {\n        if (useMockBackingNetwork()) {\n            console.log(\"using MOCK blockchain\");\n            vm.chainId(11155111);\n        } else {\n            console.log(\"using sepolia as the test blockchain\");\n            // we need to fork the sepolia network to deploy the symbiotic network adapter\n            // hardcoding the block number to benefit from the anvil cache\n            vm.createSelectFork(\"https://eth-sepolia.public.blastapi.io\", 7699085);\n        }\n\n        (env.users, env.testUsers) = _deployTestUsers();\n\n        /// DEPLOY\n        vm.startPrank(env.users.deployer);\n\n        lzAb = _getLzAddressbook();\n        symbioticAb = _getSymbioticAddressbook();\n        zapAb = _getZapAddressbook();\n\n        env.implems = _deployImplementations();\n        env.libs = _deployLibs();\n        env.infra = _deployInfra(env.implems, env.users);\n\n        env.usdMocks = _deployUSDMocks();\n        env.ethMocks = _deployEthMocks();\n\n        env.usdOracleMocks = _deployOracleMocks(env.usdMocks);\n        env.ethOracleMocks = _deployOracleMocks(env.ethMocks);\n\n        console.log(\"deploying usdVault\");\n        env.usdVault =\n            _deployVault(env.implems, env.infra, \"Cap USD\", \"cUSD\", env.usdOracleMocks.assets, env.users.insurance_fund);\n\n        console.log(\"deploying ethVault\");\n        env.ethVault =\n            _deployVault(env.implems, env.infra, \"Cap ETH\", \"cETH\", env.ethOracleMocks.assets, env.users.insurance_fund);\n\n        if (useMockBackingNetwork()) {\n            console.log(\"skipping lzperiphery\");\n        } else {\n            console.log(\"deploying lzperiphery\");\n            env.usdVault.lzperiphery = _deployVaultLzPeriphery(lzAb, zapAb, env.usdVault, env.users);\n            env.ethVault.lzperiphery = _deployVaultLzPeriphery(lzAb, zapAb, env.ethVault, env.users);\n        }\n\n        /// ACCESS CONTROL\n        console.log(\"deploying access control\");\n        vm.startPrank(env.users.access_control_admin);\n        _initInfraAccessControl(env.infra, env.users);\n        _initVaultAccessControl(env.infra, env.usdVault, env.users);\n        _initVaultAccessControl(env.infra, env.ethVault, env.users);\n\n        /// ORACLE\n        console.log(\"deploying oracle\");\n        vm.startPrank(env.users.oracle_admin);\n        _initOracleMocks(env.usdOracleMocks, 1e8, uint256(0.1e27)); // $1.00 with 8 decimals & 10% Annualized in ray decimals\n        _initOracleMocks(env.ethOracleMocks, 2600e8, uint256(0.1e27)); // $2600 with 8 decimals & 10% Annualized in ray decimals\n        _initVaultOracle(env.libs, env.infra, env.usdVault);\n        _initVaultOracle(env.libs, env.infra, env.ethVault);\n        for (uint256 i = 0; i < env.usdVault.assets.length; i++) {\n            address asset = env.usdVault.assets[i];\n            address priceFeed = env.usdOracleMocks.chainlinkPriceFeeds[i];\n            _initChainlinkPriceOracle(env.libs, env.infra, asset, priceFeed);\n        }\n        for (uint256 i = 0; i < env.ethOracleMocks.assets.length; i++) {\n            address asset = env.ethOracleMocks.assets[i];\n            address priceFeed = env.ethOracleMocks.chainlinkPriceFeeds[i];\n            _initChainlinkPriceOracle(env.libs, env.infra, asset, priceFeed);\n        }\n\n        console.log(\"deploying rate oracle\");\n        vm.startPrank(env.users.rate_oracle_admin);\n        for (uint256 i = 0; i < env.usdVault.assets.length; i++) {\n            _initAaveRateOracle(env.libs, env.infra, env.usdVault.assets[i], env.usdOracleMocks.aaveDataProviders[i]);\n        }\n        for (uint256 i = 0; i < env.ethVault.assets.length; i++) {\n            _initAaveRateOracle(env.libs, env.infra, env.ethVault.assets[i], env.ethOracleMocks.aaveDataProviders[i]);\n        }\n        for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n            /// 1.585e18 is 5% per year\n            uint256 increment = (i + 1) * 0.01585e18; // Vary the restakers rate by 1% each\n            _initRestakerRateForAgent(env.infra, env.testUsers.agents[i], uint256(1.585e18 + increment)); // Restakers rate is per second in ray\n        }\n\n        /// LENDER\n        console.log(\"deploying lender\");\n        vm.startPrank(env.users.lender_admin);\n\n        FeeConfig memory fee = FeeConfig({\n            minMintFee: 0.005e27, // 0.5% minimum mint fee\n            slope0: 0, // allow liquidity to be added without fee\n            slope1: 0, // allow liquidity to be added without fee to start with\n            mintKinkRatio: 0.85e27,\n            burnKinkRatio: 0.15e27,\n            optimalRatio: 0.33e27\n        });\n\n        _initVaultLender(env.usdVault, env.infra, fee);\n        _initVaultLender(env.ethVault, env.infra, fee);\n\n        if (useMockBackingNetwork()) {\n            vm.startPrank(env.users.middleware_admin);\n            address networkMock = _deployDelegationNetworkMock();\n            env.symbiotic.networkAdapter.networkMiddleware = networkMock;\n            vm.stopPrank();\n\n            _configureMockNetworkMiddleware(env, networkMock);\n\n            for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n                _setMockNetworkMiddlewareAgentCoverage(env, env.testUsers.agents[i], 1_000_000e8);\n            }\n        } else {\n            /// SYMBIOTIC NETWORK ADAPTER\n            console.log(\"deploying symbiotic cap network address\");\n            env.symbiotic.users.vault_admin = makeAddr(\"vault_admin\");\n\n            console.log(\"deploying symbiotic network adapter\");\n            vm.startPrank(env.users.deployer);\n            env.symbiotic.networkAdapterImplems = _deploySymbioticNetworkAdapterImplems();\n            env.symbiotic.networkAdapter = _deploySymbioticNetworkAdapterInfra(\n                env.infra,\n                symbioticAb,\n                env.symbiotic.networkAdapterImplems,\n                SymbioticNetworkAdapterParams({ vaultEpochDuration: 7 days, feeAllowed: 1000 })\n            );\n\n            console.log(\"registering delegation network\");\n            vm.startPrank(env.users.delegation_admin);\n            _registerNetworkForCapDelegation(env.infra, env.symbiotic.networkAdapter.networkMiddleware);\n\n            console.log(\"access control mgmt\");\n            vm.startPrank(env.users.access_control_admin);\n            _initSymbioticNetworkAdapterAccessControl(env.infra, env.symbiotic.networkAdapter, env.users);\n\n            console.log(\"registering symbiotic network\");\n            vm.startPrank(env.users.middleware_admin);\n            _registerCapNetwork(symbioticAb, env.symbiotic.networkAdapter);\n\n            console.log(\"registering agents as operator\");\n            for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n                vm.startPrank(env.testUsers.agents[i]);\n                _agentRegisterAsOperator(symbioticAb);\n                _agentOptInToSymbioticNetwork(symbioticAb, env.symbiotic.networkAdapter);\n            }\n\n            console.log(\"init agent delegation for symbiotic network\");\n            vm.startPrank(env.users.delegation_admin);\n            for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n                address agent = env.testUsers.agents[i];\n                _initDelegationAgent(env.infra, agent, env.symbiotic.networkAdapter.networkMiddleware);\n            }\n\n            console.log(\"deploying symbiotic WETH vault\");\n            (SymbioticVaultConfig memory _vault, SymbioticNetworkRewardsConfig memory _rewards) =\n                _deployAndConfigureTestnetSymbioticVault(env.ethMocks[0], \"WETH\");\n            _symbioticVaultConfigToEnv(_vault);\n            _symbioticNetworkRewardsConfigToEnv(_rewards);\n\n            vm.stopPrank();\n        }\n\n        // change  epoch\n        _timeTravel(28 days);\n\n        _unwrapEnvToMakeTestsReadable();\n        _applyTestnetLabels();\n\n        vm.stopPrank();\n    }\n\n    function _deployAndConfigureTestnetSymbioticVault(address collateral, string memory assetSymbol)\n        internal\n        returns (SymbioticVaultConfig memory _vault, SymbioticNetworkRewardsConfig memory _rewards)\n    {\n        console.log(string.concat(\"deploying symbiotic vault \", assetSymbol));\n        vm.startPrank(env.symbiotic.users.vault_admin);\n\n        _vault = _deploySymbioticVault(\n            symbioticAb,\n            SymbioticVaultParams({\n                vault_admin: env.symbiotic.users.vault_admin,\n                collateral: collateral,\n                vaultEpochDuration: 7 days,\n                burnerRouterDelay: 0\n            })\n        );\n\n        console.log(\"deploying symbiotic network rewards 0\");\n        vm.startPrank(env.users.staker_rewards_admin);\n\n        _rewards = _deploySymbioticRestakerRewardContract(symbioticAb, env.users, _vault);\n\n        console.log(\"registering symbiotic network in vaults\");\n        vm.startPrank(env.symbiotic.users.vault_admin);\n        _registerCapNetworkInVault(env.symbiotic.networkAdapter, _vault);\n\n        console.log(\"registering vaults in network middleware\");\n        vm.startPrank(env.users.middleware_admin);\n\n        NetworkMiddleware(env.symbiotic.networkAdapter.networkMiddleware).registerVault(\n            _vault.vault, _rewards.stakerRewarder\n        );\n\n        for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n            _registerVaultsInNetworkMiddleware(env.symbiotic.networkAdapter, _vault, env.testUsers.agents[i]);\n        }\n\n        console.log(\"registering agents as operator\");\n        for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n            vm.startPrank(env.testUsers.agents[i]);\n            _agentOptInToSymbioticVault(symbioticAb, _vault);\n        }\n\n        console.log(\"registering network in vaults\");\n        vm.startPrank(env.users.middleware_admin);\n        for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n            address _agent = env.testUsers.agents[i];\n            console.log(\"count\", i);\n            _networkOptInToSymbioticVault(env.symbiotic.networkAdapter, _vault, _agent);\n        }\n\n        console.log(\"vaults delegating to agents\");\n        vm.startPrank(env.symbiotic.users.vault_admin);\n        for (uint256 i = 0; i < env.testUsers.agents.length; i++) {\n            address _agent = env.testUsers.agents[i];\n            _symbioticVaultDelegateToAgent(_vault, env.symbiotic.networkAdapter, _agent, type(uint256).max);\n        }\n    }\n\n    function _applyTestnetLabels() internal {\n        vm.label(address(env.implems.accessControl), \"AccessControlImplem\");\n        vm.label(address(env.implems.delegation), \"DelegationImplem\");\n        vm.label(address(env.implems.feeAuction), \"FeeAuctionImplem\");\n        vm.label(address(env.implems.oracle), \"OracleImplem\");\n        vm.label(address(env.implems.lender), \"LenderImplem\");\n        vm.label(address(env.implems.stakedCap), \"StakedCapImplem\");\n        vm.label(address(env.implems.capToken), \"CapTokenImplem\");\n\n        vm.label(address(env.infra.accessControl), \"AccessControlProxy\");\n        vm.label(address(env.infra.delegation), \"DelegationProxy\");\n        vm.label(address(env.infra.oracle), \"OracleProxy\");\n        vm.label(address(env.infra.lender), \"LenderProxy\");\n\n        for (uint256 i = 0; i < env.usdVault.assets.length; i++) {\n            IERC20Metadata asset = IERC20Metadata(env.usdVault.assets[i]);\n            IERC20Metadata debtToken = IERC20Metadata(env.usdVault.debtTokens[i]);\n            vm.label(address(asset), asset.symbol());\n            vm.label(address(debtToken), debtToken.symbol());\n        }\n\n        for (uint256 i = 0; i < env.ethVault.assets.length; i++) {\n            IERC20Metadata asset = IERC20Metadata(env.ethVault.assets[i]);\n            IERC20Metadata debtToken = IERC20Metadata(env.ethVault.debtTokens[i]);\n            vm.label(address(asset), asset.symbol());\n            vm.label(address(debtToken), debtToken.symbol());\n        }\n\n        // Label vault contracts\n        vm.label(address(env.usdVault.capToken), \"cUSD\");\n        vm.label(address(env.usdVault.stakedCapToken), \"scUSD\");\n        vm.label(address(env.usdVault.feeAuction), \"cUSD_FeeAuction\");\n        vm.label(address(env.ethVault.capToken), \"cETH\");\n        vm.label(address(env.ethVault.stakedCapToken), \"scETH\");\n        vm.label(address(env.ethVault.feeAuction), \"cETH_FeeAuction\");\n\n        // Label symbiotic contracts\n        if (!useMockBackingNetwork()) {\n            for (uint256 i = 0; i < env.symbiotic.vaults.length; i++) {\n                vm.label(env.symbiotic.vaults[i], string.concat(\"SymbioticVault_\", vm.toString(i)));\n                vm.label(env.symbiotic.collaterals[i], string.concat(\"SymbioticCollateral_\", vm.toString(i)));\n                vm.label(env.symbiotic.burnerRouters[i], string.concat(\"SymbioticBurnerRouter_\", vm.toString(i)));\n                vm.label(env.symbiotic.globalReceivers[i], string.concat(\"SymbioticGlobalReceiver_\", vm.toString(i)));\n                vm.label(env.symbiotic.delegators[i], string.concat(\"SymbioticDelegator_\", vm.toString(i)));\n                vm.label(env.symbiotic.slashers[i], string.concat(\"SymbioticSlasher_\", vm.toString(i)));\n            }\n        }\n\n        vm.label(address(env.symbiotic.networkAdapter.networkMiddleware), \"SymbioticNetworkMiddleware\");\n        vm.label(address(env.symbiotic.networkAdapter.network), \"Cap_SymbioticNetwork\");\n\n        vm.label(address(env.libs.aaveAdapter), \"AaveAdapter\");\n        vm.label(address(env.libs.chainlinkAdapter), \"ChainlinkAdapter\");\n        vm.label(address(env.libs.capTokenAdapter), \"CapTokenAdapter\");\n        vm.label(address(env.libs.stakedCapAdapter), \"StakedCapTokenAdapter\");\n\n        vm.label(address(usdVault.assets[0]), \"USDT\");\n        vm.label(address(usdVault.assets[1]), \"USDC\");\n        vm.label(address(usdVault.assets[2]), \"USDX\");\n        vm.label(address(ethVault.assets[0]), \"WETH\");\n    }\n\n    function _symbioticVaultConfigToEnv(SymbioticVaultConfig memory _vault) internal {\n        console.log(\"symbiotic vault config to env\", _vault.vault);\n        env.symbiotic.vaults.push(_vault.vault);\n        env.symbiotic.collaterals.push(_vault.collateral);\n        env.symbiotic.burnerRouters.push(_vault.burnerRouter);\n        env.symbiotic.globalReceivers.push(_vault.globalReceiver);\n        env.symbiotic.delegators.push(_vault.delegator);\n        env.symbiotic.slashers.push(_vault.slasher);\n        env.symbiotic.vaultEpochDurations.push(_vault.vaultEpochDuration);\n    }\n\n    function _getSymbioticVaultConfig(uint256 index) internal view returns (SymbioticVaultConfig memory _vault) {\n        _vault.vault = env.symbiotic.vaults[index];\n        _vault.collateral = env.symbiotic.collaterals[index];\n        _vault.burnerRouter = env.symbiotic.burnerRouters[index];\n        _vault.globalReceiver = env.symbiotic.globalReceivers[index];\n        _vault.delegator = env.symbiotic.delegators[index];\n        _vault.slasher = env.symbiotic.slashers[index];\n        _vault.vaultEpochDuration = env.symbiotic.vaultEpochDurations[index];\n    }\n\n    function _symbioticNetworkRewardsConfigToEnv(SymbioticNetworkRewardsConfig memory _rewards) internal {\n        env.symbiotic.networkRewards.push(_rewards.stakerRewarder);\n    }\n\n    function _getSymbioticNetworkRewardsConfig(uint256 index)\n        internal\n        view\n        returns (SymbioticNetworkRewardsConfig memory _rewards)\n    {\n        _rewards.stakerRewarder = env.symbiotic.networkRewards[index];\n    }\n\n    VaultConfig usdVault;\n    VaultConfig ethVault;\n    MockERC20 usdt;\n    MockERC20 usdc;\n    MockERC20 usdx;\n    MockERC20 weth;\n    CapToken cUSD;\n    StakedCap scUSD;\n    FeeAuction cUSDFeeAuction;\n    CapToken cETH;\n    StakedCap scETH;\n    FeeAuction cETHFeeAuction;\n\n    NetworkMiddleware middleware;\n    SymbioticVaultConfig symbioticWethVault;\n    SymbioticNetworkRewardsConfig symbioticWethNetworkRewards;\n\n    Lender lender;\n    Delegation delegation;\n    AccessControl accessControl;\n\n    function _unwrapEnvToMakeTestsReadable() internal {\n        usdVault = env.usdVault;\n        ethVault = env.ethVault;\n        usdt = MockERC20(usdVault.assets[0]);\n        usdc = MockERC20(usdVault.assets[1]);\n        usdx = MockERC20(usdVault.assets[2]);\n        weth = MockERC20(ethVault.assets[0]);\n        cUSD = CapToken(usdVault.capToken);\n        scUSD = StakedCap(usdVault.stakedCapToken);\n        cUSDFeeAuction = FeeAuction(usdVault.feeAuction);\n        cETH = CapToken(ethVault.capToken);\n        scETH = StakedCap(ethVault.stakedCapToken);\n        cETHFeeAuction = FeeAuction(ethVault.feeAuction);\n\n        if (!useMockBackingNetwork()) {\n            middleware = NetworkMiddleware(env.symbiotic.networkAdapter.networkMiddleware);\n            symbioticWethVault = _getSymbioticVaultConfig(0);\n            symbioticWethNetworkRewards = _getSymbioticNetworkRewardsConfig(0);\n        }\n\n        lender = Lender(env.infra.lender);\n        delegation = Delegation(env.infra.delegation);\n        accessControl = AccessControl(env.infra.accessControl);\n    }\n\n    // helpers\n\n    function _getRandomAgent() internal view returns (address) {\n        return env.testUsers.agents[uint256(\n            keccak256(abi.encodePacked(block.timestamp, block.prevrandao, block.coinbase))\n        ) % env.testUsers.agents.length];\n    }\n\n    function _setAssetOraclePrice(address asset, int256 price) internal {\n        for (uint256 i = 0; i < env.usdOracleMocks.chainlinkPriceFeeds.length; i++) {\n            if (env.usdOracleMocks.assets[i] == asset) {\n                vm.startPrank(env.users.oracle_admin);\n                MockChainlinkPriceFeed(env.usdOracleMocks.chainlinkPriceFeeds[i]).setLatestAnswer(price);\n                vm.stopPrank();\n                return;\n            }\n        }\n\n        for (uint256 i = 0; i < env.ethOracleMocks.chainlinkPriceFeeds.length; i++) {\n            if (env.ethOracleMocks.assets[i] == asset) {\n                vm.startPrank(env.users.oracle_admin);\n                MockChainlinkPriceFeed(env.ethOracleMocks.chainlinkPriceFeeds[i]).setLatestAnswer(price);\n                vm.stopPrank();\n                return;\n            }\n        }\n\n        revert(\"Asset not found\");\n    }\n\n    function _grantAccess(bytes4 _selector, address _contract, address _account) internal {\n        vm.startPrank(env.users.access_control_admin);\n        accessControl.grantAccess(_selector, _contract, _account);\n        vm.stopPrank();\n    }\n}\n",
        "DeployLibs.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AaveAdapter } from \"../../oracle/libraries/AaveAdapter.sol\";\nimport { CapTokenAdapter } from \"../../oracle/libraries/CapTokenAdapter.sol\";\nimport { ChainlinkAdapter } from \"../../oracle/libraries/ChainlinkAdapter.sol\";\nimport { StakedCapAdapter } from \"../../oracle/libraries/StakedCapAdapter.sol\";\nimport { LibsConfig } from \"../interfaces/DeployConfigs.sol\";\n\ncontract DeployLibs {\n    function _deployLibs() public pure returns (LibsConfig memory d) {\n        // grab libraries addresses\n        // TODO: use deploy2 to avoid re-deploying already deployed libraries\n        d.aaveAdapter = address(AaveAdapter);\n        d.chainlinkAdapter = address(ChainlinkAdapter);\n        d.capTokenAdapter = address(CapTokenAdapter);\n        d.stakedCapAdapter = address(StakedCapAdapter);\n    }\n}\n",
        "Vault.invariants.t.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { AccessControl } from \"../../contracts/access/AccessControl.sol\";\n\nimport { ProxyUtils } from \"../../contracts/deploy/utils/ProxyUtils.sol\";\nimport { FeeAuction } from \"../../contracts/feeAuction/FeeAuction.sol\";\n\nimport { IMinter } from \"../../contracts/interfaces/IMinter.sol\";\nimport { Vault } from \"../../contracts/vault/Vault.sol\";\nimport { MockAccessControl } from \"../mocks/MockAccessControl.sol\";\nimport { MockERC20 } from \"../mocks/MockERC20.sol\";\n\nimport { MockERC4626 } from \"../mocks/MockERC4626.sol\";\nimport { MockOracle } from \"../mocks/MockOracle.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { StdCheats } from \"forge-std/StdCheats.sol\";\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Vm } from \"forge-std/Vm.sol\";\nimport { console } from \"forge-std/console.sol\";\n\nimport { RandomActorUtils } from \"../deploy/utils/RandomActorUtils.sol\";\nimport { RandomAssetUtils } from \"../deploy/utils/RandomAssetUtils.sol\";\n\ncontract VaultInvariantsTest is Test, ProxyUtils {\n    TestVaultHandler public handler;\n    TestVault public vault;\n    FeeAuction public feeAuction;\n    address[] public assets;\n    address public insuranceFund;\n\n    MockOracle public mockOracle;\n    MockAccessControl public accessControl;\n\n    address[] public fractionalReserveVaults;\n\n    // Track token holders for testing\n    address[] private tokenHolders;\n    mapping(address => bool) private isHolder;\n\n    // Mock tokens\n    MockERC20[] private mockTokens;\n\n    function setUp() public {\n        // Setup mock assets\n        mockTokens = new MockERC20[](3);\n        assets = new address[](3);\n\n        // Create mock tokens with different decimals\n        mockTokens[0] = new MockERC20(\"Mock Token 1\", \"MT1\", 18);\n        mockTokens[1] = new MockERC20(\"Mock Token 2\", \"MT2\", 6);\n        mockTokens[2] = new MockERC20(\"Mock Token 3\", \"MT3\", 8);\n\n        for (uint256 i = 0; i < 3; i++) {\n            assets[i] = address(mockTokens[i]);\n        }\n\n        // Deploy and setup mock oracle\n        mockOracle = new MockOracle();\n        for (uint256 i = 0; i < assets.length; i++) {\n            // Set initial price of 1:1 for each asset\n            mockOracle.setPrice(assets[i], 10 ** IERC20Metadata(assets[i]).decimals());\n        }\n\n        // Deploy and initialize mock access control\n        accessControl = new MockAccessControl();\n\n        // Deploy and initialize fee auction with proxy\n        FeeAuction feeAuctionImpl = new FeeAuction();\n        address proxy = _proxy(address(feeAuctionImpl));\n        feeAuction = FeeAuction(proxy);\n        feeAuction.initialize(address(accessControl), address(mockTokens[0]), address(this), 1 days, 1e18);\n\n        // Deploy insurance fund\n        insuranceFund = makeAddr(\"insurance_fund\");\n\n        // Deploy and initialize vault\n        vault = new TestVault();\n        vault.initialize(\n            \"Test Vault\",\n            \"tVAULT\",\n            address(accessControl),\n            address(feeAuction),\n            address(mockOracle),\n            assets,\n            address(insuranceFund)\n        );\n        mockOracle.setPrice(address(vault), 1e18);\n\n        // Setup initial test accounts\n        for (uint256 i = 0; i < 5; i++) {\n            address user = makeAddr(string(abi.encodePacked(\"User\", vm.toString(i))));\n            tokenHolders.push(user);\n            isHolder[user] = true;\n        }\n\n        // Create fractional reserve vaults, one for each asset\n        fractionalReserveVaults = new address[](3);\n        for (uint256 i = 0; i < 3; i++) {\n            address asset = assets[i];\n            address frVault = address(new MockERC4626(asset, 1e18, \"Fractional Reserve Vault\", \"FRV\"));\n            MockERC4626(frVault).setInterestRate(uint256(0.1e18));\n\n            fractionalReserveVaults[i] = frVault;\n            vault.setFractionalReserveVault(asset, frVault);\n\n            MockERC4626(frVault).__mockYield();\n        }\n\n        // Create and target handler\n        handler = new TestVaultHandler(vault, mockOracle, assets, tokenHolders, fractionalReserveVaults);\n        targetContract(address(handler));\n\n        // we need to set an appropriate block.number and block.timestamp for the tests\n        // otherwise they will default to 0 and the tests will fail trying to subtract staleness from 0\n        vm.roll(block.number + 1_000_000);\n        vm.warp(block.timestamp + 1_000_000);\n    }\n\n    function test_fuzzing_non_regression_loss_from_fractional_reserve_1() public {\n        //[FAIL: custom error 0x95969727: 0000000000000000000000002e234dae75c793f67a35089c9d99245e1c58470b000000000000000000000000d6bbde9174b1cdaa358d2cf4d57d1a9f7178fbff0000000000000000000000000000000000000000000000000000000000000001]\n        //[Sequence]\n        //        sender=0x8d8C714C6790785D0cD4C75935622498F1A76184 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=pause(uint256) args=[7675797 [7.675e6]]\n        //        sender=0x00000000000000000000000000000000dcD713EE addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=removeAsset(uint256) args=[14837635802857839438797466 [1.483e25]]\n        //        sender=0x00000000000000000000000000000000F6A916fd addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=donateAsset(uint256,uint256) args=[9745, 3022]\n        //        sender=0x0000000000000000000000000000000000001C71 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=pause(uint256) args=[9929]\n        //        sender=0x0000000000000000000000000000000000000EA1 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=addAsset(uint256) args=[76715587 [7.671e7]]\n        //        sender=0x3C9425bc7770077e68f6a1477D31a938683C316C addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=investAll(uint256) args=[15078001 [1.507e7]]\n        //        sender=0x000000000000000000000000000000000000249E addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=setVaultReserve(uint256,uint256) args=[115792089237316195423570985008687907853269984665640564039457584007913129639934 [1.157e77], 11]\n        //        sender=0x0000000000000000000000000000000352e302E2 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=divestAll(uint256) args=[725553526815472735717947576826637183330969562685975748313 [7.255e56]]\n        //        sender=0x0000000000000000000000000000000000000435 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=investAll(uint256) args=[13690861936455249355276266665598585 [1.369e34]]\n        //        sender=0x00000000000000000000000000000000000005d9 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=setFractionalReserveVault(uint256) args=[44123055 [4.412e7]]\n        // invariant_mintingIncreaseBalance() (runs: 749, calls: 149800, reverts: 1)\n\n        handler.pause(7675797);\n        handler.removeAsset(14837635802857839438797466);\n        handler.donateAsset(9745, 3022);\n        handler.pause(9929);\n        handler.addAsset(76715587);\n        handler.investAll(15078001);\n        handler.setVaultReserve(115792089237316195423570985008687907853269984665640564039457584007913129639934, 11);\n        handler.divestAll(725553526815472735717947576826637183330969562685975748313);\n        handler.investAll(13690861936455249355276266665598585);\n        handler.setFractionalReserveVault(44123055);\n    }\n\n    function test_fuzzing_non_regression_loss_from_fractional_reserve_2() public {\n        //[FAIL: custom error 0x95969727: 0000000000000000000000002e234dae75c793f67a35089c9d99245e1c58470b00000000000000000000000082dce515b19ca6c2b03060d7da1a9670fc6ee0740000000000000000000000000000000000000000000000000000000000000001]\n        //[Sequence]\n        //        sender=0xc7CdCe7CC669d77218fC42e5CC422ea19412eA2D addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=donateAsset(uint256,uint256) args=[3157, 2799]\n        //        sender=0x000000000000000000000000000000000000137B addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=pause(uint256) args=[3]\n        //        sender=0x0000000000000000000000000000000000000763 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=investAll(uint256) args=[4154]\n        //        sender=0x0000000000000000000000000000000000000FbB addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=pause(uint256) args=[197286539840145 [1.972e14]]\n        //        sender=0x000000000000000000000000000000000000045A addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=divestAll(uint256) args=[210304242682445377544489621833662242505594976 [2.103e44]]\n        //        sender=0x000000000000000000000000000000000000059a addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=investAll(uint256) args=[30284156 [3.028e7]]\n        //        sender=0x0000000000000000000000000000000000000C79 addr=[test/vault/Vault.invariants.t.sol:TestVaultHandler]0x212224D2F2d262cd093eE13240ca4873fcCBbA3C calldata=setFractionalReserveVault(uint256) args=[124512733235148509670984850249661524172173354937 [1.245e47]]\n        // invariant_totalAssetsExceedBorrowed() (runs: 1180, calls: 236000, reverts: 1)\n\n        handler.donateAsset(3157, 2799);\n        handler.pause(3);\n        handler.investAll(4154);\n        handler.pause(197286539840145);\n        handler.divestAll(210304242682445377544489621833662242505594976);\n        handler.investAll(30284156);\n        handler.setFractionalReserveVault(124512733235148509670984850249661524172173354937);\n    }\n\n    /// @dev Test that total assets >= total borrowed\n    function invariant_totalAssetsExceedBorrowed() public view {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            uint256 totalAssets = vault.totalSupplies(asset);\n            uint256 totalBorrowed = vault.totalBorrows(asset);\n            assertGe(totalAssets, totalBorrowed, \"Total assets must exceed borrowed\");\n        }\n    }\n\n    /// @dev Test that minting increases asset balance correctly\n    function invariant_mintingIncreaseBalance() public {\n        address[] memory unpausedAssets = handler.getVaultUnpausedAssets();\n\n        for (uint256 i = 0; i < unpausedAssets.length; i++) {\n            address asset = unpausedAssets[i];\n\n            uint256 amount = 1000 * (10 ** IERC20Metadata(asset).decimals());\n            if (amount == 0) continue;\n\n            uint256 balanceBefore = IERC20(asset).balanceOf(address(vault));\n            uint256 supplyBefore = vault.totalSupplies(asset);\n\n            address minter = makeAddr(\"Minter\");\n            MockERC20(asset).mint(minter, amount);\n\n            vm.startPrank(minter);\n            IERC20(asset).approve(address(vault), amount);\n            vault.mint(asset, amount, 0, minter, block.timestamp);\n            vm.stopPrank();\n\n            uint256 balanceAfter = IERC20(asset).balanceOf(address(vault));\n            uint256 supplyAfter = vault.totalSupplies(asset);\n\n            assertEq(balanceAfter - balanceBefore, amount, \"Asset balance should increase by exact amount\");\n            assertTrue(supplyAfter > supplyBefore, \"Total supply should increase\");\n        }\n    }\n}\n\ncontract TestVault is Vault {\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _accessControl,\n        address _feeAuction,\n        address _oracle,\n        address[] calldata _assets,\n        address _insuranceFund\n    ) external initializer {\n        __Vault_init(_name, _symbol, _accessControl, _feeAuction, _oracle, _assets, _insuranceFund);\n    }\n}\n/**\n * @notice This is a helper contract to test the vault invariants in a meaningful way\n */\n\ncontract TestVaultHandler is StdUtils, RandomActorUtils, RandomAssetUtils {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    Vault public vault;\n    MockOracle public mockOracle;\n\n    address[] public assets;\n    address[] public actors;\n    address[] public fractionalReserveVaults;\n    uint256 private constant MAX_ASSETS = 10;\n\n    constructor(\n        Vault _vault,\n        MockOracle _mockOracle,\n        address[] memory _assets,\n        address[] memory _actors,\n        address[] memory _fractionalReserveVaults\n    ) RandomActorUtils(_actors) RandomAssetUtils(_assets) {\n        vault = _vault;\n        mockOracle = _mockOracle;\n        assets = _assets;\n        actors = _actors;\n        fractionalReserveVaults = _fractionalReserveVaults;\n\n        for (uint256 i = 0; i < _fractionalReserveVaults.length; i++) {\n            MockERC4626(_fractionalReserveVaults[i]).setInterestRate(uint256(0.1e18));\n            MockERC4626(_fractionalReserveVaults[i]).__mockYield();\n        }\n    }\n\n    function getVaultUnpausedAssets() public view returns (address[] memory) {\n        address[] memory vaultAssets = vault.assets();\n        address[] memory tmp = new address[](vaultAssets.length);\n        uint256 tmpIndex = 0;\n        for (uint256 i = 0; i < vaultAssets.length; i++) {\n            address asset = vaultAssets[i];\n            if (!vault.paused(asset)) {\n                tmp[tmpIndex++] = asset;\n            }\n        }\n\n        address[] memory result = new address[](tmpIndex);\n        for (uint256 i = 0; i < tmpIndex; i++) {\n            result[i] = tmp[i];\n        }\n        return result;\n    }\n\n    function _isAssetInVault(address asset) internal view returns (bool) {\n        address[] memory vaultAssets = vault.assets();\n        for (uint256 i = 0; i < vaultAssets.length; i++) {\n            if (vaultAssets[i] == asset) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function wrapTime(uint256 timeSeed, uint256 blockNumberSeed) external returns (uint256) {\n        uint256 timestamp = bound(timeSeed, block.timestamp, block.timestamp + 100 days);\n        vm.warp(timestamp);\n\n        uint256 blockNumber = bound(blockNumberSeed, block.number, block.number + 1000000);\n        vm.roll(blockNumber);\n\n        return timestamp;\n    }\n\n    function addAsset(uint256 assetSeed) external {\n        address currentAsset = randomAsset(assets, assetSeed);\n        if (currentAsset == address(0)) return;\n        if (_isAssetInVault(currentAsset)) return;\n\n        address[] memory unpausedAssets = getVaultUnpausedAssets();\n        if (unpausedAssets.length >= MAX_ASSETS) return;\n\n        vault.addAsset(currentAsset);\n    }\n\n    function approve(uint256 actorSeed, uint256 spenderSeed, uint256 amount) external {\n        address currentSpender = randomActor(spenderSeed);\n        if (currentSpender == address(0)) return;\n        address currentActor = randomActor(actorSeed);\n        if (currentActor == address(0)) return;\n        amount = bound(amount, 0, type(uint96).max); // Reasonable bound for approval\n        if (amount == 0) return;\n\n        vm.startPrank(currentActor);\n        vault.approve(currentSpender, amount);\n        vm.stopPrank();\n    }\n\n    function borrow(uint256 actorSeed, uint256 assetSeed, uint256 amount) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        address currentActor = randomActor(actorSeed);\n        if (currentActor == address(0)) return;\n\n        uint256 maxBorrow = vault.availableBalance(currentAsset);\n        amount = bound(amount, 0, Math.min(maxBorrow, type(uint96).max)); // Reasonable bound for borrow\n\n        vm.startPrank(currentActor);\n        vault.borrow(currentAsset, amount, currentActor);\n        vm.stopPrank();\n    }\n\n    function burn(uint256 actorSeed, uint256 assetSeed, uint256 amount) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        address currentActor = randomActor(actorSeed);\n        if (currentActor == address(0)) return;\n\n        uint256 maxBurn = vault.balanceOf(currentActor);\n        if (maxBurn == 0) return;\n\n        amount = bound(amount, 1, Math.min(maxBurn, type(uint96).max)); // Reasonable bound for burn\n\n        vm.startPrank(currentActor);\n        vault.burn(currentAsset, amount, 0, currentActor, block.timestamp);\n        vm.stopPrank();\n    }\n\n    function divestAll(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        uint256 loaned = vault.loaned(currentAsset);\n        if (loaned < 1e6) return;\n\n        vm.warp(block.timestamp + 1 days);\n\n        vault.divestAll(currentAsset);\n    }\n\n    function investAll(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n        vault.investAll(currentAsset);\n    }\n\n    function mint(uint256 actorSeed, uint256 assetSeed, uint256 amountSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        address currentActor = randomActor(actorSeed);\n        if (currentActor == address(0)) return;\n\n        uint256 maxMint = vault.availableBalance(currentAsset);\n        if (maxMint == 0) return;\n        uint256 amount = bound(amountSeed, 1, Math.min(maxMint, type(uint96).max)); // Reasonable bound for mint\n\n        vm.startPrank(currentActor);\n        // Mint tokens to the actor first\n        MockERC20(currentAsset).mint(currentActor, amount);\n\n        IERC20(currentAsset).approve(address(vault), amount);\n        vault.mint(currentAsset, amount, 0, currentActor, block.timestamp);\n        vm.stopPrank();\n    }\n\n    function redeem(uint256 actorSeed, uint256 amount) external {\n        address currentActor = randomActor(actorSeed);\n        if (currentActor == address(0)) return;\n\n        uint256 maxRedeem = vault.balanceOf(currentActor);\n        if (maxRedeem == 0) return;\n\n        amount = bound(amount, 1, Math.min(maxRedeem, type(uint96).max)); // Reasonable bound for redeem\n\n        uint256[] memory amountsOut = new uint256[](1);\n        amountsOut[0] = 0;\n\n        vm.startPrank(currentActor);\n        vault.redeem(amount, amountsOut, currentActor, block.timestamp);\n        vm.stopPrank();\n    }\n\n    function removeAsset(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        vault.removeAsset(currentAsset);\n    }\n\n    function repay(uint256 actorSeed, uint256 assetSeed, uint256 amount) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        address currentActor = randomActor(actorSeed);\n        if (currentActor == address(0)) return;\n\n        uint256 maxRepay = vault.availableBalance(currentAsset);\n        amount = bound(amount, 0, Math.min(maxRepay, type(uint96).max)); // Reasonable bound for repay\n\n        vm.startPrank(currentActor);\n        // Mint tokens to the actor first\n        MockERC20(currentAsset).mint(currentActor, amount);\n\n        IERC20(currentAsset).approve(address(vault), amount);\n        vault.repay(currentAsset, amount);\n    }\n\n    function rescueERC20(IERC20 asset, uint256 receiverSeed) external {\n        address currentActor = randomActor(receiverSeed);\n        if (currentActor == address(0)) return;\n        if (address(asset).code.length == 0) {\n            return;\n        }\n        if (_isAssetInVault(address(asset))) return;\n\n        try IERC20(asset).balanceOf(address(vault)) returns (uint256 amount) {\n            if (amount > 0) {\n                vault.rescueERC20(address(asset), currentActor);\n            }\n        } catch {\n            // Do nothing if the asset is not in the vault\n        }\n    }\n\n    function pause(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        vault.pause(currentAsset);\n    }\n\n    function unpause(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        vault.unpause(currentAsset);\n    }\n\n    function setAssetOraclePrice(uint256 assetSeed, uint256 price) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        uint256 decimals = IERC20Metadata(currentAsset).decimals();\n        uint256 boundPrice = bound(price, 10 ** (decimals - 1), 10 ** decimals);\n        mockOracle.setPrice(currentAsset, boundPrice);\n    }\n\n    // TODO: make it external again after fixing the tests\n    function ______________________setVaultFeeData(\n        uint256 assetSeed,\n        uint256 slope0Seed,\n        uint256 slope1Seed,\n        uint256 mintKinkRatioSeed,\n        uint256 burnKinkRatioSeed,\n        uint256 optimalRatioSeed\n    ) internal {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        uint256 slope0 = bound(slope0Seed, 0.0000000000001e27, 100000001e27);\n        uint256 slope1 = bound(slope1Seed, slope0, 100000001e27);\n        uint256 mintKinkRatio = bound(mintKinkRatioSeed, 0.0000000000001e27, 100000001e27);\n        uint256 burnKinkRatio = bound(burnKinkRatioSeed, 0.0000000000001e27, 100000001e27);\n        uint256 optimalRatio = bound(optimalRatioSeed, 0.0000000000001e27, 100000001e27);\n\n        vault.setFeeData(\n            currentAsset,\n            IMinter.FeeData({\n                minMintFee: 0.005e27,\n                slope0: slope0,\n                slope1: slope1,\n                mintKinkRatio: mintKinkRatio,\n                burnKinkRatio: burnKinkRatio,\n                optimalRatio: optimalRatio\n            })\n        );\n    }\n\n    function setVaultRedeemFee(uint256 redeemFeeSeed) external {\n        uint256 redeemFee = bound(redeemFeeSeed, 0, type(uint256).max);\n        vault.setRedeemFee(redeemFee);\n    }\n\n    function setVaultReserve(uint256 assetSeed, uint256 reserve) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n        vault.setReserve(currentAsset, reserve);\n    }\n\n    function realizeInterest(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n        vault.realizeInterest(currentAsset);\n    }\n\n    function setFractionalReserveVault(uint256 assetSeed) external {\n        address currentAsset = randomAsset(getVaultUnpausedAssets(), assetSeed);\n        if (currentAsset == address(0)) return;\n\n        uint256 loaned = vault.loaned(currentAsset);\n        if (loaned < 1e6) return;\n\n        address newFractionalReserveVault =\n            address(new MockERC4626(currentAsset, 1e18, \"Fractional Reserve Vault\", \"FRV\"));\n\n        vm.warp(block.timestamp + 1 days);\n\n        vault.setFractionalReserveVault(currentAsset, newFractionalReserveVault);\n    }\n\n    // @dev Donate tokens to the lender's vault\n    function donateAsset(uint256 assetSeed, uint256 amountSeed) external {\n        address currentAsset = randomAsset(assetSeed);\n        if (currentAsset == address(0)) return;\n\n        uint256 amount = bound(amountSeed, 1, 1e50);\n        MockERC20(currentAsset).mint(address(vault), amount);\n    }\n\n    function donateGasToken(uint256 amountSeed) external {\n        uint256 amount = bound(amountSeed, 1, 1e50);\n        vm.deal(address(vault), amount /* we need gas to send gas */ );\n    }\n}\n"
    }
}