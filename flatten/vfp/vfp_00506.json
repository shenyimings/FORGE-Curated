{
    "vfp_id": "vfp_00506",
    "project_name": "Parallel Protocol - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Migrating PRL tokens to another chain may fail due to insufficient gas",
            "description": "The migrateToPRL and migrateToPRLAndBridge functions allow users to migrate tokens across chains using LayerZero, with gas provided via msg.value. However, there is no validation that the provided gas is sufficient for the final step of the migration on the destination chain. The _lzReceive function in PrincipalMigrationContract uses msg.value directly as gas for the LockBox.send call without checking against a minimum required fee. The root cause is the lack of a gas adequacy check before attempting the final token minting and bridging. An attacker cannot directly exploit this, but users may suffer failed migrations if insufficient gas is provided, leading to a poor user experience and potential loss of migration fees. The impact includes failed transactions on the destination chain, stranded funds, and reduced reliability of the cross-chain migration mechanism.\n",
            "severity": "Medium",
            "location": [
                "PrincipalMigrationContract.sol#migrateToPRL",
                "PrincipalMigrationContract.sol#_lzReceive",
                "LockBox::send"
            ],
            "files": [
                "0f35481fa57cd217066816fb4fa9318baf67d319/PRL-token/contracts/principal/PrincipalMigrationContract.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Paying fees with LzToken is not allowed in the migrateToPRLAndBridge function of the PrincipalMigrationContract",
            "description": "The migrateToPRLAndBridge function does not prevent users from specifying a non-zero lzTokenFee in the MessagingFee parameter. However, the function does not transfer LzToken to the endpoint, and the underlying _payLzToken function will revert if msg.sender does not approve or transfer the required LzToken amount. The root cause is the lack of a validation check on _fee.lzTokenFee before proceeding with the transaction. An attacker could craft a call with lzTokenFee > 0 to cause the transaction to revert, potentially as a denial-of-service vector. The impact is transaction failure and wasted gas for users who mistakenly or maliciously set lzTokenFee, reducing the reliability and usability of the migration function.\n",
            "severity": "Low",
            "location": [
                "PrincipalMigrationContract.sol#migrateToPRLAndBridge",
                "OAppSender.sol::_payLzToken"
            ],
            "files": [
                "0f35481fa57cd217066816fb4fa9318baf67d319/PRL-token/contracts/principal/PrincipalMigrationContract.sol"
            ]
        }
    ],
    "affected_files": {
        "PrincipalMigrationContract.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { OAppReceiver, Origin } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport { OAppCore } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\";\nimport { OAppOptionsType3 } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol\";\n\nimport { SendParam, MessagingFee, IOFT } from \"contracts/layerZero/interfaces/IOFT.sol\";\nimport { OFTMsgCodec } from \"contracts/layerZero/libs/OFTMsgCodec.sol\";\n\nimport { ErrorsLib } from \"contracts/libraries/ErrorsLib.sol\";\n\n/// @title PrincipalMigrationContract\n/// @author Cooper Labs\n/// @custom:contact security@cooperlabs.xyz\n/// @notice LayerZero OappReceiver contract.\n/// Messages received will contain the amount of Mimo the user want to migrate and the chain he want to receive it.\n/// @dev This contract will use the LockBox contract to bridge PRL to the destination chain that user specified.\ncontract PrincipalMigrationContract is OAppReceiver, OAppOptionsType3, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    uint256 private constant EXTRA_OPTION_START = 192;\n    /// MIMO contract token\n    IERC20 public immutable MIMO;\n    /// PRL contract token\n    IERC20 public immutable PRL;\n    /// LayerZero's OFTAdapter used to send PRL token to other chains\n    IOFT public immutable lockBox;\n\n    //-------------------------------------------\n    // Events\n    //-------------------------------------------\n\n    /// @notice Emitted when MIMO tokens are migrated to PRL tokens directly on this chain.\n    /// @param caller The address that initiate the migration.\n    /// @param receiver The address receiving the PRL tokens.\n    /// @param amount The amount of MIMO tokens migrated to PRL tokens.\n    event MIMOToPRLMigrated(address caller, address receiver, uint256 amount);\n\n    /// @notice Emitted when MIMO tokens are migrated to PRL tokens and bridged to another chain.\n    /// @param caller The address that initiate the migration.\n    /// @param receiver The address receiving the PRL tokens.\n    /// @param sendParam The SendParam struct send to the LockBox contract.\n    /// @param fee The MessagingFee struct paid for the bridging.\n    event MIMOToPRLMigratedAndBridged(address caller, address receiver, SendParam sendParam, MessagingFee fee);\n\n    /// @notice Emitted when a migration message is received\n    /// @param guid The unique identifier of the received message\n    /// @param srcEid The source endpoint ID\n    /// @param sender The address of the sender\n    /// @param destEid The destination endpoint ID\n    /// @param receiver The address of the receiver\n    /// @param mimoAmount The amount of tokens being migrated\n    /// @param prlAmount The amount of PRL tokens to be received\n    event MigrationMessageReceived(\n        bytes32 guid,\n        uint32 srcEid,\n        address sender,\n        uint32 destEid,\n        address receiver,\n        uint256 mimoAmount,\n        uint256 prlAmount\n    );\n\n    /// @notice Emitted when tokens are rescued in an emergency\n    /// @param token The address of the rescued token\n    /// @param amount The amount of tokens rescued\n    /// @param recipient The address that received the rescued tokens\n    event EmergencyRescued(address indexed token, uint256 amount, address indexed recipient);\n\n    //-------------------------------------------\n    // Constructor\n    //-------------------------------------------\n\n    /// @notice Constructor for PrincipalMigrationContract\n    /// @param _mimo Address of the MIMO token contract\n    /// @param _prl Address of the PRL token contract\n    /// @param _lockBox Address of the PRL bridge contract (OFTAdapter)\n    /// @param _endpoint Address of the LayerZero endpoint\n    /// @param _owner Address of the contract owner\n    constructor(\n        address _mimo,\n        address _prl,\n        address _lockBox,\n        address _endpoint,\n        address _owner\n    )\n        OAppCore(_endpoint, _owner)\n        Ownable(_owner)\n    {\n        if (_mimo == address(0)) revert ErrorsLib.AddressZero();\n        if (_prl == address(0)) revert ErrorsLib.AddressZero();\n        if (_lockBox == address(0)) revert ErrorsLib.AddressZero();\n        MIMO = IERC20(_mimo);\n        PRL = IERC20(_prl);\n        lockBox = IOFT(_lockBox);\n    }\n\n    //-------------------------------------------\n    // External functions\n    //-------------------------------------------\n\n    /// @notice Migrates MIMO tokens to PRL tokens\n    /// @param _amount The amount of MIMO tokens to migrate\n    function migrateToPRL(uint256 _amount, address _recipient) external whenNotPaused nonReentrant {\n        emit MIMOToPRLMigrated(msg.sender, _recipient, _amount);\n        MIMO.safeTransferFrom(msg.sender, address(this), _amount);\n        PRL.safeTransfer(_recipient, _amount);\n    }\n\n    /// @notice Migrates MIMO tokens to PRL tokens and bridges them to another chain\n    /// @param _sendParam The parameters for the send operation.\n    /// @param _fee The calculated fees for the send() operation.\n    ///      - nativeFee: The native fees.\n    ///      - lzTokenFee: The lzToken fees.\n    function migrateToPRLAndBridge(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n    {\n        if (_refundAddress == address(0)) revert ErrorsLib.AddressZero();\n        emit MIMOToPRLMigratedAndBridged(msg.sender, _sendParam.to.bytes32ToAddress(), _sendParam, _fee);\n        MIMO.safeTransferFrom(msg.sender, address(this), _sendParam.amount);\n        PRL.approve(address(lockBox), _sendParam.amount);\n        lockBox.send{ value: msg.value }(_sendParam, _fee, _refundAddress);\n    }\n\n    /// @notice Fallback function to receive Ether\n    /// @dev This function allows the contract to receive Ether. It's required for\n    ///      handling native token refunds from LayerZero or any other operations\n    ///      that might send Ether to this contract.\n    receive() external payable { }\n\n    //-------------------------------------------\n    // OnlyOwner functions\n    //-------------------------------------------\n\n    /// @notice Allows the owner to rescue any ERC20 token from the contract in case of emergency\n    /// @dev This function can only be called by the owner and only when the contract is paused\n    /// @param _token The address of the ERC20 token to rescue\n    /// @param _amount The amount of tokens to rescue\n    function emergencyRescue(address _token, uint256 _amount) external onlyOwner whenPaused {\n        emit EmergencyRescued(_token, _amount, msg.sender);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /// @notice Allow owner to pause the contract\n    /// @dev This function can only be called by the owner\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Allow owner to unpause the contract\n    /// @dev This function can only be called by the owner\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //-------------------------------------------\n    // Internal functions\n    //-------------------------------------------\n\n    /// @dev Internal function to handle the received message on the LayerZero endpoint.\n    /// @param _origin The origin information.\n    ///  - srcEid: The source chain endpoint ID.\n    ///  - sender: The sender address from the src chain.\n    ///  - nonce: The nonce of the LayerZero message.\n    /// @param _guid The unique identifier for the received LayerZero message.\n    /// @param _message The encoded message.\n    /// @dev _executor The address of the executor.\n    /// @dev _extraData Additional data.\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    )\n        internal\n        override\n    {\n        (address receiver, uint256 amount, uint32 destEid, uint256 extraOptionsLength) = _decodeMessage(_message);\n        emit MigrationMessageReceived(\n            _guid, _origin.srcEid, _origin.sender.bytes32ToAddress(), destEid, receiver, amount, amount\n        );\n\n        if (extraOptionsLength == 0 || destEid == endpoint.eid()) {\n            emit MIMOToPRLMigrated(_origin.sender.bytes32ToAddress(), receiver, amount);\n            PRL.safeTransfer(receiver, amount);\n        } else {\n            SendParam memory sendParam = _buildSendParam(_message, receiver, amount, destEid, extraOptionsLength);\n            emit MIMOToPRLMigratedAndBridged(\n                _origin.sender.bytes32ToAddress(), receiver, sendParam, MessagingFee(msg.value, 0)\n            );\n            PRL.approve(address(lockBox), amount);\n            lockBox.send{ value: msg.value }(sendParam, MessagingFee(msg.value, 0), receiver);\n        }\n    }\n\n    /// @notice Decodes the received LayerZero message\n    /// @param _encodedMessage The encoded message received from LayerZero\n    /// @return receiver The address of the receiver\n    /// @return amount The amount of tokens being migrated\n    /// @return destEid The destination endpoint ID\n    /// @return extraOptionsLength The length of extra options in the message\n    function _decodeMessage(bytes calldata _encodedMessage)\n        public\n        pure\n        returns (address receiver, uint256 amount, uint32 destEid, uint256 extraOptionsLength)\n    {\n        // Decode the first part of the message\n        (bytes32 _to, uint256 _amount, uint32 _destEid, uint256 _extraOptionsLength) =\n            abi.decode(_encodedMessage, (bytes32, uint256, uint32, uint256));\n        return (_to.bytes32ToAddress(), _amount, _destEid, _extraOptionsLength);\n    }\n\n    /// @notice Builds the SendParam struct for the OFT bridge\n    /// @param _encodedMessage The encoded message received from LayerZero\n    /// @param _receiver The address of the receiver\n    /// @param _finalAmount The final amount of PRL tokens to be sent\n    /// @param _destEid The destination endpoint ID\n    /// @param _extraOptionsLength The length of extra options in the message\n    /// @return params The SendParam struct for the OFT bridge\n    function _buildSendParam(\n        bytes calldata _encodedMessage,\n        address _receiver,\n        uint256 _finalAmount,\n        uint32 _destEid,\n        uint256 _extraOptionsLength\n    )\n        internal\n        pure\n        returns (SendParam memory params)\n    {\n        bytes memory _options = _encodedMessage[EXTRA_OPTION_START:EXTRA_OPTION_START + _extraOptionsLength];\n        return\n            SendParam(_destEid, OFTMsgCodec.addressToBytes32(_receiver), _finalAmount, _finalAmount, _options, \"\", \"\");\n    }\n}\n"
    }
}