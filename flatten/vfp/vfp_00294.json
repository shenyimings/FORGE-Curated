{
    "vfp_id": "vfp_00294",
    "project_name": "EVM Universal Adapter Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-346"
                ]
            },
            "title": "Unverified SOURCE_CHAIN_ID in Universal_SpokePool Constructor",
            "description": "The Universal_SpokePool contract integrates with the SP1Helios contract to verify Ethereum beacon chain state updates using zero-knowledge proofs. The SP1Helios contract has an immutable SOURCE_CHAIN_ID, typically set to 1 (Ethereum), but the Universal_SpokePool constructor does not validate that the connected SP1Helios instance has the correct SOURCE_CHAIN_ID. This omission creates a misconfiguration risk where a Universal_SpokePool could be initialized with a SP1Helios contract pointing to an unintended source chain, potentially allowing invalid or malicious state updates to be accepted. The root cause is the lack of a validation check during initialization, relying instead on administrative diligence. An attacker could exploit this by deploying or configuring a Universal_SpokePool with a malicious or incorrect SP1Helios instance, leading to acceptance of fraudulent cross-chain messages. The impact includes compromise of data integrity and potential loss of funds if incorrect state roots are accepted. While the team acknowledges this and places responsibility on the HubPool admin to verify configuration, the absence of an on-chain check increases operational risk. This is classified as low severity due to the assumption of trusted deployment processes.\n",
            "severity": "Low",
            "location": [
                "Universal_SpokePool.sol#constructor",
                "SP1Helios.sol::SOURCE_CHAIN_ID#30"
            ],
            "files": [
                "contracts/contracts/Universal_SpokePool.sol",
                "sp1-helios/contracts/src/SP1Helios.sol"
            ]
        }
    ],
    "affected_files": {
        "SP1Helios.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {ISP1Verifier} from \"@sp1-contracts/ISP1Verifier.sol\";\nimport {AccessControlEnumerable} from \"@openzeppelin/access/extensions/AccessControlEnumerable.sol\";\n\n/// @title SP1Helios\n/// @notice An Ethereum beacon chain light client, built with SP1 and Helios.\n/// @dev This contract uses SP1 zero-knowledge proofs to verify updates to the Ethereum beacon chain state.\n/// The contract stores the latest verified beacon chain header, execution state root, and sync committee information.\n/// It also provides functionality to verify and store Ethereum storage slot values.\n/// Updater permissions are fixed at contract creation time and cannot be modified afterward.\ncontract SP1Helios is AccessControlEnumerable {\n    /// @notice The genesis validators root for the beacon chain\n    bytes32 public immutable GENESIS_VALIDATORS_ROOT;\n\n    /// @notice The timestamp at which the beacon chain genesis block was processed\n    uint256 public immutable GENESIS_TIME;\n\n    /// @notice The number of seconds in a slot on the beacon chain\n    uint256 public immutable SECONDS_PER_SLOT;\n\n    /// @notice The number of slots in a sync committee period\n    uint256 public immutable SLOTS_PER_PERIOD;\n\n    /// @notice The number of slots in an epoch on the beacon chain\n    uint256 public immutable SLOTS_PER_EPOCH;\n\n    /// @notice The chain ID of the source blockchain\n    uint256 public immutable SOURCE_CHAIN_ID;\n\n    /// @notice Role for updater operations\n    bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n    /// @notice Maximum number of time behind current timestamp for a block to be used for proving\n    /// @dev This is set to 1 week to prevent timing attacks where malicious validators\n    /// could retroactively create forks that diverge from the canonical chain. To minimize this\n    /// risk, we limit the maximum age of a block to 1 week.\n    uint256 public constant MAX_SLOT_AGE = 1 weeks;\n\n    /// @notice The latest slot the light client has a finalized header for\n    uint256 public head;\n\n    /// @notice Maps from a slot to a beacon block header root\n    mapping(uint256 => bytes32) public headers;\n\n    /// @notice Maps from a slot to the current finalized execution state root\n    mapping(uint256 => bytes32) public executionStateRoots;\n\n    /// @notice Maps from a period to the hash for the sync committee\n    mapping(uint256 => bytes32) public syncCommittees;\n\n    /// @notice Maps from (block number, contract, slot) tuple to storage value\n    mapping(bytes32 => bytes32) public storageValues;\n\n    /// @notice The verification key for the SP1 Helios program\n    bytes32 public immutable heliosProgramVkey;\n\n    /// @notice The deployed SP1 verifier contract\n    address public immutable verifier;\n\n    /// @notice Represents a storage slot in an Ethereum smart contract\n    struct StorageSlot {\n        bytes32 key;\n        bytes32 value;\n        address contractAddress;\n    }\n\n    /// @notice The outputs from a verified SP1 proof\n    struct ProofOutputs {\n        bytes32 executionStateRoot;\n        bytes32 newHeader;\n        bytes32 nextSyncCommitteeHash;\n        uint256 newHead;\n        bytes32 prevHeader;\n        uint256 prevHead;\n        bytes32 syncCommitteeHash;\n        bytes32 startSyncCommitteeHash;\n        StorageSlot[] slots;\n    }\n\n    /// @notice Parameters for initializing the SP1Helios contract\n    struct InitParams {\n        bytes32 executionStateRoot;\n        uint256 genesisTime;\n        bytes32 genesisValidatorsRoot;\n        uint256 head;\n        bytes32 header;\n        bytes32 heliosProgramVkey;\n        uint256 secondsPerSlot;\n        uint256 slotsPerEpoch;\n        uint256 slotsPerPeriod;\n        uint256 sourceChainId;\n        bytes32 syncCommitteeHash;\n        address verifier;\n        address[] updaters;\n    }\n\n    event HeadUpdate(uint256 indexed slot, bytes32 indexed root);\n\n    event SyncCommitteeUpdate(uint256 indexed period, bytes32 indexed root);\n\n    event StorageSlotVerified(\n        uint256 indexed head, bytes32 indexed key, bytes32 value, address contractAddress\n    );\n    event UpdaterAdded(address indexed updater);\n\n    error SlotBehindHead(uint256 slot);\n    error SyncCommitteeAlreadySet(uint256 period);\n    error InvalidHeaderRoot(uint256 slot);\n    error InvalidStateRoot(uint256 slot);\n    error SyncCommitteeStartMismatch(bytes32 given, bytes32 expected);\n    error PreviousHeadNotSet(uint256 slot);\n    error PreviousHeadTooOld(uint256 slot);\n    error NoUpdatersProvided();\n\n    /// @notice Initializes the SP1Helios contract with the provided parameters\n    /// @dev Sets up immutable contract state and grants the UPDATER_ROLE to the provided updaters\n    /// @param params The initialization parameters\n    constructor(InitParams memory params) {\n        GENESIS_VALIDATORS_ROOT = params.genesisValidatorsRoot;\n        GENESIS_TIME = params.genesisTime;\n        SECONDS_PER_SLOT = params.secondsPerSlot;\n        SLOTS_PER_PERIOD = params.slotsPerPeriod;\n        SLOTS_PER_EPOCH = params.slotsPerEpoch;\n        SOURCE_CHAIN_ID = params.sourceChainId;\n        syncCommittees[getSyncCommitteePeriod(params.head)] = params.syncCommitteeHash;\n        heliosProgramVkey = params.heliosProgramVkey;\n        headers[params.head] = params.header;\n        executionStateRoots[params.head] = params.executionStateRoot;\n        head = params.head;\n        verifier = params.verifier;\n\n        // Make sure at least one updater is provided\n        if (params.updaters.length == 0) {\n            revert NoUpdatersProvided();\n        }\n\n        // Make UPDATER_ROLE not have any admin roles that can manage it\n        // This freezes the updater set - no role can add or remove updaters\n        _setRoleAdmin(UPDATER_ROLE, bytes32(0));\n\n        // Add all updaters\n        for (uint256 i = 0; i < params.updaters.length; i++) {\n            address updater = params.updaters[i];\n            if (updater != address(0)) {\n                _grantRole(UPDATER_ROLE, updater);\n                emit UpdaterAdded(updater);\n            }\n        }\n    }\n\n    /// @notice Updates the light client with a new header, execution state root, and sync committee (if changed)\n    /// @dev Verifies an SP1 proof and updates the light client state based on the proof outputs\n    /// @param proof The proof bytes for the SP1 proof\n    /// @param publicValues The public commitments from the SP1 proof\n    /// @param fromHead The head slot to prove against\n    function update(bytes calldata proof, bytes calldata publicValues, uint256 fromHead)\n        external\n        onlyRole(UPDATER_ROLE)\n    {\n        if (headers[fromHead] == bytes32(0)) {\n            revert PreviousHeadNotSet(fromHead);\n        }\n\n        // Check if the head being proved against is older than allowed.\n        if (block.timestamp - slotTimestamp(fromHead) > MAX_SLOT_AGE) {\n            revert PreviousHeadTooOld(fromHead);\n        }\n\n        // Parse the outputs from the committed public values associated with the proof.\n        ProofOutputs memory po = abi.decode(publicValues, (ProofOutputs));\n        if (po.newHead <= fromHead) {\n            revert SlotBehindHead(po.newHead);\n        }\n\n        uint256 currentPeriod = getSyncCommitteePeriod(fromHead);\n\n        // Note: We should always have a sync committee for the current head.\n        // The \"start\" sync committee hash is the hash of the sync committee that should sign the next update.\n        bytes32 currentSyncCommitteeHash = syncCommittees[currentPeriod];\n        if (currentSyncCommitteeHash != po.startSyncCommitteeHash) {\n            revert SyncCommitteeStartMismatch(po.startSyncCommitteeHash, currentSyncCommitteeHash);\n        }\n\n        // Verify the proof with the associated public values. This will revert if proof invalid.\n        ISP1Verifier(verifier).verifyProof(heliosProgramVkey, publicValues, proof);\n\n        // Check that the new header hasnt been set already.\n        if (headers[po.newHead] != bytes32(0) && headers[po.newHead] != po.newHeader) {\n            revert InvalidHeaderRoot(po.newHead);\n        }\n        // Set new header.\n        headers[po.newHead] = po.newHeader;\n        if (head < po.newHead) {\n            head = po.newHead;\n        }\n\n        // Check that the new state root hasnt been set already.\n        if (\n            executionStateRoots[po.newHead] != bytes32(0)\n                && executionStateRoots[po.newHead] != po.executionStateRoot\n        ) {\n            revert InvalidStateRoot(po.newHead);\n        }\n\n        // Finally set the new state root.\n        executionStateRoots[po.newHead] = po.executionStateRoot;\n        emit HeadUpdate(po.newHead, po.newHeader);\n\n        // Store all provided storage slot values\n        for (uint256 i = 0; i < po.slots.length; i++) {\n            StorageSlot memory slot = po.slots[i];\n            bytes32 storageKey = computeStorageKey(po.newHead, slot.contractAddress, slot.key);\n            storageValues[storageKey] = slot.value;\n            emit StorageSlotVerified(po.newHead, slot.key, slot.value, slot.contractAddress);\n        }\n\n        uint256 period = getSyncCommitteePeriod(po.newHead);\n\n        // If the sync committee for the new peroid is not set, set it.\n        // This can happen if the light client was very behind and had a lot of updates\n        // Note: Only the latest sync committee is stored, not the intermediate ones from every update.\n        // This may leave gaps in the sync committee history\n        if (syncCommittees[period] == bytes32(0)) {\n            syncCommittees[period] = po.syncCommitteeHash;\n            emit SyncCommitteeUpdate(period, po.syncCommitteeHash);\n        }\n        // Set next peroid's sync committee hash if value exists.\n        if (po.nextSyncCommitteeHash != bytes32(0)) {\n            uint256 nextPeriod = period + 1;\n\n            // If the next sync committee is already correct, we don't need to update it.\n            if (syncCommittees[nextPeriod] != po.nextSyncCommitteeHash) {\n                if (syncCommittees[nextPeriod] != bytes32(0)) {\n                    revert SyncCommitteeAlreadySet(nextPeriod);\n                }\n\n                syncCommittees[nextPeriod] = po.nextSyncCommitteeHash;\n                emit SyncCommitteeUpdate(nextPeriod, po.nextSyncCommitteeHash);\n            }\n        }\n    }\n\n    /// @notice Gets the sync committee period from a slot\n    /// @dev A sync committee period consists of 8192 slots (256 epochs)\n    /// @param slot The slot number to get the period for\n    /// @return The sync committee period number\n    function getSyncCommitteePeriod(uint256 slot) public view returns (uint256) {\n        return slot / SLOTS_PER_PERIOD;\n    }\n\n    /// @notice Gets the current epoch based on the latest head\n    /// @dev An epoch consists of 32 slots\n    /// @return The current epoch number\n    function getCurrentEpoch() public view returns (uint256) {\n        return head / SLOTS_PER_EPOCH;\n    }\n\n    /// @notice Gets the timestamp of a slot\n    /// @dev Calculated from GENESIS_TIME + (slot * SECONDS_PER_SLOT)\n    /// @param slot The slot number to get the timestamp for\n    /// @return The Unix timestamp in seconds for the given slot\n    function slotTimestamp(uint256 slot) public view returns (uint256) {\n        return GENESIS_TIME + slot * SECONDS_PER_SLOT;\n    }\n\n    /// @notice Gets the timestamp of the latest head\n    /// @dev Convenience function that calls slotTimestamp(head)\n    /// @return The Unix timestamp in seconds for the current head slot\n    function headTimestamp() public view returns (uint256) {\n        return slotTimestamp(head);\n    }\n\n    /// @notice Computes the key for a contract's storage slot\n    /// @dev Creates a unique key for the storage mapping based on block number, contract address, and slot\n    /// @param blockNumber The block number where the storage value was retrieved\n    /// @param contractAddress The address of the contract containing the storage slot\n    /// @param slot The storage slot key\n    /// @return A unique key for looking up the storage value\n    function computeStorageKey(uint256 blockNumber, address contractAddress, bytes32 slot)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(blockNumber, contractAddress, slot));\n    }\n\n    /// @notice Gets the value of a storage slot at a specific block\n    /// @dev Looks up storage values that have been verified and stored by this contract\n    /// @param blockNumber The block number where the storage value was retrieved\n    /// @param contractAddress The address of the contract containing the storage slot\n    /// @param slot The storage slot key\n    /// @return The value of the storage slot, or zero if not found\n    function getStorageSlot(uint256 blockNumber, address contractAddress, bytes32 slot)\n        external\n        view\n        returns (bytes32)\n    {\n        return storageValues[computeStorageKey(blockNumber, contractAddress, slot)];\n    }\n}\n",
        "Universal_SpokePool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { IHelios } from \"./external/interfaces/IHelios.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\nimport \"./SpokePool.sol\";\n\n/**\n * @notice Spoke pool capable of executing calldata stored in L1 state via storage proof + Helios light client.\n * @dev This contract has one onlyOwner function to be used as an emergency fallback to execute a message to\n * this SpokePool in the case where the light-client is not functioning correctly. The owner is designed to be set\n * to a multisig contract on this chain.\n */\ncontract Universal_SpokePool is OwnableUpgradeable, SpokePool, CircleCCTPAdapter {\n    /// @notice The data store contract that only the HubPool can write to. This spoke pool can only act on\n    /// data that has been written to this store.\n    address public immutable hubPoolStore;\n\n    /// @notice Slot index of the HubPoolStore's relayMessageCallData mapping.\n    uint256 public constant HUB_POOL_STORE_CALLDATA_MAPPING_SLOT_INDEX = 0;\n\n    /// @notice The address of the Helios L1 light client contract.\n    address public immutable helios;\n\n    /// @notice The owner of this contract must wait until this amount of seconds have passed since the latest\n    /// helios light client update to emergency execute a message. This prevents the owner from executing a message\n    /// in the happy case where the light client is being regularly updated. Therefore, this value should be\n    /// set to a very high value, like 24 hours.\n    uint256 public immutable ADMIN_UPDATE_BUFFER;\n\n    /// @notice Stores all proofs verified to prevent replay attacks.\n    mapping(uint256 => bool) public verifiedProofs;\n\n    // Warning: this variable should _never_ be touched outside of this contract. It is intentionally set to be\n    // private. Leaving it set to true can permanently disable admin calls.\n    bool private _adminCallValidated;\n\n    /// @notice Event emitted after off-chain agent sees HubPoolStore's emitted StoredCallData event and calls\n    /// executeMessage() on this contract to relay the stored calldata.\n    event RelayedCallData(uint256 indexed nonce, address caller);\n\n    error NotTarget();\n    error AdminCallAlreadySet();\n    error SlotValueMismatch();\n    error AdminCallNotValidated();\n    error DelegateCallFailed();\n    error AlreadyExecuted();\n    error NotImplemented();\n    error AdminUpdateTooCloseToLastHeliosUpdate();\n\n    // All calls that have admin privileges must be fired from within the receiveL1State method that validates that\n    // the input data was published on L1 by the HubPool. This input data is then executed on this contract.\n    // This modifier sets the adminCallValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure adminCallValidated is set to True only once at beginning of the function, which prevents\n        // the function from being re-entered.\n        if (_adminCallValidated) {\n            revert AdminCallAlreadySet();\n        }\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed.\n        _adminCallValidated = true;\n\n        _;\n\n        // Reset adminCallValidated to false to disallow admin calls after this method exits.\n        _adminCallValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        uint256 _adminUpdateBufferSeconds,\n        address _helios,\n        address _hubPoolStore,\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {\n        ADMIN_UPDATE_BUFFER = _adminUpdateBufferSeconds;\n        helios = _helios;\n        hubPoolStore = _hubPoolStore;\n    }\n\n    function initialize(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __Ownable_init();\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n    }\n\n    /**\n     * @notice Relays calldata stored by the HubPool on L1 into this contract.\n     * @dev Replay attacks are possible with this _message if this contract has the same address on another chain.\n     * @param _messageNonce Nonce of message stored in HubPoolStore.\n     * @param _message Message stored in HubPoolStore. Compared against hashed value in light client for slot key\n     * corresponding to _messageNonce at block number.\n     * @param _blockNumber Block number in light client we use to check slot value of slot key\n     */\n    function executeMessage(\n        uint256 _messageNonce,\n        bytes calldata _message,\n        uint256 _blockNumber\n    ) external validateInternalCalls {\n        bytes32 slotKey = getSlotKey(_messageNonce);\n        bytes32 expectedSlotValueHash = keccak256(_message);\n\n        // Verify Helios light client has expected slot value.\n        bytes32 slotValueHash = IHelios(helios).getStorageSlot(_blockNumber, hubPoolStore, slotKey);\n        if (expectedSlotValueHash != slotValueHash) {\n            revert SlotValueMismatch();\n        }\n\n        // Validate state is intended to be sent to this contract. The target could have been set to the zero address\n        // which is used by the StorageProof_Adapter to denote messages that can be sent to any target.\n        (address target, bytes memory message) = abi.decode(_message, (address, bytes));\n        if (target != address(0) && target != address(this)) {\n            revert NotTarget();\n        }\n\n        // Prevent replay attacks. The slot key should be a hash of the nonce associated with this calldata in the\n        // HubPoolStore, which maps the nonce to the _value.\n        if (verifiedProofs[_messageNonce]) {\n            revert AlreadyExecuted();\n        }\n        verifiedProofs[_messageNonce] = true;\n        emit RelayedCallData(_messageNonce, msg.sender);\n\n        _executeCalldata(message);\n    }\n\n    /**\n     * @notice This function is only callable by the owner and is used as an emergency fallback to execute\n     * calldata to this SpokePool in the case where the light-client is not able to be updated.\n     * @dev This function will revert if the last Helios update was less than ADMIN_UPDATE_BUFFER seconds ago.\n     * @param _message The calldata to execute on this contract.\n     */\n    function adminExecuteMessage(bytes memory _message) external onlyOwner validateInternalCalls {\n        uint256 heliosHeadTimestamp = IHelios(helios).headTimestamp();\n        if (heliosHeadTimestamp > block.timestamp || block.timestamp - heliosHeadTimestamp < ADMIN_UPDATE_BUFFER) {\n            revert AdminUpdateTooCloseToLastHeliosUpdate();\n        }\n        _executeCalldata(_message);\n    }\n\n    /**\n     * @notice Computes the EVM storage slot key for a message nonce using the formula keccak256(key, slotIndex)\n     * to find the storage slot for a value within a mapping(key=>value) at a slot index. We already know the\n     * slot index of the relayMessageCallData mapping in the HubPoolStore.\n     * @param _nonce The nonce associated with the message.\n     * @return The computed storage slot key.\n     */\n    function getSlotKey(uint256 _nonce) public pure returns (bytes32) {\n        return keccak256(abi.encode(_nonce, HUB_POOL_STORE_CALLDATA_MAPPING_SLOT_INDEX));\n    }\n\n    function _executeCalldata(bytes memory _calldata) internal {\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(_calldata);\n        if (!success) {\n            revert DelegateCallFailed();\n        }\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else {\n            revert NotImplemented();\n        }\n    }\n\n    // Check that the admin call is only triggered by a receiveL1State() call.\n    function _requireAdminSender() internal view override {\n        if (!_adminCallValidated) {\n            revert AdminCallNotValidated();\n        }\n    }\n}\n"
    }
}