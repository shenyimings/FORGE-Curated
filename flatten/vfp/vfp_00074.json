{
    "vfp_id": "vfp_00074",
    "project_name": "OIF Broadcaster Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ],
                "3": [
                    "CWE-358"
                ]
            },
            "title": "RLP Address Encoding Allows Leading Zero Bytes",
            "description": "The `RLP` library encodes addresses as 20-byte arrays, which may include leading zero bytes. However, the Ethereum Yellow Paper specifies that RLP-encoded scalars with leading zeros are non-canonical and should be rejected. Since an address is semantically a scalar (a 160-bit unsigned integer), encoding it with leading zeros may cause interoperability issues with other systems that strictly enforce canonical RLP. This could lead to failed decoding or inconsistent behavior when the encoded data is processed by external tools or contracts, undermining data integrity and cross-system compatibility.\n",
            "severity": "Low",
            "location": [
                "RLP.sol::encode#123-130"
            ],
            "files": [
                "d9f966fc3f7c4eec7f565c2442cc64481e7fb499/openzeppelin-contracts/contracts/utils/RLP.sol"
            ]
        }
    ],
    "affected_files": {
        "RLP.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Math} from \"./math/Math.sol\";\nimport {Accumulators} from \"./structs/Accumulators.sol\";\nimport {Bytes} from \"./Bytes.sol\";\nimport {Memory} from \"./Memory.sol\";\n\n/**\n * @dev Library for encoding and decoding data in RLP format.\n * Recursive Length Prefix (RLP) is the main encoding method used to serialize objects in Ethereum.\n * It's used for encoding everything from transactions to blocks to Patricia-Merkle tries.\n *\n * Inspired by\n *\n * * https://github.com/succinctlabs/optimism-bedrock-contracts/blob/main/rlp/RLPWriter.sol\n * * https://github.com/succinctlabs/optimism-bedrock-contracts/blob/main/rlp/RLPReader.sol\n */\nlibrary RLP {\n    using Accumulators for *;\n    using Bytes for *;\n    using Memory for *;\n\n    /// @dev The item is not properly formatted and cannot de decoded.\n    error RLPInvalidEncoding();\n\n    enum ItemType {\n        Data, // Single data value\n        List // List of RLP encoded items\n    }\n\n    /**\n     * @dev Maximum length for data that will be encoded using the short format.\n     * If `data.length <= 55 bytes`, it will be encoded as: `[0x80 + length]` + data.\n     */\n    uint8 internal constant SHORT_THRESHOLD = 55;\n    /// @dev Single byte prefix for short strings (0-55 bytes)\n    uint8 internal constant SHORT_OFFSET = 0x80;\n    /// @dev Prefix for list items (0xC0)\n    uint8 internal constant LONG_OFFSET = 0xC0;\n\n    /****************************************************************************************************************\n     *                                              ENCODING - ENCODER                                              *\n     ****************************************************************************************************************/\n\n    struct Encoder {\n        Accumulators.Accumulator acc;\n    }\n\n    /// @dev Create an empty RLP Encoder.\n    function encoder() internal pure returns (Encoder memory enc) {\n        enc.acc = Accumulators.accumulator();\n    }\n\n    /// @dev Add a boolean to a given RLP Encoder.\n    function push(Encoder memory self, bool input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add an address to a given RLP Encoder.\n    function push(Encoder memory self, address input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a uint256 to a given RLP Encoder.\n    function push(Encoder memory self, uint256 input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a bytes32 to a given RLP Encoder.\n    function push(Encoder memory self, bytes32 input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a bytes buffer to a given RLP Encoder.\n    function push(Encoder memory self, bytes memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a string to a given RLP Encoder.\n    function push(Encoder memory self, string memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add an array of bytes to a given RLP Encoder.\n    function push(Encoder memory self, bytes[] memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add an (input) Encoder to a (target) Encoder. The input is RLP encoded as a list of bytes, and added to the target Encoder.\n    function push(Encoder memory self, Encoder memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /****************************************************************************************************************\n     *                                             ENCODING - TO BYTES                                              *\n     ****************************************************************************************************************/\n\n    /**\n     * @dev Encode a boolean as RLP.\n     *\n     * Boolean `true` is encoded as 0x01, `false` as 0x80 (equivalent to encoding integers 1 and 0).\n     * This follows the de facto ecosystem standard where booleans are treated as 0/1 integers.\n     */\n    function encode(bool input) internal pure returns (bytes memory result) {\n        assembly (\"memory-safe\") {\n            result := mload(0x40)\n            mstore(result, 0x01) // length of the encoded data: 1 byte\n            mstore8(add(result, 0x20), add(mul(iszero(input), 0x7f), 1)) // input\n            mstore(0x40, add(result, 0x21)) // reserve memory\n        }\n    }\n\n    /// @dev Encode an address as RLP.\n    function encode(address input) internal pure returns (bytes memory result) {\n        assembly (\"memory-safe\") {\n            result := mload(0x40)\n            mstore(result, 0x15) // length of the encoded data: 1 (prefix) + 0x14 (address)\n            mstore(add(result, 0x20), or(shl(248, 0x94), shl(88, input))) // prefix (0x94 = SHORT_OFFSET + 0x14) + input\n            mstore(0x40, add(result, 0x35)) // reserve memory\n        }\n    }\n\n    /// @dev Encode a uint256 as RLP.\n    function encode(uint256 input) internal pure returns (bytes memory result) {\n        if (input < SHORT_OFFSET) {\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, 1) // length of the encoded data: 1 byte\n                mstore8(add(result, 0x20), or(input, mul(0x80, iszero(input)))) // input (zero is encoded as 0x80)\n                mstore(0x40, add(result, 0x21)) // reserve memory\n            }\n        } else {\n            uint256 length = Math.log256(input) + 1;\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, add(length, 1)) // length of the encoded data: 1 (prefix) + length\n                mstore8(add(result, 0x20), add(length, SHORT_OFFSET)) // prefix: SHORT_OFFSET + length\n                mstore(add(result, 0x21), shl(sub(256, mul(8, length)), input)) // input (aligned left)\n                mstore(0x40, add(result, add(length, 0x21))) // reserve memory\n            }\n        }\n    }\n\n    /// @dev Encode a bytes32 as RLP. Type alias for {encode-uint256-}.\n    function encode(bytes32 input) internal pure returns (bytes memory) {\n        return encode(uint256(input));\n    }\n\n    /// @dev Encode a bytes buffer as RLP.\n    function encode(bytes memory input) internal pure returns (bytes memory) {\n        return (input.length == 1 && uint8(input[0]) < SHORT_OFFSET) ? input : _encode(input, SHORT_OFFSET);\n    }\n\n    /// @dev Encode a string as RLP. Type alias for {encode-bytes-}.\n    function encode(string memory input) internal pure returns (bytes memory) {\n        return encode(bytes(input));\n    }\n\n    /// @dev Encode an array of bytes as RLP.\n    function encode(bytes[] memory input) internal pure returns (bytes memory) {\n        return _encode(input.concat(), LONG_OFFSET);\n    }\n\n    /// @dev Encode an encoder (list of bytes) as RLP\n    function encode(Encoder memory self) internal pure returns (bytes memory result) {\n        return _encode(self.acc.flatten(), LONG_OFFSET);\n    }\n\n    function _encode(bytes memory input, uint256 offset) private pure returns (bytes memory result) {\n        uint256 length = input.length;\n        if (length <= SHORT_THRESHOLD) {\n            // Encode \"short-bytes\" as\n            // [ offset + input.length |Â input ]\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, add(length, 1)) // length of the encoded data: 1 (prefix) + input.length\n                mstore8(add(result, 0x20), add(length, offset)) // prefix: offset + input.length\n                mcopy(add(result, 0x21), add(input, 0x20), length) // input\n                mstore(0x40, add(result, add(length, 0x21))) // reserve memory\n            }\n        } else {\n            // Encode \"long-bytes\" as\n            // [ SHORT_THRESHOLD + offset + input.length.length | input.length | input ]\n            uint256 lenlength = Math.log256(length) + 1;\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, add(add(length, lenlength), 1)) // length of the encoded data: 1 (prefix) + input.length.length + input.length\n                mstore8(add(result, 0x20), add(add(lenlength, offset), SHORT_THRESHOLD)) // prefix: SHORT_THRESHOLD + offset + input.length.length\n                mstore(add(result, 0x21), shl(sub(256, mul(8, lenlength)), length)) // input.length\n                mcopy(add(result, add(lenlength, 0x21)), add(input, 0x20), length) // input\n                mstore(0x40, add(result, add(add(length, lenlength), 0x21))) // reserve memory\n            }\n        }\n    }\n\n    /****************************************************************************************************************\n     *                               DECODING - READ FROM AN RLP ENCODED MEMORY SLICE                               *\n     ****************************************************************************************************************/\n\n    /// @dev Decode an RLP encoded bool. See {encode-bool}\n    function readBool(Memory.Slice item) internal pure returns (bool) {\n        return readUint256(item) != 0;\n    }\n\n    /// @dev Decode an RLP encoded address. See {encode-address}\n    function readAddress(Memory.Slice item) internal pure returns (address) {\n        uint256 length = item.length();\n        require(length == 1 || length == 21, RLPInvalidEncoding());\n        return address(uint160(readUint256(item)));\n    }\n\n    /// @dev Decode an RLP encoded uint256. See {encode-uint256}\n    function readUint256(Memory.Slice item) internal pure returns (uint256) {\n        uint256 length = item.length();\n        require(length <= 33, RLPInvalidEncoding());\n\n        (uint256 itemOffset, uint256 itemLength, ItemType itemType) = _decodeLength(item);\n        require(itemType == ItemType.Data, RLPInvalidEncoding());\n\n        return itemLength == 0 ? 0 : uint256(item.load(itemOffset)) >> (256 - 8 * itemLength);\n    }\n\n    /// @dev Decode an RLP encoded bytes32. See {encode-bytes32}\n    function readBytes32(Memory.Slice item) internal pure returns (bytes32) {\n        return bytes32(readUint256(item));\n    }\n\n    /// @dev Decodes an RLP encoded bytes. See {encode-bytes}\n    function readBytes(Memory.Slice item) internal pure returns (bytes memory) {\n        (uint256 offset, uint256 length, ItemType itemType) = _decodeLength(item);\n        require(itemType == ItemType.Data, RLPInvalidEncoding());\n\n        // Length is checked by {toBytes}\n        return item.slice(offset, length).toBytes();\n    }\n\n    /// @dev Decodes an RLP encoded string. See {encode-string}\n    function readString(Memory.Slice item) internal pure returns (string memory) {\n        return string(readBytes(item));\n    }\n\n    /// @dev Decodes an RLP encoded list into an array of RLP Items.\n    function readList(Memory.Slice item) internal pure returns (Memory.Slice[] memory list) {\n        uint256 itemLength = item.length();\n\n        (uint256 listOffset, uint256 listLength, ItemType itemType) = _decodeLength(item);\n        require(itemType == ItemType.List && itemLength == listOffset + listLength, RLPInvalidEncoding());\n\n        // Start a buffer in the unallocated space\n        uint256 ptr;\n        assembly (\"memory-safe\") {\n            list := mload(0x40)\n            ptr := add(list, 0x20)\n        }\n\n        // Get all items in order, and push them to the buffer\n        for (uint256 currentOffset = listOffset; currentOffset < itemLength; ptr += 0x20) {\n            (uint256 elementOffset, uint256 elementLength, ) = _decodeLength(item.slice(currentOffset));\n            Memory.Slice element = item.slice(currentOffset, elementLength + elementOffset);\n            currentOffset += elementOffset + elementLength;\n\n            // Write item to the buffer\n            assembly (\"memory-safe\") {\n                mstore(ptr, element)\n            }\n        }\n\n        // write list length and reserve space\n        assembly (\"memory-safe\") {\n            mstore(list, div(sub(ptr, add(list, 0x20)), 0x20))\n            mstore(0x40, ptr)\n        }\n    }\n\n    /****************************************************************************************************************\n     *                                            DECODING - FROM BYTES                                             *\n     ****************************************************************************************************************/\n\n    /// @dev Decode an RLP encoded bool from bytes. See {readBool}\n    function decodeBool(bytes memory item) internal pure returns (bool) {\n        return readBool(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded address from bytes. See {readAddress}\n    function decodeAddress(bytes memory item) internal pure returns (address) {\n        return readAddress(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded uint256 from bytes. See {readUint256}\n    function decodeUint256(bytes memory item) internal pure returns (uint256) {\n        return readUint256(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded bytes32 from bytes. See {readBytes32}\n    function decodeBytes32(bytes memory item) internal pure returns (bytes32) {\n        return readBytes32(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded bytes from bytes. See {readBytes}\n    function decodeBytes(bytes memory item) internal pure returns (bytes memory) {\n        return readBytes(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded string from bytes. See {readString}\n    function decodeString(bytes memory item) internal pure returns (string memory) {\n        return readString(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded list from bytes. See {readList}\n    function decodeList(bytes memory value) internal pure returns (Memory.Slice[] memory) {\n        return readList(value.asSlice());\n    }\n\n    /**\n     * @dev Decodes an RLP `item`'s `length and type from its prefix.\n     * Returns the offset, length, and type of the RLP item based on the encoding rules.\n     */\n    function _decodeLength(\n        Memory.Slice item\n    ) private pure returns (uint256 _offset, uint256 _length, ItemType _itemtype) {\n        uint256 itemLength = item.length();\n\n        require(itemLength != 0, RLPInvalidEncoding());\n        uint8 prefix = uint8(bytes1(item.load(0)));\n\n        if (prefix < LONG_OFFSET) {\n            // CASE: item\n            if (prefix < SHORT_OFFSET) {\n                // Case: Single byte below 128\n                return (0, 1, ItemType.Data);\n            } else if (prefix <= SHORT_OFFSET + SHORT_THRESHOLD) {\n                // Case: Short string (0-55 bytes)\n                uint256 strLength = prefix - SHORT_OFFSET;\n                require(\n                    itemLength > strLength && (strLength != 1 || bytes1(item.load(1)) >= bytes1(SHORT_OFFSET)),\n                    RLPInvalidEncoding()\n                );\n                return (1, strLength, ItemType.Data);\n            } else {\n                // Case: Long string (>55 bytes)\n                uint256 lengthLength = prefix - SHORT_OFFSET - SHORT_THRESHOLD;\n\n                require(itemLength > lengthLength && bytes1(item.load(0)) != 0x00, RLPInvalidEncoding());\n\n                uint256 len = uint256(item.load(1)) >> (256 - 8 * lengthLength);\n                require(len > SHORT_THRESHOLD && itemLength > lengthLength + len, RLPInvalidEncoding());\n\n                return (lengthLength + 1, len, ItemType.Data);\n            }\n        } else {\n            // Case: list\n            if (prefix <= LONG_OFFSET + SHORT_THRESHOLD) {\n                // Case: Short list\n                uint256 listLength = prefix - LONG_OFFSET;\n                require(item.length() > listLength, RLPInvalidEncoding());\n                return (1, listLength, ItemType.List);\n            } else {\n                // Case: Long list\n                uint256 lengthLength = prefix - LONG_OFFSET - SHORT_THRESHOLD;\n\n                require(itemLength > lengthLength, RLPInvalidEncoding());\n                require(bytes1(item.load(0)) != 0x00);\n\n                uint256 len = uint256(item.load(1)) >> (256 - 8 * lengthLength);\n                require(len > SHORT_THRESHOLD && itemLength > lengthLength + len, RLPInvalidEncoding());\n\n                return (lengthLength + 1, len, ItemType.List);\n            }\n        }\n    }\n}\n"
    }
}