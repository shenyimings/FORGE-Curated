{
    "vfp_id": "vfp_00436",
    "project_name": "Across Linea CCTP Diff Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Check For CCTP Version Is Not Fully Reliable",
            "description": "The CircleCCTPAdapter contract uses a low-level call to the `feeRecipient` function of a CCTP TokenMessenger to determine whether CCTP V1 or V2 should be used, based on the presence and return value of this function. \nThe root cause of the vulnerability lies in the unreliable handling of the return data: the contract casts the 32-byte padded return value directly to `bytes20`, which only captures the first 20 bytes (including 12 bytes of padding), thus potentially truncating the actual address; it does not validate the size of the return data, making it susceptible to incorrect parsing if unexpected data length is returned; and it assumes that any non-zero 20-byte value implies a valid V2 contract, even though a malicious or misconfigured contract with a fallback function returning arbitrary data could spoof this check.\nAn attacker could potentially exploit this by deploying a contract that returns crafted data mimicking a valid `feeRecipient` response, leading the system to incorrectly assume CCTP V2 is available when it is not, or vice versa.\nThis could result in incorrect bridging logic being executed, potentially leading to failed transactions, user fund loss due to incorrect routing, or unexpected behavior in cross-chain transfers.\n",
            "severity": "Low",
            "location": [
                "CircleCCTPAdapter.sol::constructor#83-86"
            ],
            "files": [
                "contracts/contracts/libraries/CircleCCTPAdapter.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Insufficient Documentation",
            "description": "The `_transferUsdc` function in the CircleCCTPAdapter contract performs critical operations for bridging USDC using either CCTP V1 or V2, including querying the TokenMinter address and checking burn limits. \nThe root cause is the lack of clear inline documentation indicating that the `cctpTokenMessenger` variable, typed as `ITokenMessenger` (V1), may point to a `TokenMessengerV2` contract, and that the returned `localMinter` could be either `ITokenMinter` or `ITokenMinterV2`, despite both exposing the required `burnLimitsPerMessage` function.\nWhile this does not introduce direct runtime vulnerabilities, the absence of explicit comments about version compatibility makes the code harder to understand, review, and maintain, increasing the risk of future bugs during upgrades or modifications by developers unfamiliar with the implicit assumptions.\nThe impact is primarily on code maintainability and auditability, potentially leading to integration errors or incorrect assumptions by future developers, which could indirectly result in security issues if changes are made without full understanding of the dual-version logic.\n",
            "severity": "Low",
            "location": [
                "CircleCCTPAdapter.sol::_transferUsdc#113"
            ],
            "files": [
                "contracts/contracts/libraries/CircleCCTPAdapter.sol"
            ]
        }
    ],
    "affected_files": {
        "CircleCCTPAdapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport { AddressToBytes32 } from \"../libraries/AddressConverters.sol\";\n\nlibrary CircleDomainIds {\n    uint32 public constant Ethereum = 0;\n    uint32 public constant Optimism = 2;\n    uint32 public constant Arbitrum = 3;\n    uint32 public constant Solana = 5;\n    uint32 public constant Base = 6;\n    uint32 public constant Polygon = 7;\n    uint32 public constant DoctorWho = 10;\n    uint32 public constant Linea = 11; // TODO replace with actual domain once Circle publishes it.\n    // Use this value for placeholder purposes only for adapters that extend this adapter but haven't yet been\n    // assigned a domain ID by Circle.\n    uint32 public constant UNINITIALIZED = type(uint32).max;\n}\n\n/**\n * @notice Facilitate bridging USDC via Circle's CCTP.\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\n * @custom:security-contact bugs@across.to\n */\nabstract contract CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n    /**\n     * @notice The domain ID that CCTP will transfer funds to.\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n\n    uint32 public immutable recipientCircleDomainId;\n\n    /**\n     * @notice The official USDC contract address on this chain.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IERC20 public immutable usdcToken;\n\n    /**\n     * @notice The official Circle CCTP token bridge contract endpoint.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITokenMessenger public immutable cctpTokenMessenger;\n\n    /**\n     * @notice Indicates if the CCTP V2 TokenMessenger is being used.\n     * @dev This is determined by checking if the feeRecipient() function exists and returns a non-zero address.\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    bool public immutable cctpV2;\n\n    /**\n     * @notice intiailizes the CircleCCTPAdapter contract.\n     * @param _usdcToken USDC address on the current chain.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        IERC20 _usdcToken,\n        /// @dev This should ideally be an address but its kept as an ITokenMessenger to avoid rippling changes to the\n        /// constructors for every SpokePool/Adapter.\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId\n    ) {\n        usdcToken = _usdcToken;\n        cctpTokenMessenger = _cctpTokenMessenger;\n        recipientCircleDomainId = _recipientCircleDomainId;\n\n        // Only the CCTP V2 TokenMessenger has a feeRecipient() function, so we use it to\n        // figure out if we are using CCTP V2 or V1. `success` can be true even if the contract doesn't\n        // implement feeRecipient but it has a fallback function so to be extra safe, we check the return value\n        // of feeRecipient() as well.\n        (bool success, bytes memory feeRecipient) = address(cctpTokenMessenger).staticcall(\n            abi.encodeWithSignature(\"feeRecipient()\")\n        );\n        cctpV2 = (success && address(bytes20(feeRecipient)) != address(0));\n    }\n\n    /**\n     * @notice Returns whether or not the CCTP bridge is enabled.\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\n     */\n    function _isCCTPEnabled() internal view returns (bool) {\n        return address(cctpTokenMessenger) != address(0);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(address to, uint256 amount) internal {\n        _transferUsdc(to.toBytes32(), amount);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain represented as bytes32.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(bytes32 to, uint256 amount) internal {\n        // Only approve the exact amount to be transferred\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\n        // Submit the amount to be transferred to bridged via the TokenMessenger.\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\n        uint256 remainingAmount = amount;\n        while (remainingAmount > 0) {\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\n            if (cctpV2) {\n                //  Uses the CCTP V2 \"standard transfer\" speed and\n                // therefore pays no additional fee for the transfer to be sped up.\n                ITokenMessengerV2(address(cctpTokenMessenger)).depositForBurn(\n                    partAmount,\n                    recipientCircleDomainId,\n                    to,\n                    address(usdcToken),\n                    // The following parameters are new in this function from V2 to V1, can read more here:\n                    // https://developers.circle.com/stablecoins/evm-smart-contracts\n                    bytes32(0), // destinationCaller is set to bytes32(0) to indicate that anyone can call\n                    // receiveMessage on the destination to finalize the transfer\n                    0, // maxFee can be set to 0 for a \"standard transfer\"\n                    2000 // minFinalityThreshold can be set to 20000 for a \"standard transfer\",\n                    // https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/FinalityThresholds.sol#L21\n                );\n            } else {\n                cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, to, address(usdcToken));\n            }\n            remainingAmount -= partAmount;\n        }\n    }\n}\n"
    }
}