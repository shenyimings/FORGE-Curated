{
    "vfp_id": "vfp_00105",
    "project_name": "cantina_coinbase_bridge_aug2025.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Frontrunning can block message batch submissions",
            "description": "Adversaries can frontrun legitimate message batch submission transactions. The cause is the absence of anti-frontrunning mechanisms in the batch submission logic. An attacker can observe pending batch submissions and submit their own transaction first, potentially blocking or delaying message processing. The impact is denial of service for message relaying, disrupting cross-chain communication.\n",
            "severity": "Low",
            "location": [
                "Bridge.sol#L335"
            ],
            "files": [
                "bridge/base/src/Bridge.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Unnecessary twin contract deployment for simple transfers",
            "description": "The system deploys redundant contracts for simple token transfers, increasing gas costs. The cause is a design choice to use a generalized deployment pattern even for trivial operations. Not directly exploitable, but increases operational costs for users. The impact is higher gas consumption than necessary, reducing efficiency and increasing user fees.\n",
            "severity": "Informational",
            "location": [
                "Bridge.sol#L218-L226"
            ],
            "files": [
                "bridge/base/src/Bridge.sol"
            ]
        }
    ],
    "affected_files": {
        "Bridge.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {OwnableRoles} from \"solady/auth/OwnableRoles.sol\";\nimport {Initializable} from \"solady/utils/Initializable.sol\";\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {ReentrancyGuardTransient} from \"solady/utils/ReentrancyGuardTransient.sol\";\n\nimport {BridgeValidator} from \"./BridgeValidator.sol\";\nimport {Twin} from \"./Twin.sol\";\nimport {Call} from \"./libraries/CallLib.sol\";\nimport {IncomingMessage, MessageLib, MessageType} from \"./libraries/MessageLib.sol\";\nimport {MessageStorageLib} from \"./libraries/MessageStorageLib.sol\";\nimport {SVMBridgeLib} from \"./libraries/SVMBridgeLib.sol\";\nimport {Ix, Pubkey} from \"./libraries/SVMLib.sol\";\nimport {SolanaTokenType, TokenLib, Transfer} from \"./libraries/TokenLib.sol\";\n\n/// @title Bridge\n///\n/// @notice Cross-chain bridge enabling bidirectional communication and token transfers between Solana and Base.\ncontract Bridge is ReentrancyGuardTransient, Initializable, OwnableRoles {\n    //////////////////////////////////////////////////////////////\n    ///                       Constants                        ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Pubkey of the remote bridge program on Solana.\n    ///\n    /// @dev Used to identify messages originating directly from the Solana bridge program itself (rather than from\n    ///      user Twin contracts). When a message's sender equals this pubkey, it indicates the message contains\n    ///      bridge-level operations such as wrapped token registration that require special handling.\n    Pubkey public immutable REMOTE_BRIDGE;\n\n    /// @notice Address of the Twin beacon used for deploying upgradeable Twin contract proxies.\n    ///\n    /// @dev Each Solana user gets their own deterministic Twin contract deployed via beacon proxy using their\n    ///      Solana pubkey as the salt. Twin contracts act as execution contexts for Solana users on Base,\n    ///      allowing them to execute arbitrary calls and receive tokens. The beacon pattern enables\n    ///      upgradeability of all Twin contract implementations simultaneously.\n    address public immutable TWIN_BEACON;\n\n    /// @notice Address of the CrossChainERC20Factory.\n    ///\n    /// @dev It's primarily used to check if a local token was deployed by the bridge. If so, we know we can mint /\n    ///      burn. Otherwise the token interaction is a transfer.\n    address public immutable CROSS_CHAIN_ERC20_FACTORY;\n\n    /// @notice Address of the BridgeValidator contract. Messages will be pre-validated there by our oracle & bridge\n    ///         partner.\n    address public immutable BRIDGE_VALIDATOR;\n\n    /// @notice Guardian Role to pause the bridge.\n    uint256 public constant GUARDIAN_ROLE = 1 << 0;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Storage                          ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Mapping of message hashes to boolean values indicating successful execution. A message will only be\n    ///         present in this mapping if it has successfully been executed, and therefore cannot be executed again.\n    mapping(bytes32 messageHash => bool success) public successes;\n\n    /// @notice Mapping of message hashes to boolean values indicating failed execution attempts. A message will be\n    ///         present in this mapping if and only if it has failed to execute at least once. Successfully executed\n    ///         messages on first attempt won't appear here.\n    mapping(bytes32 messageHash => bool failure) public failures;\n\n    /// @notice Mapping of Solana owner pubkeys to their Twin contract addresses.\n    mapping(Pubkey owner => address twinAddress) public twins;\n\n    /// @notice Whether the bridge is paused.\n    bool public paused;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Events                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Emitted whenever a message is successfully relayed and executed.\n    ///\n    /// @param messageHash Keccak256 hash of the message that was successfully relayed.\n    event MessageSuccessfullyRelayed(bytes32 indexed messageHash);\n\n    /// @notice Emitted whenever a message fails to be relayed.\n    ///\n    /// @param messageHash Keccak256 hash of the message that failed to be relayed.\n    event FailedToRelayMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted whenever the bridge is paused or unpaused.\n    ///\n    /// @param paused Whether the bridge is paused.\n    event PauseSwitched(bool paused);\n\n    //////////////////////////////////////////////////////////////\n    ///                       Errors                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when a message has already been successfully relayed.\n    error MessageAlreadySuccessfullyRelayed();\n\n    /// @notice Thrown when the bridge is paused.\n    error Paused();\n\n    /// @notice Thrown when `validateMessage` is called with a message hash that has not been pre-validated.\n    error InvalidMessage();\n\n    /// @notice Thrown when the sender is not the entrypoint.\n    error SenderIsNotEntrypoint();\n\n    /// @notice Thrown when a zero address is detected\n    error ZeroAddress();\n\n    //////////////////////////////////////////////////////////////\n    ///                       Modifiers                        ///\n    //////////////////////////////////////////////////////////////\n\n    modifier whenNotPaused() {\n        require(!paused, Paused());\n        _;\n    }\n\n    //////////////////////////////////////////////////////////////\n    ///                       Public Functions                 ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Constructs the Bridge contract.\n    ///\n    /// @param remoteBridge           The pubkey of the remote bridge on Solana.\n    /// @param twinBeacon             The address of the Twin beacon.\n    /// @param crossChainErc20Factory The address of the CrossChainERC20Factory.\n    /// @param bridgeValidator        The address of the contract used to validate Bridge messages\n    constructor(Pubkey remoteBridge, address twinBeacon, address crossChainErc20Factory, address bridgeValidator) {\n        require(twinBeacon != address(0), ZeroAddress());\n        require(crossChainErc20Factory != address(0), ZeroAddress());\n        require(bridgeValidator != address(0), ZeroAddress());\n\n        REMOTE_BRIDGE = remoteBridge;\n        TWIN_BEACON = twinBeacon;\n        CROSS_CHAIN_ERC20_FACTORY = crossChainErc20Factory;\n        BRIDGE_VALIDATOR = bridgeValidator;\n\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the Bridge contract with an owner and guardians with bridge pausing permissions.\n    ///\n    /// @param owner     The owner of the Bridge contract.\n    /// @param guardians An array of guardian addresses approved to pause the Bridge.\n    function initialize(address owner, address[] calldata guardians) external initializer {\n        require(owner != address(0), ZeroAddress());\n\n        // Initialize ownership\n        _initializeOwner(owner);\n\n        // Initialize guardians\n        for (uint256 i; i < guardians.length; i++) {\n            require(guardians[i] != address(0), ZeroAddress());\n            _grantRoles(guardians[i], GUARDIAN_ROLE);\n        }\n    }\n\n    /// @notice Bridges a call to the Solana bridge.\n    ///\n    /// @param ixs The instructions to execute on Solana.\n    function bridgeCall(Ix[] calldata ixs) external nonReentrant whenNotPaused {\n        MessageStorageLib.sendMessage({sender: msg.sender, data: SVMBridgeLib.serializeCall(ixs)});\n    }\n\n    /// @notice Bridges a transfer with an optional list of instructions to the Solana bridge.\n    ///\n    /// @param transfer The token transfer to execute.\n    /// @param ixs      The optional Solana instructions.\n    function bridgeToken(Transfer memory transfer, Ix[] calldata ixs) external payable nonReentrant whenNotPaused {\n        // IMPORTANT: The `TokenLib.initializeTransfer` function might modify the `transfer.remoteAmount` field to\n        //            account for potential transfer fees.\n        SolanaTokenType transferType =\n            TokenLib.initializeTransfer({transfer: transfer, crossChainErc20Factory: CROSS_CHAIN_ERC20_FACTORY});\n\n        MessageStorageLib.sendMessage({\n            sender: msg.sender,\n            data: SVMBridgeLib.serializeTransfer({transfer: transfer, tokenType: transferType, ixs: ixs})\n        });\n    }\n\n    /// @notice Relays messages sent from Solana to Base.\n    ///\n    /// @param messages The messages to relay.\n    function relayMessages(IncomingMessage[] calldata messages) external nonReentrant whenNotPaused {\n        for (uint256 i; i < messages.length; i++) {\n            _validateAndRelay(messages[i]);\n        }\n    }\n\n    /// @notice Relays a message sent from Solana to Base.\n    ///\n    /// @dev This function can only be called from `_validateAndRelay`.\n    ///\n    /// @param message The message to relay.\n    function __relayMessage(IncomingMessage calldata message) external {\n        _assertSenderIsEntrypoint();\n\n        // Special case where the message sender is directly the Solana bridge.\n        // For now this is only the case when a Wrapped Token is deployed on Solana and is being registered on Base.\n        // When this happens the message is guaranteed to be a single operation that encode the parameters of the\n        // `registerRemoteToken` function.\n        if (message.sender == REMOTE_BRIDGE) {\n            Call memory call = abi.decode(message.data, (Call));\n            (address localToken, Pubkey remoteToken, uint8 scalarExponent) =\n                abi.decode(call.data, (address, Pubkey, uint8));\n\n            TokenLib.registerRemoteToken({\n                localToken: localToken,\n                remoteToken: remoteToken,\n                scalarExponent: scalarExponent\n            });\n            return;\n        }\n\n        // Get (and deploy if needed) the Twin contract.\n        address twinAddress = twins[message.sender];\n        if (twinAddress == address(0)) {\n            twinAddress = LibClone.deployDeterministicERC1967BeaconProxy({\n                beacon: TWIN_BEACON,\n                salt: Pubkey.unwrap(message.sender)\n            });\n            twins[message.sender] = twinAddress;\n        }\n\n        if (message.ty == MessageType.Call) {\n            Call memory call = abi.decode(message.data, (Call));\n            Twin(payable(twins[message.sender])).execute(call);\n        } else if (message.ty == MessageType.Transfer) {\n            Transfer memory transfer = abi.decode(message.data, (Transfer));\n            TokenLib.finalizeTransfer({transfer: transfer, crossChainErc20Factory: CROSS_CHAIN_ERC20_FACTORY});\n        } else if (message.ty == MessageType.TransferAndCall) {\n            (Transfer memory transfer, Call memory call) = abi.decode(message.data, (Transfer, Call));\n            TokenLib.finalizeTransfer({transfer: transfer, crossChainErc20Factory: CROSS_CHAIN_ERC20_FACTORY});\n            Twin(payable(twins[message.sender])).execute(call);\n        }\n    }\n\n    /// @notice Pauses or unpauses the bridge.\n    ///\n    /// @dev This function can only be called by a guardian.\n    ///\n    /// @param isPaused Boolean representing the desired paused status\n    function setPaused(bool isPaused) external onlyRoles(GUARDIAN_ROLE) {\n        paused = isPaused;\n        emit PauseSwitched(isPaused);\n    }\n\n    /// @notice Get the current root of the MMR.\n    ///\n    /// @return The current root of the MMR.\n    function getRoot() external view returns (bytes32) {\n        return MessageStorageLib.getMessageStorageLibStorage().root;\n    }\n\n    /// @notice Get the next outgoing Message nonce.\n    ///\n    /// @return The next outgoing Message nonce.\n    function getNextNonce() external view returns (uint64) {\n        return MessageStorageLib.getMessageStorageLibStorage().nextNonce;\n    }\n\n    /// @notice Generates a Merkle proof for a specific leaf in the MMR.\n    ///\n    /// @dev This function may consume significant gas for large MMRs (O(log N) storage reads).\n    ///\n    /// @param leafIndex The 0-indexed position of the leaf to prove.\n    ///\n    /// @return proof          Array of sibling hashes for the proof.\n    /// @return totalLeafCount The total number of leaves when proof was generated.\n    function generateProof(uint64 leafIndex) external view returns (bytes32[] memory proof, uint64 totalLeafCount) {\n        return MessageStorageLib.generateProof(leafIndex);\n    }\n\n    /// @notice Predict the address of the Twin contract for a given Solana sender pubkey.\n    ///\n    /// @param sender The Solana sender's pubkey.\n    ///\n    /// @return The predicted address of the Twin contract for the given Solana sender pubkey.\n    function getPredictedTwinAddress(Pubkey sender) external view returns (address) {\n        return LibClone.predictDeterministicAddressERC1967BeaconProxy({\n            beacon: TWIN_BEACON,\n            salt: Pubkey.unwrap(sender),\n            deployer: address(this)\n        });\n    }\n\n    /// @notice Get the deposit amount for a given local token and remote token.\n    ///\n    /// @param localToken  The address of the local token.\n    /// @param remoteToken The pubkey of the remote token.\n    ///\n    /// @return _ The deposit amount for the given local token and remote token.\n    function deposits(address localToken, Pubkey remoteToken) external view returns (uint256) {\n        return TokenLib.getTokenLibStorage().deposits[localToken][remoteToken];\n    }\n\n    /// @notice Get the scalar used to convert local token amounts to remote token amounts.\n    ///\n    /// @param localToken  The address of the local token.\n    /// @param remoteToken The pubkey of the remote token.\n    ///\n    /// @return _ The scalar used to convert local token amounts to remote token amounts.\n    function scalars(address localToken, Pubkey remoteToken) external view returns (uint256) {\n        return TokenLib.getTokenLibStorage().scalars[localToken][remoteToken];\n    }\n\n    /// @notice Returns the message hash of a given message to be used as its ID\n    ///\n    /// @param message The `IncomingMessage` to retrieve the message hash for\n    ///\n    /// @return messageHash The hash of `message`\n    function getMessageHash(IncomingMessage calldata message) public pure returns (bytes32) {\n        return MessageLib.getMessageHashCd(message);\n    }\n\n    //////////////////////////////////////////////////////////////\n    ///                   Internal Functions                   ///\n    //////////////////////////////////////////////////////////////\n\n    /// @inheritdoc ReentrancyGuardTransient\n    function _useTransientReentrancyGuardOnlyOnMainnet() internal pure override returns (bool) {\n        return false;\n    }\n\n    //////////////////////////////////////////////////////////////\n    ///                    Private Functions                   ///\n    //////////////////////////////////////////////////////////////\n\n    function _validateAndRelay(IncomingMessage calldata message) private {\n        bytes32 messageHash = getMessageHash(message);\n\n        // Check that the message has not already been relayed.\n        require(!successes[messageHash], MessageAlreadySuccessfullyRelayed());\n\n        require(BridgeValidator(BRIDGE_VALIDATOR).validMessages(messageHash), InvalidMessage());\n\n        try this.__relayMessage(message) {\n            // Register the message as successfully relayed.\n            delete failures[messageHash];\n            successes[messageHash] = true;\n            emit MessageSuccessfullyRelayed(messageHash);\n        } catch {\n            // Register the message as failed to relay.\n            failures[messageHash] = true;\n            emit FailedToRelayMessage(messageHash);\n        }\n    }\n\n    /// @notice Asserts that the caller is the entrypoint.\n    function _assertSenderIsEntrypoint() private view {\n        require(msg.sender == address(this), SenderIsNotEntrypoint());\n    }\n}\n"
    }
}