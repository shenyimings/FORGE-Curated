{
    "vfp_id": "vfp_00105",
    "project_name": "cantina_euler_pr111_oct2025.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Activation marks pool active before initialization completes",
            "description": "The activate function in EulerSwapManagement.sol sets the pool status to active (s.status = 1) before completing all initialization steps. If any external call or hook is invoked after this status change but before full initialization, the system may treat the pool as active while it is still in a partially initialized state. This could lead to inconsistent behavior or errors in dependent systems that assume full initialization upon seeing an active status.\nThe root cause is the premature state transition, which violates the principle of atomic initialization. The function does not use intermediate states (e.g., \"initializing\") to prevent premature access.\nAn attacker could potentially exploit this by triggering a dependent function or hook that interacts with the pool during this vulnerable window, possibly leading to incorrect state assumptions or reentrancy-like conditions if external calls are involved.\nThe impact includes potential logic errors, inconsistent state, and possible disruption of dependent systems that rely on correct pool status semantics.\n",
            "severity": "Low",
            "location": [
                "EulerSwapManagement.sol#L68"
            ],
            "files": [
                "euler-swap/src/EulerSwapManagement.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Remove unused code",
            "description": "Multiple files in the codebase contain unused imports, error declarations, and event declarations. This includes files such as EulerSwapManagement.sol, FundsLib.sol, and UniswapHook.sol. Dead code increases code complexity, reduces readability, and can mislead developers about the actual functionality and dependencies of the system.\nThe root cause is the presence of leftover or obsolete code that was not cleaned up during development or refactoring.\nWhile not directly exploitable, this could lead to confusion during audits or future development, increasing the risk of introducing bugs due to misunderstanding the codebase.\nThe impact is reduced code maintainability and increased cognitive load for developers and auditors, potentially leading to oversight of real vulnerabilities.\n",
            "severity": "Informational",
            "location": [
                "EulerSwapManagement.sol#L4-L7",
                "EulerSwapManagement.sol#L22",
                "EulerSwap.sol#L21-L24",
                "FundsLib.sol#L10",
                "UniswapHook.sol#L19",
                "UniswapHook.sol#L21-L22"
            ],
            "files": [
                "euler-swap/src/EulerSwapManagement.sol",
                "euler-swap/src/libraries/FundsLib.sol",
                "euler-swap/src/UniswapHook.sol"
            ]
        }
    ],
    "affected_files": {
        "UniswapHook.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {BaseHook} from \"v4-periphery/src/utils/BaseHook.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\nimport {\n    BeforeSwapDelta, toBeforeSwapDelta, BeforeSwapDeltaLibrary\n} from \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\n\nimport {IEVault} from \"evk/EVault/IEVault.sol\";\n\nimport {EulerSwapBase} from \"./EulerSwapBase.sol\";\nimport {IEulerSwap} from \"./interfaces/IEulerSwap.sol\";\nimport {CtxLib} from \"./libraries/CtxLib.sol\";\nimport {QuoteLib} from \"./libraries/QuoteLib.sol\";\nimport {CurveLib} from \"./libraries/CurveLib.sol\";\nimport {FundsLib} from \"./libraries/FundsLib.sol\";\nimport {SwapLib} from \"./libraries/SwapLib.sol\";\n\nabstract contract UniswapHook is EulerSwapBase, BaseHook {\n    using SafeCast for uint256;\n\n    address public immutable protocolFeeConfig;\n\n    PoolKey internal _poolKey;\n\n    constructor(address evc_, address protocolFeeConfig_, address _poolManager)\n        EulerSwapBase(evc_)\n        BaseHook(IPoolManager(_poolManager))\n    {\n        protocolFeeConfig = protocolFeeConfig_;\n    }\n\n    function activateHook(IEulerSwap.StaticParams memory sParams) internal nonReentrant {\n        if (address(poolManager) == address(0)) return;\n\n        Hooks.validateHookPermissions(this, getHookPermissions());\n\n        address asset0Addr = IEVault(sParams.supplyVault0).asset();\n        address asset1Addr = IEVault(sParams.supplyVault1).asset();\n\n        _poolKey = PoolKey({\n            currency0: Currency.wrap(asset0Addr),\n            currency1: Currency.wrap(asset1Addr),\n            fee: 0, // hard-coded fee since it may change\n            tickSpacing: 1, // hard-coded tick spacing, as it's unused\n            hooks: IHooks(address(this))\n        });\n\n        // create the pool on v4, using starting price as sqrtPrice(1/1) * Q96\n        poolManager.initialize(_poolKey, 79228162514264337593543950336);\n    }\n\n    /// @dev Helper function to return the poolKey as its struct type\n    function poolKey() external view returns (PoolKey memory) {\n        return _poolKey;\n    }\n\n    /// @dev Prevent hook address validation in constructor, which is not needed\n    /// because hook instances are proxies. Instead, the address is validated\n    /// in activateHook().\n    function validateHookAddress(BaseHook _this) internal pure override {}\n\n    function _beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)\n        internal\n        override\n        nonReentrant\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        SwapLib.SwapContext memory ctx = SwapLib.init(address(evc), protocolFeeConfig, sender, msg.sender);\n\n        uint256 amountIn;\n        uint256 amountOut;\n        BeforeSwapDelta returnDelta;\n        bool isExactInput = params.amountSpecified < 0;\n\n        if (isExactInput) {\n            amountIn = uint256(-params.amountSpecified);\n            amountOut = QuoteLib.computeQuote(address(evc), ctx.sParams, ctx.dParams, params.zeroForOne, amountIn, true);\n        } else {\n            amountOut = uint256(params.amountSpecified);\n            amountIn =\n                QuoteLib.computeQuote(address(evc), ctx.sParams, ctx.dParams, params.zeroForOne, amountOut, false);\n        }\n\n        if (params.zeroForOne) {\n            SwapLib.setAmountsOut(ctx, 0, amountOut);\n            SwapLib.setAmountsIn(ctx, amountIn, 0);\n        } else {\n            SwapLib.setAmountsOut(ctx, amountOut, 0);\n            SwapLib.setAmountsIn(ctx, 0, amountIn);\n        }\n\n        SwapLib.invokeBeforeSwapHook(ctx);\n\n        // return the delta to the PoolManager, so it can process the accounting\n        // exact input:\n        //   specifiedDelta = positive, to offset the input token taken by the hook (negative delta)\n        //   unspecifiedDelta = negative, to offset the credit of the output token paid by the hook (positive delta)\n        // exact output:\n        //   specifiedDelta = negative, to offset the output token paid by the hook (positive delta)\n        //   unspecifiedDelta = positive, to offset the input token taken by the hook (negative delta)\n        returnDelta = isExactInput\n            ? toBeforeSwapDelta(amountIn.toInt128(), -(amountOut.toInt128()))\n            : toBeforeSwapDelta(-(amountOut.toInt128()), amountIn.toInt128());\n\n        // take the input token, from the PoolManager to the Euler vault\n        // the debt will be paid by the swapper via the swap router\n        poolManager.take(params.zeroForOne ? key.currency0 : key.currency1, address(this), amountIn);\n        SwapLib.doDeposits(ctx);\n\n        // pay the output token, to the PoolManager from an Euler vault\n        // the credit will be forwarded to the swap router, which then forwards it to the swapper\n        poolManager.sync(params.zeroForOne ? key.currency1 : key.currency0);\n        SwapLib.doWithdraws(ctx);\n        poolManager.settle();\n\n        SwapLib.finish(ctx);\n\n        return (BaseHook.beforeSwap.selector, returnDelta, 0);\n    }\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        /**\n         * @dev Hook Permissions without overrides:\n         * - beforeInitialize, beforeDoate, beforeAddLiquidity\n         * We use BaseHook's original reverts to *intentionally* revert\n         *\n         * beforeInitialize: the hook reverts for initializations NOT going through EulerSwap.activateHook()\n         * we want to prevent users from initializing other pairs with the same hook address\n         *\n         * beforeDonate: because the hook does not support native concentrated liquidity, any\n         * donations are permanently irrecoverable. The hook reverts on beforeDonate to prevent accidental misusage\n         *\n         * beforeAddLiquidity: the hook reverts to prevent v3-CLAMM positions\n         * because the hook is a \"custom curve\", any concentrated liquidity position sits idle and entirely unused\n         * to protect users from accidentally creating non-productive positions, the hook reverts on beforeAddLiquidity\n         */\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: true,\n            afterDonate: false,\n            beforeSwapReturnDelta: true,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n",
        "FundsLib.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IAllowanceTransfer} from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\n\nimport {IEVC} from \"evc/interfaces/IEthereumVaultConnector.sol\";\nimport {IEVault, IBorrowing, IERC4626, IRiskManager} from \"evk/EVault/IEVault.sol\";\n\nimport {IEulerSwap} from \"../interfaces/IEulerSwap.sol\";\n\nlibrary FundsLib {\n    using SafeERC20 for IERC20;\n\n    error DepositFailure(bytes reason);\n\n    error E_ZeroShares(); // EVK error\n    error ZeroShares(); // Euler Earn error\n\n    /// @notice Approves tokens for a given vault, supporting both standard approvals and permit2\n    /// @param vault The address of the vault to approve the token for\n    function approveVault(address vault) internal {\n        address asset = IEVault(vault).asset();\n        address permit2 = IEVault(vault).permit2Address();\n        if (permit2 == address(0)) {\n            IERC20(asset).forceApprove(vault, type(uint256).max);\n        } else {\n            IERC20(asset).forceApprove(permit2, type(uint256).max);\n            IAllowanceTransfer(permit2).approve(asset, vault, type(uint160).max, type(uint48).max);\n        }\n    }\n\n    /// @notice Withdraws assets from a vault, first using available balance and then borrowing if needed\n    /// @param evc EVC instance\n    /// @param eulerAccount Euler account to withdraw/borrow on behalf of\n    /// @param supplyVault The address of the vault to withdraw from\n    /// @param borrowVault The address of the vault to borrow from\n    /// @param amount The total amount of assets to withdraw\n    /// @param to The address that will receive the withdrawn assets\n    /// @dev This function first checks if there's an existing balance in the vault.\n    /// @dev If there is, it withdraws the minimum of the requested amount and available balance.\n    /// @dev If more assets are needed after withdrawal, it enables the controller and borrows the remaining amount.\n    function withdrawAssets(\n        address evc,\n        address eulerAccount,\n        address supplyVault,\n        address borrowVault,\n        uint256 amount,\n        address to\n    ) internal {\n        uint256 balance;\n        {\n            uint256 shares = IEVault(supplyVault).balanceOf(eulerAccount);\n            balance = shares == 0 ? 0 : IEVault(supplyVault).convertToAssets(shares);\n        }\n\n        if (balance > 0) {\n            uint256 avail = amount < balance ? amount : balance;\n            IEVC(evc).call(supplyVault, eulerAccount, 0, abi.encodeCall(IERC4626.withdraw, (avail, to, eulerAccount)));\n            amount -= avail;\n        }\n\n        if (amount > 0) {\n            IEVC(evc).enableController(eulerAccount, borrowVault);\n            IEVC(evc).call(borrowVault, eulerAccount, 0, abi.encodeCall(IBorrowing.borrow, (amount, to)));\n        }\n    }\n\n    /// @notice Deposits assets into a vault and automatically repays any outstanding debt\n    /// @param evc EVC instance\n    /// @param eulerAccount Euler account to repay/deposit on behalf of\n    /// @param supplyVault The address of the vault to deposit to\n    /// @param borrowVault The address of the vault to repay to\n    /// @param amount The total amount to deposit\n    /// @return The amount of assets successfully deposited (may be less than requested)\n    /// @dev This function attempts to deposit assets into the specified vault.\n    /// @dev If the deposit fails with E_ZeroShares error, it safely returns 0 (this happens with very small amounts).\n    /// @dev After successful deposit, if the user has any outstanding controller-enabled debt, it attempts to repay it.\n    /// @dev If all debt is repaid, the controller is automatically disabled to reduce gas costs in future operations.\n    function depositAssets(address evc, address eulerAccount, address supplyVault, address borrowVault, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        uint256 deposited;\n\n        if (IEVC(evc).isControllerEnabled(eulerAccount, borrowVault)) {\n            uint256 debt = IEVault(borrowVault).debtOf(eulerAccount);\n            uint256 repaid = IEVault(borrowVault).repay(amount > debt ? debt : amount, eulerAccount);\n\n            amount -= repaid;\n            debt -= repaid;\n            deposited += repaid;\n\n            if (debt == 0) {\n                IEVC(evc).call(borrowVault, eulerAccount, 0, abi.encodeCall(IRiskManager.disableController, ()));\n            }\n        }\n\n        if (amount > 0) {\n            try IEVault(supplyVault).deposit(amount, eulerAccount) {}\n            catch (bytes memory reason) {\n                require(\n                    bytes4(reason) == E_ZeroShares.selector || bytes4(reason) == ZeroShares.selector,\n                    DepositFailure(reason)\n                );\n                amount = 0;\n            }\n\n            deposited += amount;\n        }\n\n        return deposited;\n    }\n}\n",
        "EulerSwapManagement.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IEulerSwapCallee} from \"./interfaces/IEulerSwapCallee.sol\";\nimport {IEVC} from \"evc/interfaces/IEthereumVaultConnector.sol\";\nimport {IEVault} from \"evk/EVault/IEVault.sol\";\n\nimport {EulerSwapBase} from \"./EulerSwapBase.sol\";\nimport {IEulerSwap} from \"./interfaces/IEulerSwap.sol\";\nimport {CtxLib} from \"./libraries/CtxLib.sol\";\nimport {FundsLib} from \"./libraries/FundsLib.sol\";\nimport {CurveLib} from \"./libraries/CurveLib.sol\";\nimport {SwapLib} from \"./libraries/SwapLib.sol\";\n\ncontract EulerSwapManagement is EulerSwapBase {\n    error Unauthorized();\n    error AlreadyActivated();\n    error BadStaticParam();\n    error BadDynamicParam();\n    error AmountTooBig();\n    error AssetsOutOfOrderOrEqual();\n    error InvalidAssets();\n\n    /// @notice Emitted upon EulerSwap instance creation or reconfiguration.\n    event EulerSwapConfigured(IEulerSwap.DynamicParams dParams, IEulerSwap.InitialState initialState);\n    /// @notice Emitted upon EulerSwap instance creation or reconfiguration.\n    event EulerSwapManagerSet(address indexed manager, bool installed);\n\n    constructor(address evc_) EulerSwapBase(evc_) {}\n\n    function installDynamicParams(\n        CtxLib.State storage s,\n        IEulerSwap.DynamicParams memory dParams,\n        IEulerSwap.InitialState memory initialState\n    ) internal {\n        require(dParams.minReserve0 <= dParams.equilibriumReserve0, BadDynamicParam());\n        require(dParams.minReserve1 <= dParams.equilibriumReserve1, BadDynamicParam());\n        require(dParams.minReserve0 <= initialState.reserve0, BadDynamicParam());\n        require(dParams.minReserve1 <= initialState.reserve1, BadDynamicParam());\n\n        require(dParams.priceX > 0 && dParams.priceY > 0, BadDynamicParam());\n        require(dParams.priceX <= 1e24 && dParams.priceY <= 1e24, BadDynamicParam());\n        require(dParams.concentrationX <= 1e18 && dParams.concentrationY <= 1e18, BadDynamicParam());\n\n        require(dParams.fee0 <= 1e18 && dParams.fee1 <= 1e18, BadDynamicParam());\n\n        require(dParams.swapHookedOperations <= 7, BadDynamicParam());\n        require(dParams.swapHookedOperations == 0 || dParams.swapHook != address(0), BadDynamicParam());\n\n        require(CurveLib.verify(dParams, initialState.reserve0, initialState.reserve1), SwapLib.CurveViolation());\n\n        CtxLib.writeDynamicParamsToStorage(dParams);\n        s.reserve0 = initialState.reserve0;\n        s.reserve1 = initialState.reserve1;\n\n        emit EulerSwapConfigured(dParams, initialState);\n    }\n\n    function activate(IEulerSwap.DynamicParams calldata dParams, IEulerSwap.InitialState calldata initialState)\n        external\n    {\n        CtxLib.State storage s = CtxLib.getState();\n        IEulerSwap.StaticParams memory sParams = CtxLib.getStaticParams();\n\n        require(s.status == 0, AlreadyActivated());\n        s.status = 1;\n\n        // Static parameters\n\n        {\n            address asset0Addr = IEVault(sParams.supplyVault0).asset();\n            address asset1Addr = IEVault(sParams.supplyVault1).asset();\n\n            require(\n                sParams.borrowVault0 == address(0) || IEVault(sParams.borrowVault0).asset() == asset0Addr,\n                InvalidAssets()\n            );\n            require(\n                sParams.borrowVault1 == address(0) || IEVault(sParams.borrowVault1).asset() == asset1Addr,\n                InvalidAssets()\n            );\n\n            require(asset0Addr != address(0) && asset1Addr != address(0), InvalidAssets());\n            require(asset0Addr < asset1Addr, AssetsOutOfOrderOrEqual());\n        }\n\n        require(sParams.eulerAccount != sParams.feeRecipient, BadStaticParam()); // set feeRecipient to 0 instead\n\n        // Dynamic parameters\n\n        if (initialState.reserve0 != 0) {\n            require(\n                !CurveLib.verify(dParams, initialState.reserve0 - 1, initialState.reserve1), SwapLib.CurveViolation()\n            );\n        }\n        if (initialState.reserve1 != 0) {\n            require(\n                !CurveLib.verify(dParams, initialState.reserve0, initialState.reserve1 - 1), SwapLib.CurveViolation()\n            );\n        }\n\n        installDynamicParams(s, dParams, initialState);\n\n        // Configure external contracts\n\n        FundsLib.approveVault(sParams.supplyVault0);\n        FundsLib.approveVault(sParams.supplyVault1);\n\n        if (sParams.borrowVault0 != address(0) && sParams.borrowVault0 != sParams.supplyVault0) {\n            FundsLib.approveVault(sParams.borrowVault0);\n        }\n        if (sParams.borrowVault1 != address(0) && sParams.borrowVault1 != sParams.supplyVault1) {\n            FundsLib.approveVault(sParams.borrowVault1);\n        }\n\n        if (\n            !IEVC(evc).isCollateralEnabled(sParams.eulerAccount, sParams.supplyVault0)\n                && sParams.borrowVault1 != address(0)\n        ) {\n            IEVC(evc).enableCollateral(sParams.eulerAccount, sParams.supplyVault0);\n        }\n        if (\n            !IEVC(evc).isCollateralEnabled(sParams.eulerAccount, sParams.supplyVault1)\n                && sParams.borrowVault0 != address(0)\n        ) {\n            IEVC(evc).enableCollateral(sParams.eulerAccount, sParams.supplyVault1);\n        }\n    }\n\n    function setManager(address manager, bool installed) external nonReentrant {\n        CtxLib.State storage s = CtxLib.getState();\n        IEulerSwap.StaticParams memory sParams = CtxLib.getStaticParams();\n\n        require(_msgSender() == sParams.eulerAccount, Unauthorized());\n        s.managers[manager] = installed;\n\n        emit EulerSwapManagerSet(manager, installed);\n    }\n\n    function reconfigure(IEulerSwap.DynamicParams calldata dParams, IEulerSwap.InitialState calldata initialState)\n        external\n        nonReentrant\n    {\n        CtxLib.State storage s = CtxLib.getState();\n        IEulerSwap.StaticParams memory sParams = CtxLib.getStaticParams();\n        IEulerSwap.DynamicParams memory oldDParams = CtxLib.getDynamicParams();\n\n        {\n            address sender = _msgSender();\n            require(\n                sender == sParams.eulerAccount || s.managers[sender] || sender == oldDParams.swapHook, Unauthorized()\n            );\n        }\n\n        installDynamicParams(s, dParams, initialState);\n    }\n}\n"
    }
}