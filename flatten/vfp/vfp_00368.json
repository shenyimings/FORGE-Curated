{
    "vfp_id": "vfp_00368",
    "project_name": "cantina_eco_pr28_pr38_aug2025.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "NONCE_ constants can be bools",
            "description": "The constants NONCE_NOT_USED (0) and NONCE_USED (1) in NonceManager.sol are used to mark nonce states in a mapping. These can be replaced with boolean values (false and true) to save gas, as boolean storage is more efficient and direct boolean checks eliminate comparison operations. For example, `if (usedNonces[owner][salt])` is cheaper than `if (usedNonces[owner][salt] == NONCE_USED)`. The cause is suboptimal data type selection. The impact is higher storage and computation costs than necessary, which can be reduced through simple refactoring.\n",
            "severity": "Informational",
            "location": [
                "NonceManager.sol#L25-L28"
            ],
            "files": [
                "70649332/permit3/src/NonceManager.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant check for empty salts array",
            "description": "The invalidateNonces() function in NonceManager.sol checks if the salts array is empty before proceeding, but this is unnecessary because the internal _processNonceInvalidation() function will revert if the array is empty. This redundant check consumes gas without preventing any invalid state. The root cause is defensive programming without considering downstream validations. The impact is wasted gas on every call, especially in edge cases where the array might be empty.\n",
            "severity": "Informational",
            "location": [
                "NonceManager.sol#L103-L105"
            ],
            "files": [
                "70649332/permit3/src/NonceManager.sol"
            ]
        }
    ],
    "affected_files": {
        "NonceManager.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { INonceManager } from \"./interfaces/INonceManager.sol\";\nimport { EIP712 } from \"./lib/EIP712.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title NonceManager\n * @notice Manages non-sequential nonces for replay protection in the Permit3 system\n * @dev Key features:\n * - Non-sequential nonces for concurrent operation support\n * - Signature-based nonce invalidation\n * - Cross-chain nonce management\n * - EIP-712 compliant signatures\n */\nabstract contract NonceManager is INonceManager, EIP712 {\n    using ECDSA for bytes32;\n    using SignatureChecker for address;\n\n    /// @dev Constant representing an unused nonce\n    bool private constant NONCE_NOT_USED = false;\n\n    /// @dev Constant representing a used nonce\n    bool private constant NONCE_USED = true;\n\n    /**\n     * @notice Maps owner address to their used nonces\n     * @dev Non-sequential nonces allow parallel operations without conflicts\n     */\n    mapping(address => mapping(bytes32 => bool)) internal usedNonces;\n\n    /**\n     * @notice EIP-712 typehash for nonce invalidation\n     * @dev Includes chainId for cross-chain replay protection\n     */\n    bytes32 public constant NONCES_TO_INVALIDATE_TYPEHASH =\n        keccak256(\"NoncesToInvalidate(uint64 chainId,bytes32[] salts)\");\n\n    /**\n     * @notice EIP-712 typehash for invalidation signatures\n     * @dev Includes owner, deadline, and unbalanced root for batch operations\n     */\n    bytes32 public constant CANCEL_PERMIT3_TYPEHASH =\n        keccak256(\"CancelPermit3(address owner,uint48 deadline,bytes32 merkleRoot)\");\n\n    /**\n     * @notice Initialize EIP-712 domain separator\n     * @param name Contract name for EIP-712 domain\n     * @param version Contract version for EIP-712 domain\n     */\n    constructor(string memory name, string memory version) EIP712(name, version) { }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Check if a specific nonce has been used\n     * @param owner The address to check nonces for\n     * @param salt The salt value to verify\n     * @return True if nonce has been used, false otherwise\n     */\n    function isNonceUsed(address owner, bytes32 salt) external view returns (bool) {\n        return usedNonces[owner][salt];\n    }\n\n    /**\n     * @notice Directly invalidate multiple nonces without signature\n     * @param salts Array of salts to mark as used\n     */\n    function invalidateNonces(\n        bytes32[] calldata salts\n    ) external {\n        _processNonceInvalidation(msg.sender, salts);\n    }\n\n    /**\n     * @notice Invalidate nonces using a signed message\n     * @param owner Address that signed the invalidation\n     * @param deadline Timestamp after which signature is invalid\n     * @param salts Array of nonce salts to invalidate\n     * @param signature EIP-712 signature authorizing invalidation\n     */\n    function invalidateNonces(\n        address owner,\n        uint48 deadline,\n        bytes32[] calldata salts,\n        bytes calldata signature\n    ) external {\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n\n        NoncesToInvalidate memory invalidations = NoncesToInvalidate({ chainId: uint64(block.chainid), salts: salts });\n\n        bytes32 signedHash =\n            keccak256(abi.encode(CANCEL_PERMIT3_TYPEHASH, owner, deadline, hashNoncesToInvalidate(invalidations)));\n\n        _verifySignature(owner, signedHash, signature);\n\n        _processNonceInvalidation(owner, salts);\n    }\n\n    /**\n     * @notice Cross-chain nonce invalidation using the Unbalanced Merkle Tree approach\n     * @param owner Token owner\n     * @param deadline Signature expiration\n     * @param proof Unbalanced Merkle Tree invalidation proof\n     * @param signature Authorization signature\n     */\n    function invalidateNonces(\n        address owner,\n        uint48 deadline,\n        NoncesToInvalidate calldata invalidations,\n        bytes32[] calldata proof,\n        bytes calldata signature\n    ) external {\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (invalidations.chainId != uint64(block.chainid)) {\n            revert WrongChainId(uint64(block.chainid), invalidations.chainId);\n        }\n\n        // Calculate the root from the invalidations and proof\n        // processProof performs validation internally and provides granular error messages\n        bytes32 invalidationsHash = hashNoncesToInvalidate(invalidations);\n        bytes32 merkleRoot = MerkleProof.processProof(proof, invalidationsHash);\n\n        bytes32 signedHash = keccak256(abi.encode(CANCEL_PERMIT3_TYPEHASH, owner, deadline, merkleRoot));\n\n        _verifySignature(owner, signedHash, signature);\n\n        _processNonceInvalidation(owner, invalidations.salts);\n    }\n\n    /**\n     * @notice Generate EIP-712 hash for nonce invalidation data\n     * @param invalidations Struct containing chain ID and nonces\n     * @return bytes32 Hash of the invalidation data\n     */\n    function hashNoncesToInvalidate(\n        NoncesToInvalidate memory invalidations\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(NONCES_TO_INVALIDATE_TYPEHASH, invalidations.chainId, invalidations.salts));\n    }\n\n    /**\n     * @dev Process batch nonce invalidation by marking all specified nonces as used\n     * @param owner Token owner whose nonces are being invalidated\n     * @param salts Array of salts to invalidate\n     * @notice This function iterates through all provided salts and:\n     *         1. Marks each nonce as NONCE_USED in the usedNonces mapping\n     *         2. Emits a NonceInvalidated event for each invalidated nonce\n     * @notice This is an internal helper used by the public invalidateNonces functions\n     *         to process the actual invalidation after signature verification\n     */\n    function _processNonceInvalidation(address owner, bytes32[] memory salts) internal {\n        uint256 saltsLength = salts.length;\n\n        require(saltsLength != 0, EmptyArray());\n\n        for (uint256 i = 0; i < saltsLength; i++) {\n            usedNonces[owner][salts[i]] = NONCE_USED;\n            emit NonceInvalidated(owner, salts[i]);\n        }\n    }\n\n    /**\n     * @dev Consume a nonce by marking it as used for replay protection\n     * @param owner Token owner whose nonce is being consumed\n     * @param salt Unique salt value identifying the nonce to consume\n     * @notice This function provides replay protection by:\n     *         1. Checking if the nonce has already been used (NONCE_NOT_USED = 0)\n     *         2. Marking the nonce as used (NONCE_USED = 1)\n     * @notice Reverts with NonceAlreadyUsed() if the nonce was previously consumed\n     * @notice This is called before processing permits to ensure each signature\n     *         can only be used once per salt value\n     */\n    function _useNonce(address owner, bytes32 salt) internal {\n        if (usedNonces[owner][salt]) {\n            revert NonceAlreadyUsed(owner, salt);\n        }\n        usedNonces[owner][salt] = NONCE_USED;\n    }\n\n    /**\n     * @dev Validate EIP-712 signature against expected signer using ECDSA recovery\n     * @param owner Expected message signer to validate against\n     * @param structHash Hash of the signed data structure (pre-hashed message)\n     * @param signature Raw signature bytes in (v, r, s) format for ECDSA recovery\n     * @notice This function:\n     *         1. Computes the EIP-712 compliant digest using _hashTypedDataV4\n     *         2. For short signatures (<=65 bytes), tries ECDSA recovery first\n     *         3. Falls back to ERC-1271 validation for contract wallets or if ECDSA fails\n     *         4. Handles EIP-7702 delegated EOAs correctly\n     * @notice Reverts with InvalidSignature() if the signature is invalid or\n     *         the recovered signer doesn't match the expected owner\n     */\n    function _verifySignature(address owner, bytes32 structHash, bytes calldata signature) internal view {\n        bytes32 digest = _hashTypedDataV4(structHash);\n\n        // For signatures == 65 bytes ECDSA first then falling back to ERC-1271\n        // We don't check for code length as EIP-7702 EOAs can have code\n        if (signature.length == 65 && digest.recover(signature) == owner) {\n            return;\n        }\n\n        // For longer signatures or when ECDSA failed use ERC-1271 validation\n        if (owner.code.length == 0 || !owner.isValidERC1271SignatureNow(digest, signature)) {\n            revert InvalidSignature(owner);\n        }\n    }\n}\n"
    }
}