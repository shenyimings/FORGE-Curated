{
    "vfp_id": "vfp_00368",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unused Variables",
            "description": "Multiple state and local variables are declared but never used in the codebase, such as `BPS_DECIMALS`, `PX_D`, and `accountActivationFeeToken`.\nThe root cause is leftover or obsolete code from development or refactoring.\nWhile not directly exploitable, these variables increase code complexity and reduce clarity.\nThe impact is reduced code readability and maintainability, potentially leading to confusion for auditors and developers.\n",
            "severity": "Informational",
            "location": [
                "ArbitraryEVMFlowExecutor.sol::BPS_DECIMALS#43",
                "HyperCoreFlowExecutor.sol::PX_D#29",
                "HyperCoreFlowExecutor.sol::accountActivationFeeToken#282-313"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Partial Conversion of Initial Token Leads to Stranded Funds",
            "description": "The `_executeFlow` function in `ArbitraryEVMFlowExecutor.sol` uses balance snapshots before and after a multicall execution to determine the outcome. It assumes that the `initialToken` is either fully consumed or fully refunded, and only accounts for the resulting `finalToken`.\n\nThe root cause is an incorrect assumption about the behavior of arbitrary execution sequences. Many valid swap paths may only partially convert the `initialToken`, returning the remainder to the executor. The function interprets any decrease in the `initialToken` balance as a full conversion, ignoring the leftover amount.\n\nAn attacker cannot directly exploit this, but users may lose funds if the execution flow leaves behind partial `initialToken` balances. These leftover tokens become permanently stranded on the `ArbitraryEVMFlowExecutor` contract, as there is no mechanism to return them.\n\nThe issue was acknowledged but not resolved. The team argued that it is the API's responsibility to ensure no leftover tokens are created and that `drainLeftoverTokens` can be used to handle such cases.\n",
            "severity": "High",
            "location": [
                "ArbitraryEVMFlowExecutor.sol::_executeFlow#56-114"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typographical Errors",
            "description": "Several spelling mistakes were found in comments and potentially in code (e.g., 'Calcualtes', 'form', 'revover', 'receipent').\nThe cause is typos introduced during development without subsequent review.\nThese errors do not introduce security vulnerabilities but can mislead developers reading the code or documentation.\nThe impact is reduced code professionalism and clarity, potentially causing confusion during development or auditing.\n",
            "severity": "Informational",
            "location": [
                "ArbitraryEVMFlowExecutor.sol#159",
                "HyperCoreFlowExecutor.sol#547",
                "DstOFTHandler.sol#104",
                "SponsoredCCTPDstPeriphery.sol#97"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol"
            ]
        }
    ],
    "affected_files": {
        "ArbitraryEVMFlowExecutor.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\n\n// Import MulticallHandler\nimport { MulticallHandler } from \"../../handlers/MulticallHandler.sol\";\nimport { EVMFlowParams, CommonFlowParams } from \"./Structs.sol\";\n\n/**\n * @title ArbitraryEVMFlowExecutor\n * @notice Base contract for executing arbitrary action sequences using MulticallHandler\n * @dev This contract provides shared functionality for both OFT and CCTP handlers to execute\n * arbitrary actions on HyperEVM via MulticallHandler, returning information about the resulting token amount\n * @custom:security-contact bugs@across.to\n */\nabstract contract ArbitraryEVMFlowExecutor {\n    using SafeERC20 for IERC20;\n\n    /// @notice Compressed call struct (no value field to save gas)\n    struct CompressedCall {\n        address target;\n        bytes callData;\n    }\n\n    /// @notice MulticallHandler contract instance\n    address public immutable multicallHandler;\n\n    /**\n     * @notice Emitted when arbitrary actions are executed successfully\n     * @param quoteNonce Unique identifier for this quote/transaction\n     * @param initialToken The token address received before executing actions\n     * @param initialAmount The amount of initial token received\n     * @param finalToken The token address after executing actions\n     * @param finalAmount The amount of final token after executing actions\n     */\n    event ArbitraryActionsExecuted(\n        bytes32 indexed quoteNonce,\n        address indexed initialToken,\n        uint256 initialAmount,\n        address indexed finalToken,\n        uint256 finalAmount\n    );\n\n    uint256 private constant BPS_TOTAL_PRECISION = 18;\n    uint256 private constant BPS_PRECISION_SCALAR = 10 ** BPS_TOTAL_PRECISION;\n\n    constructor(address _multicallHandler) {\n        multicallHandler = _multicallHandler;\n    }\n\n    /**\n     * @notice Executes arbitrary actions by transferring tokens to MulticallHandler\n     * @dev Decompresses CompressedCall[] to MulticallHandler.Call[] format (adds value: 0)\n     * @param params Parameters of HyperEVM execution\n     * @return commonParams Parameters to continue sponsored execution to transfer funds to final recipient at correct destination\n     */\n    function _executeFlow(EVMFlowParams memory params) internal returns (CommonFlowParams memory commonParams) {\n        // Decode the compressed action data\n        CompressedCall[] memory compressedCalls = abi.decode(params.actionData, (CompressedCall[]));\n\n        // Snapshot balances\n        uint256 initialAmountSnapshot = IERC20(params.initialToken).balanceOf(address(this));\n        uint256 finalAmountSnapshot = IERC20(params.commonParams.finalToken).balanceOf(address(this));\n\n        // Transfer tokens to MulticallHandler\n        IERC20(params.initialToken).safeTransfer(multicallHandler, params.commonParams.amountInEVM);\n\n        // Build instructions for MulticallHandler\n        bytes memory instructions = _buildMulticallInstructions(\n            compressedCalls,\n            params.commonParams.finalToken,\n            address(this) // Send leftover tokens back to this contract\n        );\n\n        // Execute via MulticallHandler\n        MulticallHandler(payable(multicallHandler)).handleV3AcrossMessage(\n            params.initialToken,\n            params.commonParams.amountInEVM,\n            address(this),\n            instructions\n        );\n\n        uint256 finalAmount;\n        // This means the swap (if one was intended) didn't happen (action failed), so we use the initial token as the final token.\n        if (initialAmountSnapshot == IERC20(params.initialToken).balanceOf(address(this))) {\n            params.commonParams.finalToken = params.initialToken;\n            finalAmount = params.commonParams.amountInEVM;\n        } else {\n            uint256 finalBalance = IERC20(params.commonParams.finalToken).balanceOf(address(this));\n            if (finalBalance >= finalAmountSnapshot) {\n                // This means the swap did happen, so we check the balance of the output token and send it.\n                finalAmount = finalBalance - finalAmountSnapshot;\n            } else {\n                // If we somehow lost final tokens, just set the finalAmount to 0.\n                finalAmount = 0;\n            }\n        }\n\n        params.commonParams.extraFeesIncurred = _calcExtraFeesFinal(\n            params.commonParams.amountInEVM,\n            params.commonParams.extraFeesIncurred,\n            finalAmount\n        );\n        params.commonParams.amountInEVM = finalAmount;\n\n        emit ArbitraryActionsExecuted(\n            params.commonParams.quoteNonce,\n            params.initialToken,\n            params.commonParams.amountInEVM,\n            params.commonParams.finalToken,\n            finalAmount\n        );\n\n        return params.commonParams;\n    }\n\n    /**\n     * @notice Builds MulticallHandler Instructions from compressed calls\n     * @dev Decompresses calls by adding value: 0, and adds drainLeftoverTokens call at the end\n     */\n    function _buildMulticallInstructions(\n        CompressedCall[] memory compressedCalls,\n        address finalToken,\n        address fallbackRecipient\n    ) internal view returns (bytes memory) {\n        uint256 callCount = compressedCalls.length;\n\n        // Create Call[] array with value: 0 for each call, plus one for drainLeftoverTokens\n        MulticallHandler.Call[] memory calls = new MulticallHandler.Call[](callCount + 1);\n\n        // Decompress: add value: 0 to each call\n        for (uint256 i = 0; i < callCount; ++i) {\n            calls[i] = MulticallHandler.Call({\n                target: compressedCalls[i].target,\n                callData: compressedCalls[i].callData,\n                value: 0\n            });\n        }\n\n        // Add final call to drain leftover tokens back to this contract\n        calls[callCount] = MulticallHandler.Call({\n            target: multicallHandler,\n            callData: abi.encodeCall(MulticallHandler.drainLeftoverTokens, (finalToken, payable(fallbackRecipient))),\n            value: 0\n        });\n\n        // Build Instructions struct\n        MulticallHandler.Instructions memory instructions = MulticallHandler.Instructions({\n            calls: calls,\n            fallbackRecipient: fallbackRecipient\n        });\n\n        return abi.encode(instructions);\n    }\n\n    /// @notice Calculates proportional fees to sponsor in finalToken, given the fees to sponsor in initial token and initial amount\n    function _calcExtraFeesFinal(\n        uint256 amount,\n        uint256 extraFeesToSponsorTokenIn,\n        uint256 finalAmount\n    ) internal pure returns (uint256 extraFeesToSponsorFinalToken) {\n        // Total amount to sponsor is the extra fees to sponsor, ceiling division.\n        uint256 bpsToSponsor;\n        {\n            uint256 totalAmount = amount + extraFeesToSponsorTokenIn;\n            bpsToSponsor = ((extraFeesToSponsorTokenIn * BPS_PRECISION_SCALAR) + totalAmount - 1) / totalAmount;\n        }\n\n        // Apply the bps to sponsor to the final amount to get the amount to sponsor, ceiling division.\n        uint256 bpsToSponsorAdjusted = BPS_PRECISION_SCALAR - bpsToSponsor;\n        extraFeesToSponsorFinalToken =\n            (((finalAmount * BPS_PRECISION_SCALAR) + bpsToSponsorAdjusted - 1) / bpsToSponsorAdjusted) -\n            finalAmount;\n    }\n\n    /// @notice Allow contract to receive native tokens for arbitrary action execution\n    receive() external payable virtual {}\n}\n"
    }
}