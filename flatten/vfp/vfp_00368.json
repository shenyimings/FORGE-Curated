{
    "vfp_id": "vfp_00368",
    "project_name": "ClaimVault Security Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Possible Cross-Contract Signature Replay Attack",
            "description": "The vulnerability arises because the `calculateClaimZBTHash` function does not include the contract's own address (`address(this)`) in the hash computation used for ECDSA signature verification. This omission allows a valid signature intended for one instance of `ClaimVault` to be replayed on another instance if the same signer key is used and the nonce/epoch mechanism is identical. The root cause is the lack of contextual binding of the signature to the specific contract instance. An attacker could exploit this by capturing a valid signed message off-chain and submitting it to a different `ClaimVault` contract, potentially allowing unauthorized claims of ZBT tokens. The impact includes the risk of draining reward pools from unintended contract instances, especially in multi-chain or multi-instance deployments, leading to financial loss and undermining the intended distribution model.\n",
            "severity": "Medium",
            "location": [
                "ClaimVault.sol::calculateClaimZBTHash#127"
            ],
            "files": [
                "ZKFi/claim/src/ClaimVault.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Missing Docstrings",
            "description": "The contract lacks NatSpec documentation (docstrings) for all its functions, which reduces code readability and maintainability. The absence of documentation makes it harder for auditors, developers, and users to understand the intended behavior, preconditions, postconditions, and potential failure modes of each function. While this does not directly introduce a security flaw, it increases the risk of misinterpretation during audits or upgrades, potentially leading to incorrect assumptions about access control, state changes, or error conditions. The root cause is the omission of comments adhering to the Ethereum Natural Specification Format (NatSpec). This could indirectly lead to vulnerabilities being overlooked during future development or review processes.\n",
            "severity": "Low",
            "location": [
                "ClaimVault.sol"
            ],
            "files": [
                "ZKFi/claim/src/ClaimVault.sol"
            ]
        }
    ],
    "affected_files": {
        "ClaimVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract ClaimVault is Ownable, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable ZBT;\n    uint256 public immutable startClaimTimestamp;\n    address public signer;\n\n    mapping(address user => uint256 nonce) public userNonce;\n\n    uint256 public epochDuration = 1 hours;\n    uint256 public globalCapPerEpoch = 100_000 ether;\n    uint256 public userCapPerEpoch = 50_000 ether;\n\n    mapping(uint256 epochDuration => mapping(uint256 epochId => uint256 claimedAmount))\n        public claimedByEpoch;\n    mapping(uint256 epochDuration => mapping(address user => mapping(uint256 epochId => uint256 claimedAmount)))\n        public userClaimedByEpoch;\n\n    event Claimed(\n        address indexed user,\n        uint256 indexed amount,\n        uint256 indexed epochId,\n        uint256 currentEpochDuration,\n        uint256 userNonce\n    );\n    event EmergencyWithdrawal(\n        address indexed _token,\n        address indexed _receiver\n    );\n    event UpdateSigner(address indexed oldSigner, address indexed newSigner);\n    event UpdateEpochConfig(\n        uint256 indexed epochDuration,\n        uint256 globalCapPerEpoch,\n        uint256 userCapPerEpoch\n    );\n\n    constructor(address _ZBT, address _signer) Ownable(msg.sender) {\n        ZBT = IERC20(_ZBT);\n        signer = _signer;\n        startClaimTimestamp = block.timestamp;\n    }\n\n    function Claim(\n        address user,\n        uint256 claimAmount,\n        uint256 expiry,\n        bytes calldata signature\n    ) external whenNotPaused nonReentrant {\n        require(claimAmount != 0, \"Zero ZBT number\");\n        require(user == msg.sender, \"Invalid sender\");\n        require(expiry > block.timestamp, \"Signature expired\");\n\n        uint256 currentUserNonce = userNonce[msg.sender];\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        bytes32 claimDigestHash = calculateClaimZBTHash(\n            msg.sender,\n            claimAmount,\n            currentUserNonce,\n            chainId,\n            expiry\n        );\n\n        require(\n            _checkSignature(claimDigestHash, signature),\n            \"Invalid signature\"\n        );\n        unchecked {\n            userNonce[msg.sender] = currentUserNonce + 1;\n        }\n\n        uint256 epochId = currentEpochId();\n\n        uint256 globalUsed = claimedByEpoch[epochDuration][epochId];\n        require(\n            globalUsed + claimAmount <= globalCapPerEpoch,\n            \"Global cap exceeded\"\n        );\n\n        uint256 userUsed = userClaimedByEpoch[epochDuration][msg.sender][\n            epochId\n        ];\n        require(userUsed + claimAmount <= userCapPerEpoch, \"User cap exceeded\");\n\n        require(\n            ZBT.balanceOf(address(this)) >= claimAmount,\n            \"Insufficient Balance\"\n        );\n\n        unchecked {\n            claimedByEpoch[epochDuration][epochId] = globalUsed + claimAmount;\n            userClaimedByEpoch[epochDuration][msg.sender][epochId] =\n                userUsed +\n                claimAmount;\n        }\n\n        ZBT.safeTransfer(msg.sender, claimAmount);\n        emit Claimed(msg.sender, claimAmount, epochId, epochDuration , currentUserNonce);\n    }\n\n    function currentEpochId() public view returns (uint256) {\n        return (block.timestamp - startClaimTimestamp) / epochDuration;\n    }\n\n    function calculateClaimZBTHash(\n        address _user,\n        uint256 _claimAmount,\n        uint256 _userNonce,\n        uint256 _chainid,\n        uint256 _expiry\n    ) public pure returns (bytes32) {\n        bytes32 userClaimZBTStructHash = keccak256(\n            abi.encode(_user, _claimAmount, _userNonce, _chainid, _expiry)\n        );\n        return MessageHashUtils.toEthSignedMessageHash(userClaimZBTStructHash);\n    }\n\n    function _checkSignature(\n        bytes32 digestHash,\n        bytes memory signature\n    ) internal view returns (bool result) {\n        address recovered = ECDSA.recover(digestHash, signature);\n        result = recovered == signer;\n    }\n\n    function emergencyWithdraw(\n        address _token,\n        address _receiver\n    ) external onlyOwner {\n        require(_token != address(0), \"Token must not be zero\");\n        require(_receiver != address(0), \"Receiver must not be zero\");\n\n        IERC20(_token).safeTransfer(\n            _receiver,\n            IERC20(_token).balanceOf(address(this))\n        );\n        emit EmergencyWithdrawal(_token, _receiver);\n    }\n\n    function setSigner(address _newSigner) external onlyOwner {\n        require(_newSigner != address(0), \"Signer must not be zero\");\n        address oldSigner = signer;\n        signer = _newSigner;\n        emit UpdateSigner(oldSigner, _newSigner);\n    }\n\n    function setEpochConfig(\n        uint256 _epochDuration,\n        uint256 _globalCapPerEpoch,\n        uint256 _userCapPerEpoch\n    ) external onlyOwner {\n        require(_epochDuration > 0, \"epochDuration can not be zero\");\n        require(\n            _globalCapPerEpoch > 0,\n            \"globalCapPerEpoch must greater than zero\"\n        );\n        require(\n            _userCapPerEpoch > 0 && _userCapPerEpoch <= _globalCapPerEpoch,\n            \"_userCapPerEpoch must greater than zero and less than _globalCapPerEpoch\"\n        );\n        epochDuration = _epochDuration;\n        globalCapPerEpoch = _globalCapPerEpoch;\n        userCapPerEpoch = _userCapPerEpoch;\n        emit UpdateEpochConfig(\n            _epochDuration,\n            _globalCapPerEpoch,\n            _userCapPerEpoch\n        );\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
    }
}