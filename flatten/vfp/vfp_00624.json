{
    "vfp_id": "vfp_00624",
    "project_name": "Cove - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of access control in requestDeposit",
            "description": "The BasketToken contract's requestDeposit function allows any caller to deposit assets on behalf of any user, provided the user has approved the contract to spend their tokens. This is due to the absence of access control checks ensuring that only the owner can initiate deposits for themselves. An attacker can exploit this by calling requestDeposit with a victim's address as the owner and themselves as the controller, thereby gaining control over the deposited assets. This leads to a complete loss of funds for users who have approved the contract, as their assets can be effectively stolen through unauthorized deposits.\n",
            "severity": "Critical",
            "location": [
                "BasketToken.sol::requestDeposit"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Underflow when calculating basket balances",
            "description": "The _processInternalTrades function in BasketManagerUtils performs unchecked arithmetic when updating basket balances. Although it checks that the net buy amount does not exceed the current balance, it subtracts the larger initialBuyAmount (before fee deduction) from the balance within an unchecked block. This can result in an underflow, setting the balance to an extremely large value due to integer wraparound. Since the operation occurs in an unchecked context, Solidity's built-in overflow protection is bypassed. This could corrupt basket state, block further operations, and potentially lead to loss of funds by disrupting internal accounting and rebalancing mechanisms.\n",
            "severity": "Critical",
            "location": [
                "BasketManagerUtils.sol::_processInternalTrades"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Missing rebalance-status check in updateBitFlag() leads to incorrect rebalancing",
            "description": "The updateBitFlag function in BasketToken allows administrative changes to the basket's asset configuration without verifying whether a rebalance operation is currently in progress. If called during an active rebalance, it updates the basketAssets array, which is used by the rebalancing logic to determine which assets to trade. This can result in the rebalancer using an inconsistent or outdated list of assets, leading to incorrect balance calculations, erroneous trade proposals, or failed rebalances. The root cause is the lack of a reentrancy-like guard or status check to prevent configuration changes during critical operations.\n",
            "severity": "High",
            "location": [
                "BasketToken.sol::updateBitFlag"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect swap-fee calculation on feeOnBuy",
            "description": "The swap fee is calculated based on initialBuyAmount, which is derived after deducting the sell-side fee. However, according to the protocol specification, the fee should be calculated on the buy amount before any fee deductions. This discrepancy causes the protocol to collect less fee revenue than intended, as the fee base is smaller than it should be. The cause is a misalignment between the documented fee model and the implementation logic. Over time, this leads to significant financial loss for the protocol due to undercollected fees.\n",
            "severity": "High",
            "location": [
                "BasketManagerUtils.sol::_processInternalTrades"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Management-fee calculation results in lower effective rate",
            "description": "The _harvestManagementFee function mints new shares as fees, but it calculates the fee amount based on the pre-mint total supply. After minting, the total supply increases, diluting the effective fee rate. For example, a 5% fee results in only ~4.76% effective rate due to the increased denominator. This flaw stems from not accounting for the dilutive effect of minting in the fee calculation. As a result, the protocol consistently collects less value than intended, leading to long-term revenue loss and misaligned incentives.\n",
            "severity": "High",
            "location": [
                "BasketToken.sol::_harvestManagementFee"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Missing mapping update in BasketToken.updateBitFlag() causes rebalancing failure",
            "description": "The updateBitFlag function updates the basketAssets array but fails to update the basketAssetToIndexPlusOne mapping, which is used during rebalancing to locate assets by index. When a new asset is added via bitFlag update, its index is not recorded in this mapping. Subsequently, during rebalancing, calls to basketTokenToRebalanceAssetToIndex fail with \"AssetNotFoundInBasket\" because the index lookup returns zero. This breaks the rebalancing process for baskets with updated assets, preventing proper portfolio adjustments and potentially freezing asset management operations.\n",
            "severity": "Medium",
            "location": [
                "BasketToken.sol::updateBitFlag"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Potential price manipulation via read-only reentrancy in BasketToken.proRataRedeem()",
            "description": "The proRataRedeem function in BasketToken burns shares before completing the redemption via BasketManager, creating a reentrancy window through ERC20PluginsUpgradeable's plugin system. If the 'from' address has a malicious plugin, it can reenter during the _updateBalances call after _burn but before assets are withdrawn. This allows manipulation of the basket's totalAssets during the redemption, temporarily inflating the LP token price. Third-party protocols relying on this price for collateral valuation could be tricked into allowing excessive borrowing. The impact is potential fund loss in integrated systems due to price oracle manipulation, even though the core contract has reentrancy guards.\n",
            "severity": "Medium",
            "location": [
                "BasketToken.sol::proRataRedeem"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Denial-of-service risk where attackers can disrupt rebalance process with BasketManagerUtils.completeRebalance() functionality",
            "description": "The completeRebalance function can be called by anyone once 15 minutes have passed since the rebalance was proposed, even if the rebalance is not ready to complete. If the target weights are not met, the function resets the status to REBALANCE_PROPOSED instead of reverting, allowing an attacker to repeatedly call it and force the admin to re-propose token swaps. The root cause is the lack of access control on completeRebalance and the silent reset of state instead of reverting. An attacker can exploit this by monitoring the rebalance timeline and calling completeRebalance at the 15-minute mark to reset the process, preventing the admin from progressing to TOKEN_SWAP_EXECUTED. The impact is a denial-of-service on the rebalancing mechanism, delaying or disrupting basket maintenance, which could affect liquidity and user confidence. The team acknowledges the vector but considers it mitigated by completing rebalances within 15 minutes.\n",
            "severity": "Medium",
            "location": [
                "BasketManagerUtils.sol::completeRebalance#status reset"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Weights can pass unchecked",
            "description": "The completeRebalance function allows the rebalancing process to finalize even if the target weights are not met after the maximum number of retries (_MAX_RETRIES). Instead of reverting, the function proceeds with the current (potentially unfavorable) weights, leading to a basket that may be improperly balanced. The cause is the design decision to continue rather than revert when target weights are unmet. An attacker could exploit this by manipulating market conditions or delaying trades to ensure target weights are not met, forcing a rebalance with suboptimal allocations. The impact is a potential imbalance in basket composition, which could affect performance, valuation, and user trust. This is considered a design limitation rather than a critical flaw, but it introduces risk in volatile market conditions.\n",
            "severity": "Medium",
            "location": [
                "BasketManagerUtils.sol::completeRebalance#_isTargetWeightMet"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Potential asset manipulation via read-only reentrancy in BasketManagerUtils.proRataRedeem()",
            "description": "The proRataRedeem() function in BasketManagerUtils is vulnerable to read-only reentrancy when calling IERC20(asset).safeTransfer(to, amountToWithdraw), especially if the asset is an ERC-777 token or another token that allows receiver hooks. Although BasketManager has a reentrancy guard, the BasketToken.totalAssets() function can still be called during the transfer, allowing an attacker to manipulate the control flow. The root cause is the lack of adherence to the checks-effects-interactions pattern and the support for callback-enabled tokens. An attacker could exploit this by registering a malicious receiver that calls back into the system during the transfer, causing third parties relying on totalAssets() to observe inconsistent or incorrect asset values during redemption. The impact is limited to incorrect value calculations by third-party systems, potentially leading to financial losses for those parties, but not direct theft of funds from the contract.\n",
            "severity": "Low",
            "location": [
                "BasketManagerUtils.sol::proRataRedeem#loop"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Shares can round down to zero",
            "description": "The proRataRedeem function allows users to redeem shares in a basket, calculating the amount of each underlying asset based on the proportion of shares burned. However, due to integer division rounding down, if the calculated amountToWithdraw is very small, it may round down to zero, resulting in the user receiving no assets despite burning shares. The root cause is the use of integer arithmetic without safeguards for minimum withdrawal amounts. An attacker could exploit this by making small, repeated redemptions that yield zero assets, effectively destroying value without compensation. The impact is a poor user experience and potential loss of value for users redeeming small amounts, which could erode trust in the system. While not a critical vulnerability, it represents a design flaw that could be mitigated with proper checks or alternative rounding mechanisms.\n",
            "severity": "Low",
            "location": [
                "BasketManagerUtils.sol::proRataRedeem#amountToWithdraw"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol",
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketManager.sol",
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        }
    ],
    "affected_files": {
        "BasketToken.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { ERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ERC4626Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { MulticallUpgradeable } from \"@openzeppelin-upgradeable/contracts/utils/MulticallUpgradeable.sol\";\nimport { ERC165Upgradeable } from \"@openzeppelin-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FixedPointMathLib } from \"@solady/utils/FixedPointMathLib.sol\";\nimport { EulerRouter } from \"euler-price-oracle/src/EulerRouter.sol\";\nimport { SelfPermit } from \"src/deps/uniswap-v3-periphery/base/SelfPermit.sol\";\nimport { ERC20PluginsUpgradeable } from \"token-plugins-upgradeable/contracts/ERC20PluginsUpgradeable.sol\";\n\nimport { AssetRegistry } from \"src/AssetRegistry.sol\";\nimport { BasketManager } from \"src/BasketManager.sol\";\nimport { FeeCollector } from \"src/FeeCollector.sol\";\nimport { IERC7540Deposit, IERC7540Operator, IERC7540Redeem } from \"src/interfaces/IERC7540.sol\";\nimport { Errors } from \"src/libraries/Errors.sol\";\nimport { WeightStrategy } from \"src/strategies/WeightStrategy.sol\";\n\n/// @title BasketToken\n/// @notice Manages user deposits and redemptions, which are processed asynchronously by the Basket Manager.\n// slither-disable-next-line missing-inheritance\ncontract BasketToken is\n    ERC20PluginsUpgradeable,\n    ERC4626Upgradeable,\n    ERC165Upgradeable,\n    IERC7540Operator,\n    IERC7540Deposit,\n    IERC7540Redeem,\n    MulticallUpgradeable,\n    SelfPermit\n{\n    /// LIBRARIES ///\n    using SafeERC20 for IERC20;\n\n    /// CONSTANTS ///\n    /// @notice ISO 4217 numeric code for USD, used as a constant address representation\n    address private constant _USD_ISO_4217_CODE = address(840);\n    uint16 private constant _MANAGEMENT_FEE_DECIMALS = 1e4;\n    /// @notice Maximum management fee (30%) in BPS denominated in 1e4.\n    uint16 private constant _MAX_MANAGEMENT_FEE = 3000;\n\n    /// @notice Struct representing a deposit request.\n    struct DepositRequestStruct {\n        // Mapping of controller addresses to their deposited asset amounts.\n        mapping(address controller => uint256 assets) depositAssets;\n        // Total amount of assets deposited in this request.\n        uint256 totalDepositAssets;\n        // Number of shares fulfilled for this deposit request.\n        uint256 fulfilledShares;\n    }\n\n    /// @notice Struct representing a redeem request.\n    struct RedeemRequestStruct {\n        // Mapping of controller addresses to their shares to be redeemed.\n        mapping(address controller => uint256 shares) redeemShares;\n        // Total number of shares to be redeemed in this request.\n        uint256 totalRedeemShares;\n        // Amount of assets fulfilled for this redeem request.\n        uint256 fulfilledAssets;\n        // Flag indicating if the fallback redemption process has been triggered.\n        bool fallbackTriggered;\n    }\n\n    /// STATE VARIABLES ///\n    /// @notice Operator approval status per controller.\n    mapping(address controller => mapping(address operator => bool)) public isOperator;\n    /// @notice Last deposit request ID per controller.\n    mapping(address controller => uint256 requestId) public lastDepositRequestId;\n    /// @notice Last redemption request ID per controller.\n    mapping(address controller => uint256 requestId) public lastRedeemRequestId;\n    /// @dev Deposit requests mapped by request ID. Even IDs are for deposits.\n    mapping(uint256 requestId => DepositRequestStruct) internal _depositRequests;\n    /// @dev Redemption requests mapped by request ID. Odd IDs are for redemptions.\n    mapping(uint256 requestId => RedeemRequestStruct) internal _redeemRequests;\n    /// @notice Address of the BasketManager contract handling deposits and redemptions.\n    address public basketManager;\n    /// @notice Upcoming deposit request ID.\n    uint256 public nextDepositRequestId;\n    /// @notice Upcoming redemption request ID.\n    uint256 public nextRedeemRequestId;\n    /// @notice Address of the AssetRegistry contract for asset status checks.\n    address public assetRegistry;\n    /// @notice Bitflag representing selected assets.\n    uint256 public bitFlag;\n    /// @notice Strategy contract address associated with this basket.\n    address public strategy;\n    /// @notice Timestamp of the last management fee harvest.\n    uint40 public lastManagementFeeHarvestTimestamp;\n\n    /// EVENTS ///\n    /// @notice Emitted when the management fee is harvested.\n    /// @param fee The amount of the management fee harvested.\n    event ManagementFeeHarvested(uint256 fee);\n    /// @notice Emitted when a deposit request is fulfilled and assets are transferred to the user.\n    /// @param requestId The unique identifier of the deposit request.\n    /// @param assets The amount of assets that were deposited.\n    /// @param shares The number of shares minted for the deposit.\n    event DepositFulfilled(uint256 indexed requestId, uint256 assets, uint256 shares);\n    /// @notice Emitted when a redemption request is fulfilled and shares are burned.\n    /// @param requestId The unique identifier of the redemption request.\n    /// @param shares The number of shares redeemed.\n    /// @param assets The amount of assets returned to the user.\n    event RedeemFulfilled(uint256 indexed requestId, uint256 shares, uint256 assets);\n    /// @notice Emitted when the bitflag is updated to a new value.\n    /// @param oldBitFlag The previous bitflag value.\n    /// @param newBitFlag The new bitflag value.\n    event BitFlagUpdated(uint256 oldBitFlag, uint256 newBitFlag);\n\n    /// ERRORS ///\n    /// @notice Thrown when there are no pending deposits to fulfill.\n    error ZeroPendingDeposits();\n    /// @notice Thrown when there are no pending redeems to fulfill.\n    error ZeroPendingRedeems();\n    /// @notice Thrown when attempting to request a deposit or redeem while one or more of the basket's assets are\n    /// paused in the AssetRegistry.\n    error AssetPaused();\n    /// @notice Thrown when attempting to request a new deposit while the user has an outstanding claimable deposit from\n    /// a previous request. The user must first claim the outstanding deposit.\n    error MustClaimOutstandingDeposit();\n    /// @notice Thrown when attempting to request a new redeem while the user has an outstanding claimable redeem from a\n    /// previous request. The user must first claim the outstanding redeem.\n    error MustClaimOutstandingRedeem();\n    /// @notice Thrown when attempting to claim a partial amount of an outstanding deposit or redeem. The user must\n    /// claim the full claimable amount.\n    error MustClaimFullAmount();\n    /// @notice Thrown when the basket manager attempts to fulfill a deposit request with zero shares.\n    error CannotFulfillWithZeroShares();\n    /// @notice Thrown when the basket manager attempts to fulfill a redeem request with zero assets.\n    error CannotFulfillWithZeroAssets();\n    /// @notice Thrown when attempting to claim fallback shares when none are available.\n    error ZeroClaimableFallbackShares();\n    /// @notice Thrown when a non-authorized address attempts to request a deposit or redeem on behalf of another user\n    /// who has not approved them as an operator.\n    error NotAuthorizedOperator();\n    /// @notice Thrown when an address other than the basket manager attempts to call a basket manager only function.\n    error NotBasketManager();\n    /// @notice Thrown when attempting to set an invalid management fee percentage greater than the maximum allowed.\n    error InvalidManagementFee();\n    /// @notice Thrown when the basket manager attempts to fulfill a deposit request that has already been fulfilled.\n    error DepositRequestAlreadyFulfilled();\n    /// @notice Thrown when the basket manager attempts to fulfill a redeem request that has already been fulfilled.\n    error RedeemRequestAlreadyFulfilled();\n    /// @notice Thrown when the basket manager attempts to trigger the fallback for a redeem request that has already\n    /// been put in fallback state.\n    error RedeemRequestAlreadyFallbacked();\n    /// @notice Thrown when attempting to prepare for a new rebalance before the previous epoch's deposit request has\n    /// been fulfilled.\n    error PreviousDepositRequestNotFulfilled();\n    /// @notice Thrown when attempting to prepare for a new rebalance before the previous epoch's redeem request has\n    /// been fulfilled or put in fallback state.\n    error PreviousRedeemRequestNotFulfilled();\n\n    /// @notice Disables initializer functions.\n    constructor() payable {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract.\n    /// @param asset_ Address of the underlying asset.\n    /// @param name_ Name of the token, prefixed with \"CoveBasket-\".\n    /// @param symbol_ Symbol of the token, prefixed with \"cb\".\n    /// @param bitFlag_ Bitflag representing selected assets.\n    /// @param strategy_ Strategy contract address.\n    function initialize(\n        IERC20 asset_,\n        string memory name_,\n        string memory symbol_,\n        uint256 bitFlag_,\n        address strategy_,\n        address assetRegistry_\n    )\n        public\n        initializer\n    {\n        if (strategy_ == address(0) || assetRegistry_ == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        basketManager = msg.sender;\n        bitFlag = bitFlag_;\n        strategy = strategy_;\n        assetRegistry = assetRegistry_;\n        nextDepositRequestId = 2;\n        nextRedeemRequestId = 3;\n        __ERC4626_init(asset_);\n        __ERC20_init(string.concat(\"CoveBasket-\", name_), string.concat(\"covb\", symbol_));\n        __ERC20Plugins_init(8, 2_000_000);\n    }\n\n    /// @notice Returns the value of the basket in assets. This will be an estimate as it does not account for other\n    /// factors that may affect the swap rates.\n    /// @return The total value of the basket in assets.\n    function totalAssets() public view override returns (uint256) {\n        address[] memory assets = AssetRegistry(assetRegistry).getAssets(bitFlag);\n        uint256 usdAmount;\n        uint256 assetsLength = assets.length;\n\n        BasketManager bm = BasketManager(basketManager);\n        EulerRouter eulerRouter = EulerRouter(bm.eulerRouter());\n\n        for (uint256 i = 0; i < assetsLength;) {\n            // slither-disable-start calls-loop\n            uint256 assetBalance = bm.basketBalanceOf(address(this), assets[i]);\n            // Rounding direction: down\n            usdAmount += eulerRouter.getQuote(assetBalance, assets[i], _USD_ISO_4217_CODE);\n            // slither-disable-end calls-loop\n\n            unchecked {\n                // Overflow not possible: i is less than assetsLength\n                ++i;\n            }\n        }\n\n        return eulerRouter.getQuote(usdAmount, _USD_ISO_4217_CODE, asset());\n    }\n\n    /// @notice Returns the target weights for the given epoch.\n    /// @return The target weights for the basket.\n    function getTargetWeights() public view returns (uint64[] memory) {\n        return WeightStrategy(strategy).getTargetWeights(bitFlag);\n    }\n\n    /// ERC7540 LOGIC ///\n\n    /// @notice Transfers assets from owner and submits a request for an asynchronous deposit.\n    /// @param assets The amount of assets to deposit.\n    /// @param controller The address of the controller of the position being created.\n    /// @param owner The address of the owner of the assets being deposited.\n    function requestDeposit(uint256 assets, address controller, address owner) public returns (uint256 requestId) {\n        // Checks\n        if (assets == 0) {\n            revert Errors.ZeroAmount();\n        }\n        requestId = nextDepositRequestId;\n        uint256 userLastDepositRequestId = lastDepositRequestId[controller];\n        // If the user has a pending deposit request in the past, they must wait for it to be fulfilled before making a\n        // new one\n        if (userLastDepositRequestId != requestId) {\n            if (pendingDepositRequest(userLastDepositRequestId, controller) > 0) {\n                revert MustClaimOutstandingDeposit();\n            }\n        }\n        // If the user has a claimable deposit request, they must claim it before making a new one\n        if (claimableDepositRequest(userLastDepositRequestId, controller) > 0) {\n            revert MustClaimOutstandingDeposit();\n        }\n        if (AssetRegistry(assetRegistry).hasPausedAssets(bitFlag)) {\n            revert AssetPaused();\n        }\n        // Effects\n        DepositRequestStruct storage depositRequest = _depositRequests[requestId];\n        // update controllers balance of assets pending deposit\n        depositRequest.depositAssets[controller] += assets;\n        // update total pending deposits for the current requestId\n        depositRequest.totalDepositAssets += assets;\n        // update controllers latest deposit request id\n        lastDepositRequestId[controller] = requestId;\n        emit DepositRequest(controller, owner, requestId, msg.sender, assets);\n        // Interactions\n        // Assets are immediately transferrred to here to await the basketManager to pull them\n        // slither-disable-next-line arbitrary-send-erc20\n        IERC20(asset()).safeTransferFrom(owner, address(this), assets);\n    }\n\n    /// @notice Returns the pending deposit request amount for a controller.\n    /// @dev If the epoch has been advanced then the request has been fulfilled and is no longer pending.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller of the deposit request.\n    /// @return assets The amount of assets pending deposit.\n    function pendingDepositRequest(uint256 requestId, address controller) public view returns (uint256 assets) {\n        DepositRequestStruct storage depositRequest = _depositRequests[requestId];\n        assets = depositRequest.fulfilledShares == 0 ? depositRequest.depositAssets[controller] : 0;\n    }\n\n    /// @notice Returns the amount of requested assets in Claimable state for the controller with the given requestId.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller.\n    function claimableDepositRequest(uint256 requestId, address controller) public view returns (uint256 assets) {\n        DepositRequestStruct storage depositRequest = _depositRequests[requestId];\n        assets = _claimableDepositRequest(depositRequest.fulfilledShares, depositRequest.depositAssets[controller]);\n    }\n\n    function _claimableDepositRequest(\n        uint256 fulfilledShares,\n        uint256 depositAssets\n    )\n        internal\n        pure\n        returns (uint256 assets)\n    {\n        return fulfilledShares != 0 ? depositAssets : 0;\n    }\n\n    /// @notice Requests a redemption of shares from the basket.\n    /// @param shares The amount of shares to redeem.\n    /// @param controller The address of the controller of the redeemed shares.\n    /// @param owner The address of the request owner.\n    function requestRedeem(uint256 shares, address controller, address owner) public returns (uint256 requestId) {\n        // Checks\n        if (shares == 0) {\n            revert Errors.ZeroAmount();\n        }\n        requestId = nextRedeemRequestId;\n        // If the user has a pending redeem request in the past, they must wait for it to be fulfilled before making a\n        // new one\n        uint256 userLastRedeemRequestId = lastRedeemRequestId[controller];\n        if (userLastRedeemRequestId != requestId) {\n            if (pendingRedeemRequest(userLastRedeemRequestId, controller) > 0) {\n                revert MustClaimOutstandingRedeem();\n            }\n        }\n        // If the user has a claimable redeem request, they must claim it before making a new one\n        if (claimableRedeemRequest(userLastRedeemRequestId, controller) > 0 || claimableFallbackShares(controller) > 0)\n        {\n            revert MustClaimOutstandingRedeem();\n        }\n        if (msg.sender != owner) {\n            if (!isOperator[owner][msg.sender]) {\n                _spendAllowance(owner, msg.sender, shares);\n            }\n        }\n        if (AssetRegistry(assetRegistry).hasPausedAssets(bitFlag)) {\n            revert AssetPaused();\n        }\n\n        // Effects\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];\n        // update total pending redemptions for the current requestId\n        redeemRequest.totalRedeemShares += shares;\n        // update controllers latest redeem request id\n        lastRedeemRequestId[controller] = requestId;\n        // update controllers balance of assets pending deposit\n        redeemRequest.redeemShares[controller] += shares;\n        _transfer(owner, address(this), shares);\n        emit RedeemRequest(controller, owner, requestId, msg.sender, shares);\n    }\n\n    /// @notice Returns the pending redeem request amount for a user.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller of the redemption request.\n    /// @return shares The amount of shares pending redemption.\n    function pendingRedeemRequest(uint256 requestId, address controller) public view returns (uint256 shares) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];\n        shares = redeemRequest.fulfilledAssets == 0 && !redeemRequest.fallbackTriggered\n            ? redeemRequest.redeemShares[controller]\n            : 0;\n    }\n\n    /// @notice Returns the amount of requested shares in Claimable state for the controller with the given requestId.\n    /// @param requestId The id of the request.\n    /// @param controller The address of the controller of the redemption request.\n    /// @return shares The amount of shares claimable.\n    // solhint-disable-next-line no-unused-vars\n    function claimableRedeemRequest(uint256 requestId, address controller) public view returns (uint256 shares) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];\n        shares = _claimableRedeemRequest(redeemRequest.fulfilledAssets, redeemRequest.redeemShares[controller]);\n    }\n\n    function _claimableRedeemRequest(\n        uint256 fulfilledAssets,\n        uint256 redeemShares\n    )\n        internal\n        pure\n        returns (uint256 shares)\n    {\n        return fulfilledAssets != 0 ? redeemShares : 0;\n    }\n\n    /// @notice Fulfills all pending deposit requests. Only callable by the basket manager. Assets are held by the\n    /// basket manager. Locks in the rate at which users can claim their shares for deposited assets.\n    /// @param shares The amount of shares the deposit was fulfilled with.\n    function fulfillDeposit(uint256 shares) public {\n        // Checks\n        _onlyBasketManager();\n        // currentRequestId was advanced by 2 to prepare for rebalance\n        uint256 currentRequestId = nextDepositRequestId - 2;\n        DepositRequestStruct storage depositRequest = _depositRequests[currentRequestId];\n        uint256 assets = depositRequest.totalDepositAssets;\n        if (assets == 0) {\n            revert ZeroPendingDeposits();\n        }\n        if (shares == 0) {\n            revert CannotFulfillWithZeroShares();\n        }\n        if (depositRequest.fulfilledShares > 0) {\n            revert DepositRequestAlreadyFulfilled();\n        }\n        // Effects\n        depositRequest.fulfilledShares = shares;\n        emit DepositFulfilled(currentRequestId, assets, shares);\n        _mint(address(this), shares);\n        // Interactions\n        // transfer the assets to the basket manager\n        IERC20(asset()).safeTransfer(msg.sender, assets);\n    }\n\n    /// @notice Sets the new bitflag for the basket.\n    /// @dev This can only be called by the Basket Manager therefore we assume that the new bitflag is valid.\n    /// @param bitFlag_ The new bitflag.\n    function setBitFlag(uint256 bitFlag_) public {\n        _onlyBasketManager();\n        uint256 oldBitFlag = bitFlag;\n        bitFlag = bitFlag_;\n        emit BitFlagUpdated(oldBitFlag, bitFlag_);\n    }\n\n    /// @notice Called by the basket manager to advance the redeem epoch, preventing any further redeem requests for the\n    /// current epoch. Returns the total amount of assets pending deposit and shares pending redemption. This is called\n    /// at the first step of the rebalance process regardless of the presence of any pending deposits or redemptions.\n    /// When there are no pending deposits or redeems, the epoch is not advanced.\n    /// @dev This function also records the total amount of shares pending redemption for the current epoch.\n    /// @param feeBps The management fee in basis points to be harvested.\n    /// @param feeCollector The address that will receive the harvested management fee.\n    /// @return pendingDeposits The total amount of assets pending deposit.\n    /// @return sharesPendingRedemption The total amount of shares pending redemption.\n    function prepareForRebalance(\n        uint16 feeBps,\n        address feeCollector\n    )\n        external\n        returns (uint256 pendingDeposits, uint256 sharesPendingRedemption)\n    {\n        _onlyBasketManager();\n        uint256 nextDepositRequestId_ = nextDepositRequestId;\n        uint256 nextRedeemRequestId_ = nextRedeemRequestId;\n\n        // Check if previous deposit request has been fulfilled\n        DepositRequestStruct storage previousDepositRequest = _depositRequests[nextDepositRequestId_ - 2];\n        if (previousDepositRequest.totalDepositAssets > 0) {\n            if (previousDepositRequest.fulfilledShares == 0) {\n                revert PreviousDepositRequestNotFulfilled();\n            }\n        }\n\n        // Check if previous redeem request has been fulfilled or fallbacked\n        RedeemRequestStruct storage previousRedeemRequest = _redeemRequests[nextRedeemRequestId_ - 2];\n        if (previousRedeemRequest.totalRedeemShares > 0) {\n            if (previousRedeemRequest.fulfilledAssets == 0) {\n                if (!previousRedeemRequest.fallbackTriggered) {\n                    revert PreviousRedeemRequestNotFulfilled();\n                }\n            }\n        }\n\n        // Get current pending deposits\n        pendingDeposits = _depositRequests[nextDepositRequestId_].totalDepositAssets;\n        if (pendingDeposits > 0) {\n            nextDepositRequestId = nextDepositRequestId_ + 2;\n        }\n\n        sharesPendingRedemption = _redeemRequests[nextRedeemRequestId_].totalRedeemShares;\n        if (sharesPendingRedemption > 0) {\n            nextRedeemRequestId = nextRedeemRequestId_ + 2;\n        }\n\n        _harvestManagementFee(feeBps, feeCollector);\n    }\n\n    /// @notice Fulfills all pending redeem requests. Only callable by the basket manager. Burns the shares which are\n    /// pending redemption. Locks in the rate at which users can claim their assets for redeemed shares.\n    /// @dev prepareForRebalance must be called before this function.\n    /// @param assets The amount of assets the redemption was fulfilled with.\n    function fulfillRedeem(uint256 assets) public {\n        // Checks\n        _onlyBasketManager();\n        uint256 currentRequestId = nextRedeemRequestId - 2;\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[currentRequestId];\n        uint256 sharesPendingRedemption = redeemRequest.totalRedeemShares;\n        if (sharesPendingRedemption == 0) {\n            revert ZeroPendingRedeems();\n        }\n        if (assets == 0) {\n            revert CannotFulfillWithZeroAssets();\n        }\n        if (redeemRequest.fulfilledAssets > 0) {\n            revert RedeemRequestAlreadyFulfilled();\n        }\n        // Effects\n        redeemRequest.fulfilledAssets = assets;\n        emit RedeemFulfilled(currentRequestId, sharesPendingRedemption, assets);\n        _burn(address(this), sharesPendingRedemption);\n        // Interactions\n        // slither-disable-next-line arbitrary-send-erc20\n        IERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n    }\n\n    /// @notice Returns the total amount of assets pending deposit.\n    /// @return The total pending deposit amount.\n    function totalPendingDeposits() public view returns (uint256) {\n        return _depositRequests[nextDepositRequestId].totalDepositAssets;\n    }\n\n    /// @notice Returns the total number of shares pending redemption.\n    /// @return The total pending redeem amount.\n    function totalPendingRedemptions() public view returns (uint256) {\n        return _redeemRequests[nextRedeemRequestId].totalRedeemShares;\n    }\n\n    /// @notice Cancels a pending deposit request.\n    function cancelDepositRequest() public {\n        // Checks\n        uint256 nextDepositRequestId_ = nextDepositRequestId;\n        uint256 pendingDeposit = pendingDepositRequest(nextDepositRequestId_, msg.sender);\n        if (pendingDeposit == 0) {\n            revert ZeroPendingDeposits();\n        }\n        // Effects\n        DepositRequestStruct storage depositRequest = _depositRequests[nextDepositRequestId_];\n        depositRequest.depositAssets[msg.sender] = 0;\n        depositRequest.totalDepositAssets -= pendingDeposit;\n        // Interactions\n        IERC20(asset()).safeTransfer(msg.sender, pendingDeposit);\n    }\n\n    /// @notice Cancels a pending redeem request.\n    function cancelRedeemRequest() public {\n        // Checks\n        uint256 nextRedeemRequestId_ = nextRedeemRequestId;\n        uint256 pendingRedeem = pendingRedeemRequest(nextRedeemRequestId_, msg.sender);\n        if (pendingRedeem == 0) {\n            revert ZeroPendingRedeems();\n        }\n        // Effects\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[nextRedeemRequestId_];\n        redeemRequest.redeemShares[msg.sender] = 0;\n        redeemRequest.totalRedeemShares -= pendingRedeem;\n        _transfer(address(this), msg.sender, pendingRedeem);\n    }\n\n    /// @notice Sets a status for an operator's ability to act on behalf of a controller.\n    /// @param operator The address of the operator.\n    /// @param approved The status of the operator.\n    /// @return success True if the operator status was set, false otherwise.\n    function setOperator(address operator, bool approved) public returns (bool success) {\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n\n    /// @dev Reverts if the controller is not the caller or the operator of the caller.\n    function _onlySelfOrOperator(address controller) internal view {\n        if (msg.sender != controller) {\n            if (!isOperator[controller][msg.sender]) {\n                revert NotAuthorizedOperator();\n            }\n        }\n    }\n\n    /// @dev Reverts if the caller is not the Basket Manager.\n    function _onlyBasketManager() internal view {\n        if (basketManager != msg.sender) {\n            revert NotBasketManager();\n        }\n    }\n\n    /// @notice Returns the address of the share token as per ERC-7575.\n    /// @return shareTokenAddress The address of the share token.\n    /// @dev For non-multi asset vaults this should always return address(this).\n    function share() public view returns (address shareTokenAddress) {\n        shareTokenAddress = address(this);\n    }\n\n    /// FALLBACK REDEEM LOGIC ///\n\n    /// @notice In the event of a failed redemption fulfillment this function is called by the basket manager. Allows\n    /// users to claim their shares back for a redemption in the future and advances the redemption epoch.\n    function fallbackRedeemTrigger() public {\n        _onlyBasketManager();\n        // Check if the redeem is going on. If not, revert\n        uint256 currentRedeemRequestId = nextRedeemRequestId - 2;\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[currentRedeemRequestId];\n        if (redeemRequest.fallbackTriggered) {\n            revert RedeemRequestAlreadyFallbacked();\n        }\n        if (redeemRequest.fulfilledAssets > 0) {\n            revert RedeemRequestAlreadyFulfilled();\n        }\n        if (redeemRequest.totalRedeemShares == 0) {\n            revert ZeroPendingRedeems();\n        }\n        redeemRequest.fallbackTriggered = true;\n    }\n\n    /// @notice Claims shares given for a previous redemption request in the event a redemption fulfillment for a\n    /// given epoch fails.\n    /// @param receiver The address to receive the shares.\n    /// @param controller The address of the controller of the redemption request.\n    /// @return shares The amount of shares claimed.\n    function claimFallbackShares(address receiver, address controller) public returns (uint256 shares) {\n        // Checks\n        _onlySelfOrOperator(controller);\n        shares = claimableFallbackShares(controller);\n        if (shares == 0) {\n            revert ZeroClaimableFallbackShares();\n        }\n        // Effects\n        _redeemRequests[lastRedeemRequestId[controller]].redeemShares[controller] = 0;\n        _transfer(address(this), receiver, shares);\n    }\n\n    /// @notice Allows the caller to claim their own fallback shares.\n    /// @return shares The amount of shares claimed.\n    function claimFallbackShares() public returns (uint256 shares) {\n        return claimFallbackShares(msg.sender, msg.sender);\n    }\n\n    /// @notice Returns the amount of shares claimable for a given user in the event of a failed redemption\n    /// fulfillment.\n    /// @param controller The address of the controller.\n    /// @return shares The amount of shares claimable by the controller.\n    function claimableFallbackShares(address controller) public view returns (uint256 shares) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        if (redeemRequest.fallbackTriggered) {\n            return redeemRequest.redeemShares[controller];\n        }\n        return 0;\n    }\n\n    /// @notice Immediately redeems shares for all assets associated with this basket. This is synchronous and does not\n    /// require the rebalance process to be completed.\n    /// @param shares Number of shares to redeem.\n    /// @param to Address to receive the assets.\n    /// @param from Address to redeem shares from.\n    function proRataRedeem(uint256 shares, address to, address from) public {\n        // Effects\n        uint16 feeBps = BasketManager(basketManager).managementFee(address(this));\n        address feeCollector = BasketManager(basketManager).feeCollector();\n        _harvestManagementFee(feeBps, feeCollector);\n        if (msg.sender != from) {\n            _spendAllowance(from, msg.sender, shares);\n        }\n        uint256 totalSupplyBefore = totalSupply();\n        _burn(from, shares);\n        // Interactions\n        BasketManager(basketManager).proRataRedeem(totalSupplyBefore, shares, to);\n    }\n\n    // slither-disable-next-line timestamp\n    function _harvestManagementFee(uint16 feeBps, address feeCollector) internal {\n        // Checks\n        if (feeBps > _MAX_MANAGEMENT_FEE) {\n            revert InvalidManagementFee();\n        }\n        uint256 timeSinceLastHarvest = block.timestamp - lastManagementFeeHarvestTimestamp;\n\n        // Effects\n        lastManagementFeeHarvestTimestamp = uint40(block.timestamp);\n        if (feeBps != 0) {\n            if (timeSinceLastHarvest != 0) {\n                if (timeSinceLastHarvest != block.timestamp) {\n                    // remove shares held by the treasury or currently pending redemption from calculation\n                    uint256 currentTotalSupply = totalSupply() - balanceOf(feeCollector)\n                        - pendingRedeemRequest(lastRedeemRequestId[feeCollector], feeCollector);\n                    uint256 fee = FixedPointMathLib.fullMulDiv(\n                        currentTotalSupply, feeBps * timeSinceLastHarvest, _MANAGEMENT_FEE_DECIMALS * uint256(365 days)\n                    );\n                    if (fee != 0) {\n                        emit ManagementFeeHarvested(fee);\n                        _mint(feeCollector, fee);\n                        // Interactions\n                        FeeCollector(feeCollector).notifyHarvestFee(fee);\n                    }\n                }\n            }\n        }\n    }\n\n    /// ERC4626 OVERRIDDEN LOGIC ///\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @param assets The amount of assets previously requested for deposit.\n    /// @param receiver The address to receive the shares.\n    /// @param controller The address of the controller of the deposit request.\n    /// @return shares The amount of shares minted.\n    function deposit(uint256 assets, address receiver, address controller) public returns (uint256 shares) {\n        // Checks\n        if (assets == 0) {\n            revert Errors.ZeroAmount();\n        }\n        _onlySelfOrOperator(controller);\n        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];\n        uint256 fulfilledShares = depositRequest.fulfilledShares;\n        uint256 depositAssets = depositRequest.depositAssets[controller];\n        if (assets != _claimableDepositRequest(fulfilledShares, depositAssets)) {\n            revert MustClaimFullAmount();\n        }\n        shares = _maxMint(fulfilledShares, depositAssets, depositRequest.totalDepositAssets);\n        // Effects\n        _claimDeposit(depositRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @param assets The amount of assets to be claimed.\n    /// @param receiver The address to receive the assets.\n    /// @return shares The amount of shares previously requested for redemption.\n    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\n        return deposit(assets, receiver, msg.sender);\n    }\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @dev Deposit should be used in all instances instead.\n    /// @param shares The amount of shares to receive.\n    /// @param receiver The address to receive the shares.\n    /// @param controller The address of the controller of the deposit request.\n    /// @return assets The amount of assets previously requested for deposit.\n    function mint(uint256 shares, address receiver, address controller) public returns (uint256 assets) {\n        // Checks\n        _onlySelfOrOperator(controller);\n        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];\n        uint256 fulfilledShares = depositRequest.fulfilledShares;\n        uint256 depositAssets = depositRequest.depositAssets[controller];\n        if (shares != _maxMint(fulfilledShares, depositAssets, depositRequest.totalDepositAssets)) {\n            revert MustClaimFullAmount();\n        }\n        // Effects\n        assets = _claimableDepositRequest(fulfilledShares, depositAssets);\n        _claimDeposit(depositRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.\n    /// @param shares The amount of shares to receive.\n    /// @param receiver The address to receive the shares.\n    /// @return assets The amount of assets previously requested for deposit.\n    function mint(uint256 shares, address receiver) public override returns (uint256 assets) {\n        return mint(shares, receiver, msg.sender);\n    }\n\n    /// @notice Internal function to claim deposit for a given amount of assets and shares.\n    /// @param assets The amount of assets to claim.\n    /// @param shares The amount of shares to claim.\n    /// @param receiver The address of the receiver of the claimed assets.\n    /// @param controller The address of the controller of the deposit request.\n    function _claimDeposit(\n        DepositRequestStruct storage depositRequest,\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address controller\n    )\n        internal\n    {\n        // Effects\n        depositRequest.depositAssets[controller] = 0;\n        emit Deposit(controller, receiver, assets, shares);\n        // Interactions\n        _transfer(address(this), receiver, shares);\n    }\n\n    /// @notice Transfers a user's assets owed for a previously fulfillled redemption request.\n    /// @dev Redeem should be used in all instances instead.\n    /// @param assets The amount of assets to be claimed.\n    /// @param receiver The address to receive the assets.\n    /// @param controller The address of the controller of the redeem request.\n    /// @return shares The amount of shares previously requested for redemption.\n    function withdraw(uint256 assets, address receiver, address controller) public override returns (uint256 shares) {\n        // Checks\n        _onlySelfOrOperator(controller);\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        uint256 fulfilledAssets = redeemRequest.fulfilledAssets;\n        uint256 redeemShares = redeemRequest.redeemShares[controller];\n        if (assets != _maxWithdraw(fulfilledAssets, redeemShares, redeemRequest.totalRedeemShares)) {\n            revert MustClaimFullAmount();\n        }\n        shares = _claimableRedeemRequest(fulfilledAssets, redeemShares);\n        // Effects\n        _claimRedemption(redeemRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Transfers the receiver assets owed for a fulfilled redeem request.\n    /// @param shares The amount of shares to be claimed.\n    /// @param receiver The address to receive the assets.\n    /// @param controller The address of the controller of the redeem request.\n    /// @return assets The amount of assets previously requested for redemption.\n    function redeem(uint256 shares, address receiver, address controller) public override returns (uint256 assets) {\n        // Checks\n        if (shares == 0) {\n            revert Errors.ZeroAmount();\n        }\n        _onlySelfOrOperator(controller);\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        uint256 fulfilledAssets = redeemRequest.fulfilledAssets;\n        uint256 redeemShares = redeemRequest.redeemShares[controller];\n        if (shares != _claimableRedeemRequest(fulfilledAssets, redeemShares)) {\n            revert MustClaimFullAmount();\n        }\n        assets = _maxWithdraw(fulfilledAssets, redeemShares, redeemRequest.totalRedeemShares);\n        // Effects & Interactions\n        _claimRedemption(redeemRequest, assets, shares, receiver, controller);\n    }\n\n    /// @notice Internal function to claim redemption for a given amount of assets and shares.\n    /// @param assets The amount of assets to claim.\n    /// @param shares The amount of shares to claim.\n    /// @param receiver The address of the receiver of the claimed assets.\n    /// @param controller The address of the controller of the redemption request.\n    function _claimRedemption(\n        RedeemRequestStruct storage redeemRequest,\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address controller\n    )\n        internal\n    {\n        // Effects\n        redeemRequest.redeemShares[controller] = 0;\n        emit Withdraw(msg.sender, receiver, controller, assets, shares);\n        // Interactions\n        IERC20(asset()).safeTransfer(receiver, assets);\n    }\n\n    /// @notice Returns an controller's amount of assets fulfilled for redemption.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of assets that can be withdrawn.\n    function maxWithdraw(address controller) public view override returns (uint256) {\n        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];\n        return _maxWithdraw(\n            redeemRequest.fulfilledAssets, redeemRequest.redeemShares[controller], redeemRequest.totalRedeemShares\n        );\n    }\n\n    function _maxWithdraw(\n        uint256 fulfilledAssets,\n        uint256 redeemShares,\n        uint256 totalRedeemShares\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            totalRedeemShares == 0 ? 0 : FixedPointMathLib.fullMulDiv(fulfilledAssets, redeemShares, totalRedeemShares);\n    }\n\n    /// @notice Returns an controller's amount of shares fulfilled for redemption.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of shares that can be redeemed.\n    function maxRedeem(address controller) public view override returns (uint256) {\n        return claimableRedeemRequest(lastRedeemRequestId[controller], controller);\n    }\n\n    /// @notice Returns an controller's amount of assets fulfilled for deposit.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of assets that can be deposited.\n    function maxDeposit(address controller) public view override returns (uint256) {\n        return claimableDepositRequest(lastDepositRequestId[controller], controller);\n    }\n\n    /// @notice Returns an controller's amount of shares fulfilled for deposit.\n    /// @dev For requests yet to be fulfilled, this will return 0.\n    /// @param controller The address of the controller.\n    /// @return The amount of shares that can be minted.\n    function maxMint(address controller) public view override returns (uint256) {\n        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];\n        return _maxMint(\n            depositRequest.fulfilledShares, depositRequest.depositAssets[controller], depositRequest.totalDepositAssets\n        );\n    }\n\n    function _maxMint(\n        uint256 fulfilledShares,\n        uint256 depositAssets,\n        uint256 totalDepositAssets\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return totalDepositAssets == 0\n            ? 0\n            : FixedPointMathLib.fullMulDiv(fulfilledShares, depositAssets, totalDepositAssets);\n    }\n\n    // solhint-disable custom-errors,gas-custom-errors,reason-string\n    // Preview functions always revert for async flows\n    function previewDeposit(uint256) public pure override returns (uint256) {\n        revert();\n    }\n\n    // Preview functions always revert for async flows\n    function previewMint(uint256) public pure override returns (uint256) {\n        revert();\n    }\n\n    // Preview functions always revert for async flows\n    function previewWithdraw(uint256) public pure override returns (uint256) {\n        revert();\n    }\n\n    // Preview functions always revert for async flows\n    function previewRedeem(uint256) public pure override returns (uint256) {\n        revert();\n    }\n    // solhint-enable custom-errors,gas-custom-errors,reason-string\n\n    /// @notice Returns true if the redemption request's fallback has been triggered.\n    /// @param requestId The id of the request.\n    /// @return True if the fallback has been triggered, false otherwise.\n    function fallbackTriggered(uint256 requestId) public view returns (bool) {\n        return _redeemRequests[requestId].fallbackTriggered;\n    }\n\n    //// ERC165 OVERRIDDEN LOGIC ///\n    /// @notice Checks if the contract supports the given interface.\n    /// @param interfaceID The interface ID.\n    /// @return True if the contract supports the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == 0x2f0a18c5 || interfaceID == 0xf815c03d\n            || interfaceID == type(IERC7540Operator).interfaceId || interfaceID == type(IERC7540Deposit).interfaceId\n            || interfaceID == type(IERC7540Redeem).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /// @dev Override to call the ERC20PluginsUpgradeable's _update function.\n    function _update(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override(ERC20PluginsUpgradeable, ERC20Upgradeable)\n    {\n        ERC20PluginsUpgradeable._update(from, to, amount);\n    }\n\n    /// @dev Override to call the ERC20PluginsUpgradeable's balanceOf function.\n    /// See {IERC20-balanceOf}.\n    function balanceOf(address account)\n        public\n        view\n        override(ERC20PluginsUpgradeable, ERC20Upgradeable, IERC20)\n        returns (uint256)\n    {\n        return ERC20PluginsUpgradeable.balanceOf(account);\n    }\n\n    /// @dev Override to use ERC4626's decimals function.\n    /// See {IERC20Metadata-decimals}.\n    function decimals() public view override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8) {\n        return ERC4626Upgradeable.decimals();\n    }\n}\n",
        "BasketManagerUtils.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FixedPointMathLib } from \"@solady/utils/FixedPointMathLib.sol\";\n\nimport { AssetRegistry } from \"src/AssetRegistry.sol\";\nimport { BasketToken } from \"src/BasketToken.sol\";\nimport { Errors } from \"src/libraries/Errors.sol\";\nimport { MathUtils } from \"src/libraries/MathUtils.sol\";\nimport { TokenSwapAdapter } from \"src/swap_adapters/TokenSwapAdapter.sol\";\nimport { BasketManagerStorage, RebalanceStatus, Status } from \"src/types/BasketManagerStorage.sol\";\nimport { BasketTradeOwnership, ExternalTrade, InternalTrade } from \"src/types/Trades.sol\";\n\n/// @title BasketManagerUtils\n/// @notice Library containing utility functions for managing storage related to baskets, including creating new\n/// baskets, proposing and executing rebalances, and settling internal and external token trades.\nlibrary BasketManagerUtils {\n    using SafeERC20 for IERC20;\n\n    /// STRUCTS ///\n\n    /// @notice Struct containing data for an internal trade.\n    struct InternalTradeInfo {\n        // Index of the basket that is selling.\n        uint256 fromBasketIndex;\n        // Index of the basket that is buying.\n        uint256 toBasketIndex;\n        // Index of the token to sell.\n        uint256 sellTokenAssetIndex;\n        // Index of the token to buy.\n        uint256 buyTokenAssetIndex;\n        // Index of the buy token in the buying basket.\n        uint256 toBasketBuyTokenIndex;\n        // Index of the sell token in the buying basket.\n        uint256 toBasketSellTokenIndex;\n        // Amount of the buy token that is traded.\n        uint256 netBuyAmount;\n        // Amount of the sell token that is traded.\n        uint256 netSellAmount;\n        // Fee charged on the buy token on the trade.\n        uint256 feeOnBuy;\n        // Fee charged on the sell token on the trade.\n        uint256 feeOnSell;\n    }\n\n    /// @notice Struct containing data for an external trade.\n    struct ExternalTradeInfo {\n        // Price of the sell token.\n        uint256 sellTokenPrice;\n        // Price of the buy token.\n        uint256 buyTokenPrice;\n        // Value of the sell token.\n        uint256 sellValue;\n        // Minimum amount of the buy token that the trade results in.\n        uint256 internalMinAmount;\n        // Difference between the internalMinAmount and the minAmount.\n        uint256 diff;\n    }\n\n    /// @notice Struct containing data for basket ownership of an external trade.\n    struct BasketOwnershipInfo {\n        // Index of the basket.\n        uint256 basketIndex;\n        // Index of the buy token asset.\n        uint256 buyTokenAssetIndex;\n        // Index of the sell token asset.\n        uint256 sellTokenAssetIndex;\n    }\n\n    /// CONSTANTS ///\n    /// @notice ISO 4217 numeric code for USD, used as a constant address representation\n    address private constant _USD_ISO_4217_CODE = address(840);\n    /// @notice Maximum number of basket tokens allowed to be created.\n    uint256 private constant _MAX_NUM_OF_BASKET_TOKENS = 256;\n    /// @notice Maximum slippage multiplier for token swaps, expressed in 1e18.\n    uint256 private constant _MAX_SLIPPAGE = 0.05e18; // 5%\n    /// @notice Maximum deviation multiplier to determine if a set of balances has reached the desired target weights.\n    uint256 private constant _MAX_WEIGHT_DEVIATION = 0.05e18; // 5%\n    /// @notice Precision used for weight calculations and slippage calculations.\n    uint256 private constant _WEIGHT_PRECISION = 1e18;\n    /// @notice Maximum number of retries for a rebalance.\n    uint8 private constant _MAX_RETRIES = 3;\n    /// @notice Minimum time between rebalances in seconds.\n    uint40 private constant _REBALANCE_COOLDOWN_SEC = 1 hours;\n\n    /// EVENTS ///\n    /// @notice Emitted when an internal trade is settled.\n    /// @param internalTrade Internal trade that was settled.\n    /// @param buyAmount Amount of the the from token that is traded.\n    event InternalTradeSettled(InternalTrade internalTrade, uint256 buyAmount);\n    /// @notice Emitted when swap fees are charged on an internal trade.\n    /// @param asset Asset that the swap fee was charged in.\n    /// @param amount Amount of the asset that was charged.\n    event SwapFeeCharged(address indexed asset, uint256 amount);\n    /// @notice Emitted when a rebalance is proposed for a set of baskets\n    /// @param epoch Unique identifier for the rebalance, incremented each time a rebalance is proposed\n    /// @param baskets Array of basket addresses to rebalance\n    /// @param proposedTargetWeights Array of target weights for each basket\n    /// @param basketHash Hash of the basket addresses and target weights for the rebalance\n    event RebalanceProposed(\n        uint40 indexed epoch, address[] baskets, uint64[][] proposedTargetWeights, bytes32 basketHash\n    );\n    /// @notice Emitted when a rebalance is completed.\n    event RebalanceCompleted(uint40 indexed epoch);\n\n    /// ERRORS ///\n    /// @dev Reverts when the total supply of a basket token is zero.\n    error ZeroTotalSupply();\n    /// @dev Reverts when the amount of burned shares is zero.\n    error ZeroBurnedShares();\n    /// @dev Reverts when trying to burn more shares than the total supply.\n    error CannotBurnMoreSharesThanTotalSupply();\n    /// @dev Reverts when the requested basket token is not found.\n    error BasketTokenNotFound();\n    /// @dev Reverts when the requested asset is not found in the basket.\n    error AssetNotFoundInBasket();\n    /// @dev Reverts when trying to create a basket token that already exists.\n    error BasketTokenAlreadyExists();\n    /// @dev Reverts when the maximum number of basket tokens has been reached.\n    error BasketTokenMaxExceeded();\n    /// @dev Reverts when the requested element index is not found.\n    error ElementIndexNotFound();\n    /// @dev Reverts when the strategy registry does not support the given strategy.\n    error StrategyRegistryDoesNotSupportStrategy();\n    /// @dev Reverts when the baskets or target weights do not match the proposed rebalance.\n    error BasketsMismatch();\n    /// @dev Reverts when the base asset does not match the given asset.\n    error BaseAssetMismatch();\n    /// @dev Reverts when the asset is not found in the asset registry.\n    error AssetListEmpty();\n    /// @dev Reverts when a rebalance is in progress and the caller must wait for it to complete.\n    error MustWaitForRebalanceToComplete();\n    /// @dev Reverts when there is no rebalance in progress.\n    error NoRebalanceInProgress();\n    /// @dev Reverts when it is too early to complete the rebalance.\n    error TooEarlyToCompleteRebalance();\n    /// @dev Reverts when it is too early to propose a rebalance.\n    error TooEarlyToProposeRebalance();\n    /// @dev Reverts when a rebalance is not required.\n    error RebalanceNotRequired();\n    /// @dev Reverts when the external trade slippage exceeds the allowed limit.\n    error ExternalTradeSlippage();\n    /// @dev Reverts when the target weights are not met.\n    error TargetWeightsNotMet();\n    /// @dev Reverts when the minimum or maximum amount is not reached for an internal trade.\n    error InternalTradeMinMaxAmountNotReached();\n    /// @dev Reverts when the trade token amount is incorrect.\n    error IncorrectTradeTokenAmount();\n    /// @dev Reverts when given external trades do not match.\n    error ExternalTradeMismatch();\n    /// @dev Reverts when the delegatecall to the tokenswap adapter fails.\n    error CompleteTokenSwapFailed();\n    /// @dev Reverts when an asset included in a bit flag is not enabled in the asset registry.\n    error AssetNotEnabled();\n\n    /// @notice Creates a new basket token with the given parameters.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basketName Name of the basket.\n    /// @param symbol Symbol of the basket.\n    /// @param bitFlag Asset selection bitFlag for the basket.\n    /// @param strategy Address of the strategy contract for the basket.\n    /// @return basket Address of the newly created basket token.\n    function createNewBasket(\n        BasketManagerStorage storage self,\n        string calldata basketName,\n        string calldata symbol,\n        address baseAsset,\n        uint256 bitFlag,\n        address strategy\n    )\n        external\n        returns (address basket)\n    {\n        // Checks\n        if (baseAsset == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        uint256 basketTokensLength = self.basketTokens.length;\n        if (basketTokensLength >= _MAX_NUM_OF_BASKET_TOKENS) {\n            revert BasketTokenMaxExceeded();\n        }\n        bytes32 basketId = keccak256(abi.encodePacked(bitFlag, strategy));\n        if (self.basketIdToAddress[basketId] != address(0)) {\n            revert BasketTokenAlreadyExists();\n        }\n        // Checks with external view calls\n        if (!self.strategyRegistry.supportsBitFlag(bitFlag, strategy)) {\n            revert StrategyRegistryDoesNotSupportStrategy();\n        }\n        AssetRegistry assetRegistry = AssetRegistry(self.assetRegistry);\n        {\n            if (assetRegistry.hasPausedAssets(bitFlag)) {\n                revert AssetNotEnabled();\n            }\n            address[] memory assets = assetRegistry.getAssets(bitFlag);\n            if (assets.length == 0) {\n                revert AssetListEmpty();\n            }\n            basket = Clones.clone(self.basketTokenImplementation);\n            _setBaseAssetIndex(self, basket, assets, baseAsset);\n            self.basketTokens.push(basket);\n            self.basketAssets[basket] = assets;\n            self.basketIdToAddress[basketId] = basket;\n            // The set default management fee will given to the zero address\n            self.managementFees[basket] = self.managementFees[address(0)];\n            uint256 assetsLength = assets.length;\n            for (uint256 j = 0; j < assetsLength;) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketAssetToIndexPlusOne[basket][assets[j]] = j + 1;\n                unchecked {\n                    // Overflow not possible: j is bounded by assets.length\n                    ++j;\n                }\n            }\n        }\n        unchecked {\n            // Overflow not possible: basketTokensLength is less than the constant _MAX_NUM_OF_BASKET_TOKENS\n            self.basketTokenToIndexPlusOne[basket] = basketTokensLength + 1;\n        }\n        // Interactions\n        BasketToken(basket).initialize(IERC20(baseAsset), basketName, symbol, bitFlag, strategy, address(assetRegistry));\n    }\n\n    /// @notice Proposes a rebalance for the given baskets. The rebalance is proposed if the difference between the\n    /// target balance and the current balance of any asset in the basket is more than 500 USD.\n    /// @param baskets Array of basket addresses to rebalance.\n    // solhint-disable code-complexity\n    // slither-disable-next-line cyclomatic-complexity\n    function proposeRebalance(BasketManagerStorage storage self, address[] calldata baskets) external {\n        // Checks\n        // Revert if a rebalance is already in progress\n        if (self.rebalanceStatus.status != Status.NOT_STARTED) {\n            revert MustWaitForRebalanceToComplete();\n        }\n        // slither-disable-next-line timestamp\n        if (block.timestamp - self.rebalanceStatus.timestamp < _REBALANCE_COOLDOWN_SEC) {\n            revert TooEarlyToProposeRebalance();\n        }\n\n        // Effects\n        self.rebalanceStatus.basketMask = _createRebalanceBitMask(self, baskets);\n        self.rebalanceStatus.timestamp = uint40(block.timestamp);\n        self.rebalanceStatus.status = Status.REBALANCE_PROPOSED;\n\n        address assetRegistry = self.assetRegistry;\n        uint64[][] memory basketTargetWeights = new uint64[][](baskets.length);\n\n        // Interactions\n        bool shouldRebalance = false;\n        for (uint256 i = 0; i < baskets.length;) {\n            // slither-disable-start calls-loop\n            address basket = baskets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            basketTargetWeights[i] = BasketToken(basket).getTargetWeights();\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            if (assets.length == 0) {\n                revert BasketTokenNotFound();\n            }\n            if (AssetRegistry(assetRegistry).hasPausedAssets(BasketToken(basket).bitFlag())) {\n                revert AssetNotEnabled();\n            }\n            // Calculate current basket value\n            (uint256[] memory balances, uint256 basketValue) = _calculateBasketValue(self, basket, assets);\n            // Notify Basket Token of rebalance:\n            (uint256 pendingDeposits, uint256 pendingRedeems) =\n                BasketToken(basket).prepareForRebalance(self.managementFees[basket], self.feeCollector);\n            if (pendingDeposits > 0) {\n                shouldRebalance = true;\n            }\n            uint256 totalSupply;\n            {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;\n                uint256 pendingDepositValue;\n                // Process pending deposits and fulfill them\n                (totalSupply, pendingDepositValue) = _processPendingDeposits(\n                    self, basket, basketValue, balances[baseAssetIndex], pendingDeposits, baseAssetIndex\n                );\n                balances[baseAssetIndex] += pendingDeposits;\n                basketValue += pendingDepositValue;\n            }\n            uint256 requiredWithdrawValue = 0;\n            // Pre-process pending redemptions\n            if (pendingRedeems > 0) {\n                shouldRebalance = true;\n                if (totalSupply > 0) {\n                    // totalSupply cannot be 0 when pendingRedeems is greater than 0, as redemptions\n                    // can only occur if there are issued shares (i.e., totalSupply > 0).\n                    // Division-by-zero is not possible: totalSupply is greater than 0\n                    requiredWithdrawValue = FixedPointMathLib.fullMulDiv(basketValue, pendingRedeems, totalSupply);\n                    if (requiredWithdrawValue > basketValue) {\n                        // This should never happen, but if it does, withdraw the entire basket value\n                        requiredWithdrawValue = basketValue;\n                    }\n                    unchecked {\n                        // Overflow not possible: requiredWithdrawValue is less than or equal to basketValue\n                        basketValue -= requiredWithdrawValue;\n                    }\n                }\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.pendingRedeems[basket] = pendingRedeems;\n            }\n            uint256[] memory targetBalances = _calculateTargetBalances(\n                self, basket, basketValue, requiredWithdrawValue, assets, basketTargetWeights[i]\n            );\n            if (_isRebalanceRequired(assets, balances, targetBalances)) {\n                shouldRebalance = true;\n            }\n            // slither-disable-end calls-loop\n            unchecked {\n                // Overflow not possible: i is less than baskets.length\n                ++i;\n            }\n        }\n        if (!shouldRebalance) {\n            revert RebalanceNotRequired();\n        }\n        // Effects after Interactions. Target weights require external view calls to respective strategies.\n        bytes32 basketHash = keccak256(abi.encode(baskets, basketTargetWeights));\n        self.rebalanceStatus.basketHash = basketHash;\n        // slither-disable-next-line reentrancy-events\n        emit RebalanceProposed(self.rebalanceStatus.epoch, baskets, basketTargetWeights, basketHash);\n    }\n    // solhint-enable code-complexity\n\n    // @notice Proposes a set of internal trades and external trades to rebalance the given baskets.\n    /// If the proposed token swap results are not close to the target balances, this function will revert.\n    /// @dev This function can only be called after proposeRebalance.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param internalTrades Array of internal trades to execute.\n    /// @param externalTrades Array of external trades to execute.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketTargetWeights Array of target weights for each basket.\n    // slither-disable-next-line cyclomatic-complexity\n    function proposeTokenSwap(\n        BasketManagerStorage storage self,\n        InternalTrade[] calldata internalTrades,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata baskets,\n        uint64[][] calldata basketTargetWeights\n    )\n        external\n    {\n        // Checks\n        RebalanceStatus memory status = self.rebalanceStatus;\n        if (status.status != Status.REBALANCE_PROPOSED) {\n            revert MustWaitForRebalanceToComplete();\n        }\n        _validateBasketHash(self, baskets, basketTargetWeights);\n\n        // Effects\n        status.timestamp = uint40(block.timestamp);\n        status.status = Status.TOKEN_SWAP_PROPOSED;\n        self.rebalanceStatus = status;\n        self.externalTradesHash = keccak256(abi.encode(externalTrades));\n\n        uint256 numBaskets = baskets.length;\n        uint256[] memory totalValues = new uint256[](numBaskets);\n        // 2d array of asset balances for each basket\n        uint256[][] memory basketBalances = new uint256[][](numBaskets);\n        _initializeBasketData(self, baskets, basketBalances, totalValues);\n        // NOTE: for rebalance retries the internal trades must be updated as well\n        _processInternalTrades(self, internalTrades, baskets, basketBalances);\n        _validateExternalTrades(self, externalTrades, baskets, totalValues, basketBalances);\n        if (!_isTargetWeightMet(self, baskets, basketBalances, totalValues, basketTargetWeights)) {\n            revert TargetWeightsNotMet();\n        }\n    }\n\n    /// @notice Completes the rebalance for the given baskets. The rebalance can be completed if it has been more than\n    /// 15 minutes since the last action.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades matching those proposed for rebalance.\n    /// @param baskets Array of basket addresses proposed for rebalance.\n    /// @param basketTargetWeights Array of target weights for each basket.\n    // slither-disable-next-line cyclomatic-complexity\n    function completeRebalance(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata baskets,\n        uint64[][] calldata basketTargetWeights\n    )\n        external\n    {\n        // Revert if there is no rebalance in progress\n        // slither-disable-next-line incorrect-equality\n        if (self.rebalanceStatus.status == Status.NOT_STARTED) {\n            revert NoRebalanceInProgress();\n        }\n        _validateBasketHash(self, baskets, basketTargetWeights);\n        // Check if the rebalance was proposed more than 15 minutes ago\n        // slither-disable-next-line timestamp\n        if (block.timestamp - self.rebalanceStatus.timestamp < 15 minutes) {\n            revert TooEarlyToCompleteRebalance();\n        }\n        // if external trades are proposed and executed, finalize them and claim results from the trades\n        if (self.rebalanceStatus.status == Status.TOKEN_SWAP_EXECUTED) {\n            if (keccak256(abi.encode(externalTrades)) != self.externalTradesHash) {\n                revert ExternalTradeMismatch();\n            }\n            _processExternalTrades(self, externalTrades);\n        }\n\n        uint256 len = baskets.length;\n        uint256[] memory totalValue_ = new uint256[](len);\n        // 2d array of asset amounts for each basket after all trades are settled\n        uint256[][] memory afterTradeAmounts_ = new uint256[][](len);\n        _initializeBasketData(self, baskets, afterTradeAmounts_, totalValue_);\n        // Confirm that target weights have been met, if max retries is reached continue regardless\n        if (self.retryCount < _MAX_RETRIES) {\n            if (!_isTargetWeightMet(self, baskets, afterTradeAmounts_, totalValue_, basketTargetWeights)) {\n                // If target weights are not met and we have not reached max retries, revert to beginning of rebalance\n                // to allow for additional token swaps to be proposed and increment retryCount.\n                self.retryCount += 1;\n                self.rebalanceStatus.timestamp = uint40(block.timestamp);\n                self.externalTradesHash = bytes32(0);\n                self.rebalanceStatus.status = Status.REBALANCE_PROPOSED;\n                return;\n            }\n        }\n        _finalizeRebalance(self, baskets);\n    }\n\n    /// FALLBACK REDEEM LOGIC ///\n\n    /// @notice Fallback redeem function to redeem shares when the rebalance is not in progress. Redeems the shares for\n    /// each underlying asset in the basket pro-rata to the amount of shares redeemed.\n    /// @param totalSupplyBefore Total supply of the basket token before the shares were burned.\n    /// @param burnedShares Amount of shares burned.\n    /// @param to Address to send the redeemed assets to.\n    function proRataRedeem(\n        BasketManagerStorage storage self,\n        uint256 totalSupplyBefore,\n        uint256 burnedShares,\n        address to\n    )\n        external\n    {\n        // Checks\n        if (totalSupplyBefore == 0) {\n            revert ZeroTotalSupply();\n        }\n        if (burnedShares == 0) {\n            revert ZeroBurnedShares();\n        }\n        if (burnedShares > totalSupplyBefore) {\n            revert CannotBurnMoreSharesThanTotalSupply();\n        }\n        if (to == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        // Revert if the basket is currently rebalancing\n        if ((self.rebalanceStatus.basketMask & (1 << self.basketTokenToIndexPlusOne[msg.sender] - 1)) != 0) {\n            revert MustWaitForRebalanceToComplete();\n        }\n\n        address basket = msg.sender;\n        address[] storage assets = self.basketAssets[basket];\n        uint256 assetsLength = assets.length;\n\n        // Interactions\n        for (uint256 i = 0; i < assetsLength;) {\n            address asset = assets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            uint256 balance = self.basketBalanceOf[basket][asset];\n            // Rounding direction: down\n            // Division-by-zero is not possible: totalSupplyBefore is greater than 0\n            uint256 amountToWithdraw = FixedPointMathLib.fullMulDiv(burnedShares, balance, totalSupplyBefore);\n            if (amountToWithdraw > 0) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[basket][asset] = balance - amountToWithdraw;\n                // Asset is an allowlisted ERC20 with no reentrancy problem in transfer\n                // slither-disable-next-line reentrancy-no-eth\n                IERC20(asset).safeTransfer(to, amountToWithdraw);\n            }\n            unchecked {\n                // Overflow not possible: i is less than assetsLength\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the index of the asset in a given basket\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basketToken Basket token address.\n    /// @param asset Asset address.\n    /// @return index Index of the asset in the basket.\n    function basketTokenToRebalanceAssetToIndex(\n        BasketManagerStorage storage self,\n        address basketToken,\n        address asset\n    )\n        public\n        view\n        returns (uint256 index)\n    {\n        index = self.basketAssetToIndexPlusOne[basketToken][asset];\n        if (index == 0) {\n            revert AssetNotFoundInBasket();\n        }\n        unchecked {\n            // Overflow not possible: index is not 0\n            return index - 1;\n        }\n    }\n\n    /// @notice Returns the index of the basket token.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basketToken Basket token address.\n    /// @return index Index of the basket token.\n    function basketTokenToIndex(\n        BasketManagerStorage storage self,\n        address basketToken\n    )\n        public\n        view\n        returns (uint256 index)\n    {\n        index = self.basketTokenToIndexPlusOne[basketToken];\n        if (index == 0) {\n            revert BasketTokenNotFound();\n        }\n        unchecked {\n            // Overflow not possible: index is not 0\n            return index - 1;\n        }\n    }\n\n    /// INTERNAL FUNCTIONS ///\n\n    /// @notice Returns the index of the element in the array.\n    /// @dev Reverts if the element does not exist in the array.\n    /// @param array Array to find the element in.\n    /// @param element Element to find in the array.\n    /// @return index Index of the element in the array.\n    function _indexOf(address[] memory array, address element) internal pure returns (uint256 index) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length;) {\n            if (array[i] == element) {\n                return i;\n            }\n            unchecked {\n                // Overflow not possible: index is not 0\n                ++i;\n            }\n        }\n        revert ElementIndexNotFound();\n    }\n\n    /// PRIVATE FUNCTIONS ///\n\n    /// @notice Internal function to finalize the state changes for the current rebalance. Resets rebalance status and\n    /// attempts to process pending redeems. If all pending redeems cannot be fulfilled notifies basket token of a\n    /// failed rebalance.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    function _finalizeRebalance(BasketManagerStorage storage self, address[] calldata baskets) private {\n        // Advance the rebalance epoch and reset the status\n        uint40 epoch = self.rebalanceStatus.epoch;\n        self.rebalanceStatus.basketHash = bytes32(0);\n        self.rebalanceStatus.basketMask = 0;\n        self.rebalanceStatus.epoch += 1;\n        self.rebalanceStatus.timestamp = uint40(block.timestamp);\n        self.rebalanceStatus.status = Status.NOT_STARTED;\n        self.externalTradesHash = bytes32(0);\n        self.retryCount = 0;\n        // slither-disable-next-line reentrancy-events\n        emit RebalanceCompleted(epoch);\n\n        // Process the redeems for the given baskets\n        // slither-disable-start calls-loop\n        uint256 len = baskets.length;\n        for (uint256 i = 0; i < len;) {\n            // NOTE: Can be optimized by using calldata for the `baskets` parameter or by moving the\n            // redemption processing logic to a ZK coprocessor like Axiom for improved efficiency and scalability.\n            address basket = baskets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 assetsLength = assets.length;\n            uint256[] memory balances = new uint256[](assetsLength);\n            uint256 basketValue = 0;\n\n            // Calculate current basket value\n            for (uint256 j = 0; j < assetsLength;) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                balances[j] = self.basketBalanceOf[basket][assets[j]];\n                // Rounding direction: down\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                basketValue += self.eulerRouter.getQuote(balances[j], assets[j], _USD_ISO_4217_CODE);\n                unchecked {\n                    // Overflow not possible: j is less than assetsLength\n                    ++j;\n                }\n            }\n\n            // If there are pending redeems, process them\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            uint256 pendingRedeems = self.pendingRedeems[basket];\n            if (pendingRedeems > 0) {\n                // slither-disable-next-line costly-loop\n                delete self.pendingRedeems[basket]; // nosemgrep\n                // Assume the first asset listed in the basket is the base asset\n                // Rounding direction: down\n                // Division-by-zero is not possible: priceOfAssets[baseAssetIndex] is greater than 0, totalSupply is\n                // greater than 0\n                // when pendingRedeems is greater than 0\n                uint256 rawAmount =\n                    FixedPointMathLib.fullMulDiv(basketValue, pendingRedeems, BasketToken(basket).totalSupply());\n                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                uint256 withdrawAmount =\n                    self.eulerRouter.getQuote(rawAmount, _USD_ISO_4217_CODE, assets[baseAssetIndex]);\n                if (withdrawAmount <= balances[baseAssetIndex]) {\n                    unchecked {\n                        // Overflow not possible: withdrawAmount is less than or equal to balances[baseAssetIndex]\n                        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                        self.basketBalanceOf[basket][assets[baseAssetIndex]] = balances[baseAssetIndex] - withdrawAmount;\n                    }\n                    // slither-disable-next-line reentrancy-no-eth\n                    IERC20(assets[baseAssetIndex]).forceApprove(basket, withdrawAmount);\n                    // ERC20.transferFrom is called in BasketToken.fulfillRedeem\n                    // slither-disable-next-line reentrancy-no-eth\n                    BasketToken(basket).fulfillRedeem(withdrawAmount);\n                } else {\n                    BasketToken(basket).fallbackRedeemTrigger();\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is less than baskets.length\n                ++i;\n            }\n        }\n        // slither-disable-end calls-loop\n    }\n\n    /// @notice Internal function to complete proposed token swaps.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades to be completed.\n    /// @return claimedAmounts amounts claimed from the completed token swaps\n    function _completeTokenSwap(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades\n    )\n        private\n        returns (uint256[2][] memory claimedAmounts)\n    {\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) =\n            self.tokenSwapAdapter.delegatecall(abi.encodeCall(TokenSwapAdapter.completeTokenSwap, (externalTrades)));\n        // solhint-enable avoid-low-level-calls\n        if (!success) {\n            // assume this low-level call never fails\n            revert CompleteTokenSwapFailed();\n        }\n        claimedAmounts = abi.decode(data, (uint256[2][]));\n    }\n\n    /// @notice Internal function to update internal accounting with result of completed token swaps.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades to be completed.\n    function _processExternalTrades(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades\n    )\n        private\n    {\n        uint256 externalTradesLength = externalTrades.length;\n        uint256[2][] memory claimedAmounts = _completeTokenSwap(self, externalTrades);\n        // Update basketBalanceOf with amounts gained from swaps\n        for (uint256 i = 0; i < externalTradesLength;) {\n            ExternalTrade memory trade = externalTrades[i];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 tradeOwnershipLength = trade.basketTradeOwnership.length;\n            for (uint256 j; j < tradeOwnershipLength;) {\n                BasketTradeOwnership memory ownership = trade.basketTradeOwnership[j];\n                address basket = ownership.basket;\n                // Account for bought tokens\n                self.basketBalanceOf[basket][trade.buyToken] +=\n                    FixedPointMathLib.fullMulDiv(claimedAmounts[i][1], ownership.tradeOwnership, _WEIGHT_PRECISION);\n                // Account for sold tokens\n                self.basketBalanceOf[basket][trade.sellToken] = self.basketBalanceOf[basket][trade.sellToken]\n                    + FixedPointMathLib.fullMulDiv(claimedAmounts[i][0], ownership.tradeOwnership, _WEIGHT_PRECISION)\n                    - FixedPointMathLib.fullMulDiv(trade.sellAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);\n                unchecked {\n                    // Overflow not possible: i is less than tradeOwnerShipLength.length\n                    ++j;\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is less than externalTradesLength.length\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function to initialize basket data.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketBalances An empty array used for asset balances for each basket being rebalanced. Updated with\n    /// current balances at the end of the function.\n    /// @param totalValue_ An initialized array of total basket values for each basket being rebalanced.\n    function _initializeBasketData(\n        BasketManagerStorage storage self,\n        address[] calldata baskets,\n        uint256[][] memory basketBalances,\n        uint256[] memory totalValue_\n    )\n        private\n        view\n    {\n        uint256 numBaskets = baskets.length;\n        for (uint256 i = 0; i < numBaskets;) {\n            address basket = baskets[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 assetsLength = assets.length;\n            basketBalances[i] = new uint256[](assetsLength);\n            for (uint256 j = 0; j < assetsLength;) {\n                address asset = assets[j];\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                uint256 currentAssetAmount = self.basketBalanceOf[basket][asset];\n                basketBalances[i][j] = currentAssetAmount;\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                totalValue_[i] += self.eulerRouter.getQuote(currentAssetAmount, asset, _USD_ISO_4217_CODE);\n                unchecked {\n                    // Overflow not possible: j is less than assetsLength\n                    ++j;\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is less than numBaskets\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function to settle internal trades.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param internalTrades Array of internal trades to execute.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketBalances An initialized array of asset amounts for each basket being rebalanced. Updated with\n    /// settled internal trades at the end of the function.\n    /// @dev If the result of an internal trade is not within the provided minAmount or maxAmount, this function will\n    /// revert.\n    function _processInternalTrades(\n        BasketManagerStorage storage self,\n        InternalTrade[] calldata internalTrades,\n        address[] calldata baskets,\n        uint256[][] memory basketBalances\n    )\n        private\n    {\n        uint256 swapFee = self.swapFee; // Fetch swapFee once for gas optimization\n        uint256 internalTradesLength = internalTrades.length;\n        for (uint256 i = 0; i < internalTradesLength;) {\n            InternalTrade memory trade = internalTrades[i];\n            InternalTradeInfo memory info = InternalTradeInfo({\n                fromBasketIndex: _indexOf(baskets, trade.fromBasket),\n                toBasketIndex: _indexOf(baskets, trade.toBasket),\n                sellTokenAssetIndex: basketTokenToRebalanceAssetToIndex(self, trade.fromBasket, trade.sellToken),\n                buyTokenAssetIndex: basketTokenToRebalanceAssetToIndex(self, trade.fromBasket, trade.buyToken),\n                toBasketBuyTokenIndex: basketTokenToRebalanceAssetToIndex(self, trade.toBasket, trade.buyToken),\n                toBasketSellTokenIndex: basketTokenToRebalanceAssetToIndex(self, trade.toBasket, trade.sellToken),\n                netBuyAmount: 0,\n                netSellAmount: 0,\n                feeOnBuy: 0,\n                feeOnSell: 0\n            });\n\n            // Calculate fee on sellAmount\n            if (swapFee > 0) {\n                info.feeOnSell = FixedPointMathLib.fullMulDiv(trade.sellAmount, swapFee, 20_000);\n                self.collectedSwapFees[trade.sellToken] += info.feeOnSell;\n                emit SwapFeeCharged(trade.sellToken, info.feeOnSell);\n            }\n            info.netSellAmount = trade.sellAmount - info.feeOnSell;\n\n            // Calculate initial buyAmount based on netSellAmount\n            uint256 initialBuyAmount = self.eulerRouter.getQuote(\n                self.eulerRouter.getQuote(info.netSellAmount, trade.sellToken, _USD_ISO_4217_CODE),\n                _USD_ISO_4217_CODE,\n                trade.buyToken\n            );\n\n            // Calculate fee on buyAmount\n            if (swapFee > 0) {\n                info.feeOnBuy = FixedPointMathLib.fullMulDiv(initialBuyAmount, swapFee, 20_000);\n                self.collectedSwapFees[trade.buyToken] += info.feeOnBuy;\n                emit SwapFeeCharged(trade.buyToken, info.feeOnBuy);\n            }\n            info.netBuyAmount = initialBuyAmount - info.feeOnBuy;\n\n            if (info.netBuyAmount < trade.minAmount || trade.maxAmount < info.netBuyAmount) {\n                revert InternalTradeMinMaxAmountNotReached();\n            }\n            if (trade.sellAmount > basketBalances[info.fromBasketIndex][info.sellTokenAssetIndex]) {\n                revert IncorrectTradeTokenAmount();\n            }\n            if (info.netBuyAmount > basketBalances[info.toBasketIndex][info.toBasketBuyTokenIndex]) {\n                revert IncorrectTradeTokenAmount();\n            }\n\n            // Settle the internal trades and track the balance changes.\n            // This unchecked block is safe because:\n            // - The subtraction operations can't underflow since the if checks above ensure the values being\n            //   subtracted are less than or equal to the corresponding values in basketBalances.\n            // - The addition operations can't overflow since the total supply of each token is limited and the\n            //   amounts being added are always less than the total supply.\n            unchecked {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.fromBasket][trade.sellToken] =\n                    basketBalances[info.fromBasketIndex][info.sellTokenAssetIndex] -= trade.sellAmount; // nosemgrep\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.fromBasket][trade.buyToken] =\n                    basketBalances[info.fromBasketIndex][info.buyTokenAssetIndex] += info.netBuyAmount; // nosemgrep\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.toBasket][trade.buyToken] =\n                    basketBalances[info.toBasketIndex][info.toBasketBuyTokenIndex] -= initialBuyAmount; // nosemgrep\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                self.basketBalanceOf[trade.toBasket][trade.sellToken] =\n                    basketBalances[info.toBasketIndex][info.toBasketSellTokenIndex] += info.netSellAmount; // nosemgrep\n                ++i;\n            }\n            emit InternalTradeSettled(trade, info.netBuyAmount);\n        }\n    }\n\n    /// @notice Internal function to validate the results of external trades.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param externalTrades Array of external trades to be validated.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param totalValue_ Array of total basket values in USD.\n    /// @param afterTradeAmounts_ An initialized array of asset amounts for each basket being rebalanced.\n    /// @dev If the result of an external trade is not within the _MAX_SLIPPAGE threshold of the minAmount, this\n    /// function will revert.\n    function _validateExternalTrades(\n        BasketManagerStorage storage self,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata baskets,\n        uint256[] memory totalValue_,\n        uint256[][] memory afterTradeAmounts_\n    )\n        private\n        view\n    {\n        for (uint256 i = 0; i < externalTrades.length;) {\n            ExternalTrade memory trade = externalTrades[i];\n            // slither-disable-start uninitialized-local\n            ExternalTradeInfo memory info;\n            BasketOwnershipInfo memory ownershipInfo;\n            // slither-disable-end uninitialized-local\n\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            for (uint256 j = 0; j < trade.basketTradeOwnership.length;) {\n                BasketTradeOwnership memory ownership = trade.basketTradeOwnership[j];\n                ownershipInfo.basketIndex = _indexOf(baskets, ownership.basket);\n                ownershipInfo.buyTokenAssetIndex =\n                    basketTokenToRebalanceAssetToIndex(self, ownership.basket, trade.buyToken);\n                ownershipInfo.sellTokenAssetIndex =\n                    basketTokenToRebalanceAssetToIndex(self, ownership.basket, trade.sellToken);\n                uint256 ownershipSellAmount =\n                    FixedPointMathLib.fullMulDiv(trade.sellAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);\n                uint256 ownershipBuyAmount =\n                    FixedPointMathLib.fullMulDiv(trade.minAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);\n                // Record changes in basket asset holdings due to the external trade\n                if (\n                    ownershipSellAmount\n                        > afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.sellTokenAssetIndex]\n                ) {\n                    revert IncorrectTradeTokenAmount();\n                }\n                // solhint-disable-next-line max-line-length\n                afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.sellTokenAssetIndex] = afterTradeAmounts_[ownershipInfo\n                    .basketIndex][ownershipInfo.sellTokenAssetIndex] - ownershipSellAmount;\n                afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.buyTokenAssetIndex] =\n                    afterTradeAmounts_[ownershipInfo.basketIndex][ownershipInfo.buyTokenAssetIndex] + ownershipBuyAmount;\n                // Update total basket value\n                totalValue_[ownershipInfo.basketIndex] = totalValue_[ownershipInfo.basketIndex]\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                - self.eulerRouter.getQuote(ownershipSellAmount, trade.sellToken, _USD_ISO_4217_CODE)\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                + self.eulerRouter.getQuote(ownershipBuyAmount, trade.buyToken, _USD_ISO_4217_CODE);\n                unchecked {\n                    // Overflow not possible: j is bounded by trade.basketTradeOwnership.length\n                    ++j;\n                }\n            }\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            info.sellValue = self.eulerRouter.getQuote(trade.sellAmount, trade.sellToken, _USD_ISO_4217_CODE);\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            info.internalMinAmount = self.eulerRouter.getQuote(info.sellValue, _USD_ISO_4217_CODE, trade.buyToken);\n            info.diff = MathUtils.diff(info.internalMinAmount, trade.minAmount);\n\n            // Check if the given minAmount is within the _MAX_SLIPPAGE threshold of internalMinAmount\n            if (info.internalMinAmount < trade.minAmount) {\n                if (info.diff * _WEIGHT_PRECISION / info.internalMinAmount > _MAX_SLIPPAGE) {\n                    revert ExternalTradeSlippage();\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is bounded by baskets.length\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Validate the basket hash based on the given baskets and target weights.\n    function _validateBasketHash(\n        BasketManagerStorage storage self,\n        address[] calldata baskets,\n        uint64[][] calldata basketsTargetWeights\n    )\n        private\n        view\n    {\n        // Validate the calldata hashes\n        bytes32 basketHash = keccak256(abi.encode(baskets, basketsTargetWeights));\n        if (self.rebalanceStatus.basketHash != basketHash) {\n            revert BasketsMismatch();\n        }\n    }\n\n    /// @notice Checks if weight deviations after trades are within the acceptable _MAX_WEIGHT_DEVIATION threshold.\n    /// Returns true if all deviations are within bounds for each asset in every basket.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @param basketBalances 2D array of asset balances for each basket. Rows are baskets, columns are assets.\n    /// @param totalValues Array of total basket values in USD.\n    /// @param basketsTargetWeights Array of target weights for each basket.\n    function _isTargetWeightMet(\n        BasketManagerStorage storage self,\n        address[] calldata baskets,\n        uint256[][] memory basketBalances,\n        uint256[] memory totalValues,\n        uint64[][] calldata basketsTargetWeights\n    )\n        private\n        view\n        returns (bool)\n    {\n        // Check if total weight change due to all trades is within the _MAX_WEIGHT_DEVIATION threshold\n        uint256 len = baskets.length;\n        for (uint256 i = 0; i < len;) {\n            address basket = baskets[i];\n            // slither-disable-next-line calls-loop\n            uint64[] memory proposedTargetWeights = basketsTargetWeights[i];\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            address[] memory assets = self.basketAssets[basket];\n            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop\n            uint256 proposedTargetWeightsLength = proposedTargetWeights.length;\n            for (uint256 j = 0; j < proposedTargetWeightsLength;) {\n                address asset = assets[j];\n                uint256 assetValueInUSD =\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                 self.eulerRouter.getQuote(basketBalances[i][j], asset, _USD_ISO_4217_CODE);\n                // Rounding direction: down\n                uint256 afterTradeWeight =\n                    FixedPointMathLib.fullMulDiv(assetValueInUSD, _WEIGHT_PRECISION, totalValues[i]);\n                if (MathUtils.diff(proposedTargetWeights[j], afterTradeWeight) > _MAX_WEIGHT_DEVIATION) {\n                    return false;\n                }\n                unchecked {\n                    // Overflow not possible: j is bounded by proposedTargetWeightsLength\n                    ++j;\n                }\n            }\n            unchecked {\n                // Overflow not possible: i is bounded by len\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Internal function to process pending deposits and fulfill them.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param basketValue Current value of the basket in USD.\n    /// @param baseAssetBalance Current balance of the base asset in the basket.\n    /// @param pendingDeposit Current assets pending deposit in the given basket.\n    /// @return totalSupply Total supply of the basket token after processing pending deposits.\n    /// @return pendingDepositValue Value of the pending deposits in USD.\n    // slither-disable-next-line calls-loop\n    function _processPendingDeposits(\n        BasketManagerStorage storage self,\n        address basket,\n        uint256 basketValue,\n        uint256 baseAssetBalance,\n        uint256 pendingDeposit,\n        uint256 baseAssetIndex\n    )\n        private\n        returns (uint256 totalSupply, uint256 pendingDepositValue)\n    {\n        totalSupply = BasketToken(basket).totalSupply();\n\n        if (pendingDeposit > 0) {\n            // Assume the first asset listed in the basket is the base asset\n            // Round direction: down\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            pendingDepositValue =\n                self.eulerRouter.getQuote(pendingDeposit, self.basketAssets[basket][baseAssetIndex], _USD_ISO_4217_CODE);\n            // Rounding direction: down\n            // Division-by-zero is not possible: basketValue is greater than 0\n            uint256 requiredDepositShares = basketValue > 0\n                ? FixedPointMathLib.fullMulDiv(pendingDepositValue, totalSupply, basketValue)\n                : pendingDeposit;\n            totalSupply += requiredDepositShares;\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            self.basketBalanceOf[basket][self.basketAssets[basket][baseAssetIndex]] = baseAssetBalance + pendingDeposit;\n            // slither-disable-next-line reentrancy-no-eth,reentrancy-benign\n            BasketToken(basket).fulfillDeposit(requiredDepositShares);\n        }\n    }\n\n    /// @notice Internal function to calculate the target balances for each asset in a given basket.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param basketValue Current value of the basket in USD.\n    /// @param requiredWithdrawValue Value of the assets to be withdrawn from the basket.\n    /// @param assets Array of asset addresses in the basket.\n    /// @return targetBalances Array of target balances for each asset in the basket.\n    // slither-disable-next-line calls-loop,naming-convention\n    function _calculateTargetBalances(\n        BasketManagerStorage storage self,\n        address basket,\n        uint256 basketValue,\n        uint256 requiredWithdrawValue,\n        address[] memory assets,\n        uint64[] memory proposedTargetWeights\n    )\n        private\n        view\n        returns (uint256[] memory targetBalances)\n    {\n        uint256 assetsLength = assets.length;\n        targetBalances = new uint256[](assetsLength);\n        // Rounding direction: down\n        // Division-by-zero is not possible: priceOfAssets[j] is greater than 0\n        for (uint256 j = 0; j < assetsLength;) {\n            if (proposedTargetWeights[j] > 0) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                targetBalances[j] = self.eulerRouter.getQuote(\n                    FixedPointMathLib.fullMulDiv(proposedTargetWeights[j], basketValue, _WEIGHT_PRECISION),\n                    _USD_ISO_4217_CODE,\n                    assets[j]\n                );\n            }\n            unchecked {\n                // Overflow not possible: j is less than assetsLength\n                ++j;\n            }\n        }\n        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n        uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;\n        if (requiredWithdrawValue > 0) {\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            targetBalances[baseAssetIndex] +=\n                self.eulerRouter.getQuote(requiredWithdrawValue, _USD_ISO_4217_CODE, assets[baseAssetIndex]);\n        }\n    }\n\n    /// @notice Internal function to calculate the current value of all assets in a given basket.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param assets Array of asset addresses in the basket.\n    /// @return balances Array of balances of each asset in the basket.\n    /// @return basketValue Current value of the basket in USD.\n    // slither-disable-next-line calls-loop\n    function _calculateBasketValue(\n        BasketManagerStorage storage self,\n        address basket,\n        address[] memory assets\n    )\n        private\n        view\n        returns (uint256[] memory balances, uint256 basketValue)\n    {\n        uint256 assetsLength = assets.length;\n        balances = new uint256[](assetsLength);\n        for (uint256 j = 0; j < assetsLength;) {\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            balances[j] = self.basketBalanceOf[basket][assets[j]];\n            // Rounding direction: down\n            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n            if (balances[j] > 0) {\n                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop\n                basketValue += self.eulerRouter.getQuote(balances[j], assets[j], _USD_ISO_4217_CODE);\n            }\n            unchecked {\n                // Overflow not possible: j is less than assetsLength\n                ++j;\n            }\n        }\n    }\n\n    /// @notice Internal function to check if a rebalance is required for the given basket.\n    /// @dev A rebalance is required if the difference between the current asset balances and the target balances is\n    /// greater than 0. We assume the permissioned caller has already validated the condition to call this function\n    /// optimally.\n    /// @param assets Array of asset addresses in the basket.\n    /// @param balances Array of balances of each asset in the basket.\n    /// @param targetBalances Array of target balances for each asset in the basket.\n    /// @return shouldRebalance Boolean indicating if a rebalance is required.\n    function _isRebalanceRequired(\n        address[] memory assets,\n        uint256[] memory balances,\n        uint256[] memory targetBalances\n    )\n        private\n        view\n        returns (bool shouldRebalance)\n    {\n        uint256 assetsLength = assets.length;\n        for (uint256 j = 0; j < assetsLength;) {\n            // slither-disable-start calls-loop\n            if (\n                MathUtils.diff(balances[j], targetBalances[j]) > 0 // nosemgrep\n            ) {\n                shouldRebalance = true;\n                break;\n            }\n            // slither-disable-end calls-loop\n            unchecked {\n                // Overflow not possible: j is less than assetsLength\n                ++j;\n            }\n        }\n    }\n\n    /// @notice Internal function to store the index of the base asset for a given basket. Reverts if the base asset is\n    /// not present in the basket's assets.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param basket Basket token address.\n    /// @param assets Array of asset addresses in the basket.\n    /// @param baseAsset Base asset address.\n    /// @dev If the base asset is not present in the basket, this function will revert.\n    function _setBaseAssetIndex(\n        BasketManagerStorage storage self,\n        address basket,\n        address[] memory assets,\n        address baseAsset\n    )\n        private\n    {\n        uint256 len = assets.length;\n        for (uint256 i = 0; i < len;) {\n            if (assets[i] == baseAsset) {\n                self.basketTokenToBaseAssetIndexPlusOne[basket] = i + 1;\n                return;\n            }\n            unchecked {\n                // Overflow not possible: i is less than len\n                ++i;\n            }\n        }\n        revert BaseAssetMismatch();\n    }\n\n    /// @notice Internal function to create a bitmask for baskets being rebalanced.\n    /// @param self BasketManagerStorage struct containing strategy data.\n    /// @param baskets Array of basket addresses currently being rebalanced.\n    /// @return basketMask Bitmask for baskets being rebalanced.\n    /// @dev A bitmask like 00000011 indicates that the first two baskets are being rebalanced.\n    function _createRebalanceBitMask(\n        BasketManagerStorage storage self,\n        address[] memory baskets\n    )\n        private\n        view\n        returns (uint256 basketMask)\n    {\n        // Create the bitmask for baskets being rebalanced\n        basketMask = 0;\n        uint256 len = baskets.length;\n        for (uint256 i = 0; i < len;) {\n            uint256 indexPlusOne = self.basketTokenToIndexPlusOne[baskets[i]];\n            if (indexPlusOne == 0) {\n                revert BasketTokenNotFound();\n            }\n            basketMask |= (1 << indexPlusOne - 1);\n            unchecked {\n                // Overflow not possible: i is less than len\n                ++i;\n            }\n        }\n    }\n}\n",
        "BasketManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { ReentrancyGuardTransient } from \"@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol\";\nimport { EulerRouter } from \"euler-price-oracle/src/EulerRouter.sol\";\n\nimport { AssetRegistry } from \"src/AssetRegistry.sol\";\nimport { BasketToken } from \"src/BasketToken.sol\";\nimport { FeeCollector } from \"src/FeeCollector.sol\";\nimport { BasketManagerUtils } from \"src/libraries/BasketManagerUtils.sol\";\nimport { Errors } from \"src/libraries/Errors.sol\";\nimport { StrategyRegistry } from \"src/strategies/StrategyRegistry.sol\";\nimport { WeightStrategy } from \"src/strategies/WeightStrategy.sol\";\nimport { TokenSwapAdapter } from \"src/swap_adapters/TokenSwapAdapter.sol\";\nimport { BasketManagerStorage, RebalanceStatus, Status } from \"src/types/BasketManagerStorage.sol\";\nimport { ExternalTrade, InternalTrade } from \"src/types/Trades.sol\";\n\n/// @title BasketManager\n/// @notice Contract responsible for managing baskets and their tokens. The accounting for assets per basket is done\n/// in the BasketManagerUtils contract.\ncontract BasketManager is ReentrancyGuardTransient, AccessControlEnumerable, Pausable {\n    /// LIBRARIES ///\n    using BasketManagerUtils for BasketManagerStorage;\n    using SafeERC20 for IERC20;\n\n    /// CONSTANTS ///\n    /// @notice Manager role. Managers can create new baskets.\n    bytes32 private constant _MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    /// @notice Pauser role.\n    bytes32 private constant _PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    /// @notice Rebalance Proposer role. Rebalance proposers can propose a new rebalance.\n    bytes32 private constant _REBALANCE_PROPOSER_ROLE = keccak256(\"REBALANCE_PROPOSER_ROLE\");\n    /// @notice TokenSwap Proposer role. Token swap proposers can propose a new token swap.\n    bytes32 private constant _TOKENSWAP_PROPOSER_ROLE = keccak256(\"TOKENSWAP_PROPOSER_ROLE\");\n    /// @notice TokenSwap Executor role. Token swap executors can execute a token swap.\n    bytes32 private constant _TOKENSWAP_EXECUTOR_ROLE = keccak256(\"TOKENSWAP_EXECUTOR_ROLE\");\n    /// @notice Basket token role. Given to the basket token contracts when they are created.\n    bytes32 private constant _BASKET_TOKEN_ROLE = keccak256(\"BASKET_TOKEN_ROLE\");\n    /// @notice Role given to a timelock contract that can set critical parameters.\n    bytes32 private constant _TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    /// @notice Maximum management fee (30%) in BPS denominated in 1e4.\n    uint16 private constant _MAX_MANAGEMENT_FEE = 3000;\n    /// @notice Maximum swap fee (5%) in BPS denominated in 1e4.\n    uint16 private constant _MAX_SWAP_FEE = 500;\n\n    /// STATE VARIABLES ///\n    /// @notice Struct containing the BasketManagerUtils contract and other necessary data.\n    BasketManagerStorage private _bmStorage;\n    /// @notice Mapping of order hashes to their validity status.\n    mapping(bytes32 => bool) public isOrderValid;\n\n    /// EVENTS ///\n    /// @notice Emitted when the swap fee is set.\n    event SwapFeeSet(uint16 oldFee, uint16 newFee);\n    /// @notice Emitted when the management fee is set.\n    event ManagementFeeSet(address indexed basket, uint16 oldFee, uint16 newFee);\n    /// @notice Emitted when the TokenSwapAdapter contract is set.\n    event TokenSwapAdapterSet(address oldAdapter, address newAdapter);\n    /// @notice Emitted when a new basket is created.\n    event BasketCreated(\n        address indexed basket, string basketName, string symbol, address baseAsset, uint256 bitFlag, address strategy\n    );\n    /// @notice Emitted when the bitFlag of a basket is updated.\n    event BasketBitFlagUpdated(\n        address indexed basket, uint256 oldBitFlag, uint256 newBitFlag, bytes32 oldId, bytes32 newId\n    );\n    /// @notice Emitted when a token swap is proposed during a rebalance.\n    event TokenSwapProposed(uint40 indexed epoch, InternalTrade[] internalTrades, ExternalTrade[] externalTrades);\n    /// @notice Emitted when a token swap is executed during a rebalance.\n    event TokenSwapExecuted(uint40 indexed epoch);\n\n    /// ERRORS ///\n    /// @notice Thrown when attempting to execute a token swap without first proposing it.\n    error TokenSwapNotProposed();\n    /// @notice Thrown when the call to `TokenSwapAdapter.executeTokenSwap` fails.\n    error ExecuteTokenSwapFailed();\n    /// @notice Thrown when the provided hash does not match the expected hash.\n    /// @dev This error is used to validate the integrity of data passed between functions.\n    error InvalidHash();\n    /// @notice Thrown when the provided external trades do not match the hash stored during the token swap proposal.\n    /// @dev This error prevents executing a token swap with different parameters than originally proposed.\n    error ExternalTradesHashMismatch();\n    /// @notice Thrown when attempting to perform an action that requires no active rebalance.\n    /// @dev Certain actions, like setting the token swap adapter, are disallowed during an active rebalance.\n    error MustWaitForRebalanceToComplete();\n    /// @notice Thrown when a caller attempts to access a function without proper authorization.\n    /// @dev This error is thrown when a caller lacks the required role to perform an action.\n    error Unauthorized();\n    /// @notice Thrown when attempting to set an invalid management fee.\n    /// @dev The management fee must not exceed `_MAX_MANAGEMENT_FEE`.\n    error InvalidManagementFee();\n    /// @notice Thrown when attempting to set an invalid swap fee.\n    /// @dev The swap fee must not exceed `_MAX_SWAP_FEE`.\n    error InvalidSwapFee();\n    /// @notice Thrown when attempting to perform an action on a non-existent basket token.\n    /// @dev This error is thrown when the provided basket token is not in the `basketTokenToIndexPlusOne` mapping.\n    error BasketTokenNotFound();\n    error BitFlagMustBeDifferent();\n    error BitFlagMustIncludeCurrent();\n    error BitFlagUnsupportedByStrategy();\n    error BasketIdAlreadyExists();\n\n    /// @notice Initializes the contract with the given parameters.\n    /// @param basketTokenImplementation Address of the basket token implementation.\n    /// @param eulerRouter_ Address of the oracle registry.\n    /// @param strategyRegistry_ Address of the strategy registry.\n    /// @param assetRegistry_ Address of the asset registry.\n    /// @param admin Address of the admin.\n    /// @param feeCollector_ Address of the fee collector.\n    constructor(\n        address basketTokenImplementation,\n        address eulerRouter_,\n        address strategyRegistry_,\n        address assetRegistry_,\n        address admin,\n        address feeCollector_\n    )\n        payable\n    {\n        // Checks\n        if (basketTokenImplementation == address(0)) revert Errors.ZeroAddress();\n        if (eulerRouter_ == address(0)) revert Errors.ZeroAddress();\n        if (strategyRegistry_ == address(0)) revert Errors.ZeroAddress();\n        if (admin == address(0)) revert Errors.ZeroAddress();\n        if (feeCollector_ == address(0)) revert Errors.ZeroAddress();\n        if (assetRegistry_ == address(0)) revert Errors.ZeroAddress();\n\n        // Effects\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        // Initialize the BasketManagerUtils struct\n        _bmStorage.strategyRegistry = StrategyRegistry(strategyRegistry_);\n        _bmStorage.eulerRouter = EulerRouter(eulerRouter_);\n        _bmStorage.assetRegistry = assetRegistry_;\n        _bmStorage.basketTokenImplementation = basketTokenImplementation;\n        _bmStorage.feeCollector = feeCollector_;\n    }\n\n    /// PUBLIC FUNCTIONS ///\n\n    /// @notice Returns the index of the basket token in the basketTokens array.\n    /// @dev Reverts if the basket token does not exist.\n    /// @param basketToken Address of the basket token.\n    /// @return index Index of the basket token.\n    function basketTokenToIndex(address basketToken) public view returns (uint256 index) {\n        index = _bmStorage.basketTokenToIndex(basketToken);\n    }\n\n    /// @notice Returns the index of the basket asset in the basketAssets array.\n    /// @dev Reverts if the basket asset does not exist.\n    /// @param basketToken Address of the basket token.\n    /// @param asset Address of the asset.\n    /// @return index Index of the basket asset.\n    function basketTokenToRebalanceAssetToIndex(\n        address basketToken,\n        address asset\n    )\n        public\n        view\n        returns (uint256 index)\n    {\n        index = _bmStorage.basketTokenToRebalanceAssetToIndex(basketToken, asset);\n    }\n\n    /// @notice Returns the number of basket tokens.\n    /// @return Number of basket tokens.\n    function numOfBasketTokens() public view returns (uint256) {\n        return _bmStorage.basketTokens.length;\n    }\n\n    /// @notice Returns all basket token addresses.\n    /// @return Array of basket token addresses.\n    function basketTokens() external view returns (address[] memory) {\n        return _bmStorage.basketTokens;\n    }\n\n    /// @notice Returns the basket token address with the given basketId.\n    /// @dev The basketId is the keccak256 hash of the bitFlag and strategy address.\n    /// @param basketId Basket ID.\n    function basketIdToAddress(bytes32 basketId) external view returns (address) {\n        return _bmStorage.basketIdToAddress[basketId];\n    }\n\n    /// @notice Returns the balance of the given asset in the given basket.\n    /// @param basketToken Address of the basket token.\n    /// @param asset Address of the asset.\n    /// @return Balance of the asset in the basket.\n    function basketBalanceOf(address basketToken, address asset) external view returns (uint256) {\n        return _bmStorage.basketBalanceOf[basketToken][asset];\n    }\n\n    /// @notice Returns the current rebalance status.\n    /// @return Rebalance status struct with the following fields:\n    ///   - basketHash: Hash of the baskets proposed for rebalance.\n    ///   - timestamp: Timestamp of the last action.\n    ///   - status: Status enum of the rebalance.\n    function rebalanceStatus() external view returns (RebalanceStatus memory) {\n        return _bmStorage.rebalanceStatus;\n    }\n\n    /// @notice Returns the hash of the external trades stored during proposeTokenSwap\n    /// @return Hash of the external trades\n    function externalTradesHash() external view returns (bytes32) {\n        return _bmStorage.externalTradesHash;\n    }\n\n    /// @notice Returns the address of the basket token implementation.\n    /// @return Address of the basket token implementation.\n    function eulerRouter() external view returns (address) {\n        return address(_bmStorage.eulerRouter);\n    }\n\n    /// @notice Returns the address of the feeCollector contract.\n    /// @return Address of the feeCollector.\n    function feeCollector() external view returns (address) {\n        return address(_bmStorage.feeCollector);\n    }\n\n    /// @notice Returns the management fee of a basket in BPS denominated in 1e4.\n    /// @param basket Address of the basket.\n    /// @return Management fee.\n    function managementFee(address basket) external view returns (uint16) {\n        return _bmStorage.managementFees[basket];\n    }\n\n    /// @notice Returns the swap fee in BPS denominated in 1e4.\n    /// @return Swap fee.\n    function swapFee() external view returns (uint16) {\n        return _bmStorage.swapFee;\n    }\n\n    /// @notice Returns the address of the strategy registry.\n    /// @return Address of the strategy registry.\n    function strategyRegistry() external view returns (address) {\n        return address(_bmStorage.strategyRegistry);\n    }\n\n    /// @notice Returns the address of the token swap adapter.\n    /// @return Address of the token swap adapter.\n    function tokenSwapAdapter() external view returns (address) {\n        return _bmStorage.tokenSwapAdapter;\n    }\n\n    /// @notice Returns the retry count for the current rebalance epoch.\n    /// @return Retry count.\n    function retryCount() external view returns (uint8) {\n        return _bmStorage.retryCount;\n    }\n\n    /// @notice Returns the addresses of all assets in the given basket.\n    /// @param basket Address of the basket.\n    /// @return Array of asset addresses.\n    function basketAssets(address basket) external view returns (address[] memory) {\n        return _bmStorage.basketAssets[basket];\n    }\n\n    /// @notice Creates a new basket token with the given parameters.\n    /// @param basketName Name of the basket.\n    /// @param symbol Symbol of the basket.\n    /// @param bitFlag Asset selection bitFlag for the basket.\n    /// @param strategy Address of the strategy contract for the basket.\n    function createNewBasket(\n        string calldata basketName,\n        string calldata symbol,\n        address baseAsset,\n        uint256 bitFlag,\n        address strategy\n    )\n        external\n        payable\n        whenNotPaused\n        onlyRole(_MANAGER_ROLE)\n        returns (address basket)\n    {\n        basket = _bmStorage.createNewBasket(basketName, symbol, baseAsset, bitFlag, strategy);\n        _grantRole(_BASKET_TOKEN_ROLE, basket);\n        emit BasketCreated(basket, basketName, symbol, baseAsset, bitFlag, strategy);\n    }\n\n    /// @notice Proposes a rebalance for the given baskets. The rebalance is proposed if the difference between the\n    /// target balance and the current balance of any asset in the basket is more than 500 USD.\n    /// @param basketsToRebalance Array of basket addresses to rebalance.\n    function proposeRebalance(address[] calldata basketsToRebalance)\n        external\n        onlyRole(_REBALANCE_PROPOSER_ROLE)\n        nonReentrant\n        whenNotPaused\n    {\n        _bmStorage.proposeRebalance(basketsToRebalance);\n    }\n\n    /// @notice Proposes a set of internal trades and external trades to rebalance the given baskets.\n    /// If the proposed token swap results are not close to the target balances, this function will revert.\n    /// @dev This function can only be called after proposeRebalance.\n    /// @param internalTrades Array of internal trades to execute.\n    /// @param externalTrades Array of external trades to execute.\n    /// @param basketsToRebalance Array of basket addresses currently being rebalanced.\n    /// @param targetWeights Array of target weights for the baskets.\n    function proposeTokenSwap(\n        InternalTrade[] calldata internalTrades,\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata basketsToRebalance,\n        uint64[][] calldata targetWeights\n    )\n        external\n        onlyRole(_TOKENSWAP_PROPOSER_ROLE)\n        nonReentrant\n        whenNotPaused\n    {\n        _bmStorage.proposeTokenSwap(internalTrades, externalTrades, basketsToRebalance, targetWeights);\n        emit TokenSwapProposed(_bmStorage.rebalanceStatus.epoch, internalTrades, externalTrades);\n    }\n\n    /// @notice Executes the token swaps proposed in proposeTokenSwap and updates the basket balances.\n    /// @param externalTrades Array of external trades to execute.\n    /// @param data Encoded data for the token swap.\n    /// @dev This function can only be called after proposeTokenSwap.\n    // slither-disable-next-line controlled-delegatecall\n    function executeTokenSwap(\n        ExternalTrade[] calldata externalTrades,\n        bytes calldata data\n    )\n        external\n        onlyRole(_TOKENSWAP_EXECUTOR_ROLE)\n        nonReentrant\n        whenNotPaused\n    {\n        if (_bmStorage.rebalanceStatus.status != Status.TOKEN_SWAP_PROPOSED) {\n            revert TokenSwapNotProposed();\n        }\n        address swapAdapter = _bmStorage.tokenSwapAdapter;\n        if (swapAdapter == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        // Check if the external trades match the hash from proposeTokenSwap\n        if (keccak256(abi.encode(externalTrades)) != _bmStorage.externalTradesHash) {\n            revert ExternalTradesHashMismatch();\n        }\n        _bmStorage.rebalanceStatus.status = Status.TOKEN_SWAP_EXECUTED;\n        _bmStorage.rebalanceStatus.timestamp = uint40(block.timestamp);\n\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success,) =\n            swapAdapter.delegatecall(abi.encodeCall(TokenSwapAdapter.executeTokenSwap, (externalTrades, data)));\n        // solhint-enable avoid-low-level-calls\n        if (!success) {\n            revert ExecuteTokenSwapFailed();\n        }\n\n        emit TokenSwapExecuted(_bmStorage.rebalanceStatus.epoch);\n    }\n\n    /// @notice Sets the address of the TokenSwapAdapter contract used to execute token swaps.\n    /// @param tokenSwapAdapter_ Address of the TokenSwapAdapter contract.\n    /// @dev Only callable by the timelock.\n    function setTokenSwapAdapter(address tokenSwapAdapter_) external onlyRole(_TIMELOCK_ROLE) {\n        if (tokenSwapAdapter_ == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        if (_bmStorage.rebalanceStatus.status != Status.NOT_STARTED) {\n            revert MustWaitForRebalanceToComplete();\n        }\n        emit TokenSwapAdapterSet(_bmStorage.tokenSwapAdapter, tokenSwapAdapter_);\n        _bmStorage.tokenSwapAdapter = tokenSwapAdapter_;\n    }\n\n    /// @notice Completes the rebalance for the given baskets. The rebalance can be completed if it has been more than\n    /// 15 minutes since the last action.\n    /// @param basketsToRebalance Array of basket addresses proposed for rebalance.\n    /// @param targetWeights Array of target weights for the baskets.\n    function completeRebalance(\n        ExternalTrade[] calldata externalTrades,\n        address[] calldata basketsToRebalance,\n        uint64[][] calldata targetWeights\n    )\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        _bmStorage.completeRebalance(externalTrades, basketsToRebalance, targetWeights);\n    }\n\n    /// FALLBACK REDEEM LOGIC ///\n\n    /// @notice Fallback redeem function to redeem shares when the rebalance is not in progress. Redeems the shares for\n    /// each underlying asset in the basket pro-rata to the amount of shares redeemed.\n    /// @param totalSupplyBefore Total supply of the basket token before the shares were burned.\n    /// @param burnedShares Amount of shares burned.\n    /// @param to Address to send the redeemed assets to.\n    function proRataRedeem(\n        uint256 totalSupplyBefore,\n        uint256 burnedShares,\n        address to\n    )\n        public\n        nonReentrant\n        whenNotPaused\n        onlyRole(_BASKET_TOKEN_ROLE)\n    {\n        _bmStorage.proRataRedeem(totalSupplyBefore, burnedShares, to);\n    }\n\n    /// FEE FUNCTIONS ///\n\n    /// @notice Set the management fee to be given to the treausry on rebalance.\n    /// @param basket Address of the basket token.\n    /// @param managementFee_ Management fee in BPS denominated in 1e4.\n    /// @dev Only callable by the timelock.\n    /// @dev Setting the management fee of the 0 address will set the default management fee for newly created baskets.\n    function setManagementFee(address basket, uint16 managementFee_) external onlyRole(_TIMELOCK_ROLE) {\n        if (managementFee_ > _MAX_MANAGEMENT_FEE) {\n            revert InvalidManagementFee();\n        }\n\n        // Check if the basket is currently rebalancing\n        if (basket != address(0)) {\n            uint256 indexPlusOne = _bmStorage.basketTokenToIndexPlusOne[basket];\n            if (indexPlusOne == 0) {\n                revert BasketTokenNotFound();\n            }\n            if ((_bmStorage.rebalanceStatus.basketMask & (1 << indexPlusOne - 1)) != 0) {\n                revert MustWaitForRebalanceToComplete();\n            }\n        }\n        emit ManagementFeeSet(basket, _bmStorage.managementFees[basket], managementFee_);\n        _bmStorage.managementFees[basket] = managementFee_;\n    }\n\n    /// @notice Set the swap fee to be given to the treasury on rebalance.\n    /// @param swapFee_ Swap fee in BPS denominated in 1e4.\n    /// @dev Only callable by the timelock.\n    function setSwapFee(uint16 swapFee_) external onlyRole(_TIMELOCK_ROLE) {\n        if (swapFee_ > _MAX_SWAP_FEE) {\n            revert InvalidSwapFee();\n        }\n        if (_bmStorage.rebalanceStatus.status != Status.NOT_STARTED) {\n            revert MustWaitForRebalanceToComplete();\n        }\n        emit SwapFeeSet(_bmStorage.swapFee, swapFee_);\n        _bmStorage.swapFee = swapFee_;\n    }\n\n    /// @notice Claims the swap fee for the given asset and sends it to protocol treasury defined in the FeeCollector.\n    /// @param asset Address of the asset to collect the swap fee for.\n    function collectSwapFee(address asset) external onlyRole(_MANAGER_ROLE) returns (uint256 collectedFees) {\n        collectedFees = _bmStorage.collectedSwapFees[asset];\n        if (collectedFees != 0) {\n            _bmStorage.collectedSwapFees[asset] = 0;\n            IERC20(asset).safeTransfer(FeeCollector(_bmStorage.feeCollector).protocolTreasury(), collectedFees);\n        }\n    }\n\n    /// @notice Updates the bitFlag for the given basket.\n    /// @param basket Address of the basket.\n    /// @param bitFlag New bitFlag. It must be inclusive of the current bitFlag.\n    function updateBitFlag(address basket, uint256 bitFlag) external onlyRole(_TIMELOCK_ROLE) {\n        // Checks\n        // Check if basket exists\n        uint256 indexPlusOne = _bmStorage.basketTokenToIndexPlusOne[basket];\n        if (indexPlusOne == 0) {\n            revert BasketTokenNotFound();\n        }\n        uint256 currentBitFlag = BasketToken(basket).bitFlag();\n        if (currentBitFlag == bitFlag) {\n            revert BitFlagMustBeDifferent();\n        }\n        // Check if the new bitFlag is inclusive of the current bitFlag\n        if ((currentBitFlag & bitFlag) != currentBitFlag) {\n            revert BitFlagMustIncludeCurrent();\n        }\n        address strategy = BasketToken(basket).strategy();\n        if (!WeightStrategy(strategy).supportsBitFlag(bitFlag)) {\n            revert BitFlagUnsupportedByStrategy();\n        }\n        bytes32 newId = keccak256(abi.encodePacked(bitFlag, strategy));\n        if (_bmStorage.basketIdToAddress[newId] != address(0)) {\n            revert BasketIdAlreadyExists();\n        }\n        // Remove the old bitFlag mapping and add the new bitFlag mapping\n        bytes32 oldId = keccak256(abi.encodePacked(currentBitFlag, strategy));\n        _bmStorage.basketIdToAddress[oldId] = address(0);\n        _bmStorage.basketIdToAddress[newId] = basket;\n        _bmStorage.basketAssets[basket] = AssetRegistry(_bmStorage.assetRegistry).getAssets(bitFlag);\n        emit BasketBitFlagUpdated(basket, currentBitFlag, bitFlag, oldId, newId);\n        // Update the bitFlag in the BasketToken contract\n        BasketToken(basket).setBitFlag(bitFlag);\n    }\n\n    /// PAUSING FUNCTIONS ///\n\n    /// @notice Pauses the contract. Callable by DEFAULT_ADMIN_ROLE or PAUSER_ROLE.\n    function pause() external {\n        if (!(hasRole(_PAUSER_ROLE, msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender))) {\n            revert Unauthorized();\n        }\n        _pause();\n    }\n\n    /// @notice Unpauses the contract. Only callable by DEFAULT_ADMIN_ROLE.\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    }
}