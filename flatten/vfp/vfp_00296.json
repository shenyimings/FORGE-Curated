{
    "vfp_id": "vfp_00296",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding in Debt Shares Calculation Can Mint Unbacked Tokens",
            "description": "This vulnerability arises from the rounding down of debt shares in the TroveManager._updateBatchShares() function, which allows an attacker to manipulate the debt-to-shares ratio in a batch. By repeatedly donating small amounts of debt and opening/closing troves, an attacker can inflate the ratio to a point where new troves receive zero debt shares for non-zero debt, enabling them to mint unbacked BOLD tokens. The root cause is improper handling of integer division and lack of safeguards against ratio manipulation. An attacker could exploit this by looping through donation and trove operations to inflate the ratio, then mint large amounts of unbacked tokens, leading to protocol insolvency. The impact includes loss of trust, financial loss, and potential collapse of the system's monetary model.\n",
            "severity": "Critical",
            "location": [
                "TroveManager.sol::_updateBatchShares",
                "TroveManager.sol::_requireBelowMaxSharesRatio"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Leverage Zappers Do Not Return Swap Excess",
            "description": "The leverage zapper contracts fail to return excess tokens received from swap operations (e.g., UniV3Exchange and CurveExchange), leaving user funds stranded in the contract. The root cause is the lack of balance tracking before and after swaps and failure to refund leftover tokens. An attacker could exploit market volatility and slippage to generate excess tokens during swaps, which would remain in the zapper and could be drained by others. This leads to user fund loss, as excess BOLD or collateral tokens are not returned. The impact is direct financial loss for users and reduced trust in the system's fund handling.\n",
            "severity": "High",
            "location": [
                "UniV3Exchange.sol::swapFromBold",
                "CurveExchange.sol::swapFromBold",
                "Zapper contracts::openLeveragedTroveWithRawETH",
                "Zapper contracts::leverUpTrove",
                "Zapper contracts::leverDownTrove"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Zappers Can Lose User Funds",
            "description": "When users repay debt via zapper functions, if the repayment would bring the trove below MIN_DEBT, only a partial amount is repaid, and the remainder stays locked in the zapper contract. The cause is the logic in _adjustTrove that silently reduces the repayment amount without refunding excess. An attacker can front-run a large repayment by redeeming the target trove down to just above MIN_DEBT, causing nearly the entire repayment amount to be trapped. The impact is significant loss of user funds, especially in large repayments, and creates an attack vector where malicious actors can profit by backrunning and extracting stuck funds. This undermines user trust and fund safety.\n",
            "severity": "High",
            "location": [
                "BorrowerOperations.sol::_adjustTrove",
                "Zapper contracts::adjust",
                "Zapper contracts::repay"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Incorrect Scaling of P",
            "description": "In the StabilityPool.offset function, the variable P can be scaled beyond the assumed upper bound of 1e36 due to incorrect loop conditions, leading to incorrect calculations in dependent functions like getDepositorCollGain. The cause is a flawed while loop condition that allows P to grow excessively during scaling. An attacker could manipulate deposit and offset values to trigger this overflow, resulting in incorrect reward distributions and collateral gain calculations. The impact includes incorrect state updates, unfair reward allocation, and potential exploitation of miscalculated gains, though the risk is mitigated by the rarity of such edge cases.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::offset"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Pool Deposit Are Compared to Precision",
            "description": "The _updateYieldRewardsSum function compares total deposits to DECIMAL_PRECISION instead of the standard MIN_BOLD_IN_SP constant used elsewhere, despite both having the same value (1e18). While this does not result in functional bugs due to identical values, it introduces inconsistency and potential risk if constants are later changed independently. The cause is code duplication and lack of centralized constant usage. This could lead to future bugs if one constant is updated without the other. The impact is low, as no immediate exploit exists, but it represents a correctness issue in code consistency and maintainability.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1107"
                ]
            },
            "title": "Total Deposit Are Compared to Wrong Constant",
            "description": "Similar to the previous issue, _updateYieldRewardsSum uses DECIMAL_PRECISION instead of MIN_BOLD_IN_SP when checking total deposits for yield distribution thresholds. Although both constants are equal (1e18), this creates a discrepancy in codebase consistency. The root cause is redundant use of different constants for the same logical threshold. There is no immediate security impact, but it increases technical debt and risk of future divergence. The impact is limited to code clarity and maintainability, classified as a low-severity correctness issue.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Batches Can Be Used to Make Two Free Adjustments in a Row",
            "description": "Users can exploit the batch interest rate adjustment mechanism to perform two interest rate changes in a row without paying the required upfront fee. The cause is that setBatchManagerAnnualInterestRate only checks the batch's last adjustment time, not individual trove adjustments. A user can join a batch that was adjusted long ago, change its interest rate, and leave—effectively adjusting their own rate twice within the cooldown period. This allows strategic avoidance of redemption risk while minimizing cost. The impact includes unfair advantage, manipulation of interest rates, and potential abuse of the system's economic model, though the financial impact is limited.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::setInterestBatchManager",
                "BorrowerOperations.sol::setBatchManagerAnnualInterestRate"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Delegation Specification",
            "description": "The code initially allowed the receiver address (set by a Remove Manager) to receive collateral during any withdrawal, including those initiated by the owner, contrary to the documentation which states the receiver only gets funds during Remove Manager actions. The cause is a mismatch between specification and implementation. This could lead to user funds being sent to an unintended address if the receiver is set and the owner withdraws. The impact is potential loss of user funds and confusion due to undocumented behavior. The issue was corrected to align code with documentation.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::withdrawCollateral"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unredeemable Troves Can Pay Minimum Interest Rate",
            "description": "Troves with debt below MIN_DEBT are marked as unredeemable (zombie troves) and excluded from redemption lists, removing the risk of redemption and thus the incentive to pay higher interest rates. An attacker can create many such troves to pay only the minimum interest, gaining an unfair economic advantage. The cause is the design decision to exclude small troves from redemption lists. While mitigated by gas and capital costs, the strategy could still be profitable under certain conditions. The partial fix ensures zombie troves are redeemed first during redemptions, but an edge case remains where liquidated troves with zero debt can still become unredeemable and pay minimal interest. The impact is economic inefficiency and potential abuse of the interest model.\n",
            "severity": "Medium",
            "location": [
                "TroveManager.sol",
                "RedemptionLogic.sol"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy in swapFromBold Behavior",
            "description": "The UniV3Exchange and CurveExchange implementations of swapFromBold behave differently: UniV3 uses ExactOutput (fixing output, variable input), while Curve uses ExactInput (fixing input, variable output), leading to inconsistent handling of excess tokens. The cause is the use of different swap semantics across exchange adapters. This can result in unexpected leftover tokens in different contracts, complicating user expectations and integration logic. Liquity acknowledged the inconsistency but noted future exchanges may not support a uniform model. The impact is low, limited to usability and predictability, with no direct fund loss.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.sol::swapFromBold",
                "CurveExchange.sol::swapFromBold"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect Code Comments",
            "description": "The code contains outdated, inaccurate, or misleading comments and natspec documentation across several functions and contracts. For example, references to the deprecated \"composite debt\" concept from Liquity V1 persist in V2, where gas compensation is now handled in WETH. Additionally, some comments describe logic that no longer applies, such as redemption order based on collateral ratio when it is now based on interest rate.\n\nThe cause is that the comments were not updated during the transition from Liquity V1 to V2 or during subsequent logic changes. Some are the result of copy-paste from older versions or incomplete refactoring.\n\nWhile the code itself is correct, misleading comments could lead developers or auditors to misunderstand the system's behavior, potentially introducing bugs during future maintenance or upgrades.\n\nThe primary impact is reduced code maintainability and increased risk of human error during development or auditing. Although the runtime behavior is unaffected, incorrect documentation may lead to incorrect assumptions and future vulnerabilities.\n",
            "severity": "Low",
            "location": [
                "ActivePool._mintBatchManagementFeeAndAccountForChange",
                "BorrowerOperations._openTrove",
                "BorrowerOperations._applyUpfrontFee",
                "TroveManager.redeemCollateral",
                "LiquityMath._decPow",
                "StabilityPool.sortedTroves",
                "TroveManager.Batch",
                "MainnetPriceFeedBase.priceFeedDisabled",
                "TroveManager._urgentRedeemCollateralFromTrove",
                "BorrowerOperations.adjustUnredeemableTrove"
            ],
            "files": [
                "bold/contracts/src/ActivePool.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation of Troves in Urgent Redemptions",
            "description": "The `TroveManager.urgentRedemption` function does not validate whether a trove exists, is active, or has debt before processing, leading to unnecessary gas consumption and storage writes.\n\nThe cause is input validation for trove status and debt amount is missing in the function logic.\n\nAn attacker could submit redemption requests for non-existent or closed troves, causing the system to perform redundant storage operations and waste gas.\n\nIncreased gas costs for transactions and unnecessary state bloat. While no critical state corruption occurs, external applications reading from storage may observe incorrect or stale data.\n",
            "severity": "Low",
            "location": [
                "TroveManager.urgentRedemption",
                "TroveManager._applySingleRedemption"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Opening Troves Can Be Blocked",
            "description": "The trove ID in `BorrowerOperations._openTrove` is derived only from the owner and owner index, making it predictable and susceptible to frontrunning. An attacker can open a trove with the same ID, set themselves as manager, and steal the collateral.\n\nThe cause is that the trove ID does not include the caller (`msg.sender`), allowing anyone to replicate the ID and preempt the intended user.\n\nAn attacker monitors pending transactions and frontruns a trove creation by submitting their own with the same owner and index, becoming the manager and later withdrawing the collateral.\n\nUsers, especially multisigs or governance systems with delayed execution, can be permanently prevented from opening troves, leading to denial of service and potential loss of funds if the attacker withdraws collateral.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations._openTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Price Limit in UniV3Exchange Is Too Strict",
            "description": "The `UniV3Exchange.getBoldAmountToSwap` function uses a price limit that is too strict, based on the maximum output price rather than the average trade price, leading to suboptimal swaps.\n\nThe cause is that the price limit is derived directly from `_maxBoldAmount / _minCollAmount`, which does not reflect the actual average execution price of the swap.\n\nUsers may be forced to use looser price bounds than necessary, increasing slippage and allowing MEV bots to extract more value during large swaps.\n\nReduced swap efficiency and increased vulnerability to MEV, resulting in worse execution prices for users.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.getBoldAmountToSwap"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Shutdown Can Be Triggered Twice",
            "description": "The `shutdown` function in `BorrowerOperations` can be called when the TCR is below SCR, but it also calls `priceFeed.fetchPrice()`, which may independently trigger a shutdown due to oracle failure, resulting in two shutdown events.\n\nThe cause is that the function does not check whether the oracle call already caused a shutdown before proceeding with the TCR-based shutdown logic.\n\nIf both conditions occur simultaneously, two shutdown events are emitted, which may confuse off-chain monitoring systems that expect mutually exclusive shutdown causes.\n\nIncorrect event logging and potential misinterpretation by external systems, though no functional harm occurs due to idempotent shutdown logic.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.shutdown"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "User-provided transferFrom Source Address",
            "description": "The `UniV3Exchange` and `CurveExchange` contracts use a user-provided `_zapper` address in `transferFrom` calls, allowing arbitrary token pulls from approved addresses.\n\nThe cause is using a user-controlled address as the `from` parameter in `transferFrom` violates secure coding practices and introduces unintended token access.\n\nAn attacker could drain tokens from any address that has approved the exchange contract, including zappers or users who mistakenly approved it.\n\nRisk of unauthorized token transfers, though the actual impact is limited since zappers are not intended to hold balances.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.swapFromBold",
                "UniV3Exchange.SwapToBold",
                "CurveExchange.swapFromBold",
                "CurveExchange.SwapToBold"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Gas Optimizations in StabilityPool",
            "description": "Several gas inefficiencies were identified in the `StabilityPool` contract, including unnecessary checks, redundant arithmetic, and ineffective function calls.\n\nThe cause is suboptimal code structure and lack of early returns or simplifications in yield calculation and withdrawal logic.\n\nThese inefficiencies increase transaction costs for users but do not enable malicious exploitation.\n\nHigher gas consumption for depositors and withdrawers, reducing user experience and increasing operational costs.\n",
            "severity": "Informational",
            "location": [
                "StabilityPool.getDepositorYieldGainWithPending",
                "StabilityPool.withdrawFromSP"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Backed Tokens Can Be Redeemed Unproportionally",
            "description": "The `redeemCollateral` function in `CollateralRegistry` can redeem disproportionately from a single branch when not all branches are fully backed, violating fairness assumptions.\n\nThe cause is that the redemption logic does not cap the amount by total unbacked debt when some branches are partially backed.\n\nAn attacker could redeem large amounts from a single branch before it becomes fully backed, gaining an unfair advantage over proportional redemption.\n\nUnfair distribution of collateral during redemptions, potentially leading to economic imbalance between branches.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Floating Pragma",
            "description": "Some contracts use a floating Solidity pragma, which can lead to compilation with untested compiler versions.\n\nThe cause is lack of version pinning in pragma statements.\n\nCompiling with an untested version may introduce compiler-specific bugs or optimizations.\n\nIncreased risk of deployment issues or undefined behavior due to compiler version mismatches.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry.sol"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGPool.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveFactory.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGFactory.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurvePool.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3ExchangeHelpers.sol",
                "bold/contracts/src/Zappers/Interfaces/IFlashLoanReceiver.sol",
                "bold/contracts/src/Zappers/Interfaces/ILeverageZapper.sol",
                "bold/contracts/src/Zappers/Interfaces/IZapper.sol",
                "bold/contracts/src/Zappers/Interfaces/IExchangeHelpers.sol",
                "bold/contracts/src/Zappers/Interfaces/IFlashLoanProvider.sol",
                "bold/contracts/src/Zappers/Interfaces/IExchange.sol",
                "bold/contracts/src/NFTMetadata/utils/JSON.sol",
                "bold/contracts/src/NFTMetadata/utils/SVG.sol",
                "bold/contracts/src/Interfaces/ISortedTroves.sol",
                "bold/contracts/src/Interfaces/ILQTYToken.sol",
                "bold/contracts/src/Interfaces/IBorrowerOperations.sol",
                "bold/contracts/src/Interfaces/IAddressesRegistry.sol",
                "bold/contracts/src/Interfaces/IAddRemoveManagers.sol",
                "bold/contracts/src/Interfaces/ILiquityBase.sol",
                "bold/contracts/src/Interfaces/ICollSurplusPool.sol",
                "bold/contracts/src/Interfaces/IInterestRouter.sol",
                "bold/contracts/src/Interfaces/ILQTYStaking.sol",
                "bold/contracts/src/Interfaces/IBoldRewardsReceiver.sol",
                "bold/contracts/src/Interfaces/IActivePool.sol",
                "bold/contracts/src/Interfaces/IStabilityPoolEvents.sol",
                "bold/contracts/src/Interfaces/ICommunityIssuance.sol",
                "bold/contracts/src/Interfaces/IHintHelpers.sol",
                "bold/contracts/src/Interfaces/IBoldToken.sol",
                "bold/contracts/src/Interfaces/IWETH.sol",
                "bold/contracts/src/Interfaces/IWSTETH.sol",
                "bold/contracts/src/Interfaces/ITroveNFT.sol",
                "bold/contracts/src/Interfaces/IPriceFeed.sol",
                "bold/contracts/src/Interfaces/IMultiTroveGetter.sol",
                "bold/contracts/src/Interfaces/IMainnetPriceFeed.sol",
                "bold/contracts/src/Interfaces/IRETHPriceFeed.sol",
                "bold/contracts/src/Interfaces/IStabilityPool.sol",
                "bold/contracts/src/Interfaces/IDefaultPool.sol",
                "bold/contracts/src/Interfaces/ITroveEvents.sol",
                "bold/contracts/src/Interfaces/ITroveManager.sol",
                "bold/contracts/src/Interfaces/ICollateralRegistry.sol",
                "bold/contracts/src/Interfaces/IWSTETHPriceFeed.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Minting Unbacked Tokens via Redistributions",
            "description": "A rounding issue in debt share calculations allowed attackers to mint unbacked tokens by manipulating exchange rates and triggering redistributions.\n\nThe cause is that debt redistribution logic did not account for rounding down when calculating debt shares, allowing debt to be allocated without corresponding shares.\n\nAn attacker could open troves, manipulate exchange rates, and trigger redistributions to increase debt without minting shares, effectively creating unbacked tokens.\n\nRisk of protocol insolvency if exploited at scale, particularly in low-liquidity branches.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._getLatestTroveDataFromBatch",
                "TroveManager.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing Events",
            "description": "The `AddRemoveManager._setAddManager` and `_setRemoveManager` functions do not emit events when manager roles are updated.\n\nThe cause is event emission was omitted during implementation.\n\nUsers cannot track changes to manager roles, especially after transferring Trove NFTs.\n\nReduced transparency and auditability, making it harder for users to monitor access control changes.\n",
            "severity": "Informational",
            "location": [
                "AddRemoveManager._setAddManager",
                "AddRemoveManager._setRemoveManager"
            ],
            "files": [
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Bypassing Collateral Adjustment Check",
            "description": "The function BorrowerOperations._requireValidAdjustmentInCurrentMode prevents reducing collateral in undercollateralized troves (ICR < MCR). However, this check can be bypassed via self-redemptions: a user can first adjust the interest rate of their trove to be the lowest in the branch, then redeem from it. This sequence allows indirect reduction of collateral in an undercollateralized state. While Liquity acknowledges this behavior, they argue it does not allow converting a healthy trove into an undercollateralized one, thus posing minimal risk. Nevertheless, this represents a deviation from expected system invariants.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._requireValidAdjustmentInCurrentMode"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified across several contracts:\n1. ActivePool.mintBatchManagementFeeAndAccountForChange() is protected by a modifier that allows BorrowOperations or TroveManager, but is only ever called by TroveManager.\n2. ActivePool.calcPendingAggInterest() and calcPendingAggBatchManagementFee() could short-circuit early when the timestamp hasn't changed.\n3. TroveManager._getLatestTroveDataFromBatch() reads the entire batch struct but uses only one value.\n4. CollateralRegistry._requireBoldBalanceCoversRedemption() reasserts an invariant already enforced by OpenZeppelin's token implementation.\n5. TroveManager._redistributeDebtAndColl can skip sending zero collateral to DefaultPool.\n6. UniV3Exchange._requireCallerIsUniV3Router() and uniswapV3SwapCallback() are defined but never used.\n7. BorrowerOperations.adjustTroveInterestRate charges an upfront fee only if the rate changes, but _requireAnnualInterestRateIsNew makes this redundant.\n8. StabilityPool.sortedTroves is declared immutable but never used.\n9. Several state variables in TroveManager, BorrowerOperations, and ActivePool could be marked immutable for gas savings.\n10. WSTETHPriceFeed._fetchPrice() can be optimized by calling stETH directly instead of through wstETH.\n11. priceToSqrtPrice and _zeroForOne in UniV3Exchange are unused.\n12. TroveManager._requireBelowMaxSharesRatio could short-circuit before multiplication.\nSome of these (6, 7, 14) were partially corrected in Version 2.\n",
            "severity": "Informational",
            "location": [
                "ActivePool.mintBatchManagementFeeAndAccountForChange",
                "ActivePool.calcPendingAggInterest",
                "ActivePool.calcPendingAggBatchManagementFee",
                "TroveManager._getLatestTroveDataFromBatch",
                "CollateralRegistry._requireBoldBalanceCoversRedemption",
                "TroveManager._redistributeDebtAndColl",
                "UniV3Exchange._requireCallerIsUniV3Router",
                "UniV3Exchange.uniswapV3SwapCallback",
                "BorrowerOperations.adjustTroveInterestRate",
                "StabilityPool.sortedTroves",
                "BorrowerOperations._requireIsShutDown",
                "WSTETHPriceFeed._fetchPrice",
                "TroveManager contract state variables",
                "BorrowerOperations contract state variables",
                "ActivePool contract state variables",
                "UniV3Exchange.priceToSqrtPrice",
                "UniV3Exchange._zeroForOne",
                "TroveManager._requireBelowMaxSharesRatio"
            ],
            "files": [
                "bold/contracts/src/ActivePool.sol",
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/CollateralRegistry.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/PriceFeeds/WSTETHPriceFeed.sol",
                "bold/contracts/src/PriceFeeds/RETHPriceFeed.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Insufficient Gas Compensation Could Mint Bad Debt",
            "description": "The system relies on gas compensation to incentivize liquidations. If the gas cost exceeds the compensation, liquidators may not act, leading to accumulation of bad debt. This can occur during prolonged periods of high gas prices or falling collateral values. An attacker could exploit this by creating a batch with maximum interest rate and joining the Stability Pool, allowing unbacked tokens to be minted via interest accrual if the trove remains unliquidated. Although such attacks carry risk (anyone can liquidate at a loss to punish the attacker), they illustrate a theoretical pathway for minting unbacked debt. The risk is considered low due to economic disincentives and prioritization of large troves for liquidation.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Price Deviation in Composite Price Feed",
            "description": "The RETHPriceFeed computes RETH/USD as the product of RETH/ETH and ETH/USD prices. With Chainlink deviation thresholds of 2% and 0.5% respectively, the combined price can deviate up to ~2.5% before updating. During branch shutdowns triggered by TCR < SCR, the protocol offers a 1% bonus on oracle price, which may be insufficient to cover this deviation. Additionally, the canonical rate from Rocket Pool updates every 24 hours, potentially delaying urgent redemptions. This creates a window where users may receive less value than expected during critical events. Liquity acknowledges this as a known and accepted risk.\n",
            "severity": "Informational",
            "location": [
                "RETHPriceFeed",
                "CompositePriceFeed._fetchPrice",
                "TroveManager.urgentRedemption"
            ],
            "files": [
                "bold/contracts/src/PriceFeeds/RETHPriceFeed.sol",
                "bold/contracts/src/PriceFeeds/CompositePriceFeed.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small Redemptions Do Not Increase Base Rate",
            "description": "The function CollateralRegistry._getUpdatedBaseRateFromRedemption calculates the base rate based on the fraction of BOLD redeemed. Due to integer division rounding down, very small redemptions (e.g., less than totalSupply / 1e18) result in zero base rate increase. This allows strategic splitting of redemptions to avoid fees, though at higher gas cost. For example, with a 10B total supply, redemptions below 1e-8 BOLD have no effect. Liquity acknowledges this but considers the amounts negligible and not economically viable to exploit.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry._getUpdatedBaseRateFromRedemption"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Upfront Fee Is Zero for Small Borrows",
            "description": "The upfront fee in BorrowerOperations._calcUpfrontFee is calculated as a fraction of debt and interest rate over time. Due to precision limitations, the fee rounds to zero for small borrows. For instance, with a 0.5% average interest rate, any borrow below 10,400 wei pays no fee. Similarly, interest accrual on small troves may also round to zero. This primarily affects zombie troves with negligible debt. Liquity acknowledges the issue but deems the impact negligible at both user and system levels.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._calcUpfrontFee",
                "_calcInterest"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Upfrontfee Can Bring Troves Below MCR",
            "description": "While BorrowerOperations._applyUpfrontFee includes a check to ensure ICR remains above MCR, the function setBatchManagerAnnualInterestRate lacks this protection. As a result, charging an upfront fee during a batch interest rate adjustment could push a trove below MCR. However, interest can only be adjusted once per second, limiting the potential for repeated manipulation within a block. In Version 5, a 10% collateral buffer was introduced to prevent single-transaction liquidation exploits. This mitigates the most critical variant where a user could open a trove at 110%, pay an upfront fee, and immediately liquidate it in one transaction. The attack is now only possible over time.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._applyUpfrontFee",
                "setBatchManagerAnnualInterestRate"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "rETH Address Might Change",
            "description": "The rETH token address is set once in the AddressesRegistry and cannot be updated. However, Rocket Pool recommends retrieving addresses dynamically from their registry contract rather than hardcoding them. Although Liquity contacted Rocket Pool and was assured the rETH address is unlikely to change, the current design does not support migration if it ever does. This creates a potential long-term integration risk, especially if Rocket Pool upgrades its token contract.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry"
            ],
            "files": [
                "bold/contracts/src/AddressesRegistry.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Add Manager Can Increase Stake",
            "description": "The addManager role allows anyone to add collateral to a trove. While this improves collateralization, it also increases the trove’s stake in the system. In extreme cases involving negative redistributions (where debt increases more than collateral), an attacker could manipulate another user’s trove to increase their share of losses. Users can mitigate this by setting the addManager to their own address, effectively disabling third-party deposits.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "CCR and SCR Considerations",
            "description": "The Close Crowdfunding Ratio (CCR) and Shutdown Collateralization Ratio (SCR) must be sufficiently far apart to prevent attackers from frontrunning oracle updates to trigger branch shutdowns. If CCR is too close to SCR, a price drop could be exploited to force a shutdown. This mirrors known attacks in Liquity V1. The proposed values (CCR=1.5, SCR=1.1) are considered safe, but future deployments with tighter margins should evaluate this risk.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/AddressesRegistry.sol"
            ]
        },
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Delegations Are Deleted on Liquidation",
            "description": "Upon liquidation, all delegations for a trove are deleted via the _BorrowerOperations.onLiquidateTrove hook. Only the trove owner can reclaim surplus collateral; delegated accounts cannot. If the owner is a smart contract, it must implement claimCollateral() directly and cannot rely on delegation. Failure to do so risks permanent loss of surplus collateral.\n",
            "severity": "Informational",
            "location": [
                "_BorrowerOperations.onLiquidateTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Frontrunning Considerations for Off-Chain Infrastructure",
            "description": "Off-chain systems must account for frontrunning risks:\n1. redeemCollateral uses user-provided max amount for fee calculation, which may exceed actual redemption, leading to overpayment.\n2. Setting _maxFeePercentage may cause reverts if base rate increases due to prior redemptions.\n3. Liquidation order affects redistributions, which can alter the health of other troves.\nIntegrators should consider using wrapper contracts to dynamically compute safe redemption amounts.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Fully Backed Branches Can Have Low Interest Rates",
            "description": "Branches with more BOLD in Stability Pool than outstanding debt are \"fully backed\" and immune to redemptions. This removes the incentive to maintain high interest rates, leading to rate drops to the minimum. If the branch later becomes unbacked (via withdrawals, liquidations, or new debt), troves may face sudden redemption pressure. The system may self-correct if Stability Pool deposits decrease due to lower yields, but the dynamics are uncertain.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Integration Notes for Smart Contract Devs",
            "description": "Several behaviors may surprise integrators:\n- repayBold and adjustTrove repay only up to MIN_DEBT, leaving excess with caller.\n- withdrawFromSP withdraws full balance if _amount exceeds user’s deposit.\n- Trove state can change between calls due to batch-wide effects (e.g., rounding).\nContracts must handle partial executions and dynamic state changes.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations.repayBold",
                "BorrowerOperations.adjustTrove",
                "StabilityPool.withdrawFromSP",
                "TroveManager.getLatestTroveData"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Interest Rate Adjustments Below CCR",
            "description": "When TCR falls below CCR, debt-increasing operations (including upfront fee payments for interest rate adjustments) are blocked. This prevents users from increasing their interest rate to avoid redemptions once below CCR. Users must act before crossing this threshold, as adjustments are subject to a cooldown period.\n",
            "severity": "Informational",
            "location": [
                "INTEREST_RATE_ADJ_COOLDOWN"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Manipulating Bold Supply With Flashloans",
            "description": "Users can use flashloans to inflate BOLD supply temporarily, reducing redemption fees (which are proportional to supply). For example, doubling supply halves the fee on large redemptions. If the average interest rate post-borrow is low (e.g., 1%), this can be profitable. Users can avoid self-redemption by depositing minted BOLD into the Stability Pool. This behavior is economically rational but may distort fee mechanisms.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/BoldToken.sol"
            ]
        },
        {
            "id": 54,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Trove Shares Exchange Rate Invariant",
            "description": "The function TroveManager._updateBatchShares() rounds down when reducing debt, which can slightly reduce debt per share. While the protocol assumes a 1:1 debt-to-share ratio, rounding could theoretically cause discrepancies. In extreme cases, this could lead to overflow in debt calculations (e.g., when totalDebtShares is extremely large). Full redemptions may leave residual shares due to division truncation. In Version 2, full closures now set shares to zero to avoid this. The core invariant — that debt per share never falls below 1 — must be preserved.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._updateBatchShares",
                "TroveManager._getLatestTroveDataFromBatch"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        }
    ],
    "affected_files": {
        "CollateralRegistry.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Dependencies/Constants.sol\";\nimport \"./Dependencies/LiquityMath.sol\";\n\nimport \"./Interfaces/ICollateralRegistry.sol\";\n\ncontract CollateralRegistry is ICollateralRegistry {\n    // See: https://github.com/ethereum/solidity/issues/12587\n    uint256 public immutable totalCollaterals;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n    IERC20Metadata internal immutable token4;\n    IERC20Metadata internal immutable token5;\n    IERC20Metadata internal immutable token6;\n    IERC20Metadata internal immutable token7;\n    IERC20Metadata internal immutable token8;\n    IERC20Metadata internal immutable token9;\n\n    ITroveManager internal immutable troveManager0;\n    ITroveManager internal immutable troveManager1;\n    ITroveManager internal immutable troveManager2;\n    ITroveManager internal immutable troveManager3;\n    ITroveManager internal immutable troveManager4;\n    ITroveManager internal immutable troveManager5;\n    ITroveManager internal immutable troveManager6;\n    ITroveManager internal immutable troveManager7;\n    ITroveManager internal immutable troveManager8;\n    ITroveManager internal immutable troveManager9;\n\n    IBoldToken public immutable boldToken;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new Bold issuance)\n    uint256 public lastFeeOperationTime = block.timestamp;\n\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n\n    constructor(IBoldToken _boldToken, IERC20Metadata[] memory _tokens, ITroveManager[] memory _troveManagers) {\n        uint256 numTokens = _tokens.length;\n        require(numTokens > 0, \"Collateral list cannot be empty\");\n        require(numTokens <= 10, \"Collateral list too long\");\n        totalCollaterals = numTokens;\n\n        boldToken = _boldToken;\n\n        token0 = _tokens[0];\n        token1 = numTokens > 1 ? _tokens[1] : IERC20Metadata(address(0));\n        token2 = numTokens > 2 ? _tokens[2] : IERC20Metadata(address(0));\n        token3 = numTokens > 3 ? _tokens[3] : IERC20Metadata(address(0));\n        token4 = numTokens > 4 ? _tokens[4] : IERC20Metadata(address(0));\n        token5 = numTokens > 5 ? _tokens[5] : IERC20Metadata(address(0));\n        token6 = numTokens > 6 ? _tokens[6] : IERC20Metadata(address(0));\n        token7 = numTokens > 7 ? _tokens[7] : IERC20Metadata(address(0));\n        token8 = numTokens > 8 ? _tokens[8] : IERC20Metadata(address(0));\n        token9 = numTokens > 9 ? _tokens[9] : IERC20Metadata(address(0));\n\n        troveManager0 = _troveManagers[0];\n        troveManager1 = numTokens > 1 ? _troveManagers[1] : ITroveManager(address(0));\n        troveManager2 = numTokens > 2 ? _troveManagers[2] : ITroveManager(address(0));\n        troveManager3 = numTokens > 3 ? _troveManagers[3] : ITroveManager(address(0));\n        troveManager4 = numTokens > 4 ? _troveManagers[4] : ITroveManager(address(0));\n        troveManager5 = numTokens > 5 ? _troveManagers[5] : ITroveManager(address(0));\n        troveManager6 = numTokens > 6 ? _troveManagers[6] : ITroveManager(address(0));\n        troveManager7 = numTokens > 7 ? _troveManagers[7] : ITroveManager(address(0));\n        troveManager8 = numTokens > 8 ? _troveManagers[8] : ITroveManager(address(0));\n        troveManager9 = numTokens > 9 ? _troveManagers[9] : ITroveManager(address(0));\n\n        // Initialize the baseRate state variable\n        baseRate = INITIAL_BASE_RATE;\n        emit BaseRateUpdated(INITIAL_BASE_RATE);\n    }\n\n    struct RedemptionTotals {\n        uint256 numCollaterals;\n        uint256 boldSupplyAtStart;\n        uint256 unbacked;\n        uint256 redeemedAmount;\n    }\n\n    function redeemCollateral(uint256 _boldAmount, uint256 _maxIterationsPerCollateral, uint256 _maxFeePercentage)\n        external\n    {\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAmountGreaterThanZero(_boldAmount);\n\n        RedemptionTotals memory totals;\n\n        totals.numCollaterals = totalCollaterals;\n        uint256[] memory unbackedPortions = new uint256[](totals.numCollaterals);\n        uint256[] memory prices = new uint256[](totals.numCollaterals);\n\n        // Gather and accumulate unbacked portions\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            ITroveManager troveManager = getTroveManager(index);\n            (uint256 unbackedPortion, uint256 price, bool redeemable) =\n                troveManager.getUnbackedPortionPriceAndRedeemability();\n            prices[index] = price;\n            if (redeemable) {\n                totals.unbacked += unbackedPortion;\n                unbackedPortions[index] = unbackedPortion;\n            }\n        }\n\n        // There’s an unlikely scenario where all the normally redeemable branches (i.e. having TCR > SCR) have 0 unbacked\n        // In that case, we redeem proportionally to branch size\n        if (totals.unbacked == 0) {\n            unbackedPortions = new uint256[](totals.numCollaterals);\n            for (uint256 index = 0; index < totals.numCollaterals; index++) {\n                ITroveManager troveManager = getTroveManager(index);\n                (,, bool redeemable) = troveManager.getUnbackedPortionPriceAndRedeemability();\n                if (redeemable) {\n                    uint256 unbackedPortion = troveManager.getEntireBranchDebt();\n                    totals.unbacked += unbackedPortion;\n                    unbackedPortions[index] = unbackedPortion;\n                }\n            }\n        } else {\n            // Don't allow redeeming more than the total unbacked in one go, as that would result in a disproportionate\n            // redemption (see CS-BOLD-013). Instead, truncate the redemption to total unbacked. If this happens, the\n            // redeemer can call `redeemCollateral()` a second time to redeem the remainder of their BOLD.\n            if (_boldAmount > totals.unbacked) {\n                _boldAmount = totals.unbacked;\n            }\n        }\n\n        totals.boldSupplyAtStart = boldToken.totalSupply();\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total Bold supply value, from before it was reduced by the redemption.\n        // We only compute it here, and update it at the end,\n        // because the final redeemed amount may be less than the requested amount\n        // Redeemers should take this into account in order to request the optimal amount to not overpay\n        uint256 redemptionRate =\n            _calcRedemptionRate(_getUpdatedBaseRateFromRedemption(_boldAmount, totals.boldSupplyAtStart));\n        require(redemptionRate <= _maxFeePercentage, \"CR: Fee exceeded provided maximum\");\n        // Implicit by the above and the _requireValidMaxFeePercentage checks\n        //require(newBaseRate < DECIMAL_PRECISION, \"CR: Fee would eat up all collateral\");\n\n        // Compute redemption amount for each collateral and redeem against the corresponding TroveManager\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            //uint256 unbackedPortion = unbackedPortions[index];\n            if (unbackedPortions[index] > 0) {\n                uint256 redeemAmount = _boldAmount * unbackedPortions[index] / totals.unbacked;\n                if (redeemAmount > 0) {\n                    ITroveManager troveManager = getTroveManager(index);\n                    uint256 redeemedAmount = troveManager.redeemCollateral(\n                        msg.sender, redeemAmount, prices[index], redemptionRate, _maxIterationsPerCollateral\n                    );\n                    totals.redeemedAmount += redeemedAmount;\n                }\n\n                // Ensure that per-branch redeems add up to `_boldAmount` exactly\n                _boldAmount -= redeemAmount;\n                totals.unbacked -= unbackedPortions[index];\n            }\n        }\n\n        _updateBaseRateAndGetRedemptionRate(totals.redeemedAmount, totals.boldSupplyAtStart);\n\n        // Burn the total Bold that is cancelled with debt\n        if (totals.redeemedAmount > 0) {\n            boldToken.burn(msg.sender, totals.redeemedAmount);\n        }\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n\n        if (minutesPassed > 0) {\n            lastFeeOperationTime += ONE_MINUTE * minutesPassed;\n            emit LastFeeOpTimeUpdated(lastFeeOperationTime);\n        }\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint256) {\n        return (block.timestamp - lastFeeOperationTime) / ONE_MINUTE;\n    }\n\n    // Updates the `baseRate` state with math from `_getUpdatedBaseRateFromRedemption`\n    function _updateBaseRateAndGetRedemptionRate(uint256 _boldAmount, uint256 _totalBoldSupplyAtStart) internal {\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_boldAmount, _totalBoldSupplyAtStart);\n\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in `_getUpdatedBaseRateFromRedemption`\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    /*\n     * This function calculates the new baseRate in the following way:\n     * 1) decays the baseRate based on time passed since last redemption or Bold borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _getUpdatedBaseRateFromRedemption(uint256 _redeemAmount, uint256 _totalBoldSupply)\n        internal\n        view\n        returns (uint256)\n    {\n        // decay the base rate\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        // get the fraction of total supply that was redeemed\n        uint256 redeemedBoldFraction = _redeemAmount * DECIMAL_PRECISION / _totalBoldSupply;\n\n        uint256 newBaseRate = decayedBaseRate + redeemedBoldFraction / REDEMPTION_BETA;\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n\n        return newBaseRate;\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint256 decayFactor = LiquityMath._decPow(REDEMPTION_MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate * decayFactor / DECIMAL_PRECISION;\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal pure returns (uint256) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR + _baseRate,\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _amount) internal pure returns (uint256) {\n        uint256 redemptionFee = _redemptionRate * _amount / DECIMAL_PRECISION;\n        return redemptionFee;\n    }\n\n    // external redemption rate/fee getters\n\n    function getRedemptionRate() external view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionRate(newBaseRate);\n    }\n\n    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);\n    }\n\n    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view override returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionFee(_calcRedemptionRate(newBaseRate), _redeemAmount);\n    }\n\n    // getters\n\n    function getToken(uint256 _index) external view returns (IERC20Metadata) {\n        if (_index == 0) return token0;\n        else if (_index == 1) return token1;\n        else if (_index == 2) return token2;\n        else if (_index == 3) return token3;\n        else if (_index == 4) return token4;\n        else if (_index == 5) return token5;\n        else if (_index == 6) return token6;\n        else if (_index == 7) return token7;\n        else if (_index == 8) return token8;\n        else if (_index == 9) return token9;\n        else revert(\"Invalid index\");\n    }\n\n    function getTroveManager(uint256 _index) public view returns (ITroveManager) {\n        if (_index == 0) return troveManager0;\n        else if (_index == 1) return troveManager1;\n        else if (_index == 2) return troveManager2;\n        else if (_index == 3) return troveManager3;\n        else if (_index == 4) return troveManager4;\n        else if (_index == 5) return troveManager5;\n        else if (_index == 6) return troveManager6;\n        else if (_index == 7) return troveManager7;\n        else if (_index == 8) return troveManager8;\n        else if (_index == 9) return troveManager9;\n        else revert(\"Invalid index\");\n    }\n\n    // require functions\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        require(_amount > 0, \"CollateralRegistry: Amount must be greater than zero\");\n    }\n}\n",
        "IHintHelpers.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IHintHelpers {\n    function getApproxHint(uint256 _collIndex, uint256 _interestRate, uint256 _numTrials, uint256 _inputRandomSeed)\n        external\n        view\n        returns (uint256 hintId, uint256 diff, uint256 latestRandomSeed);\n\n    function predictOpenTroveUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, uint256 _interestRate)\n        external\n        view\n        returns (uint256);\n\n    function predictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256);\n\n    function forcePredictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256);\n\n    function predictAdjustTroveUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _debtIncrease)\n        external\n        view\n        returns (uint256);\n\n    function predictAdjustBatchInterestRateUpfrontFee(\n        uint256 _collIndex,\n        address _batchAddress,\n        uint256 _newInterestRate\n    ) external view returns (uint256);\n\n    function predictJoinBatchInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, address _batchAddress)\n        external\n        view\n        returns (uint256);\n}\n",
        "IWETH.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IWETH is IERC20Metadata {\n    function deposit() external payable;\n    function withdraw(uint256 wad) external;\n}\n",
        "ITroveEvents.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ITroveEvents {\n    enum Operation {\n        openTrove,\n        closeTrove,\n        adjustTrove,\n        adjustTroveInterestRate,\n        applyPendingDebt,\n        liquidate,\n        redeemCollateral,\n        // batch management\n        openTroveAndJoinBatch,\n        setInterestBatchManager,\n        removeFromBatch\n    }\n\n    event Liquidation(\n        uint256 _debtOffsetBySP,\n        uint256 _debtRedistributed,\n        uint256 _boldGasCompensation,\n        uint256 _collGasCompensation,\n        uint256 _collSentToSP,\n        uint256 _collRedistributed,\n        uint256 _collSurplus,\n        uint256 _L_ETH,\n        uint256 _L_boldDebt,\n        uint256 _price\n    );\n\n    event Redemption(\n        uint256 _attemptedBoldAmount,\n        uint256 _actualBoldAmount,\n        uint256 _ETHSent,\n        uint256 _ETHFee,\n        uint256 _price,\n        uint256 _redemptionPrice\n    );\n\n    // A snapshot of the Trove's latest state on-chain\n    event TroveUpdated(\n        uint256 indexed _troveId,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _stake,\n        uint256 _annualInterestRate,\n        uint256 _snapshotOfTotalCollRedist,\n        uint256 _snapshotOfTotalDebtRedist\n    );\n\n    // Details of an operation that modifies a Trove\n    event TroveOperation(\n        uint256 indexed _troveId,\n        Operation _operation,\n        uint256 _annualInterestRate,\n        uint256 _debtIncreaseFromRedist,\n        uint256 _debtIncreaseFromUpfrontFee,\n        int256 _debtChangeFromOperation,\n        uint256 _collIncreaseFromRedist,\n        int256 _collChangeFromOperation\n    );\n\n    event RedemptionFeePaidToTrove(uint256 indexed _troveId, uint256 _ETHFee);\n\n    // Batch management\n\n    enum BatchOperation {\n        registerBatchManager,\n        lowerBatchManagerAnnualFee,\n        setBatchManagerAnnualInterestRate,\n        applyBatchInterestAndFee,\n        joinBatch,\n        exitBatch,\n        // used when the batch is updated as a result of a Trove change inside the batch\n        troveChange\n    }\n\n    event BatchUpdated(\n        address indexed _interestBatchManager,\n        BatchOperation _operation,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _annualInterestRate,\n        uint256 _annualManagementFee,\n        uint256 _totalDebtShares,\n        uint256 _debtIncreaseFromUpfrontFee\n    );\n\n    event BatchedTroveUpdated(\n        uint256 indexed _troveId,\n        address _interestBatchManager,\n        uint256 _batchDebtShares,\n        uint256 _coll,\n        uint256 _stake,\n        uint256 _snapshotOfTotalCollRedist,\n        uint256 _snapshotOfTotalDebtRedist\n    );\n}\n",
        "IZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IFlashLoanProvider.sol\";\nimport \"./IExchange.sol\";\n\ninterface IZapper {\n    struct OpenTroveParams {\n        address owner;\n        uint256 ownerIndex;\n        uint256 collAmount;\n        uint256 boldAmount;\n        uint256 upperHint;\n        uint256 lowerHint;\n        uint256 annualInterestRate;\n        address batchManager;\n        uint256 maxUpfrontFee;\n        address addManager;\n        address removeManager;\n        address receiver;\n    }\n\n    struct CloseTroveParams {\n        uint256 troveId;\n        uint256 flashLoanAmount;\n        uint256 minExpectedCollateral;\n        address receiver;\n    }\n\n    function flashLoanProvider() external view returns (IFlashLoanProvider);\n\n    function exchange() external view returns (IExchange);\n\n    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256);\n\n    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount, uint256 _minExpectedCollateral)\n        external;\n}\n",
        "IRETHPriceFeed.sol": "// SPDX-License-Identifier: MIT\nimport \"./IMainnetPriceFeed.sol\";\nimport \"../Dependencies/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IRETHPriceFeed is IMainnetPriceFeed {\n    function rEthEthOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n}\n",
        "IInterestRouter.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IInterestRouter {\n// Currently the Interest Router doesn’t need any specific function\n}\n",
        "IDefaultPool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IDefaultPool {\n    function troveManagerAddress() external view returns (address);\n    function activePoolAddress() external view returns (address);\n    // --- Functions ---\n    function getCollBalance() external view returns (uint256);\n    function getBoldDebt() external view returns (uint256);\n    function sendCollToActivePool(uint256 _amount) external;\n    function receiveColl(uint256 _amount) external;\n\n    function increaseBoldDebt(uint256 _amount) external;\n    function decreaseBoldDebt(uint256 _amount) external;\n}\n",
        "ILiquityBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IActivePool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IPriceFeed.sol\";\n\ninterface ILiquityBase {\n    function activePool() external view returns (IActivePool);\n    function getEntireBranchDebt() external view returns (uint256);\n    function getEntireBranchColl() external view returns (uint256);\n}\n",
        "IExchangeHelpers.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExchangeHelpers {\n    function getCollFromBold(uint256 _boldAmount, IERC20 _collToken, uint256 _desiredCollAmount)\n        external /* view */\n        returns (uint256, uint256);\n}\n",
        "IAddRemoveManagers.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAddRemoveManagers {\n    function setAddManager(uint256 _troveId, address _manager) external;\n    function setRemoveManager(uint256 _troveId, address _manager) external;\n    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) external;\n    function addManagerOf(uint256 _troveId) external view returns (address);\n    function removeManagerReceiverOf(uint256 _troveId) external view returns (address, address);\n}\n",
        "WSTETHPriceFeed.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"./CompositePriceFeed.sol\";\nimport \"../Interfaces/IWSTETH.sol\";\nimport \"../Interfaces/IWSTETHPriceFeed.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract WSTETHPriceFeed is CompositePriceFeed, IWSTETHPriceFeed {\n    Oracle public stEthUsdOracle;\n\n    uint256 public constant STETH_USD_DEVIATION_THRESHOLD = 1e16; // 1%\n\n    constructor(\n        address _ethUsdOracleAddress,\n        address _stEthUsdOracleAddress,\n        address _wstEthTokenAddress,\n        uint256 _ethUsdStalenessThreshold,\n        uint256 _stEthUsdStalenessThreshold,\n        address _borrowerOperationsAddress\n    )\n        CompositePriceFeed(_ethUsdOracleAddress, _wstEthTokenAddress, _ethUsdStalenessThreshold, _borrowerOperationsAddress)\n    {\n        stEthUsdOracle.aggregator = AggregatorV3Interface(_stEthUsdOracleAddress);\n        stEthUsdOracle.stalenessThreshold = _stEthUsdStalenessThreshold;\n        stEthUsdOracle.decimals = stEthUsdOracle.aggregator.decimals();\n\n        _fetchPricePrimary(false);\n\n        // Check the oracle didn't already fail\n        assert(priceSource == PriceSource.primary);\n    }\n\n    function _fetchPricePrimary(bool _isRedemption) internal override returns (uint256, bool) {\n        assert(priceSource == PriceSource.primary);\n        (uint256 stEthUsdPrice, bool stEthUsdOracleDown) = _getOracleAnswer(stEthUsdOracle);\n        (uint256 stEthPerWstEth, bool exchangeRateIsDown) = _getCanonicalRate();\n        (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);\n\n        // - If exchange rate or ETH-USD is down, shut down and switch to last good price. Reasoning:\n        // - Exchange rate is used in all price calcs\n        // - ETH-USD is used in the fallback calc, and for redemptions in the primary price calc\n        if (exchangeRateIsDown) {\n            return (_shutDownAndSwitchToLastGoodPrice(rateProviderAddress), true);\n        }\n        if (ethUsdOracleDown) {\n            return (_shutDownAndSwitchToLastGoodPrice(address(ethUsdOracle.aggregator)), true);\n        }\n\n        // If the STETH-USD feed is down, shut down and try to substitute it with the ETH-USD price\n        if (stEthUsdOracleDown) {\n            return (_shutDownAndSwitchToETHUSDxCanonical(address(stEthUsdOracle.aggregator), ethUsdPrice), true);\n        }\n\n        // Otherwise, use the primary price calculation:\n        uint256 wstEthUsdPrice;\n\n        if (_isRedemption && _withinDeviationThreshold(stEthUsdPrice, ethUsdPrice, STETH_USD_DEVIATION_THRESHOLD)) {\n            // If it's a redemption and within 1%, take the max of (STETH-USD, ETH-USD) to mitigate unwanted redemption arb and convert to WSTETH-USD\n            wstEthUsdPrice = LiquityMath._max(stEthUsdPrice, ethUsdPrice) * stEthPerWstEth / 1e18;\n        } else {\n            // Otherwise, just calculate WSTETH-USD price: USD_per_WSTETH = USD_per_STETH * STETH_per_WSTETH\n            wstEthUsdPrice = stEthUsdPrice * stEthPerWstEth / 1e18;\n        }\n\n        lastGoodPrice = wstEthUsdPrice;\n\n        return (wstEthUsdPrice, false);\n    }\n\n    function _getCanonicalRate() internal view override returns (uint256, bool) {\n        uint256 gasBefore = gasleft();\n\n        try IWSTETH(rateProviderAddress).stEthPerToken() returns (uint256 stEthPerWstEth) {\n            // If rate is 0, return true\n            if (stEthPerWstEth == 0) return (0, true);\n\n            return (stEthPerWstEth, false);\n        } catch {\n            // Require that enough gas was provided to prevent an OOG revert in the external call\n            // causing a shutdown. Instead, just revert. Slightly conservative, as it includes gas used\n            // in the check itself.\n            if (gasleft() <= gasBefore / 64) revert InsufficientGasForExternalCall();\n\n            // If call to exchange rate reverted for another reason, return true\n            return (0, true);\n        }\n    }\n}\n",
        "ISortedTroves.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ITroveManager.sol\";\nimport {BatchId, BATCH_ID_ZERO} from \"../Types/BatchId.sol\";\n\ninterface ISortedTroves {\n    // -- Mutating functions (permissioned) --\n    function insert(uint256 _id, uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId) external;\n    function insertIntoBatch(\n        uint256 _troveId,\n        BatchId _batchId,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) external;\n\n    function remove(uint256 _id) external;\n    function removeFromBatch(uint256 _id) external;\n\n    function reInsert(uint256 _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId) external;\n    function reInsertBatch(BatchId _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId) external;\n\n    // -- View functions --\n\n    function contains(uint256 _id) external view returns (bool);\n    function isBatchedNode(uint256 _id) external view returns (bool);\n    function isEmptyBatch(BatchId _id) external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n    function getSize() external view returns (uint256);\n\n    function getFirst() external view returns (uint256);\n    function getLast() external view returns (uint256);\n    function getNext(uint256 _id) external view returns (uint256);\n    function getPrev(uint256 _id) external view returns (uint256);\n\n    function validInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        view\n        returns (bool);\n    function findInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        view\n        returns (uint256, uint256);\n\n    // Public state variable getters\n    function borrowerOperationsAddress() external view returns (address);\n    function troveManager() external view returns (ITroveManager);\n    function size() external view returns (uint256);\n    function nodes(uint256 _id) external view returns (uint256 nextId, uint256 prevId, BatchId batchId, bool exists);\n    function batches(BatchId _id) external view returns (uint256 head, uint256 tail);\n}\n",
        "HybridCurveUniV3Exchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"../../../Interfaces/IWETH.sol\";\nimport \"../../LeftoversSweep.sol\";\n// Curve\nimport \"./Curve/ICurveStableswapNGPool.sol\";\n// UniV3\nimport \"./UniswapV3/ISwapRouter.sol\";\n\nimport \"../../Interfaces/IExchange.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract HybridCurveUniV3Exchange is LeftoversSweep, IExchange {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    IERC20 public immutable USDC;\n    IWETH public immutable WETH;\n\n    // Curve\n    ICurveStableswapNGPool public immutable curvePool;\n    uint128 public immutable USDC_INDEX;\n    uint128 public immutable BOLD_TOKEN_INDEX;\n\n    // Uniswap\n    uint24 public immutable feeUsdcWeth;\n    uint24 public immutable feeWethColl;\n    ISwapRouter public immutable uniV3Router;\n\n    constructor(\n        IERC20 _collToken,\n        IBoldToken _boldToken,\n        IERC20 _usdc,\n        IWETH _weth,\n        // Curve\n        ICurveStableswapNGPool _curvePool,\n        uint128 _usdcIndex,\n        uint128 _boldIndex,\n        // UniV3\n        uint24 _feeUsdcWeth,\n        uint24 _feeWethColl,\n        ISwapRouter _uniV3Router\n    ) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        USDC = _usdc;\n        WETH = _weth;\n\n        // Curve\n        curvePool = _curvePool;\n        USDC_INDEX = _usdcIndex;\n        BOLD_TOKEN_INDEX = _boldIndex;\n\n        // Uniswap\n        feeUsdcWeth = _feeUsdcWeth;\n        feeWethColl = _feeWethColl;\n        uniV3Router = _uniV3Router;\n    }\n\n    // Bold -> USDC on Curve; then USDC -> WETH, and optionally WETH -> Coll, on UniV3\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {\n        InitialBalances memory initialBalances;\n        _setHybridExchangeInitialBalances(initialBalances);\n\n        // Curve\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n        boldToken.approve(address(curvePool), _boldAmount);\n\n        uint256 curveUsdcAmount = curvePool.exchange(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), _boldAmount, 0);\n\n        // Uniswap\n        USDC.approve(address(uniV3Router), curveUsdcAmount);\n\n        // See: https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps\n        bytes memory path;\n        if (address(WETH) == address(collToken)) {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH);\n        } else {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH, feeWethColl, collToken);\n        }\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: curveUsdcAmount,\n            amountOutMinimum: _minCollAmount\n        });\n\n        // Executes the swap.\n        uniV3Router.exactInput(params);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    // Optionally Coll -> WETH, and WETH -> USDC on UniV3; then USDC -> Bold on Curve\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {\n        InitialBalances memory initialBalances;\n        _setHybridExchangeInitialBalances(initialBalances);\n\n        // Uniswap\n        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);\n        collToken.approve(address(uniV3Router), _collAmount);\n\n        // See: https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps\n        bytes memory path;\n        if (address(WETH) == address(collToken)) {\n            path = abi.encodePacked(WETH, feeUsdcWeth, USDC);\n        } else {\n            path = abi.encodePacked(collToken, feeWethColl, WETH, feeUsdcWeth, USDC);\n        }\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: _collAmount,\n            amountOutMinimum: 0\n        });\n\n        // Executes the swap.\n        uint256 uniV3UsdcAmount = uniV3Router.exactInput(params);\n\n        // Curve\n        USDC.approve(address(curvePool), uniV3UsdcAmount);\n\n        uint256 boldAmount =\n            curvePool.exchange(int128(USDC_INDEX), int128(BOLD_TOKEN_INDEX), uniV3UsdcAmount, _minBoldAmount);\n        boldToken.transfer(msg.sender, boldAmount);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n\n        return boldAmount;\n    }\n\n    function _setHybridExchangeInitialBalances(InitialBalances memory initialBalances) internal view {\n        initialBalances.tokens[0] = boldToken;\n        initialBalances.tokens[1] = USDC;\n        initialBalances.tokens[2] = WETH;\n        if (address(WETH) != address(collToken)) {\n            initialBalances.tokens[3] = collToken;\n        }\n        _setInitialBalances(initialBalances);\n    }\n}\n",
        "ICommunityIssuance.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICommunityIssuance {\n    function setAddresses(address _lqtyTokenAddress, address _stabilityPoolAddress) external;\n\n    function issueLQTY() external returns (uint256);\n\n    function sendLQTY(address _account, uint256 _LQTYamount) external;\n}\n",
        "AddRemoveManagers.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"../Interfaces/IAddRemoveManagers.sol\";\nimport \"../Interfaces/IAddressesRegistry.sol\";\nimport \"../Interfaces/ITroveNFT.sol\";\n\ncontract AddRemoveManagers is IAddRemoveManagers {\n    ITroveNFT internal immutable troveNFT;\n\n    struct RemoveManagerReceiver {\n        address manager;\n        address receiver;\n    }\n\n    /*\n     * Mapping from TroveId to granted address for operations that \"give\" money to the trove (add collateral, pay debt).\n     * Useful for instance for cold/hot wallet setups.\n     * If its value is zero address, any address is allowed to do those operations on behalf of trove owner.\n     * Otherwise, only the address in this mapping (and the trove owner) will be allowed.\n     * To restrict this permission to no one, trove owner should be set in this mapping.\n     */\n    mapping(uint256 => address) public addManagerOf;\n\n    /*\n     * Mapping from TroveId to granted addresses for operations that \"withdraw\" money from the trove (withdraw collateral, borrow),\n     * and for each of those addresses another address for the receiver of those withdrawn funds.\n     * Useful for instance for cold/hot wallet setups or for automations.\n     * Only the address in this mapping, if any, and the trove owner, will be allowed.\n     * Therefore, by default this permission is restricted to no one.\n     * If the receiver is zero, the owner is assumed as the receiver.\n     * RemoveManager also assumes AddManager permission\n     */\n    mapping(uint256 => RemoveManagerReceiver) public removeManagerReceiverOf;\n\n    error EmptyManager();\n    error NotBorrower();\n    error NotOwnerNorAddManager();\n    error NotOwnerNorRemoveManager();\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n    event AddManagerUpdated(uint256 indexed _troveId, address _newAddManager);\n    event RemoveManagerAndReceiverUpdated(uint256 indexed _troveId, address _newRemoveManager, address _newReceiver);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        troveNFT = _addressesRegistry.troveNFT();\n        emit TroveNFTAddressChanged(address(troveNFT));\n    }\n\n    function setAddManager(uint256 _troveId, address _manager) external {\n        _requireCallerIsBorrower(_troveId);\n        _setAddManager(_troveId, _manager);\n    }\n\n    function _setAddManager(uint256 _troveId, address _manager) internal {\n        addManagerOf[_troveId] = _manager;\n        emit AddManagerUpdated(_troveId, _manager);\n    }\n\n    function setRemoveManager(uint256 _troveId, address _manager) external {\n        setRemoveManagerWithReceiver(_troveId, _manager, troveNFT.ownerOf(_troveId));\n    }\n\n    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) public {\n        _requireCallerIsBorrower(_troveId);\n        _setRemoveManagerAndReceiver(_troveId, _manager, _receiver);\n    }\n\n    function _setRemoveManagerAndReceiver(uint256 _troveId, address _manager, address _receiver) internal {\n        _requireNonZeroManagerUnlessWiping(_manager, _receiver);\n        removeManagerReceiverOf[_troveId].manager = _manager;\n        removeManagerReceiverOf[_troveId].receiver = _receiver;\n        emit RemoveManagerAndReceiverUpdated(_troveId, _manager, _receiver);\n    }\n\n    function _wipeAddRemoveManagers(uint256 _troveId) internal {\n        delete addManagerOf[_troveId];\n        delete removeManagerReceiverOf[_troveId];\n        emit AddManagerUpdated(_troveId, address(0));\n        emit RemoveManagerAndReceiverUpdated(_troveId, address(0), address(0));\n    }\n\n    function _requireNonZeroManagerUnlessWiping(address _manager, address _receiver) internal pure {\n        if (_manager == address(0) && _receiver != address(0)) {\n            revert EmptyManager();\n        }\n    }\n\n    function _requireCallerIsBorrower(uint256 _troveId) internal view {\n        if (msg.sender != troveNFT.ownerOf(_troveId)) {\n            revert NotBorrower();\n        }\n    }\n\n    function _requireSenderIsOwnerOrAddManager(uint256 _troveId, address _owner) internal view {\n        address addManager = addManagerOf[_troveId];\n        if (msg.sender != _owner && addManager != address(0) && msg.sender != addManager) {\n            // RemoveManager assumes AddManager permission too\n            address removeManager = removeManagerReceiverOf[_troveId].manager;\n            if (msg.sender != removeManager) {\n                revert NotOwnerNorAddManager();\n            }\n        }\n    }\n\n    function _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(uint256 _troveId, address _owner)\n        internal\n        view\n        returns (address)\n    {\n        address manager = removeManagerReceiverOf[_troveId].manager;\n        address receiver = removeManagerReceiverOf[_troveId].receiver;\n        if (msg.sender != _owner && msg.sender != manager) {\n            revert NotOwnerNorRemoveManager();\n        }\n        if (receiver == address(0) || msg.sender != manager) {\n            return _owner;\n        }\n        return receiver;\n    }\n}\n",
        "ILQTYStaking.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ILQTYStaking {\n    function setAddresses(\n        address _lqtyTokenAddress,\n        address _boldTokenAddress,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function stake(uint256 _LQTYamount) external;\n\n    function unstake(uint256 _LQTYamount) external;\n\n    function increaseF_ETH(uint256 _ETHFee) external;\n\n    function increaseF_bold(uint256 _LQTYFee) external;\n\n    function getPendingETHGain(address _user) external view returns (uint256);\n\n    function getPendingBoldGain(address _user) external view returns (uint256);\n}\n",
        "IWSTETH.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IWSTETH {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\n    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);\n    function stEthPerToken() external view returns (uint256);\n    function tokensPerStEth() external view returns (uint256);\n}\n",
        "ITroveNFT.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport \"./ITroveManager.sol\";\n\ninterface ITroveNFT is IERC721Metadata {\n    function mint(address _owner, uint256 _troveId) external;\n    function burn(uint256 _troveId) external;\n}\n",
        "RETHPriceFeed.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"./CompositePriceFeed.sol\";\nimport \"../Interfaces/IRETHToken.sol\";\nimport \"../Interfaces/IRETHPriceFeed.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract RETHPriceFeed is CompositePriceFeed, IRETHPriceFeed {\n    constructor(\n        address _ethUsdOracleAddress,\n        address _rEthEthOracleAddress,\n        address _rEthTokenAddress,\n        uint256 _ethUsdStalenessThreshold,\n        uint256 _rEthEthStalenessThreshold,\n        address _borrowerOperationsAddress\n    )\n        CompositePriceFeed(_ethUsdOracleAddress, _rEthTokenAddress, _ethUsdStalenessThreshold, _borrowerOperationsAddress)\n    {\n        // Store RETH-ETH oracle\n        rEthEthOracle.aggregator = AggregatorV3Interface(_rEthEthOracleAddress);\n        rEthEthOracle.stalenessThreshold = _rEthEthStalenessThreshold;\n        rEthEthOracle.decimals = rEthEthOracle.aggregator.decimals();\n\n        _fetchPricePrimary(false);\n\n        // Check the oracle didn't already fail\n        assert(priceSource == PriceSource.primary);\n    }\n\n    Oracle public rEthEthOracle;\n\n    uint256 public constant RETH_ETH_DEVIATION_THRESHOLD = 2e16; // 2%\n\n    function _fetchPricePrimary(bool _isRedemption) internal override returns (uint256, bool) {\n        assert(priceSource == PriceSource.primary);\n        (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);\n        (uint256 rEthEthPrice, bool rEthEthOracleDown) = _getOracleAnswer(rEthEthOracle);\n        (uint256 ethPerReth, bool exchangeRateIsDown) = _getCanonicalRate();\n\n        // If either the ETH-USD feed or exchange rate is down, shut down and switch to the last good price\n        // seen by the system since we need both for primary and fallback price calcs\n        if (ethUsdOracleDown) {\n            return (_shutDownAndSwitchToLastGoodPrice(address(ethUsdOracle.aggregator)), true);\n        }\n        if (exchangeRateIsDown) {\n            return (_shutDownAndSwitchToLastGoodPrice(rateProviderAddress), true);\n        }\n        // If the ETH-USD feed is live but the RETH-ETH oracle is down, shutdown and substitute RETH-ETH with the canonical rate\n        if (rEthEthOracleDown) {\n            return (_shutDownAndSwitchToETHUSDxCanonical(address(rEthEthOracle.aggregator), ethUsdPrice), true);\n        }\n\n        // Otherwise, use the primary price calculation:\n\n        // Calculate the market RETH-USD price: USD_per_RETH = USD_per_ETH * ETH_per_RETH\n        uint256 rEthUsdMarketPrice = ethUsdPrice * rEthEthPrice / 1e18;\n\n        // Calculate the canonical LST-USD price: USD_per_RETH = USD_per_ETH * ETH_per_RETH\n        uint256 rEthUsdCanonicalPrice = ethUsdPrice * ethPerReth / 1e18;\n\n        uint256 rEthUsdPrice;\n\n        // If it's a redemption and canonical is within 2% of market, use the max to mitigate unwanted redemption oracle arb\n        if (\n            _isRedemption\n                && _withinDeviationThreshold(rEthUsdMarketPrice, rEthUsdCanonicalPrice, RETH_ETH_DEVIATION_THRESHOLD)\n        ) {\n            rEthUsdPrice = LiquityMath._max(rEthUsdMarketPrice, rEthUsdCanonicalPrice);\n        } else {\n            // Take the minimum of (market, canonical) in order to mitigate against upward market price manipulation.\n            // Assumes a deviation between market <> canonical of >2% represents a legitimate market price difference.\n            rEthUsdPrice = LiquityMath._min(rEthUsdMarketPrice, rEthUsdCanonicalPrice);\n        }\n\n        lastGoodPrice = rEthUsdPrice;\n\n        return (rEthUsdPrice, false);\n    }\n\n    function _getCanonicalRate() internal view override returns (uint256, bool) {\n        uint256 gasBefore = gasleft();\n\n        try IRETHToken(rateProviderAddress).getExchangeRate() returns (uint256 ethPerReth) {\n            // If rate is 0, return true\n            if (ethPerReth == 0) return (0, true);\n\n            return (ethPerReth, false);\n        } catch {\n            // Require that enough gas was provided to prevent an OOG revert in the external call\n            // causing a shutdown. Instead, just revert. Slightly conservative, as it includes gas used\n            // in the check itself.\n            if (gasleft() <= gasBefore / 64) revert InsufficientGasForExternalCall();\n\n            // If call to exchange rate reverts, return true\n            return (0, true);\n        }\n    }\n}\n",
        "BorrowerOperations.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/AddRemoveManagers.sol\";\nimport \"./Types/LatestTroveData.sol\";\nimport \"./Types/LatestBatchData.sol\";\n\ncontract BorrowerOperations is LiquityBase, AddRemoveManagers, IBorrowerOperations {\n    using SafeERC20 for IERC20;\n\n    // --- Connected contract declarations ---\n\n    IERC20 internal immutable collToken;\n    ITroveManager internal troveManager;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n    bool public hasBeenShutDown;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    // Extra buffer of collateral ratio to join a batch or adjust a trove inside a batch (on top of MCR)\n    uint256 public immutable BCR;\n\n    /*\n    * Mapping from TroveId to individual delegate for interest rate setting.\n    *\n    * This address then has the ability to update the borrower’s interest rate, but not change its debt or collateral.\n    * Useful for instance for cold/hot wallet setups.\n    */\n    mapping(uint256 => InterestIndividualDelegate) private interestIndividualDelegateOf;\n\n    /*\n     * Mapping from TroveId to granted address for interest rate setting (batch manager).\n     *\n     * Batch managers set the interest rate for every Trove in the batch. The interest rate is the same for all Troves in the batch.\n     */\n    mapping(uint256 => address) public interestBatchManagerOf;\n\n    // List of registered Interest Batch Managers\n    mapping(address => InterestBatchManager) private interestBatchManagers;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct OpenTroveVars {\n        ITroveManager troveManager;\n        uint256 troveId;\n        TroveChange change;\n        LatestBatchData batch;\n    }\n\n    struct LocalVariables_openTrove {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IBoldToken boldToken;\n        uint256 troveId;\n        uint256 price;\n        uint256 avgInterestRate;\n        uint256 entireDebt;\n        uint256 ICR;\n        uint256 newTCR;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_adjustTrove {\n        IActivePool activePool;\n        IBoldToken boldToken;\n        LatestTroveData trove;\n        uint256 price;\n        bool isBelowCriticalThreshold;\n        uint256 newICR;\n        uint256 newDebt;\n        uint256 newColl;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_setInterestBatchManager {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ISortedTroves sortedTroves;\n        address oldBatchManager;\n        LatestTroveData trove;\n        LatestBatchData oldBatch;\n        LatestBatchData newBatch;\n    }\n\n    struct LocalVariables_removeFromBatch {\n        ITroveManager troveManager;\n        ISortedTroves sortedTroves;\n        address batchManager;\n        LatestTroveData trove;\n        LatestBatchData batch;\n        uint256 batchFutureDebt;\n        TroveChange batchChange;\n    }\n\n    error IsShutDown();\n    error TCRNotBelowSCR();\n    error ZeroAdjustment();\n    error NotOwnerNorInterestManager();\n    error TroveInBatch();\n    error TroveNotInBatch();\n    error InterestNotInRange();\n    error BatchInterestRateChangePeriodNotPassed();\n    error DelegateInterestRateChangePeriodNotPassed();\n    error TroveExists();\n    error TroveNotOpen();\n    error TroveNotActive();\n    error TroveNotZombie();\n    error TroveWithZeroDebt();\n    error UpfrontFeeTooHigh();\n    error ICRBelowMCR();\n    error ICRBelowMCRPlusBCR();\n    error RepaymentNotMatchingCollWithdrawal();\n    error TCRBelowCCR();\n    error DebtBelowMin();\n    error CollWithdrawalTooHigh();\n    error NotEnoughBoldBalance();\n    error InterestRateTooLow();\n    error InterestRateTooHigh();\n    error InterestRateNotNew();\n    error InvalidInterestBatchManager();\n    error BatchManagerExists();\n    error BatchManagerNotNew();\n    error NewFeeNotLower();\n    error CallerNotTroveManager();\n    error CallerNotPriceFeed();\n    error MinGeMax();\n    error AnnualManagementFeeTooHigh();\n    error MinInterestRateChangePeriodTooLow();\n    error NewOracleFailureDetected();\n    error BatchSharesRatioTooLow();\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n\n    event ShutDown(uint256 _tcr);\n\n    constructor(IAddressesRegistry _addressesRegistry)\n        AddRemoveManagers(_addressesRegistry)\n        LiquityBase(_addressesRegistry)\n    {\n        // This makes impossible to open a trove with zero withdrawn Bold\n        assert(MIN_DEBT > 0);\n\n        collToken = _addressesRegistry.collToken();\n\n        WETH = _addressesRegistry.WETH();\n\n        CCR = _addressesRegistry.CCR();\n        SCR = _addressesRegistry.SCR();\n        MCR = _addressesRegistry.MCR();\n        BCR = _addressesRegistry.BCR();\n\n        troveManager = _addressesRegistry.troveManager();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit BoldTokenAddressChanged(address(boldToken));\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(address(activePool), type(uint256).max);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external override returns (uint256) {\n        _requireValidAnnualInterestRate(_annualInterestRate);\n\n        OpenTroveVars memory vars;\n\n        vars.troveId = _openTrove(\n            _owner,\n            _ownerIndex,\n            _collAmount,\n            _boldAmount,\n            _annualInterestRate,\n            address(0),\n            0,\n            0,\n            _maxUpfrontFee,\n            _addManager,\n            _removeManager,\n            _receiver,\n            vars.change\n        );\n\n        // Set the stored Trove properties and mint the NFT\n        troveManager.onOpenTrove(_owner, vars.troveId, vars.change, _annualInterestRate);\n\n        sortedTroves.insert(vars.troveId, _annualInterestRate, _upperHint, _lowerHint);\n\n        return vars.troveId;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        override\n        returns (uint256)\n    {\n        _requireValidInterestBatchManager(_params.interestBatchManager);\n\n        OpenTroveVars memory vars;\n        vars.troveManager = troveManager;\n\n        vars.batch = vars.troveManager.getLatestBatchData(_params.interestBatchManager);\n\n        // We set old weighted values here, as it’s only necessary for batches, so we don’t need to pass them to _openTrove func\n        vars.change.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.change.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.change.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.troveId = _openTrove(\n            _params.owner,\n            _params.ownerIndex,\n            _params.collAmount,\n            _params.boldAmount,\n            vars.batch.annualInterestRate,\n            _params.interestBatchManager,\n            vars.batch.entireDebtWithoutRedistribution,\n            vars.batch.annualManagementFee,\n            _params.maxUpfrontFee,\n            _params.addManager,\n            _params.removeManager,\n            _params.receiver,\n            vars.change\n        );\n\n        interestBatchManagerOf[vars.troveId] = _params.interestBatchManager;\n\n        // Set the stored Trove properties and mint the NFT\n        vars.troveManager.onOpenTroveAndJoinBatch(\n            _params.owner,\n            vars.troveId,\n            vars.change,\n            _params.interestBatchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution\n        );\n\n        sortedTroves.insertIntoBatch(\n            vars.troveId,\n            BatchId.wrap(_params.interestBatchManager),\n            vars.batch.annualInterestRate,\n            _params.upperHint,\n            _params.lowerHint\n        );\n\n        return vars.troveId;\n    }\n\n    function _openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _annualInterestRate,\n        address _interestBatchManager,\n        uint256 _batchEntireDebt,\n        uint256 _batchManagementAnnualFee,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver,\n        TroveChange memory _change\n    ) internal returns (uint256) {\n        _requireIsNotShutDown();\n\n        LocalVariables_openTrove memory vars;\n\n        // stack too deep not allowing to reuse troveManager from outer functions\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n\n        // --- Checks ---\n\n        vars.troveId = uint256(keccak256(abi.encode(msg.sender, _owner, _ownerIndex)));\n        _requireTroveDoesNotExists(vars.troveManager, vars.troveId);\n\n        _change.collIncrease = _collAmount;\n        _change.debtIncrease = _boldAmount;\n\n        // For simplicity, we ignore the fee when calculating the approx. interest rate\n        _change.newWeightedRecordedDebt = (_batchEntireDebt + _change.debtIncrease) * _annualInterestRate;\n\n        vars.avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_change);\n        _change.upfrontFee = _calcUpfrontFee(_change.debtIncrease, vars.avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_change.upfrontFee, _maxUpfrontFee);\n\n        vars.entireDebt = _change.debtIncrease + _change.upfrontFee;\n        _requireAtLeastMinDebt(vars.entireDebt);\n\n        vars.ICR = LiquityMath._computeCR(_collAmount, vars.entireDebt, vars.price);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee, and the batch fee if needed\n        if (_interestBatchManager == address(0)) {\n            _change.newWeightedRecordedDebt = vars.entireDebt * _annualInterestRate;\n\n            // ICR is based on the requested Bold amount + upfront fee.\n            _requireICRisAboveMCR(vars.ICR);\n        } else {\n            // old values have been set outside, before calling this function\n            _change.newWeightedRecordedDebt = (_batchEntireDebt + vars.entireDebt) * _annualInterestRate;\n            _change.newWeightedRecordedBatchManagementFee =\n                (_batchEntireDebt + vars.entireDebt) * _batchManagementAnnualFee;\n\n            // ICR is based on the requested Bold amount + upfront fee.\n            // Troves in a batch have a stronger requirement (MCR+BCR)\n            _requireICRisAboveMCRPlusBCR(vars.ICR);\n        }\n\n        vars.newTCR = _getNewTCRFromTroveChange(_change, vars.price);\n        _requireNewTCRisAboveCCR(vars.newTCR);\n\n        // --- Effects & interactions ---\n\n        // Set add/remove managers\n        _setAddManager(vars.troveId, _addManager);\n        _setRemoveManagerAndReceiver(vars.troveId, _removeManager, _receiver);\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_change, _interestBatchManager);\n\n        // Pull coll tokens from sender and move them to the Active Pool\n        _pullCollAndSendToActivePool(vars.activePool, _collAmount);\n\n        // Mint the requested _boldAmount to the borrower and mint the gas comp to the GasPool\n        vars.boldToken.mint(msg.sender, _boldAmount);\n        WETH.transferFrom(msg.sender, gasPoolAddress, ETH_GAS_COMPENSATION);\n\n        return vars.troveId;\n    }\n\n    // Send collateral to a trove\n    function addColl(uint256 _troveId, uint256 _collAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collIncrease = _collAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(uint256 _troveId, uint256 _collWithdrawal) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = _collWithdrawal;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw Bold tokens from a trove: mint new Bold tokens to the owner, and increase the trove's debt accordingly\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtIncrease = _boldAmount;\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    // Repay Bold tokens to a Trove: Burn the repaid Bold tokens, and reduce the trove's debt accordingly\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtDecrease = _boldAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    function _initTroveChange(\n        TroveChange memory _troveChange,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease\n    ) internal pure {\n        if (_isCollIncrease) {\n            _troveChange.collIncrease = _collChange;\n        } else {\n            _troveChange.collDecrease = _collChange;\n        }\n\n        if (_isDebtIncrease) {\n            _troveChange.debtIncrease = _boldChange;\n        } else {\n            _troveChange.debtDecrease = _boldChange;\n        }\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    function adjustZombieTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsZombie(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n\n        troveManagerCached.setTroveStatusToActive(_troveId);\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        uint256 batchAnnualInterestRate;\n        if (batchManager != address(0)) {\n            LatestBatchData memory batch = troveManagerCached.getLatestBatchData(batchManager);\n            batchAnnualInterestRate = batch.annualInterestRate;\n        }\n        _reInsertIntoSortedTroves(\n            _troveId,\n            troveManagerCached.getTroveAnnualInterestRate(_troveId),\n            _upperHint,\n            _lowerHint,\n            batchManager,\n            batchAnnualInterestRate\n        );\n    }\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        _requireIsNotInBatch(_troveId);\n        _requireSenderIsOwnerOrInterestManager(_troveId);\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireValidDelegateAdustment(_troveId, trove.lastInterestRateAdjTime, _newAnnualInterestRate);\n        _requireAnnualInterestRateIsNew(trove.annualInterestRate, _newAnnualInterestRate);\n\n        uint256 newDebt = trove.entireDebt;\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n\n        // Apply upfront fee on premature adjustments. It checks the resulting ICR\n        if (block.timestamp < trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            newDebt = _applyUpfrontFee(trove.entireColl, newDebt, troveChange, _maxUpfrontFee, false);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n\n        activePool.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        sortedTroves.reInsert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        troveManagerCached.onAdjustTroveInterestRate(\n            _troveId, trove.entireColl, newDebt, _newAnnualInterestRate, troveChange\n        );\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    */\n    function _adjustTrove(\n        ITroveManager _troveManager,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_adjustTrove memory vars;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n        vars.isBelowCriticalThreshold = _checkBelowCriticalThreshold(vars.price, CCR);\n\n        // --- Checks ---\n\n        _requireTroveIsOpen(_troveManager, _troveId);\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = owner; // If it’s a withdrawal, and remove manager privilege is set, a different receiver can be defined\n\n        if (_troveChange.collDecrease > 0 || _troveChange.debtIncrease > 0) {\n            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        } else {\n            // RemoveManager assumes AddManager, so if the former is set, there's no need to check the latter\n            _requireSenderIsOwnerOrAddManager(_troveId, owner);\n            // No need to check the type of trove change for two reasons:\n            // - If the check above fails, it means sender is not owner, nor AddManager, nor RemoveManager.\n            //   An independent 3rd party should not be allowed here.\n            // - If it's not collIncrease or debtDecrease, _requireNonZeroAdjustment would revert\n        }\n\n        vars.trove = _troveManager.getLatestTroveData(_troveId);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Bold\n        if (_troveChange.debtDecrease > 0) {\n            uint256 maxRepayment = vars.trove.entireDebt > MIN_DEBT ? vars.trove.entireDebt - MIN_DEBT : 0;\n            if (_troveChange.debtDecrease > maxRepayment) {\n                _troveChange.debtDecrease = maxRepayment;\n            }\n            _requireSufficientBoldBalance(vars.boldToken, msg.sender, _troveChange.debtDecrease);\n        }\n\n        _requireNonZeroAdjustment(_troveChange);\n\n        // When the adjustment is a collateral withdrawal, check that it's no more than the Trove's entire collateral\n        if (_troveChange.collDecrease > 0) {\n            _requireValidCollWithdrawal(vars.trove.entireColl, _troveChange.collDecrease);\n        }\n\n        vars.newColl = vars.trove.entireColl + _troveChange.collIncrease - _troveChange.collDecrease;\n        vars.newDebt = vars.trove.entireDebt + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        bool isTroveInBatch = batchManager != address(0);\n        LatestBatchData memory batch;\n        uint256 batchFutureDebt;\n        if (isTroveInBatch) {\n            batch = _troveManager.getLatestBatchData(batchManager);\n\n            batchFutureDebt = batch.entireDebtWithoutRedistribution + vars.trove.redistBoldDebtGain\n                + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            _troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            _troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.oldWeightedRecordedDebt = vars.trove.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n        }\n\n        // Pay an upfront fee on debt increases\n        if (_troveChange.debtIncrease > 0) {\n            uint256 avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n            _troveChange.upfrontFee = _calcUpfrontFee(_troveChange.debtIncrease, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n            vars.newDebt += _troveChange.upfrontFee;\n            if (isTroveInBatch) {\n                batchFutureDebt += _troveChange.upfrontFee;\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n                _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n            } else {\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n            }\n        }\n\n        // Make sure the Trove doesn't end up zombie\n        // Now the max repayment is capped to stay above MIN_DEBT, so this only applies to adjustZombieTrove\n        _requireAtLeastMinDebt(vars.newDebt);\n\n        vars.newICR = LiquityMath._computeCR(vars.newColl, vars.newDebt, vars.price);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(_troveChange, vars, isTroveInBatch);\n\n        // --- Effects and interactions ---\n\n        if (isTroveInBatch) {\n            _troveManager.onAdjustTroveInsideBatch(\n                _troveId,\n                vars.newColl,\n                vars.newDebt,\n                _troveChange,\n                batchManager,\n                batch.entireCollWithoutRedistribution,\n                batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _troveManager.onAdjustTrove(_troveId, vars.newColl, vars.newDebt, _troveChange);\n        }\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_troveChange, batchManager);\n        _moveTokensFromAdjustment(receiver, _troveChange, vars.boldToken, vars.activePool);\n    }\n\n    function closeTrove(uint256 _troveId) external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IBoldToken boldTokenCached = boldToken;\n\n        // --- Checks ---\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n\n        // The borrower must repay their entire debt including accrued interest, batch fee and redist. gains\n        _requireSufficientBoldBalance(boldTokenCached, msg.sender, trove.entireDebt);\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n        if (batchManager != address(0)) {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            uint256 batchFutureDebt =\n                batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain);\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            // troveChange.newWeightedRecordedDebt = 0;\n        }\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        uint256 newTCR = _getNewTCRFromTroveChange(troveChange, price);\n        if (!hasBeenShutDown) _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.onCloseTrove(\n            _troveId,\n            troveChange,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution\n        );\n\n        // If trove is in batch\n        if (batchManager != address(0)) {\n            // Unlink here in BorrowerOperations\n            interestBatchManagerOf[_troveId] = address(0);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, batchManager);\n\n        // Return ETH gas compensation\n        WETH.transferFrom(gasPoolAddress, receiver, ETH_GAS_COMPENSATION);\n        // Burn the remainder of the Trove's entire debt from the user\n        boldTokenCached.burn(msg.sender, trove.entireDebt);\n\n        // Send the collateral back to the user\n        activePoolCached.sendColl(receiver, trove.entireColl);\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) public {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireNonZeroDebt(trove.entireDebt);\n\n        TroveChange memory change;\n        change.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        change.appliedRedistCollGain = trove.redistCollGain;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n\n        if (batchManager == address(0)) {\n            change.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            change.newWeightedRecordedDebt = trove.entireDebt * trove.annualInterestRate;\n        } else {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            change.batchAccruedManagementFee = batch.accruedManagementFee;\n            change.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            change.newWeightedRecordedDebt =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualInterestRate;\n            change.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            change.newWeightedRecordedBatchManagementFee =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualManagementFee;\n        }\n\n        troveManagerCached.onApplyTroveInterest(\n            _troveId,\n            trove.entireColl,\n            trove.entireDebt,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            change\n        );\n        activePool.mintAggInterestAndAccountForTroveChange(change, batchManager);\n\n        // If the trove was zombie, and now it’s not anymore, put it back in the list\n        if (_checkTroveIsZombie(troveManagerCached, _troveId) && trove.entireDebt >= MIN_DEBT) {\n            troveManagerCached.setTroveStatusToActive(_troveId);\n            _reInsertIntoSortedTroves(\n                _troveId, trove.annualInterestRate, _upperHint, _lowerHint, batchManager, batch.annualInterestRate\n            );\n        }\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory)\n    {\n        return interestIndividualDelegateOf[_troveId];\n    }\n\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee,\n        uint256 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireTroveIsActive(troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        _requireOrderedRange(_minInterestRate, _maxInterestRate);\n\n        interestIndividualDelegateOf[_troveId] =\n            InterestIndividualDelegate(_delegate, _minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n        // Can’t have both individual delegation and batch manager\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            // Not needed, implicitly checked in removeFromBatch\n            //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n            removeFromBatch(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);\n        }\n    }\n\n    function removeInterestIndividualDelegate(uint256 _troveId) external {\n        _requireCallerIsBorrower(_troveId);\n        delete interestIndividualDelegateOf[_troveId];\n    }\n\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory) {\n        return interestBatchManagers[_account];\n    }\n\n    function registerBatchManager(\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        uint128 _currentInterestRate,\n        uint128 _annualManagementFee,\n        uint128 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireNonExistentInterestBatchManager(msg.sender);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        _requireOrderedRange(_minInterestRate, _maxInterestRate);\n        _requireInterestRateInRange(_currentInterestRate, _minInterestRate, _maxInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_currentInterestRate);\n        if (_annualManagementFee > MAX_ANNUAL_BATCH_MANAGEMENT_FEE) revert AnnualManagementFeeTooHigh();\n        if (_minInterestRateChangePeriod < MIN_INTEREST_RATE_CHANGE_PERIOD) revert MinInterestRateChangePeriodTooLow();\n\n        interestBatchManagers[msg.sender] =\n            InterestBatchManager(_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n\n        troveManager.onRegisterBatchManager(msg.sender, _currentInterestRate, _annualManagementFee);\n    }\n\n    function lowerBatchManagementFee(uint256 _newAnnualManagementFee) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n\n        ITroveManager troveManagerCached = troveManager;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        if (_newAnnualManagementFee >= batch.annualManagementFee) {\n            revert NewFeeNotLower();\n        }\n\n        // Lower batch fee on TM\n        troveManagerCached.onLowerBatchManagerAnnualFee(\n            msg.sender,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            _newAnnualManagementFee\n        );\n\n        // active pool mint\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * _newAnnualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n    }\n\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n        _requireInterestRateInBatchManagerRange(msg.sender, _newAnnualInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        _requireBatchInterestRateChangePeriodPassed(msg.sender, uint256(batch.lastInterestRateAdjTime));\n\n        uint256 newDebt = batch.entireDebtWithoutRedistribution;\n\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            uint256 price = _requireOraclesLive();\n\n            uint256 avgInterestRate = activePoolCached.getNewApproxAvgInterestRateFromTroveChange(batchChange);\n            batchChange.upfrontFee = _calcUpfrontFee(newDebt, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(batchChange.upfrontFee, _maxUpfrontFee);\n\n            newDebt += batchChange.upfrontFee;\n\n            // Recalculate the batch's weighted terms, now taking into account the upfront fee\n            batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n            batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n            // Disallow a premature adjustment if it would result in TCR < CCR\n            // (which includes the case when TCR is already below CCR before the adjustment).\n            uint256 newTCR = _getNewTCRFromTroveChange(batchChange, price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n\n        // Check batch is not empty, and then reinsert in sorted list\n        if (!sortedTroves.isEmptyBatch(BatchId.wrap(msg.sender))) {\n            sortedTroves.reInsertBatch(BatchId.wrap(msg.sender), _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        troveManagerCached.onSetBatchManagerAnnualInterestRate(\n            msg.sender, batch.entireCollWithoutRedistribution, newDebt, _newAnnualInterestRate, batchChange.upfrontFee\n        );\n    }\n\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n        LocalVariables_setInterestBatchManager memory vars;\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidInterestBatchManager(_newBatchManager);\n        _requireIsNotInBatch(_troveId);\n\n        interestBatchManagerOf[_troveId] = _newBatchManager;\n        // Can’t have both individual delegation and batch manager\n        if (interestIndividualDelegateOf[_troveId].account != address(0)) delete interestIndividualDelegateOf[_troveId];\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.newBatch = vars.troveManager.getLatestBatchData(_newBatchManager);\n\n        TroveChange memory newBatchTroveChange;\n        newBatchTroveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        newBatchTroveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        newBatchTroveChange.batchAccruedManagementFee = vars.newBatch.accruedManagementFee;\n        newBatchTroveChange.oldWeightedRecordedDebt =\n            vars.newBatch.weightedRecordedDebt + vars.trove.weightedRecordedDebt;\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // An upfront fee is always charged upon joining a batch to ensure that borrowers can not game the fee logic\n        // and gain free interest rate updates (e.g. if they also manage the batch they joined)\n        // It checks the resulting ICR\n        vars.trove.entireDebt =\n            _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, newBatchTroveChange, _maxUpfrontFee, true);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // Add batch fees\n        newBatchTroveChange.oldWeightedRecordedBatchManagementFee = vars.newBatch.weightedRecordedBatchManagementFee;\n        newBatchTroveChange.newWeightedRecordedBatchManagementFee =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualManagementFee;\n        vars.activePool.mintAggInterestAndAccountForTroveChange(newBatchTroveChange, _newBatchManager);\n\n        vars.troveManager.onSetInterestBatchManager(\n            ITroveManager.OnSetInterestBatchManagerParams({\n                troveId: _troveId,\n                troveColl: vars.trove.entireColl,\n                troveDebt: vars.trove.entireDebt,\n                troveChange: newBatchTroveChange,\n                newBatchAddress: _newBatchManager,\n                newBatchColl: vars.newBatch.entireCollWithoutRedistribution,\n                newBatchDebt: vars.newBatch.entireDebtWithoutRedistribution\n            })\n        );\n\n        vars.sortedTroves.remove(_troveId);\n        vars.sortedTroves.insertIntoBatch(\n            _troveId, BatchId.wrap(_newBatchManager), vars.newBatch.annualInterestRate, _upperHint, _lowerHint\n        );\n    }\n\n    function kickFromBatch(uint256 _troveId, uint256 _upperHint, uint256 _lowerHint) external override {\n        _removeFromBatch({\n            _troveId: _troveId,\n            _newAnnualInterestRate: 0, // ignored when kicking\n            _upperHint: _upperHint,\n            _lowerHint: _lowerHint,\n            _maxUpfrontFee: 0, // will use the batch's existing interest rate, so no fee\n            _kick: true\n        });\n    }\n\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _removeFromBatch({\n            _troveId: _troveId,\n            _newAnnualInterestRate: _newAnnualInterestRate,\n            _upperHint: _upperHint,\n            _lowerHint: _lowerHint,\n            _maxUpfrontFee: _maxUpfrontFee,\n            _kick: false\n        });\n    }\n\n    function _removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee,\n        bool _kick\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_removeFromBatch memory vars;\n        vars.troveManager = troveManager;\n        vars.sortedTroves = sortedTroves;\n\n        if (_kick) {\n            _requireTroveIsOpen(vars.troveManager, _troveId);\n        } else {\n            _requireTroveIsActive(vars.troveManager, _troveId);\n            _requireCallerIsBorrower(_troveId);\n            _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        }\n\n        vars.batchManager = _requireIsInBatch(_troveId);\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.batch = vars.troveManager.getLatestBatchData(vars.batchManager);\n\n        if (_kick) {\n            if (vars.batch.totalDebtShares * MAX_BATCH_SHARES_RATIO >= vars.batch.entireDebtWithoutRedistribution) {\n                revert BatchSharesRatioTooLow();\n            }\n            _newAnnualInterestRate = vars.batch.annualInterestRate;\n        }\n\n        delete interestBatchManagerOf[_troveId];\n\n        if (!_checkTroveIsZombie(vars.troveManager, _troveId)) {\n            // Remove trove from Batch in SortedTroves\n            vars.sortedTroves.removeFromBatch(_troveId);\n            // Reinsert as single trove\n            vars.sortedTroves.insert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        vars.batchFutureDebt =\n            vars.batch.entireDebtWithoutRedistribution - (vars.trove.entireDebt - vars.trove.redistBoldDebtGain);\n\n        vars.batchChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        vars.batchChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        vars.batchChange.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.batchChange.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.batchChange.newWeightedRecordedDebt =\n            vars.batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;\n\n        // Apply upfront fee on premature adjustments. It checks the resulting ICR\n        if (\n            vars.batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, vars.batchChange, _maxUpfrontFee, false);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        vars.batchChange.newWeightedRecordedDebt =\n            vars.batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;\n        // Add batch fees\n        vars.batchChange.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.batchChange.newWeightedRecordedBatchManagementFee = vars.batchFutureDebt * vars.batch.annualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(vars.batchChange, vars.batchManager);\n\n        vars.troveManager.onRemoveFromBatch(\n            _troveId,\n            vars.trove.entireColl,\n            vars.trove.entireDebt,\n            vars.batchChange,\n            vars.batchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution,\n            _newAnnualInterestRate\n        );\n    }\n\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        address oldBatchManager = _requireIsInBatch(_troveId);\n        _requireNewInterestBatchManager(oldBatchManager, _newBatchManager);\n\n        LatestBatchData memory oldBatch = troveManager.getLatestBatchData(oldBatchManager);\n\n        removeFromBatch(_troveId, oldBatch.annualInterestRate, _removeUpperHint, _removeLowerHint, 0);\n        setInterestBatchManager(_troveId, _newBatchManager, _addUpperHint, _addLowerHint, _maxUpfrontFee);\n    }\n\n    function _applyUpfrontFee(\n        uint256 _troveEntireColl,\n        uint256 _troveEntireDebt,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        uint256 price = _requireOraclesLive();\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n        _troveChange.upfrontFee = _calcUpfrontFee(_troveEntireDebt, avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n        _troveEntireDebt += _troveChange.upfrontFee;\n\n        // ICR is based on the requested Bold amount + upfront fee.\n        uint256 newICR = LiquityMath._computeCR(_troveEntireColl, _troveEntireDebt, price);\n        if (_isTroveInBatch) {\n            _requireICRisAboveMCRPlusBCR(newICR);\n        } else {\n            _requireICRisAboveMCR(newICR);\n        }\n\n        // Disallow a premature adjustment if it would result in TCR < CCR\n        // (which includes the case when TCR is already below CCR before the adjustment).\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        return _troveEntireDebt;\n    }\n\n    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {\n        return _calcInterest(_debt * _avgInterestRate, UPFRONT_INTEREST_PERIOD);\n    }\n\n    // Call from TM to clean state here\n    function onLiquidateTrove(uint256 _troveId) external {\n        _requireCallerIsTroveManager();\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function _wipeTroveMappings(uint256 _troveId) internal {\n        delete interestIndividualDelegateOf[_troveId];\n        delete interestBatchManagerOf[_troveId];\n        _wipeAddRemoveManagers(_troveId);\n    }\n\n    /**\n     * Claim remaining collateral from a liquidation with ICR exceeding the liquidation penalty\n     */\n    function claimCollateral() external override {\n        // send coll from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    function shutdown() external {\n        if (hasBeenShutDown) revert IsShutDown();\n\n        uint256 totalColl = getEntireBranchColl();\n        uint256 totalDebt = getEntireBranchDebt();\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        // If the oracle failed, the above call to PriceFeed will have shut this branch down\n        if (newOracleFailureDetected) return;\n\n        // Otherwise, proceed with the TCR check:\n        uint256 TCR = LiquityMath._computeCR(totalColl, totalDebt, price);\n        if (TCR >= SCR) revert TCRNotBelowSCR();\n\n        _applyShutdown();\n\n        emit ShutDown(TCR);\n    }\n\n    // Not technically a \"Borrower op\", but seems best placed here given current shutdown logic.\n    function shutdownFromOracleFailure() external {\n        _requireCallerIsPriceFeed();\n\n        // No-op rather than revert here, so that the outer function call which fetches the price does not revert\n        // if the system is already shut down.\n        if (hasBeenShutDown) return;\n\n        _applyShutdown();\n    }\n\n    function _applyShutdown() internal {\n        activePool.mintAggInterest();\n        hasBeenShutDown = true;\n        troveManager.shutdown();\n    }\n\n    // --- Helper functions ---\n\n    function _reInsertIntoSortedTroves(\n        uint256 _troveId,\n        uint256 _troveAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        address _batchManager,\n        uint256 _batchAnnualInterestRate\n    ) internal {\n        // If it was in a batch, we need to put it back, otherwise we insert it normally\n        if (_batchManager == address(0)) {\n            sortedTroves.insert(_troveId, _troveAnnualInterestRate, _upperHint, _lowerHint);\n        } else {\n            sortedTroves.insertIntoBatch(\n                _troveId, BatchId.wrap(_batchManager), _batchAnnualInterestRate, _upperHint, _lowerHint\n            );\n        }\n    }\n\n    // This function mints the BOLD corresponding to the borrower's chosen debt increase\n    // (it does not mint the accrued interest).\n    function _moveTokensFromAdjustment(\n        address withdrawalReceiver,\n        TroveChange memory _troveChange,\n        IBoldToken _boldToken,\n        IActivePool _activePool\n    ) internal {\n        if (_troveChange.debtIncrease > 0) {\n            _boldToken.mint(withdrawalReceiver, _troveChange.debtIncrease);\n        } else if (_troveChange.debtDecrease > 0) {\n            _boldToken.burn(msg.sender, _troveChange.debtDecrease);\n        }\n\n        if (_troveChange.collIncrease > 0) {\n            // Pull coll tokens from sender and move them to the Active Pool\n            _pullCollAndSendToActivePool(_activePool, _troveChange.collIncrease);\n        } else if (_troveChange.collDecrease > 0) {\n            // Pull Coll from Active Pool and decrease its recorded Coll balance\n            _activePool.sendColl(withdrawalReceiver, _troveChange.collDecrease);\n        }\n    }\n\n    function _pullCollAndSendToActivePool(IActivePool _activePool, uint256 _amount) internal {\n        // Send Coll tokens from sender to active pool\n        collToken.safeTransferFrom(msg.sender, address(_activePool), _amount);\n        // Make sure Active Pool accountancy is right\n        _activePool.accountForReceivedColl(_amount);\n    }\n\n    function checkBatchManagerExists(address _batchManager) external view returns (bool) {\n        return interestBatchManagers[_batchManager].maxInterestRate > 0;\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireIsNotShutDown() internal view {\n        if (hasBeenShutDown) {\n            revert IsShutDown();\n        }\n    }\n\n    function _requireNonZeroAdjustment(TroveChange memory _troveChange) internal pure {\n        if (\n            _troveChange.collIncrease == 0 && _troveChange.collDecrease == 0 && _troveChange.debtIncrease == 0\n                && _troveChange.debtDecrease == 0\n        ) {\n            revert ZeroAdjustment();\n        }\n    }\n\n    function _requireSenderIsOwnerOrInterestManager(uint256 _troveId) internal view {\n        address owner = troveNFT.ownerOf(_troveId);\n        if (msg.sender != owner && msg.sender != interestIndividualDelegateOf[_troveId].account) {\n            revert NotOwnerNorInterestManager();\n        }\n    }\n\n    function _requireValidDelegateAdustment(\n        uint256 _troveId,\n        uint256 _lastInterestRateAdjTime,\n        uint256 _annualInterestRate\n    ) internal view {\n        InterestIndividualDelegate memory individualDelegate = interestIndividualDelegateOf[_troveId];\n        // We have previously checked that sender is either owner or delegate\n        // If it’s owner, this restriction doesn’t apply\n        if (individualDelegate.account == msg.sender) {\n            _requireInterestRateInRange(\n                _annualInterestRate, individualDelegate.minInterestRate, individualDelegate.maxInterestRate\n            );\n            _requireDelegateInterestRateChangePeriodPassed(\n                _lastInterestRateAdjTime, individualDelegate.minInterestRateChangePeriod\n            );\n        }\n    }\n\n    function _requireIsNotInBatch(uint256 _troveId) internal view {\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            revert TroveInBatch();\n        }\n    }\n\n    function _requireIsInBatch(uint256 _troveId) internal view returns (address) {\n        address batchManager = interestBatchManagerOf[_troveId];\n        if (batchManager == address(0)) {\n            revert TroveNotInBatch();\n        }\n\n        return batchManager;\n    }\n\n    function _requireTroveDoesNotExists(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.nonExistent) {\n            revert TroveExists();\n        }\n    }\n\n    function _requireTroveIsOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active && status != ITroveManager.Status.zombie) {\n            revert TroveNotOpen();\n        }\n    }\n\n    function _requireTroveIsActive(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active) {\n            revert TroveNotActive();\n        }\n    }\n\n    function _requireTroveIsZombie(ITroveManager _troveManager, uint256 _troveId) internal view {\n        if (!_checkTroveIsZombie(_troveManager, _troveId)) {\n            revert TroveNotZombie();\n        }\n    }\n\n    function _checkTroveIsZombie(ITroveManager _troveManager, uint256 _troveId) internal view returns (bool) {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        return status == ITroveManager.Status.zombie;\n    }\n\n    function _requireNonZeroDebt(uint256 _troveDebt) internal pure {\n        if (_troveDebt == 0) {\n            revert TroveWithZeroDebt();\n        }\n    }\n\n    function _requireUserAcceptsUpfrontFee(uint256 _fee, uint256 _maxFee) internal pure {\n        if (_fee > _maxFee) {\n            revert UpfrontFeeTooHigh();\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        TroveChange memory _troveChange,\n        LocalVariables_adjustTrove memory _vars,\n        bool _isTroveInBatch\n    ) internal view {\n        /*\n        * Below Critical Threshold, it is not permitted:\n        *\n        * - Borrowing, unless it brings TCR up to CCR again\n        * - Collateral withdrawal except accompanied by a debt repayment of at least the same value\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The adjustment won't pull the TCR below CCR\n        *\n        * In Both cases:\n        * - The new ICR is above MCR, or MCR+BCR if a batched trove\n        */\n\n        if (_isTroveInBatch) {\n            _requireICRisAboveMCRPlusBCR(_vars.newICR);\n        } else {\n            _requireICRisAboveMCR(_vars.newICR);\n        }\n\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, _vars.price);\n        if (_vars.isBelowCriticalThreshold) {\n            _requireNoBorrowingUnlessNewTCRisAboveCCR(_troveChange.debtIncrease, newTCR);\n            _requireDebtRepaymentGeCollWithdrawal(_troveChange, _vars.price);\n        } else {\n            // if Normal Mode\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal view {\n        if (_newICR < MCR) {\n            revert ICRBelowMCR();\n        }\n    }\n\n    function _requireICRisAboveMCRPlusBCR(uint256 _newICR) internal view {\n        if (_newICR < MCR + BCR) {\n            revert ICRBelowMCRPlusBCR();\n        }\n    }\n\n    function _requireNoBorrowingUnlessNewTCRisAboveCCR(uint256 _debtIncrease, uint256 _newTCR) internal view {\n        if (_debtIncrease > 0 && _newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireDebtRepaymentGeCollWithdrawal(TroveChange memory _troveChange, uint256 _price) internal pure {\n        if ((_troveChange.debtDecrease * DECIMAL_PRECISION < _troveChange.collDecrease * _price)) {\n            revert RepaymentNotMatchingCollWithdrawal();\n        }\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal view {\n        if (_newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireAtLeastMinDebt(uint256 _debt) internal pure {\n        if (_debt < MIN_DEBT) {\n            revert DebtBelowMin();\n        }\n    }\n\n    function _requireValidCollWithdrawal(uint256 _currentColl, uint256 _collWithdrawal) internal pure {\n        if (_collWithdrawal > _currentColl) {\n            revert CollWithdrawalTooHigh();\n        }\n    }\n\n    function _requireSufficientBoldBalance(IBoldToken _boldToken, address _borrower, uint256 _debtRepayment)\n        internal\n        view\n    {\n        if (_boldToken.balanceOf(_borrower) < _debtRepayment) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    function _requireValidAnnualInterestRate(uint256 _annualInterestRate) internal pure {\n        if (_annualInterestRate < MIN_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooLow();\n        }\n        if (_annualInterestRate > MAX_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooHigh();\n        }\n    }\n\n    function _requireAnnualInterestRateIsNew(uint256 _oldAnnualInterestRate, uint256 _newAnnualInterestRate)\n        internal\n        pure\n    {\n        if (_oldAnnualInterestRate == _newAnnualInterestRate) {\n            revert InterestRateNotNew();\n        }\n    }\n\n    function _requireOrderedRange(uint256 _minInterestRate, uint256 _maxInterestRate) internal pure {\n        if (_minInterestRate >= _maxInterestRate) revert MinGeMax();\n    }\n\n    function _requireInterestRateInBatchManagerRange(address _interestBatchManagerAddress, uint256 _annualInterestRate)\n        internal\n        view\n    {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        _requireInterestRateInRange(\n            _annualInterestRate, interestBatchManager.minInterestRate, interestBatchManager.maxInterestRate\n        );\n    }\n\n    function _requireInterestRateInRange(\n        uint256 _annualInterestRate,\n        uint256 _minInterestRate,\n        uint256 _maxInterestRate\n    ) internal pure {\n        if (_minInterestRate > _annualInterestRate || _annualInterestRate > _maxInterestRate) {\n            revert InterestNotInRange();\n        }\n    }\n\n    function _requireBatchInterestRateChangePeriodPassed(\n        address _interestBatchManagerAddress,\n        uint256 _lastInterestRateAdjTime\n    ) internal view {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        if (block.timestamp < _lastInterestRateAdjTime + uint256(interestBatchManager.minInterestRateChangePeriod)) {\n            revert BatchInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireDelegateInterestRateChangePeriodPassed(\n        uint256 _lastInterestRateAdjTime,\n        uint256 _minInterestRateChangePeriod\n    ) internal view {\n        if (block.timestamp < _lastInterestRateAdjTime + _minInterestRateChangePeriod) {\n            revert DelegateInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireValidInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate == 0) {\n            revert InvalidInterestBatchManager();\n        }\n    }\n\n    function _requireNonExistentInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate > 0) {\n            revert BatchManagerExists();\n        }\n    }\n\n    function _requireNewInterestBatchManager(address _oldBatchManagerAddress, address _newBatchManagerAddress)\n        internal\n        pure\n    {\n        if (_oldBatchManagerAddress == _newBatchManagerAddress) {\n            revert BatchManagerNotNew();\n        }\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        if (msg.sender != address(troveManager)) {\n            revert CallerNotTroveManager();\n        }\n    }\n\n    function _requireCallerIsPriceFeed() internal view {\n        if (msg.sender != address(priceFeed)) {\n            revert CallerNotPriceFeed();\n        }\n    }\n\n    function _requireOraclesLive() internal returns (uint256) {\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        if (newOracleFailureDetected) {\n            revert NewOracleFailureDetected();\n        }\n\n        return price;\n    }\n\n    // --- ICR and TCR getters ---\n\n    function _getNewTCRFromTroveChange(TroveChange memory _troveChange, uint256 _price)\n        internal\n        view\n        returns (uint256 newTCR)\n    {\n        uint256 totalColl = getEntireBranchColl();\n        totalColl += _troveChange.collIncrease;\n        totalColl -= _troveChange.collDecrease;\n\n        uint256 totalDebt = getEntireBranchDebt();\n        totalDebt += _troveChange.debtIncrease;\n        totalDebt += _troveChange.upfrontFee;\n        totalDebt -= _troveChange.debtDecrease;\n\n        newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n    }\n}\n",
        "IActivePool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IInterestRouter.sol\";\nimport \"./IBoldRewardsReceiver.sol\";\nimport \"../Types/TroveChange.sol\";\n\ninterface IActivePool {\n    function defaultPoolAddress() external view returns (address);\n    function borrowerOperationsAddress() external view returns (address);\n    function troveManagerAddress() external view returns (address);\n    function interestRouter() external view returns (IInterestRouter);\n    // We avoid IStabilityPool here in order to prevent creating a dependency cycle that would break flattening\n    function stabilityPool() external view returns (IBoldRewardsReceiver);\n\n    function getCollBalance() external view returns (uint256);\n    function getBoldDebt() external view returns (uint256);\n    function lastAggUpdateTime() external view returns (uint256);\n    function aggRecordedDebt() external view returns (uint256);\n    function aggWeightedDebtSum() external view returns (uint256);\n    function aggBatchManagementFees() external view returns (uint256);\n    function aggWeightedBatchManagementFeeSum() external view returns (uint256);\n    function calcPendingAggInterest() external view returns (uint256);\n    function calcPendingSPYield() external view returns (uint256);\n    function calcPendingAggBatchManagementFee() external view returns (uint256);\n    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)\n        external\n        view\n        returns (uint256);\n\n    function mintAggInterest() external;\n    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchManager)\n        external;\n    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)\n        external;\n\n    function setShutdownFlag() external;\n    function hasBeenShutDown() external view returns (bool);\n    function shutdownTime() external view returns (uint256);\n\n    function sendColl(address _account, uint256 _amount) external;\n    function sendCollToDefaultPool(uint256 _amount) external;\n    function receiveColl(uint256 _amount) external;\n    function accountForReceivedColl(uint256 _amount) external;\n}\n",
        "IExchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IExchange {\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external;\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256);\n}\n",
        "CompositePriceFeed.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"../Dependencies/LiquityMath.sol\";\nimport \"./MainnetPriceFeedBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\n// The CompositePriceFeed is used for feeds that incorporate both a market price oracle (e.g. STETH-USD, or RETH-ETH)\n// and an LST canonical rate (e.g. WSTETH:STETH, or RETH:ETH).\nabstract contract CompositePriceFeed is MainnetPriceFeedBase {\n    address public rateProviderAddress;\n\n    constructor(\n        address _ethUsdOracleAddress,\n        address _rateProviderAddress,\n        uint256 _ethUsdStalenessThreshold,\n        address _borrowerOperationsAddress\n    ) MainnetPriceFeedBase(_ethUsdOracleAddress, _ethUsdStalenessThreshold, _borrowerOperationsAddress) {\n        // Store rate provider\n        rateProviderAddress = _rateProviderAddress;\n    }\n\n    // Returns:\n    // - The price, using the current price calculation\n    // - A bool that is true if:\n    // --- a) the system was not shut down prior to this call, and\n    // --- b) an oracle or exchange rate contract failed during this call.\n    function fetchPrice() public returns (uint256, bool) {\n        // If branch is live and the primary oracle setup has been working, try to use it\n        if (priceSource == PriceSource.primary) return _fetchPricePrimary(false);\n\n        return _fetchPriceDuringShutdown();\n    }\n\n    function fetchRedemptionPrice() external returns (uint256, bool) {\n        // If branch is live and the primary oracle setup has been working, try to use it\n        if (priceSource == PriceSource.primary) return _fetchPricePrimary(true);\n\n        return _fetchPriceDuringShutdown();\n    }\n\n    function _shutDownAndSwitchToETHUSDxCanonical(address _failedOracleAddr, uint256 _ethUsdPrice)\n        internal\n        returns (uint256)\n    {\n        // Shut down the branch\n        borrowerOperations.shutdownFromOracleFailure();\n\n        priceSource = PriceSource.ETHUSDxCanonical;\n\n        emit ShutDownFromOracleFailure(_failedOracleAddr);\n        return _fetchPriceETHUSDxCanonical(_ethUsdPrice);\n    }\n\n    function _fetchPriceDuringShutdown() internal returns (uint256, bool) {\n        // When branch is already shut down and using ETH-USD * canonical_rate, try to use that\n        if (priceSource == PriceSource.ETHUSDxCanonical) {\n            (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);\n            //... but if the ETH-USD oracle *also* fails here, switch to using the lastGoodPrice\n            if (ethUsdOracleDown) {\n                // No need to shut down, since branch already is shut down\n                priceSource = PriceSource.lastGoodPrice;\n                return (lastGoodPrice, false);\n            } else {\n                return (_fetchPriceETHUSDxCanonical(ethUsdPrice), false);\n            }\n        }\n\n        // Otherwise when branch is shut down and already using the lastGoodPrice, continue with it\n        assert(priceSource == PriceSource.lastGoodPrice);\n        return (lastGoodPrice, false);\n    }\n\n    // Only called if the primary LST oracle has failed, branch has shut down,\n    // and we've switched to using: ETH-USD * canonical_rate.\n    function _fetchPriceETHUSDxCanonical(uint256 _ethUsdPrice) internal returns (uint256) {\n        assert(priceSource == PriceSource.ETHUSDxCanonical);\n        // Get the underlying_per_LST canonical rate directly from the LST contract\n        (uint256 lstRate, bool exchangeRateIsDown) = _getCanonicalRate();\n\n        // If the exchange rate contract is down, switch to (and return) lastGoodPrice.\n        if (exchangeRateIsDown) {\n            priceSource = PriceSource.lastGoodPrice;\n            return lastGoodPrice;\n        }\n\n        // Calculate the canonical LST-USD price: USD_per_LST = USD_per_ETH * underlying_per_LST\n        uint256 lstUsdCanonicalPrice = _ethUsdPrice * lstRate / 1e18;\n\n        uint256 bestPrice = LiquityMath._min(lstUsdCanonicalPrice, lastGoodPrice);\n\n        lastGoodPrice = bestPrice;\n\n        return bestPrice;\n    }\n\n    function _withinDeviationThreshold(uint256 _priceToCheck, uint256 _referencePrice, uint256 _deviationThreshold)\n        internal\n        pure\n        returns (bool)\n    {\n        // Calculate the price deviation of the oracle market price relative to the canonical price\n        uint256 max = _referencePrice * (DECIMAL_PRECISION + _deviationThreshold) / 1e18;\n        uint256 min = _referencePrice * (DECIMAL_PRECISION - _deviationThreshold) / 1e18;\n\n        return _priceToCheck >= min && _priceToCheck <= max;\n    }\n\n    // An individual Pricefeed instance implements _fetchPricePrimary according to the data sources it uses. Returns:\n    // - The price\n    // - A bool indicating whether a new oracle failure or exchange rate failure was detected in the call\n    function _fetchPricePrimary(bool _isRedemption) internal virtual returns (uint256, bool);\n\n    // Returns the LST exchange rate and a bool indicating whether the exchange rate failed to return a valid rate.\n    // Implementation depends on the specific LST.\n    function _getCanonicalRate() internal view virtual returns (uint256, bool);\n}\n",
        "IBoldRewardsReceiver.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBoldRewardsReceiver {\n    function triggerBoldRewards(uint256 _boldYield) external;\n}\n",
        "ICurveStableswapNGPool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICurveStableswapNGPool {\n    function add_liquidity(uint256[] memory amounts, uint256 min_mint_amount) external returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256 output);\n    function get_dx(int128 i, int128 j, uint256 dy) external view returns (uint256 dx);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\n}\n",
        "TroveManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveEvents.sol\";\nimport \"./Interfaces/ITroveNFT.sol\";\nimport \"./Interfaces/ICollateralRegistry.sol\";\nimport \"./Interfaces/IWETH.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\ncontract TroveManager is LiquityBase, ITroveManager, ITroveEvents {\n    // --- Connected contract declarations ---\n\n    ITroveNFT public troveNFT;\n    IBorrowerOperations public borrowerOperations;\n    IStabilityPool public stabilityPool;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their interest rate\n    ISortedTroves public sortedTroves;\n    ICollateralRegistry internal collateralRegistry;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 internal immutable MCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 internal immutable SCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 internal immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 internal immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    // --- Data structures ---\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n    }\n\n    mapping(uint256 => Trove) public Troves;\n\n    // Store the necessary data for an interest batch manager. We treat each batch as a “big trove”.\n    // Each trove has a share of the debt of the global batch. Collateral is stored per trove (as CRs are different)\n    // Still the total amount of batch collateral is stored for informational purposes\n    struct Batch {\n        uint256 debt;\n        uint256 coll;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        uint256 annualManagementFee;\n        uint256 totalDebtShares;\n    }\n\n    mapping(address => Batch) internal batches;\n\n    uint256 internal totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 internal totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 internal totalCollateralSnapshot;\n\n    /*\n    * L_coll and L_boldDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An Coll gain of ( stake * [L_coll - L_coll(0)] )\n    * A boldDebt increase  of ( stake * [L_boldDebt - L_boldDebt(0)] )\n    *\n    * Where L_coll(0) and L_boldDebt(0) are snapshots of L_coll and L_boldDebt for the active Trove taken at the instant the stake was made\n    */\n    uint256 internal L_coll;\n    uint256 internal L_boldDebt;\n\n    // Map active troves to their RewardSnapshot\n    mapping(uint256 => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the Coll and Bold snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 coll;\n        uint256 boldDebt;\n    }\n\n    // Array of all active trove addresses - used to compute an approximate hint off-chain, for the sorted list insertion\n    uint256[] internal TroveIds;\n    // Array of all batch managers - used to fetch them off-chain\n    address[] public batchIds;\n\n    uint256 public lastZombieTroveId;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 internal lastCollError_Redistribution;\n    uint256 internal lastBoldDebtError_Redistribution;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LiquidationValues {\n        uint256 collGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n        uint256 ETHGasCompensation;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedeemCollateralValues {\n        uint256 totalCollFee;\n        uint256 remainingBold;\n        address lastBatchUpdatedInterest;\n        uint256 nextUserToCheck;\n    }\n\n    struct SingleRedemptionValues {\n        uint256 troveId;\n        address batchAddress;\n        uint256 boldLot;\n        uint256 collLot;\n        uint256 collFee;\n        uint256 appliedRedistBoldDebtGain;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n        uint256 newStake;\n        bool isZombieTrove;\n        LatestTroveData trove;\n        LatestBatchData batch;\n    }\n\n    // --- Errors ---\n\n    error EmptyData();\n    error NothingToLiquidate();\n    error CallerNotBorrowerOperations();\n    error CallerNotCollateralRegistry();\n    error OnlyOneTroveLeft();\n    error NotShutDown();\n    error ZeroAmount();\n    error NotEnoughBoldBalance();\n    error MinCollNotReached(uint256 _coll);\n    error BatchSharesRatioTooHigh();\n\n    // --- Events ---\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        CCR = _addressesRegistry.CCR();\n        MCR = _addressesRegistry.MCR();\n        SCR = _addressesRegistry.SCR();\n        LIQUIDATION_PENALTY_SP = _addressesRegistry.LIQUIDATION_PENALTY_SP();\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _addressesRegistry.LIQUIDATION_PENALTY_REDISTRIBUTION();\n\n        troveNFT = _addressesRegistry.troveNFT();\n        borrowerOperations = _addressesRegistry.borrowerOperations();\n        stabilityPool = _addressesRegistry.stabilityPool();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        boldToken = _addressesRegistry.boldToken();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        WETH = _addressesRegistry.WETH();\n        collateralRegistry = _addressesRegistry.collateralRegistry();\n\n        emit TroveNFTAddressChanged(address(troveNFT));\n        emit BorrowerOperationsAddressChanged(address(borrowerOperations));\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit BoldTokenAddressChanged(address(boldToken));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit CollateralRegistryAddressChanged(address(collateralRegistry));\n    }\n\n    // --- Getters ---\n\n    function getTroveIdsCount() external view override returns (uint256) {\n        return TroveIds.length;\n    }\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view override returns (uint256) {\n        return TroveIds[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove\n    function _liquidate(\n        IDefaultPool _defaultPool,\n        uint256 _troveId,\n        uint256 _boldInSPForOffsets,\n        uint256 _price,\n        LatestTroveData memory trove,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        address owner = troveNFT.ownerOf(_troveId);\n\n        _getLatestTroveData(_troveId, trove);\n        address batchAddress = _getBatchManager(_troveId);\n        bool isTroveInBatch = batchAddress != address(0);\n        LatestBatchData memory batch;\n        if (isTroveInBatch) _getLatestBatchData(batchAddress, batch);\n\n        _movePendingTroveRewardsToActivePool(_defaultPool, trove.redistBoldDebtGain, trove.redistCollGain);\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.collGasCompensation,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute,\n            singleLiquidation.collSurplus\n        ) = _getOffsetAndRedistributionVals(trove.entireDebt, trove.entireColl, _boldInSPForOffsets, _price);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        _closeTrove(\n            _troveId,\n            troveChange,\n            batchAddress,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            Status.closedByLiquidation\n        );\n\n        if (isTroveInBatch) {\n            // the parenthesis in the old weighted term equals `recordedDebt + accruedInterest + accruedBatchManagementFee`\n            // We want to capture last 2 ones, as the batch part only has recorded debt. The recorded debt of the trove is duplicated there,\n            // but it needs to be, because it’s also included in `entireDebtWithoutRedistribution` in the next line.\n            // So in the end we add it once and subtract it twice, which is the same as subtracting it once.\n            singleLiquidation.oldWeightedRecordedDebt =\n                batch.weightedRecordedDebt + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualInterestRate;\n            singleLiquidation.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n            // Mint batch management fee\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee\n                + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, batchAddress);\n        } else {\n            singleLiquidation.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n        }\n\n        // Difference between liquidation penalty and liquidation threshold\n        if (singleLiquidation.collSurplus > 0) {\n            collSurplusPool.accountSurplus(owner, singleLiquidation.collSurplus);\n        }\n\n        // Wipe out state in BO\n        borrowerOperations.onLiquidateTrove(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.liquidate,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(trove.entireDebt),\n            _collIncreaseFromRedist: trove.redistCollGain,\n            _collChangeFromOperation: -int256(trove.entireColl)\n        });\n\n        if (isTroveInBatch) {\n            emit BatchUpdated({\n                _interestBatchManager: batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[batchAddress].debt,\n                _coll: batches[batchAddress].coll,\n                _annualInterestRate: batch.annualInterestRate,\n                _annualManagementFee: batch.annualManagementFee,\n                _totalDebtShares: batches[batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n    }\n\n    // Return the amount of Coll to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint256 _coll) internal pure returns (uint256) {\n        // _entireDebt should never be zero, but we add the condition defensively to avoid an unexpected revert\n        return LiquityMath._min(_coll / COLL_GAS_COMPENSATION_DIVISOR, COLL_GAS_COMPENSATION_CAP);\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        uint256 _entireTroveColl,\n        uint256 _boldInSPForOffsets,\n        uint256 _price\n    )\n        internal\n        view\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 collGasCompensation,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute,\n            uint256 collSurplus\n        )\n    {\n        uint256 collSPPortion;\n        /*\n         * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n         * between all active troves.\n         *\n         *  If the trove's debt is larger than the deposited Bold in the Stability Pool:\n         *\n         *  - Offset an amount of the trove's debt equal to the Bold in the Stability Pool\n         *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n         *\n         */\n        if (_boldInSPForOffsets > 0) {\n            debtToOffset = LiquityMath._min(_entireTroveDebt, _boldInSPForOffsets);\n            collSPPortion = _entireTroveColl * debtToOffset / _entireTroveDebt;\n\n            collGasCompensation = _getCollGasCompensation(collSPPortion);\n            uint256 collToOffset = collSPPortion - collGasCompensation;\n\n            (collToSendToSP, collSurplus) =\n                _getCollPenaltyAndSurplus(collToOffset, debtToOffset, LIQUIDATION_PENALTY_SP, _price);\n        }\n\n        // Redistribution\n        debtToRedistribute = _entireTroveDebt - debtToOffset;\n        if (debtToRedistribute > 0) {\n            uint256 collRedistributionPortion = _entireTroveColl - collSPPortion;\n            if (collRedistributionPortion > 0) {\n                (collToRedistribute, collSurplus) = _getCollPenaltyAndSurplus(\n                    collRedistributionPortion + collSurplus, // Coll surplus from offset can be eaten up by red. penalty\n                    debtToRedistribute,\n                    LIQUIDATION_PENALTY_REDISTRIBUTION, // _penaltyRatio\n                    _price\n                );\n            }\n        }\n        // assert(_collToLiquidate == collToSendToSP + collToRedistribute + collSurplus);\n    }\n\n    function _getCollPenaltyAndSurplus(\n        uint256 _collToLiquidate,\n        uint256 _debtToLiquidate,\n        uint256 _penaltyRatio,\n        uint256 _price\n    ) internal pure returns (uint256 seizedColl, uint256 collSurplus) {\n        uint256 maxSeizedColl = _debtToLiquidate * (DECIMAL_PRECISION + _penaltyRatio) / _price;\n        if (_collToLiquidate > maxSeizedColl) {\n            seizedColl = maxSeizedColl;\n            collSurplus = _collToLiquidate - maxSeizedColl;\n        } else {\n            seizedColl = _collToLiquidate;\n            collSurplus = 0;\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(uint256[] memory _troveArray) public override {\n        if (_troveArray.length == 0) {\n            revert EmptyData();\n        }\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        TroveChange memory troveChange;\n        LiquidationValues memory totals;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n\n        // - If the SP has total deposits >= 1e18, we leave 1e18 in it untouched.\n        // - If it has 0 < x < 1e18 total deposits, we leave x in it.\n        uint256 totalBoldDeposits = stabilityPoolCached.getTotalBoldDeposits();\n        uint256 boldToLeaveInSP = LiquityMath._min(MIN_BOLD_IN_SP, totalBoldDeposits);\n        uint256 boldInSPForOffsets = totalBoldDeposits - boldToLeaveInSP;\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        _batchLiquidateTroves(defaultPoolCached, price, boldInSPForOffsets, _troveArray, totals, troveChange);\n\n        if (troveChange.debtDecrease == 0) {\n            revert NothingToLiquidate();\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        // Move liquidated Coll and Bold to the appropriate pools\n        if (totals.debtToOffset > 0 || totals.collToSendToSP > 0) {\n            stabilityPoolCached.offset(totals.debtToOffset, totals.collToSendToSP);\n        }\n        // we check amount is not zero inside\n        _redistributeDebtAndColl(\n            activePoolCached, defaultPoolCached, totals.debtToRedistribute, totals.collToRedistribute\n        );\n        if (totals.collSurplus > 0) {\n            activePoolCached.sendColl(address(collSurplusPool), totals.collSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.collGasCompensation);\n\n        emit Liquidation(\n            totals.debtToOffset,\n            totals.debtToRedistribute,\n            totals.ETHGasCompensation,\n            totals.collGasCompensation,\n            totals.collToSendToSP,\n            totals.collToRedistribute,\n            totals.collSurplus,\n            L_coll,\n            L_boldDebt,\n            price\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, totals.ETHGasCompensation, totals.collGasCompensation);\n    }\n\n    function _isActiveOrZombie(Status _status) internal pure returns (bool) {\n        return _status == Status.active || _status == Status.zombie;\n    }\n\n    function _batchLiquidateTroves(\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _boldInSPForOffsets,\n        uint256[] memory _troveArray,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal {\n        uint256 remainingBoldInSPForOffsets = _boldInSPForOffsets;\n\n        for (uint256 i = 0; i < _troveArray.length; i++) {\n            uint256 troveId = _troveArray[i];\n\n            // Skip non-liquidatable troves\n            if (!_isActiveOrZombie(Troves[troveId].status)) continue;\n\n            uint256 ICR = getCurrentICR(troveId, _price);\n\n            if (ICR < MCR) {\n                LiquidationValues memory singleLiquidation;\n                LatestTroveData memory trove;\n\n                _liquidate(_defaultPool, troveId, remainingBoldInSPForOffsets, _price, trove, singleLiquidation);\n                remainingBoldInSPForOffsets -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                _addLiquidationValuesToTotals(trove, singleLiquidation, totals, troveChange);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    // Adds all values from `singleLiquidation` to their respective totals in `totals` in-place\n    function _addLiquidationValuesToTotals(\n        LatestTroveData memory _trove,\n        LiquidationValues memory _singleLiquidation,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal pure {\n        // Tally all the values with their respective running totals\n        totals.collGasCompensation += _singleLiquidation.collGasCompensation;\n        totals.ETHGasCompensation += ETH_GAS_COMPENSATION;\n        troveChange.debtDecrease += _trove.entireDebt;\n        troveChange.collDecrease += _trove.entireColl;\n        troveChange.appliedRedistBoldDebtGain += _trove.redistBoldDebtGain;\n        troveChange.oldWeightedRecordedDebt += _singleLiquidation.oldWeightedRecordedDebt;\n        troveChange.newWeightedRecordedDebt += _singleLiquidation.newWeightedRecordedDebt;\n        totals.debtToOffset += _singleLiquidation.debtToOffset;\n        totals.collToSendToSP += _singleLiquidation.collToSendToSP;\n        totals.debtToRedistribute += _singleLiquidation.debtToRedistribute;\n        totals.collToRedistribute += _singleLiquidation.collToRedistribute;\n        totals.collSurplus += _singleLiquidation.collSurplus;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _eth, uint256 _coll) internal {\n        if (_eth > 0) {\n            WETH.transferFrom(gasPoolAddress, _liquidator, _eth);\n        }\n\n        if (_coll > 0) {\n            _activePool.sendColl(_liquidator, _coll);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IDefaultPool _defaultPool, uint256 _bold, uint256 _coll) internal {\n        if (_bold > 0) {\n            _defaultPool.decreaseBoldDebt(_bold);\n        }\n\n        if (_coll > 0) {\n            _defaultPool.sendCollToActivePool(_coll);\n        }\n    }\n\n    // --- Redemption functions ---\n\n    function _applySingleRedemption(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        // Decrease the debt and collateral of the current Trove according to the Bold lot and corresponding ETH to send\n        uint256 newDebt = _singleRedemption.trove.entireDebt - _singleRedemption.boldLot;\n        uint256 newColl = _singleRedemption.trove.entireColl - _singleRedemption.collLot;\n\n        _singleRedemption.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n\n        if (_isTroveInBatch) {\n            _getLatestBatchData(_singleRedemption.batchAddress, _singleRedemption.batch);\n            // We know boldLot <= trove entire debt, so this subtraction is safe\n            uint256 newAmountForWeightedDebt = _singleRedemption.batch.entireDebtWithoutRedistribution\n                + _singleRedemption.trove.redistBoldDebtGain - _singleRedemption.boldLot;\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.batch.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualInterestRate;\n\n            TroveChange memory troveChange;\n            troveChange.debtDecrease = _singleRedemption.boldLot;\n            troveChange.collDecrease = _singleRedemption.collLot;\n            troveChange.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n            troveChange.appliedRedistCollGain = _singleRedemption.trove.redistCollGain;\n            // batchAccruedManagementFee is handled in the outer function\n            troveChange.oldWeightedRecordedBatchManagementFee =\n                _singleRedemption.batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualManagementFee;\n\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, _singleRedemption.batchAddress);\n\n            Troves[_singleRedemption.troveId].coll = newColl;\n            // interest and fee were updated in the outer function\n            // This call could revert due to BatchSharesRatioTooHigh if trove.redistCollGain > boldLot\n            // so we skip that check to avoid blocking redemptions\n            _updateBatchShares(\n                _singleRedemption.troveId,\n                _singleRedemption.batchAddress,\n                troveChange,\n                newDebt,\n                _singleRedemption.batch.entireCollWithoutRedistribution,\n                _singleRedemption.batch.entireDebtWithoutRedistribution,\n                false // _checkBatchSharesRatio\n            );\n        } else {\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.trove.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt = newDebt * _singleRedemption.trove.annualInterestRate;\n            Troves[_singleRedemption.troveId].debt = newDebt;\n            Troves[_singleRedemption.troveId].coll = newColl;\n            Troves[_singleRedemption.troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _singleRedemption.newStake = _updateStakeAndTotalStakes(_singleRedemption.troveId, newColl);\n        _movePendingTroveRewardsToActivePool(\n            _defaultPool, _singleRedemption.trove.redistBoldDebtGain, _singleRedemption.trove.redistCollGain\n        );\n        _updateTroveRewardSnapshots(_singleRedemption.troveId);\n\n        if (_isTroveInBatch) {\n            emit BatchedTroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _batchDebtShares: Troves[_singleRedemption.troveId].batchDebtShares,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        } else {\n            emit TroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _debt: newDebt,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        }\n\n        emit TroveOperation({\n            _troveId: _singleRedemption.troveId,\n            _operation: Operation.redeemCollateral,\n            _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n            _debtIncreaseFromRedist: _singleRedemption.trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(_singleRedemption.boldLot),\n            _collIncreaseFromRedist: _singleRedemption.trove.redistCollGain,\n            _collChangeFromOperation: -int256(_singleRedemption.collLot)\n        });\n\n        if (_isTroveInBatch) {\n            emit BatchUpdated({\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _operation: BatchOperation.troveChange,\n                _debt: batches[_singleRedemption.batchAddress].debt,\n                _coll: batches[_singleRedemption.batchAddress].coll,\n                _annualInterestRate: _singleRedemption.batch.annualInterestRate,\n                _annualManagementFee: _singleRedemption.batch.annualManagementFee,\n                _totalDebtShares: batches[_singleRedemption.batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n\n        emit RedemptionFeePaidToTrove(_singleRedemption.troveId, _singleRedemption.collFee);\n\n        return newDebt;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _redeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        uint256 _maxBoldamount,\n        uint256 _redemptionPrice,\n        uint256 _redemptionRate\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of Coll equal in USD value to the boldLot redeemed\n        uint256 correspondingColl = _singleRedemption.boldLot * DECIMAL_PRECISION / _redemptionPrice;\n        // Calculate the collFee separately (for events)\n        _singleRedemption.collFee = correspondingColl * _redemptionRate / DECIMAL_PRECISION;\n        // Get the final collLot to send to redeemer, leaving the fee in the Trove\n        _singleRedemption.collLot = correspondingColl - _singleRedemption.collFee;\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        uint256 newDebt = _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // Make Trove zombie if it's tiny (and it wasn’t already), in order to prevent griefing future (normal, sequential) redemptions\n        if (newDebt < MIN_DEBT) {\n            if (!_singleRedemption.isZombieTrove) {\n                Troves[_singleRedemption.troveId].status = Status.zombie;\n                if (isTroveInBatch) {\n                    sortedTroves.removeFromBatch(_singleRedemption.troveId);\n                } else {\n                    sortedTroves.remove(_singleRedemption.troveId);\n                }\n                // If it’s a partial redemption, let’s store a pointer to it so it’s used first in the next one\n                if (newDebt > 0) {\n                    lastZombieTroveId = _singleRedemption.troveId;\n                }\n            } else if (newDebt == 0) {\n                // Reset last zombie trove pointer if the previous one was fully redeemed now\n                lastZombieTroveId = 0;\n            }\n        }\n        // Note: technically, it could happen that the Trove pointed to by `lastZombieTroveId` ends up with\n        // newDebt >= MIN_DEBT thanks to BOLD debt redistribution, which means it _could_ be made active again,\n        // however we don't do that here, as it would require hints for re-insertion into `SortedTroves`.\n    }\n\n    function _updateBatchInterestPriorToRedemption(IActivePool _activePool, address _batchAddress) internal {\n        LatestBatchData memory batch;\n        _getLatestBatchData(_batchAddress, batch);\n        batches[_batchAddress].debt = batch.entireDebtWithoutRedistribution;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        // As we are updating the batch, we update the ActivePool weighted sum too\n        TroveChange memory batchTroveChange;\n        batchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchTroveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchTroveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchTroveChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n\n        _activePool.mintAggInterestAndAccountForTroveChange(batchTroveChange, _batchAddress);\n    }\n\n    /* Send _boldamount Bold to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies redistribution gains to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, and therefore in “zombie” state\n    */\n    function redeemCollateral(\n        address _redeemer,\n        uint256 _boldamount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external override returns (uint256 _redeemedAmount) {\n        _requireCallerIsCollateralRegistry();\n\n        IActivePool activePoolCached = activePool;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        TroveChange memory totalsTroveChange;\n        RedeemCollateralValues memory vars;\n\n        vars.remainingBold = _boldamount;\n\n        SingleRedemptionValues memory singleRedemption;\n        // Let’s check if there’s a pending zombie trove from previous redemption\n        if (lastZombieTroveId != 0) {\n            singleRedemption.troveId = lastZombieTroveId;\n            singleRedemption.isZombieTrove = true;\n        } else {\n            singleRedemption.troveId = sortedTrovesCached.getLast();\n        }\n        vars.lastBatchUpdatedInterest = address(0);\n\n        // Get the price to use for the redemption collateral calculations\n        (uint256 redemptionPrice,) = priceFeed.fetchRedemptionPrice();\n\n        // Loop through the Troves starting from the one with lowest interest rate until _amount of Bold is exchanged for collateral\n        if (_maxIterations == 0) _maxIterations = type(uint256).max;\n        while (singleRedemption.troveId != 0 && vars.remainingBold > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the uint256 of the Trove preceding the current one\n            if (singleRedemption.isZombieTrove) {\n                vars.nextUserToCheck = sortedTrovesCached.getLast();\n            } else {\n                vars.nextUserToCheck = sortedTrovesCached.getPrev(singleRedemption.troveId);\n            }\n\n            // Skip if ICR < 100%, to make sure that redemptions don’t decrease the CR of hit Troves.\n            // Use the normal price for the ICR check.\n            if (getCurrentICR(singleRedemption.troveId, _price) < _100pct) {\n                singleRedemption.troveId = vars.nextUserToCheck;\n                singleRedemption.isZombieTrove = false;\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // We do it here outside, to avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (\n                singleRedemption.batchAddress != address(0)\n                    && singleRedemption.batchAddress != vars.lastBatchUpdatedInterest\n            ) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n                vars.lastBatchUpdatedInterest = singleRedemption.batchAddress;\n            }\n\n            _redeemCollateralFromTrove(\n                defaultPool, singleRedemption, vars.remainingBold, redemptionPrice, _redemptionRate\n            );\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n            vars.totalCollFee += singleRedemption.collFee;\n\n            vars.remainingBold -= singleRedemption.boldLot;\n            singleRedemption.troveId = vars.nextUserToCheck;\n            singleRedemption.isZombieTrove = false;\n        }\n\n        // We are removing this condition to prevent blocking redemptions\n        //require(totals.totalCollDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        emit Redemption(\n            _boldamount,\n            totalsTroveChange.debtDecrease,\n            totalsTroveChange.collDecrease,\n            vars.totalCollFee,\n            _price,\n            redemptionPrice\n        );\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed Coll to sender\n        activePoolCached.sendColl(_redeemer, totalsTroveChange.collDecrease);\n        // We’ll burn all the Bold together out in the CollateralRegistry, to save gas\n\n        return totalsTroveChange.debtDecrease;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _urgentRedeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        SingleRedemptionValues memory _singleRedemption\n    ) internal {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of ETH equal in USD value to the BOLD lot redeemed\n        _singleRedemption.collLot = _singleRedemption.boldLot * (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS) / _price;\n        // As here we can redeem when CR < 101% (accounting for 1% bonus), we need to cap by collateral too\n        if (_singleRedemption.collLot > _singleRedemption.trove.entireColl) {\n            _singleRedemption.collLot = _singleRedemption.trove.entireColl;\n            _singleRedemption.boldLot =\n                _singleRedemption.trove.entireColl * _price / (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS);\n        }\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // No need to make this Trove zombie if it has tiny debt, since:\n        // - This collateral branch has shut down and urgent redemptions are enabled\n        // - Urgent redemptions aren't sequential, so they can't be griefed by tiny Troves.\n    }\n\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external {\n        _requireIsShutDown();\n        _requireAmountGreaterThanZero(_boldAmount);\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        IActivePool activePoolCached = activePool;\n        TroveChange memory totalsTroveChange;\n\n        // Use the standard fetchPrice here, since if branch has shut down we don't worry about small redemption arbs\n        (uint256 price,) = priceFeed.fetchPrice();\n\n        uint256 remainingBold = _boldAmount;\n        for (uint256 i = 0; i < _troveIds.length; i++) {\n            if (remainingBold == 0) break;\n\n            SingleRedemptionValues memory singleRedemption;\n            singleRedemption.troveId = _troveIds[i];\n            _getLatestTroveData(singleRedemption.troveId, singleRedemption.trove);\n\n            if (!_isActiveOrZombie(Troves[singleRedemption.troveId].status) || singleRedemption.trove.entireDebt == 0) {\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // As we don’t have them ordered now, we cannot avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (singleRedemption.batchAddress != address(0)) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n            }\n\n            _urgentRedeemCollateralFromTrove(defaultPool, remainingBold, price, singleRedemption);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n\n            remainingBold -= singleRedemption.boldLot;\n        }\n\n        if (totalsTroveChange.collDecrease < _minCollateral) {\n            revert MinCollNotReached(totalsTroveChange.collDecrease);\n        }\n\n        emit Redemption(_boldAmount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, 0, price, price);\n\n        // Since this branch is shut down, this will mint 0 interest.\n        // We call this only to update the aggregate debt and weighted debt trackers.\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed coll to caller\n        activePoolCached.sendColl(msg.sender, totalsTroveChange.collDecrease);\n        // Burn bold\n        boldToken.burn(msg.sender, totalsTroveChange.debtDecrease);\n    }\n\n    function shutdown() external {\n        _requireCallerIsBorrowerOperations();\n        shutdownTime = block.timestamp;\n        activePool.setShutdownFlag();\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(uint256 _troveId, uint256 _price) public view override returns (uint256) {\n        LatestTroveData memory trove;\n        _getLatestTroveData(_troveId, trove);\n        return LiquityMath._computeCR(trove.entireColl, trove.entireDebt, _price);\n    }\n\n    function _updateTroveRewardSnapshots(uint256 _troveId) internal {\n        rewardSnapshots[_troveId].coll = L_coll;\n        rewardSnapshots[_troveId].boldDebt = L_boldDebt;\n    }\n\n    // Return the Troves entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestTroveData(uint256 _troveId, LatestTroveData memory trove) internal view {\n        // If trove belongs to a batch, we fetch the batch and apply its share to obtained values\n        address batchAddress = _getBatchManager(_troveId);\n        if (batchAddress != address(0)) {\n            LatestBatchData memory batch;\n            _getLatestBatchData(batchAddress, batch);\n            _getLatestTroveDataFromBatch(_troveId, trove, batch);\n            return;\n        }\n\n        uint256 stake = Troves[_troveId].stake;\n        trove.redistBoldDebtGain = stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        trove.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        trove.recordedDebt = Troves[_troveId].debt;\n        trove.annualInterestRate = Troves[_troveId].annualInterestRate;\n        trove.weightedRecordedDebt = trove.recordedDebt * trove.annualInterestRate;\n\n        uint256 period = _getInterestPeriod(Troves[_troveId].lastDebtUpdateTime);\n        trove.accruedInterest = _calcInterest(trove.weightedRecordedDebt, period);\n\n        trove.entireDebt = trove.recordedDebt + trove.redistBoldDebtGain + trove.accruedInterest;\n        trove.entireColl = Troves[_troveId].coll + trove.redistCollGain;\n        trove.lastInterestRateAdjTime = Troves[_troveId].lastInterestRateAdjTime;\n    }\n\n    function _getLatestTroveDataFromBatch(\n        uint256 _troveId,\n        LatestTroveData memory _latestTroveData,\n        LatestBatchData memory _latestBatchData\n    ) internal view {\n        Trove memory trove = Troves[_troveId];\n        uint256 batchDebtShares = trove.batchDebtShares;\n        uint256 totalDebtShares = _latestBatchData.totalDebtShares;\n\n        uint256 stake = trove.stake;\n        _latestTroveData.redistBoldDebtGain =\n            stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        if (totalDebtShares > 0) {\n            _latestTroveData.recordedDebt = _latestBatchData.recordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.weightedRecordedDebt = _latestTroveData.recordedDebt * _latestBatchData.annualInterestRate;\n            _latestTroveData.accruedInterest = _latestBatchData.accruedInterest * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedBatchManagementFee =\n                _latestBatchData.accruedManagementFee * batchDebtShares / totalDebtShares;\n        }\n        _latestTroveData.annualInterestRate = _latestBatchData.annualInterestRate;\n\n        // We can’t do pro-rata batch entireDebt, because redist gains are proportional to coll, not to debt\n        _latestTroveData.entireDebt = _latestTroveData.recordedDebt + _latestTroveData.redistBoldDebtGain\n            + _latestTroveData.accruedInterest + _latestTroveData.accruedBatchManagementFee;\n        _latestTroveData.entireColl = trove.coll + _latestTroveData.redistCollGain;\n        _latestTroveData.lastInterestRateAdjTime =\n            LiquityMath._max(_latestBatchData.lastInterestRateAdjTime, trove.lastInterestRateAdjTime);\n    }\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory trove) {\n        _getLatestTroveData(_troveId, trove);\n    }\n\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256) {\n        Trove memory trove = Troves[_troveId];\n        address batchAddress = _getBatchManager(trove);\n        if (batchAddress != address(0)) {\n            return batches[batchAddress].annualInterestRate;\n        }\n        return trove.annualInterestRate;\n    }\n\n    function _getBatchManager(uint256 _troveId) internal view returns (address) {\n        return Troves[_troveId].interestBatchManager;\n    }\n\n    function _getBatchManager(Trove memory trove) internal pure returns (address) {\n        return trove.interestBatchManager;\n    }\n\n    // Return the Batch entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestBatchData(address _batchAddress, LatestBatchData memory latestBatchData) internal view {\n        Batch memory batch = batches[_batchAddress];\n\n        latestBatchData.totalDebtShares = batch.totalDebtShares;\n        latestBatchData.recordedDebt = batch.debt;\n        latestBatchData.annualInterestRate = batch.annualInterestRate;\n        latestBatchData.weightedRecordedDebt = latestBatchData.recordedDebt * latestBatchData.annualInterestRate;\n        uint256 period = _getInterestPeriod(batch.lastDebtUpdateTime);\n        latestBatchData.accruedInterest = _calcInterest(latestBatchData.weightedRecordedDebt, period);\n        latestBatchData.annualManagementFee = batch.annualManagementFee;\n        latestBatchData.weightedRecordedBatchManagementFee =\n            latestBatchData.recordedDebt * latestBatchData.annualManagementFee;\n        latestBatchData.accruedManagementFee = _calcInterest(latestBatchData.weightedRecordedBatchManagementFee, period);\n\n        latestBatchData.entireDebtWithoutRedistribution =\n            latestBatchData.recordedDebt + latestBatchData.accruedInterest + latestBatchData.accruedManagementFee;\n        latestBatchData.entireCollWithoutRedistribution = batch.coll;\n        latestBatchData.lastDebtUpdateTime = batch.lastDebtUpdateTime;\n        latestBatchData.lastInterestRateAdjTime = batch.lastInterestRateAdjTime;\n    }\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory batch) {\n        _getLatestBatchData(_batchAddress, batch);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(uint256 _troveId, uint256 _coll) internal returns (uint256 newStake) {\n        newStake = _computeNewStake(_coll);\n        uint256 oldStake = Troves[_troveId].stake;\n        Troves[_troveId].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the redistribution gains, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            // assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debtToRedistribute,\n        uint256 _collToRedistribute\n    ) internal {\n        if (_debtToRedistribute == 0) return; // Otherwise _collToRedistribute > 0 too\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_coll and L_boldDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToRedistribute * DECIMAL_PRECISION + lastCollError_Redistribution;\n        uint256 boldDebtNumerator = _debtToRedistribute * DECIMAL_PRECISION + lastBoldDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint256 collRewardPerUnitStaked = collNumerator / totalStakes;\n        uint256 boldDebtRewardPerUnitStaked = boldDebtNumerator / totalStakes;\n\n        lastCollError_Redistribution = collNumerator - collRewardPerUnitStaked * totalStakes;\n        lastBoldDebtError_Redistribution = boldDebtNumerator - boldDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_coll = L_coll + collRewardPerUnitStaked;\n        L_boldDebt = L_boldDebt + boldDebtRewardPerUnitStaked;\n\n        _defaultPool.increaseBoldDebt(_debtToRedistribute);\n        _activePool.sendCollToDefaultPool(_collToRedistribute);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getCollBalance();\n        uint256 liquidatedColl = defaultPool.getCollBalance();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveIds array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveId(uint256 _troveId, uint256 TroveIdsArrayLength) internal {\n        uint64 index = Troves[_troveId].arrayIndex;\n        uint256 idxLast = TroveIdsArrayLength - 1;\n\n        // assert(index <= idxLast);\n\n        uint256 idToMove = TroveIds[idxLast];\n\n        TroveIds[index] = idToMove;\n        Troves[idToMove].arrayIndex = index;\n\n        TroveIds.pop();\n    }\n\n    function getTroveStatus(uint256 _troveId) external view override returns (Status) {\n        return Troves[_troveId].status;\n    }\n\n    // --- Interest rate calculations ---\n\n    function _getInterestPeriod(uint256 _lastDebtUpdateTime) internal view returns (uint256) {\n        if (shutdownTime == 0) {\n            // If branch is not shut down, interest is earned up to now.\n            return block.timestamp - _lastDebtUpdateTime;\n        } else if (shutdownTime > 0 && _lastDebtUpdateTime < shutdownTime) {\n            // If branch is shut down and the Trove was not updated since shut down, interest is earned up to the shutdown time.\n            return shutdownTime - _lastDebtUpdateTime;\n        } else {\n            // if (shutdownTime > 0 && _lastDebtUpdateTime >= shutdownTime)\n            // If branch is shut down and the Trove was updated after shutdown, no interest is earned since.\n            return 0;\n        }\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != address(borrowerOperations)) {\n            revert CallerNotBorrowerOperations();\n        }\n    }\n\n    function _requireCallerIsCollateralRegistry() internal view {\n        if (msg.sender != address(collateralRegistry)) {\n            revert CallerNotCollateralRegistry();\n        }\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint256 TroveIdsArrayLength) internal pure {\n        if (TroveIdsArrayLength == 1) {\n            revert OnlyOneTroveLeft();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (shutdownTime == 0) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        if (boldBalance < _amount) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    // --- Trove property getters ---\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool) {\n        uint256 totalDebt = getEntireBranchDebt();\n        uint256 spSize = stabilityPool.getTotalBoldDeposits();\n        uint256 unbackedPortion = totalDebt > spSize ? totalDebt - spSize : 0;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        // It's redeemable if the TCR is above the shutdown threshold, and branch has not been shut down.\n        // Use the normal price for the TCR check.\n        bool redeemable = _getTCR(price) >= SCR && shutdownTime == 0;\n\n        return (unbackedPortion, price, redeemable);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].debt = _troveChange.debtIncrease + _troveChange.upfrontFee;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _annualInterestRate;\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _troveChange.debtIncrease + _troveChange.upfrontFee,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _annualInterestRate: _annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTrove,\n            _annualInterestRate: _annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n    }\n\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].interestBatchManager = _batchAddress;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        assert(_troveChange.debtIncrease > 0);\n        _updateBatchShares(\n            _troveId, _batchAddress, _troveChange, _troveChange.debtIncrease, _batchColl, _batchDebt, true\n        );\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTroveAndJoinBatch,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove joining the batch pays an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function setTroveStatusToActive(uint256 _troveId) external {\n        _requireCallerIsBorrowerOperations();\n        Troves[_troveId].status = Status.active;\n        if (lastZombieTroveId == _troveId) {\n            lastZombieTroveId = 0;\n        }\n    }\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTroveInterestRate,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n    }\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newColl);\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: newStake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        _closeTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, Status.closedByOwner);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.closeTrove,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        if (_batchAddress != address(0)) {\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[_batchAddress].debt,\n                _coll: batches[_batchAddress].coll,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n    }\n\n    function _closeTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        Status closedStatus\n    ) internal {\n        // assert(closedStatus == Status.closedByLiquidation || closedStatus == Status.closedByOwner);\n\n        uint256 TroveIdsArrayLength = TroveIds.length;\n        // If branch has not been shut down, or it's a liquidation,\n        // require at least 1 trove in the system\n        if (shutdownTime == 0 || closedStatus == Status.closedByLiquidation) {\n            _requireMoreThanOneTroveInSystem(TroveIdsArrayLength);\n        }\n\n        _removeTroveId(_troveId, TroveIdsArrayLength);\n\n        Trove memory trove = Troves[_troveId];\n\n        // If trove belongs to a batch, remove from it\n        if (_batchAddress != address(0)) {\n            if (trove.status == Status.active) {\n                sortedTroves.removeFromBatch(_troveId);\n            } else if (trove.status == Status.zombie && lastZombieTroveId == _troveId) {\n                lastZombieTroveId = 0;\n            }\n\n            _removeTroveSharesFromBatch(\n                _troveId,\n                _troveChange.collDecrease,\n                _troveChange.debtDecrease,\n                _troveChange,\n                _batchAddress,\n                _newBatchColl,\n                _newBatchDebt\n            );\n        } else {\n            if (trove.status == Status.active) {\n                sortedTroves.remove(_troveId);\n            } else if (trove.status == Status.zombie && lastZombieTroveId == _troveId) {\n                lastZombieTroveId = 0;\n            }\n        }\n\n        uint256 newTotalStakes = totalStakes - trove.stake;\n        totalStakes = newTotalStakes;\n\n        // Zero Trove properties\n        delete Troves[_troveId];\n        Troves[_troveId].status = closedStatus;\n\n        // Zero Trove snapshots\n        delete rewardSnapshots[_troveId];\n\n        // burn ERC721\n        troveNFT.burn(_troveId);\n    }\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution and trove change\n        uint256 _newTroveDebt, // entire, with redistribution and trove change\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest, batch fee), but without trove change nor upfront fee nor redistribution\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        // Trove\n        Troves[_troveId].coll = _newTroveColl;\n        _updateTroveRewardSnapshots(_troveId);\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newTroveColl);\n\n        // Batch\n        assert(_newTroveDebt > 0);\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _newTroveDebt, _newBatchColl, _newBatchDebt, true);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _newTroveColl,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove being adjusted may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newTroveColl;\n\n        if (_batchAddress != address(0)) {\n            assert(_newTroveDebt > 0);\n            _updateBatchShares(_troveId, _batchAddress, _troveChange, _newTroveDebt, _newBatchColl, _newBatchDebt, true);\n\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.applyBatchInterestAndFee,\n                _debt: _newBatchDebt,\n                _coll: _newBatchColl,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        } else {\n            Troves[_troveId].debt = _newTroveDebt;\n            Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.applyPendingDebt,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_account].arrayIndex = uint64(batchIds.length);\n        batches[_account].annualInterestRate = _annualInterestRate;\n        batches[_account].annualManagementFee = _annualManagementFee;\n        batches[_account].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        batchIds.push(_account);\n\n        emit BatchUpdated({\n            _interestBatchManager: _account,\n            _operation: BatchOperation.registerBatchManager,\n            _debt: 0,\n            _coll: 0,\n            _annualInterestRate: _annualInterestRate,\n            _annualManagementFee: _annualManagementFee,\n            _totalDebtShares: 0,\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualManagementFee = _newAnnualManagementFee;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.lowerBatchManagerAnnualFee,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: _newAnnualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        uint256 _upfrontFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualInterestRate = _newAnnualInterestRate;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        batches[_batchAddress].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.setBatchManagerAnnualInterestRate,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: _newAnnualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            _debtIncreaseFromUpfrontFee: _upfrontFee\n        });\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external {\n        _requireCallerIsBorrowerOperations();\n        TroveChange memory _troveChange = _params.troveChange;\n\n        // assert(batchIds[batches[_params.newBatchAddress].arrayIndex] == _params.newBatchAddress);\n\n        _updateTroveRewardSnapshots(_params.troveId);\n\n        // Clean Trove state\n        Troves[_params.troveId].debt = 0;\n        Troves[_params.troveId].annualInterestRate = 0;\n        Troves[_params.troveId].lastDebtUpdateTime = 0;\n        Troves[_params.troveId].coll = _params.troveColl;\n\n        Troves[_params.troveId].interestBatchManager = _params.newBatchAddress;\n        Troves[_params.troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _troveChange.collIncrease = _params.troveColl - _troveChange.appliedRedistCollGain;\n        _troveChange.debtIncrease = _params.troveDebt - _troveChange.appliedRedistBoldDebtGain - _troveChange.upfrontFee;\n        assert(_params.troveDebt > 0);\n        _updateBatchShares(\n            _params.troveId,\n            _params.newBatchAddress,\n            _troveChange,\n            _params.troveDebt,\n            _params.newBatchColl,\n            _params.newBatchDebt,\n            true\n        );\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _params.troveId,\n            _interestBatchManager: _params.newBatchAddress,\n            _batchDebtShares: Troves[_params.troveId].batchDebtShares,\n            _coll: _params.troveColl,\n            _stake: Troves[_params.troveId].stake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _params.troveId,\n            _operation: Operation.setInterestBatchManager,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _params.newBatchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_params.newBatchAddress].debt,\n            _coll: batches[_params.newBatchAddress].coll,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _annualManagementFee: batches[_params.newBatchAddress].annualManagementFee,\n            _totalDebtShares: batches[_params.newBatchAddress].totalDebtShares,\n            // Although the Trove joining the batch may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    // This function will revert if there’s a total debt increase and the ratio debt / shares has exceeded the max\n    function _updateBatchShares(\n        uint256 _troveId,\n        address _batchAddress,\n        TroveChange memory _troveChange,\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        uint256 _batchColl, // without trove change\n        uint256 _batchDebt, // entire (with interest, batch fee), but without trove change, nor upfront fee nor redist\n        bool _checkBatchSharesRatio // whether we do the check on the resulting ratio inside the func call\n    ) internal {\n        // Debt\n        uint256 currentBatchDebtShares = batches[_batchAddress].totalDebtShares;\n        uint256 batchDebtSharesDelta;\n        uint256 debtIncrease =\n            _troveChange.debtIncrease + _troveChange.upfrontFee + _troveChange.appliedRedistBoldDebtGain;\n        uint256 debtDecrease;\n        if (debtIncrease > _troveChange.debtDecrease) {\n            debtIncrease -= _troveChange.debtDecrease;\n        } else {\n            debtDecrease = _troveChange.debtDecrease - debtIncrease;\n            debtIncrease = 0;\n        }\n\n        if (debtIncrease == 0 && debtDecrease == 0) {\n            batches[_batchAddress].debt = _batchDebt;\n        } else {\n            if (debtIncrease > 0) {\n                // Add debt\n                if (_batchDebt == 0) {\n                    batchDebtSharesDelta = debtIncrease;\n                } else {\n                    // To avoid rebasing issues, let’s make sure the ratio debt / shares is not too high\n                    _requireBelowMaxSharesRatio(currentBatchDebtShares, _batchDebt, _checkBatchSharesRatio);\n\n                    batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / _batchDebt;\n                }\n\n                Troves[_troveId].batchDebtShares += batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt + debtIncrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares + batchDebtSharesDelta;\n            } else if (debtDecrease > 0) {\n                // Subtract debt\n                // We make sure that if final trove debt is zero, shares are too (avoiding rounding issues)\n                // This can only happen from redemptions, as otherwise we would be using _removeTroveSharesFromBatch\n                // In redemptions we don’t do that because we don’t want to kick the trove out of the batch (it’d be bad UX)\n                if (_newTroveDebt == 0) {\n                    batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                    batches[_batchAddress].totalDebtShares = currentBatchDebtShares - Troves[_troveId].batchDebtShares;\n                    Troves[_troveId].batchDebtShares = 0;\n                } else {\n                    batchDebtSharesDelta = currentBatchDebtShares * debtDecrease / _batchDebt;\n\n                    Troves[_troveId].batchDebtShares -= batchDebtSharesDelta;\n                    batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                    batches[_batchAddress].totalDebtShares = currentBatchDebtShares - batchDebtSharesDelta;\n                }\n            }\n        }\n        // Update debt checkpoint\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        // Collateral\n        uint256 collIncrease = _troveChange.collIncrease + _troveChange.appliedRedistCollGain;\n        uint256 collDecrease;\n        if (collIncrease > _troveChange.collDecrease) {\n            collIncrease -= _troveChange.collDecrease;\n        } else {\n            collDecrease = _troveChange.collDecrease - collIncrease;\n            collIncrease = 0;\n        }\n\n        if (collIncrease == 0 && collDecrease == 0) {\n            batches[_batchAddress].coll = _batchColl;\n        } else {\n            if (collIncrease > 0) {\n                // Add coll\n                batches[_batchAddress].coll = _batchColl + collIncrease;\n            } else if (collDecrease > 0) {\n                // Subtract coll\n                batches[_batchAddress].coll = _batchColl - collDecrease;\n            }\n        }\n    }\n\n    // For the debt / shares ratio to increase by a factor 1e9\n    // at a average annual debt increase (compounded interest + fees) of 10%, it would take more than 217 years (log(1e9)/log(1.1))\n    // at a average annual debt increase (compounded interest + fees) of 50%, it would take more than 51 years (log(1e9)/log(1.5))\n    // When that happens, no more debt can be manually added to the batch, so batch should be migrated to a new one\n    function _requireBelowMaxSharesRatio(\n        uint256 _currentBatchDebtShares,\n        uint256 _batchDebt,\n        bool _checkBatchSharesRatio\n    ) internal pure {\n        // debt / shares should be below MAX_BATCH_SHARES_RATIO\n        if (_currentBatchDebtShares * MAX_BATCH_SHARES_RATIO < _batchDebt && _checkBatchSharesRatio) {\n            revert BatchSharesRatioTooHigh();\n        }\n    }\n\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        // Subtract from batch\n        _removeTroveSharesFromBatch(\n            _troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt\n        );\n\n        // Restore Trove state\n        Troves[_troveId].debt = _newTroveDebt;\n        Troves[_troveId].coll = _newTroveColl;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.removeFromBatch,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove leaving the batch may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function _removeTroveSharesFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest and batch fee), but without trove change\n    ) internal {\n        // As we are removing:\n        // assert(_newBatchDebt > 0 || _newBatchColl > 0);\n\n        Trove memory trove = Troves[_troveId];\n\n        // We don’t need to increase the shares corresponding to redistribution first, because they would be subtracted immediately after\n        // We don’t need to account for interest nor batch fee because it’s proportional to debt shares\n        uint256 batchDebtDecrease = _newTroveDebt - _troveChange.upfrontFee - _troveChange.appliedRedistBoldDebtGain;\n        uint256 batchCollDecrease = _newTroveColl - _troveChange.appliedRedistCollGain;\n\n        batches[_batchAddress].totalDebtShares -= trove.batchDebtShares;\n        batches[_batchAddress].debt = _newBatchDebt - batchDebtDecrease;\n        batches[_batchAddress].coll = _newBatchColl - batchCollDecrease;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        Troves[_troveId].interestBatchManager = address(0);\n        Troves[_troveId].batchDebtShares = 0;\n    }\n}\n",
        "IBorrowerOperations.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ILiquityBase.sol\";\nimport \"./IAddRemoveManagers.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./ITroveManager.sol\";\nimport \"./IWETH.sol\";\n\n// Common interface for the Borrower Operations.\ninterface IBorrowerOperations is ILiquityBase, IAddRemoveManagers {\n    function CCR() external view returns (uint256);\n    function MCR() external view returns (uint256);\n    function SCR() external view returns (uint256);\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _ETHAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external returns (uint256);\n\n    struct OpenTroveAndJoinInterestBatchManagerParams {\n        address owner;\n        uint256 ownerIndex;\n        uint256 collAmount;\n        uint256 boldAmount;\n        uint256 upperHint;\n        uint256 lowerHint;\n        address interestBatchManager;\n        uint256 maxUpfrontFee;\n        address addManager;\n        address removeManager;\n        address receiver;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        returns (uint256);\n\n    function addColl(uint256 _troveId, uint256 _ETHAmount) external;\n\n    function withdrawColl(uint256 _troveId, uint256 _amount) external;\n\n    function withdrawBold(uint256 _troveId, uint256 _amount, uint256 _maxUpfrontFee) external;\n\n    function repayBold(uint256 _troveId, uint256 _amount) external;\n\n    function closeTrove(uint256 _troveId) external;\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external;\n\n    function adjustZombieTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) external;\n\n    function onLiquidateTrove(uint256 _troveId) external;\n\n    function claimCollateral() external;\n\n    function hasBeenShutDown() external view returns (bool);\n    function shutdown() external;\n    function shutdownFromOracleFailure() external;\n\n    function checkBatchManagerExists(address _batchMananger) external view returns (bool);\n\n    // -- individual delegation --\n    struct InterestIndividualDelegate {\n        address account;\n        uint128 minInterestRate;\n        uint128 maxInterestRate;\n        uint256 minInterestRateChangePeriod;\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory);\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee,\n        uint256 _minInterestRateChangePeriod\n    ) external;\n    function removeInterestIndividualDelegate(uint256 _troveId) external;\n\n    // -- batches --\n    struct InterestBatchManager {\n        uint128 minInterestRate;\n        uint128 maxInterestRate;\n        uint256 minInterestRateChangePeriod;\n    }\n\n    function registerBatchManager(\n        uint128 minInterestRate,\n        uint128 maxInterestRate,\n        uint128 currentInterestRate,\n        uint128 fee,\n        uint128 minInterestRateChangePeriod\n    ) external;\n    function lowerBatchManagementFee(uint256 _newAnnualFee) external;\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function interestBatchManagerOf(uint256 _troveId) external view returns (address);\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory);\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function kickFromBatch(uint256 _troveId, uint256 _upperHint, uint256 _lowerHint) external;\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n}\n",
        "HybridCurveUniV3ExchangeHelpers.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"../../../Interfaces/IWETH.sol\";\n// Curve\nimport \"./Curve/ICurveStableswapNGPool.sol\";\n// UniV3\nimport \"./UniswapV3/IQuoterV2.sol\";\n\nimport \"../../Interfaces/IExchangeHelpers.sol\";\n\ncontract HybridCurveUniV3ExchangeHelpers is IExchangeHelpers {\n    uint256 private constant DECIMAL_PRECISION = 1e18;\n\n    //HybridCurveUniV3Exchange public immutable exchange;\n\n    IERC20 public immutable USDC;\n    IWETH public immutable WETH;\n\n    // Curve\n    ICurveStableswapNGPool public immutable curvePool;\n    uint128 public immutable USDC_INDEX;\n    uint128 public immutable BOLD_TOKEN_INDEX;\n\n    // Uniswap\n    uint24 public immutable feeUsdcWeth;\n    uint24 public immutable feeWethColl;\n    IQuoterV2 public immutable uniV3Quoter;\n\n    /*\n    constructor(HybridCurveUniV3Exchange _exchange) {\n        exchange = _exchange;\n\n        USDC = _exchange.USDC();\n        WETH = _exchange.WETH();\n\n        curvePool = _exchange.curvePool();\n        USDC_INDEX = _exchange.USDC_INDEX();\n        BOLD_TOKEN_INDEX = _exchange.BOLD_INDEX();\n\n        // Uniswap\n        feeUsdcWeth = _exchange.feeUsdcWeth();\n        feeWethColl = _exchange.feeWethColl();\n        uniV3Quoter = _exchange.uniV3Quoter();\n    }\n    */\n\n    constructor(\n        IERC20 _usdc,\n        IWETH _weth,\n        // Curve\n        ICurveStableswapNGPool _curvePool,\n        uint128 _usdcIndex,\n        uint128 _boldIndex,\n        // UniV3\n        uint24 _feeUsdcWeth,\n        uint24 _feeWethColl,\n        IQuoterV2 _uniV3Quoter\n    ) {\n        USDC = _usdc;\n        WETH = _weth;\n\n        // Curve\n        curvePool = _curvePool;\n        USDC_INDEX = _usdcIndex;\n        BOLD_TOKEN_INDEX = _boldIndex;\n\n        // Uniswap\n        feeUsdcWeth = _feeUsdcWeth;\n        feeWethColl = _feeWethColl;\n        uniV3Quoter = _uniV3Quoter;\n    }\n\n    function getCollFromBold(uint256 _boldAmount, IERC20 _collToken, uint256 _desiredCollAmount)\n        external /* view */\n        returns (uint256 collAmount, uint256 deviation)\n    {\n        // BOLD -> USDC\n        uint256 curveUsdcAmount = curvePool.get_dy(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), _boldAmount);\n\n        // USDC -> Coll\n        bytes memory path;\n        if (address(WETH) == address(_collToken)) {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH);\n        } else {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH, feeWethColl, _collToken);\n        }\n\n        (collAmount,,,) = uniV3Quoter.quoteExactInput(path, curveUsdcAmount);\n\n        if (_desiredCollAmount > 0 && collAmount <= _desiredCollAmount) {\n            deviation = DECIMAL_PRECISION - collAmount * DECIMAL_PRECISION / _desiredCollAmount;\n        }\n\n        return (collAmount, deviation);\n    }\n}\n",
        "IFlashLoanReceiver.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IZapper.sol\";\nimport \"./ILeverageZapper.sol\";\n\ninterface IFlashLoanReceiver {\n    function receiveFlashLoanOnOpenLeveragedTrove(\n        ILeverageZapper.OpenLeveragedTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n    function receiveFlashLoanOnLeverUpTrove(\n        ILeverageZapper.LeverUpTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n    function receiveFlashLoanOnLeverDownTrove(\n        ILeverageZapper.LeverDownTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n    function receiveFlashLoanOnCloseTroveFromCollateral(\n        IZapper.CloseTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n}\n",
        "ActivePool.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"./Dependencies/Constants.sol\";\nimport \"./Interfaces/IActivePool.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/IInterestRouter.sol\";\nimport \"./Interfaces/IDefaultPool.sol\";\n\n/*\n * The Active Pool holds the collateral and Bold debt (but not Bold tokens) for all active troves.\n *\n * When a trove is liquidated, it's Coll and Bold debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is IActivePool {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"ActivePool\";\n\n    IERC20 public immutable collToken;\n    address public immutable borrowerOperationsAddress;\n    address public immutable troveManagerAddress;\n    address public immutable defaultPoolAddress;\n\n    IBoldToken public immutable boldToken;\n\n    IInterestRouter public immutable interestRouter;\n    IBoldRewardsReceiver public immutable stabilityPool;\n\n    uint256 internal collBalance; // deposited coll tracker\n\n    // Aggregate recorded debt tracker. Updated whenever a Trove's debt is touched AND whenever the aggregate pending interest is minted.\n    // \"D\" in the spec.\n    uint256 public aggRecordedDebt;\n\n    /* Sum of individual recorded Trove debts weighted by their respective chosen interest rates.\n    * Updated at individual Trove operations.\n    * \"S\" in the spec.\n    */\n    uint256 public aggWeightedDebtSum;\n\n    // Last time at which the aggregate recorded debt and weighted sum were updated\n    uint256 public lastAggUpdateTime;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    // Aggregate batch fees tracker\n    uint256 public aggBatchManagementFees;\n    /* Sum of individual recorded Trove debts weighted by their respective batch management fees\n     * Updated at individual batched Trove operations.\n     */\n    uint256 public aggWeightedBatchManagementFeeSum;\n    // Last time at which the aggregate batch fees and weighted sum were updated\n    uint256 public lastAggBatchManagementFeesUpdateTime;\n\n    // --- Events ---\n\n    event CollTokenAddressChanged(address _newCollTokenAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event ActivePoolBoldDebtUpdated(uint256 _recordedDebtSum);\n    event ActivePoolCollBalanceUpdated(uint256 _collBalance);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());\n        troveManagerAddress = address(_addressesRegistry.troveManager());\n        stabilityPool = IBoldRewardsReceiver(_addressesRegistry.stabilityPool());\n        defaultPoolAddress = address(_addressesRegistry.defaultPool());\n        interestRouter = _addressesRegistry.interestRouter();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit CollTokenAddressChanged(address(collToken));\n        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(troveManagerAddress);\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit DefaultPoolAddressChanged(defaultPoolAddress);\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(defaultPoolAddress, type(uint256).max);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the Coll state variable.\n    *\n    *Not necessarily equal to the the contract's raw Coll balance - ether can be forcibly sent to contracts.\n    */\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function calcPendingAggInterest() public view returns (uint256) {\n        if (shutdownTime != 0) return 0;\n\n        // We use the ceiling of the division here to ensure positive error, while we use regular floor division\n        // when calculating the interest accrued by individual Troves.\n        // This ensures that `system debt >= sum(trove debt)` always holds, and thus system debt won't turn negative\n        // even if all Trove debt is repaid. The difference should be small and it should scale with the number of\n        // interest minting events.\n        return Math.ceilDiv(aggWeightedDebtSum * (block.timestamp - lastAggUpdateTime), ONE_YEAR * DECIMAL_PRECISION);\n    }\n\n    function calcPendingSPYield() external view returns (uint256) {\n        return calcPendingAggInterest() * SP_YIELD_SPLIT / DECIMAL_PRECISION;\n    }\n\n    function calcPendingAggBatchManagementFee() public view returns (uint256) {\n        uint256 periodEnd = shutdownTime != 0 ? shutdownTime : block.timestamp;\n        uint256 periodStart = Math.min(lastAggBatchManagementFeesUpdateTime, periodEnd);\n\n        return Math.ceilDiv(aggWeightedBatchManagementFeeSum * (periodEnd - periodStart), ONE_YEAR * DECIMAL_PRECISION);\n    }\n\n    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)\n        external\n        view\n        returns (uint256)\n    {\n        // We are ignoring the upfront fee when calculating the approx. avg. interest rate.\n        // This is a simple way to resolve the circularity in:\n        //   fee depends on avg. interest rate -> avg. interest rate is weighted by debt -> debt includes fee -> ...\n        assert(_troveChange.upfrontFee == 0);\n\n        if (shutdownTime != 0) return 0;\n\n        uint256 newAggRecordedDebt = aggRecordedDebt;\n        newAggRecordedDebt += calcPendingAggInterest();\n        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;\n        newAggRecordedDebt += _troveChange.debtIncrease;\n        newAggRecordedDebt += _troveChange.batchAccruedManagementFee;\n        newAggRecordedDebt -= _troveChange.debtDecrease;\n\n        uint256 newAggWeightedDebtSum = aggWeightedDebtSum;\n        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;\n        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;\n\n        // Avoid division by 0 if the first ever borrower tries to borrow 0 BOLD\n        // Borrowing 0 BOLD is not allowed, but our check of debt >= MIN_DEBT happens _after_ calculating the upfront\n        // fee, which involves getting the new approx. avg. interest rate\n        return newAggRecordedDebt > 0 ? newAggWeightedDebtSum / newAggRecordedDebt : 0;\n    }\n\n    // Returns sum of agg.recorded debt plus agg. pending interest. Excludes pending redist. gains.\n    function getBoldDebt() external view returns (uint256) {\n        return aggRecordedDebt + calcPendingAggInterest() + aggBatchManagementFees + calcPendingAggBatchManagementFee();\n    }\n\n    // --- Pool functionality ---\n\n    function sendColl(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n\n        _accountForSendColl(_amount);\n\n        collToken.safeTransfer(_account, _amount);\n    }\n\n    function sendCollToDefaultPool(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n\n        _accountForSendColl(_amount);\n\n        IDefaultPool(defaultPoolAddress).receiveColl(_amount);\n    }\n\n    function _accountForSendColl(uint256 _amount) internal {\n        uint256 newCollBalance = collBalance - _amount;\n        collBalance = newCollBalance;\n        emit ActivePoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function receiveColl(uint256 _amount) external {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n\n        _accountForReceivedColl(_amount);\n\n        // Pull Coll tokens from sender\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function accountForReceivedColl(uint256 _amount) public {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n\n        _accountForReceivedColl(_amount);\n    }\n\n    function _accountForReceivedColl(uint256 _amount) internal {\n        uint256 newCollBalance = collBalance + _amount;\n        collBalance = newCollBalance;\n\n        emit ActivePoolCollBalanceUpdated(newCollBalance);\n    }\n\n    // --- Aggregate interest operations ---\n\n    // This function is called inside all state-changing user ops: borrower ops, liquidations, redemptions and SP deposits/withdrawals.\n    // Some user ops trigger debt changes to Trove(s), in which case _troveDebtChange will be non-zero.\n    // The aggregate recorded debt is incremented by the aggregate pending interest, plus the net Trove debt change.\n    // The net Trove debt change consists of the sum of a) any debt issued/repaid and b) any redistribution debt gain applied in the encapsulating operation.\n    // It does *not* include the Trove's individual accrued interest - this gets accounted for in the aggregate accrued interest.\n    // The net Trove debt change could be positive or negative in a repayment (depending on whether its redistribution gain or repayment amount is larger),\n    // so this function accepts both the increase and the decrease to avoid using (and converting to/from) signed ints.\n    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchAddress)\n        external\n    {\n        _requireCallerIsBOorTroveM();\n\n        // Batch management fees\n        if (_batchAddress != address(0)) {\n            _mintBatchManagementFeeAndAccountForChange(_troveChange, _batchAddress);\n        }\n\n        // Do the arithmetic in 2 steps here to avoid underflow from the decrease\n        uint256 newAggRecordedDebt = aggRecordedDebt; // 1 SLOAD\n        newAggRecordedDebt += _mintAggInterest(_troveChange.upfrontFee); // adds minted agg. interest + upfront fee\n        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;\n        newAggRecordedDebt += _troveChange.debtIncrease;\n        newAggRecordedDebt -= _troveChange.debtDecrease;\n        aggRecordedDebt = newAggRecordedDebt; // 1 SSTORE\n\n        // assert(aggRecordedDebt >= 0) // This should never be negative. If all redistribution gians and all aggregate interest was applied\n        // and all Trove debts were repaid, it should become 0.\n\n        // Do the arithmetic in 2 steps here to avoid underflow from the decrease\n        uint256 newAggWeightedDebtSum = aggWeightedDebtSum; // 1 SLOAD\n        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;\n        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;\n        aggWeightedDebtSum = newAggWeightedDebtSum; // 1 SSTORE\n    }\n\n    function mintAggInterest() external override {\n        _requireCallerIsBOorSP();\n        aggRecordedDebt += _mintAggInterest(0);\n    }\n\n    function _mintAggInterest(uint256 _upfrontFee) internal returns (uint256 mintedAmount) {\n        mintedAmount = calcPendingAggInterest() + _upfrontFee;\n\n        // Mint part of the BOLD interest to the SP and part to the router for LPs.\n        if (mintedAmount > 0) {\n            uint256 spYield = SP_YIELD_SPLIT * mintedAmount / DECIMAL_PRECISION;\n            uint256 remainderToLPs = mintedAmount - spYield;\n\n            boldToken.mint(address(interestRouter), remainderToLPs);\n\n            if (spYield > 0) {\n                boldToken.mint(address(stabilityPool), spYield);\n                stabilityPool.triggerBoldRewards(spYield);\n            }\n        }\n\n        lastAggUpdateTime = block.timestamp;\n    }\n\n    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)\n        external\n        override\n    {\n        _requireCallerIsTroveManager();\n        _mintBatchManagementFeeAndAccountForChange(_troveChange, _batchAddress);\n    }\n\n    function _mintBatchManagementFeeAndAccountForChange(TroveChange memory _troveChange, address _batchAddress)\n        internal\n    {\n        aggRecordedDebt += _troveChange.batchAccruedManagementFee;\n\n        // Do the arithmetic in 2 steps here to avoid underflow from the decrease\n        uint256 newAggBatchManagementFees = aggBatchManagementFees; // 1 SLOAD\n        newAggBatchManagementFees += calcPendingAggBatchManagementFee();\n        newAggBatchManagementFees -= _troveChange.batchAccruedManagementFee;\n        aggBatchManagementFees = newAggBatchManagementFees; // 1 SSTORE\n\n        // Do the arithmetic in 2 steps here to avoid underflow from the decrease\n        uint256 newAggWeightedBatchManagementFeeSum = aggWeightedBatchManagementFeeSum; // 1 SLOAD\n        newAggWeightedBatchManagementFeeSum += _troveChange.newWeightedRecordedBatchManagementFee;\n        newAggWeightedBatchManagementFeeSum -= _troveChange.oldWeightedRecordedBatchManagementFee;\n        aggWeightedBatchManagementFeeSum = newAggWeightedBatchManagementFeeSum; // 1 SSTORE\n\n        // mint fee to batch address\n        if (_troveChange.batchAccruedManagementFee > 0) {\n            boldToken.mint(_batchAddress, _troveChange.batchAccruedManagementFee);\n        }\n\n        lastAggBatchManagementFeesUpdateTime = block.timestamp;\n    }\n\n    // --- Shutdown ---\n\n    function setShutdownFlag() external {\n        _requireCallerIsTroveManager();\n        shutdownTime = block.timestamp;\n    }\n\n    function hasBeenShutDown() external view returns (bool) {\n        return shutdownTime != 0;\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress\n                || msg.sender == address(stabilityPool),\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == address(stabilityPool),\n            \"ActivePool: Caller is not BorrowerOperations nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"ActivePool: Caller is not TroveManager\");\n    }\n}\n",
        "ICurvePool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);\n    //function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth, address receiver) external returns (uint256 output);\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256 output);\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256 dy);\n}\n",
        "AddressesRegistry.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"./Dependencies/Ownable.sol\";\nimport {MIN_LIQUIDATION_PENALTY_SP, MAX_LIQUIDATION_PENALTY_REDISTRIBUTION} from \"./Dependencies/Constants.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\n\ncontract AddressesRegistry is Ownable, IAddressesRegistry {\n    IERC20Metadata public collToken;\n    IBorrowerOperations public borrowerOperations;\n    ITroveManager public troveManager;\n    ITroveNFT public troveNFT;\n    IMetadataNFT public metadataNFT;\n    IStabilityPool public stabilityPool;\n    IPriceFeed public priceFeed;\n    IActivePool public activePool;\n    IDefaultPool public defaultPool;\n    address public gasPoolAddress;\n    ICollSurplusPool public collSurplusPool;\n    ISortedTroves public sortedTroves;\n    IInterestRouter public interestRouter;\n    IHintHelpers public hintHelpers;\n    IMultiTroveGetter public multiTroveGetter;\n    ICollateralRegistry public collateralRegistry;\n    IBoldToken public boldToken;\n    IWETH public WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n    // Extra buffer of collateral ratio to join a batch or adjust a trove inside a batch (on top of MCR)\n    uint256 public immutable BCR;\n    // Liquidation penalty for troves offset to the SP\n    uint256 public immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 public immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    error InvalidCCR();\n    error InvalidMCR();\n    error InvalidBCR();\n    error InvalidSCR();\n    error SPPenaltyTooLow();\n    error SPPenaltyGtRedist();\n    error RedistPenaltyTooHigh();\n\n    event CollTokenAddressChanged(address _collTokenAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event TroveNFTAddressChanged(address _troveNFTAddress);\n    event MetadataNFTAddressChanged(address _metadataNFTAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event PriceFeedAddressChanged(address _priceFeedAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event InterestRouterAddressChanged(address _interestRouterAddress);\n    event HintHelpersAddressChanged(address _hintHelpersAddress);\n    event MultiTroveGetterAddressChanged(address _multiTroveGetterAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n    event WETHAddressChanged(address _wethAddress);\n\n    constructor(\n        address _owner,\n        uint256 _ccr,\n        uint256 _mcr,\n        uint256 _bcr,\n        uint256 _scr,\n        uint256 _liquidationPenaltySP,\n        uint256 _liquidationPenaltyRedistribution\n    ) Ownable(_owner) {\n        if (_ccr <= 1e18 || _ccr >= 2e18) revert InvalidCCR();\n        if (_mcr <= 1e18 || _mcr >= 2e18) revert InvalidMCR();\n        if (_bcr < 5e16 || _bcr >= 50e16) revert InvalidBCR();\n        if (_scr <= 1e18 || _scr >= 2e18) revert InvalidSCR();\n        if (_liquidationPenaltySP < MIN_LIQUIDATION_PENALTY_SP) revert SPPenaltyTooLow();\n        if (_liquidationPenaltySP > _liquidationPenaltyRedistribution) revert SPPenaltyGtRedist();\n        if (_liquidationPenaltyRedistribution > MAX_LIQUIDATION_PENALTY_REDISTRIBUTION) revert RedistPenaltyTooHigh();\n\n        CCR = _ccr;\n        SCR = _scr;\n        MCR = _mcr;\n        BCR = _bcr;\n        LIQUIDATION_PENALTY_SP = _liquidationPenaltySP;\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _liquidationPenaltyRedistribution;\n    }\n\n    function setAddresses(AddressVars memory _vars) external onlyOwner {\n        collToken = _vars.collToken;\n        borrowerOperations = _vars.borrowerOperations;\n        troveManager = _vars.troveManager;\n        troveNFT = _vars.troveNFT;\n        metadataNFT = _vars.metadataNFT;\n        stabilityPool = _vars.stabilityPool;\n        priceFeed = _vars.priceFeed;\n        activePool = _vars.activePool;\n        defaultPool = _vars.defaultPool;\n        gasPoolAddress = _vars.gasPoolAddress;\n        collSurplusPool = _vars.collSurplusPool;\n        sortedTroves = _vars.sortedTroves;\n        interestRouter = _vars.interestRouter;\n        hintHelpers = _vars.hintHelpers;\n        multiTroveGetter = _vars.multiTroveGetter;\n        collateralRegistry = _vars.collateralRegistry;\n        boldToken = _vars.boldToken;\n        WETH = _vars.WETH;\n\n        emit CollTokenAddressChanged(address(_vars.collToken));\n        emit BorrowerOperationsAddressChanged(address(_vars.borrowerOperations));\n        emit TroveManagerAddressChanged(address(_vars.troveManager));\n        emit TroveNFTAddressChanged(address(_vars.troveNFT));\n        emit MetadataNFTAddressChanged(address(_vars.metadataNFT));\n        emit StabilityPoolAddressChanged(address(_vars.stabilityPool));\n        emit PriceFeedAddressChanged(address(_vars.priceFeed));\n        emit ActivePoolAddressChanged(address(_vars.activePool));\n        emit DefaultPoolAddressChanged(address(_vars.defaultPool));\n        emit GasPoolAddressChanged(_vars.gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(_vars.collSurplusPool));\n        emit SortedTrovesAddressChanged(address(_vars.sortedTroves));\n        emit InterestRouterAddressChanged(address(_vars.interestRouter));\n        emit HintHelpersAddressChanged(address(_vars.hintHelpers));\n        emit MultiTroveGetterAddressChanged(address(_vars.multiTroveGetter));\n        emit CollateralRegistryAddressChanged(address(_vars.collateralRegistry));\n        emit BoldTokenAddressChanged(address(_vars.boldToken));\n        emit WETHAddressChanged(address(_vars.WETH));\n\n        _renounceOwnership();\n    }\n}\n",
        "ITroveManager.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ILiquityBase.sol\";\nimport \"./ITroveNFT.sol\";\nimport \"./IBorrowerOperations.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"../Types/LatestTroveData.sol\";\nimport \"../Types/LatestBatchData.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is ILiquityBase {\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        zombie\n    }\n\n    function shutdownTime() external view returns (uint256);\n\n    function troveNFT() external view returns (ITroveNFT);\n    function stabilityPool() external view returns (IStabilityPool);\n    //function boldToken() external view returns (IBoldToken);\n    function sortedTroves() external view returns (ISortedTroves);\n    function borrowerOperations() external view returns (IBorrowerOperations);\n\n    function Troves(uint256 _id)\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 stake,\n            Status status,\n            uint64 arrayIndex,\n            uint64 lastDebtUpdateTime,\n            uint64 lastInterestRateAdjTime,\n            uint256 annualInterestRate,\n            address interestBatchManager,\n            uint256 batchDebtShares\n        );\n\n    function rewardSnapshots(uint256 _id) external view returns (uint256 coll, uint256 boldDebt);\n\n    function getTroveIdsCount() external view returns (uint256);\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view returns (uint256);\n\n    function getCurrentICR(uint256 _troveId, uint256 _price) external view returns (uint256);\n\n    function lastZombieTroveId() external view returns (uint256);\n\n    function batchLiquidateTroves(uint256[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        address _sender,\n        uint256 _boldAmount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external returns (uint256 _redemeedAmount);\n\n    function shutdown() external;\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external;\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool);\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory);\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256);\n\n    function getTroveStatus(uint256 _troveId) external view returns (Status);\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory);\n\n    // -- permissioned functions called by BorrowerOperations\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external;\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external;\n\n    // Called from `adjustZombieTrove()`\n    function setTroveStatusToActive(uint256 _troveId) external;\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external;\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external;\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt\n    ) external;\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external;\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external;\n\n    // -- batches --\n    function onRegisterBatchManager(address _batchAddress, uint256 _annualInterestRate, uint256 _annualFee) external;\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external;\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        uint256 _upfrontFee // needed by BatchUpdated event\n    ) external;\n\n    struct OnSetInterestBatchManagerParams {\n        uint256 troveId;\n        uint256 troveColl; // entire, with redistribution\n        uint256 troveDebt; // entire, with interest, batch fee and redistribution\n        TroveChange troveChange;\n        address newBatchAddress;\n        uint256 newBatchColl; // updated collateral for new batch manager\n        uint256 newBatchDebt; // updated debt for new batch manager\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external;\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external;\n\n    // -- end of permissioned functions --\n}\n",
        "ICurveFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ICurvePool.sol\";\n\ninterface ICurveFactory {\n    function deploy_pool(\n        string memory name,\n        string memory symbol,\n        address[2] memory coins,\n        uint256 implementation_id,\n        uint256 A,\n        uint256 gamma,\n        uint256 mid_fee,\n        uint256 out_fee,\n        uint256 fee_gamma,\n        uint256 allowed_extra_profit,\n        uint256 adjustment_step,\n        uint256 ma_exp_time,\n        uint256 initial_price\n    ) external returns (ICurvePool);\n}\n",
        "ILQTYToken.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface ILQTYToken is IERC20, IERC20Permit {\n    function sendToLQTYStaking(address _sender, uint256 _amount) external;\n\n    function getDeploymentStartTime() external view returns (uint256);\n\n    function getLpRewardsEntitlement() external view returns (uint256);\n}\n",
        "IStabilityPool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IActivePool.sol\";\nimport \"./ILiquityBase.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./ITroveManager.sol\";\nimport \"./IBoldRewardsReceiver.sol\";\n\n/*\n * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with\n * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total Bold in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n*/\ninterface IStabilityPool is ILiquityBase, IBoldRewardsReceiver {\n    function boldToken() external view returns (IBoldToken);\n    function troveManager() external view returns (ITroveManager);\n\n    /*  provideToSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Increases deposit, and takes new snapshots of accumulators P and S\n    * - Sends depositor's accumulated Coll gains to depositor\n    */\n    function provideToSP(uint256 _amount, bool _doClaim) external;\n\n    /*  withdrawFromSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Sends the requested BOLD withdrawal to depositor\n    * - (If _amount > userDeposit, the user withdraws all of their compounded deposit)\n    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S\n    */\n    function withdrawFromSP(uint256 _amount, bool doClaim) external;\n\n    function claimAllCollGains() external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint256 _debt, uint256 _coll) external;\n\n    function deposits(address _depositor) external view returns (uint256 initialValue);\n    function stashedColl(address _depositor) external view returns (uint256);\n\n    /*\n     * Returns the total amount of Coll held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like Coll received from a self-destruct.\n     */\n    function getCollBalance() external view returns (uint256);\n\n    /*\n     * Returns Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalBoldDeposits() external view returns (uint256);\n\n    function getYieldGainsOwed() external view returns (uint256);\n    function getYieldGainsPending() external view returns (uint256);\n\n    /*\n     * Calculates the Coll gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorCollGain(address _depositor) external view returns (uint256);\n\n    /*\n     * Calculates the BOLD yield gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorYieldGain(address _depositor) external view returns (uint256);\n\n    /*\n     * Calculates what `getDepositorYieldGain` will be if interest is minted now.\n     */\n    function getDepositorYieldGainWithPending(address _depositor) external view returns (uint256);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedBoldDeposit(address _depositor) external view returns (uint256);\n\n    function scaleToS(uint256 _scale) external view returns (uint256);\n\n    function scaleToB(uint256 _scale) external view returns (uint256);\n\n    function P() external view returns (uint256);\n    function currentScale() external view returns (uint256);\n\n    function P_PRECISION() external view returns (uint256);\n}\n",
        "IFlashLoanProvider.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"./ILeverageZapper.sol\";\nimport \"./IFlashLoanReceiver.sol\";\n\ninterface IFlashLoanProvider {\n    enum Operation {\n        OpenTrove,\n        CloseTrove,\n        LeverUpTrove,\n        LeverDownTrove\n    }\n\n    function receiver() external view returns (IFlashLoanReceiver);\n\n    function makeFlashLoan(IERC20 _token, uint256 _amount, Operation _operation, bytes calldata userData) external;\n}\n",
        "SVG.sol": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {utils, LibString} from \"./Utils.sol\";\n\n/// @notice Core SVG utility library which helps us construct onchain SVG's with a simple, web-like API.\n/// @author Modified from (https://github.com/w1nt3r-eth/hot-chain-svg/blob/main/contracts/SVG.sol) by w1nt3r-eth.\n\nlibrary svg {\n    /* GLOBAL CONSTANTS */\n    string internal constant _SVG = 'xmlns=\"http://www.w3.org/2000/svg\"';\n    string internal constant _HTML = 'xmlns=\"http://www.w3.org/1999/xhtml\"';\n    string internal constant _XMLNS = \"http://www.w3.org/2000/xmlns/ \";\n    string internal constant _XLINK = \"http://www.w3.org/1999/xlink \";\n\n    /* MAIN ELEMENTS */\n    function g(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"g\", _props, _children);\n    }\n\n    function _svg(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"svg\", string.concat(_SVG, \" \", _props), _children);\n    }\n\n    function style(string memory _title, string memory _props) internal pure returns (string memory) {\n        return el(\"style\", string.concat(\".\", _title, \" \", _props));\n    }\n\n    function path(string memory _d) internal pure returns (string memory) {\n        return el(\"path\", prop(\"d\", _d, true));\n    }\n\n    function path(string memory _d, string memory _props) internal pure returns (string memory) {\n        return el(\"path\", string.concat(prop(\"d\", _d), _props));\n    }\n\n    function path(string memory _d, string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\"path\", string.concat(prop(\"d\", _d), _props), _children);\n    }\n\n    function text(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"text\", _props, _children);\n    }\n\n    function line(string memory _props) internal pure returns (string memory) {\n        return el(\"line\", _props);\n    }\n\n    function line(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"line\", _props, _children);\n    }\n\n    function circle(string memory _props) internal pure returns (string memory) {\n        return el(\"circle\", _props);\n    }\n\n    function circle(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"circle\", _props, _children);\n    }\n\n    function circle(string memory cx, string memory cy, string memory r) internal pure returns (string memory) {\n        return el(\"circle\", string.concat(prop(\"cx\", cx), prop(\"cy\", cy), prop(\"r\", r, true)));\n    }\n\n    function circle(string memory cx, string memory cy, string memory r, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\"circle\", string.concat(prop(\"cx\", cx), prop(\"cy\", cy), prop(\"r\", r, true)), _children);\n    }\n\n    function circle(string memory cx, string memory cy, string memory r, string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\"circle\", string.concat(prop(\"cx\", cx), prop(\"cy\", cy), prop(\"r\", r), _props), _children);\n    }\n\n    function ellipse(string memory _props) internal pure returns (string memory) {\n        return el(\"ellipse\", _props);\n    }\n\n    function ellipse(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"ellipse\", _props, _children);\n    }\n\n    function polygon(string memory _props) internal pure returns (string memory) {\n        return el(\"polygon\", _props);\n    }\n\n    function polygon(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"polygon\", _props, _children);\n    }\n\n    function polyline(string memory _props) internal pure returns (string memory) {\n        return el(\"polyline\", _props);\n    }\n\n    function polyline(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"polyline\", _props, _children);\n    }\n\n    function rect(string memory _props) internal pure returns (string memory) {\n        return el(\"rect\", _props);\n    }\n\n    function rect(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"rect\", _props, _children);\n    }\n\n    function filter(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"filter\", _props, _children);\n    }\n\n    function cdata(string memory _content) internal pure returns (string memory) {\n        return string.concat(\"<![CDATA[\", _content, \"]]>\");\n    }\n\n    /* GRADIENTS */\n    function radialGradient(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"radialGradient\", _props, _children);\n    }\n\n    function linearGradient(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"linearGradient\", _props, _children);\n    }\n\n    function gradientStop(uint256 offset, string memory stopColor, string memory _props)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\n            \"stop\",\n            string.concat(\n                prop(\"stop-color\", stopColor),\n                \" \",\n                prop(\"offset\", string.concat(LibString.toString(offset), \"%\")),\n                \" \",\n                _props\n            ),\n            utils.NULL\n        );\n    }\n\n    /* ANIMATION */\n    function animateTransform(string memory _props) internal pure returns (string memory) {\n        return el(\"animateTransform\", _props);\n    }\n\n    function animate(string memory _props) internal pure returns (string memory) {\n        return el(\"animate\", _props);\n    }\n\n    /* COMMON */\n    // A generic element, can be used to construct any SVG (or HTML) element\n    function el(string memory _tag, string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(\"<\", _tag, \" \", _props, \">\", _children, \"</\", _tag, \">\");\n    }\n\n    // A generic element, can be used to construct SVG (or HTML) elements without children\n    function el(string memory _tag, string memory _props) internal pure returns (string memory) {\n        return string.concat(\"<\", _tag, \" \", _props, \"/>\");\n    }\n\n    // an SVG attribute\n    function prop(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat(_key, \"=\", '\"', _val, '\" ');\n    }\n\n    function prop(string memory _key, string memory _val, bool last) internal pure returns (string memory) {\n        if (last) {\n            return string.concat(_key, \"=\", '\"', _val, '\"');\n        } else {\n            return string.concat(_key, \"=\", '\"', _val, '\" ');\n        }\n    }\n}\n",
        "IMainnetPriceFeed.sol": "// SPDX-License-Identifier: MIT\nimport \"../Interfaces/IPriceFeed.sol\";\nimport \"../Dependencies/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IMainnetPriceFeed is IPriceFeed {\n    enum PriceSource {\n        primary,\n        ETHUSDxCanonical,\n        lastGoodPrice\n    }\n\n    function ethUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n    function priceSource() external view returns (PriceSource);\n}\n",
        "ICollSurplusPool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICollSurplusPool {\n    function getCollBalance() external view returns (uint256);\n\n    function getCollateral(address _account) external view returns (uint256);\n\n    function accountSurplus(address _account, uint256 _amount) external;\n\n    function claimColl(address _account) external;\n}\n",
        "BoldToken.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\n\n/*\n * --- Functionality added specific to the BoldToken ---\n *\n * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending BOLD directly to a Liquity\n * core contract, when they should rather call the right function.\n *\n * 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move BOLD tokens between Liquity <-> user.\n */\n\ncontract BoldToken is Ownable, IBoldToken, ERC20Permit {\n    string internal constant _NAME = \"BOLD Stablecoin\";\n    string internal constant _SYMBOL = \"BOLD\";\n\n    // --- Addresses ---\n\n    address public collateralRegistryAddress;\n    mapping(address => bool) troveManagerAddresses;\n    mapping(address => bool) stabilityPoolAddresses;\n    mapping(address => bool) borrowerOperationsAddresses;\n    mapping(address => bool) activePoolAddresses;\n\n    // --- Events ---\n    event CollateralRegistryAddressChanged(address _newCollateralRegistryAddress);\n    event TroveManagerAddressAdded(address _newTroveManagerAddress);\n    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);\n    event ActivePoolAddressAdded(address _newActivePoolAddress);\n\n    constructor(address _owner) Ownable(_owner) ERC20(_NAME, _SYMBOL) ERC20Permit(_NAME) {}\n\n    function setBranchAddresses(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external override onlyOwner {\n        troveManagerAddresses[_troveManagerAddress] = true;\n        emit TroveManagerAddressAdded(_troveManagerAddress);\n\n        stabilityPoolAddresses[_stabilityPoolAddress] = true;\n        emit StabilityPoolAddressAdded(_stabilityPoolAddress);\n\n        borrowerOperationsAddresses[_borrowerOperationsAddress] = true;\n        emit BorrowerOperationsAddressAdded(_borrowerOperationsAddress);\n\n        activePoolAddresses[_activePoolAddress] = true;\n        emit ActivePoolAddressAdded(_activePoolAddress);\n    }\n\n    function setCollateralRegistry(address _collateralRegistryAddress) external override onlyOwner {\n        collateralRegistryAddress = _collateralRegistryAddress;\n        emit CollateralRegistryAddressChanged(_collateralRegistryAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorAP();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsCRorBOorTMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(address _sender, address _poolAddress, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        public\n        override(ERC20, IERC20)\n        returns (bool)\n    {\n        _requireValidRecipient(recipient);\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"BoldToken: Cannot transfer tokens directly to the Bold token contract or the zero address\"\n        );\n    }\n\n    function _requireCallerIsBOorAP() internal view {\n        require(\n            borrowerOperationsAddresses[msg.sender] || activePoolAddresses[msg.sender],\n            \"BoldToken: Caller is not BO or AP\"\n        );\n    }\n\n    function _requireCallerIsCRorBOorTMorSP() internal view {\n        require(\n            msg.sender == collateralRegistryAddress || borrowerOperationsAddresses[msg.sender]\n                || troveManagerAddresses[msg.sender] || stabilityPoolAddresses[msg.sender],\n            \"BoldToken: Caller is neither CR nor BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(stabilityPoolAddresses[msg.sender], \"BoldToken: Caller is not the StabilityPool\");\n    }\n}\n",
        "ICollateralRegistry.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./ITroveManager.sol\";\n\ninterface ICollateralRegistry {\n    function baseRate() external view returns (uint256);\n    function lastFeeOperationTime() external view returns (uint256);\n\n    function redeemCollateral(uint256 _boldamount, uint256 _maxIterations, uint256 _maxFeePercentage) external;\n    // getters\n    function totalCollaterals() external view returns (uint256);\n    function getToken(uint256 _index) external view returns (IERC20Metadata);\n    function getTroveManager(uint256 _index) external view returns (ITroveManager);\n    function boldToken() external view returns (IBoldToken);\n\n    function getRedemptionRate() external view returns (uint256);\n    function getRedemptionRateWithDecay() external view returns (uint256);\n    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256);\n\n    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view returns (uint256);\n    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view returns (uint256);\n}\n",
        "IAddressesRegistry.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IActivePool.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./IBorrowerOperations.sol\";\nimport \"./ICollSurplusPool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IHintHelpers.sol\";\nimport \"./IMultiTroveGetter.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./ITroveManager.sol\";\nimport \"./ITroveNFT.sol\";\nimport {IMetadataNFT} from \"../NFTMetadata/MetadataNFT.sol\";\nimport \"./ICollateralRegistry.sol\";\nimport \"./IInterestRouter.sol\";\nimport \"./IPriceFeed.sol\";\n\ninterface IAddressesRegistry {\n    struct AddressVars {\n        IERC20Metadata collToken;\n        IBorrowerOperations borrowerOperations;\n        ITroveManager troveManager;\n        ITroveNFT troveNFT;\n        IMetadataNFT metadataNFT;\n        IStabilityPool stabilityPool;\n        IPriceFeed priceFeed;\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        address gasPoolAddress;\n        ICollSurplusPool collSurplusPool;\n        ISortedTroves sortedTroves;\n        IInterestRouter interestRouter;\n        IHintHelpers hintHelpers;\n        IMultiTroveGetter multiTroveGetter;\n        ICollateralRegistry collateralRegistry;\n        IBoldToken boldToken;\n        IWETH WETH;\n    }\n\n    function CCR() external returns (uint256);\n    function SCR() external returns (uint256);\n    function MCR() external returns (uint256);\n    function BCR() external returns (uint256);\n    function LIQUIDATION_PENALTY_SP() external returns (uint256);\n    function LIQUIDATION_PENALTY_REDISTRIBUTION() external returns (uint256);\n\n    function collToken() external view returns (IERC20Metadata);\n    function borrowerOperations() external view returns (IBorrowerOperations);\n    function troveManager() external view returns (ITroveManager);\n    function troveNFT() external view returns (ITroveNFT);\n    function metadataNFT() external view returns (IMetadataNFT);\n    function stabilityPool() external view returns (IStabilityPool);\n    function priceFeed() external view returns (IPriceFeed);\n    function activePool() external view returns (IActivePool);\n    function defaultPool() external view returns (IDefaultPool);\n    function gasPoolAddress() external view returns (address);\n    function collSurplusPool() external view returns (ICollSurplusPool);\n    function sortedTroves() external view returns (ISortedTroves);\n    function interestRouter() external view returns (IInterestRouter);\n    function hintHelpers() external view returns (IHintHelpers);\n    function multiTroveGetter() external view returns (IMultiTroveGetter);\n    function collateralRegistry() external view returns (ICollateralRegistry);\n    function boldToken() external view returns (IBoldToken);\n    function WETH() external returns (IWETH);\n\n    function setAddresses(AddressVars memory _vars) external;\n}\n",
        "UniV3Exchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"../../LeftoversSweep.sol\";\nimport \"../../../Interfaces/IBoldToken.sol\";\nimport \"./UniswapV3/ISwapRouter.sol\";\nimport \"./UniswapV3/UniPriceConverter.sol\";\nimport \"../../Interfaces/IExchange.sol\";\nimport {DECIMAL_PRECISION} from \"../../../Dependencies/Constants.sol\";\n\ncontract UniV3Exchange is LeftoversSweep, UniPriceConverter, IExchange {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    uint24 public immutable fee;\n    ISwapRouter public immutable uniV3Router;\n\n    constructor(IERC20 _collToken, IBoldToken _boldToken, uint24 _fee, ISwapRouter _uniV3Router) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        fee = _fee;\n        uniV3Router = _uniV3Router;\n    }\n\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {\n        ISwapRouter uniV3RouterCached = uniV3Router;\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);\n\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n        boldToken.approve(address(uniV3RouterCached), _boldAmount);\n\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({\n            tokenIn: address(boldToken),\n            tokenOut: address(collToken),\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountOut: _minCollAmount,\n            amountInMaximum: _boldAmount,\n            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205\n        });\n\n        uniV3RouterCached.exactOutputSingle(params);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {\n        ISwapRouter uniV3RouterCached = uniV3Router;\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);\n\n        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);\n        collToken.approve(address(uniV3RouterCached), _collAmount);\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(collToken),\n            tokenOut: address(boldToken),\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _collAmount,\n            amountOutMinimum: _minBoldAmount,\n            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205\n        });\n\n        uint256 amountOut = uniV3RouterCached.exactInputSingle(params);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n\n        return amountOut;\n    }\n\n    function priceToSqrtPrice(IBoldToken _boldToken, IERC20 _collToken, uint256 _price) public pure returns (uint160) {\n        // inverse price if Bold goes first\n        uint256 price = _zeroForOne(_boldToken, _collToken) ? DECIMAL_PRECISION * DECIMAL_PRECISION / _price : _price;\n        return priceToSqrtPriceX96(price);\n    }\n\n    // See: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol#L207C9-L207C60\n    function _zeroForOne(IBoldToken _boldToken, IERC20 _collToken) internal pure returns (bool) {\n        return address(_boldToken) < address(_collToken);\n    }\n}\n",
        "IBoldToken.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/interfaces/IERC5267.sol\";\n\ninterface IBoldToken is IERC20Metadata, IERC20Permit, IERC5267 {\n    function setBranchAddresses(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function setCollateralRegistry(address _collateralRegistryAddress) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(address _sender, address poolAddress, uint256 _amount) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 _amount) external;\n}\n",
        "JSON.sol": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// JSON utilities for base64 encoded ERC721 JSON metadata scheme\nlibrary json {\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /// @dev JSON requires that double quotes be escaped or JSONs will not build correctly\n    /// string.concat also requires an escape, use \\\\\" or the constant DOUBLE_QUOTES to represent \" in JSON\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    string constant DOUBLE_QUOTES = '\\\\\"';\n\n    function formattedMetadata(\n        string memory name,\n        string memory description,\n        string memory svgImg,\n        string memory attributes\n    ) internal pure returns (string memory) {\n        return string.concat(\n            \"data:application/json;base64,\",\n            encode(\n                bytes(\n                    string.concat(\n                        \"{\",\n                        _prop(\"name\", name),\n                        _prop(\"description\", description),\n                        _xmlImage(svgImg),\n                        ',\"attributes\":',\n                        attributes,\n                        \"}\"\n                    )\n                )\n            )\n        );\n    }\n\n    function _xmlImage(string memory _svgImg) internal pure returns (string memory) {\n        return _prop(\"image\", string.concat(\"data:image/svg+xml;base64,\", encode(bytes(_svgImg))), true);\n    }\n\n    function _prop(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\": ', '\"', _val, '\", ');\n    }\n\n    function _prop(string memory _key, string memory _val, bool last) internal pure returns (string memory) {\n        if (last) {\n            return string.concat('\"', _key, '\": ', '\"', _val, '\"');\n        } else {\n            return string.concat('\"', _key, '\": ', '\"', _val, '\", ');\n        }\n    }\n\n    function _object(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\": ', \"{\", _val, \"}\");\n    }\n\n    /**\n     * taken from Openzeppelin\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {} {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 { mstore8(sub(resultPtr, 1), 0x3d) }\n        }\n\n        return result;\n    }\n}\n",
        "IPriceFeed.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256, bool);\n    function fetchRedemptionPrice() external returns (uint256, bool);\n    function lastGoodPrice() external view returns (uint256);\n}\n",
        "ILeverageZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IZapper.sol\";\n\ninterface ILeverageZapper is IZapper {\n    struct OpenLeveragedTroveParams {\n        address owner;\n        uint256 ownerIndex;\n        uint256 collAmount;\n        uint256 flashLoanAmount;\n        uint256 boldAmount;\n        uint256 upperHint;\n        uint256 lowerHint;\n        uint256 annualInterestRate;\n        address batchManager;\n        uint256 maxUpfrontFee;\n        address addManager;\n        address removeManager;\n        address receiver;\n    }\n\n    struct LeverUpTroveParams {\n        uint256 troveId;\n        uint256 flashLoanAmount;\n        uint256 boldAmount;\n        uint256 maxUpfrontFee;\n    }\n\n    struct LeverDownTroveParams {\n        uint256 troveId;\n        uint256 flashLoanAmount;\n        uint256 minBoldAmount;\n    }\n\n    function openLeveragedTroveWithRawETH(OpenLeveragedTroveParams calldata _params) external payable;\n\n    function leverUpTrove(LeverUpTroveParams calldata _params) external;\n\n    function leverDownTrove(LeverDownTroveParams calldata _params) external;\n\n    function leverageRatioToCollateralRatio(uint256 _inputRatio) external pure returns (uint256);\n}\n",
        "IWSTETHPriceFeed.sol": "// SPDX-License-Identifier: MIT\nimport \"./IMainnetPriceFeed.sol\";\nimport \"../Dependencies/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IWSTETHPriceFeed is IMainnetPriceFeed {\n    function stEthUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n}\n",
        "IStabilityPoolEvents.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IStabilityPoolEvents {\n    enum Operation {\n        provideToSP,\n        withdrawFromSP,\n        claimAllCollGains\n    }\n\n    event StabilityPoolCollBalanceUpdated(uint256 _newBalance);\n    event StabilityPoolBoldBalanceUpdated(uint256 _newBalance);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(uint256 _S, uint256 _scale);\n    event B_Updated(uint256 _B, uint256 _scale);\n    event ScaleUpdated(uint256 _currentScale);\n\n    event DepositUpdated(\n        address indexed _depositor,\n        uint256 _newDeposit,\n        uint256 _stashedColl,\n        uint256 _snapshotP,\n        uint256 _snapshotS,\n        uint256 _snapshotB,\n        uint256 _snapshotScale\n    );\n\n    event DepositOperation(\n        address indexed _depositor,\n        Operation _operation,\n        uint256 _depositLossSinceLastOperation,\n        int256 _topUpOrWithdrawal,\n        uint256 _yieldGainSinceLastOperation,\n        uint256 _yieldGainClaimed,\n        uint256 _ethGainSinceLastOperation,\n        uint256 _ethGainClaimed\n    );\n}\n",
        "StabilityPool.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPoolEvents.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\n/*\n * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with\n * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total Bold in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and Coll gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and Coll gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated Coll gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated Coll gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Coll gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Coll gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Coll gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 36 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n * \n * P is stored at 36-digit precision as a uint. That is, a value of \"1\" is represented by a value of 1e36 in the code.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease below 1e27,\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e27, the relative precision loss in P due to floor division is only on the\n * order of 1e-27.\n *\n * --- MIN BOLD IN SP ---\n *\n * Once totalBoldDeposits has become >= MIN_BOLD_IN_SP, a liquidation may never fully empty the Pool - a minimum of 1 BOLD remains in the SP at all times thereafter.\n * This is enforced for liquidations in TroveManager.batchLiquidateTroves, and for withdrawals in StabilityPool.withdrawFromSP.\n * As such, it is impossible to empty the Stability Pool via liquidations, and P can never become 0.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES ---\n *\n * When a deposit is made, it gets a snapshot of the currentScale.\n *\n * When calculating a compounded deposit, we compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9).\n *\n *  --- TRACKING DEPOSITOR'S COLL GAIN OVER SCALE CHANGES  ---\n *\n * We calculate the depositor's accumulated Coll gain for the scale at which they made the deposit, using the Coll gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for the scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated Coll gain, handling the case where their\n * deposit spanned one scale change.\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n */\ncontract StabilityPool is LiquityBase, IStabilityPool, IStabilityPoolEvents {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"StabilityPool\";\n\n    IERC20 public immutable collToken;\n    ITroveManager public immutable troveManager;\n    IBoldToken public immutable boldToken;\n\n    uint256 internal collBalance; // deposited coll tracker\n\n    // Tracker for Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalBoldDeposits;\n\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, and not yet paid out to depositors\n    // From the contract's perspective, this is a write-only variable.\n    uint256 internal yieldGainsOwed;\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, not yet paid out to depositors,\n    // and not accounted for because they were received when the total deposits were too small\n    uint256 internal yieldGainsPending;\n\n    // --- Data structures ---\n\n    struct Deposit {\n        uint256 initialValue;\n    }\n\n    struct Snapshots {\n        uint256 S; // Coll reward sum liqs\n        uint256 P;\n        uint256 B; // Bold reward sum from minted interest\n        uint256 scale;\n    }\n\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n    mapping(address => uint256) public stashedColl;\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some Bold debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint256 public P = P_PRECISION;\n\n    uint256 public constant P_PRECISION = 1e36;\n\n    // A scale change will happen if P decreases by a factor of at least this much\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Highest power `SCALE_FACTOR` can be raised to without overflow\n    uint256 public constant MAX_SCALE_FACTOR_EXPONENT = 8;\n\n    // The number of scale changes after which an untouched deposit stops receiving yield / coll gains\n    uint256 public constant SCALE_SPAN = 2;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint256 public currentScale;\n\n    /* Coll Gain sum 'S': During its lifetime, each deposit d_t earns an Coll gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a mapping (scale => sum).\n    * - The mapping records the sum S at different scales.\n    */\n    mapping(uint256 => uint256) public scaleToS;\n    mapping(uint256 => uint256) public scaleToB;\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        troveManager = _addressesRegistry.troveManager();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit BoldTokenAddressChanged(address(boldToken));\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getTotalBoldDeposits() external view override returns (uint256) {\n        return totalBoldDeposits;\n    }\n\n    function getYieldGainsOwed() external view override returns (uint256) {\n        return yieldGainsOwed;\n    }\n\n    function getYieldGainsPending() external view override returns (uint256) {\n        return yieldGainsPending;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Increases deposit, and takes new snapshots of accumulators P and S\n    * - Sends depositor's accumulated Coll gains to depositor\n    */\n    function provideToSP(uint256 _topUp, bool _doClaim) external override {\n        _requireNonZeroAmount(_topUp);\n\n        activePool.mintAggInterest();\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit + _topUp + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.provideToSP,\n            initialDeposit - compoundedBoldDeposit,\n            int256(_topUp),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        boldToken.sendToPool(msg.sender, address(this), _topUp);\n        _updateTotalBoldDeposits(_topUp + keptYieldGain, 0);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        _sendBoldtoDepositor(msg.sender, yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n\n        // If there were pending yields and with the new deposit we are reaching the threshold, let’s move the yield to owed\n        _updateYieldRewardsSum(0);\n    }\n\n    function _getYieldToKeepOrSend(uint256 _currentYieldGain, bool _doClaim) internal pure returns (uint256, uint256) {\n        uint256 yieldToKeep;\n        uint256 yieldToSend;\n\n        if (_doClaim) {\n            yieldToKeep = 0;\n            yieldToSend = _currentYieldGain;\n        } else {\n            yieldToKeep = _currentYieldGain;\n            yieldToSend = 0;\n        }\n\n        return (yieldToKeep, yieldToSend);\n    }\n\n    /*  withdrawFromSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Sends the requested BOLD withdrawal to depositor\n    * - (If _amount > userDeposit, the user withdraws all of their compounded deposit)\n    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S\n    */\n    function withdrawFromSP(uint256 _amount, bool _doClaim) external override {\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        activePool.mintAggInterest();\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        uint256 boldToWithdraw = LiquityMath._min(_amount, compoundedBoldDeposit);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit - boldToWithdraw + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.withdrawFromSP,\n            initialDeposit - compoundedBoldDeposit,\n            -int256(boldToWithdraw),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        uint256 newTotalBoldDeposits = _updateTotalBoldDeposits(keptYieldGain, boldToWithdraw);\n        _sendBoldtoDepositor(msg.sender, boldToWithdraw + yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n\n        require(newTotalBoldDeposits >= MIN_BOLD_IN_SP, \"Withdrawal must leave totalBoldDeposits >= MIN_BOLD_IN_SP\");\n    }\n\n    function _getNewStashedCollAndCollToSend(address _depositor, uint256 _currentCollGain, bool _doClaim)\n        internal\n        view\n        returns (uint256 newStashedColl, uint256 collToSend)\n    {\n        if (_doClaim) {\n            newStashedColl = 0;\n            collToSend = stashedColl[_depositor] + _currentCollGain;\n        } else {\n            newStashedColl = stashedColl[_depositor] + _currentCollGain;\n            collToSend = 0;\n        }\n    }\n\n    // This function is only needed in the case a user has no deposit but still has remaining stashed Coll gains.\n    function claimAllCollGains() external {\n        _requireUserHasNoDeposit(msg.sender);\n\n        activePool.mintAggInterest();\n\n        uint256 collToSend = stashedColl[msg.sender];\n        _requireNonZeroAmount(collToSend);\n        stashedColl[msg.sender] = 0;\n\n        emit DepositOperation(msg.sender, Operation.claimAllCollGains, 0, 0, 0, 0, 0, collToSend);\n        emit DepositUpdated(msg.sender, 0, 0, 0, 0, 0, 0);\n\n        _sendCollGainToDepositor(collToSend);\n    }\n\n    // --- BOLD reward functions ---\n\n    function triggerBoldRewards(uint256 _boldYield) external {\n        _requireCallerIsActivePool();\n        _updateYieldRewardsSum(_boldYield);\n    }\n\n    function _updateYieldRewardsSum(uint256 _newYield) internal {\n        uint256 accumulatedYieldGains = yieldGainsPending + _newYield;\n        if (accumulatedYieldGains == 0) return;\n\n        // When total deposits is very small, B is not updated. In this case, the BOLD issued is held\n        // until the total deposits reach 1 BOLD (remains in the balance of the SP).\n        if (totalBoldDeposits < MIN_BOLD_IN_SP) {\n            yieldGainsPending = accumulatedYieldGains;\n            return;\n        }\n\n        yieldGainsOwed += accumulatedYieldGains;\n        yieldGainsPending = 0;\n\n        scaleToB[currentScale] += P * accumulatedYieldGains / totalBoldDeposits;\n        emit B_Updated(scaleToB[currentScale], currentScale);\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's Coll collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint256 _debtToOffset, uint256 _collToAdd) external override {\n        _requireCallerIsTroveManager();\n\n        scaleToS[currentScale] += P * _collToAdd / totalBoldDeposits;\n        emit S_Updated(scaleToS[currentScale], currentScale);\n\n        uint256 numerator = P * (totalBoldDeposits - _debtToOffset);\n        uint256 newP = numerator / totalBoldDeposits;\n\n        // For `P` to turn zero, `totalBoldDeposits` has to be greater than `P * (totalBoldDeposits - _debtToOffset)`.\n        // - As the offset must leave at least 1 BOLD in the SP (MIN_BOLD_IN_SP),\n        //   the minimum value of `totalBoldDeposits - _debtToOffset` is `1e18`\n        // - It can be shown that `P` is always in range [1e27, 1e36].\n        // Thus, to turn `P` zero, `totalBoldDeposits` has to be greater than `1e27 * 1e18`,\n        // and the offset has to be (near) maximal.\n        // In other words, there needs to be octillions of BOLD in the SP, which is unlikely to happen in practice.\n        require(newP > 0, \"P must never decrease to 0\");\n\n        // Overflow analyisis of scaling up P:\n        // We know that the resulting P is <= 1e36, and it's the result of dividing numerator by totalBoldDeposits.\n        // Thus, numerator <= 1e36 * totalBoldDeposits, so unless totalBoldDeposits is septillions of BOLD, it won’t overflow.\n        // That holds on every iteration as an upper bound. We multiply numerator by SCALE_FACTOR,\n        // but numerator is by definition smaller than 1e36 * totalBoldDeposits / SCALE_FACTOR.\n        while (newP < P_PRECISION / SCALE_FACTOR) {\n            numerator *= SCALE_FACTOR;\n            newP = numerator / totalBoldDeposits;\n            currentScale += 1;\n            emit ScaleUpdated(currentScale);\n        }\n\n        emit P_Updated(newP);\n        P = newP;\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    function _moveOffsetCollAndDebt(uint256 _collToAdd, uint256 _debtToOffset) internal {\n        // Cancel the liquidated Bold debt with the Bold in the stability pool\n        _updateTotalBoldDeposits(0, _debtToOffset);\n\n        // Burn the debt that was successfully offset\n        boldToken.burn(address(this), _debtToOffset);\n\n        // Update internal Coll balance tracker\n        uint256 newCollBalance = collBalance + _collToAdd;\n        collBalance = newCollBalance;\n\n        // Pull Coll from Active Pool\n        activePool.sendColl(address(this), _collToAdd);\n\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function _updateTotalBoldDeposits(uint256 _depositIncrease, uint256 _depositDecrease) internal returns (uint256) {\n        if (_depositIncrease == 0 && _depositDecrease == 0) return totalBoldDeposits;\n        uint256 newTotalBoldDeposits = totalBoldDeposits + _depositIncrease - _depositDecrease;\n        totalBoldDeposits = newTotalBoldDeposits;\n\n        emit StabilityPoolBoldBalanceUpdated(newTotalBoldDeposits);\n        return newTotalBoldDeposits;\n    }\n\n    function _decreaseYieldGainsOwed(uint256 _amount) internal {\n        if (_amount == 0) return;\n        uint256 newYieldGainsOwed = yieldGainsOwed - _amount;\n        yieldGainsOwed = newYieldGainsOwed;\n    }\n\n    // --- Reward calculator functions for depositor ---\n\n    function getDepositorCollGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        // Coll gains from the same scale in which the deposit was made need no scaling\n        uint256 normalizedGains = scaleToS[snapshots.scale] - snapshots.S;\n\n        // Scale down further coll gains by a power of `SCALE_FACTOR` depending on how many scale changes they span\n        for (uint256 i = 1; i <= SCALE_SPAN; ++i) {\n            normalizedGains += scaleToS[snapshots.scale + i] / SCALE_FACTOR ** i;\n        }\n\n        return LiquityMath._min(initialDeposit * normalizedGains / snapshots.P, collBalance);\n    }\n\n    function getDepositorYieldGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        // Yield gains from the same scale in which the deposit was made need no scaling\n        uint256 normalizedGains = scaleToB[snapshots.scale] - snapshots.B;\n\n        // Scale down further yield gains by a power of `SCALE_FACTOR` depending on how many scale changes they span\n        for (uint256 i = 1; i <= SCALE_SPAN; ++i) {\n            normalizedGains += scaleToB[snapshots.scale + i] / SCALE_FACTOR ** i;\n        }\n\n        return LiquityMath._min(initialDeposit * normalizedGains / snapshots.P, yieldGainsOwed);\n    }\n\n    function getDepositorYieldGainWithPending(address _depositor) external view override returns (uint256) {\n        if (totalBoldDeposits < MIN_BOLD_IN_SP) return 0;\n\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        uint256 newYieldGainsOwed = yieldGainsOwed;\n\n        // Yield gains from the same scale in which the deposit was made need no scaling\n        uint256 normalizedGains = scaleToB[snapshots.scale] - snapshots.B;\n\n        // Scale down further yield gains by a power of `SCALE_FACTOR` depending on how many scale changes they span\n        for (uint256 i = 1; i <= SCALE_SPAN; ++i) {\n            normalizedGains += scaleToB[snapshots.scale + i] / SCALE_FACTOR ** i;\n        }\n\n        // Pending gains\n        uint256 pendingSPYield = activePool.calcPendingSPYield();\n        newYieldGainsOwed += pendingSPYield;\n\n        if (currentScale <= snapshots.scale + SCALE_SPAN) {\n            normalizedGains += P * pendingSPYield / totalBoldDeposits / SCALE_FACTOR ** (currentScale - snapshots.scale);\n        }\n\n        return LiquityMath._min(initialDeposit * normalizedGains / snapshots.P, newYieldGainsOwed);\n    }\n\n    // --- Compounded deposit ---\n\n    function getCompoundedBoldDeposit(address _depositor) public view override returns (uint256 compoundedDeposit) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 scaleDiff = currentScale - snapshots.scale;\n\n        // Compute the compounded deposit. If one or more scale changes in `P` were made during the deposit's lifetime,\n        // account for them.\n        // If more than `MAX_SCALE_FACTOR_EXPONENT` scale changes were made, then the divisor is greater than 2^256 so\n        // any deposit amount would be rounded down to zero.\n        if (scaleDiff <= MAX_SCALE_FACTOR_EXPONENT) {\n            compoundedDeposit = initialDeposit * P / snapshots.P / SCALE_FACTOR ** scaleDiff;\n        } else {\n            compoundedDeposit = 0;\n        }\n    }\n\n    // --- Sender functions for Bold deposit and Coll gains ---\n\n    function _sendCollGainToDepositor(uint256 _collAmount) internal {\n        if (_collAmount == 0) return;\n\n        uint256 newCollBalance = collBalance - _collAmount;\n        collBalance = newCollBalance;\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n        collToken.safeTransfer(msg.sender, _collAmount);\n    }\n\n    // Send Bold to user and decrease Bold in Pool\n    function _sendBoldtoDepositor(address _depositor, uint256 _boldToSend) internal {\n        if (_boldToSend == 0) return;\n        boldToken.returnFromPool(address(this), _depositor, _boldToSend);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newDeposit, uint256 _newStashedColl) internal {\n        deposits[_depositor].initialValue = _newDeposit;\n        stashedColl[_depositor] = _newStashedColl;\n\n        if (_newDeposit == 0) {\n            delete depositSnapshots[_depositor];\n            emit DepositUpdated(_depositor, 0, _newStashedColl, 0, 0, 0, 0);\n            return;\n        }\n\n        uint256 currentScaleCached = currentScale;\n        uint256 currentP = P;\n\n        // Get S for the current scale\n        uint256 currentS = scaleToS[currentScaleCached];\n        uint256 currentB = scaleToB[currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum S for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].B = currentB;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n\n        emit DepositUpdated(_depositor, _newDeposit, _newStashedColl, currentP, currentS, currentB, currentScaleCached);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit > 0, \"StabilityPool: User must have a non-zero deposit\");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, \"StabilityPool: User must have no deposit\");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n    }\n}\n",
        "IMultiTroveGetter.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IMultiTroveGetter {\n    struct CombinedTroveData {\n        uint256 id;\n        uint256 entireDebt;\n        uint256 entireColl;\n        uint256 redistBoldDebtGain;\n        uint256 redistCollGain;\n        uint256 accruedInterest;\n        uint256 recordedDebt;\n        uint256 annualInterestRate;\n        uint256 accruedBatchManagementFee;\n        uint256 lastInterestRateAdjTime;\n        uint256 stake;\n        uint256 lastDebtUpdateTime;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n        uint256 snapshotETH;\n        uint256 snapshotBoldDebt;\n    }\n\n    struct DebtPerInterestRate {\n        address interestBatchManager;\n        uint256 interestRate;\n        uint256 debt;\n    }\n\n    function getMultipleSortedTroves(uint256 _collIndex, int256 _startIdx, uint256 _count)\n        external\n        view\n        returns (CombinedTroveData[] memory _troves);\n\n    function getDebtPerInterestRateAscending(uint256 _collIndex, uint256 _startId, uint256 _maxIterations)\n        external\n        view\n        returns (DebtPerInterestRate[] memory, uint256 currId);\n}\n",
        "ICurveStableswapNGFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ICurveStableswapNGPool.sol\";\n\ninterface ICurveStableswapNGFactory {\n    /*\n    function deploy_plain_pool(\n        string memory name,\n        string memory symbol,\n        address[2] memory coins,\n        uint256 A,\n        uint256 fee,\n        uint256 asset_type,\n        uint256 implementation_id\n    ) external returns (ICurvePool);\n    */\n    function deploy_plain_pool(\n        string memory name,\n        string memory symbol,\n        address[] memory coins,\n        uint256 A,\n        uint256 fee,\n        uint256 offpeg_fee_multiplier,\n        uint256 ma_exp_time,\n        uint256 implementation_id,\n        uint8[] memory asset_types,\n        bytes4[] memory method_ids,\n        address[] memory oracles\n    ) external returns (ICurveStableswapNGPool);\n}\n"
    }
}