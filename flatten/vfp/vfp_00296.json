{
    "vfp_id": "vfp_00296",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "No Interest Paid on Pending Redistributions",
            "description": "Debt from liquidations is held in DefaultPool until a trove is touched. No interest accrues on this pending debt. Additionally, the upfront fee calculation ignores pending debt (which has 0% rate), potentially overestimating the effective system interest rate. This leads to minor inaccuracies in fee modeling.\n",
            "severity": "Informational",
            "location": [
                "DefaultPool"
            ],
            "files": [
                "bold/contracts/src/DefaultPool.sol"
            ]
        }
    ],
    "affected_files": {
        "DefaultPool.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IDefaultPool.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IActivePool.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n * The Default Pool holds the Coll and Bold debt (but not Bold tokens) from liquidations that have been redistributed\n * to active troves but not yet \"applied\", i.e. not yet recorded on a recipient active trove's struct.\n *\n * When a trove makes an operation that applies its pending Coll and Bold debt, its pending Coll and Bold debt is moved\n * from the Default Pool to the Active Pool.\n */\ncontract DefaultPool is IDefaultPool {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"DefaultPool\";\n\n    IERC20 public immutable collToken;\n    address public immutable troveManagerAddress;\n    address public immutable activePoolAddress;\n    uint256 internal collBalance; // deposited Coll tracker\n    uint256 internal BoldDebt; // debt\n\n    event CollTokenAddressChanged(address _newCollTokenAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event EtherSent(address _to, uint256 _amount);\n    event DefaultPoolBoldDebtUpdated(uint256 _boldDebt);\n    event DefaultPoolCollBalanceUpdated(uint256 _collBalance);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        troveManagerAddress = address(_addressesRegistry.troveManager());\n        activePoolAddress = address(_addressesRegistry.activePool());\n\n        emit CollTokenAddressChanged(address(collToken));\n        emit TroveManagerAddressChanged(troveManagerAddress);\n        emit ActivePoolAddressChanged(activePoolAddress);\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(activePoolAddress, type(uint256).max);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collBalance state variable.\n    *\n    * Not necessarily equal to the the contract's raw Coll balance - ether can be forcibly sent to contracts.\n    */\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getBoldDebt() external view override returns (uint256) {\n        return BoldDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendCollToActivePool(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        uint256 newCollBalance = collBalance - _amount;\n        collBalance = newCollBalance;\n        emit DefaultPoolCollBalanceUpdated(newCollBalance);\n        emit EtherSent(activePoolAddress, _amount);\n\n        // Send Coll to Active Pool and increase its recorded Coll balance\n        IActivePool(activePoolAddress).receiveColl(_amount);\n    }\n\n    function receiveColl(uint256 _amount) external {\n        _requireCallerIsActivePool();\n\n        uint256 newCollBalance = collBalance + _amount;\n        collBalance = newCollBalance;\n\n        // Pull Coll tokens from ActivePool\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit DefaultPoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function increaseBoldDebt(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        BoldDebt = BoldDebt + _amount;\n        emit DefaultPoolBoldDebtUpdated(BoldDebt);\n    }\n\n    function decreaseBoldDebt(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        BoldDebt = BoldDebt - _amount;\n        emit DefaultPoolBoldDebtUpdated(BoldDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == activePoolAddress, \"DefaultPool: Caller is not the ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"DefaultPool: Caller is not the TroveManager\");\n    }\n}\n"
    }
}