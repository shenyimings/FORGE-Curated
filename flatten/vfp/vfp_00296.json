{
    "vfp_id": "vfp_00296",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding in Debt Shares Calculation Can Mint Unbacked Tokens",
            "description": "This vulnerability arises from the rounding down of debt shares in the TroveManager._updateBatchShares() function, which allows an attacker to manipulate the debt-to-shares ratio in a batch. By repeatedly donating small amounts of debt and opening/closing troves, an attacker can inflate the ratio to a point where new troves receive zero debt shares for non-zero debt, enabling them to mint unbacked BOLD tokens. The root cause is improper handling of integer division and lack of safeguards against ratio manipulation. An attacker could exploit this by looping through donation and trove operations to inflate the ratio, then mint large amounts of unbacked tokens, leading to protocol insolvency. The impact includes loss of trust, financial loss, and potential collapse of the system's monetary model.\n",
            "severity": "Critical",
            "location": [
                "TroveManager.sol::_updateBatchShares",
                "TroveManager.sol::_requireBelowMaxSharesRatio"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Zappers Can Lose User Funds",
            "description": "When users repay debt via zapper functions, if the repayment would bring the trove below MIN_DEBT, only a partial amount is repaid, and the remainder stays locked in the zapper contract. The cause is the logic in _adjustTrove that silently reduces the repayment amount without refunding excess. An attacker can front-run a large repayment by redeeming the target trove down to just above MIN_DEBT, causing nearly the entire repayment amount to be trapped. The impact is significant loss of user funds, especially in large repayments, and creates an attack vector where malicious actors can profit by backrunning and extracting stuck funds. This undermines user trust and fund safety.\n",
            "severity": "High",
            "location": [
                "BorrowerOperations.sol::_adjustTrove",
                "Zapper contracts::adjust",
                "Zapper contracts::repay"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Incorrect Scaling of P",
            "description": "In the StabilityPool.offset function, the variable P can be scaled beyond the assumed upper bound of 1e36 due to incorrect loop conditions, leading to incorrect calculations in dependent functions like getDepositorCollGain. The cause is a flawed while loop condition that allows P to grow excessively during scaling. An attacker could manipulate deposit and offset values to trigger this overflow, resulting in incorrect reward distributions and collateral gain calculations. The impact includes incorrect state updates, unfair reward allocation, and potential exploitation of miscalculated gains, though the risk is mitigated by the rarity of such edge cases.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::offset"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Pool Deposit Are Compared to Precision",
            "description": "The _updateYieldRewardsSum function compares total deposits to DECIMAL_PRECISION instead of the standard MIN_BOLD_IN_SP constant used elsewhere, despite both having the same value (1e18). While this does not result in functional bugs due to identical values, it introduces inconsistency and potential risk if constants are later changed independently. The cause is code duplication and lack of centralized constant usage. This could lead to future bugs if one constant is updated without the other. The impact is low, as no immediate exploit exists, but it represents a correctness issue in code consistency and maintainability.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1107"
                ]
            },
            "title": "Total Deposit Are Compared to Wrong Constant",
            "description": "Similar to the previous issue, _updateYieldRewardsSum uses DECIMAL_PRECISION instead of MIN_BOLD_IN_SP when checking total deposits for yield distribution thresholds. Although both constants are equal (1e18), this creates a discrepancy in codebase consistency. The root cause is redundant use of different constants for the same logical threshold. There is no immediate security impact, but it increases technical debt and risk of future divergence. The impact is limited to code clarity and maintainability, classified as a low-severity correctness issue.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Batches Can Be Used to Make Two Free Adjustments in a Row",
            "description": "Users can exploit the batch interest rate adjustment mechanism to perform two interest rate changes in a row without paying the required upfront fee. The cause is that setBatchManagerAnnualInterestRate only checks the batch's last adjustment time, not individual trove adjustments. A user can join a batch that was adjusted long ago, change its interest rate, and leave—effectively adjusting their own rate twice within the cooldown period. This allows strategic avoidance of redemption risk while minimizing cost. The impact includes unfair advantage, manipulation of interest rates, and potential abuse of the system's economic model, though the financial impact is limited.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::setInterestBatchManager",
                "BorrowerOperations.sol::setBatchManagerAnnualInterestRate"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Delegation Specification",
            "description": "The code initially allowed the receiver address (set by a Remove Manager) to receive collateral during any withdrawal, including those initiated by the owner, contrary to the documentation which states the receiver only gets funds during Remove Manager actions. The cause is a mismatch between specification and implementation. This could lead to user funds being sent to an unintended address if the receiver is set and the owner withdraws. The impact is potential loss of user funds and confusion due to undocumented behavior. The issue was corrected to align code with documentation.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::withdrawCollateral"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unredeemable Troves Can Pay Minimum Interest Rate",
            "description": "Troves with debt below MIN_DEBT are marked as unredeemable (zombie troves) and excluded from redemption lists, removing the risk of redemption and thus the incentive to pay higher interest rates. An attacker can create many such troves to pay only the minimum interest, gaining an unfair economic advantage. The cause is the design decision to exclude small troves from redemption lists. While mitigated by gas and capital costs, the strategy could still be profitable under certain conditions. The partial fix ensures zombie troves are redeemed first during redemptions, but an edge case remains where liquidated troves with zero debt can still become unredeemable and pay minimal interest. The impact is economic inefficiency and potential abuse of the interest model.\n",
            "severity": "Medium",
            "location": [
                "TroveManager.sol",
                "RedemptionLogic.sol"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation of Troves in Urgent Redemptions",
            "description": "The `TroveManager.urgentRedemption` function does not validate whether a trove exists, is active, or has debt before processing, leading to unnecessary gas consumption and storage writes.\n\nThe cause is input validation for trove status and debt amount is missing in the function logic.\n\nAn attacker could submit redemption requests for non-existent or closed troves, causing the system to perform redundant storage operations and waste gas.\n\nIncreased gas costs for transactions and unnecessary state bloat. While no critical state corruption occurs, external applications reading from storage may observe incorrect or stale data.\n",
            "severity": "Low",
            "location": [
                "TroveManager.urgentRedemption",
                "TroveManager._applySingleRedemption"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Opening Troves Can Be Blocked",
            "description": "The trove ID in `BorrowerOperations._openTrove` is derived only from the owner and owner index, making it predictable and susceptible to frontrunning. An attacker can open a trove with the same ID, set themselves as manager, and steal the collateral.\n\nThe cause is that the trove ID does not include the caller (`msg.sender`), allowing anyone to replicate the ID and preempt the intended user.\n\nAn attacker monitors pending transactions and frontruns a trove creation by submitting their own with the same owner and index, becoming the manager and later withdrawing the collateral.\n\nUsers, especially multisigs or governance systems with delayed execution, can be permanently prevented from opening troves, leading to denial of service and potential loss of funds if the attacker withdraws collateral.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations._openTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Shutdown Can Be Triggered Twice",
            "description": "The `shutdown` function in `BorrowerOperations` can be called when the TCR is below SCR, but it also calls `priceFeed.fetchPrice()`, which may independently trigger a shutdown due to oracle failure, resulting in two shutdown events.\n\nThe cause is that the function does not check whether the oracle call already caused a shutdown before proceeding with the TCR-based shutdown logic.\n\nIf both conditions occur simultaneously, two shutdown events are emitted, which may confuse off-chain monitoring systems that expect mutually exclusive shutdown causes.\n\nIncorrect event logging and potential misinterpretation by external systems, though no functional harm occurs due to idempotent shutdown logic.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.shutdown"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Gas Optimizations in StabilityPool",
            "description": "Several gas inefficiencies were identified in the `StabilityPool` contract, including unnecessary checks, redundant arithmetic, and ineffective function calls.\n\nThe cause is suboptimal code structure and lack of early returns or simplifications in yield calculation and withdrawal logic.\n\nThese inefficiencies increase transaction costs for users but do not enable malicious exploitation.\n\nHigher gas consumption for depositors and withdrawers, reducing user experience and increasing operational costs.\n",
            "severity": "Informational",
            "location": [
                "StabilityPool.getDepositorYieldGainWithPending",
                "StabilityPool.withdrawFromSP"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Minting Unbacked Tokens via Redistributions",
            "description": "A rounding issue in debt share calculations allowed attackers to mint unbacked tokens by manipulating exchange rates and triggering redistributions.\n\nThe cause is that debt redistribution logic did not account for rounding down when calculating debt shares, allowing debt to be allocated without corresponding shares.\n\nAn attacker could open troves, manipulate exchange rates, and trigger redistributions to increase debt without minting shares, effectively creating unbacked tokens.\n\nRisk of protocol insolvency if exploited at scale, particularly in low-liquidity branches.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._getLatestTroveDataFromBatch",
                "TroveManager.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing Events",
            "description": "The `AddRemoveManager._setAddManager` and `_setRemoveManager` functions do not emit events when manager roles are updated.\n\nThe cause is event emission was omitted during implementation.\n\nUsers cannot track changes to manager roles, especially after transferring Trove NFTs.\n\nReduced transparency and auditability, making it harder for users to monitor access control changes.\n",
            "severity": "Informational",
            "location": [
                "AddRemoveManager._setAddManager",
                "AddRemoveManager._setRemoveManager"
            ],
            "files": [
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Bypassing Collateral Adjustment Check",
            "description": "The function BorrowerOperations._requireValidAdjustmentInCurrentMode prevents reducing collateral in undercollateralized troves (ICR < MCR). However, this check can be bypassed via self-redemptions: a user can first adjust the interest rate of their trove to be the lowest in the branch, then redeem from it. This sequence allows indirect reduction of collateral in an undercollateralized state. While Liquity acknowledges this behavior, they argue it does not allow converting a healthy trove into an undercollateralized one, thus posing minimal risk. Nevertheless, this represents a deviation from expected system invariants.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._requireValidAdjustmentInCurrentMode"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Insufficient Gas Compensation Could Mint Bad Debt",
            "description": "The system relies on gas compensation to incentivize liquidations. If the gas cost exceeds the compensation, liquidators may not act, leading to accumulation of bad debt. This can occur during prolonged periods of high gas prices or falling collateral values. An attacker could exploit this by creating a batch with maximum interest rate and joining the Stability Pool, allowing unbacked tokens to be minted via interest accrual if the trove remains unliquidated. Although such attacks carry risk (anyone can liquidate at a loss to punish the attacker), they illustrate a theoretical pathway for minting unbacked debt. The risk is considered low due to economic disincentives and prioritization of large troves for liquidation.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Upfront Fee Is Zero for Small Borrows",
            "description": "The upfront fee in BorrowerOperations._calcUpfrontFee is calculated as a fraction of debt and interest rate over time. Due to precision limitations, the fee rounds to zero for small borrows. For instance, with a 0.5% average interest rate, any borrow below 10,400 wei pays no fee. Similarly, interest accrual on small troves may also round to zero. This primarily affects zombie troves with negligible debt. Liquity acknowledges the issue but deems the impact negligible at both user and system levels.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._calcUpfrontFee",
                "_calcInterest"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Upfrontfee Can Bring Troves Below MCR",
            "description": "While BorrowerOperations._applyUpfrontFee includes a check to ensure ICR remains above MCR, the function setBatchManagerAnnualInterestRate lacks this protection. As a result, charging an upfront fee during a batch interest rate adjustment could push a trove below MCR. However, interest can only be adjusted once per second, limiting the potential for repeated manipulation within a block. In Version 5, a 10% collateral buffer was introduced to prevent single-transaction liquidation exploits. This mitigates the most critical variant where a user could open a trove at 110%, pay an upfront fee, and immediately liquidate it in one transaction. The attack is now only possible over time.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._applyUpfrontFee",
                "setBatchManagerAnnualInterestRate"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "rETH Address Might Change",
            "description": "The rETH token address is set once in the AddressesRegistry and cannot be updated. However, Rocket Pool recommends retrieving addresses dynamically from their registry contract rather than hardcoding them. Although Liquity contacted Rocket Pool and was assured the rETH address is unlikely to change, the current design does not support migration if it ever does. This creates a potential long-term integration risk, especially if Rocket Pool upgrades its token contract.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry"
            ],
            "files": [
                "bold/contracts/src/AddressesRegistry.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Add Manager Can Increase Stake",
            "description": "The addManager role allows anyone to add collateral to a trove. While this improves collateralization, it also increases the trove’s stake in the system. In extreme cases involving negative redistributions (where debt increases more than collateral), an attacker could manipulate another user’s trove to increase their share of losses. Users can mitigate this by setting the addManager to their own address, effectively disabling third-party deposits.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "CCR and SCR Considerations",
            "description": "The Close Crowdfunding Ratio (CCR) and Shutdown Collateralization Ratio (SCR) must be sufficiently far apart to prevent attackers from frontrunning oracle updates to trigger branch shutdowns. If CCR is too close to SCR, a price drop could be exploited to force a shutdown. This mirrors known attacks in Liquity V1. The proposed values (CCR=1.5, SCR=1.1) are considered safe, but future deployments with tighter margins should evaluate this risk.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/AddressesRegistry.sol"
            ]
        },
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Delegations Are Deleted on Liquidation",
            "description": "Upon liquidation, all delegations for a trove are deleted via the _BorrowerOperations.onLiquidateTrove hook. Only the trove owner can reclaim surplus collateral; delegated accounts cannot. If the owner is a smart contract, it must implement claimCollateral() directly and cannot rely on delegation. Failure to do so risks permanent loss of surplus collateral.\n",
            "severity": "Informational",
            "location": [
                "_BorrowerOperations.onLiquidateTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Fully Backed Branches Can Have Low Interest Rates",
            "description": "Branches with more BOLD in Stability Pool than outstanding debt are \"fully backed\" and immune to redemptions. This removes the incentive to maintain high interest rates, leading to rate drops to the minimum. If the branch later becomes unbacked (via withdrawals, liquidations, or new debt), troves may face sudden redemption pressure. The system may self-correct if Stability Pool deposits decrease due to lower yields, but the dynamics are uncertain.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Integration Notes for Smart Contract Devs",
            "description": "Several behaviors may surprise integrators:\n- repayBold and adjustTrove repay only up to MIN_DEBT, leaving excess with caller.\n- withdrawFromSP withdraws full balance if _amount exceeds user’s deposit.\n- Trove state can change between calls due to batch-wide effects (e.g., rounding).\nContracts must handle partial executions and dynamic state changes.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations.repayBold",
                "BorrowerOperations.adjustTrove",
                "StabilityPool.withdrawFromSP",
                "TroveManager.getLatestTroveData"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Interest Rate Adjustments Below CCR",
            "description": "When TCR falls below CCR, debt-increasing operations (including upfront fee payments for interest rate adjustments) are blocked. This prevents users from increasing their interest rate to avoid redemptions once below CCR. Users must act before crossing this threshold, as adjustments are subject to a cooldown period.\n",
            "severity": "Informational",
            "location": [
                "INTEREST_RATE_ADJ_COOLDOWN"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Manipulating Bold Supply With Flashloans",
            "description": "Users can use flashloans to inflate BOLD supply temporarily, reducing redemption fees (which are proportional to supply). For example, doubling supply halves the fee on large redemptions. If the average interest rate post-borrow is low (e.g., 1%), this can be profitable. Users can avoid self-redemption by depositing minted BOLD into the Stability Pool. This behavior is economically rational but may distort fee mechanisms.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/BoldToken.sol"
            ]
        },
        {
            "id": 54,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Trove Shares Exchange Rate Invariant",
            "description": "The function TroveManager._updateBatchShares() rounds down when reducing debt, which can slightly reduce debt per share. While the protocol assumes a 1:1 debt-to-share ratio, rounding could theoretically cause discrepancies. In extreme cases, this could lead to overflow in debt calculations (e.g., when totalDebtShares is extremely large). Full redemptions may leave residual shares due to division truncation. In Version 2, full closures now set shares to zero to avoid this. The core invariant — that debt per share never falls below 1 — must be preserved.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._updateBatchShares",
                "TroveManager._getLatestTroveDataFromBatch"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        }
    ],
    "affected_files": {
        "AddRemoveManagers.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.18;\n\nimport \"../Interfaces/IAddRemoveManagers.sol\";\nimport \"../Interfaces/IAddressesRegistry.sol\";\nimport \"../Interfaces/ITroveNFT.sol\";\n\ncontract AddRemoveManagers is IAddRemoveManagers {\n    ITroveNFT internal immutable troveNFT;\n\n    struct RemoveManagerReceiver {\n        address manager;\n        address receiver;\n    }\n\n    /*\n     * Mapping from TroveId to granted address for operations that \"give\" money to the trove (add collateral, pay debt).\n     * Useful for instance for cold/hot wallet setups.\n     * If its value is zero address, any address is allowed to do those operations on behalf of trove owner.\n     * Otherwise, only the address in this mapping (and the trove owner) will be allowed.\n     * To restrict this permission to no one, trove owner should be set in this mapping.\n     */\n    mapping(uint256 => address) public addManagerOf;\n\n    /*\n     * Mapping from TroveId to granted addresses for operations that \"withdraw\" money from the trove (withdraw collateral, borrow),\n     * and for each of those addresses another address for the receiver of those withdrawn funds.\n     * Useful for instance for cold/hot wallet setups or for automations.\n     * Only the address in this mapping, if any, and the trove owner, will be allowed.\n     * Therefore, by default this permission is restricted to no one.\n     * If the receiver is zero, the owner is assumed as the receiver.\n     */\n    mapping(uint256 => RemoveManagerReceiver) public removeManagerReceiverOf;\n\n    error EmptyManager();\n    error NotBorrower();\n    error NotOwnerNorAddManager();\n    error NotOwnerNorRemoveManager();\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        troveNFT = _addressesRegistry.troveNFT();\n        emit TroveNFTAddressChanged(address(troveNFT));\n    }\n\n    function setAddManager(uint256 _troveId, address _manager) external {\n        _requireCallerIsBorrower(_troveId);\n        _setAddManager(_troveId, _manager);\n    }\n\n    function _setAddManager(uint256 _troveId, address _manager) internal {\n        addManagerOf[_troveId] = _manager;\n    }\n\n    function setRemoveManager(uint256 _troveId, address _manager) external {\n        setRemoveManagerWithReceiver(_troveId, _manager, troveNFT.ownerOf(_troveId));\n    }\n\n    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) public {\n        _requireCallerIsBorrower(_troveId);\n        _setRemoveManagerAndReceiver(_troveId, _manager, _receiver);\n    }\n\n    function _setRemoveManagerAndReceiver(uint256 _troveId, address _manager, address _receiver) internal {\n        _requireNonZeroManagerUnlessWiping(_manager, _receiver);\n        removeManagerReceiverOf[_troveId].manager = _manager;\n        removeManagerReceiverOf[_troveId].receiver = _receiver;\n    }\n\n    function _requireNonZeroManagerUnlessWiping(address _manager, address _receiver) internal pure {\n        if (_manager == address(0) && _receiver != address(0)) {\n            revert EmptyManager();\n        }\n    }\n\n    function _requireCallerIsBorrower(uint256 _troveId) internal view {\n        if (msg.sender != troveNFT.ownerOf(_troveId)) {\n            revert NotBorrower();\n        }\n    }\n\n    function _requireSenderIsOwnerOrAddManager(uint256 _troveId, address _owner) internal view {\n        address addManager = addManagerOf[_troveId];\n        if (msg.sender != _owner && addManager != address(0) && msg.sender != addManager) {\n            revert NotOwnerNorAddManager();\n        }\n    }\n\n    function _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(uint256 _troveId, address _owner)\n        internal\n        view\n        returns (address)\n    {\n        address manager = removeManagerReceiverOf[_troveId].manager;\n        address receiver = removeManagerReceiverOf[_troveId].receiver;\n        if (msg.sender != _owner && msg.sender != manager) {\n            revert NotOwnerNorRemoveManager();\n        }\n        if (receiver == address(0)) {\n            return _owner;\n        }\n        return receiver;\n    }\n}\n",
        "TroveManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveEvents.sol\";\nimport \"./Interfaces/ITroveNFT.sol\";\nimport \"./Interfaces/ICollateralRegistry.sol\";\nimport \"./Interfaces/IWETH.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract TroveManager is LiquityBase, ITroveManager, ITroveEvents {\n    // --- Connected contract declarations ---\n\n    ITroveNFT public troveNFT;\n    IBorrowerOperations public borrowerOperations;\n    IStabilityPool public stabilityPool;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n    ICollateralRegistry internal collateralRegistry;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 internal immutable MCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 internal immutable SCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 internal immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 internal immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    // --- Data structures ---\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n    }\n\n    mapping(uint256 => Trove) public Troves;\n\n    // Store the necessary data for an interest batch manager. We treat each batch as a “big trove”.\n    // Each trove has a share of the debt and a share of the coll of the global batch (will in general be different, as CRs are different).\n    struct Batch {\n        uint256 debt;\n        uint256 coll;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        uint256 annualManagementFee;\n        uint256 totalDebtShares;\n    }\n\n    mapping(address => Batch) internal batches;\n\n    uint256 internal totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 internal totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 internal totalCollateralSnapshot;\n\n    /*\n    * L_coll and L_boldDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An Coll gain of ( stake * [L_coll - L_coll(0)] )\n    * A boldDebt increase  of ( stake * [L_boldDebt - L_boldDebt(0)] )\n    *\n    * Where L_coll(0) and L_boldDebt(0) are snapshots of L_coll and L_boldDebt for the active Trove taken at the instant the stake was made\n    */\n    uint256 internal L_coll;\n    uint256 internal L_boldDebt;\n\n    // Map active troves to their RewardSnapshot\n    mapping(uint256 => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the Coll and Bold snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 coll;\n        uint256 boldDebt;\n    }\n\n    // Array of all active trove addresses - used to compute an approximate hint off-chain, for the sorted list insertion\n    uint256[] internal TroveIds;\n    // Array of all batch managers - used to fetch them off-chain\n    address[] public batchIds;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 internal lastCollError_Redistribution;\n    uint256 internal lastBoldDebtError_Redistribution;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LiquidationValues {\n        uint256 collGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n        uint256 ETHGasCompensation;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct SingleRedemptionValues {\n        uint256 troveId;\n        address batchAddress;\n        uint256 boldLot;\n        uint256 collLot;\n        uint256 collFee;\n        uint256 appliedRedistBoldDebtGain;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n        uint256 newStake;\n        LatestTroveData trove;\n        LatestBatchData batch;\n    }\n\n    // --- Errors ---\n\n    error EmptyData();\n    error NothingToLiquidate();\n    error CallerNotBorrowerOperations();\n    error CallerNotCollateralRegistry();\n    error OnlyOneTroveLeft();\n    error NotShutDown();\n    error NotEnoughBoldBalance();\n    error MinCollNotReached(uint256 _coll);\n\n    // --- Events ---\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        CCR = _addressesRegistry.CCR();\n        MCR = _addressesRegistry.MCR();\n        SCR = _addressesRegistry.SCR();\n        LIQUIDATION_PENALTY_SP = _addressesRegistry.LIQUIDATION_PENALTY_SP();\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _addressesRegistry.LIQUIDATION_PENALTY_REDISTRIBUTION();\n\n        troveNFT = _addressesRegistry.troveNFT();\n        borrowerOperations = _addressesRegistry.borrowerOperations();\n        stabilityPool = _addressesRegistry.stabilityPool();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        boldToken = _addressesRegistry.boldToken();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        WETH = _addressesRegistry.WETH();\n        collateralRegistry = _addressesRegistry.collateralRegistry();\n\n        emit TroveNFTAddressChanged(address(troveNFT));\n        emit BorrowerOperationsAddressChanged(address(borrowerOperations));\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit BoldTokenAddressChanged(address(boldToken));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit CollateralRegistryAddressChanged(address(collateralRegistry));\n    }\n\n    // --- Getters ---\n\n    function getTroveIdsCount() external view override returns (uint256) {\n        return TroveIds.length;\n    }\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view override returns (uint256) {\n        return TroveIds[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove\n    function _liquidate(\n        IDefaultPool _defaultPool,\n        uint256 _troveId,\n        uint256 _boldInStabPool,\n        uint256 _price,\n        LatestTroveData memory trove,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        address owner = troveNFT.ownerOf(_troveId);\n\n        _getLatestTroveData(_troveId, trove);\n        address batchAddress = _getBatchManager(_troveId);\n        bool isTroveInBatch = batchAddress != address(0);\n        LatestBatchData memory batch;\n        if (isTroveInBatch) _getLatestBatchData(batchAddress, batch);\n\n        _movePendingTroveRewardsToActivePool(_defaultPool, trove.redistBoldDebtGain, trove.redistCollGain);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(trove.entireColl);\n        uint256 collToLiquidate = trove.entireColl - singleLiquidation.collGasCompensation;\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute,\n            singleLiquidation.collSurplus\n        ) = _getOffsetAndRedistributionVals(trove.entireDebt, collToLiquidate, _boldInStabPool, _price);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        _closeTrove(\n            _troveId,\n            troveChange,\n            batchAddress,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            Status.closedByLiquidation\n        );\n\n        if (isTroveInBatch) {\n            singleLiquidation.oldWeightedRecordedDebt =\n                batch.weightedRecordedDebt + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualInterestRate;\n            singleLiquidation.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n            // Mint batch management fee\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee\n                + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, batchAddress);\n        } else {\n            singleLiquidation.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n        }\n\n        // Differencen between liquidation penalty and liquidation threshold\n        if (singleLiquidation.collSurplus > 0) {\n            collSurplusPool.accountSurplus(owner, singleLiquidation.collSurplus);\n        }\n\n        // Wipe out state in BO\n        borrowerOperations.onLiquidateTrove(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.liquidate,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(trove.entireDebt),\n            _collIncreaseFromRedist: trove.redistCollGain,\n            _collChangeFromOperation: -int256(trove.entireColl)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[batchAddress].debt,\n            _coll: batches[batchAddress].coll,\n            _annualInterestRate: batch.annualInterestRate,\n            _annualManagementFee: batch.annualManagementFee,\n            _totalDebtShares: batches[batchAddress].totalDebtShares\n        });\n    }\n\n    // Return the amount of Coll to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {\n        return LiquityMath._min(_entireColl / COLL_GAS_COMPENSATION_DIVISOR, COLL_GAS_COMPENSATION_CAP);\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        uint256 _collToLiquidate, // gas compensation is already subtracted\n        uint256 _boldInStabPool,\n        uint256 _price\n    )\n        internal\n        view\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute,\n            uint256 collSurplus\n        )\n    {\n        uint256 collSPPortion;\n        /*\n         * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n         * between all active troves.\n         *\n         *  If the trove's debt is larger than the deposited Bold in the Stability Pool:\n         *\n         *  - Offset an amount of the trove's debt equal to the Bold in the Stability Pool\n         *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n         *\n         */\n        if (_boldInStabPool > 0) {\n            debtToOffset = LiquityMath._min(_entireTroveDebt, _boldInStabPool);\n            collSPPortion = _collToLiquidate * debtToOffset / _entireTroveDebt;\n            (collToSendToSP, collSurplus) =\n                _getCollPenaltyAndSurplus(collSPPortion, debtToOffset, LIQUIDATION_PENALTY_SP, _price);\n        }\n\n        // Redistribution\n        debtToRedistribute = _entireTroveDebt - debtToOffset;\n        if (debtToRedistribute > 0) {\n            uint256 collRedistributionPortion = _collToLiquidate - collSPPortion;\n            if (collRedistributionPortion > 0) {\n                (collToRedistribute, collSurplus) = _getCollPenaltyAndSurplus(\n                    collRedistributionPortion + collSurplus, // Coll surplus from offset can be eaten up by red. penalty\n                    debtToRedistribute,\n                    LIQUIDATION_PENALTY_REDISTRIBUTION, // _penaltyRatio\n                    _price\n                );\n            }\n        }\n        // assert(_collToLiquidate == collToSendToSP + collToRedistribute + collSurplus);\n    }\n\n    function _getCollPenaltyAndSurplus(\n        uint256 _collToLiquidate,\n        uint256 _debtToLiquidate,\n        uint256 _penaltyRatio,\n        uint256 _price\n    ) internal pure returns (uint256 seizedColl, uint256 collSurplus) {\n        uint256 maxSeizedColl = _debtToLiquidate * (DECIMAL_PRECISION + _penaltyRatio) / _price;\n        if (_collToLiquidate > maxSeizedColl) {\n            seizedColl = maxSeizedColl;\n            collSurplus = _collToLiquidate - maxSeizedColl;\n        } else {\n            seizedColl = _collToLiquidate;\n            collSurplus = 0;\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(uint256[] memory _troveArray) public override {\n        if (_troveArray.length == 0) {\n            revert EmptyData();\n        }\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        TroveChange memory troveChange;\n        LiquidationValues memory totals;\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n        uint256 boldInStabPool = stabilityPoolCached.getTotalBoldDeposits();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        _batchLiquidateTroves(defaultPoolCached, price, boldInStabPool, _troveArray, totals, troveChange);\n\n        if (troveChange.debtDecrease == 0) {\n            revert NothingToLiquidate();\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        // Move liquidated Coll and Bold to the appropriate pools\n        if (totals.debtToOffset > 0 || totals.collToSendToSP > 0) {\n            stabilityPoolCached.offset(totals.debtToOffset, totals.collToSendToSP);\n        }\n        // we check amount is not zero inside\n        _redistributeDebtAndColl(\n            activePoolCached, defaultPoolCached, totals.debtToRedistribute, totals.collToRedistribute\n        );\n        if (totals.collSurplus > 0) {\n            activePoolCached.sendColl(address(collSurplusPool), totals.collSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.collGasCompensation);\n\n        emit Liquidation(\n            totals.debtToOffset,\n            totals.debtToRedistribute,\n            totals.ETHGasCompensation,\n            totals.collGasCompensation,\n            totals.collToSendToSP,\n            totals.collToRedistribute,\n            totals.collSurplus,\n            L_coll,\n            L_boldDebt,\n            price\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, totals.ETHGasCompensation, totals.collGasCompensation);\n    }\n\n    function _isLiquidatableStatus(Status _status) internal pure returns (bool) {\n        return _status == Status.active || _status == Status.unredeemable;\n    }\n\n    function _batchLiquidateTroves(\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _boldInStabPool,\n        uint256[] memory _troveArray,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal {\n        uint256 remainingBoldInStabPool = _boldInStabPool;\n\n        for (uint256 i = 0; i < _troveArray.length; i++) {\n            uint256 troveId = _troveArray[i];\n\n            // Skip non-liquidatable troves\n            if (!_isLiquidatableStatus(Troves[troveId].status)) continue;\n\n            uint256 ICR = getCurrentICR(troveId, _price);\n\n            if (ICR < MCR) {\n                LiquidationValues memory singleLiquidation;\n                LatestTroveData memory trove;\n\n                _liquidate(_defaultPool, troveId, remainingBoldInStabPool, _price, trove, singleLiquidation);\n                remainingBoldInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                _addLiquidationValuesToTotals(trove, singleLiquidation, totals, troveChange);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    // Adds all values from `singleLiquidation` to their respective totals in `totals` in-place\n    function _addLiquidationValuesToTotals(\n        LatestTroveData memory _trove,\n        LiquidationValues memory _singleLiquidation,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal pure {\n        // Tally all the values with their respective running totals\n        totals.collGasCompensation += _singleLiquidation.collGasCompensation;\n        totals.ETHGasCompensation += ETH_GAS_COMPENSATION;\n        troveChange.debtDecrease += _trove.entireDebt;\n        troveChange.collDecrease += _trove.entireColl;\n        troveChange.appliedRedistBoldDebtGain += _trove.redistBoldDebtGain;\n        troveChange.oldWeightedRecordedDebt += _singleLiquidation.oldWeightedRecordedDebt;\n        troveChange.newWeightedRecordedDebt += _singleLiquidation.newWeightedRecordedDebt;\n        totals.debtToOffset += _singleLiquidation.debtToOffset;\n        totals.collToSendToSP += _singleLiquidation.collToSendToSP;\n        totals.debtToRedistribute += _singleLiquidation.debtToRedistribute;\n        totals.collToRedistribute += _singleLiquidation.collToRedistribute;\n        totals.collSurplus += _singleLiquidation.collSurplus;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _eth, uint256 _coll) internal {\n        if (_eth > 0) {\n            WETH.transferFrom(gasPoolAddress, _liquidator, _eth);\n        }\n\n        if (_coll > 0) {\n            _activePool.sendColl(_liquidator, _coll);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IDefaultPool _defaultPool, uint256 _bold, uint256 _coll) internal {\n        if (_bold > 0) {\n            _defaultPool.decreaseBoldDebt(_bold);\n        }\n\n        if (_coll > 0) {\n            _defaultPool.sendCollToActivePool(_coll);\n        }\n    }\n\n    // --- Redemption functions ---\n\n    function _applySingleRedemption(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        // Decrease the debt and collateral of the current Trove according to the Bold lot and corresponding ETH to send\n        uint256 newDebt = _singleRedemption.trove.entireDebt - _singleRedemption.boldLot;\n        uint256 newColl = _singleRedemption.trove.entireColl - _singleRedemption.collLot;\n\n        _singleRedemption.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n\n        if (_isTroveInBatch) {\n            _getLatestBatchData(_singleRedemption.batchAddress, _singleRedemption.batch);\n            // We know boldLot <= trove entire debt, so this subtraction is safe\n            uint256 newAmountForWeightedDebt = _singleRedemption.batch.entireDebtWithoutRedistribution\n                + _singleRedemption.trove.redistBoldDebtGain - _singleRedemption.boldLot;\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.batch.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualInterestRate;\n\n            TroveChange memory troveChange;\n            troveChange.debtDecrease = _singleRedemption.boldLot;\n            troveChange.collDecrease = _singleRedemption.collLot;\n            troveChange.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n            troveChange.appliedRedistCollGain = _singleRedemption.trove.redistCollGain;\n            // batchAccruedManagementFee is handled in the outer function\n            troveChange.oldWeightedRecordedBatchManagementFee =\n                _singleRedemption.batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualManagementFee;\n\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, _singleRedemption.batchAddress);\n\n            Troves[_singleRedemption.troveId].coll = newColl;\n            // interest and fee were updated in the outer function\n            _updateBatchShares(\n                _singleRedemption.troveId,\n                _singleRedemption.batchAddress,\n                troveChange,\n                _singleRedemption.batch.entireCollWithoutRedistribution,\n                _singleRedemption.batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.trove.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt = newDebt * _singleRedemption.trove.annualInterestRate;\n            Troves[_singleRedemption.troveId].debt = newDebt;\n            Troves[_singleRedemption.troveId].coll = newColl;\n            Troves[_singleRedemption.troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _singleRedemption.newStake = _updateStakeAndTotalStakes(_singleRedemption.troveId, newColl);\n        _movePendingTroveRewardsToActivePool(\n            _defaultPool, _singleRedemption.trove.redistBoldDebtGain, _singleRedemption.trove.redistCollGain\n        );\n        _updateTroveRewardSnapshots(_singleRedemption.troveId);\n\n        if (_isTroveInBatch) {\n            emit BatchedTroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _batchDebtShares: Troves[_singleRedemption.troveId].batchDebtShares,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        } else {\n            emit TroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _debt: newDebt,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        }\n\n        emit TroveOperation({\n            _troveId: _singleRedemption.troveId,\n            _operation: Operation.redeemCollateral,\n            _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n            _debtIncreaseFromRedist: _singleRedemption.trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(_singleRedemption.boldLot),\n            _collIncreaseFromRedist: _singleRedemption.trove.redistCollGain,\n            _collChangeFromOperation: -int256(_singleRedemption.collLot)\n        });\n\n        emit RedemptionFeePaidToTrove(_singleRedemption.troveId, _singleRedemption.collFee);\n\n        return newDebt;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _redeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        uint256 _redemptionRate\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of Coll equal in USD value to the boldLot redeemed\n        uint256 correspondingColl = _singleRedemption.boldLot * DECIMAL_PRECISION / _price;\n        // Calculate the collFee separately (for events)\n        _singleRedemption.collFee = correspondingColl * _redemptionRate / DECIMAL_PRECISION;\n        // Get the final collLot to send to redeemer, leaving the fee in the Trove\n        _singleRedemption.collLot = correspondingColl - _singleRedemption.collFee;\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        uint256 newDebt = _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // Make Trove unredeemable if it's tiny, in order to prevent griefing future (normal, sequential) redemptions\n        if (newDebt < MIN_DEBT) {\n            Troves[_singleRedemption.troveId].status = Status.unredeemable;\n            if (isTroveInBatch) {\n                sortedTroves.removeFromBatch(_singleRedemption.troveId);\n            } else {\n                sortedTroves.remove(_singleRedemption.troveId);\n            }\n        }\n    }\n\n    function _updateBatchInterestPriorToRedemption(IActivePool _activePool, address _batchAddress) internal {\n        LatestBatchData memory batch;\n        _getLatestBatchData(_batchAddress, batch);\n        batches[_batchAddress].debt = batch.entireDebtWithoutRedistribution;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        // As we are updating the batch, we update the ActivePool weighted sum too\n        TroveChange memory batchTroveChange;\n        batchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchTroveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchTroveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchTroveChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n\n        _activePool.mintAggInterestAndAccountForTroveChange(batchTroveChange, _batchAddress);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batch.entireDebtWithoutRedistribution,\n            _coll: batch.entireCollWithoutRedistribution,\n            _annualInterestRate: batch.annualInterestRate,\n            _annualManagementFee: batch.annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    /* Send _boldamount Bold to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies redistribution gains to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining Bold amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        address _redeemer,\n        uint256 _boldamount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external override returns (uint256 _redemeedAmount) {\n        _requireCallerIsCollateralRegistry();\n\n        IActivePool activePoolCached = activePool;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        TroveChange memory totalsTroveChange;\n        uint256 totalCollFee;\n\n        uint256 remainingBold = _boldamount;\n\n        SingleRedemptionValues memory singleRedemption;\n        singleRedemption.troveId = sortedTrovesCached.getLast();\n        address lastBatchUpdatedInterest = address(0);\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of Bold is exchanged for collateral\n        if (_maxIterations == 0) _maxIterations = type(uint256).max;\n        while (singleRedemption.troveId != 0 && remainingBold > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the uint256 of the Trove preceding the current one\n            uint256 nextUserToCheck = sortedTrovesCached.getPrev(singleRedemption.troveId);\n            // Skip if ICR < 100%, to make sure that redemptions always improve the CR of hit Troves\n            if (getCurrentICR(singleRedemption.troveId, _price) < _100pct) {\n                singleRedemption.troveId = nextUserToCheck;\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // We do it here outside, to avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (\n                singleRedemption.batchAddress != address(0) && singleRedemption.batchAddress != lastBatchUpdatedInterest\n            ) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n                lastBatchUpdatedInterest = singleRedemption.batchAddress;\n            }\n\n            _redeemCollateralFromTrove(defaultPool, singleRedemption, remainingBold, _price, _redemptionRate);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n            totalCollFee += singleRedemption.collFee;\n\n            remainingBold -= singleRedemption.boldLot;\n            singleRedemption.troveId = nextUserToCheck;\n        }\n\n        // We are removing this condition to prevent blocking redemptions\n        //require(totals.totalCollDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        emit Redemption(\n            _boldamount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, totalCollFee, _price\n        );\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed Coll to sender\n        activePoolCached.sendColl(_redeemer, totalsTroveChange.collDecrease);\n        // We’ll burn all the Bold together out in the CollateralRegistry, to save gas\n\n        return totalsTroveChange.debtDecrease;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _urgentRedeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        SingleRedemptionValues memory _singleRedemption\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of ETH equal in USD value to the BOLD lot redeemed\n        _singleRedemption.collLot = _singleRedemption.boldLot * (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS) / _price;\n        // As here we can redeem when CR < 100%, we need to cap by collateral too\n        if (_singleRedemption.collLot > _singleRedemption.trove.entireColl) {\n            _singleRedemption.collLot = _singleRedemption.trove.entireColl;\n            _singleRedemption.boldLot =\n                _singleRedemption.trove.entireColl * _price / (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS);\n        }\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // No need to make this Trove unredeemable if it has tiny debt, since:\n        // - This collateral branch has shut down and urgent redemptions are enabled\n        // - Urgent redemptions aren't sequential, so they can't be griefed by tiny Troves.\n    }\n\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external {\n        _requireIsShutDown();\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        IActivePool activePoolCached = activePool;\n        TroveChange memory totalsTroveChange;\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n\n        uint256 remainingBold = _boldAmount;\n        for (uint256 i = 0; i < _troveIds.length; i++) {\n            SingleRedemptionValues memory singleRedemption;\n            singleRedemption.troveId = _troveIds[i];\n\n            // If it’s in a batch, we need to update interest first\n            // As we don’t have them ordered now, we cannot avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (singleRedemption.batchAddress != address(0)) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n            }\n\n            _urgentRedeemCollateralFromTrove(defaultPool, remainingBold, price, singleRedemption);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n\n            remainingBold -= singleRedemption.boldLot;\n            if (remainingBold == 0) break;\n        }\n\n        if (totalsTroveChange.collDecrease < _minCollateral) {\n            revert MinCollNotReached(totalsTroveChange.collDecrease);\n        }\n\n        emit Redemption(_boldAmount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, 0, price);\n\n        // Since this branch is shut down, this will mint 0 interest.\n        // We call this only to update the aggregate debt and weighted debt trackers.\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed coll to caller\n        activePoolCached.sendColl(msg.sender, totalsTroveChange.collDecrease);\n        // Burn bold\n        boldToken.burn(msg.sender, totalsTroveChange.debtDecrease);\n    }\n\n    function shutdown() external {\n        _requireCallerIsBorrowerOperations();\n        shutdownTime = block.timestamp;\n        activePool.setShutdownFlag();\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(uint256 _troveId, uint256 _price) public view override returns (uint256) {\n        LatestTroveData memory trove;\n        _getLatestTroveData(_troveId, trove);\n        return LiquityMath._computeCR(trove.entireColl, trove.entireDebt, _price);\n    }\n\n    function _updateTroveRewardSnapshots(uint256 _troveId) internal {\n        rewardSnapshots[_troveId].coll = L_coll;\n        rewardSnapshots[_troveId].boldDebt = L_boldDebt;\n    }\n\n    // Return the Troves entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestTroveData(uint256 _troveId, LatestTroveData memory trove) internal view {\n        // If trove belongs to a batch, we fetch the batch and apply its share to obtained values\n        address batchAddress = _getBatchManager(_troveId);\n        if (batchAddress != address(0)) {\n            LatestBatchData memory batch;\n            _getLatestBatchData(batchAddress, batch);\n            _getLatestTroveDataFromBatch(_troveId, batchAddress, trove, batch);\n            return;\n        }\n\n        uint256 stake = Troves[_troveId].stake;\n        trove.redistBoldDebtGain = stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        trove.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        trove.recordedDebt = Troves[_troveId].debt;\n        trove.annualInterestRate = Troves[_troveId].annualInterestRate;\n        trove.weightedRecordedDebt = trove.recordedDebt * trove.annualInterestRate;\n\n        uint256 period = _getInterestPeriod(Troves[_troveId].lastDebtUpdateTime);\n        trove.accruedInterest = _calcInterest(trove.weightedRecordedDebt, period);\n\n        trove.entireDebt = trove.recordedDebt + trove.redistBoldDebtGain + trove.accruedInterest;\n        trove.entireColl = Troves[_troveId].coll + trove.redistCollGain;\n        trove.lastInterestRateAdjTime = Troves[_troveId].lastInterestRateAdjTime;\n    }\n\n    function _getLatestTroveDataFromBatch(\n        uint256 _troveId,\n        address _batchAddress,\n        LatestTroveData memory _latestTroveData,\n        LatestBatchData memory _latestBatchData\n    ) internal view {\n        Trove memory trove = Troves[_troveId];\n        Batch memory batch = batches[_batchAddress];\n        uint256 batchDebtShares = trove.batchDebtShares;\n        uint256 totalDebtShares = batch.totalDebtShares;\n\n        uint256 stake = trove.stake;\n        //uint256 batchRedistBoldDebtGain = stake * (L_boldDebt - rewardBatchSnapshots[_batchAddress].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistBoldDebtGain =\n            stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        if (totalDebtShares > 0) {\n            _latestTroveData.recordedDebt = _latestBatchData.recordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.weightedRecordedDebt =\n                _latestBatchData.weightedRecordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedInterest = _latestBatchData.accruedInterest * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedBatchManagementFee =\n                _latestBatchData.accruedManagementFee * batchDebtShares / totalDebtShares;\n        }\n        _latestTroveData.annualInterestRate = _latestBatchData.annualInterestRate;\n\n        // We can’t do pro-rata batch entireDebt, because redist gains are proportional to coll, not to debt\n        _latestTroveData.entireDebt = _latestTroveData.recordedDebt + _latestTroveData.redistBoldDebtGain\n            + _latestTroveData.accruedInterest + _latestTroveData.accruedBatchManagementFee;\n        _latestTroveData.entireColl = trove.coll + _latestTroveData.redistCollGain;\n        _latestTroveData.lastInterestRateAdjTime =\n            LiquityMath._max(_latestBatchData.lastInterestRateAdjTime, trove.lastInterestRateAdjTime);\n    }\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory trove) {\n        _getLatestTroveData(_troveId, trove);\n    }\n\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256) {\n        Trove memory trove = Troves[_troveId];\n        address batchAddress = _getBatchManager(trove);\n        if (batchAddress != address(0)) {\n            return batches[batchAddress].annualInterestRate;\n        }\n        return trove.annualInterestRate;\n    }\n\n    function _getBatchManager(uint256 _troveId) internal view returns (address) {\n        return Troves[_troveId].interestBatchManager;\n    }\n\n    function _getBatchManager(Trove memory trove) internal pure returns (address) {\n        return trove.interestBatchManager;\n    }\n\n    // Return the Batch entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestBatchData(address _batchAddress, LatestBatchData memory latestBatchData) internal view {\n        Batch memory batch = batches[_batchAddress];\n\n        latestBatchData.recordedDebt = batch.debt;\n        latestBatchData.annualInterestRate = batch.annualInterestRate;\n        latestBatchData.weightedRecordedDebt = latestBatchData.recordedDebt * latestBatchData.annualInterestRate;\n        uint256 period = _getInterestPeriod(batch.lastDebtUpdateTime);\n        latestBatchData.accruedInterest = _calcInterest(latestBatchData.weightedRecordedDebt, period);\n        latestBatchData.annualManagementFee = batch.annualManagementFee;\n        latestBatchData.weightedRecordedBatchManagementFee =\n            latestBatchData.recordedDebt * latestBatchData.annualManagementFee;\n        latestBatchData.accruedManagementFee =\n            _calcInterest(latestBatchData.weightedRecordedBatchManagementFee, period);\n\n        latestBatchData.entireDebtWithoutRedistribution =\n            latestBatchData.recordedDebt + latestBatchData.accruedInterest + latestBatchData.accruedManagementFee;\n        latestBatchData.entireCollWithoutRedistribution = batch.coll;\n        latestBatchData.lastDebtUpdateTime = batch.lastDebtUpdateTime;\n        latestBatchData.lastInterestRateAdjTime = batch.lastInterestRateAdjTime;\n    }\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory batch) {\n        _getLatestBatchData(_batchAddress, batch);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(uint256 _troveId, uint256 _coll) internal returns (uint256 newStake) {\n        newStake = _computeNewStake(_coll);\n        uint256 oldStake = Troves[_troveId].stake;\n        Troves[_troveId].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the redistribution gains, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            // assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debtToRedistribute,\n        uint256 _collToRedistribute\n    ) internal {\n        if (_debtToRedistribute == 0) return;\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_coll and L_boldDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToRedistribute * DECIMAL_PRECISION + lastCollError_Redistribution;\n        uint256 boldDebtNumerator = _debtToRedistribute * DECIMAL_PRECISION + lastBoldDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint256 collRewardPerUnitStaked = collNumerator / totalStakes;\n        uint256 boldDebtRewardPerUnitStaked = boldDebtNumerator / totalStakes;\n\n        lastCollError_Redistribution = collNumerator - collRewardPerUnitStaked * totalStakes;\n        lastBoldDebtError_Redistribution = boldDebtNumerator - boldDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_coll = L_coll + collRewardPerUnitStaked;\n        L_boldDebt = L_boldDebt + boldDebtRewardPerUnitStaked;\n\n        _defaultPool.increaseBoldDebt(_debtToRedistribute);\n        _activePool.sendCollToDefaultPool(_collToRedistribute);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getCollBalance();\n        uint256 liquidatedColl = defaultPool.getCollBalance();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveIds array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveId(uint256 _troveId, uint256 TroveIdsArrayLength) internal {\n        uint64 index = Troves[_troveId].arrayIndex;\n        uint256 idxLast = TroveIdsArrayLength - 1;\n\n        // assert(index <= idxLast);\n\n        uint256 idToMove = TroveIds[idxLast];\n\n        TroveIds[index] = idToMove;\n        Troves[idToMove].arrayIndex = index;\n\n        TroveIds.pop();\n    }\n\n    function getTroveStatus(uint256 _troveId) external view override returns (Status) {\n        return Troves[_troveId].status;\n    }\n\n    // --- Interest rate calculations ---\n\n    function _getInterestPeriod(uint256 _lastDebtUpdateTime) internal view returns (uint256) {\n        if (shutdownTime == 0) {\n            // If branch is not shut down, interest is earned up to now.\n            return block.timestamp - _lastDebtUpdateTime;\n        } else if (shutdownTime > 0 && _lastDebtUpdateTime < shutdownTime) {\n            // If branch is shut down and the Trove was not updated since shut down, interest is earned up to the shutdown time.\n            return shutdownTime - _lastDebtUpdateTime;\n        } else {\n            // if (shutdownTime > 0 && _lastDebtUpdateTime >= shutdownTime)\n            // If branch is shut down and the Trove was updated after shutdown, no interest is earned since.\n            return 0;\n        }\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != address(borrowerOperations)) {\n            revert CallerNotBorrowerOperations();\n        }\n    }\n\n    function _requireCallerIsCollateralRegistry() internal view {\n        if (msg.sender != address(collateralRegistry)) {\n            revert CallerNotCollateralRegistry();\n        }\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint256 TroveIdsArrayLength) internal pure {\n        if (TroveIdsArrayLength == 1) {\n            revert OnlyOneTroveLeft();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (shutdownTime == 0) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        if (boldBalance < _amount) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    // --- Trove property getters ---\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool) {\n        uint256 totalDebt = getEntireSystemDebt();\n        uint256 spSize = stabilityPool.getTotalBoldDeposits();\n        uint256 unbackedPortion = totalDebt > spSize ? totalDebt - spSize : 0;\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n        // It's redeemable if the TCR is above the shutdown threshold, and branch has not been shut down\n        bool redeemable = _getTCR(price) >= SCR && shutdownTime == 0;\n\n        return (unbackedPortion, price, redeemable);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].debt = _troveChange.debtIncrease + _troveChange.upfrontFee;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _annualInterestRate;\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _troveChange.debtIncrease + _troveChange.upfrontFee,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _annualInterestRate: _annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTrove,\n            _annualInterestRate: _annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n    }\n\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].interestBatchManager = _batchAddress;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _batchColl, _batchDebt);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTroveAndJoinBatch,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function setTroveStatusToActive(uint256 _troveId) external {\n        _requireCallerIsBorrowerOperations();\n        Troves[_troveId].status = Status.active;\n    }\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTroveInterestRate,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n    }\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newColl);\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: newStake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        _closeTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, Status.closedByOwner);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.closeTrove,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        if (_batchAddress != address(0)) {\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[_batchAddress].debt,\n                _coll: batches[_batchAddress].coll,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares\n            });\n        }\n    }\n\n    function _closeTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        Status closedStatus\n    ) internal {\n        // assert(closedStatus == Status.closedByLiquidation || closedStatus == Status.closedByOwner);\n\n        uint256 TroveIdsArrayLength = TroveIds.length;\n        _requireMoreThanOneTroveInSystem(TroveIdsArrayLength);\n\n        _removeTroveId(_troveId, TroveIdsArrayLength);\n\n        Trove memory trove = Troves[_troveId];\n\n        // If trove belongs to a batch, remove from it\n        if (_batchAddress != address(0)) {\n            if (trove.status == Status.active) {\n                sortedTroves.removeFromBatch(_troveId);\n            }\n\n            _removeTroveSharesFromBatch(\n                _troveId,\n                _troveChange.collDecrease,\n                _troveChange.debtDecrease,\n                _troveChange,\n                _batchAddress,\n                _newBatchColl,\n                _newBatchDebt\n            );\n        } else {\n            if (trove.status == Status.active) {\n                sortedTroves.remove(_troveId);\n            }\n        }\n\n        uint256 newTotalStakes = totalStakes - trove.stake;\n        totalStakes = newTotalStakes;\n\n        // Zero Trove properties\n        delete Troves[_troveId];\n        Troves[_troveId].status = closedStatus;\n\n        // Zero Trove snapshots\n        delete rewardSnapshots[_troveId];\n\n        // burn ERC721\n        troveNFT.burn(_troveId);\n    }\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution and trove change\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest, batch fee), but without trove change nor upfront fee nor redistribution\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        // Trove\n        Troves[_troveId].coll = _newTroveColl;\n        _updateTroveRewardSnapshots(_troveId);\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newTroveColl);\n\n        // Batch\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _newBatchColl, _newBatchDebt);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _newTroveColl,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newTroveColl;\n\n        if (_batchAddress != address(0)) {\n            _updateBatchShares(_troveId, _batchAddress, _troveChange, _newBatchColl, _newBatchDebt);\n\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.applyBatchInterestAndFee,\n                _debt: _newBatchDebt,\n                _coll: _newBatchColl,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares\n            });\n        } else {\n            Troves[_troveId].debt = _newTroveDebt;\n            Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.applyPendingDebt,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_account].arrayIndex = uint64(batchIds.length);\n        batches[_account].annualInterestRate = _annualInterestRate;\n        batches[_account].annualManagementFee = _annualManagementFee;\n        batches[_account].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        batchIds.push(_account);\n\n        emit BatchUpdated({\n            _interestBatchManager: _account,\n            _operation: BatchOperation.registerBatchManager,\n            _debt: 0,\n            _coll: 0,\n            _annualInterestRate: _annualInterestRate,\n            _annualManagementFee: _annualManagementFee,\n            _totalDebtShares: 0\n        });\n    }\n\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualManagementFee = _newAnnualManagementFee;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.lowerBatchManagerAnnualFee,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: _newAnnualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualInterestRate = _newAnnualInterestRate;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        batches[_batchAddress].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.setBatchManagerAnnualInterestRate,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: _newAnnualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external {\n        _requireCallerIsBorrowerOperations();\n        TroveChange memory _troveChange = _params.troveChange;\n\n        // assert(batchIds[batches[_params.newBatchAddress].arrayIndex] == _params.newBatchAddress);\n\n        _updateTroveRewardSnapshots(_params.troveId);\n\n        // Clean Trove state\n        Troves[_params.troveId].debt = 0;\n        Troves[_params.troveId].annualInterestRate = 0;\n        Troves[_params.troveId].lastDebtUpdateTime = 0;\n        Troves[_params.troveId].coll = _params.troveColl;\n\n        Troves[_params.troveId].interestBatchManager = _params.newBatchAddress;\n        Troves[_params.troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _troveChange.collIncrease = _params.troveColl - _troveChange.appliedRedistCollGain;\n        _troveChange.debtIncrease = _params.troveDebt - _troveChange.appliedRedistBoldDebtGain - _troveChange.upfrontFee;\n        _updateBatchShares(\n            _params.troveId, _params.newBatchAddress, _troveChange, _params.newBatchColl, _params.newBatchDebt\n        );\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _params.troveId,\n            _interestBatchManager: _params.newBatchAddress,\n            _batchDebtShares: Troves[_params.troveId].batchDebtShares,\n            _coll: _params.troveColl,\n            _stake: Troves[_params.troveId].stake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _params.troveId,\n            _operation: Operation.setInterestBatchManager,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _params.newBatchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_params.newBatchAddress].debt,\n            _coll: batches[_params.newBatchAddress].coll,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _annualManagementFee: batches[_params.newBatchAddress].annualManagementFee,\n            _totalDebtShares: batches[_params.newBatchAddress].totalDebtShares\n        });\n    }\n\n    function _updateBatchShares(\n        uint256 _troveId,\n        address _batchAddress,\n        TroveChange memory _troveChange,\n        uint256 _batchColl, // without trove change\n        uint256 _batchDebt // entire (with interest, batch fee), but without trove change, nor upfront fee nor redist\n    ) internal {\n        // Debt\n        uint256 currentBatchDebtShares = batches[_batchAddress].totalDebtShares;\n        uint256 batchDebtSharesDelta;\n        uint256 debtIncrease =\n            _troveChange.debtIncrease + _troveChange.upfrontFee + _troveChange.appliedRedistBoldDebtGain;\n        uint256 debtDecrease;\n        if (debtIncrease > _troveChange.debtDecrease) {\n            debtIncrease -= _troveChange.debtDecrease;\n        } else {\n            debtDecrease = _troveChange.debtDecrease - debtIncrease;\n            debtIncrease = 0;\n        }\n\n        if (debtIncrease == 0 && debtDecrease == 0) {\n            batches[_batchAddress].debt = _batchDebt;\n        } else {\n            if (debtIncrease > 0) {\n                // Add debt\n                if (_batchDebt == 0) {\n                    batchDebtSharesDelta = debtIncrease;\n                } else {\n                    batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / _batchDebt;\n                }\n\n                Troves[_troveId].batchDebtShares += batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt + debtIncrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares + batchDebtSharesDelta;\n            } else if (debtDecrease > 0) {\n                // Subtract debt\n                batchDebtSharesDelta = currentBatchDebtShares * debtDecrease / _batchDebt;\n\n                Troves[_troveId].batchDebtShares -= batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares - batchDebtSharesDelta;\n            }\n        }\n        // Update debt checkpoint\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        // Collateral\n        uint256 collIncrease = _troveChange.collIncrease + _troveChange.appliedRedistCollGain;\n        uint256 collDecrease;\n        if (collIncrease > _troveChange.collDecrease) {\n            collIncrease -= _troveChange.collDecrease;\n        } else {\n            collDecrease = _troveChange.collDecrease - collIncrease;\n            collIncrease = 0;\n        }\n\n        if (collIncrease == 0 && collDecrease == 0) {\n            batches[_batchAddress].coll = _batchColl;\n        } else {\n            if (collIncrease > 0) {\n                // Add coll\n                batches[_batchAddress].coll = _batchColl + collIncrease;\n            } else if (collDecrease > 0) {\n                // Subtract coll\n                batches[_batchAddress].coll = _batchColl - collDecrease;\n            }\n        }\n    }\n\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        // Subtract from batch\n        _removeTroveSharesFromBatch(\n            _troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt\n        );\n\n        // Restore Trove state\n        Troves[_troveId].debt = _newTroveDebt;\n        Troves[_troveId].coll = _newTroveColl;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.removeFromBatch,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares\n        });\n    }\n\n    function _removeTroveSharesFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest and batch fee), but without trove change\n    ) internal {\n        // As we are removing:\n        // assert(_newBatchDebt > 0 || _newBatchColl > 0);\n\n        Trove memory trove = Troves[_troveId];\n\n        // We don’t need to increase the shares corresponding to redistribution first, because they would be subtracted immediately after\n        // We don’t need to account for interest nor batch fee because it’s proportional to debt shares\n        uint256 batchDebtDecrease = _newTroveDebt - _troveChange.upfrontFee - _troveChange.appliedRedistBoldDebtGain;\n        uint256 batchCollDecrease = _newTroveColl - _troveChange.appliedRedistCollGain;\n\n        batches[_batchAddress].totalDebtShares -= trove.batchDebtShares;\n        batches[_batchAddress].debt = _newBatchDebt - batchDebtDecrease;\n        batches[_batchAddress].coll = _newBatchColl - batchCollDecrease;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        Troves[_troveId].interestBatchManager = address(0);\n        Troves[_troveId].batchDebtShares = 0;\n    }\n}\n",
        "StabilityPool.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPoolEvents.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with\n * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total Bold in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and Coll gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and Coll gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated Coll gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated Coll gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Coll gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Coll gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Coll gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion Bold has depleted to < 1 Bold).\n *\n *\n *  --- TRACKING DEPOSITOR'S Coll GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated Coll gain, during the epoch in which the deposit was non-zero and earned Coll.\n *\n * We calculate the depositor's accumulated Coll gain for the scale at which they made the deposit, using the Coll gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated Coll gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n */\ncontract StabilityPool is LiquityBase, IStabilityPool, IStabilityPoolEvents {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"StabilityPool\";\n\n    IERC20 public immutable collToken;\n    ITroveManager public immutable troveManager;\n    IBoldToken public immutable boldToken;\n    // Needed to check if there are pending liquidations\n    ISortedTroves public immutable sortedTroves;\n\n    uint256 internal collBalance; // deposited ether tracker\n\n    // Tracker for Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalBoldDeposits;\n\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, and not yet paid out to depositors\n    // TODO: from the contract's perspective, this is a write-only variable. It is only ever read in tests, so it would\n    // be better to keep it outside the core contract.\n    uint256 internal yieldGainsOwed;\n\n    // --- Data structures ---\n\n    struct Deposit {\n        uint256 initialValue;\n    }\n\n    struct Snapshots {\n        uint256 S; // Coll reward sum liqs\n        uint256 P;\n        uint256 B; // Bold reward sum from minted interest\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n    mapping(address => uint256) public stashedColl;\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some Bold debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* Coll Gain sum 'S': During its lifetime, each deposit d_t earns an Coll gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    *\n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs.\n    */\n    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToS;\n    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToB;\n\n    // Error trackers for the error correction in the offset calculation\n    uint256 public lastCollError_Offset;\n    uint256 public lastBoldLossError_Offset;\n\n    // Error tracker fror the error correction in the BOLD reward calculation\n    uint256 public lastYieldError;\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        troveManager = _addressesRegistry.troveManager();\n        boldToken = _addressesRegistry.boldToken();\n        sortedTroves = _addressesRegistry.sortedTroves();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit BoldTokenAddressChanged(address(boldToken));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getTotalBoldDeposits() external view override returns (uint256) {\n        return totalBoldDeposits;\n    }\n\n    function getYieldGainsOwed() external view override returns (uint256) {\n        return yieldGainsOwed;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Increases deposit, and takes new snapshots of accumulators P and S\n    * - Sends depositor's accumulated Coll gains to depositor\n    */\n    function provideToSP(uint256 _topUp, bool _doClaim) external override {\n        _requireNonZeroAmount(_topUp);\n\n        activePool.mintAggInterest();\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit + _topUp + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.provideToSP,\n            initialDeposit - compoundedBoldDeposit,\n            int256(_topUp),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        boldToken.sendToPool(msg.sender, address(this), _topUp);\n        _updateTotalBoldDeposits(_topUp + keptYieldGain, 0);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        _sendBoldtoDepositor(msg.sender, yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n    }\n\n    function _getYieldToKeepOrSend(uint256 _currentYieldGain, bool _doClaim) internal pure returns (uint256, uint256) {\n        uint256 yieldToKeep;\n        uint256 yieldToSend;\n\n        if (_doClaim) {\n            yieldToKeep = 0;\n            yieldToSend = _currentYieldGain;\n        } else {\n            yieldToKeep = _currentYieldGain;\n            yieldToSend = 0;\n        }\n\n        return (yieldToKeep, yieldToSend);\n    }\n\n    /*  withdrawFromSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Sends the requested BOLD withdrawal to depositor\n    * - (If _amount > userDeposit, the user withdraws all of their compounded deposit)\n    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S\n    */\n    function withdrawFromSP(uint256 _amount, bool _doClaim) external override {\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        activePool.mintAggInterest();\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        uint256 boldToWithdraw = LiquityMath._min(_amount, compoundedBoldDeposit);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit - boldToWithdraw + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.withdrawFromSP,\n            initialDeposit - compoundedBoldDeposit,\n            -int256(boldToWithdraw),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        _updateTotalBoldDeposits(keptYieldGain, boldToWithdraw);\n        _sendBoldtoDepositor(msg.sender, boldToWithdraw + yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n    }\n\n    function _getNewStashedCollAndCollToSend(address _depositor, uint256 _currentCollGain, bool _doClaim)\n        internal\n        view\n        returns (uint256 newStashedColl, uint256 collToSend)\n    {\n        if (_doClaim) {\n            newStashedColl = 0;\n            collToSend = stashedColl[_depositor] + _currentCollGain;\n        } else {\n            newStashedColl = stashedColl[_depositor] + _currentCollGain;\n            collToSend = 0;\n        }\n    }\n\n    // This function is only needed in the case a user has no deposit but still has remaining stashed Coll gains.\n    function claimAllCollGains() external {\n        _requireUserHasNoDeposit(msg.sender);\n\n        activePool.mintAggInterest();\n\n        uint256 collToSend = stashedColl[msg.sender];\n        _requireNonZeroAmount(collToSend);\n        stashedColl[msg.sender] = 0;\n\n        emit DepositOperation(msg.sender, Operation.claimAllCollGains, 0, 0, 0, 0, 0, collToSend);\n        emit DepositUpdated(msg.sender, 0, 0, 0, 0, 0, 0, 0);\n\n        _sendCollGainToDepositor(collToSend);\n    }\n\n    // --- BOLD reward functions ---\n\n    function triggerBoldRewards(uint256 _boldYield) external {\n        _requireCallerIsActivePool();\n\n        uint256 totalBoldDepositsCached = totalBoldDeposits; // cached to save an SLOAD\n        /*\n        * When total deposits is 0, B is not updated. In this case, the BOLD issued can not be obtained by later\n        * depositors - it is missed out on, and remains in the balance of the SP.\n        *\n        */\n        if (totalBoldDepositsCached == 0 || _boldYield == 0) {\n            return;\n        }\n\n        yieldGainsOwed += _boldYield;\n\n        uint256 yieldPerUnitStaked = _computeYieldPerUnitStaked(_boldYield, totalBoldDepositsCached);\n\n        uint256 marginalYieldGain = yieldPerUnitStaked * P;\n        epochToScaleToB[currentEpoch][currentScale] = epochToScaleToB[currentEpoch][currentScale] + marginalYieldGain;\n\n        emit B_Updated(epochToScaleToB[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYieldPerUnitStaked(uint256 _yield, uint256 _totalBoldDeposits) internal returns (uint256) {\n        /*\n        * Calculate the BOLD-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n        * cumulative error low in the running total B:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 yieldNumerator = _yield * DECIMAL_PRECISION + lastYieldError;\n\n        uint256 yieldPerUnitStaked = yieldNumerator / _totalBoldDeposits;\n        lastYieldError = yieldNumerator - yieldPerUnitStaked * _totalBoldDeposits;\n\n        return yieldPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's Coll collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint256 _debtToOffset, uint256 _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint256 totalBold = totalBoldDeposits; // cached to save an SLOAD\n        if (totalBold == 0 || _debtToOffset == 0) return;\n\n        (uint256 collGainPerUnitStaked, uint256 boldLossPerUnitStaked) =\n            _computeCollRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalBold);\n\n        _updateCollRewardSumAndProduct(collGainPerUnitStaked, boldLossPerUnitStaked); // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeCollRewardsPerUnitStaked(uint256 _collToAdd, uint256 _debtToOffset, uint256 _totalBoldDeposits)\n        internal\n        returns (uint256 collGainPerUnitStaked, uint256 boldLossPerUnitStaked)\n    {\n        /*\n        * Compute the Bold and Coll rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToAdd * DECIMAL_PRECISION + lastCollError_Offset;\n\n        assert(_debtToOffset <= _totalBoldDeposits);\n        if (_debtToOffset == _totalBoldDeposits) {\n            boldLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastBoldLossError_Offset = 0;\n        } else {\n            uint256 boldLossNumerator = _debtToOffset * DECIMAL_PRECISION - lastBoldLossError_Offset;\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" Bold loss,\n            * which ensures the error in any given compoundedBoldDeposit favors the Stability Pool.\n            */\n            boldLossPerUnitStaked = boldLossNumerator / _totalBoldDeposits + 1;\n            lastBoldLossError_Offset = boldLossPerUnitStaked * _totalBoldDeposits - boldLossNumerator;\n        }\n\n        collGainPerUnitStaked = collNumerator / _totalBoldDeposits;\n        lastCollError_Offset = collNumerator - collGainPerUnitStaked * _totalBoldDeposits;\n\n        return (collGainPerUnitStaked, boldLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateCollRewardSumAndProduct(uint256 _collGainPerUnitStaked, uint256 _boldLossPerUnitStaked) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        assert(_boldLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool Bold in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - boldLossPerUnitStaked)\n        */\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION) - _boldLossPerUnitStaked;\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentS = epochToScaleToS[currentEpochCached][currentScaleCached];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The Coll gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to Coll gain, and P to deposit loss, we update S first.\n        */\n        uint256 marginalCollGain = _collGainPerUnitStaked * currentP;\n        uint256 newS = currentS + marginalCollGain;\n        epochToScaleToS[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached + 1;\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP * newProductFactor / DECIMAL_PRECISION < SCALE_FACTOR) {\n            newP = currentP * newProductFactor * SCALE_FACTOR / DECIMAL_PRECISION;\n            currentScale = currentScaleCached + 1;\n\n            // Increment the scale again if it's still below the boundary. This ensures the invariant P >= 1e9 holds and addresses this issue\n            // from Liquity v1: https://github.com/liquity/dev/security/advisories/GHSA-m9f3-hrx8-x2g3\n            if (newP < SCALE_FACTOR) {\n                newP *= SCALE_FACTOR;\n                currentScale = currentScaleCached + 2;\n            }\n\n            emit ScaleUpdated(currentScale);\n            // If there's no scale change and no pool-emptying, just do a standard multiplication\n        } else {\n            newP = currentP * newProductFactor / DECIMAL_PRECISION;\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint256 _collToAdd, uint256 _debtToOffset) internal {\n        // Cancel the liquidated Bold debt with the Bold in the stability pool\n        _updateTotalBoldDeposits(0, _debtToOffset);\n\n        // Burn the debt that was successfully offset\n        boldToken.burn(address(this), _debtToOffset);\n\n        // Update internal Coll balance tracker\n        uint256 newCollBalance = collBalance + _collToAdd;\n        collBalance = newCollBalance;\n\n        // Pull Coll from Active Pool\n        activePool.sendColl(address(this), _collToAdd);\n\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function _updateTotalBoldDeposits(uint256 _depositIncrease, uint256 _depositDecrease) internal {\n        if (_depositIncrease == 0 && _depositDecrease == 0) return;\n        uint256 newTotalBoldDeposits = totalBoldDeposits + _depositIncrease - _depositDecrease;\n        totalBoldDeposits = newTotalBoldDeposits;\n        emit StabilityPoolBoldBalanceUpdated(newTotalBoldDeposits);\n    }\n\n    function _decreaseYieldGainsOwed(uint256 _amount) internal {\n        if (_amount == 0) return;\n        uint256 newYieldGainsOwed = yieldGainsOwed - _amount;\n        yieldGainsOwed = newYieldGainsOwed;\n    }\n\n    // --- Reward calculator functions for depositor ---\n\n    /* Calculates the Coll gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorCollGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 collGain = _getCollGainFromSnapshots(initialDeposit, snapshots);\n        return collGain;\n    }\n\n    function getDepositorYieldGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 yieldGain = _getYieldGainFromSnapshots(initialDeposit, snapshots);\n        return yieldGain;\n    }\n\n    function getDepositorYieldGainWithPending(address _depositor) external view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 pendingSPYield = activePool.calcPendingSPYield();\n        uint256 firstPortionPending;\n        uint256 secondPortionPending;\n\n        if (pendingSPYield > 0 && snapshots.epoch == currentEpoch) {\n            uint256 yieldNumerator = pendingSPYield * DECIMAL_PRECISION + lastYieldError;\n            uint256 yieldPerUnitStaked = yieldNumerator / totalBoldDeposits;\n            uint256 marginalYieldGain = yieldPerUnitStaked * P;\n\n            if (currentScale == snapshots.scale) firstPortionPending = marginalYieldGain;\n            else if (currentScale == snapshots.scale + 1) secondPortionPending = marginalYieldGain;\n        }\n\n        uint256 firstPortion = epochToScaleToB[snapshots.epoch][snapshots.scale] + firstPortionPending - snapshots.B;\n        uint256 secondPortion =\n            (epochToScaleToB[snapshots.epoch][snapshots.scale + 1] + secondPortionPending) / SCALE_FACTOR;\n\n        return initialDeposit * (firstPortion + secondPortion) / snapshots.P / DECIMAL_PRECISION;\n    }\n\n    function _getCollGainFromSnapshots(uint256 initialDeposit, Snapshots memory snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The Coll gain may span up to one scale change.\n        * If it does, the second portion of the Coll gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 S_Snapshot = snapshots.S;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToS[epochSnapshot][scaleSnapshot] - S_Snapshot;\n        uint256 secondPortion = epochToScaleToS[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint256 collGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;\n\n        return collGain;\n    }\n\n    function _getYieldGainFromSnapshots(uint256 initialDeposit, Snapshots memory snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /*\n        * Grab the sum 'B' from the epoch at which the stake was made. The Bold gain may span up to one scale change.\n        * If it does, the second portion of the Bold gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 B_Snapshot = snapshots.B;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToB[epochSnapshot][scaleSnapshot] - B_Snapshot;\n        uint256 secondPortion = epochToScaleToB[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint256 yieldGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;\n\n        return yieldGain;\n    }\n\n    // --- Compounded deposit ---\n\n    /*\n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedBoldDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots memory snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) return 0;\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale - scaleSnapshot;\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-9 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake * P / snapshot_P;\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake * P / snapshot_P / SCALE_FACTOR;\n        } else {\n            // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.\n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake / 1e9) return 0;\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for Bold deposit and Coll gains ---\n\n    function _sendCollGainToDepositor(uint256 _collAmount) internal {\n        if (_collAmount == 0) return;\n\n        uint256 newCollBalance = collBalance - _collAmount;\n        collBalance = newCollBalance;\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n        emit EtherSent(msg.sender, _collAmount);\n        collToken.safeTransfer(msg.sender, _collAmount);\n    }\n\n    // Send Bold to user and decrease Bold in Pool\n    function _sendBoldtoDepositor(address _depositor, uint256 _boldToSend) internal {\n        if (_boldToSend == 0) return;\n        boldToken.returnFromPool(address(this), _depositor, _boldToSend);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newDeposit, uint256 _newStashedColl) internal {\n        deposits[_depositor].initialValue = _newDeposit;\n        stashedColl[_depositor] = _newStashedColl;\n\n        if (_newDeposit == 0) {\n            delete depositSnapshots[_depositor];\n            emit DepositUpdated(_depositor, 0, _newStashedColl, 0, 0, 0, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get S for the current epoch and current scale\n        uint256 currentS = epochToScaleToS[currentEpochCached][currentScaleCached];\n        uint256 currentB = epochToScaleToB[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum S for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].B = currentB;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositUpdated(\n            _depositor,\n            _newDeposit,\n            _newStashedColl,\n            currentP,\n            currentS,\n            currentB,\n            currentScaleCached,\n            currentEpochCached\n        );\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit > 0, \"StabilityPool: User must have a non-zero deposit\");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, \"StabilityPool: User must have no deposit\");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n    }\n}\n",
        "AddressesRegistry.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.18;\n\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\n\ncontract AddressesRegistry is Ownable, IAddressesRegistry {\n    IERC20Metadata public collToken;\n    IBorrowerOperations public borrowerOperations;\n    ITroveManager public troveManager;\n    ITroveNFT public troveNFT;\n    IMetadataNFT public metadataNFT;\n    IStabilityPool public stabilityPool;\n    IPriceFeed public priceFeed;\n    IActivePool public activePool;\n    IDefaultPool public defaultPool;\n    address public gasPoolAddress;\n    ICollSurplusPool public collSurplusPool;\n    ISortedTroves public sortedTroves;\n    IInterestRouter public interestRouter;\n    IHintHelpers public hintHelpers;\n    IMultiTroveGetter public multiTroveGetter;\n    ICollateralRegistry public collateralRegistry;\n    IBoldToken public boldToken;\n    IWETH public WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 public immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 public immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    error InvalidCCR();\n    error InvalidMCR();\n    error InvalidSCR();\n    error SPPenaltyTooLow();\n    error SPPenaltyGtRedist();\n    error RedistPenaltyTooHigh();\n\n    event CollTokenAddressChanged(address _collTokenAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event TroveNFTAddressChanged(address _troveNFTAddress);\n    event MetadataNFTAddressChanged(address _metadataNFTAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event PriceFeedAddressChanged(address _priceFeedAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event InterestRouterAddressChanged(address _interestRouterAddress);\n    event HintHelpersAddressChanged(address _hintHelpersAddress);\n    event MultiTroveGetterAddressChanged(address _multiTroveGetterAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n    event WETHAddressChanged(address _wethAddress);\n\n    constructor(\n        address _owner,\n        uint256 _ccr,\n        uint256 _mcr,\n        uint256 _scr,\n        uint256 _liquidationPenaltySP,\n        uint256 _liquidationPenaltyRedistribution\n    ) Ownable(_owner) {\n        if (_ccr <= 1e18 || _ccr >= 2e18) revert InvalidCCR();\n        if (_mcr <= 1e18 || _mcr >= 2e18) revert InvalidMCR();\n        if (_scr <= 1e18 || _scr >= 2e18) revert InvalidSCR();\n        if (_liquidationPenaltySP < 5e16) revert SPPenaltyTooLow();\n        if (_liquidationPenaltySP > _liquidationPenaltyRedistribution) revert SPPenaltyGtRedist();\n        if (_liquidationPenaltyRedistribution > 10e16) revert RedistPenaltyTooHigh();\n\n        CCR = _ccr;\n        SCR = _scr;\n        MCR = _mcr;\n        LIQUIDATION_PENALTY_SP = _liquidationPenaltySP;\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _liquidationPenaltyRedistribution;\n    }\n\n    function setAddresses(AddressVars memory _vars) external onlyOwner {\n        collToken = _vars.collToken;\n        borrowerOperations = _vars.borrowerOperations;\n        troveManager = _vars.troveManager;\n        troveNFT = _vars.troveNFT;\n        metadataNFT = _vars.metadataNFT;\n        stabilityPool = _vars.stabilityPool;\n        priceFeed = _vars.priceFeed;\n        activePool = _vars.activePool;\n        defaultPool = _vars.defaultPool;\n        gasPoolAddress = _vars.gasPoolAddress;\n        collSurplusPool = _vars.collSurplusPool;\n        sortedTroves = _vars.sortedTroves;\n        interestRouter = _vars.interestRouter;\n        hintHelpers = _vars.hintHelpers;\n        multiTroveGetter = _vars.multiTroveGetter;\n        collateralRegistry = _vars.collateralRegistry;\n        boldToken = _vars.boldToken;\n        WETH = _vars.WETH;\n\n        emit CollTokenAddressChanged(address(_vars.collToken));\n        emit BorrowerOperationsAddressChanged(address(_vars.borrowerOperations));\n        emit TroveManagerAddressChanged(address(_vars.troveManager));\n        emit TroveNFTAddressChanged(address(_vars.troveNFT));\n        emit MetadataNFTAddressChanged(address(_vars.metadataNFT));\n        emit StabilityPoolAddressChanged(address(_vars.stabilityPool));\n        emit PriceFeedAddressChanged(address(_vars.priceFeed));\n        emit ActivePoolAddressChanged(address(_vars.activePool));\n        emit DefaultPoolAddressChanged(address(_vars.defaultPool));\n        emit GasPoolAddressChanged(_vars.gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(_vars.collSurplusPool));\n        emit SortedTrovesAddressChanged(address(_vars.sortedTroves));\n        emit InterestRouterAddressChanged(address(_vars.interestRouter));\n        emit HintHelpersAddressChanged(address(_vars.hintHelpers));\n        emit MultiTroveGetterAddressChanged(address(_vars.multiTroveGetter));\n        emit CollateralRegistryAddressChanged(address(_vars.collateralRegistry));\n        emit BoldTokenAddressChanged(address(_vars.boldToken));\n        emit WETHAddressChanged(address(_vars.WETH));\n\n        _renounceOwnership();\n    }\n}\n",
        "BoldToken.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\n\n/*\n * --- Functionality added specific to the BoldToken ---\n *\n * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending Bold directly to a Liquity\n * core contract, when they should rather call the right function.\n *\n * 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move Bold tokens between Liquity <-> user.\n */\n\ncontract BoldToken is Ownable, IBoldToken, ERC20Permit {\n    string internal constant _NAME = \"Bold Stablecoin\";\n    string internal constant _SYMBOL = \"Bold\";\n\n    // --- Addresses ---\n\n    // TODO: optimize to make them immutable\n    address public collateralRegistryAddress;\n    mapping(address => bool) troveManagerAddresses;\n    mapping(address => bool) stabilityPoolAddresses;\n    mapping(address => bool) borrowerOperationsAddresses;\n    mapping(address => bool) activePoolAddresses;\n\n    // --- Events ---\n    event CollateralRegistryAddressChanged(address _newCollateralRegistryAddress);\n    event TroveManagerAddressAdded(address _newTroveManagerAddress);\n    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);\n    event ActivePoolAddressAdded(address _newActivePoolAddress);\n\n    constructor(address _owner) Ownable(_owner) ERC20(_NAME, _SYMBOL) ERC20Permit(_NAME) {}\n\n    function setBranchAddresses(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external override onlyOwner {\n        troveManagerAddresses[_troveManagerAddress] = true;\n        emit TroveManagerAddressAdded(_troveManagerAddress);\n\n        stabilityPoolAddresses[_stabilityPoolAddress] = true;\n        emit StabilityPoolAddressAdded(_stabilityPoolAddress);\n\n        borrowerOperationsAddresses[_borrowerOperationsAddress] = true;\n        emit BorrowerOperationsAddressAdded(_borrowerOperationsAddress);\n\n        activePoolAddresses[_activePoolAddress] = true;\n        emit ActivePoolAddressAdded(_activePoolAddress);\n    }\n\n    function setCollateralRegistry(address _collateralRegistryAddress) external override onlyOwner {\n        collateralRegistryAddress = _collateralRegistryAddress;\n        emit CollateralRegistryAddressChanged(_collateralRegistryAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorAP();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsCRorBOorTMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(address _sender, address _poolAddress, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        public\n        override(ERC20, IERC20)\n        returns (bool)\n    {\n        _requireValidRecipient(recipient);\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"Bold: Cannot transfer tokens directly to the Bold token contract or the zero address\"\n        );\n    }\n\n    function _requireCallerIsBOorAP() internal view {\n        require(\n            borrowerOperationsAddresses[msg.sender] || activePoolAddresses[msg.sender],\n            \"BoldToken: Caller is not BO or AP\"\n        );\n    }\n\n    function _requireCallerIsCRorBOorTMorSP() internal view {\n        require(\n            msg.sender == collateralRegistryAddress || borrowerOperationsAddresses[msg.sender]\n                || troveManagerAddresses[msg.sender] || stabilityPoolAddresses[msg.sender],\n            \"Bold: Caller is neither CR nor BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(stabilityPoolAddresses[msg.sender], \"Bold: Caller is not the StabilityPool\");\n    }\n}\n",
        "BorrowerOperations.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/AddRemoveManagers.sol\";\nimport \"./Types/LatestTroveData.sol\";\nimport \"./Types/LatestBatchData.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract BorrowerOperations is LiquityBase, AddRemoveManagers, IBorrowerOperations {\n    using SafeERC20 for IERC20;\n\n    // --- Connected contract declarations ---\n\n    IERC20 internal immutable collToken;\n    ITroveManager internal troveManager;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n    bool public hasBeenShutDown;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    /*\n    * Mapping from TroveId to individual delegate for interest rate setting.\n    *\n    * This address then has the ability to update the borrower’s interest rate, but not change its debt or collateral.\n    * Useful for instance for cold/hot wallet setups.\n    */\n    mapping(uint256 => InterestIndividualDelegate) private interestIndividualDelegateOf;\n\n    /*\n     * Mapping from TroveId to granted address for interest rate setting (batch manager).\n     *\n     * Batch managers set the interest rate for every Trove in the batch. The interest rate is the same for all Troves in the batch.\n     */\n    mapping(uint256 => address) public interestBatchManagerOf;\n\n    // List of registered Interest Batch Managers\n    mapping(address => InterestBatchManager) private interestBatchManagers;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct OpenTroveVars {\n        ITroveManager troveManager;\n        uint256 troveId;\n        TroveChange change;\n        LatestBatchData batch;\n    }\n\n    struct LocalVariables_openTrove {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IBoldToken boldToken;\n        uint256 troveId;\n        uint256 price;\n        uint256 avgInterestRate;\n        uint256 entireDebt;\n        uint256 ICR;\n        uint256 newTCR;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_adjustTrove {\n        IActivePool activePool;\n        IBoldToken boldToken;\n        LatestTroveData trove;\n        uint256 price;\n        bool isBelowCriticalThreshold;\n        uint256 newICR;\n        uint256 newDebt;\n        uint256 newColl;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_setInterestBatchManager {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ISortedTroves sortedTroves;\n        address oldBatchManager;\n        LatestTroveData trove;\n        LatestBatchData oldBatch;\n        LatestBatchData newBatch;\n    }\n\n    struct LocalVariables_removeFromBatch {\n        ITroveManager troveManager;\n        ISortedTroves sortedTroves;\n        address batchManager;\n        LatestTroveData trove;\n        LatestBatchData batch;\n        uint256 newBatchDebt;\n    }\n\n    error IsShutDown();\n    error NotShutDown();\n    error TCRNotBelowSCR();\n    error ZeroAdjustment();\n    error NotOwnerNorInterestManager();\n    error TroveInBatch();\n    error TroveNotInBatch();\n    error InterestNotInRange();\n    error BatchInterestRateChangePeriodNotPassed();\n    error TroveNotOpen();\n    error TroveNotActive();\n    error TroveNotUnredeemable();\n    error TroveOpen();\n    error UpfrontFeeTooHigh();\n    error BelowCriticalThreshold();\n    error BorrowingNotPermittedBelowCT();\n    error ICRBelowMCR();\n    error RepaymentNotMatchingCollWithdrawal();\n    error TCRBelowCCR();\n    error DebtBelowMin();\n    error CollWithdrawalTooHigh();\n    error NotEnoughBoldBalance();\n    error InterestRateTooLow();\n    error InterestRateTooHigh();\n    error InterestRateNotNew();\n    error InvalidInterestBatchManager();\n    error BatchManagerExists();\n    error BatchManagerNotNew();\n    error NewFeeNotLower();\n    error CallerNotTroveManager();\n    error CallerNotPriceFeed();\n    error MinGeMax();\n    error AnnualManagementFeeTooHigh();\n    error MinInterestRateChangePeriodTooLow();\n    error NewOracleFailureDetected();\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n\n    event ShutDown(uint256 _tcr);\n    event ShutDownFromOracleFailure(address _oracleAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) AddRemoveManagers(_addressesRegistry) LiquityBase(_addressesRegistry) {\n        // This makes impossible to open a trove with zero withdrawn Bold\n        assert(MIN_DEBT > 0);\n\n        collToken = _addressesRegistry.collToken();\n\n        WETH = _addressesRegistry.WETH();\n\n        CCR = _addressesRegistry.CCR();\n        SCR = _addressesRegistry.SCR();\n        MCR = _addressesRegistry.MCR();\n\n        troveManager = _addressesRegistry.troveManager();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit BoldTokenAddressChanged(address(boldToken));\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(address(activePool), type(uint256).max);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external override returns (uint256) {\n        _requireValidAnnualInterestRate(_annualInterestRate);\n\n        OpenTroveVars memory vars;\n\n        vars.troveId = _openTrove(\n            _owner,\n            _ownerIndex,\n            _collAmount,\n            _boldAmount,\n            _annualInterestRate,\n            address(0),\n            0,\n            0,\n            _maxUpfrontFee,\n            _addManager,\n            _removeManager,\n            _receiver,\n            vars.change\n        );\n\n        // Set the stored Trove properties and mint the NFT\n        troveManager.onOpenTrove(_owner, vars.troveId, vars.change, _annualInterestRate);\n\n        sortedTroves.insert(vars.troveId, _annualInterestRate, _upperHint, _lowerHint);\n\n        return vars.troveId;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        override\n        returns (uint256)\n    {\n        _requireValidInterestBatchManager(_params.interestBatchManager);\n\n        OpenTroveVars memory vars;\n        vars.troveManager = troveManager;\n\n        vars.batch = vars.troveManager.getLatestBatchData(_params.interestBatchManager);\n\n        // We set old weighted values here, as it’s only necessary for batches, so we don’t need to pass them to _openTrove func\n        vars.change.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.change.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.change.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.troveId = _openTrove(\n            _params.owner,\n            _params.ownerIndex,\n            _params.collAmount,\n            _params.boldAmount,\n            vars.batch.annualInterestRate,\n            _params.interestBatchManager,\n            vars.batch.entireDebtWithoutRedistribution,\n            vars.batch.annualManagementFee,\n            _params.maxUpfrontFee,\n            _params.addManager,\n            _params.removeManager,\n            _params.receiver,\n            vars.change\n        );\n\n        interestBatchManagerOf[vars.troveId] = _params.interestBatchManager;\n\n        // Set the stored Trove properties and mint the NFT\n        vars.troveManager.onOpenTroveAndJoinBatch(\n            _params.owner,\n            vars.troveId,\n            vars.change,\n            _params.interestBatchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution\n        );\n\n        sortedTroves.insertIntoBatch(\n            vars.troveId,\n            BatchId.wrap(_params.interestBatchManager),\n            vars.batch.annualInterestRate,\n            _params.upperHint,\n            _params.lowerHint\n        );\n\n        return vars.troveId;\n    }\n\n    function _openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _annualInterestRate,\n        address _interestBatchManager,\n        uint256 _batchEntireDebt,\n        uint256 _batchManagementAnnualFee,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver,\n        TroveChange memory _change\n    ) internal returns (uint256) {\n        _requireIsNotShutDown();\n\n        LocalVariables_openTrove memory vars;\n\n        // TODO: stack too deep not allowing to reuse troveManager from outer functions\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n\n        // --- Checks ---\n\n        _requireNotBelowCriticalThreshold(vars.price);\n\n        vars.troveId = uint256(keccak256(abi.encode(_owner, _ownerIndex)));\n        _requireTroveIsNotOpen(vars.troveManager, vars.troveId);\n\n        _change.collIncrease = _collAmount;\n        _change.debtIncrease = _boldAmount;\n\n        // For simplicity, we ignore the fee when calculating the approx. interest rate\n        _change.newWeightedRecordedDebt = (_batchEntireDebt + _change.debtIncrease) * _annualInterestRate;\n\n        vars.avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_change);\n        _change.upfrontFee = _calcUpfrontFee(_change.debtIncrease, vars.avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_change.upfrontFee, _maxUpfrontFee);\n\n        vars.entireDebt = _change.debtIncrease + _change.upfrontFee;\n        _requireAtLeastMinDebt(vars.entireDebt);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee, and the batch fee if needed\n        if (_interestBatchManager == address(0)) {\n            _change.newWeightedRecordedDebt = vars.entireDebt * _annualInterestRate;\n        } else {\n            // old values have been set outside, before calling this function\n            _change.newWeightedRecordedDebt = (_batchEntireDebt + vars.entireDebt) * _annualInterestRate;\n            _change.newWeightedRecordedBatchManagementFee =\n                (_batchEntireDebt + vars.entireDebt) * _batchManagementAnnualFee;\n        }\n\n        // ICR is based on the composite debt, i.e. the requested Bold amount + Bold gas comp + upfront fee.\n        vars.ICR = LiquityMath._computeCR(_collAmount, vars.entireDebt, vars.price);\n        _requireICRisAboveMCR(vars.ICR);\n\n        vars.newTCR = _getNewTCRFromTroveChange(_change, vars.price);\n        _requireNewTCRisAboveCCR(vars.newTCR);\n\n        // --- Effects & interactions ---\n\n        // Set add/remove managers\n        // TODO: We can restore the condition for non-zero managers if we end up ipmlementing at least one of:\n        // - wipe them out on closing troves\n        // - do not reuse troveIds\n        // for now it is safer to make sure they are set\n        _setAddManager(vars.troveId, _addManager);\n        _setRemoveManagerAndReceiver(vars.troveId, _removeManager, _receiver);\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_change, _interestBatchManager);\n\n        // Pull coll tokens from sender and move them to the Active Pool\n        _pullCollAndSendToActivePool(vars.activePool, _collAmount);\n\n        // Mint the requested _boldAmount to the borrower and mint the gas comp to the GasPool\n        vars.boldToken.mint(msg.sender, _boldAmount);\n        WETH.transferFrom(msg.sender, gasPoolAddress, ETH_GAS_COMPENSATION);\n\n        return vars.troveId;\n    }\n\n    // Send collateral to a trove\n    function addColl(uint256 _troveId, uint256 _collAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collIncrease = _collAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(uint256 _troveId, uint256 _collWithdrawal) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = _collWithdrawal;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw Bold tokens from a trove: mint new Bold tokens to the owner, and increase the trove's debt accordingly\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtIncrease = _boldAmount;\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    // Repay Bold tokens to a Trove: Burn the repaid Bold tokens, and reduce the trove's debt accordingly\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtDecrease = _boldAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    function _initTroveChange(\n        TroveChange memory _troveChange,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease\n    ) internal pure {\n        if (_isCollIncrease) {\n            _troveChange.collIncrease = _collChange;\n        } else {\n            _troveChange.collDecrease = _collChange;\n        }\n\n        if (_isDebtIncrease) {\n            _troveChange.debtIncrease = _boldChange;\n        } else {\n            _troveChange.debtDecrease = _boldChange;\n        }\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    function adjustUnredeemableTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsUnredeemable(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n\n        troveManagerCached.setTroveStatusToActive(_troveId);\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        uint256 batchAnnualInteresRate;\n        if (batchManager != address(0)) {\n            LatestBatchData memory batch = troveManagerCached.getLatestBatchData(batchManager);\n            batchAnnualInteresRate = batch.annualInterestRate;\n        }\n        _reInsertIntoSortedTroves(\n            _troveId,\n            troveManagerCached.getTroveAnnualInterestRate(_troveId),\n            _upperHint,\n            _lowerHint,\n            batchManager,\n            batchAnnualInteresRate\n        );\n    }\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        _requireIsNotInBatch(_troveId);\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrInterestManager(_troveId, owner);\n        _requireInterestRateInDelegateRange(_troveId, _newAnnualInterestRate);\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireAnnualInterestRateIsNew(trove.annualInterestRate, _newAnnualInterestRate);\n\n        uint256 newDebt = trove.entireDebt;\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            trove.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            newDebt = _applyUpfrontFee(trove.entireColl, newDebt, troveChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n\n        activePool.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        sortedTroves.reInsert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        troveManagerCached.onAdjustTroveInterestRate(\n            _troveId, trove.entireColl, newDebt, _newAnnualInterestRate, troveChange\n        );\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    */\n    function _adjustTrove(\n        ITroveManager _troveManager,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_adjustTrove memory vars;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n        vars.isBelowCriticalThreshold = _checkBelowCriticalThreshold(vars.price, CCR);\n\n        // --- Checks ---\n\n        _requireTroveIsOpen(_troveManager, _troveId);\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = owner; // If it’s a withdrawal, and manager has receive privilege, manager would be the receiver\n\n        if (_troveChange.collDecrease > 0 || _troveChange.debtIncrease > 0) {\n            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        }\n\n        if (_troveChange.collIncrease > 0 || _troveChange.debtDecrease > 0) {\n            _requireSenderIsOwnerOrAddManager(_troveId, owner);\n        }\n\n        vars.trove = _troveManager.getLatestTroveData(_troveId);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Bold\n        if (_troveChange.debtDecrease > 0) {\n            uint256 maxRepayment = vars.trove.entireDebt > MIN_DEBT ? vars.trove.entireDebt - MIN_DEBT : 0;\n            if (_troveChange.debtDecrease > maxRepayment) {\n                _troveChange.debtDecrease = maxRepayment;\n            }\n            _requireSufficientBoldBalance(vars.boldToken, msg.sender, _troveChange.debtDecrease);\n        }\n\n        _requireNonZeroAdjustment(_troveChange);\n\n        // When the adjustment is a collateral withdrawal, check that it's no more than the Trove's entire collateral\n        if (_troveChange.collDecrease > 0) {\n            _requireValidCollWithdrawal(vars.trove.entireColl, _troveChange.collDecrease);\n        }\n\n        vars.newColl = vars.trove.entireColl + _troveChange.collIncrease - _troveChange.collDecrease;\n        vars.newDebt = vars.trove.entireDebt + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        bool isTroveInBatch = batchManager != address(0);\n        LatestBatchData memory batch;\n        uint256 batchFutureDebt;\n        if (isTroveInBatch) {\n            batch = _troveManager.getLatestBatchData(batchManager);\n\n            batchFutureDebt = batch.entireDebtWithoutRedistribution + vars.trove.redistBoldDebtGain\n                + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n            // TODO: comment\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            _troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            _troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.oldWeightedRecordedDebt = vars.trove.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n        }\n\n        // Pay an upfront fee on debt increases\n        if (_troveChange.debtIncrease > 0) {\n            uint256 avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n            _troveChange.upfrontFee = _calcUpfrontFee(_troveChange.debtIncrease, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n            vars.newDebt += _troveChange.upfrontFee;\n            if (isTroveInBatch) {\n                batchFutureDebt += _troveChange.upfrontFee;\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n                _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n            } else {\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n            }\n        }\n\n        // Make sure the Trove doesn't end up unredeemable\n        // Now the max repayment is capped to stay above MIN_DEBT, so this only applies to adjustUnredeemableTrove\n        _requireAtLeastMinDebt(vars.newDebt);\n\n        vars.newICR = LiquityMath._computeCR(vars.newColl, vars.newDebt, vars.price);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(_troveChange, vars);\n\n        // --- Effects and interactions ---\n\n        if (isTroveInBatch) {\n            _troveManager.onAdjustTroveInsideBatch(\n                _troveId,\n                vars.newColl,\n                _troveChange,\n                batchManager,\n                batch.entireCollWithoutRedistribution,\n                batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _troveManager.onAdjustTrove(_troveId, vars.newColl, vars.newDebt, _troveChange);\n        }\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_troveChange, batchManager);\n        _moveTokensFromAdjustment(receiver, _troveChange, vars.boldToken, vars.activePool);\n    }\n\n    function closeTrove(uint256 _troveId) external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IBoldToken boldTokenCached = boldToken;\n\n        // --- Checks ---\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n\n        // The borrower must repay their entire debt including accrued interest, batch fee and redist. gains\n        _requireSufficientBoldBalance(boldTokenCached, msg.sender, trove.entireDebt);\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n        if (batchManager != address(0)) {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            uint256 batchFutureDebt =\n                batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain);\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            // troveChange.newWeightedRecordedDebt = 0;\n        }\n\n        (uint256 price, ) = priceFeed.fetchPrice();\n        uint256 newTCR = _getNewTCRFromTroveChange(troveChange, price);\n        if (!hasBeenShutDown) _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.onCloseTrove(\n            _troveId,\n            troveChange,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution\n        );\n\n        // If trove is in batch\n        if (batchManager != address(0)) {\n            // Unlink here in BorrowerOperations\n            interestBatchManagerOf[_troveId] = address(0);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, batchManager);\n\n        // Return ETH gas compensation\n        WETH.transferFrom(gasPoolAddress, receiver, ETH_GAS_COMPENSATION);\n        // Burn the remainder of the Trove's entire debt from the user\n        boldTokenCached.burn(msg.sender, trove.entireDebt);\n\n        // Send the collateral back to the user\n        activePoolCached.sendColl(receiver, trove.entireColl);\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) public {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        TroveChange memory change;\n        change.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        change.appliedRedistCollGain = trove.redistCollGain;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n\n        if (batchManager == address(0)) {\n            change.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            change.newWeightedRecordedDebt = trove.entireDebt * trove.annualInterestRate;\n        } else {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            change.batchAccruedManagementFee = batch.accruedManagementFee;\n            change.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            change.newWeightedRecordedDebt =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualInterestRate;\n            change.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            change.newWeightedRecordedBatchManagementFee =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualManagementFee;\n        }\n\n        troveManagerCached.onApplyTroveInterest(\n            _troveId,\n            trove.entireColl,\n            trove.entireDebt,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            change\n        );\n        activePool.mintAggInterestAndAccountForTroveChange(change, batchManager);\n\n        // If the trove was unredeemable, and now it’s not anymore, put it back in the list\n        if (_checkTroveIsUnredeemable(troveManagerCached, _troveId) && trove.entireDebt >= MIN_DEBT) {\n            troveManagerCached.setTroveStatusToActive(_troveId);\n            _reInsertIntoSortedTroves(\n                _troveId, trove.annualInterestRate, _upperHint, _lowerHint, batchManager, batch.annualInterestRate\n            );\n        }\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory)\n    {\n        return interestIndividualDelegateOf[_troveId];\n    }\n\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireCallerIsBorrower(_troveId);\n        interestIndividualDelegateOf[_troveId] =\n            InterestIndividualDelegate(_delegate, _minInterestRate, _maxInterestRate);\n        // Can’t have both individual delegation and batch manager\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            removeFromBatch(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);\n        }\n    }\n\n    function removeInterestIndividualDelegate(uint256 _troveId) external {\n        _requireCallerIsBorrower(_troveId);\n        delete interestIndividualDelegateOf[_troveId];\n    }\n\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory) {\n        return interestBatchManagers[_account];\n    }\n\n    function registerBatchManager(\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        uint128 _currentInterestRate,\n        uint128 _annualManagementFee,\n        uint128 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireNonExistentInterestBatchManager(msg.sender);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        if (_minInterestRate >= _maxInterestRate) revert MinGeMax();\n        _requireInterestRateInRange(_currentInterestRate, _minInterestRate, _maxInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_currentInterestRate);\n        if (_annualManagementFee > MAX_ANNUAL_BATCH_MANAGEMENT_FEE) revert AnnualManagementFeeTooHigh();\n        if (_minInterestRateChangePeriod < MIN_INTEREST_RATE_CHANGE_PERIOD) revert MinInterestRateChangePeriodTooLow();\n\n        interestBatchManagers[msg.sender] =\n            InterestBatchManager(_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n\n        troveManager.onRegisterBatchManager(msg.sender, _currentInterestRate, _annualManagementFee);\n    }\n\n    function lowerBatchManagementFee(uint256 _newAnnualManagementFee) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n\n        ITroveManager troveManagerCached = troveManager;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        if (_newAnnualManagementFee >= batch.annualManagementFee) {\n            revert NewFeeNotLower();\n        }\n\n        // Lower batch fee on TM\n        troveManagerCached.onLowerBatchManagerAnnualFee(\n            msg.sender,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            _newAnnualManagementFee\n        );\n\n        // active pool mint\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * _newAnnualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n    }\n\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n        _requireInterestRateInBatchManagerRange(msg.sender, _newAnnualInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        _requireInterestRateChangePeriodPassed(msg.sender, uint256(batch.lastInterestRateAdjTime));\n\n        uint256 newDebt = batch.entireDebtWithoutRedistribution;\n\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            uint256 price = _requireOraclesLive();\n\n            uint256 avgInterestRate = activePoolCached.getNewApproxAvgInterestRateFromTroveChange(batchChange);\n            batchChange.upfrontFee = _calcUpfrontFee(newDebt, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(batchChange.upfrontFee, _maxUpfrontFee);\n\n            newDebt += batchChange.upfrontFee;\n\n            // Recalculate the batch's weighted terms, now taking into account the upfront fee\n            batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n            batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n            // Disallow a premature adjustment if it would result in TCR < CCR\n            // (which includes the case when TCR is already below CCR before the adjustment).\n            uint256 newTCR = _getNewTCRFromTroveChange(batchChange, price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n\n        // Check batch is not empty, and then reinsert in sorted list\n        if (!sortedTroves.isEmptyBatch(BatchId.wrap(msg.sender))) {\n            sortedTroves.reInsertBatch(BatchId.wrap(msg.sender), _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        troveManagerCached.onSetBatchManagerAnnualInterestRate(\n            msg.sender, batch.entireCollWithoutRedistribution, newDebt, _newAnnualInterestRate\n        );\n    }\n\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n        LocalVariables_setInterestBatchManager memory vars;\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidInterestBatchManager(_newBatchManager);\n        _requireIsNotInBatch(_troveId);\n\n        interestBatchManagerOf[_troveId] = _newBatchManager;\n        // Can’t have both individual delegation and batch manager\n        if (interestIndividualDelegateOf[_troveId].account != address(0)) delete interestIndividualDelegateOf[_troveId];\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.newBatch = vars.troveManager.getLatestBatchData(_newBatchManager);\n\n        TroveChange memory newBatchTroveChange;\n        newBatchTroveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        newBatchTroveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        newBatchTroveChange.batchAccruedManagementFee = vars.newBatch.accruedManagementFee;\n        newBatchTroveChange.oldWeightedRecordedDebt =\n            vars.newBatch.weightedRecordedDebt + vars.trove.weightedRecordedDebt;\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // We may check the old rate to see if it’s different than the new one, but then we should check the\n        // last interest adjustment times to avoid gaming. So we decided to keep it simple and account it always\n        // as a change. It’s probably not so common to join a batch with the exact same interest rate.\n        // Apply upfront fee on premature adjustments\n        if (block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, newBatchTroveChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // Add batch fees\n        newBatchTroveChange.oldWeightedRecordedBatchManagementFee = vars.newBatch.weightedRecordedBatchManagementFee;\n        newBatchTroveChange.newWeightedRecordedBatchManagementFee =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualManagementFee;\n        vars.activePool.mintAggInterestAndAccountForTroveChange(newBatchTroveChange, _newBatchManager);\n\n        vars.troveManager.onSetInterestBatchManager(\n            ITroveManager.OnSetInterestBatchManagerParams({\n                troveId: _troveId,\n                troveColl: vars.trove.entireColl,\n                troveDebt: vars.trove.entireDebt,\n                troveChange: newBatchTroveChange,\n                newBatchAddress: _newBatchManager,\n                newBatchColl: vars.newBatch.entireCollWithoutRedistribution,\n                newBatchDebt: vars.newBatch.entireDebtWithoutRedistribution\n            })\n        );\n\n        vars.sortedTroves.remove(_troveId);\n        vars.sortedTroves.insertIntoBatch(\n            _troveId, BatchId.wrap(_newBatchManager), vars.newBatch.annualInterestRate, _upperHint, _lowerHint\n        );\n    }\n\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n\n        LocalVariables_removeFromBatch memory vars;\n        vars.troveManager = troveManager;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        vars.batchManager = _requireIsInBatch(_troveId);\n        delete interestBatchManagerOf[_troveId];\n\n        // Remove trove from Batch in SortedTroves\n        vars.sortedTroves.removeFromBatch(_troveId);\n        // Reinsert as single trove\n        vars.sortedTroves.insert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.batch = vars.troveManager.getLatestBatchData(vars.batchManager);\n\n        TroveChange memory batchChange;\n        batchChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        batchChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        batchChange.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt\n            + (vars.trove.entireDebt - vars.trove.redistBoldDebtGain) * vars.batch.annualInterestRate;\n        batchChange.newWeightedRecordedDebt = vars.batch.entireDebtWithoutRedistribution * vars.batch.annualInterestRate\n            + vars.trove.entireDebt * _newAnnualInterestRate;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            vars.batch.annualInterestRate != _newAnnualInterestRate\n            && block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, batchChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        batchChange.newWeightedRecordedDebt = vars.batch.entireDebtWithoutRedistribution * vars.batch.annualInterestRate\n            + vars.trove.entireDebt * _newAnnualInterestRate;\n        // Add batch fees\n        batchChange.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee\n            + (vars.trove.entireDebt - batchChange.upfrontFee - vars.trove.redistBoldDebtGain)\n                * vars.batch.annualManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            vars.batch.entireDebtWithoutRedistribution * vars.batch.annualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, vars.batchManager);\n\n        vars.troveManager.onRemoveFromBatch(\n            _troveId,\n            vars.trove.entireColl,\n            vars.trove.entireDebt,\n            batchChange,\n            vars.batchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution,\n            _newAnnualInterestRate\n        );\n    }\n\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        address oldBatchManager = _requireIsInBatch(_troveId);\n        _requireNewInterestBatchManager(oldBatchManager, _newBatchManager);\n\n        LatestBatchData memory oldBatch = troveManager.getLatestBatchData(oldBatchManager);\n\n        removeFromBatch(_troveId, oldBatch.annualInterestRate, _removeUpperHint, _removeLowerHint, 0);\n        setInterestBatchManager(_troveId, _newBatchManager, _addUpperHint, _addLowerHint, _maxUpfrontFee);\n    }\n\n    function _applyUpfrontFee(\n        uint256 _troveEntireColl,\n        uint256 _troveEntireDebt,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal returns (uint256) {\n        uint256 price = _requireOraclesLive();\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n        _troveChange.upfrontFee = _calcUpfrontFee(_troveEntireDebt, avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n        _troveEntireDebt += _troveChange.upfrontFee;\n\n        // ICR is based on the composite debt, i.e. the requested Bold amount + Bold gas comp + upfront fee.\n        uint256 newICR = LiquityMath._computeCR(_troveEntireColl, _troveEntireDebt, price);\n        _requireICRisAboveMCR(newICR);\n\n        // Disallow a premature adjustment if it would result in TCR < CCR\n        // (which includes the case when TCR is already below CCR before the adjustment).\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        return _troveEntireDebt;\n    }\n\n    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {\n        return _calcInterest(_debt * _avgInterestRate, UPFRONT_INTEREST_PERIOD);\n    }\n\n    // Call from TM to clean state here\n    function onLiquidateTrove(uint256 _troveId) external {\n        _requireCallerIsTroveManager();\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function _wipeTroveMappings(uint256 _troveId) internal {\n        delete interestIndividualDelegateOf[_troveId];\n        delete interestBatchManagerOf[_troveId];\n        delete addManagerOf[_troveId];\n        delete removeManagerReceiverOf[_troveId];\n    }\n\n    /**\n     * Claim remaining collateral from a liquidation with ICR exceeding the liquidation penalty\n     */\n    function claimCollateral() external override {\n        // send coll from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    function shutdown() external {\n        if (hasBeenShutDown) revert IsShutDown();\n\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n        (uint256 price, ) = priceFeed.fetchPrice();\n\n        uint256 TCR = LiquityMath._computeCR(totalColl, totalDebt, price);\n        if (TCR >= SCR) revert TCRNotBelowSCR();\n\n        _applyShutdown();\n\n        emit ShutDown(TCR);\n    }\n\n    // Not technically a \"Borrower op\", but seems best placed here given current shutdown logic.\n    function shutdownFromOracleFailure(address _failedOracleAddr) external {\n        _requireCallerIsPriceFeed();\n\n        // No-op rather than revert here, so that the outer function call which fetches the price does not revert\n        // if the system is already shut down.\n        if (hasBeenShutDown) return;\n\n        _applyShutdown();\n\n        emit ShutDownFromOracleFailure(_failedOracleAddr);\n    }\n\n    function _applyShutdown() internal {\n        activePool.mintAggInterest();\n        hasBeenShutDown = true;\n        troveManager.shutdown();\n    }\n\n    // --- Helper functions ---\n\n    function _reInsertIntoSortedTroves(\n        uint256 _troveId,\n        uint256 _troveAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        address _batchManager,\n        uint256 _batchAnnualInterestRate\n    ) internal {\n        // If it was in a batch, we need to put it back, otherwise we insert it normally\n        if (_batchManager == address(0)) {\n            sortedTroves.insert(_troveId, _troveAnnualInterestRate, _upperHint, _lowerHint);\n        } else {\n            sortedTroves.insertIntoBatch(\n                _troveId, BatchId.wrap(_batchManager), _batchAnnualInterestRate, _upperHint, _lowerHint\n            );\n        }\n    }\n\n    // This function mints the BOLD corresponding to the borrower's chosen debt increase\n    // (it does not mint the accrued interest).\n    function _moveTokensFromAdjustment(\n        address withdrawalReceiver,\n        TroveChange memory _troveChange,\n        IBoldToken _boldToken,\n        IActivePool _activePool\n    ) internal {\n        if (_troveChange.debtIncrease > 0) {\n            _boldToken.mint(withdrawalReceiver, _troveChange.debtIncrease);\n        } else if (_troveChange.debtDecrease > 0) {\n            _boldToken.burn(msg.sender, _troveChange.debtDecrease);\n        }\n\n        if (_troveChange.collIncrease > 0) {\n            // Pull coll tokens from sender and move them to the Active Pool\n            _pullCollAndSendToActivePool(_activePool, _troveChange.collIncrease);\n        } else if (_troveChange.collDecrease > 0) {\n            // Pull Coll from Active Pool and decrease its recorded Coll balance\n            _activePool.sendColl(withdrawalReceiver, _troveChange.collDecrease);\n        }\n    }\n\n    function _pullCollAndSendToActivePool(IActivePool _activePool, uint256 _amount) internal {\n        // Send Coll tokens from sender to active pool\n        collToken.safeTransferFrom(msg.sender, address(_activePool), _amount);\n        // Make sure Active Pool accountancy is right\n        _activePool.accountForReceivedColl(_amount);\n    }\n\n    function checkBatchManagerExists(address _batchManager) external view returns (bool) {\n        return interestBatchManagers[_batchManager].maxInterestRate > 0;\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireIsNotShutDown() internal view {\n        if (hasBeenShutDown) {\n            revert IsShutDown();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (!hasBeenShutDown) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireNonZeroAdjustment(TroveChange memory _troveChange) internal pure {\n        if (\n            _troveChange.collIncrease == 0 && _troveChange.collDecrease == 0 && _troveChange.debtIncrease == 0\n                && _troveChange.debtDecrease == 0\n        ) {\n            revert ZeroAdjustment();\n        }\n    }\n\n    function _requireSenderIsOwnerOrInterestManager(uint256 _troveId, address _owner) internal view {\n        if (msg.sender != _owner && msg.sender != interestIndividualDelegateOf[_troveId].account) {\n            revert NotOwnerNorInterestManager();\n        }\n    }\n\n    function _requireIsNotInBatch(uint256 _troveId) internal view {\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            revert TroveInBatch();\n        }\n    }\n\n    function _requireIsInBatch(uint256 _troveId) internal view returns (address) {\n        address batchManager = interestBatchManagerOf[_troveId];\n        if (batchManager == address(0)) {\n            revert TroveNotInBatch();\n        }\n\n        return batchManager;\n    }\n\n    function _requireInterestRateInDelegateRange(uint256 _troveId, uint256 _annualInterestRate) internal view {\n        InterestIndividualDelegate memory individualDelegate = interestIndividualDelegateOf[_troveId];\n        if (individualDelegate.account != address(0)) {\n            _requireInterestRateInRange(\n                _annualInterestRate, individualDelegate.minInterestRate, individualDelegate.maxInterestRate\n            );\n        }\n    }\n\n    function _requireInterestRateInBatchManagerRange(address _interestBatchManagerAddress, uint256 _annualInterestRate)\n        internal\n        view\n    {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        _requireInterestRateInRange(\n            _annualInterestRate, interestBatchManager.minInterestRate, interestBatchManager.maxInterestRate\n        );\n    }\n\n    function _requireInterestRateInRange(\n        uint256 _annualInterestRate,\n        uint256 _minInterestRate,\n        uint256 _maxInterestRate\n    ) internal pure {\n        if (_minInterestRate > _annualInterestRate || _annualInterestRate > _maxInterestRate) {\n            revert InterestNotInRange();\n        }\n    }\n\n    function _requireInterestRateChangePeriodPassed(\n        address _interestBatchManagerAddress,\n        uint256 _lastInterestRateAdjTime\n    ) internal view {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        if (block.timestamp < _lastInterestRateAdjTime + uint256(interestBatchManager.minInterestRateChangePeriod)) {\n            revert BatchInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireTroveIsOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active && status != ITroveManager.Status.unredeemable) {\n            revert TroveNotOpen();\n        }\n    }\n\n    function _requireTroveIsActive(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active) {\n            revert TroveNotActive();\n        }\n    }\n\n    function _requireTroveIsUnredeemable(ITroveManager _troveManager, uint256 _troveId) internal view {\n        if (!_checkTroveIsUnredeemable(_troveManager, _troveId)) {\n            revert TroveNotUnredeemable();\n        }\n    }\n\n    function _checkTroveIsUnredeemable(ITroveManager _troveManager, uint256 _troveId) internal view returns (bool) {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        return status == ITroveManager.Status.unredeemable;\n    }\n\n    function _requireTroveIsNotOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status == ITroveManager.Status.active || status == ITroveManager.Status.unredeemable) {\n            revert TroveOpen();\n        }\n    }\n\n    function _requireUserAcceptsUpfrontFee(uint256 _fee, uint256 _maxFee) internal pure {\n        if (_fee > _maxFee) {\n            revert UpfrontFeeTooHigh();\n        }\n    }\n\n    function _requireNotBelowCriticalThreshold(uint256 _price) internal view {\n        if (_checkBelowCriticalThreshold(_price, CCR)) {\n            revert BelowCriticalThreshold();\n        }\n    }\n\n    function _requireNoBorrowing(uint256 _debtIncrease) internal pure {\n        if (_debtIncrease > 0) {\n            revert BorrowingNotPermittedBelowCT();\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        TroveChange memory _troveChange,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n        * Below Critical Threshold, it is not permitted:\n        *\n        * - Borrowing\n        * - Collateral withdrawal except accompanied by a debt repayment of at least the same value\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The adjustment won't pull the TCR below CCR\n        *\n        * In Both cases:\n        * - The new ICR is above MCR\n        */\n        _requireICRisAboveMCR(_vars.newICR);\n\n        if (_vars.isBelowCriticalThreshold) {\n            _requireNoBorrowing(_troveChange.debtIncrease);\n            _requireDebtRepaymentGeCollWithdrawal(_troveChange, _vars.price);\n        } else {\n            // if Normal Mode\n            uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, _vars.price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal view {\n        if (_newICR < MCR) {\n            revert ICRBelowMCR();\n        }\n    }\n\n    function _requireDebtRepaymentGeCollWithdrawal(TroveChange memory _troveChange, uint256 _price) internal pure {\n        if ((_troveChange.debtDecrease * DECIMAL_PRECISION < _troveChange.collDecrease * _price)) {\n            revert RepaymentNotMatchingCollWithdrawal();\n        }\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal view {\n        if (_newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireAtLeastMinDebt(uint256 _debt) internal pure {\n        if (_debt < MIN_DEBT) {\n            revert DebtBelowMin();\n        }\n    }\n\n    function _requireValidCollWithdrawal(uint256 _currentColl, uint256 _collWithdrawal) internal pure {\n        if (_collWithdrawal > _currentColl) {\n            revert CollWithdrawalTooHigh();\n        }\n    }\n\n    function _requireSufficientBoldBalance(IBoldToken _boldToken, address _borrower, uint256 _debtRepayment)\n        internal\n        view\n    {\n        if (_boldToken.balanceOf(_borrower) < _debtRepayment) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    function _requireValidAnnualInterestRate(uint256 _annualInterestRate) internal pure {\n        if (_annualInterestRate < MIN_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooLow();\n        }\n        if (_annualInterestRate > MAX_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooHigh();\n        }\n    }\n\n    function _requireAnnualInterestRateIsNew(uint256 _oldAnnualInterestRate, uint256 _newAnnualInterestRate)\n        internal\n        pure\n    {\n        if (_oldAnnualInterestRate == _newAnnualInterestRate) {\n            revert InterestRateNotNew();\n        }\n    }\n\n    function _requireValidInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate == 0) {\n            revert InvalidInterestBatchManager();\n        }\n    }\n\n    function _requireNonExistentInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate > 0) {\n            revert BatchManagerExists();\n        }\n    }\n\n    function _requireNewInterestBatchManager(address _oldBatchManagerAddress, address _newBatchManagerAddress)\n        internal\n        pure\n    {\n        if (_oldBatchManagerAddress == _newBatchManagerAddress) {\n            revert BatchManagerNotNew();\n        }\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        if (msg.sender != address(troveManager)) {\n            revert CallerNotTroveManager();\n        }\n    }\n\n    function _requireCallerIsPriceFeed() internal view {\n        if (msg.sender != address(priceFeed)) {\n            revert CallerNotPriceFeed();\n        }\n    }\n\n    function _requireOraclesLive() internal returns (uint256) {\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        if (newOracleFailureDetected) {\n            revert NewOracleFailureDetected();\n        }\n\n        return price;\n    }\n\n    // --- ICR and TCR getters ---\n\n    function _getNewTCRFromTroveChange(TroveChange memory _troveChange, uint256 _price)\n        internal\n        view\n        returns (uint256 newTCR)\n    {\n        uint256 totalColl = getEntireSystemColl();\n        totalColl += _troveChange.collIncrease;\n        totalColl -= _troveChange.collDecrease;\n\n        uint256 totalDebt = getEntireSystemDebt();\n        totalDebt += _troveChange.debtIncrease;\n        totalDebt += _troveChange.upfrontFee;\n        totalDebt -= _troveChange.debtDecrease;\n\n        newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n    }\n}\n"
    }
}