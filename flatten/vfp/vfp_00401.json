{
    "vfp_id": "vfp_00401",
    "project_name": "ackee-blockchain-lido-vault-wrapper-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "SocializedLoss event emits incorrect asset amount",
            "description": "The SocializedLoss event in the StvStETHPool contract emits an incorrect value for the assets parameter due to a timing issue in the calculation. The root cause is that the asset amount is calculated after the rebalance operation, which mutates the totalAssets value. Specifically, _convertToAssets(_maxStvToBurn) uses the post-rebalance totalAssets, whereas the event should reflect the pre-rebalance state. This leads to a discrepancy in the emitted asset amount. An attacker or affected party, such as a protocol operator relying on event data for off-chain accounting, could be misled by the incorrect value. The impact is low, as it does not lead to direct fund loss or system compromise, but it can cause inaccuracies in monitoring and reporting systems that consume the event data.\n",
            "severity": "Low",
            "location": [
                "StvStETHPool.sol::StvStETHPool._rebalanceMintedStethShares#678-682"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rebalance preview calculation inconsistency",
            "description": "The previewForceRebalance function in the StvStETHPool contract returns a different STV burn amount than what is actually executed during rebalancing, leading to a calculation inconsistency. The cause is a rounding discrepancy in the execution path: the actual burn uses a round-trip conversion through stETH shares (which involves a down-rounding step in getSharesByPooledEth), while the preview function does not replicate this exact path. As a result, the preview overestimates the required STV amount. An attacker cannot directly exploit this for financial gain, but integrators or automated systems relying on accurate previews may experience confusion or operational issues. The impact is low, as it affects usability and predictability rather than security-critical functions.\n",
            "severity": "Low",
            "location": [
                "StvStETHPool.sol::previewForceRebalance",
                "StvStETHPool.sol::StvStETHPool._rebalanceMintedStethShares#670-671"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Shares cannot be burnt when exceeding liability exists on pool and liability on vault is low",
            "description": "The vulnerability arises in the StvStETHPool contract during direct staking vault rebalancing, where the liabilityShares field in the VaultRecord structure is decreased, but this change does not reflect in the mintedStethShares mapping used by the burnStethShares and burnWsteth functions. This discrepancy causes a logic error that prevents users from burning their stETH or wstETH shares to repay debt, even when the liability has been reduced via rebalancing. The root cause is the lack of synchronization between the liabilityShares in the vault record and the mintedStethShares tracking in the pool contract. An attacker or affected user could find themselves unable to repay debt despite having sufficient shares, especially after a rebalance reduces their liability. In rare cases, this could lead to a user position becoming unhealthy and subject to forced rebalancing, although users may still use the WithdrawalQueue contract as an alternative path to withdraw and repay. The impact is limited to user functionality and debt repayment, not leading to fund loss, hence classified as a Warning.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::burnWsteth#338",
                "StvStETHPool.sol::burnStethShares#353"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1109"
                ]
            },
            "title": "Potentially misleading reserveRatioBp variable name",
            "description": "The variable reserveRatioBp is used in multiple contexts within StvStETHPool, but its effective value for users includes an added gap (ReservationGap + VaultConnection.reserveRatioBp). However, the same name is used without distinguishing between the base value and the effective value, leading to confusion. This is a code quality issue where ambiguous naming can mislead developers about the actual logic. The root cause is the reuse of a variable name across different semantic meanings. While this does not lead to incorrect behavior, it increases the risk of misinterpretation during audits or upgrades, potentially leading to logic errors in future development. The impact is limited to developer experience and code clarity, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::forcedRebalanceThresholdBP#483"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused errors",
            "description": "The errors ArraysLengthMismatch in StvStETHPool.sol and StringTooLong in Factory.sol are declared but never used in the codebase. This is a code quality issue that adds unnecessary complexity and can mislead developers into thinking these conditions are handled. The root cause is incomplete cleanup after refactoring. While these errors do not introduce vulnerabilities, they clutter the code and increase compilation size. The impact is limited to code maintainability and clarity, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::ArraysLengthMismatch",
                "Factory.sol::StringTooLong"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol",
                "vaults-wrapper/src/Factory.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Public functions can be declared as external",
            "description": "The functions forceRebalance and forceRebalanceAndSocializeLoss in StvStETHPool.sol are declared as public but are not called internally, meaning they can be declared as external to save gas on deployment and execution. This is a code optimization and quality issue. The root cause is suboptimal function visibility selection. While this does not pose a security risk, it results in higher gas costs for users. The impact is economic inefficiency, not security, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::forceRebalance#564",
                "StvStETHPool.sol::forceRebalanceAndSocializeLoss#580"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-348"
                ]
            },
            "title": "Role constants read from Dashboard implementation instead of proxy",
            "description": "The Factory.createPoolFinish function reads role constants (e.g., FUND_ROLE, REBALANCE_ROLE) from the global DASHBOARD_IMPL instead of the deployed Dashboard instance. If the implementation changes between pool creation phases, the roles granted may not match the actual implementation, leading to privilege misassignment. The root cause is incorrect source of role identifiers. An attacker could potentially exploit timing between implementation upgrades to gain unintended privileges or cause denial of service by breaking expected role assignments. The impact is on access control integrity, hence classified as Informational due to low likelihood and fixability.\n",
            "severity": "Informational",
            "location": [
                "Factory.sol::createPoolFinish#647"
            ],
            "files": [
                "vaults-wrapper/src/Factory.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "createPoolFinish forwards full msg.value instead of exact connect deposit potentially causing loss of overpaid ETH",
            "description": "The Factory.createPoolFinish function forwards the entire msg.value to Dashboard.connectToVaultHub instead of only the required CONNECT_DEPOSIT amount. This means any overpayment is sent to the dashboard and not refunded, potentially leading to loss of excess ETH if users are unaware. The root cause is lack of explicit value capping in the call. While the function checks for minimum deposit, it does not limit the forwarded value. An attacker cannot directly exploit this, but users may lose funds due to overpayment, especially if documentation does not warn them. The impact is potential user fund loss due to poor UX, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "Factory.sol::createPoolFinish#564"
            ],
            "files": [
                "vaults-wrapper/src/Factory.sol"
            ]
        }
    ],
    "affected_files": {
        "Factory.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {ShortString, ShortStrings} from \"@openzeppelin/contracts/utils/ShortStrings.sol\";\n\nimport {StvPool} from \"./StvPool.sol\";\nimport {StvStETHPool} from \"./StvStETHPool.sol\";\nimport {WithdrawalQueue} from \"./WithdrawalQueue.sol\";\nimport {DistributorFactory} from \"./factories/DistributorFactory.sol\";\nimport {StvPoolFactory} from \"./factories/StvPoolFactory.sol\";\nimport {StvStETHPoolFactory} from \"./factories/StvStETHPoolFactory.sol\";\nimport {TimelockFactory} from \"./factories/TimelockFactory.sol\";\nimport {WithdrawalQueueFactory} from \"./factories/WithdrawalQueueFactory.sol\";\nimport {IStrategy} from \"./interfaces/IStrategy.sol\";\nimport {IStrategyFactory} from \"./interfaces/IStrategyFactory.sol\";\nimport {ILidoLocator} from \"./interfaces/core/ILidoLocator.sol\";\nimport {IVaultHub} from \"./interfaces/core/IVaultHub.sol\";\nimport {DummyImplementation} from \"./proxy/DummyImplementation.sol\";\nimport {OssifiableProxy} from \"./proxy/OssifiableProxy.sol\";\n\nimport {IDashboard} from \"./interfaces/core/IDashboard.sol\";\nimport {IVaultFactory} from \"./interfaces/core/IVaultFactory.sol\";\n\n/**\n * @title Factory\n * @notice Main factory contract for deploying complete pool ecosystems with vaults, withdrawal queues, distributors, etc\n * @dev Implements a two-phase deployment process (start/finish) to ensure robust setup of all components and roles\n */\ncontract Factory {\n    //\n    // Structs\n    //\n\n    /**\n     * @notice Addresses of all sub-factory contracts used for deploying components\n     * @param stvPoolFactory Factory for deploying StvPool implementations\n     * @param stvStETHPoolFactory Factory for deploying StvStETHPool implementations\n     * @param withdrawalQueueFactory Factory for deploying WithdrawalQueue implementations\n     * @param distributorFactory Factory for deploying Distributor implementations\n     * @param timelockFactory Factory for deploying Timelock controllers\n     */\n    struct SubFactories {\n        address stvPoolFactory;\n        address stvStETHPoolFactory;\n        address withdrawalQueueFactory;\n        address distributorFactory;\n        address timelockFactory;\n    }\n\n    /**\n     * @notice Configuration parameters for vault creation\n     * @param nodeOperator Address of the node operator managing the vault\n     * @param nodeOperatorManager Address authorized to manage node operator settings\n     * @param nodeOperatorFeeBP Node operator fee in basis points (1 BP = 0.01%)\n     * @param confirmExpiry Time period for confirmation expiry\n     */\n    struct VaultConfig {\n        address nodeOperator;\n        address nodeOperatorManager;\n        uint256 nodeOperatorFeeBP;\n        uint256 confirmExpiry;\n    }\n\n    /**\n     * @notice Configuration for timelock controller deployment\n     * @param minDelaySeconds Minimum delay before executing queued operations\n     * @param proposer Address authorized to propose operations\n     * @param executor Address authorized to execute operations\n     */\n    struct TimelockConfig {\n        uint256 minDelaySeconds;\n        address proposer;\n        address executor;\n    }\n\n    /**\n     * @notice Common configuration shared across all pool types\n     * @param minWithdrawalDelayTime Minimum delay time for processing withdrawals\n     * @param name ERC20 token name for the pool shares\n     * @param symbol ERC20 token symbol for the pool shares\n     * @param emergencyCommittee Address of the emergency committee\n     */\n    struct CommonPoolConfig {\n        uint256 minWithdrawalDelayTime;\n        string name;\n        string symbol;\n        address emergencyCommittee;\n    }\n\n    /**\n     * @notice Configuration specific to StvStETH pools (deprecated, kept for compatibility)\n     * @param allowListEnabled Whether the pool requires allowlist for deposits\n     * @param reserveRatioGapBP Maximum allowed gap in reserve ratio in basis points\n     */\n    struct StvStETHPoolConfig {\n        bool allowListEnabled;\n        uint256 reserveRatioGapBP;\n    }\n\n    /**\n     * @notice Extended configuration for pools with minting or strategy capabilities\n     * @param allowListEnabled Whether the pool requires allowlist for deposits\n     * @param allowListManager Address to be granted ALLOW_LIST_MANAGER_ROLE (ignored for strategy pools)\n     * @param mintingEnabled Whether the pool can mint stETH tokens\n     * @param reserveRatioGapBP Maximum allowed gap in reserve ratio in basis points\n     */\n    struct AuxiliaryPoolConfig {\n        bool allowListEnabled;\n        address allowListManager;\n        bool mintingEnabled;\n        uint256 reserveRatioGapBP;\n    }\n\n    /**\n     * @notice Intermediate state returned by deployment start functions\n     * @param dashboard Address of the deployed dashboard\n     * @param poolProxy Address of the deployed pool proxy (not yet initialized)\n     * @param poolImpl Address of the deployed pool implementation (not yet initialized)\n     * @param withdrawalQueueProxy Address of the deployed withdrawal queue proxy (not yet initialized)\n     * @param wqImpl Address of the deployed withdrawal queue implementation (not yet initialized)\n     * @param timelock Address of the deployed timelock controller\n     */\n    struct PoolIntermediate {\n        address dashboard;\n        address poolProxy;\n        address poolImpl;\n        address withdrawalQueueProxy;\n        address wqImpl;\n        address timelock;\n    }\n\n    /**\n     * @notice Complete deployment result returned by createPoolFinish\n     * @param poolType Type identifier for the pool (StvPool, StvStETHPool, or StvStrategyPool)\n     * @param vault Address of the deployed vault (staking vault)\n     * @param dashboard Address of the deployed dashboard (manages vault roles and interactions)\n     * @param pool Address of the deployed pool (initialized with ERC20 token functionality)\n     * @param withdrawalQueue Address of the deployed withdrawal queue (handles withdrawal requests)\n     * @param distributor Address of the deployed distributor (handles fee distribution)\n     * @param timelock Address of the deployed timelock controller (admin for all components)\n     * @param strategy Address of the deployed strategy (zero if not using strategies)\n     */\n    struct PoolDeployment {\n        bytes32 poolType;\n        address vault;\n        address dashboard;\n        address pool;\n        address withdrawalQueue;\n        address distributor;\n        address timelock;\n        address strategy;\n    }\n\n    //\n    // Events\n    //\n\n    /**\n     * @notice Emitted when pool deployment is initiated in the start phase\n     * @param sender Address that initiated the deployment (msg.sender)\n     * @param vaultConfig Configuration for the vault\n     * @param commonPoolConfig Common pool parameters\n     * @param auxiliaryConfig Additional pool configuration\n     * @param timelockConfig Configuration for the timelock controller\n     * @param strategyFactory Address of strategy factory (zero if not using strategies)\n     * @param strategyDeployBytes ABI-encoded parameters for strategy deployment (empty if no strategy)\n     * @param intermediate Contains addresses of deployed components (dashboard, pool proxy, withdrawal queue proxy, timelock) needed for finish phase\n     * @param finishDeadline Timestamp by which createPoolFinish must be called (inclusive)\n     */\n    event PoolCreationStarted(\n        address indexed sender,\n        VaultConfig vaultConfig,\n        CommonPoolConfig commonPoolConfig,\n        AuxiliaryPoolConfig auxiliaryConfig,\n        TimelockConfig timelockConfig,\n        address indexed strategyFactory,\n        bytes strategyDeployBytes,\n        PoolIntermediate intermediate,\n        uint256 finishDeadline\n    );\n\n    /**\n     * @notice Emitted when pool deployment is completed in the finish phase\n     * @param vault Address of the deployed vault\n     * @param pool Address of the deployed pool\n     * @param poolType Type identifier for the pool (StvPool, StvStETHPool, or StvStrategyPool)\n     * @param withdrawalQueue Address of the deployed withdrawal queue\n     * @param strategyFactory Address of the strategy factory used (zero if none)\n     * @param strategyDeployBytes ABI-encoded parameters used for strategy deployment (empty if no strategy)\n     * @param strategy Address of the deployed strategy (zero if not using strategies)\n     */\n    event PoolCreated(\n        address vault,\n        address pool,\n        bytes32 indexed poolType,\n        address withdrawalQueue,\n        address indexed strategyFactory,\n        bytes strategyDeployBytes,\n        address strategy\n    );\n\n    //\n    // Custom errors\n    //\n\n    /**\n     * @notice Thrown when configuration parameters are invalid or inconsistent\n     * @param reason Human-readable description of the configuration error\n     */\n    error InvalidConfiguration(string reason);\n\n    /**\n     * @notice Thrown when insufficient ETH is sent for the vault connection deposit\n     * @param provided Amount of ETH provided in msg.value\n     * @param required Required amount for VAULT_HUB.CONNECT_DEPOSIT()\n     */\n    error InsufficientConnectDeposit(uint256 provided, uint256 required);\n\n    //\n    // Constants and immutables\n    //\n\n    /**\n     * @notice Lido vault factory for creating vaults and dashboards\n     */\n    IVaultFactory public immutable VAULT_FACTORY;\n\n    /**\n     * @notice Lido V3 VaultHub (cached from LidoLocator for gas cost reduction)\n     */\n    IVaultHub public immutable VAULT_HUB;\n\n    /**\n     * @notice Lido stETH token address (cached from LidoLocator for gas cost reduction)\n     */\n    address public immutable STETH;\n\n    /**\n     * @notice Lido wstETH token address (cached from LidoLocator for gas cost reduction)\n     */\n    address public immutable WSTETH;\n\n    /**\n     * @notice Lido V3 LazyOracle (cached from LidoLocator for gas cost reduction)\n     */\n    address public immutable LAZY_ORACLE;\n\n    /**\n     * @notice Pool type identifier for basic StvPool\n     */\n    bytes32 public immutable STV_POOL_TYPE;\n\n    /**\n     * @notice Pool type identifier for StvStETHPool with minting capabilities\n     */\n    bytes32 public immutable STV_STETH_POOL_TYPE;\n\n    /**\n     * @notice Pool type identifier for StvStrategyPool with strategy integration\n     */\n    bytes32 public immutable STRATEGY_POOL_TYPE;\n\n    /**\n     * @notice Factory for deploying StvPool implementations\n     */\n    StvPoolFactory public immutable STV_POOL_FACTORY;\n\n    /**\n     * @notice Factory for deploying StvStETHPool implementations\n     */\n    StvStETHPoolFactory public immutable STV_STETH_POOL_FACTORY;\n\n    /**\n     * @notice Factory for deploying WithdrawalQueue implementations\n     */\n    WithdrawalQueueFactory public immutable WITHDRAWAL_QUEUE_FACTORY;\n\n    /**\n     * @notice Factory for deploying Distributor implementations\n     */\n    DistributorFactory public immutable DISTRIBUTOR_FACTORY;\n\n    /**\n     * @notice Factory for deploying Timelock controllers\n     */\n    TimelockFactory public immutable TIMELOCK_FACTORY;\n\n    /**\n     * @notice Dummy implementation used for temporary proxy initialization\n     */\n    address public immutable DUMMY_IMPLEMENTATION;\n\n    /**\n     * @notice Default admin role identifier (keccak256(\"\") = 0x00)\n     */\n    bytes32 public immutable DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @notice Maximum time allowed between start and finish deployment phases\n     */\n    uint256 public constant DEPLOY_START_FINISH_SPAN_SECONDS = 1 days;\n\n    /**\n     * @notice Sentinel value marking a deployment as complete\n     */\n    uint256 public constant DEPLOY_FINISHED = type(uint256).max;\n\n    //\n    // Structured storage\n    //\n\n    /**\n     * @notice Tracks deployment state by hash of intermediate state and sender\n     * @dev Maps deployment hash to finish deadline (0 = not started, DEPLOY_FINISHED = finished)\n     */\n    mapping(bytes32 => uint256) public intermediateState;\n\n    /**\n     * @notice Initializes the factory with Lido locator and sub-factory addresses\n     * @param _locatorAddress Address of the Lido locator contract containing core protocol addresses\n     * @param _subFactories Struct containing addresses of all required sub-factory contracts\n     */\n    constructor(address _locatorAddress, SubFactories memory _subFactories) {\n        ILidoLocator locator = ILidoLocator(_locatorAddress);\n        VAULT_FACTORY = IVaultFactory(locator.vaultFactory());\n        STETH = address(locator.lido());\n        WSTETH = address(locator.wstETH());\n        LAZY_ORACLE = locator.lazyOracle();\n        VAULT_HUB = IVaultHub(locator.vaultHub());\n\n        STV_POOL_FACTORY = StvPoolFactory(_subFactories.stvPoolFactory);\n        STV_STETH_POOL_FACTORY = StvStETHPoolFactory(_subFactories.stvStETHPoolFactory);\n        WITHDRAWAL_QUEUE_FACTORY = WithdrawalQueueFactory(_subFactories.withdrawalQueueFactory);\n        DISTRIBUTOR_FACTORY = DistributorFactory(_subFactories.distributorFactory);\n        TIMELOCK_FACTORY = TimelockFactory(_subFactories.timelockFactory);\n\n        DUMMY_IMPLEMENTATION = address(new DummyImplementation());\n\n        STV_POOL_TYPE = ShortString.unwrap(ShortStrings.toShortString(\"StvPool\"));\n        STV_STETH_POOL_TYPE = ShortString.unwrap(ShortStrings.toShortString(\"StvStETHPool\"));\n        STRATEGY_POOL_TYPE = ShortString.unwrap(ShortStrings.toShortString(\"StvStrategyPool\"));\n    }\n\n    /**\n     * @notice Initiates deployment of a basic StvPool (first phase)\n     * @param _vaultConfig Configuration for the vault\n     * @param _timelockConfig Configuration for the timelock controller\n     * @param _commonPoolConfig Common pool parameters (name, symbol, withdrawal delay)\n     * @param _allowListEnabled Whether to enable allowlist for deposits\n     * @param _allowListManager Address to be granted ALLOW_LIST_MANAGER_ROLE\n     * @return intermediate Deployment state needed for finish phase\n     * @dev ETH for vault connection deposit should be sent in createPoolFinish\n     */\n    function createPoolStvStart(\n        VaultConfig memory _vaultConfig,\n        TimelockConfig memory _timelockConfig,\n        CommonPoolConfig memory _commonPoolConfig,\n        bool _allowListEnabled,\n        address _allowListManager\n    ) external returns (PoolIntermediate memory intermediate) {\n        AuxiliaryPoolConfig memory _auxiliaryPoolConfig = AuxiliaryPoolConfig({\n            allowListEnabled: _allowListEnabled,\n            allowListManager: _allowListManager,\n            mintingEnabled: false,\n            reserveRatioGapBP: 0\n        });\n        intermediate =\n            createPoolStart(_vaultConfig, _timelockConfig, _commonPoolConfig, _auxiliaryPoolConfig, address(0), \"\");\n    }\n\n    /**\n     * @notice Initiates deployment of an StvStETHPool with minting capabilities (first phase)\n     * @param _vaultConfig Configuration for the vault\n     * @param _timelockConfig Configuration for the timelock controller\n     * @param _commonPoolConfig Common pool parameters (name, symbol, withdrawal delay)\n     * @param _allowListEnabled Whether to enable allowlist for deposits\n     * @param _allowListManager Address to be granted ALLOW_LIST_MANAGER_ROLE\n     * @param _reserveRatioGapBP Maximum allowed reserve ratio gap in basis points\n     * @return intermediate Deployment state needed for finish phase\n     * @dev ETH for vault connection deposit should be sent in createPoolFinish\n     */\n    function createPoolStvStETHStart(\n        VaultConfig memory _vaultConfig,\n        TimelockConfig memory _timelockConfig,\n        CommonPoolConfig memory _commonPoolConfig,\n        bool _allowListEnabled,\n        address _allowListManager,\n        uint256 _reserveRatioGapBP\n    ) external returns (PoolIntermediate memory intermediate) {\n        AuxiliaryPoolConfig memory _auxiliaryPoolConfig = AuxiliaryPoolConfig({\n            allowListEnabled: _allowListEnabled,\n            allowListManager: _allowListManager,\n            mintingEnabled: true,\n            reserveRatioGapBP: _reserveRatioGapBP\n        });\n\n        intermediate =\n            createPoolStart(_vaultConfig, _timelockConfig, _commonPoolConfig, _auxiliaryPoolConfig, address(0), \"\");\n    }\n\n    /**\n     * @notice Generic pool deployment start function (first phase)\n     * @param _vaultConfig Configuration for the vault\n     * @param _timelockConfig Configuration for the timelock controller\n     * @param _commonPoolConfig Common pool parameters\n     * @param _auxiliaryConfig Additional pool configuration\n     * @param _strategyFactory Address of strategy factory (zero for pools without strategy)\n     * @param _strategyDeployBytes ABI-encoded parameters for strategy deployment\n     * @return intermediate Deployment state required to finish deployment createPoolFinish call\n     * @dev This is the main deployment function called by all pool-specific start functions\n     * @dev ETH for vault connection deposit should be sent in createPoolFinish\n     * @dev Must be followed by createPoolFinish within DEPLOY_START_FINISH_SPAN_SECONDS\n     */\n    function createPoolStart(\n        VaultConfig memory _vaultConfig,\n        TimelockConfig memory _timelockConfig,\n        CommonPoolConfig memory _commonPoolConfig,\n        AuxiliaryPoolConfig memory _auxiliaryConfig,\n        address _strategyFactory,\n        bytes memory _strategyDeployBytes\n    ) public returns (PoolIntermediate memory intermediate) {\n        if (bytes(_commonPoolConfig.name).length == 0 || bytes(_commonPoolConfig.symbol).length == 0) {\n            revert InvalidConfiguration(\"name and symbol must be set\");\n        }\n\n        // Validate allowListManager configuration\n        // For strategy pools, allowListManager is ignored so we don't validate it\n        if (_strategyFactory == address(0)) {\n            if (_auxiliaryConfig.allowListEnabled && _auxiliaryConfig.allowListManager == address(0)) {\n                revert InvalidConfiguration(\"allowListManager must be set when allowlist is enabled\");\n            }\n            if (!_auxiliaryConfig.allowListEnabled && _auxiliaryConfig.allowListManager != address(0)) {\n                revert InvalidConfiguration(\"allowListManager must be zero when allowlist is disabled\");\n            }\n        }\n\n        // Validate proposer and executor addresses\n        if (_timelockConfig.proposer == address(0)) {\n            revert InvalidConfiguration(\"proposer must not be zero address\");\n        }\n        if (_timelockConfig.executor == address(0)) {\n            revert InvalidConfiguration(\"executor must not be zero address\");\n        }\n\n        address timelock = TIMELOCK_FACTORY.deploy(\n            _timelockConfig.minDelaySeconds, _timelockConfig.proposer, _timelockConfig.executor\n        );\n\n        address tempAdmin = address(this);\n\n        address poolProxy = payable(address(new OssifiableProxy(DUMMY_IMPLEMENTATION, tempAdmin, bytes(\"\"))));\n        address wqProxy = payable(address(new OssifiableProxy(DUMMY_IMPLEMENTATION, tempAdmin, bytes(\"\"))));\n\n        (, address dashboardAddress) = VAULT_FACTORY.createVaultWithDashboardWithoutConnectingToVaultHub(\n            tempAdmin,\n            _vaultConfig.nodeOperator,\n            _vaultConfig.nodeOperatorManager,\n            _vaultConfig.nodeOperatorFeeBP,\n            _vaultConfig.confirmExpiry,\n            new IVaultFactory.RoleAssignment[](0)\n        );\n\n        address wqImpl = WITHDRAWAL_QUEUE_FACTORY.deploy(\n            poolProxy,\n            dashboardAddress,\n            address(VAULT_HUB),\n            STETH,\n            address(IDashboard(payable(dashboardAddress)).stakingVault()),\n            LAZY_ORACLE,\n            _commonPoolConfig.minWithdrawalDelayTime,\n            _auxiliaryConfig.mintingEnabled\n        );\n\n        address distributor = DISTRIBUTOR_FACTORY.deploy(timelock, _vaultConfig.nodeOperatorManager);\n\n        bytes32 poolType = derivePoolType(_auxiliaryConfig, _strategyFactory);\n        address poolImpl = address(0);\n        if (poolType == STV_POOL_TYPE) {\n            poolImpl = STV_POOL_FACTORY.deploy(\n                dashboardAddress, _auxiliaryConfig.allowListEnabled, wqProxy, distributor, poolType\n            );\n        } else if (poolType == STV_STETH_POOL_TYPE || poolType == STRATEGY_POOL_TYPE) {\n            poolImpl = STV_STETH_POOL_FACTORY.deploy(\n                dashboardAddress,\n                _auxiliaryConfig.allowListEnabled,\n                _auxiliaryConfig.reserveRatioGapBP,\n                wqProxy,\n                distributor,\n                poolType\n            );\n        } else {\n            assert(false);\n        }\n\n        intermediate = PoolIntermediate({\n            dashboard: dashboardAddress,\n            poolProxy: poolProxy,\n            poolImpl: poolImpl,\n            withdrawalQueueProxy: wqProxy,\n            wqImpl: wqImpl,\n            timelock: timelock\n        });\n\n        bytes32 deploymentHash = _hashDeploymentConfiguration(\n            msg.sender,\n            _vaultConfig,\n            _commonPoolConfig,\n            _auxiliaryConfig,\n            _timelockConfig,\n            _strategyFactory,\n            _strategyDeployBytes,\n            intermediate\n        );\n        uint256 finishDeadline = block.timestamp + DEPLOY_START_FINISH_SPAN_SECONDS;\n        intermediateState[deploymentHash] = finishDeadline;\n\n        emit PoolCreationStarted(\n            msg.sender,\n            _vaultConfig,\n            _commonPoolConfig,\n            _auxiliaryConfig,\n            _timelockConfig,\n            _strategyFactory,\n            _strategyDeployBytes,\n            intermediate,\n            finishDeadline\n        );\n    }\n\n    /**\n     * @notice Completes pool deployment (second phase)\n     *         Requires at least `VAULT_HUB.CONNECT_DEPOSIT()` ether sent with the transaction.\n     *\n     *         All ether sent above `CONNECT_DEPOSIT` is used the same way as `CONNECT_DEPOSIT`\n     *         amount: corresponding STV is minted to the pool contract, available for\n     *         retrieval upon pool shutdown. Increased connect deposit value would increase\n     *         vault's health factor sustainability.\n     * @param _vaultConfig Configuration for the vault (must match createPoolStart)\n     * @param _timelockConfig Configuration for the timelock controller (must match createPoolStart)\n     * @param _commonPoolConfig Common pool parameters (must match createPoolStart)\n     * @param _auxiliaryConfig Additional pool configuration (must match createPoolStart)\n     * @param _strategyFactory Address of strategy factory (must match createPoolStart)\n     * @param _strategyDeployBytes ABI-encoded parameters for strategy deployment (must match createPoolStart)\n     * @param _intermediate Deployment state returned by createPoolStart\n     * @return deployment Complete deployment information with all component addresses\n     * @dev Must be called by the same address that called createPoolStart\n     * @dev Must be called within DEPLOY_START_FINISH_SPAN_SECONDS of start\n     * @dev All parameters must exactly match those used in createPoolStart\n     * @dev Requires msg.value >= VAULT_HUB.CONNECT_DEPOSIT() for vault connection\n     */\n    function createPoolFinish(\n        VaultConfig memory _vaultConfig,\n        TimelockConfig memory _timelockConfig,\n        CommonPoolConfig memory _commonPoolConfig,\n        AuxiliaryPoolConfig memory _auxiliaryConfig,\n        address _strategyFactory,\n        bytes memory _strategyDeployBytes,\n        PoolIntermediate calldata _intermediate\n    ) external payable returns (PoolDeployment memory deployment) {\n        if (msg.value < VAULT_HUB.CONNECT_DEPOSIT()) {\n            revert InsufficientConnectDeposit(msg.value, VAULT_HUB.CONNECT_DEPOSIT());\n        }\n\n        bytes32 deploymentHash = _hashDeploymentConfiguration(\n            msg.sender,\n            _vaultConfig,\n            _commonPoolConfig,\n            _auxiliaryConfig,\n            _timelockConfig,\n            _strategyFactory,\n            _strategyDeployBytes,\n            _intermediate\n        );\n        uint256 finishDeadline = intermediateState[deploymentHash];\n        if (finishDeadline == 0) {\n            revert InvalidConfiguration(\"deploy not started\");\n        } else if (finishDeadline == DEPLOY_FINISHED) {\n            revert InvalidConfiguration(\"deploy already finished\");\n        }\n        if (block.timestamp > finishDeadline) {\n            revert InvalidConfiguration(\"deploy finish deadline passed\");\n        }\n        intermediateState[deploymentHash] = DEPLOY_FINISHED;\n\n        address tempAdmin = address(this);\n\n        IDashboard dashboard = IDashboard(payable(_intermediate.dashboard));\n\n        dashboard.connectToVaultHub{value: msg.value}();\n\n        address wqImpl = _intermediate.wqImpl;\n        address poolImpl = _intermediate.poolImpl;\n\n        OssifiableProxy(payable(_intermediate.poolProxy))\n            .proxy__upgradeToAndCall(\n                poolImpl,\n                abi.encodeCall(StvPool.initialize, (tempAdmin, _commonPoolConfig.name, _commonPoolConfig.symbol))\n            );\n        OssifiableProxy(payable(_intermediate.poolProxy)).proxy__changeAdmin(_intermediate.timelock);\n\n        OssifiableProxy(payable(_intermediate.withdrawalQueueProxy))\n            .proxy__upgradeToAndCall(\n                wqImpl,\n                abi.encodeCall(\n                    WithdrawalQueue.initialize,\n                    (\n                        _intermediate.timelock,\n                        _vaultConfig.nodeOperator,\n                        _commonPoolConfig.emergencyCommittee,\n                        _commonPoolConfig.emergencyCommittee\n                    )\n                )\n            );\n        OssifiableProxy(payable(_intermediate.withdrawalQueueProxy)).proxy__changeAdmin(_intermediate.timelock);\n\n        StvPool pool = StvPool(payable(_intermediate.poolProxy));\n        WithdrawalQueue withdrawalQueue = WithdrawalQueue(payable(_intermediate.withdrawalQueueProxy));\n\n        address strategyProxy = address(0);\n        if (_strategyFactory != address(0)) {\n            address strategyImpl = IStrategyFactory(_strategyFactory).deploy(address(pool), _strategyDeployBytes);\n            strategyProxy = address(\n                new OssifiableProxy(\n                    strategyImpl,\n                    _intermediate.timelock,\n                    abi.encodeCall(IStrategy.initialize, (_intermediate.timelock, _commonPoolConfig.emergencyCommittee))\n                )\n            );\n            pool.addToAllowList(strategyProxy);\n        }\n\n        if (_commonPoolConfig.emergencyCommittee != address(0)) {\n            pool.grantRole(pool.DEPOSITS_PAUSE_ROLE(), _commonPoolConfig.emergencyCommittee);\n            if (_auxiliaryConfig.mintingEnabled) {\n                StvStETHPool stvStETHPool = StvStETHPool(payable(address(pool)));\n                stvStETHPool.grantRole(stvStETHPool.MINTING_PAUSE_ROLE(), _commonPoolConfig.emergencyCommittee);\n            }\n        }\n\n        if (_auxiliaryConfig.allowListEnabled) {\n            if (_strategyFactory == address(0)) {\n                pool.grantRole(pool.ALLOW_LIST_MANAGER_ROLE(), _auxiliaryConfig.allowListManager);\n            }\n            pool.revokeRole(pool.ALLOW_LIST_MANAGER_ROLE(), tempAdmin);\n        }\n\n        pool.grantRole(DEFAULT_ADMIN_ROLE, _intermediate.timelock);\n        pool.revokeRole(DEFAULT_ADMIN_ROLE, tempAdmin);\n\n        dashboard.grantRole(dashboard.FUND_ROLE(), _intermediate.poolProxy);\n        dashboard.grantRole(dashboard.REBALANCE_ROLE(), _intermediate.poolProxy);\n        dashboard.grantRole(dashboard.WITHDRAW_ROLE(), _intermediate.withdrawalQueueProxy);\n        if (_auxiliaryConfig.mintingEnabled) {\n            dashboard.grantRole(dashboard.MINT_ROLE(), _intermediate.poolProxy);\n            dashboard.grantRole(dashboard.BURN_ROLE(), _intermediate.poolProxy);\n        }\n        if (address(0) != _commonPoolConfig.emergencyCommittee) {\n            dashboard.grantRole(dashboard.PAUSE_BEACON_CHAIN_DEPOSITS_ROLE(), _commonPoolConfig.emergencyCommittee);\n        }\n\n        dashboard.grantRole(DEFAULT_ADMIN_ROLE, _intermediate.timelock);\n        dashboard.revokeRole(DEFAULT_ADMIN_ROLE, tempAdmin);\n\n        deployment = PoolDeployment({\n            poolType: derivePoolType(_auxiliaryConfig, _strategyFactory),\n            vault: address(dashboard.stakingVault()),\n            dashboard: address(dashboard),\n            pool: address(pool),\n            withdrawalQueue: address(withdrawalQueue),\n            distributor: address(pool.DISTRIBUTOR()),\n            timelock: _intermediate.timelock,\n            strategy: strategyProxy\n        });\n\n        emit PoolCreated(\n            deployment.vault,\n            deployment.pool,\n            deployment.poolType,\n            deployment.withdrawalQueue,\n            _strategyFactory,\n            _strategyDeployBytes,\n            deployment.strategy\n        );\n    }\n\n    function derivePoolType(AuxiliaryPoolConfig memory _auxiliaryConfig, address _strategyFactory)\n        public\n        view\n        returns (bytes32 poolType)\n    {\n        poolType = STV_POOL_TYPE;\n        if (_strategyFactory != address(0)) {\n            poolType = STRATEGY_POOL_TYPE;\n            if (!_auxiliaryConfig.allowListEnabled) {\n                revert InvalidConfiguration(\"allowListEnabled must be true if strategy factory is set\");\n            }\n            if (!_auxiliaryConfig.mintingEnabled) {\n                revert InvalidConfiguration(\"mintingEnabled must be true if strategy factory is set\");\n            }\n        } else if (_auxiliaryConfig.mintingEnabled) {\n            poolType = STV_STETH_POOL_TYPE;\n        }\n    }\n\n    /**\n     * @notice Computes a unique hash for tracking deployment state\n     * @param _sender Address that initiated the deployment\n     * @param _vaultConfig Configuration for the vault\n     * @param _commonPoolConfig Common pool parameters\n     * @param _auxiliaryConfig Additional pool configuration\n     * @param _timelockConfig Configuration for the timelock controller\n     * @param _strategyFactory Address of strategy factory\n     * @param _strategyDeployBytes ABI-encoded parameters for strategy deployment\n     * @param _intermediate The intermediate deployment state\n     * @return result Keccak256 hash of all deployment configuration parameters\n     */\n    function _hashDeploymentConfiguration(\n        address _sender,\n        VaultConfig memory _vaultConfig,\n        CommonPoolConfig memory _commonPoolConfig,\n        AuxiliaryPoolConfig memory _auxiliaryConfig,\n        TimelockConfig memory _timelockConfig,\n        address _strategyFactory,\n        bytes memory _strategyDeployBytes,\n        PoolIntermediate memory _intermediate\n    ) internal pure returns (bytes32 result) {\n        result = keccak256(\n            abi.encode(\n                _sender,\n                abi.encode(_vaultConfig),\n                abi.encode(_commonPoolConfig),\n                abi.encode(_auxiliaryConfig),\n                abi.encode(_timelockConfig),\n                _strategyFactory,\n                _strategyDeployBytes,\n                abi.encode(_intermediate)\n            )\n        );\n    }\n}\n",
        "StvStETHPool.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {StvPool} from \"./StvPool.sol\";\nimport {IVaultHub} from \"./interfaces/core/IVaultHub.sol\";\nimport {IWstETH} from \"./interfaces/core/IWstETH.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title StvStETHPool\n * @notice Extended STV pool with (w)stETH minting, liability management, and rebalancing capabilities\n * @dev Allows users to mint (w)stETH against their deposits with configurable reserve ratios\n */\ncontract StvStETHPool is StvPool {\n    event StethSharesMinted(address indexed account, uint256 stethShares);\n    event StethSharesBurned(address indexed account, uint256 stethShares);\n    event StethSharesRebalanced(address indexed account, uint256 stethShares, uint256 stvBurned);\n    event SocializedLoss(uint256 stv, uint256 assets, uint256 maxLossSocializationBP);\n    event VaultParametersUpdated(uint256 newReserveRatioBP, uint256 newForcedRebalanceThresholdBP);\n    event MaxLossSocializationUpdated(uint256 newMaxLossSocializationBP);\n\n    error InsufficientMintingCapacity();\n    error InsufficientStethShares();\n    error InsufficientBalance();\n    error InsufficientReservedBalance();\n    error InsufficientMintedShares();\n    error InsufficientExceedingShares();\n    error InsufficientStv();\n    error ZeroArgument();\n    error CannotRebalanceWithdrawalQueue();\n    error CannotTransferLiabilityToWithdrawalQueue();\n    error UndercollateralizedAccount();\n    error CollateralizedAccount();\n    error ExcessiveLossSocialization();\n    error SameValue();\n    error InvalidValue();\n\n    bytes32 public constant MINTING_FEATURE = keccak256(\"MINTING_FEATURE\");\n    bytes32 public constant MINTING_PAUSE_ROLE = keccak256(\"MINTING_PAUSE_ROLE\");\n    bytes32 public constant MINTING_RESUME_ROLE = keccak256(\"MINTING_RESUME_ROLE\");\n\n    bytes32 public constant LOSS_SOCIALIZER_ROLE = keccak256(\"LOSS_SOCIALIZER_ROLE\");\n\n    /// @notice The gap between the reserve ratio in Staking Vault and Pool (in basis points)\n    uint256 public immutable RESERVE_RATIO_GAP_BP;\n\n    IWstETH public immutable WSTETH;\n\n    /// @custom:storage-location erc7201:pool.storage.StvStETHPool\n    struct StvStETHPoolStorage {\n        mapping(address => uint256) mintedStethShares;\n        uint256 totalMintedStethShares;\n        uint16 poolReserveRatioBP;\n        uint16 poolForcedRebalanceThresholdBP;\n        uint16 maxLossSocializationBP;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"pool.storage.StvStETHPool\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant STV_STETH_POOL_STORAGE_LOCATION =\n        0xcb955bfb671da6f0ca24747fd5d6827b1540ffa01981f020957afc070cf0eb00;\n\n    function _getStvStETHPoolStorage() internal pure returns (StvStETHPoolStorage storage $) {\n        assembly {\n            $.slot := STV_STETH_POOL_STORAGE_LOCATION\n        }\n    }\n\n    constructor(\n        address _dashboard,\n        bool _allowListEnabled,\n        uint256 _reserveRatioGapBP,\n        address _withdrawalQueue,\n        address _distributor,\n        bytes32 _poolType\n    ) StvPool(_dashboard, _allowListEnabled, _withdrawalQueue, _distributor, _poolType) {\n        RESERVE_RATIO_GAP_BP = _reserveRatioGapBP;\n        WSTETH = IWstETH(DASHBOARD.WSTETH());\n\n        // Pause features in implementation\n        _pauseFeature(MINTING_FEATURE);\n    }\n\n    function initialize(address _owner, string memory _name, string memory _symbol) public override initializer {\n        _initializeBasePool(_owner, _name, _symbol);\n\n        // Approve max to the Dashboard for burning\n        STETH.approve(address(DASHBOARD), type(uint256).max);\n        WSTETH.approve(address(DASHBOARD), type(uint256).max);\n\n        // Sync reserve ratio and forced rebalance threshold from the VaultHub\n        syncVaultParameters();\n    }\n\n    // =================================================================================\n    // DEPOSIT\n    // =================================================================================\n\n    /**\n     * @notice Deposit native ETH and receive stv, minting a specific amount of stETH shares\n     * @param _referral Address of the referral (if any)\n     * @param _stethSharesToMint Optional amount of stETH shares to mint (18 decimals)\n     * @return stv Amount of stv minted (27 decimals)\n     */\n    function depositETHAndMintStethShares(address _referral, uint256 _stethSharesToMint)\n        external\n        payable\n        virtual\n        returns (uint256 stv)\n    {\n        stv = depositETH(msg.sender, _referral);\n        if (_stethSharesToMint != 0) mintStethShares(_stethSharesToMint);\n    }\n\n    /**\n     * @notice Deposit native ETH and receive stv, minting a specific amount of wstETH\n     * @param _referral Address of the referral (if any)\n     * @param _wstethToMint Optional amount of wstETH to mint (18 decimals)\n     * @return stv Amount of stv minted (27 decimals)\n     */\n    function depositETHAndMintWsteth(address _referral, uint256 _wstethToMint)\n        external\n        payable\n        virtual\n        returns (uint256 stv)\n    {\n        stv = depositETH(msg.sender, _referral);\n        if (_wstethToMint != 0) mintWsteth(_wstethToMint);\n    }\n\n    // =================================================================================\n    // WITHDRAWALS\n    // =================================================================================\n\n    /**\n     * @notice Calculate the amount of assets that can be unlocked if a specified amount of stETH shares is burned\n     * @param _account The address of the account\n     * @param _stethSharesToBurn The amount of stETH shares to burn\n     * @return assets The amount of assets that can be unlocked (18 decimals)\n     */\n    function unlockedAssetsOf(address _account, uint256 _stethSharesToBurn) public view returns (uint256 assets) {\n        uint256 mintedStethShares = mintedStethSharesOf(_account);\n        if (mintedStethShares < _stethSharesToBurn) revert InsufficientStethShares();\n\n        uint256 mintedStethSharesAfter = mintedStethShares - _stethSharesToBurn;\n        uint256 minLockedAssetsAfter = calcAssetsToLockForStethShares(mintedStethSharesAfter);\n        assets = Math.saturatingSub(assetsOf(_account), minLockedAssetsAfter);\n    }\n\n    /**\n     * @notice Calculate the amount of unlocked assets for an account\n     * @param _account The address of the account\n     * @return assets The amount of assets (18 decimals)\n     */\n    function unlockedAssetsOf(address _account) public view returns (uint256 assets) {\n        assets = unlockedAssetsOf(_account, 0);\n    }\n\n    /**\n     * @notice Calculate the amount of stv that can be unlocked if a specified amount of stETH shares is burned\n     * @param _account The address of the account\n     * @param _stethSharesToBurn The amount of stETH shares to burn\n     * @return stv The amount of stv that can be unlocked (27 decimals)\n     */\n    function unlockedStvOf(address _account, uint256 _stethSharesToBurn) public view returns (uint256 stv) {\n        stv = _convertToStv(unlockedAssetsOf(_account, _stethSharesToBurn), Math.Rounding.Floor);\n    }\n\n    /**\n     * @notice Calculate the amount of unlocked stv for an account\n     * @param _account The address of the account\n     * @return stv The amount of stv (27 decimals)\n     */\n    function unlockedStvOf(address _account) public view returns (uint256 stv) {\n        stv = unlockedStvOf(_account, 0);\n    }\n\n    /**\n     * @notice Calculate the amount of stETH shares to burn to unlock a given amount of stv\n     * @param _account The address of the account\n     * @param _stv The amount of stv to unlock\n     * @return stethShares The corresponding amount of stETH shares needed to burn (18 decimals)\n     */\n    function stethSharesToBurnForStvOf(address _account, uint256 _stv) external view returns (uint256 stethShares) {\n        if (_stv == 0) return 0;\n\n        uint256 currentBalance = balanceOf(_account);\n        if (currentBalance < _stv) revert InsufficientBalance();\n\n        uint256 balanceAfter = currentBalance - _stv;\n        uint256 maxStethSharesAfter = calcStethSharesToMintForStv(balanceAfter);\n        stethShares = Math.saturatingSub(mintedStethSharesOf(_account), maxStethSharesAfter);\n    }\n\n    /**\n     * @notice Transfer stv with liability from user to WithdrawalQueue contract when enqueuing withdrawal requests\n     * @param _from Address of the user\n     * @param _stv Amount of stv to transfer (27 decimals)\n     * @param _stethShares Amount of stETH shares liability to transfer (18 decimals)\n     * @dev Ensures that the transferred stv covers the minimum required to lock for the transferred stETH shares liability\n     * @dev Can only be called by the WithdrawalQueue contract\n     * @dev Requires fresh oracle report, which is checked in the Withdrawal Queue\n     */\n    function transferFromWithLiabilityForWithdrawalQueue(address _from, uint256 _stv, uint256 _stethShares) external {\n        _checkOnlyWithdrawalQueue();\n        _transferWithLiability(_from, address(WITHDRAWAL_QUEUE), _stv, _stethShares);\n    }\n\n    function _checkMinStvToLock(uint256 _stv, uint256 _stethShares) internal view {\n        uint256 minStvAmountToLock = calcStvToLockForStethShares(_stethShares);\n        if (_stv < minStvAmountToLock) revert InsufficientStv();\n    }\n\n    // =================================================================================\n    // ASSETS\n    // =================================================================================\n\n    /**\n     * @notice Total assets managed by the pool\n     * @return assets Total assets (18 decimals)\n     * @dev Includes total assets + total exceeding minted stETH\n     */\n    function totalAssets() public view override returns (uint256 assets) {\n        /// As a result of the rebalancing initiated in the Staking Vault, bypassing the Wrapper,\n        /// part of the total liability can be reduced at the expense of the Staking Vault's assets.\n        ///\n        /// As a result of this operation, the total liabilityShares on the Staking Vault will decrease,\n        /// while mintedStethShares will remain the same, as will the users' debts on these obligations.\n        /// The difference between these two values is the stETH that users owe to Wrapper, but which\n        /// should not be returned to Staking Vault, but should be distributed among all participants\n        /// in exchange for the withdrawn ETH.\n        ///\n        /// Thus, in rare situations, StvStETHPool may have two assets: ETH and stETH, which are\n        /// distributed among all users in proportion to their shares.\n\n        uint256 exceedingMintedSteth = totalExceedingMintedSteth();\n\n        /// total assets = nominal assets + exceeding minted steth - unassigned liability steth\n        ///\n        /// exceeding minted steth = minted steth on wrapper - liability on vault\n        /// unassigned liability steth = liability on vault - minted steth on wrapper\n        /// so only one of these values can be > 0 at any time\n        if (exceedingMintedSteth > 0) {\n            assets = totalNominalAssets() + exceedingMintedSteth;\n        } else {\n            assets = Math.saturatingSub(totalNominalAssets(), totalUnassignedLiabilitySteth());\n        }\n    }\n\n    // =================================================================================\n    // MINTED STETH SHARES\n    // =================================================================================\n\n    /**\n     * @notice Total stETH shares minted by the pool\n     * @return stethShares Total stETH shares minted (18 decimals)\n     */\n    function totalMintedStethShares() public view returns (uint256 stethShares) {\n        stethShares = _getStvStETHPoolStorage().totalMintedStethShares;\n    }\n\n    /**\n     * @notice Amount of stETH shares minted by the pool for a specific account\n     * @param _account The address of the account\n     * @return stethShares Amount of stETH shares minted (18 decimals)\n     */\n    function mintedStethSharesOf(address _account) public view returns (uint256 stethShares) {\n        stethShares = _getStvStETHPoolStorage().mintedStethShares[_account];\n    }\n\n    /**\n     * @notice Calculate the total minting capacity in stETH shares for a specific account\n     * @param _account The address of the account\n     * @return stethShares The total minting capacity in stETH shares\n     */\n    function totalMintingCapacitySharesOf(address _account) external view returns (uint256 stethShares) {\n        stethShares = calcStethSharesToMintForAssets(assetsOf(_account));\n    }\n\n    /**\n     * @notice Calculate the remaining minting capacity in stETH shares for a specific account\n     * @param _account The address of the account\n     * @param _ethToFund The amount of ETH to fund\n     * @return stethShares The remaining minting capacity in stETH shares\n     */\n    function remainingMintingCapacitySharesOf(address _account, uint256 _ethToFund)\n        public\n        view\n        returns (uint256 stethShares)\n    {\n        // Simulate depositing ETH to account for rounded down assets after conversion\n        uint256 stvForAssets = _convertToStv(_ethToFund, Math.Rounding.Floor);\n        uint256 ethRoundedDown = _convertToAssets(stvForAssets);\n\n        uint256 stethSharesForAssets = calcStethSharesToMintForAssets(assetsOf(_account) + ethRoundedDown);\n        stethShares = Math.saturatingSub(stethSharesForAssets, mintedStethSharesOf(_account));\n    }\n\n    /**\n     * @notice Mint wstETH up to the user's minting capacity\n     * @param _wsteth The amount of wstETH to mint\n     * @dev Note that minted wstETH may not be enough to cover the full obligation in stETH shares because of rounding error\n     * on WSTETH contract during unwrapping. The dust from rounding accumulates on the WSTETH contract during unwrapping\n     */\n    function mintWsteth(uint256 _wsteth) public {\n        _checkFeatureNotPaused(MINTING_FEATURE);\n        _checkRemainingMintingCapacityOf(msg.sender, _wsteth);\n\n        _increaseMintedStethShares(msg.sender, _wsteth);\n        DASHBOARD.mintWstETH(msg.sender, _wsteth);\n    }\n\n    /**\n     * @notice Mint stETH shares up to the user's minting capacity\n     * @param _stethShares The amount of stETH shares to mint\n     */\n    function mintStethShares(uint256 _stethShares) public {\n        _checkFeatureNotPaused(MINTING_FEATURE);\n        _checkRemainingMintingCapacityOf(msg.sender, _stethShares);\n\n        _increaseMintedStethShares(msg.sender, _stethShares);\n        DASHBOARD.mintShares(msg.sender, _stethShares);\n    }\n\n    /**\n     * @notice Burn wstETH to reduce the user's minted stETH obligation\n     * @param _wsteth The amount of wstETH to burn\n     * @dev Note that minted wstETH may not be enough to cover the full obligation in stETH shares because of rounding error\n     * on WSTETH contract during unwrapping. The dust from rounding accumulates on the WSTETH contract during unwrapping\n     */\n    function burnWsteth(uint256 _wsteth) external {\n        /// @dev Simulate conversions during unwrapping to account for possible reduction due to rounding errors\n        uint256 unwrappedSteth = _getPooledEthByShares(_wsteth);\n        uint256 unwrappedStethShares = _getSharesByPooledEth(unwrappedSteth);\n        _decreaseMintedStethShares(msg.sender, unwrappedStethShares);\n\n        // Transfer on WSTETH contract always return true or revert\n        assert(WSTETH.transferFrom(msg.sender, address(this), _wsteth));\n        DASHBOARD.burnWstETH(_wsteth);\n    }\n\n    /**\n     * @notice Burn stETH shares to reduce the user's minted stETH obligation\n     * @param _stethShares The amount of stETH shares to burn\n     */\n    function burnStethShares(uint256 _stethShares) external {\n        _decreaseMintedStethShares(msg.sender, _stethShares);\n        STETH.transferSharesFrom(msg.sender, address(this), _stethShares);\n        DASHBOARD.burnShares(_stethShares);\n    }\n\n    function _checkRemainingMintingCapacityOf(address _account, uint256 _stethShares) internal view {\n        if (remainingMintingCapacitySharesOf(_account, 0) < _stethShares) revert InsufficientMintingCapacity();\n    }\n\n    function _increaseMintedStethShares(address _account, uint256 _stethShares) internal {\n        StvStETHPoolStorage storage $ = _getStvStETHPoolStorage();\n\n        if (_stethShares == 0) revert ZeroArgument();\n\n        $.totalMintedStethShares += _stethShares;\n        $.mintedStethShares[_account] += _stethShares;\n\n        emit StethSharesMinted(_account, _stethShares);\n    }\n\n    function _decreaseMintedStethShares(address _account, uint256 _stethShares) internal {\n        StvStETHPoolStorage storage $ = _getStvStETHPoolStorage();\n\n        if (_stethShares == 0) revert ZeroArgument();\n        if ($.mintedStethShares[_account] < _stethShares) revert InsufficientMintedShares();\n\n        $.totalMintedStethShares -= _stethShares;\n        $.mintedStethShares[_account] -= _stethShares;\n\n        emit StethSharesBurned(_account, _stethShares);\n    }\n\n    function _transferStethSharesLiability(address _from, address _to, uint256 _stethShares) internal {\n        StvStETHPoolStorage storage $ = _getStvStETHPoolStorage();\n\n        if (_stethShares == 0) revert ZeroArgument();\n        if ($.mintedStethShares[_from] < _stethShares) revert InsufficientMintedShares();\n\n        $.mintedStethShares[_from] -= _stethShares;\n        $.mintedStethShares[_to] += _stethShares;\n\n        emit StethSharesBurned(_from, _stethShares);\n        emit StethSharesMinted(_to, _stethShares);\n    }\n\n    /**\n     * @notice Calculate the amount of stETH shares to mint for a given amount of assets\n     * @param _assets The amount of assets (18 decimals)\n     * @return stethShares The corresponding amount of stETH shares to mint (18 decimals)\n     */\n    function calcStethSharesToMintForAssets(uint256 _assets) public view returns (uint256 stethShares) {\n        uint256 maxStethToMint =\n            Math.mulDiv(_assets, TOTAL_BASIS_POINTS - poolReserveRatioBP(), TOTAL_BASIS_POINTS, Math.Rounding.Floor);\n\n        stethShares = _getSharesByPooledEth(maxStethToMint);\n    }\n\n    /**\n     * @notice Calculate the amount of stETH shares to mint for a given amount of stv\n     * @param _stv The amount of stv (27 decimals)\n     * @return stethShares The corresponding amount of stETH shares to mint (18 decimals)\n     */\n    function calcStethSharesToMintForStv(uint256 _stv) public view returns (uint256 stethShares) {\n        stethShares = calcStethSharesToMintForAssets(_convertToAssets(_stv));\n    }\n\n    /**\n     * @notice Calculate the min amount of assets to lock for a given amount of stETH shares\n     * @param _stethShares The amount of stETH shares (18 decimals)\n     * @return assetsToLock The min amount of assets to lock (18 decimals)\n     * @dev Use the ceiling rounding to ensure enough assets are locked\n     */\n    function calcAssetsToLockForStethShares(uint256 _stethShares) public view returns (uint256 assetsToLock) {\n        if (_stethShares == 0) return 0;\n\n        assetsToLock = Math.mulDiv(\n            _getPooledEthBySharesRoundUp(_stethShares),\n            TOTAL_BASIS_POINTS,\n            TOTAL_BASIS_POINTS - poolReserveRatioBP(),\n            Math.Rounding.Ceil\n        );\n    }\n\n    /**\n     * @notice Calculate the min amount of stv to lock for a given amount of stETH shares\n     * @param _stethShares The amount of stETH shares (18 decimals)\n     * @return stvToLock The min amount of stv to lock (27 decimals)\n     */\n    function calcStvToLockForStethShares(uint256 _stethShares) public view returns (uint256 stvToLock) {\n        stvToLock = _convertToStv(calcAssetsToLockForStethShares(_stethShares), Math.Rounding.Ceil);\n    }\n\n    // =================================================================================\n    // VAULT PARAMETERS\n    // =================================================================================\n\n    /**\n     * @notice Reserve ratio in basis points with the gap applied\n     * @return reserveRatio The reserve ratio in basis points\n     */\n    function poolReserveRatioBP() public view returns (uint256 reserveRatio) {\n        reserveRatio = uint256(_getStvStETHPoolStorage().poolReserveRatioBP);\n    }\n\n    /**\n     * @notice Forced rebalance threshold in basis points\n     * @return threshold The forced rebalance threshold in basis points\n     */\n    function poolForcedRebalanceThresholdBP() public view returns (uint256 threshold) {\n        threshold = uint256(_getStvStETHPoolStorage().poolForcedRebalanceThresholdBP);\n    }\n\n    /**\n     * @notice Sync reserve ratio and forced rebalance threshold from VaultHub\n     * @dev Permissionless method to keep reserve ratio and forced rebalance threshold in sync with VaultHub\n     * @dev Adds a gap defined by RESERVE_RATIO_GAP_BP to VaultHub's values\n     */\n    function syncVaultParameters() public {\n        IVaultHub.VaultConnection memory connection = DASHBOARD.vaultConnection();\n\n        uint256 maxReserveRatioBP = TOTAL_BASIS_POINTS - 1;\n        uint256 maxForcedRebalanceThresholdBP = maxReserveRatioBP - 1;\n\n        /// Invariants from the OperatorGrid\n        assert(connection.reserveRatioBP > 0);\n        assert(connection.reserveRatioBP <= maxReserveRatioBP);\n        assert(connection.forcedRebalanceThresholdBP > 0);\n        assert(connection.forcedRebalanceThresholdBP < connection.reserveRatioBP);\n\n        uint16 newPoolReserveRatioBP =\n            uint16(Math.min(connection.reserveRatioBP + RESERVE_RATIO_GAP_BP, maxReserveRatioBP));\n        uint16 newPoolForcedRebalanceThresholdBP = uint16(\n            Math.min(connection.forcedRebalanceThresholdBP + RESERVE_RATIO_GAP_BP, maxForcedRebalanceThresholdBP)\n        );\n\n        StvStETHPoolStorage storage $ = _getStvStETHPoolStorage();\n\n        if (\n            newPoolReserveRatioBP == $.poolReserveRatioBP\n                && newPoolForcedRebalanceThresholdBP == $.poolForcedRebalanceThresholdBP\n        ) {\n            return;\n        }\n\n        $.poolReserveRatioBP = newPoolReserveRatioBP;\n        $.poolForcedRebalanceThresholdBP = newPoolForcedRebalanceThresholdBP;\n\n        emit VaultParametersUpdated(newPoolReserveRatioBP, newPoolForcedRebalanceThresholdBP);\n    }\n\n    // =================================================================================\n    // EXCEEDING MINTED STETH\n    // =================================================================================\n\n    /**\n     * @notice Amount of minted stETH shares exceeding the Staking Vault's liability\n     * @return stethShares Amount of exceeding stETH shares (18 decimals)\n     * @dev May occur if rebalancing happens on the Staking Vault bypassing the Wrapper\n     */\n    function totalExceedingMintedStethShares() public view returns (uint256 stethShares) {\n        stethShares = Math.saturatingSub(totalMintedStethShares(), totalLiabilityShares());\n    }\n\n    /**\n     * @notice Amount of minted stETH exceeding the Staking Vault's liability\n     * @return steth Amount of exceeding stETH (18 decimals)\n     * @dev May occur if rebalancing happens on the Staking Vault bypassing the Wrapper\n     */\n    function totalExceedingMintedSteth() public view returns (uint256 steth) {\n        steth = _getPooledEthByShares(totalExceedingMintedStethShares());\n    }\n\n    // =================================================================================\n    // UNASSIGNED LIABILITY\n    // =================================================================================\n\n    /**\n     * @notice Total unassigned liability shares in the Staking Vault\n     * @return unassignedLiabilityShares Total unassigned liability shares (18 decimals)\n     * @dev Overridden method from StvPool to include unassigned liability shares\n     * @dev May occur if liability was transferred from another Staking Vault\n     */\n    function totalUnassignedLiabilityShares() public view override returns (uint256 unassignedLiabilityShares) {\n        unassignedLiabilityShares = Math.saturatingSub(totalLiabilityShares(), totalMintedStethShares());\n    }\n\n    // =================================================================================\n    // REBALANCE\n    // =================================================================================\n\n    /**\n     * @notice Rebalance the user's minted stETH shares by burning stv\n     * @param _stethShares The amount of stETH shares to rebalance\n     * @param _maxStvToBurn The maximum amount of stv to burn for rebalancing\n     * @return stvBurned The actual amount of stv burned for rebalancing\n     * @dev First, rebalances internally by burning stv, which decreases exceeding shares (if any)\n     * @dev Second, if there are remaining liability shares, rebalances Staking Vault\n     * @dev Requires fresh oracle report, which is checked in the Withdrawal Queue\n     */\n    function rebalanceMintedStethSharesForWithdrawalQueue(uint256 _stethShares, uint256 _maxStvToBurn)\n        public\n        returns (uint256 stvBurned)\n    {\n        _checkOnlyWithdrawalQueue();\n        stvBurned = _rebalanceMintedStethShares(msg.sender, _stethShares, _maxStvToBurn);\n    }\n\n    /**\n     * @notice Force rebalance the user's minted stETH shares if the reserve ratio threshold is breached\n     * @param _account The address of the account to rebalance\n     * @return stvBurned The actual amount of stv burned for rebalancing\n     * @dev Permissionless method to rebalance any account that breached the health threshold\n     * @dev Requires fresh oracle report to price stv accurately\n     */\n    function forceRebalance(address _account) external returns (uint256 stvBurned) {\n        if (_account == address(WITHDRAWAL_QUEUE)) revert CannotRebalanceWithdrawalQueue();\n        _checkFreshReport();\n\n        (uint256 stethShares, uint256 stv, bool isUndercollateralized) = previewForceRebalance(_account);\n        if (isUndercollateralized) revert UndercollateralizedAccount();\n\n        stvBurned = _rebalanceMintedStethShares(_account, stethShares, stv);\n    }\n\n    /**\n     * @notice Force rebalance undercollateralized account and socialize the remaining loss to all pool participants\n     * @param _account The address of the account to rebalance\n     * @return stvBurned The actual amount of stv burned for rebalancing\n     * @dev Requires fresh oracle report to price stv accurately\n     */\n    function forceRebalanceAndSocializeLoss(address _account) external returns (uint256 stvBurned) {\n        if (_account == address(WITHDRAWAL_QUEUE)) revert CannotRebalanceWithdrawalQueue();\n        _checkRole(LOSS_SOCIALIZER_ROLE, msg.sender);\n        _checkFreshReport();\n\n        (uint256 stethShares, uint256 stv, bool isUndercollateralized) = previewForceRebalance(_account);\n        if (!isUndercollateralized) revert CollateralizedAccount();\n\n        stvBurned = _rebalanceMintedStethShares(_account, stethShares, stv);\n    }\n\n    /**\n     * @notice Preview the amount of stETH shares and stv needed to force rebalance the user's position\n     * @param _account The address of the account to preview\n     * @return stethShares The amount of stETH shares to rebalance, limited by available assets\n     * @return stv The amount of stv needed to burn in exchange for the stETH shares, limited by user's stv balance\n     * @return isUndercollateralized True if the user's assets are insufficient to cover the liability\n     * @dev Requires fresh oracle report to price stv accurately (not enforced in this method, so caller must ensure it)\n     */\n    function previewForceRebalance(address _account)\n        public\n        view\n        returns (uint256 stethShares, uint256 stv, bool isUndercollateralized)\n    {\n        uint256 stethSharesLiability = mintedStethSharesOf(_account);\n        uint256 stvBalance = balanceOf(_account);\n        uint256 assets = assetsOf(_account);\n\n        /// Position is healthy, nothing to rebalance\n        if (!_isThresholdBreached(assets, stethSharesLiability)) return (0, 0, false);\n\n        /// Rebalance (swap steth liability for stv at the current rate) user to the reserve ratio level\n        ///\n        /// To calculate how much steth shares to rebalance to reach the target reserve ratio, we can set up the equation:\n        /// (1 - reserveRatio) = (liabilityShares - x) / (assetsInStethShares - x)\n        ///\n        /// Rearranging the equation to solve for x gives us:\n        /// x = (liabilityShares - (1 - reserveRatio) * assetsInStethShares) / reserveRatio\n        uint256 reserveRatioBP_ = poolReserveRatioBP();\n        uint256 assetsInStethShares = _getSharesByPooledEth(assets);\n        uint256 targetStethSharesToRebalance = Math.ceilDiv(\n            /// Shouldn't underflow as threshold breach is already checked\n            stethSharesLiability * TOTAL_BASIS_POINTS - (TOTAL_BASIS_POINTS - reserveRatioBP_) * assetsInStethShares,\n            reserveRatioBP_\n        );\n\n        /// If the target rebalance amount exceeds the liability itself, the user is undercollateralized\n        if (targetStethSharesToRebalance > stethSharesLiability) {\n            targetStethSharesToRebalance = stethSharesLiability;\n            isUndercollateralized = true;\n        }\n\n        /// Limit rebalance to available assets\n        ///\n        /// First, the rebalancing will use exceeding minted steth shares, bringing the vault closer to minted steth == liability,\n        /// then the rebalancing mechanism on the vault, which is limited by available balance in the staking vault\n        stethShares = totalExceedingMintedStethShares() + _getSharesByPooledEth(VAULT.availableBalance());\n        stethShares = Math.min(targetStethSharesToRebalance, stethShares);\n\n        uint256 stethToRebalance = _getPooledEthBySharesRoundUp(stethShares);\n        uint256 stvRequired = _convertToStv(stethToRebalance, Math.Rounding.Ceil);\n\n        stv = Math.min(stvRequired, stvBalance);\n        isUndercollateralized = isUndercollateralized || stvRequired > stvBalance;\n    }\n\n    /**\n     * @notice Check if the user's minted stETH shares are healthy (not breaching the threshold)\n     * @param _account The address of the account to check\n     * @return isHealthy True if the account is healthy, false if the forced rebalance threshold is breached\n     */\n    function isHealthyOf(address _account) external view returns (bool isHealthy) {\n        isHealthy = !_isThresholdBreached(assetsOf(_account), mintedStethSharesOf(_account));\n    }\n\n    /**\n     * @notice Reduce user's stETH shares liability by burning stv when exceeding minted stETH exists\n     * @param _stethShares The amount of stETH shares liability to reduce (18 decimals)\n     * @return stvBurned The amount of stv burned (27 decimals)\n     * @dev Requires fresh oracle report to price stv accurately\n     * @dev When totalMintedStethShares > totalLiabilityShares (exceeding shares exist), users can voluntarily\n     * rebalance their liability directly against their stv within the exceeding amount\n     *\n     * @dev WARNING: Front-running risk. Exceeding shares are a shared pool-wide limit. Multiple users\n     * competing for limited exceeding shares may have transactions revert with `InsufficientExceedingShares`.\n     * This is accepted: scenario is rare (requires vault liability < pool minted shares), no value extraction,\n     * and worst case is transaction revert with option to retry with smaller amount.\n     */\n    function rebalanceExceedingMintedStethShares(uint256 _stethShares) external returns (uint256 stvBurned) {\n        _checkFreshReport();\n\n        if (_stethShares == 0) revert ZeroArgument();\n        if (_stethShares > mintedStethSharesOf(msg.sender)) revert InsufficientMintedShares();\n        if (_stethShares > totalExceedingMintedStethShares()) revert InsufficientExceedingShares();\n\n        uint256 stethToRebalance = _getPooledEthBySharesRoundUp(_stethShares);\n        stvBurned = _convertToStv(stethToRebalance, Math.Rounding.Ceil);\n\n        _decreaseMintedStethShares(msg.sender, _stethShares);\n        _burnUnsafe(msg.sender, stvBurned);\n\n        emit StethSharesRebalanced(msg.sender, _stethShares, stvBurned);\n    }\n\n    /**\n     * @dev Requires fresh oracle report to price stv accurately\n     */\n    function _rebalanceMintedStethShares(address _account, uint256 _stethShares, uint256 _maxStvToBurn)\n        internal\n        returns (uint256 stvToBurn)\n    {\n        _checkNoUnassignedLiability();\n        _checkNoBadDebt();\n\n        if (_stethShares == 0) revert ZeroArgument();\n        if (_stethShares > mintedStethSharesOf(_account)) revert InsufficientMintedShares();\n\n        uint256 exceedingStethShares = totalExceedingMintedStethShares();\n        uint256 remainingStethShares = Math.saturatingSub(_stethShares, exceedingStethShares);\n        uint256 ethToRebalance = _getPooledEthBySharesRoundUp(_stethShares);\n        uint256 ethForMaxStvToBurn = _convertToAssets(_maxStvToBurn);\n        stvToBurn = _convertToStv(ethToRebalance, Math.Rounding.Ceil);\n\n        if (remainingStethShares > 0) DASHBOARD.rebalanceVaultWithShares(remainingStethShares);\n\n        if (stvToBurn > _maxStvToBurn) {\n            _checkAllowedLossSocializationPortion(stvToBurn, _maxStvToBurn);\n\n            emit SocializedLoss(\n                stvToBurn - _maxStvToBurn,\n                ethToRebalance - ethForMaxStvToBurn,\n                _getStvStETHPoolStorage().maxLossSocializationBP\n            );\n            stvToBurn = _maxStvToBurn;\n        }\n\n        _decreaseMintedStethShares(_account, _stethShares);\n        _burnUnsafe(_account, stvToBurn);\n\n        emit StethSharesRebalanced(_account, _stethShares, stvToBurn);\n    }\n\n    function _isThresholdBreached(uint256 _assets, uint256 _stethShares) internal view returns (bool isBreached) {\n        if (_stethShares == 0) return false;\n\n        uint256 assetsThreshold = Math.mulDiv(\n            _getPooledEthBySharesRoundUp(_stethShares),\n            TOTAL_BASIS_POINTS,\n            TOTAL_BASIS_POINTS - poolForcedRebalanceThresholdBP(),\n            Math.Rounding.Ceil\n        );\n\n        isBreached = _assets < assetsThreshold;\n    }\n\n    function _checkAllowedLossSocializationPortion(uint256 stvRequired, uint256 stvAvailable) internal view {\n        // It's guaranteed that stvRequired > stvAvailable here\n        uint256 portionToSocializeBP =\n            Math.mulDiv(stvRequired - stvAvailable, TOTAL_BASIS_POINTS, stvRequired, Math.Rounding.Ceil);\n\n        if (portionToSocializeBP > _getStvStETHPoolStorage().maxLossSocializationBP) {\n            revert ExcessiveLossSocialization();\n        }\n    }\n\n    // =================================================================================\n    // LOSS SOCIALIZATION LIMITER\n    // =================================================================================\n\n    // During rebalancing, it's possible that the stv available for burning is not sufficient to cover the entire liability.\n    // This may be due to a sharp drop in the stv price, which has resulted in an individual account or a request in Withdrawal Queue\n    // no longer being collateralized (assets < liability).\n    //\n    // The limiter on loss socialization is introduced to prevent excessive losses from being socialized to all pool participants.\n    // The limiter is defined as a maximum portion of the loss that can be socialized, expressed in basis points (BP).\n    //\n    // The default value is set to 0 BP, meaning that no loss socialization is allowed without explicit permission.\n\n    /**\n     * @notice Maximum allowed loss socialization in basis points\n     * @return maxSocializablePortionBP The maximum allowed portion of loss to be socialized in basis points\n     * @dev Used to limit the portion of loss that can be socialized to all pool participants during rebalance\n     */\n    function maxLossSocializationBP() external view returns (uint256 maxSocializablePortionBP) {\n        maxSocializablePortionBP = uint256(_getStvStETHPoolStorage().maxLossSocializationBP);\n    }\n\n    /**\n     * @notice Set the maximum allowed loss socialization in basis points\n     * @param _maxSocializablePortionBP The new maximum allowed loss socialization in basis points\n     * @dev Sets the maximum portion of loss that can be socialized to all pool participants during rebalance\n     * @dev Can only be called by accounts with the DEFAULT_ADMIN_ROLE\n     */\n    function setMaxLossSocializationBP(uint16 _maxSocializablePortionBP) external {\n        _checkRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        if (_maxSocializablePortionBP > TOTAL_BASIS_POINTS) revert InvalidValue();\n\n        StvStETHPoolStorage storage $ = _getStvStETHPoolStorage();\n        if (_maxSocializablePortionBP == $.maxLossSocializationBP) revert SameValue();\n        $.maxLossSocializationBP = _maxSocializablePortionBP;\n\n        emit MaxLossSocializationUpdated(_maxSocializablePortionBP);\n    }\n\n    // =================================================================================\n    // TRANSFER WITH LIABILITY\n    // =================================================================================\n\n    /**\n     * @notice Transfer stv along with stETH shares liability\n     * @param _to The address to transfer to\n     * @param _stv The amount of stv to transfer\n     * @param _stethShares The amount of stETH shares liability to transfer\n     * @return success True if the transfer was successful\n     * @dev Ensures that the transferred stv covers the minimum required to lock for the transferred stETH shares liability\n     * @dev Requires fresh oracle report to price stv accurately\n     */\n    function transferWithLiability(address _to, uint256 _stv, uint256 _stethShares) external returns (bool success) {\n        if (_to == address(WITHDRAWAL_QUEUE)) revert CannotTransferLiabilityToWithdrawalQueue();\n        _checkFreshReport();\n\n        _transferWithLiability(msg.sender, _to, _stv, _stethShares);\n        success = true;\n    }\n\n    function _transferWithLiability(address _from, address _to, uint256 _stv, uint256 _stethShares) internal {\n        _checkMinStvToLock(_stv, _stethShares);\n\n        _transferStethSharesLiability(_from, _to, _stethShares);\n        _transfer(_from, _to, _stv);\n    }\n\n    // =================================================================================\n    // ERC20 OVERRIDES\n    // =================================================================================\n\n    /**\n     * @dev Overridden method from ERC20 to include reserve ratio check\n     * @dev Ensures that after any transfer, the sender still has enough reserved balance for their minted stETH shares\n     */\n    function _update(address _from, address _to, uint256 _value) internal override {\n        super._update(_from, _to, _value);\n\n        uint256 mintedStethShares = mintedStethSharesOf(_from);\n        if (mintedStethShares == 0) return;\n\n        uint256 stvToLock = calcStvToLockForStethShares(mintedStethShares);\n\n        if (balanceOf(_from) < stvToLock) revert InsufficientReservedBalance();\n    }\n\n    // =================================================================================\n    // PAUSE / RESUME MINTING\n    // =================================================================================\n\n    /**\n     * @notice Pause (w)stETH minting\n     * @dev Can only be called by accounts with the MINTING_PAUSE_ROLE\n     */\n    function pauseMinting() external {\n        _checkRole(MINTING_PAUSE_ROLE, msg.sender);\n        _pauseFeature(MINTING_FEATURE);\n    }\n\n    /**\n     * @notice Resume (w)stETH minting\n     * @dev Can only be called by accounts with the MINTING_RESUME_ROLE\n     */\n    function resumeMinting() external {\n        _checkRole(MINTING_RESUME_ROLE, msg.sender);\n        _resumeFeature(MINTING_FEATURE);\n    }\n}\n"
    }
}