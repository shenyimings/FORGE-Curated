{
    "vfp_id": "vfp_00243",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Allowance Timestamp Can Be Reset",
            "description": "The PriceFeedStore.allowPriceFeed function does not revert if the price feed is already allowed, allowing repeated calls to reset the allowanceTimestamp.\nCause: Missing validation to prevent re-allowing an already allowed price feed.\nExploitation: An admin could repeatedly call the function to reset the timestamp, potentially extending the validity period of a price feed unintentionally.\nImpact: This could lead to prolonged use of a price feed beyond its intended validity window, increasing risk if the feed becomes unreliable or compromised.\n",
            "severity": "Low",
            "location": [
                "PriceFeedStore::allowPriceFeed"
            ],
            "files": [
                "permissionless/contracts/instance/PriceFeedStore.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Pending Owners",
            "description": "The PriceFeedStore._validatePriceFeedDeployment function requires accepting ownership from a pending owner, but the price feed cannot be validated unless it is already known, creating a circular dependency.\nCause: The validation and ownership acceptance processes are mutually dependent.\nExploitation: A legitimate price feed cannot be onboarded because it cannot pass validation until it is known, but it cannot be known until it passes validation.\nImpact: New price feeds cannot be added, blocking protocol expansion or updates to oracle systems.\n",
            "severity": "Low",
            "location": [
                "PriceFeedStore::_validatePriceFeedDeployment"
            ],
            "files": [
                "permissionless/contracts/instance/PriceFeedStore.sol"
            ]
        }
    ],
    "affected_files": {
        "PriceFeedStore.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {SanityCheckTrait} from \"@gearbox-protocol/core-v3/contracts/traits/SanityCheckTrait.sol\";\nimport {PriceFeedValidationTrait} from \"@gearbox-protocol/core-v3/contracts/traits/PriceFeedValidationTrait.sol\";\nimport {IPriceFeed} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IPriceFeed.sol\";\n\nimport {IPriceFeedStore} from \"../interfaces/IPriceFeedStore.sol\";\nimport {AP_PRICE_FEED_STORE, AP_INSTANCE_MANAGER_PROXY, NO_VERSION_CONTROL} from \"../libraries/ContractLiterals.sol\";\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {PriceFeedInfo} from \"../interfaces/Types.sol\";\nimport {ImmutableOwnableTrait} from \"../traits/ImmutableOwnableTrait.sol\";\n\ncontract PriceFeedStore is ImmutableOwnableTrait, SanityCheckTrait, PriceFeedValidationTrait, IPriceFeedStore {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    //\n    // CONSTANTS\n    //\n\n    /// @notice Meta info about contract type & version\n    uint256 public constant override version = 3_10;\n    bytes32 public constant override contractType = AP_PRICE_FEED_STORE;\n\n    //\n    // VARIABLES\n    //\n\n    /// @dev Set of all known price feeds\n    EnumerableSet.AddressSet internal _knownPriceFeeds;\n\n    /// @dev Set of all known price feeds\n    EnumerableSet.AddressSet internal _knownTokens;\n\n    /// @dev Mapping from token address to its set of allowed price feeds\n    mapping(address token => EnumerableSet.AddressSet) internal _allowedPriceFeeds;\n\n    /// @dev Mapping from a (token, priceFeed) pair to a timestamp when price feed was allowed for token\n    mapping(address token => mapping(address priceFeed => uint256)) _allowanceTimestamps;\n\n    /// @notice Mapping from price feed address to its data\n    mapping(address => PriceFeedInfo) internal _priceFeedInfo;\n\n    constructor(address _addressProvider)\n        ImmutableOwnableTrait(\n            IAddressProvider(_addressProvider).getAddressOrRevert(AP_INSTANCE_MANAGER_PROXY, NO_VERSION_CONTROL)\n        )\n    {}\n\n    /// @notice Returns the list of price feeds available for a token\n    function getPriceFeeds(address token) external view returns (address[] memory) {\n        return _allowedPriceFeeds[token].values();\n    }\n\n    /// @notice Returns whether a price feed is allowed to be used for a token\n    function isAllowedPriceFeed(address token, address priceFeed) external view returns (bool) {\n        return _allowedPriceFeeds[token].contains(priceFeed);\n    }\n\n    /// @notice Returns the staleness period for a price feed\n    function getStalenessPeriod(address priceFeed) external view returns (uint32) {\n        return _priceFeedInfo[priceFeed].stalenessPeriod;\n    }\n\n    /// @notice Returns the timestamp when priceFeed was allowed for token\n    function getAllowanceTimestamp(address token, address priceFeed) external view returns (uint256) {\n        if (!_allowedPriceFeeds[token].contains(priceFeed)) revert PriceFeedIsNotAllowedException(token, priceFeed);\n        return _allowanceTimestamps[token][priceFeed];\n    }\n\n    function getKnownTokens() external view returns (address[] memory) {\n        return _knownTokens.values();\n    }\n\n    function getKnownPriceFeeds() external view returns (address[] memory) {\n        return _knownPriceFeeds.values();\n    }\n\n    /**\n     * @notice Adds a new price feed\n     * @param priceFeed The address of the new price feed\n     * @param stalenessPeriod Staleness period of the new price feed\n     * @dev Reverts if the price feed's result is stale based on the staleness period\n     */\n    function addPriceFeed(address priceFeed, uint32 stalenessPeriod) external onlyOwner nonZeroAddress(priceFeed) {\n        if (_knownPriceFeeds.contains(priceFeed)) revert PriceFeedAlreadyAddedException(priceFeed);\n\n        _validatePriceFeed(priceFeed, stalenessPeriod);\n\n        bytes32 priceFeedType;\n        uint256 priceFeedVersion;\n\n        try IPriceFeed(priceFeed).contractType() returns (bytes32 _cType) {\n            priceFeedType = _cType;\n            priceFeedVersion = IPriceFeed(priceFeed).version();\n        } catch {\n            priceFeedType = \"PRICE_FEED::EXTERNAL\";\n            priceFeedVersion = 0;\n        }\n\n        _knownPriceFeeds.add(priceFeed);\n        _priceFeedInfo[priceFeed].author = msg.sender;\n        _priceFeedInfo[priceFeed].priceFeedType = priceFeedType;\n        _priceFeedInfo[priceFeed].stalenessPeriod = stalenessPeriod;\n        _priceFeedInfo[priceFeed].version = priceFeedVersion;\n\n        emit AddPriceFeed(priceFeed, stalenessPeriod);\n    }\n\n    /**\n     * @notice Sets the staleness period for an existing price feed\n     * @param priceFeed The address of the price feed\n     * @param stalenessPeriod New staleness period for the price feed\n     * @dev Reverts if the price feed is not added to the global list\n     */\n    function setStalenessPeriod(address priceFeed, uint32 stalenessPeriod)\n        external\n        onlyOwner\n        nonZeroAddress(priceFeed)\n    {\n        if (!_knownPriceFeeds.contains(priceFeed)) revert PriceFeedNotKnownException(priceFeed);\n        uint32 oldStalenessPeriod = _priceFeedInfo[priceFeed].stalenessPeriod;\n\n        if (stalenessPeriod != oldStalenessPeriod) {\n            _validatePriceFeed(priceFeed, stalenessPeriod);\n            _priceFeedInfo[priceFeed].stalenessPeriod = stalenessPeriod;\n            emit SetStalenessPeriod(priceFeed, stalenessPeriod);\n        }\n    }\n\n    /**\n     * @notice Allows a price feed for use with a particular token\n     * @param token Address of the token\n     * @param priceFeed Address of the price feed\n     * @dev Reverts if the price feed is not added to the global list\n     */\n    function allowPriceFeed(address token, address priceFeed) external onlyOwner nonZeroAddress(token) {\n        if (!_knownPriceFeeds.contains(priceFeed)) revert PriceFeedNotKnownException(priceFeed);\n\n        _allowedPriceFeeds[token].add(priceFeed);\n        _allowanceTimestamps[token][priceFeed] = block.timestamp;\n        _knownTokens.add(token);\n\n        emit AllowPriceFeed(token, priceFeed);\n    }\n\n    /**\n     * @notice Forbids a price feed for use with a particular token\n     * @param token Address of the token\n     * @param priceFeed Address of the price feed\n     * @dev Reverts if the price feed is not added to the global list or the per-token list\n     */\n    function forbidPriceFeed(address token, address priceFeed) external onlyOwner nonZeroAddress(token) {\n        if (!_knownPriceFeeds.contains(priceFeed)) revert PriceFeedNotKnownException(priceFeed);\n        if (!_allowedPriceFeeds[token].contains(priceFeed)) revert PriceFeedIsNotAllowedException(token, priceFeed);\n\n        _allowedPriceFeeds[token].remove(priceFeed);\n        _allowanceTimestamps[token][priceFeed] = 0;\n\n        emit ForbidPriceFeed(token, priceFeed);\n    }\n\n    function priceFeedInfo(address priceFeed) external view returns (PriceFeedInfo memory) {\n        return _priceFeedInfo[priceFeed];\n    }\n}\n"
    }
}