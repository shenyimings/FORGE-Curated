{
    "vfp_id": "vfp_00174",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "No Fallback Recipient in Forced Withdrawal",
            "description": "The `forcedWithdrawal` function allows a user to withdraw locked funds to a specified `recipient`, but does not replace a zero address with `msg.sender`, unlike the deposit functions which use `usingCallerIfNull` for this purpose.\nThe root cause is inconsistent handling of zero addresses across deposit and withdrawal logic, creating a usability gap in the forced withdrawal path.\nA user who accidentally sets the recipient to zero or omits it will cause the funds to be sent to the zero address, resulting in permanent loss.\nThe impact is accidental fund loss due to lack of input normalization, reducing user safety and increasing risk during recovery procedures.\n",
            "severity": "Low",
            "location": [
                "TheCompact.sol::forcedWithdrawal#236",
                "DirectDepositLogic.sol#54",
                "DirectDepositLogic.sol#158",
                "DirectDepositLogic.sol#186",
                "EfficiencyLib.sol::usingCallerIfNull#24",
                "WithdrawalLogic.sol#112"
            ],
            "files": [
                "the-compact/src/TheCompact.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Native Token Deposit Not Bounded in `batchDeposit*ViaPermit2`",
            "description": "The `batchDepositViaPermit2` and `batchDepositAndRegisterViaPermit2` functions accept a native token deposit via `msg.value`, but this amount is not included in the sponsor-signed data. This allows an observer to frontrun the transaction with a lower or zero value.\nThe cause is the separation of signature validation from value validation, enabling reuse of the permit nonce without enforcing the expected native amount.\nAn attacker can copy the transaction, reduce `msg.value`, and broadcast it first, consuming the nonce and causing the original transaction to revert. The relayer must then refund or re-execute, incurring gas costs and operational overhead.\nThe impact includes transaction frontrunning, denial of service for legitimate deposits, and increased operational burden on relayers, though funds are not directly lost.\n",
            "severity": "Low",
            "location": [
                "TheCompact.sol::batchDepositViaPermit2#57",
                "TheCompact.sol::batchDepositAndRegisterViaPermit2#214"
            ],
            "files": [
                "the-compact/src/TheCompact.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1120"
                ]
            },
            "title": "Code Simplifications",
            "description": "Several opportunities for code simplification were identified, such as removing redundant function calls (`hasConsumedAllocatorNonce` going through unused intermediaries), inlining one-time-use functions like `_revertWithInvalidBatchAllocationIfError`, merging duplicate `_validateAllocator` functions, and eliminating redundant abstractions like `toRegisteredAllocatorWithConsumed`. These inefficiencies arise from over-engineering or incomplete refactoring. The resulting code has unnecessary complexity, longer call paths, and increased gas overhead. The impact includes higher maintenance burden, reduced readability, and slightly increased execution cost.\n",
            "severity": "Low",
            "location": [
                "TheCompact.sol::hasConsumedAllocatorNonce#299",
                "ConsumerLib.sol::isConsumedByAllocator#33",
                "AllocatorLogic.sol::_hasConsumedAllocatorNonce#90",
                "ValidityLib.sol::hasConsumedAllocatorNonce#188",
                "ClaimHashLib.sol::toMessageHashes#74",
                "ClaimHashLib.sol::toMessageHashes#92",
                "ComponentLib.sol::_revertWithInvalidBatchAllocationIfError#361",
                "ComponentLib.sol::_buildIdsAndAmounts#255",
                "ClaimProcessorLib.sol::_validateAllocator#122",
                "ClaimProcessorLib.sol::_validateAllocator#135",
                "ValidityLib.sol::toRegisteredAllocatorWithConsumed#63-L66",
                "ValidityLib.sol::fromRegisteredAllocatorIdWithConsumed#48-L54"
            ],
            "files": [
                "the-compact/src/TheCompact.sol"
            ]
        }
    ],
    "affected_files": {
        "TheCompact.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ITheCompact } from \"./interfaces/ITheCompact.sol\";\n\nimport { AllocatedBatchTransfer } from \"./types/BatchClaims.sol\";\nimport { AllocatedTransfer } from \"./types/Claims.sol\";\nimport { CompactCategory } from \"./types/CompactCategory.sol\";\nimport { Lock } from \"./types/Lock.sol\";\nimport { Scope } from \"./types/Scope.sol\";\nimport { ResetPeriod } from \"./types/ResetPeriod.sol\";\nimport { ForcedWithdrawalStatus } from \"./types/ForcedWithdrawalStatus.sol\";\nimport { EmissaryStatus } from \"./types/EmissaryStatus.sol\";\nimport { DepositDetails } from \"./types/DepositDetails.sol\";\n\nimport { ERC6909 } from \"solady/tokens/ERC6909.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nimport { TheCompactLogic } from \"./lib/TheCompactLogic.sol\";\n\n/**\n * @title The Compact\n * @custom:version 1\n * @author 0age (0age.eth)\n * @notice The Compact is an ownerless ERC6909 contract that facilitates the voluntary\n *         formation and mediation of reusable \"resource locks.\"\n *         This contract has not yet been properly tested, audited, or reviewed.\n */\ncontract TheCompact is ITheCompact, ERC6909, TheCompactLogic {\n    function depositNative(bytes12 lockTag, address recipient) external payable returns (uint256) {\n        return _performCustomNativeTokenDeposit(lockTag, recipient);\n    }\n\n    function depositERC20(address token, bytes12 lockTag, uint256 amount, address recipient)\n        external\n        returns (uint256 id)\n    {\n        (id,) = _performCustomERC20Deposit(token, lockTag, amount, recipient);\n    }\n\n    function batchDeposit(uint256[2][] calldata idsAndAmounts, address recipient) external payable returns (bool) {\n        _processBatchDeposit(idsAndAmounts, recipient, false);\n\n        return true;\n    }\n\n    function depositERC20ViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address, // depositor\n        bytes12, // lockTag\n        address recipient,\n        bytes calldata signature\n    ) external returns (uint256) {\n        return _depositViaPermit2(permit.permitted.token, recipient, signature);\n    }\n\n    function batchDepositViaPermit2(\n        address, // depositor\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata,\n        address recipient,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory) {\n        return _depositBatchViaPermit2(permitted, recipient, signature);\n    }\n\n    function allocatedTransfer(AllocatedTransfer calldata transfer) external returns (bool) {\n        return _processTransfer(transfer);\n    }\n\n    function allocatedBatchTransfer(AllocatedBatchTransfer calldata transfer) external returns (bool) {\n        return _processBatchTransfer(transfer);\n    }\n\n    function register(bytes32 claimHash, bytes32 typehash) external returns (bool) {\n        _register(msg.sender, claimHash, typehash);\n\n        return true;\n    }\n\n    function registerMultiple(bytes32[2][] calldata claimHashesAndTypehashes) external returns (bool) {\n        return _registerBatch(claimHashesAndTypehashes);\n    }\n\n    function registerFor(\n        bytes32 typehash,\n        address, // arbiter\n        address sponsor,\n        uint256, // nonce\n        uint256, // expires\n        uint256, // id\n        uint256, // amount\n        bytes32, // witness\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash) {\n        return _registerFor(sponsor, typehash, sponsorSignature);\n    }\n\n    function registerBatchFor(\n        bytes32 typehash,\n        address, // arbiter\n        address sponsor,\n        uint256, // nonce\n        uint256, // expires\n        bytes32, // idsAndAmountsHash\n        bytes32, // witness\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash) {\n        return _registerBatchFor(sponsor, typehash, sponsorSignature);\n    }\n\n    function registerMultichainFor(\n        bytes32 typehash,\n        address sponsor,\n        uint256, // nonce,\n        uint256, // expires,\n        bytes32, // elementsHash,\n        uint256 notarizedChainId,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash) {\n        return _registerMultichainFor(sponsor, typehash, notarizedChainId, sponsorSignature);\n    }\n\n    function depositNativeAndRegister(bytes12 lockTag, bytes32 claimHash, bytes32 typehash)\n        external\n        payable\n        returns (uint256 id)\n    {\n        id = _performCustomNativeTokenDeposit(lockTag, msg.sender);\n\n        _register(msg.sender, claimHash, typehash);\n    }\n\n    function depositNativeAndRegisterFor(\n        address recipient,\n        bytes12 lockTag,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (uint256 id, bytes32 claimHash) {\n        id = _performCustomNativeTokenDeposit(lockTag, recipient);\n\n        claimHash = _registerUsingClaimWithWitness(recipient, id, msg.value, arbiter, nonce, expires, typehash, witness);\n    }\n\n    function depositERC20AndRegister(\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        bytes32 claimHash,\n        bytes32 typehash\n    ) external returns (uint256 id) {\n        (id,) = _performCustomERC20Deposit(token, lockTag, amount, msg.sender);\n\n        _register(msg.sender, claimHash, typehash);\n    }\n\n    function depositERC20AndRegisterFor(\n        address recipient,\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external returns (uint256 id, bytes32 claimHash, uint256 registeredAmount) {\n        (id, registeredAmount) = _performCustomERC20Deposit(token, lockTag, amount, recipient);\n\n        claimHash =\n            _registerUsingClaimWithWitness(recipient, id, registeredAmount, arbiter, nonce, expires, typehash, witness);\n    }\n\n    function batchDepositAndRegisterMultiple(\n        uint256[2][] calldata idsAndAmounts,\n        bytes32[2][] calldata claimHashesAndTypehashes\n    ) external payable returns (bool) {\n        _processBatchDeposit(idsAndAmounts, msg.sender, false);\n\n        return _registerBatch(claimHashesAndTypehashes);\n    }\n\n    function batchDepositAndRegisterFor(\n        address recipient,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (bytes32 claimHash, uint256[] memory registeredAmounts) {\n        registeredAmounts = _processBatchDeposit(idsAndAmounts, recipient, true);\n\n        claimHash = _registerUsingBatchClaimWithWitness(\n            recipient, idsAndAmounts, arbiter, nonce, expires, typehash, witness, registeredAmounts\n        );\n    }\n\n    function depositERC20AndRegisterViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address depositor, // also recipient\n        bytes12, // lockTag\n        bytes32 claimHash,\n        CompactCategory, // compactCategory\n        string calldata witness,\n        bytes calldata signature\n    ) external returns (uint256) {\n        return _depositAndRegisterViaPermit2(permit.permitted.token, depositor, claimHash, witness, signature);\n    }\n\n    function batchDepositAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata,\n        bytes32, // claimHash\n        CompactCategory, // compactCategory\n        string calldata witness,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory) {\n        return _depositBatchAndRegisterViaPermit2(depositor, permitted, witness, signature);\n    }\n\n    function enableForcedWithdrawal(uint256 id) external returns (uint256) {\n        return _enableForcedWithdrawal(id);\n    }\n\n    function disableForcedWithdrawal(uint256 id) external returns (bool) {\n        _disableForcedWithdrawal(id);\n\n        return true;\n    }\n\n    function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool) {\n        _processForcedWithdrawal(id, recipient, amount);\n\n        return true;\n    }\n\n    function assignEmissary(bytes12 lockTag, address emissary) external returns (bool) {\n        return _assignEmissary(lockTag, emissary);\n    }\n\n    function scheduleEmissaryAssignment(bytes12 lockTag) external returns (uint256 emissaryAssignmentAvailableAt) {\n        return _scheduleEmissaryAssignment(lockTag);\n    }\n\n    function consume(uint256[] calldata nonces) external returns (bool) {\n        return _consume(nonces);\n    }\n\n    function __registerAllocator(address allocator, bytes calldata proof) external returns (uint96) {\n        return _registerAllocator(allocator, proof);\n    }\n\n    function __benchmark(bytes32 salt) external payable {\n        _benchmark(salt);\n    }\n\n    function getRequiredWithdrawalFallbackStipends()\n        external\n        view\n        returns (uint256 nativeTokenStipend, uint256 erc20TokenStipend)\n    {\n        return _getRequiredWithdrawalFallbackStipends();\n    }\n\n    function getForcedWithdrawalStatus(address account, uint256 id)\n        external\n        view\n        returns (ForcedWithdrawalStatus, uint256)\n    {\n        return _getForcedWithdrawalStatus(account, id);\n    }\n\n    function getRegistrationStatus(address sponsor, bytes32 claimHash, bytes32 typehash)\n        external\n        view\n        returns (bool isActive, uint256 registrationTimestamp)\n    {\n        registrationTimestamp = _getRegistrationStatus(sponsor, claimHash, typehash);\n        isActive = registrationTimestamp != 0;\n    }\n\n    function getEmissaryStatus(address sponsor, bytes12 lockTag)\n        external\n        view\n        returns (EmissaryStatus status, uint256 emissaryAssignmentAvailableAt, address currentEmissary)\n    {\n        return _getEmissaryStatus(sponsor, lockTag);\n    }\n\n    function getLockDetails(uint256 id) external view returns (address, address, ResetPeriod, Scope, bytes12) {\n        return _getLockDetails(id);\n    }\n\n    function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool) {\n        return _hasConsumedAllocatorNonce(nonce, allocator);\n    }\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    /**\n     * @notice Returns the name for token `id`.\n     * @param id The ERC6909 token identifier to get the name for.\n     * @return The name of the token.\n     */\n    function name(uint256 id) public view virtual override returns (string memory) {\n        return _name(id);\n    }\n\n    /**\n     * @notice Returns the symbol for token `id`.\n     * @param id The ERC6909 token identifier to get the symbol for.\n     * @return The symbol of the token.\n     */\n    function symbol(uint256 id) public view virtual override returns (string memory) {\n        return _symbol(id);\n    }\n\n    /**\n     * @notice Returns the decimals for token `id`.\n     * @param id The ERC6909 token identifier to get the decimals for.\n     * @return The decimals of the token.\n     */\n    function decimals(uint256 id) public view virtual override returns (uint8) {\n        return _decimals(id);\n    }\n\n    /**\n     * @notice Returns the ERC6909 Uniform Resource Identifier (URI) for token `id`.\n     * @param id The ERC6909 token identifier to get the URI for.\n     * @return The URI of the token.\n     */\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\n        return _tokenURI(id);\n    }\n\n    /**\n     * @notice External pure function for returning the name of the contract.\n     * @return A string representing the name of the contract.\n     */\n    function name() external pure returns (string memory) {\n        // Return the name of the contract.\n        assembly (\"memory-safe\") {\n            mstore(0x20, 0x20)\n            mstore(0x4b, 0x0b54686520436f6d70616374)\n            return(0x20, 0x60)\n        }\n    }\n\n    /**\n     * @notice Hook that is called before any standard ERC6909 token transfer. Note that this hook\n     *         is not called when performing allocated transfers or when processing claims, nor are\n     *         standard token approvals required.\n     * @param from   The address tokens are transferred from.\n     * @param to     The address tokens are transferred to.\n     * @param id     The ERC6909 token identifier.\n     * @param amount The amount of tokens being transferred.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 id, uint256 amount) internal virtual override {\n        _ensureAttested(from, to, id, amount);\n    }\n}\n"
    }
}