{
    "vfp_id": "vfp_00029",
    "project_name": "2025.03.10 - Final - Symmio, Staking and Vesting Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "USDC rewards will not be distributed if _updateRewardsStates is triggered too often",
            "description": "The vulnerability arises in the SymmStaking contract where frequent calls to _updateRewardsStates (via deposit, withdraw, claim, or notifyRewardAmount) can prevent proper distribution of rewards for tokens with low decimals like USDC. The root cause is the lack of upscaling in reward calculations, which leads to integer division rounding down to zero when the reward rate per block is small relative to the total staked supply. An attacker or griefer can exploit this by calling deposit or other triggering functions every few blocks, causing perTokenStored to remain unchanged due to rounding, while lastUpdated still advances. As a result, stakers receive no rewards despite rewards being available in the contract, leading to a high-impact scenario where user incentives are undermined and rewards become stuck.\n",
            "severity": "High",
            "location": [
                "SymmStaking.sol::updateRewardsStates#402-423",
                "SymmStaking.sol#374",
                "SymmStaking.sol#194-202",
                "SymmStaking.sol#412",
                "SymmStaking.sol#413"
            ],
            "files": [
                "token/contracts/staking/SymmStaking.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ]
            },
            "title": "Readding the reward token causes user-RewardPerTokenPaid to be incorrect for some users, resulting in them receiving too many rewards",
            "description": "When a reward token is removed and later re-added in the SymmStaking contract, the stored `perTokenStored` value persists, but new users who deposit during the removal period do not have their `userRewardPerTokenPaid` updated for that token. Upon re-addition and new reward notifications, these users receive rewards accumulated from before their deposit, effectively stealing rewards from existing stakers. The root cause is the failure to reset or reinitialize reward state when a token is re-added, combined with the lack of checks to update historical reward data for new users. This leads to unfair distribution, potential reward pool exhaustion, and possible reversion of the `claimRewards` function for legitimate users due to insufficient balance, severely disrupting staking operations.\n",
            "severity": "Medium",
            "location": [
                "SymmStaking.sol#319-328",
                "SymmStaking.sol#406-418"
            ],
            "files": [
                "token/contracts/staking/SymmStaking.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Malicious User can dilute staking Rewards to a longer timeframe",
            "description": "The SymmStaking contract allows any user to call the notifyRewardAmount function, which recalculates the reward rate for stakers. The root cause is the lack of access control on this function, enabling malicious actors to repeatedly deposit negligible reward amounts (e.g., 1 wei). When the previous reward period is still active, the new amount is added to the leftover rewards and divided by the fixed duration, thereby reducing the per-block reward rate. An attacker can exploit this by spamming tiny reward deposits, which progressively dilute the reward distribution rate. This results in stakers receiving their entitled rewards over a significantly extended timeframe, effectively creating a denial-of-service condition on reward distribution.\n",
            "severity": "Medium",
            "location": [
                "SymmStaking.sol::notifyRewardAmount"
            ],
            "files": [
                "token/contracts/staking/SymmStaking.sol"
            ]
        }
    ],
    "affected_files": {
        "SymmStaking.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.18;\n\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title SymmStaking\n * @notice An upgradeable staking contract that supports multiple reward tokens.\n * @dev This contract is designed to be used with the Transparent Upgradeable Proxy pattern.\n */\ncontract SymmStaking is Initializable, AccessControlEnumerableUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\n\tusing SafeERC20 for IERC20;\n\n\t//--------------------------------------------------------------------------\n\t// Constants\n\t//--------------------------------------------------------------------------\n\n\tuint256 public constant DEFAULT_REWARDS_DURATION = 1 weeks;\n\n\tbytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n\tbytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\tbytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n\t//--------------------------------------------------------------------------\n\t// Errors\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Thrown when the staked or withdrawn amount is zero.\n\terror ZeroAmount();\n\n\t/// @notice Thrown when the staked for zero address.\n\terror ZeroAddress();\n\n\t/// @notice Thrown when the user does not have enough staked balance.\n\t/// @param available The available staked balance.\n\t/// @param required The required amount.\n\terror InsufficientBalance(uint256 available, uint256 required);\n\n\t/// @notice Thrown when a token is not whitelisted for rewards.\n\t/// @param token The token address.\n\terror TokenNotWhitelisted(address token);\n\n\t/// @notice Thrown when the two arrays passed as parameters have different lengths.\n\terror ArraysMismatched();\n\n\t/// @notice Thrown when there is an already ongoing reward period for this token.\n\t//TODO: params\n\terror OngoingRewardPeriodForToken(address token, uint256 pendingRewards);\n\n\t/// @notice Thrown when the whitelist status is already set.\n\t/// @param token The token address.\n\t/// @param currentStatus The current whitelist status.\n\terror TokenWhitelistStatusUnchanged(address token, bool currentStatus);\n\n\t//--------------------------------------------------------------------------\n\t// Events\n\t//--------------------------------------------------------------------------\n\n\t/**\n\t * @notice Emitted when rewards are added.\n\t * @param rewardsTokens Array of reward token addresses.\n\t * @param rewards Array of reward amounts.\n\t */\n\tevent RewardNotified(address[] rewardsTokens, uint256[] rewards);\n\n\t/**\n\t * @notice Emitted when a deposit is made.\n\t * @param sender The address initiating the deposit.\n\t * @param amount The staked amount.\n\t * @param receiver The address that receives the staking balance.\n\t */\n\tevent Deposit(address indexed sender, uint256 amount, address indexed receiver);\n\n\t/**\n\t * @notice Emitted when a withdrawal is made.\n\t * @param sender The address initiating the withdrawal.\n\t * @param amount The withdrawn amount.\n\t * @param to The address receiving the tokens.\n\t */\n\tevent Withdraw(address indexed sender, uint256 amount, address indexed to);\n\n\t/**\n\t * @notice Emitted when a reward is paid.\n\t * @param user The user receiving the reward.\n\t * @param rewardsToken The token in which the reward is paid.\n\t * @param reward The amount of reward paid.\n\t */\n\tevent RewardClaimed(address indexed user, address indexed rewardsToken, uint256 reward);\n\n\t/**\n\t * @notice Emitted when a token's whitelist status is updated.\n\t * @param token The token address.\n\t * @param whitelist The new whitelist status.\n\t */\n\tevent UpdateWhitelist(address indexed token, bool whitelist);\n\n\t/**\n\t * @notice Emitted when admin rescue tokens.\n\t * @param token the token address.\n\t * @param amount the amount to be rescued.\n\t */\n\tevent RescueToken(address token, uint256 amount, address receiver);\n\n\t//--------------------------------------------------------------------------\n\t// Structs\n\t//--------------------------------------------------------------------------\n\n\tstruct TokenRewardState {\n\t\tuint256 duration;\n\t\tuint256 periodFinish;\n\t\tuint256 rate;\n\t\tuint256 lastUpdated;\n\t\tuint256 perTokenStored;\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// State Variables\n\t//--------------------------------------------------------------------------\n\taddress public stakingToken;\n\n\tuint256 public totalSupply;\n\tmapping(address => uint256) public balanceOf;\n\n\t// Mapping from reward token to reward state.\n\tmapping(address => TokenRewardState) public rewardState;\n\t// Array of reward tokens.\n\taddress[] public rewardTokens;\n\t// Mapping to track if a token is whitelisted for rewards.\n\tmapping(address => bool) public isRewardToken;\n\n\t// Mapping from user => reward token => user paid reward per token.\n\tmapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n\t// Mapping from user => reward token => reward amount.\n\tmapping(address => mapping(address => uint256)) public rewards;\n\n\t// Mapping from reward token to the total pending rewards (i.e. rewards that have been notified but not yet claimed).\n\tmapping(address => uint256) public pendingRewards;\n\n\t//--------------------------------------------------------------------------\n\t// Initialization\n\t//--------------------------------------------------------------------------\n\n\t/**\n\t * @notice Initializes the staking contract.\n\t * @param admin The admin of the contract.\n\t */\n\tfunction initialize(address admin, address _stakingToken) external initializer {\n\t\t__AccessControlEnumerable_init();\n\t\t__ReentrancyGuard_init();\n\t\t__Pausable_init();\n\n\t\tif (admin == address(0) || _stakingToken == address(0)) revert ZeroAddress();\n\n\t\tstakingToken = _stakingToken;\n\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, admin);\n\t\t_grantRole(REWARD_MANAGER_ROLE, admin);\n\t\t_grantRole(PAUSER_ROLE, admin);\n\t\t_grantRole(UNPAUSER_ROLE, admin);\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Views\n\t//--------------------------------------------------------------------------\n\n\t/**\n\t * @notice Returns the number of reward tokens.\n\t * @return The length of the rewardTokens array.\n\t */\n\tfunction rewardTokensCount() external view returns (uint256) {\n\t\treturn rewardTokens.length;\n\t}\n\n\t/**\n\t * @notice Returns the last applicable time for rewards.\n\t * @param _rewardsToken The reward token address.\n\t * @return The last time at which rewards are applicable.\n\t */\n\tfunction lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\n\t\treturn block.timestamp < rewardState[_rewardsToken].periodFinish ? block.timestamp : rewardState[_rewardsToken].periodFinish;\n\t}\n\n\t/**\n\t * @notice Calculates the reward per token for a given reward token.\n\t * @param _rewardsToken The reward token address.\n\t * @return The reward per token.\n\t */\n\tfunction rewardPerToken(address _rewardsToken) public view returns (uint256) {\n\t\tif (totalSupply == 0) {\n\t\t\treturn rewardState[_rewardsToken].perTokenStored;\n\t\t}\n\t\treturn\n\t\t\trewardState[_rewardsToken].perTokenStored +\n\t\t\t(((lastTimeRewardApplicable(_rewardsToken) - rewardState[_rewardsToken].lastUpdated) * rewardState[_rewardsToken].rate * 1e18) /\n\t\t\t\ttotalSupply);\n\t}\n\n\t/**\n\t * @notice Calculates the earned rewards for an account and a specific reward token.\n\t * @param account The user address.\n\t * @param _rewardsToken The reward token address.\n\t * @return The amount of earned rewards.\n\t */\n\tfunction earned(address account, address _rewardsToken) public view returns (uint256) {\n\t\treturn\n\t\t\t((balanceOf[account] * (rewardPerToken(_rewardsToken) - userRewardPerTokenPaid[account][_rewardsToken])) / 1e18) +\n\t\t\trewards[account][_rewardsToken];\n\t}\n\n\t/**\n\t * @notice Returns the reward amount for the entire reward duration.\n\t * @param _rewardsToken The reward token address.\n\t * @return The reward amount for the reward duration.\n\t */\n\tfunction getFullPeriodReward(address _rewardsToken) external view returns (uint256) {\n\t\treturn rewardState[_rewardsToken].rate * rewardState[_rewardsToken].duration;\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Mutative Functions\n\t//--------------------------------------------------------------------------\n\n\t/**\n\t * @notice Deposits SYMM tokens for staking on behalf of a receiver.\n\t * @param amount The amount of SYMM tokens to deposit.\n\t * @param receiver The address receiving the staking balance.\n\t */\n\tfunction deposit(uint256 amount, address receiver) external nonReentrant whenNotPaused {\n\t\t_updateRewardsStates(receiver);\n\n\t\tif (amount == 0) revert ZeroAmount();\n\t\tif (receiver == address(0)) revert ZeroAddress();\n\t\tIERC20(stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n\t\ttotalSupply += amount;\n\t\tbalanceOf[receiver] += amount;\n\t\temit Deposit(msg.sender, amount, receiver);\n\t}\n\n\t/**\n\t * @notice Withdraws staked SYMM tokens.\n\t * @param amount The amount of tokens to withdraw.\n\t * @param to The address receiving the tokens.\n\t */\n\tfunction withdraw(uint256 amount, address to) external nonReentrant whenNotPaused {\n\t\t_updateRewardsStates(msg.sender);\n\n\t\tif (amount == 0) revert ZeroAmount();\n\t\tif (to == address(0)) revert ZeroAddress();\n\t\tif (amount > balanceOf[msg.sender]) revert InsufficientBalance(balanceOf[msg.sender], amount);\n\t\tIERC20(stakingToken).safeTransfer(to, amount);\n\t\ttotalSupply -= amount;\n\t\tbalanceOf[msg.sender] -= amount;\n\t\temit Withdraw(msg.sender, amount, to);\n\t}\n\n\t/**\n\t * @notice Claims all earned rewards for the caller.\n\t */\n\tfunction claimRewards() external nonReentrant whenNotPaused {\n\t\t_updateRewardsStates(msg.sender);\n\t\t_claimRewardsFor(msg.sender);\n\t}\n\n\t/**\n\t * @notice Notifies the contract about new reward amounts.\n\t * @param tokens Array of reward token addresses.\n\t * @param amounts Array of reward amounts corresponding to each token.\n\t */\n\tfunction notifyRewardAmount(address[] calldata tokens, uint256[] calldata amounts) external nonReentrant whenNotPaused {\n\t\t_updateRewardsStates(address(0));\n\t\tif (tokens.length != amounts.length) revert ArraysMismatched();\n\n\t\tuint256 len = tokens.length;\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\taddress token = tokens[i];\n\t\t\tuint256 amount = amounts[i];\n\n\t\t\tif (amount == 0) continue;\n\t\t\tif (!isRewardToken[token]) revert TokenNotWhitelisted(token);\n\n\t\t\tIERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\t\t\tpendingRewards[token] += amount;\n\t\t\t_addRewardsForToken(token, amount);\n\t\t}\n\t\temit RewardNotified(tokens, amounts);\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Restricted Functions\n\t//--------------------------------------------------------------------------\n\n\t/**\n\t * @notice Allows admin to claim rewards on behalf of a user.\n\t * @param user The user address for which to claim rewards.\n\t */\n\tfunction claimFor(address user) external nonReentrant onlyRole(REWARD_MANAGER_ROLE) whenNotPaused {\n\t\t_updateRewardsStates(user);\n\t\t_claimRewardsFor(user);\n\t}\n\n\t/**\n\t * @notice Updates the whitelist status of a reward token.\n\t * @param token The token address.\n\t * @param status The new whitelist status.\n\t */\n\tfunction configureRewardToken(address token, bool status) external onlyRole(REWARD_MANAGER_ROLE) {\n\t\t_updateRewardsStates(address(0));\n\n\t\tif (token == address(0)) revert ZeroAddress();\n\t\tif (isRewardToken[token] == status) revert TokenWhitelistStatusUnchanged(token, status);\n\n\t\tisRewardToken[token] = status;\n\t\tif (!status) {\n\t\t\tif (pendingRewards[token] > 10) revert OngoingRewardPeriodForToken(token, pendingRewards[token]);\n\t\t\tuint256 len = rewardTokens.length;\n\t\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\t\tif (rewardTokens[i] == token) {\n\t\t\t\t\trewardTokens[i] = rewardTokens[rewardTokens.length - 1];\n\t\t\t\t\trewardTokens.pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trewardTokens.push(token);\n\t\t\trewardState[token].duration = DEFAULT_REWARDS_DURATION;\n\t\t}\n\n\t\temit UpdateWhitelist(token, status);\n\t}\n\n\t/**\n\t * @notice Withdraw specific amount of token.\n\t * @param token The token address.\n\t * @param amount The amount.\n\t * @param receiver The address of receiver\n\t */\n\tfunction rescueTokens(address token, uint256 amount, address receiver) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n\t\tIERC20(token).safeTransfer(receiver, amount);\n\t\temit RescueToken(token, amount, receiver);\n\t}\n\n\t/**\n\t * @notice Pauses contract operations.\n\t */\n\tfunction pause() external onlyRole(PAUSER_ROLE) {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpauses contract operations.\n\t */\n\tfunction unpause() external onlyRole(UNPAUSER_ROLE) {\n\t\t_unpause();\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Internal Functions\n\t//--------------------------------------------------------------------------\n\n\tfunction _addRewardsForToken(address token, uint256 amount) internal {\n\t\tTokenRewardState storage state = rewardState[token];\n\n\t\tif (block.timestamp >= state.periodFinish) {\n\t\t\tstate.rate = amount / state.duration;\n\t\t} else {\n\t\t\tuint256 remaining = state.periodFinish - block.timestamp;\n\t\t\tuint256 leftover = remaining * state.rate;\n\t\t\tstate.rate = (amount + leftover) / state.duration;\n\t\t}\n\n\t\tstate.lastUpdated = block.timestamp;\n\t\tstate.periodFinish = block.timestamp + state.duration;\n\t}\n\n\t/**\n\t * @notice Internal function to claim rewards for a given user.\n\t * Assumes updateRewards(user) has already been called.\n\t */\n\tfunction _claimRewardsFor(address user) internal {\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\taddress token = rewardTokens[i];\n\t\t\tuint256 reward = rewards[user][token];\n\t\t\tif (reward > 0) {\n\t\t\t\trewards[user][token] = 0;\n\t\t\t\tpendingRewards[token] -= reward;\n\t\t\t\tIERC20(token).safeTransfer(user, reward);\n\t\t\t\temit RewardClaimed(user, token, reward);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Updates the rewards for an account for all reward tokens.\n\t * @param account The account to update.\n\t */\n\tfunction _updateRewardsStates(address account) internal {\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\taddress token = rewardTokens[i];\n\t\t\tTokenRewardState storage state = rewardState[token];\n\n\t\t\tstate.perTokenStored = rewardPerToken(token);\n\t\t\tstate.lastUpdated = lastTimeRewardApplicable(token);\n\n\t\t\tif (account != address(0)) {\n\t\t\t\trewards[account][token] = earned(account, token);\n\t\t\t\tuserRewardPerTokenPaid[account][token] = state.perTokenStored;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }
}