{
    "vfp_id": "vfp_00622",
    "project_name": "Oxorio SAMM Module Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Front-Running Can Lead to Multisig Wallet DoS",
            "description": "The `executeTransaction` and `executeTransactionReturnData` functions in the SAMM contract do not restrict the caller, allowing any external party to invoke them. An attacker can observe a relayer's transaction in the mempool and front-run it with a modified gas amount. By carefully choosing the gas limit, the attacker can cause the forwarded call to revert due to insufficient gas while still allowing the outer transaction to succeed (thanks to EIP-150's gas stipend rules). This results in the SAMM contract's nonce being incremented, which invalidates the original relayer's transaction. The exploitation does not require special privileges and relies only on mempool monitoring and faster transaction submission. The impact is a denial-of-service on the multisig functionality, discarding the off-chain coordination and proof generation effort, and blocking legitimate transaction execution until a new proof is generated.\n",
            "severity": "High",
            "location": [
                "samm-contracts/src/SAMM.sol#167",
                "samm-contracts/src/SAMM.sol#194",
                "samm-contracts/src/SAMM.sol#443",
                "samm-contracts/src/SAMM.sol#435"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Insufficient Setup Validation Can Render SAMM Unusable",
            "description": "The `setup` function in the SAMM contract lacks validation for two critical parameters: the `relayer` email length and the `membersRoot` value. The `relayer` email is later written into a fixed-size array of 172 bytes starting at index 1, but if the email exceeds 124 characters, it causes an out-of-bounds write and contract panic. Similarly, the `membersRoot` is not validated against the BN254 field order, and if set to an invalid value, it prevents transaction execution. Although these can be corrected post-deployment via multisig governance, the lack of input validation during setup introduces an initial denial-of-service risk. The cause is missing require checks in the `setup` function. An attacker cannot directly exploit this, but a misconfiguration or malicious deployer could render the contract unusable. The impact is a potential permanent or temporary loss of functionality until governance intervention.\n",
            "severity": "Low",
            "location": [
                "samm-contracts/src/SAMM.sol#98",
                "samm-contracts/src/SAMM.sol#124",
                "samm-contracts/src/SAMM.sol#272",
                "samm-contracts/src/libraries/PubSignalsConstructor.sol#38",
                "samm-contracts/src/SAMM.sol#263",
                "samm-contracts/src/SAMM.sol#227"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Incomplete Transaction Validation",
            "description": "The `ModuleGuard` and `SAMM` contracts validate the function selector by reading the first 4 bytes of the `data` field, but they do not ensure that the `data` buffer is at least 4 bytes long. If a transaction has less than 4 bytes of data, the selector check reads uninitialized or zero-padded data, leading to a mismatch between validation and execution. This allows the contract to execute `fallback` or `receive` functions on destination contracts without proper authorization. Additionally, a partial selector (e.g., 2 bytes) could be interpreted differently than intended if the destination contract has non-standard function dispatching. The root cause is the absence of a length check before selector extraction. The impact is unauthorized execution of unintended functions, potentially leading to loss of funds or unintended state changes in target contracts.\n",
            "severity": "Low",
            "location": [
                "samm-contracts/src/ModuleGuard.sol#168",
                "samm-contracts/src/ModuleGuard.sol#133",
                "samm-contracts/src/SAMM.sol#446-L458",
                "samm-contracts/src/SAMM.sol#443"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/ModuleGuard.sol",
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Allowance System Ignores Operation Type",
            "description": "The `_checkTxAllowance` function in the SAMM contract validates the target and selector of a transaction but does not consider the operation type (e.g., `call`, `delegatecall`). This means that a transaction using `delegatecall` could be allowed even if only a regular `call` was intended, potentially leading to unauthorized state modifications in the context of the calling contract. The root cause is the lack of operation type validation in the allowance check. An attacker could exploit this by crafting a transaction with a different operation type than intended, potentially escalating privileges or manipulating contract state. The impact is a potential bypass of intended security restrictions.\n",
            "severity": "Low",
            "location": [
                "samm-contracts/src/SAMM.sol#446"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Potential Use of Revoked Public Key Hashes With Updated DKIM Registry",
            "description": "The `setDKIMRegistry` function allows the multisig to update the DKIM registry contract. However, when the registry is changed, there is no mechanism to ensure that public key hashes revoked in the previous registry are not reused in the new one. This could allow a previously revoked key to be accepted if the new registry does not maintain revocation status. The root cause is the lack of continuity in revocation state across registry updates. An attacker with access to a previously revoked but now re-registered key could forge approvals. The impact is a potential compromise of the approval process if registry updates are not carefully managed.\n",
            "severity": "Low",
            "location": [
                "samm-contracts/src/SAMM.sol#245"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Use of Non-Audited `Base64` Library",
            "description": "The codebase uses an external `Base64` library from `Brechtpd/base64` that has not undergone a security audit. Unaudited libraries may contain vulnerabilities such as buffer overflows, incorrect padding handling, or side-channel leaks. The root cause is the inclusion of a third-party dependency without security validation. An attacker could exploit a vulnerability in the library to corrupt data, cause denial-of-service, or potentially execute arbitrary code if the library is used in a sensitive context. The impact is an increased attack surface due to untrusted external code.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/libraries/PubSignalsConstructor.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "No Event Emitted for Allowed Transactions Added During Setup",
            "description": "The `setup` function in the SAMM contract adds initial allowed transactions but does not emit the `TxAllowanceChanged` event, unlike the `setTxAllowed` function. This creates a discrepancy between the on-chain state and off-chain event indexing systems, which rely on events to track changes. The root cause is inconsistent use of event emission. An attacker cannot directly exploit this, but it hampers transparency and monitoring, making it harder to detect malicious configuration during deployment. The impact is reduced observability and potential for undetected misconfiguration.\n",
            "severity": "Low",
            "location": [
                "samm-contracts/src/SAMM.sol#98",
                "samm-contracts/src/SAMM.sol#133-L141",
                "samm-contracts/src/SAMM.sol#304"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Duplicate Transaction IDs Can Overwrite Each Other During Setup",
            "description": "The `setup` function allows duplicate `txId` entries in the `txAllowances` array, causing later entries to overwrite earlier ones. This can lead to an unintended protocol state where expected allowances are missing or altered. The root cause is the lack of uniqueness enforcement, despite using a `Set` structure elsewhere. An attacker could exploit this during deployment (if they control setup) to weaken the transaction whitelist. The impact is potential misconfiguration of the allowance system, leading to either over-permissioned or under-permissioned states.\n",
            "severity": "Low",
            "location": [
                "samm-contracts/src/SAMM.sol#98",
                "samm-contracts/src/SAMM.sol#140",
                "samm-contracts/src/SAMM.sol#286"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading and Incomplete Documentation",
            "description": "Multiple instances of incorrect or incomplete comments exist across the codebase. For example, the `txAllowances` documentation omits the `amount` field, function comments refer to non-existent concepts like \"hash approval amount\", deadline behavior is incorrectly described as exclusive, and DKIM key splitting details in comments do not match the actual circuit logic. Additionally, the `ModuleGuard` comments incorrectly imply support for multiple modules. The root cause is outdated or inaccurate documentation. While not directly exploitable, this increases the risk of developer error during maintenance or integration. The impact is reduced code clarity and increased likelihood of bugs due to misunderstanding.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol",
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/ModuleGuard.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "The Codebase Contains Magic Numbers",
            "description": "The codebase uses several unexplained numeric constants (e.g., 124 for email length, 44 for msgHash64, arbitrary chunk counts for key and message splitting) without defining them as named constants or providing justification. This reduces code readability and maintainability, as the meaning and origin of these numbers are unclear. The root cause is the absence of proper constant definitions and documentation. While not directly exploitable, magic numbers increase the risk of errors during modifications and make audits more difficult. The impact is reduced code quality and higher maintenance burden.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol",
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/libraries/PubSignalsConstructor.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "Inefficient uniqueness check in _checkNProofs",
            "description": "The `_checkNProofs` function uses a loop to verify the uniqueness of each commitment without assuming any order.\nThis results in O(nÂ²) complexity due to nested loops or repeated comparisons.\nThe root cause is the absence of an assumption that inputs can be pre-sorted.\nThis inefficiency increases gas usage during proof validation.\nThe impact is higher transaction costs and potential scalability issues under large input sets.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol::_checkNProofs#472-477"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Inefficient storage layout in SAMM contract",
            "description": "The `SAMM` contract's storage layout does not pack variables efficiently.\nSpecifically, `s_threshold` (uint64) is stored alongside `s_safe` (address, 20 bytes), leaving 32 bits unused in the same slot.\nAdditionally, `nonce` (uint256) is not packed with `s_dkimRegistry` (address), which could save a storage slot if `nonce` were reduced to uint96.\nThe root cause is suboptimal variable ordering and sizing.\nThe impact is increased gas costs for storage operations due to missed packing opportunities.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol#54"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ]
            },
            "title": "Inefficient on-chain proof verification design",
            "description": "The current design verifies each proof individually on-chain after the threshold is met.\nThis leads to higher gas costs due to repeated verification logic.\nThe root cause is delegating aggregation to the off-chain relayer without requiring joint proofs.\nAn optimized design would have the relayer generate a single aggregated proof once the threshold is reached.\nThe impact is unnecessarily high transaction costs and reduced scalability.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol::checkNProofs#460",
                "SAMM.sol#437-439"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Inefficient handling of s_relayer in getPubSignals",
            "description": "The `getPubSignals` function splits the `s_relayer` address into a bytes32 array, incurring memory expansion and parsing overhead.\nThe root cause is using the full address as a public signal instead of its hash.\nThis increases memory usage and computation cost in the verifier contract.\nThe impact is higher gas consumption during verification.\nOptimizing by hashing `s_relayer` would reduce memory usage to a single 32-byte word.\n",
            "severity": "Informational",
            "location": [
                "PubSignalsConstructor.sol::getPubSignals#55-59"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/libraries/PubSignalsConstructor.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1050"
                ]
            },
            "title": "Missing cache of s_dkimRegistry in checkNProofs",
            "description": "The `checkNProofs` function reads `s_dkimRegistry` from storage in a loop, causing multiple SLOADs.\nThe root cause is the failure to cache the storage variable in memory before the loop.\nThis leads to unnecessary gas costs, as storage reads are expensive.\nThe impact is increased gas usage proportional to the number of iterations.\nCaching the value in memory before the loop would reduce costs.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol::checkNProofs#467"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused return value in checkModuleTransaction",
            "description": "The `checkModuleTransaction` function computes and returns `moduleTxHash` using `keccak256`, but the return value is not used by callers.\nThe root cause is unnecessary computation for a value with no downstream use.\nThis wastes gas due to hashing potentially large inputs.\nThe impact is avoidable execution costs.\nReturning a constant or removing the computation would optimize this.\n",
            "severity": "Informational",
            "location": [
                "ModuleGuard.sol::checkModuleTransaction#139"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/ModuleGuard.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant access control checks in SAMM contract",
            "description": "Multiple functions in the `SAMM` contract repeat the same access control check to ensure the caller is the Safe account.\nThe root cause is the lack of a reusable modifier to encapsulate this logic.\nThis leads to code bloat and increased deployment cost.\nThe impact is reduced code maintainability and higher gas costs due to duplicated logic.\nImplementing a modifier would improve clarity and efficiency.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol#210-212",
                "SAMM.sol#209-316"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant txId encoding logic",
            "description": "The computation of `txId` as a packed encoding of address and function selector is repeated across the codebase.\nThe root cause is the absence of a dedicated private function to centralize this logic.\nThis increases the risk of encoding mismatches and bugs.\nThe impact is reduced code maintainability and potential vulnerabilities from inconsistent encoding.\nMoving this to a private function would improve consistency and safety.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused ModuleGuard contract",
            "description": "The `ModuleGuard` contract is present in the codebase but appears to be unused, as its functionality is implemented in the `SAMM` contract.\nThe root cause is leftover code from prior design iterations.\nThis increases code complexity and maintenance burden.\nThe impact is confusion for auditors and developers, and potential security risks if the contract is accidentally deployed or referenced.\nThe contract should be removed or documented if retained.\n",
            "severity": "Informational",
            "location": [
                "ModuleGuard.sol"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/ModuleGuard.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Non-indexed dkimRegistry parameter in Setup event",
            "description": "The `dkimRegistry` parameter in the `Setup` event is not indexed, making it difficult to query logs for specific registry instances.\nThe root cause is missing `indexed` keyword in event definition.\nThis impacts off-chain monitoring and integration tools.\nThe impact is inefficient log filtering and increased operational overhead for clients.\nIndexing the parameter would enable efficient topic-based queries.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol#149",
                "ISAMMEvents.sol::Setup"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typographical errors in code comments and variable names",
            "description": "Multiple typographical errors exist, such as \"one of the proof\" instead of \"one of the proofs\" and \"uniq\" instead of \"unique\".\nThe root cause is lack of proofreading.\nWhile not directly security-relevant, these reduce code readability and professionalism.\nThe impact is potential confusion for developers and auditors.\nCorrecting these would improve code clarity.\n",
            "severity": "Informational",
            "location": [
                "SAMM.sol#158",
                "SAMM.sol#184",
                "SAMM.sol#472"
            ],
            "files": [
                "c2d255dfe6e0be8a1650c6018da37e73f29521ed/samm-contracts/src/SAMM.sol"
            ]
        }
    ],
    "affected_files": {
        "ModuleGuard.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {Enum} from \"./libraries/Enum.sol\";\nimport {IModuleGuard} from \"./interfaces/IModuleGuard.sol\";\n\nimport {ISafe} from \"./Safe/interfaces/ISafe.sol\";\nimport {Singleton} from \"./Safe/common/Singleton.sol\";\n\ncontract ModuleGuard is Singleton, IModuleGuard {\n    // solhint-disable-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    //////////////////////\n    // State Variables  //\n    //////////////////////\n\n    ISafe private safe;\n\n    // A whitelist of contract addresses and function signatures\n    // with which the SAMM module can interact on behalf of the Safe multisig\n    mapping(address module => mapping(address to => mapping(bytes4 selector => bool))) public isTxAllowed;\n\n    // A limit on the amount of ETH that can be transferred\n    // to a single address in the whitelist.\n    mapping(address module => mapping(address to => uint256)) public allowance;\n\n    //////////////////////////////\n    // Functions - Constructor  //\n    //////////////////////////////\n    constructor() {\n        // To lock the singleton contract so no one can call setup.\n        safe = ISafe(address(1));\n    }\n\n    ///////////////////////////\n    // Functions - External  //\n    ///////////////////////////\n\n    /**\n     * @notice Initializes the contract.\n     * @dev This method can only be called once.\n     * If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * Revert in case:\n     *  - The contract has already been initialized.\n     *  - One of the passed parameters is 0.\n     * @param _safe The address of the Safe.\n     */\n    function setup(address _safe) external {\n        if (safe != ISafe(address(0))) {\n            revert ModuleGuard__alreadyInitialized();\n        }\n\n        if (_safe == address(0)) {\n            revert ModuleGuard__safeIsZero();\n        }\n\n        safe = ISafe(_safe);\n        emit Setup(msg.sender, _safe);\n    }\n\n    /**\n     * @notice Updates list of allowed transactions.\n     * @param module The address of module, for which allowed transactions list is changing.\n     * @param to The destination address of new transaction.\n     * @param selector The selector of new transaction.\n     * @param isAllowed Boolean: 1 if the transaction is allowed, 0 if the transaction is not allowed anymore.\n     */\n    function setTxAllowed(address module, address to, bytes4 selector, bool isAllowed) external {\n        address _safe = address(safe);\n        if (msg.sender != _safe) {\n            revert ModuleGuard__notSafe();\n        }\n        if (module == _safe || module == address(0)) {\n            revert ModuleGuard__moduleIsWrong();\n        }\n        if (to == _safe || to == address(0)) {\n            revert ModuleGuard__toIsWrong();\n        }\n        if (isAllowed == isTxAllowed[module][to][selector]) {\n            revert ModuleGuard__noChanges();\n        }\n        isTxAllowed[module][to][selector] = isAllowed;\n        emit TxAllowanceChanged(module, to, selector, isAllowed);\n    }\n\n    /**\n     * @notice Updates allowance mapping.\n     * @param module The address of module, for which allowance mapping is changing.\n     * @param to The destination address for which allowance is changing.\n     * @param amount The new allowance value.\n     */\n    function setAllowance(address module, address to, uint256 amount) external {\n        address _safe = address(safe);\n        if (msg.sender != _safe) {\n            revert ModuleGuard__notSafe();\n        }\n        if (module == _safe || module == address(0)) {\n            revert ModuleGuard__moduleIsWrong();\n        }\n        if (to == _safe || to == address(0)) {\n            revert ModuleGuard__toIsWrong();\n        }\n        if (amount == allowance[module][to]) {\n            revert ModuleGuard__noChanges();\n        }\n        allowance[module][to] = amount;\n        emit AllowanceChanged(module, to, amount);\n    }\n\n    /**\n     * @notice Called by the Safe contract before a transaction is executed via a module.\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param module Account executing the transaction.\n     * @return moduleTxHash Hash of the module transaction.\n     */\n    function checkModuleTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        address module\n    ) external view override returns (bytes32 moduleTxHash) {\n        bytes4 selector = _getABISig(data);\n        if (!isTxAllowed[module][to][selector]) {\n            revert ModuleGuard__txIsNotAllowed();\n        }\n        if (allowance[module][to] < value) {\n            revert ModuleGuard__allowanceIsNotEnough();\n        }\n\n        moduleTxHash = keccak256(abi.encodePacked(to, value, data, operation, module));\n    }\n\n    /**\n     * @notice Called by the Safe contract after a module transaction is executed.\n     * @dev No-op.\n     */\n    function checkAfterModuleExecution(bytes32 txHash, bool success) external override {}\n\n    //////////////////////////////\n    // Functions  -   View      //\n    //////////////////////////////\n\n    /// @notice Retrieves the address of the Safe associated with this module.\n    /// @return _safe The address of the associated Safe.\n    function getSafe() external view returns (address _safe) {\n        return address(safe);\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IModuleGuard).interfaceId // 0x58401ed8\n            || interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    //////////////////////////////\n    //   Functions - Private    //\n    //////////////////////////////\n    function _getABISig(bytes memory data) private pure returns (bytes4 sig) {\n        assembly {\n            sig := mload(add(data, 0x20))\n        }\n    }\n}\n",
        "PubSignalsConstructor.sol": "// SPDX-License-Identifier: GPL-3\n/**\n *     Safe Anonymization Mail Module\n *     Copyright (C) 2024 OXORIO-FZCO\n *\n *     This program is free software: you can redistribute it and/or modify\n *     it under the terms of the GNU General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n *\n *     This program is distributed in the hope that it will be useful,\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *     GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.23;\n\nimport {ISafe} from \"../Safe/interfaces/ISafe.sol\";\nimport \"base64/base64.sol\";\n\nlibrary PubSignalsConstructor {\n    function getMsgHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        uint256 nonce,\n        uint256 deadline\n    ) internal view returns (bytes32 msgHash) {\n        bytes32 calldataHash = keccak256(data);\n        msgHash =\n            keccak256(abi.encode(to, value, calldataHash, operation, nonce, deadline, address(this), block.chainid));\n    }\n\n    function getPubSignals(\n        uint256 participantsRoot,\n        string memory relayer,\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        uint256 nonce,\n        uint256 deadline\n    ) internal view returns (bytes32[] memory pubSignals) {\n        // public signals order: root, relayer, relayer_len, msg_hash, commit, pubkey_hash\n        pubSignals = new bytes32[](172);\n\n        // root\n        pubSignals[0] = bytes32(participantsRoot);\n\n        // relayer\n        bytes memory relayerBytes = bytes(relayer);\n        for (uint256 i = 0; i < relayerBytes.length; i++) {\n            pubSignals[1 + i] = bytes32(uint256(uint8(relayerBytes[i])));\n        }\n        pubSignals[125] = bytes32(uint256(bytes(relayer).length));\n\n        // msgHash\n        bytes32 msgHash = getMsgHash(to, value, data, operation, nonce, deadline);\n        bytes memory msgHash64 = bytes(Base64.encode(bytes.concat(msgHash)));\n        for (uint256 i = 0; i < 44; i++) {\n            pubSignals[126 + i] = bytes32(uint256(uint8(msgHash64[i])));\n        }\n    }\n}\n",
        "SAMM.sol": "// SPDX-License-Identifier: GPL-3\n/**\n *     Safe Anonymization Mail Module\n *     Copyright (C) 2024 OXORIO-FZCO\n *\n *     This program is free software: you can redistribute it and/or modify\n *     it under the terms of the GNU General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n *\n *     This program is distributed in the hope that it will be useful,\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *     GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.23;\n\n// Contracts\nimport {Singleton} from \"./Safe/common/Singleton.sol\";\nimport {HonkVerifier as Verifier1024} from \"./utils/Verifier1024.sol\";\nimport {HonkVerifier as Verifier2048} from \"./utils/Verifier2048.sol\";\n\n// Libs\nimport {PubSignalsConstructor} from \"./libraries/PubSignalsConstructor.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Interfaces\nimport {ISAMM} from \"./interfaces/ISAMM.sol\";\nimport {ISafe} from \"./Safe/interfaces/ISafe.sol\";\nimport {IDKIMRegistry} from \"./interfaces/IDKIMRegistry.sol\";\n\n/// @title Safe Anonymization Mail Module\n/// @author Vladimir Kumalagov (@KumaCrypto, @dry914)\n/// @notice This contract is a module for Safe Wallet (Gnosis Safe), aiming to provide anonymity for users.\n/// It allows users to execute transactions for a specified Safe without revealing the addresses of the members who voted to execute the transaction.\n/// @dev This contract should be used as a singleton. And proxy contracts must use delegatecall to use the contract logic.\ncontract SAMM is Singleton, ISAMM {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    ///////////////////////\n    //Immutable Variables//\n    ///////////////////////\n\n    // Verifiers from repository: https://github.com/oxor-io/samm-circuits\n    Verifier1024 private immutable VERIFIER1024 = new Verifier1024();\n    Verifier2048 private immutable VERIFIER2048 = new Verifier2048();\n\n    //////////////////////\n    // State Variables  //\n    //////////////////////\n    ISafe private s_safe;\n    // The value of type(uint64).max is large enough to hold the maximum possible amount of proofs.\n    uint64 private s_threshold;\n    // Relayer email address\n    string private s_relayer;\n    // The root of the Merkle tree from the addresses of all SAM members (using Poseidon)\n    uint256 private s_membersRoot;\n    uint256 private s_nonce;\n    IDKIMRegistry private s_dkimRegistry;\n\n    // A whitelist of contract addresses and function signatures\n    // with which the SAMM module can interact on behalf of the Safe multisig\n    EnumerableSet.Bytes32Set private s_allowedTxs; // abi.encodePacked(bytes20(address),bytes4(signature))\n\n    // A limit on the amount of ETH that can be transferred\n    // to a single (address,signature) in the whitelist.\n    mapping(bytes32 => uint256) private s_allowance;\n\n    //////////////////////////////\n    // Functions - Constructor  //\n    //////////////////////////////\n    constructor() {\n        // To lock the singleton contract so no one can call setup.\n        s_threshold = 1;\n    }\n\n    ///////////////////////////\n    // Functions - External  //\n    ///////////////////////////\n\n    /**\n     * @notice Initializes the contract.\n     * @dev This method can only be called once.\n     * If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * Revert in case:\n     *  - The contract has already been initialized.\n     *  - One of the passed parameters is 0.\n     * @param safe The address of the Safe.\n     * @param membersRoot The Merkle root of participant addresses.\n     * @param threshold The minimum number of proofs required to execute a transaction.\n     * @param relayer The email address of Relayer.\n     * @param dkimRegistry The DKIM pubkeys registry contract address.\n     * @param txAllowances List of [address, selector] pairs which are initialy allowed.\n     */\n    function setup(\n        address safe,\n        uint256 membersRoot,\n        uint64 threshold,\n        string calldata relayer,\n        address dkimRegistry,\n        TxAllowance[] calldata txAllowances\n    ) external {\n        if (s_threshold != 0) {\n            revert SAMM__alreadyInitialized();\n        }\n\n        // Parameters validation block\n        {\n            if (safe == address(0)) {\n                revert SAMM__safeIsZero();\n            }\n\n            if (membersRoot == 0) {\n                revert SAMM__rootIsZero();\n            }\n\n            if (threshold == 0) {\n                revert SAMM__thresholdIsZero();\n            }\n\n            if (bytes(relayer).length == 0) {\n                revert SAMM__emptyRelayer();\n            }\n\n            if (dkimRegistry == address(0)) {\n                revert SAMM__dkimRegistryIsZero();\n            }\n        }\n\n        bytes32 txId;\n        for (uint256 i; i < txAllowances.length; i++) {\n            if (txAllowances[i].to == safe || txAllowances[i].to == address(0)) {\n                revert SAMM__toIsWrong();\n            }\n            txId = bytes32(abi.encodePacked(bytes20(txAllowances[i].to), txAllowances[i].selector));\n            s_allowedTxs.add(txId);\n            s_allowance[txId] = txAllowances[i].amount;\n        }\n\n        s_safe = ISafe(safe);\n        s_membersRoot = membersRoot;\n        s_threshold = threshold;\n        s_relayer = relayer;\n        s_dkimRegistry = IDKIMRegistry(dkimRegistry);\n\n        emit Setup(msg.sender, safe, membersRoot, threshold, relayer, dkimRegistry);\n    }\n\n    /**\n     * @notice Executes a transaction with zk proofs without returning data.\n     * @dev Revert in case:\n     *          - Not enough proofs provided (threshold > hash approval amount + amount of provided proofs).\n     *          - Contract not initialized.\n     *          - One of the proof commits has already been used.\n     *          - One of the proof is invalid.\n     * @param to The target address to be called by safe.\n     * @param value The value in wei to be sent.\n     * @param data The data payload of the transaction.\n     * @param operation The type of operation (CALL, DELEGATECALL).\n     * @param proofs An array of zk proofs.\n     * @param deadline The deadline before which transaction should be executed.\n     * @return success A boolean indicating whether the transaction was successful.\n     */\n    function executeTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        Proof[] calldata proofs,\n        uint256 deadline\n    ) external returns (bool success) {\n        (success,) = _executeTransaction(to, value, data, operation, proofs, deadline);\n    }\n\n    /**\n     * @notice Executes a transaction with zk proofs and returns the returned by the transaction execution.\n     * @dev Revert in case:\n     *          - Not enough proofs provided (threshold > hash approval amount + amount of provided proofs).\n     *          - Contract not initialized.\n     *          - One of the proof commits has already been used.\n     *          - One of the proof is invalid.\n     * @param to The target address to be called by safe.\n     * @param value The value in wei to be sent.\n     * @param data The data payload of the transaction.\n     * @param operation The type of operation (CALL, DELEGATECALL).\n     * @param proofs An array of zk proofs.\n     * @param deadline The deadline before which transaction should be executed.\n     * @return success A boolean indicating whether the transaction was successful.\n     * @return returnData The data returned by the transaction execution.\n     */\n    function executeTransactionReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        Proof[] calldata proofs,\n        uint256 deadline\n    ) external returns (bool success, bytes memory returnData) {\n        (success, returnData) = _executeTransaction(to, value, data, operation, proofs, deadline);\n    }\n\n    /**\n     * @notice Updates threshold parameter.\n     * @param threshold The new threshold value.\n     */\n    function setThreshold(uint64 threshold) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (threshold == 0) {\n            revert SAMM__thresholdIsZero();\n        }\n\n        s_threshold = threshold;\n\n        emit ThresholdIsChanged(threshold);\n    }\n\n    /**\n     * @notice Updates members root parameter.\n     * @param membersRoot The new members' root value.\n     */\n    function setMembersRoot(uint256 membersRoot) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (membersRoot == 0) {\n            revert SAMM__rootIsZero();\n        }\n\n        s_membersRoot = membersRoot;\n\n        emit MembersRootIsChanged(membersRoot);\n    }\n\n    /**\n     * @notice Updates DKIM registry parameter.\n     * @param dkimRegistry The new DKIM registry address.\n     */\n    function setDKIMRegistry(address dkimRegistry) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (dkimRegistry == address(0)) {\n            revert SAMM__dkimRegistryIsZero();\n        }\n\n        s_dkimRegistry = IDKIMRegistry(dkimRegistry);\n\n        emit DKIMRegistryIsChanged(dkimRegistry);\n    }\n\n    /**\n     * @notice Updates relayer email address parameter.\n     * @param relayer The new relayer email address.\n     */\n    function setRelayer(string calldata relayer) external {\n        if (msg.sender != address(s_safe)) {\n            revert SAMM__notSafe();\n        }\n\n        if (bytes(relayer).length == 0) {\n            revert SAMM__emptyRelayer();\n        }\n\n        if (bytes(relayer).length > 124) {\n            revert SAMM__longRelayer();\n        }\n\n        s_relayer = relayer;\n\n        emit RelayerIsChanged(relayer);\n    }\n\n    /**\n     * @notice Updates list of allowed transactions.\n     * @param txAllowance TxAllowance structure of new transaction.\n     * @param isAllowed Boolean: 1 if the transaction is allowed, 0 if the transaction is not allowed anymore.\n     */\n    function setTxAllowed(TxAllowance calldata txAllowance, bool isAllowed) external {\n        address _safe = address(s_safe);\n        if (msg.sender != _safe) {\n            revert SAMM__notSafe();\n        }\n        if (txAllowance.to == _safe || txAllowance.to == address(0)) {\n            revert SAMM__toIsWrong();\n        }\n        bool success;\n        bytes32 txId = bytes32(abi.encodePacked(bytes20(txAllowance.to), txAllowance.selector));\n        if (isAllowed) {\n            success = s_allowedTxs.add(txId);\n            s_allowance[txId] = txAllowance.amount;\n        } else {\n            success = s_allowedTxs.remove(txId);\n            s_allowance[txId] = 0;\n        }\n        if (!success) revert SAMM__noChanges();\n        emit TxAllowanceChanged(txId, txAllowance.amount, isAllowed);\n    }\n\n    /**\n     * @notice Updates allowance mapping.\n     * @param txId Transaction id for which allowance is changing.\n     * @param amount The new allowance value.\n     */\n    function changeAllowance(bytes32 txId, uint256 amount) external {\n        address _safe = address(s_safe);\n        if (msg.sender != _safe) {\n            revert SAMM__notSafe();\n        }\n        if (!s_allowedTxs.contains(txId)) {\n            revert SAMM__txIsNotAllowed();\n        }\n        if (amount == s_allowance[txId]) {\n            revert SAMM__noChanges();\n        }\n        s_allowance[txId] = amount;\n        emit AllowanceChanged(txId, amount);\n    }\n\n    //////////////////////////////\n    // Functions  -   View      //\n    //////////////////////////////\n\n    /// @notice Retrieves the address of the Safe associated with this module.\n    /// @return safe The address of the associated Safe.\n    function getSafe() external view returns (address safe) {\n        return address(s_safe);\n    }\n\n    /// @notice Retrieves the current members root.\n    /// @return root The Merkle root of participant addresses.\n    function getMembersRoot() external view returns (uint256 root) {\n        return s_membersRoot;\n    }\n\n    /// @notice Retrieves the threshold number of proofs required for transaction execution.\n    /// @return threshold The current threshold value.\n    function getThreshold() external view returns (uint64 threshold) {\n        return s_threshold;\n    }\n\n    /// @notice Retrieves the relayer email address.\n    /// @return relayer The current relayer email address.\n    function getRelayer() external view returns (string memory relayer) {\n        return s_relayer;\n    }\n\n    /// @notice Retrieves the address of DKIMRegistry.\n    /// @return dkimRegistry The current DKIMRegistry address.\n    function getDKIMRegistry() external view returns (address dkimRegistry) {\n        return address(s_dkimRegistry);\n    }\n\n    /// @notice Retrieves the current nonce value.\n    /// @return nonce The current nonce.\n    function getNonce() external view returns (uint256 nonce) {\n        return s_nonce;\n    }\n\n    /// @notice Retrieves the current list of allowed transactions.\n    /// @return List of allowed transactions.\n    function getAllowedTxs() external view returns (TxAllowance[] memory) {\n        bytes32[] memory allowedTxs = s_allowedTxs.values();\n        TxAllowance[] memory txAllowances = new TxAllowance[](allowedTxs.length);\n\n        address to;\n        bytes4 selector;\n        uint256 amount;\n        for (uint256 i; i < allowedTxs.length; i++) {\n            // decode allowedTxs storage\n            to = address(bytes20(allowedTxs[i]));\n            selector = bytes4(allowedTxs[i] << 160);\n            amount = s_allowance[allowedTxs[i]];\n            txAllowances[i] = TxAllowance(to, selector, amount);\n        }\n        return txAllowances;\n    }\n\n    /**\n     * @notice Generates a message hash based on transaction parameters.\n     * @param to The target address to be called by safe.\n     * @param value The value in wei of the transaction.\n     * @param data The data payload of the transaction.\n     * @param operation The type of operation (CALL, DELEGATECALL).\n     * @param nonce The nonce to be used for the transaction.\n     * @param deadline The deadline before which transaction should be executed.\n     * @return msgHash The resulting message hash.\n     */\n    function getMessageHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        uint256 nonce,\n        uint256 deadline\n    ) external view returns (bytes32 msgHash) {\n        return PubSignalsConstructor.getMsgHash(to, value, data, operation, nonce, deadline);\n    }\n\n    //////////////////////////////\n    //   Functions - Private    //\n    //////////////////////////////\n    function _executeTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        ISafe.Operation operation,\n        Proof[] calldata proofs,\n        uint256 deadline\n    ) private returns (bool success, bytes memory returnData) {\n        uint256 root = s_membersRoot;\n\n        // Check root to prevent calls when contract is not initialized.\n        if (root == 0) {\n            revert SAMM__rootIsZero();\n        }\n\n        // Check execution deadline.\n        if (block.timestamp > deadline) {\n            revert SAMM__deadlineIsPast();\n        }\n\n        // Check tx allowance\n        _checkTxAllowance(to, value, data);\n\n        // pubSignals = [root, relayer, relayer_len, msg_hash, pubkey_mod, redc_params]\n        bytes32[] memory pubSignals =\n            PubSignalsConstructor.getPubSignals(root, s_relayer, to, value, data, operation, s_nonce++, deadline);\n\n        if (s_threshold > proofs.length) {\n            revert SAMM__notEnoughProofs(proofs.length, s_threshold);\n        }\n\n        _checkNProofs(proofs, pubSignals);\n\n        return s_safe.execTransactionFromModuleReturnData(to, value, data, operation);\n    }\n\n    function _checkTxAllowance(address to, uint256 value, bytes memory data) private view {\n        bytes4 selector;\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n        bytes32 txId = bytes32(abi.encodePacked(bytes20(to), selector));\n        if (!s_allowedTxs.contains(txId)) {\n            revert SAMM__txIsNotAllowed();\n        }\n        if (s_allowance[txId] < value) {\n            revert SAMM__allowanceIsNotEnough();\n        }\n    }\n\n    function _checkNProofs(Proof[] calldata proofs, bytes32[] memory pubSignals) private {\n        uint256 proofsLength = proofs.length;\n\n        for (uint256 i; i < proofsLength; i++) {\n            Proof memory currentProof = proofs[i];\n\n            // check DKIM public key\n            bool isValid = s_dkimRegistry.isDKIMPublicKeyHashValid(currentProof.domain, currentProof.pubkeyHash);\n            if (!isValid) {\n                revert SAMM__DKIMPublicKeyVerificationFailed(i);\n            }\n\n            // Commit must be uniq, because it is a hash(userEmail, msgHash)\n            for (uint256 j; j < i; j++) {\n                if (proofs[j].commit == currentProof.commit) {\n                    revert SAMM__commitAlreadyUsed(i);\n                }\n            }\n\n            pubSignals[170] = bytes32(currentProof.commit);\n            pubSignals[171] = currentProof.pubkeyHash;\n            bool result;\n            if (currentProof.is2048sig) {\n                result = VERIFIER2048.verify({proof: currentProof.proof, publicInputs: pubSignals});\n            } else {\n                result = VERIFIER1024.verify({proof: currentProof.proof, publicInputs: pubSignals});\n            }\n\n            if (!result) {\n                revert SAMM__proofVerificationFailed(i);\n            }\n        }\n    }\n}\n"
    }
}