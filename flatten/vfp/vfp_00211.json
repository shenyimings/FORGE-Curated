{
    "vfp_id": "vfp_00211",
    "project_name": "ackee-blockchain-lido-triggerable-withdrawals-report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Inconsistent calculation of total requests processed",
            "description": "The system fails to consistently update the total number of processed exit requests when configuration parameters change, leading to a discrepancy between expected and actual state.\nThe cause is an incorrect handling of exit request counters during reconfiguration, where the system does not account for previously processed requests relative to the old limits.\nThis could be exploited by an observer to manipulate perception of system progress or to trigger edge cases in dependent components that rely on accurate request counts.\nThe impact is low, as it does not result in fund loss or critical failure, but it may affect operational accuracy and monitoring.\nSpecifically, the ValidatorsExitBusOracle contract maintains a variable to track the total number of processed triggerable withdrawal requests, but this variable is only updated during the Consensus path and not during the Easy Track path. This inconsistency arises because the counter update is missing in the Easy Track flow, specifically in the submitExitRequestsData function. As a result, when requests are processed via the Easy Track, the counter does not reflect the actual number of processed requests. An attacker or malicious actor is not required for exploitation; normal protocol usage can trigger the inconsistency. The impact is a misleading view of protocol activity for off-chain monitors and tooling relying on the counter, leading to inaccurate operational decisions and reduced transparency.\n",
            "severity": "Low",
            "location": [
                "ValidatorsExitBusOracle.sol::submitReportData#154",
                "ValidatorsExitBus.sol::submitExitRequestsData#251"
            ],
            "files": [
                "core/contracts/0.8.9/oracle/ValidatorsExitBusOracle.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused using-for directive",
            "description": "A 'using-for' directive is declared but not utilized in any function, leading to unnecessary code bloat.\nThis is a code hygiene issue that does not affect runtime behavior or security.\nThe impact is informational, as it represents a minor inefficiency without exploit potential.\nSpecifically, the ValidatorsExitBusOracle contract contains unused 'using-for' directives for ExitLimitUtilsStorage and ExitLimitUtils. These directives import library functions that are never invoked in the contract. The root cause is leftover code from prior development iterations. Unused directives contribute to bloat in the compiled bytecode, increasing deployment costs. The impact is unnecessary gas expenditure during deployment and reduced code clarity, though runtime behavior is unaffected.\n",
            "severity": "Informational",
            "location": [
                "ValidatorsExitBusOracle.sol"
            ],
            "files": [
                "core/contracts/0.8.9/oracle/ValidatorsExitBusOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "ValidatorsExitBusOracle.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {SafeCast} from \"@openzeppelin/contracts-v4.4/utils/math/SafeCast.sol\";\n\nimport {UnstructuredStorage} from \"../lib/UnstructuredStorage.sol\";\n\nimport {BaseOracle} from \"./BaseOracle.sol\";\nimport {ValidatorsExitBus} from \"./ValidatorsExitBus.sol\";\nimport {ExitRequestLimitData, ExitLimitUtilsStorage, ExitLimitUtils} from \"../lib/ExitLimitUtils.sol\";\n\ninterface IOracleReportSanityChecker {\n    function checkExitBusOracleReport(uint256 _exitRequestsCount) external view;\n}\n\ncontract ValidatorsExitBusOracle is BaseOracle, ValidatorsExitBus {\n    using UnstructuredStorage for bytes32;\n    using SafeCast for uint256;\n    using ExitLimitUtilsStorage for bytes32;\n    using ExitLimitUtils for ExitRequestLimitData;\n\n    error AdminCannotBeZero();\n    error SenderNotAllowed();\n    error UnexpectedRequestsDataLength();\n    error ArgumentOutOfBounds();\n\n    event WarnDataIncompleteProcessing(uint256 indexed refSlot, uint256 requestsProcessed, uint256 requestsCount);\n\n    struct DataProcessingState {\n        uint64 refSlot;\n        uint64 requestsCount;\n        uint64 requestsProcessed;\n        uint16 dataFormat;\n    }\n\n    /// @notice An ACL role granting the permission to submit the data for a committee report.\n    bytes32 public constant SUBMIT_DATA_ROLE = keccak256(\"SUBMIT_DATA_ROLE\");\n\n    /// @dev Storage slot: uint256 totalRequestsProcessed\n    bytes32 internal constant TOTAL_REQUESTS_PROCESSED_POSITION =\n        keccak256(\"lido.ValidatorsExitBusOracle.totalRequestsProcessed\");\n\n    /// @dev [DEPRECATED] Storage slot: mapping(uint256 => RequestedValidator) lastRequestedValidatorIndices\n    /// This mapping was previously used for storing last requested validator indexes per (moduleId, nodeOpId) key.\n    /// This code was removed from the contract, but slots can still contain logic.\n\n    /// @dev Storage slot: DataProcessingState dataProcessingState\n    bytes32 internal constant DATA_PROCESSING_STATE_POSITION =\n        keccak256(\"lido.ValidatorsExitBusOracle.dataProcessingState\");\n\n    ///\n    /// Initialization & admin functions\n    ///\n\n    constructor(\n        uint256 secondsPerSlot,\n        uint256 genesisTime,\n        address lidoLocator\n    ) BaseOracle(secondsPerSlot, genesisTime) ValidatorsExitBus(lidoLocator) {}\n\n    function initialize(\n        address admin,\n        address consensusContract,\n        uint256 consensusVersion,\n        uint256 lastProcessingRefSlot,\n        uint256 maxValidatorsPerRequest,\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) external {\n        if (admin == address(0)) revert AdminCannotBeZero();\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n\n        _pauseFor(PAUSE_INFINITELY);\n        _initialize(consensusContract, consensusVersion, lastProcessingRefSlot);\n\n        _initialize_v2(maxValidatorsPerRequest, maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(\n        uint256 maxValidatorsPerReport,\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) external {\n        _initialize_v2(maxValidatorsPerReport, maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    function _initialize_v2(\n        uint256 maxValidatorsPerReport,\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) internal {\n        _updateContractVersion(2);\n        _setMaxValidatorsPerReport(maxValidatorsPerReport);\n        _setExitRequestLimit(maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    ///\n    /// Data provider interface\n    ///\n\n    struct ReportData {\n        ///\n        /// Oracle consensus info\n        ///\n\n        /// @dev Version of the oracle consensus rules. Current version expected\n        /// by the oracle can be obtained by calling getConsensusVersion().\n        uint256 consensusVersion;\n        /// @dev Reference slot for which the report was calculated. If the slot\n        /// contains a block, the state being reported should include all state\n        /// changes resulting from that block. The epoch containing the slot\n        /// should be finalized prior to calculating the report.\n        uint256 refSlot;\n        ///\n        /// Requests data\n        ///\n\n        /// @dev Total number of validator exit requests in this report. Must not be greater\n        /// than limit checked in OracleReportSanityChecker.checkExitBusOracleReport.\n        uint256 requestsCount;\n        /// @dev Format of the validator exit requests data. Currently, only the\n        /// DATA_FORMAT_LIST=1 is supported.\n        uint256 dataFormat;\n        /// @dev Validator exit requests data. Can differ based on the data format,\n        /// see the constant defining a specific data format below for more info.\n        bytes data;\n    }\n\n    /// @notice Submits report data for processing.\n    ///\n    /// @param data The data. See the `ReportData` structure's docs for details.\n    /// @param contractVersion Expected version of the oracle contract.\n    ///\n    /// Reverts if:\n    /// - The caller is not a member of the oracle committee and doesn't possess the\n    ///   SUBMIT_DATA_ROLE.\n    /// - The provided contract version is different from the current one.\n    /// - The provided consensus version is different from the expected one.\n    /// - The provided reference slot differs from the current consensus frame's one.\n    /// - The processing deadline for the current consensus frame is missed.\n    /// - The keccak256 hash of the ABI-encoded data is different from the last hash\n    ///   provided by the hash consensus contract.\n    /// - The provided data doesn't meet safety checks.\n    ///\n    function submitReportData(ReportData calldata data, uint256 contractVersion) external whenResumed {\n        _checkMsgSenderIsAllowedToSubmitData();\n        _checkContractVersion(contractVersion);\n        bytes32 dataHash = keccak256(abi.encode(data.data, data.dataFormat));\n        // it's a waste of gas to copy the whole calldata into mem but seems there's no way around\n        bytes32 reportDataHash = keccak256(abi.encode(data));\n        _checkConsensusData(data.refSlot, data.consensusVersion, reportDataHash);\n        _startProcessing();\n        _handleConsensusReportData(data);\n        _storeOracleExitRequestHash(dataHash, contractVersion);\n        emit ExitDataProcessing(dataHash);\n    }\n\n    /// @notice Returns the total number of validator exit requests ever processed\n    /// across all received reports.\n    ///\n    function getTotalRequestsProcessed() external view returns (uint256) {\n        return TOTAL_REQUESTS_PROCESSED_POSITION.getStorageUint256();\n    }\n\n    struct ProcessingState {\n        /// @notice Reference slot for the current reporting frame.\n        uint256 currentFrameRefSlot;\n        /// @notice The last time at which a report data can be submitted for the current\n        /// reporting frame.\n        uint256 processingDeadlineTime;\n        /// @notice Hash of the report data. Zero bytes if consensus on the hash hasn't\n        /// been reached yet for the current reporting frame.\n        bytes32 dataHash;\n        /// @notice Whether any report data for the for the current reporting frame has been\n        /// already submitted.\n        bool dataSubmitted;\n        /// @notice Format of the report data for the current reporting frame.\n        uint256 dataFormat;\n        /// @notice Total number of validator exit requests for the current reporting frame.\n        uint256 requestsCount;\n        /// @notice How many validator exit requests are already submitted for the current\n        /// reporting frame.\n        uint256 requestsSubmitted;\n    }\n\n    /// @notice Returns data processing state for the current reporting frame.\n    /// @return result See the docs for the `ProcessingState` struct.\n    ///\n    function getProcessingState() external view returns (ProcessingState memory result) {\n        ConsensusReport memory report = _storageConsensusReport().value;\n        result.currentFrameRefSlot = _getCurrentRefSlot();\n\n        if (report.hash == bytes32(0) || result.currentFrameRefSlot != report.refSlot) {\n            return result;\n        }\n\n        result.processingDeadlineTime = report.processingDeadlineTime;\n        result.dataHash = report.hash;\n\n        DataProcessingState memory procState = _storageDataProcessingState().value;\n\n        result.dataSubmitted = procState.refSlot == result.currentFrameRefSlot;\n        if (!result.dataSubmitted) {\n            return result;\n        }\n\n        result.dataFormat = procState.dataFormat;\n        result.requestsCount = procState.requestsCount;\n        result.requestsSubmitted = procState.requestsProcessed;\n    }\n\n    ///\n    /// Implementation & helpers\n    ///\n\n    function _handleConsensusReport(\n        ConsensusReport memory /* report */,\n        uint256 /* prevSubmittedRefSlot */,\n        uint256 prevProcessingRefSlot\n    ) internal override {\n        DataProcessingState memory state = _storageDataProcessingState().value;\n        if (state.refSlot == prevProcessingRefSlot && state.requestsProcessed < state.requestsCount) {\n            emit WarnDataIncompleteProcessing(prevProcessingRefSlot, state.requestsProcessed, state.requestsCount);\n        }\n    }\n\n    function _checkMsgSenderIsAllowedToSubmitData() internal view {\n        address sender = _msgSender();\n        if (!hasRole(SUBMIT_DATA_ROLE, sender) && !_isConsensusMember(sender)) {\n            revert SenderNotAllowed();\n        }\n    }\n\n    function _handleConsensusReportData(ReportData calldata data) internal {\n        if (data.dataFormat != DATA_FORMAT_LIST) {\n            revert UnsupportedRequestsDataFormat(data.dataFormat);\n        }\n\n        if (data.data.length % PACKED_REQUEST_LENGTH != 0) {\n            revert InvalidRequestsDataLength();\n        }\n\n        if (data.data.length / PACKED_REQUEST_LENGTH != data.requestsCount) {\n            revert UnexpectedRequestsDataLength();\n        }\n\n        IOracleReportSanityChecker(LOCATOR.oracleReportSanityChecker()).checkExitBusOracleReport(data.requestsCount);\n\n        _processExitRequestsList(data.data);\n\n        _storageDataProcessingState().value = DataProcessingState({\n            refSlot: data.refSlot.toUint64(),\n            requestsCount: data.requestsCount.toUint64(),\n            requestsProcessed: data.requestsCount.toUint64(),\n            dataFormat: uint16(DATA_FORMAT_LIST)\n        });\n\n        if (data.requestsCount == 0) {\n            return;\n        }\n\n        TOTAL_REQUESTS_PROCESSED_POSITION.setStorageUint256(\n            TOTAL_REQUESTS_PROCESSED_POSITION.getStorageUint256() + data.requestsCount\n        );\n    }\n\n    function _storeOracleExitRequestHash(bytes32 exitRequestsHash, uint256 contractVersion) internal {\n        _storeOracleNewHashRequestStatus(exitRequestsHash, uint32(contractVersion), uint32(_getTime()));\n    }\n\n    ///\n    /// Storage helpers\n    ///\n\n    struct StorageDataProcessingState {\n        DataProcessingState value;\n    }\n\n    function _storageDataProcessingState() internal pure returns (StorageDataProcessingState storage r) {\n        bytes32 position = DATA_PROCESSING_STATE_POSITION;\n        assembly {\n            r.slot := position\n        }\n    }\n}\n"
    }
}