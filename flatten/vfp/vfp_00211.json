{
    "vfp_id": "vfp_00211",
    "project_name": "Fireblocks Gasless Contracts Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Limitation in Asset Transfer Capabilities During Contract Deployment in `GaslessFactory`",
            "description": "The `deploy` and `deployDeterministic` functions in the `GaslessFactory` contract are not marked as `payable`, which prevents users from sending native assets during contract deployment. This limitation stems from the lack of payable modifier on these functions, restricting the ability to initialize newly deployed contracts with a native asset balance. An attacker or user cannot exploit this directly, but it limits functionality for legitimate use cases where a contract must hold native assets upon creation. The impact is reduced flexibility and utility of the `GaslessFactory`, especially for contracts that require initial funding upon deployment.\n",
            "severity": "Low",
            "location": [
                "GaslessFactory.sol::deploy#108-138",
                "GaslessFactory.sol::deployDeterministic#161-177",
                "GaslessFactory.sol::postConfig"
            ],
            "files": [
                "fireblocks-smart-contracts/contracts/gasless-contracts/GaslessFactory.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Premature Event Emission in GaslessFactory's `_execute` Function",
            "description": "The `_execute` function in the `GaslessFactory` contract emits the `FunctionExecuted` event before the actual delegated call is executed. This incorrect ordering causes the event to log a result of zero regardless of the actual outcome of the function call, leading to inaccurate event logs. The root cause is improper sequence of operations within the function. Off-chain services relying on these events may be misled into believing a function call succeeded or failed incorrectly, which undermines trust and transparency. The impact is potential misinterpretation of transaction results by external systems, though it does not directly lead to fund loss or control overreach.\n",
            "severity": "Low",
            "location": [
                "GaslessFactory.sol::_execute#220-227"
            ],
            "files": [
                "fireblocks-smart-contracts/contracts/gasless-contracts/GaslessFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "GaslessFactory.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2024 Fireblocks <support@fireblocks.com>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity 0.8.20;\n\nimport {ERC2771Context} from \"@openzeppelin/contracts-v5/metatx/ERC2771Context.sol\";\nimport {Address} from \"@openzeppelin/contracts-v5/utils/Address.sol\";\nimport {Create2} from \"@openzeppelin/contracts-v5/utils/Create2.sol\";\nimport {Context} from \"@openzeppelin/contracts-v5/utils/Context.sol\";\nimport {Multicall} from \"@openzeppelin/contracts-v5/utils/Multicall.sol\";\nimport {LibErrors} from \"../library/Errors/LibErrors.sol\";\n\n/**\n * @title GaslessFactory\n * @author Fireblocks\n * @notice A factory contract that deploys contracts and executes functions on them.\n *\n * This contract serves as a factory designed to deploy contracts and execute post deployment functions on the deployed\n * contract. This unopinionated factory is capable of deploying any arbitrary bytecode and execute corresponding\n * post-deployment functions. This factory allows the deployment of contracts using the provided bytecode and inputs.\n *\n * @dev This factory contract supports both normal and deterministic deployments of contracts. The deployment process\n * accepts the contract bytecode and inputs, allowing for flexibility in creating various types of contracts.\n *\n * If a `postConfig` is provided, it is treated as a single unit of post-deployment configuration. The entire set of\n * `postConfig` must execute successfully; otherwise, the deployment will be considered a failure, and the contract\n * will not be deployed.\n *\n * This factory contract also offers the ability to deploy contracts deterministically using the `create2` opcode when\n * desired. This allows pre-computation of contract addresses. In cases where a set of `postConfig` exists, it is\n * executed immediately after deployment, and if any part of the `postConfig` instructions fail, the entire deployment\n * is reverted to maintain atomicity.\n *\n * @custom:security-contact support@fireblocks.com\n */\ncontract GaslessFactory is ERC2771Context, Multicall {\n\tusing Address for address;\n\t/// Events\n\n\t/**\n\t * @notice This event is logged  whenever a contract is deployed through the factory.\n\t * @param from The (indexed) address of the user that initiated the contract deployment request.\n\t * @param deployedAddress The (indexed) address of the deployed contract.\n\t * @param bytecodeHash The (indexed) hash of the bytecode of the deployed contract (without constructor inputs).\n\t * @param inputs The constructor inputs that were appended to the bytecode.\n\t * @param isDeterministic A boolean indicating whether the deployment was deterministic or not.\n\t * @param salt The salt used for the deployment.\n\t */\n\tevent ContractDeployed(\n\t\taddress indexed from,\n\t\taddress indexed deployedAddress,\n\t\tbytes32 indexed bytecodeHash,\n\t\tbytes inputs,\n\t\tbool isDeterministic,\n\t\tbytes32 salt\n\t);\n\n\t/**\n\t * @notice This event is logged whenever a function is executed on a deployed contract.\n\t * @param executor The (indexed) address of the user that executed the function.\n\t * @param target The (indexed) address of the contract on which the function was executed.\n\t * @param data The raw calldata that was passed to the function.\n\t * @param result The raw returned data from the function call.\n\t */\n\tevent FunctionExecuted(address indexed executor, address indexed target, bytes data, bytes result);\n\n\t/// Functions\n\n\t/**\n\t * @notice This function acts as the constructor of the contract.\n\t * @dev This function initializes the contract with the provided trusted forwarder.\n\t *\n\t * @param trustedForwarder_ The address of the trusted forwarder.\n\t */\n\tconstructor(address trustedForwarder_) ERC2771Context(trustedForwarder_) {}\n\n\t/**\n\t * @notice This function deploys a contract using the provided bytecode and inputs.\n\t * @dev Appends the inputs to the bytecode and deploys it using assembly. Executes post-deployment\n\t * configuration.\n\t *\n\t * Calling Conditions:\n\t *\n\t * - The bytecode must not be empty.\n\t *\n\t * This function emits a {ContractDeployed} event after a successful deployment.\n\t * This function might emit a {FunctionExecuted} event if a set of post-deployment configurations were provided and\n\t * executed successfully.\n\t *\n\t * @param bytecode The bytecode of the contract to be deployed.\n\t * @param inputs The constructor inputs to be appended to the bytecode.\n\t * @param postConfig A set of configurations to be executed after deployment.\n\t * @return deployedAddress The address of the deployed contract.\n\t * @return postConfigResults A list of raw returned data corresponding to each function call in the post-deployment\n\t */\n\tfunction deploy(\n\t\tbytes calldata bytecode,\n\t\tbytes calldata inputs,\n\t\tbytes[] calldata postConfig\n\t) external virtual returns (address deployedAddress, bytes[] memory postConfigResults) {\n\t\tif (bytecode.length == 0) {\n\t\t\trevert LibErrors.EmptyBytecode();\n\t\t}\n\t\tbytes memory finalCode = abi.encodePacked(bytecode, inputs);\n\n\t\tassembly (\"memory-safe\") {\n\t\t\tdeployedAddress := create(0, add(finalCode, 0x20), mload(finalCode))\n\n\t\t\tif and(iszero(deployedAddress), not(iszero(returndatasize()))) {\n\t\t\t\tlet returndata := mload(0x40)\n\t\t\t\treturndatacopy(returndata, 0, returndatasize())\n\t\t\t\trevert(returndata, returndatasize())\n\t\t\t}\n\t\t}\n\n\t\tif (deployedAddress == address(0)) {\n\t\t\trevert LibErrors.DeploymentFailed();\n\t\t}\n\t\temit ContractDeployed(_msgSender(), deployedAddress, bytes32(keccak256(bytecode)), inputs, false, bytes32(\"\"));\n\n\t\tpostConfigResults = new bytes[](postConfig.length);\n\t\t// Execute post-deployment configuration\n\t\tfor (uint256 i = 0; i < postConfig.length; i++) {\n\t\t\tpostConfigResults[i] = _execute(deployedAddress, postConfig[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice This function deploys a contract using the provided bytecode and inputs deterministically.\n\t * @dev Appends the inputs to the bytecode and deploys it using {Create2} library. Executes post-deployment\n\t * configuration.\n\t *\n\t * Calling Conditions:\n\t *\n\t * - The bytecode must not be empty (checked internally by {Create2}.{deploy}).\n\t *\n\t * This function emits a {ContractDeployed} event after a successful deployment.\n\t * This function might emit a {FunctionExecuted} event if a set of post-deployment configurations were provided and\n\t * executed successfully.\n\t *\n\t * @param bytecode The bytecode of the contract to be deployed.\n\t * @param inputs The constructor inputs to be appended to the bytecode.\n\t * @param postConfig A set of configurations to be executed after deployment.\n\t * @param salt The salt to be used for the deployment.\n\t * @return deployedAddress The address of the deployed contract.\n\t * @return postConfigResults A list of raw returned data corresponding to each function call in the post-deployment\n\t * configuration.\n\t */\n\tfunction deployDeterministic(\n\t\tbytes calldata bytecode,\n\t\tbytes calldata inputs,\n\t\tbytes[] calldata postConfig,\n\t\tbytes32 salt\n\t) external virtual returns (address deployedAddress, bytes[] memory postConfigResults) {\n\t\tbytes memory finalCode = abi.encodePacked(bytecode, inputs);\n\n\t\tdeployedAddress = Create2.deploy(0, salt, finalCode);\n\t\temit ContractDeployed(_msgSender(), deployedAddress, bytes32(keccak256(bytecode)), inputs, true, salt);\n\n\t\tpostConfigResults = new bytes[](postConfig.length);\n\t\t// Execute post-deployment configuration\n\t\tfor (uint256 i = 0; i < postConfig.length; i++) {\n\t\t\tpostConfigResults[i] = _execute(deployedAddress, postConfig[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice This function computes the address of a contract that would be deployed using the provided salt.\n\t * @dev Computes the address of the contract that would be deployed by making a call to\n\t * {Create2}.{computeAddress}\n\t *\n\t * Calling Conditions:\n\t *\n\t * - The bytecode must not be empty.\n\t *\n\t * @param salt The salt to be used for the deployment.\n\t * @param bytecode The bytecode of the contract to be deployed.\n\t * @param inputs The constructor inputs to be appended to the bytecode (if any).\n\t * @return address The computed address based on the provided parameters.\n\t */\n\tfunction computeAddress(\n\t\tbytes32 salt,\n\t\tbytes calldata bytecode,\n\t\tbytes calldata inputs\n\t) external view virtual returns (address) {\n\t\tif (bytecode.length == 0) {\n\t\t\trevert LibErrors.EmptyBytecode();\n\t\t}\n\t\tbytes memory finalCode = abi.encodePacked(bytecode, inputs);\n\t\treturn Create2.computeAddress(salt, keccak256(finalCode));\n\t}\n\n\t/**\n\t * @dev This function allows the factory to execute any function on any contract.\n\t *\n\t * Calling Conditions:\n\t *\n\t * - The call data must not be empty.\n\t *\n\t * This function emits a {FunctionExecuted} event after a successful execution.\n\t * Also note that the function does not check if the target address is zero or not as it is internal function and\n\t * the address is already validated in the public function after deployment.\n\t *\n\t * @param target The address of the contract on which the function will be executed.\n\t * @param data The function calldata that will be executed on the contract.\n\t * @return result The raw returned data from the function call.\n\t */\n\tfunction _execute(address target, bytes calldata data) internal virtual returns (bytes memory result) {\n\t\tif (data.length == 0) {\n\t\t\trevert LibErrors.EmptyCallData();\n\t\t}\n\n\t\temit FunctionExecuted(_msgSender(), target, data, result);\n\t\tresult = target.functionCall(data);\n\t}\n\n\t/**\n\t * @notice This function is used to retrieve the sender of the transaction.\n\t * @dev This function is an override of the logic provided by {Context} contract. Instead it uses the\n\t * {ERC2771Context}.{_msgSender} function to retrieve the sender.\n\t * @return The address of the sender.\n\t */\n\tfunction _msgSender() internal view virtual override(Context, ERC2771Context) returns (address) {\n\t\treturn super._msgSender();\n\t}\n\n\t/**\n\t * @notice This function is used to retrieve the data of the transaction.\n\t * @dev This function is an override of the logic provided by {Context} contract. Instead it uses the\n\t * {ERC2771Context}.{_msgData} function to retrieve the data.\n\t * @return The data of the transaction.\n\t */\n\tfunction _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {\n\t\treturn super._msgData();\n\t}\n\n\t/**\n\t * @notice This function is used to retrieve the suffix length of the context.\n\t * @dev This function is an override of the logic provided by {Context} contract. Instead it uses the\n\t * {ERC2771Context}.{_contextSuffixLength} function to retrieve the suffix length.\n\t * @return uint256 The suffix length of the context.\n\t */\n\tfunction _contextSuffixLength() internal view virtual override(Context, ERC2771Context) returns (uint256) {\n\t\treturn super._contextSuffixLength();\n\t}\n}\n"
    }
}