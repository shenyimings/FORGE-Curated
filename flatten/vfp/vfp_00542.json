{
    "vfp_id": "vfp_00542",
    "project_name": "Mitosis (May) - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "First depositor inflation attack via missing _decimalsOffset() override in ERC-4626 vault",
            "description": "The ERC-4626 vault implementation in EOLVault.sol and MatrixVault.sol does not override the _decimalsOffset() function, leaving it at the default value of 0. This makes the vault susceptible to a first-depositor attack where an attacker deposits a minimal amount (e.g., 1 wei), donates additional funds to the vault, and then causes subsequent depositors to receive zero shares due to precision loss in share calculation. The vulnerability arises because the convertToShares function uses a virtual supply of totalSupply() + 1 when decimalsOffset is 0, which creates an imbalance when multiple deposits occur in the same block. A block proposer or MEV bot can exploit this to steal value from other users by front-running deposits and redeeming disproportionate assets.\n",
            "severity": "High",
            "location": [
                "protocol/src/hub/EOLVault.sol",
                "protocol/src/hub/MatrixVault.sol"
            ],
            "files": [
                "f18b1965c3d5816e422edb206efe598f0fb39899/protocol/src/hub/eol/EOLVault.sol",
                "f18b1965c3d5816e422edb206efe598f0fb39899/protocol/src/hub/matrix/MatrixVault.sol"
            ]
        }
    ],
    "affected_files": {
        "EOLVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { ERC4626 } from '@solady/tokens/ERC4626.sol';\n\nimport { IERC20Metadata } from '@oz/interfaces/IERC20Metadata.sol';\nimport { ReentrancyGuardTransient } from '@oz/utils/ReentrancyGuardTransient.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\n\nimport { ERC7201Utils } from '../../lib/ERC7201Utils.sol';\nimport { Pausable } from '../../lib/Pausable.sol';\n\ncontract EOLVault is ERC4626, Ownable2StepUpgradeable, Pausable, ReentrancyGuardTransient {\n  using ERC7201Utils for string;\n\n  struct StorageV1 {\n    address asset;\n    string name;\n    string symbol;\n    uint8 decimals;\n  }\n\n  string private constant _NAMESPACE = 'mitosis.storage.EOLVault.v1';\n  bytes32 private immutable _slot = _NAMESPACE.storageSlot();\n\n  function _getStorageV1() internal view returns (StorageV1 storage $) {\n    bytes32 slot = _slot;\n    // slither-disable-next-line assembly\n    assembly {\n      $.slot := slot\n    }\n  }\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address owner_, IERC20Metadata asset_, string memory name_, string memory symbol_)\n    external\n    initializer\n  {\n    __Ownable2Step_init();\n    __Ownable_init(owner_);\n    __Pausable_init();\n\n    if (bytes(name_).length == 0 || bytes(symbol_).length == 0) {\n      name_ = string.concat('Mitosis EOL ', asset_.name());\n      symbol_ = string.concat('mi', asset_.symbol());\n    }\n\n    StorageV1 storage $ = _getStorageV1();\n    $.asset = address(asset_);\n    $.name = name_;\n    $.symbol = symbol_;\n\n    (bool success, uint8 result) = _tryGetAssetDecimals(address(asset_));\n    $.decimals = success ? result : _DEFAULT_UNDERLYING_DECIMALS;\n  }\n\n  function asset() public view override returns (address) {\n    return _getStorageV1().asset;\n  }\n\n  function name() public view override returns (string memory) {\n    return _getStorageV1().name;\n  }\n\n  function symbol() public view override returns (string memory) {\n    return _getStorageV1().symbol;\n  }\n\n  function _underlyingDecimals() internal view override returns (uint8) {\n    return _getStorageV1().decimals;\n  }\n\n  function deposit(uint256 assets, address receiver) public override nonReentrant whenNotPaused returns (uint256) {\n    return super.deposit(assets, receiver);\n  }\n\n  function mint(uint256 shares, address receiver) public override nonReentrant whenNotPaused returns (uint256) {\n    return super.mint(shares, receiver);\n  }\n\n  /// @dev There's no redeem period for EOL vaults for initial phase\n  function withdraw(uint256 assets, address receiver, address owner)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /// @dev There's no redeem period for EOL vaults for initial phase\n  function redeem(uint256 shares, address receiver, address owner)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  function _authorizePause(address) internal view override onlyOwner { }\n}\n",
        "MatrixVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { IERC20Metadata } from '@oz/interfaces/IERC20Metadata.sol';\nimport { Math } from '@oz/utils/math/Math.sol';\nimport { ReentrancyGuardTransient } from '@oz/utils/ReentrancyGuardTransient.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\n\nimport { ERC4626 } from '@solady/tokens/ERC4626.sol';\n\nimport { IMatrixVault } from '../../interfaces/hub/matrix/IMatrixVault.sol';\nimport { Pausable } from '../../lib/Pausable.sol';\nimport { StdError } from '../../lib/StdError.sol';\nimport { MatrixVaultStorageV1 } from './MatrixVaultStorageV1.sol';\n\n/**\n * @title MatrixVault\n * @notice Base implementation of an MatrixVault\n */\nabstract contract MatrixVault is\n  MatrixVaultStorageV1,\n  ERC4626,\n  Ownable2StepUpgradeable,\n  Pausable,\n  ReentrancyGuardTransient\n{\n  using Math for uint256;\n\n  function __MatrixVault_init(\n    address owner_,\n    address assetManager_,\n    IERC20Metadata asset_,\n    string memory name_,\n    string memory symbol_\n  ) internal {\n    __Ownable2Step_init();\n    __Ownable_init(owner_);\n    __Pausable_init();\n\n    if (bytes(name_).length == 0 || bytes(symbol_).length == 0) {\n      name_ = string.concat('Mitosis Matrix ', asset_.name());\n      symbol_ = string.concat('ma', asset_.symbol());\n    }\n\n    StorageV1 storage $ = _getStorageV1();\n    $.asset = address(asset_);\n    $.name = name_;\n    $.symbol = symbol_;\n\n    (bool success, uint8 result) = _tryGetAssetDecimals(address(asset_));\n    $.decimals = success ? result : _DEFAULT_UNDERLYING_DECIMALS;\n\n    _setAssetManager($, assetManager_);\n  }\n\n  function asset() public view override returns (address) {\n    return _getStorageV1().asset;\n  }\n\n  function name() public view override returns (string memory) {\n    return _getStorageV1().name;\n  }\n\n  function symbol() public view override returns (string memory) {\n    return _getStorageV1().symbol;\n  }\n\n  function _underlyingDecimals() internal view override returns (uint8) {\n    return _getStorageV1().decimals;\n  }\n\n  // Mutative functions\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    uint256 maxAssets = maxDeposit(receiver);\n    require(assets <= maxAssets, DepositMoreThanMax());\n\n    uint256 shares = previewDeposit(assets);\n    _deposit(_msgSender(), receiver, assets, shares);\n\n    return shares;\n  }\n\n  function mint(uint256 shares, address receiver) public virtual override nonReentrant whenNotPaused returns (uint256) {\n    uint256 maxShares = maxMint(receiver);\n    require(shares <= maxShares, MintMoreThanMax());\n\n    uint256 assets = previewMint(shares);\n    _deposit(_msgSender(), receiver, assets, shares);\n\n    return assets;\n  }\n\n  function withdraw(uint256 assets, address receiver, address owner)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyReclaimQueue($);\n\n    uint256 maxAssets = maxWithdraw(owner);\n    require(assets <= maxAssets, WithdrawMoreThanMax());\n\n    uint256 shares = previewWithdraw(assets);\n    _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n    return shares;\n  }\n\n  function redeem(uint256 shares, address receiver, address owner)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyReclaimQueue($);\n\n    uint256 maxShares = maxRedeem(owner);\n    require(shares <= maxShares, RedeemMoreThanMax());\n\n    uint256 assets = previewRedeem(shares);\n    _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n    return assets;\n  }\n\n  // general overrides\n\n  function _authorizePause(address) internal view override onlyOwner { }\n}\n"
    }
}