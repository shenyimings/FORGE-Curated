{
    "vfp_id": "vfp_00458",
    "project_name": "ackee-blockchain-let's-get-hai-new-core-features-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "User can claim all rewards, that StakingManager received from RewardPool",
            "description": "The StakingManager contract uses a reward accounting mechanism based on the `rewardIntegralFor` mapping to track per-user reward integrals. However, this mapping is only updated when users check their rewards via the `earned` function, not when they claim rewards via `getReward`. As a result, after claiming rewards, the integral remains unchanged, allowing a malicious user to repeatedly call `getReward` and drain all accumulated rewards from the StakingManager. This flaw stems from incorrect state management in the reward claiming logic. An attacker can exploit this by staking a minimal amount and repeatedly calling `getReward` after rewards are distributed, thereby claiming all available rewards before other legitimate stakers can claim theirs. The impact is severe, leading to complete loss of distributed rewards for honest users and undermining the fairness and integrity of the staking system.\n",
            "severity": "Critical",
            "location": [
                "StakingManager.sol::getReward",
                "StakingManager.sol::earned"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "User can inflate number of rewards by staking additional amount of rewards right before claiming them",
            "description": "The `StakingManager.sol` contract calculates rewards using the `rewardIntegral` and `rewardIntegralFor` variables, but it fails to update the `rewardIntegralFor` mapping before modifying the user's staked balance during stake or withdraw operations. This allows a user to manipulate the reward calculation by staking additional tokens just before claiming rewards. The root cause is incorrect ordering of operations in the reward calculation logic. An attacker can exploit this by staking a large amount of tokens right before claiming, thereby inflating their reward integral and receiving disproportionately high rewards. The impact is significant, as it can lead to substantial reward token inflation and financial loss for the protocol.\n",
            "severity": "Critical",
            "location": [
                "StakingManager.sol::stake",
                "StakingManager.sol::withdraw"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Front-running RewardDistributor.updateMerkleRoots allows double claim",
            "description": "The `updateMerkleRoots` function in the RewardDistributor contract does not prevent front-running attacks because it updates the active Merkle root without any safeguards. Since the contract maintains only one active root at a time, a malicious user can monitor the mempool for an upcoming root update transaction and front-run it by claiming rewards from the old root, then immediately claim again from the new root once the update is confirmed. This double claim is possible due to the lack of access control or pausing mechanism during root updates, despite such functionality existing in the contract. The root cause is the absence of a required pause-unpause procedure around root updates, despite such functionality existing in the contract. An attacker with sufficient capital and MEV infrastructure can exploit this by timing their claims around root updates, potentially draining the contract of funds and preventing other users from claiming their rightful rewards if the balance is exhausted. The impact includes financial loss and disruption of fair reward distribution.\n",
            "severity": "High",
            "location": [
                "RewardDistributor.sol::updateMerkleRoots",
                "RewardDistributor.sol::multiClaim"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "RewardPool._totalStaked variable updates incorrectly",
            "description": "The RewardPool contract maintains a _totalStaked variable to track the total amount of staked tokens in the StakingManager contract. This variable is updated when StakingManager stakes or withdraws tokens via the stake, increaseStake, and decreaseStake functions. However, when a new RewardPool contract connects to StakingManager after tokens are already staked, the _totalStaked variable in the new pool starts at zero and does not reflect the correct total staked amount. This leads to two potential exploit scenarios: first, a user's withdrawal may revert due to an incorrect balance check (when _wad > _totalStaked), and second, users may receive zero rewards from the new pool because reward calculations depend on _totalStaked being accurate. The root cause is the lack of initialization of _totalStaked with the actual total supply from the StakingToken contract upon deployment. This results in incorrect state tracking and potential denial of service for withdrawals or incorrect reward distribution.\n",
            "severity": "Medium",
            "location": [
                "RewardPool.sol::stake#100-104",
                "RewardPool.sol::increaseStake#107-110",
                "RewardPool.sol::decreaseStake#114-119"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "stakeToken can be transferred to any other address while it is still assumed staked",
            "description": "The `StakingManager.sol` contract tracks staked balances using the `stakedBalances` mapping, but it does not update this mapping when a user transfers their `stakeToken`. This creates a logic flaw where a user can sell or transfer their staked tokens while still retaining their staked balance record. The root cause is the lack of integration between token transfer events and staking balance updates. An attacker could exploit this by staking tokens, transferring them to another address (e.g., via a DEX), and still claiming rewards based on the original staked amount. This could lead to reward inflation and unfair distribution, allowing malicious actors to collect more rewards than they are entitled to.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Miscalculation of rewardToken distribution after withdrawal initiation in StakingManager",
            "description": "When a user initiates a withdrawal, their tokens enter a cooldown period during which they should no longer earn rewards. However, the reward distribution calculation still includes the total supply of staking tokens, including those in cooldown. This causes an incorrect distribution where part of the reward pool is not allocated and remains stuck in the contract. The root cause is the failure to exclude tokens in the withdrawal process from the reward calculation. While the impact is partially mitigated by the `emergencyWithdrawReward` function, this flaw still leads to inefficient reward distribution and potential loss of rewards for honest users.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect reward calculation when reward token is the same as staking token",
            "description": "When the staking token (KITE) is also used as a reward token, the `StakingManager.sol` contract fails to distinguish between staked tokens and reward tokens in its accounting. This leads to an inflation of rewards because the reward calculation erroneously includes staked tokens in the reward pool. The root cause is the lack of separate accounting for staked and reward balances when the tokens are the same. An attacker can exploit this by staking tokens and then claiming rewards, receiving a much larger amount than deserved due to the flawed calculation. This results in unfair reward distribution and potential depletion of the reward pool.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Queued rewards in RewardPool can become stuck",
            "description": "The RewardPool contract includes a queueNewRewards function that can place rewards into a queuedRewards state when the new reward ratio is less than or equal to the calculated _queuedRatio. These queued rewards are only moved into active distribution when a subsequent call to queueNewRewards occurs with a higher ratio. If no such call is made after existing rewards are fully distributed, the queued rewards remain permanently stuck in the contract and are never distributed to users. The root cause is the absence of an automatic mechanism to release queued rewards when the current reward period ends or when the reward balance is depleted. This creates a dependency on external intervention to release funds, which may never happen, leading to permanent loss of reward funds for users. Although the team acknowledged this as intentional, it still represents a logic flaw that could result in user funds being locked indefinitely.\n",
            "severity": "Low",
            "location": [
                "RewardDistributor.sol::queueNewRewards#172-177"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "A user can received rewards after withdrawal process has been initiated",
            "description": "In the StakingManager contract, users can initiate a withdrawal using initiateWithdrawal, wait for the cooldown period, and then call withdraw to retrieve their tokens. However, the contract continues to accrue rewards for a user's staked balance even after the withdrawal has been initiated and the tokens are eligible for withdrawal. This allows a user to stake tokens, immediately initiate withdrawal, and continue earning rewards indefinitely while still being able to withdraw their principal at any time after the cooldown. The root cause is the lack of logic to pause or stop reward accrual upon initiation of the withdrawal process. This undermines the intended staking mechanism by allowing users to effectively earn rewards without maintaining long-term stake, potentially leading to unfair reward distribution and reduced economic security of the protocol.\n",
            "severity": "Low",
            "location": [
                "StakingManager.sol::initiateWithdrawal",
                "StakingManager.sol::withdraw"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Reward calculation state variables not updated in critical functions",
            "description": "The RewardPool contract uses several state variables—rewardPerTokenStored, lastUpdateTime, rewards, and rewardsPerTokenPaid—to calculate and distribute rewards accurately. However, these variables are not updated in the increaseStake and decreaseStake functions, which modify the staked balance and thus affect reward calculations. The root cause is the absence of the updateReward modifier on these functions, which is used elsewhere to synchronize reward state before balance changes. As a result, reward calculations may be based on outdated timestamps and reward rates, leading to incorrect or unfair reward distributions. This can cause users to receive less or more than their fair share of rewards, especially when stakes are increased or decreased between reward periods.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol::increaseStake#107-110",
                "RewardPool.sol::decreaseStake#114-119"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Potential underflow in math operations leads to unspecified errors",
            "description": "The RewardPool and StakingManager contracts contain arithmetic operations that are susceptible to underflow. In RewardPool, the expression `block.timestamp - (periodFinish - _params.duration)` can underflow if `block.timestamp + _params.duration < periodFinish`, which could occur if duration is decreased too much. In StakingManager, the line `stakedBalances[msg.sender] -= _wad` can underflow if `_wad` exceeds the user's balance during a withdrawal. The root cause is the lack of input validation and safe math checks before performing subtraction operations. Successful exploitation could lead to transaction reverts, denial of service, or in extreme cases, incorrect state updates if wrapped arithmetic is not enforced. This represents a data validation flaw that could disrupt normal contract operation.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol#168",
                "StakingManager.sol#143"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol",
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Unchecked return value of ERC20.transfer in RewardDistributor",
            "description": "The RewardDistributor contract calls ERC20.transfer in both the _claim and emergencyWithdraw functions but does not check the boolean return value. While most ERC-20 tokens revert on failure, some non-compliant tokens may return false instead of reverting. In such cases, the contract would proceed as if the transfer succeeded, emit a claim event, and mark the claim as completed, even though no tokens were transferred. This could result in permanent loss of user funds and prevent them from retrying the claim. The root cause is the lack of a return value check or use of a safe transfer library. Although a partial fix was implemented in _claim, the emergencyWithdraw function still lacks this check, leaving a critical function vulnerable.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::_claim",
                "RewardDistributor.sol::emergencyWithdraw"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emission for reward pool token staking",
            "description": "When users stake tokens through the StakingManager contract, the stake amount is distributed across active reward pools via internal calls to _rewardPool.stake(_wad). While the StakingManager emits a StakingManagerStaked event, it does not emit any event indicating which specific reward pools received the stake. This makes it difficult for off-chain services and users to track where their staked tokens are allocated. The root cause is the lack of an event emission after each _rewardPool.stake call. Although this does not affect on-chain functionality, it reduces transparency and complicates integration with external tools such as dashboards and analytics platforms.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol::stake",
                "StakingManager.sol#127-135"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol",
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "RewardDistributor._claim leaf is double hashed",
            "description": "In the RewardDistributor._claim function, the Merkle leaf is computed using double keccak256 hashing: `keccak256(bytes.concat(keccak256(abi.encode(...))))`. This is redundant because the Merkle proof verification only requires a single hash. The double hashing increases gas costs and requires off-chain systems to perform an extra hashing step, reducing computational efficiency. The root cause is unnecessary nesting of hash functions. While this does not introduce a security vulnerability, it represents a gas optimization and performance issue that could be improved by simplifying the leaf construction to a single hash.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::_claim#116"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "Magic numbers",
            "description": "The codebase contains multiple instances of magic numbers, such as 1e18 and 1000, used in calculations without explanatory context. For example, 1e18 is used as a fixed-point precision multiplier in reward calculations, and 1000 is used as a ratio multiplier in _queuedRatio. These values are not defined as named constants, making the code harder to read and maintain. The root cause is the direct use of numeric literals instead of symbolic constants. Although fixes were applied in later commits to replace 1e18 with WAD and 1000 with RATIO_MULTIPLIER, the initial code lacked this clarity, representing a code quality issue that could lead to errors during future modifications.\n",
            "severity": "Informational",
            "location": [
                "StakingManager.sol#335",
                "StakingManager.sol#351",
                "StakingManager.sol#367",
                "RewardPool.sol#150",
                "RewardPool.sol#155",
                "RewardPool.sol#170"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typos and missing documentation",
            "description": "The codebase contains several typos and documentation issues. Notably, the function emergencyWidthdraw in RewardDistributor contains a typo in its name and should be emergencyWithdraw. Additionally, the constructor parameter _cooldownPeriod is incorrectly documented as \"Address of the StakingToken contract\". Other issues include missing NatSpec documentation for struct fields, incorrect function names (e.g., authorizedAccounts instead of isAccountAuthorized), and missing source references in interface files. The root cause is insufficient code review and documentation hygiene. These issues reduce code readability and maintainability, and could mislead developers or auditors.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::emergencyWidthdraw",
                "StakingManager.sol#99",
                "Authorizable.sol::authorizedAccounts",
                "IStakingManager.sol::StakingManagerParams"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Code style inconsistencies",
            "description": "The codebase exhibits inconsistent style practices, such as unnecessary variable assignments (e.g., _uint256 = _data.toUint256()) when the value is used only once, and inconsistent use of curly braces for single-line if statements. Additionally, some _modifyParameters functions lack an else branch to revert on unrecognized parameters. The root cause is a lack of unified style guidelines across the team. While these do not affect functionality, they reduce code readability and maintainability. The issue was partially addressed by inlining variables in a later commit, but initial inconsistencies remained.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::_modifyParameters#130-136",
                "WrappedToken.sol::_modifyParameters#85",
                "StakingManager.sol::_modifyParameters#418-421"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused using-for directives",
            "description": "The RewardPool and AbstractVeloVaultRelayer contracts include `using Math for uint256` directives, but the Math library functions are not used in these contracts. Similarly, a `using SafeERC20 for IERC20` directive was added to RewardDistributor but not used. These unused directives clutter the code and may mislead developers into thinking the library functions are being utilized. The root cause is incomplete cleanup after refactoring. Although some were removed in commits, new unused directives were introduced due to architectural changes, indicating an ongoing code hygiene issue.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol#24",
                "AbstractVeloVaultRelayer.sol#15",
                "RewardDistributor.sol#23"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol",
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardPool.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {IRewardPool} from '@interfaces/tokens/IRewardPool.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\nimport {Math, RAY, WAD} from '@libraries/Math.sol';\n\n/**\n * @title  RewardPool\n * @notice This contract constitutes a reward pool for a given reward token\n */\ncontract RewardPool is Authorizable, Modifiable, IRewardPool {\n  using Encoding for bytes;\n  using Assertions for uint256;\n  using Assertions for address;\n  using Math for uint256;\n  using SafeERC20 for IERC20;\n\n  // --- Registry ---\n\n  /// @inheritdoc IRewardPool\n  IERC20 public rewardToken;\n\n  // --- Params ---\n\n  /// @inheritdoc IRewardPool\n  // solhint-disable-next-line private-vars-leading-underscore\n  RewardPoolParams public _params;\n\n  /// @inheritdoc IRewardPool\n  function params() external view returns (RewardPoolParams memory _rewardPoolParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  uint256 private _totalStaked;\n\n  /// @inheritdoc IRewardPool\n  function totalStaked() external view returns (uint256 _totalStakedAmt) {\n    return _totalStaked;\n  }\n\n  /// @inheritdoc IRewardPool\n  uint256 public rewardPerTokenStored;\n  /// @inheritdoc IRewardPool\n  uint256 public periodFinish = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewardRate = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public lastUpdateTime;\n  /// @inheritdoc IRewardPool\n  uint256 public queuedRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public currentRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public historicalRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewardPerTokenPaid = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewards = 0;\n\n  // --- Init ---\n\n  /**\n   * @param _rewardToken Address of the reward token\n   */\n  constructor(\n    address _rewardToken,\n    address _stakingManager,\n    uint256 _duration,\n    uint256 _newRewardRatio,\n    address _deployer\n  ) Authorizable(msg.sender) validParams {\n    if (_rewardToken == address(0)) revert RewardPool_InvalidRewardToken();\n    rewardToken = IERC20(_rewardToken);\n    _params.stakingManager = _stakingManager;\n    _params.duration = _duration;\n    _params.newRewardRatio = _newRewardRatio;\n    _addAuthorization(_deployer);\n    _addAuthorization(_stakingManager);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IRewardPool\n  function lastTimeRewardApplicable() public view returns (uint256 _lastTime) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  /// @inheritdoc IRewardPool\n  function stake(uint256 _wad) external updateReward isAuthorized {\n    if (_wad == 0) revert RewardPool_StakeNullAmount();\n    _totalStaked += _wad;\n    emit RewardPoolStaked(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function increaseStake(uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_IncreaseStakeNullAmount();\n    _totalStaked += _wad;\n    emit RewardPoolIncreaseStake(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function decreaseStake(uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_DecreaseStakeNullAmount();\n    if (_wad > _totalStaked) revert RewardPool_InsufficientBalance();\n    _totalStaked -= _wad;\n    emit RewardPoolDecreaseStake(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function withdraw(uint256 _wad, bool _claim) external updateReward isAuthorized {\n    if (_wad == 0) revert RewardPool_WithdrawNullAmount();\n    if (_wad > _totalStaked) revert RewardPool_InsufficientBalance();\n    if (_claim) {\n      _getReward();\n    }\n    _totalStaked -= _wad;\n    emit RewardPoolWithdrawn(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function getReward() external updateReward isAuthorized {\n    _getReward();\n  }\n\n  function _getReward() internal {\n    uint256 _reward = earned();\n    if (_reward > 0) {\n      rewards = 0;\n      rewardToken.safeTransfer(_params.stakingManager, _reward);\n      emit RewardPoolRewardPaid(_params.stakingManager, _reward);\n    }\n  }\n\n  /// @inheritdoc IRewardPool\n  function rewardPerToken() public view returns (uint256 _rewardPerToken) {\n    if (_totalStaked == 0) return rewardPerTokenStored;\n    uint256 _timeElapsed = lastTimeRewardApplicable() - lastUpdateTime;\n    return rewardPerTokenStored + ((_timeElapsed * rewardRate * 1e18) / _totalStaked);\n  }\n\n  /// @inheritdoc IRewardPool\n  function earned() public view returns (uint256 _earned) {\n    return ((_totalStaked * (rewardPerToken() - rewardPerTokenPaid)) / 1e18) + rewards;\n  }\n\n  /// @inheritdoc IRewardPool\n  function queueNewRewards(uint256 _rewardsToQueue) external isAuthorized {\n    uint256 _totalRewards = _rewardsToQueue + queuedRewards;\n\n    if (block.timestamp >= periodFinish) {\n      notifyRewardAmount(_totalRewards);\n      queuedRewards = 0;\n      return;\n    }\n\n    uint256 _elapsedTime = block.timestamp - (periodFinish - _params.duration);\n    uint256 _currentAtNow = rewardRate * _elapsedTime;\n    uint256 _queuedRatio = (_currentAtNow * 1000) / _totalRewards;\n\n    if (_queuedRatio < _params.newRewardRatio) {\n      notifyRewardAmount(_totalRewards);\n      queuedRewards = 0;\n    } else {\n      queuedRewards = _totalRewards;\n    }\n  }\n\n  /// @inheritdoc IRewardPool\n  function notifyRewardAmount(uint256 _reward) public updateReward isAuthorized {\n    if (_reward == 0) revert RewardPool_InvalidRewardAmount();\n    historicalRewards = historicalRewards + _reward;\n    if (block.timestamp >= periodFinish) {\n      rewardRate = _reward / _params.duration;\n    } else {\n      uint256 _remaining = periodFinish - block.timestamp;\n      uint256 _leftover = _remaining * rewardRate;\n      _reward = _reward + _leftover;\n      rewardRate = _reward / _params.duration;\n    }\n    currentRewards = _reward;\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp + _params.duration;\n    emit RewardPoolRewardAdded(_reward);\n  }\n\n  /// @inheritdoc IRewardPool\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_WithdrawNullAmount();\n    IERC20(rewardToken).safeTransfer(_rescueReceiver, _wad);\n    emit RewardPoolEmergencyWithdrawal(msg.sender, _wad);\n  }\n\n  function updateRewardHelper() public updateReward isAuthorized {\n    // Empty function that just applies the modifier\n  }\n\n  // --- Modifiers ---\n\n  modifier updateReward() {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (msg.sender == _params.stakingManager) {\n      rewards = earned();\n      rewardPerTokenPaid = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    if (_param == 'stakingManager') {\n      _params.stakingManager = _data.toAddress();\n    } else if (_param == 'duration') {\n      _params.duration = _data.toUint256();\n    } else if (_param == 'newRewardRatio') {\n      _params.newRewardRatio = _data.toUint256();\n    } else {\n      revert UnrecognizedParam();\n    }\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    _params.duration.assertNonNull().assertGt(0);\n    _params.newRewardRatio.assertNonNull().assertGt(0);\n    address(_params.stakingManager).assertHasCode();\n  }\n}\n",
        "RewardDistributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport {Pausable} from '@openzeppelin/contracts/utils/Pausable.sol';\n\nimport {IRewardDistributor} from '@interfaces/tokens/IRewardDistributor.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\n/**\n * @title  RewardDistributor\n * @notice This contract distributes rewards to users to claim every 24 hours\n */\n\ncontract RewardDistributor is Authorizable, Modifiable, Pausable, IRewardDistributor {\n  using Encoding for bytes;\n\n  // --- Data ---\n\n  /// @inheritdoc IRewardDistributor\n  uint256 public epochCounter;\n  /// @inheritdoc IRewardDistributor\n  uint256 public epochDuration;\n  /// @inheritdoc IRewardDistributor\n  uint256 public lastUpdatedTime;\n  /// @inheritdoc IRewardDistributor\n  address public rootSetter;\n\n  /// @inheritdoc IRewardDistributor\n  mapping(address _token => bytes32 _root) public merkleRoots;\n  /// @inheritdoc IRewardDistributor\n  mapping(bytes32 _root => mapping(address _account => bool _hasClaimed)) public isClaimed;\n\n  // --- Init ---\n  constructor(uint256 _epochDuration, address _rootSetter) Authorizable(msg.sender) {\n    epochDuration = _epochDuration;\n    epochCounter = 0;\n    rootSetter = _rootSetter;\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IRewardDistributor\n  function pause() external isAuthorized {\n    _pause();\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function unpause() external isAuthorized {\n    _unpause();\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function updateMerkleRoots(address[] calldata _tokens, bytes32[] calldata _merkleRoots) external {\n    if (block.timestamp - lastUpdatedTime < epochDuration) {\n      revert RewardDistributor_TooSoonEpochNotElapsed();\n    }\n    if (msg.sender != rootSetter) revert RewardDistributor_NotRootSetter();\n    if (_tokens.length != _merkleRoots.length) {\n      revert RewardDistributor_ArrayLengthsMustMatch();\n    }\n\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n      if (_tokens[_i] == address(0)) {\n        revert RewardDistributor_InvalidTokenAddress();\n      }\n      if (_merkleRoots[_i] == bytes32(0)) {\n        revert RewardDistributor_InvalidMerkleRoot();\n      }\n      merkleRoots[_tokens[_i]] = _merkleRoots[_i];\n      emit RewardDistributorMerkleRootUpdated(_tokens[_i], _merkleRoots[_i], epochCounter);\n    }\n    lastUpdatedTime = block.timestamp;\n    epochCounter++;\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function claim(address _token, uint256 _wad, bytes32[] calldata _merkleProof) external whenNotPaused {\n    _claim(_token, _wad, _merkleProof);\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function multiClaim(\n    address[] calldata _tokens,\n    uint256[] calldata _wads,\n    bytes32[][] calldata _merkleProofs\n  ) external whenNotPaused {\n    if (_tokens.length != _wads.length || _wads.length != _merkleProofs.length) {\n      revert RewardDistributor_ArrayLengthsMustMatch();\n    }\n\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n      _claim(_tokens[_i], _wads[_i], _merkleProofs[_i]);\n    }\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function emergencyWidthdraw(address _rescueReceiver, address _token, uint256 _wad) external isAuthorized {\n    if (_token == address(0)) {\n      revert RewardDistributor_InvalidTokenAddress();\n    }\n    if (_wad == 0) revert RewardDistributor_InvalidAmount();\n    IERC20(_token).transfer(_rescueReceiver, _wad);\n    emit RewardDistributorEmergencyWithdrawal(_rescueReceiver, _token, _wad);\n  }\n\n  function _claim(address _token, uint256 _wad, bytes32[] calldata _merkleProof) internal {\n    if (isClaimed[merkleRoots[_token]][msg.sender]) {\n      revert RewardDistributor_AlreadyClaimed();\n    }\n\n    bytes32 _leaf = keccak256(bytes.concat(keccak256(abi.encode(address(msg.sender), _wad))));\n\n    if (MerkleProof.verify(_merkleProof, merkleRoots[_token], _leaf)) {\n      isClaimed[merkleRoots[_token]][msg.sender] = true;\n      IERC20(_token).transfer(msg.sender, _wad);\n      emit RewardDistributorRewardClaimed(msg.sender, _token, _wad);\n    } else {\n      revert RewardDistributor_InvalidMerkleProof();\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    address _address = _data.toAddress();\n\n    if (_param == 'epochDuration') epochDuration = _uint256;\n    else if (_param == 'rootSetter') rootSetter = _address;\n    else revert UnrecognizedParam();\n  }\n}\n",
        "StakingManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {IProtocolToken} from '@interfaces/tokens/IProtocolToken.sol';\nimport {IStakingToken} from '@interfaces/tokens/IStakingToken.sol';\n\nimport {IRewardPool} from '@interfaces/tokens/IRewardPool.sol';\n\nimport {IStakingManager} from '@interfaces/tokens/IStakingManager.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\n/**\n * @title  StakingManager\n * @notice This contract is used to manage staking positions\n *         and to distribute staking rewards\n */\ncontract StakingManager is Authorizable, Modifiable, IStakingManager {\n  using Encoding for bytes;\n  using Assertions for uint256;\n  using Assertions for address;\n  using SafeERC20 for IProtocolToken;\n  using SafeERC20 for IERC20;\n\n  // --- Registry ---\n\n  /// @inheritdoc IStakingManager\n  IProtocolToken public protocolToken;\n\n  /// @inheritdoc IStakingManager\n  IStakingToken public stakingToken;\n\n  // --- Params ---\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  StakingManagerParams public _params;\n\n  /// @inheritdoc IStakingManager\n  function params() external view returns (StakingManagerParams memory _stakingManagerParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IStakingManager\n  mapping(address => uint256) public stakedBalances;\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  mapping(address _account => PendingWithdrawal) public _pendingWithdrawals;\n\n  /// @inheritdoc IStakingManager\n  function pendingWithdrawals(address _account) external view returns (PendingWithdrawal memory _pendingWithdrawal) {\n    return _pendingWithdrawals[_account];\n  }\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  mapping(uint256 _id => RewardType) public _rewardTypes;\n\n  /// @inheritdoc IStakingManager\n  function rewardTypes(uint256 _id) external view returns (RewardTypeInfo memory _rewardTypeInfo) {\n    RewardType storage _rewardType = _rewardTypes[_id];\n    return RewardTypeInfo({\n      rewardToken: _rewardType.rewardToken,\n      rewardPool: _rewardType.rewardPool,\n      isActive: _rewardType.isActive,\n      rewardIntegral: _rewardType.rewardIntegral,\n      rewardRemaining: _rewardType.rewardRemaining\n    });\n  }\n\n  /// @inheritdoc IStakingManager\n  function rewardIntegralFor(uint256 _id, address _user) external view returns (uint256 _rewardIntegral) {\n    return _rewardTypes[_id].rewardIntegralFor[_user];\n  }\n\n  /// @inheritdoc IStakingManager\n  function claimableReward(uint256 _id, address _user) external view returns (uint256 _claimableReward) {\n    return _rewardTypes[_id].claimableReward[_user];\n  }\n\n  /// @inheritdoc IStakingManager\n  uint256 public rewards;\n\n  // --- Init ---\n\n  /**\n   * @param  _protocolToken Address of the ProtocolToken contract\n   * @param  _stakingToken Address of the StakingToken contract\n   * @param  _cooldownPeriod Address of the StakingToken contract\n   */\n  constructor(\n    address _protocolToken,\n    address _stakingToken,\n    uint256 _cooldownPeriod\n  ) Authorizable(msg.sender) validParams {\n    stakingToken = IStakingToken(_stakingToken);\n    protocolToken = IProtocolToken(_protocolToken);\n    _params.cooldownPeriod = _cooldownPeriod;\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IStakingManager\n  function stake(address _account, uint256 _wad) external {\n    if (_account == address(0)) revert StakingManager_StakeNullReceiver();\n    if (_wad == 0) revert StakingManager_StakeNullAmount();\n\n    stakedBalances[_account] += _wad;\n\n    // Mint stKITE\n    stakingToken.mint(_account, _wad);\n\n    // transfer KITE\n    protocolToken.safeTransferFrom(msg.sender, address(this), _wad);\n\n    // Call stake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.stake(_wad);\n      }\n    }\n\n    emit StakingManagerStaked(_account, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function initiateWithdrawal(uint256 _wad) external {\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n    stakedBalances[msg.sender] -= _wad;\n\n    if (_existingWithdrawal.amount != 0) {\n      _existingWithdrawal.amount += _wad;\n      _existingWithdrawal.timestamp = block.timestamp;\n    } else {\n      _pendingWithdrawals[msg.sender] = PendingWithdrawal({amount: _wad, timestamp: block.timestamp});\n    }\n\n    // Call decreaseStake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.decreaseStake(_wad);\n      }\n    }\n\n    emit StakingManagerWithdrawalInitiated(msg.sender, _wad);\n  }\n  /// @inheritdoc IStakingManager\n\n  function cancelWithdrawal() external {\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n\n    if (_existingWithdrawal.amount == 0) {\n      revert StakingManager_NoPendingWithdrawal();\n    }\n\n    uint256 _withdrawalAmount = _existingWithdrawal.amount; // Store the amount before deleting\n\n    delete _pendingWithdrawals[msg.sender];\n\n    stakedBalances[msg.sender] += _withdrawalAmount; // use stored amount\n\n    // Call increaseStake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.increaseStake(_withdrawalAmount);\n      }\n    }\n\n    emit StakingManagerWithdrawalCancelled(msg.sender, _withdrawalAmount);\n  }\n\n  /// @inheritdoc IStakingManager\n  function withdraw() external {\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n\n    if (_existingWithdrawal.amount == 0) {\n      revert StakingManager_NoPendingWithdrawal();\n    }\n\n    if (block.timestamp - _existingWithdrawal.timestamp < _params.cooldownPeriod) {\n      revert StakingManager_CooldownPeriodNotElapsed();\n    }\n\n    uint256 _withdrawalAmount = _existingWithdrawal.amount; // Store amount first\n\n    delete _pendingWithdrawals[msg.sender];\n\n    stakingToken.burnFrom(msg.sender, _withdrawalAmount);\n\n    protocolToken.safeTransfer(msg.sender, _withdrawalAmount);\n\n    emit StakingManagerWithdrawn(msg.sender, _withdrawalAmount);\n  }\n\n  /// @inheritdoc IStakingManager\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    protocolToken.safeTransfer(_rescueReceiver, _wad);\n\n    emit StakingManagerEmergencyWithdrawal(_rescueReceiver, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function emergencyWithdrawReward(uint256 _id, address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    IERC20(_rewardTypes[_id].rewardToken).safeTransfer(_rescueReceiver, _wad);\n\n    // protocolToken.safeTransfer(_rescueReceiver, _wad);\n\n    emit StakingManagerEmergencyRewardWithdrawal(_rescueReceiver, _rewardTypes[_id].rewardToken, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function getReward(address _account) external {\n    _checkpointAndClaim([_account, _account]);\n  }\n\n  /// @inheritdoc IStakingManager\n  function getRewardAndForward(address _account, address _forwardTo) external {\n    if (msg.sender != _account) revert StakingManager_ForwardingOnly();\n\n    _checkpointAndClaim([_account, _forwardTo]);\n  }\n\n  /// @inheritdoc IStakingManager\n  function addRewardType(address _rewardToken, address _rewardPool) external isAuthorized {\n    if (_rewardToken == address(0)) revert StakingManager_NullRewardToken();\n    if (_rewardPool == address(0)) revert StakingManager_NullRewardPool();\n\n    uint256 _id = rewards;\n    rewards++;\n\n    RewardType storage _rewardType = _rewardTypes[_id];\n    _rewardType.rewardToken = _rewardToken;\n    _rewardType.rewardPool = _rewardPool;\n    _rewardType.isActive = true;\n    _rewardType.rewardIntegral = 0;\n    _rewardType.rewardRemaining = 0;\n\n    emit StakingManagerAddRewardType(_id, _rewardToken, _rewardPool);\n  }\n\n  /// @inheritdoc IStakingManager\n  function activateRewardType(uint256 _id) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    _rewardTypes[_id].isActive = true;\n    emit StakingManagerActivateRewardType(_id);\n  }\n\n  /// @inheritdoc IStakingManager\n  function deactivateRewardType(uint256 _id) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    _rewardTypes[_id].isActive = false;\n    emit StakingManagerDeactivateRewardType(_id);\n  }\n\n  /// @inheritdoc IStakingManager\n  function earned(address _account) external returns (EarnedData[] memory _claimable) {\n    _checkpoint([_account, address(0)]);\n    return _earned(_account);\n  }\n\n  /// @inheritdoc IStakingManager\n  function checkpoint(address[2] memory _accounts) external {\n    _checkpoint(_accounts);\n  }\n\n  /// @inheritdoc IStakingManager\n  function userCheckpoint(address _account) external {\n    _checkpoint([_account, address(0)]);\n  }\n\n  function _earned(address _account) internal view returns (EarnedData[] memory _claimable) {\n    _claimable = new EarnedData[](rewards);\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n\n      if (_rewardType.rewardToken == address(0)) {\n        continue;\n      }\n\n      _claimable[_i].rewardToken = _rewardType.rewardToken;\n      _claimable[_i].rewardAmount = _rewardType.claimableReward[_account];\n    }\n    return _claimable;\n  }\n\n  // TODO: Check decimals\n  function _calcRewardIntegral(\n    uint256 _id,\n    address[2] memory _accounts,\n    uint256[2] memory _balances,\n    uint256 _supply,\n    bool _isClaim\n  ) internal {\n    RewardType storage _rewardType = _rewardTypes[_id];\n\n    if (!_rewardType.isActive) return;\n\n    uint256 _balance = IERC20(_rewardType.rewardToken).balanceOf(address(this));\n\n    // Checks if new rewards have been added by comparing current balance with rewardRemaining\n    if (_balance > _rewardType.rewardRemaining) {\n      uint256 _newRewards = _balance - _rewardType.rewardRemaining;\n      // If there are new rewards and there are existing stakers\n      if (_supply > 0) {\n        _rewardType.rewardIntegral += (_newRewards * 1e18) / _supply;\n        _rewardType.rewardRemaining = _balance;\n      }\n    }\n\n    for (uint256 _i = 0; _i < _accounts.length; _i++) {\n      if (_accounts[_i] == address(0)) continue;\n      if (_isClaim && _i != 0) continue; //only update/claim for first address and use second as forwarding\n\n      uint256 _userBalance = _balances[_i];\n      uint256 _userIntegral = _rewardType.rewardIntegralFor[_accounts[_i]];\n\n      if (_isClaim || _userIntegral < _rewardType.rewardIntegral) {\n        if (_isClaim) {\n          // Calculate total receiveable rewards\n          uint256 _receiveable = _rewardType.claimableReward[_accounts[_i]]\n            + (_userBalance * (_rewardType.rewardIntegral - _userIntegral)) / 1e18;\n\n          if (_receiveable > 0) {\n            // Reset claimable rewards to 0\n            _rewardType.claimableReward[_accounts[_i]] = 0;\n\n            // Transfer rewards to the next address in the array (forwarding address)\n            IERC20(_rewardType.rewardToken).safeTransfer(_accounts[_i + 1], _receiveable);\n\n            emit StakingManagerRewardPaid(_accounts[_i], _rewardType.rewardToken, _receiveable, _accounts[_i + 1]);\n            // Update the remaining balance\n            _balance = _balance - _receiveable;\n          }\n        } else {\n          // Just accumulate rewards without claiming\n          _rewardType.claimableReward[_accounts[_i]] = _rewardType.claimableReward[_accounts[_i]]\n            + (_userBalance * (_rewardType.rewardIntegral - _userIntegral)) / 1e18;\n\n          // Update user's reward integral\n          _rewardType.rewardIntegralFor[_accounts[_i]] = _rewardType.rewardIntegral;\n        }\n      }\n    }\n\n    // Update remaining reward here since balance could have changed if claiming\n    if (_balance != _rewardType.rewardRemaining) {\n      _rewardType.rewardRemaining = uint256(_balance);\n    }\n  }\n\n  function _checkpoint(address[2] memory _accounts) internal {\n    uint256 _supply = stakingToken.totalSupply();\n    uint256[2] memory _depositedBalance;\n    _depositedBalance[0] = stakingToken.balanceOf(_accounts[0]);\n    _depositedBalance[1] = stakingToken.balanceOf(_accounts[1]);\n\n    _claimManagerRewards();\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      _calcRewardIntegral(_i, _accounts, _depositedBalance, _supply, false);\n    }\n  }\n\n  function _checkpointAndClaim(address[2] memory _accounts) internal {\n    uint256 _supply = stakingToken.totalSupply();\n    uint256[2] memory _depositedBalance;\n    _depositedBalance[0] = stakingToken.balanceOf(_accounts[0]); //only do first slot\n\n    _claimManagerRewards();\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      _calcRewardIntegral(_i, _accounts, _depositedBalance, _supply, true);\n    }\n  }\n\n  function _claimManagerRewards() internal {\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n      if (!_rewardType.isActive) continue;\n      _rewardPool.getReward();\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    if (_param == 'cooldownPeriod') _params.cooldownPeriod = _uint256;\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    _params.cooldownPeriod.assertNonNull().assertGt(0);\n    address(stakingToken).assertHasCode();\n    address(protocolToken).assertHasCode();\n  }\n}\n"
    }
}