{
    "vfp_id": "vfp_00458",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Documentation issues",
            "description": "Multiple contracts contain inaccurate or misleading documentation. In FallbackManager.sol, the comment claims the function returns 0 when no handler is set, but it actually returns empty bytes. In SignatureVerifierMuxer.sol, byte offset comments use hexadecimal prefixes for decimal values, leading to incorrect position descriptions. In MultiSendCallOnly.sol, a comment contains a typo (\"it right\" instead of \"right\"). Additionally, the changelog incorrectly attributes a function implementation to CompatibilityFallbackHandler when it is in the Safe contract. The root cause is inconsistent documentation practices and lack of review. These inaccuracies can mislead developers and auditors, increasing the risk of incorrect assumptions during integration or maintenance. The impact is informational, as these do not introduce direct security risks but affect code clarity and maintainability.\n",
            "severity": "Informational",
            "location": [
                "FallbackManager.sol",
                "SignatureVerifierMuxer.sol::isValidSignature",
                "MultiSendCallOnly.sol::multiSend",
                "MultiSend.sol::multiSend"
            ],
            "files": [
                "safe-smart-account/contracts/base/FallbackManager.sol",
                "safe-smart-account/contracts/handler/extensible/SignatureVerifierMuxer.sol",
                "safe-smart-account/contracts/libraries/MultiSendCallOnly.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Misleading event emissions",
            "description": "The _setSafeMethod function in ExtensibleBase.sol and the setDomainVerifier function in SignatureVerifierMuxer.sol emit events even when no actual state change occurs. Specifically, AddedSafeMethod and AddedDomainVerifier events are emitted when both old and new values are zero, and ChangedSafeMethod/ChangedDomainVerifier events are emitted when old and new values are identical. The root cause is the lack of value comparison before event emission. This can mislead off-chain indexers and monitoring tools into believing that a change has occurred when none has, potentially causing incorrect state reconstruction or false alerts. The impact is classified as Warning because it does not directly affect on-chain security but undermines the reliability of event-based tracking systems, which are critical for wallet and service integrations.\n",
            "severity": "Informational",
            "location": [
                "ExtensibleBase.sol::_setSafeMethod",
                "SignatureVerifierMuxer.sol::setDomainVerifier"
            ],
            "files": [
                "safe-smart-account/contracts/handler/extensible/ExtensibleBase.sol",
                "safe-smart-account/contracts/handler/extensible/SignatureVerifierMuxer.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "No view function for FallbackManager handler address",
            "description": "Unlike other manager contracts (GuardManager, ModuleManager, OwnerManager), FallbackManager.sol does not provide a public view function to read the stored fallback handler address. This breaks consistency in the codebase and forces external callers to use alternative methods (e.g., StorageAccessible interface) to access this data. The root cause is an omission in interface design. While the value can still be accessed, the lack of a dedicated getter reduces usability and developer experience. The impact is informational. The client acknowledged the finding but chose not to implement a fix, citing implementation complexity and alternative access methods.\n",
            "severity": "Informational",
            "location": [
                "FallbackManager.sol"
            ],
            "files": [
                "safe-smart-account/contracts/base/FallbackManager.sol"
            ]
        }
    ],
    "affected_files": {
        "FallbackManager.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IFallbackManager} from \"../interfaces/IFallbackManager.sol\";\n\n/**\n * @title Fallback Manager - A contract managing fallback calls made to this contract\n * @author Richard Meissner - @rmeissner\n */\nabstract contract FallbackManager is SelfAuthorized, IFallbackManager {\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    /**\n     *  @notice Internal function to set the fallback handler.\n     *  @param handler contract to handle fallback calls.\n     */\n    function internalSetFallbackHandler(address handler) internal {\n        /*\n            If a fallback handler is set to self, then the following attack vector is opened:\n            Imagine we have a function like this:\n            function withdraw() internal authorized {\n                withdrawalAddress.call.value(address(this).balance)(\"\");\n            }\n\n            If the fallback method is triggered, the fallback handler appends the msg.sender address to the calldata and calls the fallback handler.\n            A potential attacker could call a Safe with the 3 bytes signature of a withdraw function. Since 3 bytes do not create a valid signature,\n            the call would end in a fallback handler. Since it appends the msg.sender address to the calldata, the attacker could craft an address \n            where the first 3 bytes of the previous calldata + the first byte of the address make up a valid function signature. The subsequent call would result in unsanctioned access to Safe's internal protected methods.\n            For some reason, solidity matches the first 4 bytes of the calldata to a function signature, regardless if more data follow these 4 bytes.\n        */\n        if (handler == address(this)) revertWithError(\"GS400\");\n\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @inheritdoc IFallbackManager\n     */\n    function setFallbackHandler(address handler) public override authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // @notice Forwards all calls to the fallback handler if set. Returns 0 if no handler is set.\n    // @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\n    //      The handler can make use of `HandlerContext.sol` to extract the address.\n    //      This is done because in the next call frame the `msg.sender` will be FallbackManager's address\n    //      and having the original caller address may enable additional verification scenarios.\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // When compiled with the optimizer, the compiler relies on certain assumptions on how the\n            // memory is used, therefore we need to guarantee memory safety (keeping the free memory point 0x40 slot intact,\n            // not going beyond the scratch space, etc)\n            // Solidity docs: https://docs.soliditylang.org/en/latest/assembly.html#memory-safety\n\n            let handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n\n            if iszero(handler) {\n                return(0, 0)\n            }\n\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(add(ptr, calldatasize()), shl(96, caller()))\n\n            // Add 20 bytes for the address appended at the end\n            let success := call(gas(), handler, 0, ptr, add(calldatasize(), 20), 0, 0)\n\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n            return(ptr, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n",
        "MultiSendCallOnly.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Multi Send Call Only - Allows to batch multiple transactions into one, but only calls\n * @notice The guard logic is not required here as this contract doesn't support nested delegate calls\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract MultiSendCallOnly {\n    /**\n     * @dev Sends multiple transactions and reverts all if one fails.\n     * @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n     *                     operation has to be uint8(0) in this version (=> 1 byte),\n     *                     to as a address (=> 20 bytes),\n     *                     value as a uint256 (=> 32 bytes),\n     *                     data length as a uint256 (=> 32 bytes),\n     *                     data as bytes.\n     *                     see abi.encodePacked for more information on packed encoding\n     * @notice The code is for the most part the same as the normal MultiSend (to keep compatibility),\n     *         but reverts if a transaction tries to use a delegatecall.\n     * @notice This method is payable as delegatecalls keep the msg.value from the previous call\n     *         If the calling method (e.g. execTransaction) received ETH this would revert otherwise\n     */\n    function multiSend(bytes memory transactions) public payable {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // Defaults `to` to `address(this)` if `address(0)` is provided.\n                to := or(to, mul(iszero(to), address()))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 {\n                    success := call(gas(), to, value, data, dataLength, 0, 0)\n                }\n                // This version does not allow delegatecalls\n                case 1 {\n                    revert(0, 0)\n                }\n                if iszero(success) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n",
        "SignatureVerifierMuxer.sol": "// SPDX-License-Identifier: LGPL-3.0-only\n// solhint-disable one-contract-per-file\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ISafe, ExtensibleBase} from \"./ExtensibleBase.sol\";\n\ninterface ERC1271 {\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n\n/**\n * @title Safe Signature Verifier Interface\n * @author mfw78 <mfw78@rndlabs.xyz>\n * @notice This interface provides a standard for external contracts that verify signatures\n *         for a Safe.\n */\ninterface ISafeSignatureVerifier {\n    /**\n     * @dev If called by `SignatureVerifierMuxer`, the following has already been checked:\n     *      _hash = h(abi.encodePacked(\"\\x19\\x01\", domainSeparator, h(typeHash || encodeData)));\n     * @param safe The Safe that has delegated the signature verification\n     * @param sender The address that originally called the Safe's `isValidSignature` method\n     * @param _hash The EIP-712 hash whose signature will be verified\n     * @param domainSeparator The EIP-712 domainSeparator\n     * @param typeHash The EIP-712 typeHash\n     * @param encodeData The EIP-712 encoded data\n     * @param payload An arbitrary payload that can be used to pass additional data to the verifier\n     * @return magic The magic value that should be returned if the signature is valid (0x1626ba7e)\n     */\n    function isValidSafeSignature(\n        ISafe safe,\n        address sender,\n        bytes32 _hash,\n        bytes32 domainSeparator,\n        bytes32 typeHash,\n        bytes calldata encodeData,\n        bytes calldata payload\n    ) external view returns (bytes4 magic);\n}\n\ninterface ISignatureVerifierMuxer {\n    function domainVerifiers(ISafe safe, bytes32 domainSeparator) external view returns (ISafeSignatureVerifier);\n\n    function setDomainVerifier(bytes32 domainSeparator, ISafeSignatureVerifier verifier) external;\n}\n\n/**\n * @title ERC-1271 Signature Verifier Multiplexer (Muxer)\n * @author mfw78 <mfw78@rndlabs.xyz>\n * @notice Allows delegating EIP-712 domains to an arbitrary `ISafeSignatureVerifier`\n * @dev This multiplexer enforces a strict authorisation per domainSeparator. This is to prevent a malicious\n *     `ISafeSignatureVerifier` from being able to verify signatures for any domainSeparator. This does not prevent\n *      an `ISafeSignatureVerifier` from being able to verify signatures for multiple domainSeparators, however\n *      each domainSeparator requires specific approval by Safe.\n */\nabstract contract SignatureVerifierMuxer is ExtensibleBase, ERC1271, ISignatureVerifierMuxer {\n    // --- constants ---\n    // keccak256(\"SafeMessage(bytes message)\");\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n    // keccak256(\"safeSignature(bytes32,bytes32,bytes,bytes)\");\n    bytes4 private constant SAFE_SIGNATURE_MAGIC_VALUE = 0x5fd7e97d;\n\n    // --- storage ---\n    mapping(ISafe => mapping(bytes32 => ISafeSignatureVerifier)) public override domainVerifiers;\n\n    // --- events ---\n    event AddedDomainVerifier(ISafe indexed safe, bytes32 domainSeparator, ISafeSignatureVerifier verifier);\n    event ChangedDomainVerifier(\n        ISafe indexed safe,\n        bytes32 domainSeparator,\n        ISafeSignatureVerifier oldVerifier,\n        ISafeSignatureVerifier newVerifier\n    );\n    event RemovedDomainVerifier(ISafe indexed safe, bytes32 domainSeparator);\n\n    /**\n     * Setter for the signature muxer\n     * @param domainSeparator The domainSeparator authorised for the `ISafeSignatureVerifier`\n     * @param newVerifier A contract that implements `ISafeSignatureVerifier`\n     */\n    function setDomainVerifier(bytes32 domainSeparator, ISafeSignatureVerifier newVerifier) public override onlySelf {\n        ISafe safe = ISafe(payable(_msgSender()));\n        ISafeSignatureVerifier oldVerifier = domainVerifiers[safe][domainSeparator];\n        if (address(newVerifier) == address(0) && address(oldVerifier) != address(0)) {\n            delete domainVerifiers[safe][domainSeparator];\n            emit RemovedDomainVerifier(safe, domainSeparator);\n        } else {\n            domainVerifiers[safe][domainSeparator] = newVerifier;\n            if (address(oldVerifier) == address(0)) {\n                emit AddedDomainVerifier(safe, domainSeparator, newVerifier);\n            } else {\n                emit ChangedDomainVerifier(safe, domainSeparator, oldVerifier, newVerifier);\n            }\n        }\n    }\n\n    /**\n     * @notice Implements ERC1271 interface for smart contract EIP-712 signature validation\n     * @dev The signature format is the same as the one used by the Safe contract\n     * @param _hash Hash of the data that is signed\n     * @param signature The signature to be verified\n     * @return magic Standardised ERC1271 return value\n     */\n    function isValidSignature(bytes32 _hash, bytes calldata signature) external view override returns (bytes4 magic) {\n        (ISafe safe, address sender) = _getContext();\n\n        // Check if the signature is for an `ISafeSignatureVerifier` and if it is valid for the domain.\n        if (signature.length >= 4) {\n            bytes4 sigSelector;\n            /* solhint-disable no-inline-assembly */\n            /// @solidity memory-safe-assembly\n            assembly {\n                sigSelector := calldataload(signature.offset)\n            }\n            /* solhint-enable no-inline-assembly */\n\n            // Guard against short signatures that would cause abi.decode to revert.\n            if (sigSelector == SAFE_SIGNATURE_MAGIC_VALUE && signature.length >= 68) {\n                // Signature is for an `ISafeSignatureVerifier` - decode the signature.\n                // Layout of the `signature`:\n                // 0x00 to 0x04: selector\n                // 0x04 to 0x36: domainSeparator\n                // 0x36 to 0x68: typeHash\n                // 0x68 to 0x88: encodeData length\n                // 0x88 to 0x88 + encodeData length: encodeData\n                // 0x88 + encodeData length to 0x88 + encodeData length + 0x20: payload length\n                // 0x88 + encodeData length + 0x20 to end: payload\n                //\n                // Get the domainSeparator from the signature.\n                (bytes32 domainSeparator, bytes32 typeHash) = abi.decode(signature[4:68], (bytes32, bytes32));\n\n                ISafeSignatureVerifier verifier = domainVerifiers[safe][domainSeparator];\n                // Check if there is an `ISafeSignatureVerifier` for the domain.\n                if (address(verifier) != address(0)) {\n                    (, , bytes memory encodeData, bytes memory payload) = abi.decode(signature[4:], (bytes32, bytes32, bytes, bytes));\n\n                    // Check that the signature is valid for the domain.\n                    if (keccak256(EIP712.encodeMessageData(domainSeparator, typeHash, encodeData)) == _hash) {\n                        // Preserving the context, call the Safe's authorised `ISafeSignatureVerifier` to verify.\n                        return verifier.isValidSafeSignature(safe, sender, _hash, domainSeparator, typeHash, encodeData, payload);\n                    }\n                }\n            }\n        }\n\n        // domainVerifier doesn't exist or the signature is invalid for the domain - fall back to the default\n        return defaultIsValidSignature(safe, _hash, signature);\n    }\n\n    /**\n     * Default Safe signature validation (approved hashes/threshold signatures)\n     * @param safe The safe being asked to validate the signature\n     * @param _hash Hash of the data that is signed\n     * @param signature The signature to be verified\n     */\n    function defaultIsValidSignature(ISafe safe, bytes32 _hash, bytes memory signature) internal view returns (bytes4 magic) {\n        bytes memory messageData = EIP712.encodeMessageData(\n            safe.domainSeparator(),\n            SAFE_MSG_TYPEHASH,\n            abi.encode(keccak256(abi.encode(_hash)))\n        );\n        bytes32 messageHash = keccak256(messageData);\n        if (signature.length == 0) {\n            // approved hashes\n            require(safe.signedMessages(messageHash) != 0, \"Hash not approved\");\n        } else {\n            // threshold signatures\n            safe.checkSignatures(address(0), messageHash, signature);\n        }\n        magic = ERC1271.isValidSignature.selector;\n    }\n}\n\nlibrary EIP712 {\n    function encodeMessageData(bytes32 domainSeparator, bytes32 typeHash, bytes memory message) internal pure returns (bytes memory) {\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator, keccak256(abi.encodePacked(typeHash, message)));\n    }\n}\n",
        "ExtensibleBase.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ISafe} from \"../../interfaces/ISafe.sol\";\nimport {HandlerContext} from \"../HandlerContext.sol\";\nimport {MarshalLib} from \"./MarshalLib.sol\";\n\ninterface IFallbackMethod {\n    function handle(ISafe safe, address sender, uint256 value, bytes calldata data) external returns (bytes memory result);\n}\n\ninterface IStaticFallbackMethod {\n    function handle(ISafe safe, address sender, uint256 value, bytes calldata data) external view returns (bytes memory result);\n}\n\n/**\n * @title Base contract for Extensible Fallback Handlers\n * @dev This contract provides the base for storage and modifiers for extensible fallback handlers\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\nabstract contract ExtensibleBase is HandlerContext {\n    // --- events ---\n    event AddedSafeMethod(ISafe indexed safe, bytes4 selector, bytes32 method);\n    event ChangedSafeMethod(ISafe indexed safe, bytes4 selector, bytes32 oldMethod, bytes32 newMethod);\n    event RemovedSafeMethod(ISafe indexed safe, bytes4 selector);\n\n    // --- storage ---\n\n    // A mapping of Safe => selector => method\n    // The method is a bytes32 that is encoded as follows:\n    // - The first byte is 0x00 if the method is static and 0x01 if the method is not static\n    // - The last 20 bytes are the address of the handler contract\n    // The method is encoded / decoded using the MarshalLib\n    mapping(ISafe => mapping(bytes4 => bytes32)) public safeMethods;\n\n    // --- modifiers ---\n    modifier onlySelf() {\n        // Use the `HandlerContext._msgSender()` to get the caller of the fallback function\n        // Use the `HandlerContext._manager()` to get the manager, which should be the Safe\n        // Require that the caller is the Safe itself\n        require(_msgSender() == _manager(), \"only safe can call this method\");\n        _;\n    }\n\n    // --- internal ---\n\n    function _setSafeMethod(ISafe safe, bytes4 selector, bytes32 newMethod) internal {\n        (, address newHandler) = MarshalLib.decode(newMethod);\n        mapping(bytes4 => bytes32) storage safeMethod = safeMethods[safe];\n        bytes32 oldMethod = safeMethod[selector];\n        (, address oldHandler) = MarshalLib.decode(oldMethod);\n\n        if (address(newHandler) == address(0) && address(oldHandler) != address(0)) {\n            delete safeMethod[selector];\n            emit RemovedSafeMethod(safe, selector);\n        } else {\n            safeMethod[selector] = newMethod;\n            if (address(oldHandler) == address(0)) {\n                emit AddedSafeMethod(safe, selector, newMethod);\n            } else {\n                emit ChangedSafeMethod(safe, selector, oldMethod, newMethod);\n            }\n        }\n    }\n\n    /**\n     * Dry code to get the Safe and the original `msg.sender` from the FallbackManager\n     * @return safe The safe whose FallbackManager is making this call\n     * @return sender The original `msg.sender` (as received by the FallbackManager)\n     */\n    function _getContext() internal view returns (ISafe safe, address sender) {\n        safe = ISafe(payable(_manager()));\n        sender = _msgSender();\n    }\n\n    /**\n     * Get the context and the method handler applicable to the current call\n     * @return safe The safe whose FallbackManager is making this call\n     * @return sender The original `msg.sender` (as received by the FallbackManager)\n     * @return isStatic Whether the method is static (`view`) or not\n     * @return handler the address of the handler contract\n     */\n    function _getContextAndHandler() internal view returns (ISafe safe, address sender, bool isStatic, address handler) {\n        (safe, sender) = _getContext();\n        (isStatic, handler) = MarshalLib.decode(safeMethods[safe][msg.sig]);\n    }\n}\n"
    }
}