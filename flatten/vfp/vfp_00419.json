{
    "vfp_id": "vfp_00419",
    "project_name": "USDT0 Polygon Integration Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Fee Cap May Be Too Low",
            "description": "The `Polygon_SpokePool` contract is deployed with a fee cap of `1e18` POL, which may be insufficient to cover the actual cost of executing a transaction on the destination chain (Ethereum mainnet). The fee is calculated in destination chain terms but paid in source chain tokens (POL), which have a much lower value compared to ETH. The root cause is the static and potentially underestimated fee cap that does not account for the exchange rate between POL and ETH or actual L1 execution costs. An attacker cannot directly exploit this, but legitimate users may find their cross-chain transfers failing if the required fee exceeds the cap. The impact is a denial of service for USDT0 transfers from Polygon to Ethereum mainnet when network fees are high, undermining the reliability of the bridge functionality.\n",
            "severity": "Medium",
            "location": [
                "Polygon_SpokePool.sol#(constructor)",
                "deploy/011_deploy_polygon_spokepool.ts#24"
            ],
            "files": [
                "contracts/contracts/Polygon_SpokePool.sol"
            ]
        }
    ],
    "affected_files": {
        "Polygon_SpokePool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./PolygonTokenBridger.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\n/**\n * @notice IFxMessageProcessor represents interface to process messages.\n */\ninterface IFxMessageProcessor {\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(uint256 stateId, address rootMessageSender, bytes calldata data) external;\n}\n\n/**\n * @notice Polygon specific SpokePool.\n * @custom:security-contact bugs@across.to\n */\ncontract Polygon_SpokePool is IFxMessageProcessor, SpokePool, CircleCCTPAdapter {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n\n    // Address of FxChild which sends and receives messages to and from L1.\n    address public fxChild;\n\n    // Contract deployed on L1 and L2 processes all cross-chain transfers between this contract and the HubPool.\n    // Required because bridging tokens from Polygon to Ethereum has special constraints.\n    PolygonTokenBridger public polygonTokenBridger;\n\n    // Internal variable that only flips temporarily to true upon receiving messages from L1. Used to authenticate that\n    // the caller is the fxChild AND that the fxChild called processMessageFromRoot\n    bool private callValidated;\n\n    error MulticallExecuteLeaf();\n\n    event SetFxChild(address indexed newFxChild);\n    event SetPolygonTokenBridger(address indexed polygonTokenBridger);\n    event ReceivedMessageFromL1(address indexed caller, address indexed rootMessageSender);\n\n    error CallValidatedAlreadySet();\n    error CallValidatedNotSet();\n    error DelegateCallFailed();\n    error NotHubPool();\n    error NotFxChild();\n\n    // Note: validating calls this way ensures that strange calls coming from the fxChild won't be misinterpreted.\n    // Put differently, just checking that msg.sender == fxChild is not sufficient.\n    // All calls that have admin privileges must be fired from within the processMessageFromRoot method that's gone\n    // through validation where the sender is checked and the root (mainnet) sender is also validated.\n    // This modifier sets the callValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure callValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        if (callValidated) revert CallValidatedAlreadySet();\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed. See comment for `_requireAdminSender` for more details.\n        callValidated = true;\n\n        _;\n\n        // Reset callValidated to false to disallow admin calls after this method exits.\n        callValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer, _oftDstEid, _oftFeeCap)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Polygon SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _polygonTokenBridger Token routing contract that sends tokens from here to HubPool. Changeable by Admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _fxChild FxChild contract, changeable by Admin.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        PolygonTokenBridger _polygonTokenBridger,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _fxChild\n    ) public initializer {\n        callValidated = false;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setPolygonTokenBridger(payable(_polygonTokenBridger));\n        //slither-disable-next-line missing-zero-check\n        _setFxChild(_fxChild);\n    }\n\n    /********************************************************\n     *    POLYGON-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change FxChild address. Callable only by admin via processMessageFromRoot.\n     * @param newFxChild New FxChild.\n     */\n    function setFxChild(address newFxChild) public onlyAdmin nonReentrant {\n        _setFxChild(newFxChild);\n    }\n\n    /**\n     * @notice Change polygonTokenBridger address. Callable only by admin via processMessageFromRoot.\n     * @param newPolygonTokenBridger New Polygon Token Bridger contract.\n     */\n    function setPolygonTokenBridger(address payable newPolygonTokenBridger) public onlyAdmin nonReentrant {\n        _setPolygonTokenBridger(newPolygonTokenBridger);\n    }\n\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256 /*stateId*/,\n        address rootMessageSender,\n        bytes calldata data\n    ) public validateInternalCalls {\n        // Validation logic.\n        if (msg.sender != fxChild) revert NotFxChild();\n        if (rootMessageSender != crossDomainAdmin) revert NotHubPool();\n\n        // This uses delegatecall to take the information in the message and process it as a function call on this contract.\n        /// This is a safe delegatecall because its made to address(this) so there is no risk of delegating to a\n        /// selfdestruct().\n        //slither-disable-start low-level-calls\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(data);\n        //slither-disable-end low-level-calls\n        if (!success) revert DelegateCallFailed();\n\n        emit ReceivedMessageFromL1(msg.sender, rootMessageSender);\n    }\n\n    /**\n     * @notice Allows the caller to trigger the wrapping of any unwrapped matic tokens.\n     * @dev Unlike other ERC20 transfers, Matic transfers from L1 -> L2 bridging don't result in an L2 call into\n     * the contract receiving the tokens, so wrapping must be done via a separate transaction. In other words,\n     * we can't rely upon a `fallback()` method being triggered to wrap MATIC upon receiving it.\n     */\n    function wrap() public nonReentrant {\n        _wrap();\n    }\n\n    /**\n     * @notice Override multicall so that it cannot include executeRelayerRefundLeaf\n     * as one of the calls combined with other public function calls and blocks nested multicalls in general, which\n     * don't have any practical use case. We also block nested multicalls which could be used to bypass\n     * this check and there are no practical use cases for nested multicalls.\n     * @dev Multicalling a single transaction will always succeed.\n     * @dev Multicalling execute functions without combining other public function calls will succeed.\n     * @dev Nested multicalls will always fail.\n     * @dev Multicalling public function calls without combining execute functions will succeed.\n     */\n    function _validateMulticallData(bytes[] calldata data) internal pure override {\n        bool hasOtherPublicFunctionCall = false;\n        bool hasExecutedLeafCall = false;\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes4 selector = bytes4(data[i][:4]);\n            if (selector == MultiCallerUpgradeable.multicall.selector) {\n                revert MulticallExecuteLeaf();\n            } else if (selector == SpokePoolInterface.executeRelayerRefundLeaf.selector) {\n                if (hasOtherPublicFunctionCall) revert MulticallExecuteLeaf();\n                hasExecutedLeafCall = true;\n            } else {\n                if (hasExecutedLeafCall) revert MulticallExecuteLeaf();\n                hasOtherPublicFunctionCall = true;\n            }\n        }\n    }\n\n    /**\n     * @notice This function can send an L2 to L1 message so we are extra cautious about preventing a griefing vector\n     * whereby someone batches this call with a bunch of other calls and produces a very large L2 burn transaction.\n     * This might make the L2 -> L1 message fail due to exceeding the L1 calldata limit.\n     */\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable override {\n        // AddressLibUpgradeable.isContract isn't a sufficient check because it checks the contract code size of\n        // msg.sender which is 0 if called from a constructor function on msg.sender. This is why we check if\n        // msg.sender is equal to tx.origin which is fine as long as Polygon supports the tx.origin opcode. We also\n        // check if the msg.sender has delegated their code to a contract via EIP7702.\n        // solhint-disable-next-line avoid-tx-origin\n        if (relayerRefundLeaf.amountToReturn > 0 && (msg.sender != tx.origin || msg.sender.code.length > 0))\n            revert NotEOA();\n        super.executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _setFxChild(address _fxChild) internal {\n        //slither-disable-next-line missing-zero-check\n        fxChild = _fxChild;\n        emit SetFxChild(_fxChild);\n    }\n\n    function _setPolygonTokenBridger(address payable _polygonTokenBridger) internal {\n        polygonTokenBridger = PolygonTokenBridger(_polygonTokenBridger);\n        emit SetPolygonTokenBridger(address(_polygonTokenBridger));\n    }\n\n    function _preExecuteLeafHook(address) internal override {\n        // Wraps MATIC --> WMATIC before distributing tokens from this contract.\n        _wrap();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // WARNING: Withdrawing MATIC can result in the L1 PolygonTokenBridger.startExitWithBurntTokens() failing\n        // due to a MAX_LOGS constraint imposed by the ERC20Predicate, so if this SpokePool will be used to withdraw\n        // MATIC then additional constraints need to be imposed to limit the # of logs produed by the L2 withdrawal\n        // transaction. Currently, MATIC is not a supported token in Across for this SpokePool.\n        address oftMessenger = _getOftMessenger(l2TokenAddress);\n\n        // If the token is USDC, we need to use the CCTP bridge to transfer it to the hub pool.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else if (oftMessenger != address(0)) {\n            _transferViaOFT(IERC20(l2TokenAddress), IOFT(oftMessenger), withdrawalRecipient, amountToReturn);\n        } else {\n            PolygonIERC20Upgradeable(l2TokenAddress).safeIncreaseAllowance(\n                address(polygonTokenBridger),\n                amountToReturn\n            );\n            // Note: WrappedNativeToken is WMATIC on matic, so this tells the tokenbridger that this is an unwrappable native token.\n            polygonTokenBridger.send(PolygonIERC20Upgradeable(l2TokenAddress), amountToReturn);\n        }\n    }\n\n    function _wrap() internal {\n        uint256 balance = address(this).balance;\n        //slither-disable-next-line arbitrary-send-eth\n        if (balance > 0) wrappedNativeToken.deposit{ value: balance }();\n    }\n\n    // @dev: This contract will trigger admin functions internally via the `processMessageFromRoot`, which is why\n    // the `callValidated` check is made below  and why we use the `validateInternalCalls` modifier on\n    // `processMessageFromRoot`. This prevents calling the admin functions from any other method besides\n    // `processMessageFromRoot`.\n    function _requireAdminSender() internal view override {\n        if (!callValidated) revert CallValidatedNotSet();\n    }\n}\n"
    }
}