{
    "vfp_id": "vfp_00419",
    "project_name": "ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Discrepancy in swapFromBold Behavior",
            "description": "The UniV3Exchange and CurveExchange contracts both implement the swapFromBold function, but they behave differently despite being intended as interchangeable. UniV3Exchange uses an ExactOutput swap, which ensures the exact amount of collateral tokens is received and may leave excess BOLD tokens. In contrast, CurveExchange uses an ExactInput swap (via Curve's exchange function), which swaps the full BOLD input and may leave excess collateral tokens.\n\nThe root cause is inconsistent implementation across exchange adapters, violating the principle of uniform behavior when interfaces are meant to be substitutable. This discrepancy can lead to unexpected token balances and user confusion when different exchanges are used under the same expected behavior.\n\nAn attacker or user could exploit this by choosing the exchange that best suits their slippage or surplus token strategy, potentially leading to inefficient trades or unexpected leftover tokens in the calling contract. The impact is primarily on user experience and economic efficiency, with potential for minor fund loss due to mismanagement of excess tokens.\n\nLiquity acknowledged the issue and noted that while ExactOutput is more natural, they cannot guarantee all future exchanges will support it, leaving the inconsistency unresolved.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "User-provided transferFrom Source Address",
            "description": "The `UniV3Exchange` and `CurveExchange` contracts use a user-provided `_zapper` address in `transferFrom`, allowing arbitrary token pulls from approved addresses.\n\nThe root cause is using a user-controlled address as the `from` parameter in `transferFrom`, violating secure token interaction patterns.\n\nAn attacker could trick a user into approving the exchange contract and then drain their tokens by specifying their address as `_zapper`.\n\nThe impact is risk of token theft from users who mistakenly approve the contract, though the actual impact is limited since zappers are not intended to hold balances.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.swapFromBold",
                "UniV3Exchange.SwapToBold",
                "CurveExchange.swapFromBold",
                "CurveExchange.SwapToBold"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Leverage Zappers Do Not Return Swap Excess",
            "description": "The leverage zapper contracts fail to return excess tokens to users after swap operations. When using UniV3Exchange.swapFromBold(), an ExactOutput swap may leave excess BOLD tokens in the exchange contract. Similarly, ExactInput swaps in UniV3Exchange.swapToBold(), CurveExchange.swapFromBold(), and CurveExchange.swapToBold() may result in excess output tokens being sent to the zapper but not forwarded to the user.\n\nThe root cause is the lack of post-swap balance checks and token return logic in the zapper functions. This oversight leads to user funds being stranded in the zapper or exchange contracts.\n\nAn attacker or any user could later claim these stranded tokens (as noted in the related finding \"Zappers Can Lose User Funds\"), but the primary impact is user fund loss due to poor handling of expected surplus from decentralized exchange trades. Market volatility between transaction submission and execution makes such surpluses common.\n\nThe issue was resolved in Version 2 by implementing _setInitialBalancesAndReceiver() to record token balances before swaps and _returnLeftovers() to transfer any excess back to the caller. This ensures all leftover tokens are returned, regardless of swap type.\n",
            "severity": "High",
            "location": [
                "UniV3Exchange.sol::swapFromBold#",
                "CurveExchange.sol::swapFromBold#",
                "UniV3Exchange.sol::swapToBold#",
                "CurveExchange.sol::swapToBold#"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Price Limit in UniV3Exchange Is Too Strict",
            "description": "The price limit in `UniV3Exchange.getBoldAmountToSwap` is based on a strict post-trade price check, which may prevent valid swaps even when the average price is acceptable.\n\nThe root cause is that the function uses a maximum price ratio that is too restrictive, not accounting for the difference between instantaneous and average trade price.\n\nUsers may be forced to use looser price bounds, increasing slippage and allowing MEV bots to extract more value during large swaps.\n\nThe impact is reduced swap efficiency and increased vulnerability to front-running and value extraction by bots, degrading user experience and economic fairness.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.getBoldAmountToSwap"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        }
    ],
    "affected_files": {
        "CurveExchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../Interfaces/IBoldToken.sol\";\nimport \"./Curve/ICurvePool.sol\";\nimport \"../../Interfaces/IExchange.sol\";\n\ncontract CurveExchange is IExchange {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    ICurvePool public immutable curvePool;\n    uint256 public immutable COLL_TOKEN_INDEX;\n    uint256 public immutable BOLD_TOKEN_INDEX;\n\n    constructor(\n        IERC20 _collToken,\n        IBoldToken _boldToken,\n        ICurvePool _curvePool,\n        uint256 _collIndex,\n        uint256 _boldIndex\n    ) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        curvePool = _curvePool;\n        COLL_TOKEN_INDEX = _collIndex;\n        BOLD_TOKEN_INDEX = _boldIndex;\n    }\n\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {\n        ICurvePool curvePoolCached = curvePool;\n        uint256 initialBoldBalance = boldToken.balanceOf(address(this));\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n        boldToken.approve(address(curvePoolCached), _boldAmount);\n\n        uint256 output = curvePoolCached.exchange(BOLD_TOKEN_INDEX, COLL_TOKEN_INDEX, _boldAmount, _minCollAmount);\n        collToken.safeTransfer(msg.sender, output);\n\n        uint256 currentBoldBalance = boldToken.balanceOf(address(this));\n        if (currentBoldBalance > initialBoldBalance) {\n            boldToken.transfer(msg.sender, currentBoldBalance - initialBoldBalance);\n        }\n    }\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {\n        ICurvePool curvePoolCached = curvePool;\n        uint256 initialCollBalance = collToken.balanceOf(address(this));\n        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);\n        collToken.approve(address(curvePoolCached), _collAmount);\n\n        uint256 output = curvePoolCached.exchange(COLL_TOKEN_INDEX, BOLD_TOKEN_INDEX, _collAmount, _minBoldAmount);\n        boldToken.transfer(msg.sender, output);\n\n        uint256 currentCollBalance = collToken.balanceOf(address(this));\n        if (currentCollBalance > initialCollBalance) {\n            collToken.safeTransfer(msg.sender, currentCollBalance - initialCollBalance);\n        }\n\n        return output;\n    }\n}\n",
        "UniV3Exchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"../../LeftoversSweep.sol\";\nimport \"../../../Interfaces/IBoldToken.sol\";\nimport \"./UniswapV3/ISwapRouter.sol\";\nimport \"./UniswapV3/UniPriceConverter.sol\";\nimport \"../../Interfaces/IExchange.sol\";\nimport {DECIMAL_PRECISION} from \"../../../Dependencies/Constants.sol\";\n\ncontract UniV3Exchange is LeftoversSweep, UniPriceConverter, IExchange {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    uint24 public immutable fee;\n    ISwapRouter public immutable uniV3Router;\n\n    constructor(IERC20 _collToken, IBoldToken _boldToken, uint24 _fee, ISwapRouter _uniV3Router) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        fee = _fee;\n        uniV3Router = _uniV3Router;\n    }\n\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {\n        ISwapRouter uniV3RouterCached = uniV3Router;\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);\n\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n        boldToken.approve(address(uniV3RouterCached), _boldAmount);\n\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({\n            tokenIn: address(boldToken),\n            tokenOut: address(collToken),\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountOut: _minCollAmount,\n            amountInMaximum: _boldAmount,\n            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205\n        });\n\n        uniV3RouterCached.exactOutputSingle(params);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {\n        ISwapRouter uniV3RouterCached = uniV3Router;\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);\n\n        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);\n        collToken.approve(address(uniV3RouterCached), _collAmount);\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(collToken),\n            tokenOut: address(boldToken),\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _collAmount,\n            amountOutMinimum: _minBoldAmount,\n            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205\n        });\n\n        uint256 amountOut = uniV3RouterCached.exactInputSingle(params);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n\n        return amountOut;\n    }\n\n    function priceToSqrtPrice(IBoldToken _boldToken, IERC20 _collToken, uint256 _price) public pure returns (uint160) {\n        // inverse price if Bold goes first\n        uint256 price = _zeroForOne(_boldToken, _collToken) ? DECIMAL_PRECISION * DECIMAL_PRECISION / _price : _price;\n        return priceToSqrtPriceX96(price);\n    }\n\n    // See: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol#L207C9-L207C60\n    function _zeroForOne(IBoldToken _boldToken, IERC20 _collToken) internal pure returns (bool) {\n        return address(_boldToken) < address(_collToken);\n    }\n}\n"
    }
}