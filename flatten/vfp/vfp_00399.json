{
    "vfp_id": "vfp_00399",
    "project_name": "ackee-blockchain-lido-vault-wrapper-report.pdf",
    "findings": [
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "calculateCurrentStethShareRate documentation contradicts implementation precision",
            "description": "The NatSpec for calculateCurrentStethShareRate in WithdrawalQueue.sol claims a 1e27 precision return value, but the implementation returns a value with 1e18 precision (ETH amount per 1e27 stETH shares). This inconsistency can mislead off-chain integrators who rely on documentation for correct scaling. The root cause is outdated or incorrect documentation. While the internal logic is correct, external systems may apply wrong scaling, leading to incorrect calculations in UIs or analytics. The impact is on integration correctness and data interpretation, not on-chain security, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "WithdrawalQueue.sol::calculateCurrentStethShareRate#658"
            ],
            "files": [
                "vaults-wrapper/src/WithdrawalQueue.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incomplete documentation for checkpoint hint function",
            "description": "The documentation for the checkpoint hint function in WithdrawalQueue.sol incorrectly states that it is used with claimWithdrawalBatch and getClaimableEther, omitting that the batch functions require manual calling while single functions call it automatically. This is a documentation inconsistency that can mislead integrators and developers about the correct usage pattern. The root cause is outdated or incomplete NatSpec comments. This does not introduce a security flaw but can lead to incorrect implementation in off-chain systems, resulting in failed claims or inefficient gas usage. The impact is on integration correctness and developer experience, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "WithdrawalQueue.sol#758"
            ],
            "files": [
                "vaults-wrapper/src/WithdrawalQueue.sol"
            ]
        }
    ],
    "affected_files": {
        "WithdrawalQueue.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {IStvStETHPool} from \"./interfaces/IStvStETHPool.sol\";\nimport {IDashboard} from \"./interfaces/core/IDashboard.sol\";\nimport {ILazyOracle} from \"./interfaces/core/ILazyOracle.sol\";\nimport {IStETH} from \"./interfaces/core/IStETH.sol\";\nimport {IStakingVault} from \"./interfaces/core/IStakingVault.sol\";\nimport {IVaultHub} from \"./interfaces/core/IVaultHub.sol\";\nimport {FeaturePausable} from \"./utils/FeaturePausable.sol\";\nimport {\n    AccessControlEnumerableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title WithdrawalQueue\n * @notice Manages withdrawal requests from the STV Pool with queuing, finalization, and claiming\n * @dev Handles the complete lifecycle of withdrawal requests including optional stETH rebalancing,\n * and discount mechanisms\n */\ncontract WithdrawalQueue is AccessControlEnumerableUpgradeable, FeaturePausable {\n    using SafeCast for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice Min delay between withdrawal request and finalization\n    /// @dev Contract enforces a minimum 1-hour delay to ensure the value is set within reasonable bounds\n    uint256 public immutable MIN_WITHDRAWAL_DELAY_TIME_IN_SECONDS;\n\n    // ACL\n    bytes32 public constant WITHDRAWALS_FEATURE = keccak256(\"WITHDRAWALS_FEATURE\");\n    bytes32 public constant WITHDRAWALS_PAUSE_ROLE = keccak256(\"WITHDRAWALS_PAUSE_ROLE\");\n    bytes32 public constant WITHDRAWALS_RESUME_ROLE = keccak256(\"WITHDRAWALS_RESUME_ROLE\");\n\n    bytes32 public constant FINALIZE_FEATURE = keccak256(\"FINALIZE_FEATURE\");\n    bytes32 public constant FINALIZE_PAUSE_ROLE = keccak256(\"FINALIZE_PAUSE_ROLE\");\n    bytes32 public constant FINALIZE_RESUME_ROLE = keccak256(\"FINALIZE_RESUME_ROLE\");\n    bytes32 public constant FINALIZE_ROLE = keccak256(\"FINALIZE_ROLE\");\n\n    /// @notice Precision base for stv and steth share rates\n    uint256 public constant E27_PRECISION_BASE = 1e27;\n    uint256 public constant E36_PRECISION_BASE = 1e36;\n\n    /// @notice Maximum gas cost coverage that can be applied for a single request\n    /// @dev High enough to cover gas costs for finalization tx\n    /// @dev Low enough to prevent abuse by excessive gas cost coverage\n    ///\n    /// Request finalization tx for 1 request consumes ~200k gas\n    /// Request finalization tx for 10 requests (in batch) consumes ~300k gas\n    /// Thus, setting max coverage to 0.0005 ether should be sufficient to cover finalization gas costs:\n    /// - when gas price is up to 2.5 gwei for tx with a single request (0.0005 eth / 200k gas = 2.5 gwei per gas)\n    /// - when gas price is up to 16.6 gwei for batched tx of 10 requests (10 * 0.0005 eth / 300k gas = 16.6 gwei per gas)\n    uint256 public constant MAX_GAS_COST_COVERAGE = 0.0005 ether;\n\n    /// @notice Minimal value (assets - stETH to rebalance) that is possible to request\n    /// @dev Prevents placing many small requests\n    uint256 public constant MIN_WITHDRAWAL_VALUE = 0.001 ether;\n\n    /// @notice Maximum amount of assets that is possible to withdraw in a single request\n    /// @dev Prevents accumulating too much funds per single request fulfillment in the future\n    /// @dev To withdraw larger amounts, it's recommended to split it to several requests\n    uint256 public constant MAX_WITHDRAWAL_ASSETS = 10_000 ether;\n\n    /// @dev Return value for the `findCheckpointHint` method in case of no result\n    uint256 internal constant NOT_FOUND = 0;\n\n    /// @notice Flag indicating whether the pool supports rebalancing of steth shares\n    bool public immutable IS_REBALANCING_SUPPORTED;\n\n    IStvStETHPool public immutable POOL;\n    IVaultHub public immutable VAULT_HUB;\n    IDashboard public immutable DASHBOARD;\n    IStETH public immutable STETH;\n    ILazyOracle public immutable LAZY_ORACLE;\n    IStakingVault public immutable VAULT;\n\n    /// @notice Structure representing a request for withdrawal\n    struct WithdrawalRequest {\n        /// @notice Sum of all stv locked for withdrawal including this request\n        uint256 cumulativeStv;\n        /// @notice Sum of all steth shares to rebalance including this request\n        uint128 cumulativeStethShares;\n        /// @notice Sum of all assets submitted for withdrawals including this request\n        uint128 cumulativeAssets;\n        /// @notice Address that can claim this request\n        address owner;\n        /// @notice Timestamp of when the request was created, in seconds\n        uint40 timestamp;\n        /// @notice True, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\n        bool isClaimed;\n    }\n\n    /// @notice Structure to store stv rates for finalized requests\n    struct Checkpoint {\n        /// @notice First requestId that was finalized with these rates\n        uint256 fromRequestId;\n        /// @notice Stv rate at the moment of finalization (1e27 precision)\n        uint256 stvRate;\n        /// @notice Steth share rate at the moment of finalization (1e18 precision)\n        uint128 stethShareRate;\n        /// @notice Gas cost coverage for the requests in this checkpoint\n        uint64 gasCostCoverage;\n    }\n\n    /// @notice Output format struct for view methods `getWithdrawalStatus()` and `getWithdrawalStatusBatch()`\n    struct WithdrawalRequestStatus {\n        /// @notice Amount of stv locked for this request\n        uint256 amountOfStv;\n        /// @notice Amount of steth shares to rebalance for this request\n        uint256 amountOfStethShares;\n        /// @notice Asset amount that was locked for this request\n        uint256 amountOfAssets;\n        /// @notice Address that can claim this request\n        address owner;\n        /// @notice Timestamp of when the request was created, in seconds\n        uint256 timestamp;\n        /// @notice True, if request is finalized\n        bool isFinalized;\n        /// @notice True, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\n        bool isClaimed;\n    }\n\n    /// @custom:storage-location erc7201:pool.storage.WithdrawalQueue\n    struct WithdrawalQueueStorage {\n        // ### 1st slot\n        /// @dev queue for withdrawal requests, indexes (requestId) start from 1\n        mapping(uint256 => WithdrawalRequest) requests;\n        // ### 2nd slot\n        /// @dev withdrawal requests mapped to the owners\n        mapping(address => EnumerableSet.UintSet) requestsByOwner;\n        // ### 3rd slot\n        /// @dev finalization rate history, indexes start from 1\n        mapping(uint256 => Checkpoint) checkpoints;\n        // ### 4th slot\n        /// @dev last index in request queue\n        uint128 lastRequestId;\n        /// @dev last index of finalized request in the queue\n        uint128 lastFinalizedRequestId;\n        // ### 5th slot\n        /// @dev last index in checkpoints array\n        uint96 lastCheckpointIndex;\n        /// @dev amount of ETH locked on contract for further claiming\n        uint96 totalLockedAssets;\n        /// @dev request finalization gas cost coverage in wei\n        uint64 gasCostCoverage;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"pool.storage.WithdrawalQueue\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant WITHDRAWAL_QUEUE_STORAGE_LOCATION =\n        0x11fba3ff43ee43ae28e3c08029ee00ea5862db2aba88444d8c290c62bd802000;\n\n    function _getWithdrawalQueueStorage() private pure returns (WithdrawalQueueStorage storage $) {\n        assembly {\n            $.slot := WITHDRAWAL_QUEUE_STORAGE_LOCATION\n        }\n    }\n\n    event Initialized(address indexed admin, address indexed finalizer);\n    event WithdrawalRequested(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 amountOfStv,\n        uint256 amountOfStethShares,\n        uint256 amountOfAssets\n    );\n    event WithdrawalsFinalized(\n        uint256 indexed from,\n        uint256 indexed to,\n        uint256 ethLocked,\n        uint256 ethForGasCoverage,\n        uint256 stvBurned,\n        uint256 stvRebalanced,\n        uint256 stethSharesRebalanced,\n        uint256 timestamp\n    );\n    event WithdrawalClaimed(\n        uint256 indexed requestId, address indexed owner, address indexed recipient, uint256 amountOfETH\n    );\n    event GasCostCoverageSet(uint256 newCoverage);\n\n    error ZeroAddress();\n    error RequestValueTooSmall(uint256 amount);\n    error RequestAssetsTooLarge(uint256 amount);\n    error GasCostCoverageTooLarge(uint256 amount);\n    error InvalidWithdrawalDelay();\n    error InvalidRequestId(uint256 requestId);\n    error InvalidRange(uint256 start, uint256 end);\n    error RequestAlreadyClaimed(uint256 requestId);\n    error RequestNotFoundOrNotFinalized(uint256 requestId);\n    error RequestIdsNotSorted();\n    error ArraysLengthMismatch(uint256 firstArrayLength, uint256 secondArrayLength);\n    error VaultReportStale();\n    error CantSendValueRecipientMayHaveReverted();\n    error InvalidHint(uint256 hint);\n    error NoRequestsToFinalize();\n    error NotOwner(address _requestor, address _owner);\n    error RebalancingIsNotSupported();\n\n    constructor(\n        address _pool,\n        address _dashboard,\n        address _vaultHub,\n        address _steth,\n        address _vault,\n        address _lazyOracle,\n        uint256 _minWithdrawalDelayTimeInSeconds,\n        bool _isRebalancingSupported\n    ) {\n        if (_minWithdrawalDelayTimeInSeconds < 1 hours) revert InvalidWithdrawalDelay();\n\n        MIN_WITHDRAWAL_DELAY_TIME_IN_SECONDS = _minWithdrawalDelayTimeInSeconds;\n        IS_REBALANCING_SUPPORTED = _isRebalancingSupported;\n\n        POOL = IStvStETHPool(payable(_pool));\n        DASHBOARD = IDashboard(payable(_dashboard));\n        VAULT_HUB = IVaultHub(_vaultHub);\n        STETH = IStETH(_steth);\n        LAZY_ORACLE = ILazyOracle(_lazyOracle);\n        VAULT = IStakingVault(_vault);\n\n        _disableInitializers();\n\n        // Pause features in implementation\n        _pauseFeature(WITHDRAWALS_FEATURE);\n        _pauseFeature(FINALIZE_FEATURE);\n    }\n\n    /**\n     * @notice Initialize the contract storage explicitly\n     * @param _admin Admin address that can change every role\n     * @param _finalizer Address that will be granted FINALIZE_ROLE\n     * @param _withdrawalsPauser Address that will be granted WITHDRAWALS_PAUSE_ROLE (zero address for none)\n     * @param _finalizePauser Address that will be granted FINALIZE_PAUSE_ROLE (zero address for none)\n     * @dev Reverts if `_admin` or `_finalizer` equals to `address(0)`\n     */\n    function initialize(address _admin, address _finalizer, address _withdrawalsPauser, address _finalizePauser)\n        external\n        initializer\n    {\n        if (_admin == address(0)) revert ZeroAddress();\n        if (_finalizer == address(0)) revert ZeroAddress();\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(FINALIZE_ROLE, _finalizer);\n        if (_withdrawalsPauser != address(0)) {\n            _grantRole(WITHDRAWALS_PAUSE_ROLE, _withdrawalsPauser);\n        }\n        if (_finalizePauser != address(0)) {\n            _grantRole(FINALIZE_PAUSE_ROLE, _finalizePauser);\n        }\n\n        _getWithdrawalQueueStorage().requests[0] = WithdrawalRequest({\n            cumulativeStv: 0,\n            cumulativeStethShares: 0,\n            cumulativeAssets: 0,\n            owner: address(0),\n            timestamp: uint40(block.timestamp),\n            isClaimed: true\n        });\n\n        emit Initialized(_admin, _finalizer);\n    }\n\n    // =================================================================================\n    // PAUSE / RESUME\n    // =================================================================================\n\n    /**\n     * @notice Pause withdrawal requests submission\n     * @dev Can only be called by accounts with the WITHDRAWALS_PAUSE_ROLE\n     * @dev Does not affect claiming of already finalized requests\n     */\n    function pauseWithdrawals() external {\n        _checkRole(WITHDRAWALS_PAUSE_ROLE, msg.sender);\n        _pauseFeature(WITHDRAWALS_FEATURE);\n    }\n\n    /**\n     * @notice Resume withdrawal requests submission\n     * @dev Can only be called by accounts with the WITHDRAWALS_RESUME_ROLE\n     */\n    function resumeWithdrawals() external {\n        _checkRole(WITHDRAWALS_RESUME_ROLE, msg.sender);\n        _resumeFeature(WITHDRAWALS_FEATURE);\n    }\n\n    /**\n     * @notice Pause withdrawals finalization\n     * @dev Can only be called by accounts with the FINALIZE_PAUSE_ROLE\n     * @dev Does not affect claiming of already finalized requests\n     */\n    function pauseFinalization() external {\n        _checkRole(FINALIZE_PAUSE_ROLE, msg.sender);\n        _pauseFeature(FINALIZE_FEATURE);\n    }\n\n    /**\n     * @notice Resume withdrawals finalization\n     * @dev Can only be called by accounts with the FINALIZE_RESUME_ROLE\n     */\n    function resumeFinalization() external {\n        _checkRole(FINALIZE_RESUME_ROLE, msg.sender);\n        _resumeFeature(FINALIZE_FEATURE);\n    }\n\n    // =================================================================================\n    // REQUESTS\n    // =================================================================================\n\n    /**\n     * @notice Request multiple withdrawals from the Pool\n     * @param _owner Address that will be able to claim the created request\n     * @param _stvToWithdraw Array of amounts of stv to withdraw\n     * @param _stethSharesToRebalance Array of amounts of stETH shares to rebalance if supported by the pool, array of 0 otherwise\n     * @return requestIds the created withdrawal request ids\n     * @dev Transfers stv and liability shares from the requester to the withdrawal queue\n     * @dev Requires fresh oracle report to price stv accurately\n     */\n    function requestWithdrawalBatch(\n        address _owner,\n        uint256[] calldata _stvToWithdraw,\n        uint256[] calldata _stethSharesToRebalance\n    ) external returns (uint256[] memory requestIds) {\n        _checkFeatureNotPaused(WITHDRAWALS_FEATURE);\n        _checkArrayLength(_stvToWithdraw.length, _stethSharesToRebalance.length);\n        _checkFreshReport();\n\n        requestIds = new uint256[](_stvToWithdraw.length);\n        for (uint256 i = 0; i < _stvToWithdraw.length; ++i) {\n            requestIds[i] = _requestWithdrawal(_owner, _stvToWithdraw[i], _stethSharesToRebalance[i]);\n        }\n    }\n\n    /**\n     * @notice Request a withdrawal from the Pool\n     * @param _owner Address that will be able to claim the created request\n     * @param _stvToWithdraw Amount of stv to withdraw\n     * @param _stethSharesToRebalance Amount of steth shares to rebalance if supported by the pool, 0 otherwise\n     * @return requestId The created withdrawal request id\n     * @dev Transfers stv and liability shares from the requester to the withdrawal queue\n     * @dev Requires fresh oracle report to price stv accurately\n     */\n    function requestWithdrawal(address _owner, uint256 _stvToWithdraw, uint256 _stethSharesToRebalance)\n        external\n        returns (uint256 requestId)\n    {\n        _checkFeatureNotPaused(WITHDRAWALS_FEATURE);\n        _checkFreshReport();\n\n        requestId = _requestWithdrawal(_owner, _stvToWithdraw, _stethSharesToRebalance);\n    }\n\n    function _requestWithdrawal(address _owner, uint256 _stvToWithdraw, uint256 _stethSharesToRebalance)\n        internal\n        returns (uint256 requestId)\n    {\n        if (_owner == address(0)) revert ZeroAddress();\n        if (_stethSharesToRebalance > 0 && !IS_REBALANCING_SUPPORTED) revert RebalancingIsNotSupported();\n\n        uint256 assets = POOL.previewRedeem(_stvToWithdraw);\n        uint256 value = _stethSharesToRebalance > 0\n            ? Math.saturatingSub(assets, _getPooledEthBySharesRoundUp(_stethSharesToRebalance))\n            : assets;\n\n        if (value < MIN_WITHDRAWAL_VALUE) revert RequestValueTooSmall(value);\n        if (assets > MAX_WITHDRAWAL_ASSETS) revert RequestAssetsTooLarge(assets);\n\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n\n        uint256 lastRequestId = $.lastRequestId;\n        WithdrawalRequest memory lastRequest = $.requests[lastRequestId];\n\n        requestId = lastRequestId + 1;\n        $.lastRequestId = requestId.toUint128();\n\n        uint256 cumulativeStv = lastRequest.cumulativeStv + _stvToWithdraw;\n        uint256 cumulativeStethShares = lastRequest.cumulativeStethShares + _stethSharesToRebalance;\n        uint256 cumulativeAssets = lastRequest.cumulativeAssets + assets;\n\n        $.requests[requestId] = WithdrawalRequest({\n            cumulativeStv: cumulativeStv,\n            cumulativeStethShares: cumulativeStethShares.toUint128(),\n            cumulativeAssets: cumulativeAssets.toUint128(),\n            owner: _owner,\n            timestamp: uint40(block.timestamp),\n            isClaimed: false\n        });\n\n        assert($.requestsByOwner[_owner].add(requestId));\n\n        _transferForWithdrawalQueue(msg.sender, _stvToWithdraw, _stethSharesToRebalance);\n\n        emit WithdrawalRequested(requestId, _owner, _stvToWithdraw, _stethSharesToRebalance, assets);\n    }\n\n    function _transferForWithdrawalQueue(address _from, uint256 _stv, uint256 _stethShares) internal {\n        if (_stethShares == 0) {\n            POOL.transferFromForWithdrawalQueue(_from, _stv);\n        } else {\n            POOL.transferFromWithLiabilityForWithdrawalQueue(_from, _stv, _stethShares);\n        }\n    }\n\n    function _getPooledEthBySharesRoundUp(uint256 _stethShares) internal view returns (uint256 ethAmount) {\n        ethAmount = STETH.getPooledEthBySharesRoundUp(_stethShares);\n    }\n\n    // =================================================================================\n    // GAS COST COVERAGE\n    // =================================================================================\n\n    /**\n     * @notice Set the gas cost coverage that applies to each request during finalization\n     * @param _coverage The gas cost coverage per request in wei\n     * @dev Reverts if `_coverage` is greater than `MAX_GAS_COST_COVERAGE`\n     * @dev 0 by default. Increasing coverage discourages malicious actors from creating\n     * excessive requests while compensating finalizers for gas expenses\n     */\n    function setFinalizationGasCostCoverage(uint256 _coverage) external {\n        _checkRole(FINALIZE_ROLE, msg.sender);\n\n        _setFinalizationGasCostCoverage(_coverage);\n    }\n\n    function _setFinalizationGasCostCoverage(uint256 _coverage) internal {\n        if (_coverage > MAX_GAS_COST_COVERAGE) revert GasCostCoverageTooLarge(_coverage);\n\n        _getWithdrawalQueueStorage().gasCostCoverage = _coverage.toUint64();\n        emit GasCostCoverageSet(_coverage);\n    }\n\n    /**\n     * @notice Get the current gas cost coverage that applies to each request during finalization\n     * @return coverage The gas cost coverage per request in wei\n     */\n    function getFinalizationGasCostCoverage() external view returns (uint256 coverage) {\n        coverage = _getWithdrawalQueueStorage().gasCostCoverage;\n    }\n\n    // =================================================================================\n    // FINALIZATION\n    // =================================================================================\n\n    /**\n     * @notice Receive ETH for claims\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Finalize withdrawal requests\n     * @param _maxRequests The maximum number of requests to finalize\n     * @param _gasCostCoverageRecipient The address to receive gas cost coverage\n     * @return finalizedRequests The number of requests that were finalized\n     * @dev Reverts if there are no requests to finalize\n     */\n    function finalize(uint256 _maxRequests, address _gasCostCoverageRecipient)\n        external\n        returns (uint256 finalizedRequests)\n    {\n        _checkFeatureNotPaused(FINALIZE_FEATURE);\n        _checkRole(FINALIZE_ROLE, msg.sender);\n        _checkFreshReport();\n\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n\n        uint256 lastFinalizedRequestId = $.lastFinalizedRequestId;\n        uint256 firstRequestIdToFinalize = lastFinalizedRequestId + 1;\n        uint256 lastRequestIdToFinalize = Math.min(lastFinalizedRequestId + _maxRequests, $.lastRequestId);\n\n        if (firstRequestIdToFinalize > lastRequestIdToFinalize) revert NoRequestsToFinalize();\n\n        // Collect necessary data for finalization\n        uint256 currentStvRate = calculateCurrentStvRate();\n        uint256 currentStethShareRate = calculateCurrentStethShareRate();\n        uint256 withdrawableValue = DASHBOARD.withdrawableValue();\n        uint256 availableBalance = VAULT.availableBalance();\n        uint256 exceedingSteth = _getExceedingMintedSteth();\n        uint256 latestReportTimestamp = LAZY_ORACLE.latestReportTimestamp();\n\n        uint256 totalStvToBurn;\n        uint256 totalStethShares;\n        uint256 totalEthToClaim;\n        uint256 totalGasCoverage;\n        uint256 maxStvToRebalance;\n\n        Checkpoint memory checkpoint = Checkpoint({\n            fromRequestId: firstRequestIdToFinalize,\n            stvRate: currentStvRate,\n            stethShareRate: currentStethShareRate.toUint128(),\n            gasCostCoverage: $.gasCostCoverage\n        });\n\n        // Finalize requests one by one until conditions are met\n        for (uint256 i = firstRequestIdToFinalize; i <= lastRequestIdToFinalize; ++i) {\n            WithdrawalRequest memory currRequest = $.requests[i];\n            WithdrawalRequest memory prevRequest = $.requests[i - 1];\n\n            // Calculate amounts for the request\n            // - stv: amount of stv requested to withdraw\n            // - ethToClaim: amount of ETH that can be claimed for this request, excluding rebalancing and fees\n            // - stethSharesToRebalance: amount of steth shares to rebalance for this request\n            // - stethToRebalance: amount of steth corresponding to stethSharesToRebalance at the current rate\n            // - gasCostCoverage: amount of ETH that should be subtracted as gas cost coverage for this request\n            (\n                uint256 stv,\n                uint256 ethToClaim,\n                uint256 stethSharesToRebalance,\n                uint256 stethToRebalance,\n                uint256 gasCostCoverage\n            ) = _calcRequestAmounts(prevRequest, currRequest, checkpoint);\n\n            // Handle rebalancing if applicable\n            uint256 ethToRebalance;\n            uint256 stvToRebalance;\n\n            if (stethToRebalance > 0) {\n                // Determine how much stv should be burned in exchange for the steth shares\n                stvToRebalance = Math.mulDiv(stethToRebalance, E36_PRECISION_BASE, currentStvRate, Math.Rounding.Ceil);\n\n                // Cap stvToRebalance to requested stv. The rest (if any) will be socialized to users\n                // When creating a request, user transfers stv and liability to the withdrawal queue with the necessary reserve\n                // However, while waiting for finalization in the withdrawal queue, the position may become undercollateralized\n                // In this case, the loss is shared among all participants\n                if (stvToRebalance > stv) stvToRebalance = stv;\n\n                // Exceeding minted stETH (if any) is used to cover rebalancing need without withdrawing ETH from the vault\n                // Thus, Exceeding minted stETH aims to be reduced to 0\n                if (exceedingSteth > stethToRebalance) {\n                    exceedingSteth -= stethToRebalance;\n                } else {\n                    ethToRebalance = stethToRebalance - exceedingSteth;\n                    exceedingSteth = 0;\n                }\n            }\n\n            if (\n                // Stop if insufficient withdrawable ETH to cover claimable ETH for this request\n                // Stop if insufficient available ETH to cover claimable and rebalancable ETH for this request\n                // Stop if not enough time has passed since the request was created\n                // Stop if the request was created after the latest report was published, at least one oracle report is required\n                (ethToClaim + gasCostCoverage) > withdrawableValue\n                    || (ethToClaim + ethToRebalance + gasCostCoverage) > availableBalance\n                    || currRequest.timestamp + MIN_WITHDRAWAL_DELAY_TIME_IN_SECONDS > block.timestamp\n                    || currRequest.timestamp > latestReportTimestamp\n            ) {\n                break;\n            }\n\n            withdrawableValue -= (ethToClaim + gasCostCoverage);\n            availableBalance -= (ethToClaim + gasCostCoverage + ethToRebalance);\n            totalEthToClaim += ethToClaim;\n            totalGasCoverage += gasCostCoverage;\n            totalStvToBurn += (stv - stvToRebalance);\n            totalStethShares += stethSharesToRebalance;\n            maxStvToRebalance += stvToRebalance;\n            finalizedRequests++;\n        }\n\n        if (finalizedRequests == 0) revert NoRequestsToFinalize();\n\n        // 1. Withdraw ETH from the vault to cover finalized requests and burn associated stv\n        // Eth to claim or stv to burn could be 0 if all requests are going to be rebalanced\n        // Rebalance cannot be done first because it will withdraw eth without unlocking it\n        uint256 totalEthToWithdraw = totalEthToClaim + totalGasCoverage;\n        if (totalEthToWithdraw > 0) {\n            uint256 balanceBefore = address(this).balance;\n            DASHBOARD.withdraw(address(this), totalEthToWithdraw);\n            assert(address(this).balance - balanceBefore == totalEthToWithdraw);\n        }\n        if (totalStvToBurn > 0) POOL.burnStvForWithdrawalQueue(totalStvToBurn);\n\n        // 2. Rebalance steth shares by burning corresponding amount stv. Or socialize the losses if not enough stv\n        // At this point stv rate may change because of the operation above\n        // So it may burn less stv than maxStvToRebalance because of new stv rate\n        uint256 totalStvRebalanced;\n        if (totalStethShares > 0) {\n            assert(IS_REBALANCING_SUPPORTED);\n\n            // Stv burning is limited at this point by maxStvToRebalance calculated above\n            // to make sure that only stv of finalized requests is used for rebalancing\n            totalStvRebalanced = POOL.rebalanceMintedStethSharesForWithdrawalQueue(totalStethShares, maxStvToRebalance);\n        }\n\n        // 3. Burn any remaining stv that was not used for rebalancing\n        // The rebalancing may burn less stv than maxStvToRebalance because of:\n        //   - the changed stv rate after the first step\n        //   - accumulated rounding errors in maxStvToRebalance\n        //\n        // It's guaranteed by POOL.rebalanceMintedStethSharesForWithdrawalQueue() that maxStvToRebalance >= totalStvRebalanced\n        uint256 remainingStvForRebalance = maxStvToRebalance - totalStvRebalanced;\n        if (remainingStvForRebalance > 0) {\n            POOL.burnStvForWithdrawalQueue(remainingStvForRebalance);\n            totalStvToBurn += remainingStvForRebalance;\n        }\n\n        lastFinalizedRequestId = lastFinalizedRequestId + finalizedRequests;\n\n        // Store checkpoint with current stvRate, stethShareRate and gasCostCoverage\n        uint96 lastCheckpointIndex = $.lastCheckpointIndex + 1;\n        $.checkpoints[lastCheckpointIndex] = checkpoint;\n        $.lastCheckpointIndex = lastCheckpointIndex;\n\n        $.lastFinalizedRequestId = lastFinalizedRequestId.toUint128();\n        $.totalLockedAssets += totalEthToClaim.toUint96();\n\n        // Send gas coverage to the caller\n        if (totalGasCoverage > 0) {\n            // Set gas cost coverage recipient to msg.sender if not specified\n            if (_gasCostCoverageRecipient == address(0)) _gasCostCoverageRecipient = msg.sender;\n\n            (bool success,) = _gasCostCoverageRecipient.call{value: totalGasCoverage}(\"\");\n            if (!success) revert CantSendValueRecipientMayHaveReverted();\n        }\n\n        emit WithdrawalsFinalized(\n            firstRequestIdToFinalize,\n            lastFinalizedRequestId,\n            totalEthToClaim,\n            totalGasCoverage,\n            totalStvToBurn,\n            totalStvRebalanced,\n            totalStethShares,\n            block.timestamp\n        );\n    }\n\n    function _getExceedingMintedSteth() internal view returns (uint256 exceedingMintedSteth) {\n        if (IS_REBALANCING_SUPPORTED) {\n            exceedingMintedSteth = POOL.totalExceedingMintedSteth();\n        } else {\n            exceedingMintedSteth = 0;\n        }\n    }\n\n    // =================================================================================\n    // STV & STETH RATES\n    // =================================================================================\n\n    /**\n     * @notice Calculate current stv rate of the vault\n     * @return stvRate Current stv rate of the vault (1e27 precision)\n     */\n    function calculateCurrentStvRate() public view returns (uint256 stvRate) {\n        uint256 totalStv = POOL.totalSupply(); // 1e27 precision\n        uint256 totalAssets = POOL.totalAssets(); // 1e18 precision\n\n        if (totalStv == 0) return E27_PRECISION_BASE;\n        stvRate = (totalAssets * E36_PRECISION_BASE) / totalStv;\n    }\n\n    /**\n     * @notice Calculate current stETH share rate\n     * @return stethShareRate ETH amount (1e18 precision) per 1e27 stETH shares\n     * @dev Returns the amount of ETH (in wei) that corresponds to 1e27 stETH shares at the current exchange rate\n     */\n    function calculateCurrentStethShareRate() public view returns (uint256 stethShareRate) {\n        stethShareRate = _getPooledEthBySharesRoundUp(E27_PRECISION_BASE);\n    }\n\n    // =================================================================================\n    // CLAIMING\n    // =================================================================================\n\n    /**\n     * @notice Claim a batch of withdrawal requests once finalized sending locked ether to the recipient\n     * @param _recipient Address where claimed ether will be sent to\n     * @param _requestIds Array of request ids to claim\n     * @param _hints Checkpoint hints. can be found with `findCheckpointHintBatch(_requestIds, 1, getLastCheckpointIndex())`\n     * @return claimedAmounts Array of claimed amounts for each request\n     */\n    function claimWithdrawalBatch(address _recipient, uint256[] calldata _requestIds, uint256[] calldata _hints)\n        external\n        returns (uint256[] memory claimedAmounts)\n    {\n        _checkArrayLength(_requestIds.length, _hints.length);\n\n        claimedAmounts = new uint256[](_requestIds.length);\n        for (uint256 i = 0; i < _requestIds.length; ++i) {\n            claimedAmounts[i] = _claim(msg.sender, _recipient, _requestIds[i], _hints[i]);\n        }\n    }\n\n    /**\n     * @notice Claim one `_requestId` request once finalized sending locked ether to the recipient\n     * @param _recipient Address where claimed ether will be sent to\n     * @param _requestId Request id to claim\n     * @dev\n     *  Reverts if requestId is not valid\n     *  Reverts if request is not finalized or already claimed\n     *  Reverts if msg sender is not an owner of request\n     */\n    function claimWithdrawal(address _recipient, uint256 _requestId) external returns (uint256 claimedEth) {\n        uint256 checkpoint = findCheckpointHint(_requestId, 1, getLastCheckpointIndex());\n        claimedEth = _claim(msg.sender, _recipient, _requestId, checkpoint);\n    }\n\n    function _claim(address _requestor, address _recipient, uint256 _requestId, uint256 _hint)\n        internal\n        returns (uint256 ethWithDiscount)\n    {\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_requestId == 0) revert InvalidRequestId(_requestId);\n\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        if (_requestId > $.lastFinalizedRequestId) revert RequestNotFoundOrNotFinalized(_requestId);\n\n        WithdrawalRequest storage request = $.requests[_requestId];\n\n        if (request.isClaimed) revert RequestAlreadyClaimed(_requestId);\n        if (request.owner != _requestor) revert NotOwner(_requestor, request.owner);\n\n        request.isClaimed = true;\n        assert($.requestsByOwner[request.owner].remove(_requestId));\n\n        ethWithDiscount = _calcClaimableEther(request, _requestId, _hint);\n        // Because of the rounding issue some dust could be accumulated upon claiming on the contract\n        $.totalLockedAssets -= ethWithDiscount.toUint96();\n\n        (bool success,) = _recipient.call{value: ethWithDiscount}(\"\");\n        if (!success) revert CantSendValueRecipientMayHaveReverted();\n\n        emit WithdrawalClaimed(_requestId, _requestor, _recipient, ethWithDiscount);\n    }\n\n    // =================================================================================\n    // CHECKPOINTS\n    // =================================================================================\n\n    /**\n     * @notice Finds the list of hints for the given `_requestIds` searching among the checkpoints with indices\n     *  in the range  `[_firstIndex, _lastIndex]`.\n     *  NB! Array of request ids should be sorted\n     *  NB! `_firstIndex` should be greater than 0, because checkpoint list is 1-based array\n     *  Usage: findCheckpointHintBatch(_requestIds, 1, getLastCheckpointIndex())\n     * @param _requestIds Ids of the requests sorted in the ascending order to get hints for\n     * @param _firstIndex Left boundary of the search range. Should be greater than 0\n     * @param _lastIndex Right boundary of the search range. Should be less than or equal to getLastCheckpointIndex()\n     * @return hintIds Array of hints used to find required checkpoint for the request\n     */\n    function findCheckpointHintBatch(uint256[] calldata _requestIds, uint256 _firstIndex, uint256 _lastIndex)\n        external\n        view\n        returns (uint256[] memory hintIds)\n    {\n        hintIds = new uint256[](_requestIds.length);\n        uint256 prevRequestId = 0;\n        for (uint256 i = 0; i < _requestIds.length; ++i) {\n            if (_requestIds[i] < prevRequestId) revert RequestIdsNotSorted();\n            hintIds[i] = findCheckpointHint(_requestIds[i], _firstIndex, _lastIndex);\n            if (hintIds[i] != NOT_FOUND) _firstIndex = hintIds[i];\n            prevRequestId = _requestIds[i];\n        }\n    }\n\n    /**\n     * @notice View function to find a checkpoint hint to use in `claimWithdrawal()`, claimWithdrawalBatch()`, `getClaimableEther()`, and `getClaimableEtherBatch()`\n     * Search will be performed in the range of `[_firstIndex, _lastIndex]`\n     * @param _requestId Request id to search the checkpoint for\n     * @param _start Index of the left boundary of the search range, should be greater than 0\n     * @param _end Index of the right boundary of the search range, should be less than or equal to `getLastCheckpointIndex()`\n     * @return hint for later use in other methods or 0 if hint not found in the range\n     */\n    function findCheckpointHint(uint256 _requestId, uint256 _start, uint256 _end) public view returns (uint256) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        if (_requestId == 0 || _requestId > $.lastRequestId) revert InvalidRequestId(_requestId);\n\n        uint256 lastCheckpointIndex_ = $.lastCheckpointIndex;\n        if (_start == 0 || _end > lastCheckpointIndex_) revert InvalidRange(_start, _end);\n\n        if (lastCheckpointIndex_ == 0 || _requestId > $.lastFinalizedRequestId || _start > _end) return NOT_FOUND;\n\n        // Right boundary\n        if (_requestId >= $.checkpoints[_end].fromRequestId) {\n            // it's the last checkpoint, so it's valid\n            if (_end == lastCheckpointIndex_) return _end;\n            // it fits right before the next checkpoint\n            if (_requestId < $.checkpoints[_end + 1].fromRequestId) return _end;\n\n            return NOT_FOUND;\n        }\n        // Left boundary\n        if (_requestId < $.checkpoints[_start].fromRequestId) {\n            return NOT_FOUND;\n        }\n\n        // Binary search\n        uint256 min = _start;\n        uint256 max = _end - 1;\n\n        while (max > min) {\n            uint256 mid = (max + min + 1) / 2;\n            if ($.checkpoints[mid].fromRequestId <= _requestId) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    /**\n     * @notice Returns the last checkpoint index\n     * @return index Last checkpoint index\n     */\n    function getLastCheckpointIndex() public view returns (uint256 index) {\n        index = _getWithdrawalQueueStorage().lastCheckpointIndex;\n    }\n\n    // =================================================================================\n    // REQUESTS BY OWNER\n    // =================================================================================\n\n    /**\n     * @notice Returns all withdrawal requests that belong to the `_owner` address\n     * @param _owner Address to get requests for\n     * @return requestIds Array of request ids\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function withdrawalRequestsOf(address _owner) external view returns (uint256[] memory requestIds) {\n        requestIds = _getWithdrawalQueueStorage().requestsByOwner[_owner].values();\n    }\n\n    /**\n     * @notice Returns withdrawal requests in range that belong to the `_owner` address\n     * @param _owner Address to get requests for\n     * @param _start Start index\n     * @param _end End index\n     * @return requestIds Array of request ids\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function withdrawalRequestsInRangeOf(address _owner, uint256 _start, uint256 _end)\n        external\n        view\n        returns (uint256[] memory requestIds)\n    {\n        requestIds = _getWithdrawalQueueStorage().requestsByOwner[_owner].values(_start, _end);\n    }\n\n    /**\n     * @notice Returns the length of the withdrawal requests that belong to the `_owner` address\n     * @param _owner Address to get requests for\n     * @return length Length of the requests array\n     */\n    function withdrawalRequestsLengthOf(address _owner) external view returns (uint256 length) {\n        length = _getWithdrawalQueueStorage().requestsByOwner[_owner].length();\n    }\n\n    // =================================================================================\n    // REQUEST STATUS\n    // =================================================================================\n\n    /**\n     * @notice Returns status for requests with provided ids\n     * @param _requestIds Array of withdrawal request ids\n     * @return statuses Array of withdrawal request statuses\n     */\n    function getWithdrawalStatusBatch(uint256[] calldata _requestIds)\n        external\n        view\n        returns (WithdrawalRequestStatus[] memory statuses)\n    {\n        statuses = new WithdrawalRequestStatus[](_requestIds.length);\n        for (uint256 i = 0; i < _requestIds.length; ++i) {\n            statuses[i] = _getStatus(_requestIds[i]);\n        }\n    }\n\n    /**\n     * @notice Returns status for a single request\n     * @param _requestId Request id to get status for\n     * @return status Withdrawal request status\n     */\n    function getWithdrawalStatus(uint256 _requestId) external view returns (WithdrawalRequestStatus memory status) {\n        status = _getStatus(_requestId);\n    }\n\n    function _getStatus(uint256 _requestId) internal view returns (WithdrawalRequestStatus memory requestStatus) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        if (_requestId == 0 || _requestId > $.lastRequestId) revert InvalidRequestId(_requestId);\n\n        WithdrawalRequest storage request = $.requests[_requestId];\n        WithdrawalRequest storage previousRequest = $.requests[_requestId - 1];\n\n        requestStatus = WithdrawalRequestStatus({\n            amountOfStv: request.cumulativeStv - previousRequest.cumulativeStv,\n            amountOfStethShares: request.cumulativeStethShares - previousRequest.cumulativeStethShares,\n            amountOfAssets: request.cumulativeAssets - previousRequest.cumulativeAssets,\n            owner: request.owner,\n            timestamp: request.timestamp,\n            isFinalized: _requestId <= $.lastFinalizedRequestId,\n            isClaimed: request.isClaimed\n        });\n    }\n\n    // =================================================================================\n    // CLAIMABLE ETHER\n    // =================================================================================\n\n    /**\n     * @notice Returns amount of ether available for claim for each provided request id\n     * @param _requestIds Array of request ids to get claimable ether for\n     * @param _hints Checkpoint hints. Can be found with `findCheckpointHintBatch(_requestIds, 1, getLastCheckpointIndex())`\n     * @return claimableEthValues Amount of claimable ether for each request, amount is equal to 0 if request\n     * is not finalized or already claimed\n     */\n    function getClaimableEtherBatch(uint256[] calldata _requestIds, uint256[] calldata _hints)\n        external\n        view\n        returns (uint256[] memory claimableEthValues)\n    {\n        _checkArrayLength(_requestIds.length, _hints.length);\n\n        claimableEthValues = new uint256[](_requestIds.length);\n        for (uint256 i = 0; i < _requestIds.length; ++i) {\n            claimableEthValues[i] = _getClaimableEther(_requestIds[i], _hints[i]);\n        }\n    }\n\n    /**\n     * @notice Returns the claimable ether for a request\n     * @param _requestId Request id to get claimable ether for\n     * @return claimableEth Amount of claimable ether, amount is equal to 0 if request is not finalized or already claimed\n     */\n    function getClaimableEther(uint256 _requestId) external view returns (uint256 claimableEth) {\n        uint256 checkpoint = findCheckpointHint(_requestId, 1, getLastCheckpointIndex());\n        claimableEth = _getClaimableEther(_requestId, checkpoint);\n    }\n\n    function _getClaimableEther(uint256 _requestId, uint256 _hint) internal view returns (uint256 claimableEth) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        if (_requestId == 0 || _requestId > $.lastRequestId) return 0;\n        if (_requestId > $.lastFinalizedRequestId) return 0;\n\n        WithdrawalRequest storage request = $.requests[_requestId];\n        if (request.isClaimed) return 0;\n\n        claimableEth = _calcClaimableEther(request, _requestId, _hint);\n    }\n\n    function _calcClaimableEther(WithdrawalRequest storage _request, uint256 _requestId, uint256 _hint)\n        internal\n        view\n        returns (uint256 claimableEth)\n    {\n        if (_hint == 0) revert InvalidHint(_hint);\n\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n\n        uint256 lastCheckpointIndex_ = $.lastCheckpointIndex;\n        if (_hint > lastCheckpointIndex_) revert InvalidHint(_hint);\n\n        Checkpoint memory checkpoint = $.checkpoints[_hint];\n        // Reverts if requestId is not in range [checkpoint[hint], checkpoint[hint+1])\n        // ______(>______\n        //    ^  hint\n        if (_requestId < checkpoint.fromRequestId) revert InvalidHint(_hint);\n        if (_hint < lastCheckpointIndex_) {\n            // ______(>______(>________\n            //       hint    hint+1  ^\n            Checkpoint memory nextCheckpoint = $.checkpoints[_hint + 1];\n            if (nextCheckpoint.fromRequestId <= _requestId) revert InvalidHint(_hint);\n        }\n\n        WithdrawalRequest memory prevRequest = $.requests[_requestId - 1];\n        (, claimableEth,,,) = _calcRequestAmounts(prevRequest, _request, checkpoint);\n    }\n\n    function _calcRequestAmounts(\n        WithdrawalRequest memory _prevRequest,\n        WithdrawalRequest memory _request,\n        Checkpoint memory _checkpoint\n    )\n        internal\n        pure\n        returns (\n            uint256 stv,\n            uint256 assetsToClaim,\n            uint256 stethSharesToRebalance,\n            uint256 assetsToRebalance,\n            uint256 gasCostCoverage\n        )\n    {\n        stv = _request.cumulativeStv - _prevRequest.cumulativeStv;\n        stethSharesToRebalance = _request.cumulativeStethShares - _prevRequest.cumulativeStethShares;\n        assetsToClaim = _request.cumulativeAssets - _prevRequest.cumulativeAssets;\n\n        // Calculate stv rate at the time of request creation\n        uint256 requestStvRate = (assetsToClaim * E36_PRECISION_BASE) / stv;\n\n        // Apply discount if the request stv rate is above the finalization stv rate\n        if (requestStvRate > _checkpoint.stvRate) {\n            assetsToClaim = Math.mulDiv(stv, _checkpoint.stvRate, E36_PRECISION_BASE, Math.Rounding.Floor);\n        }\n\n        if (stethSharesToRebalance > 0) {\n            assetsToRebalance =\n                Math.mulDiv(stethSharesToRebalance, _checkpoint.stethShareRate, E27_PRECISION_BASE, Math.Rounding.Ceil);\n\n            // Decrease assets to claim by the amount of assets to rebalance\n            assetsToClaim = Math.saturatingSub(assetsToClaim, assetsToRebalance);\n        }\n\n        // Apply request finalization gas cost coverage\n        if (_checkpoint.gasCostCoverage > 0) {\n            gasCostCoverage = Math.min(assetsToClaim, _checkpoint.gasCostCoverage);\n            assetsToClaim -= gasCostCoverage;\n        }\n    }\n\n    // =================================================================================\n    // UNFINALIZED\n    // =================================================================================\n\n    /**\n     * @notice Return the number of unfinalized requests in the queue\n     * @return requestsNumber Number of unfinalized requests\n     */\n    function unfinalizedRequestsNumber() external view returns (uint256 requestsNumber) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        requestsNumber = $.lastRequestId - $.lastFinalizedRequestId;\n    }\n\n    /**\n     * @notice Returns the amount of stv in the queue yet to be finalized\n     * @return stv Amount of stv yet to be finalized\n     */\n    function unfinalizedStv() external view returns (uint256 stv) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        stv = $.requests[$.lastRequestId].cumulativeStv - $.requests[$.lastFinalizedRequestId].cumulativeStv;\n    }\n\n    /**\n     * @notice Returns the amount of stethShares in the queue yet to be rebalanced\n     * @return stethShares Amount of stethShares yet to be rebalanced\n     */\n    function unfinalizedStethShares() external view returns (uint256 stethShares) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        stethShares = $.requests[$.lastRequestId].cumulativeStethShares\n            - $.requests[$.lastFinalizedRequestId].cumulativeStethShares;\n    }\n\n    /**\n     * @notice Returns the amount of assets in the queue yet to be finalized\n     * @dev NOTE: This returns the nominal amount. Actual ETH needed may be less due to discounts\n     * @return assets Amount of assets yet to be finalized\n     */\n    function unfinalizedAssets() external view returns (uint256 assets) {\n        WithdrawalQueueStorage storage $ = _getWithdrawalQueueStorage();\n        assets = $.requests[$.lastRequestId].cumulativeAssets - $.requests[$.lastFinalizedRequestId].cumulativeAssets;\n    }\n\n    // =================================================================================\n    // REQUEST IDS\n    // =================================================================================\n\n    /**\n     * @notice Returns the last request id\n     * @return requestId Last request id\n     */\n    function getLastRequestId() external view returns (uint256 requestId) {\n        requestId = _getWithdrawalQueueStorage().lastRequestId;\n    }\n\n    /**\n     * @notice Returns the last finalized request id\n     * @return requestId Last finalized request id\n     */\n    function getLastFinalizedRequestId() external view returns (uint256 requestId) {\n        requestId = _getWithdrawalQueueStorage().lastFinalizedRequestId;\n    }\n\n    // =================================================================================\n    // CHECKS\n    // =================================================================================\n\n    function _checkArrayLength(uint256 _firstArrayLength, uint256 _secondArrayLength) internal pure {\n        if (_firstArrayLength != _secondArrayLength) {\n            revert ArraysLengthMismatch(_firstArrayLength, _secondArrayLength);\n        }\n    }\n\n    function _checkFreshReport() internal view {\n        if (!VAULT_HUB.isReportFresh(address(VAULT))) revert VaultReportStale();\n    }\n}\n"
    }
}