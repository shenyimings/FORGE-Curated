{
    "vfp_id": "vfp_00421",
    "project_name": "ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Total Deposit Are Compared to Wrong Constant",
            "description": "Similar to the previous issue, _updateYieldRewardsSum compares total deposits to DECIMAL_PRECISION when checking yield distribution thresholds, while other system components use MIN_BOLD_IN_SP. Despite both being 1e18, the use of different constants for the same logical threshold is inconsistent.\n\nThe root cause is redundant constant usage without centralized definition. The bug has no functional impact due to identical values, but it increases the risk of future divergence and logic errors.\n\nThe impact is purely on code clarity and maintainability. The fix involved replacing DECIMAL_PRECISION with MIN_BOLD_IN_SP in the comparison to ensure uniformity across the codebase.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum#"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Gas Optimizations in StabilityPool",
            "description": "Several gas inefficiencies were identified in the `StabilityPool`, including unnecessary checks and redundant operations.\n\nThe root cause is suboptimal code structure leading to wasted gas on conditionals and arithmetic that have no effect.\n\nNot exploitable for financial gain, but increases transaction costs for users.\n\nThe impact is higher gas consumption for depositors and withdrawers, reducing efficiency and increasing user costs.\n",
            "severity": "Informational",
            "location": [
                "StabilityPool.getDepositorYieldGainWithPending",
                "StabilityPool.withdrawFromSP",
                "_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Incorrect Scaling of P",
            "description": "In the StabilityPool.offset function, the variable P (a cumulative product used in deposit indexing) is assumed to stay within the range (1e27, 1e36]. However, due to integer arithmetic and scaling logic, P can exceed 1e36 under certain conditions.\n\nThe root cause is an incorrect loop condition in the scaling logic. The code uses while (newP <= P_PRECISION / SCALE_FACTOR) to trigger scaling up, but this can result in P values exceeding 1e36 after rescaling. For example, with P = 2e17 + 1, totalBoldDeposits = 1e20, and _debtToOffset = 5e19, the computed P after scaling becomes ~5e36, far above the expected upper bound.\n\nThis leads to incorrect calculations in functions like getDepositorCollGain, which assume P drops by exactly 1e9 per scale period. When P starts above 1e36, the drop can be much larger, breaking internal invariants and leading to incorrect reward distributions.\n\nThe impact is miscalculation of collateral gains and potential unfair distribution of rewards. The fix modified the loop condition to while (newP < P_PRECISION / SCALE_FACTOR), ensuring P is properly bounded within [1e27, 1e36] after scaling.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::offset#"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Pool Deposit Are Compared to Precision",
            "description": "The _updateYieldRewardsSum function compares total deposits against DECIMAL_PRECISION (1e18) to determine if yield distribution should occur. However, other parts of the system use MIN_BOLD_IN_SP for the same purpose. Although both constants have the same value (1e18), using inconsistent constants can lead to confusion and future bugs if one is changed independently.\n\nThe root cause is code duplication and lack of constant unification. While no immediate impact occurs due to equal values, the inconsistency violates clean code practices and introduces technical debt.\n\nThere is no direct exploitation path, but the impact is reduced code maintainability and risk of future discrepancies if constants diverge. The fix updated the function to use MIN_BOLD_IN_SP instead of DECIMAL_PRECISION for consistency.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum#"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        }
    ],
    "affected_files": {
        "StabilityPool.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IStabilityPoolEvents.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n\n/*\n * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with\n * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total Bold in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and Coll gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and Coll gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated Coll gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated Coll gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Coll gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Coll gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Coll gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 36 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n * \n * P is stored at 36-digit precision as a uint. That is, a value of \"1\" is represented by a value of 1e36 in the code.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease below 1e27,\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e27, the relative precision loss in P due to floor division is only on the\n * order of 1e-27.\n *\n * --- MIN BOLD IN SP ---\n *\n * Once totalBoldDeposits has become >= MIN_BOLD_IN_SP, a liquidation may never fully empty the Pool - a minimum of 1 BOLD remains in the SP at all times thereafter.\n * This is enforced for liquidations in TroveManager.batchLiquidateTroves, and for withdrawals in StabilityPool.withdrawFromSP.\n * As such, it is impossible to empty the Stability Pool via liquidations, and P can never become 0.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES ---\n *\n * When a deposit is made, it gets a snapshot of the currentScale.\n *\n * When calculating a compounded deposit, we compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9).\n *\n *  --- TRACKING DEPOSITOR'S COLL GAIN OVER SCALE CHANGES  ---\n *\n * We calculate the depositor's accumulated Coll gain for the scale at which they made the deposit, using the Coll gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for the scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated Coll gain, handling the case where their\n * deposit spanned one scale change.\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n */\ncontract StabilityPool is LiquityBase, IStabilityPool, IStabilityPoolEvents {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"StabilityPool\";\n\n    IERC20 public immutable collToken;\n    ITroveManager public immutable troveManager;\n    IBoldToken public immutable boldToken;\n\n    uint256 internal collBalance; // deposited coll tracker\n\n    // Tracker for Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalBoldDeposits;\n\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, and not yet paid out to depositors\n    // From the contract's perspective, this is a write-only variable.\n    uint256 internal yieldGainsOwed;\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, not yet paid out to depositors,\n    // and not accounted for because they were received when the total deposits were too small\n    uint256 internal yieldGainsPending;\n\n    // --- Data structures ---\n\n    struct Deposit {\n        uint256 initialValue;\n    }\n\n    struct Snapshots {\n        uint256 S; // Coll reward sum liqs\n        uint256 P;\n        uint256 B; // Bold reward sum from minted interest\n        uint256 scale;\n    }\n\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n    mapping(address => uint256) public stashedColl;\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some Bold debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint256 public P = P_PRECISION;\n\n    uint256 public constant P_PRECISION = 1e36;\n\n    // A scale change will happen if P decreases by a factor of at least this much\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Highest power `SCALE_FACTOR` can be raised to without overflow\n    uint256 public constant MAX_SCALE_FACTOR_EXPONENT = 8;\n\n    // The number of scale changes after which an untouched deposit stops receiving yield / coll gains\n    uint256 public constant SCALE_SPAN = 2;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint256 public currentScale;\n\n    /* Coll Gain sum 'S': During its lifetime, each deposit d_t earns an Coll gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a mapping (scale => sum).\n    * - The mapping records the sum S at different scales.\n    */\n    mapping(uint256 => uint256) public scaleToS;\n    mapping(uint256 => uint256) public scaleToB;\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        troveManager = _addressesRegistry.troveManager();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit BoldTokenAddressChanged(address(boldToken));\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getTotalBoldDeposits() external view override returns (uint256) {\n        return totalBoldDeposits;\n    }\n\n    function getYieldGainsOwed() external view override returns (uint256) {\n        return yieldGainsOwed;\n    }\n\n    function getYieldGainsPending() external view override returns (uint256) {\n        return yieldGainsPending;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Increases deposit, and takes new snapshots of accumulators P and S\n    * - Sends depositor's accumulated Coll gains to depositor\n    */\n    function provideToSP(uint256 _topUp, bool _doClaim) external override {\n        _requireNonZeroAmount(_topUp);\n\n        activePool.mintAggInterest();\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit + _topUp + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.provideToSP,\n            initialDeposit - compoundedBoldDeposit,\n            int256(_topUp),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        boldToken.sendToPool(msg.sender, address(this), _topUp);\n        _updateTotalBoldDeposits(_topUp + keptYieldGain, 0);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        _sendBoldtoDepositor(msg.sender, yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n\n        // If there were pending yields and with the new deposit we are reaching the threshold, let’s move the yield to owed\n        _updateYieldRewardsSum(0);\n    }\n\n    function _getYieldToKeepOrSend(uint256 _currentYieldGain, bool _doClaim) internal pure returns (uint256, uint256) {\n        uint256 yieldToKeep;\n        uint256 yieldToSend;\n\n        if (_doClaim) {\n            yieldToKeep = 0;\n            yieldToSend = _currentYieldGain;\n        } else {\n            yieldToKeep = _currentYieldGain;\n            yieldToSend = 0;\n        }\n\n        return (yieldToKeep, yieldToSend);\n    }\n\n    /*  withdrawFromSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Sends the requested BOLD withdrawal to depositor\n    * - (If _amount > userDeposit, the user withdraws all of their compounded deposit)\n    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S\n    */\n    function withdrawFromSP(uint256 _amount, bool _doClaim) external override {\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        activePool.mintAggInterest();\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        uint256 boldToWithdraw = LiquityMath._min(_amount, compoundedBoldDeposit);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit - boldToWithdraw + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.withdrawFromSP,\n            initialDeposit - compoundedBoldDeposit,\n            -int256(boldToWithdraw),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        uint256 newTotalBoldDeposits = _updateTotalBoldDeposits(keptYieldGain, boldToWithdraw);\n        _sendBoldtoDepositor(msg.sender, boldToWithdraw + yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n\n        require(newTotalBoldDeposits >= MIN_BOLD_IN_SP, \"Withdrawal must leave totalBoldDeposits >= MIN_BOLD_IN_SP\");\n    }\n\n    function _getNewStashedCollAndCollToSend(address _depositor, uint256 _currentCollGain, bool _doClaim)\n        internal\n        view\n        returns (uint256 newStashedColl, uint256 collToSend)\n    {\n        if (_doClaim) {\n            newStashedColl = 0;\n            collToSend = stashedColl[_depositor] + _currentCollGain;\n        } else {\n            newStashedColl = stashedColl[_depositor] + _currentCollGain;\n            collToSend = 0;\n        }\n    }\n\n    // This function is only needed in the case a user has no deposit but still has remaining stashed Coll gains.\n    function claimAllCollGains() external {\n        _requireUserHasNoDeposit(msg.sender);\n\n        activePool.mintAggInterest();\n\n        uint256 collToSend = stashedColl[msg.sender];\n        _requireNonZeroAmount(collToSend);\n        stashedColl[msg.sender] = 0;\n\n        emit DepositOperation(msg.sender, Operation.claimAllCollGains, 0, 0, 0, 0, 0, collToSend);\n        emit DepositUpdated(msg.sender, 0, 0, 0, 0, 0, 0);\n\n        _sendCollGainToDepositor(collToSend);\n    }\n\n    // --- BOLD reward functions ---\n\n    function triggerBoldRewards(uint256 _boldYield) external {\n        _requireCallerIsActivePool();\n        _updateYieldRewardsSum(_boldYield);\n    }\n\n    function _updateYieldRewardsSum(uint256 _newYield) internal {\n        uint256 accumulatedYieldGains = yieldGainsPending + _newYield;\n        if (accumulatedYieldGains == 0) return;\n\n        // When total deposits is very small, B is not updated. In this case, the BOLD issued is held\n        // until the total deposits reach 1 BOLD (remains in the balance of the SP).\n        if (totalBoldDeposits < MIN_BOLD_IN_SP) {\n            yieldGainsPending = accumulatedYieldGains;\n            return;\n        }\n\n        yieldGainsOwed += accumulatedYieldGains;\n        yieldGainsPending = 0;\n\n        scaleToB[currentScale] += P * accumulatedYieldGains / totalBoldDeposits;\n        emit B_Updated(scaleToB[currentScale], currentScale);\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's Coll collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint256 _debtToOffset, uint256 _collToAdd) external override {\n        _requireCallerIsTroveManager();\n\n        scaleToS[currentScale] += P * _collToAdd / totalBoldDeposits;\n        emit S_Updated(scaleToS[currentScale], currentScale);\n\n        uint256 numerator = P * (totalBoldDeposits - _debtToOffset);\n        uint256 newP = numerator / totalBoldDeposits;\n\n        // For `P` to turn zero, `totalBoldDeposits` has to be greater than `P * (totalBoldDeposits - _debtToOffset)`.\n        // - As the offset must leave at least 1 BOLD in the SP (MIN_BOLD_IN_SP),\n        //   the minimum value of `totalBoldDeposits - _debtToOffset` is `1e18`\n        // - It can be shown that `P` is always in range [1e27, 1e36].\n        // Thus, to turn `P` zero, `totalBoldDeposits` has to be greater than `1e27 * 1e18`,\n        // and the offset has to be (near) maximal.\n        // In other words, there needs to be octillions of BOLD in the SP, which is unlikely to happen in practice.\n        require(newP > 0, \"P must never decrease to 0\");\n\n        // Overflow analyisis of scaling up P:\n        // We know that the resulting P is <= 1e36, and it's the result of dividing numerator by totalBoldDeposits.\n        // Thus, numerator <= 1e36 * totalBoldDeposits, so unless totalBoldDeposits is septillions of BOLD, it won’t overflow.\n        // That holds on every iteration as an upper bound. We multiply numerator by SCALE_FACTOR,\n        // but numerator is by definition smaller than 1e36 * totalBoldDeposits / SCALE_FACTOR.\n        while (newP < P_PRECISION / SCALE_FACTOR) {\n            numerator *= SCALE_FACTOR;\n            newP = numerator / totalBoldDeposits;\n            currentScale += 1;\n            emit ScaleUpdated(currentScale);\n        }\n\n        emit P_Updated(newP);\n        P = newP;\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    function _moveOffsetCollAndDebt(uint256 _collToAdd, uint256 _debtToOffset) internal {\n        // Cancel the liquidated Bold debt with the Bold in the stability pool\n        _updateTotalBoldDeposits(0, _debtToOffset);\n\n        // Burn the debt that was successfully offset\n        boldToken.burn(address(this), _debtToOffset);\n\n        // Update internal Coll balance tracker\n        uint256 newCollBalance = collBalance + _collToAdd;\n        collBalance = newCollBalance;\n\n        // Pull Coll from Active Pool\n        activePool.sendColl(address(this), _collToAdd);\n\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function _updateTotalBoldDeposits(uint256 _depositIncrease, uint256 _depositDecrease) internal returns (uint256) {\n        if (_depositIncrease == 0 && _depositDecrease == 0) return totalBoldDeposits;\n        uint256 newTotalBoldDeposits = totalBoldDeposits + _depositIncrease - _depositDecrease;\n        totalBoldDeposits = newTotalBoldDeposits;\n\n        emit StabilityPoolBoldBalanceUpdated(newTotalBoldDeposits);\n        return newTotalBoldDeposits;\n    }\n\n    function _decreaseYieldGainsOwed(uint256 _amount) internal {\n        if (_amount == 0) return;\n        uint256 newYieldGainsOwed = yieldGainsOwed - _amount;\n        yieldGainsOwed = newYieldGainsOwed;\n    }\n\n    // --- Reward calculator functions for depositor ---\n\n    function getDepositorCollGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        // Coll gains from the same scale in which the deposit was made need no scaling\n        uint256 normalizedGains = scaleToS[snapshots.scale] - snapshots.S;\n\n        // Scale down further coll gains by a power of `SCALE_FACTOR` depending on how many scale changes they span\n        for (uint256 i = 1; i <= SCALE_SPAN; ++i) {\n            normalizedGains += scaleToS[snapshots.scale + i] / SCALE_FACTOR ** i;\n        }\n\n        return LiquityMath._min(initialDeposit * normalizedGains / snapshots.P, collBalance);\n    }\n\n    function getDepositorYieldGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        // Yield gains from the same scale in which the deposit was made need no scaling\n        uint256 normalizedGains = scaleToB[snapshots.scale] - snapshots.B;\n\n        // Scale down further yield gains by a power of `SCALE_FACTOR` depending on how many scale changes they span\n        for (uint256 i = 1; i <= SCALE_SPAN; ++i) {\n            normalizedGains += scaleToB[snapshots.scale + i] / SCALE_FACTOR ** i;\n        }\n\n        return LiquityMath._min(initialDeposit * normalizedGains / snapshots.P, yieldGainsOwed);\n    }\n\n    function getDepositorYieldGainWithPending(address _depositor) external view override returns (uint256) {\n        if (totalBoldDeposits < MIN_BOLD_IN_SP) return 0;\n\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        uint256 newYieldGainsOwed = yieldGainsOwed;\n\n        // Yield gains from the same scale in which the deposit was made need no scaling\n        uint256 normalizedGains = scaleToB[snapshots.scale] - snapshots.B;\n\n        // Scale down further yield gains by a power of `SCALE_FACTOR` depending on how many scale changes they span\n        for (uint256 i = 1; i <= SCALE_SPAN; ++i) {\n            normalizedGains += scaleToB[snapshots.scale + i] / SCALE_FACTOR ** i;\n        }\n\n        // Pending gains\n        uint256 pendingSPYield = activePool.calcPendingSPYield();\n        newYieldGainsOwed += pendingSPYield;\n\n        if (currentScale <= snapshots.scale + SCALE_SPAN) {\n            normalizedGains += P * pendingSPYield / totalBoldDeposits / SCALE_FACTOR ** (currentScale - snapshots.scale);\n        }\n\n        return LiquityMath._min(initialDeposit * normalizedGains / snapshots.P, newYieldGainsOwed);\n    }\n\n    // --- Compounded deposit ---\n\n    function getCompoundedBoldDeposit(address _depositor) public view override returns (uint256 compoundedDeposit) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 scaleDiff = currentScale - snapshots.scale;\n\n        // Compute the compounded deposit. If one or more scale changes in `P` were made during the deposit's lifetime,\n        // account for them.\n        // If more than `MAX_SCALE_FACTOR_EXPONENT` scale changes were made, then the divisor is greater than 2^256 so\n        // any deposit amount would be rounded down to zero.\n        if (scaleDiff <= MAX_SCALE_FACTOR_EXPONENT) {\n            compoundedDeposit = initialDeposit * P / snapshots.P / SCALE_FACTOR ** scaleDiff;\n        } else {\n            compoundedDeposit = 0;\n        }\n    }\n\n    // --- Sender functions for Bold deposit and Coll gains ---\n\n    function _sendCollGainToDepositor(uint256 _collAmount) internal {\n        if (_collAmount == 0) return;\n\n        uint256 newCollBalance = collBalance - _collAmount;\n        collBalance = newCollBalance;\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n        collToken.safeTransfer(msg.sender, _collAmount);\n    }\n\n    // Send Bold to user and decrease Bold in Pool\n    function _sendBoldtoDepositor(address _depositor, uint256 _boldToSend) internal {\n        if (_boldToSend == 0) return;\n        boldToken.returnFromPool(address(this), _depositor, _boldToSend);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newDeposit, uint256 _newStashedColl) internal {\n        deposits[_depositor].initialValue = _newDeposit;\n        stashedColl[_depositor] = _newStashedColl;\n\n        if (_newDeposit == 0) {\n            delete depositSnapshots[_depositor];\n            emit DepositUpdated(_depositor, 0, _newStashedColl, 0, 0, 0, 0);\n            return;\n        }\n\n        uint256 currentScaleCached = currentScale;\n        uint256 currentP = P;\n\n        // Get S for the current scale\n        uint256 currentS = scaleToS[currentScaleCached];\n        uint256 currentB = scaleToB[currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum S for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].B = currentB;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n\n        emit DepositUpdated(_depositor, _newDeposit, _newStashedColl, currentP, currentS, currentB, currentScaleCached);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit > 0, \"StabilityPool: User must have a non-zero deposit\");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, \"StabilityPool: User must have no deposit\");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n    }\n}\n"
    }
}