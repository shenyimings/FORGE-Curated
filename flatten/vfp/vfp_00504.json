{
    "vfp_id": "vfp_00504",
    "project_name": "2026-01-offchain-nitro-external-da-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing validations in executeValidatePreimage",
            "description": "The executeValidatePreimage function in the OneStepProverHostIo.sol contract lacks validation of the PreImageType and ptr inputs, creating a behavioral divergence from the equivalent implementation in Nitro's machine.rs. In the Rust implementation, invalid preImageType values result in pushing 0 to the stack, while invalid ptr values trigger an error state. However, the Solidity version does not replicate these checks, potentially allowing inconsistent state validation during dispute resolution. This divergence could be exploited if an attacker crafts inputs that are accepted by the challenge contract but would have failed in the Nitro node, leading to incorrect dispute outcomes. The impact depends on whether such a discrepancy can be weaponized in a live challenge, which remains undetermined.\n",
            "severity": "Informational",
            "location": [
                "arbitrator/prover/src/machine.rs",
                "src/osp/OneStepProverHostIo.sol"
            ],
            "files": [
                "3f226a0ecf91ceed3688a2fc41969fae1f32d03d/nitro/arbitrator/prover/src/machine.rs",
                "940373b68d0e9cffa006eb9e6d0b4376138d531c/nitro-contracts/src/osp/OneStepProverHostIo.sol"
            ]
        }
    ],
    "affected_files": {
        "OneStepProverHostIo.sol": "// Copyright 2021-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/MerkleProof.sol\";\nimport \"../state/MultiStack.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"../state/ModuleMemory.sol\";\nimport \"./IOneStepProver.sol\";\nimport \"./ICustomDAProofValidator.sol\";\nimport \"../bridge/Messages.sol\";\nimport \"../bridge/IBridge.sol\";\n\ncontract OneStepProverHostIo is IOneStepProver {\n    using GlobalStateLib for GlobalState;\n    using MachineLib for Machine;\n    using MerkleProofLib for MerkleProof;\n    using ModuleMemoryLib for ModuleMemory;\n    using MultiStackLib for MultiStack;\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n    using StackFrameLib for StackFrameWindow;\n\n    uint256 private constant LEAF_SIZE = 32;\n    uint256 private constant INBOX_NUM = 2;\n    uint64 private constant INBOX_HEADER_LEN = 40;\n    uint64 private constant DELAYED_HEADER_LEN = 112 + 1;\n\n    // CustomDA proof format constants\n    uint256 private constant CERT_SIZE_LEN = 8;\n    uint256 private constant CLAIMED_VALID_LEN = 1;\n\n    ICustomDAProofValidator public immutable customDAValidator;\n\n    constructor(\n        address _customDAValidator\n    ) {\n        customDAValidator = ICustomDAProofValidator(_customDAValidator);\n    }\n\n    function setLeafByte(bytes32 oldLeaf, uint256 idx, uint8 val) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeGetOrSetBytes32(\n        Machine memory mach,\n        Module memory mod,\n        GlobalState memory state,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.BYTES32_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (!mod.moduleMemory.isValidLeaf(ptr)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 startLeafContents;\n        MerkleProof memory merkleProof;\n        (startLeafContents, proofOffset, merkleProof) =\n            mod.moduleMemory.proveLeaf(leafIdx, proof, proofOffset);\n\n        if (inst.opcode == Instructions.GET_GLOBAL_STATE_BYTES32) {\n            mod.moduleMemory.merkleRoot =\n                merkleProof.computeRootFromMemory(leafIdx, state.bytes32Vals[idx]);\n        } else if (inst.opcode == Instructions.SET_GLOBAL_STATE_BYTES32) {\n            state.bytes32Vals[idx] = startLeafContents;\n        } else {\n            revert(\"BAD_GLOBAL_STATE_OPCODE\");\n        }\n    }\n\n    function executeGetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        mach.valueStack.push(ValueLib.newI64(state.u64Vals[idx]));\n    }\n\n    function executeSetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint64 val = mach.valueStack.pop().assumeI64();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        state.u64Vals[idx] = val;\n    }\n\n    uint256 internal constant BLS_MODULUS =\n        52435875175126190479447740508185965837690552500527637822603658699938581184513;\n    uint256 internal constant PRIMITIVE_ROOT_OF_UNITY =\n        10238227357739495823651030575849232062558860180284477541189508159991286009131;\n\n    // Computes b**e % m\n    // Really pure but the Solidity compiler sees the staticcall and requires view\n    function modExp256(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        bytes memory modExpInput = abi.encode(32, 32, 32, b, e, m);\n        (bool modexpSuccess, bytes memory modExpOutput) = address(0x05).staticcall(modExpInput);\n        require(modexpSuccess, \"MODEXP_FAILED\");\n        require(modExpOutput.length == 32, \"MODEXP_WRONG_LENGTH\");\n        return uint256(bytes32(modExpOutput));\n    }\n\n    function executeReadPreImage(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 preimageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        if (preimageOffset % 32 != 0 || ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) =\n            mod.moduleMemory.proveLeaf(leafIdx, proof, proofOffset);\n\n        bytes memory extracted;\n        uint8 proofType = uint8(proof[proofOffset]);\n        proofOffset++;\n        // These values must be kept in sync with `arbitrator/arbutil/src/types.rs`\n        // and `arbutil/preimage_type.go` (both in the nitro repo).\n        if (inst.argumentData == 0) {\n            // The machine is asking for a keccak256 preimage\n\n            if (proofType == 0) {\n                bytes calldata preimage = proof[proofOffset:];\n                require(keccak256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n                uint256 preimageEnd = preimageOffset + 32;\n                if (preimageEnd > preimage.length) {\n                    preimageEnd = preimage.length;\n                }\n                extracted = preimage[preimageOffset:preimageEnd];\n            } else {\n                // TODO: support proving via an authenticated contract\n                revert(\"UNKNOWN_PREIMAGE_PROOF\");\n            }\n        } else if (inst.argumentData == 1) {\n            // The machine is asking for a sha2-256 preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n            bytes calldata preimage = proof[proofOffset:];\n            require(sha256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n            uint256 preimageEnd = preimageOffset + 32;\n            if (preimageEnd > preimage.length) {\n                preimageEnd = preimage.length;\n            }\n            extracted = preimage[preimageOffset:preimageEnd];\n        } else if (inst.argumentData == 2) {\n            // The machine is asking for an Ethereum versioned hash preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n\n            // kzgProof should be a valid input to the EIP-4844 point evaluation precompile at address 0x0A.\n            // It should prove the preimageOffset/32'th word of the machine's requested KZG commitment.\n            bytes calldata kzgProof = proof[proofOffset:];\n\n            require(bytes32(kzgProof[:32]) == leafContents, \"KZG_PROOF_WRONG_HASH\");\n\n            uint256 fieldElementsPerBlob;\n            uint256 blsModulus;\n            {\n                (bool success, bytes memory kzgParams) = address(0x0A).staticcall(kzgProof);\n                require(success, \"INVALID_KZG_PROOF\");\n                require(kzgParams.length > 0, \"KZG_PRECOMPILE_MISSING\");\n                (fieldElementsPerBlob, blsModulus) = abi.decode(kzgParams, (uint256, uint256));\n            }\n\n            // With a hardcoded PRIMITIVE_ROOT_OF_UNITY, we can only support this BLS modulus.\n            // It may be worth in the future supporting arbitrary BLS moduli, but we would likely need to\n            // validate a user-supplied root of unity.\n            require(blsModulus == BLS_MODULUS, \"UNKNOWN_BLS_MODULUS\");\n\n            // If preimageOffset is greater than or equal to the blob size, leave extracted empty and call it here.\n            if (preimageOffset < fieldElementsPerBlob * 32) {\n                // We need to compute what point the polynomial should be evaluated at to get the right part of the preimage.\n                // KZG commitments use a bit reversal permutation to order the roots of unity.\n                // To account for that, we reverse the bit order of the index.\n                uint256 bitReversedIndex = 0;\n                // preimageOffset was required to be 32 byte aligned above\n                uint256 tmp = preimageOffset / 32;\n                for (uint256 i = 1; i < fieldElementsPerBlob; i <<= 1) {\n                    bitReversedIndex <<= 1;\n                    if (tmp & 1 == 1) {\n                        bitReversedIndex |= 1;\n                    }\n                    tmp >>= 1;\n                }\n\n                // First, we get the root of unity of order 2**fieldElementsPerBlob.\n                // We start with a root of unity of order 2**32 and then raise it to\n                // the power of (2**32)/fieldElementsPerBlob to get root of unity we need.\n                uint256 rootOfUnityPower = (1 << 32) / fieldElementsPerBlob;\n                // Then, we raise the root of unity to the power of bitReversedIndex,\n                // to retrieve this word of the KZG commitment.\n                rootOfUnityPower *= bitReversedIndex;\n                // z is the point the polynomial is evaluated at to retrieve this word of data\n                uint256 z = modExp256(PRIMITIVE_ROOT_OF_UNITY, rootOfUnityPower, blsModulus);\n                require(bytes32(kzgProof[32:64]) == bytes32(z), \"KZG_PROOF_WRONG_Z\");\n\n                extracted = kzgProof[64:96];\n            }\n        } else if (inst.argumentData == 3) {\n            // The machine is asking for a CustomDA preimage\n            require(address(customDAValidator) != address(0), \"CUSTOM_DA_VALIDATOR_NOT_SUPPORTED\");\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n\n            bytes calldata customProof = proof[proofOffset:];\n\n            // Extract certificate size and certificate\n            require(customProof.length >= CERT_SIZE_LEN, \"CUSTOM_DA_PROOF_TOO_SHORT\");\n\n            uint256 certSize = uint256(uint64(bytes8(customProof[0:CERT_SIZE_LEN])));\n\n            require(customProof.length >= CERT_SIZE_LEN + certSize, \"PROOF_TOO_SHORT_FOR_CERT\");\n\n            // Extract and validate certificate\n            bytes calldata certificate = customProof[CERT_SIZE_LEN:CERT_SIZE_LEN + certSize];\n\n            // Verify this is the certificate the machine requested\n            require(keccak256(certificate) == leafContents, \"WRONG_CERTIFICATE_HASH\");\n\n            // Delegate to custom validator with proven values and full proof\n            extracted =\n                customDAValidator.validateReadPreimage(leafContents, preimageOffset, customProof);\n\n            // Ensure we got a valid response\n            require(extracted.length > 0 && extracted.length <= 32, \"INVALID_CUSTOM_DA_RESPONSE\");\n        } else {\n            revert(\"UNKNOWN_PREIMAGE_TYPE\");\n        }\n\n        for (uint256 i = 0; i < extracted.length; i++) {\n            leafContents = setLeafByte(leafContents, i, uint8(extracted[i]));\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n\n        mach.valueStack.push(ValueLib.newI32(uint32(extracted.length)));\n    }\n\n    function executeValidatePreimage(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal view {\n        uint256 preimageType = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n\n        // Prove the hash in memory\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) =\n            mod.moduleMemory.proveLeaf(leafIdx, proof, proofOffset);\n\n        if (preimageType == 3) {\n            require(address(customDAValidator) != address(0), \"CUSTOM_DA_VALIDATOR_NOT_SUPPORTED\");\n            if (validateAndCheckCertificate(proof, proofOffset, leafContents)) {\n                mach.valueStack.push(ValueLib.newI32(1));\n            } else {\n                mach.valueStack.push(ValueLib.newI32(0));\n            }\n        } else {\n            // Non-CustomDA always valid\n            mach.valueStack.push(ValueLib.newI32(1));\n        }\n\n        // Update merkle root\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n    }\n\n    function validateAndCheckCertificate(\n        bytes calldata proof,\n        uint256 proofOffset,\n        bytes32 expectedHash\n    ) internal view returns (bool) {\n        // Proof format is: [certSize(8), certificate, claimedValid(1), validityProof...]\n        uint256 certSize = uint256(uint64(bytes8(proof[proofOffset:proofOffset + CERT_SIZE_LEN])));\n\n        require(\n            proof.length >= proofOffset + CERT_SIZE_LEN + certSize + CLAIMED_VALID_LEN,\n            \"PROOF_TOO_SHORT\"\n        );\n\n        bytes calldata certificate =\n            proof[proofOffset + CERT_SIZE_LEN:proofOffset + CERT_SIZE_LEN + certSize];\n\n        // Verify this is the certificate the machine requested\n        require(keccak256(certificate) == expectedHash, \"WRONG_CERTIFICATE_HASH\");\n\n        bool claimedValid = uint8(proof[proofOffset + CERT_SIZE_LEN + certSize]) != 0;\n\n        // Pass the full proof segment to validateCertificate\n        bytes calldata validationProof = proof[proofOffset:];\n\n        // Check actual validity and verify claims match\n        bool isValid = customDAValidator.validateCertificate(validationProof);\n        require(\n            isValid == claimedValid,\n            isValid ? \"CLAIMED_INVALID_BUT_VALID\" : \"CLAIMED_VALID_BUT_INVALID\"\n        );\n        return isValid;\n    }\n\n    function validateSequencerInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        require(message.length >= INBOX_HEADER_LEN, \"BAD_SEQINBOX_PROOF\");\n\n        uint64 afterDelayedMsg;\n        (afterDelayedMsg,) = Deserialize.u64(message, 32);\n        bytes32 messageHash = keccak256(message);\n        bytes32 beforeAcc;\n        bytes32 delayedAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.sequencerInboxAccs(msgIndex - 1);\n        }\n        if (afterDelayedMsg > 0) {\n            delayedAcc = execCtx.bridge.delayedInboxAccs(afterDelayedMsg - 1);\n        }\n        bytes32 acc = keccak256(abi.encodePacked(beforeAcc, messageHash, delayedAcc));\n        require(acc == execCtx.bridge.sequencerInboxAccs(msgIndex), \"BAD_SEQINBOX_MESSAGE\");\n        return true;\n    }\n\n    function validateDelayedInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        require(message.length >= DELAYED_HEADER_LEN, \"BAD_DELAYED_PROOF\");\n\n        bytes32 beforeAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.delayedInboxAccs(msgIndex - 1);\n        }\n\n        bytes32 messageDataHash = keccak256(message[DELAYED_HEADER_LEN:]);\n        bytes1 kind = message[0];\n        uint256 sender;\n        (sender,) = Deserialize.u256(message, 1);\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(kind, uint160(sender), message[33:DELAYED_HEADER_LEN], messageDataHash)\n        );\n        bytes32 acc = Messages.accumulateInboxMessage(beforeAcc, messageHash);\n\n        require(acc == execCtx.bridge.delayedInboxAccs(msgIndex), \"BAD_DELAYED_MESSAGE\");\n        return true;\n    }\n\n    function executeReadInboxMessage(\n        ExecutionContext calldata execCtx,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 messageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint256 msgIndex = mach.valueStack.pop().assumeI64();\n        if (\n            inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER\n                && msgIndex >= execCtx.maxInboxMessagesRead\n        ) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) =\n            mod.moduleMemory.proveLeaf(leafIdx, proof, proofOffset);\n\n        {\n            // TODO: support proving via an authenticated contract\n            require(proof[proofOffset] == 0, \"UNKNOWN_INBOX_PROOF\");\n            proofOffset++;\n\n            function(ExecutionContext calldata, uint64, bytes calldata) internal view returns (bool)\n                inboxValidate;\n\n            bool success;\n            if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER) {\n                inboxValidate = validateSequencerInbox;\n            } else if (inst.argumentData == Instructions.INBOX_INDEX_DELAYED) {\n                inboxValidate = validateDelayedInbox;\n            } else {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            success = inboxValidate(execCtx, uint64(msgIndex), proof[proofOffset:]);\n            if (!success) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n        }\n\n        require(proof.length >= proofOffset, \"BAD_MESSAGE_PROOF\");\n        uint256 messageLength = proof.length - proofOffset;\n\n        uint32 i = 0;\n        for (; i < 32 && messageOffset + i < messageLength; i++) {\n            leafContents =\n                setLeafByte(leafContents, i, uint8(proof[proofOffset + messageOffset + i]));\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n        mach.valueStack.push(ValueLib.newI32(i));\n    }\n\n    function executeHaltAndSetFinished(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.status = MachineStatus.FINISHED;\n    }\n\n    function isPowerOfTwo(\n        uint256 value\n    ) internal pure returns (bool) {\n        return value != 0 && (value & (value - 1) == 0);\n    }\n\n    function proveLastLeaf(\n        Machine memory mach,\n        uint256 offset,\n        bytes calldata proof\n    )\n        internal\n        pure\n        returns (uint256 leaf, MerkleProof memory leafProof, MerkleProof memory zeroProof)\n    {\n        string memory prefix = \"Module merkle tree:\";\n        bytes32 root = mach.modulesRoot;\n\n        {\n            Module memory leafModule;\n            uint32 leaf32;\n            (leafModule, offset) = Deserialize.module(proof, offset);\n            (leaf32, offset) = Deserialize.u32(proof, offset);\n            (leafProof, offset) = Deserialize.merkleProof(proof, offset);\n            leaf = uint256(leaf32);\n\n            bytes32 compRoot = leafProof.computeRootFromModule(leaf, leafModule);\n            require(compRoot == root, \"WRONG_ROOT_FOR_LEAF\");\n        }\n\n        // if tree is unbalanced, check that the next leaf is 0\n        bool balanced = isPowerOfTwo(leaf + 1);\n        if (balanced) {\n            require(1 << leafProof.counterparts.length == leaf + 1, \"WRONG_LEAF\");\n        } else {\n            (zeroProof, offset) = Deserialize.merkleProof(proof, offset);\n            bytes32 compRoot = zeroProof.computeRootUnsafe(leaf + 1, 0, prefix);\n            require(compRoot == root, \"WRONG_ROOT_FOR_ZERO\");\n        }\n\n        return (leaf, leafProof, zeroProof);\n    }\n\n    function executeLinkModule(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        string memory prefix = \"Module merkle tree:\";\n        bytes32 root = mach.modulesRoot;\n\n        uint256 pointer = mach.valueStack.pop().assumeI32();\n        if (!mod.moduleMemory.isValidLeaf(pointer)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        (bytes32 userMod, uint256 offset,) =\n            mod.moduleMemory.proveLeaf(pointer / LEAF_SIZE, proof, 0);\n\n        (uint256 leaf,, MerkleProof memory zeroProof) = proveLastLeaf(mach, offset, proof);\n\n        bool balanced = isPowerOfTwo(leaf + 1);\n        if (balanced) {\n            mach.modulesRoot = MerkleProofLib.growToNewRoot(root, leaf + 1, userMod, 0, prefix);\n        } else {\n            mach.modulesRoot = zeroProof.computeRootUnsafe(leaf + 1, userMod, prefix);\n        }\n\n        mach.valueStack.push(ValueLib.newI32(uint32(leaf + 1)));\n    }\n\n    function executeUnlinkModule(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        string memory prefix = \"Module merkle tree:\";\n\n        (uint256 leaf, MerkleProof memory leafProof,) = proveLastLeaf(mach, 0, proof);\n\n        bool shrink = isPowerOfTwo(leaf);\n        if (shrink) {\n            mach.modulesRoot = leafProof.counterparts[leafProof.counterparts.length - 1];\n        } else {\n            mach.modulesRoot = leafProof.computeRootUnsafe(leaf, 0, prefix);\n        }\n    }\n\n    function executeGlobalStateAccess(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint16 opcode = inst.opcode;\n\n        GlobalState memory state;\n        uint256 proofOffset = 0;\n        (state, proofOffset) = Deserialize.globalState(proof, proofOffset);\n        require(state.hash() == mach.globalStateHash, \"BAD_GLOBAL_STATE\");\n\n        if (\n            opcode == Instructions.GET_GLOBAL_STATE_BYTES32\n                || opcode == Instructions.SET_GLOBAL_STATE_BYTES32\n        ) {\n            executeGetOrSetBytes32(mach, mod, state, inst, proof[proofOffset:]);\n        } else if (opcode == Instructions.GET_GLOBAL_STATE_U64) {\n            executeGetU64(mach, state);\n        } else if (opcode == Instructions.SET_GLOBAL_STATE_U64) {\n            executeSetU64(mach, state);\n        } else {\n            revert(\"INVALID_GLOBALSTATE_OPCODE\");\n        }\n\n        mach.globalStateHash = state.hash();\n    }\n\n    function executeNewCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // cannot create new cothread from inside cothread\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        mach.frameMultiStack.pushNew();\n        mach.valueMultiStack.pushNew();\n    }\n\n    function provePopCothread(MultiStack memory multi, bytes calldata proof) internal pure {\n        uint256 proofOffset = 0;\n        bytes32 newInactiveCoThread;\n        bytes32 newRemaining;\n        (newInactiveCoThread, proofOffset) = Deserialize.b32(proof, proofOffset);\n        (newRemaining, proofOffset) = Deserialize.b32(proof, proofOffset);\n        if (newInactiveCoThread == MultiStackLib.NO_STACK_HASH) {\n            require(newRemaining == bytes32(0), \"WRONG_COTHREAD_EMPTY\");\n            require(multi.remainingHash == bytes32(0), \"WRONG_COTHREAD_EMPTY\");\n        } else {\n            require(\n                keccak256(abi.encodePacked(\"cothread:\", newInactiveCoThread, newRemaining))\n                    == multi.remainingHash,\n                \"WRONG_COTHREAD_POP\"\n            );\n        }\n        multi.remainingHash = newRemaining;\n        multi.inactiveStackHash = newInactiveCoThread;\n    }\n\n    function executePopCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // cannot pop cothread from inside cothread\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (mach.frameMultiStack.inactiveStackHash == MultiStackLib.NO_STACK_HASH) {\n            // cannot pop cothread if there isn't one\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        provePopCothread(mach.valueMultiStack, proof);\n        provePopCothread(mach.frameMultiStack, proof[64:]);\n    }\n\n    function executeSwitchCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        if (mach.frameMultiStack.inactiveStackHash == MultiStackLib.NO_STACK_HASH) {\n            // cannot switch cothread if there isn't one\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (inst.argumentData == 0) {\n            if (mach.recoveryPc == MachineLib.NO_RECOVERY_PC) {\n                // switching to main thread, from main thread\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            mach.recoveryPc = MachineLib.NO_RECOVERY_PC;\n        } else {\n            if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n                // switching from cothread to cothread\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            mach.setRecoveryFromPc(uint32(inst.argumentData));\n        }\n        mach.switchCoThreadStacks();\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata execCtx,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external view override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(ExecutionContext calldata, Machine memory, Module memory, Instruction calldata, bytes calldata)\n            internal\n            view impl;\n\n        if (\n            opcode >= Instructions.GET_GLOBAL_STATE_BYTES32\n                && opcode <= Instructions.SET_GLOBAL_STATE_U64\n        ) {\n            impl = executeGlobalStateAccess;\n        } else if (opcode == Instructions.VALIDATE_CERTIFICATE) {\n            impl = executeValidatePreimage;\n        } else if (opcode == Instructions.READ_PRE_IMAGE) {\n            impl = executeReadPreImage;\n        } else if (opcode == Instructions.READ_INBOX_MESSAGE) {\n            impl = executeReadInboxMessage;\n        } else if (opcode == Instructions.HALT_AND_SET_FINISHED) {\n            impl = executeHaltAndSetFinished;\n        } else if (opcode == Instructions.LINK_MODULE) {\n            impl = executeLinkModule;\n        } else if (opcode == Instructions.UNLINK_MODULE) {\n            impl = executeUnlinkModule;\n        } else if (opcode == Instructions.NEW_COTHREAD) {\n            impl = executeNewCoThread;\n        } else if (opcode == Instructions.POP_COTHREAD) {\n            impl = executePopCoThread;\n        } else if (opcode == Instructions.SWITCH_COTHREAD) {\n            impl = executeSwitchCoThread;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(execCtx, mach, mod, inst, proof);\n    }\n}\n"
    }
}