{
    "vfp_id": "vfp_00182",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ]
            },
            "title": "BalancerPoolToken permit signatures cannot be revoked",
            "description": "The BalancerPoolToken contract implements ERC2612 permit functionality but lacks a mechanism for users to revoke a signed permit before its deadline. Once a signature is shared, the only way to invalidate it is to have it consumed or wait for expiration. A user cannot proactively invalidate a leaked or prematurely shared signature, leaving them exposed to potential unauthorized spending until the deadline passes. This reduces user control over permissions and increases risk in scenarios involving third-party relayers or compromised clients.\n",
            "severity": "Informational",
            "location": [
                "BalancerPoolToken.sol::permit#125-149",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1009"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/BalancerPoolToken.sol"
            ]
        }
    ],
    "affected_files": {
        "BalancerPoolToken.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { Nonces } from \"@openzeppelin/contracts/utils/Nonces.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { IRateProvider } from \"@balancer-labs/v3-interfaces/contracts/vault/IRateProvider.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\n\nimport { VaultGuard } from \"./VaultGuard.sol\";\n\n/**\n * @notice `BalancerPoolToken` is a fully ERC20-compatible token to be used as the base contract for Balancer Pools,\n * with all the data and implementation delegated to the ERC20Multitoken contract.\n\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n */\ncontract BalancerPoolToken is IERC20, IERC20Metadata, IERC20Permit, IRateProvider, EIP712, Nonces, ERC165, VaultGuard {\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // @dev Permit deadline has expired.\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    // @dev Mismatched signature.\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    // EIP712 also defines _name.\n    string private _bptName;\n    string private _bptSymbol;\n\n    constructor(IVault vault_, string memory bptName, string memory bptSymbol) EIP712(bptName, \"1\") VaultGuard(vault_) {\n        _bptName = bptName;\n        _bptSymbol = bptSymbol;\n    }\n\n    /// @inheritdoc IERC20Metadata\n    function name() public view returns (string memory) {\n        return _bptName;\n    }\n\n    /// @inheritdoc IERC20Metadata\n    function symbol() public view returns (string memory) {\n        return _bptSymbol;\n    }\n\n    /// @inheritdoc IERC20Metadata\n    function decimals() public pure returns (uint8) {\n        // Always 18 decimals for BPT.\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view returns (uint256) {\n        return _vault.totalSupply(address(this));\n    }\n\n    function getVault() public view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view returns (uint256) {\n        return _vault.balanceOf(address(this), account);\n    }\n\n    /// @inheritdoc IERC20\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // Vault will perform the transfer and call emitTransfer to emit the event from this contract.\n        _vault.transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _vault.allowance(address(this), owner, spender);\n    }\n\n    /// @inheritdoc IERC20\n    function approve(address spender, uint256 amount) public returns (bool) {\n        // Vault will perform the approval and call emitApproval to emit the event from this contract.\n        _vault.approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        // Vault will perform the transfer and call emitTransfer to emit the event from this contract.\n        _vault.transferFrom(msg.sender, from, to, amount);\n        return true;\n    }\n\n    /// Accounting is centralized in the MultiToken contract, and the actual transfers and approvals\n    /// are done there. Operations can be initiated from either the token contract or the MultiToken.\n    ///\n    /// To maintain compliance with the ERC-20 standard, and conform to the expectations of off-chain processes,\n    /// the MultiToken calls `emitTransfer` and `emitApproval` during those operations, so that the event is emitted\n    /// only from the token contract. These events are NOT defined in the MultiToken contract.\n\n    /// @dev Emit the Transfer event. This function can only be called by the MultiToken.\n    function emitTransfer(address from, address to, uint256 amount) external onlyVault {\n        emit Transfer(from, to, amount);\n    }\n\n    /// @dev Emit the Approval event. This function can only be called by the MultiToken.\n    function emitApproval(address owner, address spender, uint256 amount) external onlyVault {\n        emit Approval(owner, spender, amount);\n    }\n\n    // @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _vault.approve(owner, spender, amount);\n    }\n\n    // @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    // @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Get the BPT rate, which is defined as: pool invariant/total supply.\n     * @dev The Vault Extension defines a default implementation (`getBptRate`) to calculate the rate\n     * of any given pool, which should be sufficient in nearly all cases.\n     *\n     * @return rate Rate of the pool's BPT\n     */\n    function getRate() public view returns (uint256) {\n        return getVault().getBptRate(address(this));\n    }\n}\n"
    }
}