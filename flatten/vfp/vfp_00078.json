{
    "vfp_id": "vfp_00078",
    "project_name": "cantina_sky_oft_evm_sep2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Minor issues, Typos & Documentation",
            "description": "This finding encompasses several minor issues in the codebase, including outdated Solidity pragma version, inaccurate comments, incorrect inheritance descriptions, formatting issues in conditional statements, and lack of clarity in documentation regarding unsupported token behaviors. The root cause is insufficient code review and documentation maintenance. These issues do not directly lead to security exploits but reduce code clarity and maintainability. An attacker cannot directly exploit these issues, but they may lead to misunderstandings during future development or audits. The impact is limited to code quality and developer experience, with no direct financial or operational risk.\n",
            "severity": "Informational",
            "location": [
                "SkyRateLimiter.sol#L2",
                "SkyRateLimiter.sol#L15",
                "SkyOFTAdapterMintBurn.sol#L16",
                "SkyOFTAdapterMintBurn.sol#L117",
                "SkyOFTAdapter.sol#L89",
                "SkyOFTAdapter.sol#L122-L123",
                "SkyOFTAdapter.sol#L139"
            ],
            "files": [
                "sky-oapp-oft/contracts/SkyRateLimiter.sol",
                "sky-oapp-oft/contracts/interfaces/ISkyRateLimiter.sol",
                "sky-oapp-oft/contracts/SkyOFTCore.sol",
                "sky-oapp-oft/contracts/SkyOFTAdapter.sol",
                "sky-oapp-oft/contracts/SkyOFTAdapterMintBurn.sol"
            ]
        }
    ],
    "affected_files": {
        "SkyRateLimiter.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport {\n    RateLimit,\n    RateLimitConfig,\n    RateLimitDirection,\n    RateLimitAccountingType,\n    ISkyRateLimiter\n} from \"./interfaces/ISkyRateLimiter.sol\";\n\n/**\n * @title SkyRateLimiter\n * @dev Abstract contract for implementing net and gross rate limiting functionality.\n * @dev Toggle between net and gross accounting by calling `_setRateLimitAccountingType`.\n * ---------------------------------------------------------------------------------------------------------------------\n * Net accounting allows two operations to offset each other's net impact (e.g., inflow v.s. outflow of assets).\n * A flexible rate limit that grows during congestive periods and shrinks during calm periods could give some\n * leeway when someone tries to forcefully congest the network, while still preventing huge amounts to be sent at once.\n * ---------------------------------------------------------------------------------------------------------------------\n * Gross accounting does not allow any offsetting and will revert if the amount to be sent or received,\n * is greater than the available capacity.\n * Designed to be inherited by other contracts requiring rate limiting to protect resources/services from excessive use.\n */\nabstract contract SkyRateLimiter is ISkyRateLimiter {\n    RateLimitAccountingType public rateLimitAccountingType;\n\n    // Tracks rate limits for outbound transactions to a dstEid.\n    mapping(uint32 dstEid => RateLimit) public outboundRateLimits;\n    // Tracks rate limits for inbound transactions from a srcEid.\n    mapping(uint32 srcEid => RateLimit) public inboundRateLimits;\n\n    /**\n     * @notice Get the current amount that can be sent to this destination endpoint id for the given rate limit window.\n     * @param _dstEid The destination endpoint id.\n     * @return currentAmountInFlight The current amount that was sent in this window.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function getAmountCanBeSent(\n        uint32 _dstEid\n    ) public view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        RateLimit storage orl = outboundRateLimits[_dstEid];\n        return _amountCanBeSent(orl.amountInFlight, orl.lastUpdated, orl.limit, orl.window);\n    }\n\n    /**\n     * @notice Get the current amount that can be received from the source endpoint id for the given rate limit window.\n     * @param _srcEid The source endpoint id.\n     * @return currentAmountInFlight The current amount that has been received in this window.\n     * @return amountCanBeReceived The amount that can be received.\n     */\n    function getAmountCanBeReceived(\n        uint32 _srcEid\n    ) public view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeReceived) {\n        RateLimit storage irl = inboundRateLimits[_srcEid];\n        return _amountCanBeReceived(irl.amountInFlight, irl.lastUpdated, irl.limit, irl.window);\n    }\n\n    /**\n     * @notice Sets the rate limits.\n     * @param _rateLimitConfigs A `RateLimitConfig[]` array representing the rate limit configurations.\n     * @param _direction Indicates whether the rate limits being set are for outbound or inbound.\n     */\n    function _setRateLimits(RateLimitConfig[] memory _rateLimitConfigs, RateLimitDirection _direction) internal virtual {\n        unchecked {\n            for (uint256 i = 0; i < _rateLimitConfigs.length; i++) {\n                RateLimit storage rateLimit = _direction == RateLimitDirection.Outbound\n                    ? outboundRateLimits[_rateLimitConfigs[i].eid]\n                    : inboundRateLimits[_rateLimitConfigs[i].eid];\n\n                // Checkpoint the existing rate limit to not retroactively apply the new decay rate.\n                _checkAndUpdateRateLimit(_rateLimitConfigs[i].eid, 0, _direction);\n\n                // Does NOT reset the amountInFlight/lastUpdated of an existing rate limit.\n                rateLimit.limit = _rateLimitConfigs[i].limit;\n                rateLimit.window = _rateLimitConfigs[i].window;\n            }\n        }\n        emit RateLimitsChanged(_rateLimitConfigs, _direction);\n    }\n\n    /**\n     * @notice Resets the rate limits (sets amountInFlight to 0) for the given endpoint ids.\n     * @dev This is useful when the rate limit accounting type is changed.\n     * @param _eids The endpoint ids to reset the rate limits for.\n     * @param _direction The direction of the rate limits to reset.\n     */\n    function _resetRateLimits(uint32[] memory _eids, RateLimitDirection _direction) internal virtual {\n        for (uint256 i = 0; i < _eids.length; i++) {\n            RateLimit storage rateLimit = _direction == RateLimitDirection.Outbound\n                ? outboundRateLimits[_eids[i]]\n                : inboundRateLimits[_eids[i]];\n\n            rateLimit.amountInFlight = 0;\n            rateLimit.lastUpdated = uint128(block.timestamp);\n        }\n        emit RateLimitsReset(_eids, _direction);\n    }\n\n     /**\n     * @notice Sets the rate limit accounting type.\n     * @dev You may want to call `_resetRateLimits` after changing the rate limit accounting type.\n     * @param _rateLimitAccountingType The new rate limit accounting type.\n     */\n    function _setRateLimitAccountingType(RateLimitAccountingType _rateLimitAccountingType) internal {\n        rateLimitAccountingType = _rateLimitAccountingType;\n        emit RateLimitAccountingTypeSet(_rateLimitAccountingType);\n    }\n\n    /**\n     * @dev Calculates current amount in flight and the available capacity based on configuration and time elapsed.\n     * Applies a linear decay to compute how much 'amountInFlight' remains based on the time elapsed since last update.\n     * @param _amountInFlight The total amount that was in flight at the last update.\n     * @param _lastUpdated The timestamp (in seconds) when the last update occurred.\n     * @param _limit The maximum allowable amount within the specified window.\n     * @param _window The time window (in seconds) for which the limit applies.\n     *\n     * @return currentAmountInFlight The decayed amount of in-flight based on the elapsed time since lastUpdated.\n     * @return availableCapacity The amount of capacity available for new activity.\n     * @dev If the time since lastUpdated exceeds the window:\n     *      - currentAmountInFlight is 0.\n     *      - availableCapacity is the full limit.\n     */\n    function _calculateDecay(\n        uint256 _amountInFlight,\n        uint128 _lastUpdated,\n        uint256 _limit,\n        uint48 _window\n    ) internal view returns (uint256 currentAmountInFlight, uint256 availableCapacity) {\n        uint256 timeSinceLastUpdate = block.timestamp - _lastUpdated;\n        if (timeSinceLastUpdate >= _window) {\n            return (0, _limit);\n        } else {\n            uint256 decay = (_limit * timeSinceLastUpdate) / _window;\n            currentAmountInFlight = _amountInFlight > decay ? _amountInFlight - decay : 0;\n            availableCapacity = _limit > currentAmountInFlight ? _limit - currentAmountInFlight : 0;\n        }\n    }\n\n    /**\n     * @notice Checks current amount in flight and amount that can be sent for a given rate limit window.\n     * @param _amountInFlight The amount in the current window.\n     * @param _lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param _limit This represents the maximum allowed amount within a given window.\n     * @param _window Defines the duration of the rate limiting window.\n     * @return currentAmountInFlight The amount in the current window.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function _amountCanBeSent(\n        uint256 _amountInFlight,\n        uint128 _lastUpdated,\n        uint256 _limit,\n        uint48 _window\n    ) internal view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        (currentAmountInFlight, amountCanBeSent) = _calculateDecay(_amountInFlight, _lastUpdated, _limit, _window);\n    }\n\n    /**\n     * @notice Checks current amount in flight and amount that can be received for a given rate limit window.\n     * @param _amountInFlight The amount in the current window.\n     * @param _lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param _limit This represents the maximum allowed amount within a given window.\n     * @param _window Defines the duration of the rate limiting window.\n     * @return currentAmountInFlight The amount in the current window.\n     * @return amountCanBeReceived The amount that can be received.\n     */\n    function _amountCanBeReceived(\n        uint256 _amountInFlight,\n        uint128 _lastUpdated,\n        uint256 _limit,\n        uint48 _window\n    ) internal view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeReceived) {\n        (currentAmountInFlight, amountCanBeReceived) = _calculateDecay(_amountInFlight, _lastUpdated, _limit, _window);\n    }\n    \n    /**\n     * @notice Checks and updates the rate limit based on the endpoint ID and amount.\n     * @param _eid The endpoint ID for which the rate limit needs to be checked and updated.\n     * @param _amount The amount to add to the current amount in flight.\n     * @param _direction The direction (inbound or outbound) of the rate limits being checked.\n     */\n    function _checkAndUpdateRateLimit(uint32 _eid, uint256 _amount, RateLimitDirection _direction) internal {\n        // Select the correct mapping based on the direction of the rate limit\n        RateLimit storage rl = _direction == RateLimitDirection.Outbound\n            ? outboundRateLimits[_eid]\n            : inboundRateLimits[_eid];\n\n        // Calculate current amount in flight and available capacity\n        (uint256 currentAmountInFlight, uint256 availableCapacity) = _calculateDecay(\n            rl.amountInFlight,\n            rl.lastUpdated,\n            rl.limit,\n            rl.window\n        );\n\n        // Check if the requested amount exceeds the available capacity\n        if (_amount > availableCapacity) revert RateLimitExceeded();\n\n        // Update the rate limit with the new amount in flight and the current timestamp\n        rl.amountInFlight = currentAmountInFlight + _amount;\n        rl.lastUpdated = uint128(block.timestamp);\n\n        if (rateLimitAccountingType == RateLimitAccountingType.Net) {\n            RateLimit storage oppositeRL = _direction == RateLimitDirection.Outbound\n                ? inboundRateLimits[_eid]\n                : outboundRateLimits[_eid];\n            (uint256 otherCurrentAmountInFlight,) = _calculateDecay(\n                oppositeRL.amountInFlight,\n                oppositeRL.lastUpdated,\n                oppositeRL.limit,\n                oppositeRL.window\n            );\n            unchecked {\n                oppositeRL.amountInFlight = otherCurrentAmountInFlight > _amount ? otherCurrentAmountInFlight - _amount : 0;\n            }\n            oppositeRL.lastUpdated = uint128(block.timestamp);\n        }\n    }\n}",
        "ISkyRateLimiter.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @notice Rate Limit struct\n * @param lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n * @param window Defines the duration of the rate limiting window.\n * @param amountInFlight Current amount within the rate limit window.\n * @param limit This represents the maximum allowed amount within a given window.\n */\nstruct RateLimit {\n    uint128 lastUpdated;    // 16 bytes\n    uint48 window;          // 6 bytes\n    uint256 amountInFlight; // 32 bytes (new slot)\n    uint256 limit;          // 32 bytes (new slot)\n}\n\n/**\n* @notice Rate Limit Configuration struct.\n * @param eid The endpoint id.\n * @param window Defines the duration of the rate limiting window.\n * @param limit This represents the maximum allowed amount within a given window.\n */\nstruct RateLimitConfig {\n    uint32 eid;      // 4 bytes\n    uint48 window;   // 6 bytes\n    uint256 limit;   // 32 bytes (new slot)\n}\n\n// @dev Define an enum to clearly distinguish between inbound and outbound rate limits.\nenum RateLimitDirection {\n    Inbound,\n    Outbound\n}\n\n// @dev Define an enum to distinguish between net and gross accounting types for rate limits.\nenum RateLimitAccountingType {\n    Net,\n    Gross\n}\n\n/**\n * @notice Interface for the SkyRateLimiter.\n * @dev This interface defines the functions and events for managing rate limits for both inbound and outbound flows.\n */\ninterface ISkyRateLimiter {\n    /**\n     * @notice Emitted when _setRateLimits occurs.\n     * @param rateLimitConfigs An array of `RateLimitConfig` structs representing configurations set per endpoint id.\n     * - `eid`: The source / destination endpoint id (depending on direction).\n     * - `window`: Defines the duration of the rate limiting window.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * @param direction Specifies whether the outbound or inbound rates were changed.\n     */\n    event RateLimitsChanged(RateLimitConfig[] rateLimitConfigs, RateLimitDirection direction);\n    event RateLimitAccountingTypeSet(RateLimitAccountingType newRateLimitAccountingType);\n    event RateLimitsReset(uint32[] eids, RateLimitDirection direction);\n\n    // @dev Error that is thrown when an amount exceeds the rate limit for a given direction.\n    error RateLimitExceeded();\n\n    /**\n     * @notice Get the current amount that can be sent to this destination endpoint id for the given rate limit window.\n     * @param dstEid The destination endpoint id.\n     * @return currentAmountInFlight The current amount that was sent in this window.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function getAmountCanBeSent(\n        uint32 dstEid\n    ) external view returns (uint256 currentAmountInFlight, uint256 amountCanBeSent);\n\n    /**\n     * @notice Get the current amount that can be received from the source endpoint id for the given rate limit window.\n     * @param srcEid The source endpoint id.\n     * @return currentAmountInFlight The current amount that has been received in this window.\n     * @return amountCanBeReceived The amount that can be received.\n     */\n    function getAmountCanBeReceived(\n        uint32 srcEid\n    ) external view returns (uint256 currentAmountInFlight, uint256 amountCanBeReceived);\n}\n",
        "SkyOFTCore.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Fee } from \"@layerzerolabs/oft-evm/contracts/Fee.sol\";\nimport { OFTCore, SendParam, OFTLimit, OFTFeeDetail, OFTReceipt } from \"@layerzerolabs/oft-evm/contracts/OFTCore.sol\";\n\nimport { ISkyOFT } from \"./interfaces/ISkyOFT.sol\";\nimport {\n    RateLimitConfig,\n    RateLimitDirection,\n    RateLimitAccountingType,\n    SkyRateLimiter\n} from \"./SkyRateLimiter.sol\";\n\n/**\n * @title SkyOFTCore\n * @notice The SkyOFTCore contract, which manages cross-chain transfer rate limits and fees.\n * @dev This contracts defines the core functionalities of the SkyOFT system, including rate limit management,\n * pauser management, and fee withdrawal.\n */\nabstract contract SkyOFTCore is ISkyOFT, OFTCore, SkyRateLimiter, Fee, Pausable {\n    using SafeERC20 for IERC20;\n\n    mapping(address pauser => bool canPause) public pausers;\n\n    IERC20 internal immutable innerToken;\n\n    /**\n     * @notice Initializes the SkyOFTCore contract.\n     *\n     * @param _token The address of the underlying ERC20 token.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The address of the delegate.\n     */\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _delegate\n    ) OFTCore(IERC20Metadata(_token).decimals(), _lzEndpoint, _delegate) Ownable(_delegate){\n        innerToken = IERC20(_token);\n    }\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the adapted ERC20 token.\n     *\n     * @dev In the case of OFTAdapter, address(this) and ERC20 are NOT the same contract.\n     */\n    function token() public view returns (address) {\n        return address(innerToken);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     */\n    function approvalRequired() external pure virtual override returns (bool requiresApproval) {\n        return true;\n    }\n\n    /**\n     * @notice Provides the fee breakdown and settings data for an OFT. Unused in the default implementation.\n     * @param _sendParam The parameters for the send operation.\n     * @return oftLimit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return oftReceipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        virtual\n        override\n        returns (OFTLimit memory oftLimit, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory oftReceipt)\n    {\n        uint256 minAmountLD = 0;\n        (/*uint256 currentAmountInFlight*/, uint256 maxAmountLD) = getAmountCanBeSent(_sendParam.dstEid);\n        oftLimit = OFTLimit(minAmountLD, maxAmountLD);\n\n        // @dev This is the same as the send() operation, but without the actual send.\n        // - amountSentLD is the amount in local decimals that would be sent from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be credited to the recipient on the remote OFT.\n        // @dev The amountSentLD MIGHT not equal the amount the user actually receives. HOWEVER, the default does.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debitView(\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n\n        // Return empty array if no fee is charged, otherwise include fee details.\n        if (amountSentLD == amountReceivedLD) {\n            oftFeeDetails = new OFTFeeDetail[](0);\n        } else {\n            oftFeeDetails = new OFTFeeDetail[](1);\n            oftFeeDetails[0] = OFTFeeDetail(\n                int256(amountSentLD - amountReceivedLD), // The fee amount in local decimals.\n                'SkyOFT: cross-chain transfer fee' // Fee description.\n            );\n        }\n    }\n\n    /**\n     * @notice Sets the cross-chain tx rate limits for specific endpoints based on provided configurations.\n     * It allows configuration of rate limits either for outbound and inbound directions.\n     * This method is designed to be called by contract admins for updating the system's rate limiting behavior.\n     * \n     * @notice WARNING: Changing rate limits without first calling resetRateLimits() MIGHT result in unexpected behavior.\n     * DYOR on Rate Limits across every VM to ensure compatibility.\n     * Especially consider inflight decay rates when reducing limits.\n     * \n     * @param _rateLimitConfigsInbound Array of INBOUND `RateLimitConfig` structs that specify new rate limit settings.\n     * @param _rateLimitConfigsOutbound Array of OUTBOUND `RateLimitConfig` structs that specify new rate limit settings.\n     *\n     * @dev Each struct includes an endpoint ID, the limit value, and the window duration.\n     * @dev The direction (inbound or outbound) specifies whether the eid passed should be considered a srcEid or dstEid.\n     */\n    function setRateLimits(\n        RateLimitConfig[] calldata _rateLimitConfigsInbound,\n        RateLimitConfig[] calldata _rateLimitConfigsOutbound\n    ) external onlyOwner {\n        _setRateLimits(_rateLimitConfigsInbound, RateLimitDirection.Inbound);\n        _setRateLimits(_rateLimitConfigsOutbound, RateLimitDirection.Outbound);\n    }\n\n    /**\n     * @notice Resets the rate limits for the given endpoint ids.\n     * @param _eidsInbound The endpoint ids to reset the rate limits for inbound.\n     * @param _eidsOutbound The endpoint ids to reset the rate limits for outbound.\n     */\n    function resetRateLimits(uint32[] calldata _eidsInbound, uint32[] calldata _eidsOutbound) external onlyOwner {\n        _resetRateLimits(_eidsInbound, RateLimitDirection.Inbound);\n        _resetRateLimits(_eidsOutbound, RateLimitDirection.Outbound);\n    }\n\n    /**\n     * @notice Sets the rate limit accounting type.\n     * @param _rateLimitAccountingType The new rate limit accounting type.\n     * @dev You may want to call `resetRateLimits` after changing the rate limit accounting type.\n     */\n    function setRateLimitAccountingType(RateLimitAccountingType _rateLimitAccountingType) external onlyOwner {\n        _setRateLimitAccountingType(_rateLimitAccountingType);\n    }\n\n    /**\n     * @notice Sets the pauser status for a given address.\n     * @param _pauser The address to set the pauser status for.\n     * @param _canPause Boolean indicating ability to pause cross-chain transfers.\n     */\n    function setPauser(address _pauser, bool _canPause) public onlyOwner {\n        // @dev Perform an idempotency check to prevent unnecessary state changes.\n        // @dev Also prevents redundant event emissions.\n        if (pausers[_pauser] == _canPause) revert PauserIdempotent(_pauser);\n\n        pausers[_pauser] = _canPause;\n        emit PauserSet(_pauser, _canPause);\n    }\n\n    /**\n     * @notice Pauses the contract if the caller is a pauser.\n     * @dev Only pausers can pause the contract.\n     */\n    function pause() external {\n        if (!pausers[msg.sender]) revert OnlyPauser(msg.sender);\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract.\n     * @dev Only the owner can unpause the contract.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Internal function to mock the amount mutation from a OFT debit() operation.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent, in local decimals.\n     * @return amountReceivedLD The amount to be received on the remote chain, in local decimals.\n     *\n     * @dev This function applies the fee to the amount, removes dust, and checks for slippage.\n     * @dev This view function will revert if cross-chain transfers are paused.\n     */\n    function _debitView(\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal view virtual override whenNotPaused returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        amountSentLD = _amountLD;\n\n        // @dev Apply the fee, then de-dust the amount afterwards.\n        // This means the fee is taken from the amount before the dust is removed.\n        uint256 fee = getFee(_dstEid, _amountLD);\n        // @dev The fee technically also includes the dust.\n        amountReceivedLD = _removeDust(_amountLD - fee);\n\n        // @dev Check for slippage.\n        if (amountReceivedLD < _minAmountLD) {\n            revert SlippageExceeded(amountReceivedLD, _minAmountLD);\n        }\n    }\n} ",
        "SkyOFTAdapterMintBurn.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { IMintBurnVoidReturn } from \"./interfaces/IMintBurnVoidReturn.sol\";\nimport { SkyOFTCore, RateLimitDirection } from \"./SkyOFTCore.sol\";\n\n/**\n * @title SkyOFTAdapterMintBurn\n * @notice A variant of the standard OFT Adapter that uses an existing ERC20's mint and burn for cross-chain transfers.\n * @dev This contract needs mint permissions on the token.\n * @dev This contract burns the tokens from the sender's balance and transfers in the fee.\n *\n * @dev This contract extends the SkyOFTCore, which extends the SkyRateLimiter containing rate limiting functionality.\n * @dev It allows for the configuration of rate limits for both outbound and inbound directions.\n * @dev It also allows for the setting of the rate limit accounting type to be net or gross.\n */\ncontract SkyOFTAdapterMintBurn is SkyOFTCore {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Initializes the SkyOFTAdapterMintBurn contract.\n     *\n     * @param _token The address of the underlying ERC20 token.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The address of the delegate.\n     */\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _delegate\n    ) SkyOFTCore(_token, _lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Returns the balance of fees accumulated in the contract.\n     * @return amountLD The balance of fees in local decimals.\n     *\n     * @dev This function is used to check the fee balance before withdrawal.\n     */\n    function feeBalance() public view returns (uint256 amountLD) {\n        return innerToken.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Withdraws accumulated fees to a specified address.\n     * @param _to The address to which the fees will be withdrawn.\n     * @param _amountLD The amount of tokens to withdraw in local decimals.\n     *\n     * @dev This also allows for owner to rescue tokens that are otherwise burned/lost.\n     */\n    function withdrawFees(address _to, uint256 _amountLD) external onlyOwner {\n        uint256 balance = feeBalance();\n        if (_amountLD > balance) revert InsufficientFeeBalance(_amountLD, balance);\n\n        innerToken.safeTransfer(_to, _amountLD);\n        emit FeesWithdrawn(_to, _amountLD);\n    }\n\n    /**\n     * @notice Burns tokens from the sender's balance to prepare for sending.\n     *\n     * @param _from The address to debit the tokens from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     *\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n\n        // @dev We are using amountReceivedLD because that is the amount of tokens leaving the chain.\n        // @dev The fee remains on this chain, thus it is not included in the rate limit check.\n        _checkAndUpdateRateLimit(_dstEid, amountReceivedLD, RateLimitDirection.Outbound);\n\n        // @dev Burn the total amount sent, and mint the difference (i.e. the fee) to this contract.\n        IMintBurnVoidReturn(token()).burn(_from, amountSentLD);\n\n        // @dev Conditionally handle the fee.\n        uint256 fee = amountSentLD - amountReceivedLD;\n        if (fee > 0) IMintBurnVoidReturn(token()).mint(address(this), fee);\n    }\n\n    /**\n     * @notice Mints tokens to the recipient.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @param _srcEid The source Endpoint ID.\n     *\n     * @return amountReceivedLD The amount of tokens actually received in local decimals.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 _srcEid\n    ) internal virtual override whenNotPaused returns (uint256 amountReceivedLD) {\n        // @dev Check and update the rate limit based on the source endpoint ID (srcEid).\n        _checkAndUpdateRateLimit(_srcEid, _amountLD, RateLimitDirection.Inbound);\n\n        // @dev If recipient is the zero address or the inner token, reroute to the dead address.\n        if (_to == address(0) || _to == token()) _to = address(0xdead);\n\n        // @dev Mints the tokens to the recipient.\n        IMintBurnVoidReturn(token()).mint(_to, _amountLD);\n\n        return _amountLD;\n    }\n}\n",
        "SkyOFTAdapter.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.22;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { ISkyOFTAdapter } from \"./interfaces/ISkyOFTAdapter.sol\";\nimport { SkyOFTCore, RateLimitDirection } from \"./SkyOFTCore.sol\";\n\n/**\n * @title SkyOFTAdapter Contract\n * @dev OFTAdapter is a contract that adapts an ERC-20 token to the OFT functionality.\n * @dev This contract extends the SkyOFTCore, which extends the SkyRateLimiter containing rate limiting functionality.\n * @dev It allows for the configuration of rate limits for both outbound and inbound directions.\n * @dev It also allows for the setting of the rate limit accounting type to be net or gross.\n *\n * @dev For existing ERC20 tokens, this can be used to convert the token to cross-chain compatibility.\n * @dev WARNING: ONLY 1 of these should exist for a given global mesh.\n */\ncontract SkyOFTAdapter is ISkyOFTAdapter, SkyOFTCore {\n    using SafeERC20 for IERC20;\n\n    uint256 public feeBalance;\n\n    /**\n     * @notice Initializes the SkyOFTAdapter contract.\n     *\n     * @param _token The address of the underlying ERC20 token.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The address of the delegate.\n     */\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _delegate\n    ) SkyOFTCore(_token, _lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Withdraws accumulated fees to a specified address.\n     * @param _to The address to which the fees will be withdrawn.\n     * @param _amountLD The amount of tokens to withdraw in local decimals.\n     *\n     * @dev Doesn't allow owner to pull from the locked assets of the contract, only from accumulated fees.\n     */\n    function withdrawFees(address _to, uint256 _amountLD) external onlyOwner {\n        uint256 balance = feeBalance;\n        if (_amountLD > balance) revert InsufficientFeeBalance(_amountLD, balance);\n\n        // @dev Deduct the amount from the fee balance before transferring.\n        feeBalance -= _amountLD;\n\n        innerToken.safeTransfer(_to, _amountLD);\n        emit FeesWithdrawn(_to, _amountLD);\n    }\n\n    /**\n     * @notice Migrates all locked tokens to a specified address, less the accumulated fees.\n     * @param _to The address to which the locked tokens will be migrated.\n     *\n     * @dev This function is intended to be called by the owner to migrate all locked tokens\n     * from this contract to another address, effectively allowing for a migration of the contract's state.\n     * @dev The migration EXCLUDES accumulated fees.\n     */\n    function migrateLockedTokens(address _to) external onlyOwner {\n        // @dev Block sending directly to the zero address.\n        if (_to == address(0)) revert InvalidAddressZero();\n\n        // @dev Do not include the fee balance in the migration.\n        uint256 balance = innerToken.balanceOf(address(this)) - feeBalance;\n\n        innerToken.safeTransfer(_to, balance);\n        emit LockedTokensMigrated(_to, balance);\n    }\n\n    /**\n     * @dev Locks tokens from the sender's specified balance in this contract.\n     * @param _from The address to debit from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev msg.sender will need to approve this _amountLD of tokens to be locked inside of the contract.\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n\n        // @dev We are using amountReceivedLD because that is the amount of tokens leaving the chain.\n        // @dev The fee remains on this chain, thus it is not included in the rate limit check.\n        _checkAndUpdateRateLimit(_dstEid, amountReceivedLD, RateLimitDirection.Outbound);\n\n        // @dev Lock tokens by moving them into this contract from the caller.\n        innerToken.safeTransferFrom(_from, address(this), amountSentLD);\n\n        // @dev Conditionally handle the fee.\n        uint256 fee = amountSentLD - amountReceivedLD;\n        if (fee > 0) feeBalance += fee;\n    }\n\n    /**\n     * @notice Transfers tokens to the recipient.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @param _srcEid The source Endpoint ID.\n     *\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 _srcEid\n    ) internal virtual override whenNotPaused returns (uint256 amountReceivedLD) {\n        // @dev Check and update the rate limit based on the source endpoint ID (srcEid).\n        _checkAndUpdateRateLimit(_srcEid, _amountLD, RateLimitDirection.Inbound);\n\n        // @dev If recipient is the zero address or the inner token, reroute to the dead address.\n        if (_to == address(0) || _to == token()) _to = address(0xdead);\n        \n        // @dev Unlock the tokens and transfer to the recipient.\n        innerToken.safeTransfer(_to, _amountLD);\n\n        return _amountLD;\n    }\n}"
    }
}