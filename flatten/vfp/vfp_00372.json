{
    "vfp_id": "vfp_00372",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Documentation",
            "description": "A comment in `SponsoredCCTPDstPeriphery.sol` incorrectly states that funds will be minted to the contract itself, when in fact they are minted directly to the specified `mintRecipient`.\nThe cause is outdated or incorrect inline documentation that does not reflect the actual behavior of the external contract call.\nDevelopers relying on the comment may misunderstand the flow of funds, potentially leading to incorrect assumptions in integrations or security analyses.\nThe impact is risk of incorrect integration logic or flawed security assessments due to reliance on inaccurate documentation.\n",
            "severity": "Informational",
            "location": [
                "SponsoredCCTPDstPeriphery.sol#84-85"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/periphery/mintburn/sponsored-cctp/SponsoredCCTPDstPeriphery.sol"
            ]
        }
    ],
    "affected_files": {
        "SponsoredCCTPDstPeriphery.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { BaseModuleHandler } from \"../BaseModuleHandler.sol\";\nimport { IMessageTransmitterV2 } from \"../../../external/interfaces/CCTPInterfaces.sol\";\nimport { SponsoredCCTPQuoteLib } from \"../../../libraries/SponsoredCCTPQuoteLib.sol\";\nimport { SponsoredCCTPInterface } from \"../../../interfaces/SponsoredCCTPInterface.sol\";\nimport { Bytes32ToAddress } from \"../../../libraries/AddressConverters.sol\";\nimport { HyperCoreFlowExecutor } from \"../HyperCoreFlowExecutor.sol\";\nimport { ArbitraryEVMFlowExecutor } from \"../ArbitraryEVMFlowExecutor.sol\";\nimport { CommonFlowParams, EVMFlowParams } from \"../Structs.sol\";\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title SponsoredCCTPDstPeriphery\n * @notice Destination chain periphery contract that supports sponsored/non-sponsored CCTP deposits.\n * @dev This contract is used to receive tokens via CCTP and execute the flow accordingly.\n * @dev IMPORTANT. `BaseModuleHandler` should always be the first contract in inheritance chain. Read \n    `BaseModuleHandler` contract code to learn more.\n */\ncontract SponsoredCCTPDstPeriphery is BaseModuleHandler, SponsoredCCTPInterface, ArbitraryEVMFlowExecutor {\n    using SafeERC20 for IERC20Metadata;\n    using Bytes32ToAddress for bytes32;\n\n    /// @notice The CCTP message transmitter contract.\n    IMessageTransmitterV2 public immutable cctpMessageTransmitter;\n\n    /// @notice Base token associated with this handler. The one we receive from the CCTP bridge\n    address public immutable baseToken;\n\n    /// @custom:storage-location erc7201:SponsoredCCTPDstPeriphery.main\n    struct MainStorage {\n        /// @notice The public key of the signer that was used to sign the quotes.\n        address signer;\n        /// @notice Allow a buffer for quote deadline validation. CCTP transfer might have taken a while to finalize\n        uint256 quoteDeadlineBuffer;\n        /// @notice A mapping of used nonces to prevent replay attacks.\n        mapping(bytes32 => bool) usedNonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"erc7201:SponsoredCCTPDstPeriphery.main\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant MAIN_STORAGE_LOCATION = 0xb788edf5b6d001c4df53cb371352fd225afa05a1712075d5f89a08d6b6f79f00;\n\n    function _getMainStorage() private pure returns (MainStorage storage $) {\n        assembly {\n            $.slot := MAIN_STORAGE_LOCATION\n        }\n    }\n\n    /**\n     * @notice Constructor for the SponsoredCCTPDstPeriphery contract.\n     * @param _cctpMessageTransmitter The address of the CCTP message transmitter contract.\n     * @param _signer The address of the signer that was used to sign the quotes.\n     * @param _donationBox The address of the donation box contract. This is used to store funds that are used for sponsored flows.\n     * @param _baseToken The address of the base token which would be the USDC on HyperEVM.\n     * @param _multicallHandler The address of the multicall handler contract.\n     */\n    constructor(\n        address _cctpMessageTransmitter,\n        address _signer,\n        address _donationBox,\n        address _baseToken,\n        address _multicallHandler\n    ) BaseModuleHandler(_donationBox, _baseToken, DEFAULT_ADMIN_ROLE) ArbitraryEVMFlowExecutor(_multicallHandler) {\n        baseToken = _baseToken;\n\n        cctpMessageTransmitter = IMessageTransmitterV2(_cctpMessageTransmitter);\n\n        MainStorage storage $ = _getMainStorage();\n        $.signer = _signer;\n        $.quoteDeadlineBuffer = 30 minutes;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Returns the signer address that is used to validate the signatures of the quotes.\n     * @return The signer address.\n     */\n    function signer() external view returns (address) {\n        return _getMainStorage().signer;\n    }\n\n    /**\n     * @notice Returns the quote deadline buffer.\n     * @return The quote deadline buffer.\n     */\n    function quoteDeadlineBuffer() external view returns (uint256) {\n        return _getMainStorage().quoteDeadlineBuffer;\n    }\n\n    /**\n     * @notice Returns true if the nonce has been used, false otherwise.\n     * @param nonce The nonce to check.\n     * @return True if the nonce has been used, false otherwise.\n     */\n    function usedNonces(bytes32 nonce) external view returns (bool) {\n        return _getMainStorage().usedNonces[nonce];\n    }\n\n    /**\n     * @notice Sets the signer address that is used to validate the signatures of the quotes.\n     * @param _signer The new signer address.\n     */\n    function setSigner(address _signer) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        _getMainStorage().signer = _signer;\n    }\n\n    /**\n     * @notice Sets the quote deadline buffer. This is used to prevent the quote from being used after it has expired.\n     * @param _quoteDeadlineBuffer The new quote deadline buffer.\n     */\n    function setQuoteDeadlineBuffer(uint256 _quoteDeadlineBuffer) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        _getMainStorage().quoteDeadlineBuffer = _quoteDeadlineBuffer;\n    }\n\n    /**\n     * @notice Emmergency function that can be used to recover funds in cases where it is not possible to go\n     * through the normal flow (e.g. HyperEVM <> HyperCore USDC bridge is blacklisted). Receives the message from\n     * CCTP and then sends it to final recipient\n     * @param message The message that is received from CCTP.\n     * @param attestation The attestation that is received from CCTP.\n     */\n    function emergencyReceiveMessage(\n        bytes memory message,\n        bytes memory attestation\n    ) external nonReentrant onlyRole(PERMISSIONED_BOT_ROLE) {\n        bool success = cctpMessageTransmitter.receiveMessage(message, attestation);\n        if (!success) {\n            return;\n        }\n\n        // Use try-catch to handle potential abi.decode reverts gracefully\n        try this.validateMessage(message) returns (bool isValid) {\n            if (!isValid) {\n                return;\n            }\n        } catch {\n            // Malformed message that causes abi.decode to revert then early return\n            return;\n        }\n        (SponsoredCCTPInterface.SponsoredCCTPQuote memory quote, uint256 feeExecuted) = SponsoredCCTPQuoteLib\n            .getSponsoredCCTPQuoteData(message);\n\n        _getMainStorage().usedNonces[quote.nonce] = true;\n\n        IERC20Metadata(baseToken).safeTransfer(quote.finalRecipient.toAddress(), quote.amount - feeExecuted);\n\n        emit EmergencyReceiveMessage(\n            quote.nonce,\n            quote.finalRecipient.toAddress(),\n            baseToken,\n            quote.amount - feeExecuted\n        );\n    }\n\n    /**\n     * @notice Receives a message from CCTP and executes the flow accordingly. This function first calls the\n     * CCTP message transmitter to receive the funds before validating the quote and executing the flow.\n     * @param message The message that is received from CCTP.\n     * @param attestation The attestation that is received from CCTP.\n     * @param signature The signature of the quote.\n     */\n    function receiveMessage(\n        bytes memory message,\n        bytes memory attestation,\n        bytes memory signature\n    ) external nonReentrant authorizeFundedFlow {\n        bool success = cctpMessageTransmitter.receiveMessage(message, attestation);\n        if (!success) {\n            revert CCTPMessageTransmitterFailed();\n        }\n\n        // If the hook data is invalid or the mint recipient is not this contract we cannot process the message\n        // and therefore we exit. In this case the funds will be kept in this contract.\n        // Use try-catch to handle potential abi.decode reverts gracefully\n        try this.validateMessage(message) returns (bool isValid) {\n            if (!isValid) {\n                return;\n            }\n        } catch {\n            // Malformed message that causes abi.decode to revert then early return\n            return;\n        }\n        // Extract the quote and the fee that was executed from the message.\n        (SponsoredCCTPInterface.SponsoredCCTPQuote memory quote, uint256 feeExecuted) = SponsoredCCTPQuoteLib\n            .getSponsoredCCTPQuoteData(message);\n\n        // Validate the quote and the signature.\n        bool isQuoteValid = _isQuoteValid(quote, signature);\n        if (isQuoteValid) {\n            _getMainStorage().usedNonces[quote.nonce] = true;\n        }\n\n        uint256 amountAfterFees = quote.amount - feeExecuted;\n\n        CommonFlowParams memory commonParams = CommonFlowParams({\n            amountInEVM: amountAfterFees,\n            quoteNonce: quote.nonce,\n            finalRecipient: quote.finalRecipient.toAddress(),\n            // If the quote is invalid we don't want to swap, so we use the base token as the final token\n            finalToken: isQuoteValid ? quote.finalToken.toAddress() : baseToken,\n            // If the quote is invalid we don't sponsor the flow or the extra fees\n            maxBpsToSponsor: isQuoteValid ? quote.maxBpsToSponsor : 0,\n            extraFeesIncurred: feeExecuted\n        });\n\n        // Route to appropriate execution based on executionMode\n        if (\n            isQuoteValid &&\n            (quote.executionMode == uint8(ExecutionMode.ArbitraryActionsToCore) ||\n                quote.executionMode == uint8(ExecutionMode.ArbitraryActionsToEVM))\n        ) {\n            // Execute flow with arbitrary evm actions\n            _executeWithEVMFlow(\n                EVMFlowParams({\n                    commonParams: commonParams,\n                    initialToken: baseToken,\n                    actionData: quote.actionData,\n                    transferToCore: quote.executionMode == uint8(ExecutionMode.ArbitraryActionsToCore)\n                })\n            );\n        } else {\n            // Execute standard HyperCore flow (default) via delegatecall\n            _delegateToHyperCore(\n                abi.encodeCall(HyperCoreFlowExecutor.executeFlow, (commonParams, quote.maxUserSlippageBps))\n            );\n        }\n    }\n\n    /**\n     * @notice External wrapper for validateMessage to enable try-catch for safe abi.decode handling\n     * @param message The CCTP message to validate\n     * @return True if the message is valid, false otherwise\n     */\n    function validateMessage(bytes memory message) external view returns (bool) {\n        return SponsoredCCTPQuoteLib.validateMessage(message);\n    }\n\n    function _isQuoteValid(\n        SponsoredCCTPInterface.SponsoredCCTPQuote memory quote,\n        bytes memory signature\n    ) internal view returns (bool) {\n        MainStorage storage $ = _getMainStorage();\n        return\n            SponsoredCCTPQuoteLib.validateSignature($.signer, quote, signature) &&\n            !$.usedNonces[quote.nonce] &&\n            quote.deadline + $.quoteDeadlineBuffer >= block.timestamp;\n    }\n\n    function _executeWithEVMFlow(EVMFlowParams memory params) internal {\n        params.commonParams = ArbitraryEVMFlowExecutor._executeFlow(params);\n\n        // Route to appropriate destination based on transferToCore flag\n        _delegateToHyperCore(\n            params.transferToCore\n                ? abi.encodeCall(HyperCoreFlowExecutor.executeSimpleTransferFlow, (params.commonParams))\n                : abi.encodeCall(HyperCoreFlowExecutor.fallbackHyperEVMFlow, (params.commonParams))\n        );\n    }\n}\n"
    }
}