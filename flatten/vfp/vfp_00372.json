{
    "vfp_id": "vfp_00372",
    "project_name": "ChainSecurity_M0_MExtensions_Audit.pdf",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Wrong Storage Location for EIP7201",
            "description": "The MSpokeYieldFee contract implements EIP-7201 for namespaced storage but incorrectly documents the storage slot in the `@custom` comment as `M0.storage.SpokeMYieldFee`, while the actual computation uses `M0.storage.MSpokeYieldFee`. The cause is a mismatch between documentation and implementation. This could mislead developers or tools relying on the comment for storage layout analysis. Although the code was later removed, the inconsistency highlights the importance of accurate documentation in critical infrastructure.\n",
            "severity": "Informational",
            "location": [
                "MSpokeYieldFee::EIP7201 storage layout"
            ],
            "files": [
                "evm-m-extensions/src/projects/yieldToAllWithFee/MSpokeYieldFee.sol"
            ]
        }
    ],
    "affected_files": {
        "MSpokeYieldFee.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { MYieldFee } from \"./MYieldFee.sol\";\n\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\nimport { IRateOracle } from \"./interfaces/IRateOracle.sol\";\nimport { IMSpokeYieldFee } from \"./interfaces/IMSpokeYieldFee.sol\";\n\nabstract contract MSpokeYieldFeeStorageLayout {\n    /// @custom:storage-location erc7201:M0.storage.SpokeMYieldFee\n    struct MSpokeYieldFeeStorageStruct {\n        address rateOracle;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MSpokeYieldFee\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_SPOKE_YIELD_FEE_STORAGE_LOCATION =\n        0x2aa34bda88d9a6fad4859c438b6b00a9fe5d9d80a401ed1357a646e247972000;\n\n    function _getMSpokeYieldFeeStorageLocation() internal pure returns (MSpokeYieldFeeStorageStruct storage $) {\n        assembly {\n            $.slot := _M_SPOKE_YIELD_FEE_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title  SpokeMYieldFee\n * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.\n *         Extended to take a fee from the yield generated by M.\n * @dev    All holders of this ERC20 token are earners.\n * @dev    This M extension must only be deployed on Spoke chains.\n *         Check MYieldFee for the Mainnet version.\n * @author M0 Labs\n */\ncontract MSpokeYieldFee is IMSpokeYieldFee, MSpokeYieldFeeStorageLayout, MYieldFee {\n    /* ============ Initializer ============ */\n\n    /**\n     * @dev   Initializes the Spoke M Yield Fee token.\n     * @param name                  The name of the token (e.g. \"M Yield Fee\").\n     * @param symbol                The symbol of the token (e.g. \"MYF\").\n     * @param mToken                The address of a Spoke M Token.\n     * @param swapFacility          The address of the Swap Facility.\n     * @param feeRate          The fee rate, in bps, that will be taken from the yield generated by M.\n     * @param feeRecipient     The address of the recipient of the yield fee.\n     * @param admin                 The address administrating the M extension. Can grant and revoke roles.\n     * @param yieldFeeManager       The address managing the fee rate and recipient.\n     * @param claimRecipientManager The address managing claim recipients for accounts.\n     * @param rateOracle_           The address of a rate oracle.\n\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address mToken,\n        address swapFacility,\n        uint16 feeRate,\n        address feeRecipient,\n        address admin,\n        address yieldFeeManager,\n        address claimRecipientManager,\n        address rateOracle_\n    ) public virtual initializer {\n        if ((_getMSpokeYieldFeeStorageLocation().rateOracle = rateOracle_) == address(0)) revert ZeroRateOracle();\n\n        super.initialize(\n            name,\n            symbol,\n            mToken,\n            swapFacility,\n            feeRate,\n            feeRecipient,\n            admin,\n            yieldFeeManager,\n            claimRecipientManager\n        );\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc IMSpokeYieldFee\n    function rateOracle() public view returns (address) {\n        return _getMSpokeYieldFeeStorageLocation().rateOracle;\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev    Returns the timestamp when the earner rate was last accrued to accounts.\n     * @dev    Uses `latestUpdateTimestamp` from Spoke M to cap `currentIndex` to the timestamp\n     *         when Spoke M's index was last updated and thus avoid overprinting M extension tokens.\n     * @return The current block timestamp.\n     */\n    function _latestEarnerRateAccrualTimestamp() internal view override returns (uint40) {\n        return IContinuousIndexing(mToken()).latestUpdateTimestamp();\n    }\n\n    /// @dev Returns the current earner rate.\n    function _currentEarnerRate() internal view override returns (uint32) {\n        // NOTE: The behavior of Rate Oracle is known, so we can safely retrieve the earner rate.\n        return IRateOracle(rateOracle()).earnerRate();\n    }\n}\n"
    }
}