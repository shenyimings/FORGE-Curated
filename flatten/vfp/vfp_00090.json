{
    "vfp_id": "vfp_00090",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Cross-contract reentrancy allows YIELD_- TOKEN theft for the GenericERC4626 WithdrawalRequestManager variant",
            "description": "The WithdrawalRequestManager in the GenericERC4626 variant is vulnerable to a cross-contract reentrancy attack due to the absence of reentrancy guards in critical functions. The vulnerability arises because the contract allows multiple whitelisted vaults to interact with it, and functions like initiateWithdraw do not employ nonReentrant modifiers or equivalent protections against reentrancy from external contracts.\n\nThe root cause is the lack of reentrancy protection in the WithdrawalRequestManager, particularly in functions that handle asset transfers and state changes. Since the contract relies on external calls to yield strategies that may contain malicious code, an attacker can exploit the reentrancy window during a Uniswap swap that includes a malicious pool. This pool can trigger a callback into the protocol, re-entering the deposit function before the initial transaction completes.\n\nAn attacker can initiate a withdrawal, leaving YIELD_TOKENs in the WithdrawalRequestManager, then execute a multihop swap through a malicious pool that re-enters the protocol to deposit assets. This reentrant call manipulates the accounting of YIELD_TOKEN balances, causing the system to mint more shares than deserved based on inflated balance differences.\n\nThe impact is severe: attackers can steal YIELD_TOKENs from pending withdrawal requests of other users, effectively draining funds from the WithdrawalRequestManager. This leads to loss of user funds and undermines the integrity of the withdrawal mechanism.\n",
            "severity": "High",
            "location": [
                "src/withdraws/GenericERC4626.sol",
                "src/withdraws/WithdrawalRequestManager.sol::initiateWithdraw"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/withdraws/GenericERC4626.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/withdraws/WithdrawalRequestManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "RewardManagerMixin.claimAccountRewards lacks of necessary param check",
            "description": "The claimAccountRewards function in RewardManagerMixin does not validate the account parameter, allowing any caller to specify any address, including privileged addresses like MORPHO. The root cause is the absence of input validation and the logic that uses balanceOf(account) when the caller is not a lending router. If MORPHO is passed as the account, it will receive rewards based on its vault token balance, which accumulates when users enter positions via AbstractLendingRouter. An attacker can exploit this by calling enterPosition with MORPHO as the account, causing rewards to be incorrectly distributed to MORPHO. This leads to users receiving fewer rewards than expected, as MORPHO holds a large portion of vault tokens, thereby misallocating reward distributions.\n",
            "severity": "High",
            "location": [
                "RewardManagerMixin.sol#L155-L177",
                "AbstractLendingRouter.sol#L241",
                "AbstractLendingRouter.sol#L244"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/AbstractLendingRouter.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/rewards/RewardManagerMixin.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "initializeMarket Can Be Frontran, Preventing Markets From Being Configured in MorphoLendingRouter",
            "description": "The initializeMarket function in MorphoLendingRouter.sol can be frontran by an attacker who calls Morpho's createMarket() with the same market parameters before the legitimate initialization. This is possible because initializeMarket does not use try/catch and assumes it will always succeed in creating the market.\n\nThe root cause is the lack of error handling for market creation. Since Morpho enforces that each market can only be created once, a malicious actor can preemptively create the market, causing the legitimate initializeMarket call to revert.\n\nAn attacker can monitor the mempool for calls to initializeMarket and quickly submit a transaction calling createMarket directly with identical parameters. This would block the router from storing the market configuration in s_morphoParams.\n\nThe impact is medium: it results in a denial of service for market initialization, preventing the router from supporting the affected vault. While the issue is recoverable via an upgrade (as noted in discussion), it still disrupts normal operations and requires manual intervention, reducing system reliability and autonomy.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::initializeMarket#51"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Hard-Coded Mainnet WETH Address Breaks All Non-Mainnet Deployments",
            "description": "The protocol uses a compile-time constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), which is the WETH address on Ethereum mainnet. This constant is used across core contracts like AbstractStakingStrategy, CurveConvexLib, and various withdraw managers. The root cause is the hardcoding of a chain-specific address in a protocol designed for multi-chain deployment. When deployed on L2s like Arbitrum or Base, where WETH exists at a different address or is not present, calls to WETH.withdraw() will revert and WETH.deposit{value:...}() will fail to mint tokens. This breaks critical functionality such as withdrawals and redemptions. The impact is medium: while the protocol functions on mainnet, it becomes unusable on other chains, contradicting the project's stated goal of supporting multiple networks. The likelihood is medium given the explicit mention of future Base and Arbitrum deployments.\n",
            "severity": "Medium",
            "location": [
                "Constants.sol::WETH#19",
                "AbstractStakingStrategy",
                "CurveConvexLib",
                "EtherFiWithdrawRequestManager"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/2025-06-notional-exponent/notional-v4/src/utils/Constants.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/staking/AbstractStakingStrategy.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Liquidations can be frontrunned to avoid by paying as little as 1 share",
            "description": "The protocol integrates with Morpho for debt management, and during liquidation, the full debt is expected to be repaid. However, a user can frontrun their own liquidation by repaying just 1 share of debt via exitPosition, which reduces their borrowShares.\n\nThe root cause lies in Morpho's internal accounting: when liquidate() is called after a partial repayment, it attempts to subtract the full sharesToLiquidate from the borrower's reduced borrowShares, causing an underflow revert. This is exacerbated by the lack of a cooldown or rate-limiting mechanism on exitPosition.\n\nThe attack path involves a user detecting an impending liquidation and frontrunning it with a minimal repayment (1 share), causing the liquidation transaction to revert due to arithmetic underflow when subtracting shares.\n\nThe impact is that liquidations can be consistently avoided by borrowers at minimal cost, undermining the protocol's solvency mechanism and increasing systemic risk.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::_liquidate",
                "Morpho.sol::liquidate#247",
                "Morpho.sol::position#L532"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Withdrawals ongoing for OETH, apxETH, weETH, and almost any LST are overpriced by the oracle",
            "description": "When a user initiates a withdrawal of an LST (like OETH), the yield token is sent to the Withdraw Request Manager to start beacon chain unstaking. However, during the pending withdrawal period, the protocol continues to price the collateral using the yield token's oracle rate, even though the LST has stopped earning yield.\n\nThe root cause is that the pricing logic in getWithdrawRequestValue defaults to using the YIELD_TOKEN's oracle price if the withdrawal is not yet finalized. Since the LST no longer accrues rewards after unstaking begins, this leads to overvaluation of the collateral.\n\nAn attacker can initiate a withdrawal, keep the overvalued collateral on the Morpho market, and borrow additional funds based on the inflated value, even though the underlying asset is no longer generating yield.\n\nThe impact is that users can over-leverage by borrowing against collateral that is no longer earning yield, creating a risk of under-collateralization. In extreme cases (e.g., slashing), the collateral could be significantly overvalued, threatening protocol solvency.\n",
            "severity": "Medium",
            "location": [
                "AbstractStakingStrategy.sol::initiateWithdraw#64-74",
                "AbstractWithdrawRequestManager.sol::getWithdrawRequestValue#307-340",
                "Origin.sol::withdraw#12-19"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/staking/AbstractStakingStrategy.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding discrepancy between MorphoLendingRouter::healthFactor and Morpho::repay causes position migration failures",
            "description": "The MorphoLendingRouter::healthFactor function calculates borrowed assets using integer division (rounding down), while Morpho's internal repay function uses a rounding-up method (toAssetsUp). This discrepancy causes the router to underestimate the amount of debt that must be repaid during a position migration.\n\nThe root cause is the inconsistent rounding logic between the two systems: the router uses truncating division, while Morpho uses ceiling division for asset conversion. Over time, as interest accrues, the difference—though small (e.g., 1 wei)—becomes significant enough to cause failures.\n\nDuring a migratePosition call, the router computes a flash loan amount based on the underestimated debt. When Morpho attempts to repay the full shares, it demands slightly more assets than were borrowed, causing a balance shortfall and revert.\n\nThe impact is that position migrations fail unexpectedly, even for healthy positions, breaking a core protocol feature. This issue is latent and may only manifest after prolonged market activity, making it difficult to detect.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::healthFactor#279",
                "Morpho.sol::_isHealthy#532",
                "Morpho.sol::repay#284"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect rounding in MorphoLendingRouter::healthFactor breaks migratePosition",
            "description": "The vulnerability lies in the MorphoLendingRouter::healthFactor function, which calculates the borrow amount for position migration using integer division that rounds down. This causes an underestimation of the required repayment amount during flash loans. The root cause is the use of truncating integer division (a * b) / c instead of ceiling division, which fails to account for the rounding-up behavior used by Morpho Blue's toAssetsUp() during actual repayment. An attacker cannot directly exploit this, but any user attempting to migrate a position will trigger a revert when the flash loaned amount is insufficient by ~1 wei to cover the actual repayment. This results in a denial of service for the migratePosition functionality, a core protocol feature, rendering it unusable despite correct user intent and sufficient underlying collateral.\n",
            "severity": "Medium",
            "location": [
                "MorphoLendingRouter.sol::healthFactor",
                "AbstractLendingRouter.sol::migratePosition#L74",
                "AbstractLendingRouter.sol::_enterPosition#L97",
                "MorphoLendingRouter.sol::onMorphoFlashLoan#L140",
                "AbstractLendingRouter.sol::_enterOrMigrate#L236",
                "MorphoLendingRouter.sol::_exitWithRepay#L192",
                "Morpho.sol::repay#L284",
                "MorphoLendingRouter.sol::onMorphoRepay#L224"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/MorphoLendingRouter.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Incompatibility of ERC20::approve with USDT tokens on Ethereum",
            "description": "The vulnerability arises from the use of high-level Solidity calls (e.g., ERC20(token).approve) that expect a boolean return value, which is not returned by certain ERC-20 tokens like USDT on Ethereum. The root cause is the violation of the ERC-20 standard by USDT, which omits the return statement in its approve function. When the Notional protocol calls approve on such tokens, the EVM attempts to decode a return value that does not exist, causing the transaction to revert. This leads to a failure in token approval, preventing users from depositing or interacting with USDT in the protocol. The impact is a denial of service for USDT users, blocking core functionality such as entering positions or migrating assets. This issue affects all operations requiring approval of USDT and similar non-conforming tokens.\n",
            "severity": "Medium",
            "location": [
                "ERC20.sol#L81"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/AbstractLendingRouter.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/MorphoLendingRouter.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/staking/AbstractStakingStrategy.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/withdraws/GenericERC4626.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "USDT approve() reverts due to non-standard return value",
            "description": "The AbstractLendingRouter::_enterOrMigrate, MorphoLendingRouter::_supplyCollateral, AbstractStakingStrategy::_mintYieldToken, and GenericERC4626::_stakeTokens functions use the standard ERC20::approve function to set token allowances. However, the USDT token on Ethereum does not return a boolean value upon approval, which violates the ERC20 standard expectation that approve() returns a bool. As a result, any call to approve() for USDT will revert.\n\nThe root cause is the direct use of IERC20.approve without handling non-conforming implementations like USDT. Additionally, these functions do not first reset the allowance to zero before setting a new one, which is required by USDT's implementation. If the current allowance is non-zero, the approve() call will revert again due to USDT's internal requirement that the previous allowance must be zero.\n\nAn attacker cannot directly exploit this, but any legitimate user attempting to use USDT in core protocol functions (e.g., entering a vault, staking, or migrating) will face transaction reverts. This breaks core functionality for a supported asset.\n\nThe impact is critical because USDT is a primary token the protocol intends to support, and users are unable to perform essential operations when using USDT on Ethereum Mainnet.\n",
            "severity": "Critical",
            "location": [
                "AbstractLendingRouter.sol::deposit#222-245",
                "MorphoLendingRouter.sol::supplyCollateral#150-164",
                "AbstractStakingStrategy.sol::mintYieldToken#77-81",
                "GenericERC4626.sol::stakeTokens#77-81"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/AbstractLendingRouter.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/routers/MorphoLendingRouter.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/staking/AbstractStakingStrategy.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/withdraws/GenericERC4626.sol"
            ]
        }
    ],
    "affected_files": {
        "AbstractLendingRouter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ILendingRouter, VaultPosition} from \"../interfaces/ILendingRouter.sol\";\nimport {\n    NotAuthorized,\n    CannotExitPositionWithinCooldownPeriod,\n    CannotInitiateWithdraw,\n    CannotForceWithdraw,\n    InvalidLendingRouter,\n    NoExistingPosition,\n    LiquidatorHasPosition,\n    CannotEnterPosition,\n    CannotLiquidateZeroShares,\n    InsufficientSharesHeld\n} from \"../interfaces/Errors.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IYieldStrategy} from \"../interfaces/IYieldStrategy.sol\";\nimport {RewardManagerMixin} from \"../rewards/RewardManagerMixin.sol\";\nimport {ILendingRouter} from \"../interfaces/ILendingRouter.sol\";\nimport {ADDRESS_REGISTRY, COOLDOWN_PERIOD} from \"../utils/Constants.sol\";\n\nabstract contract AbstractLendingRouter is ILendingRouter {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    mapping(address user => mapping(address operator => bool approved)) private s_isApproved;\n\n    /*** Authorization Methods ***/\n    modifier isAuthorized(address onBehalf, address vault) {\n        // In this case msg.sender is the operator\n        if (msg.sender != onBehalf && !isApproved(onBehalf, msg.sender)) {\n            revert NotAuthorized(msg.sender, onBehalf);\n        }\n\n        _;\n\n        // Clear the current account after the transaction is finished\n        IYieldStrategy(vault).clearCurrentAccount();\n    }\n\n    /// @inheritdoc ILendingRouter\n    function setApproval(address operator, bool approved) external override {\n        if (operator == msg.sender) revert NotAuthorized(msg.sender, operator);\n        s_isApproved[msg.sender][operator] = approved;\n    }\n\n    /// @inheritdoc ILendingRouter\n    function isApproved(address user, address operator) public view override returns (bool) {\n        return s_isApproved[user][operator];\n    }\n\n    /// @inheritdoc ILendingRouter\n    function enterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes calldata depositData\n    ) public override isAuthorized(onBehalf, vault) {\n        _enterPosition(onBehalf, vault, depositAssetAmount, borrowAmount, depositData, address(0));\n    }\n\n    /// @inheritdoc ILendingRouter\n    function migratePosition(\n        address onBehalf,\n        address vault,\n        address migrateFrom\n    ) public override isAuthorized(onBehalf, vault) {\n        if (!ADDRESS_REGISTRY.isLendingRouter(migrateFrom)) revert InvalidLendingRouter();\n        // Borrow amount is set to the amount of debt owed to the previous lending router\n        (uint256 borrowAmount, /* */, /* */) = ILendingRouter(migrateFrom).healthFactor(onBehalf, vault);\n\n        _enterPosition(onBehalf, vault, 0, borrowAmount, bytes(\"\"), migrateFrom);\n    }\n\n    function _enterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal {\n        address asset = IYieldStrategy(vault).asset();\n        // Cannot enter a position if the account already has a native share balance\n        if (IYieldStrategy(vault).balanceOf(onBehalf) > 0) revert CannotEnterPosition();\n\n        if (depositAssetAmount > 0) {\n            // Take any margin deposit from the sender initially\n            ERC20(asset).safeTransferFrom(msg.sender, address(this), depositAssetAmount);\n        }\n\n        if (borrowAmount > 0) {\n            _flashBorrowAndEnter(\n                onBehalf, vault, asset, depositAssetAmount, borrowAmount, depositData, migrateFrom\n            );\n        } else {\n            _enterOrMigrate(onBehalf, vault, asset, depositAssetAmount, depositData, migrateFrom);\n        }\n\n        ADDRESS_REGISTRY.setPosition(onBehalf, vault);\n    }\n\n    /// @inheritdoc ILendingRouter\n    function exitPosition(\n        address onBehalf,\n        address vault,\n        address receiver,\n        uint256 sharesToRedeem,\n        uint256 assetToRepay,\n        bytes calldata redeemData\n    ) external override isAuthorized(onBehalf, vault) {\n        _checkExit(onBehalf, vault);\n\n        address asset = IYieldStrategy(vault).asset();\n        if (0 < assetToRepay) {\n            _exitWithRepay(onBehalf, vault, asset, receiver, sharesToRedeem, assetToRepay, redeemData);\n        } else {\n            address migrateTo = _isMigrate(receiver) ? receiver : address(0);\n            uint256 assetsWithdrawn = _redeemShares(onBehalf, vault, asset, migrateTo, sharesToRedeem, redeemData);\n            if (0 < assetsWithdrawn) ERC20(asset).safeTransfer(receiver, assetsWithdrawn);\n        }\n\n        if (balanceOfCollateral(onBehalf, vault) == 0) {\n            ADDRESS_REGISTRY.clearPosition(onBehalf, vault);\n        }\n    }\n\n    /// @inheritdoc ILendingRouter\n    function liquidate(\n        address liquidateAccount,\n        address vault,\n        uint256 sharesToLiquidate,\n        uint256 debtToRepay\n    ) external override returns (uint256 sharesToLiquidator) {\n        if (sharesToLiquidate == 0) revert CannotLiquidateZeroShares();\n\n        address liquidator = msg.sender;\n        VaultPosition memory position = ADDRESS_REGISTRY.getVaultPosition(liquidator, vault);\n        // If the liquidator has a position then they cannot liquidate or they will have\n        // a native balance and a balance on the lending market.\n        if (position.lendingRouter != address(0)) revert LiquidatorHasPosition();\n\n        uint256 balanceBefore = balanceOfCollateral(liquidateAccount, vault);\n        if (balanceBefore == 0) revert InsufficientSharesHeld();\n\n        // Runs any checks on the vault to ensure that the liquidation can proceed, whitelists the lending platform\n        // to transfer collateral to the lending router. The current account is set in this method.\n        IYieldStrategy(vault).preLiquidation(liquidator, liquidateAccount, sharesToLiquidate, balanceBefore);\n\n        // After this call, address(this) will have the liquidated shares\n        sharesToLiquidator = _liquidate(liquidator, vault, liquidateAccount, sharesToLiquidate, debtToRepay);\n\n        // Transfers the shares to the liquidator from the lending router and does any post liquidation logic. The\n        // current account is cleared in this method.\n        IYieldStrategy(vault).postLiquidation(liquidator, liquidateAccount, sharesToLiquidator);\n\n        // The liquidator will receive shares in their native balance and then they can call redeem\n        // on the yield strategy to get the assets.\n\n        // Clear the position if the liquidator has taken all the shares, in the case of an insolvency,\n        // the account's position will just be left on the lending market with zero collateral. The account\n        // would be able to create a new position on this lending router or a new position on a different\n        // lending router. If they do create a new position on an insolvent account their old debt may\n        // be applied to their new position.\n        if (sharesToLiquidator == balanceBefore) ADDRESS_REGISTRY.clearPosition(liquidateAccount, vault);\n    }\n\n    /// @inheritdoc ILendingRouter\n    function initiateWithdraw(\n        address onBehalf,\n        address vault,\n        bytes calldata data\n    ) external override isAuthorized(onBehalf, vault) returns (uint256 requestId) {\n        requestId = _initiateWithdraw(vault, onBehalf, data);\n    }\n\n    /// @inheritdoc ILendingRouter\n    function forceWithdraw(address account, address vault, bytes calldata data) external returns (uint256 requestId) {\n        // Can only force a withdraw if health factor is negative, this allows a liquidator to\n        // force a withdraw and liquidate a position at a later time.\n        (uint256 borrowed, /* */, uint256 maxBorrow) = healthFactor(account, vault);\n        if (borrowed <= maxBorrow) revert CannotForceWithdraw(account);\n\n        requestId = _initiateWithdraw(vault, account, data);\n\n        // Clear the current account since this method is not called using isAuthorized\n        IYieldStrategy(vault).clearCurrentAccount();\n    }\n\n    /// @inheritdoc ILendingRouter\n    function claimRewards(address vault) external returns (uint256[] memory rewards) {\n        return RewardManagerMixin(vault).claimAccountRewards(msg.sender, balanceOfCollateral(msg.sender, vault));\n    }\n\n    /// @inheritdoc ILendingRouter\n    function healthFactor(address borrower, address vault) public override virtual returns (uint256 borrowed, uint256 collateralValue, uint256 maxBorrow);\n\n    /// @inheritdoc ILendingRouter\n    function balanceOfCollateral(address account, address vault) public override view virtual returns (uint256 collateralBalance);\n\n\n    /*** Internal Methods ***/\n\n    function _checkExit(address onBehalf, address vault) internal view  {\n        VaultPosition memory position = ADDRESS_REGISTRY.getVaultPosition(onBehalf, vault);\n        if (position.lendingRouter != address(this)) revert NoExistingPosition();\n        if (block.timestamp - position.lastEntryTime < COOLDOWN_PERIOD) {\n            revert CannotExitPositionWithinCooldownPeriod();\n        }\n    }\n\n    /// @dev Checks if an exitPosition call is a migration, this would be called via a lending router\n    function _isMigrate(address receiver) internal view returns (bool) {\n        return receiver == msg.sender && ADDRESS_REGISTRY.isLendingRouter(msg.sender);\n    }\n\n    /// @dev Enters a position or migrates shares from a previous lending router\n    function _enterOrMigrate(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 assetAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal returns (uint256 sharesReceived) {\n        if (migrateFrom != address(0)) {\n            // Allow the previous lending router to repay the debt from assets held here.\n            ERC20(asset).checkApprove(migrateFrom, assetAmount);\n            sharesReceived = ILendingRouter(migrateFrom).balanceOfCollateral(onBehalf, vault);\n\n            // Must migrate the entire position\n            ILendingRouter(migrateFrom).exitPosition(\n                onBehalf, vault, address(this), sharesReceived, type(uint256).max, bytes(\"\")\n            );\n        } else {\n            ERC20(asset).approve(vault, assetAmount);\n            sharesReceived = IYieldStrategy(vault).mintShares(assetAmount, onBehalf, depositData);\n        }\n\n        _supplyCollateral(onBehalf, vault, asset, sharesReceived);\n    }\n\n    /// @dev Redeems or withdraws shares from the lending market, handles migration\n    function _redeemShares(\n        address sharesOwner,\n        address vault,\n        address asset,\n        address migrateTo,\n        uint256 sharesToRedeem,\n        bytes memory redeemData\n    ) internal returns (uint256 assetsWithdrawn) {\n        address receiver = migrateTo == address(0) ? sharesOwner : migrateTo;\n        uint256 sharesHeld = balanceOfCollateral(sharesOwner, vault);\n\n        // Allows the transfer from the lending market to the sharesOwner\n        IYieldStrategy(vault).allowTransfer(receiver, sharesToRedeem, sharesOwner);\n        _withdrawCollateral(vault, asset, sharesToRedeem, sharesOwner, receiver);\n\n        // If we are not migrating then burn the shares\n        if (migrateTo == address(0)) {\n            assetsWithdrawn = IYieldStrategy(vault).burnShares(\n                sharesOwner, sharesToRedeem, sharesHeld, redeemData\n            );\n        }\n    }\n\n    /// @dev Initiates a withdraw request for the vault shares held by the account\n    function _initiateWithdraw(\n        address vault,\n        address account,\n        bytes calldata data\n    ) internal returns (uint256 requestId) {\n        uint256 sharesHeld = balanceOfCollateral(account, vault);\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n        return IYieldStrategy(vault).initiateWithdraw(account, sharesHeld, data);\n    }\n\n    /*** Virtual Methods (lending market specific) ***/\n\n    /// @dev Flash borrows the assets and enters a position\n    function _flashBorrowAndEnter(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal virtual;\n\n    /// @dev Supplies collateral in the amount of shares received to the lending market\n    function _supplyCollateral(\n        address onBehalf, address vault, address asset, uint256 sharesReceived\n    ) internal virtual;\n\n    /// @dev Withdraws collateral from the lending market\n    function _withdrawCollateral(\n        address vault,\n        address asset,\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        address receiver\n    ) internal virtual;\n\n    /// @dev Liquidates a position on the lending market\n    function _liquidate(\n        address liquidator,\n        address vault,\n        address liquidateAccount,\n        uint256 sharesToLiquidate,\n        uint256 debtToRepay\n    ) internal virtual returns (uint256 sharesToLiquidator);\n\n    /// @dev Exits a position with a debt repayment\n    function _exitWithRepay(\n        address onBehalf,\n        address vault,\n        address asset,\n        address receiver,\n        uint256 sharesToRedeem,\n        uint256 assetToRepay,\n        bytes calldata redeemData\n    ) internal virtual;\n\n}",
        "GenericERC4626.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {AbstractWithdrawRequestManager} from \"./AbstractWithdrawRequestManager.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @dev Used for ERC4626s that can be staked and unstaked on demand without any additional\n/// time constraints.\ncontract GenericERC4626WithdrawRequestManager is AbstractWithdrawRequestManager {\n\n    uint256 private currentRequestId;\n    mapping(uint256 => uint256) private s_withdrawRequestShares;\n\n    constructor(address _erc4626)\n        AbstractWithdrawRequestManager(IERC4626(_erc4626).asset(), _erc4626, IERC4626(_erc4626).asset()) { }\n\n    function _initiateWithdrawImpl(\n        address /* account */,\n        uint256 sharesToWithdraw,\n        bytes calldata /* data */\n    ) override internal returns (uint256 requestId) {\n        requestId = ++currentRequestId;\n        s_withdrawRequestShares[requestId] = sharesToWithdraw;\n    }\n\n    function _stakeTokens(uint256 amount, bytes memory /* stakeData */) internal override {\n        ERC20(STAKING_TOKEN).approve(address(YIELD_TOKEN), amount);\n        IERC4626(YIELD_TOKEN).deposit(amount, address(this));\n    }\n\n    function _finalizeWithdrawImpl(\n        address /* account */,\n        uint256 requestId\n    ) internal override returns (uint256 tokensClaimed, bool finalized) {\n        uint256 sharesToRedeem = s_withdrawRequestShares[requestId];\n        delete s_withdrawRequestShares[requestId];\n        tokensClaimed = IERC4626(YIELD_TOKEN).redeem(sharesToRedeem, address(this), address(this));\n        finalized = true;\n    }\n\n    function canFinalizeWithdrawRequest(uint256 /* requestId */) public pure override returns (bool) {\n        return true;\n    }\n}",
        "Constants.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {WETH9} from \"../interfaces/IWETH.sol\";\nimport {AddressRegistry} from \"../proxy/AddressRegistry.sol\";\n\naddress constant ETH_ADDRESS = address(0);\naddress constant ALT_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\nuint256 constant DEFAULT_PRECISION = 1e18;\nuint256 constant DEFAULT_DECIMALS = 18;\n\nuint256 constant COOLDOWN_PERIOD = 5 minutes;\nuint256 constant YEAR = 365 days;\n\n\n\n// TODO: move these to a deployment file\nuint256 constant CHAIN_ID_MAINNET = 1;\nWETH9 constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\nAddressRegistry constant ADDRESS_REGISTRY = AddressRegistry(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f);",
        "AbstractStakingStrategy.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {WithdrawRequestNotFinalized} from \"../interfaces/Errors.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {\n    IWithdrawRequestManager,\n    WithdrawRequest,\n    TokenizedWithdrawRequest\n} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {Trade, TradeType, TRADING_MODULE} from \"../interfaces/ITradingModule.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nstruct RedeemParams {\n    uint8 dexId;\n    uint256 minPurchaseAmount;\n    bytes exchangeData;\n}\n\nstruct DepositParams {\n    uint8 dexId;\n    uint256 minPurchaseAmount;\n    bytes exchangeData;\n}\n\n/**\n * Supports vaults that borrow a token and stake it into a token that earns yield but may\n * require some illiquid redemption period.\n */\nabstract contract AbstractStakingStrategy is AbstractYieldStrategy {\n    using SafeERC20 for ERC20;\n\n    address internal immutable withdrawToken;\n\n    constructor(\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) AbstractYieldStrategy(_asset, _yieldToken, _feeRate, ERC20(_yieldToken).decimals()) {\n        // For Pendle PT the yield token does not define the withdraw request manager,\n        // it is the token out sy\n        withdrawRequestManager = _withdrawRequestManager;\n        withdrawToken = address(withdrawRequestManager) != address(0) ? withdrawRequestManager.WITHDRAW_TOKEN() : address(0);\n    }\n\n    /// @notice Returns the total value in terms of the borrowed token of the account's position\n    function convertToAssets(uint256 shares) public view override returns (uint256) {\n        if (t_CurrentAccount != address(0) && _isWithdrawRequestPending(t_CurrentAccount)) {\n            (bool hasRequest, uint256 value) = withdrawRequestManager.getWithdrawRequestValue(\n                address(this), t_CurrentAccount, asset, shares\n            );\n\n            // If the account does not have a withdraw request then this will fall through\n            // to the super implementation.\n            if (hasRequest) return value;\n        }\n\n        return super.convertToAssets(shares);\n    }\n\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override virtual returns (uint256 requestId) {\n        ERC20(yieldToken).approve(address(withdrawRequestManager), yieldTokenAmount);\n        requestId = withdrawRequestManager.initiateWithdraw({\n            account: account, yieldTokenAmount: yieldTokenAmount, sharesAmount: sharesHeld, data: data\n        });\n    }\n\n    /// @dev By default we can use the withdraw request manager to stake the tokens\n    function _mintYieldTokens(uint256 assets, address /* receiver */, bytes memory depositData) internal override virtual {\n        ERC20(asset).approve(address(withdrawRequestManager), assets);\n        withdrawRequestManager.stakeTokens(address(asset), assets, depositData);\n    }\n\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal override {\n        if (isEscrowed) {\n            (WithdrawRequest memory w, /* */) = withdrawRequestManager.getWithdrawRequest(address(this), sharesOwner);\n            uint256 yieldTokensBurned = uint256(w.yieldTokenAmount) * sharesToRedeem / w.sharesAmount;\n\n            (uint256 tokensClaimed, bool finalized) = withdrawRequestManager.finalizeAndRedeemWithdrawRequest({\n                account: sharesOwner, withdrawYieldTokenAmount: yieldTokensBurned, sharesToBurn: sharesToRedeem\n            });\n            if (!finalized) revert WithdrawRequestNotFinalized(w.requestId);\n\n            // Trades may be required here if the borrowed token is not the same as what is\n            // received when redeeming.\n            if (asset != withdrawToken) {\n                RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n                Trade memory trade = Trade({\n                    tradeType: TradeType.EXACT_IN_SINGLE,\n                    sellToken: address(withdrawToken),\n                    buyToken: address(asset),\n                    amount: tokensClaimed,\n                    limit: params.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: params.exchangeData\n                });\n\n                _executeTrade(trade, params.dexId);\n            }\n        } else {\n            uint256 yieldTokensBurned = convertSharesToYieldToken(sharesToRedeem);\n            _executeInstantRedemption(yieldTokensBurned, redeemData);\n        }\n    }\n\n    /// @notice Default implementation for an instant redemption is to sell the staking token to the\n    /// borrow token through the trading module. Can be overridden if required for different implementations.\n    function _executeInstantRedemption(\n        uint256 yieldTokensToRedeem,\n        bytes memory redeemData\n    ) internal virtual returns (uint256 assetsPurchased) {\n        RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(yieldToken),\n            buyToken: address(asset),\n            amount: yieldTokensToRedeem,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        // Executes a trade on the given Dex, the vault must have permissions set for\n        // each dex and token it wants to sell.\n        (/* */, assetsPurchased) = _executeTrade(trade, params.dexId);\n    }\n    \n    function _preLiquidation(address, address, uint256, uint256) internal override { /* no-op */ }\n\n    function _postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal override returns (bool didTokenize) {\n        if (address(withdrawRequestManager) != address(0)) {\n            // No need to accrue fees because neither the total supply or total yield token balance is changing. If there\n            // is no withdraw request then this will be a noop.\n            didTokenize = withdrawRequestManager.tokenizeWithdrawRequest(liquidateAccount, liquidator, sharesToLiquidator);\n        }\n    }\n\n}",
        "MorphoLendingRouter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ILendingRouter} from \"../interfaces/ILendingRouter.sol\";\nimport {InsufficientAssetsForRepayment} from \"../interfaces/Errors.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IYieldStrategy} from \"../interfaces/IYieldStrategy.sol\";\nimport {IMorphoLiquidateCallback, IMorphoFlashLoanCallback, IMorphoRepayCallback} from \"../interfaces/Morpho/IMorphoCallbacks.sol\";\nimport {ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {AbstractLendingRouter} from \"./AbstractLendingRouter.sol\";\nimport {\n    MORPHO,\n    MarketParams,\n    Id,\n    Position,\n    Market,\n    Withdrawal,\n    PUBLIC_ALLOCATOR\n} from \"../interfaces/Morpho/IMorpho.sol\";\n\nstruct MorphoParams {\n    address irm;\n    uint256 lltv;\n}\n\nstruct MorphoAllocation {\n    address vault;\n    uint256 feeAmount;\n    Withdrawal[] withdrawals;\n}\n\ncontract MorphoLendingRouter is AbstractLendingRouter, IMorphoLiquidateCallback, IMorphoFlashLoanCallback, IMorphoRepayCallback {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    mapping(address vault => MorphoParams params) private s_morphoParams;\n\n    function initializeMarket(address vault, address irm, uint256 lltv) external {\n        require(ADDRESS_REGISTRY.upgradeAdmin() == msg.sender);\n        // Cannot override parameters once they are set\n        require(s_morphoParams[vault].irm == address(0));\n        require(s_morphoParams[vault].lltv == 0);\n\n        s_morphoParams[vault] = MorphoParams({\n            irm: irm,\n            lltv: lltv\n        });\n\n        MORPHO.createMarket(marketParams(vault));\n    }\n\n    function marketParams(address vault) public view returns (MarketParams memory) {\n        return marketParams(vault, IYieldStrategy(vault).asset());\n    }\n\n    function marketParams(address vault, address asset) internal view returns (MarketParams memory) {\n        MorphoParams memory params = s_morphoParams[vault];\n\n        return MarketParams({\n            loanToken: asset,\n            collateralToken: vault,\n            oracle: vault,\n            irm: params.irm,\n            lltv: params.lltv\n        });\n    }\n\n    function morphoId(MarketParams memory m) internal pure returns (Id) {\n        return Id.wrap(keccak256(abi.encode(m)));\n    }\n\n    /// @dev Allows integration with the public allocator so that accounts can\n    /// ensure there is sufficient liquidity in the lending market before entering\n    function _allocate(address vault, MorphoAllocation[] calldata allocationData) internal {\n        MarketParams memory m = marketParams(vault);\n\n        uint256 totalFeeAmount;\n        for (uint256 i = 0; i < allocationData.length; i++) {\n            PUBLIC_ALLOCATOR.reallocateTo{value: allocationData[i].feeAmount}(\n                allocationData[i].vault, allocationData[i].withdrawals, m\n            );\n            totalFeeAmount += allocationData[i].feeAmount;\n        }\n        require(msg.value == totalFeeAmount, \"Insufficient fee amount\");\n    }\n\n    function allocateAndEnterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes calldata depositData,\n        MorphoAllocation[] calldata allocationData\n    ) external payable isAuthorized(onBehalf, vault) {\n        _allocate(vault, allocationData);\n        enterPosition(onBehalf, vault, depositAssetAmount, borrowAmount, depositData);\n    }\n\n    function allocateAndMigratePosition(\n        address onBehalf,\n        address vault,\n        address migrateFrom,\n        MorphoAllocation[] calldata allocationData\n    ) external payable isAuthorized(onBehalf, vault) {\n        _allocate(vault, allocationData);\n        migratePosition(onBehalf, vault, migrateFrom);\n    }\n\n    function _flashBorrowAndEnter(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal override {\n        // At this point we will flash borrow funds from the lending market and then\n        // receive control in a different function on a callback.\n        bytes memory flashLoanData = abi.encode(\n            onBehalf, vault, asset, depositAssetAmount, depositData, migrateFrom\n        );\n        MORPHO.flashLoan(asset, borrowAmount, flashLoanData);\n    }\n\n    function onMorphoFlashLoan(uint256 assets, bytes calldata data) external override {\n        require(msg.sender == address(MORPHO));\n\n        (\n            address onBehalf,\n            address vault,\n            address asset,\n            uint256 depositAssetAmount,\n            bytes memory depositData,\n            address migrateFrom\n        ) = abi.decode(data, (address, address, address, uint256, bytes, address));\n\n        _enterOrMigrate(onBehalf, vault, asset, assets + depositAssetAmount, depositData, migrateFrom);\n\n        MarketParams memory m = marketParams(vault, asset);\n        // Borrow the assets in order to repay the flash loan\n        MORPHO.borrow(m, assets, 0, onBehalf, address(this));\n\n        // Allow for flash loan to be repaid\n        ERC20(asset).checkApprove(address(MORPHO), assets);\n    }\n\n    function _supplyCollateral(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 sharesReceived\n    ) internal override {\n        MarketParams memory m = marketParams(vault, asset);\n\n        // Allows the transfer from the lending market to the Morpho contract\n        IYieldStrategy(vault).allowTransfer(address(MORPHO), sharesReceived, onBehalf);\n\n        // We should receive shares in return\n        ERC20(vault).approve(address(MORPHO), sharesReceived);\n        MORPHO.supplyCollateral(m, sharesReceived, onBehalf, \"\");\n    }\n\n    function _withdrawCollateral(\n        address vault,\n        address asset,\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        address receiver\n    ) internal override {\n        MarketParams memory m = marketParams(vault, asset);\n        MORPHO.withdrawCollateral(m, sharesToRedeem, sharesOwner, receiver);\n    }\n\n    function _exitWithRepay(\n        address onBehalf,\n        address vault,\n        address asset,\n        address receiver,\n        uint256 sharesToRedeem,\n        uint256 assetToRepay,\n        bytes calldata redeemData\n    ) internal override {\n        MarketParams memory m = marketParams(vault, asset);\n\n        uint256 sharesToRepay;\n        if (assetToRepay == type(uint256).max) {\n            // If assetToRepay is uint256.max then get the morpho borrow shares amount to\n            // get a full exit.\n            sharesToRepay = MORPHO.position(morphoId(m), onBehalf).borrowShares;\n            assetToRepay = 0;\n        }\n\n        bytes memory repayData = abi.encode(\n            onBehalf, vault, asset, receiver, sharesToRedeem, redeemData, _isMigrate(receiver)\n        );\n\n        // Will trigger a callback to onMorphoRepay\n        MORPHO.repay(m, assetToRepay, sharesToRepay, onBehalf, repayData);\n    }\n\n    function onMorphoRepay(uint256 assetToRepay, bytes calldata data) external override {\n        require(msg.sender == address(MORPHO));\n\n        (\n            address sharesOwner,\n            address vault,\n            address asset,\n            address receiver,\n            uint256 sharesToRedeem,\n            bytes memory redeemData,\n            bool isMigrate\n        ) = abi.decode(data, (address, address, address, address, uint256, bytes, bool));\n\n        uint256 assetsWithdrawn = _redeemShares(\n            sharesOwner, vault, asset, isMigrate ? receiver : address(0), sharesToRedeem, redeemData\n        );\n\n        if (isMigrate) {\n            // When migrating we do not withdraw any assets and we must repay the entire debt\n            // from the previous lending router.\n            ERC20(asset).safeTransferFrom(receiver, address(this), assetToRepay);\n            assetsWithdrawn = assetToRepay;\n        }\n\n        // Transfer any profits to the receiver\n        if (assetsWithdrawn < assetToRepay) {\n            // We have to revert in this case because we've already redeemed the yield tokens\n            revert InsufficientAssetsForRepayment(assetToRepay, assetsWithdrawn);\n        }\n\n        uint256 profitsWithdrawn;\n        unchecked {\n            profitsWithdrawn = assetsWithdrawn - assetToRepay;\n        }\n        ERC20(asset).safeTransfer(receiver, profitsWithdrawn);\n\n        // Allow morpho to repay the debt\n        ERC20(asset).checkApprove(address(MORPHO), assetToRepay);\n    }\n\n    function _liquidate(\n        address liquidator,\n        address vault,\n        address liquidateAccount,\n        uint256 sharesToLiquidate,\n        uint256 debtToRepay\n    ) internal override returns (uint256 sharesToLiquidator) {\n        MarketParams memory m = marketParams(vault);\n        (sharesToLiquidator, /* */) = MORPHO.liquidate(\n            m, liquidateAccount, sharesToLiquidate, debtToRepay, abi.encode(m.loanToken, liquidator)\n        );\n    }\n\n    function onMorphoLiquidate(uint256 repaidAssets, bytes calldata data) external override {\n        require(msg.sender == address(MORPHO));\n        (address asset, address liquidator) = abi.decode(data, (address, address));\n\n        ERC20(asset).safeTransferFrom(liquidator, address(this), repaidAssets);\n        ERC20(asset).checkApprove(address(MORPHO), repaidAssets);\n    }\n\n    function balanceOfCollateral(address account, address vault) public view override returns (uint256 collateralBalance) {\n        MarketParams memory m = marketParams(vault);\n        collateralBalance = MORPHO.position(morphoId(m), account).collateral;\n    }\n\n    function healthFactor(address borrower, address vault) public override returns (uint256 borrowed, uint256 collateralValue, uint256 maxBorrow) {\n        MarketParams memory m = marketParams(vault);\n        Id id = morphoId(m);\n        // Ensure interest is accrued before calculating health factor\n        MORPHO.accrueInterest(m);\n        Position memory position = MORPHO.position(id, borrower);\n        Market memory market = MORPHO.market(id);\n\n        if (position.borrowShares > 0) {\n            borrowed = (uint256(position.borrowShares) * uint256(market.totalBorrowAssets)) / uint256(market.totalBorrowShares);\n        } else {\n            borrowed = 0;\n        }\n        collateralValue = (uint256(position.collateral) * IYieldStrategy(vault).price(borrower)) / 1e36;\n        maxBorrow = collateralValue * m.lltv / 1e18;\n    }\n\n}\n",
        "RewardManagerMixin.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {IRewardManager} from \"../interfaces/IRewardManager.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {ILendingRouter} from \"../interfaces/ILendingRouter.sol\";\nimport {ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {CannotLiquidateZeroShares} from \"../interfaces/Errors.sol\";\n\nabstract contract RewardManagerMixin is AbstractYieldStrategy {\n    IRewardManager public immutable REWARD_MANAGER;\n\n    uint256 internal transient t_Liquidator_SharesBefore;\n    uint256 internal transient t_LiquidateAccount_SharesBefore;\n\n    constructor(\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        uint8 _yieldTokenDecimals\n    ) AbstractYieldStrategy(_asset, _yieldToken, _feeRate, _yieldTokenDecimals) {\n        REWARD_MANAGER = IRewardManager(_rewardManager);\n    }\n\n    function _preLiquidation(\n        address /* liquidateAccount */,\n        address liquidator,\n        uint256 /* sharesToLiquidate */,\n        uint256 accountSharesHeld\n    ) internal override virtual {\n        // This only works because the liquidator is prevented from having a position on the lending router so any\n        // balance will be a native token balance.\n        t_Liquidator_SharesBefore = balanceOf(liquidator);\n        t_LiquidateAccount_SharesBefore = accountSharesHeld;\n    }\n\n    function __postLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidator\n    ) internal virtual returns (bool didTokenize);\n\n    function _postLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidator\n    ) internal override returns (bool didTokenize) {\n        // Total supply does not change during liquidation\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        if (sharesToLiquidator == 0) revert CannotLiquidateZeroShares();\n\n        didTokenize = __postLiquidation(liquidator, liquidateAccount, sharesToLiquidator);\n\n        _updateAccountRewards({\n            account: liquidator,\n            accountSharesBefore: t_Liquidator_SharesBefore,\n            accountSharesAfter: t_Liquidator_SharesBefore + sharesToLiquidator,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: didTokenize\n        });\n\n        _updateAccountRewards({\n            account: liquidateAccount,\n            accountSharesBefore: t_LiquidateAccount_SharesBefore,\n            accountSharesAfter: t_LiquidateAccount_SharesBefore - sharesToLiquidator,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: didTokenize\n        });\n    }\n\n    function _mintSharesGivenAssets(\n        uint256 assets,\n        bytes memory depositData,\n        address receiver\n    ) internal override returns (uint256 sharesMinted) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        uint256 initialVaultShares = ILendingRouter(t_CurrentLendingRouter).balanceOfCollateral(receiver, address(this));\n        sharesMinted = super._mintSharesGivenAssets(assets, depositData, receiver);\n        _updateAccountRewards({\n            account: receiver,\n            accountSharesBefore: initialVaultShares,\n            accountSharesAfter: initialVaultShares + sharesMinted,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            // Shares cannot be in escrow during minting\n            sharesInEscrow: false\n        });\n    }\n\n    function _burnShares(\n        uint256 sharesToBurn,\n        uint256 sharesHeld,\n        bytes memory redeemData,\n        address sharesOwner\n    ) internal override returns (uint256 assetsWithdrawn) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        // Get the escrow state before burning the shares since it will be cleared if\n        // the entire balance is burned.\n        bool wasEscrowed = _isWithdrawRequestPending(sharesOwner);\n\n        assetsWithdrawn = super._burnShares(sharesToBurn, sharesHeld, redeemData, sharesOwner);\n\n        _updateAccountRewards({\n            account: sharesOwner,\n            accountSharesBefore: sharesHeld,\n            // If shares after is zero then the escrow state will be cleared\n            accountSharesAfter: sharesHeld - sharesToBurn,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: wasEscrowed\n        });\n    }\n\n    function __initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal virtual returns (uint256 requestId);\n    \n    /// @dev Ensures that the account no longer accrues rewards after a withdraw request is initiated.\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override returns (uint256 requestId) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n\n        // Claim all rewards before initiating a withdraw shares not considered \n        // in the escrow state at this point.\n        _updateAccountRewards({\n            account: account,\n            accountSharesBefore: sharesHeld,\n            accountSharesAfter: sharesHeld,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: false\n        });\n\n        requestId = __initiateWithdraw(account, yieldTokenAmount, sharesHeld, data);\n    }\n\n    function _updateAccountRewards(\n        address account,\n        uint256 effectiveSupplyBefore,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        bool sharesInEscrow\n    ) internal returns (bytes memory) {\n        return _delegateCall(address(REWARD_MANAGER), abi.encodeWithSelector(\n            IRewardManager.updateAccountRewards.selector,\n            account, effectiveSupplyBefore, accountSharesBefore, accountSharesAfter, sharesInEscrow\n        ));\n    }\n\n    function claimAccountRewards(\n        address account,\n        uint256 sharesHeld\n    ) external nonReentrant returns (uint256[] memory rewards) {\n        uint256 effectiveSupplyBefore = effectiveSupply();\n        if (!ADDRESS_REGISTRY.isLendingRouter(msg.sender)) {\n            // If the caller is not a lending router we get the shares held in a\n            // native token account.\n            sharesHeld = balanceOf(account);\n        }\n        // Short circuit if the account has no shares or a withdraw request is pending\n        if (sharesHeld == 0 || _isWithdrawRequestPending(account)) return rewards;\n\n        bytes memory result = _updateAccountRewards({\n            account: account,\n            accountSharesBefore: sharesHeld,\n            accountSharesAfter: sharesHeld,\n            effectiveSupplyBefore: effectiveSupplyBefore,\n            sharesInEscrow: false\n        });\n\n        rewards = abi.decode(result, (uint256[]));\n    }\n\n    fallback() external {\n        address target = address(REWARD_MANAGER);\n        // Cannot call updateAccountRewards unless it's through the internal methods\n        require(msg.sig != IRewardManager.updateAccountRewards.selector);\n        bytes memory result = _delegateCall(target, msg.data);\n\n        assembly {\n            // Copy the result to memory\n            let resultSize := mload(result)\n            // Copy the result data (skipping the length prefix)\n            let resultData := add(result, 0x20)\n            // Copy to the return data area\n            return(resultData, resultSize)\n        }\n    }\n}\n"
    }
}