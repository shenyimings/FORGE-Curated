{
    "vfp_id": "vfp_00342",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Missed deletion of pending withdrawal address allows a potentially untrusted one to set itself as withdrawal address",
            "description": "When setWithdrawalAddress() is called with _confirm == true, it performs a single-step update but fails to delete any previously set pending withdrawal address. This allows a previously set (and potentially malicious) pending address to later call confirmWithdrawalAddress() and become the active withdrawal address.\nThe root cause is the omission of a deletion step (e.g., deleting pendingWithdrawalAddresses[_nodeAddress]) before or after updating the withdrawal address in the confirmed path.\nAn attacker could exploit this by having a node operator mistakenly set them as a pending address, then later having the node operator correct the mistake with a confirmed changeâ€”leaving the attacker's address still pending. The attacker can then claim control.\nThe impact is unauthorized control over a node's withdrawal address, leading to theft of ETH and RPL rewards, though the scenario requires a prior mistake by the node operator.\n",
            "severity": "Low",
            "location": [
                "RocketStorage.sol#L119-L134",
                "RocketStorage.sol#L136-L150"
            ],
            "files": [
                "rocketpool/contracts/contract/RocketStorage.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketStorage.sol": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title The primary persistent storage for Rocket Pool\n/// @author David Rugendyke\n\ncontract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n    mapping(bytes32 => uint256)    private uintStorage;\n    mapping(bytes32 => int256)     private intStorage;\n    mapping(bytes32 => address)    private addressStorage;\n    mapping(bytes32 => bool)       private booleanStorage;\n    mapping(bytes32 => bytes32)    private bytes32Storage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    /// @dev Only allow access from the latest version of a contract in the Rocket Pool network after deployment\n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(booleanStorage[keccak256(abi.encodePacked(\"contract.exists\", msg.sender))], \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            require((\n                booleanStorage[keccak256(abi.encodePacked(\"contract.exists\", msg.sender))] || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    /// @dev Construct RocketStorage\n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external override view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    /// @param _key The key for the record\n    function getAddress(bytes32 _key) override external view returns (address r) {\n        return addressStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        return uintStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function getBool(bytes32 _key) override external view returns (bool r) {\n        return booleanStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function getInt(bytes32 _key) override external view returns (int r) {\n        return intStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        return bytes32Storage[_key];\n    }\n\n\n    /// @param _key The key for the record\n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        addressStorage[_key] = _value;\n    }\n\n    /// @param _key The key for the record\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        uintStorage[_key] = _value;\n    }\n\n    /// @param _key The key for the record\n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    /// @param _key The key for the record\n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    /// @param _key The key for the record\n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        booleanStorage[_key] = _value;\n    }\n\n    /// @param _key The key for the record\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        intStorage[_key] = _value;\n    }\n\n    /// @param _key The key for the record\n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        bytes32Storage[_key] = _value;\n    }\n\n\n    /// @param _key The key for the record\n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete addressStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete uintStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete booleanStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete intStorage[_key];\n    }\n\n    /// @param _key The key for the record\n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytes32Storage[_key];\n    }\n\n\n    /// @param _key The key for the record\n    /// @param _amount An amount to add to the record's value\n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uintStorage[_key] = uintStorage[_key].add(_amount);\n    }\n\n    /// @param _key The key for the record\n    /// @param _amount An amount to subtract from the record's value\n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uintStorage[_key] = uintStorage[_key].sub(_amount);\n    }\n}\n"
    }
}