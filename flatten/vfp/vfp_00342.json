{
    "vfp_id": "vfp_00342",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ]
            },
            "title": "Agent creator can partially bypass LPs lock on agents with custom tokens",
            "description": "The AgentFactoryV4 contract allows the creator to specify a low initialLP amount during Agent creation, which results in only a small amount of LP tokens being locked for the 10-year maturity period. The creator can then add a large amount of unbalanced liquidity afterward, effectively bypassing the long-term lock intended for initial liquidity providers. The root cause is the ability to set arbitrary initial liquidity values without enforcement of fair or balanced locking. An attacker (the Agent creator) can exploit this to maintain liquidity control and exit flexibility while appearing to comply with lock-up requirements. This undermines the economic security model and allows manipulation of pool dynamics.\n",
            "severity": "Medium",
            "location": [
                "AgentFactoryV4.sol"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentFactoryV4.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Creating an agent that uses VIRTUAL itself as custom tokens allows to drain VIRTUAL tokens held in AgentFactoryV4",
            "description": "During agent creation via AgentFactoryV4, VIRTUAL tokens are temporarily held in the contract. An attacker can initiate an application using VIRTUAL as the custom token, then call withdraw() to cancel the application. The withdraw() function transfers the full balance of the customToken (which is VIRTUAL) back to the proposer. Since the contract holds VIRTUAL tokens from other pending applications, this allows the attacker to drain all VIRTUAL tokens in the contract. The root cause is the failure to distinguish between the application's own deposit and the global contract balance when withdrawing. This can be exploited to steal funds from other users' pending applications. The impact is complete loss of all VIRTUAL tokens held in AgentFactoryV4, affecting multiple users and applications.\n",
            "severity": "High",
            "location": [
                "AgentFactoryV4.sol"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentFactoryV4.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Creation of an agent with a custom token can be DOSed",
            "description": "The AgentFactoryV4 contract reverts if a Uniswap pool for VIRTUAL/customToken already exists when calling executeTokenApplication. An attacker can front-run the deployment by creating the pool in advance, thereby preventing the legitimate Agent creation. The root cause is the strict requirement that the pool must not exist, without any mechanism to handle or bypass pre-existing pools. This allows any third party to deny service to Agent creators using custom tokens, leading to a denial of service. While the impact is limited to new Agent deployment, it disrupts the intended functionality and can be used maliciously to block competitors.\n",
            "severity": "Medium",
            "location": [
                "AgentFactoryV4"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentFactoryV4.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Sanity checks in Agent factory",
            "description": "The AgentFactoryV4 contract lacks validation for critical token parameters such as maxSupply, lpSupply, vaultSupply, and tax basis points. If maxSupply does not equal the sum of lpSupply and vaultSupply, token creation reverts, potentially locking funds or preventing deployment. Additionally, tax parameters exceeding 10,000 basis points can break internal accounting. This is due to missing input validation in setTokenSupplyParams and setTokenTaxParams. The impact includes operational failure during token deployment or incorrect tax calculations, leading to financial discrepancies or denial of service.\n",
            "severity": "Low",
            "location": [
                "AgentFactoryV4.sol#472",
                "AgentFactoryV4.sol#492",
                "AgentToken.sol#466"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentFactoryV4.sol"
            ]
        }
    ],
    "affected_files": {
        "AgentFactoryV4.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"./IAgentFactoryV4.sol\";\nimport \"./IAgentToken.sol\";\nimport \"./IAgentVeToken.sol\";\nimport \"./IAgentDAO.sol\";\nimport \"./IAgentNft.sol\";\nimport \"../libs/IERC6551Registry.sol\";\nimport \"../pool/IUniswapV2Factory.sol\";\nimport \"../pool/IUniswapV2Router02.sol\";\n\ncontract AgentFactoryV4 is\n    IAgentFactoryV4,\n    Initializable,\n    AccessControl,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 private _nextId;\n    address public tokenImplementation;\n    address public daoImplementation;\n    address public nft;\n    address public tbaRegistry; // Token bound account\n    uint256 public applicationThreshold;\n\n    address[] public allTokens;\n    address[] public allDAOs;\n\n    address public assetToken; // Base currency\n    uint256 public maturityDuration; // Staking duration in seconds for initial LP. eg: 10years\n\n    bytes32 public constant WITHDRAW_ROLE = keccak256(\"WITHDRAW_ROLE\"); // Able to withdraw and execute applications\n\n    event NewPersona(\n        uint256 virtualId,\n        address token,\n        address dao,\n        address tba,\n        address veToken,\n        address lp\n    );\n    event NewApplication(uint256 id);\n\n    enum ApplicationStatus {\n        Active,\n        Executed,\n        Withdrawn\n    }\n\n    struct Application {\n        string name;\n        string symbol;\n        string tokenURI;\n        ApplicationStatus status;\n        uint256 withdrawableAmount;\n        address proposer;\n        uint8[] cores;\n        uint256 proposalEndBlock;\n        uint256 virtualId;\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n    }\n\n    mapping(uint256 => Application) private _applications;\n\n    event ApplicationThresholdUpdated(uint256 newThreshold);\n    event GovUpdated(address newGov);\n    event ImplContractsUpdated(address token, address dao);\n\n    address private _vault; // Vault to hold all Virtual NFTs\n\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"cannot reenter\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    ///////////////////////////////////////////////////////////////\n    // V2 Storage\n    ///////////////////////////////////////////////////////////////\n    address[] public allTradingTokens;\n    address private _uniswapRouter;\n    address public veTokenImplementation;\n    address private _tokenAdmin;\n    address public defaultDelegatee;\n\n    // Default agent token params\n    bytes private _tokenSupplyParams;\n    bytes private _tokenTaxParams;\n\n    ///////////////////////////////////////////////////////////////\n    // V4 Storage\n    ///////////////////////////////////////////////////////////////\n    // The follow 2 variables maps only custom ERC20 to agent applications\n    mapping(address => uint256) private _tokenApplication;\n    mapping(uint256 => address) private _applicationToken;\n\n    ///////////////////////////////////////////////////////////////\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address tokenImplementation_,\n        address veTokenImplementation_,\n        address daoImplementation_,\n        address tbaRegistry_,\n        address assetToken_,\n        address nft_,\n        uint256 applicationThreshold_,\n        address vault_,\n        uint256 nextId_\n    ) public initializer {\n        __Pausable_init();\n\n        tokenImplementation = tokenImplementation_;\n        veTokenImplementation = veTokenImplementation_;\n        daoImplementation = daoImplementation_;\n        assetToken = assetToken_;\n        tbaRegistry = tbaRegistry_;\n        nft = nft_;\n        applicationThreshold = applicationThreshold_;\n        _nextId = nextId_;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _vault = vault_;\n    }\n\n    function getApplication(\n        uint256 proposalId\n    ) public view returns (Application memory) {\n        return _applications[proposalId];\n    }\n\n    function proposeAgent(\n        string memory name,\n        string memory symbol,\n        string memory tokenURI,\n        uint8[] memory cores,\n        bytes32 tbaSalt,\n        address tbaImplementation,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold\n    ) public whenNotPaused returns (uint256) {\n        address sender = _msgSender();\n        require(\n            IERC20(assetToken).balanceOf(sender) >= applicationThreshold,\n            \"Insufficient asset token\"\n        );\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >=\n                applicationThreshold,\n            \"Insufficient asset token allowance\"\n        );\n        require(cores.length > 0, \"Cores must be provided\");\n\n        IERC20(assetToken).safeTransferFrom(\n            sender,\n            address(this),\n            applicationThreshold\n        );\n\n        uint256 id = _nextId++;\n        uint256 proposalEndBlock = block.number; // No longer required in v2\n        Application memory application = Application(\n            name,\n            symbol,\n            tokenURI,\n            ApplicationStatus.Active,\n            applicationThreshold,\n            sender,\n            cores,\n            proposalEndBlock,\n            0,\n            tbaSalt,\n            tbaImplementation,\n            daoVotingPeriod,\n            daoThreshold\n        );\n        _applications[id] = application;\n        emit NewApplication(id);\n\n        return id;\n    }\n\n    function withdraw(uint256 id) public noReentrant {\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        require(\n            application.status == ApplicationStatus.Active,\n            \"Application is not active\"\n        );\n\n        require(\n            block.number > application.proposalEndBlock,\n            \"Application is not matured yet\"\n        );\n\n        uint256 withdrawableAmount = application.withdrawableAmount;\n\n        application.withdrawableAmount = 0;\n        application.status = ApplicationStatus.Withdrawn;\n\n        IERC20(assetToken).safeTransfer(\n            application.proposer,\n            withdrawableAmount\n        );\n\n        address customToken = _applicationToken[id];\n        if (customToken != address(0)) {\n            IERC20(customToken).safeTransfer(\n                application.proposer,\n                IERC20(customToken).balanceOf(address(this))\n            );\n\n            _tokenApplication[customToken] = 0;\n            _applicationToken[id] = address(0);\n        }\n    }\n\n    function _executeApplication(\n        uint256 id,\n        bool canStake,\n        bytes memory tokenSupplyParams_\n    ) internal {\n        require(\n            _applications[id].status == ApplicationStatus.Active,\n            \"Application is not active\"\n        );\n\n        require(_tokenAdmin != address(0), \"Token admin not set\");\n\n        Application storage application = _applications[id];\n\n        uint256 initialAmount = application.withdrawableAmount;\n        application.withdrawableAmount = 0;\n        application.status = ApplicationStatus.Executed;\n\n        // C1 & C2\n        address token = _applicationToken[id];\n        address lp = address(0);\n        if (token == address(0)) {\n            token = _createNewAgentToken(\n                application.name,\n                application.symbol,\n                tokenSupplyParams_\n            );\n            lp = IAgentToken(token).liquidityPools()[0];\n            IERC20(assetToken).safeTransfer(token, initialAmount);\n            IAgentToken(token).addInitialLiquidity(address(this));\n        } else {\n            // Custom token\n            lp = _createPair(token);\n            IERC20(token).forceApprove(_uniswapRouter, type(uint256).max);\n            IERC20(assetToken).forceApprove(_uniswapRouter, initialAmount);\n            // Add the liquidity:\n            IUniswapV2Router02(_uniswapRouter).addLiquidity(\n                token,\n                assetToken,\n                IERC20(token).balanceOf(address(this)),\n                initialAmount,\n                0,\n                0,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        // C3\n        address veToken = _createNewAgentVeToken(\n            string.concat(\"Staked \", application.name),\n            string.concat(\"s\", application.symbol),\n            lp,\n            application.proposer,\n            canStake\n        );\n\n        // C4\n        string memory daoName = string.concat(application.name, \" DAO\");\n        address payable dao = payable(\n            _createNewDAO(\n                daoName,\n                IVotes(veToken),\n                application.daoVotingPeriod,\n                application.daoThreshold\n            )\n        );\n\n        // C5\n        uint256 virtualId = IAgentNft(nft).nextVirtualId();\n        IAgentNft(nft).mint(\n            virtualId,\n            _vault,\n            application.tokenURI,\n            dao,\n            application.proposer,\n            application.cores,\n            lp,\n            token\n        );\n        application.virtualId = virtualId;\n\n        // C6\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        address tbaAddress = IERC6551Registry(tbaRegistry).createAccount(\n            application.tbaImplementation,\n            application.tbaSalt,\n            chainId,\n            nft,\n            virtualId\n        );\n        IAgentNft(nft).setTBA(virtualId, tbaAddress);\n\n        // C7\n        IERC20(lp).approve(veToken, type(uint256).max);\n        IAgentVeToken(veToken).stake(\n            IERC20(lp).balanceOf(address(this)),\n            application.proposer,\n            defaultDelegatee\n        );\n\n        emit NewPersona(virtualId, token, dao, tbaAddress, veToken, lp);\n    }\n\n    function executeApplication(uint256 id, bool canStake) public noReentrant {\n        // This will bootstrap an Agent with following components:\n        // C1: Agent Token\n        // C2: LP Pool + Initial liquidity\n        // C3: Agent veToken\n        // C4: Agent DAO\n        // C5: Agent NFT\n        // C6: TBA\n        // C7: Stake liquidity token to get veToken\n\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        _executeApplication(id, canStake, _tokenSupplyParams);\n    }\n\n    function _createNewDAO(\n        string memory name,\n        IVotes token,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold\n    ) internal returns (address instance) {\n        instance = Clones.clone(daoImplementation);\n        IAgentDAO(instance).initialize(\n            name,\n            token,\n            nft,\n            daoThreshold,\n            daoVotingPeriod\n        );\n\n        allDAOs.push(instance);\n        return instance;\n    }\n\n    function _createNewAgentToken(\n        string memory name,\n        string memory symbol,\n        bytes memory tokenSupplyParams_\n    ) internal returns (address instance) {\n        instance = Clones.clone(tokenImplementation);\n        IAgentToken(instance).initialize(\n            [_tokenAdmin, _uniswapRouter, assetToken],\n            abi.encode(name, symbol),\n            tokenSupplyParams_,\n            _tokenTaxParams\n        );\n\n        allTradingTokens.push(instance);\n        return instance;\n    }\n\n    function _createNewAgentVeToken(\n        string memory name,\n        string memory symbol,\n        address stakingAsset,\n        address founder,\n        bool canStake\n    ) internal returns (address instance) {\n        instance = Clones.clone(veTokenImplementation);\n        IAgentVeToken(instance).initialize(\n            name,\n            symbol,\n            founder,\n            stakingAsset,\n            block.timestamp + maturityDuration,\n            address(nft),\n            canStake\n        );\n\n        allTokens.push(instance);\n        return instance;\n    }\n\n    function totalAgents() public view returns (uint256) {\n        return allTokens.length;\n    }\n\n    function setApplicationThreshold(\n        uint256 newThreshold\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        applicationThreshold = newThreshold;\n        emit ApplicationThresholdUpdated(newThreshold);\n    }\n\n    function setVault(address newVault) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _vault = newVault;\n    }\n\n    function setImplementations(\n        address token,\n        address veToken,\n        address dao\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        tokenImplementation = token;\n        daoImplementation = dao;\n        veTokenImplementation = veToken;\n    }\n\n    function setMaturityDuration(\n        uint256 newDuration\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        maturityDuration = newDuration;\n    }\n\n    function setUniswapRouter(\n        address router\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _uniswapRouter = router;\n    }\n\n    function setTokenAdmin(\n        address newTokenAdmin\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenAdmin = newTokenAdmin;\n    }\n\n    function setTokenSupplyParams(\n        uint256 maxSupply,\n        uint256 lpSupply,\n        uint256 vaultSupply,\n        uint256 maxTokensPerWallet,\n        uint256 maxTokensPerTxn,\n        uint256 botProtectionDurationInSeconds,\n        address vault\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenSupplyParams = abi.encode(\n            maxSupply,\n            lpSupply,\n            vaultSupply,\n            maxTokensPerWallet,\n            maxTokensPerTxn,\n            botProtectionDurationInSeconds,\n            vault\n        );\n    }\n\n    function setTokenTaxParams(\n        uint256 projectBuyTaxBasisPoints,\n        uint256 projectSellTaxBasisPoints,\n        uint256 taxSwapThresholdBasisPoints,\n        address projectTaxRecipient\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenTaxParams = abi.encode(\n            projectBuyTaxBasisPoints,\n            projectSellTaxBasisPoints,\n            taxSwapThresholdBasisPoints,\n            projectTaxRecipient\n        );\n    }\n\n    function setAssetToken(\n        address newToken\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        assetToken = newToken;\n    }\n\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (address sender)\n    {\n        sender = ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ContextUpgradeable._msgData();\n    }\n\n    function setDefaultDelegatee(\n        address newDelegatee\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        defaultDelegatee = newDelegatee;\n    }\n\n    // Bootstrap Agent with existing ERC20 tokens\n    function initFromToken(\n        address tokenAddr,\n        uint8[] memory cores,\n        bytes32 tbaSalt,\n        address tbaImplementation,\n        uint32 daoVotingPeriod,\n        uint256 daoThreshold,\n        uint256 initialLP\n    ) public whenNotPaused returns (uint256) {\n        address sender = _msgSender();\n        require(_tokenApplication[tokenAddr] == 0, \"Token already exists\");\n\n        require(isCompatibleToken(tokenAddr), \"Unsupported token\");\n\n        require(\n            IERC20(assetToken).balanceOf(sender) >= applicationThreshold,\n            \"Insufficient asset token\"\n        );\n\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >=\n                applicationThreshold,\n            \"Insufficient asset token allowance\"\n        );\n\n        require(cores.length > 0, \"Cores must be provided\");\n\n        require(initialLP > 0, \"InitialLP must be greater than 0\");\n\n        IERC20(tokenAddr).safeTransferFrom(sender, address(this), initialLP);\n\n        IERC20(assetToken).safeTransferFrom(\n            sender,\n            address(this),\n            applicationThreshold\n        );\n\n        uint256 id = _nextId++;\n        _tokenApplication[tokenAddr] = id;\n        _applicationToken[id] = tokenAddr;\n\n        Application memory application = Application(\n            IAgentToken(tokenAddr).name(),\n            IAgentToken(tokenAddr).symbol(),\n            \"\",\n            ApplicationStatus.Active,\n            applicationThreshold,\n            sender,\n            cores,\n            block.number,\n            0,\n            tbaSalt,\n            tbaImplementation,\n            daoVotingPeriod,\n            daoThreshold\n        );\n        _applications[id] = application;\n        emit NewApplication(id);\n\n        return id;\n    }\n\n    function executeTokenApplication(\n        uint256 id,\n        bool canStake\n    ) public noReentrant {\n        // This will bootstrap an Agent with following components:\n        // C2: LP Pool + Initial liquidity\n        // C3: Agent veToken\n        // C4: Agent DAO\n        // C5: Agent NFT\n        // C6: TBA\n        // C7: Stake liquidity token to get veToken\n\n        Application storage application = _applications[id];\n\n        require(\n            msg.sender == application.proposer ||\n                hasRole(WITHDRAW_ROLE, msg.sender),\n            \"Not proposer\"\n        );\n\n        require(\n            _applicationToken[id] != address(0),\n            \"Not custom token application\"\n        );\n\n        _executeApplication(id, canStake, _tokenSupplyParams);\n    }\n\n    function isCompatibleToken(address tokenAddr) public view returns (bool) {\n        try IAgentToken(tokenAddr).name() returns (string memory) {\n            try IAgentToken(tokenAddr).symbol() returns (string memory) {\n                try IAgentToken(tokenAddr).totalSupply() returns (uint256) {\n                    try\n                        IAgentToken(tokenAddr).balanceOf(address(this))\n                    returns (uint256) {\n                        return true;\n                    } catch {\n                        return false;\n                    }\n                } catch {\n                    return false;\n                }\n            } catch {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n    }\n\n    function _createPair(\n        address tokenAddr\n    ) internal returns (address uniswapV2Pair_) {\n        \n        IUniswapV2Factory factory = IUniswapV2Factory(\n            IUniswapV2Router02(_uniswapRouter).factory()\n        );\n\n        require(\n            factory.getPair(tokenAddr, assetToken) == address(0),\n            \"pool already exists\"\n        );\n\n        uniswapV2Pair_ = factory.createPair(tokenAddr, assetToken);\n\n        return (uniswapV2Pair_);\n    }\n}\n"
    }
}