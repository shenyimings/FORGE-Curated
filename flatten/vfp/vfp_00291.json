{
    "vfp_id": "vfp_00291",
    "project_name": "UMA Oracle Bridging Contracts Upgrade Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Oracle Upgrades Can Make Prices Inaccessible",
            "description": "The vulnerability arises because new request IDs in the Oracle system are calculated using the `requester` address, and functions like `hasPrice` and `getPrice` rely on `msg.sender` as the `requester` to retrieve price data. If the `OptimisticOracleV2` contract is upgraded to a new implementation, the new instance will not recognize or be able to access prices submitted through the previous version, as the requester-based request ID derivation would not persist across contract instances. This could result in previously submitted prices becoming inaccessible after an upgrade. The root cause is the dependency on `msg.sender` for request ID generation, which ties price resolution to the specific contract instance. While the team acknowledged the issue, they resolved it by removing the `requester` from the child request ID derivation, simplifying future upgrades and ensuring backward compatibility in request resolution.\n",
            "severity": "Low",
            "location": [
                "OracleSpoke.sol::_encodePriceRequest",
                "OracleChildTunnel.sol::_encodePriceRequest"
            ],
            "files": [
                "protocol/packages/core/contracts/cross-chain-oracle/OracleSpoke.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Repeated Event Emissions",
            "description": "The `resolveLegacyRequest` function in the `OracleSpoke` contract allows setting a price for any `childRequester` once a legacy request has been resolved, which can result in the `ResolvedLegacyRequest` event being emitted multiple times for the same request. The cause is the lack of restrictions on who can call this function and how often, combined with the fact that the previous `OracleSpoke` did not include the requester in stamped ancillary data. An attacker or misbehaving actor could emit redundant events, potentially confusing off-chain indexing services that rely on these events for state tracking. While the team acknowledged this behavior, they determined it does not impact core functionality since off-chain components can filter events using recalculated `priceRequestId` hashes. The impact is limited to potential inefficiencies in event processing.\n",
            "severity": "Informational",
            "location": [
                "OracleSpoke.sol::resolveLegacyRequest#157"
            ],
            "files": [
                "protocol/packages/core/contracts/cross-chain-oracle/OracleSpoke.sol"
            ]
        }
    ],
    "affected_files": {
        "OracleSpoke.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\nimport \"../data-verification-mechanism/interfaces/OracleInterface.sol\";\nimport \"../data-verification-mechanism/interfaces/RegistryInterface.sol\";\nimport \"./AncillaryDataCompression.sol\";\nimport \"./OracleBase.sol\";\nimport \"../common/implementation/AncillaryData.sol\";\nimport \"../common/implementation/Lockable.sol\";\nimport \"./interfaces/ChildMessengerInterface.sol\";\nimport \"./interfaces/ChildMessengerConsumerInterface.sol\";\nimport \"./SpokeBase.sol\";\n\n/**\n * @title Cross-chain Oracle L2 Oracle Spoke.\n * @notice This contract is primarily intended to receive messages on the child chain from a parent chain and allow\n * contracts deployed on the child chain to interact with this contract as an Oracle. Moreover, this contract gives\n * child chain contracts the ability to trigger cross-chain price requests to the mainnet DVM. This Spoke knows how\n * to communicate with the parent chain via a \"ChildMessenger\" contract which directly communicates with the\n * \"ParentMessenger\" on mainnet.\n * @dev The intended client of this contract is an OptimisticOracle on sidechain that needs price\n * resolution secured by the DVM on mainnet.\n */\ncontract OracleSpoke is\n    OracleBase,\n    SpokeBase,\n    OracleAncillaryInterface,\n    OracleInterface,\n    ChildMessengerConsumerInterface,\n    Lockable\n{\n    using AncillaryDataCompression for bytes;\n\n    // Mapping of parent request ID to child request ID.\n    mapping(bytes32 => bytes32) public childRequestIds;\n\n    event PriceRequestBridged(\n        address indexed requester,\n        bytes32 identifier,\n        uint256 time,\n        bytes ancillaryData,\n        bytes32 indexed childRequestId,\n        bytes32 indexed parentRequestId\n    );\n    event ResolvedLegacyRequest(\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        int256 price,\n        bytes32 indexed requestHash,\n        bytes32 indexed legacyRequestHash\n    );\n\n    constructor(address _finderAddress) HasFinder(_finderAddress) {}\n\n    // This assumes that the local network has a Registry that resembles the mainnet registry.\n    modifier onlyRegisteredContract() {\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\n        require(registry.isContractRegistered(msg.sender), \"Caller must be registered\");\n        _;\n    }\n\n    /**\n     * @notice This is called to bridge a price request to mainnet. This method will enqueue a new price request\n     * or return silently if already requested. Price requests are relayed to mainnet (the \"Parent\" chain) via the\n     * ChildMessenger contract.\n     * @dev Can be called only by a registered contract that is allowed to make DVM price requests. Will mark this\n     * price request as Requested, and therefore able to receive the price resolution data from mainnet.\n     * @dev Contract registration enables the DVM to validate that the calling contract correctly pays final fees.\n     * Therefore, this function does not directly attempt to pull a final fee from the caller.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request.\n     * @param ancillaryData extra data of price request.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override nonReentrant() onlyRegisteredContract() {\n        _requestPriceSpoke(identifier, time, ancillaryData);\n    }\n\n    /**\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\n     * ancillary data.\n     */\n    function requestPrice(bytes32 identifier, uint256 time) public override nonReentrant() onlyRegisteredContract() {\n        _requestPriceSpoke(identifier, time, \"\");\n    }\n\n    function _requestPriceSpoke(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) internal {\n        address requester = msg.sender;\n        bytes32 childRequestId = _encodeChildPriceRequest(requester, identifier, time, ancillaryData);\n        Price storage lookup = prices[childRequestId];\n\n        // Send the request to mainnet only if it has not been requested yet.\n        if (lookup.state != RequestState.NeverRequested) return;\n        lookup.state = RequestState.Requested;\n\n        // Only the compressed ancillary data is sent to the mainnet. As it includes the request block number that is\n        // not available when getting the resolved price, we map the derived request ID.\n        bytes memory parentAncillaryData = ancillaryData.compress(requester, block.number);\n        bytes32 parentRequestId = _encodePriceRequest(identifier, time, parentAncillaryData);\n        childRequestIds[parentRequestId] = childRequestId;\n\n        // Emit all required information so that voters on mainnet can track the origin of the request and full\n        // ancillary data by using the parentRequestId that is derived from identifier, time and ancillary data as\n        // observed on mainnet.\n        emit PriceRequestBridged(requester, identifier, time, ancillaryData, childRequestId, parentRequestId);\n        emit PriceRequestAdded(identifier, time, parentAncillaryData, parentRequestId);\n\n        getChildMessenger().sendMessageToParent(abi.encode(identifier, time, parentAncillaryData));\n    }\n\n    /**\n     * @notice Resolves a price request originating from a message sent by the DVM on the parent chain.\n     * @dev Can only be called by the ChildMessenger contract which is designed to communicate only with the\n     * ParentMessenger contract on Mainnet. See the SpokeBase for the onlyMessenger modifier.\n     * @param data ABI encoded params with which to call `_publishPrice`.\n     */\n    function processMessageFromParent(bytes memory data) public override nonReentrant() onlyMessenger() {\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData, int256 price) =\n            abi.decode(data, (bytes32, uint256, bytes, int256));\n        bytes32 parentRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n\n        // Resolve the requestId used when requesting and checking the price. The childRequestIds value in the mapping\n        // could be uninitialized if the request was originated from:\n        // - the previous implementation of this contract, or\n        // - another chain and was pushed to this chain by mistake.\n        bytes32 priceRequestId = childRequestIds[parentRequestId];\n        if (priceRequestId == bytes32(0)) priceRequestId = parentRequestId;\n        Price storage lookup = prices[priceRequestId];\n\n        // In order to support resolving the requests initiated from the previous implementation of this contract, we\n        // only update the state and emit an event if it has not yet been resolved.\n        if (lookup.state == RequestState.Resolved) return;\n        lookup.price = price;\n        lookup.state = RequestState.Resolved;\n        emit PushedPrice(identifier, time, ancillaryData, price, priceRequestId);\n    }\n\n    /**\n     * @notice This method handles a special case when a price request was originated on the previous implementation of\n     * this contract, but was not settled before the upgrade.\n     * @dev Duplicates the resolved state from the legacy request to the new request where requester address is also\n     * part of request ID derivation. Will revert if the legacy request has not been pushed from mainnet.\n     * @param identifier Identifier of price request to resolve.\n     * @param time Timestamp of price request to resolve.\n     * @param ancillaryData Original ancillary data passed by the requester before stamping by the legacy spoke.\n     * @param childRequester Address of the requester that initiated the price request.\n     */\n    function resolveLegacyRequest(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        address childRequester\n    ) external {\n        bytes32 legacyRequestId = _encodePriceRequest(identifier, time, _legacyStampAncillaryData(ancillaryData));\n        Price storage legacyLookup = prices[legacyRequestId];\n        require(legacyLookup.state == RequestState.Resolved, \"Price has not been resolved\");\n\n        bytes32 priceRequestId = _encodeChildPriceRequest(childRequester, identifier, time, ancillaryData);\n        Price storage lookup = prices[priceRequestId];\n\n        // Update the state and emit an event only if the legacy request has not been resolved yet.\n        if (lookup.state == RequestState.Resolved) return;\n        lookup.price = legacyLookup.price;\n        lookup.state = RequestState.Resolved;\n        emit ResolvedLegacyRequest(identifier, time, ancillaryData, lookup.price, priceRequestId, legacyRequestId);\n    }\n\n    /**\n     * @notice Returns whether a price has resolved for the request. This method will not revert.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request\n     * @param ancillaryData extra data of price request.\n     * @return True if a price is available, False otherwise. If true, then getPrice will succeed for the request.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (bool) {\n        bytes32 priceRequestId = _encodeChildPriceRequest(msg.sender, identifier, time, ancillaryData);\n        return prices[priceRequestId].state == RequestState.Resolved;\n    }\n\n    /**\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\n     * ancillary data.\n     */\n    function hasPrice(bytes32 identifier, uint256 time)\n        public\n        view\n        override\n        nonReentrantView()\n        onlyRegisteredContract()\n        returns (bool)\n    {\n        bytes32 priceRequestId = _encodeChildPriceRequest(msg.sender, identifier, time, \"\");\n        return prices[priceRequestId].state == RequestState.Resolved;\n    }\n\n    /**\n     * @notice Returns resolved price for the request. Reverts if price is not available.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request\n     * @param ancillaryData extra data of price request.\n     * @return int256 Price, or reverts if no resolved price for any reason.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (int256) {\n        bytes32 priceRequestId = _encodeChildPriceRequest(msg.sender, identifier, time, ancillaryData);\n        Price storage lookup = prices[priceRequestId];\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\n        return lookup.price;\n    }\n\n    /**\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\n     * ancillary data.\n     */\n    function getPrice(bytes32 identifier, uint256 time)\n        public\n        view\n        override\n        nonReentrantView()\n        onlyRegisteredContract()\n        returns (int256)\n    {\n        bytes32 priceRequestId = _encodeChildPriceRequest(msg.sender, identifier, time, \"\");\n        Price storage lookup = prices[priceRequestId];\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\n        return lookup.price;\n    }\n\n    /**\n     * @notice Compresses ancillary data by providing sufficient information to track back the original ancillary data\n     * mainnet.\n     * @dev This is expected to be used in offchain infrastructure when speeding up requests to the mainnet.\n     * @param ancillaryData original ancillary data to be processed.\n     * @param requester address of the requester who initiated the price request.\n     * @param requestBlockNumber block number when the price request was initiated.\n     * @return compressed ancillary data if it exceeds the threshold, otherwise metadata is appended at the end.\n     */\n    function compressAncillaryData(\n        bytes memory ancillaryData,\n        address requester,\n        uint256 requestBlockNumber\n    ) external view returns (bytes memory) {\n        return ancillaryData.compress(requester, requestBlockNumber);\n    }\n\n    /**\n     * @dev This replicates the implementation of `_stampAncillaryData` from the previous version of this contract for\n     * the purpose of resolving legacy requests if they had not been resolved before the upgrade.\n     */\n    function _legacyStampAncillaryData(bytes memory ancillaryData) internal view returns (bytes memory) {\n        // This contract should stamp the child network's ID so that voters on the parent network can\n        // deterministically track unique price requests back to this contract.\n        return AncillaryData.appendKeyValueUint(ancillaryData, \"childChainId\", block.chainid);\n    }\n\n    /**\n     * @notice Returns the convenient way to store price requests, uniquely identified by {requester, identifier, time,\n     * ancillaryData }.\n     * @dev Compared to _encodePriceRequest, this method ensures requests are unique also among different requesters.\n     */\n    function _encodeChildPriceRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(requester, identifier, time, ancillaryData));\n    }\n}\n"
    }
}