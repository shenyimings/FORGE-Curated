{
    "vfp_id": "vfp_00429",
    "project_name": "Forte - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "LP fees should be allocated to active liquidity",
            "description": "LP fees are intended to be allocated only to active liquidity, as documented and mostly implemented correctly. However, in the swap function of PoolBase.sol, LP fees are incorrectly applied to the total liquidity (including inactive liquidity) when updating _collectedLPFees. This occurs because the division is performed using _w (total liquidity) instead of (_w - _wInactive()), which represents active liquidity. An attacker could exploit this by manipulating the distribution of fees to include inactive positions, potentially distorting fee accrual and leading to incorrect revenue calculations for active LPs. The impact is a deviation from the intended economic model, which could undermine trust in the system's fairness and lead to disputes over fee distribution.\n",
            "severity": "High",
            "location": [
                "PoolBase.sol#L144"
            ],
            "files": [
                "03117b74639e71145e0640ddf33644177f390087/liquidity-base/src/amm/base/PoolBase.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "The collectedLPFees function is incorrect",
            "description": "The collectedLPFees function returns the product of _collectedLPFees and total liquidity _w, but LP fees are only meant to be distributed to active liquidity (_w - _wInactive()). By using total liquidity instead of active liquidity, the function overstates the amount of collectable LP fees. This misrepresentation could lead to incorrect accounting, misleading UIs, or flawed off-chain analytics. The root cause is the failure to exclude inactive liquidity from the calculation. While the impact is limited to incorrect reporting rather than direct fund loss, it undermines the accuracy of financial metrics and could erode trust in the system's transparency.\n",
            "severity": "Low",
            "location": [
                "PoolBase.sol#L306"
            ],
            "files": [
                "03117b74639e71145e0640ddf33644177f390087/liquidity-base/src/amm/base/PoolBase.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Missing deadline check could lead to bad trades",
            "description": "The swap function lacks a deadline parameter, allowing transactions to be executed indefinitely in the future. Without a time constraint, users are exposed to MEV (Miner Extractable Value) attacks, such as sandwich attacks, where bots exploit stale price data to extract value. For example, a user may initiate a swap expecting a certain output, but if the transaction is delayed, price movements could result in unfavorable execution. The absence of a deadline increases the window for exploitation and reduces user control over transaction timeliness. The impact includes potential financial loss due to slippage and reduced user confidence in the platform's safety.\n",
            "severity": "Low",
            "location": [
                "PoolBase.sol#L126"
            ],
            "files": [
                "03117b74639e71145e0640ddf33644177f390087/liquidity-base/src/amm/base/PoolBase.sol"
            ]
        }
    ],
    "affected_files": {
        "PoolBase.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\nimport {Ownable2Step, Ownable} from \"../../../lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport {Pausable} from \"../../../lib/openzeppelin-contracts/contracts/utils/Pausable.sol\";\nimport {IERC20Metadata} from \"../../../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IPool} from \"./IPool.sol\";\nimport \"../../common/IErrors.sol\";\nimport {CalculatorBase, packedFloat} from \"./CalculatorBase.sol\";\nimport {CumulativePrice} from \"./CumulativePrice.sol\";\nimport {FeeInfo, TBCType} from \"../../common/TBC.sol\";\nimport {MathLibs, Float} from \"../mathLibs/MathLibs.sol\";\nimport {LPToken} from \"../../../src/common/LPToken.sol\";\nimport {Descriptor} from \"../../common/NFTSVG.sol\";\n\n/**\n * @title Pool Base\n * @dev This contract implements the core of the Pool interface and is meant to be an abstract base for all the pools.\n * Any pool implementation must inherits this contract and implement all the functions from CalculatorBase.\n * @author  @oscarsernarosero @mpetersoCode55 @cirsteve\n */\nabstract contract PoolBase is IPool, CalculatorBase, Ownable2Step, Pausable, CumulativePrice, LPToken {\n    using SafeERC20 for IERC20;\n    using MathLibs for int256;\n    using MathLibs for packedFloat;\n\n    address public immutable xToken;\n    address public immutable yToken;\n    int256 constant POOL_NATIVE_DECIMALS_NEGATIVE = 0 - int(POOL_NATIVE_DECIMALS);\n\n    /**\n     * @dev difference in decimal precision between y token and x token\n     */\n\n    uint256 public immutable yDecimalDiff;\n\n    /**\n     * @dev the lower bound of x\n     */\n    // slither-disable-next-line constable-states // updated in child contract\n    packedFloat public xMin;\n\n    /**\n     * @dev balance of x token that has been swapped out of the Pool\n     */\n    packedFloat public x;\n\n    /**\n     * @dev lifetime revenue accrued by the pool\n     */\n    // slither-disable-next-line constable-states // updated in child contract\n    packedFloat public h;\n\n    /**\n     * @dev lifetime revenue claimed from the pool\n     */\n    // slither-disable-next-line constable-states // updated in child contract\n    uint256 public r;\n\n    /**\n     * @dev fee percentage for swaps for the LP\n     */\n    uint16 public lpFee;\n\n    /**\n     * @dev fee percentage for swaps for the protocol\n     */\n    uint16 public protocolFee;\n\n    /**\n     * @dev protocol-fee collector address\n     */\n    address public protocolFeeCollector;\n\n    /**\n     * @dev proposed protocol-fee collector address\n     */\n    address public proposedProtocolFeeCollector;\n\n    /**\n     * @dev currently claimable fee balance\n     */\n    packedFloat _collectedLPFees;\n\n    /**\n     * @dev currently claimable protocol fee balance\n     */\n    uint256 public collectedProtocolFees;\n\n    /**\n     * @dev inactive liquidity share\n     */\n    packedFloat _wInactive;\n\n    /**\n     * @dev total liquidity share\n     */\n    packedFloat _w;\n\n    modifier onlyProtocolFeeCollector() {\n        if (_msgSender() != protocolFeeCollector) revert NotProtocolFeeCollector();\n        _;\n    }\n\n    modifier onlyProposedProtocolFeeCollector() {\n        if (_msgSender() != proposedProtocolFeeCollector) revert NotProposedProtocolFeeCollector();\n        _;\n    }\n\n    /**\n     * @dev constructor\n     * @param _xToken address of the X token (x axis)\n     * @param _yToken address of the Y token (y axis)\n     * @param fees fee information\n     */\n    constructor(\n        address _xToken,\n        address _yToken,\n        FeeInfo memory fees,\n        string memory _name,\n        string memory _symbol\n    ) Ownable(_msgSender()) LPToken(_name, _symbol) {\n        _validateInput(_xToken, _yToken, fees._protocolFeeCollector);\n        // slither-disable-start missing-zero-check // This is done in the _validateInput function\n        xToken = _xToken;\n        yToken = _yToken;\n        protocolFeeCollector = _msgSender(); // temporary measure to avoid role failure\n        setLPFee(fees._lpFee);\n        setProtocolFee(fees._protocolFee);\n        protocolFeeCollector = fees._protocolFeeCollector;\n        // slither-disable-end missing-zero-check\n        yDecimalDiff = POOL_NATIVE_DECIMALS - IERC20Metadata(_yToken).decimals();\n\n        /// implementation contract must transfer ownership and emit a PoolDeployed event\n    }\n\n    /**\n     * @dev This is the main function of the pool to swap.\n     * @param _tokenIn the address of the token being given to the pool in exchange for another token\n     * @param _amountIn the amount of the ERC20 _tokenIn to exchange into the Pool\n     * @param _minOut the amount of the other token in the pair minimum to be received for the\n     * _amountIn of _tokenIn.\n     * @return amountOut the actual amount of the token coming out of the Pool as result of the swap\n     * @return lpFeeAmount the amount of the Y token that's being dedicated to fees for the LP\n     * @return protocolFeeAmount the amount of the Y token that's being dedicated to fees for the protocol\n     */\n    function swap(\n        address _tokenIn,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) external whenNotPaused returns (uint256 amountOut, uint256 lpFeeAmount, uint256 protocolFeeAmount) {\n        _updateCumulativePrice(spotPrice(), block.timestamp);\n        emit CumulativePriceUpdated(lastBlockTimestamp, cumulativePrice);\n\n        bool sellingX = _tokenIn == xToken;\n        //slither-disable-start reentrancy-benign // the recipient of the transfer is this contract\n        uint256 beforeBalance = IERC20(sellingX ? xToken : yToken).balanceOf(address(this));\n        IERC20(sellingX ? xToken : yToken).safeTransferFrom(_msgSender(), address(this), _amountIn);\n        uint256 afterBalance = IERC20(sellingX ? xToken : yToken).balanceOf(address(this));\n        _amountIn = afterBalance - beforeBalance;\n\n        if (_minOut == 0) revert ZeroValueNotAllowed();\n        (amountOut, lpFeeAmount, protocolFeeAmount) = simSwap(_tokenIn, _amountIn);\n        _checkSlippage(amountOut, _minOut);\n        packedFloat xOld = x;\n\n        x = sellingX ? x.sub(int(_amountIn).toPackedFloat(-18)) : x.add(int(amountOut).toPackedFloat(-18));\n        // slither-disable-end reentrancy-benign\n        // slither-disable-start reentrancy-events // the recipient of the initial transfer is this contract\n        _updateParameters(xOld);\n\n        _collectedLPFees = _collectedLPFees.add(int(lpFeeAmount).toPackedFloat(int(yDecimalDiff) - int(POOL_NATIVE_DECIMALS)).div(_w));\n        emit LPFeeGenerated(lpFeeAmount);\n        collectedProtocolFees += protocolFeeAmount;\n        emit ProtocolFeeGenerated(protocolFeeAmount);\n\n        emit Swap(_tokenIn, _amountIn, amountOut, _minOut);\n        // slither-disable-end reentrancy-events\n        IERC20(sellingX ? yToken : xToken).safeTransfer(_msgSender(), amountOut);\n    }\n\n    /**\n     * @dev This is a simulation of the swap function. Useful to get marginal prices\n     * @param _tokenIn the address of the token being sold\n     * @param _amountIn the amount of the ERC20 _tokenIn to sell to the Pool\n     * @return amountOut the amount of the token coming out of the Pool as result of the swap (main returned value)\n     * @return lpFeeAmount the amount of the Y token that's being dedicated to fees for the LP\n     * @return protocolFeeAmount the amount of the Y token that's being dedicated to fees for the protocol\n     */\n    function simSwap(\n        address _tokenIn,\n        uint256 _amountIn\n    ) public view returns (uint256 amountOut, uint256 lpFeeAmount, uint256 protocolFeeAmount) {\n        bool sellingX = _tokenIn == xToken;\n        if (!sellingX && _tokenIn != yToken) revert InvalidToken();\n\n        uint minAmountIn = 1;\n        if (lpFee > 0 && !sellingX) ++minAmountIn;\n        if (protocolFee > 0 && !sellingX) ++minAmountIn;\n        if (_amountIn < minAmountIn) revert ZeroValueNotAllowed();\n\n        if (!sellingX) {\n            lpFeeAmount = _determineFeeAmountSell(_amountIn, lpFee);\n            protocolFeeAmount = _determineFeeAmountSell(_amountIn, protocolFee);\n            _amountIn -= (lpFeeAmount + protocolFeeAmount); // fees are always coming out from the pool\n            _amountIn = _normalizeTokenDecimals(true, _amountIn);\n        }\n        packedFloat rawAmountOut = sellingX\n            ? _calculateAmountOfYReceivedSellingX(int(_amountIn).toPackedFloat(-18))\n            : _calculateAmountOfXReceivedSellingY(int(_amountIn).toPackedFloat(-18));\n        amountOut = uint(rawAmountOut.convertpackedFloatToWAD());\n        if (sellingX) {\n            amountOut = _normalizeTokenDecimals(false, amountOut);\n            // slither-disable-start incorrect-equality\n            if (amountOut == 0) return (0, 0, 0);\n            // slither-disable-end incorrect-equality\n            lpFeeAmount = _determineFeeAmountSell(amountOut, lpFee);\n            protocolFeeAmount = _determineFeeAmountSell(amountOut, protocolFee);\n            amountOut -= (lpFeeAmount + protocolFeeAmount);\n        }\n    }\n\n    /**\n     * @dev This is a simulation of the swap function from the perspective of purchasing a specific amount. Useful to get marginal price.\n     * @param _tokenout the address of the token being bought\n     * @param _amountOut the amount of the ERC20 _tokenOut to buy from the Pool\n     * @return amountIn the amount necessary of the token coming into the Pool for the desired amountOut of the swap (main returned value)\n     * @return lpFeeAmount the amount of the Y token that's being dedicated to fees for the LP\n     * @return protocolFeeAmount the amount of the Y token that's being dedicated to fees for the protocol\n     * @notice lpFeeAmount and protocolFeeAmount are already factored in the amountIn. This is useful only to know how much of the amountIn\n     * will go towards fees.\n     */\n    function simSwapReversed(\n        address _tokenout,\n        uint256 _amountOut\n    ) public view returns (uint256 amountIn, uint256 lpFeeAmount, uint256 protocolFeeAmount) {\n        bool buyingX = _tokenout == xToken;\n        if (!buyingX && _tokenout != yToken) revert InvalidToken();\n\n        if (buyingX) {\n            packedFloat amountInRaw = _calculateAmountOfYRequiredBuyingX(int(_amountOut).toPackedFloat(-18));\n            uint256 uamountInRaw = uint(amountInRaw.convertpackedFloatToWAD());\n            uamountInRaw = _normalizeTokenDecimals(false, uamountInRaw); // reversed logic because swap is reversed\n            (protocolFeeAmount, lpFeeAmount) = _determineProtocolAndLPFeesBuy(uamountInRaw);\n            amountIn = uamountInRaw + lpFeeAmount + protocolFeeAmount;\n        } else {\n            (protocolFeeAmount, lpFeeAmount) = _determineProtocolAndLPFeesBuy(_amountOut);\n            _amountOut = _normalizeTokenDecimals(true, _amountOut + protocolFeeAmount + lpFeeAmount); // reversed logic because swap is reversed\n            packedFloat amountInRaw = _calculateAmountOfXRequiredBuyingY(int(_amountOut).toPackedFloat(-18));\n            amountIn = uint(amountInRaw.convertpackedFloatToWAD());\n        }\n    }\n\n    /**\n     * @dev This is the function to activate/deactivate trading.\n     * @param _enable pass True to enable or False to disable\n     */\n    function enableSwaps(bool _enable) external virtual onlyOwner {\n        if (_enable) _unpause();\n        else _pause();\n    }\n\n    /**\n     * @dev This is the function to update the LP fees per trading.\n     * @param _fee percentage of the transaction that will get collected as fees (in percentage basis points:\n     * 1500 -> 15.00%; 500 -> 5.00%; 1 -> 0.01%)\n     */\n    function setLPFee(uint16 _fee) public onlyOwner {\n        if (_fee > MAX_LP_FEE) revert LPFeeAboveMax(_fee, MAX_LP_FEE);\n        lpFee = _fee;\n        emit LPFeeSet(_fee);\n    }\n\n    /**\n     * @dev This is the function to update the protocol fees per trading.\n     * @param _protocolFee percentage of the transaction that will get collected as fees (in percentage basis points:\n     * 10000 -> 100.00%; 500 -> 5.00%; 1 -> 0.01%)\n     */\n    function setProtocolFee(uint16 _protocolFee) public onlyProtocolFeeCollector {\n        if (_protocolFee > MAX_PROTOCOL_FEE) revert ProtocolFeeAboveMax({proposedFee: _protocolFee, maxFee: MAX_PROTOCOL_FEE});\n        protocolFee = _protocolFee;\n        emit ProtocolFeeSet(_protocolFee);\n    }\n\n    /**\n     * @dev This is the function to add XToken liquidity to the pool.\n     * @param _amount the amount of X token to transfer from the sender to the pool\n     */\n    function addXSupply(uint256 _amount) external virtual onlyOwner {\n        emit LiquidityXTokenAdded(xToken, _amount);\n        // slither-disable-start reentrancy-benign // the transfer doesn't update any state variable directly and the pool is the recipient\n        uint256 beforeBalance = IERC20(xToken).balanceOf(address(this));\n        IERC20(xToken).safeTransferFrom(_msgSender(), address(this), _amount);\n        uint256 afterBalance = IERC20(xToken).balanceOf(address(this));\n        // slither-disable-end reentrancy-benign\n        _amount = afterBalance - beforeBalance;\n        _validateLiquidityAdd(int(afterBalance).toPackedFloat(-18));\n        _mintTokenAndUpdate(_msgSender(), (int(_amount).toPackedFloat(POOL_NATIVE_DECIMALS_NEGATIVE)), packedFloat.wrap(0), false, _amount, 0);\n    }\n\n    /**\n     * @dev This function collects the protocol fees from the Pool.\n     */\n    function collectProtocolFees() external onlyProtocolFeeCollector {\n        uint256 collectedAmount = collectedProtocolFees;\n        delete collectedProtocolFees;\n        emit ProtocolFeesCollected(_msgSender(), collectedAmount);\n        IERC20(yToken).safeTransfer(_msgSender(), collectedAmount);\n    }\n\n    /**\n     * @dev function to propose a new protocol fee collector\n     * @param _protocolFeeCollector the new fee collector\n     * @notice that only the current fee collector address can call this function\n     */\n    function proposeProtocolFeeCollector(address _protocolFeeCollector) external onlyProtocolFeeCollector {\n        // slither-disable-start missing-zero-check // unnecessary\n        proposedProtocolFeeCollector = _protocolFeeCollector;\n        // slither-disable-end missing-zero-check\n        emit ProtocolFeeCollectorProposed(_protocolFeeCollector);\n    }\n\n    /**\n     * @dev function to confirm a new protocol fee collector\n     * @notice that only the already proposed fee collector can call this function\n     */\n    function confirmProtocolFeeCollector() external onlyProposedProtocolFeeCollector {\n        delete proposedProtocolFeeCollector;\n        protocolFeeCollector = _msgSender();\n        emit ProtocolFeeCollectorConfirmed(_msgSender());\n    }\n\n    /**\n     * @dev This function gets the liquidity in the pool for xToken in WAD.\n     * @return the liquidity in the pool for xToken in WAD\n     */\n    function xTokenLiquidity() external view returns (uint256) {\n        return IERC20(xToken).balanceOf(address(this));\n    }\n\n    /**\n     * @dev This function gets the liquidity in the pool for yToken in WAD\n     * @return the liquidity in the pool for yToken in WAD\n     */\n    function yTokenLiquidity() external view returns (uint256) {\n        uint revenue = _totalRevenue();\n        revenue = _normalizeTokenDecimals(false, revenue);\n        return (IERC20(yToken).balanceOf(address(this)) + r) - (collectedProtocolFees + revenue);\n    }\n\n    /**\n     * @dev This function returns the total revenue in the pool for yToken in WAD\n     * @return the revenue in the pool for yToken in WAD\n     */\n    function totalRevenue() public view returns (uint256) {\n        return _totalRevenue();\n    }\n\n    /**\n     * @dev This is the function to retrieve the current spot price of the x token.\n     * @return sPrice the price in YToken Decimals\n     */\n    function spotPrice() public view returns (uint256 sPrice) {\n        packedFloat sPriceRaw = _spotPrice();\n        sPrice = uint(sPriceRaw.convertpackedFloatToWAD());\n\n        if (yDecimalDiff != 0) {\n            sPrice = _normalizeTokenDecimals(false, sPrice);\n        }\n    }\n\n    /**\n     * @dev tells current LP fees accumulated in the pool\n     * @return currently claimable LP fee balance\n     */\n    function collectedLPFees() external view returns (uint256) {\n        return _normalizeTokenDecimals(false, uint((_collectedLPFees.mul(_w)).convertpackedFloatToWAD()));\n    }\n\n    /**\n     * @dev tells current LP fees accumulated in the pool\n     * @return currently claimable LP fee balance\n     */\n    function collectedLPFeesPerLiquidityUnit() external view returns (uint256) {\n        return _normalizeTokenDecimals(false, uint(_collectedLPFees.convertpackedFloatToWAD()));\n    }\n\n    /**\n     * @dev A helper function to validate most of constructor's inputs.\n     * @param _xToken address of the X token (x axis)\n     * @param _yToken address of the Y token (y axis)\n     */\n    function _validateInput(address _xToken, address _yToken, address _protocolFeeCollector) internal view {\n        if (_xToken == address(0) || _yToken == address(0) || _protocolFeeCollector == address(0)) revert ZeroAddress();\n        if (_xToken == _yToken) revert XandYTokensAreTheSame();\n        if (IERC20Metadata(_xToken).decimals() != 18) revert XTokenDecimalsIsNot18();\n        if (IERC20Metadata(_yToken).decimals() > 18) revert YTokenDecimalsGT18();\n    }\n\n    /**\n     * @dev This function normalizes an input amount to or from native decimal value.\n     * @param isInput if true, it assumes that the tokens are being received into the pool and therefore it\n     * multiplies/adds the zeros necessary to make it a native-decimal value. It divides otherwise.\n     * @param rawAmount amount to normalize\n     * @return normalizedAmount the normalized value\n     */\n    function _normalizeTokenDecimals(bool isInput, uint rawAmount) internal view returns (uint normalizedAmount) {\n        if (yDecimalDiff == 0) normalizedAmount = rawAmount;\n        else normalizedAmount = isInput ? rawAmount * (10 ** yDecimalDiff) : rawAmount / (10 ** yDecimalDiff);\n    }\n\n    /**\n     * @dev This function determines the amount of fees when doing a simSwap (Sell simulation).\n     * @param amountOfY the amount to calculate the fees from\n     * @return feeAmount the amount of fees\n     *\n     */\n    function _determineFeeAmountSell(uint256 amountOfY, uint16 _fee) private pure returns (uint256 feeAmount) {\n        if (_fee > 0) feeAmount = (amountOfY * _fee) / PERCENTAGE_DENOM + 1;\n    }\n\n    /**\n     * @dev This function determines the adjusted amount of y tokens needed accounting for fees when doing a simSwapReverse (buy simulation).\n     * Equation:\n     *\n     * yAmount - yAmount * fee = realYAmount, in other words: yAmount * (1 - fee) = realYAmount\n     * Thefore,\n     * adjustedYAmount = yAmount / (1 - fee),\n     * and\n     * yAmount * fee = adjustedYAmount - yAmount,\n     * which gives us\n     * yAmount * fee =  yAmount / (1 - fee) - yAmount = (yAmount * fee) / (1 - fee)\n     *\n     * @param originalAmountOfY the amount to adjust with fees\n     * @return yFees the amount necessary to add to yAmount to get the expected yAmount after fees\n     */\n    function _determineFeeAmountBuy(uint256 originalAmountOfY, uint16 _fee) private pure returns (uint256 yFees) {\n        yFees = (originalAmountOfY * _fee) / (PERCENTAGE_DENOM - _fee) + 1; // we add 1 to round up\n    }\n\n    /**\n     * @dev this functions returns the value of both protocol and LP fees that need to be added to the original amount of yTokens in order\n     * for it to have the desired effect in simSwapReversed (buy simulation).\n     * @param originalAmountOfY the net amount of yTokens expressed in its native decimals that are desired to be used in a buy operation.\n     * @return amountProtocolFee the amount of yTokens that will be destined towards protocol fees expressed in WADs of yTokens.\n     * This value should be added to originalAmountOfY for it to have the desired effect.\n     * @return amountLPFee the amount of yTokens that will be destined towards LP fees expressed in WADs of yTokens. This\n     * value should be added to originalAmountOfY for it to have the desired effect.\n     */\n    function _determineProtocolAndLPFeesBuy(\n        uint256 originalAmountOfY\n    ) internal view returns (uint256 amountProtocolFee, uint256 amountLPFee) {\n        if (lpFee + protocolFee == 0) return (0, 0);\n        else {\n            uint totalAmountFees = _determineFeeAmountBuy(originalAmountOfY, lpFee + protocolFee);\n            if (lpFee == 0) (amountProtocolFee, amountLPFee) = (totalAmountFees, 0);\n            else if (protocolFee == 0) (amountProtocolFee, amountLPFee) = (0, totalAmountFees);\n            else {\n                ++totalAmountFees; // we add 1 to the total amount of fees to account for rounding down edge cases where 1 of the 2 results could be 0\n                if (lpFee > protocolFee) {\n                    amountLPFee = (totalAmountFees * lpFee) / (protocolFee + lpFee);\n                    amountProtocolFee = totalAmountFees - amountLPFee;\n                } else {\n                    amountProtocolFee = (totalAmountFees * protocolFee) / (protocolFee + lpFee);\n                    amountLPFee = totalAmountFees - amountProtocolFee;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev This function checks to verify the amount out will be greater than or equal to the minimum expected amount out.\n     * @param _amountOut the actual amount being provided out by the swap\n     * @param _minOut the expected amount out to compare against\n     */\n    function _checkSlippage(uint256 _amountOut, uint256 _minOut) internal pure {\n        if (_amountOut < (_minOut - 1)) revert(\"max slippage reached\");\n    }\n\n    /**\n     * @dev returns the current total liquidity in the Pool\n     * @return w\n     */\n    function w() external view returns (uint256) {\n        return uint(_w.convertpackedFloatToWAD());\n    }\n\n    function wInactive() external view returns (uint256) {\n        return uint(_wInactive.convertpackedFloatToWAD());\n    }\n\n    /**\n     * @dev Overrides the tokenURI function from ERC721 to generate an NFT with pool information\n     * @param tokenId The token ID to generate the URI for\n     * @return The token URI with SVG image and metadata\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (_ownerOf(tokenId) == address(0)) revert URIQueryForNonexistentToken();\n\n        string memory xTokenSymbol = IERC20Metadata(xToken).symbol();\n        string memory yTokenSymbol = IERC20Metadata(yToken).symbol();\n\n        Descriptor.ConstructTokenURIParams memory params = Descriptor.ConstructTokenURIParams({\n            tokenId: tokenId,\n            xTokenAddress: xToken,\n            yTokenAddress: yToken,\n            xTokenSymbol: xTokenSymbol,\n            yTokenSymbol: yTokenSymbol,\n            fee: lpFee,\n            poolManager: address(this)\n        });\n\n        return Descriptor.constructTokenURI(params);\n    }\n\n    /**\n     * @dev This function gets the total revenue in the pool for yToken in WAD\n     * @return revenue The revenue in the pool for yToken in WAD\n     */\n    function _totalRevenue() internal view returns (uint256 revenue) {\n        revenue = uint((h.mul(_w)).convertpackedFloatToWAD());\n    }\n}\n"
    }
}