{
    "vfp_id": "vfp_00181",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Permit signatures can be front-run to execute a temporary denial-of-service attack",
            "description": "The permitBatchAndCall function processes permit signatures and consumes nonces without protection against front-running. An attacker can observe a pending transaction containing valid permit data and submit a copy first, consuming the nonce and causing the original transaction to revert. This enables a griefing attack where legitimate usersâ€™ transactions fail despite correct construction, resulting in a temporary denial of service. While no funds are stolen, user experience and reliability are compromised, especially in high-stakes or time-sensitive operations.\n",
            "severity": "Low",
            "location": [
                "RouterCommon.sol::permitBatchAndCall#121-151",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1024",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1157"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/RouterCommon.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "permitBatchAndCall will revert when non-payable functions are called with value",
            "description": "The permitBatchAndCall function uses delegatecall in its multicall implementation, preserving msg.value across all calls. If a non-payable function is included in the batch while msg.value > 0, the transaction will revert even if the value is intended only for a preceding payable function. This prevents safe batching of mixed payable and non-payable calls when Ether is involved, limiting composability and creating unexpected failures for users attempting complex multi-step operations involving ETH.\n",
            "severity": "Informational",
            "location": [
                "RouterCommon.sol::permitBatchAndCall#153-154",
                "RouterCommon.sol::multicall#158-164",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1012"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/RouterCommon.sol"
            ]
        }
    ],
    "affected_files": {
        "RouterCommon.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IPermit2 } from \"permit2/src/interfaces/IPermit2.sol\";\n\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IWETH } from \"@balancer-labs/v3-interfaces/contracts/solidity-utils/misc/IWETH.sol\";\nimport { IRouterCommon } from \"@balancer-labs/v3-interfaces/contracts/vault/IRouterCommon.sol\";\nimport { IAllowanceTransfer } from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\n\nimport {\n    TransientStorageHelpers\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/TransientStorageHelpers.sol\";\nimport { StorageSlotExtension } from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/StorageSlotExtension.sol\";\n\nimport { VaultGuard } from \"./VaultGuard.sol\";\n\n/// @notice Contract for functions shared between the `Router` and `BatchRouter`.\nabstract contract RouterCommon is IRouterCommon, VaultGuard {\n    using Address for address payable;\n    using SafeERC20 for IWETH;\n    using StorageSlotExtension for *;\n    using TransientStorageHelpers for StorageSlotExtension.Uint256SlotType;\n\n    // NOTE: If you use a constant, then it is simply replaced everywhere when this constant is used by what is written\n    // after =. If you use immutable, the value is first calculated and then replaced everywhere. That means that if a\n    // constant has executable variables, they will be executed every time the constant is used.\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _SENDER_SLOT = TransientStorageHelpers.calculateSlot(type(RouterCommon).name, \"sender\");\n\n    /// @dev Incoming ETH transfer from an address that is not WETH.\n    error EthTransfer();\n\n    /// @dev The amount of ETH paid is insufficient to complete this operation.\n    error InsufficientEth();\n\n    /// @dev The swap transaction was not validated before the specified deadline timestamp.\n    error SwapDeadline();\n\n    // Raw token balances are stored in half a slot, so the max is uint128. Moreover, given that amounts are usually\n    // scaled inside the Vault, sending type(uint256).max would result in an overflow and revert.\n    uint256 internal constant _MAX_AMOUNT = type(uint128).max;\n\n    // solhint-disable-next-line var-name-mixedcase\n    IWETH internal immutable _weth;\n\n    IPermit2 internal immutable _permit2;\n\n    /**\n     * @notice Saves the user or contract that initiated the current operation.\n     * @dev It is possible to nest router calls (e.g., with reentrant hooks), but the sender returned by the router's\n     * `getSender` function will always be the \"outermost\" caller. Some transactions require the router to identify\n     * multiple senders. Consider the following example:\n     *\n     * - ContractA has a function that calls the router, then calls ContractB with the output. ContractB in turn\n     * calls back into the router.\n     * - Imagine further that ContractA is a pool with a \"before\" hook that also calls the router.\n     *\n     * When the user calls the function on ContractA, there are three calls to the router in the same transaction:\n     * - 1st call: When ContractA calls the router directly, to initiate an operation on the pool (say, a swap).\n     *             (Sender is contractA, initiator of the operation.)\n     *\n     * - 2nd call: When the pool operation invokes a hook (say onBeforeSwap), which calls back into the router.\n     *             This is a \"nested\" call within the original pool operation. The nested call returns, then the\n     *             before hook returns, the router completes the operation, and finally returns back to ContractA\n     *             with the result (e.g., a calculated amount of tokens).\n     *             (Nested call; sender is still ContractA through all of this.)\n     *\n     * - 3rd call: When the first operation is complete, ContractA calls ContractB, which in turn calls the router.\n     *             (Not nested, as the original router call from contractA has returned. Sender is now ContractB.)\n     */\n    modifier saveSender() {\n        bool isExternalSender = _saveSender();\n        _;\n        _discardSenderIfRequired(isExternalSender);\n    }\n\n    function _saveSender() internal returns (bool isExternalSender) {\n        address sender = _getSenderSlot().tload();\n\n        // NOTE: Only the most external sender will be saved by the router.\n        if (sender == address(0)) {\n            _getSenderSlot().tstore(msg.sender);\n            isExternalSender = true;\n        }\n    }\n\n    function _discardSenderIfRequired(bool isExternalSender) internal {\n        // Only the external sender shall be cleaned up; if it's not an external sender it means that\n        // the value was not saved in this modifier.\n        if (isExternalSender) {\n            _getSenderSlot().tstore(address(0));\n        }\n    }\n\n    constructor(IVault vault, IWETH weth, IPermit2 permit2) VaultGuard(vault) {\n        _weth = weth;\n        _permit2 = permit2;\n        weth.approve(address(vault), type(uint256).max);\n    }\n\n    /*******************************************************************************\n                                      Utilities\n    *******************************************************************************/\n\n    struct SignatureParts {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    /// @inheritdoc IRouterCommon\n    function permitBatchAndCall(\n        PermitApproval[] calldata permitBatch,\n        bytes[] calldata permitSignatures,\n        IAllowanceTransfer.PermitBatch calldata permit2Batch,\n        bytes calldata permit2Signature,\n        bytes[] calldata multicallData\n    ) external payable virtual saveSender returns (bytes[] memory results) {\n        // Use Permit (ERC-2612) to grant allowances to Permit2 for tokens to swap,\n        // and grant allowances to Vault for BPT tokens.\n        for (uint256 i = 0; i < permitBatch.length; ++i) {\n            bytes memory signature = permitSignatures[i];\n\n            SignatureParts memory signatureParts = _getSignatureParts(signature);\n\n            PermitApproval memory permitApproval = permitBatch[i];\n            IERC20Permit(permitApproval.token).permit(\n                permitApproval.owner,\n                address(this),\n                permitApproval.amount,\n                permitApproval.deadline,\n                signatureParts.v,\n                signatureParts.r,\n                signatureParts.s\n            );\n        }\n\n        // Only call permit2 if there's something to do.\n        if (permit2Batch.details.length > 0) {\n            // Use Permit2 for tokens that are swapped and added into the Vault.\n            _permit2.permit(msg.sender, permit2Batch, permit2Signature);\n        }\n\n        // Execute all the required operations once permissions have been granted.\n        return multicall(multicallData);\n    }\n\n    /// @inheritdoc IRouterCommon\n    function multicall(bytes[] calldata data) public virtual saveSender returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; ++i) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    function _getSignatureParts(bytes memory signature) private pure returns (SignatureParts memory signatureParts) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        /// @solidity memory-safe-assembly\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        signatureParts.r = r;\n        signatureParts.s = s;\n        signatureParts.v = v;\n    }\n\n    /**\n     * @dev Returns excess ETH back to the contract caller. Checks for sufficient ETH balance are made right before\n     * each deposit, ensuring it will revert with a friendly custom error. If there is any balance remaining when\n     * `_returnEth` is called, return it to the sender.\n     *\n     * Because the caller might not know exactly how much ETH a Vault action will require, they may send extra.\n     * Note that this excess value is returned *to the contract caller* (msg.sender). If caller and e.g. swap sender\n     * are not the same (because the caller is a relayer for the sender), then it is up to the caller to manage this\n     * returned ETH.\n     */\n    function _returnEth(address sender) internal {\n        uint256 excess = address(this).balance;\n\n        if (excess > 0) {\n            payable(sender).sendValue(excess);\n        }\n    }\n\n    /**\n     * @dev Returns an array with `amountGiven` at `tokenIndex`, and 0 for every other index.\n     * The returned array length matches the number of tokens in the pool.\n     * Reverts if the given index is greater than or equal to the pool number of tokens.\n     */\n    function _getSingleInputArrayAndTokenIndex(\n        address pool,\n        IERC20 token,\n        uint256 amountGiven\n    ) internal view returns (uint256[] memory amountsGiven, uint256 tokenIndex) {\n        uint256 numTokens;\n        (numTokens, tokenIndex) = _vault.getPoolTokenCountAndIndexOfToken(pool, token);\n        amountsGiven = new uint256[](numTokens);\n        amountsGiven[tokenIndex] = amountGiven;\n    }\n\n    function _takeTokenIn(\n        address sender,\n        IERC20 tokenIn,\n        uint256 amountIn,\n        bool wethIsEth\n    ) internal returns (uint256 ethAmountIn) {\n        // If the tokenIn is ETH, then wrap `amountIn` into WETH.\n        if (wethIsEth && tokenIn == _weth) {\n            if (address(this).balance < amountIn) {\n                revert InsufficientEth();\n            }\n\n            ethAmountIn = amountIn;\n            // wrap amountIn to WETH.\n            _weth.deposit{ value: amountIn }();\n            // send WETH to Vault.\n            _weth.safeTransfer(address(_vault), amountIn);\n            // update Vault accounting.\n            _vault.settle(_weth, amountIn);\n        } else {\n            // Send the tokenIn amount to the Vault\n            _permit2.transferFrom(sender, address(_vault), uint160(amountIn), address(tokenIn));\n            _vault.settle(tokenIn, amountIn);\n        }\n    }\n\n    function _sendTokenOut(address sender, IERC20 tokenOut, uint256 amountOut, bool wethIsEth) internal {\n        // If the tokenOut is ETH, then unwrap `amountOut` into ETH.\n        if (wethIsEth && tokenOut == _weth) {\n            // Receive the WETH amountOut.\n            _vault.sendTo(tokenOut, address(this), amountOut);\n            // Withdraw WETH to ETH.\n            _weth.withdraw(amountOut);\n            // Send ETH to sender.\n            payable(sender).sendValue(amountOut);\n        } else {\n            // Receive the tokenOut amountOut.\n            _vault.sendTo(tokenOut, sender, amountOut);\n        }\n    }\n\n    function _maxTokenLimits(address pool) internal view returns (uint256[] memory maxLimits) {\n        uint256 numTokens = _vault.getPoolTokens(pool).length;\n        maxLimits = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            maxLimits[i] = _MAX_AMOUNT;\n        }\n    }\n\n    /**\n     * @dev Enables the Router to receive ETH. This is required for it to be able to unwrap WETH, which sends ETH to the\n     * caller.\n     *\n     * Any ETH sent to the Router outside of the WETH unwrapping mechanism would be forever locked inside the Router, so\n     * we prevent that from happening. Other mechanisms used to send ETH to the Router (such as being the recipient of\n     * an ETH swap, Pool exit or withdrawal, contract self-destruction, or receiving the block mining reward) will\n     * result in locked funds, but are not otherwise a security or soundness issue. This check only exists as an attempt\n     * to prevent user error.\n     */\n    receive() external payable {\n        if (msg.sender != address(_weth)) {\n            revert EthTransfer();\n        }\n    }\n\n    /// @inheritdoc IRouterCommon\n    function getSender() external view returns (address) {\n        return _getSenderSlot().tload();\n    }\n\n    function _getSenderSlot() internal view returns (StorageSlotExtension.AddressSlotType) {\n        return _SENDER_SLOT.asAddress();\n    }\n}\n"
    }
}