{
    "vfp_id": "vfp_00495",
    "project_name": "cantina_centrifuge_aug2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "CentrifugeId shouldn't be 0",
            "description": "CentrifugeId should not be zero, as it is a special value and is explicitly disallowed in MessageProcessor::handle(). However, there is no explicit validation in deployment scripts or constructors of MultiAdapter and MessageDispatcher to prevent zero values. The cause is missing input validation during configuration. A configuration error could result in a CentrifugeId being set to zero, which would be rejected downstream, causing transaction failures or inconsistent state. This could lead to denial of service or misrouting of cross-chain messages.\n",
            "severity": null,
            "location": [
                "MultiAdapter",
                "MessageDispatcher",
                "MessageProcessor::handle"
            ],
            "files": [
                "protocol-v3/src/common/MultiAdapter.sol"
            ]
        }
    ],
    "affected_files": {
        "MultiAdapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IAdapter} from \"./interfaces/IAdapter.sol\";\nimport {MessageProofLib} from \"./libraries/MessageProofLib.sol\";\nimport {IMessageHandler} from \"./interfaces/IMessageHandler.sol\";\nimport {IMultiAdapter, MAX_ADAPTER_COUNT} from \"./interfaces/IMultiAdapter.sol\";\n\nimport {Auth} from \"../misc/Auth.sol\";\nimport {CastLib} from \"../misc/libraries/CastLib.sol\";\nimport {MathLib} from \"../misc/libraries/MathLib.sol\";\nimport {ArrayLib} from \"../misc/libraries/ArrayLib.sol\";\nimport {BytesLib} from \"../misc/libraries/BytesLib.sol\";\n\ncontract MultiAdapter is Auth, IMultiAdapter {\n    using CastLib for *;\n    using MessageProofLib for *;\n    using BytesLib for bytes;\n    using ArrayLib for uint16[8];\n    using MathLib for uint256;\n\n    uint8 public constant PRIMARY_ADAPTER_ID = 1;\n    uint256 public constant RECOVERY_CHALLENGE_PERIOD = 7 days;\n\n    uint16 public immutable localCentrifugeId;\n    IMessageHandler public gateway;\n\n    mapping(uint16 centrifugeId => IAdapter[]) public adapters;\n    mapping(uint16 centrifugeId => mapping(IAdapter adapter => Adapter)) internal _adapterDetails;\n    mapping(uint16 centrifugeId => mapping(bytes32 payloadHash => Inbound)) public inbound;\n    mapping(uint16 centrifugeId => mapping(IAdapter adapter => mapping(bytes32 payloadHash => uint256 timestamp)))\n        public recoveries;\n\n    constructor(uint16 localCentrifugeId_, IMessageHandler gateway_, address deployer) Auth(deployer) {\n        localCentrifugeId = localCentrifugeId_;\n        gateway = gateway_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMultiAdapter\n    function file(bytes32 what, address instance) external auth {\n        if (what == \"gateway\") gateway = IMessageHandler(instance);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, instance);\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function file(bytes32 what, uint16 centrifugeId, IAdapter[] calldata addresses) external auth {\n        if (what == \"adapters\") {\n            uint8 quorum_ = addresses.length.toUint8();\n            require(quorum_ != 0, EmptyAdapterSet());\n            require(quorum_ <= MAX_ADAPTER_COUNT, ExceedsMax());\n\n            // Increment session id to reset pending votes\n            uint256 numAdapters = adapters[centrifugeId].length;\n            uint64 sessionId =\n                numAdapters > 0 ? _adapterDetails[centrifugeId][adapters[centrifugeId][0]].activeSessionId + 1 : 0;\n\n            // Disable old adapters\n            for (uint8 i; i < numAdapters; i++) {\n                delete _adapterDetails[centrifugeId][adapters[centrifugeId][i]];\n            }\n\n            // Enable new adapters, setting quorum to number of adapters\n            for (uint8 j; j < quorum_; j++) {\n                require(_adapterDetails[centrifugeId][addresses[j]].id == 0, NoDuplicatesAllowed());\n\n                // Ids are assigned sequentially starting at 1\n                _adapterDetails[centrifugeId][addresses[j]] = Adapter(j + 1, quorum_, sessionId);\n            }\n\n            adapters[centrifugeId] = addresses;\n        } else {\n            revert FileUnrecognizedParam();\n        }\n\n        emit File(what, centrifugeId, addresses);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageHandler\n    function handle(uint16 centrifugeId, bytes calldata payload) external {\n        _handle(centrifugeId, payload, IAdapter(msg.sender));\n    }\n\n    function _handle(uint16 centrifugeId, bytes calldata payload, IAdapter adapter_) internal {\n        Adapter memory adapter = _adapterDetails[centrifugeId][adapter_];\n        require(adapter.id != 0, InvalidAdapter());\n\n        // Verify adapter and parse message hash\n        bytes32 payloadHash;\n        bool isMessageProof = payload.toUint8(0) == MessageProofLib.MESSAGE_PROOF_ID;\n        if (isMessageProof) {\n            require(adapter.id != PRIMARY_ADAPTER_ID, NonProofAdapter());\n\n            payloadHash = payload.deserializeMessageProof();\n            bytes32 payloadId = keccak256(abi.encodePacked(centrifugeId, localCentrifugeId, payloadHash));\n            emit HandleProof(centrifugeId, payloadId, payloadHash, adapter_);\n        } else {\n            require(adapter.id == PRIMARY_ADAPTER_ID, NonPayloadAdapter());\n\n            payloadHash = keccak256(payload);\n            bytes32 payloadId = keccak256(abi.encodePacked(centrifugeId, localCentrifugeId, payloadHash));\n            emit HandlePayload(centrifugeId, payloadId, payload, adapter_);\n        }\n\n        // Special case for gas efficiency\n        if (adapter.quorum == 1 && !isMessageProof) {\n            gateway.handle(centrifugeId, payload);\n            return;\n        }\n\n        Inbound storage state = inbound[centrifugeId][payloadHash];\n\n        if (adapter.activeSessionId != state.sessionId) {\n            // Clear votes from previous session\n            delete state.votes;\n            state.sessionId = adapter.activeSessionId;\n        }\n\n        // Increase vote\n        state.votes[adapter.id - 1]++;\n\n        if (state.votes.countNonZeroValues() >= adapter.quorum) {\n            // Reduce votes by quorum\n            state.votes.decreaseFirstNValues(adapter.quorum);\n\n            if (isMessageProof) {\n                gateway.handle(centrifugeId, state.pending);\n            } else {\n                gateway.handle(centrifugeId, payload);\n            }\n\n            // Only if there are no more pending messages, remove the pending message\n            if (state.votes.isEmpty()) {\n                delete state.pending;\n            }\n        } else if (!isMessageProof) {\n            state.pending = payload;\n        }\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function initiateRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external auth {\n        require(_adapterDetails[centrifugeId][adapter].id != 0, InvalidAdapter());\n        recoveries[centrifugeId][adapter][payloadHash] = block.timestamp + RECOVERY_CHALLENGE_PERIOD;\n        emit InitiateRecovery(centrifugeId, payloadHash, adapter);\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function disputeRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external auth {\n        require(recoveries[centrifugeId][adapter][payloadHash] != 0, RecoveryNotInitiated());\n        delete recoveries[centrifugeId][adapter][payloadHash];\n        emit DisputeRecovery(centrifugeId, payloadHash, adapter);\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function executeRecovery(uint16 centrifugeId, IAdapter adapter, bytes calldata payload) external {\n        bytes32 payloadHash = keccak256(payload);\n        uint256 recovery = recoveries[centrifugeId][adapter][payloadHash];\n\n        require(recovery != 0, RecoveryNotInitiated());\n        require(recovery <= block.timestamp, RecoveryChallengePeriodNotEnded());\n\n        delete recoveries[centrifugeId][adapter][payloadHash];\n        _handle(centrifugeId, payload, adapter);\n        emit ExecuteRecovery(centrifugeId, payload, adapter);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAdapter\n    function send(uint16 centrifugeId, bytes calldata payload, uint256 gasLimit, address refund)\n        external\n        payable\n        auth\n        returns (bytes32)\n    {\n        IAdapter[] memory adapters_ = adapters[centrifugeId];\n        require(adapters_.length != 0, EmptyAdapterSet());\n\n        bytes32 payloadHash = keccak256(payload);\n        bytes32 payloadId = keccak256(abi.encodePacked(localCentrifugeId, centrifugeId, payloadHash));\n        bytes memory proof = payloadHash.serializeMessageProof();\n\n        uint256 cost = adapters_[0].estimate(centrifugeId, payload, gasLimit);\n        bytes32 adapterData = adapters_[0].send{value: cost}(centrifugeId, payload, gasLimit, refund);\n        emit SendPayload(centrifugeId, payloadId, payload, adapters_[0], adapterData, refund);\n\n        for (uint256 i = 1; i < adapters_.length; i++) {\n            cost = adapters_[i].estimate(centrifugeId, proof, gasLimit);\n            adapterData = adapters_[i].send{value: cost}(centrifugeId, proof, gasLimit, refund);\n            emit SendProof(centrifugeId, payloadId, payloadHash, adapters_[i], adapterData);\n        }\n\n        return bytes32(0);\n    }\n\n    /// @inheritdoc IAdapter\n    function estimate(uint16 centrifugeId, bytes calldata payload, uint256 gasLimit)\n        external\n        view\n        returns (uint256 total)\n    {\n        IAdapter[] memory adapters_ = adapters[centrifugeId];\n        bytes memory proof = keccak256(payload).serializeMessageProof();\n\n        for (uint256 i; i < adapters_.length; i++) {\n            total += adapters_[i].estimate(centrifugeId, i == PRIMARY_ADAPTER_ID - 1 ? payload : proof, gasLimit);\n        }\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function quorum(uint16 centrifugeId) external view returns (uint8) {\n        Adapter memory adapter = _adapterDetails[centrifugeId][adapters[centrifugeId][0]];\n        return adapter.quorum;\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function activeSessionId(uint16 centrifugeId) external view returns (uint64) {\n        Adapter memory adapter = _adapterDetails[centrifugeId][adapters[centrifugeId][0]];\n        return adapter.activeSessionId;\n    }\n\n    /// @inheritdoc IMultiAdapter\n    function votes(uint16 centrifugeId, bytes32 payloadHash) external view returns (uint16[MAX_ADAPTER_COUNT] memory) {\n        return inbound[centrifugeId][payloadHash].votes;\n    }\n}\n"
    }
}