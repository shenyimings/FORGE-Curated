{
    "vfp_id": "vfp_00107",
    "project_name": "cantina_euler_pr111_oct2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Internal function delegateToManagementImpl violates conventions",
            "description": "The internal function delegateToManagementImpl() in EulerSwap.sol does not follow Solidity naming conventions, as it lacks the underscore prefix (_delegateToManagementImpl) typically used for internal and private functions. Additionally, the function is placed among public/external functions rather than being grouped at the bottom of the contract, which is the conventional location for internal and private functions.\nThe root cause is deviation from established code style and organization practices, which are intended to improve code readability and maintainability.\nWhile not a security vulnerability per se, this inconsistency can confuse developers and auditors, potentially leading to incorrect assumptions about function visibility or accessibility.\nThe impact is reduced code clarity and maintainability, increasing the likelihood of human error during future development or audits.\n",
            "severity": "Informational",
            "location": [
                "EulerSwap.sol#L32-L39"
            ],
            "files": [
                "euler-swap/src/EulerSwap.sol"
            ]
        }
    ],
    "affected_files": {
        "EulerSwap.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IEulerSwapCallee} from \"./interfaces/IEulerSwapCallee.sol\";\nimport {IEVault} from \"evk/EVault/IEVault.sol\";\n\nimport {IEulerSwap} from \"./interfaces/IEulerSwap.sol\";\nimport {UniswapHook} from \"./UniswapHook.sol\";\nimport {CtxLib} from \"./libraries/CtxLib.sol\";\nimport {QuoteLib} from \"./libraries/QuoteLib.sol\";\nimport {SwapLib} from \"./libraries/SwapLib.sol\";\n\ncontract EulerSwap is IEulerSwap, UniswapHook {\n    bytes32 public constant curve = bytes32(\"EulerSwap v2\");\n    address public immutable managementImpl;\n\n    error AmountTooBig();\n\n    /// @notice Emitted upon EulerSwap instance creation or reconfiguration.\n    event EulerSwapConfigured(DynamicParams dParams, InitialState initialState);\n    /// @notice Emitted upon EulerSwap instance creation or reconfiguration.\n    event EulerSwapManagerSet(address indexed manager, bool installed);\n\n    constructor(address evc_, address protocolFeeConfig_, address poolManager_, address managementImpl_)\n        UniswapHook(evc_, protocolFeeConfig_, poolManager_)\n    {\n        managementImpl = managementImpl_;\n    }\n\n    function delegateToManagementImpl() internal {\n        (bool success, bytes memory result) = managementImpl.delegatecall(msg.data);\n        if (!success) {\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        }\n    }\n\n    /// @inheritdoc IEulerSwap\n    function activate(DynamicParams calldata, InitialState calldata) external {\n        delegateToManagementImpl();\n\n        // Uniswap hook activation\n\n        activateHook(CtxLib.getStaticParams());\n    }\n\n    /// @inheritdoc IEulerSwap\n    function setManager(address, bool) external {\n        delegateToManagementImpl();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function reconfigure(DynamicParams calldata, InitialState calldata) external {\n        delegateToManagementImpl();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function managers(address manager) external view returns (bool installed) {\n        CtxLib.State storage s = CtxLib.getState();\n        return s.managers[manager];\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getStaticParams() external pure returns (StaticParams memory) {\n        return CtxLib.getStaticParams();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getDynamicParams() external pure returns (DynamicParams memory) {\n        return CtxLib.getDynamicParams();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getAssets() external view returns (address asset0, address asset1) {\n        StaticParams memory sParams = CtxLib.getStaticParams();\n\n        asset0 = IEVault(sParams.supplyVault0).asset();\n        asset1 = IEVault(sParams.supplyVault1).asset();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getReserves() external view nonReentrantView returns (uint112, uint112, uint32) {\n        CtxLib.State storage s = CtxLib.getState();\n\n        return (s.reserve0, s.reserve1, s.status);\n    }\n\n    /// @inheritdoc IEulerSwap\n    function isInstalled() external view nonReentrantView returns (bool) {\n        StaticParams memory sParams = CtxLib.getStaticParams();\n\n        return evc.isAccountOperatorAuthorized(sParams.eulerAccount, address(this));\n    }\n\n    /// @inheritdoc IEulerSwap\n    function computeQuote(address tokenIn, address tokenOut, uint256 amount, bool exactIn)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        StaticParams memory sParams = CtxLib.getStaticParams();\n        DynamicParams memory dParams = CtxLib.getDynamicParams();\n\n        return QuoteLib.computeQuote(\n            address(evc), sParams, dParams, QuoteLib.checkTokens(sParams, tokenIn, tokenOut), amount, exactIn\n        );\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getLimits(address tokenIn, address tokenOut)\n        external\n        view\n        nonReentrantView\n        returns (uint256 inLimit, uint256 outLimit)\n    {\n        StaticParams memory sParams = CtxLib.getStaticParams();\n        DynamicParams memory dParams = CtxLib.getDynamicParams();\n\n        if (!evc.isAccountOperatorAuthorized(sParams.eulerAccount, address(this))) return (0, 0);\n        if (dParams.expiration != 0 && dParams.expiration <= block.timestamp) return (0, 0);\n\n        bool asset0IsInput = QuoteLib.checkTokens(sParams, tokenIn, tokenOut);\n\n        uint256 fee = QuoteLib.getFeeReadOnly(dParams, asset0IsInput);\n        if (fee >= 1e18) return (0, 0);\n\n        (inLimit, outLimit) = QuoteLib.calcLimits(sParams, dParams, asset0IsInput, fee);\n        if (outLimit > 0) outLimit--; // Compensate for rounding up of exact output quotes\n    }\n\n    /// @inheritdoc IEulerSwap\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data)\n        external\n        callThroughEVC\n        nonReentrant\n    {\n        require(amount0Out <= type(uint112).max && amount1Out <= type(uint112).max, AmountTooBig());\n\n        // Setup context\n\n        SwapLib.SwapContext memory ctx = SwapLib.init(address(evc), protocolFeeConfig, _msgSender(), to);\n        SwapLib.setAmountsOut(ctx, amount0Out, amount1Out);\n        SwapLib.invokeBeforeSwapHook(ctx);\n\n        // Optimistically send tokens\n\n        SwapLib.doWithdraws(ctx);\n\n        // Invoke callback\n\n        if (data.length > 0) IEulerSwapCallee(to).eulerSwapCall(_msgSender(), amount0Out, amount1Out, data);\n\n        // Deposit all available funds\n\n        SwapLib.setAmountsIn(\n            ctx, IERC20(ctx.asset0).balanceOf(address(this)), IERC20(ctx.asset1).balanceOf(address(this))\n        );\n        SwapLib.doDeposits(ctx);\n\n        // Verify curve invariant is satisfied\n\n        SwapLib.finish(ctx);\n    }\n}\n"
    }
}