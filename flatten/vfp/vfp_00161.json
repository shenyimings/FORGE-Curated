{
    "vfp_id": "vfp_00161",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 60,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "setMarginState updates rate-related parameters without first updating all poolsâ€™ interests",
            "description": "Changing marginState affects interest calculations, but existing pool interests are not updated with old parameters before applying the new state. The root cause is incorrect state transition order. This could lead to interest miscalculations. The impact is potential accounting inaccuracies during state updates.\n",
            "severity": "Informational",
            "location": [
                "MarginBase.solMarginBase.sol#L179"
            ],
            "files": [
                "likwid-margin/src/base/MarginBase.sol"
            ]
        }
    ],
    "affected_files": {
        "MarginBase.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\n\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {MarginState} from \"../types/MarginState.sol\";\nimport {DoubleEndedQueue} from \"../libraries/external/DoubleEndedQueue.sol\";\nimport {IMarginBase} from \"../interfaces/IMarginBase.sol\";\nimport {Math} from \"../libraries/Math.sol\";\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\nimport {StageMath} from \"../libraries/StageMath.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\nabstract contract MarginBase is IMarginBase, Owned {\n    using SafeCast for *;\n    using StageMath for uint256;\n    using CustomRevert for bytes4;\n    using DoubleEndedQueue for DoubleEndedQueue.Uint256Deque;\n\n    error LiquidityLocked();\n\n    MarginState public marginState;\n    address public marginController;\n    mapping(PoolId id => uint256) private lastStageTimestampStore; // Timestamp of the last stage\n    mapping(PoolId id => DoubleEndedQueue.Uint256Deque) private liquidityLockedQueue;\n\n    modifier onlyManager() {\n        if (msg.sender != marginController) Unauthorized.selector.revertWith();\n        _;\n    }\n\n    uint24 private constant MAX_PRICE_MOVE_PER_SECOND = 3000; // 0.3%/second\n    uint24 private constant RATE_BASE = 50000;\n    uint24 private constant USE_MIDDLE_LEVEL = 400000;\n    uint24 private constant USE_HIGH_LEVEL = 800000;\n    uint24 private constant M_LOW = 10;\n    uint24 private constant M_MIDDLE = 100;\n    uint24 private constant M_HIGH = 10000;\n    uint24 private constant STAGE_DURATION = 12 hours; // default: 12 hour seconds\n    uint24 private constant STAGE_SIZE = 5; // default: 5 stages\n    uint24 private constant STAGE_LEAVE_PART = 5; // default: 5, meaning 20% of the total liquidity is free\n\n    constructor(address initialOwner) Owned(initialOwner) {\n        MarginState _marginState = marginState.setMaxPriceMovePerSecond(MAX_PRICE_MOVE_PER_SECOND);\n        _marginState = _marginState.setRateBase(RATE_BASE);\n        _marginState = _marginState.setUseMiddleLevel(USE_MIDDLE_LEVEL);\n        _marginState = _marginState.setUseHighLevel(USE_HIGH_LEVEL);\n        _marginState = _marginState.setMLow(M_LOW);\n        _marginState = _marginState.setMMiddle(M_MIDDLE);\n        _marginState = _marginState.setMHigh(M_HIGH);\n        _marginState = _marginState.setStageDuration(STAGE_DURATION);\n        _marginState = _marginState.setStageSize(STAGE_SIZE);\n        _marginState = _marginState.setStageLeavePart(STAGE_LEAVE_PART);\n        marginState = _marginState;\n    }\n\n    /// @notice Gets the amount of released and next-to-be-released liquidity.\n    /// @dev Internal view function to calculate the amount of liquidity that is currently released and the amount that will be released in the next stage.\n    /// @param id The ID of the pool.\n    /// @return releasedLiquidity The amount of liquidity that is currently released.\n    /// @return nextReleasedLiquidity The amount of liquidity that will be released in the next stage.\n    function _getReleasedLiquidity(PoolId id)\n        internal\n        view\n        returns (uint128 releasedLiquidity, uint128 nextReleasedLiquidity)\n    {\n        releasedLiquidity = type(uint128).max;\n        if (uint256(marginState.stageDuration()) * marginState.stageSize() > 0) {\n            DoubleEndedQueue.Uint256Deque storage queue = liquidityLockedQueue[id];\n            uint256 lastStageTimestamp = lastStageTimestampStore[id];\n            if (!queue.empty()) {\n                uint256 currentStage = queue.front();\n                (, releasedLiquidity) = currentStage.decode();\n                if (\n                    queue.length() > 1 && currentStage.isFree(marginState.stageLeavePart())\n                        && block.timestamp >= lastStageTimestamp + marginState.stageDuration()\n                ) {\n                    uint256 nextStage = queue.at(1);\n                    (, nextReleasedLiquidity) = nextStage.decode();\n                }\n            }\n        }\n    }\n\n    /// @notice Handles the addition of liquidity to a pool.\n    /// @dev Locks the liquidity according to the staging mechanism.\n    /// @param id The ID of the pool.\n    /// @param liquidityAdded The amount of liquidity to add.\n    function _handleAddLiquidity(PoolId id, uint256 liquidityAdded) internal {\n        uint256 stageSize = marginState.stageSize();\n        if (uint256(marginState.stageDuration()) * stageSize == 0) {\n            return; // No locking if stageDuration or stageSize is zero\n        }\n        uint256 lastStageTimestamp = lastStageTimestampStore[id];\n        if (lastStageTimestamp == 0) {\n            // Initialize lastStageTimestamp if it's not set\n            lastStageTimestampStore[id] = block.timestamp;\n        }\n        DoubleEndedQueue.Uint256Deque storage queue = liquidityLockedQueue[id];\n        uint128 lockAmount = Math.ceilDiv(liquidityAdded, stageSize).toUint128(); // Ensure at least 1 unit is locked per stage\n        uint256 zeroStage = 0;\n        if (queue.empty()) {\n            for (uint32 i = 0; i < stageSize; i++) {\n                queue.pushBack(zeroStage.add(lockAmount));\n            }\n        } else {\n            uint256 queueSize = Math.min(queue.length(), stageSize);\n            // If the queue is not empty, we need to update the existing stages\n            // and add new stages if necessary\n            for (uint256 i = 0; i < queueSize; i++) {\n                uint256 stage = queue.at(i);\n                queue.set(i, stage.add(lockAmount));\n            }\n            for (uint256 i = queueSize; i < stageSize; i++) {\n                queue.pushBack(zeroStage.add(lockAmount));\n            }\n        }\n    }\n\n    /// @notice Handles the removal of liquidity from a pool.\n    /// @dev Checks if the requested amount of liquidity is available for withdrawal and updates the liquidity queue.\n    /// @param id The ID of the pool.\n    /// @param liquidityRemoved The amount of liquidity to remove .\n    function _handleRemoveLiquidity(PoolId id, uint256 liquidityRemoved) internal {\n        if (uint256(marginState.stageDuration()) * marginState.stageSize() > 0) {\n            (uint128 releasedLiquidity, uint128 nextReleasedLiquidity) = _getReleasedLiquidity(id);\n            uint256 availableLiquidity = releasedLiquidity + nextReleasedLiquidity;\n            if (availableLiquidity < liquidityRemoved) {\n                LiquidityLocked.selector.revertWith();\n            }\n            DoubleEndedQueue.Uint256Deque storage queue = liquidityLockedQueue[id];\n            if (!queue.empty()) {\n                if (nextReleasedLiquidity > 0) {\n                    // If next stage is free, we can release the next stage liquidity\n                    uint256 currentStage = queue.popFront(); // Remove the current stage\n                    uint256 nextStage = queue.front();\n                    (, uint128 currentLiquidity) = currentStage.decode();\n                    if (currentLiquidity > liquidityRemoved) {\n                        nextStage = nextStage.add((currentLiquidity - liquidityRemoved).toUint128());\n                    } else {\n                        nextStage = nextStage.sub((liquidityRemoved - currentLiquidity).toUint128());\n                    }\n                    queue.set(0, nextStage);\n                    // Update lastStageTimestamp to the next stage time\n                    lastStageTimestampStore[id] = block.timestamp;\n                } else {\n                    // If next stage is not free, we just reduce the current stage liquidity\n                    uint256 currentStage = queue.front();\n                    uint256 afterStage;\n                    if (queue.length() == 1) {\n                        afterStage = currentStage.subTotal(liquidityRemoved.toUint128());\n                    } else {\n                        afterStage = currentStage.sub(liquidityRemoved.toUint128());\n                    }\n                    if (!currentStage.isFree(marginState.stageLeavePart()) || queue.length() == 1) {\n                        // Update lastStageTimestamp\n                        lastStageTimestampStore[id] = block.timestamp;\n                    }\n                    queue.set(0, afterStage);\n                }\n            }\n        }\n    }\n\n    // ******************** OWNER CALL ********************\n    /// @notice Sets the margin controller address.\n    /// @dev Only the owner can call this function.\n    /// @param controller The address of the new margin controller.\n    function setMarginController(address controller) external onlyOwner {\n        if (marginController == address(0)) {\n            marginController = controller;\n            emit MarginControllerUpdated(controller);\n        }\n    }\n\n    /// @inheritdoc IMarginBase\n    function setMarginState(MarginState newMarginState) external onlyOwner {\n        marginState = newMarginState;\n        emit MarginStateUpdated(newMarginState);\n    }\n}\n"
    }
}