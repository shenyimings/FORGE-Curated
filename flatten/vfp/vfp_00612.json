{
    "vfp_id": "vfp_00612",
    "project_name": "cantina_clearpool_aug2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Decimal truncation on asset vaults different to 18 decimals loss precission",
            "description": "The calculation of asset amounts in vaults with non-18 decimal precision leads to loss of precision due to inconsistent decimal scaling across contracts such as TellerWithMultiAssetSupport.sol, AccountantWithRateProviders.sol, and AtomicQueue.sol. This occurs because the code does not properly normalize decimal representations when converting between assets and shares. An attacker could exploit this by depositing and withdrawing with low-decimal assets to induce rounding errors, potentially leading to unfair accrual of value or loss of user funds. The impact is significant for users interacting with vaults using assets that do not have 18 decimals, as they may receive fewer shares or assets than expected.\n",
            "severity": "High",
            "location": [
                "TellerWithMultiAssetSupport.sol",
                "AccountantWithRateProviders.sol",
                "AtomicQueue.sol"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/TellerWithMultiAssetSupport.sol",
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol",
                "3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Rate provider return amount inconsistency",
            "description": "The functions calculateSharesForAmount and calculateAmountForShares expect the rateProvider to return rates scaled to 18 decimals, while the claimFees function expects the rate in quote asset decimals. This inconsistency can lead to incorrect calculations when converting between shares and amounts. The root cause is the lack of a standardized scaling convention across the codebase for rateProvider outputs. An attacker could exploit this by manipulating fee claims on low-decimal assets, causing miscalculations that result in either zero-value transfers or inflated fee payouts. The impact includes potential loss of fees or incorrect distribution of assets.\n",
            "severity": "High",
            "location": [],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect scaling in _calculateWantAmount",
            "description": "The _calculateWantAmount function in AtomicQueue.sol uses inconsistent scaling logic across its three calculation paths. In some cases, it divides by 1e18 while using raw values not normalized to 18 decimals, leading to incorrect scaling of the resulting amount. The cause is the absence of consistent use of standardized constants like ONE_SHARE for scaling operations. An attacker could exploit this by triggering specific calculation paths with carefully chosen input values to manipulate the output amount, potentially leading to unfair allocation of assets or shares. The impact includes economic imbalance and loss of user funds due to incorrect conversions.\n",
            "severity": "High",
            "location": [
                "AtomicQueue.sol::_calculateWantAmount"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Inconsistent scaling in claimFees may zero out transfers",
            "description": "In the claimFees function, the non-pegged branch mixes units by using fees scaled to the fee asset's decimals while dividing by a rate expected in 18 decimals. For example, with base asset at 18 decimals and fee asset at 6 decimals, small accrued fees can round down to zero during conversion, even though _feesOwedInBase is still cleared. This is caused by improper unit alignment in arithmetic operations. An attacker could exploit this by accumulating small fees and claiming them, resulting in loss of those fees due to rounding down. The impact is loss of accrued fees for users or the protocol, especially affecting low-decimal fee assets.\n",
            "severity": "High",
            "location": [
                "claimFees"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Public checkpoint() mutates state while paused",
            "description": "The checkpoint() function in AccountantWithRateProviders.sol is public and can be called by any address even when the contract is paused. It mutates critical state variables such as _exchangeRate, _feesOwedInBase, and _lastAccrualTime through _checkpointInterestAndFees(), bypassing the intended pause protection. The root cause is the lack of a pause check within the checkpoint() function. An attacker could exploit this by calling checkpoint() after a pause is triggered (e.g., due to an invalid exchange rate), thereby updating the exchange rate and accrual data despite the paused state. The impact includes potential manipulation of state during emergency conditions, undermining the safety mechanism of the pause.\n",
            "severity": "Medium",
            "location": [
                "AccountantWithRateProviders.sol#L509-L511"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Invalid Exchange Rate Causes Permanent State Corruption in Fee Calculations",
            "description": "The updateExchangeRate() function stores invalid exchange rates that are later used as the base for future interest and fee calculations. Even if the rate is out of bounds and causes a pause, the invalid rate is still stored and used in subsequent _checkpointInterestAndFees() calls. The cause is the lack of validation before storage and the absence of a mechanism to reject invalid rates during pauses. An attacker could exploit this by submitting an out-of-bounds rate, triggering a pause but still corrupting the stored _exchangeRate, which then skews all future interest accruals. The impact is long-term state corruption affecting fee calculations and potentially leading to incorrect distributions or insolvency.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Insufficient event coverage for state changes",
            "description": "Several state-changing functions do not emit events, reducing transparency and observability. Specifically, checkpoint() modifies _exchangeRate, _feesOwedInBase, and _lastAccrualTime without emitting events; setShareLockPeriod() changes a critical parameter without notification; and updateExchangeRate() sets state._isPaused without emitting Paused(), duplicating logic from the dedicated pause() function. The cause is missing event emissions and inconsistent use of pause logic. This can be exploited indirectly by attackers who rely on event-based monitoring to detect anomalies, as they may fail to detect critical state changes. The impact includes reduced auditability, delayed incident response, and potential for undetected malicious activity.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Inconsistent enforcement when lowering maxLendingRate",
            "description": "The setMaxLendingRate function only updates the cap without adjusting the current lending rate if it exceeds the new maximum. This means the contract continues to accrue interest at a rate that is now above the governance-defined limit until a separate transaction is sent to correct it. The root cause is the lack of automatic clamping of the current rate to the new cap. An attacker (or malicious governor) could exploit this by temporarily setting a high lending rate and then lowering the cap without adjusting the active rate, allowing continued accrual at the higher rate. The impact is policy violation and potential overcharging of borrowers.\n",
            "severity": "Low",
            "location": [
                "AccountantWithRateProviders.sol#L320-L323"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Solve can be DoSed when a single request is invalid",
            "description": "In AtomicQueue.sol, the solve function reverts entirely if a single request is invalid, instead of skipping the invalid request and processing the rest. Additionally, transferFrom can fail, which also causes a full revert. The cause is the lack of error handling or try-catch logic for individual requests. An attacker could exploit this by submitting a batch with one invalid request, causing the entire solve operation to fail, effectively DoSing the system. The impact is denial of service for legitimate users trying to execute valid requests, especially in high-traffic scenarios.\n",
            "severity": "Low",
            "location": [
                "AtomicQueue.sol#L221-L232"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "Use of raw 1e4 instead of a named constant",
            "description": "The code uses the raw literal 1e4 as a denominator for basis point calculations in AccountantWithRateProviders.sol, instead of a named constant like BASIS_POINTS. While functionally correct, this reduces code clarity and maintainability. The cause is hardcoding of magic numbers. This is not directly exploitable but increases the risk of future bugs if the value is inconsistently used or mistyped elsewhere. The impact is reduced code readability and higher maintenance cost, potentially leading to errors in future modifications.\n",
            "severity": "Informational",
            "location": [
                "AccountantWithRateProviders.sol#L270-L272"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unused return value and unnecessary computation in calculateExchangeRateWithInterest",
            "description": "The function calculateExchangeRateWithInterest() computes and returns both newRate and interestAccrued, but all call sites only use newRate. This results in unnecessary computation of interestAccrued, increasing gas costs. The cause is a design decision to return extra data for off-chain use, despite no on-chain benefit. While not exploitable, it represents inefficient code. The impact is higher gas consumption for no functional benefit, which could be optimized by splitting the function or making interestAccrued optional.\n",
            "severity": "Informational",
            "location": [
                "AccountantWithRateProviders.sol#L383"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol",
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Increasing Interest Rate creates price drift risk in AtomicQueue (mitigated by current withdraw-only usage)",
            "description": "AtomicQueue uses the current NAV at execution time to price requests, which introduces price drift risk if interest rates change between request submission and execution. For example, a user expecting 100 shares for 10 USDC might receive fewer if the rate increases. Currently, this is mitigated because the queue is used only for withdrawals and managed by Clearpool. The cause is the use of real-time pricing without slippage protection. If the queue were opened for deposits, this could be exploited by frontrunning or sandwich attacks. The impact includes unfair outcomes for users and potential loss of funds if usage expands without safeguards.\n",
            "severity": "Informational",
            "location": [
                "AtomicQueue.sol#L157-L164"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/atomic-queue/AtomicQueue.sol",
                "3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Bound check incomplete",
            "description": "The bound check in AccountantWithRateProviders.sol only verifies that the exchange rate change is within upper and lower bounds but does not ensure that _allowedExchangeRateChangeUpper > _allowedExchangeRateChangeLower. This allows the bounds to be set in reverse order, effectively inverting the allowed range. The cause is missing validation of the relationship between the two parameters. An attacker (or misconfigured governor) could set the bounds in reverse, allowing out-of-bounds rates to pass validation. The impact is potential acceptance of invalid exchange rates, leading to incorrect accruals or pauses.\n",
            "severity": "Informational",
            "location": [
                "AccountantWithRateProviders.sol#L205"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol",
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        }
    ],
    "affected_files": {
        "AccountantWithRateProviders.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { FixedPointMathLib } from \"@solmate/utils/FixedPointMathLib.sol\";\nimport { IRateProvider } from \"src/interfaces/IRateProvider.sol\";\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { BoringVault } from \"src/base/BoringVault.sol\";\nimport { Auth, Authority } from \"@solmate/auth/Auth.sol\";\n\n/**\n * @title AccountantWithRateProviders\n */\ncontract AccountantWithRateProviders is Auth, IRateProvider {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    // ========================================= STRUCTS =========================================\n\n    /**\n     * @param payoutAddress the address `claimFees` sends fees to\n     * @param feesOwedInBase total pending fees owed in terms of base\n     * @param totalSharesLastUpdate total amount of shares the last exchange rate update\n     * @param exchangeRate the current exchange rate in terms of base\n     * @param _allowedExchangeRateChangeUpper the max allowed change to exchange rate from an update\n     * @param _allowedExchangeRateChangeLower the min allowed change to exchange rate from an update\n     * @param _lastUpdateTimestamp the block timestamp of the last exchange rate update\n     * @param _isPaused whether or not this contract is paused\n     * @param _minimumUpdateDelayInSeconds the minimum amount of time that must pass between\n     *        exchange rate updates, such that the update won't trigger the contract to be paused\n     * @param _managementFee the management fee\n     */\n    struct AccountantState {\n        address _payoutAddress;\n        uint128 _feesOwedInBase;\n        uint128 _totalSharesLastUpdate;\n        uint96 _exchangeRate;\n        uint16 _allowedExchangeRateChangeUpper;\n        uint16 _allowedExchangeRateChangeLower;\n        uint64 _lastUpdateTimestamp;\n        bool _isPaused;\n        uint32 _minimumUpdateDelayInSeconds;\n        uint16 _managementFee;\n    }\n\n    /**\n     * @notice Lending specific state\n     * @param _lendingRate Annual lending interest rate in basis points (1000 = 10%)\n     * @param _lastAccrualTime Timestamp of last interest accrual\n     */\n    struct LendingInfo {\n        uint256 _lendingRate; // Rate for vault growth\n        uint256 _lastAccrualTime; // Last checkpoint\n    }\n\n    /**\n     * @param isPeggedToBase whether or not the asset is 1:1 with the base asset\n     * @param rateProvider the rate provider for this asset if `isPeggedToBase` is false\n     */\n    struct RateProviderData {\n        bool isPeggedToBase;\n        IRateProvider rateProvider;\n    }\n\n    // ========================================= CONSTANTS =========================================\n    // Constants for calculations\n    uint256 constant SECONDS_PER_YEAR = 365 days;\n    uint256 constant BASIS_POINTS = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /**\n     * @notice Store the accountant state in 3 packed slots.\n     */\n    AccountantState public accountantState;\n    LendingInfo public lendingInfo;\n    uint256 public maxLendingRate;\n\n    /**\n     * @notice Maps ERC20s to their RateProviderData.\n     */\n    mapping(ERC20 => RateProviderData) public rateProviderData;\n\n    //============================== ERRORS ===============================\n\n    error AccountantWithRateProviders__UpperBoundTooSmall();\n    error AccountantWithRateProviders__LowerBoundTooLarge();\n    error AccountantWithRateProviders__ManagementFeeTooLarge();\n    error AccountantWithRateProviders__Paused();\n    error AccountantWithRateProviders__ZeroFeesOwed();\n    error AccountantWithRateProviders__OnlyCallableByBoringVault();\n    error AccountantWithRateProviders__UpdateDelayTooLarge();\n    error AccountantWithRateProviders__UpperMustExceedLower();\n\n    //============================== EVENTS ===============================\n\n    event Paused();\n    event Unpaused();\n    event DelayInSecondsUpdated(uint32 oldDelay, uint32 newDelay);\n    event UpperBoundUpdated(uint16 oldBound, uint16 newBound);\n    event LowerBoundUpdated(uint16 oldBound, uint16 newBound);\n    event PayoutAddressUpdated(address oldPayout, address newPayout);\n    event RateProviderUpdated(address asset, bool isPegged, address rateProvider);\n    event ExchangeRateUpdated(uint96 oldRate, uint96 newRate, uint64 currentTime);\n    event FeesClaimed(address indexed feeAsset, uint256 amount);\n    event LendingRateUpdated(uint256 newRate, uint256 timestamp);\n    event ManagementFeeRateUpdated(uint16 newRate, uint256 timestamp);\n    event MaxLendingRateUpdated(uint256 newMaxRate);\n    event Checkpoint(uint256 indexed timestamp);\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The base asset rates are provided in.\n     */\n    ERC20 public immutable base;\n\n    /**\n     * @notice The decimals rates are provided in.\n     */\n    uint8 public immutable decimals;\n\n    /**\n     * @notice The BoringVault this accountant is working with.\n     *         Used to determine share supply for fee calculation.\n     */\n    BoringVault public immutable vault;\n\n    /**\n     * @notice One share of the BoringVault.\n     */\n    uint256 internal immutable ONE_SHARE;\n\n    constructor(\n        address _owner,\n        address _vault,\n        address _payoutAddress,\n        uint96 _startingExchangeRate,\n        address _base,\n        uint16 _allowedExchangeRateChangeUpper,\n        uint16 _allowedExchangeRateChangeLower,\n        uint32 _minimumUpdateDelayInSeconds,\n        uint16 _managementFee\n    )\n        Auth(_owner, Authority(address(0)))\n    {\n        base = ERC20(_base);\n        decimals = ERC20(_base).decimals();\n        vault = BoringVault(payable(_vault));\n        ONE_SHARE = 10 ** vault.decimals();\n        accountantState = AccountantState({\n            _payoutAddress: _payoutAddress,\n            _feesOwedInBase: 0,\n            _totalSharesLastUpdate: uint128(vault.totalSupply()),\n            _exchangeRate: _startingExchangeRate,\n            _allowedExchangeRateChangeUpper: _allowedExchangeRateChangeUpper,\n            _allowedExchangeRateChangeLower: _allowedExchangeRateChangeLower,\n            _lastUpdateTimestamp: uint64(block.timestamp),\n            _isPaused: false,\n            _minimumUpdateDelayInSeconds: _minimumUpdateDelayInSeconds,\n            _managementFee: _managementFee\n        });\n        lendingInfo._lastAccrualTime = block.timestamp;\n        maxLendingRate = 5000;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n    /**\n     * @notice Pause this contract, which prevents future calls to `updateExchangeRate`, and any safe rate\n     *         calls will revert.\n     * @dev Pausing only prevents state changes, not time-based calculations\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function pause() public requiresAuth {\n        accountantState._isPaused = true;\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpause this contract, which allows future calls to `updateExchangeRate`, and any safe rate\n     *         calls will stop reverting.\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function unpause() external requiresAuth {\n        accountantState._isPaused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @notice Update the minimum time delay between `updateExchangeRate` calls.\n     * @dev There are no input requirements, as it is possible the admin would want\n     *      the exchange rate updated as frequently as needed.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateDelay(uint32 _minimumUpdateDelayInSeconds) external requiresAuth {\n        if (_minimumUpdateDelayInSeconds > 14 days) revert AccountantWithRateProviders__UpdateDelayTooLarge();\n        uint32 oldDelay = accountantState._minimumUpdateDelayInSeconds;\n        accountantState._minimumUpdateDelayInSeconds = _minimumUpdateDelayInSeconds;\n        emit DelayInSecondsUpdated(oldDelay, _minimumUpdateDelayInSeconds);\n    }\n\n    /**\n     * @notice Update the allowed upper bound change of exchange rate between `updateExchangeRateCalls`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateUpper(uint16 _allowedExchangeRateChangeUpper) external requiresAuth {\n        if (_allowedExchangeRateChangeUpper <= accountantState._allowedExchangeRateChangeLower) {\n            revert AccountantWithRateProviders__UpperMustExceedLower();\n        }\n        if (_allowedExchangeRateChangeUpper < BASIS_POINTS) revert AccountantWithRateProviders__UpperBoundTooSmall();\n        uint16 oldBound = accountantState._allowedExchangeRateChangeUpper;\n        accountantState._allowedExchangeRateChangeUpper = _allowedExchangeRateChangeUpper;\n        emit UpperBoundUpdated(oldBound, _allowedExchangeRateChangeUpper);\n    }\n\n    /**\n     * @notice Update the allowed lower bound change of exchange rate between `updateExchangeRateCalls`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateLower(uint16 _allowedExchangeRateChangeLower) external requiresAuth {\n        if (_allowedExchangeRateChangeLower >= accountantState._allowedExchangeRateChangeUpper) {\n            revert AccountantWithRateProviders__UpperMustExceedLower();\n        }\n        if (_allowedExchangeRateChangeLower > BASIS_POINTS) revert AccountantWithRateProviders__LowerBoundTooLarge();\n        uint16 oldBound = accountantState._allowedExchangeRateChangeLower;\n        accountantState._allowedExchangeRateChangeLower = _allowedExchangeRateChangeLower;\n        emit LowerBoundUpdated(oldBound, _allowedExchangeRateChangeLower);\n    }\n\n    /**\n     * @notice Update the payout address fees are sent to.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updatePayoutAddress(address _payoutAddress) external requiresAuth {\n        address oldPayout = accountantState._payoutAddress;\n        accountantState._payoutAddress = _payoutAddress;\n        emit PayoutAddressUpdated(oldPayout, _payoutAddress);\n    }\n\n    /**\n     * @notice Update the rate provider data for a specific `asset`.\n     * @dev Rate providers must return rates in terms of `base`\n     * @dev Rate providers MUST ALWAYS return rates in 18 decimals regardless of asset decimals\n     * @dev The rate should represent how much base value 1 unit of asset is worth\n     * @dev Callable by OWNER_ROLE.\n     */\n    function setRateProviderData(ERC20 _asset, bool _isPeggedToBase, address _rateProvider) external requiresAuth {\n        rateProviderData[_asset] =\n            RateProviderData({ isPeggedToBase: _isPeggedToBase, rateProvider: IRateProvider(_rateProvider) });\n        emit RateProviderUpdated(address(_asset), _isPeggedToBase, _rateProvider);\n    }\n\n    // ========================================= UPDATE EXCHANGE RATE/FEES FUNCTIONS\n    // =========================================\n\n    /**\n     * @notice Updates this contract exchangeRate.\n     * @dev If new exchange rate is outside of accepted bounds, or if not enough time has passed, this\n     *      will pause the contract, and this function will NOT calculate fees owed.\n     * @dev Callable by UPDATE_EXCHANGE_RATE_ROLE.\n     */\n    function updateExchangeRate(uint96 _newExchangeRate) external requiresAuth {\n        AccountantState storage state = accountantState;\n\n        uint64 currentTime = uint64(block.timestamp);\n        (uint96 currentRateWithInterest,) = calculateExchangeRateWithInterest();\n\n        uint96 oldExchangeRate = state._exchangeRate;\n\n        _checkpointInterestAndFees();\n\n        uint256 currentTotalShares = vault.totalSupply();\n\n        if (\n            currentTime < state._lastUpdateTimestamp + state._minimumUpdateDelayInSeconds\n                || _newExchangeRate\n                    > uint256(currentRateWithInterest).mulDivDown(state._allowedExchangeRateChangeUpper, BASIS_POINTS)\n                || _newExchangeRate\n                    < uint256(currentRateWithInterest).mulDivDown(state._allowedExchangeRateChangeLower, BASIS_POINTS)\n        ) {\n            pause();\n        }\n\n        // Always update the rate and timestamp\n        state._exchangeRate = _newExchangeRate;\n        state._totalSharesLastUpdate = uint128(currentTotalShares);\n        state._lastUpdateTimestamp = currentTime;\n\n        emit ExchangeRateUpdated(oldExchangeRate, _newExchangeRate, currentTime);\n    }\n\n    /**\n     * @notice Set lending rate\n     * @dev Checkpoints current interest and management fees before changing rate\n     * @dev This prevents loss of accrued value when rate changes\n     * @param _lendingRate New lending rate in basis points (1000 = 10% APY)\n     */\n    function setLendingRate(uint256 _lendingRate) external requiresAuth {\n        require(_lendingRate <= maxLendingRate, \"Lending rate exceeds maximum\");\n\n        // Checkpoint both interest and fees before rate change\n        _checkpointInterestAndFees();\n\n        lendingInfo._lendingRate = _lendingRate;\n        emit LendingRateUpdated(_lendingRate, block.timestamp);\n    }\n\n    /**\n     * @notice Set management fee rate (requires checkpoint)\n     * @dev Checkpoints current management fees at old rate before changing\n     * @dev This ensures fees are correctly attributed to each rate period\n     * @param _managementFeeRate New management fee rate in basis points\n     */\n    function setManagementFeeRate(uint16 _managementFeeRate) external requiresAuth {\n        if (_managementFeeRate > 0.2e4) revert AccountantWithRateProviders__ManagementFeeTooLarge();\n        _checkpointInterestAndFees();\n\n        accountantState._managementFee = _managementFeeRate;\n        emit ManagementFeeRateUpdated(_managementFeeRate, block.timestamp);\n    }\n\n    /**\n     * @notice Set maximum lending rate\n     * @dev Callable by OWNER_ROLE\n     */\n    function setMaxLendingRate(uint256 _maxLendingRate) external requiresAuth {\n        _checkpointInterestAndFees();\n        maxLendingRate = _maxLendingRate;\n\n        // Adjust current rate if needed\n        if (lendingInfo._lendingRate > _maxLendingRate) {\n            lendingInfo._lendingRate = _maxLendingRate;\n            emit LendingRateUpdated(_maxLendingRate, block.timestamp);\n        }\n\n        emit MaxLendingRateUpdated(_maxLendingRate);\n    }\n\n    /**\n     * @notice Claim pending fees.\n     * @dev This function must be called by the BoringVault.\n     * @dev This function will lose precision if the exchange rate\n     *      decimals is greater than the _feeAsset's decimals.\n     */\n    function claimFees(ERC20 _feeAsset) external {\n        if (msg.sender != address(vault)) revert AccountantWithRateProviders__OnlyCallableByBoringVault();\n\n        AccountantState storage state = accountantState;\n        if (state._isPaused) revert AccountantWithRateProviders__Paused();\n\n        _checkpointInterestAndFees();\n\n        if (state._feesOwedInBase == 0) revert AccountantWithRateProviders__ZeroFeesOwed();\n\n        // Determine amount of fees owed in _feeAsset\n        uint256 feesOwedInFeeAsset;\n        RateProviderData memory data = rateProviderData[_feeAsset];\n        if (address(_feeAsset) == address(base)) {\n            feesOwedInFeeAsset = state._feesOwedInBase;\n        } else {\n            uint8 feeAssetDecimals = ERC20(_feeAsset).decimals();\n            uint256 feesOwedInBaseUsingFeeAssetDecimals =\n                _changeDecimals(state._feesOwedInBase, decimals, feeAssetDecimals);\n            if (data.isPeggedToBase) {\n                feesOwedInFeeAsset = feesOwedInBaseUsingFeeAssetDecimals;\n            } else {\n                uint256 rate = data.rateProvider.getRate();\n                feesOwedInFeeAsset = feesOwedInBaseUsingFeeAssetDecimals.mulDivDown(10 ** 18, rate);\n            }\n        }\n\n        // Zero out fees owed\n        state._feesOwedInBase = 0;\n\n        // Transfer fee asset to payout address\n        _feeAsset.safeTransferFrom(msg.sender, state._payoutAddress, feesOwedInFeeAsset);\n\n        emit FeesClaimed(address(_feeAsset), feesOwedInFeeAsset);\n    }\n\n    // ========================================= RATE FUNCTIONS =========================================\n\n    /**\n     * @notice Get this BoringVault's current rate in the base (real-time with interest).\n     */\n    function getRate() public view returns (uint256 rate) {\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n        return currentRate;\n    }\n\n    /**\n     * @notice Calculate current exchange rate including accrued interest\n     * @dev This is a view function - interest continues accruing even when paused\n     * @return newRate The exchange rate including accrued interest\n     * @return interestAccrued The amount of interest accrued since last checkpoint\n     */\n    function calculateExchangeRateWithInterest() public view returns (uint96 newRate, uint256 interestAccrued) {\n        newRate = accountantState._exchangeRate;\n\n        if (lendingInfo._lendingRate > 0) {\n            uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n\n            // Calculate rate increase in 18 decimals\n            uint256 rateIncrease = uint256(accountantState._exchangeRate).mulDivDown(\n                lendingInfo._lendingRate * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS\n            );\n            newRate = accountantState._exchangeRate + uint96(rateIncrease);\n\n            // Interest accrued is only for actual deposits\n            if (vault.totalSupply() > 0) {\n                // Calculate in 18 decimals, then convert to base decimals\n                uint256 totalDepositsIn18 = vault.totalSupply().mulDivDown(newRate, ONE_SHARE);\n                uint256 totalDeposits = _changeDecimals(totalDepositsIn18, 18, decimals);\n\n                interestAccrued =\n                    totalDeposits.mulDivDown(lendingInfo._lendingRate * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n            }\n        }\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     * @dev Revert if paused.\n     */\n    function getRateSafe() external view returns (uint256 rate) {\n        if (accountantState._isPaused) revert AccountantWithRateProviders__Paused();\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n        rate = currentRate;\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the provided quote.\n     * @dev `quote` must have its RateProviderData set, else this will revert.\n     * @dev This function will lose precision if the exchange rate\n     *      decimals is greater than the _quote's decimals.\n     */\n    function getRateInQuote(ERC20 _quote) public view returns (uint256 rateInQuote) {\n        // Get real-time rate in 18 decimals\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n\n        if (address(_quote) == address(base)) {\n            // Convert from 18 decimals to base decimals for display\n            rateInQuote = _changeDecimals(currentRate, 18, decimals);\n        } else {\n            RateProviderData memory data = rateProviderData[_quote];\n            uint8 quoteDecimals = ERC20(_quote).decimals();\n\n            if (data.isPeggedToBase) {\n                // Convert from 18 decimals to quote decimals\n                rateInQuote = _changeDecimals(currentRate, 18, quoteDecimals);\n            } else {\n                // Rate provider should return 18 decimals\n                uint256 quoteRate = data.rateProvider.getRate();\n                // Calculate: currentRate * 1e18 / quoteRate, then scale to quote decimals\n                uint256 rateInQuote18 = uint256(currentRate).mulDivDown(1e18, quoteRate);\n                rateInQuote = _changeDecimals(rateInQuote18, 18, quoteDecimals);\n            }\n        }\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the provided quote.\n     * @dev `quote` must have its RateProviderData set, else this will revert.\n     * @dev Revert if paused.\n     */\n    function getRateInQuoteSafe(ERC20 _quote) external view returns (uint256 rateInQuote) {\n        if (accountantState._isPaused) revert AccountantWithRateProviders__Paused();\n        rateInQuote = getRateInQuote(_quote);\n    }\n\n    /**\n     * @notice Get total rate paid by borrower\n     * @dev This is the sum of lending rate (for depositors) and management fee rate\n     * @return Total borrower rate in basis points\n     */\n    function getBorrowerRate() public view returns (uint256) {\n        return lendingInfo._lendingRate + accountantState._managementFee;\n    }\n\n    /**\n     * @notice Preview total management fees owed including unclaimed\n     * @dev Calculates real-time fees without modifying state\n     * @dev Includes both stored fees and fees accrued since last checkpoint\n     * @return totalFees Total management fees owed in base asset\n     */\n    function previewFeesOwed() external view returns (uint256 totalFees) {\n        totalFees = accountantState._feesOwedInBase;\n\n        if (vault.totalSupply() > 0 && accountantState._managementFee > 0) {\n            uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n\n            (uint96 currentRate,) = calculateExchangeRateWithInterest();\n            uint256 totalDepositsIn18 = vault.totalSupply().mulDivDown(currentRate, ONE_SHARE);\n            // Convert to base decimals for fee calculation\n            uint256 totalDeposits = _changeDecimals(totalDepositsIn18, 18, decimals);\n\n            uint256 managementFees =\n                totalDeposits.mulDivDown(accountantState._managementFee * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n            totalFees += managementFees;\n        }\n    }\n\n    // ========================================= INTERNAL HELPER FUNCTIONS =========================================\n    /**\n     * @notice Checkpoint both interest and management fees\n     * @dev Updates exchange rate with interest and feesOwedInBase with management fees\n     */\n    function _checkpointInterestAndFees() internal {\n        uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n        if (timeElapsed > 0) {\n            (uint96 newRate,) = calculateExchangeRateWithInterest();\n            accountantState._exchangeRate = newRate;\n\n            // Only calculate management fees when there are actual deposits\n            if (vault.totalSupply() > 0 && accountantState._managementFee > 0) {\n                // Calculate value in 18 decimals, then convert to base decimals for fee storage\n                uint256 totalValueIn18 = vault.totalSupply().mulDivDown(newRate, ONE_SHARE);\n                uint256 totalValue = _changeDecimals(totalValueIn18, 18, decimals);\n\n                uint256 managementFees =\n                    totalValue.mulDivDown(accountantState._managementFee * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n                accountantState._feesOwedInBase += uint128(managementFees);\n            }\n            lendingInfo._lastAccrualTime = block.timestamp;\n            emit Checkpoint(block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Updates the stored exchange rate and accrues management fees\n     * @dev Should be called before any operation that depends on the current exchange rate\n     * @dev This includes deposits, withdrawals, and fee calculations\n     * @dev Callable by authorized contracts (Teller) to ensure rate consistency\n     */\n    function checkpoint() external requiresAuth {\n        require(!accountantState._isPaused, \"Cannot checkpoint when paused\");\n        _checkpointInterestAndFees();\n    }\n\n    /**\n     * @notice Used to change the decimals of precision used for an amount.\n     */\n    function _changeDecimals(uint256 _amount, uint8 _fromDecimals, uint8 _toDecimals) internal pure returns (uint256) {\n        if (_fromDecimals == _toDecimals) {\n            return _amount;\n        } else if (_fromDecimals < _toDecimals) {\n            return _amount * 10 ** (_toDecimals - _fromDecimals);\n        } else {\n            return _amount / 10 ** (_fromDecimals - _toDecimals);\n        }\n    }\n}\n",
        "AtomicQueue.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.22;\n\nimport { FixedPointMathLib } from \"@solmate/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { ReentrancyGuard } from \"@solmate/utils/ReentrancyGuard.sol\";\nimport { IAtomicSolver } from \"./IAtomicSolver.sol\";\nimport { AccountantWithRateProviders } from \"../base/Roles/AccountantWithRateProviders.sol\";\n\n/**\n * @title AtomicQueue\n * @notice Allows users to create `AtomicRequests` that specify an ERC20 asset to `offer`\n *         and an ERC20 asset to `want` in return.\n * @notice Making atomic requests where the exchange rate between offer and want is not\n *         relatively stable is effectively the same as placing a limit order between\n *         those assets, so requests can be filled at a rate worse than the current market rate.\n * @notice It is possible for a user to make multiple requests that use the same offer asset.\n *         If this is done it is important that the user has approved the queue to spend the\n *         total amount of assets aggregated from all their requests, and to also have enough\n *         `offer` asset to cover the aggregate total request of `offerAmount`.\n * @author crispymangoes\n */\ncontract AtomicQueue is ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    // ========================================= STRUCTS =========================================\n\n    /**\n     * @notice Stores request information needed to fulfill a users atomic request.\n     * @param deadline unix timestamp for when request is no longer valid\n     * @param offerAmount the amount of `offer` asset the user wants converted to `want` asset\n     * @param inSolve bool used during solves to prevent duplicate users, and to prevent redoing multiple checks\n     */\n    struct AtomicRequest {\n        uint64 deadline; // deadline to fulfill request\n        uint96 offerAmount; // The amount of offer asset the user wants to sell.\n        bool inSolve; // Indicates whether this user is currently having their request fulfilled.\n    }\n\n    /**\n     * @notice Used in `viewSolveMetaData` helper function to return data in a clean struct.\n     * @param user the address of the user\n     * @param flags 8 bits indicating the state of the user only the first 4 bits are used XXXX0000\n     *              Either all flags are false(user is solvable) or only 1 is true(an error occurred).\n     *              From right to left\n     *              - 0: indicates user deadline has passed.\n     *              - 1: indicates user request has zero offer amount.\n     *              - 2: indicates user does not have enough offer asset in wallet.\n     *              - 3: indicates user has not given AtomicQueue approval.\n     * @param assetsToOffer the amount of offer asset to solve\n     * @param assetsForWant the amount of assets users want for their offer assets\n     */\n    struct SolveMetaData {\n        address user;\n        uint8 flags;\n        uint256 assetsToOffer;\n        uint256 assetsForWant;\n    }\n\n    // ========================================= GLOBAL STATE =========================================\n    AccountantWithRateProviders public immutable accountant;\n\n    /**\n     * @notice Maps user address to offer asset to want asset to a AtomicRequest struct.\n     */\n    mapping(address => mapping(ERC20 => mapping(ERC20 => AtomicRequest))) public userAtomicRequest;\n\n    //============================== ERRORS ===============================\n\n    error AtomicQueue__UserRepeated(address user);\n    error AtomicQueue__RequestDeadlineExceeded(address user);\n    error AtomicQueue__UserNotInSolve(address user);\n    error AtomicQueue__ZeroOfferAmount(address user);\n    error AtomicQueue__OnlyCallableInternally();\n\n    //============================== EVENTS ===============================\n\n    /**\n     * @notice Emitted when `updateAtomicRequest` is called.\n     */\n    event AtomicRequestUpdated(\n        address user,\n        address offerToken,\n        address wantToken,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minPrice,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when `solve` exchanges a users offer asset for their want asset.\n     */\n    event AtomicRequestFulfilled(\n        address user,\n        address offerToken,\n        address wantToken,\n        uint256 offerAmountSpent,\n        uint256 wantAmountReceived,\n        uint256 timestamp\n    );\n\n    //============================== CONSTRUCTOR ===============================\n\n    constructor(address _accountant) {\n        accountant = AccountantWithRateProviders(_accountant);\n    }\n\n    //============================== USER FUNCTIONS ===============================\n\n    /**\n     * @notice Get a users Atomic Request.\n     * @param user the address of the user to get the request for\n     * @param offer the ERC0 token they want to exchange for the want\n     * @param want the ERC20 token they want in exchange for the offer\n     */\n    function getUserAtomicRequest(address user, ERC20 offer, ERC20 want) external view returns (AtomicRequest memory) {\n        return userAtomicRequest[user][offer][want];\n    }\n\n    /**\n     * @notice Helper function that returns either\n     *         true: Withdraw request is valid.\n     *         false: Withdraw request is not valid.\n     * @dev It is possible for a withdraw request to return false from this function, but using the\n     *      request in `updateAtomicRequest` will succeed, but solvers will not be able to include\n     *      the user in `solve` unless some other state is changed.\n     * @param offer the ERC0 token they want to exchange for the want\n     * @param user the address of the user making the request\n     * @param userRequest the request struct to validate\n     */\n    function isAtomicRequestValid(\n        ERC20 offer,\n        address user,\n        AtomicRequest calldata userRequest\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (userRequest.offerAmount > offer.balanceOf(user)) return false;\n        if (block.timestamp > userRequest.deadline) return false;\n        if (offer.allowance(user, address(this)) < userRequest.offerAmount) return false;\n        if (userRequest.offerAmount == 0) return false;\n\n        return true;\n    }\n\n    /**\n     * @notice Allows user to add/update their withdraw request.\n     * @param offer the ERC20 token the user is offering in exchange for the want\n     * @param want the ERC20 token the user wants in exchange for offer\n     * @param deadline unix timestamp for when request is no longer valid\n     * @param offerAmount the amount of offer asset to exchange\n     */\n    function updateAtomicRequest(ERC20 offer, ERC20 want, uint64 deadline, uint96 offerAmount) external nonReentrant {\n        AtomicRequest storage request = userAtomicRequest[msg.sender][offer][want];\n\n        request.deadline = deadline;\n        request.offerAmount = offerAmount;\n\n        emit AtomicRequestUpdated(msg.sender, address(offer), address(want), offerAmount, deadline, 0, block.timestamp);\n    }\n\n    //============================== SOLVER FUNCTIONS ===============================\n\n    /**\n     * @notice Called by solvers in order to exchange offer asset for want asset.\n     * @notice Solvers are optimistically transferred the offer asset, then are required to\n     *         approve this contract to spend enough of want assets to cover all requests.\n     * @dev It is very likely `solve` TXs will be front run if broadcasted to public mem pools,\n     *      so solvers should use private mem pools.\n     * @param offer the ERC20 offer token to solve for\n     * @param want the ERC20 want token to solve for\n     * @param users an array of user addresses to solve for\n     * @param runData extra data that is passed back to solver when `finishSolve` is called\n     * @param solver the address to make `finishSolve` callback to\n     */\n    function solve(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users,\n        bytes calldata runData,\n        address solver\n    )\n        external\n        nonReentrant\n    {\n        (uint256 assetsToOffer, uint256 assetsForWant) = _prepareSolve(offer, want, users, solver);\n\n        IAtomicSolver(solver).finishSolve(runData, msg.sender, offer, want, assetsToOffer, assetsForWant);\n\n        _finalizeSolve(offer, want, users, solver);\n    }\n\n    //============================== INTERNAL HELPER FUNCTIONS ===============================\n    /**\n     * @notice New internal function to handle first phase of solve\n     * @dev Validates all user requests and transfers offer tokens to solver\n     * @dev Calculates total assets needed using current NAV from accountant\n     * @param offer the ERC20 offer token\n     * @param want the ERC20 want token\n     * @param users array of users to process\n     * @param solver the solver address receiving offer tokens\n     * @return assetsToOffer total offer tokens transferred to solver\n     * @return assetsForWant total want tokens solver needs to provide\n     */\n    function _prepareSolve(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users,\n        address solver\n    )\n        internal\n        returns (uint256 assetsToOffer, uint256 assetsForWant)\n    {\n        uint256 rate = accountant.getRateInQuoteSafe(want);\n        uint256 offerDecimals = 10 ** offer.decimals();\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest storage request = userAtomicRequest[users[i]][offer][want];\n\n            if (request.inSolve || block.timestamp > request.deadline || request.offerAmount == 0) {\n                continue;\n            }\n\n            try this.attemptTransfer(offer, users[i], solver, request.offerAmount) {\n                assetsForWant += rate.mulDivDown(request.offerAmount, offerDecimals);\n                assetsToOffer += request.offerAmount;\n                request.inSolve = true;\n            } catch {\n                continue;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to handle final phase of solve\n     * @dev Transfers want tokens from solver to users and cleans up state\n     * @dev Uses same NAV rate for all calculations to ensure consistency\n     * @param offer the ERC20 offer token\n     * @param want the ERC20 want token\n     * @param users array of users to process\n     * @param solver the solver address providing want tokens\n     */\n    function _finalizeSolve(ERC20 offer, ERC20 want, address[] calldata users, address solver) internal {\n        uint256 rate = accountant.getRateInQuoteSafe(want);\n        uint256 offerDecimals = 10 ** offer.decimals();\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest storage request = userAtomicRequest[users[i]][offer][want];\n\n            if (request.inSolve) {\n                uint256 amountOut = rate.mulDivDown(request.offerAmount, offerDecimals);\n\n                want.safeTransferFrom(solver, users[i], amountOut);\n\n                emit AtomicRequestFulfilled(\n                    users[i], address(offer), address(want), request.offerAmount, amountOut, block.timestamp\n                );\n\n                request.offerAmount = 0;\n                request.deadline = 0;\n                request.inSolve = false;\n            } else {\n                revert AtomicQueue__UserNotInSolve(users[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function solvers can use to determine if users are solvable, and the required amounts to do so.\n     * @notice Repeated users are not accounted for in this setup, so if solvers have repeat users in their `users`\n     *         array the results can be wrong.\n     * @dev Since a user can have multiple requests with the same offer asset but different want asset, it is\n     *      possible for `viewSolveMetaData` to report no errors, but for a solve to fail, if any solves were done\n     *      between the time `viewSolveMetaData` and before `solve` is called.\n     * @param offer the ERC20 offer token to check for solvability\n     * @param want the ERC20 want token to check for solvability\n     * @param users an array of user addresses to check for solvability\n     */\n    function viewSolveMetaData(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users\n    )\n        external\n        view\n        returns (SolveMetaData[] memory metaData, uint256 totalAssetsForWant, uint256 totalAssetsToOffer)\n    {\n        metaData = new SolveMetaData[](users.length);\n        uint256 rate = accountant.getRateInQuoteSafe(want);\n        uint256 offerDecimalsPow = 10 ** offer.decimals();\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest memory request = userAtomicRequest[users[i]][offer][want];\n            metaData[i].user = users[i];\n\n            if (block.timestamp > request.deadline) {\n                metaData[i].flags |= uint8(1);\n            }\n            if (request.offerAmount == 0) {\n                metaData[i].flags |= uint8(1) << 1;\n            }\n            if (offer.balanceOf(users[i]) < request.offerAmount) {\n                metaData[i].flags |= uint8(1) << 2;\n            }\n            if (offer.allowance(users[i], address(this)) < request.offerAmount) {\n                metaData[i].flags |= uint8(1) << 3;\n            }\n\n            metaData[i].assetsToOffer = request.offerAmount;\n            metaData[i].assetsForWant = rate.mulDivDown(request.offerAmount, offerDecimalsPow);\n\n            if (metaData[i].flags == 0) {\n                totalAssetsForWant += metaData[i].assetsForWant;\n                totalAssetsToOffer += request.offerAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice External helper function to enable try-catch with safeTransferFrom\n     * @dev Only callable by this contract itself\n     * @param token The ERC20 token to transfer\n     * @param from The address to transfer from\n     * @param to The address to transfer to\n     * @param amount The amount to transfer\n     */\n    function attemptTransfer(ERC20 token, address from, address to, uint256 amount) external {\n        if (msg.sender != address(this)) revert AtomicQueue__OnlyCallableInternally();\n        token.safeTransferFrom(from, to, amount);\n    }\n}\n",
        "dataset-curated/contracts/cantina_clearpool_aug2025.pdf-source/3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.22;\n\nimport { FixedPointMathLib } from \"@solmate/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { ReentrancyGuard } from \"@solmate/utils/ReentrancyGuard.sol\";\nimport { IAtomicSolver } from \"./IAtomicSolver.sol\";\nimport { AccountantWithRateProviders } from \"../base/Roles/AccountantWithRateProviders.sol\";\nimport { Auth, Authority } from \"@solmate/auth/Auth.sol\";\nimport { IRateProvider } from \"src/interfaces/IRateProvider.sol\";\n\n/**\n * @title AtomicQueue\n * @notice Allows users to create `AtomicRequests` that specify an ERC20 asset to `offer`\n *         and an ERC20 asset to `want` in return.\n * @notice Making atomic requests where the exchange rate between offer and want is not\n *         relatively stable is effectively the same as placing a limit order between\n *         those assets, so requests can be filled at a rate worse than the current market rate.\n * @notice It is possible for a user to make multiple requests that use the same offer asset.\n *         If this is done it is important that the user has approved the queue to spend the\n *         total amount of assets aggregated from all their requests, and to also have enough\n *         `offer` asset to cover the aggregate total request of `offerAmount`.\n * @author crispymangoes\n */\ncontract AtomicQueue is ReentrancyGuard, Auth {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    // ========================================= STRUCTS =========================================\n\n    /**\n     * @notice Stores request information needed to fulfill a users atomic request.\n     * @param deadline unix timestamp for when request is no longer valid\n     * @param offerAmount the amount of `offer` asset the user wants converted to `want` asset\n     * @param inSolve bool used during solves to prevent duplicate users, and to prevent redoing multiple checks\n     */\n    struct AtomicRequest {\n        uint64 deadline; // deadline to fulfill request\n        uint96 offerAmount; // The amount of offer asset the user wants to sell.\n        bool inSolve; // Indicates whether this user is currently having their request fulfilled.\n    }\n\n    /**\n     * @notice Used in `viewSolveMetaData` helper function to return data in a clean struct.\n     * @param user the address of the user\n     * @param flags 8 bits indicating the state of the user only the first 4 bits are used XXXX0000\n     *              Either all flags are false(user is solvable) or only 1 is true(an error occurred).\n     *              From right to left\n     *              - 0: indicates user deadline has passed.\n     *              - 1: indicates user request has zero offer amount.\n     *              - 2: indicates user does not have enough offer asset in wallet.\n     *              - 3: indicates user has not given AtomicQueue approval.\n     * @param assetsToOffer the amount of offer asset to solve\n     * @param assetsForWant the amount of assets users want for their offer assets\n     */\n    struct SolveMetaData {\n        address user;\n        uint8 flags;\n        uint256 assetsToOffer;\n        uint256 assetsForWant;\n    }\n\n    // ========================================= GLOBAL STATE =========================================\n    AccountantWithRateProviders public immutable accountant;\n\n    /**\n     * @notice Maps user address to offer asset to want asset to a AtomicRequest struct.\n     */\n    mapping(address => mapping(ERC20 => mapping(ERC20 => AtomicRequest))) public userAtomicRequest;\n\n    //============================== ERRORS ===============================\n\n    error AtomicQueue__UserRepeated(address user);\n    error AtomicQueue__RequestDeadlineExceeded(address user);\n    error AtomicQueue__UserNotInSolve(address user);\n    error AtomicQueue__ZeroOfferAmount(address user);\n    error AtomicQueue__OnlyCallableInternally();\n    error AtomicQueue__NoValidRequests();\n    error AtomicQueue__NoOutputExpected();\n    error AtomicQueue__ZeroOutputAmount();\n\n    //============================== EVENTS ===============================\n\n    /**\n     * @notice Emitted when `updateAtomicRequest` is called.\n     */\n    event AtomicRequestUpdated(\n        address user,\n        address offerToken,\n        address wantToken,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minPrice,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when `solve` exchanges a users offer asset for their want asset.\n     */\n    event AtomicRequestFulfilled(\n        address user,\n        address offerToken,\n        address wantToken,\n        uint256 offerAmountSpent,\n        uint256 wantAmountReceived,\n        uint256 timestamp\n    );\n\n    //============================== CONSTRUCTOR ===============================\n\n    constructor(address _accountant, address _owner, Authority _authority) Auth(_owner, _authority) {\n        accountant = AccountantWithRateProviders(_accountant);\n    }\n\n    //============================== USER FUNCTIONS ===============================\n\n    /**\n     * @notice Get a users Atomic Request.\n     * @param user the address of the user to get the request for\n     * @param offer the ERC0 token they want to exchange for the want\n     * @param want the ERC20 token they want in exchange for the offer\n     */\n    function getUserAtomicRequest(address user, ERC20 offer, ERC20 want) external view returns (AtomicRequest memory) {\n        return userAtomicRequest[user][offer][want];\n    }\n\n    /**\n     * @notice Helper function that returns either\n     *         true: Withdraw request is valid.\n     *         false: Withdraw request is not valid.\n     * @dev It is possible for a withdraw request to return false from this function, but using the\n     *      request in `updateAtomicRequest` will succeed, but solvers will not be able to include\n     *      the user in `solve` unless some other state is changed.\n     * @param offer the ERC0 token they want to exchange for the want\n     * @param user the address of the user making the request\n     * @param userRequest the request struct to validate\n     */\n    function isAtomicRequestValid(\n        ERC20 offer,\n        address user,\n        AtomicRequest calldata userRequest\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (userRequest.offerAmount > offer.balanceOf(user)) return false;\n        if (block.timestamp > userRequest.deadline) return false;\n        if (offer.allowance(user, address(this)) < userRequest.offerAmount) return false;\n        if (userRequest.offerAmount == 0) return false;\n\n        return true;\n    }\n\n    /**\n     * @notice Allows user to add/update their withdraw request.\n     * @param offer the ERC20 token the user is offering in exchange for the want\n     * @param want the ERC20 token the user wants in exchange for offer\n     * @param deadline unix timestamp for when request is no longer valid\n     * @param offerAmount the amount of offer asset to exchange\n     */\n    function updateAtomicRequest(ERC20 offer, ERC20 want, uint64 deadline, uint96 offerAmount) external nonReentrant {\n        AtomicRequest storage request = userAtomicRequest[msg.sender][offer][want];\n\n        request.deadline = deadline;\n        request.offerAmount = offerAmount;\n\n        emit AtomicRequestUpdated(msg.sender, address(offer), address(want), offerAmount, deadline, 0, block.timestamp);\n    }\n\n    //============================== SOLVER FUNCTIONS ===============================\n\n    /**\n     * @notice Called by solvers in order to exchange offer asset for want asset.\n     * @notice Solvers are optimistically transferred the offer asset, then are required to\n     *         approve this contract to spend enough of want assets to cover all requests.\n     * @dev It is very likely `solve` TXs will be front run if broadcasted to public mem pools,\n     *      so solvers should use private mem pools.\n     * @param offer the ERC20 offer token to solve for\n     * @param want the ERC20 want token to solve for\n     * @param users an array of user addresses to solve for\n     * @param runData extra data that is passed back to solver when `finishSolve` is called\n     * @param solver the address to make `finishSolve` callback to\n     */\n    function solve(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users,\n        bytes calldata runData,\n        address solver\n    )\n        external\n        requiresAuth\n        nonReentrant\n    {\n        (uint256 assetsToOffer, uint256 assetsForWant, uint256[] memory userWantAmounts) =\n            _prepareSolve(offer, want, users, solver);\n\n        IAtomicSolver(solver).finishSolve(runData, msg.sender, offer, want, assetsToOffer, assetsForWant);\n\n        _finalizeSolve(offer, want, users, solver, userWantAmounts);\n    }\n\n    //============================== INTERNAL HELPER FUNCTIONS ===============================\n    /**\n     * @notice New internal function to handle first phase of solve\n     * @dev Validates all user requests and transfers offer tokens to solver\n     * @dev Calculates total assets needed using current NAV from accountant\n     * @param offer the ERC20 offer token\n     * @param want the ERC20 want token\n     * @param users array of users to process\n     * @param solver the solver address receiving offer tokens\n     * @return assetsToOffer total offer tokens transferred to solver\n     * @return assetsForWant total want tokens solver needs to provide\n     */\n    function _prepareSolve(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users,\n        address solver\n    )\n        internal\n        returns (uint256 assetsToOffer, uint256 assetsForWant, uint256[] memory userWantAmounts)\n    {\n        userWantAmounts = new uint256[](users.length);\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest storage request = userAtomicRequest[users[i]][offer][want];\n\n            if (request.inSolve) revert AtomicQueue__UserRepeated(users[i]);\n            if (block.timestamp > request.deadline) revert AtomicQueue__RequestDeadlineExceeded(users[i]);\n            if (request.offerAmount == 0) revert AtomicQueue__ZeroOfferAmount(users[i]);\n\n            uint256 wantAmount = _calculateWantAmount(offer, want, request.offerAmount);\n\n            if (wantAmount == 0) revert AtomicQueue__ZeroOutputAmount();\n\n            // Store the calculated amount for this user\n            userWantAmounts[i] = wantAmount;\n            assetsForWant += wantAmount;\n            assetsToOffer += request.offerAmount;\n            request.inSolve = true;\n\n            offer.safeTransferFrom(users[i], solver, request.offerAmount);\n        }\n\n        // Final checks\n        if (assetsToOffer == 0) revert AtomicQueue__NoValidRequests();\n        if (assetsForWant == 0) revert AtomicQueue__NoOutputExpected();\n    }\n\n    function _finalizeSolve(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users,\n        address solver,\n        uint256[] memory userWantAmounts\n    )\n        internal\n    {\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest storage request = userAtomicRequest[users[i]][offer][want];\n\n            if (!request.inSolve) revert AtomicQueue__UserNotInSolve(users[i]);\n\n            // Use pre-calculated amount\n            uint256 amountOut = userWantAmounts[i];\n\n            want.safeTransferFrom(solver, users[i], amountOut);\n\n            emit AtomicRequestFulfilled(\n                users[i], address(offer), address(want), request.offerAmount, amountOut, block.timestamp\n            );\n\n            request.offerAmount = 0;\n            request.deadline = 0;\n            request.inSolve = false;\n        }\n    }\n\n    /**\n     * @notice Helper function solvers can use to determine if users are solvable, and the required amounts to do so.\n     * @notice Repeated users are not accounted for in this setup, so if solvers have repeat users in their `users`\n     *         array the results can be wrong.\n     * @dev Since a user can have multiple requests with the same offer asset but different want asset, it is\n     *      possible for `viewSolveMetaData` to report no errors, but for a solve to fail, if any solves were done\n     *      between the time `viewSolveMetaData` and before `solve` is called.\n     * @param offer the ERC20 offer token to check for solvability\n     * @param want the ERC20 want token to check for solvability\n     * @param users an array of user addresses to check for solvability\n     */\n    function viewSolveMetaData(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users\n    )\n        external\n        view\n        returns (SolveMetaData[] memory metaData, uint256 totalAssetsForWant, uint256 totalAssetsToOffer)\n    {\n        metaData = new SolveMetaData[](users.length);\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest memory request = userAtomicRequest[users[i]][offer][want];\n            metaData[i].user = users[i];\n\n            if (block.timestamp > request.deadline) {\n                metaData[i].flags |= uint8(1);\n            }\n            if (request.offerAmount == 0) {\n                metaData[i].flags |= uint8(1) << 1;\n            }\n            if (offer.balanceOf(users[i]) < request.offerAmount) {\n                metaData[i].flags |= uint8(1) << 2;\n            }\n            if (offer.allowance(users[i], address(this)) < request.offerAmount) {\n                metaData[i].flags |= uint8(1) << 3;\n            }\n\n            metaData[i].assetsToOffer = request.offerAmount;\n\n            if (request.offerAmount > 0) {\n                metaData[i].assetsForWant = _calculateWantAmount(offer, want, request.offerAmount);\n            }\n\n            if (metaData[i].flags == 0) {\n                totalAssetsForWant += metaData[i].assetsForWant;\n                totalAssetsToOffer += request.offerAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Convert asset amount to 18 decimal value\n     */\n    function _convertAssetToValue18(ERC20 asset, uint256 amount) internal view returns (uint256) {\n        if (address(asset) == address(accountant.base())) {\n            return _changeDecimals(amount, accountant.decimals(), 18);\n        }\n\n        (bool isPegged,) = accountant.rateProviderData(asset);\n        if (isPegged) {\n            return _changeDecimals(amount, asset.decimals(), 18);\n        } else {\n            (, IRateProvider rateProvider) = accountant.rateProviderData(asset);\n            uint256 rate = rateProvider.getRate();\n            return amount.mulDivDown(rate, 10 ** asset.decimals());\n        }\n    }\n\n    /**\n     * @notice Convert 18 decimal value to asset amount\n     */\n    function _convertValue18ToAsset(ERC20 asset, uint256 valueIn18) internal view returns (uint256) {\n        if (address(asset) == address(accountant.base())) {\n            return _changeDecimals(valueIn18, 18, accountant.decimals());\n        }\n\n        (bool isPegged,) = accountant.rateProviderData(asset);\n        if (isPegged) {\n            return _changeDecimals(valueIn18, 18, asset.decimals());\n        } else {\n            (, IRateProvider rateProvider) = accountant.rateProviderData(asset);\n            uint256 rate = rateProvider.getRate();\n            return valueIn18.mulDivDown(10 ** asset.decimals(), rate);\n        }\n    }\n\n    /**\n     * @notice Helper to change decimals\n     */\n    function _changeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) return amount;\n        if (fromDecimals < toDecimals) {\n            return amount * 10 ** (toDecimals - fromDecimals);\n        } else {\n            return amount / 10 ** (fromDecimals - toDecimals);\n        }\n    }\n\n    /**\n     * @notice Calculate want amount for a given offer amount\n     * @dev Single source of truth for swap calculations used by both _prepareSolve and viewSolveMetaData\n     * @param offer the ERC20 offer token\n     * @param want the ERC20 want token\n     * @param offerAmount the amount of offer tokens\n     * @return wantAmount the calculated want amount\n     */\n    function _calculateWantAmount(\n        ERC20 offer,\n        ERC20 want,\n        uint256 offerAmount\n    )\n        internal\n        view\n        returns (uint256 wantAmount)\n    {\n        uint256 rate = accountant.getRate(); // Rate is in 18 decimals\n\n        if (address(offer) == address(accountant.vault())) {\n            // Withdrawing: vault shares -> asset\n            uint8 vaultDecimals = ERC20(address(offer)).decimals();\n            uint256 sharesIn18 = _changeDecimals(offerAmount, vaultDecimals, 18);\n            uint256 valueIn18 = sharesIn18.mulDivDown(rate, 1e18);\n            wantAmount = _convertValue18ToAsset(want, valueIn18);\n        } else if (address(want) == address(accountant.vault())) {\n            // Depositing: asset -> vault shares\n            uint8 vaultDecimals = ERC20(address(want)).decimals();\n            uint256 valueIn18 = _convertAssetToValue18(offer, offerAmount);\n            uint256 sharesIn18 = valueIn18.mulDivDown(1e18, rate);\n            wantAmount = _changeDecimals(sharesIn18, 18, vaultDecimals);\n        } else {\n            // Swap: asset -> asset (through value)\n            uint256 valueIn18 = _convertAssetToValue18(offer, offerAmount);\n            wantAmount = _convertValue18ToAsset(want, valueIn18);\n        }\n    }\n}\n",
        "TellerWithMultiAssetSupport.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { WETH } from \"@solmate/tokens/WETH.sol\";\nimport { BoringVault } from \"src/base/BoringVault.sol\";\nimport { AccountantWithRateProviders } from \"src/base/Roles/AccountantWithRateProviders.sol\";\nimport { FixedPointMathLib } from \"@solmate/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { BeforeTransferHook } from \"src/interfaces/BeforeTransferHook.sol\";\nimport { Auth, Authority } from \"@solmate/auth/Auth.sol\";\nimport { ReentrancyGuard } from \"@solmate/utils/ReentrancyGuard.sol\";\nimport { IKeyring } from \"src/interfaces/IKeyring.sol\";\nimport { IRateProvider } from \"src/interfaces/IRateProvider.sol\";\n\n/**\n * @title TellerWithMultiAssetSupport\n */\ncontract TellerWithMultiAssetSupport is Auth, BeforeTransferHook, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for WETH;\n\n    // ========================================= CONSTANTS =========================================\n\n    /**\n     * @notice Native address used to tell the contract to handle native asset deposits.\n     */\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /**\n     * @notice The maximum possible share lock period.\n     */\n    uint256 internal constant MAX_SHARE_LOCK_PERIOD = 3 days;\n\n    // ========================================= STATE =========================================\n\n    uint256 public depositCap;\n    /**\n     * @notice Mapping ERC20s to an isSupported bool.\n     */\n    mapping(ERC20 => bool) public isSupported;\n\n    /**\n     * @notice The deposit nonce used to map to a deposit hash.\n     */\n    uint96 public depositNonce = 1;\n\n    /**\n     * @notice After deposits, shares are locked to the msg.sender's address\n     *         for `shareLockPeriod`.\n     * @dev During this time all transfers from msg.sender will revert, and\n     *      deposits are refundable.\n     */\n    uint64 public shareLockPeriod;\n\n    /**\n     * @notice Used to pause calls to `deposit` and `depositWithPermit`.\n     */\n    bool public isPaused;\n\n    /**\n     * @dev Maps deposit nonce to keccak256(address receiver, address _depositAsset, uint256 _depositAmount, uint256\n     * _shareAmount, uint256 _timestamp, uint256 _shareLockPeriod).\n     */\n    mapping(uint256 => bytes32) public publicDepositHistory;\n\n    /**\n     * @notice Maps user address to the time their shares will be unlocked.\n     */\n    mapping(address => uint256) public shareUnlockTime;\n\n    /**\n     * @notice Access control mode for the vault\n     */\n    enum AccessControlMode {\n        DISABLED,\n        KEYRING_KYC,\n        MANUAL_WHITELIST\n    }\n\n    /**\n     * @notice Current access control mode\n     */\n    AccessControlMode public accessControlMode;\n\n    /**\n     * @notice Keyring contract interface\n     */\n    IKeyring public keyringContract;\n\n    /**\n     * @notice Keyring policy ID to check against\n     */\n    uint256 public keyringPolicyId;\n\n    /**\n     * @notice Manual whitelist for addresses when in MANUAL_WHITELIST mode\n     */\n    mapping(address => bool) public manualWhitelist;\n\n    /**\n     * @notice Whitelist for smart contracts (AMMs, protocols) that work in both modes\n     */\n    mapping(address => bool) public contractWhitelist;\n\n    //============================== ERRORS ===============================\n\n    error TellerWithMultiAssetSupport__ShareLockPeriodTooLong();\n    error TellerWithMultiAssetSupport__SharesAreLocked();\n    error TellerWithMultiAssetSupport__SharesAreUnLocked();\n    error TellerWithMultiAssetSupport__BadDepositHash();\n    error TellerWithMultiAssetSupport__AssetNotSupported();\n    error TellerWithMultiAssetSupport__ZeroAssets();\n    error TellerWithMultiAssetSupport__MinimumMintNotMet();\n    error TellerWithMultiAssetSupport__MinimumAssetsNotMet();\n    error TellerWithMultiAssetSupport__PermitFailedAndAllowanceTooLow();\n    error TellerWithMultiAssetSupport__ZeroShares();\n    error TellerWithMultiAssetSupport__Paused();\n    error TellerWithMultiAssetSupport__KeyringCredentialInvalid();\n    error TellerWithMultiAssetSupport__NotWhitelisted();\n\n    //============================== EVENTS ===============================\n\n    event Paused();\n    event Unpaused();\n    event AssetAdded(address indexed asset);\n    event AssetRemoved(address indexed asset);\n    event Deposit(\n        uint256 indexed nonce,\n        address indexed receiver,\n        address indexed _depositAsset,\n        uint256 _depositAmount,\n        uint256 _shareAmount,\n        uint256 depositTimestamp,\n        uint256 shareLockPeriodAtTimeOfDeposit\n    );\n    event BulkDeposit(address indexed asset, uint256 _depositAmount);\n    event BulkWithdraw(address indexed asset, uint256 _shareAmount);\n    event DepositRefunded(uint256 indexed nonce, bytes32 depositHash, address indexed user);\n    event DepositCapUpdated(uint256 oldCap, uint256 newCap);\n    event AccessControlModeUpdated(AccessControlMode oldMode, AccessControlMode newMode);\n    event KeyringConfigUpdated(address keyringContract, uint256 policyId);\n    event ManualWhitelistUpdated(address indexed account, bool status);\n    event ContractWhitelistUpdated(address indexed account, bool status);\n    event ShareLockPeriodUpdated(uint64 oldPeriod, uint64 newPeriod);\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The BoringVault this contract is working with.\n     */\n    BoringVault public immutable vault;\n\n    /**\n     * @notice The AccountantWithRateProviders this contract is working with.\n     */\n    AccountantWithRateProviders public immutable accountant;\n\n    /**\n     * @notice One share of the BoringVault.\n     */\n    uint256 internal immutable ONE_SHARE;\n\n    /**\n     * @notice Check if an address has access to mint/redeem\n     * @param _entity The address to check\n     */\n    modifier checkAccess(address _entity) {\n        if (accessControlMode == AccessControlMode.KEYRING_KYC) {\n            if (!contractWhitelist[_entity] && address(keyringContract) != address(0)) {\n                if (!keyringContract.checkCredential(keyringPolicyId, _entity)) {\n                    revert TellerWithMultiAssetSupport__KeyringCredentialInvalid();\n                }\n            }\n        } else if (accessControlMode == AccessControlMode.MANUAL_WHITELIST) {\n            if (!manualWhitelist[_entity] && !contractWhitelist[_entity]) {\n                revert TellerWithMultiAssetSupport__NotWhitelisted();\n            }\n        }\n        // If DISABLED, no checks performed\n        _;\n    }\n\n    constructor(address _owner, address _vault, address _accountant) Auth(_owner, Authority(address(0))) {\n        vault = BoringVault(payable(_vault));\n        ONE_SHARE = 10 ** vault.decimals();\n        accountant = AccountantWithRateProviders(_accountant);\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n    function setDepositCap(uint256 _depositCap) external requiresAuth {\n        uint256 oldCap = depositCap;\n        depositCap = _depositCap;\n        emit DepositCapUpdated(oldCap, _depositCap);\n    }\n\n    /**\n     * @notice Pause this contract, which prevents future calls to `deposit` and `depositWithPermit`.\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function pause() external requiresAuth {\n        isPaused = true;\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpause this contract, which allows future calls to `deposit` and `depositWithPermit`.\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function unpause() external requiresAuth {\n        isPaused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @notice Adds this asset as a deposit asset.\n     * @dev The accountant must also support pricing this asset, else the `deposit` call will revert.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function addAsset(ERC20 _asset) external requiresAuth {\n        isSupported[_asset] = true;\n        emit AssetAdded(address(_asset));\n    }\n\n    /**\n     * @notice Removes this asset as a deposit asset.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function removeAsset(ERC20 _asset) external requiresAuth {\n        isSupported[_asset] = false;\n        emit AssetRemoved(address(_asset));\n    }\n\n    /**\n     * @notice Sets the share lock period.\n     * @dev This not only locks shares to the user address, but also serves as the pending deposit period, where\n     * deposits can be reverted.\n     * @dev If a new shorter share lock period is set, users with pending share locks could make a new deposit to\n     * receive 1 wei shares,\n     *      and have their shares unlock sooner than their original deposit allows. This state would allow for the user\n     * deposit to be refunded,\n     *      but only if they have not transferred their shares out of there wallet. This is an accepted limitation, and\n     * should be known when decreasing\n     *      the share lock period.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function setShareLockPeriod(uint64 _shareLockPeriod) external requiresAuth {\n        if (_shareLockPeriod > MAX_SHARE_LOCK_PERIOD) revert TellerWithMultiAssetSupport__ShareLockPeriodTooLong();\n\n        uint64 oldPeriod = shareLockPeriod;\n        shareLockPeriod = _shareLockPeriod;\n\n        emit ShareLockPeriodUpdated(oldPeriod, _shareLockPeriod);\n    }\n\n    /**\n     * @notice Sets the access control mode\n     * @dev Callable by OWNER_ROLE\n     */\n    function setAccessControlMode(AccessControlMode _mode) external requiresAuth {\n        emit AccessControlModeUpdated(accessControlMode, _mode);\n        accessControlMode = _mode;\n    }\n\n    /**\n     * @notice Configure Keyring integration\n     * @dev Callable by OWNER_ROLE\n     */\n    function setKeyringConfig(address _keyringContract, uint256 _policyId) external requiresAuth {\n        keyringContract = IKeyring(_keyringContract);\n        keyringPolicyId = _policyId;\n        emit KeyringConfigUpdated(_keyringContract, _policyId);\n    }\n\n    /**\n     * @notice Update manual whitelist\n     * @dev Callable by OWNER_ROLE\n     */\n    function updateManualWhitelist(address[] calldata _addresses, bool _status) external requiresAuth {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            manualWhitelist[_addresses[i]] = _status;\n            emit ManualWhitelistUpdated(_addresses[i], _status);\n        }\n    }\n\n    /**\n     * @notice Update contract whitelist (for AMMs, protocols)\n     * @dev Callable by OWNER_ROLE\n     */\n    function updateContractWhitelist(address[] calldata _addresses, bool _status) external requiresAuth {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            contractWhitelist[_addresses[i]] = _status;\n            emit ContractWhitelistUpdated(_addresses[i], _status);\n        }\n    }\n\n    // ========================================= BeforeTransferHook FUNCTIONS =========================================\n\n    /**\n     * @notice Implement beforeTransfer hook to check if shares are locked.\n     */\n    function beforeTransfer(address _from) public view {\n        if (shareUnlockTime[_from] > block.timestamp) revert TellerWithMultiAssetSupport__SharesAreLocked();\n    }\n\n    // ========================================= REVERT DEPOSIT FUNCTIONS =========================================\n\n    /**\n     * @notice Allows DEPOSIT_REFUNDER_ROLE to revert a pending deposit.\n     * @dev Once a deposit share lock period has passed, it can no longer be reverted.\n     * @dev It is possible the admin does not setup the BoringVault to call the transfer hook,\n     *      but this contract can still be saving share lock state. In the event this happens\n     *      deposits are still refundable if the user has not transferred their shares.\n     *      But there is no guarantee that the user has not transferred their shares.\n     * @dev Callable by STRATEGIST_MULTISIG_ROLE.\n     */\n    function refundDeposit(\n        uint256 _nonce,\n        address _receiver,\n        address _depositAsset,\n        uint256 _depositAmount,\n        uint256 _shareAmount,\n        uint256 _depositTimestamp,\n        uint256 _shareLockUpPeriodAtTimeOfDeposit\n    )\n        external\n        requiresAuth\n    {\n        if ((block.timestamp - _depositTimestamp) > _shareLockUpPeriodAtTimeOfDeposit) {\n            // Shares are already unlocked, so we can not revert deposit.\n            revert TellerWithMultiAssetSupport__SharesAreUnLocked();\n        }\n        bytes32 depositHash = keccak256(\n            abi.encode(\n                _receiver,\n                _depositAsset,\n                _depositAmount,\n                _shareAmount,\n                _depositTimestamp,\n                _shareLockUpPeriodAtTimeOfDeposit\n            )\n        );\n        if (publicDepositHistory[_nonce] != depositHash) revert TellerWithMultiAssetSupport__BadDepositHash();\n\n        // Delete hash to prevent refund gas.\n        delete publicDepositHistory[_nonce];\n\n        accountant.checkpoint();\n\n        // Burn shares and refund assets to receiver.\n        vault.exit(_receiver, ERC20(_depositAsset), _depositAmount, _receiver, _shareAmount);\n\n        emit DepositRefunded(_nonce, depositHash, _receiver);\n    }\n\n    // ========================================= USER FUNCTIONS =========================================\n\n    /**\n     * @notice Allows users to deposit into the BoringVault, if this contract is not paused.\n     * @dev Publicly callable.\n     */\n    function deposit(\n        ERC20 _depositAsset,\n        uint256 _depositAmount,\n        uint256 _minimumMint\n    )\n        external\n        requiresAuth\n        nonReentrant\n        checkAccess(msg.sender)\n        returns (uint256 shares)\n    {\n        if (isPaused) revert TellerWithMultiAssetSupport__Paused();\n        if (!isSupported[_depositAsset]) revert TellerWithMultiAssetSupport__AssetNotSupported();\n\n        shares = _erc20Deposit(_depositAsset, _depositAmount, _minimumMint, msg.sender);\n\n        _afterPublicDeposit(msg.sender, _depositAsset, _depositAmount, shares, shareLockPeriod);\n    }\n\n    /**\n     * @notice Allows users to deposit into BoringVault using permit.\n     * @dev Publicly callable.\n     */\n    function depositWithPermit(\n        ERC20 _depositAsset,\n        uint256 _depositAmount,\n        uint256 _minimumMint,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        requiresAuth\n        nonReentrant\n        checkAccess(msg.sender)\n        returns (uint256 shares)\n    {\n        if (isPaused) revert TellerWithMultiAssetSupport__Paused();\n        if (!isSupported[_depositAsset]) revert TellerWithMultiAssetSupport__AssetNotSupported();\n\n        // solhint-disable-next-line no-empty-blocks\n        try _depositAsset.permit(msg.sender, address(vault), _depositAmount, _deadline, _v, _r, _s) { }\n        catch {\n            if (_depositAsset.allowance(msg.sender, address(vault)) < _depositAmount) {\n                revert TellerWithMultiAssetSupport__PermitFailedAndAllowanceTooLow();\n            }\n        }\n        shares = _erc20Deposit(_depositAsset, _depositAmount, _minimumMint, msg.sender);\n\n        _afterPublicDeposit(msg.sender, _depositAsset, _depositAmount, shares, shareLockPeriod);\n    }\n\n    /**\n     * @notice Allows on ramp role to deposit into this contract.\n     * @dev Does NOT support native deposits.\n     * @dev Callable by SOLVER_ROLE.\n     */\n    function bulkDeposit(\n        ERC20 _depositAsset,\n        uint256 _depositAmount,\n        uint256 _minimumMint,\n        address _to\n    )\n        external\n        requiresAuth\n        nonReentrant\n        checkAccess(_to)\n        returns (uint256 shares)\n    {\n        if (!isSupported[_depositAsset]) revert TellerWithMultiAssetSupport__AssetNotSupported();\n\n        shares = _erc20Deposit(_depositAsset, _depositAmount, _minimumMint, _to);\n        emit BulkDeposit(address(_depositAsset), _depositAmount);\n    }\n\n    /**\n     * @notice Allows off ramp role to withdraw from this contract.\n     * @dev Callable by SOLVER_ROLE.\n     */\n    function bulkWithdraw(\n        ERC20 _withdrawAsset,\n        uint256 _shareAmount,\n        uint256 _minimumAssets,\n        address _to\n    )\n        external\n        requiresAuth\n        checkAccess(msg.sender)\n        returns (uint256 assetsOut)\n    {\n        if (!isSupported[_withdrawAsset]) revert TellerWithMultiAssetSupport__AssetNotSupported();\n        if (_shareAmount == 0) revert TellerWithMultiAssetSupport__ZeroShares();\n\n        accountant.checkpoint();\n\n        // Get exchange rate in 18 decimals\n        uint256 rate = accountant.getRate();\n\n        // Calculate value in 18 decimals\n        uint256 withdrawValueIn18 = _shareAmount.mulDivDown(rate, ONE_SHARE);\n\n        // Convert to asset amount based on asset type\n        if (address(_withdrawAsset) == address(accountant.base())) {\n            // Base asset - convert from 18 to base decimals\n            assetsOut = _changeDecimals(withdrawValueIn18, 18, accountant.decimals());\n        } else {\n            (bool isPegged,) = accountant.rateProviderData(_withdrawAsset);\n\n            if (isPegged) {\n                // Pegged asset - convert from 18 to asset decimals\n                assetsOut = _changeDecimals(withdrawValueIn18, 18, _withdrawAsset.decimals());\n            } else {\n                // Non-pegged asset - use rate provider\n                (, IRateProvider rateProvider) = accountant.rateProviderData(_withdrawAsset);\n                uint256 assetRate = rateProvider.getRate();\n                assetsOut = withdrawValueIn18.mulDivDown(10 ** _withdrawAsset.decimals(), assetRate);\n            }\n        }\n\n        if (assetsOut < _minimumAssets) revert TellerWithMultiAssetSupport__MinimumAssetsNotMet();\n\n        vault.exit(_to, _withdrawAsset, assetsOut, msg.sender, _shareAmount);\n        emit BulkWithdraw(address(_withdrawAsset), _shareAmount);\n    }\n\n    // ========================================= INTERNAL HELPER FUNCTIONS =========================================\n\n    /**\n     * @notice Implements a common ERC20 deposit into BoringVault.\n     */\n    function _erc20Deposit(\n        ERC20 _depositAsset,\n        uint256 _depositAmount,\n        uint256 _minimumMint,\n        address _to\n    )\n        internal\n        returns (uint256 shares)\n    {\n        if (_depositAmount == 0) revert TellerWithMultiAssetSupport__ZeroAssets();\n\n        accountant.checkpoint();\n\n        // Get exchange rate in 18 decimals\n        uint256 rate = accountant.getRate();\n\n        // Convert deposit amount to 18 decimal value based on asset type\n        uint256 depositValueIn18;\n\n        if (address(_depositAsset) == address(accountant.base())) {\n            // Base asset - convert to 18 decimals\n            depositValueIn18 = _changeDecimals(_depositAmount, accountant.decimals(), 18);\n        } else {\n            (bool isPegged,) = accountant.rateProviderData(_depositAsset);\n\n            if (isPegged) {\n                // Pegged asset - convert to 18 decimals (1:1 with base)\n                depositValueIn18 = _changeDecimals(_depositAmount, _depositAsset.decimals(), 18);\n            } else {\n                // Non-pegged asset - use rate provider\n                (, IRateProvider rateProvider) = accountant.rateProviderData(_depositAsset);\n                uint256 assetRate = rateProvider.getRate();\n                depositValueIn18 = _depositAmount.mulDivDown(assetRate, 10 ** _depositAsset.decimals());\n            }\n        }\n\n        // Calculate shares using 18 decimal values\n        shares = depositValueIn18.mulDivDown(ONE_SHARE, rate);\n\n        if (shares < _minimumMint) revert TellerWithMultiAssetSupport__MinimumMintNotMet();\n\n        uint256 shareValueInBase = shares.mulDivDown(rate, ONE_SHARE);\n        // Convert to base decimals for cap check\n        shareValueInBase = _changeDecimals(shareValueInBase, 18, accountant.decimals());\n        uint256 currentTotalValue = vault.totalSupply().mulDivDown(rate, ONE_SHARE);\n        currentTotalValue = _changeDecimals(currentTotalValue, 18, accountant.decimals());\n\n        require(currentTotalValue + shareValueInBase <= depositCap, \"Deposit cap exceeded\");\n\n        vault.enter(msg.sender, _depositAsset, _depositAmount, _to, shares);\n    }\n\n    /**\n     * @notice Handle share lock logic, and event.\n     */\n    function _afterPublicDeposit(\n        address _user,\n        ERC20 _depositAsset,\n        uint256 _depositAmount,\n        uint256 _shares,\n        uint256 _currentShareLockPeriod\n    )\n        internal\n    {\n        shareUnlockTime[_user] = block.timestamp + _currentShareLockPeriod;\n\n        uint256 nonce = depositNonce;\n        publicDepositHistory[nonce] = keccak256(\n            abi.encode(_user, _depositAsset, _depositAmount, _shares, block.timestamp, _currentShareLockPeriod)\n        );\n        depositNonce++;\n        emit Deposit(\n            nonce, _user, address(_depositAsset), _depositAmount, _shares, block.timestamp, _currentShareLockPeriod\n        );\n    }\n\n    /**\n     * @notice Internal helper to change decimals\n     */\n    function _changeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) return amount;\n        if (fromDecimals < toDecimals) {\n            return amount * 10 ** (toDecimals - fromDecimals);\n        } else {\n            return amount / 10 ** (fromDecimals - toDecimals);\n        }\n    }\n}\n",
        "dataset-curated/contracts/cantina_clearpool_aug2025.pdf-source/cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { FixedPointMathLib } from \"@solmate/utils/FixedPointMathLib.sol\";\nimport { IRateProvider } from \"src/interfaces/IRateProvider.sol\";\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { BoringVault } from \"src/base/BoringVault.sol\";\nimport { Auth, Authority } from \"@solmate/auth/Auth.sol\";\n\n/**\n * @title AccountantWithRateProviders\n */\ncontract AccountantWithRateProviders is Auth, IRateProvider {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    // ========================================= STRUCTS =========================================\n\n    /**\n     * @param payoutAddress the address `claimFees` sends fees to\n     * @param feesOwedInBase total pending fees owed in terms of base\n     * @param totalSharesLastUpdate total amount of shares the last exchange rate update\n     * @param exchangeRate the current exchange rate in terms of base\n     * @param _allowedExchangeRateChangeUpper the max allowed change to exchange rate from an update\n     * @param _allowedExchangeRateChangeLower the min allowed change to exchange rate from an update\n     * @param _lastUpdateTimestamp the block timestamp of the last exchange rate update\n     * @param _isPaused whether or not this contract is paused\n     * @param _minimumUpdateDelayInSeconds the minimum amount of time that must pass between\n     *        exchange rate updates, such that the update won't trigger the contract to be paused\n     * @param _managementFee the management fee\n     */\n    struct AccountantState {\n        address _payoutAddress;\n        uint128 _feesOwedInBase;\n        uint128 _totalSharesLastUpdate;\n        uint96 _exchangeRate;\n        uint16 _allowedExchangeRateChangeUpper;\n        uint16 _allowedExchangeRateChangeLower;\n        uint64 _lastUpdateTimestamp;\n        bool _isPaused;\n        uint32 _minimumUpdateDelayInSeconds;\n        uint16 _managementFee;\n    }\n\n    /**\n     * @notice Lending specific state\n     * @param _lendingRate Annual lending interest rate in basis points (1000 = 10%)\n     * @param _lastAccrualTime Timestamp of last interest accrual\n     */\n    struct LendingInfo {\n        uint256 _lendingRate; // Rate for vault growth\n        uint256 _lastAccrualTime; // Last checkpoint\n    }\n\n    /**\n     * @param isPeggedToBase whether or not the asset is 1:1 with the base asset\n     * @param rateProvider the rate provider for this asset if `isPeggedToBase` is false\n     */\n    struct RateProviderData {\n        bool isPeggedToBase;\n        IRateProvider rateProvider;\n    }\n\n    // ========================================= CONSTANTS =========================================\n    // Constants for calculations\n    uint256 constant SECONDS_PER_YEAR = 365 days;\n    uint256 constant BASIS_POINTS = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /**\n     * @notice Store the accountant state in 3 packed slots.\n     */\n    AccountantState public accountantState;\n    LendingInfo public lendingInfo;\n    uint256 public maxLendingRate;\n\n    /**\n     * @notice Maps ERC20s to their RateProviderData.\n     */\n    mapping(ERC20 => RateProviderData) public rateProviderData;\n\n    //============================== ERRORS ===============================\n\n    error AccountantWithRateProviders__UpperBoundTooSmall();\n    error AccountantWithRateProviders__LowerBoundTooLarge();\n    error AccountantWithRateProviders__ManagementFeeTooLarge();\n    error AccountantWithRateProviders__Paused();\n    error AccountantWithRateProviders__ZeroFeesOwed();\n    error AccountantWithRateProviders__OnlyCallableByBoringVault();\n    error AccountantWithRateProviders__UpdateDelayTooLarge();\n    error AccountantWithRateProviders__UpperMustExceedLower();\n\n    //============================== EVENTS ===============================\n\n    event Paused();\n    event Unpaused();\n    event DelayInSecondsUpdated(uint32 oldDelay, uint32 newDelay);\n    event UpperBoundUpdated(uint16 oldBound, uint16 newBound);\n    event LowerBoundUpdated(uint16 oldBound, uint16 newBound);\n    event PayoutAddressUpdated(address oldPayout, address newPayout);\n    event RateProviderUpdated(address asset, bool isPegged, address rateProvider);\n    event ExchangeRateUpdated(uint96 oldRate, uint96 newRate, uint64 currentTime);\n    event FeesClaimed(address indexed feeAsset, uint256 amount);\n    event LendingRateUpdated(uint256 newRate, uint256 timestamp);\n    event ManagementFeeRateUpdated(uint16 newRate, uint256 timestamp);\n    event MaxLendingRateUpdated(uint256 newMaxRate);\n    event Checkpoint(uint256 indexed timestamp);\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The base asset rates are provided in.\n     */\n    ERC20 public immutable base;\n\n    /**\n     * @notice The decimals rates are provided in.\n     */\n    uint8 public immutable decimals;\n\n    /**\n     * @notice The BoringVault this accountant is working with.\n     *         Used to determine share supply for fee calculation.\n     */\n    BoringVault public immutable vault;\n\n    /**\n     * @notice One share of the BoringVault.\n     */\n    uint256 internal immutable ONE_SHARE;\n\n    constructor(\n        address _owner,\n        address _vault,\n        address _payoutAddress,\n        uint96 _startingExchangeRate,\n        address _base,\n        uint16 _allowedExchangeRateChangeUpper,\n        uint16 _allowedExchangeRateChangeLower,\n        uint32 _minimumUpdateDelayInSeconds,\n        uint16 _managementFee\n    )\n        Auth(_owner, Authority(address(0)))\n    {\n        base = ERC20(_base);\n        decimals = ERC20(_base).decimals();\n        vault = BoringVault(payable(_vault));\n        ONE_SHARE = 10 ** vault.decimals();\n        accountantState = AccountantState({\n            _payoutAddress: _payoutAddress,\n            _feesOwedInBase: 0,\n            _totalSharesLastUpdate: uint128(vault.totalSupply()),\n            _exchangeRate: _startingExchangeRate,\n            _allowedExchangeRateChangeUpper: _allowedExchangeRateChangeUpper,\n            _allowedExchangeRateChangeLower: _allowedExchangeRateChangeLower,\n            _lastUpdateTimestamp: uint64(block.timestamp),\n            _isPaused: false,\n            _minimumUpdateDelayInSeconds: _minimumUpdateDelayInSeconds,\n            _managementFee: _managementFee\n        });\n        lendingInfo._lastAccrualTime = block.timestamp;\n        maxLendingRate = 5000;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n    /**\n     * @notice Pause this contract, which prevents future calls to `updateExchangeRate`, and any safe rate\n     *         calls will revert.\n     * @dev Pausing only prevents state changes, not time-based calculations\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function pause() public requiresAuth {\n        accountantState._isPaused = true;\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpause this contract, which allows future calls to `updateExchangeRate`, and any safe rate\n     *         calls will stop reverting.\n     * @dev Callable by MULTISIG_ROLE.\n     */\n    function unpause() external requiresAuth {\n        accountantState._isPaused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @notice Update the minimum time delay between `updateExchangeRate` calls.\n     * @dev There are no input requirements, as it is possible the admin would want\n     *      the exchange rate updated as frequently as needed.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateDelay(uint32 _minimumUpdateDelayInSeconds) external requiresAuth {\n        if (_minimumUpdateDelayInSeconds > 14 days) revert AccountantWithRateProviders__UpdateDelayTooLarge();\n        uint32 oldDelay = accountantState._minimumUpdateDelayInSeconds;\n        accountantState._minimumUpdateDelayInSeconds = _minimumUpdateDelayInSeconds;\n        emit DelayInSecondsUpdated(oldDelay, _minimumUpdateDelayInSeconds);\n    }\n\n    /**\n     * @notice Update the allowed upper bound change of exchange rate between `updateExchangeRateCalls`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateUpper(uint16 _allowedExchangeRateChangeUpper) external requiresAuth {\n        if (_allowedExchangeRateChangeUpper <= accountantState._allowedExchangeRateChangeLower) {\n            revert AccountantWithRateProviders__UpperMustExceedLower();\n        }\n        if (_allowedExchangeRateChangeUpper < BASIS_POINTS) revert AccountantWithRateProviders__UpperBoundTooSmall();\n        uint16 oldBound = accountantState._allowedExchangeRateChangeUpper;\n        accountantState._allowedExchangeRateChangeUpper = _allowedExchangeRateChangeUpper;\n        emit UpperBoundUpdated(oldBound, _allowedExchangeRateChangeUpper);\n    }\n\n    /**\n     * @notice Update the allowed lower bound change of exchange rate between `updateExchangeRateCalls`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updateLower(uint16 _allowedExchangeRateChangeLower) external requiresAuth {\n        if (_allowedExchangeRateChangeLower >= accountantState._allowedExchangeRateChangeUpper) {\n            revert AccountantWithRateProviders__UpperMustExceedLower();\n        }\n        if (_allowedExchangeRateChangeLower > BASIS_POINTS) revert AccountantWithRateProviders__LowerBoundTooLarge();\n        uint16 oldBound = accountantState._allowedExchangeRateChangeLower;\n        accountantState._allowedExchangeRateChangeLower = _allowedExchangeRateChangeLower;\n        emit LowerBoundUpdated(oldBound, _allowedExchangeRateChangeLower);\n    }\n\n    /**\n     * @notice Update the payout address fees are sent to.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function updatePayoutAddress(address _payoutAddress) external requiresAuth {\n        address oldPayout = accountantState._payoutAddress;\n        accountantState._payoutAddress = _payoutAddress;\n        emit PayoutAddressUpdated(oldPayout, _payoutAddress);\n    }\n\n    /**\n     * @notice Update the rate provider data for a specific `asset`.\n     * @dev Rate providers must return rates in terms of `base` or\n     * an asset pegged to base and they must use the same decimals\n     * as `asset`.\n     * @dev Callable by OWNER_ROLE.\n     */\n    function setRateProviderData(ERC20 _asset, bool _isPeggedToBase, address _rateProvider) external requiresAuth {\n        rateProviderData[_asset] =\n            RateProviderData({ isPeggedToBase: _isPeggedToBase, rateProvider: IRateProvider(_rateProvider) });\n        emit RateProviderUpdated(address(_asset), _isPeggedToBase, _rateProvider);\n    }\n\n    // ========================================= UPDATE EXCHANGE RATE/FEES FUNCTIONS\n    // =========================================\n\n    /**\n     * @notice Updates this contract exchangeRate.\n     * @dev If new exchange rate is outside of accepted bounds, or if not enough time has passed, this\n     *      will pause the contract, and this function will NOT calculate fees owed.\n     * @dev Callable by UPDATE_EXCHANGE_RATE_ROLE.\n     */\n    function updateExchangeRate(uint96 _newExchangeRate) external requiresAuth {\n        AccountantState storage state = accountantState;\n\n        uint64 currentTime = uint64(block.timestamp);\n        (uint96 currentRateWithInterest,) = calculateExchangeRateWithInterest();\n\n        uint96 oldExchangeRate = state._exchangeRate;\n\n        _checkpointInterestAndFees();\n\n        uint256 currentTotalShares = vault.totalSupply();\n\n        if (\n            currentTime < state._lastUpdateTimestamp + state._minimumUpdateDelayInSeconds\n                || _newExchangeRate\n                    > uint256(currentRateWithInterest).mulDivDown(state._allowedExchangeRateChangeUpper, BASIS_POINTS)\n                || _newExchangeRate\n                    < uint256(currentRateWithInterest).mulDivDown(state._allowedExchangeRateChangeLower, BASIS_POINTS)\n        ) {\n            pause();\n        }\n\n        // Always update the rate and timestamp\n        state._exchangeRate = _newExchangeRate;\n        state._totalSharesLastUpdate = uint128(currentTotalShares);\n        state._lastUpdateTimestamp = currentTime;\n\n        emit ExchangeRateUpdated(oldExchangeRate, _newExchangeRate, currentTime);\n    }\n\n    /**\n     * @notice Set lending rate\n     * @dev Checkpoints current interest and management fees before changing rate\n     * @dev This prevents loss of accrued value when rate changes\n     * @param _lendingRate New lending rate in basis points (1000 = 10% APY)\n     */\n    function setLendingRate(uint256 _lendingRate) external requiresAuth {\n        require(_lendingRate <= maxLendingRate, \"Lending rate exceeds maximum\");\n\n        // Checkpoint both interest and fees before rate change\n        _checkpointInterestAndFees();\n\n        lendingInfo._lendingRate = _lendingRate;\n        emit LendingRateUpdated(_lendingRate, block.timestamp);\n    }\n\n    /**\n     * @notice Set management fee rate (requires checkpoint)\n     * @dev Checkpoints current management fees at old rate before changing\n     * @dev This ensures fees are correctly attributed to each rate period\n     * @param _managementFeeRate New management fee rate in basis points\n     */\n    function setManagementFeeRate(uint16 _managementFeeRate) external requiresAuth {\n        if (_managementFeeRate > 0.2e4) revert AccountantWithRateProviders__ManagementFeeTooLarge();\n        _checkpointInterestAndFees();\n\n        accountantState._managementFee = _managementFeeRate;\n        emit ManagementFeeRateUpdated(_managementFeeRate, block.timestamp);\n    }\n\n    /**\n     * @notice Set maximum lending rate\n     * @dev Callable by OWNER_ROLE\n     */\n    function setMaxLendingRate(uint256 _maxLendingRate) external requiresAuth {\n        _checkpointInterestAndFees();\n        maxLendingRate = _maxLendingRate;\n\n        // Adjust current rate if needed\n        if (lendingInfo._lendingRate > _maxLendingRate) {\n            lendingInfo._lendingRate = _maxLendingRate;\n            emit LendingRateUpdated(_maxLendingRate, block.timestamp);\n        }\n\n        emit MaxLendingRateUpdated(_maxLendingRate);\n    }\n\n    /**\n     * @notice Claim pending fees.\n     * @dev This function must be called by the BoringVault.\n     * @dev This function will lose precision if the exchange rate\n     *      decimals is greater than the _feeAsset's decimals.\n     */\n    function claimFees(ERC20 _feeAsset) external {\n        if (msg.sender != address(vault)) revert AccountantWithRateProviders__OnlyCallableByBoringVault();\n\n        AccountantState storage state = accountantState;\n        if (state._isPaused) revert AccountantWithRateProviders__Paused();\n\n        _checkpointInterestAndFees();\n\n        if (state._feesOwedInBase == 0) revert AccountantWithRateProviders__ZeroFeesOwed();\n\n        // Determine amount of fees owed in _feeAsset\n        uint256 feesOwedInFeeAsset;\n        RateProviderData memory data = rateProviderData[_feeAsset];\n        if (address(_feeAsset) == address(base)) {\n            feesOwedInFeeAsset = state._feesOwedInBase;\n        } else {\n            uint8 feeAssetDecimals = ERC20(_feeAsset).decimals();\n            uint256 feesOwedInBaseUsingFeeAssetDecimals =\n                _changeDecimals(state._feesOwedInBase, decimals, feeAssetDecimals);\n            if (data.isPeggedToBase) {\n                feesOwedInFeeAsset = feesOwedInBaseUsingFeeAssetDecimals;\n            } else {\n                uint256 rate = data.rateProvider.getRate();\n                feesOwedInFeeAsset = feesOwedInBaseUsingFeeAssetDecimals.mulDivDown(10 ** feeAssetDecimals, rate);\n            }\n        }\n\n        // Zero out fees owed\n        state._feesOwedInBase = 0;\n\n        // Transfer fee asset to payout address\n        _feeAsset.safeTransferFrom(msg.sender, state._payoutAddress, feesOwedInFeeAsset);\n\n        emit FeesClaimed(address(_feeAsset), feesOwedInFeeAsset);\n    }\n\n    // ========================================= RATE FUNCTIONS =========================================\n\n    /**\n     * @notice Get this BoringVault's current rate in the base (real-time with interest).\n     */\n    function getRate() public view returns (uint256 rate) {\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n        return currentRate;\n    }\n\n    /**\n     * @notice Calculate current exchange rate including accrued interest\n     * @dev This is a view function - interest continues accruing even when paused\n     * @return newRate The exchange rate including accrued interest\n     * @return interestAccrued The amount of interest accrued since last checkpoint\n     */\n    function calculateExchangeRateWithInterest() public view returns (uint96 newRate, uint256 interestAccrued) {\n        newRate = accountantState._exchangeRate;\n\n        if (lendingInfo._lendingRate > 0) {\n            uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n\n            // always update the rate (even when TVL = 0)\n            uint256 rateIncrease = uint256(accountantState._exchangeRate).mulDivDown(\n                lendingInfo._lendingRate * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS\n            );\n            newRate = accountantState._exchangeRate + uint96(rateIncrease);\n\n            // Interest accrued is only for actual deposits\n            if (vault.totalSupply() > 0) {\n                uint256 totalDeposits = vault.totalSupply().mulDivDown(accountantState._exchangeRate, ONE_SHARE);\n                interestAccrued =\n                    totalDeposits.mulDivDown(lendingInfo._lendingRate * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n            }\n        }\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     * @dev Revert if paused.\n     */\n    function getRateSafe() external view returns (uint256 rate) {\n        if (accountantState._isPaused) revert AccountantWithRateProviders__Paused();\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n        rate = currentRate;\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the provided quote.\n     * @dev `quote` must have its RateProviderData set, else this will revert.\n     * @dev This function will lose precision if the exchange rate\n     *      decimals is greater than the _quote's decimals.\n     */\n    function getRateInQuote(ERC20 _quote) public view returns (uint256 rateInQuote) {\n        // Get real-time rate first\n        (uint96 currentRate,) = calculateExchangeRateWithInterest();\n\n        if (address(_quote) == address(base)) {\n            rateInQuote = currentRate;\n        } else {\n            RateProviderData memory data = rateProviderData[_quote];\n            uint8 quoteDecimals = ERC20(_quote).decimals();\n            uint256 exchangeRateInQuoteDecimals = _changeDecimals(currentRate, decimals, quoteDecimals);\n            if (data.isPeggedToBase) {\n                rateInQuote = exchangeRateInQuoteDecimals;\n            } else {\n                uint256 quoteRate = data.rateProvider.getRate();\n                uint256 oneQuote = 10 ** quoteDecimals;\n                rateInQuote = oneQuote.mulDivDown(exchangeRateInQuoteDecimals, quoteRate);\n            }\n        }\n    }\n\n    /**\n     * @notice Get this BoringVault's current rate in the provided quote.\n     * @dev `quote` must have its RateProviderData set, else this will revert.\n     * @dev Revert if paused.\n     */\n    function getRateInQuoteSafe(ERC20 _quote) external view returns (uint256 rateInQuote) {\n        if (accountantState._isPaused) revert AccountantWithRateProviders__Paused();\n        rateInQuote = getRateInQuote(_quote);\n    }\n\n    /**\n     * @notice Get total rate paid by borrower\n     * @dev This is the sum of lending rate (for depositors) and management fee rate\n     * @return Total borrower rate in basis points\n     */\n    function getBorrowerRate() public view returns (uint256) {\n        return lendingInfo._lendingRate + accountantState._managementFee;\n    }\n\n    /**\n     * @notice Preview total management fees owed including unclaimed\n     * @dev Calculates real-time fees without modifying state\n     * @dev Includes both stored fees and fees accrued since last checkpoint\n     * @return totalFees Total management fees owed in base asset\n     */\n    function previewFeesOwed() external view returns (uint256 totalFees) {\n        totalFees = accountantState._feesOwedInBase;\n\n        if (vault.totalSupply() > 0 && accountantState._managementFee > 0) {\n            uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n\n            // Use current rate including interest\n            (uint96 currentRate,) = calculateExchangeRateWithInterest();\n            uint256 totalDeposits = vault.totalSupply().mulDivDown(currentRate, ONE_SHARE);\n\n            uint256 managementFees =\n                totalDeposits.mulDivDown(accountantState._managementFee * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n            totalFees += managementFees;\n        }\n    }\n\n    // ========================================= INTERNAL HELPER FUNCTIONS =========================================\n    /**\n     * @notice Checkpoint both interest and management fees\n     * @dev Updates exchange rate with interest and feesOwedInBase with management fees\n     */\n    function _checkpointInterestAndFees() internal {\n        uint256 timeElapsed = block.timestamp - lendingInfo._lastAccrualTime;\n        if (timeElapsed > 0) {\n            (uint96 newRate,) = calculateExchangeRateWithInterest();\n            accountantState._exchangeRate = newRate;\n\n            // Only calculate management fees when there are actual deposits\n            if (vault.totalSupply() > 0 && accountantState._managementFee > 0) {\n                uint256 totalValue = vault.totalSupply().mulDivDown(newRate, ONE_SHARE);\n                uint256 managementFees =\n                    totalValue.mulDivDown(accountantState._managementFee * timeElapsed, SECONDS_PER_YEAR * BASIS_POINTS);\n                accountantState._feesOwedInBase += uint128(managementFees);\n            }\n            lendingInfo._lastAccrualTime = block.timestamp;\n            emit Checkpoint(block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Updates the stored exchange rate and accrues management fees\n     * @dev Should be called before any operation that depends on the current exchange rate\n     * @dev This includes deposits, withdrawals, and fee calculations\n     * @dev Callable by authorized contracts (Teller) to ensure rate consistency\n     */\n    function checkpoint() external requiresAuth {\n        require(!accountantState._isPaused, \"Cannot checkpoint when paused\");\n        _checkpointInterestAndFees();\n    }\n\n    /**\n     * @notice Used to change the decimals of precision used for an amount.\n     */\n    function _changeDecimals(uint256 _amount, uint8 _fromDecimals, uint8 _toDecimals) internal pure returns (uint256) {\n        if (_fromDecimals == _toDecimals) {\n            return _amount;\n        } else if (_fromDecimals < _toDecimals) {\n            return _amount * 10 ** (_toDecimals - _fromDecimals);\n        } else {\n            return _amount / 10 ** (_fromDecimals - _toDecimals);\n        }\n    }\n}\n"
    }
}