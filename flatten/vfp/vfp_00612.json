{
    "vfp_id": "vfp_00612",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "State Variable Visibility Not Explicitly Declared",
            "description": "State variables are declared without explicit visibility keywords, relying on Solidity's default behavior. The cause is omission of `private` or `internal` keywords. This can lead to confusion about access control and may result in unintended exposure if the default changes in future versions. The impact is reduced code clarity and potential future vulnerabilities if assumptions about visibility are incorrect.\n",
            "severity": null,
            "location": [
                "SavingFxUSD.sol::fxSAVE#26",
                "SpotPriceOracleBase.sol::spotPriceOracle#30"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/SavingFxUSD.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Hardcoded Addresses",
            "description": "The `SavingFxUSD.sol` contract contains hardcoded addresses (e.g., `0xAffe966B27ba3E4Ebb8A0eC124C7b7019CC762f8` and `0x365AccFCa291e7D3914637ABf1F7635dB165Bb09`) that are not configurable. The cause is direct address embedding in the source code. This reduces deployment flexibility across different networks and increases the risk of deploying with incorrect addresses. If the contract is deployed on a new network without address updates, it may interact with wrong or malicious contracts. The impact includes potential fund loss, broken functionality, and the need for costly redeployments.\n",
            "severity": null,
            "location": [
                "SavingFxUSD.sol#70",
                "SavingFxUSD.sol#73"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/SavingFxUSD.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Multiple Contract Declarations Per File",
            "description": "The `SavingFxUSD.sol` file contains two contract declarations, which can reduce code organization and clarity. The cause is combining multiple contracts in one file. This makes the code harder to navigate and maintain. The impact is reduced readability and potential confusion about contract boundaries.\n",
            "severity": null,
            "location": [
                "SavingFxUSD.sol"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/SavingFxUSD.sol"
            ]
        }
    ],
    "affected_files": {
        "SavingFxUSD.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport { ERC4626Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IMultipleRewardDistributor } from \"../common/rewards/distributor/IMultipleRewardDistributor.sol\";\nimport { IHarvesterCallback } from \"../helpers/interfaces/IHarvesterCallback.sol\";\nimport { IConvexFXNBooster } from \"../interfaces/Convex/IConvexFXNBooster.sol\";\nimport { IStakingProxyERC20 } from \"../interfaces/Convex/IStakingProxyERC20.sol\";\nimport { IFxUSDBasePool } from \"../interfaces/IFxUSDBasePool.sol\";\nimport { ISavingFxUSD } from \"../interfaces/ISavingFxUSD.sol\";\nimport { ILiquidityGauge } from \"../voting-escrow/interfaces/ILiquidityGauge.sol\";\n\nimport { WordCodec } from \"../common/codec/WordCodec.sol\";\nimport { ConcentratorBase } from \"../common/concentrator/ConcentratorBase.sol\";\n\ncontract LockedFxSaveProxy {\n  address immutable fxSAVE;\n\n  error ErrorCallerNotFxSave();\n\n  constructor() {\n    fxSAVE = msg.sender;\n  }\n\n  function execute(address target, bytes calldata data) external {\n    if (msg.sender != fxSAVE) revert ErrorCallerNotFxSave();\n\n    (bool success, ) = target.call(data);\n    // below lines will propagate inner error up\n    if (!success) {\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        let ptr := mload(0x40)\n        let size := returndatasize()\n        returndatacopy(ptr, 0, size)\n        revert(ptr, size)\n      }\n    }\n  }\n}\n\ncontract SavingFxUSD is ERC20PermitUpgradeable, ERC4626Upgradeable, ConcentratorBase, ISavingFxUSD {\n  using SafeERC20 for IERC20;\n  using WordCodec for bytes32;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when the threshold exceeds `MAX_THRESHOLD`.\n  error ErrorThresholdTooLarge();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The role for `claimFor` function.\n  bytes32 public constant CLAIM_FOR_ROLE = keccak256(\"CLAIM_FOR_ROLE\");\n\n  /// @dev The address of Convex's f(x) Booster contract.\n  address private constant BOOSTER = 0xAffe966B27ba3E4Ebb8A0eC124C7b7019CC762f8;\n\n  /// @dev The address of FXN token.\n  address private constant FXN = 0x365AccFCa291e7D3914637ABf1F7635dB165Bb09;\n\n  /// @dev The denominator used for precision calculation.\n  uint256 private constant PRECISION = 1e18;\n\n  /// @dev The number of bits for threshold.\n  uint256 private constant THRESHOLD_BITS = 80;\n\n  /// @dev The offset of threshold in `_miscData`.\n  uint256 private constant THRESHOLD_OFFSET = 60;\n  \n  /// @dev The maximum value of threshold, 2^80-1.\n  uint256 private constant MAX_THRESHOLD = 1208925819614629174706175;\n\n  /***********************\n   * Immutable Variables *\n   ***********************/\n\n  /// @notice The address of `FxUSDBasePool` contract.\n  address public immutable base;\n\n  /// @notice The address of `FxUSDBasePool` gauge contract.\n  address public immutable gauge;\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @notice The address of Convex's `StakingProxyERC20` contract.\n  address public vault;\n\n  /// @notice Mapping from user address to `LockedFxSaveProxy` contract.\n  mapping(address => address) public lockedProxy;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  struct InitializationParameters {\n    string name;\n    string symbol;\n    uint256 pid;\n    uint256 threshold;\n    address treasury;\n    address harvester;\n  }\n\n  constructor(address _base, address _gauge) {\n    base = _base;\n    gauge = _gauge;\n  }\n\n  function initialize(address admin, InitializationParameters memory params) external initializer {\n    __Context_init();\n    __ERC165_init();\n    __AccessControl_init();\n\n    __ERC20_init(params.name, params.symbol);\n    __ERC20Permit_init(params.name);\n    __ERC4626_init(IERC20(base));\n\n    __ConcentratorBase_init(params.treasury, params.harvester);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n    vault = IConvexFXNBooster(BOOSTER).createVault(params.pid);\n    _updateThreshold(params.threshold);\n\n    IERC20(base).forceApprove(gauge, type(uint256).max);\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc ERC4626Upgradeable\n  function decimals() public view virtual override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8) {\n    return ERC4626Upgradeable.decimals();\n  }\n\n  /// @inheritdoc ERC4626Upgradeable\n  function totalAssets() public view virtual override returns (uint256) {\n    return IERC20(base).balanceOf(address(this)) + IERC20(gauge).balanceOf(vault);\n  }\n\n  /// @notice Return the threshold for batch deposit.\n  function getThreshold() public view returns (uint256) {\n    return _miscData.decodeUint(THRESHOLD_OFFSET, THRESHOLD_BITS);\n  }\n\n  /// @inheritdoc ISavingFxUSD\n  function nav() external view returns (uint256) {\n    return (IFxUSDBasePool(base).nav() * convertToAssets(PRECISION)) / PRECISION;\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc ISavingFxUSD\n  function depositGauge(uint256 assets, address receiver) external returns (uint256) {\n    uint256 maxAssets = maxDeposit(receiver);\n    if (assets > maxAssets) {\n      revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n    }\n\n    uint256 shares = previewDeposit(assets);\n\n    IERC20(gauge).safeTransferFrom(_msgSender(), vault, assets);\n    _mint(receiver, shares);\n\n    emit Deposit(_msgSender(), receiver, assets, shares);\n\n    return shares;\n  }\n\n  /// @inheritdoc ISavingFxUSD\n  function requestRedeem(uint256 shares) external returns (uint256) {\n    address owner = _msgSender();\n    uint256 maxShares = maxRedeem(owner);\n    if (shares > maxShares) {\n      revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n    }\n\n    uint256 assets = previewRedeem(shares);\n    _requestRedeem(owner, assets, shares);\n\n    return assets;\n  }\n\n  /// @inheritdoc ISavingFxUSD\n  function claim(address receiver) external {\n    _claim(_msgSender(), receiver);\n  }\n\n  /// @inheritdoc ISavingFxUSD\n  function claimFor(address owner, address receiver) external onlyRole(CLAIM_FOR_ROLE) {\n    _claim(owner, receiver);\n  }\n\n  /// @inheritdoc ISavingFxUSD\n  function harvest() external {\n    IStakingProxyERC20(vault).getReward();\n    address[] memory tokens = IMultipleRewardDistributor(gauge).getActiveRewardTokens();\n    address cachedHarvester = harvester;\n    uint256 harvesterRatio = getHarvesterRatio();\n    uint256 expenseRatio = getExpenseRatio();\n    bool hasFXN = false;\n    for (uint256 i = 0; i < tokens.length; ++i) {\n      _transferRewards(tokens[i], cachedHarvester, harvesterRatio, expenseRatio);\n      if (tokens[i] == FXN) hasFXN = true;\n    }\n    if (!hasFXN) {\n      _transferRewards(FXN, cachedHarvester, harvesterRatio, expenseRatio);\n    }\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the threshold for batch deposit.\n  /// @param newThreshold The address of new threshold.\n  function updateThreshold(uint256 newThreshold) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateThreshold(newThreshold);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @inheritdoc ERC4626Upgradeable\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual override {\n    ERC4626Upgradeable._deposit(caller, receiver, assets, shares);\n\n    // batch deposit to gauge through convex vault\n    uint256 balance = IERC20(base).balanceOf(address(this));\n    if (balance >= getThreshold()) {\n      ILiquidityGauge(gauge).deposit(balance, vault);\n    }\n  }\n\n  /// @inheritdoc ERC4626Upgradeable\n  function _withdraw(\n    address caller,\n    address receiver,\n    address owner,\n    uint256 assets,\n    uint256 shares\n  ) internal virtual override {\n    if (caller != owner) {\n      _spendAllowance(owner, caller, shares);\n    }\n\n    // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n    // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n    // calls the vault, which is assumed not malicious.\n    //\n    // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n    // shares are burned and after the assets are transferred, which is a valid state.\n    _burn(owner, shares);\n\n    emit Withdraw(caller, receiver, owner, assets, shares);\n\n    // Withdraw from gauge\n    IStakingProxyERC20(vault).withdraw(assets);\n    IERC20(base).transfer(receiver, assets);\n  }\n\n  /// @inheritdoc ConcentratorBase\n  function _onHarvest(address token, uint256 amount) internal virtual override {\n    if (token == gauge) {\n      IERC20(gauge).safeTransfer(vault, amount);\n      return;\n    } else if (token != base) {\n      IERC20(token).forceApprove(base, amount);\n      IFxUSDBasePool(base).deposit(address(this), token, amount, 0);\n    }\n    amount = IERC20(base).balanceOf(address(this));\n    ILiquidityGauge(gauge).deposit(amount, vault);\n  }\n\n  /// @dev Internal function to update the threshold for batch deposit.\n  /// @param newThreshold The address of new threshold.\n  function _updateThreshold(uint256 newThreshold) internal {\n    if (newThreshold > MAX_THRESHOLD) revert ErrorThresholdTooLarge();\n\n    bytes32 _data = _miscData;\n    uint256 oldThreshold = _miscData.decodeUint(THRESHOLD_OFFSET, THRESHOLD_BITS);\n    _miscData = _data.insertUint(newThreshold, THRESHOLD_OFFSET, THRESHOLD_BITS);\n\n    emit UpdateThreshold(oldThreshold, newThreshold);\n  }\n\n  /// @dev Internal function to transfer rewards to harvester.\n  /// @param token The address of rewards.\n  /// @param receiver The address of harvester.\n  function _transferRewards(address token, address receiver, uint256 harvesterRatio, uint256 expenseRatio) internal {\n    if (token == base) return;\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    if (balance > 0) {\n      uint256 performanceFee = (balance * expenseRatio) / FEE_PRECISION;\n      uint256 harvesterBounty = (balance * harvesterRatio) / FEE_PRECISION;\n      if (harvesterBounty > 0) {\n        IERC20(token).safeTransfer(_msgSender(), harvesterBounty);\n      }\n      if (performanceFee > 0) {\n        IERC20(token).safeTransfer(treasury, performanceFee);\n      }\n      IERC20(token).safeTransfer(receiver, balance - performanceFee - harvesterBounty);\n    }\n  }\n\n  /// @dev Internal function to request redeem.\n  function _requestRedeem(address owner, uint256 assets, uint256 shares) internal {\n    // burn shares\n    _burn(owner, shares);\n\n    // Withdraw from gauge\n    IStakingProxyERC20(vault).withdraw(assets);\n\n    // create locked fxSave proxy\n    address proxy = lockedProxy[owner];\n    if (proxy == address(0)) {\n      proxy = address(new LockedFxSaveProxy{ salt: keccak256(abi.encode(owner)) }());\n      lockedProxy[owner] = proxy;\n    }\n\n    // transfer to proxy for unlocking and request unlock\n    IERC20(base).transfer(proxy, assets);\n    LockedFxSaveProxy(proxy).execute(base, abi.encodeCall(IFxUSDBasePool.requestRedeem, (assets)));\n\n    emit RequestRedeem(owner, shares, assets);\n  }\n\n  /// @dev Internal function to claim unlocked tokens.\n  function _claim(address owner, address receiver) internal {\n    address proxy = lockedProxy[owner];\n    LockedFxSaveProxy(proxy).execute(base, abi.encodeCall(IFxUSDBasePool.redeem, (receiver, type(uint256).max)));\n\n    emit Claim(owner, receiver);\n  }\n}\n"
    }
}