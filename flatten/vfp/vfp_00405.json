{
    "vfp_id": "vfp_00405",
    "project_name": "Periphery Changes Audit.md",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Inflexible Fee Recipient Field Blocks Open Relaying",
            "description": "The `DepositData` and `SwapAndDepositData` structs require a hard-coded fee recipient address, which must be honored by the contract upon successful deposit. This design prevents dynamic relayer selection or fallback mechanisms, as the fee is always sent to the specified address. The root cause is the lack of a default or dynamic payee option. This inflexibility discourages open relayer competition and reduces system resilience if the designated relayer is unavailable or underperforming. The impact is reduced decentralization and reliability of the relayer network, potentially leading to failed or delayed deposits if the chosen relayer is not operational.\n",
            "severity": "Low",
            "location": [
                "SpokePoolPeripheryInterface.sol::DepositData#72",
                "SpokePoolPeripheryInterface.sol::SwapAndDepositData#72"
            ],
            "files": [
                "contracts/contracts/interfaces/SpokePoolPeripheryInterface.sol"
            ]
        }
    ],
    "affected_files": {
        "SpokePoolPeripheryInterface.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { IERC20Auth } from \"../external/interfaces/IERC20Auth.sol\";\nimport { IPermit2 } from \"../external/interfaces/IPermit2.sol\";\n\n/**\n * @title SpokePoolPeriphery\n * @notice Contract for performing more complex interactions with an Across spoke pool deployment.\n * @dev Variables which may be immutable are not marked as immutable, nor defined in the constructor, so that this\n * contract may be deployed deterministically at the same address across different networks.\n * @custom:security-contact bugs@across.to\n */\ninterface SpokePoolPeripheryInterface {\n    // Enum describing the method of transferring tokens to an exchange.\n    enum TransferType {\n        // Approve the exchange so that it may transfer tokens from this contract.\n        Approval,\n        // Transfer tokens to the exchange before calling it in this contract.\n        Transfer,\n        // Approve the exchange by authorizing a transfer with Permit2.\n        Permit2Approval\n    }\n\n    // Submission fees can be set by user to pay whoever submits the transaction in a gasless flow.\n    // These are assumed to be in the same currency that is input into the contract.\n    struct Fees {\n        // Amount of fees to pay recipient for submitting transaction.\n        uint256 amount;\n        // Recipient of fees amount.\n        address recipient;\n    }\n\n    // Params we'll need caller to pass in to specify an Across Deposit. The input token will be swapped into first\n    // before submitting a bridge deposit, which is why we don't include the input token amount as it is not known\n    // until after the swap.\n    struct BaseDepositData {\n        // Token deposited on origin chain.\n        address inputToken;\n        // Token received on destination chain.\n        bytes32 outputToken;\n        // Amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // The account credited with deposit who can submit speedups to the Across deposit.\n        address depositor;\n        // The account that will receive the output token on the destination chain. If the output token is\n        // wrapped native token, then if this is an EOA then they will receive native token on the destination\n        // chain and if this is a contract then they will receive an ERC20.\n        bytes32 recipient;\n        // The destination chain identifier.\n        uint256 destinationChainId;\n        // The account that can exclusively fill the deposit before the exclusivity parameter.\n        bytes32 exclusiveRelayer;\n        // Timestamp of the deposit used by system to charge fees. Must be within short window of time into the past\n        // relative to this chain's current time or deposit will revert.\n        uint32 quoteTimestamp;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp or offset on the destination chain after which anyone can fill the deposit. A detailed description on\n        // how the parameter is interpreted by the V3 spoke pool can be found at https://github.com/across-protocol/contracts/blob/fa67f5e97eabade68c67127f2261c2d44d9b007e/contracts/SpokePool.sol#L476\n        uint32 exclusivityParameter;\n        // Data that is forwarded to the recipient if the recipient is a contract.\n        bytes message;\n    }\n\n    // Minimum amount of parameters needed to perform a swap on an exchange specified. We include information beyond just the router calldata\n    // and exchange address so that we may ensure that the swap was performed properly.\n    struct SwapAndDepositData {\n        // Amount of fees to pay for submitting transaction. Unused in gasful flows.\n        Fees submissionFees;\n        // Deposit data to use when interacting with the Across spoke pool.\n        BaseDepositData depositData;\n        // Token to swap.\n        address swapToken;\n        // Address of the exchange to use in the swap.\n        address exchange;\n        // Method of transferring tokens to the exchange.\n        TransferType transferType;\n        // Amount of the token to swap on the exchange.\n        uint256 swapTokenAmount;\n        // Minimum output amount of the exchange, and, by extension, the minimum required amount to deposit into an Across spoke pool.\n        uint256 minExpectedInputTokenAmount;\n        // The calldata to use when calling the exchange.\n        bytes routerCalldata;\n        // When enabled (true), if the swap returns more tokens than minExpectedInputTokenAmount,\n        // the outputAmount will be increased proportionally.\n        // When disabled (false), the original outputAmount is used regardless of how many tokens are returned.\n        bool enableProportionalAdjustment;\n        // Address of the SpokePool to use for depositing tokens after swap.\n        address spokePool;\n    }\n\n    // Extended deposit data to be used specifically for signing off on periphery deposits.\n    struct DepositData {\n        // Amount of fees to pay for submitting transaction. Unused in gasful flows.\n        Fees submissionFees;\n        // Deposit data describing the parameters for the V3 Across deposit.\n        BaseDepositData baseDepositData;\n        // The precise input amount to deposit into the spoke pool.\n        uint256 inputAmount;\n        // Address of the SpokePool to use for depositing tokens.\n        address spokePool;\n    }\n\n    /**\n     * @notice Passthrough function to `depositV3()` on the SpokePool contract.\n     * @dev Protects the caller from losing their ETH (or other native token) by reverting if the SpokePool address\n     * they intended to call does not exist on this chain. Because this contract can be deployed at the same address\n     * everywhere callers should be protected even if the transaction is submitted to an unintended network.\n     * This contract should only be used for native token deposits, as this problem only exists for native tokens.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param inputToken Token to lock into this contract to initiate deposit.\n     * @param inputAmount Amount of tokens to deposit.\n     * @param outputAmount Amount of tokens to receive on destination chain.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     * @param exclusiveRelayer Address of the relayer who has exclusive rights to fill this deposit. Can be set to\n     * 0x0 if no period is desired. If so, then must set exclusivityParameter to 0.\n     * @param exclusivityParameter Timestamp or offset, after which any relayer can fill this deposit. Must set\n     * to 0 if exclusiveRelayer is set to 0x0, and vice versa.\n     * @param fillDeadline Timestamp after which this deposit can no longer be filled.\n     */\n    function deposit(\n        address spokePool,\n        address recipient,\n        address inputToken,\n        uint256 inputAmount,\n        bytes32 outputToken,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes memory message\n    ) external payable;\n\n    /**\n     * @notice Swaps tokens on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If msg.value is sent, the swapToken in swapAndDepositData must implement the WETH9 interface for wrapping native tokens.\n     * @param swapAndDepositData Specifies the data needed to perform a swap on a generic exchange.\n     */\n    function swapAndBridge(SwapAndDepositData calldata swapAndDepositData) external payable;\n\n    /**\n     * @notice Swaps an EIP-2612 token on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If the swapToken in swapData does not implement `permit` to the specifications of EIP-2612, this function will fail.\n     * @param signatureOwner The owner of the permit signature and swapAndDepositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param swapAndDepositData Specifies the params we need to perform a swap on a generic exchange.\n     * @param deadline Deadline before which the permit signature is valid.\n     * @param permitSignature Permit signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param swapAndDepositDataSignature The signature against the input swapAndDepositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function swapAndBridgeWithPermit(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external;\n\n    /**\n     * @notice Uses permit2 to transfer tokens from a user before swapping a token on this chain via specified router and submitting an Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev This function assumes the caller has properly set an allowance for the permit2 contract on this network.\n     * @dev This function assumes that the amount of token to be swapped is equal to the amount of the token to be received from permit2.\n     * @param signatureOwner The owner of the permit2 signature and depositor for the Across spoke pool.\n     * @param swapAndDepositData Specifies the params we need to perform a swap on a generic exchange.\n     * @param permit The permit data signed over by the owner.\n     * @param signature The permit2 signature to verify against the deposit data.\n     */\n    function swapAndBridgeWithPermit2(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Swaps an EIP-3009 token on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If swapToken does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\n     * @param signatureOwner The owner of the EIP3009 signature and swapAndDepositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param swapAndDepositData Specifies the params we need to perform a swap on a generic exchange.\n     * @param validAfter The unix time after which the `receiveWithAuthorization` signature is valid.\n     * @param validBefore The unix time before which the `receiveWithAuthorization` signature is valid.\n     * @param nonce Unique nonce used in the `receiveWithAuthorization` signature.\n     * @param receiveWithAuthSignature EIP3009 signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param swapAndDepositDataSignature The signature against the input swapAndDepositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function swapAndBridgeWithAuthorization(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external;\n\n    /**\n     * @notice Deposits an EIP-2612 token Across input token into the Spoke Pool contract.\n     * @dev If `acrossInputToken` does not implement `permit` to the specifications of EIP-2612, this function will fail.\n     * @param signatureOwner The owner of the permit signature and depositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param depositData Specifies the Across deposit params to send.\n     * @param deadline Deadline before which the permit signature is valid.\n     * @param permitSignature Permit signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param depositDataSignature The signature against the input depositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function depositWithPermit(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata depositDataSignature\n    ) external;\n\n    /**\n     * @notice Uses permit2 to transfer and submit an Across deposit to the Spoke Pool contract.\n     * @dev This function assumes the caller has properly set an allowance for the permit2 contract on this network.\n     * @dev This function assumes that the amount of token to be swapped is equal to the amount of the token to be received from permit2.\n     * @param signatureOwner The owner of the permit2 signature and depositor for the Across spoke pool.\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\n     * @param permit The permit data signed over by the owner.\n     * @param signature The permit2 signature to verify against the deposit data.\n     */\n    function depositWithPermit2(\n        address signatureOwner,\n        DepositData calldata depositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Deposits an EIP-3009 compliant Across input token into the Spoke Pool contract.\n     * @dev If `acrossInputToken` does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\n     * @param signatureOwner The owner of the EIP3009 signature and depositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param depositData Specifies the Across deposit params to send.\n     * @param validAfter The unix time after which the `receiveWithAuthorization` signature is valid.\n     * @param validBefore The unix time before which the `receiveWithAuthorization` signature is valid.\n     * @param nonce Unique nonce used in the `receiveWithAuthorization` signature.\n     * @param receiveWithAuthSignature EIP3009 signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param depositDataSignature The signature against the input depositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function depositWithAuthorization(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata depositDataSignature\n    ) external;\n}\n"
    }
}