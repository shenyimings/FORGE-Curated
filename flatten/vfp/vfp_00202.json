{
    "vfp_id": "vfp_00202",
    "project_name": "Pooltogether - Zenith Audit Report (March).pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "PrizePoolTwabRewards.sol contract doesn't support rebasing tokens",
            "description": "The contract fails to properly handle rebasing tokens (like stETH) when used as reward tokens, leading to potential fund locking or failed claims. The issue stems from the contract tracking rewards through a fixed rewardsUnclaimed variable that doesn't account for rebasing effects.\nIn the case of a positive rebase, the actual token balance increases over time due to rebase mechanics, but the contract's accounting does not reflect this, resulting in leftover funds being permanently locked. In a negative rebase scenario, the contract balance may drop below the recorded unclaimed amount, causing reward claim or promotion end transactions to revert due to insufficient balance.\nThe root cause is the lack of dynamic balance checks and reliance on a static accounting mechanism that assumes non-rebasing token behavior.\nAn attacker could potentially exploit this by manipulating timing or using tokens with known rebase behavior to either trap funds or cause denial of service for legitimate claims.\nThe impact includes loss of funds for the promoter and disruption of reward distribution, undermining user trust and protocol reliability.\n",
            "severity": "Medium",
            "location": [
                "PrizePoolTwabRewards.sol"
            ],
            "files": [
                "pt-v5-prize-pool-twab-rewards/src/PrizePoolTwabRewards.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing epoch validation in getVaultRewardAmount()",
            "description": "The function getVaultRewardAmount() does not validate whether the epoch is over before calculating rewards, unlike _calculateRewardAmount(), which is used in claimRewards(). This inconsistency can lead to incorrect reward calculations when querying rewards for epochs that are still active or invalid.\nThe cause is the omission of epoch validation logic in a public view function that should enforce the same preconditions as its internal counterpart.\nWhile this function is not directly used in state-changing operations, it could mislead external systems or front-ends relying on accurate reward estimates, potentially leading to user confusion or incorrect decisions.\nThe impact is limited to incorrect data reporting rather than direct fund loss, but it affects the reliability of off-chain integrations and user experience.\n",
            "severity": "Low",
            "location": [
                "PrizePoolTwabRewards.sol::getVaultRewardAmount#L439"
            ],
            "files": [
                "pt-v5-prize-pool-twab-rewards/src/PrizePoolTwabRewards.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Strict balance checks prevents using tokens with rounding issues like stETH",
            "description": "The contract performs a strict balance comparison in createPromotion() to verify received tokens, using the condition: if (_afterBalance < _beforeBalance + unclaimedRewards). This check does not account for known rounding issues in tokens like stETH, which can lose 1-2 wei during transfers due to Lido's documented corner cases.\nThe root cause is the use of a strict equality check without any tolerance margin, making the contract incompatible with widely used tokens that exhibit minor balance discrepancies post-transfer.\nAn attacker could potentially exploit this by initiating promotion creation with stETH, causing the transaction to consistently fail and preventing legitimate use of the protocol with such tokens.\nThe impact is a denial of service for users attempting to use stETH or similar tokens with rounding behaviors, limiting the protocol's interoperability and usability.\n",
            "severity": "Low",
            "location": [
                "PrizePoolTwabRewards.sol::createPromotion#L238"
            ],
            "files": [
                "pt-v5-prize-pool-twab-rewards/src/PrizePoolTwabRewards.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Inefficient error handling and misleading NatSpec in reward claiming",
            "description": "The _claimRewards() function contains inefficient error handling by reverting with RewardsAlreadyClaimed when an already claimed epoch is detected, instead of simply skipping it. Additionally, the NatSpec documentation for parameter _epochClaimFlags is misleading, stating it represents \"which epochs were claimed\" when it actually indicates which epochs should be claimed in the current transaction.\nFurthermore, the internal function _isClaimedEpoch() is used for two different semantic purposes: checking which epochs are to be claimed and which have already been claimed by the user, leading to confusion and poor code clarity.\nThis issue stems from suboptimal control flow and poor documentation practices.\nWhile not directly exploitable for financial gain, it can lead to unnecessary transaction failures and confusion for developers integrating with the contract.\nThe impact includes increased gas costs due to avoidable reverts and potential integration errors due to incorrect assumptions based on misleading documentation.\n",
            "severity": "Informational",
            "location": [
                "PrizePoolTwabRewards.sol::claimRewards#L589",
                "PrizePoolTwabRewards.sol::_isClaimedEpoch#L843"
            ],
            "files": [
                "pt-v5-prize-pool-twab-rewards/src/PrizePoolTwabRewards.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Perform divisions after multiplications",
            "description": "The _calculateRewardAmount() function performs a division before a multiplication in its arithmetic calculation, which, while not causing functional issues in this specific case, violates the best practice of performing multiplications before divisions to minimize precision loss in fixed-point arithmetic.\nThe current implementation computes: ((_promotion.tokensPerEpoch * _userAverage) / totalSupply) - contributed, then divides by another denominator. This ordering increases the risk of truncation errors, especially with low token amounts.\nThe root cause is suboptimal arithmetic ordering in reward calculation logic.\nAlthough no immediate exploit is possible due to the current parameter ranges, under different economic conditions or with low balances, this could result in miscalculated rewards.\nThe impact is potential inaccuracy in reward distribution, which could affect fairness and user trust, especially in edge cases.\n",
            "severity": "Informational",
            "location": [
                "PrizePoolTwabRewards.sol::_calculateRewardAmount#L710"
            ],
            "files": [
                "pt-v5-prize-pool-twab-rewards/src/PrizePoolTwabRewards.sol"
            ]
        }
    ],
    "affected_files": {
        "PrizePoolTwabRewards.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport { Multicall } from \"openzeppelin-contracts/utils/Multicall.sol\";\nimport { TwabController } from \"pt-v5-twab-controller/TwabController.sol\";\n\nimport { IPrizePool } from \"./external/IPrizePool.sol\";\nimport { IPrizePoolTwabRewards, Promotion } from \"./interfaces/IPrizePoolTwabRewards.sol\";\nimport { ITwabRewards } from \"./interfaces/ITwabRewards.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown when the TwabController address set in the constructor is the zero address.\nerror TwabControllerZeroAddress();\n\n/// @notice Thrown when a promotion is created with an emission of zero tokens per epoch.\nerror ZeroTokensPerEpoch();\n\n/// @notice Thrown when the number of epochs is zero when it must be greater than zero.\nerror ZeroEpochs();\n\n/// @notice Thrown if the tokens received at the creation of a promotion is less than the expected amount.\n/// @param received The amount of tokens received\n/// @param expected The expected amount of tokens\nerror TokensReceivedLessThanExpected(uint256 received, uint256 expected);\n\n/// @notice Thrown if the address to receive tokens from ending or destroying a promotion is the zero address.\nerror PayeeZeroAddress();\n\n/// @notice Thrown if an action cannot be completed while the grace period is active.\n/// @param gracePeriodEndTimestamp The end timestamp of the grace period\nerror GracePeriodActive(uint256 gracePeriodEndTimestamp);\n\n/// @notice Thrown if a promotion extension would exceed the max number of epochs.\n/// @param epochExtension The number of epochs to extend the promotion by\n/// @param currentEpochs The current number of epochs in the promotion\n/// @param maxEpochs The max number of epochs that a promotion can have\nerror ExceedsMaxEpochs(uint8 epochExtension, uint8 currentEpochs, uint8 maxEpochs);\n\n/// @notice Thrown if rewards for the promotion epoch have already been claimed by the user.\n/// @param promotionId The ID of the promotion\n/// @param user The address of the user that the rewards are being claimed for\n/// @param epochId The epoch that rewards are being claimed from\nerror RewardsAlreadyClaimed(uint256 promotionId, address user, uint8 epochId);\n\n/// @notice Thrown if a promotion is no longer active.\n/// @param promotionId The ID of the promotion\nerror PromotionInactive(uint256 promotionId);\n\n/// @notice Thrown if the sender is not the promotion creator on a creator-only action.\n/// @param sender The address of the sender\n/// @param creator The address of the creator\nerror OnlyPromotionCreator(address sender, address creator);\n\n/// @notice Thrown if the rewards for an epoch are being claimed before the epoch is over.\n/// @param epochEndTimestamp The time at which the epoch will end\nerror EpochNotOver(uint64 epochEndTimestamp);\n\n/// @notice Thrown if an epoch is outside the range of epochs in a promotion.\n/// @param epochId The ID of the epoch\n/// @param numberOfEpochs The number of epochs in the promotion\nerror InvalidEpochId(uint8 epochId, uint8 numberOfEpochs);\n\n/// @notice Thrown if the given prize pool address is zero\nerror PrizePoolZeroAddress();\n\n/// @notice Thrown when the epoch duration is less than the draw period.\nerror EpochDurationLtDrawPeriod();\n    \n/// @notice Thrown when the epoch duration is not a multiple of the draw period.\nerror EpochDurationNotMultipleOfDrawPeriod();\n    \n/// @notice Thrown when the start time is less than the first draw opens at time.\nerror StartTimeLtFirstDrawOpensAt();\n    \n/// @notice Thrown when the start time is not aligned with the draws.\nerror StartTimeNotAlignedWithDraws();\n\n/// @notice Thrown when there are no epochs available to claim\nerror NoEpochsToClaim(uint8 startEpochId, uint8 currentEpochId);\n\n/**\n * @title PoolTogether V5 PrizePoolTwabRewards\n * @author G9 Software Inc.\n * @notice Contract to distribute rewards to depositors across all vaults that contribute to a Prize Pool.\n * The contract supports multiple reward \"promotions\". Each promotion can define a different reward token,\n * start time, epoch duration, and number of epochs. Promotions divide time into evenly sized epochs; and users \n * can claim rewards for each epoch. The amount each user gets is based on their portion of the Vault twab * vault contribution,\n * where the vault contribution is fraction of prize pool prizes that the vault contributed during the epoch.\n * @dev This contract does not support the use of fee on transfer tokens.\n */\ncontract PrizePoolTwabRewards is IPrizePoolTwabRewards, Multicall {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /* ============ Global Variables ============ */\n\n    /// @notice TwabController contract from which the promotions read time-weighted average balances from.\n    TwabController public immutable twabController;\n\n    /// @notice The Prize Pool used to compute the vault contributions.\n    IPrizePool public immutable prizePool;\n\n    /// @notice Cached draw period seconds from the prize pool.\n    uint48 internal immutable _drawPeriodSeconds;\n\n    /// @notice Cached first draw opens at timestamp from the prize pool.\n    uint48 internal immutable _firstDrawOpensAt;\n\n    /// @notice The special SPONSORSHIP address constant used in the TwabController.\n    address constant SPONSORSHIP_ADDRESS = address(1);\n\n    /// @notice Period during which the promotion owner can't destroy a promotion.\n    uint32 public constant GRACE_PERIOD = 60 days;\n\n    /// @notice Settings of each promotion.\n    mapping(uint256 => Promotion) internal _promotions;\n\n    /// @notice Creator of each promotion\n    mapping(uint256 => address) public promotionCreators;\n\n    /**\n     * @notice Latest recorded promotion id.\n     * @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.\n     */\n    uint256 public latestPromotionId;\n\n    /**\n     * @notice Keeps track of claimed rewards per user.\n     * @dev claimedEpochs[promotionId][user] => claimedEpochs\n     * @dev We pack epochs claimed by a user into a uint256. So we can't store more than 256 epochs.\n     */\n    mapping(uint256 promotionId => mapping(address vault => mapping(address user => bytes32 claimMask))) public claimedEpochs;\n\n    /**\n     * @notice Cache of each epoch total contribution amount.\n     * @dev Max number of epochs is 256, so limited it appropriately. Prize Pool draw contributions are stored as uint160, but 128 bits should give us plenty of overhead.\n     */\n    mapping(uint256 promotionId => EpochCache[256]) internal _epochCaches;\n\n    /**\n     * @notice Cache of each vault's epoch total supply and contribution to the prize pool.\n     * @dev Max number of epochs is 256, so limited it appropriately. Twab Controller supply limit is 96bits, so we can store it in a uint96.\n     */\n    mapping(uint256 promotionId => mapping(address vault => VaultEpochCache[256])) internal _vaultEpochCaches;\n\n    struct EpochCache {\n        uint128 totalContributed;\n    }\n\n    struct VaultEpochCache {\n        uint128 totalSupply;\n        uint128 contributed;\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emitted when a promotion is created.\n     * @param promotionId Id of the newly created promotion\n     * @param token The token that will be rewarded from the promotion\n     * @param startTimestamp The timestamp at which the promotion starts\n     * @param tokensPerEpoch The number of tokens emitted per epoch\n     * @param epochDuration The duration of epoch in seconds\n     * @param initialNumberOfEpochs The initial number of epochs the promotion is set to run for\n     */\n    event PromotionCreated(\n        uint256 indexed promotionId,\n        IERC20 indexed token,\n        uint40 startTimestamp,\n        uint104 tokensPerEpoch,\n        uint40 epochDuration,\n        uint8 initialNumberOfEpochs\n    );\n\n    /**\n     * @notice Emitted when a promotion is ended.\n     * @param promotionId Id of the promotion being ended\n     * @param recipient Address of the recipient that will receive the remaining rewards\n     * @param amount Amount of tokens transferred to the recipient\n     * @param epochNumber Epoch number at which the promotion ended\n     */\n    event PromotionEnded(uint256 indexed promotionId, address indexed recipient, uint256 amount, uint8 epochNumber);\n\n    /**\n     * @notice Emitted when a promotion is destroyed.\n     * @param promotionId Id of the promotion being destroyed\n     * @param recipient Address of the recipient that will receive the unclaimed rewards\n     * @param amount Amount of tokens transferred to the recipient\n     */\n    event PromotionDestroyed(uint256 indexed promotionId, address indexed recipient, uint256 amount);\n\n    /**\n     * @notice Emitted when a promotion is extended.\n     * @param promotionId Id of the promotion being extended\n     * @param numberOfEpochs Number of epochs the promotion has been extended by\n     */\n    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);\n\n    /**\n     * @notice Emitted when rewards have been claimed.\n     * @param promotionId Id of the promotion for which epoch rewards were claimed\n     * @param epochClaimFlags Word representing which epochs were claimed\n     * @param user Address of the user for which the rewards were claimed\n     * @param amount Amount of tokens transferred to the recipient address\n     */\n    event RewardsClaimed(uint256 indexed promotionId, bytes32 epochClaimFlags, address indexed vault, address indexed user, uint256 amount);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor of the contract.\n     * @param _twabController The TwabController contract to reference for vault balance and supply\n     * @param _prizePool The PrizePool contract to use for prize contributions\n     */\n    constructor(TwabController _twabController, IPrizePool _prizePool) {\n        if (address(0) == address(_twabController)) revert TwabControllerZeroAddress();\n        if (address(0) == address(_prizePool)) revert PrizePoolZeroAddress();\n        twabController = _twabController;\n        prizePool = _prizePool;\n        _drawPeriodSeconds = prizePool.drawPeriodSeconds();\n        _firstDrawOpensAt = prizePool.firstDrawOpensAt();\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @inheritdoc IPrizePoolTwabRewards\n     * @dev For sake of simplicity, `msg.sender` will be the creator of the promotion.\n     * @dev `_latestPromotionId` starts at 0 and is incremented by 1 for each new promotion.\n     * So the first promotion will have id 1, the second 2, etc.\n     * @dev The transaction will revert if the amount of reward tokens provided is not equal to `_tokensPerEpoch * _numberOfEpochs`.\n     * This scenario could happen if the token supplied is a fee on transfer one.\n     */\n    function createPromotion(\n        IERC20 _token,\n        uint40 _startTimestamp,\n        uint104 _tokensPerEpoch,\n        uint40 _epochDuration,\n        uint8 _numberOfEpochs\n    ) external override returns (uint256) {\n        if (_tokensPerEpoch == 0) revert ZeroTokensPerEpoch();\n        _requireNumberOfEpochs(_numberOfEpochs);\n        if (_epochDuration < _drawPeriodSeconds) revert EpochDurationLtDrawPeriod();\n        if (_epochDuration % _drawPeriodSeconds != 0) revert EpochDurationNotMultipleOfDrawPeriod();\n        if (_startTimestamp < _firstDrawOpensAt) revert StartTimeLtFirstDrawOpensAt();\n        if ((_startTimestamp - _firstDrawOpensAt) % _drawPeriodSeconds != 0) revert StartTimeNotAlignedWithDraws();\n\n        // ensure that this contract isn't eligible to win any prizes\n        if (twabController.delegateOf(address(_token), address(this)) != SPONSORSHIP_ADDRESS) {\n            twabController.delegate(address(_token), SPONSORSHIP_ADDRESS);\n        }\n\n        uint256 _nextPromotionId = latestPromotionId + 1;\n        latestPromotionId = _nextPromotionId;\n\n        uint112 unclaimedRewards = SafeCast.toUint112(uint(_tokensPerEpoch) * uint(_numberOfEpochs));\n\n        promotionCreators[_nextPromotionId] = msg.sender;\n        _promotions[_nextPromotionId] = Promotion({\n            startTimestamp: _startTimestamp,\n            numberOfEpochs: _numberOfEpochs,\n            epochDuration: _epochDuration,\n            createdAt: SafeCast.toUint40(block.timestamp),\n            token: _token,\n            tokensPerEpoch: _tokensPerEpoch,\n            rewardsUnclaimed: unclaimedRewards\n        });\n\n        uint256 _beforeBalance = _token.balanceOf(address(this));\n\n        _token.safeTransferFrom(msg.sender, address(this), unclaimedRewards);\n\n        uint256 _afterBalance = _token.balanceOf(address(this));\n\n        if (_afterBalance < _beforeBalance + unclaimedRewards)\n            revert TokensReceivedLessThanExpected(_afterBalance - _beforeBalance, unclaimedRewards);\n\n        emit PromotionCreated(\n            _nextPromotionId,\n            _token,\n            _startTimestamp,\n            _tokensPerEpoch,\n            _epochDuration,\n            _numberOfEpochs\n        );\n\n        return _nextPromotionId;\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function endPromotion(uint256 _promotionId, address _to) external override returns (bool) {\n        if (address(0) == _to) revert PayeeZeroAddress();\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionCreator(promotionCreators[_promotionId]);\n        _requirePromotionActive(_promotionId, _promotion);\n\n        uint8 _epochNumber = _getEpochIdNow(_promotion.startTimestamp, _promotion.epochDuration);\n        _promotions[_promotionId].numberOfEpochs = _epochNumber;\n\n        uint112 _remainingRewards = _getRemainingRewards(_promotion);\n        _promotions[_promotionId].rewardsUnclaimed = _promotion.rewardsUnclaimed - _remainingRewards;\n\n        _promotion.token.safeTransfer(_to, _remainingRewards);\n\n        emit PromotionEnded(_promotionId, _to, _remainingRewards, _epochNumber);\n\n        return true;\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function destroyPromotion(uint256 _promotionId, address _to) external override returns (bool) {\n        if (address(0) == _to) revert PayeeZeroAddress();\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionCreator(promotionCreators[_promotionId]);\n\n        uint256 _promotionEndTimestamp = _getPromotionEndTimestamp(_promotion);\n        uint256 _promotionCreatedAt = _promotion.createdAt;\n\n        uint256 _gracePeriodEndTimestamp = (\n            _promotionEndTimestamp < _promotionCreatedAt ? _promotionCreatedAt : _promotionEndTimestamp\n        ) + GRACE_PERIOD;\n\n        if (block.timestamp < _gracePeriodEndTimestamp) revert GracePeriodActive(_gracePeriodEndTimestamp);\n\n        uint256 _rewardsUnclaimed = _promotion.rewardsUnclaimed;\n        delete _promotions[_promotionId];\n\n        _promotion.token.safeTransfer(_to, _rewardsUnclaimed);\n\n        emit PromotionDestroyed(_promotionId, _to, _rewardsUnclaimed);\n\n        return true;\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs) external override returns (bool) {\n        _requireNumberOfEpochs(_numberOfEpochs);\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionActive(_promotionId, _promotion);\n\n        uint8 _currentNumberOfEpochs = _promotion.numberOfEpochs;\n\n        if (_numberOfEpochs > (type(uint8).max - _currentNumberOfEpochs))\n            revert ExceedsMaxEpochs(_numberOfEpochs, _currentNumberOfEpochs, type(uint8).max);\n\n        _promotions[_promotionId].numberOfEpochs = _currentNumberOfEpochs + _numberOfEpochs;\n\n        uint112 _amount = SafeCast.toUint112(uint(_numberOfEpochs) * uint(_promotion.tokensPerEpoch));\n\n        _promotions[_promotionId].rewardsUnclaimed = _promotion.rewardsUnclaimed + _amount;\n        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit PromotionExtended(_promotionId, _numberOfEpochs);\n\n        return true;\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function claimRewards(\n        address _vault,\n        address _user,\n        uint256 _promotionId,\n        uint8[] calldata _epochIds\n    ) external override returns (uint256) {\n        bytes32 _epochClaimFlags = epochIdArrayToBytes(_epochIds);\n        return _claimRewards(_vault, _user, _promotionId, _epochClaimFlags, 0);\n    }\n\n    /**\n     * @notice Pass through to claim regular Twab Rewards. This is intended to allow single tx claiming by EOAs using the built-in Multicall\n     * @param _twabRewards TwabRewards contract to claim rewards from\n     * @param _user User to claim rewards for\n     * @param _promotionId Promotion to claim rewards for\n     * @param _epochIds Epoch ids to claim rewards for\n     * @return Total amount of rewards claimed\n     */\n    function claimTwabRewards(\n        ITwabRewards _twabRewards, address _user, uint256 _promotionId, uint8[] calldata _epochIds\n    ) external returns (uint256) {\n        return _twabRewards.claimRewards(_user, _promotionId, _epochIds);\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function claimRewardedEpochs(\n        address _vault,\n        address _user,\n        uint256 _promotionId,\n        uint8 _startEpochId\n    ) public returns (uint256) {\n        bytes32 _epochClaimFlags;\n        uint8 endEpochId = getEpochIdNow(_promotionId);\n        if (!(endEpochId > _startEpochId)) revert NoEpochsToClaim(_startEpochId, endEpochId);\n        for (uint8 index = _startEpochId; index < endEpochId; index++) {\n            _epochClaimFlags = _updateClaimedEpoch(_epochClaimFlags, index);\n        }\n        bytes32 _userClaimedEpochs = claimedEpochs[_promotionId][_vault][_user];\n        // exclude epochs already claimed by the user\n        _epochClaimFlags = _epochClaimFlags & ~_userClaimedEpochs;\n        return _claimRewards(_vault, _user, _promotionId, _epochClaimFlags, _startEpochId);\n    }\n\n    /**\n     * @notice Calculate rewards for a given vault, user, promotion and epoch ids.\n     * @param _vault Vault to calculate rewards for\n     * @param _user User to calculate rewards for\n     * @param _promotionId Promotion to calculate rewards for\n     * @param _epochIds Epoch ids to calculate rewards for\n     * @return rewards Array of reward amounts for each epoch\n     */\n    function calculateRewards(\n        address _vault,\n        address _user,\n        uint256 _promotionId,\n        uint8[] calldata _epochIds\n    ) external returns (uint256[] memory rewards) {\n        rewards = new uint256[](_epochIds.length);\n        Promotion memory promotion = _getPromotion(_promotionId);\n        for (uint256 index = 0; index < _epochIds.length; ++index) {\n            rewards[index] = _calculateRewardAmount(_vault, _user, _promotionId, promotion, _epochIds[index]);\n        }\n    }\n\n    /**\n     * @notice Get reward amount for a given vault\n     * @dev Rewards can only be calculated once the epoch is over.\n     * @dev Will revert if `_epochId` is not in the past.\n     * @param _vault Vault to get reward amount for\n     * @param _promotionId Promotion from which the epoch is\n     * @param _epochId Epoch id to get reward amount for\n     * @return Reward amount\n     */\n    function getVaultRewardAmount(\n        address _vault,\n        uint256 _promotionId,\n        uint8 _epochId\n    ) public returns (uint128) {\n        Promotion memory promotion = _getPromotion(_promotionId);\n        (\n            uint48 _epochStartTimestamp,\n            uint48 _epochEndTimestamp,\n            uint24 _epochStartDrawId,\n            uint24 _epochEndDrawId\n        ) = epochRanges(promotion.startTimestamp, promotion.epochDuration, _epochId);\n        VaultEpochCache memory vaultEpochCache = _getVaultEpochCache(_promotionId, _epochId, _vault, _epochStartTimestamp, _epochEndTimestamp, _epochStartDrawId, _epochEndDrawId);\n        if (vaultEpochCache.contributed == 0) {\n            return 0;\n        }\n        EpochCache memory epochCache = _getEpochCache(_promotionId, _epochId, _epochStartDrawId, _epochEndDrawId);\n        uint256 numerator = uint256(promotion.tokensPerEpoch) * uint256(vaultEpochCache.contributed);\n        uint256 denominator = uint256(epochCache.totalContributed);\n        return SafeCast.toUint128(numerator / denominator);\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {\n        return _getPromotion(_promotionId);\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    /// @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.\n    function getEpochIdNow(uint256 _promotionId) public view override returns (uint8) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        return _getEpochIdNow(_promotion.startTimestamp, _promotion.epochDuration);\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function getEpochIdAt(uint256 _promotionId, uint256 _timestamp) public view override returns (uint8) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        return _getEpochIdAt(_promotion.startTimestamp, _promotion.epochDuration, _timestamp);\n    }\n\n    /// @inheritdoc IPrizePoolTwabRewards\n    function getRemainingRewards(uint256 _promotionId) external view override returns (uint128) {\n        return _getRemainingRewards(_getPromotion(_promotionId));\n    }\n\n    /**\n     * @notice Calculate the draw id at a specific timestamp. Draw ids start at 1.\n     * @param _timestamp Timestamp to calculate the draw id at\n     * @return Draw id\n     */\n    function calculateDrawIdAt(uint64 _timestamp) public view returns (uint24) {\n        // NOTE: Prize Pool draw ids start at 1; that's why we have to add one below.\n        if (_timestamp < _firstDrawOpensAt) return 0;\n        else return uint24((_timestamp - _firstDrawOpensAt) / _drawPeriodSeconds) + 1;\n    }\n\n    /**\n     * @notice Get the time and draw ranges for an epoch\n     * @param _promotionId Id of the promotion\n     * @param _epochId Id of the epoch to get the ranges for\n     * @return epochStartTimestamp Start timestamp of the epoch\n     * @return epochEndTimestamp End timestamp of the epoch\n     * @return epochStartDrawId Start draw id of the epoch\n     * @return epochEndDrawId End draw id of the epoch\n     */\n    function epochRangesForPromotion(\n        uint256 _promotionId,\n        uint8 _epochId\n    ) public view returns (\n        uint48 epochStartTimestamp,\n        uint48 epochEndTimestamp,\n        uint24 epochStartDrawId,\n        uint24 epochEndDrawId\n    ) {\n        Promotion memory promotion = _promotions[_promotionId];\n        return epochRanges(promotion.startTimestamp, promotion.epochDuration, _epochId);\n    }\n\n    /**\n     * @notice Get the time and draw ranges for an epoch\n     * @param _promotionStartTimestamp Start timestamp of the promotion\n     * @param _promotionEpochDuration Duration of an epoch in the promotion\n     * @param _epochId Id of the epoch to get the ranges for\n     * @return epochStartTimestamp Start timestamp of the epoch\n     * @return epochEndTimestamp End timestamp of the epoch\n     * @return epochStartDrawId Start draw id of the epoch\n     * @return epochEndDrawId End draw id of the epoch\n     */\n    function epochRanges(\n        uint48 _promotionStartTimestamp,\n        uint48 _promotionEpochDuration,\n        uint8 _epochId\n    ) public view returns (\n        uint48 epochStartTimestamp,\n        uint48 epochEndTimestamp,\n        uint24 epochStartDrawId,\n        uint24 epochEndDrawId\n    ) {\n        epochStartTimestamp = _promotionStartTimestamp + (_promotionEpochDuration * _epochId);\n        epochEndTimestamp = epochStartTimestamp + _promotionEpochDuration;\n        epochStartDrawId = calculateDrawIdAt(epochStartTimestamp);\n        epochEndDrawId = epochStartDrawId + uint24(_promotionEpochDuration / _drawPeriodSeconds) - 1;\n    }\n\n    /**\n     * @notice Convert an array of epoch ids to a bytes32 word.\n     * @param _epochIds Array of epoch ids to convert\n     * @return Tightly Word where each bit represents an epoch\n     */\n    function epochIdArrayToBytes(uint8[] calldata _epochIds) public pure returns (bytes32) {\n        bytes32 _epochClaimFlags;\n        for (uint256 index = 0; index < _epochIds.length; ++index) {\n            _epochClaimFlags = _updateClaimedEpoch(_epochClaimFlags, _epochIds[index]);\n        }\n        return _epochClaimFlags;\n    }\n\n    /**\n     * @notice Converts a bytes32 to an array of epoch ids\n     * @param _epochClaimFlags Word where each bit represents an epoch\n     * @return Array of epoch ids\n     */\n    function epochBytesToIdArray(bytes32 _epochClaimFlags) public pure returns (uint8[] memory) {\n        uint8 count;\n        for (uint256 epoch = 0; epoch < 256; ++epoch) {\n            if (_isClaimedEpoch(_epochClaimFlags, uint8(epoch))) {\n                ++count;\n            }\n        }\n        uint8[] memory _epochIds = new uint8[](count);\n        uint8 idsIndex = 0;\n        for (uint256 epoch = 0; epoch < 256; ++epoch) {\n            if (_isClaimedEpoch(_epochClaimFlags, uint8(epoch))) {\n                _epochIds[idsIndex++] = uint8(epoch);\n            }\n        }\n        return _epochIds;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Claim rewards for a given promotion and epoch.\n     * @param _vault Address of the vault\n     * @param _user Address of the user\n     * @param _promotionId Id of the promotion\n     * @param _epochClaimFlags Word representing which epochs were claimed\n     * @param startEpochId Id of the epoch to start claiming rewards from\n     * @return Amount of tokens transferred to the recipient address\n     */\n    function _claimRewards(\n        address _vault,\n        address _user,\n        uint256 _promotionId,\n        bytes32 _epochClaimFlags,\n        uint8 startEpochId\n    ) internal returns (uint256) {\n        Promotion memory _promotion = _promotions[_promotionId];\n        uint256 _rewardsAmount;\n        bytes32 _userClaimedEpochs = claimedEpochs[_promotionId][_vault][_user];\n\n        for (uint256 index = startEpochId; index < 256; ++index) {\n            if (!_isClaimedEpoch(_epochClaimFlags, uint8(index))) {\n                continue;\n            }\n            if (_isClaimedEpoch(_userClaimedEpochs, uint8(index)))\n                revert RewardsAlreadyClaimed(_promotionId, _user, uint8(index));\n            _rewardsAmount += _calculateRewardAmount(_vault, _user, _promotionId, _promotion, uint8(index));\n            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, uint8(index));\n        }\n\n        claimedEpochs[_promotionId][_vault][_user] = _userClaimedEpochs;\n\n        _promotions[_promotionId].rewardsUnclaimed = SafeCast.toUint112(uint(_promotion.rewardsUnclaimed) - uint(_rewardsAmount));\n\n        _promotion.token.safeTransfer(_user, _rewardsAmount);\n\n        emit RewardsClaimed(_promotionId, _epochClaimFlags, _vault, _user, _rewardsAmount);\n\n        return _rewardsAmount;\n    }\n\n    /**\n     * @notice Allow a promotion to be created or extended only by a positive number of epochs.\n     * @param _numberOfEpochs Number of epochs to check\n     */\n    function _requireNumberOfEpochs(uint8 _numberOfEpochs) internal pure {\n        if (0 == _numberOfEpochs) revert ZeroEpochs();\n    }\n\n    /**\n     * @notice Requires that a promotion is active.\n     * @param _promotion Promotion to check\n     */\n    function _requirePromotionActive(uint256 _promotionId, Promotion memory _promotion) internal view {\n        if (_getPromotionEndTimestamp(_promotion) <= block.timestamp) revert PromotionInactive(_promotionId);\n    }\n\n    /**\n     * @notice Requires that msg.sender is the promotion creator.\n     * @param creator Creator of the promotion\n     */\n    function _requirePromotionCreator(address creator) internal view {\n        if (msg.sender != creator) revert OnlyPromotionCreator(msg.sender, creator);\n    }\n\n    /**\n     * @notice Get settings for a specific promotion.\n     * @dev Will revert if the promotion does not exist.\n     * @param _promotionId Promotion id to get settings for\n     * @return Promotion settings\n     */\n    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {\n        Promotion memory _promotion = _promotions[_promotionId];\n        return _promotion;\n    }\n\n    /**\n     * @notice Compute promotion end timestamp.\n     * @param _promotion Promotion to compute end timestamp for\n     * @return Promotion end timestamp\n     */\n    function _getPromotionEndTimestamp(Promotion memory _promotion) internal pure returns (uint256) {\n        unchecked {\n            return _promotion.startTimestamp + (_promotion.epochDuration * _promotion.numberOfEpochs);\n        }\n    }\n\n    /**\n     * @notice Get the current epoch id of a promotion.\n     * @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.\n     * @dev We return the current epoch id if the promotion has not ended.\n     * If the current timestamp is before the promotion start timestamp, we return 0.\n     * Otherwise, we return the epoch id at the current timestamp. This could be greater than the number of epochs of the promotion.\n     * @param _promotionStartTimestamp Start timestamp of the promotion\n     * @param _promotionEpochDuration Duration of an epoch for the promotion\n     * @return Epoch id\n     */\n    function _getEpochIdNow(uint256 _promotionStartTimestamp, uint256 _promotionEpochDuration) internal view returns (uint8) {\n        return _getEpochIdAt(_promotionStartTimestamp, _promotionEpochDuration, block.timestamp);\n    }\n\n    /**\n     * @notice Get the epoch id at a specific timestamp.\n     * @param _promotionStartTimestamp Start timestamp of the promotion\n     * @param _promotionEpochDuration Duration of an epoch for the promotion\n     * @param _timestamp Timestamp to get the epoch id for\n     */\n    function _getEpochIdAt(uint256 _promotionStartTimestamp, uint256 _promotionEpochDuration, uint256 _timestamp) internal pure returns (uint8) {\n        uint256 _currentEpochId;\n\n        if (_timestamp > _promotionStartTimestamp) {\n            unchecked {\n                _currentEpochId = (_timestamp - _promotionStartTimestamp) / _promotionEpochDuration;\n            }\n        }\n\n        return _currentEpochId > type(uint8).max ? type(uint8).max : uint8(_currentEpochId);\n    }\n\n    /**\n     * @notice Get reward amount for a specific user.\n     * @dev Rewards can only be calculated once the epoch is over.\n     * @dev Will revert if `_epochId` is not in the past.\n     * @dev Will return 0 if the user average balance in the vault is 0.\n     * @param _vault Vault to get reward amount for\n     * @param _user User to get reward amount for\n     * @param _promotion Promotion from which the epoch is\n     * @param _epochId Epoch id to get reward amount for\n     * @return Reward amount\n     */\n    function _calculateRewardAmount(\n        address _vault,\n        address _user,\n        uint256 _promotionId,\n        Promotion memory _promotion,\n        uint8 _epochId\n    ) internal returns (uint256) {\n        (\n            uint48 _epochStartTimestamp,\n            uint48 _epochEndTimestamp,\n            uint24 _epochStartDrawId,\n            uint24 _epochEndDrawId\n        ) = epochRanges(_promotion.startTimestamp, _promotion.epochDuration, _epochId);\n        if (block.timestamp < _epochEndTimestamp) revert EpochNotOver(_epochEndTimestamp);\n        if (_epochId >= _promotion.numberOfEpochs) revert InvalidEpochId(_epochId, _promotion.numberOfEpochs);\n        uint256 _userAverage = twabController.getTwabBetween(\n            _vault,\n            _user,\n            _epochStartTimestamp,\n            _epochEndTimestamp\n        );\n\n        if (_userAverage > 0) {\n            VaultEpochCache memory vaultEpochCache = _getVaultEpochCache(_promotionId, _epochId, _vault, _epochStartTimestamp, _epochEndTimestamp, _epochStartDrawId, _epochEndDrawId);\n\n            if (vaultEpochCache.contributed == 0) {\n                return 0;\n            }\n\n            EpochCache memory epochCache = _getEpochCache(_promotionId, _epochId, _epochStartDrawId, _epochEndDrawId);\n\n            uint numerator = ((_promotion.tokensPerEpoch * _userAverage) / uint256(vaultEpochCache.totalSupply)) * uint256(vaultEpochCache.contributed);\n            uint denominator = (uint256(epochCache.totalContributed));\n            return numerator / denominator;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Retrieve the contributed amount for the vault, and the vaults total supply for the given epoch\n     * @param _promotionId Promotion id\n     * @param _epochId Epoch id\n     * @param _vault Vault address\n     * @param _epochStartTimestamp Start timestamp of the epoch\n     * @param _epochEndTimestamp End timestamp of the epoch\n     * @param _epochStartDrawId Start draw id of the epoch\n     * @param _epochEndDrawId End draw id of the epoch\n     * @return vaultEpochCache VaultEpochCache struct\n     */\n    function _getVaultEpochCache(\n        uint256 _promotionId,\n        uint8 _epochId,\n        address _vault,\n        uint48 _epochStartTimestamp,\n        uint48 _epochEndTimestamp,\n        uint24 _epochStartDrawId,\n        uint24 _epochEndDrawId\n    ) internal returns (VaultEpochCache memory vaultEpochCache) {\n        vaultEpochCache = _vaultEpochCaches[_promotionId][_vault][_epochId];\n        if (vaultEpochCache.contributed == 0) {\n            vaultEpochCache.contributed = SafeCast.toUint128(prizePool.getContributedBetween(_vault, _epochStartDrawId, _epochEndDrawId));\n            vaultEpochCache.totalSupply = SafeCast.toUint128(twabController.getTotalSupplyTwabBetween(\n                _vault,\n                _epochStartTimestamp,\n                _epochEndTimestamp\n            ));\n            _vaultEpochCaches[_promotionId][_vault][_epochId] = vaultEpochCache;\n        }\n    }\n\n    /**\n     * @notice Retrieve the total contributed amount for the epoch\n     * @param _promotionId Promotion id\n     * @param _epochId Epoch id\n     * @param _epochStartDrawId Start draw id of the epoch\n     * @param _epochEndDrawId End draw id of the epoch\n     * @return epochCache EpochCache struct\n     */\n    function _getEpochCache(\n        uint256 _promotionId,\n        uint8 _epochId,\n        uint24 _epochStartDrawId,\n        uint24 _epochEndDrawId\n    ) internal returns (EpochCache memory epochCache) {\n        epochCache = _epochCaches[_promotionId][_epochId];\n        if (epochCache.totalContributed == 0) {\n            epochCache.totalContributed = SafeCast.toUint128(prizePool.getTotalContributedBetween(_epochStartDrawId, _epochEndDrawId));\n            _epochCaches[_promotionId][_epochId] = epochCache;\n        }\n    }\n\n    /**\n     * @notice Get the total amount of tokens left to be rewarded.\n     * @param _promotion Promotion to get the total amount of tokens left to be rewarded for\n     * @return Amount of tokens left to be rewarded\n     */\n    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint112) {\n        if (block.timestamp >= _getPromotionEndTimestamp(_promotion)) {\n            return 0;\n        }\n\n        return _promotion.tokensPerEpoch * (_promotion.numberOfEpochs - _getEpochIdNow(_promotion.startTimestamp, _promotion.epochDuration));\n    }\n\n    /**\n    * @notice Set boolean value for a specific epoch.\n    * @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0011\n        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.\n        We get: 0000 0001 << 2 = 0000 0100\n        We then OR the mask with the word to set the value.\n        We get: 0110 0011 | 0000 0100 = 0110 0111\n    * @param _userClaimedEpochs Tightly packed epoch ids with their boolean values\n    * @param _epochId Id of the epoch to set the boolean for\n    * @return Tightly packed epoch ids with the newly boolean value set\n    */\n    function _updateClaimedEpoch(bytes32 _userClaimedEpochs, uint8 _epochId) internal pure returns (bytes32) {\n        return _userClaimedEpochs | (bytes32(uint256(1)) << _epochId);\n    }\n\n    /**\n    * @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.\n    * @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0111\n        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.\n        We get: 0110 0111 >> 2 = 0001 1001\n        We then get the value of the last bit by masking with 1.\n        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1\n        We then return the boolean value true since the last bit is 1.\n    * @param _userClaimedEpochs Record of epochs already claimed by the user\n    * @param _epochId Epoch id to check\n    * @return true if the rewards have already been claimed for the given epoch, false otherwise\n     */\n    function _isClaimedEpoch(bytes32 _userClaimedEpochs, uint8 _epochId) internal pure returns (bool) {\n        bool value = (uint256(_userClaimedEpochs) >> _epochId) & uint256(1) == 1;\n        return value;\n    }\n}\n"
    }
}