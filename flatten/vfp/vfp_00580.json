{
    "vfp_id": "vfp_00580",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Attacker can Lock User Funds through Redeem Function",
            "description": "1. **Description:** The redeem function in the PoolManager contract allows users to burn fxUSD and receive collateral at a favorable rate, but lacks a minimum rawDebt (fxUSD) requirement. This enables an attacker to perform repeated small redemptions, creating a long chain of child nodes in the tick structure without updating the top tick.\n\n2. **Cause:** The absence of a minimum rawDebt threshold in the redeem function, combined with the recursive _getRootNodeAndCompress function in TickLogic.sol, creates a vulnerability. Each small redemption creates a new child node, and the recursive traversal to find the root node can result in a stack overflow when too many nested nodes exist.\n\n3. **Exploitation:** An attacker can repeatedly call redeem with minimal fxUSD (e.g., 2 wei) to generate hundreds or thousands of child nodes under a tick. When a user attempts to update or close a position in that tick via the operate function, the _getRootNodeAndCompress function will fail due to stack overflow, preventing the operation.\n\n4. **Impact:** Users affected by this attack will be unable to close or modify their positions, effectively locking their funds. They can only be rebalanced or liquidated by external actors, leading to potential loss of control and accessibility of funds.\n",
            "severity": "Critical",
            "location": [
                "PoolManager.sol::redeem#307-334",
                "BasePool.sol::redeem#191-245",
                "BasePool.sol::operate#73-188",
                "TickLogic.sol::_liquidateTick#L198",
                "TickLogic.sol::_getRootNodeAndCompress#65-85"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/PoolManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Flashloan Functionality is Blocked",
            "description": "1. **Description:** The flashLoan function in the FlashLoans contract incorrectly validates repayment by comparing returnedAmount against amount + fee. However, returnedAmount is calculated as the difference between post-callback and pre-loan balances, which only reflects the fee portion, not the principal.\n\n2. **Cause:** The function computes returnedAmount as (post-callback balance - pre-loan balance), which measures only the additional tokens sent beyond the borrowed amount. Since the principal is not included in this delta, the condition returnedAmount < amount + fee always evaluates to true unless the borrower sends back the full principal plus fee as extra tokens.\n\n3. **Exploitation:** Any legitimate flash loan will revert because the repayment check fails even when the borrower correctly returns the principal and fee. This effectively blocks all flash loan functionality, denying a core DeFi feature and potentially disrupting integrations or arbitrage mechanisms relying on it.\n\n4. **Impact:** The flash loan mechanism becomes unusable, reducing the protocol's utility and interoperability within the DeFi ecosystem. This could hinder arbitrageurs, liquidity providers, or other protocols attempting to interact with the system via flash loans.\n",
            "severity": "High",
            "location": [
                "FlashLoans.sol::flashLoan#67-97"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FlashLoans.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Flashloan Functionality Does Not Follow ERC-3156 Standard",
            "description": "The `flashLoan` function in the FlashLoans contract does not comply with the ERC-3156 standard, which requires the lender to pull the principal plus fee from the borrower after the callback. Instead, the current implementation relies on the borrower to return the tokens, which breaks interoperability with standard-compliant `IERC3156FlashBorrower` contracts. Additionally, the `flashFee` function does not revert when the token is unsupported (i.e., when `maxFlashLoan` returns zero), as required by the ERC-3156 specification. The cause is a deviation from the standard's expected behavior in both token handling and fee calculation logic. This could prevent integration with other DeFi protocols and lead to unexpected reverts or failed flash loans. The impact is reduced composability and potential integration failures with external systems expecting standard behavior.\n",
            "severity": "Medium",
            "location": [
                "FlashLoans.sol::flashLoan#86",
                "FlashLoans.sol::flashFee#59"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FlashLoans.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Pool at Capacity Cannot Be Liquidated",
            "description": "When a pool reaches its maximum collateral capacity, liquidation may fail even if funds are available from the ReservePool. This occurs because the `liquidate` function adds the reserve funds to the pool's current balance before checking capacity, potentially exceeding the limit and causing a revert. The root cause is the order of operations in the liquidation logic: reserve funds are added before subtracting the liquidated collateral. An attacker could exploit this by pushing a pool to capacity and then causing bad debt, knowing that liquidation will fail, thus preventing recovery. The impact is that undercapitalized positions may remain unliquidated, increasing systemic risk and potential losses for the protocol.\n",
            "severity": "Low",
            "location": [
                "PoolManager.sol::_changePoolCollateral#688",
                "PoolManager.sol::liquidate#386",
                "PoolManager.sol#416"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/PoolManager.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Users Can Open Null Positions",
            "description": "The `operate` function in the PoolManager contract allows users to create null positions by passing `type(int256).min` for both `newDebt` and `newColl` with `positionId = 0`. This results in the creation of a new position with zero debt and zero collateral, which serves no functional purpose. The root cause is the lack of validation to prevent no-op state transitions. While this does not pose a direct financial risk, it leads to event spam and ambiguity in off-chain indexing and analytics. The impact is degraded data quality for external tools and potential confusion for integrators, though there is no direct loss of funds or protocol instability.\n",
            "severity": "Low",
            "location": [
                "PoolManager.sol::operate#259-264",
                "BasePool.sol::_addPositionToTick#128-157"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/PoolManager.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Code Readability Suggestions",
            "description": "Several functions and modifiers have misleading names that do not reflect their actual behavior, such as `onlyFxSave` which checks for `fxBase`, or `totalSupply` which returns deposited assets plus yield. The cause is inaccurate naming. This can lead to confusion and bugs during development and auditing. The impact is reduced code clarity and increased risk of logic errors.\n",
            "severity": null,
            "location": [
                "PoolManager.sol::onlyFxSave#161",
                "AaveV3Strategy.sol::totalSupply#42",
                "AssetManagement.sol::manage#46"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/PoolManager.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Misleading Return Value in `_takeAccumulatedPoolFee`",
            "description": "The `_takeAccumulatedPoolFee` function in the `ProtocolFees` contract returns a value that is overwritten multiple times, ultimately only reflecting the last fee category (`accumulatedPoolMiscFees`). This makes the return value misleading and technically incorrect as it does not represent the total accumulated fees. The cause is poor variable reuse without aggregation. Although no internal or external function uses this return value, its presence could confuse developers or future auditors into assuming it represents a total. The impact is limited to code clarity and maintainability, but it could lead to incorrect assumptions in future development or integration efforts.\n",
            "severity": null,
            "location": [
                "ProtocolFees.sol::_takeAccumulatedPoolFee#441-458"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/ProtocolFees.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Inheritance Correctness",
            "description": "The `ProtocolFees` contract inherits `PausableUpgradeable` but does not use any pause functionality, while contracts that do implement pausing (`FlashLoans`, `PoolManager`) inherit from it. Additionally, the `AaveV3Strategy` contract breaks a clear codebase pattern by not inheriting the `IStrategy` interface, unlike other strategy-related contracts. The root cause is inconsistent inheritance design and deviation from established conventions. This leads to unnecessary bloat in `ProtocolFees` and reduces code clarity. The impact includes increased deployment costs, potential confusion for developers, and weakened interface consistency, which could lead to integration errors or missed functionality assumptions.\n",
            "severity": null,
            "location": [],
            "files": [
                "fx-protocol-contracts/contracts/core/ProtocolFees.sol",
                "fx-protocol-contracts/contracts/core/FlashLoans.sol",
                "fx-protocol-contracts/contracts/core/PoolManager.sol",
                "fx-protocol-contracts/contracts/fund/AaveV3Strategy.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ]
            },
            "title": "Gap Variables Allow Future Storage Collision",
            "description": "Multiple upgradeable contracts use unstructured gap variables (e.g., `__gap`) to reserve storage slots for future additions. However, since these contracts are already deployed, any future changes must carefully account for existing storage layout. The current use of gap variables does not guarantee safety against storage collisions if new variables are added without proper planning. The root cause is reliance on manual gap management instead of structured storage techniques. If a future upgrade incorrectly places new state variables, it could overwrite existing data, leading to catastrophic failures such as loss of funds or protocol freeze. This is a critical risk for long-term maintainability and upgrade safety.\n",
            "severity": null,
            "location": [
                "ProtocolFees.sol#__gap#464",
                "BasePool.sol#__gap#619",
                "PoolStorage.sol#__gap#470",
                "PositionLogic.sol#__gap#139",
                "TickLogic.sol#__gap#251",
                "AssetManagement.sol#__gap#28",
                "StrategyBase.sol#__gap#16"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/ProtocolFees.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary Casts",
            "description": "The code performs redundant `uint256` casts on values that are already of type `uint256`, adding unnecessary complexity and slight gas overhead. The cause is superfluous type casting in `ProtocolFees.sol`. This does not introduce a security vulnerability but harms code clarity and slightly increases gas usage. The impact is reduced readability and minor inefficiency in execution.\n",
            "severity": null,
            "location": [
                "ProtocolFees.sol::uint256(newRatio)#331",
                "ProtocolFees.sol::uint256(newRatio)#345",
                "ProtocolFees.sol::uint256(newRatio)#359",
                "ProtocolFees.sol::uint256(newRatio)#373",
                "ProtocolFees.sol::uint256(newRatio)#387",
                "ProtocolFees.sol::uint256(newRatio)#401"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/ProtocolFees.sol"
            ]
        }
    ],
    "affected_files": {
        "FlashLoans.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.25;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { IERC3156FlashBorrower } from \"../common/ERC3156/IERC3156FlashBorrower.sol\";\nimport { IERC3156FlashLender } from \"../common/ERC3156/IERC3156FlashLender.sol\";\n\nimport { ProtocolFees } from \"./ProtocolFees.sol\";\n\ncontract FlashLoans is ProtocolFees, ReentrancyGuardUpgradeable, IERC3156FlashLender {\n  using SafeERC20 for IERC20;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when the returned balance after flash loan is not enough.\n  error ErrorInsufficientFlashLoanReturn();\n\n  /// @dev Thrown when the returned value of `ERC3156Callback` is wrong.\n  error ErrorERC3156CallbackFailed();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The correct value of the return value of `ERC3156FlashBorrower.onFlashLoan`.\n  bytes32 private constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @dev Slots for future use.\n  uint256[50] private _gap;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  function __FlashLoans_init() internal onlyInitializing {}\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc IERC3156FlashLender\n  function maxFlashLoan(address token) external view override returns (uint256) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @inheritdoc IERC3156FlashLender\n  function flashFee(address /*token*/, uint256 amount) public view returns (uint256) {\n    return (amount * getFlashLoanFeeRatio()) / FEE_PRECISION;\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc IERC3156FlashLender\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external nonReentrant whenNotPaused returns (bool) {\n    // save the current balance\n    uint256 prevBalance = IERC20(token).balanceOf(address(this));\n    uint256 fee = flashFee(token, amount);\n\n    // transfer token to receiver\n    IERC20(token).safeTransfer(address(receiver), amount);\n\n    // invoke the recipient's callback\n    if (receiver.onFlashLoan(_msgSender(), token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert ErrorERC3156CallbackFailed();\n    }\n\n    // ensure that the tokens + fee have been deposited back to the network\n    uint256 returnedAmount = IERC20(token).balanceOf(address(this)) - prevBalance;\n    if (returnedAmount < amount + fee) {\n      revert ErrorInsufficientFlashLoanReturn();\n    }\n\n    if (fee > 0) {\n      IERC20(token).safeTransfer(treasury, fee);\n    }\n\n    return true;\n  }\n}\n",
        "PoolManager.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { IFxUSDRegeneracy } from \"../interfaces/IFxUSDRegeneracy.sol\";\nimport { IPool } from \"../interfaces/IPool.sol\";\nimport { IPoolManager } from \"../interfaces/IPoolManager.sol\";\nimport { IReservePool } from \"../interfaces/IReservePool.sol\";\nimport { IRewardSplitter } from \"../interfaces/IRewardSplitter.sol\";\nimport { IFxUSDBasePool } from \"../interfaces/IFxUSDBasePool.sol\";\nimport { IRateProvider } from \"../rate-provider/interfaces/IRateProvider.sol\";\n\nimport { WordCodec } from \"../common/codec/WordCodec.sol\";\nimport { AssetManagement } from \"../fund/AssetManagement.sol\";\nimport { FlashLoans } from \"./FlashLoans.sol\";\nimport { ProtocolFees } from \"./ProtocolFees.sol\";\n\ncontract PoolManager is ProtocolFees, FlashLoans, AssetManagement, IPoolManager {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20;\n  using WordCodec for bytes32;\n\n  /**********\n   * Errors *\n   **********/\n\n  error ErrorCollateralExceedCapacity();\n\n  error ErrorDebtExceedCapacity();\n\n  error ErrorPoolNotRegistered();\n\n  error ErrorInvalidPool();\n\n  error ErrorCallerNotFxUSDSave();\n\n  error ErrorRedeemExceedBalance();\n\n  error ErrorInsufficientRedeemedCollateral();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The role for emergency operations.\n  bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n\n  /// @dev The role for harvester\n  bytes32 public constant HARVESTER_ROLE = keccak256(\"HARVESTER_ROLE\");\n\n  /// @dev The precision for token rate.\n  uint256 internal constant PRECISION = 1e18;\n\n  /// @dev The precision for token rate.\n  int256 internal constant PRECISION_I256 = 1e18;\n\n  uint256 private constant COLLATERAL_CAPACITY_OFFSET = 0;\n  uint256 private constant COLLATERAL_BALANCE_OFFSET = 85;\n  uint256 private constant RAW_COLLATERAL_BALANCE_OFFSET = 170;\n  uint256 private constant COLLATERAL_DATA_BITS = 85;\n  uint256 private constant RAW_COLLATERAL_DATA_BITS = 86;\n\n  uint256 private constant DEBT_CAPACITY_OFFSET = 0;\n  uint256 private constant DEBT_BALANCE_OFFSET = 96;\n  uint256 private constant DEBT_DATA_BITS = 96;\n\n  /***********************\n   * Immutable Variables *\n   ***********************/\n\n  /// @inheritdoc IPoolManager\n  address public immutable fxUSD;\n\n  /// @inheritdoc IPoolManager\n  address public immutable fxBASE;\n\n  /// @inheritdoc IPoolManager\n  address public immutable pegKeeper;\n\n  /***********\n   * Structs *\n   ***********/\n\n  /// @dev The struct for pool information.\n  /// @param collateralData The data for collateral.\n  ///   ```text\n  ///   * Field                     Bits    Index       Comments\n  ///   * collateral capacity       85      0           The maximum allowed amount of collateral tokens.\n  ///   * collateral balance        85      85          The amount of collateral tokens deposited.\n  ///   * raw collateral balance    86      170         The amount of raw collateral tokens (without token rate) managed in pool.\n  ///   ```\n  /// @param debtData The data for debt.\n  ///   ```text\n  ///   * Field             Bits    Index       Comments\n  ///   * debt capacity     96      0           The maximum allowed amount of debt tokens.\n  ///   * debt balance      96      96          The amount of debt tokens borrowed.\n  ///   * reserved          64      192         Reserved data.\n  ///   ```\n  struct PoolStruct {\n    bytes32 collateralData;\n    bytes32 debtData;\n  }\n\n  /// @dev The struct for token rate information.\n  /// @param scalar The token scalar to reach 18 decimals.\n  /// @param rateProvider The address of token rate provider.\n  struct TokenRate {\n    uint96 scalar;\n    address rateProvider;\n  }\n\n  /// @dev Memory variables for liquidate or rebalance.\n  /// @param stablePrice The USD price of stable token (with scalar).\n  /// @param scalingFactor The scaling factor for collateral token.\n  /// @param collateralToken The address of collateral token.\n  /// @param rawColls The amount of raw collateral tokens liquidated or rebalanced, including bonus.\n  /// @param bonusRawColls The amount of raw collateral tokens used as bonus.\n  /// @param rawDebts The amount of raw debt tokens liquidated or rebalanced.\n  struct LiquidateOrRebalanceMemoryVar {\n    uint256 stablePrice;\n    uint256 scalingFactor;\n    address collateralToken;\n    uint256 rawColls;\n    uint256 bonusRawColls;\n    uint256 rawDebts;\n  }\n\n  /*********************\n   * Storage Variables *\n   *********************/\n\n  /// @dev The list of registered pools.\n  EnumerableSet.AddressSet private pools;\n\n  /// @notice Mapping to pool address to pool struct.\n  mapping(address => PoolStruct) private poolInfo;\n\n  /// @notice Mapping from pool address to rewards splitter.\n  mapping(address => address) public rewardSplitter;\n\n  /// @notice Mapping from token address to token rate struct.\n  mapping(address => TokenRate) public tokenRates;\n\n  /// @notice The threshold for permissioned liquidate or rebalance.\n  uint256 public permissionedLiquidationThreshold;\n\n  /*************\n   * Modifiers *\n   *************/\n\n  modifier onlyRegisteredPool(address pool) {\n    if (!pools.contains(pool)) revert ErrorPoolNotRegistered();\n    _;\n  }\n\n  modifier onlyFxUSDSave() {\n    if (_msgSender() != fxBASE) {\n      // allow permissonless rebalance or liquidate when insufficient fxUSD/USDC in fxBASE.\n      uint256 totalYieldToken = IFxUSDBasePool(fxBASE).totalYieldToken();\n      uint256 totalStableToken = IFxUSDBasePool(fxBASE).totalStableToken();\n      uint256 price = IFxUSDBasePool(fxBASE).getStableTokenPriceWithScale();\n      if (totalYieldToken + (totalStableToken * price) / PRECISION >= permissionedLiquidationThreshold) {\n        revert ErrorCallerNotFxUSDSave();\n      }\n    }\n    _;\n  }\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address _fxUSD, address _fxBASE, address _pegKeeper) {\n    fxUSD = _fxUSD;\n    fxBASE = _fxBASE;\n    pegKeeper = _pegKeeper;\n  }\n\n  function initialize(\n    address admin,\n    uint256 _expenseRatio,\n    uint256 _harvesterRatio,\n    uint256 _flashLoanFeeRatio,\n    address _treasury,\n    address _revenuePool,\n    address _reservePool\n  ) external initializer {\n    __Context_init();\n    __AccessControl_init();\n    __ERC165_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n    __ProtocolFees_init(_expenseRatio, _harvesterRatio, _flashLoanFeeRatio, _treasury, _revenuePool, _reservePool);\n    __FlashLoans_init();\n\n    // default 10000 fxUSD\n    _updateThreshold(10000 ether);\n  }\n\n  function initializeV2(address pool) external onlyRegisteredPool(pool) reinitializer(2) {\n    // fix state of pool\n    address collateralToken = IPool(pool).collateralToken();\n    uint256 scalingFactor = _getTokenScalingFactor(collateralToken);\n    uint256 rawCollaterals = IPool(pool).getTotalRawCollaterals();\n    uint256 collaterals = _scaleDown(rawCollaterals, scalingFactor);\n    bytes32 data = poolInfo[pool].collateralData;\n    data = data.insertUint(collaterals, COLLATERAL_BALANCE_OFFSET, COLLATERAL_DATA_BITS);\n    poolInfo[pool].collateralData = data.insertUint(\n      rawCollaterals,\n      RAW_COLLATERAL_BALANCE_OFFSET,\n      RAW_COLLATERAL_DATA_BITS\n    );\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Return the pool information.\n  /// @param pool The address of pool to query.\n  /// @return collateralCapacity The maximum allowed amount of collateral tokens.\n  /// @return collateralBalance The amount of collateral tokens deposited.\n  /// @return rawCollateral The amount of raw collateral tokens deposited.\n  /// @return debtCapacity The maximum allowed amount of debt tokens.\n  /// @return debtBalance The amount of debt tokens borrowed.\n  function getPoolInfo(\n    address pool\n  )\n    external\n    view\n    returns (\n      uint256 collateralCapacity,\n      uint256 collateralBalance,\n      uint256 rawCollateral,\n      uint256 debtCapacity,\n      uint256 debtBalance\n    )\n  {\n    bytes32 data = poolInfo[pool].collateralData;\n    collateralCapacity = data.decodeUint(COLLATERAL_CAPACITY_OFFSET, COLLATERAL_DATA_BITS);\n    collateralBalance = data.decodeUint(COLLATERAL_BALANCE_OFFSET, COLLATERAL_DATA_BITS);\n    rawCollateral = data.decodeUint(RAW_COLLATERAL_BALANCE_OFFSET, RAW_COLLATERAL_DATA_BITS);\n    data = poolInfo[pool].debtData;\n    debtCapacity = data.decodeUint(DEBT_CAPACITY_OFFSET, DEBT_DATA_BITS);\n    debtBalance = data.decodeUint(DEBT_BALANCE_OFFSET, DEBT_DATA_BITS);\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc IPoolManager\n  function operate(\n    address pool,\n    uint256 positionId,\n    int256 newColl,\n    int256 newDebt\n  ) external onlyRegisteredPool(pool) nonReentrant whenNotPaused returns (uint256) {\n    address collateralToken = IPool(pool).collateralToken();\n    uint256 scalingFactor = _getTokenScalingFactor(collateralToken);\n\n    int256 newRawColl = newColl;\n    if (newRawColl != type(int256).min) {\n      newRawColl = _scaleUp(newRawColl, scalingFactor);\n    }\n\n    uint256 rawProtocolFees;\n    // the `newRawColl` is the result without `protocolFees`\n    (positionId, newRawColl, newDebt, rawProtocolFees) = IPool(pool).operate(\n      positionId,\n      newRawColl,\n      newDebt,\n      _msgSender()\n    );\n\n    newColl = _scaleDown(newRawColl, scalingFactor);\n    uint256 protocolFees = _scaleDown(rawProtocolFees, scalingFactor);\n    _changePoolDebts(pool, newDebt);\n    if (newRawColl > 0) {\n      _accumulatePoolOpenFee(pool, protocolFees);\n      _changePoolCollateral(pool, newColl, newRawColl);\n      IERC20(collateralToken).safeTransferFrom(_msgSender(), address(this), uint256(newColl) + protocolFees);\n    } else if (newRawColl < 0) {\n      _accumulatePoolCloseFee(pool, protocolFees);\n      _changePoolCollateral(pool, newColl - int256(protocolFees), newRawColl - int256(rawProtocolFees));\n      _transferOut(collateralToken, uint256(-newColl), _msgSender());\n    }\n\n    if (newDebt > 0) {\n      IFxUSDRegeneracy(fxUSD).mint(_msgSender(), uint256(newDebt));\n    } else if (newDebt < 0) {\n      IFxUSDRegeneracy(fxUSD).burn(_msgSender(), uint256(-newDebt));\n    }\n\n    emit Operate(pool, positionId, newColl, newDebt, protocolFees);\n\n    return positionId;\n  }\n\n  /// @inheritdoc IPoolManager\n  function redeem(\n    address pool,\n    uint256 debts,\n    uint256 minColls\n  ) external onlyRegisteredPool(pool) nonReentrant whenNotPaused returns (uint256 colls) {\n    if (debts > IERC20(fxUSD).balanceOf(_msgSender())) {\n      revert ErrorRedeemExceedBalance();\n    }\n\n    uint256 rawColls = IPool(pool).redeem(debts);\n\n    address collateralToken = IPool(pool).collateralToken();\n    uint256 scalingFactor = _getTokenScalingFactor(collateralToken);\n    colls = _scaleDown(rawColls, scalingFactor);\n\n    _changePoolCollateral(pool, -int256(colls), -int256(rawColls));\n    _changePoolDebts(pool, -int256(debts));\n\n    uint256 protocolFees = (colls * getRedeemFeeRatio()) / FEE_PRECISION;\n    _accumulatePoolMiscFee(pool, protocolFees);\n    colls -= protocolFees;\n    if (colls < minColls) revert ErrorInsufficientRedeemedCollateral();\n\n    _transferOut(collateralToken, colls, _msgSender());\n    IFxUSDRegeneracy(fxUSD).burn(_msgSender(), debts);\n\n    emit Redeem(pool, colls, debts, protocolFees);\n  }\n\n  /// @inheritdoc IPoolManager\n  function rebalance(\n    address pool,\n    address receiver,\n    int16 tick,\n    uint256 maxFxUSD,\n    uint256 maxStable\n  )\n    external\n    onlyRegisteredPool(pool)\n    nonReentrant\n    whenNotPaused\n    onlyFxUSDSave\n    returns (uint256 colls, uint256 fxUSDUsed, uint256 stableUsed)\n  {\n    LiquidateOrRebalanceMemoryVar memory op = _beforeRebalanceOrLiquidate(pool);\n    IPool.RebalanceResult memory result = IPool(pool).rebalance(tick, maxFxUSD + _scaleUp(maxStable, op.stablePrice));\n    op.rawColls = result.rawColls + result.bonusRawColls;\n    op.bonusRawColls = result.bonusRawColls;\n    op.rawDebts = result.rawDebts;\n    (colls, fxUSDUsed, stableUsed) = _afterRebalanceOrLiquidate(pool, maxFxUSD, op, receiver);\n\n    emit RebalanceTick(pool, tick, colls, fxUSDUsed, stableUsed);\n  }\n\n  /// @inheritdoc IPoolManager\n  function rebalance(\n    address pool,\n    address receiver,\n    uint256 maxFxUSD,\n    uint256 maxStable\n  )\n    external\n    onlyRegisteredPool(pool)\n    nonReentrant\n    whenNotPaused\n    onlyFxUSDSave\n    returns (uint256 colls, uint256 fxUSDUsed, uint256 stableUsed)\n  {\n    LiquidateOrRebalanceMemoryVar memory op = _beforeRebalanceOrLiquidate(pool);\n    IPool.RebalanceResult memory result = IPool(pool).rebalance(maxFxUSD + _scaleUp(maxStable, op.stablePrice));\n    op.rawColls = result.rawColls + result.bonusRawColls;\n    op.bonusRawColls = result.bonusRawColls;\n    op.rawDebts = result.rawDebts;\n    (colls, fxUSDUsed, stableUsed) = _afterRebalanceOrLiquidate(pool, maxFxUSD, op, receiver);\n\n    emit Rebalance(pool, colls, fxUSDUsed, stableUsed);\n  }\n\n  /// @inheritdoc IPoolManager\n  function liquidate(\n    address pool,\n    address receiver,\n    uint256 maxFxUSD,\n    uint256 maxStable\n  )\n    external\n    onlyRegisteredPool(pool)\n    nonReentrant\n    whenNotPaused\n    onlyFxUSDSave\n    returns (uint256 colls, uint256 fxUSDUsed, uint256 stableUsed)\n  {\n    LiquidateOrRebalanceMemoryVar memory op = _beforeRebalanceOrLiquidate(pool);\n    {\n      IPool.LiquidateResult memory result;\n      uint256 reservedRawColls = IReservePool(reservePool).getBalance(op.collateralToken);\n      reservedRawColls = _scaleUp(reservedRawColls, op.scalingFactor);\n      result = IPool(pool).liquidate(maxFxUSD + _scaleUp(maxStable, op.stablePrice), reservedRawColls);\n      op.rawColls = result.rawColls + result.bonusRawColls;\n      op.bonusRawColls = result.bonusRawColls;\n      op.rawDebts = result.rawDebts;\n\n      // take bonus or shortfall from reserve pool\n      uint256 bonusFromReserve = result.bonusFromReserve;\n      if (bonusFromReserve > 0) {\n        bonusFromReserve = _scaleDown(result.bonusFromReserve, op.scalingFactor);\n        IReservePool(reservePool).requestBonus(IPool(pool).collateralToken(), address(this), bonusFromReserve);\n\n        // increase pool reserve first\n        _changePoolCollateral(pool, int256(bonusFromReserve), int256(result.bonusFromReserve));\n      }\n    }\n\n    (colls, fxUSDUsed, stableUsed) = _afterRebalanceOrLiquidate(pool, maxFxUSD, op, receiver);\n\n    emit Liquidate(pool, colls, fxUSDUsed, stableUsed);\n  }\n\n  /// @inheritdoc IPoolManager\n  function harvest(\n    address pool\n  )\n    external\n    onlyRegisteredPool(pool)\n    onlyRole(HARVESTER_ROLE)\n    nonReentrant\n    returns (uint256 amountRewards, uint256 amountFunding)\n  {\n    address collateralToken = IPool(pool).collateralToken();\n    uint256 scalingFactor = _getTokenScalingFactor(collateralToken);\n\n    uint256 collateralRecorded;\n    uint256 rawCollateralRecorded;\n    {\n      bytes32 data = poolInfo[pool].collateralData;\n      collateralRecorded = data.decodeUint(COLLATERAL_BALANCE_OFFSET, COLLATERAL_DATA_BITS);\n      rawCollateralRecorded = data.decodeUint(RAW_COLLATERAL_BALANCE_OFFSET, RAW_COLLATERAL_DATA_BITS);\n    }\n    uint256 performanceFee;\n    uint256 harvestBounty;\n    uint256 pendingRewards;\n    // compute funding\n    uint256 rawCollateral = IPool(pool).getTotalRawCollaterals();\n    if (rawCollateralRecorded > rawCollateral) {\n      unchecked {\n        amountFunding = _scaleDown(rawCollateralRecorded - rawCollateral, scalingFactor);\n        _changePoolCollateral(pool, -int256(amountFunding), -int256(rawCollateralRecorded - rawCollateral));\n\n        performanceFee = (getFundingExpenseRatio() * amountFunding) / FEE_PRECISION;\n        harvestBounty = (getHarvesterRatio() * amountFunding) / FEE_PRECISION;\n        pendingRewards = amountFunding - harvestBounty - performanceFee;\n      }\n      // recorded data changed, update local cache\n      {\n        bytes32 data = poolInfo[pool].collateralData;\n        collateralRecorded = data.decodeUint(COLLATERAL_BALANCE_OFFSET, COLLATERAL_DATA_BITS);\n        rawCollateralRecorded = data.decodeUint(RAW_COLLATERAL_BALANCE_OFFSET, RAW_COLLATERAL_DATA_BITS);\n      }\n    }\n    // compute rewards\n    rawCollateral = _scaleUp(collateralRecorded, scalingFactor);\n    if (rawCollateral > rawCollateralRecorded) {\n      unchecked {\n        amountRewards = _scaleDown(rawCollateral - rawCollateralRecorded, scalingFactor);\n        _changePoolCollateral(pool, -int256(amountRewards), 0);\n\n        uint256 performanceFeeRewards = (getRewardsExpenseRatio() * amountRewards) / FEE_PRECISION;\n        uint256 harvestBountyRewards = (getHarvesterRatio() * amountRewards) / FEE_PRECISION;\n        pendingRewards += amountRewards - harvestBountyRewards - performanceFeeRewards;\n        performanceFee += performanceFeeRewards;\n        harvestBounty += harvestBountyRewards;\n      }\n    }\n\n    // transfer performance fee to treasury\n    if (performanceFee > 0) {\n      _transferOut(collateralToken, performanceFee, treasury);\n    }\n    // transfer various fees to revenue pool\n    _takeAccumulatedPoolFee(pool);\n    // transfer harvest bounty\n    if (harvestBounty > 0) {\n      _transferOut(collateralToken, harvestBounty, _msgSender());\n    }\n    // transfer rewards for fxBASE\n    if (pendingRewards > 0) {\n      address splitter = rewardSplitter[pool];\n      _transferOut(collateralToken, pendingRewards, splitter);\n      IRewardSplitter(splitter).split(collateralToken);\n    }\n\n    emit Harvest(_msgSender(), pool, amountRewards, amountFunding, performanceFee, harvestBounty);\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n  \n  /// @notice Pause or unpause the system.\n  /// @param status The pause status to update.\n  function setPause(bool status) external onlyRole(EMERGENCY_ROLE) {\n    if (status) _pause();\n    else _unpause();\n  }\n\n  /// @notice Register a new pool with reward splitter.\n  /// @param pool The address of pool.\n  /// @param splitter The address of reward splitter.\n  function registerPool(\n    address pool,\n    address splitter,\n    uint96 collateralCapacity,\n    uint96 debtCapacity\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (fxUSD != IPool(pool).fxUSD()) revert ErrorInvalidPool();\n\n    if (pools.add(pool)) {\n      emit RegisterPool(pool);\n\n      _updateRewardSplitter(pool, splitter);\n      _updatePoolCapacity(pool, collateralCapacity, debtCapacity);\n    }\n  }\n\n  /// @notice Update rate provider for the given token.\n  /// @param token The address of the token.\n  /// @param provider The address of corresponding rate provider.\n  function updateRateProvider(address token, address provider) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 scale = 10 ** (18 - IERC20Metadata(token).decimals());\n    tokenRates[token] = TokenRate(uint96(scale), provider);\n\n    emit UpdateTokenRate(token, scale, provider);\n  }\n\n  /// @notice Update the address of reward splitter for the given pool.\n  /// @param pool The address of the pool.\n  /// @param newSplitter The address of reward splitter.\n  function updateRewardSplitter(\n    address pool,\n    address newSplitter\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) onlyRegisteredPool(pool) {\n    _updateRewardSplitter(pool, newSplitter);\n  }\n\n  /// @notice Update the pool capacity.\n  /// @param pool The address of fx pool.\n  /// @param collateralCapacity The capacity for collateral token.\n  /// @param debtCapacity The capacity for debt token.\n  function updatePoolCapacity(\n    address pool,\n    uint96 collateralCapacity,\n    uint96 debtCapacity\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) onlyRegisteredPool(pool) {\n    _updatePoolCapacity(pool, collateralCapacity, debtCapacity);\n  }\n\n  /// @notice Update threshold for permissionless liquidation.\n  /// @param newThreshold The value of new threshold.\n  function updateThreshold(uint256 newThreshold) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateThreshold(newThreshold);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update the address of reward splitter for the given pool.\n  /// @param pool The address of the pool.\n  /// @param newSplitter The address of reward splitter.\n  function _updateRewardSplitter(address pool, address newSplitter) internal {\n    address oldSplitter = rewardSplitter[pool];\n    rewardSplitter[pool] = newSplitter;\n\n    emit UpdateRewardSplitter(pool, oldSplitter, newSplitter);\n  }\n\n  /// @dev Internal function to update the pool capacity.\n  /// @param pool The address of fx pool.\n  /// @param collateralCapacity The capacity for collateral token.\n  /// @param debtCapacity The capacity for debt token.\n  function _updatePoolCapacity(address pool, uint96 collateralCapacity, uint96 debtCapacity) internal {\n    poolInfo[pool].collateralData = poolInfo[pool].collateralData.insertUint(\n      collateralCapacity,\n      COLLATERAL_CAPACITY_OFFSET,\n      COLLATERAL_DATA_BITS\n    );\n    poolInfo[pool].debtData = poolInfo[pool].debtData.insertUint(debtCapacity, DEBT_CAPACITY_OFFSET, DEBT_DATA_BITS);\n\n    emit UpdatePoolCapacity(pool, collateralCapacity, debtCapacity);\n  }\n\n  /// @dev Internal function to update threshold for permissionless liquidation.\n  /// @param newThreshold The value of new threshold.\n  function _updateThreshold(uint256 newThreshold) internal {\n    uint256 oldThreshold = permissionedLiquidationThreshold;\n    permissionedLiquidationThreshold = newThreshold;\n\n    emit UpdatePermissionedLiquidationThreshold(oldThreshold, newThreshold);\n  }\n\n  /// @dev Internal function to scaler up for `uint256`.\n  function _scaleUp(uint256 value, uint256 scale) internal pure returns (uint256) {\n    return (value * scale) / PRECISION;\n  }\n\n  /// @dev Internal function to scaler up for `int256`.\n  function _scaleUp(int256 value, uint256 scale) internal pure returns (int256) {\n    return (value * int256(scale)) / PRECISION_I256;\n  }\n\n  /// @dev Internal function to scaler down for `uint256`, rounding down.\n  function _scaleDown(uint256 value, uint256 scale) internal pure returns (uint256) {\n    return (value * PRECISION) / scale;\n  }\n\n  /// @dev Internal function to scaler down for `uint256`, rounding up.\n  function _scaleDownRoundingUp(uint256 value, uint256 scale) internal pure returns (uint256) {\n    return (value * PRECISION + scale - 1) / scale;\n  }\n\n  /// @dev Internal function to scaler down for `int256`.\n  function _scaleDown(int256 value, uint256 scale) internal pure returns (int256) {\n    return (value * PRECISION_I256) / int256(scale);\n  }\n\n  /// @dev Internal function to prepare variables before rebalance or liquidate.\n  /// @param pool The address of pool to liquidate or rebalance.\n  function _beforeRebalanceOrLiquidate(address pool) internal view returns (LiquidateOrRebalanceMemoryVar memory op) {\n    op.stablePrice = IFxUSDBasePool(fxBASE).getStableTokenPriceWithScale();\n    op.collateralToken = IPool(pool).collateralToken();\n    op.scalingFactor = _getTokenScalingFactor(op.collateralToken);\n  }\n\n  /// @dev Internal function to do actions after rebalance or liquidate.\n  /// @param pool The address of pool to liquidate or rebalance.\n  /// @param maxFxUSD The maximum amount of fxUSD can be used.\n  /// @param op The memory helper variable.\n  /// @param receiver The address collateral token receiver.\n  /// @return colls The actual amount of collateral token rebalanced or liquidated.\n  /// @return fxUSDUsed The amount of fxUSD used.\n  /// @return stableUsed The amount of stable token (a.k.a USDC) used.\n  function _afterRebalanceOrLiquidate(\n    address pool,\n    uint256 maxFxUSD,\n    LiquidateOrRebalanceMemoryVar memory op,\n    address receiver\n  ) internal returns (uint256 colls, uint256 fxUSDUsed, uint256 stableUsed) {\n    colls = _scaleDown(op.rawColls, op.scalingFactor);\n    _changePoolCollateral(pool, -int256(colls), -int256(op.rawColls));\n    _changePoolDebts(pool, -int256(op.rawDebts));\n\n    // burn fxUSD or transfer USDC\n    fxUSDUsed = op.rawDebts;\n    if (fxUSDUsed > maxFxUSD) {\n      // rounding up here\n      stableUsed = _scaleDownRoundingUp(fxUSDUsed - maxFxUSD, op.stablePrice);\n      fxUSDUsed = maxFxUSD;\n    }\n    if (fxUSDUsed > 0) {\n      IFxUSDRegeneracy(fxUSD).burn(_msgSender(), fxUSDUsed);\n    }\n    if (stableUsed > 0) {\n      IERC20(IFxUSDBasePool(fxBASE).stableToken()).safeTransferFrom(_msgSender(), fxUSD, stableUsed);\n      IFxUSDRegeneracy(fxUSD).onRebalanceWithStable(stableUsed, op.rawDebts - maxFxUSD);\n    }\n\n    // transfer collateral\n    uint256 protocolRevenue = (_scaleDown(op.bonusRawColls, op.scalingFactor) * getLiquidationExpenseRatio()) /\n      FEE_PRECISION;\n    _accumulatePoolMiscFee(pool, protocolRevenue);\n    unchecked {\n      colls -= protocolRevenue;\n    }\n    _transferOut(op.collateralToken, colls, receiver);\n  }\n\n  /// @dev Internal function to update collateral balance.\n  function _changePoolCollateral(address pool, int256 delta, int256 rawDelta) internal {\n    bytes32 data = poolInfo[pool].collateralData;\n    uint256 capacity = data.decodeUint(COLLATERAL_CAPACITY_OFFSET, COLLATERAL_DATA_BITS);\n    uint256 balance = uint256(int256(data.decodeUint(COLLATERAL_BALANCE_OFFSET, COLLATERAL_DATA_BITS)) + delta);\n    if (balance > capacity) revert ErrorCollateralExceedCapacity();\n    data = data.insertUint(balance, COLLATERAL_BALANCE_OFFSET, COLLATERAL_DATA_BITS);\n    balance = uint256(int256(data.decodeUint(RAW_COLLATERAL_BALANCE_OFFSET, RAW_COLLATERAL_DATA_BITS)) + rawDelta);\n    poolInfo[pool].collateralData = data.insertUint(balance, RAW_COLLATERAL_BALANCE_OFFSET, RAW_COLLATERAL_DATA_BITS);\n  }\n\n  /// @dev Internal function to update debt balance.\n  function _changePoolDebts(address pool, int256 delta) internal {\n    bytes32 data = poolInfo[pool].debtData;\n    uint256 capacity = data.decodeUint(DEBT_CAPACITY_OFFSET, DEBT_DATA_BITS);\n    uint256 balance = uint256(int256(data.decodeUint(DEBT_BALANCE_OFFSET, DEBT_DATA_BITS)) + delta);\n    if (balance > capacity) revert ErrorDebtExceedCapacity();\n    poolInfo[pool].debtData = data.insertUint(balance, DEBT_BALANCE_OFFSET, DEBT_DATA_BITS);\n  }\n\n  /// @dev Internal function to get token scaling factor.\n  function _getTokenScalingFactor(address token) internal view returns (uint256 value) {\n    TokenRate memory rate = tokenRates[token];\n    value = rate.scalar;\n    unchecked {\n      if (rate.rateProvider != address(0)) {\n        value *= IRateProvider(rate.rateProvider).getRate();\n      } else {\n        value *= PRECISION;\n      }\n    }\n  }\n}\n",
        "ProtocolFees.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { IPool } from \"../interfaces/IPool.sol\";\nimport { IProtocolFees } from \"../interfaces/IProtocolFees.sol\";\n\nimport { WordCodec } from \"../common/codec/WordCodec.sol\";\n\nabstract contract ProtocolFees is AccessControlUpgradeable, PausableUpgradeable, IProtocolFees {\n  using SafeERC20 for IERC20;\n  using WordCodec for bytes32;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when the given address is zero.\n  error ErrorZeroAddress();\n\n  /// @dev Thrown when the expense ratio exceeds `MAX_EXPENSE_RATIO`.\n  error ErrorExpenseRatioTooLarge();\n\n  /// @dev Thrown when the harvester ratio exceeds `MAX_HARVESTER_RATIO`.\n  error ErrorHarvesterRatioTooLarge();\n\n  /// @dev Thrown when the flash loan fee ratio exceeds `MAX_FLASH_LOAN_FEE_RATIO`.\n  error ErrorFlashLoanFeeRatioTooLarge();\n\n  /// @dev Thrown when the redeem fee ratio exceeds `MAX_REDEEM_FEE_RATIO`.\n  error ErrorRedeemFeeRatioTooLarge();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The maximum expense ratio.\n  uint256 private constant MAX_EXPENSE_RATIO = 5e8; // 50%\n\n  /// @dev The maximum harvester ratio.\n  uint256 private constant MAX_HARVESTER_RATIO = 2e8; // 20%\n\n  /// @dev The maximum flash loan fee ratio.\n  uint256 private constant MAX_FLASH_LOAN_FEE_RATIO = 1e8; // 10%\n\n  /// @dev The maximum redeem fee ratio.\n  uint256 private constant MAX_REDEEM_FEE_RATIO = 1e8; // 10%\n\n  /// @dev The offset of general expense ratio in `_miscData`.\n  uint256 private constant REWARDS_EXPENSE_RATIO_OFFSET = 0;\n\n  /// @dev The offset of harvester ratio in `_miscData`.\n  uint256 private constant HARVESTER_RATIO_OFFSET = 30;\n\n  /// @dev The offset of flash loan ratio in `_miscData`.\n  uint256 private constant FLASH_LOAN_RATIO_OFFSET = 60;\n\n  /// @dev The offset of redeem fee ratio in `_miscData`.\n  uint256 private constant REDEEM_FEE_RATIO_OFFSET = 90;\n\n  /// @dev The offset of funding expense ratio in `_miscData`.\n  uint256 private constant FUNDING_EXPENSE_RATIO_OFFSET = 120;\n\n  /// @dev The offset of liquidation expense ratio in `_miscData`.\n  uint256 private constant LIQUIDATION_EXPENSE_RATIO_OFFSET = 150;\n\n  /// @dev The precision used to compute fees.\n  uint256 internal constant FEE_PRECISION = 1e9;\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @dev `_miscData` is a storage slot that can be used to store unrelated pieces of information.\n  /// All pools store the *expense ratio*, *harvester ratio* and *withdraw fee percentage*, but\n  /// the `miscData`can be extended to store more pieces of information.\n  ///\n  /// The *expense ratio* is stored in the first most significant 32 bits, and the *harvester ratio* is\n  /// stored in the next most significant 32 bits, and the *withdraw fee percentage* is stored in the\n  /// next most significant 32 bits, leaving the remaining 160 bits free to store any other information\n  /// derived pools might need.\n  ///\n  /// - The *expense ratio* and *harvester ratio* are charged each time when harvester harvest the pool revenue.\n  /// - The *withdraw fee percentage* is charged each time when user try to withdraw assets from the pool.\n  ///\n  /// [ rewards expense ratio | harvester ratio | flash loan ratio | redeem ratio | funding expense ratio | liquidation expense ratio | available ]\n  /// [        30 bits        |     30 bits     |     30  bits     |   30  bits   |        30 bits        |          30 bits          |  76 bits  ]\n  /// [ MSB                                                                                                                                   LSB ]\n  bytes32 internal _miscData;\n\n  /// @inheritdoc IProtocolFees\n  address public treasury;\n\n  /// @inheritdoc IProtocolFees\n  /// @dev Hold fees including open.\n  address public openRevenuePool;\n\n  /// @inheritdoc IProtocolFees\n  address public reservePool;\n\n  /// @inheritdoc IProtocolFees\n  mapping(address => uint256) public accumulatedPoolOpenFees;\n\n  /// @inheritdoc IProtocolFees\n  /// @dev Hold fees including close\n  address public closeRevenuePool;\n\n  /// @inheritdoc IProtocolFees\n  mapping(address => uint256) public accumulatedPoolCloseFees;\n\n  /// @inheritdoc IProtocolFees\n  /// @dev Hold fees including redeem, liquidation and rebalance.\n  address public miscRevenuePool;\n\n  /// @inheritdoc IProtocolFees\n  mapping(address => uint256) public accumulatedPoolMiscFees;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  function __ProtocolFees_init(\n    uint256 _expenseRatio,\n    uint256 _harvesterRatio,\n    uint256 _flashLoanFeeRatio,\n    address _treasury,\n    address _revenuePool,\n    address _reservePool\n  ) internal onlyInitializing {\n    _updateFundingExpenseRatio(_expenseRatio);\n    _updateRewardsExpenseRatio(_expenseRatio);\n    _updateLiquidationExpenseRatio(_expenseRatio);\n    _updateHarvesterRatio(_harvesterRatio);\n    _updateFlashLoanFeeRatio(_flashLoanFeeRatio);\n    _updateTreasury(_treasury);\n    _updateOpenRevenuePool(_revenuePool);\n    _updateCloseRevenuePool(_revenuePool);\n    _updateMiscRevenuePool(_revenuePool);\n    _updateReservePool(_reservePool);\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc IProtocolFees\n  function getFundingExpenseRatio() public view returns (uint256) {\n    return _miscData.decodeUint(FUNDING_EXPENSE_RATIO_OFFSET, 30);\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getRewardsExpenseRatio() public view returns (uint256) {\n    return _miscData.decodeUint(REWARDS_EXPENSE_RATIO_OFFSET, 30);\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getLiquidationExpenseRatio() public view returns (uint256) {\n    return _miscData.decodeUint(LIQUIDATION_EXPENSE_RATIO_OFFSET, 30);\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getHarvesterRatio() public view returns (uint256) {\n    return _miscData.decodeUint(HARVESTER_RATIO_OFFSET, 30);\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getFundingFxSaveRatio() external view returns (uint256) {\n    return FEE_PRECISION - getFundingExpenseRatio() - getHarvesterRatio();\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getRewardsFxSaveRatio() external view returns (uint256) {\n    return FEE_PRECISION - getRewardsExpenseRatio() - getHarvesterRatio();\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getFlashLoanFeeRatio() public view returns (uint256) {\n    return _miscData.decodeUint(FLASH_LOAN_RATIO_OFFSET, 30);\n  }\n\n  /// @inheritdoc IProtocolFees\n  function getRedeemFeeRatio() public view returns (uint256) {\n    return _miscData.decodeUint(REDEEM_FEE_RATIO_OFFSET, 30);\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc IProtocolFees\n  function withdrawAccumulatedPoolFee(address[] memory pools) external {\n    for (uint256 i = 0; i < pools.length; ++i) {\n      _takeAccumulatedPoolFee(pools[i]);\n    }\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Change address of reserve pool contract.\n  /// @param _newReservePool The new address of reserve pool contract.\n  function updateReservePool(address _newReservePool) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateReservePool(_newReservePool);\n  }\n\n  /// @notice Change address of treasury contract.\n  /// @param _newTreasury The new address of treasury contract.\n  function updateTreasury(address _newTreasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateTreasury(_newTreasury);\n  }\n\n  /// @notice Change address of open revenue pool contract.\n  /// @param _newPool The new address of revenue pool contract.\n  function updateOpenRevenuePool(address _newPool) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateOpenRevenuePool(_newPool);\n  }\n\n  /// @notice Change address of close revenue pool contract.\n  /// @param _newPool The new address of revenue pool contract.\n  function updateCloseRevenuePool(address _newPool) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateCloseRevenuePool(_newPool);\n  }\n\n  /// @notice Change address of misc revenue pool contract.\n  /// @param _newPool The new address of revenue pool contract.\n  function updateMiscRevenuePool(address _newPool) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateMiscRevenuePool(_newPool);\n  }\n\n  /// @notice Update the fee ratio distributed to treasury.\n  /// @param newRewardsRatio The new ratio for rewards to update, multiplied by 1e9.\n  /// @param newFundingRatio The new ratio for funding to update, multiplied by 1e9.\n  /// @param newLiquidationRatio The new ratio for liquidation/rebalance to update, multiplied by 1e9.\n  function updateExpenseRatio(\n    uint32 newRewardsRatio,\n    uint32 newFundingRatio,\n    uint32 newLiquidationRatio\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateRewardsExpenseRatio(newRewardsRatio);\n    _updateFundingExpenseRatio(newFundingRatio);\n    _updateLiquidationExpenseRatio(newLiquidationRatio);\n  }\n\n  /// @notice Update the fee ratio distributed to harvester.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function updateHarvesterRatio(uint32 newRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateHarvesterRatio(newRatio);\n  }\n\n  /// @notice Update the flash loan fee ratio.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function updateFlashLoanFeeRatio(uint32 newRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateFlashLoanFeeRatio(newRatio);\n  }\n\n  /// @notice Update the redeem fee ratio.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function updateRedeemFeeRatio(uint32 newRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateRedeemFeeRatio(newRatio);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to change address of treasury contract.\n  /// @param _newTreasury The new address of treasury contract.\n  function _updateTreasury(address _newTreasury) private {\n    if (_newTreasury == address(0)) revert ErrorZeroAddress();\n\n    address _oldTreasury = treasury;\n    treasury = _newTreasury;\n\n    emit UpdateTreasury(_oldTreasury, _newTreasury);\n  }\n\n  /// @dev Internal function to change address of revenue pool contract.\n  /// @param _newPool The new address of revenue pool contract.\n  function _updateOpenRevenuePool(address _newPool) private {\n    if (_newPool == address(0)) revert ErrorZeroAddress();\n\n    address _oldPool = openRevenuePool;\n    openRevenuePool = _newPool;\n\n    emit UpdateOpenRevenuePool(_oldPool, _newPool);\n  }\n\n  /// @dev Internal function to change address of revenue pool contract.\n  /// @param _newPool The new address of revenue pool contract.\n  function _updateCloseRevenuePool(address _newPool) private {\n    if (_newPool == address(0)) revert ErrorZeroAddress();\n\n    address _oldPool = closeRevenuePool;\n    closeRevenuePool = _newPool;\n\n    emit UpdateCloseRevenuePool(_oldPool, _newPool);\n  }\n\n  /// @dev Internal function to change address of revenue pool contract.\n  /// @param _newPool The new address of revenue pool contract.\n  function _updateMiscRevenuePool(address _newPool) private {\n    if (_newPool == address(0)) revert ErrorZeroAddress();\n\n    address _oldPool = miscRevenuePool;\n    miscRevenuePool = _newPool;\n\n    emit UpdateMiscRevenuePool(_oldPool, _newPool);\n  }\n\n  /// @dev Internal function to change the address of reserve pool contract.\n  /// @param newReservePool The new address of reserve pool contract.\n  function _updateReservePool(address newReservePool) private {\n    if (newReservePool == address(0)) revert ErrorZeroAddress();\n\n    address oldReservePool = reservePool;\n    reservePool = newReservePool;\n\n    emit UpdateReservePool(oldReservePool, newReservePool);\n  }\n\n  /// @dev Internal function to update the fee ratio distributed to treasury.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function _updateRewardsExpenseRatio(uint256 newRatio) private {\n    if (uint256(newRatio) > MAX_EXPENSE_RATIO) {\n      revert ErrorExpenseRatioTooLarge();\n    }\n\n    bytes32 _data = _miscData;\n    uint256 _oldRatio = _miscData.decodeUint(REWARDS_EXPENSE_RATIO_OFFSET, 30);\n    _miscData = _data.insertUint(newRatio, REWARDS_EXPENSE_RATIO_OFFSET, 30);\n\n    emit UpdateRewardsExpenseRatio(_oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to update the fee ratio distributed to treasury.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function _updateLiquidationExpenseRatio(uint256 newRatio) private {\n    if (uint256(newRatio) > MAX_EXPENSE_RATIO) {\n      revert ErrorExpenseRatioTooLarge();\n    }\n\n    bytes32 _data = _miscData;\n    uint256 _oldRatio = _miscData.decodeUint(LIQUIDATION_EXPENSE_RATIO_OFFSET, 30);\n    _miscData = _data.insertUint(newRatio, LIQUIDATION_EXPENSE_RATIO_OFFSET, 30);\n\n    emit UpdateLiquidationExpenseRatio(_oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to update the fee ratio distributed to treasury.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function _updateFundingExpenseRatio(uint256 newRatio) private {\n    if (uint256(newRatio) > MAX_EXPENSE_RATIO) {\n      revert ErrorExpenseRatioTooLarge();\n    }\n\n    bytes32 _data = _miscData;\n    uint256 _oldRatio = _miscData.decodeUint(FUNDING_EXPENSE_RATIO_OFFSET, 30);\n    _miscData = _data.insertUint(newRatio, FUNDING_EXPENSE_RATIO_OFFSET, 30);\n\n    emit UpdateFundingExpenseRatio(_oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to update the fee ratio distributed to harvester.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function _updateHarvesterRatio(uint256 newRatio) private {\n    if (uint256(newRatio) > MAX_HARVESTER_RATIO) {\n      revert ErrorHarvesterRatioTooLarge();\n    }\n\n    bytes32 _data = _miscData;\n    uint256 _oldRatio = _miscData.decodeUint(HARVESTER_RATIO_OFFSET, 30);\n    _miscData = _data.insertUint(newRatio, HARVESTER_RATIO_OFFSET, 30);\n\n    emit UpdateHarvesterRatio(_oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to update the flash loan fee ratio.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function _updateFlashLoanFeeRatio(uint256 newRatio) private {\n    if (uint256(newRatio) > MAX_FLASH_LOAN_FEE_RATIO) {\n      revert ErrorFlashLoanFeeRatioTooLarge();\n    }\n\n    bytes32 _data = _miscData;\n    uint256 _oldRatio = _miscData.decodeUint(FLASH_LOAN_RATIO_OFFSET, 30);\n    _miscData = _data.insertUint(newRatio, FLASH_LOAN_RATIO_OFFSET, 30);\n\n    emit UpdateFlashLoanFeeRatio(_oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to update the redeem fee ratio.\n  /// @param newRatio The new ratio to update, multiplied by 1e9.\n  function _updateRedeemFeeRatio(uint256 newRatio) private {\n    if (uint256(newRatio) > MAX_REDEEM_FEE_RATIO) {\n      revert ErrorRedeemFeeRatioTooLarge();\n    }\n\n    bytes32 _data = _miscData;\n    uint256 _oldRatio = _miscData.decodeUint(REDEEM_FEE_RATIO_OFFSET, 30);\n    _miscData = _data.insertUint(newRatio, REDEEM_FEE_RATIO_OFFSET, 30);\n\n    emit UpdateRedeemFeeRatio(_oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to accumulate protocol fee for the given pool.\n  /// @param pool The address of pool.\n  /// @param amount The amount of protocol fee.\n  function _accumulatePoolOpenFee(address pool, uint256 amount) internal {\n    if (amount > 0) {\n      accumulatedPoolOpenFees[pool] += amount;\n    }\n  }\n\n  /// @dev Internal function to accumulate protocol fee for the given pool.\n  /// @param pool The address of pool.\n  /// @param amount The amount of protocol fee.\n  function _accumulatePoolCloseFee(address pool, uint256 amount) internal {\n    if (amount > 0) {\n      accumulatedPoolCloseFees[pool] += amount;\n    }\n  }\n\n  /// @dev Internal function to accumulate protocol fee for the given pool.\n  /// @param pool The address of pool.\n  /// @param amount The amount of protocol fee.\n  function _accumulatePoolMiscFee(address pool, uint256 amount) internal {\n    if (amount > 0) {\n      accumulatedPoolMiscFees[pool] += amount;\n    }\n  }\n\n  /// @dev Internal function to withdraw accumulated protocol fee for the given pool.\n  /// @param pool The address of pool.\n  function _takeAccumulatedPoolFee(address pool) internal returns (uint256 fees) {\n    address collateralToken = IPool(pool).collateralToken();\n    fees = accumulatedPoolOpenFees[pool];\n    if (fees > 0) {\n      IERC20(collateralToken).safeTransfer(openRevenuePool, fees);\n      accumulatedPoolOpenFees[pool] = 0;\n    }\n    fees = accumulatedPoolCloseFees[pool];\n    if (fees > 0) {\n      IERC20(collateralToken).safeTransfer(closeRevenuePool, fees);\n      accumulatedPoolCloseFees[pool] = 0;\n    }\n    fees = accumulatedPoolMiscFees[pool];\n    if (fees > 0) {\n      IERC20(collateralToken).safeTransfer(miscRevenuePool, fees);\n      accumulatedPoolMiscFees[pool] = 0;\n    }\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[41] private __gap;\n}\n"
    }
}