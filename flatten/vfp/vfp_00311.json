{
    "vfp_id": "vfp_00311",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Span Handling in _finalize() Causes Permanent Finalization Halt",
            "description": "The _finalize() function in the Inbox contract assumes that each processed proposal both starts and ends at lastFinalizedProposalId + 1, which only holds true when transitionRecord.span == 1. When span > 1 (as used in optimized inboxes), the function finalizes multiple proposals but only advances lastFinalizedProposalId by one, creating a state inconsistency. This causes subsequent finalization attempts to fail because the next expected proposal ID does not have a corresponding transition record, as aggregated records are stored under the first proposal ID in the span. As a result, finalization halts permanently, unfinalized proposals accumulate, and the ring buffer eventually fills, preventing new proposals. This leads to a complete denial of service on the rollup, with prover bonds remaining locked indefinitely.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol::_finalize#955-1046",
                "InboxOptimized1.sol::_buildAndSaveAggregatedTransitionRecords"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Finalization Denial of Service due to Forced Record Hash Mismatch",
            "description": "The Inbox and InboxOptimized1 contracts implement a conflict detection mechanism that sets the finalization deadline to the maximum value when a transition record hash mismatch occurs. However, this mechanism is too rigid and can be triggered by valid, non-contradictory proofs that differ only in structure or bond instructions. Three vectors exist: aggregation vs. single-step proofs, time-dependent bond variance near proving window boundaries, and prover-dependent bond differences. In each case, honest provers can generate different hashes for valid transitions, causing the system to treat them as conflicting and freeze finalization. This design flaw exposes a denial-of-service vector where the rollup's finalization is permanently blocked due to benign variations in proof data, undermining liveness and decentralization.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol",
                "InboxOptimized1.sol",
                "LibBondInstruction.sol"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Proving Window Misconfiguration Leads to Altered Bond Mechanics",
            "description": "The `Inbox` contract does not enforce that `extendedProvingWindow >= provingWindow` during initialization. This allows a misconfigured deployment where the extended window is shorter than the base proving window, which collapses the \"late\" proof interval and causes all proofs submitted after `provingWindow` to be classified as \"very-late\".\n\nThe root cause is the lack of input validation in the constructor. The bond classification logic in `_buildTransitionRecord` relies on these windows to determine whether a proof is on-time, late, or very-late. When `extendedProvingWindow < provingWindow`, the condition for \"late\" proofs becomes impossible to satisfy, so all delayed proofs are treated as very-late, shifting bond responsibilities from the designated prover to the proposer and altering incentive structures.\n\nThe impact is a distortion of the intended economic incentives for provers. For example, a proof submitted within what should be the \"late\" window may be penalized as \"very-late\", discouraging external provers and reducing liveness. This could be exploited by proposers to manipulate bond payouts or avoid accountability for delayed proofs.\n",
            "severity": "Medium",
            "location": [
                "Inbox.sol::#166-188",
                "Inbox.sol::_buildTransitionRecord",
                "LibBondInstruction.sol::calculateBondInstructions#67-109",
                "Anchor.sol::_processBondInstructions#428-463"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Re-activation Causes Permanent DoS Due to Stale Ring Buffer State",
            "description": "The `activate` function in the `Inbox` contract resets `nextProposalId` but does not clear the `_proposalHashes` ring buffer. If proposals were submitted between the first and second activation, their hashes remain in the buffer. After reset, when a new proposal is submitted with `id = 1`, the contract detects a non-zero hash at index 1 and triggers wrap-around logic, requiring the proposal ID in that slot (which is 1) to be less than the genesis proposal ID (0). Since 1 < 0 is impossible, all future proposals revert.\n\nThe root cause is incomplete state reset logic in the `_activateInbox` function. The ring buffer is not cleared, leading to a contradiction in the chain head verification logic after reactivation. This creates a permanent denial-of-service condition that renders the contract unusable.\n\nThe impact is a complete halt of proposal submission and chain progression if `activate` is called twice within the 2-hour window. Although the function is time-locked, this vulnerability poses a critical risk during recovery scenarios or L1 reorgs, potentially leading to irreversible chain downtime.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol::activate#208",
                "Inbox.sol::_verifyChainHead",
                "_proposalHashes ring buffer"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Gas Asymmetry and Low-Bond Path Enable Griefing of Previous Prover",
            "description": "There is a structural gas asymmetry between proposing and proving blocks, where proving is significantly more expensive than proposing. When a proposer is in a low-bond state (e.g., after slashing or withdrawal request), the protocol automatically assigns the previous prover as the designated prover without requiring authentication or paying a prover fee. This allows a low-bond proposer to force the previous prover to incur high proving costs without compensation, creating a griefing vector.\n\nThe root cause is the protocol design decision to waive prover authentication and fees in low-bond cases while still imposing high proving costs. An attacker (or misbehaving proposer) can exploit this by repeatedly submitting proposals while in a low-bond state, forcing the previous prover to prove them at a net loss.\n\nThe impact is a denial-of-service-like condition against the previous prover, who may be forced to bear unsustainable gas costs. While the team acknowledges the issue and plans to eject low-bond operators from the whitelist, the current design allows this griefing scenario to persist until enforcement is implemented off-chain.\n",
            "severity": "High",
            "location": [
                "Inbox.sol::propose#232",
                "Inbox.sol::prove#300",
                "Anchor.sol::setDesignatedProver#302-304"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Ring Buffer Size of 1 Makes Inbox Permanently Unable to Accept Proposals",
            "description": "The `Inbox` contract uses a ring buffer to manage proposals, with available capacity calculated as `ringBufferSize - 1 - unfinalizedProposalCount`. When `ringBufferSize == 1`, this formula always yields zero capacity, even when no proposals are unfinalized. After the genesis block is seeded via `activate`, any call to `propose` will revert with `NotEnoughCapacity()`.\n\nThe root cause is the lack of input validation in the constructor, which only checks for `ringBufferSize == 0` but allows `ringBufferSize == 1`. This is a configuration-level vulnerability that leads to a permanent liveness failure: the contract becomes unable to accept any new proposals after initialization.\n\nAn attacker or misconfigured deployment could set `ringBufferSize = 1`, rendering the system non-operational. The impact is a complete halt in block proposal processing, resulting in a denial of service for the entire rollup.\n\nThe fix requires the constructor to enforce `ringBufferSize >= 2` to ensure at least one usable slot is available.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol::_getAvailableCapacity#1081-1087",
                "Inbox.sol::constructor#166-179",
                "Inbox.sol::propose#250-252"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        }
    ],
    "affected_files": {
        "Inbox.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IForcedInclusionStore } from \"../iface/IForcedInclusionStore.sol\";\nimport { IInbox } from \"../iface/IInbox.sol\";\nimport { IProposerChecker } from \"../iface/IProposerChecker.sol\";\nimport { LibBlobs } from \"../libs/LibBlobs.sol\";\nimport { LibBondInstruction } from \"../libs/LibBondInstruction.sol\";\nimport { LibForcedInclusion } from \"../libs/LibForcedInclusion.sol\";\nimport { LibHashSimple } from \"../libs/LibHashSimple.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IProofVerifier } from \"src/layer1/verifiers/IProofVerifier.sol\";\nimport { EssentialContract } from \"src/shared/common/EssentialContract.sol\";\nimport { LibAddress } from \"src/shared/libs/LibAddress.sol\";\nimport { LibBonds } from \"src/shared/libs/LibBonds.sol\";\nimport { LibMath } from \"src/shared/libs/LibMath.sol\";\nimport { ICheckpointStore } from \"src/shared/signal/ICheckpointStore.sol\";\n\nimport \"./Inbox_Layout.sol\"; // DO NOT DELETE\n\n/// @title Inbox\n/// @notice Core contract for managing L2 proposals, proof verification, and forced inclusion in\n/// Taiko's based rollup architecture.\n/// @dev The Pacaya inbox contract is not being upgraded to the Shasta implementation;\n///      instead, Shasta uses a separate inbox address.\n/// @dev This contract implements the fundamental inbox logic including:\n///      - Proposal submission with forced inclusion support\n///      - Proof verification with transition record management\n///      - Ring buffer storage for efficient state management\n///      - Bond instruction calculation(but actual funds are managed on L2)\n///      - Finalization of proven proposals with checkpoint rate limiting\n/// @custom:security-contact security@taiko.xyz\ncontract Inbox is IInbox, IForcedInclusionStore, EssentialContract {\n    using LibAddress for address;\n    using LibMath for uint48;\n    using LibMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------\n    // Constants\n    // ---------------------------------------------------------------\n    uint256 private constant ACTIVATION_WINDOW = 2 hours;\n\n    // ---------------------------------------------------------------\n    // Structs\n    // ---------------------------------------------------------------\n\n    /// @notice Struct for storing transition effective timestamp and hash.\n    /// @dev Stores transition record hash and finalization deadline.\n    struct TransitionRecordHashAndDeadline {\n        bytes26 recordHash;\n        uint48 finalizationDeadline;\n    }\n\n    /// @notice Result from consuming forced inclusions\n    struct ConsumptionResult {\n        IInbox.DerivationSource[] sources;\n        bool allowsPermissionless;\n    }\n\n    // ---------------------------------------------------------------\n    // Events\n    // ---------------------------------------------------------------\n\n    event InboxActivated(bytes32 lastPacayaBlockHash);\n\n    // ---------------------------------------------------------------\n    // Immutable Variables\n    // ---------------------------------------------------------------\n\n    /// @notice The codec used for encoding and hashing.\n    address private immutable _codec;\n\n    /// @notice The token used for bonds.\n    IERC20 internal immutable _bondToken;\n\n    /// @notice The proof verifier contract.\n    IProofVerifier internal immutable _proofVerifier;\n\n    /// @notice The proposer checker contract.\n    IProposerChecker internal immutable _proposerChecker;\n\n    /// @notice The proving window in seconds.\n    uint48 internal immutable _provingWindow;\n\n    /// @notice The extended proving window in seconds.\n    uint48 internal immutable _extendedProvingWindow;\n\n    /// @notice The maximum number of proposals that can be finalized in one finalization call.\n    uint256 internal immutable _maxFinalizationCount;\n\n    /// @notice The finalization grace period in seconds.\n    uint48 internal immutable _finalizationGracePeriod;\n\n    /// @notice The ring buffer size for storing proposal hashes.\n    uint256 internal immutable _ringBufferSize;\n\n    /// @notice The percentage of basefee paid to coinbase.\n    uint8 internal immutable _basefeeSharingPctg;\n\n    /// @notice The minimum number of forced inclusions that the proposer is forced to process if\n    /// they are due.\n    uint256 internal immutable _minForcedInclusionCount;\n\n    /// @notice The delay for forced inclusions measured in seconds.\n    uint16 internal immutable _forcedInclusionDelay;\n\n    /// @notice The base fee for forced inclusions in Gwei.\n    uint64 internal immutable _forcedInclusionFeeInGwei;\n\n    /// @notice Queue size at which the fee doubles. See IInbox.Config for formula details.\n    uint64 internal immutable _forcedInclusionFeeDoubleThreshold;\n\n    /// @notice The minimum delay between checkpoints in seconds.\n    uint16 internal immutable _minCheckpointDelay;\n\n    /// @notice The multiplier to determine when a forced inclusion is too old so that proposing\n    /// becomes permissionless\n    uint8 internal immutable _permissionlessInclusionMultiplier;\n\n    /// @notice Version identifier for composite key generation\n    /// @dev Used to invalidate all proved but unfinalized transition records to recover from\n    /// potential proof verifier bugs\n    uint16 internal immutable _compositeKeyVersion;\n\n    /// @notice Checkpoint store responsible for checkpoints\n    ICheckpointStore internal immutable _checkpointStore;\n\n    // ---------------------------------------------------------------\n    // State Variables\n    // ---------------------------------------------------------------\n\n    /// @notice The timestamp when the first activation occurred.\n    uint48 public activationTimestamp;\n\n    /// @notice Flag indicating whether a conflicting transition record has been detected\n    bool public conflictingTransitionDetected;\n\n    /// @dev Ring buffer for storing proposal hashes indexed by buffer slot\n    /// - bufferSlot: The ring buffer slot calculated as proposalId % ringBufferSize\n    /// - proposalHash: The keccak256 hash of the Proposal struct\n    mapping(uint256 bufferSlot => bytes32 proposalHash) internal _proposalHashes;\n\n    /// @dev Simple mapping for storing transition record hashes\n    /// @dev We do not use a ring buffer for this mapping, since a nested mapping does not benefit\n    /// from it\n    /// @dev Stores transition records for proposals with different parent transitions\n    /// - compositeKey: Keccak256 hash of (proposalId, parentTransitionHash)\n    /// - value: The struct contains the finalization deadline and the hash of the TransitionRecord\n    mapping(bytes32 compositeKey => TransitionRecordHashAndDeadline hashAndDeadline) internal\n        _transitionRecordHashAndDeadline;\n\n    /// @dev Storage for forced inclusion requests\n    /// @dev 2 slots used\n    LibForcedInclusion.Storage private _forcedInclusionStorage;\n\n    uint256[37] private __gap;\n\n    // ---------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------\n\n    /// @notice Initializes the Inbox contract\n    /// @param _config Configuration struct containing all constructor parameters\n    constructor(IInbox.Config memory _config) {\n        require(_config.checkpointStore != address(0), ZERO_ADDRESS());\n        require(_config.ringBufferSize != 0, RingBufferSizeZero());\n\n        _codec = _config.codec;\n        _bondToken = IERC20(_config.bondToken);\n        _proofVerifier = IProofVerifier(_config.proofVerifier);\n        _proposerChecker = IProposerChecker(_config.proposerChecker);\n        _checkpointStore = ICheckpointStore(_config.checkpointStore);\n        _provingWindow = _config.provingWindow;\n        _extendedProvingWindow = _config.extendedProvingWindow;\n        _maxFinalizationCount = _config.maxFinalizationCount;\n        _finalizationGracePeriod = _config.finalizationGracePeriod;\n        _ringBufferSize = _config.ringBufferSize;\n        _basefeeSharingPctg = _config.basefeeSharingPctg;\n        _minForcedInclusionCount = _config.minForcedInclusionCount;\n        _forcedInclusionDelay = _config.forcedInclusionDelay;\n        _forcedInclusionFeeInGwei = _config.forcedInclusionFeeInGwei;\n        _forcedInclusionFeeDoubleThreshold = _config.forcedInclusionFeeDoubleThreshold;\n        _minCheckpointDelay = _config.minCheckpointDelay;\n        _permissionlessInclusionMultiplier = _config.permissionlessInclusionMultiplier;\n        _compositeKeyVersion = _config.compositeKeyVersion;\n    }\n\n    // ---------------------------------------------------------------\n    // External Functions\n    // ---------------------------------------------------------------\n\n    /// @notice Initializes the owner of the inbox.\n    /// @param _owner The owner of this contract\n    function init(address _owner) external initializer {\n        __Essential_init(_owner);\n    }\n\n    /// @notice Activates the inbox so that it can start accepting proposals.\n    /// @dev The `propose` function implicitly checks that activation has occurred by verifying\n    ///      the genesis proposal (ID 0) exists in storage via `_verifyChainHead` â†’\n    ///      `_checkProposalHash`. If `activate` hasn't been called, the genesis proposal won't\n    ///      exist and `propose` will revert with `ProposalHashMismatch()`.\n    ///      This function can be called multiple times to handle L1 reorgs where the last Pacaya\n    ///      block may change after this function is called.\n    /// @param _lastPacayaBlockHash The hash of the last Pacaya block\n    function activate(bytes32 _lastPacayaBlockHash) external onlyOwner {\n        require(_lastPacayaBlockHash != 0, InvalidLastPacayaBlockHash());\n        if (activationTimestamp == 0) {\n            activationTimestamp = uint48(block.timestamp);\n        } else {\n            require(\n                block.timestamp <= ACTIVATION_WINDOW + activationTimestamp,\n                ActivationPeriodExpired()\n            );\n        }\n        _activateInbox(_lastPacayaBlockHash);\n        emit InboxActivated(_lastPacayaBlockHash);\n    }\n\n    /// @inheritdoc IInbox\n    /// @notice Proposes new L2 blocks and forced inclusions to the rollup using blobs for DA.\n    /// @dev Key behaviors:\n    ///      1. Validates proposer authorization via `IProposerChecker`\n    ///      2. Finalizes eligible proposals up to `config.maxFinalizationCount` to free ring buffer\n    ///         space.\n    ///      3. Process `input.numForcedInclusions` forced inclusions. The proposer is forced to\n    ///         process at least `config.minForcedInclusionCount` if they are due.\n    ///      4. Updates core state and emits `Proposed` event\n    /// NOTE: This function can only be called once per block to prevent spams that can fill the ring buffer.\n    function propose(bytes calldata _lookahead, bytes calldata _data) external nonReentrant {\n        unchecked {\n            // Decode and validate input data\n            ProposeInput memory input = _decodeProposeInput(_data);\n\n            _validateProposeInput(input);\n\n            // Verify parentProposals[0] is actually the last proposal stored on-chain.\n            _verifyChainHead(input.parentProposals);\n\n            // IMPORTANT: Finalize first to free ring buffer space and prevent deadlock\n            (CoreState memory coreState, LibBonds.BondInstruction[] memory bondInstructions) =\n                _finalize(input);\n\n            // Enforce one propose call per Ethereum block to prevent spam attacks that could\n            // deplete the ring buffer\n            coreState.lastProposalBlockId = uint48(block.number);\n\n            // Verify capacity for new proposals\n            require(_getAvailableCapacity(coreState) > 0, NotEnoughCapacity());\n\n            // Consume forced inclusions (validation happens inside)\n            ConsumptionResult memory result =\n                _consumeForcedInclusions(msg.sender, input.numForcedInclusions);\n\n            // Add normal proposal source in last slot\n            result.sources[result.sources.length - 1] =\n                DerivationSource(false, LibBlobs.validateBlobReference(input.blobReference));\n\n            // If forced inclusion is old enough, allow anyone to propose\n            // and set endOfSubmissionWindowTimestamp = 0\n            // Otherwise, only the current preconfer can propose\n            uint48 endOfSubmissionWindowTimestamp = result.allowsPermissionless\n                ? 0\n                : _proposerChecker.checkProposer(msg.sender, _lookahead);\n\n            // Create single proposal with multi-source derivation\n            // Use previous block as the origin for the proposal to be able to call `blockhash`\n            uint256 parentBlockNumber = block.number - 1;\n\n            Derivation memory derivation = Derivation({\n                originBlockNumber: uint48(parentBlockNumber),\n                originBlockHash: blockhash(parentBlockNumber),\n                basefeeSharingPctg: _basefeeSharingPctg,\n                sources: result.sources\n            });\n\n            // Increment nextProposalId (lastProposalBlockId was already set above)\n            Proposal memory proposal = Proposal({\n                id: coreState.nextProposalId++,\n                timestamp: uint48(block.timestamp),\n                endOfSubmissionWindowTimestamp: endOfSubmissionWindowTimestamp,\n                proposer: msg.sender,\n                coreStateHash: _hashCoreState(coreState),\n                derivationHash: _hashDerivation(derivation)\n            });\n\n            _setProposalHash(proposal.id, _hashProposal(proposal));\n            _emitProposedEvent(proposal, derivation, coreState, bondInstructions);\n        }\n    }\n\n    /// @inheritdoc IInbox\n    /// @notice Proves the validity of proposed L2 blocks\n    /// @dev Validates transitions, calculates bond instructions, and verifies proofs\n    /// NOTE: this function sends the proposal age to the proof verifier when proving a single proposal.\n    /// This can be used by the verifier system to change its behavior\n    /// if the proposal is too old(e.g. this can serve as a signal that a prover killer proposal was produced)\n    function prove(bytes calldata _data, bytes calldata _proof) external nonReentrant {\n        // Decode and validate input\n        ProveInput memory input = _decodeProveInput(_data);\n        require(input.proposals.length != 0, EmptyProposals());\n        require(input.proposals.length == input.transitions.length, InconsistentParams());\n        require(input.transitions.length == input.metadata.length, InconsistentParams());\n\n        // Build transition records with validation and bond calculations\n        _buildAndSaveTransitionRecords(input);\n\n        uint256 proposalAge;\n        if (input.proposals.length == 1) {\n            unchecked {\n                proposalAge = block.timestamp - input.proposals[0].timestamp;\n            }\n        }\n\n        bytes32 aggregatedProvingHash =\n            _hashTransitionsWithMetadata(input.transitions, input.metadata);\n\n        _proofVerifier.verifyProof(proposalAge, aggregatedProvingHash, _proof);\n    }\n\n    /// @inheritdoc IForcedInclusionStore\n    function saveForcedInclusion(LibBlobs.BlobReference memory _blobReference) external payable {\n        uint256 refund = LibForcedInclusion.saveForcedInclusion(\n            _forcedInclusionStorage,\n            _forcedInclusionFeeInGwei,\n            _forcedInclusionFeeDoubleThreshold,\n            _blobReference\n        );\n\n        // Refund excess payment to the sender\n        if (refund > 0) {\n            msg.sender.sendEtherAndVerify(refund);\n        }\n    }\n\n    // ---------------------------------------------------------------\n    // External View Functions\n    // ---------------------------------------------------------------\n    /// @inheritdoc IForcedInclusionStore\n    function getCurrentForcedInclusionFee() external view returns (uint64 feeInGwei_) {\n        return LibForcedInclusion.getCurrentForcedInclusionFee(\n            _forcedInclusionStorage, _forcedInclusionFeeInGwei, _forcedInclusionFeeDoubleThreshold\n        );\n    }\n\n    /// @inheritdoc IForcedInclusionStore\n    function getForcedInclusions(\n        uint48 _start,\n        uint48 _maxCount\n    )\n        external\n        view\n        returns (IForcedInclusionStore.ForcedInclusion[] memory inclusions_)\n    {\n        return LibForcedInclusion.getForcedInclusions(_forcedInclusionStorage, _start, _maxCount);\n    }\n\n    /// @inheritdoc IForcedInclusionStore\n    function getForcedInclusionState()\n        external\n        view\n        returns (uint48 head_, uint48 tail_, uint48 lastProcessedAt_)\n    {\n        return LibForcedInclusion.getForcedInclusionState(_forcedInclusionStorage);\n    }\n\n    /// @notice Retrieves the proposal hash for a given proposal ID\n    /// @param _proposalId The ID of the proposal to query\n    /// @return proposalHash_ The keccak256 hash of the Proposal struct at the ring buffer slot\n    function getProposalHash(uint48 _proposalId) external view returns (bytes32 proposalHash_) {\n        uint256 bufferSlot = _proposalId % _ringBufferSize;\n        proposalHash_ = _proposalHashes[bufferSlot];\n    }\n\n    /// @notice Retrieves the transition record hash for a specific proposal and parent transition\n    /// @param _proposalId The ID of the proposal containing the transition\n    /// @param _parentTransitionHash The hash of the parent transition in the proof chain\n    /// @return finalizationDeadline_ The timestamp when finalization is enforced\n    /// @return recordHash_ The hash of the transition record\n    function getTransitionRecordHash(\n        uint48 _proposalId,\n        bytes32 _parentTransitionHash\n    )\n        external\n        view\n        returns (uint48 finalizationDeadline_, bytes26 recordHash_)\n    {\n        (recordHash_, finalizationDeadline_) =\n            _getTransitionRecordHashAndDeadline(_proposalId, _parentTransitionHash);\n    }\n\n    /// @inheritdoc IInbox\n    function getConfig() external view returns (IInbox.Config memory config_) {\n        config_ = IInbox.Config({\n            codec: _codec,\n            bondToken: address(_bondToken),\n            checkpointStore: address(_checkpointStore),\n            proofVerifier: address(_proofVerifier),\n            proposerChecker: address(_proposerChecker),\n            provingWindow: _provingWindow,\n            extendedProvingWindow: _extendedProvingWindow,\n            maxFinalizationCount: _maxFinalizationCount,\n            finalizationGracePeriod: _finalizationGracePeriod,\n            ringBufferSize: _ringBufferSize,\n            basefeeSharingPctg: _basefeeSharingPctg,\n            minForcedInclusionCount: _minForcedInclusionCount,\n            forcedInclusionDelay: _forcedInclusionDelay,\n            forcedInclusionFeeInGwei: _forcedInclusionFeeInGwei,\n            forcedInclusionFeeDoubleThreshold: _forcedInclusionFeeDoubleThreshold,\n            minCheckpointDelay: _minCheckpointDelay,\n            permissionlessInclusionMultiplier: _permissionlessInclusionMultiplier,\n            compositeKeyVersion: _compositeKeyVersion\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Internal Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Activates the inbox with genesis state so that it can start accepting proposals.\n    /// Sets up the initial proposal and core state with genesis block.\n    /// Can be called multiple times to handle L1 reorgs or correct incorrect values.\n    /// Resets state variables to allow fresh start.\n    /// @param _lastPacayaBlockHash The hash of the last Pacaya block\n    function _activateInbox(bytes32 _lastPacayaBlockHash) internal {\n        conflictingTransitionDetected = false;\n\n        Transition memory transition;\n        transition.checkpoint.blockHash = _lastPacayaBlockHash;\n\n        CoreState memory coreState;\n        coreState.nextProposalId = 1;\n\n        // Set lastProposalBlockId to 1 to ensure the first proposal happens at block 2 or later.\n        // This prevents reading blockhash(0) in propose(), which would return 0x0 and create\n        // an invalid origin block hash. The EVM hardcodes blockhash(0) to 0x0, so we must\n        // ensure proposals never reference the genesis block.\n        coreState.lastProposalBlockId = 1;\n        coreState.lastFinalizedTransitionHash = _hashTransition(transition);\n\n        Proposal memory proposal;\n        proposal.coreStateHash = _hashCoreState(coreState);\n\n        Derivation memory derivation;\n        proposal.derivationHash = _hashDerivation(derivation);\n\n        _setProposalHash(0, _hashProposal(proposal));\n\n        _emitProposedEvent(proposal, derivation, coreState, new LibBonds.BondInstruction[](0));\n    }\n\n    /// @dev Builds and persists transition records for batch proof submissions\n    /// Validates transitions, calculates bond instructions, and stores records\n    /// @dev Virtual function that can be overridden for optimization (e.g., transition aggregation)\n    /// @param _input The ProveInput containing arrays of proposals, transitions, and metadata\n    function _buildAndSaveTransitionRecords(ProveInput memory _input) internal virtual {\n        for (uint256 i; i < _input.proposals.length; ++i) {\n            _processSingleTransitionAtIndex(_input, i);\n        }\n    }\n\n    /// @dev Processes a single transition at the specified index\n    /// Reusable function for validating, building, and storing individual transitions\n    /// @param _input The ProveInput containing all transition data\n    /// @param _index The index of the transition to process\n    function _processSingleTransitionAtIndex(\n        ProveInput memory _input,\n        uint256 _index\n    )\n        internal\n    {\n        _validateTransition(_input.proposals[_index], _input.transitions[_index]);\n\n        TransitionRecord memory transitionRecord = _buildTransitionRecord(\n            _input.proposals[_index], _input.transitions[_index], _input.metadata[_index]\n        );\n\n        _setTransitionRecordHashAndDeadline(\n            _input.proposals[_index].id,\n            _input.transitions[_index],\n            _input.metadata[_index],\n            transitionRecord\n        );\n    }\n\n    /// @dev Stores a proposal hash in the ring buffer\n    /// Overwrites any existing hash at the calculated buffer slot\n    function _setProposalHash(uint48 _proposalId, bytes32 _proposalHash) internal {\n        _proposalHashes[_proposalId % _ringBufferSize] = _proposalHash;\n    }\n\n    /// @dev Stores transition record hash and emits `Proved` event\n    /// Virtual function to allow optimization in derived contracts\n    /// @dev Uses composite key for unique transition identification\n    /// @param _proposalId The ID of the proposal being proven\n    /// @param _transition The transition data to include in the event\n    /// @param _metadata The metadata containing prover information to include in the event\n    /// @param _transitionRecord The transition record to hash and store\n    function _setTransitionRecordHashAndDeadline(\n        uint48 _proposalId,\n        Transition memory _transition,\n        TransitionMetadata memory _metadata,\n        TransitionRecord memory _transitionRecord\n    )\n        internal\n        virtual\n    {\n        (bytes26 transitionRecordHash, TransitionRecordHashAndDeadline memory hashAndDeadline) =\n            _computeTransitionRecordHashAndDeadline(_transitionRecord);\n\n        _storeTransitionRecord(\n            _proposalId, _transition.parentTransitionHash, transitionRecordHash, hashAndDeadline\n        );\n\n        ProvedEventPayload memory payload = ProvedEventPayload({\n            proposalId: _proposalId,\n            transition: _transition,\n            transitionRecord: _transitionRecord,\n            metadata: _metadata\n        });\n        emit Proved(_encodeProvedEventData(payload));\n    }\n\n    /// @dev Persists transition record metadata in storage.\n    /// Returns false when an identical record already exists, avoiding redundant event\n    /// emissions.\n    /// @param _proposalId The proposal identifier.\n    /// @param _parentTransitionHash Hash of the parent transition for uniqueness.\n    /// @param _recordHash The keccak hash representing the transition record.\n    /// @param _hashAndDeadline The finalization metadata to store alongside the hash.\n    function _storeTransitionRecord(\n        uint48 _proposalId,\n        bytes32 _parentTransitionHash,\n        bytes26 _recordHash,\n        TransitionRecordHashAndDeadline memory _hashAndDeadline\n    )\n        internal\n        virtual\n    {\n        bytes32 compositeKey = _composeTransitionKey(_proposalId, _parentTransitionHash);\n        TransitionRecordHashAndDeadline storage entry =\n            _transitionRecordHashAndDeadline[compositeKey];\n        bytes26 recordHash = entry.recordHash;\n\n        if (recordHash == 0) {\n            entry.recordHash = _recordHash;\n            entry.finalizationDeadline = _hashAndDeadline.finalizationDeadline;\n        } else if (recordHash == _recordHash) {\n            emit TransitionDuplicateDetected();\n        } else {\n            emit TransitionConflictDetected();\n            conflictingTransitionDetected = true;\n            entry.finalizationDeadline = type(uint48).max;\n        }\n    }\n\n    /// @dev Loads transition record metadata from storage.\n    /// @param _proposalId The proposal identifier.\n    /// @param _parentTransitionHash Hash of the parent transition used as lookup key.\n    /// @return recordHash_ The hash of the transition record.\n    /// @return finalizationDeadline_ The finalization deadline for the transition.\n    function _getTransitionRecordHashAndDeadline(\n        uint48 _proposalId,\n        bytes32 _parentTransitionHash\n    )\n        internal\n        view\n        virtual\n        returns (bytes26 recordHash_, uint48 finalizationDeadline_)\n    {\n        bytes32 compositeKey = _composeTransitionKey(_proposalId, _parentTransitionHash);\n        TransitionRecordHashAndDeadline storage hashAndDeadline =\n            _transitionRecordHashAndDeadline[compositeKey];\n        return (hashAndDeadline.recordHash, hashAndDeadline.finalizationDeadline);\n    }\n\n    /// @dev Validates transition consistency with its corresponding proposal\n    /// Ensures the transition references the correct proposal hash\n    /// @param _proposal The proposal being proven\n    /// @param _transition The transition to validate against the proposal\n    function _validateTransition(\n        Proposal memory _proposal,\n        Transition memory _transition\n    )\n        internal\n        view\n    {\n        bytes32 proposalHash = _checkProposalHash(_proposal);\n        require(proposalHash == _transition.proposalHash, ProposalHashMismatchWithTransition());\n    }\n\n    /// @dev Validates proposal hash against stored value\n    /// Reverts with ProposalHashMismatch if hashes don't match\n    /// @param _proposal The proposal to validate\n    /// @return proposalHash_ The computed hash of the proposal\n    function _checkProposalHash(Proposal memory _proposal)\n        internal\n        view\n        returns (bytes32 proposalHash_)\n    {\n        proposalHash_ = _hashProposal(_proposal);\n        bytes32 storedProposalHash = _proposalHashes[_proposal.id % _ringBufferSize];\n        require(proposalHash_ == storedProposalHash, ProposalHashMismatch());\n    }\n\n    /// @dev Builds a transition record for a proposal, transition, and metadata tuple.\n    /// @param _proposal The proposal the transition is proving.\n    /// @param _transition The transition associated with the proposal.\n    /// @param _metadata The metadata describing the prover and additional context.\n    /// @return record The constructed transition record with span set to one.\n    function _buildTransitionRecord(\n        Proposal memory _proposal,\n        Transition memory _transition,\n        TransitionMetadata memory _metadata\n    )\n        internal\n        view\n        returns (TransitionRecord memory record)\n    {\n        record.span = 1;\n        record.bondInstructions = LibBondInstruction.calculateBondInstructions(\n            _provingWindow, _extendedProvingWindow, _proposal, _metadata\n        );\n        record.transitionHash = _hashTransition(_transition);\n        record.checkpointHash = _hashCheckpoint(_transition.checkpoint);\n    }\n\n    /// @dev Computes the hash and finalization deadline for a transition record.\n    /// @param _transitionRecord The transition record to hash.\n    /// @return recordHash_ The keccak hash of the transition record.\n    /// @return hashAndDeadline_ The struct containing the hash and deadline to persist.\n    function _computeTransitionRecordHashAndDeadline(TransitionRecord memory _transitionRecord)\n        internal\n        view\n        returns (bytes26 recordHash_, TransitionRecordHashAndDeadline memory hashAndDeadline_)\n    {\n        unchecked {\n            recordHash_ = _hashTransitionRecord(_transitionRecord);\n            hashAndDeadline_ = TransitionRecordHashAndDeadline({\n                finalizationDeadline: uint48(block.timestamp + _finalizationGracePeriod),\n                recordHash: recordHash_\n            });\n        }\n    }\n\n    /// @dev Computes composite key for transition record storage\n    /// Creates unique identifier for proposal-parent transition pairs\n    /// @param _proposalId The ID of the proposal\n    /// @param _parentTransitionHash Hash of the parent transition\n    /// @return _ Keccak256 hash of encoded parameters\n    function _composeTransitionKey(\n        uint48 _proposalId,\n        bytes32 _parentTransitionHash\n    )\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        return LibHashSimple.composeTransitionKey(\n            _proposalId, _compositeKeyVersion, _parentTransitionHash\n        );\n    }\n\n    // ---------------------------------------------------------------\n    // Encoder Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Encodes the proposed event data\n    /// @param _payload The ProposedEventPayload object\n    /// @return The encoded data\n    function _encodeProposedEventData(ProposedEventPayload memory _payload)\n        internal\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encode(_payload);\n    }\n\n    /// @dev Encodes the proved event data\n    /// @param _payload The ProvedEventPayload object\n    /// @return The encoded data\n    function _encodeProvedEventData(ProvedEventPayload memory _payload)\n        internal\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encode(_payload);\n    }\n\n    // ---------------------------------------------------------------\n    // Decoder Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Decodes proposal input data\n    /// @param _data The encoded data\n    /// @return input_ The decoded ProposeInput struct containing all proposal data\n    function _decodeProposeInput(bytes calldata _data)\n        internal\n        pure\n        virtual\n        returns (ProposeInput memory)\n    {\n        return abi.decode(_data, (ProposeInput));\n    }\n\n    /// @dev Decodes prove input data\n    /// @param _data The encoded data\n    /// @return _ The decoded ProveInput struct containing proposals and transitions\n    function _decodeProveInput(bytes calldata _data)\n        internal\n        pure\n        virtual\n        returns (ProveInput memory)\n    {\n        return abi.decode(_data, (ProveInput));\n    }\n\n    // ---------------------------------------------------------------\n    // Hashing Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Optimized hashing for blob hashes array to reduce stack depth\n    /// @param _blobHashes The blob hashes array to hash\n    /// @return The hash of the blob hashes array\n    function _hashBlobHashesArray(bytes32[] memory _blobHashes)\n        internal\n        pure\n        virtual\n        returns (bytes32)\n    {\n        return LibHashSimple.hashBlobHashesArray(_blobHashes);\n    }\n\n    /// @dev Hashes a Checkpoint struct.\n    /// @param _checkpoint The checkpoint to hash.\n    /// @return _ The hash of the checkpoint.\n    function _hashCheckpoint(ICheckpointStore.Checkpoint memory _checkpoint)\n        internal\n        pure\n        virtual\n        returns (bytes32)\n    {\n        return LibHashSimple.hashCheckpoint(_checkpoint);\n    }\n\n    /// @dev Hashes a CoreState struct.\n    /// @param _coreState The core state to hash.\n    /// @return _ The hash of the core state.\n    function _hashCoreState(CoreState memory _coreState) internal pure virtual returns (bytes32) {\n        return LibHashSimple.hashCoreState(_coreState);\n    }\n\n    /// @dev Hashes a Derivation struct.\n    /// @param _derivation The derivation to hash.\n    /// @return _ The hash of the derivation.\n    function _hashDerivation(Derivation memory _derivation)\n        internal\n        pure\n        virtual\n        returns (bytes32)\n    {\n        return LibHashSimple.hashDerivation(_derivation);\n    }\n\n    /// @dev Hashes a Proposal struct.\n    /// @param _proposal The proposal to hash.\n    /// @return _ The hash of the proposal.\n    function _hashProposal(Proposal memory _proposal) internal pure virtual returns (bytes32) {\n        return LibHashSimple.hashProposal(_proposal);\n    }\n\n    /// @dev Hashes a Transition struct.\n    /// @param _transition The transition to hash.\n    /// @return _ The hash of the transition.\n    function _hashTransition(Transition memory _transition)\n        internal\n        pure\n        virtual\n        returns (bytes32)\n    {\n        return LibHashSimple.hashTransition(_transition);\n    }\n\n    /// @dev Hashes a TransitionRecord struct.\n    /// @param _transitionRecord The transition record to hash.\n    /// @return _ The hash of the transition record.\n    function _hashTransitionRecord(TransitionRecord memory _transitionRecord)\n        internal\n        pure\n        virtual\n        returns (bytes26)\n    {\n        return LibHashSimple.hashTransitionRecord(_transitionRecord);\n    }\n\n    /// @dev Hashes an array of Transitions.\n    /// @param _transitions The transitions array to hash.\n    /// @param _metadata The metadata array to hash.\n    /// @return _ The hash of the transitions array.\n    function _hashTransitionsWithMetadata(\n        Transition[] memory _transitions,\n        TransitionMetadata[] memory _metadata\n    )\n        internal\n        pure\n        virtual\n        returns (bytes32)\n    {\n        return LibHashSimple.hashTransitionsWithMetadata(_transitions, _metadata);\n    }\n\n    // ---------------------------------------------------------------\n    // Private Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Consumes forced inclusions from the queue and returns result with extra slot for normal\n    /// source\n    /// @param _feeRecipient Address to receive accumulated fees\n    /// @param _numForcedInclusionsRequested Maximum number of forced inclusions to consume\n    /// @return result_ ConsumptionResult with sources array (size: processed + 1, last slot empty)\n    /// and whether permissionless proposals are allowed\n    function _consumeForcedInclusions(\n        address _feeRecipient,\n        uint256 _numForcedInclusionsRequested\n    )\n        private\n        returns (ConsumptionResult memory result_)\n    {\n        unchecked {\n            LibForcedInclusion.Storage storage $ = _forcedInclusionStorage;\n\n            // Load storage once\n            (uint48 head, uint48 tail, uint48 lastProcessedAt) = ($.head, $.tail, $.lastProcessedAt);\n\n            uint256 available = tail - head;\n            uint256 toProcess = _numForcedInclusionsRequested > available\n                ? available\n                : _numForcedInclusionsRequested;\n\n            // Allocate array with extra slot for normal source\n            result_.sources = new IInbox.DerivationSource[](toProcess + 1);\n\n            // Process inclusions if any\n            uint48 oldestTimestamp;\n            (oldestTimestamp, head, lastProcessedAt) = _dequeueAndProcessForcedInclusions(\n                $, _feeRecipient, result_.sources, head, lastProcessedAt, toProcess\n            );\n\n            // We check the following conditions are met:\n            // 1. Proposer is willing to include at least the minimum required\n            // (_minForcedInclusionCount)\n            // 2. Proposer included all available inclusions\n            // 3. The oldest inclusion is not due\n            if (_numForcedInclusionsRequested < _minForcedInclusionCount && available > toProcess) {\n                bool isOldestInclusionDue = LibForcedInclusion.isOldestForcedInclusionDue(\n                    $, head, tail, lastProcessedAt, _forcedInclusionDelay\n                );\n                require(!isOldestInclusionDue, UnprocessedForcedInclusionIsDue());\n            }\n\n            // Check if permissionless proposals are allowed\n            uint256 permissionlessTimestamp = uint256(_forcedInclusionDelay)\n                * _permissionlessInclusionMultiplier + oldestTimestamp;\n            result_.allowsPermissionless = block.timestamp > permissionlessTimestamp;\n        }\n    }\n\n    /// @dev Dequeues and processes forced inclusions from the queue\n    /// @param $ Storage reference\n    /// @param _feeRecipient Address to receive fees\n    /// @param _sources Array to populate with derivation sources\n    /// @param _head Current queue head position\n    /// @param _lastProcessedAt Timestamp of last processing\n    /// @param _toProcess Number of inclusions to process\n    /// @return oldestTimestamp_ Oldest timestamp from processed inclusions\n    /// @return head_ Updated head position\n    /// @return lastProcessedAt_ Updated last processed timestamp\n    function _dequeueAndProcessForcedInclusions(\n        LibForcedInclusion.Storage storage $,\n        address _feeRecipient,\n        IInbox.DerivationSource[] memory _sources,\n        uint48 _head,\n        uint48 _lastProcessedAt,\n        uint256 _toProcess\n    )\n        private\n        returns (uint48 oldestTimestamp_, uint48 head_, uint48 lastProcessedAt_)\n    {\n        if (_toProcess > 0) {\n            // Process inclusions and accumulate fees\n            uint256 totalFees;\n            unchecked {\n                for (uint256 i; i < _toProcess; ++i) {\n                    IForcedInclusionStore.ForcedInclusion storage inclusion = $.queue[_head + i];\n                    _sources[i] = IInbox.DerivationSource(true, inclusion.blobSlice);\n                    totalFees += inclusion.feeInGwei;\n                }\n            }\n\n            // Transfer accumulated fees\n            if (totalFees > 0) {\n                _feeRecipient.sendEtherAndVerify(totalFees * 1 gwei);\n            }\n\n            // Oldest timestamp is max of first inclusion timestamp and last processed time\n            oldestTimestamp_ = uint48(_sources[0].blobSlice.timestamp.max(_lastProcessedAt));\n\n            // Update queue position and last processed time\n            head_ = _head + uint48(_toProcess);\n            lastProcessedAt_ = uint48(block.timestamp);\n\n            // Write to storage once\n            ($.head, $.lastProcessedAt) = (head_, lastProcessedAt_);\n        } else {\n            // No inclusions processed\n            oldestTimestamp_ = type(uint48).max;\n            head_ = _head;\n            lastProcessedAt_ = _lastProcessedAt;\n        }\n    }\n\n    /// @dev Emits the Proposed event with stack-optimized approach\n    /// @param _proposal The proposal data\n    /// @param _derivation The derivation data\n    /// @param _coreState The core state data\n    function _emitProposedEvent(\n        Proposal memory _proposal,\n        Derivation memory _derivation,\n        CoreState memory _coreState,\n        LibBonds.BondInstruction[] memory _bondInstructions\n    )\n        private\n    {\n        ProposedEventPayload memory payload = ProposedEventPayload({\n            proposal: _proposal,\n            derivation: _derivation,\n            coreState: _coreState,\n            bondInstructions: _bondInstructions\n        });\n        emit Proposed(_encodeProposedEventData(payload));\n    }\n\n    /// @dev Finalizes proven proposals and updates checkpoints with rate limiting.\n    /// Checkpoints are only saved if minCheckpointDelay seconds have passed since the last save,\n    /// reducing SSTORE operations but making L2 checkpoints less frequently available on L1.\n    /// Set minCheckpointDelay to 0 to disable rate limiting.\n    /// @param _input Contains transition records and the end block header.\n    /// @return coreState_ Updated core state with new finalization counters.\n    /// @return bondInstructions_ Array of bond instructions from finalized proposals.\n    function _finalize(ProposeInput memory _input)\n        private\n        returns (CoreState memory coreState_, LibBonds.BondInstruction[] memory bondInstructions_)\n    {\n        unchecked {\n            CoreState memory coreState = _input.coreState;\n            uint48 proposalId = coreState.lastFinalizedProposalId + 1;\n            uint256 lastFinalizedRecordIdx;\n            uint256 finalizedCount;\n            uint256 transitionCount = _input.transitionRecords.length;\n            uint256 currentTimestamp = block.timestamp;\n            uint256 totalBondInstructionCount;\n\n            for (uint256 i; i < _maxFinalizationCount; ++i) {\n                // Check if there are more proposals to finalize\n                if (proposalId >= coreState.nextProposalId) break;\n\n                // Try to finalize the current proposal\n                (bytes26 recordHash, uint48 finalizationDeadline) = _getTransitionRecordHashAndDeadline(\n                    proposalId, coreState.lastFinalizedTransitionHash\n                );\n\n                if (i >= transitionCount) {\n                    if (recordHash == 0) break;\n\n                    if (currentTimestamp >= finalizationDeadline) {\n                        revert TransitionRecordNotProvided();\n                    }\n\n                    break;\n                }\n\n                if (recordHash == 0) break;\n\n                TransitionRecord memory transitionRecord = _input.transitionRecords[i];\n\n                require(\n                    _hashTransitionRecord(transitionRecord) == recordHash,\n                    TransitionRecordHashMismatchWithStorage()\n                );\n\n                coreState.lastFinalizedProposalId = proposalId;\n                coreState.lastFinalizedTransitionHash = transitionRecord.transitionHash;\n\n                uint256 bondInstructionLen = transitionRecord.bondInstructions.length;\n                for (uint256 j; j < bondInstructionLen; ++j) {\n                    coreState.bondInstructionsHash = LibBonds.aggregateBondInstruction(\n                        coreState.bondInstructionsHash, transitionRecord.bondInstructions[j]\n                    );\n                }\n\n                totalBondInstructionCount += bondInstructionLen;\n\n                require(transitionRecord.span > 0, InvalidSpan());\n\n                uint48 nextProposalId = proposalId + transitionRecord.span;\n                require(nextProposalId <= coreState.nextProposalId, SpanOutOfBounds());\n\n                proposalId = nextProposalId;\n\n                // Update state for successful finalization\n                lastFinalizedRecordIdx = i;\n                ++finalizedCount;\n            }\n\n            // Update checkpoint if any proposals were finalized and minimum delay has passed\n            if (finalizedCount > 0) {\n                _syncCheckpointIfNeeded(\n                    _input.checkpoint,\n                    _input.transitionRecords[lastFinalizedRecordIdx].checkpointHash,\n                    coreState\n                );\n            }\n\n            if (totalBondInstructionCount > 0) {\n                bondInstructions_ = new LibBonds.BondInstruction[](totalBondInstructionCount);\n                uint256 bondInstructionIndex;\n\n                for (uint256 i; i < finalizedCount; ++i) {\n                    LibBonds.BondInstruction[] memory instructions =\n                    _input.transitionRecords[i].bondInstructions;\n                    uint256 instructionsLen = instructions.length;\n\n                    for (uint256 j; j < instructionsLen; ++j) {\n                        bondInstructions_[bondInstructionIndex++] = instructions[j];\n                    }\n                }\n            }\n\n            return (coreState, bondInstructions_);\n        }\n    }\n\n    /// @dev Syncs checkpoint to storage when voluntary or forced sync conditions are met.\n    ///      Validates the checkpoint hash, persists it, and refreshes the timestamp in core state.\n    /// @param _checkpoint The checkpoint data to sync.\n    /// @param _expectedCheckpointHash The expected hash to validate against.\n    /// @param _coreState Core state to update with new checkpoint timestamp.\n    function _syncCheckpointIfNeeded(\n        ICheckpointStore.Checkpoint memory _checkpoint,\n        bytes32 _expectedCheckpointHash,\n        CoreState memory _coreState\n    )\n        private\n    {\n        // Check if checkpoint sync should occur:\n        // 1. Voluntary: proposer provided a checkpoint (blockHash != 0)\n        // 2. Forced: minimum delay elapsed since last checkpoint\n        if (_checkpoint.blockHash != 0) {\n            bytes32 checkpointHash = _hashCheckpoint(_checkpoint);\n            require(checkpointHash == _expectedCheckpointHash, CheckpointMismatch());\n\n            _checkpointStore.saveCheckpoint(_checkpoint);\n            _coreState.lastCheckpointTimestamp = uint48(block.timestamp);\n        } else {\n            require(\n                block.timestamp < _coreState.lastCheckpointTimestamp + _minCheckpointDelay,\n                CheckpointNotProvided()\n            );\n        }\n    }\n\n    /// @dev Calculates remaining capacity for new proposals\n    /// Subtracts unfinalized proposals from total capacity\n    /// @param _coreState Current state with proposal counters\n    /// @return _ Number of additional proposals that can be submitted\n    function _getAvailableCapacity(CoreState memory _coreState) private view returns (uint256) {\n        unchecked {\n            uint256 numUnfinalizedProposals =\n                _coreState.nextProposalId - _coreState.lastFinalizedProposalId - 1;\n            return _ringBufferSize - 1 - numUnfinalizedProposals;\n        }\n    }\n\n    /// @dev Validates propose function inputs\n    /// Checks deadline, proposal array, and state consistency\n    /// @param _input The ProposeInput to validate\n    function _validateProposeInput(ProposeInput memory _input) private view {\n        require(_input.deadline == 0 || block.timestamp <= _input.deadline, DeadlineExceeded());\n        require(_input.parentProposals.length > 0, EmptyProposals());\n        require(block.number > _input.coreState.lastProposalBlockId, CannotProposeInCurrentBlock());\n        require(\n            _hashCoreState(_input.coreState) == _input.parentProposals[0].coreStateHash,\n            InvalidState()\n        );\n    }\n\n    /// @dev Verifies that parentProposals[0] is the current chain head\n    /// Requires 1 element if next slot empty, 2 if occupied with older proposal\n    /// @param _parentProposals Array of 1-2 proposals to verify chain head\n    function _verifyChainHead(Proposal[] memory _parentProposals) private view {\n        unchecked {\n            // First verify parentProposals[0] matches what's stored on-chain\n            _checkProposalHash(_parentProposals[0]);\n\n            // Then verify it's actually the chain head\n            uint256 nextBufferSlot = (_parentProposals[0].id + 1) % _ringBufferSize;\n            bytes32 storedNextProposalHash = _proposalHashes[nextBufferSlot];\n\n            if (storedNextProposalHash == bytes32(0)) {\n                // Next slot in the ring buffer is empty, only one proposal expected\n                require(_parentProposals.length == 1, IncorrectProposalCount());\n            } else {\n                // Next slot in the ring buffer is occupied, need to prove it contains a\n                // proposal with a smaller id\n                require(_parentProposals.length == 2, IncorrectProposalCount());\n                require(_parentProposals[1].id < _parentProposals[0].id, InvalidLastProposalProof());\n                require(\n                    storedNextProposalHash == _hashProposal(_parentProposals[1]),\n                    NextProposalHashMismatch()\n                );\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------\n    // Errors\n    // ---------------------------------------------------------------\n\n    error ActivationPeriodExpired();\n    error CannotProposeInCurrentBlock();\n    error CheckpointMismatch();\n    error CheckpointNotProvided();\n    error DeadlineExceeded();\n    error EmptyProposals();\n    error InconsistentParams();\n    error IncorrectProposalCount();\n    error InvalidLastPacayaBlockHash();\n    error InvalidLastProposalProof();\n    error InvalidSpan();\n    error InvalidState();\n    error NextProposalHashMismatch();\n    error NoBondToWithdraw();\n    error NotEnoughCapacity();\n    error ProposalHashMismatch();\n    error ProposalHashMismatchWithTransition();\n    error RingBufferSizeZero();\n    error SpanOutOfBounds();\n    error TransitionRecordHashMismatchWithStorage();\n    error TransitionRecordNotProvided();\n    error UnprocessedForcedInclusionIsDue();\n}\n"
    }
}