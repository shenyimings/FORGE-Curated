{
    "vfp_id": "vfp_00062",
    "project_name": "2025-01-bacon-labs-bunniv2-securityreview.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Users can bid arbitrarily low rent during the bidding process",
            "description": "The bid function in the AmAmm contract allows users to set rent to zero or an extremely low value when there is no existing next bid, as the 10% increase requirement only applies if a next bid exists.\n\nThe cause is the lack of a minimum rent floor in the validation logic. The condition `rent <= _nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id))` does not account for the case when no next bid exists, allowing rent to be zero.\n\nAn attacker could exploit this by placing a near-zero rent bid when no next bid exists, becoming the next manager at minimal cost. If no higher bids follow, they could eventually become the top manager and collect full swap fees for a very low rent payment.\n\nThe impact is economic distortion of the auction mechanism, potentially allowing attackers to capture significant value for minimal cost, undermining the intended market-based fee discovery.\n",
            "severity": "Informational",
            "location": [
                "lib/biddog/AmAMM.sol",
                "src/AmAmm.sol#L75-L86",
                "src/AmAmm.sol#L676-L680"
            ],
            "files": [
                "95f4270ad4447e96044973580afda9176730e7c8/biddog/src/AmAmm.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Overly strict bid withdrawal validation reduces am-AMM efficiency by enabling griefing",
            "description": "The AmAmm contract's withdrawNextBid function requires the next highest bidder to maintain a deposit covering 24 hours of rent, regardless of the current top bidder's remaining deposit. This deviates from the intended design where the next bidder should be able to withdraw fully if the top bidder has sufficient deposit.\n\nThe cause is an overly strict condition in the withdrawNextBid function: (nextBid.deposit - amount) / nextBid.rent < K(id), which always enforces a 24-hour minimum. This creates unnecessary fund lockup.\n\nAn attacker (or competitive bidder) can exploit this by maintaining a long-running top bid with periodic top-ups, effectively locking the next bidder's funds indefinitely. This prevents the next bidder from reclaiming their capital even when economically justified.\n\nThe impact is reduced capital efficiency and increased risk for bidders, potentially leading to fewer participants in the auction. It also creates griefing opportunities and may reduce LP earnings by prolonging suboptimal fee regimes.\n",
            "severity": "Low",
            "location": [
                "src/AmAmm.sol",
                "src/AmAmm.sol#L273-L276",
                "src/AmAmm.sol#L319-L325"
            ],
            "files": [
                "95f4270ad4447e96044973580afda9176730e7c8/biddog/src/AmAmm.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-267"
                ]
            },
            "title": "AmAmm manager can manipulate TWAP prices without risk",
            "description": "The AmAmm manager has the ability to set swap fees for a pool via the setBidPayload function. This allows them to set extremely high fees, effectively preventing arbitrageurs from correcting price imbalances. Since the TWAP (Time-Weighted Average Price) oracle is used by external systems such as lending protocols, a malicious manager can manipulate the TWAP by executing large swaps and then locking in the manipulated price with high fees.\n\nThe root cause is excessive privilege granted to the AmAmm manager without sufficient safeguards. The system allows the manager to control swap fees, which directly impacts the ability of the market to correct price deviations. Although there is a maximum fee limit, it may be set too high or misconfigured.\n\nAn attacker who becomes the AmAmm manager can borrow assets to manipulate the pool’s price over several blocks, set fees to 100% to prevent arbitrage, and then use the inflated TWAP price to drain a lending protocol that relies on it for valuation.\n\nThe impact includes potential loss of funds in connected protocols (e.g., lending platforms), erosion of trust in the oracle system, and manipulation of market prices. This poses a systemic risk if the pool is used as a price feed for other DeFi applications.\n",
            "severity": "Medium",
            "location": [
                "biddog/src/AmAmm.sol#L406-L429",
                "src/lib/AmAmmPayload.sol#L11-L18",
                "src/lib/BunniHookLogic.sol#L295-L305"
            ],
            "files": [
                "95f4270ad4447e96044973580afda9176730e7c8/biddog/src/AmAmm.sol",
                "95f4270ad4447e96044973580afda9176730e7c8/biddog/src/lib/AmAmmPayload.sol",
                "95f4270ad4447e96044973580afda9176730e7c8/biddog/src/lib/BunniHookLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "AmAmm.sol": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {LibMulticaller} from \"multicaller/LibMulticaller.sol\";\n\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {IAmAmm} from \"./interfaces/IAmAmm.sol\";\n\n/// @title AmAmm\n/// @author zefram.eth\n/// @notice Implements the auction mechanism from the am-AMM paper (https://arxiv.org/abs/2403.03367)\nabstract contract AmAmm is IAmAmm {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SafeCastLib for *;\n    using FixedPointMathLib for *;\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    function K(PoolId) internal view virtual returns (uint40) {\n        return 24;\n    }\n\n    function EPOCH_SIZE(PoolId) internal view virtual returns (uint256) {\n        return 1 hours;\n    }\n\n    function MIN_BID_MULTIPLIER(PoolId) internal view virtual returns (uint256) {\n        return 1.1e18;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    mapping(PoolId id => Bid) internal _topBids;\n    mapping(PoolId id => Bid) internal _nextBids;\n    mapping(PoolId id => uint40) internal _lastUpdatedEpoch;\n    mapping(Currency currency => uint256) internal _totalFees;\n    mapping(address manager => mapping(PoolId id => uint256)) internal _refunds;\n    mapping(address manager => mapping(Currency currency => uint256)) internal _fees;\n\n    /// -----------------------------------------------------------------------\n    /// Bidder actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IAmAmm\n    function bid(PoolId id, address manager, bytes7 payload, uint128 rent, uint128 deposit) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        // ensure bid is valid\n        // - manager can't be zero address\n        // - bid needs to be greater than the next bid by >10%\n        // - deposit needs to cover the rent for K hours\n        // - deposit needs to be a multiple of rent\n        // - payload needs to be valid\n        if (\n            manager == address(0) || rent <= _nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n                || deposit % rent != 0 || !_payloadIsValid(id, payload)\n        ) {\n            revert AmAmm__InvalidBid();\n        }\n\n        // refund deposit of the previous next bid\n        _refunds[_nextBids[id].manager][id] += _nextBids[id].deposit;\n\n        // update next bid\n        uint40 epoch = _getEpoch(id, block.timestamp);\n        _nextBids[id] = Bid(manager, epoch, payload, rent, deposit);\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer deposit from msg.sender to this contract\n        _pullBidToken(id, msgSender, deposit);\n\n        emit SubmitBid(id, manager, epoch, payload, rent, deposit);\n    }\n\n    /// @inheritdoc IAmAmm\n    function depositIntoTopBid(PoolId id, uint128 amount) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory topBid = _topBids[id];\n\n        // only the top bid manager can deposit into the top bid\n        if (msgSender != topBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % topBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // add amount to top bid deposit\n        _topBids[id].deposit = topBid.deposit + amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount from msg.sender to this contract\n        _pullBidToken(id, msgSender, amount);\n\n        emit DepositIntoTopBid(id, msgSender, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function withdrawFromTopBid(PoolId id, uint128 amount, address recipient) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory topBid = _topBids[id];\n\n        // only the top bid manager can withdraw from the top bid\n        if (msgSender != topBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % topBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // require D_top / R_top >= K\n        if ((topBid.deposit - amount) / topBid.rent < K(id)) {\n            revert AmAmm__BidLocked();\n        }\n\n        // deduct amount from top bid deposit\n        _topBids[id].deposit = topBid.deposit - amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount to recipient\n        _pushBidToken(id, recipient, amount);\n\n        emit WithdrawFromTopBid(id, msgSender, recipient, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function depositIntoNextBid(PoolId id, uint128 amount) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory nextBid = _nextBids[id];\n\n        // only the next bid manager can deposit into the next bid\n        if (msgSender != nextBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % nextBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // add amount to next bid deposit\n        _nextBids[id].deposit = nextBid.deposit + amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount from msg.sender to this contract\n        _pullBidToken(id, msgSender, amount);\n\n        emit DepositIntoNextBid(id, msgSender, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function withdrawFromNextBid(PoolId id, uint128 amount, address recipient) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory nextBid = _nextBids[id];\n\n        // only the next bid manager can withdraw from the next bid\n        if (msgSender != nextBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % nextBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // require D_next / R_next >= K\n        if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n            revert AmAmm__BidLocked();\n        }\n\n        // deduct amount from next bid deposit\n        _nextBids[id].deposit = nextBid.deposit - amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount to recipient\n        _pushBidToken(id, recipient, amount);\n\n        emit WithdrawFromNextBid(id, msgSender, recipient, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function cancelNextBid(PoolId id, address recipient) external virtual override returns (uint256 refund) {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory nextBid = _nextBids[id];\n\n        // only the next bid manager can withdraw from the next bid\n        if (msgSender != nextBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        Bid memory topBid = _topBids[id];\n\n        // require D_top / R_top >= K\n        if (topBid.manager != address(0) && topBid.deposit / topBid.rent < K(id)) {\n            revert AmAmm__BidLocked();\n        }\n\n        // delete next bid from storage\n        delete _nextBids[id];\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer nextBid.deposit to recipient\n        _pushBidToken(id, recipient, nextBid.deposit);\n\n        emit CancelNextBid(id, msgSender, recipient, nextBid.deposit);\n\n        return nextBid.deposit;\n    }\n\n    /// @inheritdoc IAmAmm\n    function claimRefund(PoolId id, address recipient) external virtual override returns (uint256 refund) {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        refund = _refunds[msgSender][id];\n        if (refund == 0) {\n            return 0;\n        }\n        delete _refunds[msgSender][id];\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer refund to recipient\n        _pushBidToken(id, recipient, refund);\n\n        emit ClaimRefund(id, msgSender, recipient, refund);\n    }\n\n    /// @inheritdoc IAmAmm\n    function claimFees(Currency currency, address recipient) external virtual override returns (uint256 fees) {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update manager fees\n        fees = _fees[msgSender][currency];\n        if (fees == 0) {\n            return 0;\n        }\n        delete _fees[msgSender][currency];\n\n        // update total fees\n        unchecked {\n            // safe because _totalFees[currency] is the sum of all managers' fees\n            _totalFees[currency] -= fees;\n        }\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer fees to recipient\n        _transferFeeToken(currency, recipient, fees);\n\n        emit ClaimFees(currency, msgSender, recipient, fees);\n    }\n\n    /// @inheritdoc IAmAmm\n    function setBidPayload(PoolId id, bytes7 payload, bool topBid) external virtual override {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n\n        if (msgSender != relevantBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        if (!_payloadIsValid(id, payload)) {\n            revert AmAmm__InvalidBid();\n        }\n\n        relevantBid.payload = payload;\n\n        emit SetBidPayload(id, msgSender, payload, topBid);\n    }\n\n    /// @inheritdoc IAmAmm\n    function updateStateMachine(PoolId id) external override {\n        _updateAmAmmWrite(id);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IAmAmm\n    function getTopBid(PoolId id) external view override returns (Bid memory topBid) {\n        (topBid,) = _updateAmAmm(id);\n    }\n\n    /// @inheritdoc IAmAmm\n    function getTopBidWrite(PoolId id) external override returns (Bid memory) {\n        _updateAmAmmWrite(id);\n        return _topBids[id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getNextBid(PoolId id) external view override returns (Bid memory nextBid) {\n        (, nextBid) = _updateAmAmm(id);\n    }\n\n    /// @inheritdoc IAmAmm\n    function getNextBidWrite(PoolId id) external override returns (Bid memory) {\n        _updateAmAmmWrite(id);\n        return _nextBids[id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getRefund(address manager, PoolId id) external view override returns (uint256) {\n        return _refunds[manager][id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getRefundWrite(address manager, PoolId id) external override returns (uint256) {\n        _updateAmAmmWrite(id);\n        return _refunds[manager][id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getFees(address manager, Currency currency) external view override returns (uint256) {\n        return _fees[manager][currency];\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Virtual functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns whether the am-AMM is enabled for a given pool\n    function _amAmmEnabled(PoolId id) internal view virtual returns (bool);\n\n    /// @dev Validates a bid payload, e.g. ensure the swap fee is below a certain threshold\n    function _payloadIsValid(PoolId id, bytes7 payload) internal view virtual returns (bool);\n\n    /// @dev Burns bid tokens from address(this)\n    function _burnBidToken(PoolId id, uint256 amount) internal virtual;\n\n    /// @dev Transfers bid tokens from an address that's not address(this) to address(this)\n    function _pullBidToken(PoolId id, address from, uint256 amount) internal virtual;\n\n    /// @dev Transfers bid tokens from address(this) to an address that's not address(this)\n    function _pushBidToken(PoolId id, address to, uint256 amount) internal virtual;\n\n    /// @dev Transfers accrued fees from address(this)\n    function _transferFeeToken(Currency currency, address to, uint256 amount) internal virtual;\n\n    /// @dev Accrues swap fees to the manager\n    function _accrueFees(address manager, Currency currency, uint256 amount) internal virtual {\n        _fees[manager][currency] += amount;\n        _totalFees[currency] += amount;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal helpers\n    /// -----------------------------------------------------------------------\n\n    /// @dev Charges rent and updates the top and next bids for a given pool\n    function _updateAmAmmWrite(PoolId id) internal virtual returns (address manager, bytes7 payload) {\n        uint40 currentEpoch = _getEpoch(id, block.timestamp);\n\n        // early return if the pool has already been updated in this epoch\n        if (_lastUpdatedEpoch[id] == currentEpoch) {\n            return (_topBids[id].manager, _topBids[id].payload);\n        }\n\n        Bid memory topBid = _topBids[id];\n        Bid memory nextBid = _nextBids[id];\n        bool updatedTopBid;\n        bool updatedNextBid;\n        uint256 rentCharged;\n\n        // run state machine\n        {\n            bool stepHasUpdatedTopBid;\n            bool stepHasUpdatedNextBid;\n            uint256 stepRentCharged;\n            while (true) {\n                (topBid, nextBid, stepHasUpdatedTopBid, stepHasUpdatedNextBid, stepRentCharged) =\n                    _stateTransitionWrite(currentEpoch, id, topBid, nextBid);\n\n                if (!stepHasUpdatedTopBid && !stepHasUpdatedNextBid) {\n                    break;\n                }\n\n                updatedTopBid = updatedTopBid || stepHasUpdatedTopBid;\n                updatedNextBid = updatedNextBid || stepHasUpdatedNextBid;\n                rentCharged += stepRentCharged;\n            }\n        }\n\n        // update top and next bids\n        if (updatedTopBid) {\n            _topBids[id] = topBid;\n        }\n        if (updatedNextBid) {\n            _nextBids[id] = nextBid;\n        }\n\n        // update last updated epoch\n        _lastUpdatedEpoch[id] = currentEpoch;\n\n        // burn rent charged\n        if (rentCharged != 0) {\n            _burnBidToken(id, rentCharged);\n        }\n\n        return (topBid.manager, topBid.payload);\n    }\n\n    /// @dev View version of _updateAmAmmWrite()\n    function _updateAmAmm(PoolId id) internal view virtual returns (Bid memory topBid, Bid memory nextBid) {\n        uint40 currentEpoch = _getEpoch(id, block.timestamp);\n\n        topBid = _topBids[id];\n        nextBid = _nextBids[id];\n\n        // run state machine\n        {\n            bool stepHasUpdatedTopBid;\n            bool stepHasUpdatedNextBid;\n            while (true) {\n                (topBid, nextBid, stepHasUpdatedTopBid, stepHasUpdatedNextBid,) =\n                    _stateTransition(currentEpoch, id, topBid, nextBid);\n\n                if (!stepHasUpdatedTopBid && !stepHasUpdatedNextBid) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the updated top and next bids after a single state transition\n    /// State diagram is as follows:\n    ///                                          after\n    ///                 ┌───────────────────────deposit ───────────────────┐\n    ///                 │                       depletes                   │\n    ///                 ▼                                                  │\n    ///    ┌────────────────────────┐                         ┌────────────────────────┐\n    ///    │                        │                         │                        │\n    ///    │        State A         │                         │        State B         │\n    ///    │      Manager: nil      │            ┌───────────▶│      Manager: r0       │◀─┐\n    ///    │       Next: nil        │            │            │       Next: nil        │  │\n    ///    │                        │            │            │                        │  │\n    ///    └────────────────────────┘            │            └────────────────────────┘  │\n    ///                 │                        │                         │              │\n    ///                 │                        │                         │              │\n    ///                 │                        │                         │              │\n    ///                 │                        │                         │           after K\n    ///              bid(r)                  after K                    bid(r)        epochs or\n    ///                 │                     epochs                       │            after\n    ///                 │                        │                         │           deposit\n    ///                 │                        │                         │          depletes\n    ///                 │                        │                         │              │\n    ///                 │                        │                         │              │\n    ///                 │                        │                         │              │\n    ///                 ▼                        │                         ▼              │\n    ///    ┌────────────────────────┐            │            ┌────────────────────────┐  │\n    ///    │                        │            │            │                        │  │\n    ///    │        State C         │            │            │        State D         │  │\n    /// ┌─▶│      Manager: nil      │────────────┘         ┌─▶│      Manager: r0       │──┘\n    /// │  │        Next: r         │                      │  │        Next: r         │\n    /// │  │                        │                      │  │                        │\n    /// │  └────────────────────────┘                      │  └────────────────────────┘\n    /// │               │                                  │               │\n    /// │               │                                  │               │\n    /// └─────bid(r)────┘                                  └─────bid(r)────┘\n    function _stateTransitionWrite(uint40 currentEpoch, PoolId id, Bid memory topBid, Bid memory nextBid)\n        internal\n        virtual\n        returns (Bid memory, Bid memory, bool updatedTopBid, bool updatedNextBid, uint256 rentCharged)\n    {\n        uint40 k = K(id);\n        if (nextBid.manager == address(0)) {\n            if (topBid.manager != address(0)) {\n                // State B\n                // charge rent from top bid\n                uint40 epochsPassed;\n                unchecked {\n                    // unchecked so that if epoch ever overflows, we simply wrap around\n                    epochsPassed = currentEpoch - topBid.epoch;\n                }\n                uint256 rentOwed = epochsPassed * topBid.rent;\n                if (rentOwed >= topBid.deposit) {\n                    // State B -> State A\n                    // the top bid's deposit has been depleted\n                    rentCharged = topBid.deposit;\n\n                    topBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                } else if (rentOwed != 0) {\n                    // State B\n                    // charge rent from top bid\n                    rentCharged = rentOwed;\n\n                    topBid.deposit -= rentOwed.toUint128();\n                    topBid.epoch = uint40(currentEpoch);\n\n                    updatedTopBid = true;\n                }\n            }\n        } else {\n            if (topBid.manager == address(0)) {\n                // State C\n                // check if K epochs have passed since the next bid was submitted\n                // if so, promote next bid to top bid\n                uint40 nextBidStartEpoch;\n                unchecked {\n                    // unchecked so that if epoch ever overflows, we simply wrap around\n                    nextBidStartEpoch = nextBid.epoch + k;\n                }\n                if (currentEpoch >= nextBidStartEpoch) {\n                    // State C -> State B\n                    // promote next bid to top bid\n                    topBid = nextBid;\n                    topBid.epoch = nextBidStartEpoch;\n                    nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                    updatedNextBid = true;\n                }\n            } else {\n                // State D\n                // we charge rent from the top bid only until K epochs after the next bid was submitted\n                // assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise we don't care about\n                // the next bid\n                bool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\n                uint40 epochsPassed;\n                unchecked {\n                    // unchecked so that if epoch ever overflows, we simply wrap around\n                    epochsPassed = nextBidIsBetter\n                        ? uint40(FixedPointMathLib.min(currentEpoch - topBid.epoch, nextBid.epoch + k - topBid.epoch))\n                        : currentEpoch - topBid.epoch;\n                }\n                uint256 rentOwed = epochsPassed * topBid.rent;\n                if (rentOwed >= topBid.deposit) {\n                    // State D -> State B\n                    // top bid has insufficient deposit\n                    // next bid becomes active after top bid depletes its deposit\n                    rentCharged = topBid.deposit;\n\n                    uint40 nextBidStartEpoch;\n                    unchecked {\n                        // unchecked so that if epoch ever overflows, we simply wrap around\n                        nextBidStartEpoch = uint40(topBid.deposit / topBid.rent) + topBid.epoch;\n                    }\n                    topBid = nextBid;\n                    topBid.epoch = nextBidStartEpoch;\n                    nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                    updatedNextBid = true;\n                } else {\n                    // State D\n                    // top bid has sufficient deposit\n                    // charge rent from top bid\n                    if (rentOwed != 0) {\n                        rentCharged = rentOwed;\n\n                        topBid.deposit -= rentOwed.toUint128();\n                        topBid.epoch = currentEpoch;\n\n                        updatedTopBid = true;\n                    }\n\n                    // check if K epochs have passed since the next bid was submitted\n                    // and that the next bid's rent is greater than the top bid's rent + 10%\n                    // if so, promote next bid to top bid\n                    uint40 nextBidStartEpoch;\n                    unchecked {\n                        // unchecked so that if epoch ever overflows, we simply wrap around\n                        nextBidStartEpoch = nextBid.epoch + k;\n                    }\n                    if (currentEpoch >= nextBidStartEpoch && nextBidIsBetter) {\n                        // State D -> State B\n                        // refund remaining deposit to top bid manager\n                        _refunds[topBid.manager][id] += topBid.deposit;\n\n                        // promote next bid to top bid\n                        topBid = nextBid;\n                        topBid.epoch = nextBidStartEpoch;\n                        nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                        updatedTopBid = true;\n                        updatedNextBid = true;\n                    }\n                }\n            }\n        }\n\n        return (topBid, nextBid, updatedTopBid, updatedNextBid, rentCharged);\n    }\n\n    /// @dev View version of _stateTransitionWrite()\n    function _stateTransition(uint40 currentEpoch, PoolId id, Bid memory topBid, Bid memory nextBid)\n        internal\n        view\n        virtual\n        returns (Bid memory, Bid memory, bool updatedTopBid, bool updatedNextBid, uint256 rentCharged)\n    {\n        uint40 k = K(id);\n        if (nextBid.manager == address(0)) {\n            if (topBid.manager != address(0)) {\n                // State B\n                // charge rent from top bid\n                uint40 epochsPassed;\n                unchecked {\n                    // unchecked so that if epoch ever overflows, we simply wrap around\n                    epochsPassed = currentEpoch - topBid.epoch;\n                }\n                uint256 rentOwed = epochsPassed * topBid.rent;\n                if (rentOwed >= topBid.deposit) {\n                    // State B -> State A\n                    // the top bid's deposit has been depleted\n                    rentCharged = topBid.deposit;\n\n                    topBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                } else if (rentOwed != 0) {\n                    // State B\n                    // charge rent from top bid\n                    rentCharged = rentOwed;\n\n                    topBid.deposit -= rentOwed.toUint128();\n                    topBid.epoch = uint40(currentEpoch);\n\n                    updatedTopBid = true;\n                }\n            }\n        } else {\n            if (topBid.manager == address(0)) {\n                // State C\n                // check if K epochs have passed since the next bid was submitted\n                // if so, promote next bid to top bid\n                uint40 nextBidStartEpoch;\n                unchecked {\n                    // unchecked so that if epoch ever overflows, we simply wrap around\n                    nextBidStartEpoch = nextBid.epoch + k;\n                }\n                if (currentEpoch >= nextBidStartEpoch) {\n                    // State C -> State B\n                    // promote next bid to top bid\n                    topBid = nextBid;\n                    topBid.epoch = nextBidStartEpoch;\n                    nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                    updatedNextBid = true;\n                }\n            } else {\n                // State D\n                // we charge rent from the top bid only until K epochs after the next bid was submitted\n                // assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise we don't care about\n                // the next bid\n                bool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\n                uint40 epochsPassed;\n                unchecked {\n                    // unchecked so that if epoch ever overflows, we simply wrap around\n                    epochsPassed = nextBidIsBetter\n                        ? uint40(FixedPointMathLib.min(currentEpoch - topBid.epoch, nextBid.epoch + k - topBid.epoch))\n                        : currentEpoch - topBid.epoch;\n                }\n                uint256 rentOwed = epochsPassed * topBid.rent;\n                if (rentOwed >= topBid.deposit) {\n                    // State D -> State B\n                    // top bid has insufficient deposit\n                    // next bid becomes active after top bid depletes its deposit\n                    rentCharged = topBid.deposit;\n\n                    uint40 nextBidStartEpoch;\n                    unchecked {\n                        // unchecked so that if epoch ever overflows, we simply wrap around\n                        nextBidStartEpoch = uint40(topBid.deposit / topBid.rent) + topBid.epoch;\n                    }\n                    topBid = nextBid;\n                    topBid.epoch = nextBidStartEpoch;\n                    nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                    updatedNextBid = true;\n                } else {\n                    // State D\n                    // top bid has sufficient deposit\n                    // charge rent from top bid\n                    if (rentOwed != 0) {\n                        rentCharged = rentOwed;\n\n                        topBid.deposit -= rentOwed.toUint128();\n                        topBid.epoch = currentEpoch;\n\n                        updatedTopBid = true;\n                    }\n\n                    // check if K epochs have passed since the next bid was submitted\n                    // and that the next bid's rent is greater than the top bid's rent + 10%\n                    // if so, promote next bid to top bid\n                    uint40 nextBidStartEpoch;\n                    unchecked {\n                        // unchecked so that if epoch ever overflows, we simply wrap around\n                        nextBidStartEpoch = nextBid.epoch + k;\n                    }\n                    if (currentEpoch >= nextBidStartEpoch && nextBidIsBetter) {\n                        // State D -> State B\n\n                        // promote next bid to top bid\n                        topBid = nextBid;\n                        topBid.epoch = nextBidStartEpoch;\n                        nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                        updatedTopBid = true;\n                        updatedNextBid = true;\n                    }\n                }\n            }\n        }\n\n        return (topBid, nextBid, updatedTopBid, updatedNextBid, rentCharged);\n    }\n\n    function _getEpoch(PoolId id, uint256 timestamp) internal view returns (uint40) {\n        return uint40(timestamp / EPOCH_SIZE(id));\n    }\n}\n"
    }
}