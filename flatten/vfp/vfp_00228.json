{
    "vfp_id": "vfp_00228",
    "project_name": "cantina_managed_sky_lockstake_april2025.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Lockstake migration might bring users closer to liquidation",
            "description": "During the migration from the old LockstakeEngine (LSE) to the new version, users' CDPs are converted from MKR to SKY. The new LSE uses a different oracle (SKY) which may have different price feeds and configuration for mat (liquidation ratio). This change could result in migrated positions being closer to liquidation than before, introducing unexpected risk for users. The issue stems from a shift in oracle dependency and risk parameters without automatic adjustment of collateral ratios.\n",
            "severity": "Informational",
            "location": [
                "LockstakeMigrator.sol#L137"
            ],
            "files": [
                "lockstake/src/LockstakeMigrator.sol"
            ]
        }
    ],
    "affected_files": {
        "LockstakeMigrator.sol": "// SPDX-FileCopyrightText: Â© 2023 Dai Foundation <www.daifoundation.org>\n// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.21;\n\ninterface VatLike {\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function urns(bytes32, address) external view returns (uint256, uint256);\n    function hope(address) external;\n}\n\ninterface LockstakeEngineLike {\n    function vat() external view returns (VatLike);\n    function ilk() external view returns (bytes32);\n    function mkr() external view returns (TokenLike);\n    function sky() external view returns (TokenLike);\n    function usdsJoin() external view returns (UsdsJoinLike);\n    function ownerUrns(address, uint256) external view returns (address);\n    function isUrnAuth(address, uint256, address) external view returns (bool);\n    function lock(address, uint256, uint256, uint16) external;\n    function freeNoFee(address, uint256, address, uint256) external;\n    function draw(address, uint256, address, uint256) external;\n    function wipeAll(address, uint256) external;\n}\n\ninterface UsdsJoinLike {\n    function usds() external view returns (TokenLike);\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n\ninterface TokenLike {\n    function approve(address, uint256) external;\n}\n\ninterface MkrSkyLike {\n    function rate() external view returns (uint256);\n    function mkrToSky(address, uint256) external;\n}\n\ninterface FlashLike {\n    function vatDaiFlashLoan(address, uint256, bytes calldata) external;\n}\n\ncontract LockstakeMigrator {\n    // --- immutables ---\n\n    LockstakeEngineLike immutable public oldEngine;\n    LockstakeEngineLike immutable public newEngine;\n    MkrSkyLike          immutable public mkrSky;\n    FlashLike           immutable public flash;\n    VatLike             immutable public vat;\n    UsdsJoinLike        immutable public usdsJoin;\n    bytes32             immutable public oldIlk;\n    uint256             immutable public mkrSkyRate;\n\n    // --- constants ---\n\n    uint256 private constant RAY = 10**27;\n\n    // --- math ---\n\n    function _divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // Note: _divup(0,0) will return 0 differing from natural solidity division\n        unchecked {\n            z = x != 0 ? ((x - 1) / y) + 1 : 0;\n        }\n    }\n\n    // --- events ---\n\n    event Migrate(address indexed oldOwner, uint256 indexed oldIndex, address indexed newOwner, uint256 indexed newIndex, uint256 ink, uint256 debt) anonymous;\n\n    // --- constructor ---\n\n    constructor(address oldEngine_, address newEngine_, address mkrSky_, address flash_) {\n        oldEngine = LockstakeEngineLike(oldEngine_);\n        newEngine = LockstakeEngineLike(newEngine_);\n        mkrSky = MkrSkyLike(mkrSky_);\n        flash = FlashLike(flash_);\n        vat = oldEngine.vat();\n        usdsJoin = oldEngine.usdsJoin();\n        oldIlk = oldEngine.ilk();\n        mkrSkyRate = mkrSky.rate();\n\n        TokenLike usds = usdsJoin.usds();\n        oldEngine.mkr().approve(mkrSky_, type(uint256).max);\n        oldEngine.sky().approve(newEngine_, type(uint256).max);\n        usds.approve(oldEngine_, type(uint256).max);\n        usds.approve(address(usdsJoin), type(uint256).max);\n        vat.hope(address(usdsJoin));\n    }\n\n    function migrate(address oldOwner, uint256 oldIndex, address newOwner, uint256 newIndex, uint16 ref) external {\n        require(oldEngine.isUrnAuth(oldOwner, oldIndex, msg.sender), \"LockstakeMigrator/sender-not-authed-old-urn\");\n        require(newEngine.isUrnAuth(newOwner, newIndex, msg.sender), \"LockstakeMigrator/sender-not-authed-new-urn\");\n\n        address oldUrn = oldEngine.ownerUrns(oldOwner, oldIndex);\n        (uint256 ink, uint256 art) = vat.urns(oldIlk, oldUrn);\n        uint256 debt;\n        if (art == 0) {\n            oldEngine.freeNoFee(oldOwner, oldIndex, address(this), ink);\n            mkrSky.mkrToSky(address(this), ink);\n            newEngine.lock(newOwner, newIndex, ink * mkrSkyRate, ref);\n        } else {\n            (, uint256 oldIlkRate,,,) = vat.ilks(oldIlk);\n            debt = _divup(art * oldIlkRate, RAY) * RAY;\n            flash.vatDaiFlashLoan(address(this), debt, abi.encode(oldOwner, oldIndex, newOwner, newIndex, ink, ref));\n        }\n\n        emit Migrate(oldOwner, oldIndex, newOwner, newIndex, ink, debt);\n    }\n\n    function onVatDaiFlashLoan(address initiator, uint256 radAmt, uint256, bytes calldata data) external returns (bytes32) {\n        require(msg.sender == address(flash) && initiator == address(this), \"LockstakeMigrator/wrong-origin\");\n\n        uint256 wadAmt = radAmt / RAY;\n        (address oldOwner, uint256 oldIndex, address newOwner, uint256 newIndex, uint256 ink, uint16 ref) = abi.decode(data, (address, uint256, address, uint256, uint256, uint16));\n        usdsJoin.exit(address(this), wadAmt);\n        oldEngine.wipeAll(oldOwner, oldIndex);\n        oldEngine.freeNoFee(oldOwner, oldIndex, address(this), ink);\n        mkrSky.mkrToSky(address(this), ink);\n        newEngine.lock(newOwner, newIndex, ink * mkrSkyRate, ref);\n        newEngine.draw(newOwner, newIndex, address(this), wadAmt);\n        usdsJoin.join(address(flash), wadAmt);\n\n        return keccak256(\"VatDaiFlashBorrower.onVatDaiFlashLoan\");\n    }\n}\n"
    }
}