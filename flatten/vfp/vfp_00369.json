{
    "vfp_id": "vfp_00369",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Errors",
            "description": "Several custom errors are defined but never used, including `TransferAmtExceedsAssetBridgeBalance`, `InsufficientFinalBalance`, and `DonationBoxInsufficientFundsError`.\nThe root cause is likely incomplete implementation or removal of logic that used these errors.\nUnused errors clutter the code and may mislead developers into thinking certain checks are in place.\nThe impact is reduced code clarity and potential confusion about the actual error handling behavior.\n",
            "severity": "Informational",
            "location": [
                "HyperCoreLib.sol::TransferAmtExceedsAssetBridgeBalance#68",
                "ArbitraryEVMFlowExecutor.sol::InsufficientFinalBalance#40",
                "HyperCoreFlowExecutor.sol::DonationBoxInsufficientFundsError#178"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/libraries/HyperCoreLib.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Unaddressed TODO Comments",
            "description": "TODO comments in the codebase (e.g., in `SponsoredCCTPInterface.sol` and `HyperCoreLib.sol`) indicate incomplete or pending work that has not been resolved before audit.\nThe cause is development tasks were left incomplete and tracked only in code comments rather than in a formal issue tracker.\nIf the TODOs relate to security-critical functionality, their neglect could lead to vulnerabilities. Even if not, they indicate technical debt.\nThe impact is increased risk of forgotten security considerations, reduced code maturity, and potential for future bugs if not properly tracked and resolved.\n",
            "severity": "Informational",
            "location": [
                "SponsoredCCTPInterface.sol#59",
                "HyperCoreLib.sol#48"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/interfaces/SponsoredCCTPInterface.sol",
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/libraries/HyperCoreLib.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unoptimized USDC Transfer to HyperCore",
            "description": "The `HyperCoreLib` library uses a two-step process to transfer USDC to HyperCore, first depositing to its own account and then transferring to the final recipient, instead of using a single `depositFor` call.\nThe cause is suboptimal implementation that does not leverage the full functionality of the `ICoreDepositWallet` contract.\nThis inefficiency increases gas costs and transaction complexity for USDC transfers, though it does not lead to fund loss.\nThe impact is higher transaction costs and reduced efficiency for USDC transfers, negatively affecting user experience and economic efficiency.\n",
            "severity": "Low",
            "location": [
                "HyperCoreLib.sol::transferERC20EVMToCore"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/libraries/HyperCoreLib.sol"
            ]
        }
    ],
    "affected_files": {
        "SponsoredCCTPInterface.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n/**\n * @title SponsoredCCTPInterface\n * @notice Interface for the SponsoredCCTP contract\n * @custom:security-contact bugs@across.to\n */\ninterface SponsoredCCTPInterface {\n    // Error thrown when the signature is invalid.\n    error InvalidSignature();\n\n    // Error thrown when the nonce is invalid.\n    error InvalidNonce();\n\n    // Error thrown when the deadline is invalid.\n    error InvalidDeadline();\n\n    // Error thrown when the source domain is invalid.\n    error InvalidSourceDomain();\n\n    // Error thrown when the CCTP message transmitter receive message fails.\n    error CCTPMessageTransmitterFailed();\n\n    event SponsoredDepositForBurn(\n        bytes32 indexed quoteNonce,\n        address indexed originSender,\n        bytes32 indexed finalRecipient,\n        uint256 quoteDeadline,\n        uint256 maxBpsToSponsor,\n        uint256 maxUserSlippageBps,\n        bytes32 finalToken,\n        bytes signature\n    );\n\n    // Event when emergency receive is called\n    event EmergencyReceiveMessage(bytes32 nonce, address finalRecipent, address finalToken, uint256 amount);\n\n    // Execution modes for the sponsored CCTP flow\n    enum ExecutionMode {\n        // Send to core and perform swap (if needed) there.\n        DirectToCore,\n        // Execute arbitrary actions (like a swap) on HyperEVM, then transfer to HyperCore\n        ArbitraryActionsToCore,\n        // Execute arbitrary actions on HyperEVM only (no HyperCore transfer)\n        ArbitraryActionsToEVM\n    }\n\n    // Params that will be used to create a sponsored CCTP quote and deposit for burn.\n    struct SponsoredCCTPQuote {\n        // The domain ID of the source chain.\n        uint32 sourceDomain;\n        // The domain ID of the destination chain.\n        uint32 destinationDomain;\n        // The recipient of the minted USDC on the destination chain.\n        bytes32 mintRecipient;\n        // The amount that the user pays on the source chain.\n        uint256 amount;\n        // The token that will be burned on the source chain.\n        bytes32 burnToken;\n        // The caller of the destination chain.\n        bytes32 destinationCaller;\n        // Maximum fee to pay on the destination domain, specified in units of burnToken\n        uint256 maxFee;\n        // Minimum finality threshold before allowed to attest\n        uint32 minFinalityThreshold;\n        // Nonce is used to prevent replay attacks.\n        bytes32 nonce;\n        // Timestamp of the quote after which it can no longer be used.\n        uint256 deadline;\n        // The maximum basis points of the amount that can be sponsored.\n        uint256 maxBpsToSponsor;\n        // Slippage tolerance for the fees on the destination. Used in swap flow, enforced on destination\n        uint256 maxUserSlippageBps;\n        // The final recipient of the sponsored deposit. This is needed as the mintRecipient will be the\n        // handler contract address instead of the final recipient.\n        bytes32 finalRecipient;\n        // The final token that final recipient will receive. This is needed as it can be different from the burnToken\n        // in which case we perform a swap on the destination chain.\n        bytes32 finalToken;\n        // Execution mode: DirectToCore, ArbitraryActionsToCore, or ArbitraryActionsToEVM\n        uint8 executionMode;\n        // Encoded action data for arbitrary execution. Empty for DirectToCore mode.\n        bytes actionData;\n    }\n}\n",
        "HyperCoreLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\nimport { ICoreDepositWallet } from \"../external/interfaces/ICoreDepositWallet.sol\";\n\ninterface ICoreWriter {\n    function sendRawAction(bytes calldata data) external;\n}\n\nlibrary HyperCoreLib {\n    using SafeERC20 for IERC20;\n\n    // Time-in-Force order types\n    enum Tif {\n        None, // invalid\n        ALO, // Add Liquidity Only\n        GTC, // Good-Till-Cancel\n        IOC // Immediate-or-Cancel\n    }\n\n    struct SpotBalance {\n        uint64 total;\n        uint64 hold; // Unused in this implementation\n        uint64 entryNtl; // Unused in this implementation\n    }\n\n    struct TokenInfo {\n        string name;\n        uint64[] spots;\n        uint64 deployerTradingFeeShare;\n        address deployer;\n        address evmContract;\n        uint8 szDecimals;\n        uint8 weiDecimals;\n        int8 evmExtraWeiDecimals;\n    }\n\n    struct CoreUserExists {\n        bool exists;\n    }\n\n    // Base asset bridge addresses\n    address public constant BASE_ASSET_BRIDGE_ADDRESS = 0x2000000000000000000000000000000000000000;\n    uint256 public constant BASE_ASSET_BRIDGE_ADDRESS_UINT256 = uint256(uint160(BASE_ASSET_BRIDGE_ADDRESS));\n\n    // Precompile addresses\n    address public constant SPOT_BALANCE_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000801;\n    address public constant SPOT_PX_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000808;\n    address public constant CORE_USER_EXISTS_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000810;\n    address public constant TOKEN_INFO_PRECOMPILE_ADDRESS = 0x000000000000000000000000000000000000080C;\n    address public constant CORE_WRITER_PRECOMPILE_ADDRESS = 0x3333333333333333333333333333333333333333;\n\n    // USDC\n    address public constant USDC_CORE_DEPOSIT_WALLET_ADDRESS = 0x6B9E773128f453f5c2C60935Ee2DE2CBc5390A24;\n    uint64 public constant USDC_CORE_INDEX = 0;\n\n    // CoreWriter action headers\n    bytes4 public constant LIMIT_ORDER_HEADER = 0x01000001; // version=1, action=1\n    bytes4 public constant SPOT_SEND_HEADER = 0x01000006; // version=1, action=6\n    bytes4 public constant CANCEL_BY_CLOID_HEADER = 0x0100000B; // version=1, action=11\n\n    // HyperCore protocol constants\n    uint32 private constant CORE_SPOT_DEX_ID = type(uint32).max;\n\n    // Errors\n    error LimitPxIsZero();\n    error OrderSizeIsZero();\n    error InvalidTif();\n    error SpotBalancePrecompileCallFailed();\n    error CoreUserExistsPrecompileCallFailed();\n    error TokenInfoPrecompileCallFailed();\n    error SpotPxPrecompileCallFailed();\n\n    /**\n     * @notice Transfer `amountEVM` from HyperEVM to `to` on HyperCore.\n     * @dev Returns the amount credited on Core in Core units (post conversion).\n     * @param erc20EVMAddress The address of the ERC20 token on HyperEVM\n     * @param erc20CoreIndex The HyperCore index id of the token to transfer\n     * @param to The address to receive tokens on HyperCore\n     * @param amountEVM The amount to transfer on HyperEVM\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMSent The amount sent on HyperEVM\n     * @return amountCoreToReceive The amount credited on Core in Core units (post conversion)\n     */\n    function transferERC20EVMToCore(\n        address erc20EVMAddress,\n        uint64 erc20CoreIndex,\n        address to,\n        uint256 amountEVM,\n        int8 decimalDiff\n    ) internal returns (uint256 amountEVMSent, uint64 amountCoreToReceive) {\n        // if the transfer amount exceeds the bridge balance, this wil revert\n        (uint256 _amountEVMToSend, uint64 _amountCoreToReceive) = maximumEVMSendAmountToAmounts(amountEVM, decimalDiff);\n\n        if (_amountEVMToSend != 0) {\n            transferToCore(erc20EVMAddress, erc20CoreIndex, _amountEVMToSend);\n            // Transfer the tokens from this contract on HyperCore to the `to` address on HyperCore\n            transferERC20CoreToCore(erc20CoreIndex, to, _amountCoreToReceive);\n        }\n\n        return (_amountEVMToSend, _amountCoreToReceive);\n    }\n\n    /**\n     * @notice Bridges `amountEVM` of `erc20` from this address on HyperEVM to this address on HyperCore.\n     * @dev Returns the amount credited on Core in Core units (post conversion).\n     * @dev The decimal difference is evmDecimals - coreDecimals\n     * @param erc20EVMAddress The address of the ERC20 token on HyperEVM\n     * @param erc20CoreIndex The HyperCore index id of the token to transfer\n     * @param amountEVM The amount to transfer on HyperEVM\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMSent The amount sent on HyperEVM\n     * @return amountCoreToReceive The amount credited on Core in Core units (post conversion)\n     */\n    function transferERC20EVMToSelfOnCore(\n        address erc20EVMAddress,\n        uint64 erc20CoreIndex,\n        uint256 amountEVM,\n        int8 decimalDiff\n    ) internal returns (uint256 amountEVMSent, uint64 amountCoreToReceive) {\n        (uint256 _amountEVMToSend, uint64 _amountCoreToReceive) = maximumEVMSendAmountToAmounts(amountEVM, decimalDiff);\n\n        if (_amountEVMToSend != 0) {\n            transferToCore(erc20EVMAddress, erc20CoreIndex, _amountEVMToSend);\n        }\n\n        return (_amountEVMToSend, _amountCoreToReceive);\n    }\n\n    /**\n     * @notice Transfers tokens from this contract on HyperCore to the `to` address on HyperCore\n     * @param erc20CoreIndex The HyperCore index id of the token\n     * @param to The address to receive tokens on HyperCore\n     * @param amountCore The amount to transfer on HyperCore\n     */\n    function transferERC20CoreToCore(uint64 erc20CoreIndex, address to, uint64 amountCore) internal {\n        bytes memory action = abi.encode(to, erc20CoreIndex, amountCore);\n        bytes memory payload = abi.encodePacked(SPOT_SEND_HEADER, action);\n\n        ICoreWriter(CORE_WRITER_PRECOMPILE_ADDRESS).sendRawAction(payload);\n    }\n\n    /**\n     * @notice Transfers tokens from this contract on HyperEVM to this contract's address on HyperCore\n     * @param erc20EVMAddress The address of the ERC20 token on HyperEVM\n     * @param erc20CoreIndex The HyperCore index id of the token to transfer\n     * @param amountEVMToSend The amount to transfer on HyperEVM\n     */\n    function transferToCore(address erc20EVMAddress, uint64 erc20CoreIndex, uint256 amountEVMToSend) internal {\n        // USDC requires a special transfer to core\n        if (erc20CoreIndex == USDC_CORE_INDEX) {\n            IERC20(erc20EVMAddress).forceApprove(USDC_CORE_DEPOSIT_WALLET_ADDRESS, amountEVMToSend);\n            ICoreDepositWallet(USDC_CORE_DEPOSIT_WALLET_ADDRESS).deposit(amountEVMToSend, CORE_SPOT_DEX_ID);\n        } else {\n            // For all other tokens, transfer to the asset bridge address on HyperCore\n            IERC20(erc20EVMAddress).safeTransfer(toAssetBridgeAddress(erc20CoreIndex), amountEVMToSend);\n        }\n    }\n\n    /**\n     * @notice Submit a limit order on HyperCore.\n     * @dev Expects price & size already scaled by 1e8 per HyperCore spec.\n     * @param asset The asset index of the order\n     * @param isBuy Whether the order is a buy order\n     * @param limitPriceX1e8 The limit price of the order scaled by 1e8\n     * @param sizeX1e8 The size of the order scaled by 1e8\n     * @param reduceOnly If true, only reduce existing position rather than opening a new opposing order\n     * @param tif Time-in-Force: ALO, GTC, IOC (None invalid)\n     * @param cloid The client order id of the order, 0 means no cloid\n     */\n    function submitLimitOrder(\n        uint32 asset,\n        bool isBuy,\n        uint64 limitPriceX1e8,\n        uint64 sizeX1e8,\n        bool reduceOnly,\n        Tif tif,\n        uint128 cloid\n    ) internal {\n        // Basic sanity checks\n        if (limitPriceX1e8 == 0) revert LimitPxIsZero();\n        if (sizeX1e8 == 0) revert OrderSizeIsZero();\n        if (tif == Tif.None || uint8(tif) > uint8(type(Tif).max)) revert InvalidTif();\n\n        // Encode the action\n        bytes memory encodedAction = abi.encode(asset, isBuy, limitPriceX1e8, sizeX1e8, reduceOnly, uint8(tif), cloid);\n\n        // Prefix with the limit-order header\n        bytes memory data = abi.encodePacked(LIMIT_ORDER_HEADER, encodedAction);\n\n        // Enqueue limit order to HyperCore via CoreWriter precompile\n        ICoreWriter(CORE_WRITER_PRECOMPILE_ADDRESS).sendRawAction(data);\n    }\n\n    /**\n     * @notice Enqueue a cancel-order-by-CLOID for a given asset.\n     * @param asset The asset index of the order\n     * @param cloid The client order id of the order\n     */\n    function cancelOrderByCloid(uint32 asset, uint128 cloid) internal {\n        // Encode the action\n        bytes memory encodedAction = abi.encode(asset, cloid);\n\n        // Prefix with the cancel-by-cloid header\n        bytes memory data = abi.encodePacked(CANCEL_BY_CLOID_HEADER, encodedAction);\n\n        // Enqueue cancel order by CLOID to HyperCore via CoreWriter precompile\n        ICoreWriter(CORE_WRITER_PRECOMPILE_ADDRESS).sendRawAction(data);\n    }\n\n    /**\n     * @notice Get the balance of the specified ERC20 for `account` on HyperCore.\n     * @param account The address of the account to get the balance of\n     * @param token The token to get the balance of\n     * @return balance The balance of the specified ERC20 for `account` on HyperCore\n     */\n    function spotBalance(address account, uint64 token) internal view returns (uint64 balance) {\n        (bool success, bytes memory result) = SPOT_BALANCE_PRECOMPILE_ADDRESS.staticcall(abi.encode(account, token));\n        if (!success) revert SpotBalancePrecompileCallFailed();\n        SpotBalance memory _spotBalance = abi.decode(result, (SpotBalance));\n        return _spotBalance.total;\n    }\n\n    /**\n     * @notice Checks if the user exists / has been activated on HyperCore.\n     * @param user The address of the user to check if they exist on HyperCore\n     * @return exists True if the user exists on HyperCore, false otherwise\n     */\n    function coreUserExists(address user) internal view returns (bool) {\n        (bool success, bytes memory result) = CORE_USER_EXISTS_PRECOMPILE_ADDRESS.staticcall(abi.encode(user));\n        if (!success) revert CoreUserExistsPrecompileCallFailed();\n        CoreUserExists memory _coreUserExists = abi.decode(result, (CoreUserExists));\n        return _coreUserExists.exists;\n    }\n\n    /**\n     * @notice Get the spot price of the specified asset on HyperCore.\n     * @param index The asset index to get the spot price of\n     * @return spotPx The spot price of the specified asset on HyperCore scaled by 1e8\n     */\n    function spotPx(uint32 index) internal view returns (uint64) {\n        (bool success, bytes memory result) = SPOT_PX_PRECOMPILE_ADDRESS.staticcall(abi.encode(index));\n        if (!success) revert SpotPxPrecompileCallFailed();\n        return abi.decode(result, (uint64));\n    }\n\n    /**\n     * @notice Get the info of the specified token on HyperCore.\n     * @param erc20CoreIndex The token to get the info of\n     * @return tokenInfo The info of the specified token on HyperCore\n     */\n    function tokenInfo(uint32 erc20CoreIndex) internal view returns (TokenInfo memory) {\n        (bool success, bytes memory result) = TOKEN_INFO_PRECOMPILE_ADDRESS.staticcall(abi.encode(erc20CoreIndex));\n        if (!success) revert TokenInfoPrecompileCallFailed();\n        TokenInfo memory _tokenInfo = abi.decode(result, (TokenInfo));\n        return _tokenInfo;\n    }\n\n    /**\n     * @notice Checks if an amount is safe to bridge from HyperEVM to HyperCore\n     * @dev Verifies that the asset bridge has sufficient balance to cover the amount plus a buffer\n     * @param erc20CoreIndex The HyperCore index id of the token\n     * @param coreAmount The amount that the bridging should result in on HyperCore\n     * @param coreBufferAmount The minimum buffer amount that should remain on HyperCore after bridging\n     * @return True if the bridge has enough balance to safely bridge the amount, false otherwise\n     */\n    function isCoreAmountSafeToBridge(\n        uint64 erc20CoreIndex,\n        uint64 coreAmount,\n        uint64 coreBufferAmount\n    ) internal view returns (bool) {\n        address bridgeAddress = toAssetBridgeAddress(erc20CoreIndex);\n        uint64 currentBridgeBalance = spotBalance(bridgeAddress, erc20CoreIndex);\n\n        // Return true if currentBridgeBalance >= coreAmount + coreBufferAmount\n        return currentBridgeBalance >= coreAmount + coreBufferAmount;\n    }\n\n    /**\n     * @notice Converts a core index id to an asset bridge address\n     * @param erc20CoreIndex The core token index id to convert\n     * @return assetBridgeAddress The asset bridge address\n     */\n    function toAssetBridgeAddress(uint64 erc20CoreIndex) internal pure returns (address) {\n        return address(uint160(BASE_ASSET_BRIDGE_ADDRESS_UINT256 + erc20CoreIndex));\n    }\n\n    /**\n     * @notice Converts an asset bridge address to a core index id\n     * @param assetBridgeAddress The asset bridge address to convert\n     * @return erc20CoreIndex The core token index id\n     */\n    function toTokenId(address assetBridgeAddress) internal pure returns (uint64) {\n        return uint64(uint160(assetBridgeAddress) - BASE_ASSET_BRIDGE_ADDRESS_UINT256);\n    }\n\n    /**\n     * @notice Returns an amount to send on HyperEVM to receive AT LEAST the minimumCoreReceiveAmount on HyperCore\n     * @param minimumCoreReceiveAmount The minimum amount desired to receive on HyperCore\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMToSend The amount to send on HyperEVM to receive at least minimumCoreReceiveAmount on HyperCore\n     * @return amountCoreToReceive The amount that will be received on core if the amountEVMToSend is sent from HyperEVM\n     */\n    function minimumCoreReceiveAmountToAmounts(\n        uint64 minimumCoreReceiveAmount,\n        int8 decimalDiff\n    ) internal pure returns (uint256 amountEVMToSend, uint64 amountCoreToReceive) {\n        if (decimalDiff == 0) {\n            // Same decimals between HyperEVM and HyperCore\n            amountEVMToSend = uint256(minimumCoreReceiveAmount);\n            amountCoreToReceive = minimumCoreReceiveAmount;\n        } else if (decimalDiff > 0) {\n            // EVM token has more decimals than Core\n            // Scale up to represent the same value in higher-precision EVM units\n            amountEVMToSend = uint256(minimumCoreReceiveAmount) * (10 ** uint8(decimalDiff));\n            amountCoreToReceive = minimumCoreReceiveAmount;\n        } else {\n            // Core token has more decimals than EVM\n            // Scale down, rounding UP to avoid shortfall on Core\n            uint256 scaleDivisor = 10 ** uint8(-decimalDiff);\n            amountEVMToSend = (uint256(minimumCoreReceiveAmount) + scaleDivisor - 1) / scaleDivisor; // ceil division\n            amountCoreToReceive = uint64(amountEVMToSend * scaleDivisor);\n        }\n    }\n\n    /**\n     * @notice Converts a maximum EVM amount to send into an EVM amount to send to avoid loss to dust,\n     * @notice and the corresponding amount that will be recieved on Core.\n     * @param maximumEVMSendAmount The maximum amount to send on HyperEVM\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMToSend The amount to send on HyperEVM\n     * @return amountCoreToReceive The amount that will be received on HyperCore if the amountEVMToSend is sent\n     */\n    function maximumEVMSendAmountToAmounts(\n        uint256 maximumEVMSendAmount,\n        int8 decimalDiff\n    ) internal pure returns (uint256 amountEVMToSend, uint64 amountCoreToReceive) {\n        /// @dev HyperLiquid decimal conversion: Scale EVM (u256,evmDecimals) -> Core (u64,coreDecimals)\n        /// @dev Core amount is guaranteed to be within u64 range.\n        if (decimalDiff == 0) {\n            amountEVMToSend = maximumEVMSendAmount;\n            amountCoreToReceive = uint64(amountEVMToSend);\n        } else if (decimalDiff > 0) {\n            // EVM token has more decimals than Core\n            uint256 scale = 10 ** uint8(decimalDiff);\n            amountEVMToSend = maximumEVMSendAmount - (maximumEVMSendAmount % scale); // Safe: dustAmount = maximumEVMSendAmount % scale, so dust <= maximumEVMSendAmount\n\n            /// @dev Safe: Guaranteed to be in the range of [0, u64.max] because it is upperbounded by uint64 maxAmt\n            amountCoreToReceive = uint64(amountEVMToSend / scale);\n        } else {\n            // Core token has more decimals than EVM\n            uint256 scale = 10 ** uint8(-1 * decimalDiff);\n            amountEVMToSend = maximumEVMSendAmount;\n\n            /// @dev Safe: Guaranteed to be in the range of [0, u64.max] because it is upperbounded by uint64 maxAmt\n            amountCoreToReceive = uint64(amountEVMToSend * scale);\n        }\n    }\n\n    function convertCoreDecimalsSimple(\n        uint64 amountDecimalsFrom,\n        uint8 decimalsFrom,\n        uint8 decimalsTo\n    ) internal pure returns (uint64) {\n        if (decimalsFrom == decimalsTo) {\n            return amountDecimalsFrom;\n        } else if (decimalsFrom < decimalsTo) {\n            return uint64(amountDecimalsFrom * 10 ** (decimalsTo - decimalsFrom));\n        } else {\n            // round down\n            return uint64(amountDecimalsFrom / 10 ** (decimalsFrom - decimalsTo));\n        }\n    }\n}\n"
    }
}