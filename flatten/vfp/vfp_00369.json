{
    "vfp_id": "vfp_00369",
    "project_name": "ChainSecurity_M0_MExtensions_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "MYieldFee Can Be Forced Into Insolvency if Non Earning",
            "description": "The MYieldFee contract uses an internal index to track yield and fees, relying on the `latestRate` value to determine if it is earning. If the contract is removed from the earner whitelist but the index is not paused, the internal accounting continues to accrue yield that is never received, leading to insolvency. The root cause is that `updateIndex()` does not validate the current earning status before resuming index growth. An attacker or governance action could trigger `updateIndex()` after removal from the earners list, reactivating the index despite no actual yield generation. This would cause the contract to owe more than it holds, resulting in insolvency and potential loss of user funds.\n",
            "severity": "High",
            "location": [
                "MYieldFee::updateIndex"
            ],
            "files": [
                "evm-m-extensions/src/projects/yieldToAllWithFee/MYieldFee.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "MEarnerManager Can Be Forced Into an Irrecoverable State",
            "description": "The MEarnerManager contract uses `wasEarningEnabled` and `disableIndex` to manage its earning state, forming a state machine where the (0, !0) state is invalid but reachable. If the contract is not an allowed earner at deployment, anyone can call `disableEarning()`, setting it into this invalid state. Once there, calling `enableEarning()` will not restore functionality, permanently disabling interest accrual. The cause is flawed state transition logic that does not validate preconditions. This leads to a bricked contract state, preventing any future yield distribution and effectively freezing user funds indefinitely.\n",
            "severity": "Medium",
            "location": [
                "MEarnerManager::disableEarning",
                "MEarnerManager::enableEarning"
            ],
            "files": [
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Removing MEarnerManager From the Earner List Will Make It Insolvent",
            "description": "If MEarnerManager is removed from the earner list without proper handling, its internal accounting continues to accrue yield even though no real yield is received. This discrepancy causes the contract to become insolvent, as obligations exceed actual holdings. The root cause is the lack of automatic pausing of the index upon removal from the earners list. An attacker or governance action could exploit this by removing and re-adding the contract, triggering a bank run as users rush to withdraw before insolvency is realized. This undermines trust and financial integrity.\n",
            "severity": "Medium",
            "location": [
                "MEarnerManager::disableEarning"
            ],
            "files": [
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-657"
                ]
            },
            "title": "Disable Initializers on Implementation",
            "description": "Wrapper extension contracts use initializer functions behind proxy patterns, but the implementation contracts remain vulnerable to initialization because `_disableInitializers()` is not called. While no immediate harm occurs, leaving initializers enabled on the implementation contract is a security anti-pattern. The cause is missing defensive coding in the constructor. A malicious actor could potentially re-initialize the implementation, leading to unexpected behavior or future exploit vectors if combined with other vulnerabilities. Though low risk, it violates secure design principles.\n",
            "severity": "Low",
            "location": [
                "MExtenstion::constructor"
            ],
            "files": [
                "evm-m-extensions/src/projects/yieldToAllWithFee/MYieldFee.sol",
                "evm-m-extensions/src/projects/yieldToOne/MYieldToOne.sol",
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect earnerRate() Returned by MYieldFee When Not Earning",
            "description": "The `MYieldFee.earnerRate()` function fails to return 0 when the contract is not earning, instead returning the discounted earner rate. This misrepresents the actual earning status. The cause is missing logic to check earning state before returning the rate. External systems relying on this function for decision-making (e.g., UIs, oracles, or other contracts) may incorrectly assume yield generation is ongoing, leading to flawed economic models or user confusion. While not directly exploitable for fund theft, it distorts system transparency.\n",
            "severity": "Low",
            "location": [
                "MYieldFee::earnerRate"
            ],
            "files": [
                "evm-m-extensions/src/projects/yieldToAllWithFee/MYieldFee.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Blacklist Can Theoretically Be Evaded",
            "description": "The MYieldToOne token implements a blacklist that prevents blacklisted users from spending allowances but does not block EIP-3009 signatures, which can be used from fresh addresses. The cause is incomplete enforcement of restrictions across all transfer mechanisms. A blacklisted user could use a valid signature from a non-blacklisted account to transfer funds via a lending protocol or similar system. While no such protocol currently exists, this represents a theoretical attack vector that could undermine sanction compliance if exploited in the future.\n",
            "severity": "Informational",
            "location": [
                "MYieldToOne::EIP-3009 transferWithAuthorization"
            ],
            "files": [
                "evm-m-extensions/src/projects/yieldToOne/MYieldToOne.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ]
            },
            "title": "Wrong feeRate in Event for De-Whitelisted Addresses",
            "description": "In MEarnerManager, when an address is de-whitelisted, the emitted event shows `feeRate=0` even though the effective fee rate becomes 100%. The cause is incorrect event parameter usage. Observers relying solely on `feeRate` in the event will misinterpret the actual policy change. This inconsistency can lead to incorrect off-chain logic or user confusion, especially in automated systems that monitor fee changes.\n",
            "severity": "Informational",
            "location": [
                "MEarnerManager::deWhitelistAddress"
            ],
            "files": [
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "MEarnerManager Fee Can Round to 0",
            "description": "Due to the 6-decimal precision of $M and its extensions, small yield amounts claimed frequently can result in fees rounding down to zero. The cause is integer division truncation in fee calculation. While not profitable as an attack due to gas costs, it allows users to effectively avoid fees through high-frequency claiming. This creates a minor griefing vector and may lead to revenue loss for the protocol if exploited systematically.\n",
            "severity": "Informational",
            "location": [
                "MEarnerManager::claimFor"
            ],
            "files": [
                "evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol"
            ]
        }
    ],
    "affected_files": {
        "MYieldToOne.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { IERC20 } from \"../../../lib/common/src/interfaces/IERC20.sol\";\n\nimport { IMYieldToOne } from \"./IMYieldToOne.sol\";\n\nimport { Blacklistable } from \"../../components/Blacklistable.sol\";\nimport { MExtension } from \"../../MExtension.sol\";\n\nabstract contract MYieldToOneStorageLayout {\n    /// @custom:storage-location erc7201:M0.storage.MYieldToOne\n    struct MYieldToOneStorageStruct {\n        uint256 totalSupply;\n        address yieldRecipient;\n        mapping(address account => uint256 balance) balanceOf;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MYieldToOne\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_YIELD_TO_ONE_STORAGE_LOCATION =\n        0xee2f6fc7e2e5879b17985791e0d12536cba689bda43c77b8911497248f4af100;\n\n    function _getMYieldToOneStorageLocation() internal pure returns (MYieldToOneStorageStruct storage $) {\n        assembly {\n            $.slot := _M_YIELD_TO_ONE_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title  MYieldToOne\n * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token\n *         with yield claimable by a single recipient.\n * @author M0 Labs\n */\ncontract MYieldToOne is IMYieldToOne, MYieldToOneStorageLayout, MExtension, Blacklistable {\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMYieldToOne\n    bytes32 public constant YIELD_RECIPIENT_MANAGER_ROLE = keccak256(\"YIELD_RECIPIENT_MANAGER_ROLE\");\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @dev   Initializes the M extension token with yield claimable by a single recipient.\n     * @param name                   The name of the token (e.g. \"M Yield to One\").\n     * @param symbol                 The symbol of the token (e.g. \"MYO\").\n     * @param mToken                 The address of the M Token.\n     * @param swapFacility           The address of the Swap Facility.\n     * @param yieldRecipient_        The address of an yield destination.\n     * @param admin           The address of a admin.\n     * @param blacklistManager       The address of a blacklist manager.\n     * @param yieldRecipientManager  The address of a yield recipient setter.\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address mToken,\n        address swapFacility,\n        address yieldRecipient_,\n        address admin,\n        address blacklistManager,\n        address yieldRecipientManager\n    ) public initializer {\n        if (yieldRecipientManager == address(0)) revert ZeroYieldRecipientManager();\n        if (admin == address(0)) revert ZeroAdmin();\n\n        __MExtension_init(name, symbol, mToken, swapFacility);\n        __Blacklistable_init(blacklistManager);\n\n        _setYieldRecipient(yieldRecipient_);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(YIELD_RECIPIENT_MANAGER_ROLE, yieldRecipientManager);\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMYieldToOne\n    function claimYield() external returns (uint256) {\n        uint256 yield_ = yield();\n\n        if (yield_ == 0) revert NoYield();\n\n        emit YieldClaimed(yield_);\n\n        _mint(yieldRecipient(), yield_);\n\n        return yield_;\n    }\n\n    /// @inheritdoc IMYieldToOne\n    function setYieldRecipient(address account) external onlyRole(YIELD_RECIPIENT_MANAGER_ROLE) {\n        _setYieldRecipient(account);\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view override returns (uint256) {\n        return _getMYieldToOneStorageLocation().balanceOf[account];\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view returns (uint256) {\n        return _getMYieldToOneStorageLocation().totalSupply;\n    }\n\n    /// @inheritdoc IMYieldToOne\n    function yield() public view returns (uint256) {\n        unchecked {\n            uint256 balance_ = _mBalanceOf(address(this));\n            uint256 totalSupply_ = totalSupply();\n\n            return balance_ > totalSupply_ ? balance_ - totalSupply_ : 0;\n        }\n    }\n\n    /// @inheritdoc IMYieldToOne\n    function yieldRecipient() public view returns (address) {\n        return _getMYieldToOneStorageLocation().yieldRecipient;\n    }\n\n    /* ============ Hooks For Internal Interactive Functions ============ */\n\n    /**\n     * @dev    Hooks called before approval of M extension spend.\n     * @param  account The account from which M is deposited.\n     * @param  spender The account spending M Extension token.\n     */\n    function _beforeApprove(address account, address spender, uint256 /* amount */) internal view override {\n        BlacklistableStorageStruct storage $ = _getBlacklistableStorageLocation();\n\n        _revertIfBlacklisted($, account);\n        _revertIfBlacklisted($, spender);\n    }\n\n    /**\n     * @dev    Hooks called before wrapping M into M Extension token.\n     * @param  account   The account from which M is deposited.\n     * @param  recipient The account receiving the minted M Extension token.\n     */\n    function _beforeWrap(address account, address recipient, uint256 /* amount */) internal view override {\n        BlacklistableStorageStruct storage $ = _getBlacklistableStorageLocation();\n\n        _revertIfBlacklisted($, account);\n        _revertIfBlacklisted($, recipient);\n    }\n\n    /**\n     * @dev   Hook called before unwrapping M Extension token.\n     * @param account The account from which M Extension token is burned.\n     */\n    function _beforeUnwrap(address account, uint256 /* amount */) internal view override {\n        _revertIfBlacklisted(_getBlacklistableStorageLocation(), account);\n    }\n\n    /**\n     * @dev   Hook called before transferring M Extension token.\n     * @param sender    The address from which the tokens are being transferred.\n     * @param recipient The address to which the tokens are being transferred.\n     */\n    function _beforeTransfer(address sender, address recipient, uint256 /* amount */) internal view override {\n        BlacklistableStorageStruct storage $ = _getBlacklistableStorageLocation();\n\n        _revertIfBlacklisted($, msg.sender);\n\n        _revertIfBlacklisted($, sender);\n        _revertIfBlacklisted($, recipient);\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Mints `amount` tokens to `recipient`.\n     * @param recipient The address whose account balance will be incremented.\n     * @param amount    The present amount of tokens to mint.\n     */\n    function _mint(address recipient, uint256 amount) internal override {\n        MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();\n\n        // NOTE: Can be `unchecked` because the max amount of $M is never greater than `type(uint240).max`.\n        unchecked {\n            $.balanceOf[recipient] += amount;\n            $.totalSupply += amount;\n        }\n\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev   Burns `amount` tokens from `account`.\n     * @param account The address whose account balance will be decremented.\n     * @param amount  The present amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal override {\n        MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used in MExtension.\n        unchecked {\n            $.balanceOf[account] -= amount;\n            $.totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _update(address sender, address recipient, uint256 amount) internal override {\n        MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` for `sender` is used in MExtension.\n        unchecked {\n            $.balanceOf[sender] -= amount;\n            $.balanceOf[recipient] += amount;\n        }\n    }\n\n    /**\n     * @dev Sets the yield recipient.\n     * @param yieldRecipient_ The address of the new yield recipient.\n     */\n    function _setYieldRecipient(address yieldRecipient_) internal {\n        if (yieldRecipient_ == address(0)) revert ZeroYieldRecipient();\n\n        MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();\n\n        if (yieldRecipient_ == $.yieldRecipient) return;\n\n        $.yieldRecipient = yieldRecipient_;\n\n        emit YieldRecipientSet(yieldRecipient_);\n    }\n}\n",
        "MYieldFee.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport {\n    AccessControlUpgradeable\n} from \"../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\n\nimport { IERC20 } from \"../../../lib/common/src/interfaces/IERC20.sol\";\n\nimport { ContinuousIndexingMath } from \"../../../lib/common/src/libs/ContinuousIndexingMath.sol\";\nimport { UIntMath } from \"../../../lib/common/src/libs/UIntMath.sol\";\n\nimport { IndexingMath } from \"../../libs/IndexingMath.sol\";\n\nimport { IMExtension } from \"../../interfaces/IMExtension.sol\";\nimport { IMTokenLike } from \"../../interfaces/IMTokenLike.sol\";\n\nimport { IMYieldFee } from \"./interfaces/IMYieldFee.sol\";\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\n\nimport { MExtension } from \"../../MExtension.sol\";\n\nabstract contract MYieldFeeStorageLayout {\n    /// @custom:storage-location erc7201:M0.storage.MYieldFee\n    struct MYieldFeeStorageStruct {\n        // NOTE: Slot 1\n        uint256 totalSupply;\n        // NOTE: Slot 2\n        uint112 totalPrincipal;\n        uint128 latestIndex;\n        uint16 feeRate;\n        // NOTE: Slot 3\n        address feeRecipient;\n        uint40 latestUpdateTimestamp;\n        uint32 latestRate;\n        // NOTE: Slot 4\n        mapping(address account => uint256 balance) balanceOf;\n        // NOTE: Slot 5\n        mapping(address account => uint112 principal) principalOf;\n        // NOTE: Slot 6\n        mapping(address account => address claimRecipient) claimRecipients;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MYieldFee\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_YIELD_FEE_STORAGE_LOCATION =\n        0x9d728c135b5b2cd0ace61885d69c4f72215f10f82e77822fb7c6bf472237dd00;\n\n    function _getMYieldFeeStorageLocation() internal pure returns (MYieldFeeStorageStruct storage $) {\n        assembly {\n            $.slot := _M_YIELD_FEE_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title MYieldFee\n * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.\n *         Extended to take a fee from the yield generated by M.\n * @dev    All holders of this ERC20 token are earners.\n * @author M0 Labs\n */\ncontract MYieldFee is IContinuousIndexing, IMYieldFee, AccessControlUpgradeable, MYieldFeeStorageLayout, MExtension {\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMYieldFee\n    uint16 public constant ONE_HUNDRED_PERCENT = 10_000;\n\n    /// @inheritdoc IMYieldFee\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n\n    /// @inheritdoc IMYieldFee\n    bytes32 public constant CLAIM_RECIPIENT_MANAGER_ROLE = keccak256(\"CLAIM_RECIPIENT_MANAGER_ROLE\");\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @notice Initializes the generic M Yield Fee extension token.\n     * @param name             The name of the token (e.g. \"M Yield Fee\").\n     * @param symbol           The symbol of the token (e.g. \"MYF\").\n     * @param mToken           The address of an M Token.\n     * @param swapFacility     The address of the Swap Facility.\n     * @param feeRate_         The fee rate, in bps, that will be taken from the yield generated by M.\n     * @param feeRecipient_    The address of the recipient of the yield fee.\n     * @param admin            The address administrating the M extension. Can grant and revoke roles.\n     * @param feeManager       The address managing the fee rate and recipient.\n     * @param claimRecipientManager The address managing claim recipients for accounts.\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address mToken,\n        address swapFacility,\n        uint16 feeRate_,\n        address feeRecipient_,\n        address admin,\n        address feeManager,\n        address claimRecipientManager\n    ) public virtual initializer {\n        if (admin == address(0)) revert ZeroAdmin();\n        if (feeManager == address(0)) revert ZeroFeeManager();\n        if (claimRecipientManager == address(0)) revert ZeroClaimRecipientManager();\n\n        __MExtension_init(name, symbol, mToken, swapFacility);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(FEE_MANAGER_ROLE, feeManager);\n        _grantRole(CLAIM_RECIPIENT_MANAGER_ROLE, claimRecipientManager);\n\n        _setFeeRate(feeRate_);\n        _setFeeRecipient(feeRecipient_);\n\n        _getMYieldFeeStorageLocation().latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMYieldFee\n    function claimYieldFor(address account) external returns (uint256) {\n        if (account == address(0)) revert ZeroAccount();\n\n        uint256 yield_ = accruedYieldOf(account);\n\n        if (yield_ == 0) return 0;\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.\n        unchecked {\n            $.balanceOf[account] += yield_;\n            $.totalSupply += yield_;\n        }\n\n        address claimRecipient_ = claimRecipientFor(account);\n\n        // Emit the appropriate `YieldClaimed` and `Transfer` events, depending on the claim override recipient\n        emit YieldClaimed(account, claimRecipient_, yield_);\n        emit Transfer(address(0), claimRecipient_, yield_);\n\n        if (claimRecipient_ == account) return yield_;\n\n        // Distribute the yield to the claim recipient.\n        _update(account, claimRecipient_, yield_);\n\n        return yield_;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function claimFee() public returns (uint256) {\n        uint256 yieldFee_ = totalAccruedFee();\n\n        if (yieldFee_ == 0) return 0;\n\n        address recipient_ = _getMYieldFeeStorageLocation().feeRecipient;\n\n        emit FeeClaimed(msg.sender, recipient_, yieldFee_);\n\n        // NOTE: Round up to allow claiming the whole amount of yield fee.\n        _mint(recipient_, yieldFee_, IndexingMath.getPrincipalAmountRoundedUp(yieldFee_, currentIndex()));\n\n        return yieldFee_;\n    }\n\n    /// @inheritdoc IMExtension\n    function enableEarning() external override {\n        if (isEarningEnabled()) revert EarningIsEnabled();\n\n        // NOTE: update the index to store the latest state, current index won't accrue since `latestRate` is 0.\n        emit EarningEnabled(updateIndex());\n\n        IMTokenLike(mToken()).startEarning();\n    }\n\n    /// @inheritdoc IMExtension\n    function disableEarning() external override {\n        if (!isEarningEnabled()) revert EarningIsDisabled();\n\n        // NOTE: update the index to store the latest state.\n        emit EarningDisabled(updateIndex());\n\n        // NOTE: `latestRate` is set to 0 to indicate that earning is disabled.\n        delete _getMYieldFeeStorageLocation().latestRate;\n\n        IMTokenLike(mToken()).stopEarning(address(this));\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function updateIndex() public virtual returns (uint128 currentIndex_) {\n        // NOTE: Read the current M token rate adjusted by fee rate split.\n        uint32 rate_ = earnerRate();\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.latestUpdateTimestamp == block.timestamp && $.latestRate == rate_) return $.latestIndex;\n\n        // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.\n        $.latestIndex = currentIndex_ = currentIndex();\n        $.latestRate = rate_;\n        $.latestUpdateTimestamp = _latestEarnerRateAccrualTimestamp();\n\n        emit IndexUpdated(currentIndex_, rate_);\n    }\n\n    /// @inheritdoc IMYieldFee\n    function setFeeRate(uint16 feeRate_) external onlyRole(FEE_MANAGER_ROLE) {\n        _setFeeRate(feeRate_);\n\n        // NOTE: Update the index to store the new adjusted rate.\n        if (isEarningEnabled()) updateIndex();\n    }\n\n    /// @inheritdoc IMYieldFee\n    function setFeeRecipient(address feeRecipient_) external onlyRole(FEE_MANAGER_ROLE) {\n        // Claim fee for the previous fee recipient.\n        claimFee();\n\n        _setFeeRecipient(feeRecipient_);\n    }\n\n    /// @inheritdoc IMYieldFee\n    function setClaimRecipient(\n        address account,\n        address claimRecipient\n    ) external onlyRole(CLAIM_RECIPIENT_MANAGER_ROLE) {\n        if (account == address(0)) revert ZeroAccount();\n        if (claimRecipient == address(0)) revert ZeroClaimRecipient();\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.claimRecipients[account] == claimRecipient) return;\n\n        // Optionally consider claiming yield for the previous claim recipient.\n        // claimYieldFor(account);\n\n        $.claimRecipients[account] = claimRecipient;\n\n        emit ClaimRecipientSet(account, claimRecipient);\n    }\n\n    /* ============ External/Public view functions ============ */\n\n    /// @inheritdoc IMYieldFee\n    function accruedYieldOf(address account) public view returns (uint256) {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n        return _getAccruedYield($.balanceOf[account], $.principalOf[account], currentIndex());\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view override returns (uint256) {\n        return _getMYieldFeeStorageLocation().balanceOf[account];\n    }\n\n    /// @inheritdoc IMYieldFee\n    function balanceWithYieldOf(address account) external view returns (uint256) {\n        unchecked {\n            return balanceOf(account) + accruedYieldOf(account);\n        }\n    }\n\n    /// @inheritdoc IMYieldFee\n    function principalOf(address account) public view returns (uint112) {\n        return _getMYieldFeeStorageLocation().principalOf[account];\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function currentIndex() public view virtual override(IContinuousIndexing, MExtension) returns (uint128) {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if (!isEarningEnabled()) return $.latestIndex;\n\n        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.\n        unchecked {\n            return\n                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.\n                UIntMath.bound128(\n                    ContinuousIndexingMath.multiplyIndicesDown(\n                        $.latestIndex,\n                        ContinuousIndexingMath.getContinuousIndex(\n                            ContinuousIndexingMath.convertFromBasisPoints($.latestRate),\n                            uint32(_latestEarnerRateAccrualTimestamp() - $.latestUpdateTimestamp)\n                        )\n                    )\n                );\n        }\n    }\n\n    /// @inheritdoc IMYieldFee\n    function earnerRate() public view virtual returns (uint32) {\n        return UIntMath.safe32((uint256(ONE_HUNDRED_PERCENT - feeRate()) * _currentEarnerRate()) / ONE_HUNDRED_PERCENT);\n    }\n\n    /// @inheritdoc IMExtension\n    function isEarningEnabled() public view override returns (bool) {\n        return _getMYieldFeeStorageLocation().latestRate != 0;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function latestIndex() public view returns (uint128) {\n        return _getMYieldFeeStorageLocation().latestIndex;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function latestRate() public view returns (uint32) {\n        return _getMYieldFeeStorageLocation().latestRate;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function latestUpdateTimestamp() public view returns (uint40) {\n        return _getMYieldFeeStorageLocation().latestUpdateTimestamp;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function projectedTotalSupply() public view returns (uint256) {\n        return IndexingMath.getPresentAmountRoundedUp(_getMYieldFeeStorageLocation().totalPrincipal, currentIndex());\n    }\n\n    /// @inheritdoc IMYieldFee\n    function totalAccruedYield() public view returns (uint256) {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n        return _getAccruedYield($.totalSupply, $.totalPrincipal, currentIndex());\n    }\n\n    /// @inheritdoc IMYieldFee\n    function totalAccruedFee() public view returns (uint256) {\n        uint256 mBalance_ = _mBalanceOf(address(this));\n        uint256 projectedTotalSupply_ = projectedTotalSupply();\n\n        unchecked {\n            return mBalance_ > projectedTotalSupply_ ? mBalance_ - projectedTotalSupply_ : 0;\n        }\n    }\n\n    /// @inheritdoc IMYieldFee\n    function totalPrincipal() public view returns (uint112) {\n        return _getMYieldFeeStorageLocation().totalPrincipal;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view returns (uint256) {\n        return _getMYieldFeeStorageLocation().totalSupply;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function feeRate() public view returns (uint16) {\n        return _getMYieldFeeStorageLocation().feeRate;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function feeRecipient() public view returns (address) {\n        return _getMYieldFeeStorageLocation().feeRecipient;\n    }\n\n    /// @inheritdoc IMYieldFee\n    function claimRecipientFor(address account) public view returns (address) {\n        address recipient_ = _getMYieldFeeStorageLocation().claimRecipients[account];\n\n        // If no claim recipient is set, return the account itself.\n        return recipient_ == address(0) ? account : recipient_;\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Mints `amount` tokens to `recipient`.\n     * @param recipient The address that will receive tokens.\n     * @param amount    The amount of tokens to mint.\n     */\n    function _mint(address recipient, uint256 amount) internal override {\n        _mint(recipient, amount, IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex()));\n    }\n\n    /**\n     * @dev   Mints `amount` tokens to `recipient` with a specified principal.\n     * @param recipient The address that will receive tokens.\n     * @param amount    The amount of tokens to mint.\n     * @param principal The principal amount to be associated with the minted tokens.\n     */\n    function _mint(address recipient, uint256 amount, uint112 principal) internal {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // NOTE: Can be `unchecked` because the max amount of  M is never greater than `type(uint240).max`.\n        //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `totalPrincipal`\n        unchecked {\n            $.balanceOf[recipient] += amount;\n            $.totalSupply += amount;\n\n            $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal);\n            // No need for `UIntMath.safe112`, `principalOf[recipient]` cannot be greater than `totalPrincipal`.\n            $.principalOf[recipient] += principal;\n        }\n\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev   Burns `amount` tokens from `account`.\n     * @param account The address whose account balance will be decremented.\n     * @param amount  The present amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal override {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in unchecked block\n        uint112 fromPrincipal_ = $.principalOf[account];\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and\n        //       `principalOf[account]` cannot be greater than `totalPrincipal`.\n        unchecked {\n            $.balanceOf[account] -= amount;\n            $.totalSupply -= amount;\n\n            $.principalOf[account] = fromPrincipal_ - principal_;\n            $.totalPrincipal -= principal_;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _update(address sender, address recipient, uint256 amount) internal override {\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        // Slightly overestimate the principal amount to be moved on transfer\n        uint112 fromPrincipal_ = $.principalOf[sender];\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because we check for insufficient sender balance above.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and\n        unchecked {\n            $.balanceOf[sender] -= amount;\n            $.balanceOf[recipient] += amount;\n\n            $.principalOf[sender] = fromPrincipal_ - principal_;\n            $.principalOf[recipient] += principal_;\n        }\n    }\n\n    /**\n     * @notice Sets the yield fee rate, in bps, that will be taken from the yield generated by M.\n     * @dev    Reverts if the yield fee rate is greater than ONE_HUNDRED_PERCENT.\n     * @dev    Returns early if the yield fee rate is the same as the current one.\n     * @param  feeRate_ The yield fee rate.\n     */\n    function _setFeeRate(uint16 feeRate_) internal {\n        if (feeRate_ > ONE_HUNDRED_PERCENT) revert FeeRateTooHigh(feeRate_, ONE_HUNDRED_PERCENT);\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.feeRate == feeRate_) return;\n\n        $.feeRate = feeRate_;\n\n        emit FeeRateSet(feeRate_);\n    }\n\n    /**\n     * @notice Sets the yield fee recipient that will receive part of the yield generated by M.\n     * @dev    Reverts if the yield fee recipient is address zero.\n     * @dev    Returns early if the yield fee recipient is the same as the current one.\n     * @param  feeRecipient_ The yield fee recipient address.\n     */\n    function _setFeeRecipient(address feeRecipient_) internal {\n        if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();\n\n        MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();\n\n        if ($.feeRecipient == feeRecipient_) return;\n\n        $.feeRecipient = feeRecipient_;\n\n        emit FeeRecipientSet(feeRecipient_);\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev   Returns the timestamp when the earner rate was last accrued to accounts.\n     *        For L1: returns the current `block.timestamp` as the rate accrues continuously.\n     *        For L2: returns the `latestUpdateTimestamp` from the M token when the index was propagated from L1.\n     *        Can be overridden by the inheriting contract (for EVM L2 contracts with index propagation).\n     *        MUST return the current block timestamp for an M extension token deployed on the mainnet.\n     *        MUST return spoke M token's `latestUpdateTimestamp` for an M extension token deployed on a spoke chain.\n     * @return The current block timestamp.\n     */\n    function _latestEarnerRateAccrualTimestamp() internal view virtual returns (uint40) {\n        return uint40(block.timestamp);\n    }\n\n    /**\n     * @dev    Returns the current earner rate.\n     *         Needs to be overridden by the inheriting contract.\n     *         MUST return M token's earner rate for an M extension token deployed on the mainnet.\n     *         MUST return a rate oracle's earner rate for an M extension token deployed on a spoke chain.\n     * @return The current earner rate.\n     */\n    function _currentEarnerRate() internal view virtual returns (uint32) {\n        // NOTE: The behavior of M is known, so we can safely retrieve the earner rate.\n        return IMTokenLike(mToken()).earnerRate();\n    }\n\n    /**\n     * @dev    Compute the yield given a balance, principal and index.\n     * @param  balance   The current balance of the account.\n     * @param  principal The principal of the account.\n     * @param  index     The current index.\n     * @return The yield accrued since the last claim.\n     */\n    function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {\n        uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);\n        unchecked {\n            return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;\n        }\n    }\n}\n",
        "MEarnerManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { IERC20 } from \"../../../lib/common/src/interfaces/IERC20.sol\";\n\nimport {\n    AccessControlUpgradeable\n} from \"../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\n\nimport { IndexingMath } from \"../../libs/IndexingMath.sol\";\nimport { UIntMath } from \"../../../lib/common/src/libs/UIntMath.sol\";\n\nimport { IMEarnerManager } from \"./IMEarnerManager.sol\";\n\nimport { MExtension } from \"../../MExtension.sol\";\n\nabstract contract MEarnerManagerStorageLayout {\n    /**\n     * @dev   Struct to represent an account's balance, whitelisted status, and earning details like `feeRate` and earning principal.\n     * @param balance       The current balance of the account.\n     * @param isWhitelisted Whether the account is whitelisted by an earner manager.\n     * @param feeRate       The fee rate that defines yield split between account and earner manager.\n     * @param principal     The earning principal for the account.\n     */\n    struct Account {\n        // Slot 1\n        uint256 balance;\n        // Slot 2\n        bool isWhitelisted;\n        uint16 feeRate;\n        uint112 principal;\n    }\n\n    /// @custom:storage-location erc7201:M0.storage.MEarnerManager\n    struct MEarnerManagerStorageStruct {\n        // Slot 1\n        address feeRecipient;\n        // Slot 2\n        uint256 totalSupply;\n        // Slot 3\n        uint112 totalPrincipal;\n        // Slot 4\n        mapping(address account => Account) accounts;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MEarnerManager\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_EARNER_MANAGER_STORAGE_LOCATION =\n        0x1c4485857d96206482b943eeab7f941848f1c52b84a4bd59d8c2a3e8468f8300;\n\n    function _getMEarnerManagerStorageLocation() internal pure returns (MEarnerManagerStorageStruct storage $) {\n        assembly {\n            $.slot := _M_EARNER_MANAGER_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title M Extension where Earner Manager whitelists accounts and sets fee rates for them.\n * @author M0 Labs\n */\ncontract MEarnerManager is IMEarnerManager, AccessControlUpgradeable, MEarnerManagerStorageLayout, MExtension {\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMEarnerManager\n    uint16 public constant ONE_HUNDRED_PERCENT = 10_000;\n\n    /// @inheritdoc IMEarnerManager\n    bytes32 public constant EARNER_MANAGER_ROLE = keccak256(\"EARNER_MANAGER_ROLE\");\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @dev   Initializes the M extension token with earner manager role and different fee tiers.\n     * @param name               The name of the token (e.g. \"M Earner Manager\").\n     * @param symbol             The symbol of the token (e.g. \"MEM\").\n     * @param mToken             The address of an M Token.\n     * @param swapFacility       The address of the Swap Facility.\n     * @param admin              The address administrating the M extension. Can grant and revoke roles.\n     * @param earnerManager      The address of earner manager\n     * @param feeRecipient_      The address that will receive the fees from all the earners.\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address mToken,\n        address swapFacility,\n        address admin,\n        address earnerManager,\n        address feeRecipient_\n    ) public virtual initializer {\n        if (admin == address(0)) revert ZeroAdmin();\n        if (earnerManager == address(0)) revert ZeroEarnerManager();\n\n        __MExtension_init(name, symbol, mToken, swapFacility);\n\n        _setFeeRecipient(feeRecipient_);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(EARNER_MANAGER_ROLE, earnerManager);\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMEarnerManager\n    function setAccountInfo(address account, bool status, uint16 feeRate) public onlyRole(EARNER_MANAGER_ROLE) {\n        _setAccountInfo(account, status, feeRate);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function setAccountInfo(\n        address[] calldata accounts,\n        bool[] calldata statuses,\n        uint16[] calldata feeRates\n    ) external onlyRole(EARNER_MANAGER_ROLE) {\n        if (accounts.length == 0) revert ArrayLengthZero();\n        if (accounts.length != statuses.length || accounts.length != feeRates.length) revert ArrayLengthMismatch();\n\n        for (uint256 index_; index_ < accounts.length; ++index_) {\n            _setAccountInfo(accounts[index_], statuses[index_], feeRates[index_]);\n        }\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function setFeeRecipient(address feeRecipient_) external onlyRole(EARNER_MANAGER_ROLE) {\n        _setFeeRecipient(feeRecipient_);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function claimFor(address account) public returns (uint256 yieldWithFee, uint256 fee, uint256 yieldNetOfFee) {\n        if (account == address(0)) revert ZeroAccount();\n\n        (yieldWithFee, fee, yieldNetOfFee) = accruedYieldAndFeeOf(account);\n\n        if (yieldWithFee == 0) return (0, 0, 0);\n\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        // Emit the appropriate `YieldClaimed` and `Transfer` events.\n        emit YieldClaimed(account, yieldNetOfFee);\n        emit Transfer(address(0), account, yieldWithFee);\n\n        // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.\n        unchecked {\n            $.accounts[account].balance += yieldWithFee;\n            $.totalSupply += yieldWithFee;\n        }\n\n        if (fee == 0) return (yieldWithFee, 0, yieldNetOfFee);\n\n        address feeRecipient_ = $.feeRecipient;\n\n        // Emit the appropriate `FeeClaimed` and `Transfer` events.\n        emit FeeClaimed(account, feeRecipient_, fee);\n        emit Transfer(account, feeRecipient_, fee);\n\n        // Transfer fee to the fee recipient.\n        _update(account, feeRecipient_, fee);\n    }\n\n    /* ============ External/Public view functions ============ */\n\n    /// @inheritdoc IMEarnerManager\n    function accruedYieldAndFeeOf(\n        address account\n    ) public view returns (uint256 yieldWithFee, uint256 fee, uint256 yieldNetOfFee) {\n        Account storage accountInfo_ = _getMEarnerManagerStorageLocation().accounts[account];\n\n        yieldWithFee = _getAccruedYield(accountInfo_.balance, accountInfo_.principal, currentIndex());\n        uint16 feeRate_ = accountInfo_.feeRate;\n\n        if (feeRate_ == 0 || yieldWithFee == 0) return (yieldWithFee, 0, yieldWithFee);\n\n        unchecked {\n            fee = (yieldWithFee * feeRate_) / ONE_HUNDRED_PERCENT;\n            yieldNetOfFee = yieldWithFee - fee;\n        }\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function accruedYieldOf(address account) public view returns (uint256 yieldNetOfFee) {\n        (, , yieldNetOfFee) = accruedYieldAndFeeOf(account);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function accruedFeeOf(address account) public view returns (uint256 fee) {\n        (, fee, ) = accruedYieldAndFeeOf(account);\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function balanceWithYieldOf(address account) external view returns (uint256) {\n        unchecked {\n            return balanceOf(account) + accruedYieldOf(account);\n        }\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view override returns (uint256) {\n        return _getMEarnerManagerStorageLocation().accounts[account].balance;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view returns (uint256) {\n        return _getMEarnerManagerStorageLocation().totalSupply;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function projectedTotalSupply() public view returns (uint256) {\n        return IndexingMath.getPresentAmountRoundedUp(totalPrincipal(), currentIndex());\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function totalPrincipal() public view returns (uint112) {\n        return _getMEarnerManagerStorageLocation().totalPrincipal;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function feeRecipient() public view returns (address) {\n        return _getMEarnerManagerStorageLocation().feeRecipient;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function isWhitelisted(address account) public view returns (bool) {\n        return _getMEarnerManagerStorageLocation().accounts[account].isWhitelisted;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function principalOf(address account) public view returns (uint112) {\n        return _getMEarnerManagerStorageLocation().accounts[account].principal;\n    }\n\n    /// @inheritdoc IMEarnerManager\n    function feeRateOf(address account) public view returns (uint16) {\n        return _getMEarnerManagerStorageLocation().accounts[account].feeRate;\n    }\n\n    /* ============ Hooks For Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Hook called before approving an allowance.\n     * @param account  The account that is approving the allowance.\n     * @param spender  The account that is being approved to spend tokens.\n     */\n    function _beforeApprove(address account, address spender, uint256 /* amount */) internal view override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        _revertIfNotWhitelisted($, account);\n        _revertIfNotWhitelisted($, spender);\n    }\n\n    /**\n     * @dev    Hooks called before wrapping M into M Extension token.\n     * @param  account   The account from which M is deposited.\n     * @param  recipient The account receiving the minted M Extension token.\n     */\n    function _beforeWrap(address account, address recipient, uint256 /* amount */) internal view override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        _revertIfNotWhitelisted($, account);\n        _revertIfNotWhitelisted($, recipient);\n    }\n\n    /**\n     * @dev   Hook called before unwrapping M Extension token.\n     * @param account The account from which M Extension token is burned.\n     */\n    function _beforeUnwrap(address account, uint256 /* amount */) internal view override {\n        _revertIfNotWhitelisted(_getMEarnerManagerStorageLocation(), account);\n    }\n\n    /**\n     * @dev   Hook called before transferring tokens.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     */\n    function _beforeTransfer(address sender, address recipient, uint256 /* amount */) internal view override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        _revertIfNotWhitelisted($, msg.sender);\n\n        _revertIfNotWhitelisted($, sender);\n        _revertIfNotWhitelisted($, recipient);\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @notice Sets the account info like:\n     *         - whitelisting or removing account from whitelist,\n     *         - fee rate for the account.\n     * @param  account The address of the accounts to whitelist for earning or remove from the whitelist.\n     * @param  status Whether an account is a whitelisted account, respectively, according to the admin.\n     * @param  feeRate The fee rate, in bps, that will be taken from the yield generated by the account.\n     */\n    function _setAccountInfo(address account, bool status, uint16 feeRate) internal {\n        if (account == address(0)) revert ZeroAccount();\n        if (feeRate > ONE_HUNDRED_PERCENT) revert InvalidFeeRate();\n        if (status == false && feeRate != 0) revert InvalidAccountInfo();\n\n        Account storage accountInfo_ = _getMEarnerManagerStorageLocation().accounts[account];\n        bool isWhitelisted_ = accountInfo_.isWhitelisted;\n\n        // No change, no-op action\n        if (!isWhitelisted_ && !status) return;\n\n        // No change, no-op action\n        if (isWhitelisted_ && status && accountInfo_.feeRate == feeRate) return;\n\n        emit AccountInfoSet(account, status, feeRate);\n\n        // Set up a new whitelisted account\n        if (!isWhitelisted_ && status) {\n            accountInfo_.isWhitelisted = true;\n            accountInfo_.feeRate = feeRate;\n            return;\n        }\n\n        // Claim yield as the action below will lead to the change in whitelisted account info.\n        claimFor(account);\n\n        if (!status) {\n            // Remove whitelisted account info.\n            accountInfo_.isWhitelisted = false;\n            // fee recipient will receive all yield from such 'un-whitelisted' accounts.\n            accountInfo_.feeRate = ONE_HUNDRED_PERCENT;\n        } else {\n            // Change fee rate for the whitelisted account.\n            accountInfo_.feeRate = feeRate;\n        }\n    }\n\n    /**\n     * @notice Sets the yield fee recipient that will receive part of the yield generated by token.\n     * @dev    Reverts if the yield fee recipient is address zero.\n     * @dev    Returns early if the yield fee recipient is the same as the current one.\n     * @param  feeRecipient_ The yield fee recipient address.\n     */\n    function _setFeeRecipient(address feeRecipient_) internal {\n        if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();\n\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n\n        if ($.feeRecipient == feeRecipient_) return;\n\n        // Yield fee recipient does not pay fees.\n        _setAccountInfo(feeRecipient_, true, 0);\n\n        $.feeRecipient = feeRecipient_;\n\n        emit FeeRecipientSet(feeRecipient_);\n    }\n\n    /**\n     * @dev   Mints `amount` tokens to `account`.\n     * @param account The address that will receive tokens.\n     * @param amount  The amount of tokens to mint.\n     */\n    function _mint(address account, uint256 amount) internal override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n        Account storage accountInfo_ = $.accounts[account];\n\n        // Slightly underestimate the principal amount to be minted, round down in favor of protocol.\n        uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex());\n\n        // NOTE: Can be `unchecked` because the max amount of $M is never greater than `type(uint240).max`.\n        //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `principal[account]`\n        unchecked {\n            accountInfo_.balance += amount;\n            $.totalSupply += amount;\n\n            $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal_);\n            // No need for `UIntMath.safe112`, `accountInfo_.principal` cannot be greater than `totalPrincipal`.\n            accountInfo_.principal += principal_;\n        }\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev   Burns `amount` tokens from `account`.\n     * @param account The address whose account balance will be decremented.\n     * @param amount  The present amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n        Account storage accountInfo_ = $.accounts[account];\n\n        // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in the unchecked block.\n        uint112 fromPrincipal_ = accountInfo_.principal;\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above\n        unchecked {\n            accountInfo_.balance -= amount;\n            $.totalSupply -= amount;\n\n            accountInfo_.principal = fromPrincipal_ - principal_;\n            $.totalPrincipal -= principal_;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _update(address sender, address recipient, uint256 amount) internal override {\n        MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();\n        Account storage senderAccount_ = $.accounts[sender];\n        Account storage recipientAccount_ = $.accounts[recipient];\n\n        // Slightly overestimate the principal amount to be moved on transfer\n        uint112 fromPrincipal_ = senderAccount_.principal;\n        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);\n\n        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used in MExtension.\n        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and\n        unchecked {\n            senderAccount_.balance -= amount;\n            recipientAccount_.balance += amount;\n\n            senderAccount_.principal = fromPrincipal_ - principal_;\n            recipientAccount_.principal += principal_;\n        }\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev    Compute the yield given a balance, principal and index.\n     * @param  balance   The current balance of the account.\n     * @param  principal The principal of the account.\n     * @param  index     The current index.\n     * @return The yield accrued since the last claim.\n     */\n    function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {\n        if (principal == 0) return 0;\n\n        uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);\n        unchecked {\n            return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;\n        }\n    }\n\n    /**\n     * @dev Reverts if `account` is not whitelisted by earner manager.\n     */\n    function _revertIfNotWhitelisted(MEarnerManagerStorageStruct storage $, address account) internal view {\n        if (!$.accounts[account].isWhitelisted) revert NotWhitelisted(account);\n    }\n}\n"
    }
}