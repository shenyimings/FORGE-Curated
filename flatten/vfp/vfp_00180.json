{
    "vfp_id": "vfp_00180",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of approval reset on buffer allows anyone to drain the Vault",
            "description": "The lack of approval reset after the call to deposit allows a malicious wrapper contract to steal the Vault’s funds. When wrapping tokens, the _wrapWithBuffer function allows the wrapped token contract to transfer the underlying tokens via ERC20 approval. However, since the approval is not reset to zero after the deposit call, a malicious wrapper contract can retain the approval and later withdraw the Vault's funds after it has been locked. This vulnerability arises from improper handling of ERC20 approvals and trust in external contracts without proper safeguards. An attacker can exploit this by creating a malicious wrapper that does nothing during deposit, thereby preserving the approval, and later directly transferring the tokens out. The impact is critical as it allows an attacker to drain all of the Vault’s tokens for any underlying asset.\n",
            "severity": "High",
            "location": [
                "Vault.sol::deposit#1169-1172",
                "Vault.sol::erc4626BufferWrapOrUnwrap",
                "https://github.com/balancer/balancer-v3-monorepo/pull/855"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Lack of reserve updates when collecting fees allows anyone to drain the Vault",
            "description": "The Vault fails to update its internal reserves after collecting fees, leading to a discrepancy between the recorded reserves and actual token balance. When fees are collected via collectAggregateFees, the tokens are transferred out but the Vault's reserve accounting remains unchanged. This causes the Vault to believe it holds more tokens than it actually does. The root cause is the omission of a reserve update step after fee collection. An attacker can exploit this by using the erc4626BufferWrapOrUnwrap function, which relies on reserve accounting to determine how many tokens to credit. By manipulating this discrepancy with a malicious wrapper contract, the attacker can withdraw tokens corresponding to the difference. The impact is high, as this can be repeated to drain the entire Vault of all its assets.\n",
            "severity": "High",
            "location": [
                "VaultAdmin.sol::collectAggregateFees#273-295",
                "Vault.sol::_updateReservesAfterWrapping#1367-1390",
                "https://github.com/balancer/balancer-v3-monorepo/pull/857"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Quote functions should not be payable",
            "description": "The VaultExtension.quote and VaultExtension.quoteAndRevert functions are marked as payable, but they cannot receive Ether due to the Vault's fallback function reverting on non-zero msg.value. This creates a contradiction in the contract design. The cause is an unnecessary payable modifier on functions that do not and cannot handle Ether. While these functions use msg.value in their logic, the proxy architecture ensures msg.value is always zero when they are called. This issue does not lead to direct exploitation but indicates poor code hygiene and potential confusion for integrators. An attacker cannot exploit this to cause harm, as the system rejects Ether at the entry point. The impact is purely informational, affecting code clarity and maintainability rather than security.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::fallback#1436-1442",
                "VaultExtension.sol::quote#843-851",
                "VaultExtension.sol::quoteAndRevert",
                "https://github.com/balancer/balancer-v3-monorepo/pull/863"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultExtension.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Pool registration and initialization can be front-run",
            "description": "The registration and initialization of pools can be front-run by malicious actors, potentially causing denial of service or enabling malicious parameter setup. Since anyone can call registerPool and initialize on VaultExtension, an attacker can observe a legitimate pool deployment and register it first with harmful parameters. The root cause is the lack of access control or commitment mechanisms during pool registration. An attacker can exploit this by monitoring the mempool and submitting a higher gas transaction to register a legitimate pool address before the original creator. This leads to the legitimate transaction reverting, forcing the creator to deploy a new pool. The impact is low, as it does not result in fund loss but can disrupt legitimate operations and increase deployment costs.\n",
            "severity": "Low",
            "location": [
                "Vault.sol::registerPool",
                "Vault.sol::initialize",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1164"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Buffer total supply can be reset",
            "description": "The addLiquidityToBuffer function can be called multiple times to reset the buffer's total supply if the wrapped token's asset function returns address(0). This occurs because the function checks if _bufferAssets[wrappedToken] is zero to determine initialization, but does not validate that the underlying token is non-zero. The cause is missing input validation for the wrapped token's asset. An attacker can exploit this by deploying a malicious token that returns address(0) as its asset, allowing repeated initialization and incorrect accounting of _bufferTotalShares. This leads to inconsistent state and potential manipulation of share calculations. The impact is informational, as it affects internal accounting but does not directly enable fund theft.\n",
            "severity": "Informational",
            "location": [
                "VaultAdmin.sol::addLiquidityToBuffer#415-443",
                "https://github.com/balancer/balancer-v3-monorepo/pull/865"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-454"
                ]
            },
            "title": "Vault can be drained by updating the buffer underlying token",
            "description": "A malicious user can drain the Vault by manipulating the underlying token of a buffer. The erc4626BufferWrapOrUnwrap function allows wrapping via uninitialized buffers, and the addLiquidityToBuffer function does not prevent changes to the underlying token. An attacker can first wrap a worthless token into a buffer, then change the underlying token to a valuable one (e.g., DAI), and withdraw the full balance of that token. The root cause is the lack of a check ensuring that a buffer must be explicitly initialized before interaction and that the underlying token cannot be changed after initialization. Exploitation involves creating a malicious wrapper token, inflating buffer balances with a worthless token, switching the underlying token, and withdrawing the real assets. The impact is high, as it allows complete draining of any token in the Vault.\n",
            "severity": "High",
            "location": [
                "Vault.sol::erc4626BufferWrapOrUnwrap#1054-1108",
                "Vault.sol::_wrapWithBuffer#1117-1238",
                "VaultAdmin.sol::addLiquidityToBuffer#415-465",
                "https://github.com/balancer/balancer-v3-monorepo/pull/881"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Yield fees collected when exiting recovery mode will be lost",
            "description": "When a pool exits recovery mode, yield fees that are accrued during the disableRecoveryMode call are removed from the pool balance but not credited to the aggregate fee balance, resulting in permanent loss. The issue arises because _setPoolRecoveryMode sets the recovery mode flag to false before updating balances, causing _loadPoolData to accrue yield fees. However, there is no mechanism to transfer these fees to the ProtocolFeeController. The root cause is incorrect ordering of state updates. An attacker cannot directly exploit this for profit, but can trigger the condition by forcing a pool into recovery mode and waiting for yield accumulation. The impact is medium, as it leads to loss of fees that should have been distributed to stakeholders, affecting economic fairness.\n",
            "severity": "Medium",
            "location": [
                "VaultAdmin.sol::disableRecoveryMode#352-355",
                "VaultAdmin.sol::_setPoolRecoveryMode#374-383",
                "PoolDataLib.sol::load#31-64",
                "PoolDataLib.sol::load#49-91",
                "https://github.com/balancer/balancer-v3-monorepo/pull/880"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/lib/PoolDataLib.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Risks with non-standard token implementations",
            "description": "The system is exposed to risks when interacting with non-standard ERC20 tokens, such as rebasing tokens (e.g., stETH), multi-address tokens (e.g., Celo), tokens with fees on transfer (e.g., PAXG), or tokens with more than 18 decimals. These tokens can break internal accounting assumptions. For example, rebasing tokens can cause balance discrepancies, double-entry tokens can be drained via settle, and fee-on-transfer tokens can lead to incorrect balance tracking. The root cause is the lack of explicit validation and handling for non-standard behaviors. While no direct exploit is described, an attacker could use such tokens to manipulate balances or drain funds. The impact is informational, but the risk is significant if unsupported tokens are registered, potentially leading to fund loss.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::settle",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1057"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Buffer can consider it has liquidity when it has none",
            "description": "The erc4626BufferWrapOrUnwrap function does not validate that the calculated amountOutUnderlying or amountOutWrapped is non-zero before proceeding with balance updates. If these values are zero, the buffer may incorrectly believe it has liquidity and update balances accordingly, even if the buffer is uninitialized. The root cause is missing zero checks in the liquidity validation logic. An attacker can exploit this by providing zero amounts to trick the system into crediting shares or tokens without actual liquidity. This allows unauthorized minting or withdrawal of assets. The impact is informational in this context, but could lead to more serious issues if combined with other vulnerabilities.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::_wrapWithBuffer#1143-1156",
                "Vault.sol::_unwrapWithBuffer#1271-1283",
                "https://github.com/balancer/balancer-v3-monorepo/pull/881"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Dynamic swap fee is not limited to 100%",
            "description": "The dynamic swap fee, calculated via callComputeDynamicSwapFeeHook, is not explicitly capped at 100%, unlike other fees in the system. While arithmetic checks may implicitly prevent overflow, the absence of an explicit limit introduces risk of unexpected behavior if a hook returns a value greater than 100%. The root cause is incomplete validation of dynamic fee inputs. An attacker controlling a pool's hook could set an excessive fee, potentially causing incorrect fee calculations or reverts during swaps. The impact is informational, as it does not currently lead to fund loss, but represents a design inconsistency that could become critical if assumptions change.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::swap#228-239",
                "https://github.com/balancer/balancer-v3-monorepo/pull/915"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Lack of slippage protection on liquidity buffer increase",
            "description": "The addLiquidityToBuffer function lacks slippage protection, exposing users to front-running and price manipulation during liquidity provision. Since the function does not include minimum amount expectations or price checks, an attacker can manipulate the price between the time of transaction submission and execution, causing the user to receive fewer shares than expected. The root cause is the absence of slippage controls in the buffer liquidity functions. An attacker can exploit this by sandwiching the transaction with large trades to alter the price. The impact is low, as it affects economic fairness rather than leading to direct fund loss, but can erode user trust. The addLiquidityToBuffer function does not allow users to specify a minimum amount of shares they expect to receive, making them vulnerable to unfavorable changes in the asset-to-share ratio between transaction submission and inclusion. This occurs because the number of shares issued is calculated dynamically via a call to the wrapped token’s convertToAssets function without any slippage guardrails. If the ratio changes due to prior transactions (e.g., front-running), the user may receive fewer shares than anticipated. An attacker can exploit this by manipulating the underlying token state before the victim’s transaction is processed, leading to economic loss for the liquidity provider.\n",
            "severity": "Low",
            "location": [
                "VaultAdmin.sol::addLiquidityToBuffer",
                "VaultAdmin.sol::addLiquidityToBuffer#430-432",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1108"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Reentrancy on pool initialization allows users to re-initialize pools",
            "description": "The initialize function in VaultExtension.sol follows an incorrect check-effect-interaction pattern, where it checks if a pool is already initialized at the beginning but only marks it as initialized after an external call via the BeforeInitialize hook. This creates a window for reentrancy: a malicious contract can re-enter the initialize function during the hook call and re-initialize the pool multiple times. Since state changes occur after external calls, the attacker can manipulate pool behavior, potentially leading to unexpected state transitions or economic impacts. The severity is undetermined due to time constraints in fully assessing the impact, but the flaw enables repeated initialization which could be abused in combination with other actions like swapping or liquidity manipulation.\n",
            "severity": "Informational",
            "location": [
                "VaultExtension.sol::initialize#364-379",
                "VaultExtension.sol::initialize#391-392",
                "VaultExtension.sol::initialize#443-446",
                "https://github.com/balancer/balancer-v3-monorepo/pull/899"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultExtension.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Insufficient event generation",
            "description": "Several critical functions in VaultAdmin.sol and ProtocolFeeController.sol do not emit events upon state changes, hindering off-chain monitoring and auditing. Operations such as withdrawing protocol fees, disabling queries, pausing buffers, and collecting aggregate fees lack corresponding events, making it difficult for users and monitoring systems to detect abnormal or malicious behavior. Events are essential for transparency, debugging, and security tooling; their absence increases the risk of undetected exploits or malfunctions. This reduces the system's observability and violates best practices for smart contract design.\n",
            "severity": "Informational",
            "location": [
                "ProtocolFeeController.sol::withdrawProtocolFees#449-461",
                "ProtocolFeeController.sol::_withdrawPoolCreatorFees#473-485",
                "VaultAdmin.sol::disableQuery#390-394",
                "VaultAdmin.sol::pauseVaultBuffers#401-405",
                "VaultAdmin.sol::unpauseVaultBuffers#408-412",
                "VaultAdmin.sol::collectAggregateFees#273-295",
                "https://github.com/balancer/balancer-v3-monorepo/pull/916"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/ProtocolFeeController.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Buffer _CONVERT_FACTOR can be avoided by providing unbalanced liquidity",
            "description": "Users can bypass the _CONVERT_FACTOR safety mechanism—intended to protect the buffer from rounding-related drain—by adding unbalanced liquidity (only underlying or only wrapped tokens) and immediately removing it. The _CONVERT_FACTOR is applied during wrap/unwrap operations to reduce output tokens slightly, but addLiquidityToBuffer allows unbalanced deposits that effectively mimic wrapping without applying the factor. This arbitrage opportunity allows users to obtain more tokens than permitted under normal wrap operations, undermining the buffer’s economic safeguards and potentially leading to gradual depletion over time.\n",
            "severity": "Low",
            "location": [
                "Vault.sol::_wrapWithBuffer#1148-1171",
                "VaultAdmin.sol::addLiquidityToBuffer",
                "https://github.com/balancer/balancer-v3-monorepo/pull/967"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Buffer wrap and unwrap queries return incorrect results",
            "description": "The erc4626BufferWrapOrUnwrap function returns inaccurate values during query mode because it uses preview* functions that do not account for the _CONVERT_FACTOR, while actual on-chain operations do. This discrepancy means users may base their transactions on incorrect expected outputs, leading to failed transactions or suboptimal trades. Since queries are often used by frontends to estimate outcomes, this inconsistency introduces user experience and reliability issues, potentially causing financial loss due to miscalculated inputs.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::_wrapWithBuffer#1158-1170",
                "Vault.sol::_unwrapWithBuffer",
                "https://github.com/balancer/balancer-v3-monorepo/pull/967"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Providing unbalanced liquidity to a buffer can mint more shares due to rounding",
            "description": "When users provide only the underlying token to addLiquidityToBuffer, the invariant calculation uses convertToAssets, which rounds down. This results in a lower currentInvariant value, increasing the number of shares issued due to division by a smaller denominator. Consequently, depositing only underlying tokens yields more shares than depositing a balanced mix of underlying and wrapped tokens of equal value. This rounding advantage creates an arbitrage opportunity and unfair distribution of shares, favoring users who exploit the rounding behavior, which could erode trust in fair issuance mechanics.\n",
            "severity": "Informational",
            "location": [
                "VaultAdmin.sol::addLiquidityToBuffer#512-520",
                "https://github.com/balancer/balancer-v3-monorepo/pull/982"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "The swap functions allows zero amountIn to be provided",
            "description": "The swap function checks for zero raw input amount but does not prevent scaled amounts from becoming zero due to rounding during conversion. The _ensureValidTradeAmount function only reverts if the scaled amount is non-zero and below the minimum threshold, allowing exactly zero to pass. If a calculation error existed that allowed a zero input to yield a non-zero output, this could be exploited to drain pools. While no such flaw was found, the lack of a zero-check on scaled amounts creates a potential attack vector under edge cases involving low-rate tokens and minimal inputs.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::swap#195-197",
                "Vault.sol::swap#231",
                "Vault.sol::_ensureValidTradeAmount#1545-1549",
                "https://github.com/balancer/balancer-v3-monorepo/pull/991"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Vault.sol"
            ]
        }
    ],
    "affected_files": {
        "ProtocolFeeController.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { IVaultErrors } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultErrors.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { FEE_SCALING_FACTOR } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport {\n    SingletonAuthentication\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/SingletonAuthentication.sol\";\nimport {\n    ReentrancyGuardTransient\n} from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/ReentrancyGuardTransient.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\n\nimport { VaultGuard } from \"./VaultGuard.sol\";\n\n/**\n * @notice Helper contract to manage protocol and creator fees outside the Vault.\n * @dev This contract stores global default protocol swap and yield fees, and also tracks the values of those fees\n * for each pool (the `PoolFeeConfig` described below). Protocol fees can always be overwritten by governance, but\n * pool creator fees are controlled by the registered poolCreator (see `PoolRoleAccounts`).\n *\n * The Vault stores a single aggregate percentage for swap and yield fees; only this `ProtocolFeeController` knows\n * the component fee percentages, and how to compute the aggregate from the components. This is done for performance\n * reasons, to minimize gas on the critical path, as this way the Vault simply applies a single \"cut\", and stores the\n * fee amounts separately from the pool balances.\n *\n * The pool creator fees are \"net\" protocol fees, meaning the protocol fee is taken first, and the pool creator fee\n * percentage is applied to the remainder. Essentially, the protocol is paid first, then the remainder is divided\n * between the pool creator and the LPs.\n *\n * There is a permissionless function (`collectAggregateFees`) that transfers these tokens from the Vault to this\n * contract, and distributes them between the protocol and pool creator, after which they can be withdrawn at any\n * time by governance and the pool creator, respectively.\n *\n * Protocol fees can be zero in some cases (e.g., the token is registered as exempt), and pool creator fees are zero\n * if there is no creator role address defined. Protocol fees are capped at a maximum percentage (50%); pool creator\n * fees are computed \"net\" protocol fees, so they can be any value from 0 to 100%. Any combination is possible.\n * A protocol-fee-exempt pool with a 100% pool creator fee would send all fees to the creator. If there is no pool\n * creator, a pool with a 50% protocol fee would divide the fees evenly between the protocol and LPs.\n *\n * This contract is deployed with the Vault, but can be changed by governance.\n */\ncontract ProtocolFeeController is\n    IProtocolFeeController,\n    SingletonAuthentication,\n    ReentrancyGuardTransient,\n    VaultGuard\n{\n    using FixedPoint for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Fee configuration stored in the swap and yield fee mappings.\n     * @dev Instead of storing only the fee in the mapping, also store a flag to indicate whether the fee has been\n     * set by governance through a permissioned call. (The fee is stored in 64-bits, so that the struct fits\n     * within a single slot.)\n     *\n     * We know the percentage is an 18-decimal FP value, which only takes 60 bits, so it's guaranteed to fit,\n     * and we can do simple casts to truncate the high bits without needed SafeCast.\n     *\n     * We want to enable permissionless updates for pools, so that it is less onerous to update potentially\n     * hundreds of pools if the global protocol fees change. However, we don't want to overwrite pools that\n     * have had their fee percentages manually set by the DAO (i.e., after off-chain negotiation and agreement).\n     *\n     * @param feePercentage The raw swap or yield fee percentage\n     * @param isOverride When set, this fee is controlled by governance, and cannot be changed permissionlessly\n     */\n    struct PoolFeeConfig {\n        uint64 feePercentage;\n        bool isOverride;\n    }\n\n    // Maximum protocol swap fee percentage. FixedPoint.ONE corresponds to a 100% fee.\n    uint256 internal constant _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE = 50e16; // 50%\n\n    // Maximum protocol yield fee percentage.\n    uint256 internal constant _MAX_PROTOCOL_YIELD_FEE_PERCENTAGE = 50e16; // 50%\n\n    // Global protocol swap fee.\n    uint256 private _globalProtocolSwapFeePercentage;\n\n    // Global protocol yield fee.\n    uint256 private _globalProtocolYieldFeePercentage;\n\n    // Store the pool-specific swap fee percentages (the Vault's poolConfigBits stores the aggregate percentage).\n    mapping(address => PoolFeeConfig) internal _poolProtocolSwapFeePercentages;\n\n    // Store the pool-specific yield fee percentages (the Vault's poolConfigBits stores the aggregate percentage).\n    mapping(address => PoolFeeConfig) internal _poolProtocolYieldFeePercentages;\n\n    // Pool -> address of pool creator (empowered to set pool creator fee percentages, and withdraw creator fees).\n    mapping(address => address) internal _poolCreators;\n\n    // Pool -> creator swap fee percentage.\n    mapping(address => uint256) internal _poolCreatorSwapFeePercentages;\n\n    // Pool -> creator yield fee percentage.\n    mapping(address => uint256) internal _poolCreatorYieldFeePercentages;\n\n    // Pool -> (Token -> fee): Disaggregated protocol fees (from swap and yield), available for withdrawal\n    // by governance.\n    mapping(address => mapping(IERC20 => uint256)) internal _protocolFeeAmounts;\n\n    // Pool -> (Token -> fee): Disaggregated pool creator fees (from swap and yield), available for withdrawal by\n    // the pool creator.\n    mapping(address => mapping(IERC20 => uint256)) internal _poolCreatorFeeAmounts;\n\n    // Ensure that the caller is the pool creator.\n    modifier onlyPoolCreator(address pool) {\n        _ensureCallerIsPoolCreator(pool);\n        _;\n    }\n\n    // Validate the swap fee percentage against the maximum.\n    modifier withValidSwapFee(uint256 newSwapFeePercentage) {\n        if (newSwapFeePercentage > _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE) {\n            revert ProtocolSwapFeePercentageTooHigh();\n        }\n        _;\n    }\n\n    // Validate the yield fee percentage against the maximum.\n    modifier withValidYieldFee(uint256 newYieldFeePercentage) {\n        if (newYieldFeePercentage > _MAX_PROTOCOL_YIELD_FEE_PERCENTAGE) {\n            revert ProtocolYieldFeePercentageTooHigh();\n        }\n        _;\n    }\n\n    // Force collection and disaggregation (e.g., before changing protocol fee percentages).\n    modifier withLatestFees(address pool) {\n        getVault().collectAggregateFees(pool);\n        _;\n    }\n\n    constructor(IVault vault_) SingletonAuthentication(vault_) VaultGuard(vault_) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function vault() external view returns (IVault) {\n        return getVault();\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getGlobalProtocolSwapFeePercentage() external view returns (uint256) {\n        return _globalProtocolSwapFeePercentage;\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getGlobalProtocolYieldFeePercentage() external view returns (uint256) {\n        return _globalProtocolYieldFeePercentage;\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getPoolProtocolSwapFeeInfo(address pool) external view returns (uint256, bool) {\n        PoolFeeConfig memory config = _poolProtocolSwapFeePercentages[pool];\n\n        return (config.feePercentage, config.isOverride);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getPoolProtocolYieldFeeInfo(address pool) external view returns (uint256, bool) {\n        PoolFeeConfig memory config = _poolProtocolYieldFeePercentages[pool];\n\n        return (config.feePercentage, config.isOverride);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getProtocolFeeAmounts(address pool) public view returns (uint256[] memory feeAmounts) {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        feeAmounts = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            feeAmounts[i] = _protocolFeeAmounts[pool][poolTokens[i]];\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getPoolCreatorFeeAmounts(address pool) public view returns (uint256[] memory feeAmounts) {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        feeAmounts = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            feeAmounts[i] = _poolCreatorFeeAmounts[pool][poolTokens[i]];\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function computeAggregateFeePercentage(\n        uint256 protocolFeePercentage,\n        uint256 poolCreatorFeePercentage\n    ) external pure returns (uint256) {\n        return _computeAggregateFeePercentage(protocolFeePercentage, poolCreatorFeePercentage);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function updateProtocolSwapFeePercentage(address pool) external withLatestFees(pool) {\n        PoolFeeConfig memory feeConfig = _poolProtocolSwapFeePercentages[pool];\n        uint256 globalProtocolSwapFee = _globalProtocolSwapFeePercentage;\n\n        if (feeConfig.isOverride == false && globalProtocolSwapFee != feeConfig.feePercentage) {\n            _updatePoolSwapFeePercentage(pool, globalProtocolSwapFee, false);\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function updateProtocolYieldFeePercentage(address pool) external withLatestFees(pool) {\n        PoolFeeConfig memory feeConfig = _poolProtocolYieldFeePercentages[pool];\n        uint256 globalProtocolYieldFee = _globalProtocolYieldFeePercentage;\n\n        if (feeConfig.isOverride == false && globalProtocolYieldFee != feeConfig.feePercentage) {\n            _updatePoolYieldFeePercentage(pool, globalProtocolYieldFee, false);\n        }\n    }\n\n    function _getAggregateFeePercentage(address pool, ProtocolFeeType feeType) internal view returns (uint256) {\n        uint256 protocolFeePercentage;\n        uint256 poolCreatorFeePercentage;\n\n        if (feeType == ProtocolFeeType.SWAP) {\n            protocolFeePercentage = _poolProtocolSwapFeePercentages[pool].feePercentage;\n            poolCreatorFeePercentage = _poolCreatorSwapFeePercentages[pool];\n        } else {\n            protocolFeePercentage = _poolProtocolYieldFeePercentages[pool].feePercentage;\n            poolCreatorFeePercentage = _poolCreatorYieldFeePercentages[pool];\n        }\n\n        return _computeAggregateFeePercentage(protocolFeePercentage, poolCreatorFeePercentage);\n    }\n\n    function _computeAggregateFeePercentage(\n        uint256 protocolFeePercentage,\n        uint256 poolCreatorFeePercentage\n    ) internal pure returns (uint256 aggregateFeePercentage) {\n        aggregateFeePercentage =\n            protocolFeePercentage +\n            protocolFeePercentage.complement().mulDown(poolCreatorFeePercentage);\n\n        // Primary fee percentages are 18-decimal values, stored here in 64 bits, and calculated with full 256-bit\n        // precision. However, the resulting aggregate fees are stored in the Vault with 24-bit precision, which\n        // corresponds to 0.00001% resolution (i.e., a fee can be 1%, 1.00001%, 1.00002%, but not 1.000005%).\n        // Ensure there will be no precision loss in the Vault - which would lead to a discrepancy between the\n        // aggregate fee calculated here and that stored in the Vault.\n        if ((aggregateFeePercentage / FEE_SCALING_FACTOR) * FEE_SCALING_FACTOR != aggregateFeePercentage) {\n            revert IVaultErrors.FeePrecisionTooHigh();\n        }\n    }\n\n    function _ensureCallerIsPoolCreator(address pool) internal view {\n        address poolCreator = _poolCreators[pool];\n\n        if (poolCreator == address(0)) {\n            revert PoolCreatorNotRegistered(pool);\n        }\n\n        if (poolCreator != msg.sender) {\n            revert CallerIsNotPoolCreator(msg.sender);\n        }\n    }\n\n    function _getPoolTokensAndCount(address pool) internal view returns (IERC20[] memory tokens, uint256 numTokens) {\n        tokens = getVault().getPoolTokens(pool);\n        numTokens = tokens.length;\n    }\n\n    /***************************************************************************\n                                Permissioned Functions\n    ***************************************************************************/\n\n    /// @inheritdoc IProtocolFeeController\n    function registerPool(\n        address pool,\n        address poolCreator,\n        bool protocolFeeExempt\n    ) external onlyVault returns (uint256 aggregateSwapFeePercentage, uint256 aggregateYieldFeePercentage) {\n        _poolCreators[pool] = poolCreator;\n\n        // Set local storage of the actual percentages for the pool (default to global).\n        aggregateSwapFeePercentage = protocolFeeExempt ? 0 : _globalProtocolSwapFeePercentage;\n        aggregateYieldFeePercentage = protocolFeeExempt ? 0 : _globalProtocolYieldFeePercentage;\n\n        // `isOverride` is true if the pool is protocol fee exempt; otherwise, default to false.\n        // If exempt, this pool cannot be updated to the current global percentage permissionlessly.\n        _poolProtocolSwapFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(aggregateSwapFeePercentage),\n            isOverride: protocolFeeExempt\n        });\n        _poolProtocolYieldFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(aggregateYieldFeePercentage),\n            isOverride: protocolFeeExempt\n        });\n    }\n\n    enum ProtocolFeeType {\n        SWAP,\n        YIELD\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function receiveAggregateFees(\n        address pool,\n        uint256[] memory swapFeeAmounts,\n        uint256[] memory yieldFeeAmounts\n    ) external onlyVault {\n        _receiveAggregateFees(pool, ProtocolFeeType.SWAP, swapFeeAmounts);\n        _receiveAggregateFees(pool, ProtocolFeeType.YIELD, yieldFeeAmounts);\n    }\n\n    function _receiveAggregateFees(address pool, ProtocolFeeType feeType, uint256[] memory feeAmounts) private {\n        // There are two cases when we don't need to split fees (in which case we can save gas and avoid rounding\n        // errors by skipping calculations) if either the protocol or pool creator fee percentage is zero.\n\n        uint256 protocolFeePercentage = feeType == ProtocolFeeType.SWAP\n            ? _poolProtocolSwapFeePercentages[pool].feePercentage\n            : _poolProtocolYieldFeePercentages[pool].feePercentage;\n\n        uint256 poolCreatorFeePercentage = feeType == ProtocolFeeType.SWAP\n            ? _poolCreatorSwapFeePercentages[pool]\n            : _poolCreatorYieldFeePercentages[pool];\n\n        uint256 aggregateFeePercentage;\n\n        bool needToSplitFees = poolCreatorFeePercentage > 0 && protocolFeePercentage > 0;\n        if (needToSplitFees) {\n            // Calculate once, outside the loop.\n            aggregateFeePercentage = _computeAggregateFeePercentage(protocolFeePercentage, poolCreatorFeePercentage);\n        }\n\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            if (feeAmounts[i] > 0) {\n                IERC20 token = poolTokens[i];\n\n                token.safeTransferFrom(address(getVault()), address(this), feeAmounts[i]);\n\n                // It should be easier for off-chain processes to handle two events, rather than parsing the type\n                // out of a single event.\n                if (feeType == ProtocolFeeType.SWAP) {\n                    emit ProtocolSwapFeeCollected(pool, token, feeAmounts[i]);\n                } else {\n                    emit ProtocolYieldFeeCollected(pool, token, feeAmounts[i]);\n                }\n\n                if (needToSplitFees) {\n                    uint256 totalVolume = feeAmounts[i].divUp(aggregateFeePercentage);\n                    uint256 protocolPortion = totalVolume.mulUp(protocolFeePercentage);\n\n                    _protocolFeeAmounts[pool][token] += protocolPortion;\n                    _poolCreatorFeeAmounts[pool][token] += feeAmounts[i] - protocolPortion;\n                } else {\n                    // If we don't need to split, one of them must be zero.\n                    if (poolCreatorFeePercentage == 0) {\n                        _protocolFeeAmounts[pool][token] += feeAmounts[i];\n                    } else {\n                        _poolCreatorFeeAmounts[pool][token] += feeAmounts[i];\n                    }\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setGlobalProtocolSwapFeePercentage(\n        uint256 newProtocolSwapFeePercentage\n    ) external withValidSwapFee(newProtocolSwapFeePercentage) authenticate {\n        _globalProtocolSwapFeePercentage = newProtocolSwapFeePercentage;\n\n        emit GlobalProtocolSwapFeePercentageChanged(newProtocolSwapFeePercentage);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setGlobalProtocolYieldFeePercentage(\n        uint256 newProtocolYieldFeePercentage\n    ) external withValidYieldFee(newProtocolYieldFeePercentage) authenticate {\n        _globalProtocolYieldFeePercentage = newProtocolYieldFeePercentage;\n\n        emit GlobalProtocolYieldFeePercentageChanged(newProtocolYieldFeePercentage);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setProtocolSwapFeePercentage(\n        address pool,\n        uint256 newProtocolSwapFeePercentage\n    ) external withValidSwapFee(newProtocolSwapFeePercentage) withLatestFees(pool) authenticate {\n        _updatePoolSwapFeePercentage(pool, newProtocolSwapFeePercentage, true);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setProtocolYieldFeePercentage(\n        address pool,\n        uint256 newProtocolYieldFeePercentage\n    ) external withValidYieldFee(newProtocolYieldFeePercentage) withLatestFees(pool) authenticate {\n        _updatePoolYieldFeePercentage(pool, newProtocolYieldFeePercentage, true);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setPoolCreatorSwapFeePercentage(\n        address pool,\n        uint256 poolCreatorSwapFeePercentage\n    ) external onlyPoolCreator(pool) {\n        _setPoolCreatorFeePercentage(pool, poolCreatorSwapFeePercentage, ProtocolFeeType.SWAP);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setPoolCreatorYieldFeePercentage(\n        address pool,\n        uint256 poolCreatorYieldFeePercentage\n    ) external onlyPoolCreator(pool) {\n        _setPoolCreatorFeePercentage(pool, poolCreatorYieldFeePercentage, ProtocolFeeType.YIELD);\n    }\n\n    function _setPoolCreatorFeePercentage(\n        address pool,\n        uint256 poolCreatorFeePercentage,\n        ProtocolFeeType feeType\n    ) private {\n        if (poolCreatorFeePercentage > FixedPoint.ONE) {\n            revert PoolCreatorFeePercentageTooHigh();\n        }\n\n        // Force collection of fees at the existing rate.\n        getVault().collectAggregateFees(pool);\n\n        // Need to set locally, and update the aggregate percentage in the vault.\n        if (feeType == ProtocolFeeType.SWAP) {\n            _poolCreatorSwapFeePercentages[pool] = poolCreatorFeePercentage;\n\n            getVault().updateAggregateSwapFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.SWAP));\n\n            emit PoolCreatorSwapFeePercentageChanged(pool, poolCreatorFeePercentage);\n        } else {\n            _poolCreatorYieldFeePercentages[pool] = poolCreatorFeePercentage;\n\n            getVault().updateAggregateYieldFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.YIELD));\n\n            emit PoolCreatorYieldFeePercentageChanged(pool, poolCreatorFeePercentage);\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function withdrawProtocolFees(address pool, address recipient) external authenticate {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            IERC20 token = poolTokens[i];\n\n            uint256 amountToWithdraw = _protocolFeeAmounts[pool][token];\n            if (amountToWithdraw > 0) {\n                _protocolFeeAmounts[pool][token] = 0;\n                token.safeTransfer(recipient, amountToWithdraw);\n            }\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function withdrawPoolCreatorFees(address pool, address recipient) external onlyPoolCreator(pool) {\n        _withdrawPoolCreatorFees(pool, recipient);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function withdrawPoolCreatorFees(address pool) external {\n        _withdrawPoolCreatorFees(pool, _poolCreators[pool]);\n    }\n\n    function _withdrawPoolCreatorFees(address pool, address recipient) private {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            IERC20 token = poolTokens[i];\n\n            uint256 amountToWithdraw = _poolCreatorFeeAmounts[pool][token];\n            if (amountToWithdraw > 0) {\n                _poolCreatorFeeAmounts[pool][token] = 0;\n                token.safeTransfer(recipient, amountToWithdraw);\n            }\n        }\n    }\n\n    /// @dev Common code shared between set/update. `isOverride` will be true if governance is setting the percentage.\n    function _updatePoolSwapFeePercentage(address pool, uint256 newProtocolSwapFeePercentage, bool isOverride) private {\n        // Update local storage of the raw percentage\n        _poolProtocolSwapFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(newProtocolSwapFeePercentage),\n            isOverride: isOverride\n        });\n\n        // Update the resulting aggregate swap fee value in the Vault (PoolConfig).\n        getVault().updateAggregateSwapFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.SWAP));\n\n        emit ProtocolSwapFeePercentageChanged(pool, newProtocolSwapFeePercentage);\n    }\n\n    /// @dev Common code shared between set/update. `isOverride` will be true if governance is setting the percentage.\n    function _updatePoolYieldFeePercentage(\n        address pool,\n        uint256 newProtocolYieldFeePercentage,\n        bool isOverride\n    ) private {\n        // Update local storage of the raw percentage.\n        _poolProtocolYieldFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(newProtocolYieldFeePercentage),\n            isOverride: isOverride\n        });\n\n        // Update the resulting aggregate yield fee value in the Vault (PoolConfig).\n        getVault().updateAggregateYieldFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.YIELD));\n\n        emit ProtocolYieldFeePercentageChanged(pool, newProtocolYieldFeePercentage);\n    }\n}\n",
        "PoolDataLib.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { PoolData, TokenInfo, TokenType, Rounding } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\nimport { IVaultErrors } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultErrors.sol\";\n\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { PoolConfigBits, PoolConfigLib } from \"./PoolConfigLib.sol\";\n\n/**\n * @notice Helper functions to read/write a `PoolData` struct.\n * @dev Note that the entire configuration of each pool is stored in the `_poolConfigBits` mapping (one slot per pool).\n * This includes the data in the `PoolConfig` struct, plus the data in the `HookFlags` struct. The layout (i.e.,\n * offsets for each data field) is specified in `PoolConfigConst`.\n *\n * The `PoolData` struct contains the raw bitmap with the entire pool state (`PoolConfigBits`), plus the token\n * configuration, scaling factors, and dynamic information such as current balances and rates.\n */\nlibrary PoolDataLib {\n    using PackedTokenBalance for bytes32;\n    using FixedPoint for *;\n    using ScalingHelpers for *;\n    using PoolConfigLib for PoolConfigBits;\n\n    function load(\n        PoolData memory poolData,\n        mapping(uint => bytes32) storage poolTokenBalances,\n        PoolConfigBits poolConfigBits,\n        mapping(IERC20 => TokenInfo) storage poolTokenInfo,\n        IERC20[] storage tokens,\n        Rounding roundingDirection\n    ) internal view {\n        uint256 numTokens = tokens.length;\n\n        poolData.poolConfigBits = poolConfigBits;\n        poolData.tokens = tokens;\n        poolData.tokenInfo = new TokenInfo[](numTokens);\n        poolData.balancesRaw = new uint256[](numTokens);\n        poolData.balancesLiveScaled18 = new uint256[](numTokens);\n        poolData.decimalScalingFactors = PoolConfigLib.getDecimalScalingFactors(poolData.poolConfigBits, numTokens);\n        poolData.tokenRates = new uint256[](numTokens);\n\n        bool poolSubjectToYieldFees = poolData.poolConfigBits.isPoolInitialized() &&\n            poolData.poolConfigBits.getAggregateYieldFeePercentage() > 0 &&\n            poolData.poolConfigBits.isPoolInRecoveryMode() == false;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            TokenInfo memory tokenInfo = poolTokenInfo[poolData.tokens[i]];\n            bytes32 packedBalance = poolTokenBalances[i];\n\n            poolData.tokenInfo[i] = tokenInfo;\n            poolData.tokenRates[i] = getTokenRate(tokenInfo);\n            updateRawAndLiveBalance(poolData, i, packedBalance.getBalanceRaw(), roundingDirection);\n\n            // If there are no yield fees, we can save gas by skipping to the next token now.\n            if (poolSubjectToYieldFees == false) {\n                continue;\n            }\n\n            // `poolData` already has live balances computed from raw balances according to the token rates and the\n            // given rounding direction. Charging a yield fee changes the raw balance, in which case the safest and\n            // most numerically precise way to adjust the live balance is to simply repeat the scaling (hence the\n            // second call below).\n\n            // The Vault actually guarantees that a token with paysYieldFees set is a WITH_RATE token, so technically\n            // we could just check the flag, but we don't want to introduce that dependency for a slight gas savings.\n            bool tokenSubjectToYieldFees = tokenInfo.paysYieldFees && tokenInfo.tokenType == TokenType.WITH_RATE;\n\n            // Do not charge yield fees before the pool is initialized, or in recovery mode.\n            if (tokenSubjectToYieldFees) {\n                uint256 aggregateYieldFeePercentage = poolData.poolConfigBits.getAggregateYieldFeePercentage();\n                uint256 balanceRaw = poolData.balancesRaw[i];\n\n                uint256 aggregateYieldFeeAmountRaw = _computeYieldFeesDue(\n                    poolData,\n                    packedBalance.getBalanceDerived(),\n                    i,\n                    aggregateYieldFeePercentage\n                );\n\n                if (aggregateYieldFeeAmountRaw > 0) {\n                    updateRawAndLiveBalance(poolData, i, balanceRaw - aggregateYieldFeeAmountRaw, roundingDirection);\n                }\n            }\n        }\n    }\n\n    function syncPoolBalancesAndFees(\n        PoolData memory poolData,\n        mapping(uint256 => bytes32) storage poolTokenBalances,\n        mapping(IERC20 => bytes32) storage poolAggregateProtocolFeeAmounts\n    ) internal {\n        uint256 numTokens = poolData.balancesRaw.length;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            IERC20 token = poolData.tokens[i];\n            bytes32 packedBalances = poolTokenBalances[i];\n            uint256 storedBalanceRaw = packedBalances.getBalanceRaw();\n\n            // `poolData` now has balances updated with yield fees.\n            // If yield fees are not 0, then the stored balance is greater than the one in memory.\n            if (storedBalanceRaw > poolData.balancesRaw[i]) {\n                // Both Swap and Yield fees are stored together in a `PackedTokenBalance`.\n                // We have designated \"Derived\" the derived half for Yield fee storage.\n                bytes32 packedProtocolFeeAmounts = poolAggregateProtocolFeeAmounts[token];\n                poolAggregateProtocolFeeAmounts[token] = packedProtocolFeeAmounts.setBalanceDerived(\n                    packedProtocolFeeAmounts.getBalanceDerived() + (storedBalanceRaw - poolData.balancesRaw[i])\n                );\n            }\n\n            poolTokenBalances[i] = PackedTokenBalance.toPackedBalance(\n                poolData.balancesRaw[i],\n                poolData.balancesLiveScaled18[i]\n            );\n        }\n    }\n\n    /**\n     * @dev This is typically called after a reentrant callback (e.g., a \"before\" liquidity operation callback),\n     * to refresh the poolData struct with any balances (or rates) that might have changed.\n     *\n     * Preconditions: tokenConfig, balancesRaw, and decimalScalingFactors must be current in `poolData`.\n     * Side effects: mutates tokenRates, balancesLiveScaled18 in `poolData`.\n     */\n    function reloadBalancesAndRates(\n        PoolData memory poolData,\n        mapping(uint256 => bytes32) storage poolTokenBalances,\n        Rounding roundingDirection\n    ) internal view {\n        uint256 numTokens = poolData.tokens.length;\n\n        // It's possible a reentrant hook changed the raw balances in Vault storage.\n        // Update them before computing the live balances.\n        bytes32 packedBalance;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            poolData.tokenRates[i] = getTokenRate(poolData.tokenInfo[i]);\n\n            packedBalance = poolTokenBalances[i];\n\n            // Note the order dependency. This requires up-to-date tokenRate for the token at index `i` in `poolData`\n            updateRawAndLiveBalance(poolData, i, packedBalance.getBalanceRaw(), roundingDirection);\n        }\n    }\n\n    function getTokenRate(TokenInfo memory tokenInfo) internal view returns (uint256 rate) {\n        TokenType tokenType = tokenInfo.tokenType;\n\n        if (tokenType == TokenType.STANDARD) {\n            rate = FixedPoint.ONE;\n        } else if (tokenType == TokenType.WITH_RATE) {\n            rate = tokenInfo.rateProvider.getRate();\n        } else {\n            revert IVaultErrors.InvalidTokenConfiguration();\n        }\n    }\n\n    function updateRawAndLiveBalance(\n        PoolData memory poolData,\n        uint256 tokenIndex,\n        uint256 newRawBalance,\n        Rounding roundingDirection\n    ) internal pure {\n        poolData.balancesRaw[tokenIndex] = newRawBalance;\n\n        function(uint256, uint256, uint256) internal pure returns (uint256) _upOrDown = roundingDirection ==\n            Rounding.ROUND_UP\n            ? ScalingHelpers.toScaled18ApplyRateRoundUp\n            : ScalingHelpers.toScaled18ApplyRateRoundDown;\n\n        poolData.balancesLiveScaled18[tokenIndex] = _upOrDown(\n            newRawBalance,\n            poolData.decimalScalingFactors[tokenIndex],\n            poolData.tokenRates[tokenIndex]\n        );\n    }\n\n    // solhint-disable-next-line private-vars-leading-underscore\n    function _computeYieldFeesDue(\n        PoolData memory poolData,\n        uint256 lastLiveBalance,\n        uint256 tokenIndex,\n        uint256 aggregateYieldFeePercentage\n    ) internal pure returns (uint256 aggregateYieldFeeAmountRaw) {\n        uint256 currentLiveBalance = poolData.balancesLiveScaled18[tokenIndex];\n\n        // Do not charge fees if rates go down. If the rate were to go up, down, and back up again, protocol fees\n        // would be charged multiple times on the \"same\" yield. For tokens subject to yield fees, this should not\n        // happen, or at least be very rare. It can be addressed for known volatile rates by setting the yield fee\n        // exempt flag on registration, or compensated off-chain if there is an incident with a normally\n        // well-behaved rate provider.\n        if (currentLiveBalance > lastLiveBalance) {\n            unchecked {\n                // Magnitudes are checked above, so it's safe to do unchecked math here.\n                uint256 aggregateYieldFeeAmountScaled18 = (currentLiveBalance - lastLiveBalance).mulUp(\n                    aggregateYieldFeePercentage\n                );\n\n                // A pool is subject to yield fees if poolSubjectToYieldFees is true, meaning that\n                // `protocolYieldFeePercentage > 0`. So, we don't need to check this again in here, saving some gas.\n                aggregateYieldFeeAmountRaw = aggregateYieldFeeAmountScaled18.toRawUndoRateRoundDown(\n                    poolData.decimalScalingFactors[tokenIndex],\n                    poolData.tokenRates[tokenIndex]\n                );\n            }\n        }\n    }\n}\n",
        "VaultExtension.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IBasePool } from \"@balancer-labs/v3-interfaces/contracts/vault/IBasePool.sol\";\nimport { IHooks } from \"@balancer-labs/v3-interfaces/contracts/vault/IHooks.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { IRateProvider } from \"@balancer-labs/v3-interfaces/contracts/vault/IRateProvider.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IVaultExtension } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultExtension.sol\";\nimport { IAuthentication } from \"@balancer-labs/v3-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol\";\nimport \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { CastingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/CastingHelpers.sol\";\nimport { InputHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/InputHelpers.sol\";\nimport { RevertCodec } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/RevertCodec.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { EVMCallModeHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/EVMCallModeHelpers.sol\";\nimport {\n    TransientStorageHelpers\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/TransientStorageHelpers.sol\";\nimport { BasePoolMath } from \"@balancer-labs/v3-solidity-utils/contracts/math/BasePoolMath.sol\";\nimport { StorageSlotExtension } from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/StorageSlotExtension.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { VaultStateBits, VaultStateLib } from \"./lib/VaultStateLib.sol\";\nimport { PoolConfigLib, PoolConfigBits } from \"./lib/PoolConfigLib.sol\";\nimport { HooksConfigLib } from \"./lib/HooksConfigLib.sol\";\nimport { VaultExtensionsLib } from \"./lib/VaultExtensionsLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\nimport { PoolDataLib } from \"./lib/PoolDataLib.sol\";\n\n/**\n * @notice Bytecode extension for the Vault containing permissionless functions outside the critical path.\n * It has access to the same storage layout as the main vault.\n *\n * The functions in this contract are not meant to be called directly. They must only be called by the Vault\n * via delegate calls, so that any state modifications produced by this contract's code will actually target\n * the main Vault's state.\n *\n * The storage of this contract is in practice unused.\n */\ncontract VaultExtension is IVaultExtension, VaultCommon, Proxy {\n    using Address for *;\n    using CastingHelpers for uint256[];\n    using FixedPoint for uint256;\n    using PackedTokenBalance for bytes32;\n    using PoolConfigLib for PoolConfigBits;\n    using HooksConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using InputHelpers for uint256;\n    using ScalingHelpers for *;\n    using VaultExtensionsLib for IVault;\n    using TransientStorageHelpers for *;\n    using StorageSlotExtension for *;\n    using PoolDataLib for PoolData;\n\n    IVault private immutable _vault;\n    IVaultAdmin private immutable _vaultAdmin;\n\n    /// @dev Functions with this modifier can only be delegate-called by the vault.\n    modifier onlyVaultDelegateCall() {\n        _ensureVaultDelegateCall();\n        _;\n    }\n\n    function _ensureVaultDelegateCall() internal view {\n        _vault.ensureVaultDelegateCall();\n    }\n\n    constructor(IVault mainVault, IVaultAdmin vaultAdmin) {\n        if (vaultAdmin.vault() != mainVault) {\n            revert WrongVaultAdminDeployment();\n        }\n\n        _vaultPauseWindowEndTime = vaultAdmin.getPauseWindowEndTime();\n        _vaultBufferPeriodDuration = vaultAdmin.getBufferPeriodDuration();\n        _vaultBufferPeriodEndTime = vaultAdmin.getBufferPeriodEndTime();\n\n        _vault = mainVault;\n        _vaultAdmin = vaultAdmin;\n    }\n\n    /*******************************************************************************\n                              Constants and immutables\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function vault() external view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getVaultAdmin() external view returns (address) {\n        return _implementation();\n    }\n\n    /*******************************************************************************\n                              Transient Accounting\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isUnlocked() external view onlyVaultDelegateCall returns (bool) {\n        return _isUnlocked().tload();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getNonzeroDeltaCount() external view onlyVaultDelegateCall returns (uint256) {\n        return _nonZeroDeltaCount().tload();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getTokenDelta(IERC20 token) external view onlyVaultDelegateCall returns (int256) {\n        return _tokenDeltas().tGet(token);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getReservesOf(IERC20 token) external view onlyVaultDelegateCall returns (uint256) {\n        return _reservesOf[token];\n    }\n\n    /*******************************************************************************\n                                    Pool Registration\n    *******************************************************************************/\n\n    struct PoolRegistrationParams {\n        TokenConfig[] tokenConfig;\n        uint256 swapFeePercentage;\n        uint32 pauseWindowEndTime;\n        bool protocolFeeExempt;\n        PoolRoleAccounts roleAccounts;\n        address poolHooksContract;\n        LiquidityManagement liquidityManagement;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function registerPool(\n        address pool,\n        TokenConfig[] memory tokenConfig,\n        uint256 swapFeePercentage,\n        uint32 pauseWindowEndTime,\n        bool protocolFeeExempt,\n        PoolRoleAccounts calldata roleAccounts,\n        address poolHooksContract,\n        LiquidityManagement calldata liquidityManagement\n    ) external onlyVaultDelegateCall nonReentrant whenVaultNotPaused {\n        _registerPool(\n            pool,\n            PoolRegistrationParams({\n                tokenConfig: tokenConfig,\n                swapFeePercentage: swapFeePercentage,\n                pauseWindowEndTime: pauseWindowEndTime,\n                protocolFeeExempt: protocolFeeExempt,\n                roleAccounts: roleAccounts,\n                poolHooksContract: poolHooksContract,\n                liquidityManagement: liquidityManagement\n            })\n        );\n    }\n\n    /**\n     * @dev The function will register the pool, setting its tokens with an initial balance of zero.\n     * The function also checks for valid token addresses and ensures that the pool and tokens aren't\n     * already registered.\n     *\n     * Emits a `PoolRegistered` event upon successful registration.\n     */\n    function _registerPool(address pool, PoolRegistrationParams memory params) internal {\n        // Ensure the pool isn't already registered\n        if (_isPoolRegistered(pool)) {\n            revert PoolAlreadyRegistered(pool);\n        }\n\n        uint256 numTokens = params.tokenConfig.length;\n        if (numTokens < _MIN_TOKENS) {\n            revert MinTokens();\n        }\n        if (numTokens > _MAX_TOKENS) {\n            revert MaxTokens();\n        }\n\n        uint8[] memory tokenDecimalDiffs = new uint8[](numTokens);\n        IERC20 previousToken;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            TokenConfig memory tokenData = params.tokenConfig[i];\n            IERC20 token = tokenData.token;\n\n            // Ensure that the token address is valid\n            if (address(token) == address(0) || address(token) == pool) {\n                revert InvalidToken();\n            }\n\n            // Enforce token sorting. (`previousToken` will be the zero address on the first iteration.)\n            if (token < previousToken) {\n                revert InputHelpers.TokensNotSorted();\n            }\n\n            if (token == previousToken) {\n                revert TokenAlreadyRegistered(token);\n            }\n\n            bool hasRateProvider = tokenData.rateProvider != IRateProvider(address(0));\n\n            _poolTokenInfo[pool][token] = TokenInfo({\n                tokenType: tokenData.tokenType,\n                rateProvider: tokenData.rateProvider,\n                paysYieldFees: tokenData.paysYieldFees\n            });\n\n            if (tokenData.tokenType == TokenType.STANDARD) {\n                if (hasRateProvider || tokenData.paysYieldFees) {\n                    revert InvalidTokenConfiguration();\n                }\n            } else if (tokenData.tokenType == TokenType.WITH_RATE) {\n                if (hasRateProvider == false) {\n                    revert InvalidTokenConfiguration();\n                }\n            } else {\n                revert InvalidTokenType();\n            }\n\n            tokenDecimalDiffs[i] = uint8(18) - IERC20Metadata(address(token)).decimals();\n\n            // Store token and seed the next iteration.\n            _poolTokens[pool].push(token);\n            previousToken = token;\n        }\n\n        // Store the role account addresses (for getters).\n        _poolRoleAccounts[pool] = params.roleAccounts;\n\n        // Make pool role assignments. A zero address means default to the authorizer.\n        _assignPoolRoles(pool, params.roleAccounts);\n\n        PoolConfigBits poolConfigBits;\n\n        // Store the configuration, and mark the pool as registered.\n        {\n            // Initialize the pool-specific protocol fee values to the current global defaults.\n            (uint256 aggregateSwapFeePercentage, uint256 aggregateYieldFeePercentage) = _protocolFeeController\n                .registerPool(pool, params.roleAccounts.poolCreator, params.protocolFeeExempt);\n\n            poolConfigBits = poolConfigBits.setPoolRegistered(true);\n            poolConfigBits = poolConfigBits.setDisableUnbalancedLiquidity(\n                params.liquidityManagement.disableUnbalancedLiquidity\n            );\n            poolConfigBits = poolConfigBits.setAddLiquidityCustom(params.liquidityManagement.enableAddLiquidityCustom);\n            poolConfigBits = poolConfigBits.setRemoveLiquidityCustom(\n                params.liquidityManagement.enableRemoveLiquidityCustom\n            );\n            poolConfigBits = poolConfigBits.setDonation(params.liquidityManagement.enableDonation);\n            poolConfigBits = poolConfigBits.setTokenDecimalDiffs(PoolConfigLib.toTokenDecimalDiffs(tokenDecimalDiffs));\n            poolConfigBits = poolConfigBits.setPauseWindowEndTime(params.pauseWindowEndTime);\n            poolConfigBits = poolConfigBits.setAggregateSwapFeePercentage(aggregateSwapFeePercentage);\n            poolConfigBits = poolConfigBits.setAggregateYieldFeePercentage(aggregateYieldFeePercentage);\n\n            if (params.poolHooksContract != address(0)) {\n                // If a hook address was passed, make sure that hook trusts the pool factory.\n                if (\n                    IHooks(params.poolHooksContract).onRegister(\n                        msg.sender,\n                        pool,\n                        params.tokenConfig,\n                        params.liquidityManagement\n                    ) == false\n                ) {\n                    revert HookRegistrationFailed(params.poolHooksContract, pool, msg.sender);\n                }\n\n                // Gets the default HooksConfig from the hook contract and saves in the vault state.\n                // Storing into hooksConfig first avoids stack-too-deep.\n                HookFlags memory hookFlags = IHooks(params.poolHooksContract).getHookFlags();\n\n                // When enableHookAdjustedAmounts == true, hooks are able to modify the result of a liquidity or swap\n                // operation by implementing an after hook. For simplicity, the vault only supports modifying the\n                // calculated part of the operation. As such, when a hook supports adjusted amounts, it cannot support\n                // unbalanced liquidity operations, as this would introduce instances where the amount calculated is the\n                // input amount (EXACT_OUT).\n                if (\n                    hookFlags.enableHookAdjustedAmounts &&\n                    params.liquidityManagement.disableUnbalancedLiquidity == false\n                ) {\n                    revert HookRegistrationFailed(params.poolHooksContract, pool, msg.sender);\n                }\n\n                poolConfigBits = poolConfigBits.setHookAdjustedAmounts(hookFlags.enableHookAdjustedAmounts);\n                poolConfigBits = poolConfigBits.setShouldCallBeforeInitialize(hookFlags.shouldCallBeforeInitialize);\n                poolConfigBits = poolConfigBits.setShouldCallAfterInitialize(hookFlags.shouldCallAfterInitialize);\n                poolConfigBits = poolConfigBits.setShouldCallComputeDynamicSwapFee(\n                    hookFlags.shouldCallComputeDynamicSwapFee\n                );\n                poolConfigBits = poolConfigBits.setShouldCallBeforeSwap(hookFlags.shouldCallBeforeSwap);\n                poolConfigBits = poolConfigBits.setShouldCallAfterSwap(hookFlags.shouldCallAfterSwap);\n                poolConfigBits = poolConfigBits.setShouldCallBeforeAddLiquidity(hookFlags.shouldCallBeforeAddLiquidity);\n                poolConfigBits = poolConfigBits.setShouldCallAfterAddLiquidity(hookFlags.shouldCallAfterAddLiquidity);\n                poolConfigBits = poolConfigBits.setShouldCallBeforeRemoveLiquidity(\n                    hookFlags.shouldCallBeforeRemoveLiquidity\n                );\n                poolConfigBits = poolConfigBits.setShouldCallAfterRemoveLiquidity(\n                    hookFlags.shouldCallAfterRemoveLiquidity\n                );\n            }\n\n            _poolConfigBits[pool] = poolConfigBits;\n            _hooksContracts[pool] = IHooks(params.poolHooksContract);\n        }\n\n        // Static swap fee percentage has special limits, so we don't use the library function directly.\n        _setStaticSwapFeePercentage(pool, params.swapFeePercentage);\n\n        // Emit an event to log the pool registration (pass msg.sender as the factory argument).\n        emit PoolRegistered(\n            pool,\n            msg.sender,\n            params.tokenConfig,\n            params.swapFeePercentage,\n            params.pauseWindowEndTime,\n            params.roleAccounts,\n            poolConfigBits.toHooksConfig(IHooks(params.poolHooksContract)),\n            params.liquidityManagement\n        );\n    }\n\n    function _assignPoolRoles(address pool, PoolRoleAccounts memory roleAccounts) private {\n        mapping(bytes32 => PoolFunctionPermission) storage roleAssignments = _poolFunctionPermissions[pool];\n        IAuthentication vaultAdmin = IAuthentication(address(_vaultAdmin));\n\n        if (roleAccounts.pauseManager != address(0)) {\n            roleAssignments[vaultAdmin.getActionId(IVaultAdmin.pausePool.selector)] = PoolFunctionPermission({\n                account: roleAccounts.pauseManager,\n                onlyOwner: false\n            });\n            roleAssignments[vaultAdmin.getActionId(IVaultAdmin.unpausePool.selector)] = PoolFunctionPermission({\n                account: roleAccounts.pauseManager,\n                onlyOwner: false\n            });\n        }\n\n        if (roleAccounts.swapFeeManager != address(0)) {\n            bytes32 swapFeeAction = vaultAdmin.getActionId(IVaultAdmin.setStaticSwapFeePercentage.selector);\n\n            roleAssignments[swapFeeAction] = PoolFunctionPermission({\n                account: roleAccounts.swapFeeManager,\n                onlyOwner: true\n            });\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function isPoolRegistered(address pool) external view onlyVaultDelegateCall returns (bool) {\n        return _isPoolRegistered(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function initialize(\n        address pool,\n        address to,\n        IERC20[] memory tokens,\n        uint256[] memory exactAmountsIn,\n        uint256 minBptAmountOut,\n        bytes memory userData\n    ) external onlyVaultDelegateCall onlyWhenUnlocked withRegisteredPool(pool) returns (uint256 bptAmountOut) {\n        _ensureUnpaused(pool);\n\n        // Balances are zero until after initialize is called, so there is no need to charge pending yield fee here.\n        PoolData memory poolData = _loadPoolData(pool, Rounding.ROUND_DOWN);\n\n        if (poolData.poolConfigBits.isPoolInitialized()) {\n            revert PoolAlreadyInitialized(pool);\n        }\n        uint256 numTokens = poolData.tokens.length;\n\n        InputHelpers.ensureInputLengthMatch(numTokens, exactAmountsIn.length);\n\n        // Amounts are entering pool math, so round down. A lower invariant after the join means less bptOut,\n        // favoring the pool.\n        uint256[] memory exactAmountsInScaled18 = exactAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        if (poolData.poolConfigBits.shouldCallBeforeInitialize()) {\n            HooksConfigLib.callBeforeInitializeHook(exactAmountsInScaled18, userData, _hooksContracts[pool]);\n            // The before hook is reentrant, and could have changed token rates.\n            // Updating balances here is unnecessary since they're 0, but we do not special case before init\n            // for the sake of bytecode size.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[pool], Rounding.ROUND_DOWN);\n\n            // Also update `exactAmountsInScaled18`, in case the underlying rates changed.\n            exactAmountsInScaled18 = exactAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        bptAmountOut = _initialize(pool, to, poolData, tokens, exactAmountsIn, exactAmountsInScaled18, minBptAmountOut);\n\n        if (poolData.poolConfigBits.shouldCallAfterInitialize()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[pool];\n\n            HooksConfigLib.callAfterInitializeHook(exactAmountsInScaled18, bptAmountOut, userData, hooksContract);\n        }\n    }\n\n    function _initialize(\n        address pool,\n        address to,\n        PoolData memory poolData,\n        IERC20[] memory tokens,\n        uint256[] memory exactAmountsIn,\n        uint256[] memory exactAmountsInScaled18,\n        uint256 minBptAmountOut\n    ) internal nonReentrant returns (uint256 bptAmountOut) {\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[pool];\n\n        for (uint256 i = 0; i < poolData.tokens.length; ++i) {\n            IERC20 actualToken = poolData.tokens[i];\n\n            // Tokens passed into `initialize` are the \"expected\" tokens.\n            if (actualToken != tokens[i]) {\n                revert TokensMismatch(pool, address(tokens[i]), address(actualToken));\n            }\n\n            // Debit token[i] for amountIn.\n            _takeDebt(actualToken, exactAmountsIn[i]);\n\n            // Store the new Pool balances (and initial last live balances).\n            poolBalances[i] = PackedTokenBalance.toPackedBalance(exactAmountsIn[i], exactAmountsInScaled18[i]);\n        }\n\n        emit PoolBalanceChanged(pool, to, exactAmountsIn.unsafeCastToInt256(true));\n\n        poolData.poolConfigBits = poolData.poolConfigBits.setPoolInitialized(true);\n\n        // Store config and mark the pool as initialized.\n        _poolConfigBits[pool] = poolData.poolConfigBits;\n\n        // Pass scaled balances to the pool.\n        bptAmountOut = IBasePool(pool).computeInvariant(exactAmountsInScaled18);\n\n        _ensureMinimumTotalSupply(bptAmountOut);\n\n        // At this point we know that bptAmountOut >= _MINIMUM_TOTAL_SUPPLY, so this will not revert.\n        bptAmountOut -= _MINIMUM_TOTAL_SUPPLY;\n        // When adding liquidity, we must mint tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Minting will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _mintMinimumSupplyReserve(address(pool));\n        _mint(address(pool), to, bptAmountOut);\n\n        // At this point we have the calculated BPT amount.\n        if (bptAmountOut < minBptAmountOut) {\n            revert BptAmountOutBelowMin(bptAmountOut, minBptAmountOut);\n        }\n\n        // Emit an event to log the pool initialization.\n        emit PoolInitialized(pool);\n    }\n\n    /*******************************************************************************\n                                    Pool Information\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isPoolInitialized(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool) {\n        return _isPoolInitialized(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolTokens(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (IERC20[] memory tokens) {\n        return _poolTokens[pool];\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolTokenRates(\n        address pool\n    )\n        external\n        view\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        returns (uint256[] memory decimalScalingFactors, uint256[] memory tokenRates)\n    {\n        // Retrieve the mapping of tokens and their balances for the specified pool.\n        PoolConfigBits poolConfig = _poolConfigBits[pool];\n\n        IERC20[] memory tokens = _poolTokens[pool];\n        uint256 numTokens = tokens.length;\n        decimalScalingFactors = PoolConfigLib.getDecimalScalingFactors(poolConfig, numTokens);\n        tokenRates = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            TokenInfo memory tokenInfo = _poolTokenInfo[pool][tokens[i]];\n            tokenRates[i] = PoolDataLib.getTokenRate(tokenInfo);\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolData(\n        address pool\n    ) external view onlyVaultDelegateCall withInitializedPool(pool) returns (PoolData memory) {\n        return _loadPoolData(pool, Rounding.ROUND_DOWN);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolTokenInfo(\n        address pool\n    )\n        external\n        view\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        returns (\n            IERC20[] memory tokens,\n            TokenInfo[] memory tokenInfo,\n            uint256[] memory balancesRaw,\n            uint256[] memory lastBalancesLiveScaled18\n        )\n    {\n        // Retrieve the mapping of tokens and their balances for the specified pool.\n        mapping(uint256 => bytes32) storage poolTokenBalances = _poolTokenBalances[pool];\n        tokens = _poolTokens[pool];\n        uint256 numTokens = tokens.length;\n        tokenInfo = new TokenInfo[](numTokens);\n        balancesRaw = new uint256[](numTokens);\n        lastBalancesLiveScaled18 = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            bytes32 packedBalance = poolTokenBalances[i];\n            tokenInfo[i] = _poolTokenInfo[pool][tokens[i]];\n            balancesRaw[i] = packedBalance.getBalanceRaw();\n            lastBalancesLiveScaled18[i] = packedBalance.getBalanceDerived();\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getCurrentLiveBalances(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256[] memory balancesLiveScaled18) {\n        return _loadPoolData(pool, Rounding.ROUND_DOWN).balancesLiveScaled18;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolConfig(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (PoolConfig memory) {\n        PoolConfigBits config = _poolConfigBits[pool];\n\n        return\n            PoolConfig({\n                isPoolRegistered: config.isPoolRegistered(),\n                isPoolInitialized: config.isPoolInitialized(),\n                isPoolPaused: config.isPoolPaused(),\n                isPoolInRecoveryMode: config.isPoolInRecoveryMode(),\n                staticSwapFeePercentage: config.getStaticSwapFeePercentage(),\n                aggregateSwapFeePercentage: config.getAggregateSwapFeePercentage(),\n                aggregateYieldFeePercentage: config.getAggregateYieldFeePercentage(),\n                tokenDecimalDiffs: config.getTokenDecimalDiffs(),\n                pauseWindowEndTime: config.getPauseWindowEndTime(),\n                liquidityManagement: LiquidityManagement({\n                    // NOTE: supportUnbalancedLiquidity is inverted because false means it is supported.\n                    disableUnbalancedLiquidity: !config.supportsUnbalancedLiquidity(),\n                    enableAddLiquidityCustom: config.supportsAddLiquidityCustom(),\n                    enableRemoveLiquidityCustom: config.supportsRemoveLiquidityCustom(),\n                    enableDonation: config.supportsDonation()\n                })\n            });\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getHooksConfig(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (HooksConfig memory) {\n        return _poolConfigBits[pool].toHooksConfig(_hooksContracts[pool]);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getBptRate(\n        address pool\n    ) external view onlyVaultDelegateCall withInitializedPool(pool) returns (uint256 rate) {\n        PoolData memory poolData = _loadPoolData(pool, Rounding.ROUND_DOWN);\n        uint256 invariant = IBasePool(pool).computeInvariant(poolData.balancesLiveScaled18);\n\n        return invariant.divDown(_totalSupply(pool));\n    }\n\n    /*******************************************************************************\n                                 Balancer Pool Tokens\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function totalSupply(address token) external view onlyVaultDelegateCall returns (uint256) {\n        return _totalSupply(token);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function balanceOf(address token, address account) external view onlyVaultDelegateCall returns (uint256) {\n        return _balanceOf(token, account);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external view onlyVaultDelegateCall returns (uint256) {\n        return _allowance(token, owner, spender);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function approve(address owner, address spender, uint256 amount) external onlyVaultDelegateCall returns (bool) {\n        _approve(msg.sender, owner, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function transfer(address owner, address to, uint256 amount) external onlyVaultDelegateCall returns (bool) {\n        _transfer(msg.sender, owner, to, amount);\n        return true;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function transferFrom(\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external onlyVaultDelegateCall returns (bool) {\n        _spendAllowance(msg.sender, from, spender, amount);\n        _transfer(msg.sender, from, to, amount);\n        return true;\n    }\n\n    /*******************************************************************************\n                                     Pool Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isPoolPaused(address pool) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool) {\n        return _isPoolPaused(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolPausedState(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool, uint32, uint32, address) {\n        (bool paused, uint32 pauseWindowEndTime) = _getPoolPausedState(pool);\n\n        return (\n            paused,\n            pauseWindowEndTime,\n            pauseWindowEndTime + _vaultBufferPeriodDuration,\n            _poolRoleAccounts[pool].pauseManager\n        );\n    }\n\n    /*******************************************************************************\n                                          Fees\n    *******************************************************************************/\n\n    // Swap and Yield fees are both stored using the PackedTokenBalance library, which is usually used for\n    // balances that are related (e.g., raw and live). In this case, it holds two uncorrelated values: swap\n    // and yield fee amounts, arbitrarily assigning \"Raw\" to Swap and \"Derived\" to Yield.\n\n    /// @inheritdoc IVaultExtension\n    function getAggregateSwapFeeAmount(\n        address pool,\n        IERC20 token\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256) {\n        return _aggregateFeeAmounts[pool][token].getBalanceRaw();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getAggregateYieldFeeAmount(\n        address pool,\n        IERC20 token\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256) {\n        return _aggregateFeeAmounts[pool][token].getBalanceDerived();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getStaticSwapFeePercentage(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256) {\n        PoolConfigBits config = _poolConfigBits[pool];\n        return config.getStaticSwapFeePercentage();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolRoleAccounts(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (PoolRoleAccounts memory) {\n        return _poolRoleAccounts[pool];\n    }\n\n    /// @inheritdoc IVaultExtension\n    function computeDynamicSwapFeePercentage(\n        address pool,\n        PoolSwapParams memory swapParams\n    )\n        external\n        view\n        onlyVaultDelegateCall\n        withInitializedPool(pool)\n        returns (bool success, uint256 dynamicSwapFeePercentage)\n    {\n        return\n            HooksConfigLib.callComputeDynamicSwapFeeHook(\n                swapParams,\n                pool,\n                _poolConfigBits[pool].getStaticSwapFeePercentage(),\n                _hooksContracts[pool]\n            );\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getProtocolFeeController() external view onlyVaultDelegateCall returns (IProtocolFeeController) {\n        return _protocolFeeController;\n    }\n\n    /*******************************************************************************\n                                     Recovery Mode\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isPoolInRecoveryMode(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool) {\n        return _isPoolInRecoveryMode(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function removeLiquidityRecovery(\n        address pool,\n        address from,\n        uint256 exactBptAmountIn\n    )\n        external\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        nonReentrant\n        withInitializedPool(pool)\n        onlyInRecoveryMode(pool)\n        returns (uint256[] memory amountsOutRaw)\n    {\n        // Retrieve the mapping of tokens and their balances for the specified pool.\n        mapping(uint256 => bytes32) storage poolTokenBalances = _poolTokenBalances[pool];\n\n        // Initialize arrays to store tokens and balances based on the number of tokens in the pool.\n        IERC20[] memory tokens = _poolTokens[pool];\n        uint256 numTokens = tokens.length;\n\n        uint256[] memory balancesRaw = new uint256[](numTokens);\n        bytes32 packedBalances;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            balancesRaw[i] = poolTokenBalances[i].getBalanceRaw();\n        }\n\n        amountsOutRaw = BasePoolMath.computeProportionalAmountsOut(balancesRaw, _totalSupply(pool), exactBptAmountIn);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            // Credit token[i] for amountOut.\n            _supplyCredit(tokens[i], amountsOutRaw[i]);\n\n            // Compute the new Pool balances. A Pool's token balance always decreases after an exit\n            // (potentially by 0).\n            balancesRaw[i] -= amountsOutRaw[i];\n        }\n\n        // Store the new pool balances - raw only, since we don't have rates in Recovery Mode.\n        // In Recovery Mode, raw and last live balances will get out of sync. This is corrected when the pool is taken\n        // out of Recovery Mode.\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[pool];\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            packedBalances = poolBalances[i];\n            poolBalances[i] = packedBalances.setBalanceRaw(balancesRaw[i]);\n        }\n\n        _spendAllowance(pool, from, msg.sender, exactBptAmountIn);\n\n        if (_isQueryContext()) {\n            // Increase `from` balance to ensure the burn function succeeds.\n            _queryModeBalanceIncrease(pool, from, exactBptAmountIn);\n        }\n        // When removing liquidity, we must burn tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Burning will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _burn(pool, from, exactBptAmountIn);\n\n        emit PoolBalanceChanged(\n            pool,\n            from,\n            // We can unsafely cast to int256 because balances are stored as uint128 (see PackedTokenBalance).\n            amountsOutRaw.unsafeCastToInt256(false)\n        );\n    }\n\n    /*******************************************************************************\n                                        Queries\n    *******************************************************************************/\n\n    /// @dev Ensure that only static calls are made to the functions with this modifier.\n    modifier query() {\n        _setupQuery();\n        _;\n    }\n\n    function _setupQuery() internal {\n        if (EVMCallModeHelpers.isStaticCall() == false) {\n            revert EVMCallModeHelpers.NotStaticCall();\n        }\n\n        bool _isQueryDisabled = _vaultStateBits.isQueryDisabled();\n        if (_isQueryDisabled) {\n            revert QueriesDisabled();\n        }\n\n        // Unlock so that `onlyWhenUnlocked` does not revert.\n        _isUnlocked().tstore(true);\n    }\n\n    function _isQueryContext() internal view returns (bool) {\n        return EVMCallModeHelpers.isStaticCall() && _vaultStateBits.isQueryDisabled() == false;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function quote(bytes calldata data) external payable query onlyVaultDelegateCall returns (bytes memory result) {\n        // Forward the incoming call to the original sender of this transaction.\n        return (msg.sender).functionCallWithValue(data, msg.value);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function quoteAndRevert(bytes calldata data) external payable query onlyVaultDelegateCall {\n        // Forward the incoming call to the original sender of this transaction.\n        (bool success, bytes memory result) = (msg.sender).call{ value: msg.value }(data);\n        if (success) {\n            // This will only revert if result is empty and sender account has no code.\n            Address.verifyCallResultFromTarget(msg.sender, success, result);\n            // Send result in revert reason.\n            revert RevertCodec.Result(result);\n        } else {\n            // If the call reverted with a spoofed `QuoteResult`, we catch it and bubble up a different reason.\n            bytes4 errorSelector = RevertCodec.parseSelector(result);\n            if (errorSelector == RevertCodec.Result.selector) {\n                revert QuoteResultSpoofed();\n            }\n\n            // Otherwise we bubble up the original revert reason.\n            RevertCodec.bubbleUpRevert(result);\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function isQueryDisabled() external view onlyVaultDelegateCall returns (bool) {\n        return _vaultStateBits.isQueryDisabled();\n    }\n\n    /*******************************************************************************\n                                     Default handlers\n    *******************************************************************************/\n\n    receive() external payable {\n        revert CannotReceiveEth();\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Override proxy implementation of `fallback` to disallow incoming ETH transfers.\n     * This function actually returns whatever the Vault Extension does when handling the request.\n     */\n    fallback() external payable override {\n        if (msg.value > 0) {\n            revert CannotReceiveEth();\n        }\n\n        _fallback();\n    }\n\n    /*******************************************************************************\n                                     Miscellaneous\n    *******************************************************************************/\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Returns Vault Extension, where fallback requests are forwarded.\n     */\n    function _implementation() internal view override returns (address) {\n        return address(_vaultAdmin);\n    }\n}\n",
        "Vault.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IVaultExtension } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultExtension.sol\";\nimport { IVaultMain } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultMain.sol\";\nimport { IBasePool } from \"@balancer-labs/v3-interfaces/contracts/vault/IBasePool.sol\";\nimport { IHooks } from \"@balancer-labs/v3-interfaces/contracts/vault/IHooks.sol\";\nimport { IPoolLiquidity } from \"@balancer-labs/v3-interfaces/contracts/vault/IPoolLiquidity.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { EVMCallModeHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/EVMCallModeHelpers.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { CastingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/CastingHelpers.sol\";\nimport { InputHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/InputHelpers.sol\";\nimport {\n    TransientStorageHelpers\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/TransientStorageHelpers.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { BasePoolMath } from \"@balancer-labs/v3-solidity-utils/contracts/math/BasePoolMath.sol\";\nimport { StorageSlotExtension } from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/StorageSlotExtension.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\nimport { BufferHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/BufferHelpers.sol\";\n\nimport { VaultStateLib, VaultStateBits } from \"./lib/VaultStateLib.sol\";\nimport { PoolConfigLib } from \"./lib/PoolConfigLib.sol\";\nimport { HooksConfigLib } from \"./lib/HooksConfigLib.sol\";\nimport { PoolDataLib } from \"./lib/PoolDataLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\ncontract Vault is IVaultMain, VaultCommon, Proxy {\n    using PackedTokenBalance for bytes32;\n    using BufferHelpers for bytes32;\n    using InputHelpers for uint256;\n    using FixedPoint for *;\n    using Address for *;\n    using CastingHelpers for uint256[];\n    using SafeERC20 for IERC20;\n    using PoolConfigLib for PoolConfigBits;\n    using HooksConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using ScalingHelpers for *;\n    using TransientStorageHelpers for *;\n    using StorageSlotExtension for *;\n    using PoolDataLib for PoolData;\n\n    IVaultExtension private immutable _vaultExtension;\n\n    constructor(IVaultExtension vaultExtension, IAuthorizer authorizer, IProtocolFeeController protocolFeeController) {\n        if (address(vaultExtension.vault()) != address(this)) {\n            revert WrongVaultExtensionDeployment();\n        }\n\n        if (address(protocolFeeController.vault()) != address(this)) {\n            revert WrongProtocolFeeControllerDeployment();\n        }\n\n        _vaultExtension = vaultExtension;\n        _protocolFeeController = protocolFeeController;\n\n        _vaultPauseWindowEndTime = IVaultAdmin(address(vaultExtension)).getPauseWindowEndTime();\n        _vaultBufferPeriodDuration = IVaultAdmin(address(vaultExtension)).getBufferPeriodDuration();\n        _vaultBufferPeriodEndTime = IVaultAdmin(address(vaultExtension)).getBufferPeriodEndTime();\n\n        _authorizer = authorizer;\n    }\n\n    /*******************************************************************************\n                              Transient Accounting\n    *******************************************************************************/\n\n    /**\n     * @dev This modifier is used for functions that temporarily modify the token deltas\n     * of the Vault, but expect to revert or settle balances by the end of their execution.\n     * It works by ensuring that the balances are properly settled by the time the last\n     * operation is executed.\n     *\n     * This is useful for functions like `unlock`, which perform arbitrary external calls:\n     * we can keep track of temporary deltas changes, and make sure they are settled by the\n     * time the external call is complete.\n     */\n    modifier transient() {\n        bool isUnlockedBefore = _isUnlocked().tload();\n\n        if (isUnlockedBefore == false) {\n            _isUnlocked().tstore(true);\n        }\n\n        // The caller does everything here and has to settle all outstanding balances\n        _;\n\n        if (isUnlockedBefore == false) {\n            if (_nonZeroDeltaCount().tload() != 0) {\n                revert BalanceNotSettled();\n            }\n\n            _isUnlocked().tstore(false);\n        }\n    }\n\n    /// @inheritdoc IVaultMain\n    function unlock(bytes calldata data) external transient returns (bytes memory result) {\n        return (msg.sender).functionCall(data);\n    }\n\n    /// @inheritdoc IVaultMain\n    function settle(IERC20 token, uint256 amountHint) external nonReentrant onlyWhenUnlocked returns (uint256 credit) {\n        uint256 reservesBefore = _reservesOf[token];\n        uint256 currentReserves = token.balanceOf(address(this));\n        _reservesOf[token] = currentReserves;\n        credit = currentReserves - reservesBefore;\n\n        // If the given hint is equal or greater to the reserve difference, we just take the actual reserve difference\n        // as the paid amount; the actual balance of the tokens in the vault is what matters here.\n        if (credit > amountHint) {\n            // If the difference in reserves is higher than the amount claimed to be paid by the caller, there was some\n            // leftover that had been sent to the vault beforehand, which was not incorporated into the reserves.\n            // In that case, we simply discard the leftover by considering the given hint as the amount paid.\n            // In turn, this gives the caller credit for the given amount hint, which is what the caller is expecting.\n            credit = amountHint;\n        }\n\n        _supplyCredit(token, credit);\n    }\n\n    /// @inheritdoc IVaultMain\n    function sendTo(IERC20 token, address to, uint256 amount) external nonReentrant onlyWhenUnlocked {\n        _takeDebt(token, amount);\n        _reservesOf[token] -= amount;\n\n        token.safeTransfer(to, amount);\n    }\n\n    /*******************************************************************************\n                                    Pool Operations\n    *******************************************************************************/\n\n    // The Vault performs all upscaling and downscaling (due to token decimals, rates, etc.), so that the pools\n    // don't have to. However, scaling inevitably leads to rounding errors, so we take great care to ensure that\n    // any rounding errors favor the Vault. An important invariant of the system is that there is no repeatable\n    // path where tokensOut > tokensIn.\n    //\n    // In general, this means rounding up any values entering the Vault, and rounding down any values leaving\n    // the Vault, so that external users either pay a little extra or receive a little less in the case of a\n    // rounding error.\n    //\n    // However, it's not always straightforward to determine the correct rounding direction, given the presence\n    // and complexity of intermediate steps. An \"amountIn\" sounds like it should be rounded up: but only if that\n    // is the amount actually being transferred. If instead it is an amount sent to the pool math, where rounding\n    // up would result in a *higher* calculated amount out, that would favor the user instead of the Vault. So in\n    // that case, amountIn should be rounded down.\n    //\n    // See comments justifying the rounding direction in each case.\n    //\n    // This reasoning applies to Weighted Pool math, and is likely to apply to others as well, but of course\n    // it's possible a new pool type might not conform. Duplicate the tests for new pool types (e.g., Stable Math).\n    // Also, the final code should ensure that we are not relying entirely on the rounding directions here,\n    // but have enough additional layers (e.g., minimum amounts, buffer wei on all transfers) to guarantee safety,\n    // even if it turns out these directions are incorrect for a new pool type.\n\n    /*******************************************************************************\n                                          Swaps\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function swap(\n        SwapParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256 amountCalculated, uint256 amountIn, uint256 amountOut)\n    {\n        _ensureUnpaused(params.pool);\n\n        if (params.amountGivenRaw == 0) {\n            revert AmountGivenZero();\n        }\n\n        if (params.tokenIn == params.tokenOut) {\n            revert CannotSwapSameToken();\n        }\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the swap hooks are reentrant and could do anything, including\n        // change these balances, we cannot defer settlement until `_swap`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances`, `_aggregateFeeAmounts`\n        // in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_DOWN);\n\n        // State is fully populated here, and shall not be modified at a lower level.\n        SwapState memory state = _loadSwapState(params, poolData);\n\n        PoolSwapParams memory swapParams = _buildPoolSwapParams(params, state, poolData);\n\n        if (poolData.poolConfigBits.shouldCallBeforeSwap()) {\n            HooksConfigLib.callBeforeSwapHook(swapParams, params.pool, _hooksContracts[params.pool]);\n\n            // The call to `onBeforeSwap` could potentially update token rates and balances.\n            // We update `poolData.tokenRates`, `poolData.rawBalances` and `poolData.balancesLiveScaled18`\n            // to ensure the `onSwap` and `onComputeDynamicSwapFeePercentage` are called with the current values.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_DOWN);\n\n            // Also update amountGivenScaled18, as it will now be used in the swap, and the rates might have changed.\n            state.amountGivenScaled18 = _computeAmountGivenScaled18(params, poolData, state);\n\n            swapParams = _buildPoolSwapParams(params, state, poolData);\n        }\n\n        _ensureValidTradeAmount(state.amountGivenScaled18);\n\n        // Note that this must be called *after* the before hook, to guarantee that the swap params are the same\n        // as those passed to the main operation.\n        //\n        // At this point, the static swap fee percentage is loaded in the swap state as the default, to be used\n        // unless the pool has a dynamic swap fee. It is also passed into the hook, to support common cases\n        // where the dynamic fee computation logic uses it.\n        if (poolData.poolConfigBits.shouldCallComputeDynamicSwapFee()) {\n            (bool dynamicSwapFeeCalculated, uint256 dynamicSwapFee) = HooksConfigLib.callComputeDynamicSwapFeeHook(\n                swapParams,\n                params.pool,\n                state.swapFeePercentage,\n                _hooksContracts[params.pool]\n            );\n\n            if (dynamicSwapFeeCalculated) {\n                state.swapFeePercentage = dynamicSwapFee;\n            }\n        }\n\n        // Non-reentrant call that updates accounting.\n        // The following side-effects are important to note:\n        // PoolData balancesRaw and balancesLiveScaled18 are adjusted for swap amounts and fees inside of _swap.\n        uint256 amountCalculatedScaled18;\n        (amountCalculated, amountCalculatedScaled18, amountIn, amountOut) = _swap(params, state, poolData, swapParams);\n\n        _ensureValidTradeAmount(amountCalculatedScaled18);\n\n        // The new amount calculated is 'amountCalculated + delta'. If the underlying hook fails, or limits are\n        // violated, `onAfterSwap` will revert. Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterSwap()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountCalculated = poolData.poolConfigBits.callAfterSwapHook(\n                amountCalculatedScaled18,\n                amountCalculated,\n                msg.sender,\n                params,\n                state,\n                poolData,\n                hooksContract\n            );\n        }\n\n        if (params.kind == SwapKind.EXACT_IN) {\n            amountOut = amountCalculated;\n        } else {\n            amountIn = amountCalculated;\n        }\n    }\n\n    function _loadSwapState(\n        SwapParams memory params,\n        PoolData memory poolData\n    ) private pure returns (SwapState memory state) {\n        state.indexIn = _findTokenIndex(poolData.tokens, params.tokenIn);\n        state.indexOut = _findTokenIndex(poolData.tokens, params.tokenOut);\n\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        state.amountGivenScaled18 = _computeAmountGivenScaled18(params, poolData, state);\n        state.swapFeePercentage = poolData.poolConfigBits.getStaticSwapFeePercentage();\n    }\n\n    function _buildPoolSwapParams(\n        SwapParams memory params,\n        SwapState memory state,\n        PoolData memory poolData\n    ) internal view returns (PoolSwapParams memory) {\n        // Uses msg.sender as the router (the contract that called the vault)\n        return\n            PoolSwapParams({\n                kind: params.kind,\n                amountGivenScaled18: state.amountGivenScaled18,\n                balancesScaled18: poolData.balancesLiveScaled18,\n                indexIn: state.indexIn,\n                indexOut: state.indexOut,\n                router: msg.sender,\n                userData: params.userData\n            });\n    }\n\n    /**\n     * @dev Preconditions: decimalScalingFactors and tokenRates in `poolData` must be current.\n     * Uses amountGivenRaw and kind from `params`.\n     */\n    function _computeAmountGivenScaled18(\n        SwapParams memory params,\n        PoolData memory poolData,\n        SwapState memory state\n    ) private pure returns (uint256) {\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        return\n            params.kind == SwapKind.EXACT_IN\n                ? params.amountGivenRaw.toScaled18ApplyRateRoundDown(\n                    poolData.decimalScalingFactors[state.indexIn],\n                    poolData.tokenRates[state.indexIn]\n                )\n                : params.amountGivenRaw.toScaled18ApplyRateRoundUp(\n                    poolData.decimalScalingFactors[state.indexOut],\n                    poolData.tokenRates[state.indexOut]\n                );\n    }\n\n    struct SwapInternalLocals {\n        uint256 swapFeeAmountScaled18;\n        uint256 swapFeeIndex;\n        IERC20 swapFeeToken;\n        uint256 balanceInIncrement;\n        uint256 balanceOutDecrement;\n        uint256 swapFeeAmountRaw;\n    }\n\n    /**\n     * @dev Main non-reentrant portion of the swap, which calls the pool hook and updates accounting. `vaultSwapParams`\n     * are passed to the pool's `onSwap` hook.\n     *\n     * Preconditions: complete `SwapParams`, `SwapState`, and `PoolData`.\n     * Side effects: mutates balancesRaw and balancesLiveScaled18 in `poolData`.\n     * Updates `_aggregateFeeAmounts`, and `_poolTokenBalances` in storage.\n     * Emits Swap event.\n     */\n    function _swap(\n        SwapParams memory params,\n        SwapState memory state,\n        PoolData memory poolData,\n        PoolSwapParams memory swapParams\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256 amountCalculatedRaw,\n            uint256 amountCalculatedScaled18,\n            uint256 amountInRaw,\n            uint256 amountOutRaw\n        )\n    {\n        SwapInternalLocals memory locals;\n\n        // Perform the swap request hook and compute the new balances for 'token in' and 'token out' after the swap.\n        amountCalculatedScaled18 = IBasePool(params.pool).onSwap(swapParams);\n\n        // Note that balances are kept in memory, and are not fully computed until the `setPoolBalances` below.\n        // Intervening code cannot read balances from storage, as they are temporarily out-of-sync here. This function\n        // is nonReentrant, to guard against read-only reentrancy issues.\n\n        // (1) and (2): get raw amounts and check limits.\n        if (params.kind == SwapKind.EXACT_IN) {\n            // Swap fee is always a percentage of the amountCalculated. On ExactIn, subtract it from the calculated\n            // amountOut. Round up to avoid losses during precision loss.\n            locals.swapFeeAmountScaled18 = amountCalculatedScaled18.mulUp(state.swapFeePercentage);\n\n            // Need to update `amountCalculatedScaled18` for the onAfterSwap hook.\n            amountCalculatedScaled18 -= locals.swapFeeAmountScaled18;\n\n            // For `ExactIn` the amount calculated is leaving the Vault, so we round down.\n            amountCalculatedRaw = amountCalculatedScaled18.toRawUndoRateRoundDown(\n                poolData.decimalScalingFactors[state.indexOut],\n                poolData.tokenRates[state.indexOut]\n            );\n\n            (amountInRaw, amountOutRaw) = (params.amountGivenRaw, amountCalculatedRaw);\n\n            if (amountOutRaw < params.limitRaw) {\n                revert SwapLimit(amountOutRaw, params.limitRaw);\n            }\n        } else {\n            // To ensure symmetry with EXACT_IN, the swap fee used by ExactOut is\n            // `amountCalculated * fee% / (100% - fee%)`. Add it to the calculated amountIn. Round up to avoid losses\n            // during precision loss.\n            locals.swapFeeAmountScaled18 = amountCalculatedScaled18.mulDivUp(\n                state.swapFeePercentage,\n                state.swapFeePercentage.complement()\n            );\n\n            amountCalculatedScaled18 += locals.swapFeeAmountScaled18;\n\n            // For `ExactOut` the amount calculated is entering the Vault, so we round up.\n            amountCalculatedRaw = amountCalculatedScaled18.toRawUndoRateRoundUp(\n                poolData.decimalScalingFactors[state.indexIn],\n                poolData.tokenRates[state.indexIn]\n            );\n\n            (amountInRaw, amountOutRaw) = (amountCalculatedRaw, params.amountGivenRaw);\n\n            if (amountInRaw > params.limitRaw) {\n                revert SwapLimit(amountInRaw, params.limitRaw);\n            }\n        }\n\n        // 3) Deltas: debit for token in, credit for token out.\n        _takeDebt(params.tokenIn, amountInRaw);\n        _supplyCredit(params.tokenOut, amountOutRaw);\n\n        // 4) Compute and charge protocol and creator fees.\n        (locals.swapFeeIndex, locals.swapFeeToken) = params.kind == SwapKind.EXACT_IN\n            ? (state.indexOut, params.tokenOut)\n            : (state.indexIn, params.tokenIn);\n\n        // Note that protocol fee storage is updated before balance storage, as the final raw balances need to take\n        // the fees into account.\n        uint256 totalFeesRaw = _computeAndChargeAggregateSwapFees(\n            poolData,\n            locals.swapFeeAmountScaled18,\n            params.pool,\n            locals.swapFeeToken,\n            locals.swapFeeIndex\n        );\n\n        // 5) Pool balances: raw and live.\n        //\n        // Adjust for raw swap amounts and total fees on the calculated end.\n        // So that fees are always subtracted from pool balances:\n        // For ExactIn, we increase the tokenIn balance by `amountIn`, and decrease the tokenOut balance by the\n        // (`amountOut` + fees).\n        // For ExactOut, we increase the tokenInBalance by (`amountIn` - fees), and decrease the tokenOut balance by\n        // `amountOut`.\n        (locals.balanceInIncrement, locals.balanceOutDecrement) = params.kind == SwapKind.EXACT_IN\n            ? (amountInRaw, amountOutRaw + totalFeesRaw)\n            : (amountInRaw - totalFeesRaw, amountOutRaw);\n\n        poolData.updateRawAndLiveBalance(\n            state.indexIn,\n            poolData.balancesRaw[state.indexIn] + locals.balanceInIncrement,\n            Rounding.ROUND_UP\n        );\n        poolData.updateRawAndLiveBalance(\n            state.indexOut,\n            poolData.balancesRaw[state.indexOut] - locals.balanceOutDecrement,\n            Rounding.ROUND_DOWN\n        );\n\n        // 6) Store pool balances, raw and live (only index in and out).\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[params.pool];\n        poolBalances[state.indexIn] = PackedTokenBalance.toPackedBalance(\n            poolData.balancesRaw[state.indexIn],\n            poolData.balancesLiveScaled18[state.indexIn]\n        );\n        poolBalances[state.indexOut] = PackedTokenBalance.toPackedBalance(\n            poolData.balancesRaw[state.indexOut],\n            poolData.balancesLiveScaled18[state.indexOut]\n        );\n\n        // 7) Off-chain events.\n        // Since the swapFeeAmountScaled18 (derived from scaling up either the amountGiven or amountCalculated)\n        // also contains the rate, undo it when converting to raw.\n        locals.swapFeeAmountRaw = locals.swapFeeAmountScaled18.toRawUndoRateRoundDown(\n            poolData.decimalScalingFactors[locals.swapFeeIndex],\n            poolData.tokenRates[locals.swapFeeIndex]\n        );\n\n        emit Swap(\n            params.pool,\n            params.tokenIn,\n            params.tokenOut,\n            amountInRaw,\n            amountOutRaw,\n            state.swapFeePercentage,\n            locals.swapFeeAmountRaw,\n            locals.swapFeeToken\n        );\n    }\n\n    /***************************************************************************\n                                   Add Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function addLiquidity(\n        AddLiquidityParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData)\n    {\n        // Round balances up when adding liquidity:\n        // If proportional, higher balances = higher proportional amountsIn, favoring the pool.\n        // If unbalanced, higher balances = lower invariant ratio with fees.\n        // bptOut = supply * (ratio - 1), so lower ratio = less bptOut, favoring the pool.\n\n        _ensureUnpaused(params.pool);\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the add liquidity hooks are reentrant and could do anything,\n        // including change these balances, we cannot defer settlement until `_addLiquidity`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances`, and\n        // `_aggregateFeeAmounts` in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_UP);\n        InputHelpers.ensureInputLengthMatch(poolData.tokens.length, params.maxAmountsIn.length);\n\n        // Amounts are entering pool math, so round down.\n        // Introducing `maxAmountsInScaled18` here and passing it through to _addLiquidity is not ideal,\n        // but it avoids the even worse options of mutating amountsIn inside AddLiquidityParams,\n        // or cluttering the AddLiquidityParams interface by adding amountsInScaled18.\n        uint256[] memory maxAmountsInScaled18 = params.maxAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        if (poolData.poolConfigBits.shouldCallBeforeAddLiquidity()) {\n            HooksConfigLib.callBeforeAddLiquidityHook(\n                msg.sender,\n                maxAmountsInScaled18,\n                params,\n                poolData,\n                _hooksContracts[params.pool]\n            );\n            // The hook might have altered the balances, so we need to read them again to ensure that the data\n            // are fresh moving forward. We also need to upscale (adding liquidity, so round up) again.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_UP);\n\n            // Also update maxAmountsInScaled18, as the rates might have changed.\n            maxAmountsInScaled18 = params.maxAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, and the final balances\n        // are computed. This function is non-reentrant, as it performs the accounting updates.\n        //\n        // Note that poolData is mutated to update the Raw and Live balances, so they are accurate when passed\n        // into the AfterAddLiquidity hook.\n        //\n        // `amountsInScaled18` will be overwritten in the custom case, so we need to pass it back and forth to\n        // encapsulate that logic in `_addLiquidity`.\n        uint256[] memory amountsInScaled18;\n        (amountsIn, amountsInScaled18, bptAmountOut, returnData) = _addLiquidity(\n            poolData,\n            params,\n            maxAmountsInScaled18\n        );\n\n        // AmountsIn can be changed by onAfterAddLiquidity if the hook charges fees or gives discounts.\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterAddLiquidity()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountsIn = poolData.poolConfigBits.callAfterAddLiquidityHook(\n                msg.sender,\n                amountsInScaled18,\n                amountsIn,\n                bptAmountOut,\n                params,\n                poolData,\n                hooksContract\n            );\n        }\n    }\n\n    // Avoid \"stack too deep\" - without polluting the Add/RemoveLiquidity params interface.\n    struct LiquidityLocals {\n        uint256 numTokens;\n        uint256 totalFeesRaw;\n        uint256 tokenIndex;\n    }\n\n    /**\n     * @dev Calls the appropriate pool hook and calculates the required inputs and outputs for the operation\n     * considering the given kind, and updates the vault's internal accounting. This includes:\n     * - Setting pool balances\n     * - Taking debt from the liquidity provider\n     * - Minting pool tokens\n     * - Emitting events\n     *\n     * It is non-reentrant, as it performs external calls and updates the vault's state accordingly.\n     */\n    function _addLiquidity(\n        PoolData memory poolData,\n        AddLiquidityParams memory params,\n        uint256[] memory maxAmountsInScaled18\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256[] memory amountsInRaw,\n            uint256[] memory amountsInScaled18,\n            uint256 bptAmountOut,\n            bytes memory returnData\n        )\n    {\n        LiquidityLocals memory locals;\n        locals.numTokens = poolData.tokens.length;\n        uint256[] memory swapFeeAmountsScaled18;\n\n        if (params.kind == AddLiquidityKind.PROPORTIONAL) {\n            bptAmountOut = params.minBptAmountOut;\n            // Initializes the swapFeeAmountsScaled18 empty array (no swap fees on proportional add liquidity).\n            swapFeeAmountsScaled18 = new uint256[](locals.numTokens);\n\n            amountsInScaled18 = BasePoolMath.computeProportionalAmountsIn(\n                poolData.balancesLiveScaled18,\n                _totalSupply(params.pool),\n                bptAmountOut\n            );\n        } else if (params.kind == AddLiquidityKind.DONATION) {\n            poolData.poolConfigBits.requireDonationEnabled();\n\n            swapFeeAmountsScaled18 = new uint256[](maxAmountsInScaled18.length);\n            bptAmountOut = 0;\n            amountsInScaled18 = maxAmountsInScaled18;\n        } else if (params.kind == AddLiquidityKind.UNBALANCED) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n\n            amountsInScaled18 = maxAmountsInScaled18;\n            (bptAmountOut, swapFeeAmountsScaled18) = BasePoolMath.computeAddLiquidityUnbalanced(\n                poolData.balancesLiveScaled18,\n                maxAmountsInScaled18,\n                _totalSupply(params.pool),\n                poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                IBasePool(params.pool)\n            );\n        } else if (params.kind == AddLiquidityKind.SINGLE_TOKEN_EXACT_OUT) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n\n            bptAmountOut = params.minBptAmountOut;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(maxAmountsInScaled18);\n\n            amountsInScaled18 = maxAmountsInScaled18;\n            (amountsInScaled18[locals.tokenIndex], swapFeeAmountsScaled18) = BasePoolMath\n                .computeAddLiquiditySingleTokenExactOut(\n                    poolData.balancesLiveScaled18,\n                    locals.tokenIndex,\n                    bptAmountOut,\n                    _totalSupply(params.pool),\n                    poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                    IBasePool(params.pool)\n                );\n        } else if (params.kind == AddLiquidityKind.CUSTOM) {\n            poolData.poolConfigBits.requireAddCustomLiquidityEnabled();\n\n            // Uses msg.sender as the router (the contract that called the vault).\n            (amountsInScaled18, bptAmountOut, swapFeeAmountsScaled18, returnData) = IPoolLiquidity(params.pool)\n                .onAddLiquidityCustom(\n                    msg.sender,\n                    maxAmountsInScaled18,\n                    params.minBptAmountOut,\n                    poolData.balancesLiveScaled18,\n                    params.userData\n                );\n        } else {\n            revert InvalidAddLiquidityKind();\n        }\n\n        // At this point we have the calculated BPT amount.\n        if (bptAmountOut < params.minBptAmountOut) {\n            revert BptAmountOutBelowMin(bptAmountOut, params.minBptAmountOut);\n        }\n\n        _ensureValidTradeAmount(bptAmountOut);\n\n        amountsInRaw = new uint256[](locals.numTokens);\n\n        for (uint256 i = 0; i < locals.numTokens; ++i) {\n            uint256 amountInRaw;\n\n            // 1) Calculate raw amount in.\n            {\n                uint256 amountInScaled18 = amountsInScaled18[i];\n                _ensureValidTradeAmount(amountInScaled18);\n\n                // amountsInRaw are amounts actually entering the Pool, so we round up.\n                // Do not mutate in place yet, as we need them scaled for the `onAfterAddLiquidity` hook.\n                amountInRaw = amountInScaled18.toRawUndoRateRoundUp(\n                    poolData.decimalScalingFactors[i],\n                    poolData.tokenRates[i]\n                );\n\n                amountsInRaw[i] = amountInRaw;\n            }\n\n            IERC20 token = poolData.tokens[i];\n\n            // 2) Check limits for raw amounts.\n            if (amountInRaw > params.maxAmountsIn[i]) {\n                revert AmountInAboveMax(token, amountInRaw, params.maxAmountsIn[i]);\n            }\n\n            // 3) Deltas: Debit of token[i] for amountInRaw.\n            _takeDebt(token, amountInRaw);\n\n            // 4) Compute and charge protocol and creator fees.\n            locals.totalFeesRaw = _computeAndChargeAggregateSwapFees(\n                poolData,\n                swapFeeAmountsScaled18[i],\n                params.pool,\n                token,\n                i\n            );\n\n            // 5) Pool balances: raw and live.\n            // We need regular balances to complete the accounting, and the upscaled balances\n            // to use in the `after` hook later on.\n\n            // A pool's token balance increases by amounts in after adding liquidity, minus fees.\n            poolData.updateRawAndLiveBalance(\n                i,\n                poolData.balancesRaw[i] + amountInRaw - locals.totalFeesRaw,\n                Rounding.ROUND_UP\n            );\n        }\n\n        // 6) Store pool balances, raw and live.\n        _writePoolBalancesToStorage(params.pool, poolData);\n\n        // 7) BPT supply adjustment.\n        // When adding liquidity, we must mint tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        _mint(address(params.pool), params.to, bptAmountOut);\n\n        // 8) Off-chain events.\n        emit PoolBalanceChanged(params.pool, params.to, amountsInRaw.unsafeCastToInt256(true));\n    }\n\n    /***************************************************************************\n                                 Remove Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function removeLiquidity(\n        RemoveLiquidityParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        withInitializedPool(params.pool)\n        returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData)\n    {\n        // Round down when removing liquidity:\n        // If proportional, lower balances = lower proportional amountsOut, favoring the pool.\n        // If unbalanced, lower balances = lower invariant ratio without fees.\n        // bptIn = supply * (1 - ratio), so lower ratio = more bptIn, favoring the pool.\n        _ensureUnpaused(params.pool);\n\n        // `_loadPoolDataUpdatingBalancesAndYieldFees` is non-reentrant, as it updates storage as well\n        // as filling in poolData in memory. Since the swap hooks are reentrant and could do anything, including\n        // change these balances, we cannot defer settlement until `_removeLiquidity`.\n        //\n        // Sets all fields in `poolData`. Side effects: updates `_poolTokenBalances` and\n        // `_aggregateFeeAmounts in storage.\n        PoolData memory poolData = _loadPoolDataUpdatingBalancesAndYieldFees(params.pool, Rounding.ROUND_DOWN);\n        InputHelpers.ensureInputLengthMatch(poolData.tokens.length, params.minAmountsOut.length);\n\n        // Amounts are entering pool math; higher amounts would burn more BPT, so round up to favor the pool.\n        // Do not mutate minAmountsOut, so that we can directly compare the raw limits later, without potentially\n        // losing precision by scaling up and then down.\n        uint256[] memory minAmountsOutScaled18 = params.minAmountsOut.copyToScaled18ApplyRateRoundUpArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallBeforeRemoveLiquidity()) {\n            HooksConfigLib.callBeforeRemoveLiquidityHook(\n                minAmountsOutScaled18,\n                msg.sender,\n                params,\n                poolData,\n                _hooksContracts[params.pool]\n            );\n\n            // The hook might alter the balances, so we need to read them again to ensure that the data is\n            // fresh moving forward.\n            // We also need to upscale (removing liquidity, so round down) again.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[params.pool], Rounding.ROUND_DOWN);\n\n            // Also update minAmountsOutScaled18, as the rates might have changed.\n            minAmountsOutScaled18 = params.minAmountsOut.copyToScaled18ApplyRateRoundUpArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, and the final balances\n        // are computed. This function is non-reentrant, as it performs the accounting updates.\n        //\n        // Note that poolData is mutated to update the Raw and Live balances, so they are accurate when passed\n        // into the AfterRemoveLiquidity hook.\n        uint256[] memory amountsOutScaled18;\n        (bptAmountIn, amountsOut, amountsOutScaled18, returnData) = _removeLiquidity(\n            poolData,\n            params,\n            minAmountsOutScaled18\n        );\n\n        // AmountsOut can be changed by onAfterRemoveLiquidity if the hook charges fees or gives discounts.\n        // Uses msg.sender as the router (the contract that called the vault).\n        if (poolData.poolConfigBits.shouldCallAfterRemoveLiquidity()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[params.pool];\n\n            amountsOut = poolData.poolConfigBits.callAfterRemoveLiquidityHook(\n                msg.sender,\n                amountsOutScaled18,\n                amountsOut,\n                bptAmountIn,\n                params,\n                poolData,\n                hooksContract\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the appropriate pool hook and calculates the required inputs and outputs for the operation\n     * considering the given kind, and updates the vault's internal accounting. This includes:\n     * - Setting pool balances\n     * - Supplying credit to the liquidity provider\n     * - Burning pool tokens\n     * - Emitting events\n     *\n     * It is non-reentrant, as it performs external calls and updates the vault's state accordingly.\n     */\n    function _removeLiquidity(\n        PoolData memory poolData,\n        RemoveLiquidityParams memory params,\n        uint256[] memory minAmountsOutScaled18\n    )\n        internal\n        nonReentrant\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOutRaw,\n            uint256[] memory amountsOutScaled18,\n            bytes memory returnData\n        )\n    {\n        LiquidityLocals memory locals;\n        locals.numTokens = poolData.tokens.length;\n        uint256[] memory swapFeeAmountsScaled18;\n\n        if (params.kind == RemoveLiquidityKind.PROPORTIONAL) {\n            bptAmountIn = params.maxBptAmountIn;\n            swapFeeAmountsScaled18 = new uint256[](locals.numTokens);\n            amountsOutScaled18 = BasePoolMath.computeProportionalAmountsOut(\n                poolData.balancesLiveScaled18,\n                _totalSupply(params.pool),\n                bptAmountIn\n            );\n        } else if (params.kind == RemoveLiquidityKind.SINGLE_TOKEN_EXACT_IN) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n            bptAmountIn = params.maxBptAmountIn;\n            amountsOutScaled18 = minAmountsOutScaled18;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(params.minAmountsOut);\n\n            (amountsOutScaled18[locals.tokenIndex], swapFeeAmountsScaled18) = BasePoolMath\n                .computeRemoveLiquiditySingleTokenExactIn(\n                    poolData.balancesLiveScaled18,\n                    locals.tokenIndex,\n                    bptAmountIn,\n                    _totalSupply(params.pool),\n                    poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                    IBasePool(params.pool)\n                );\n        } else if (params.kind == RemoveLiquidityKind.SINGLE_TOKEN_EXACT_OUT) {\n            poolData.poolConfigBits.requireUnbalancedLiquidityEnabled();\n            amountsOutScaled18 = minAmountsOutScaled18;\n            locals.tokenIndex = InputHelpers.getSingleInputIndex(params.minAmountsOut);\n\n            (bptAmountIn, swapFeeAmountsScaled18) = BasePoolMath.computeRemoveLiquiditySingleTokenExactOut(\n                poolData.balancesLiveScaled18,\n                locals.tokenIndex,\n                amountsOutScaled18[locals.tokenIndex],\n                _totalSupply(params.pool),\n                poolData.poolConfigBits.getStaticSwapFeePercentage(),\n                IBasePool(params.pool)\n            );\n        } else if (params.kind == RemoveLiquidityKind.CUSTOM) {\n            poolData.poolConfigBits.requireRemoveCustomLiquidityEnabled();\n            // Uses msg.sender as the router (the contract that called the vault)\n            (bptAmountIn, amountsOutScaled18, swapFeeAmountsScaled18, returnData) = IPoolLiquidity(params.pool)\n                .onRemoveLiquidityCustom(\n                    msg.sender,\n                    params.maxBptAmountIn,\n                    minAmountsOutScaled18,\n                    poolData.balancesLiveScaled18,\n                    params.userData\n                );\n        } else {\n            revert InvalidRemoveLiquidityKind();\n        }\n\n        if (bptAmountIn > params.maxBptAmountIn) {\n            revert BptAmountInAboveMax(bptAmountIn, params.maxBptAmountIn);\n        }\n\n        _ensureValidTradeAmount(bptAmountIn);\n\n        amountsOutRaw = new uint256[](locals.numTokens);\n\n        for (uint256 i = 0; i < locals.numTokens; ++i) {\n            uint256 amountOutRaw;\n\n            // 1) Calculate raw amount out.\n            {\n                uint256 amountOutScaled18 = amountsOutScaled18[i];\n                _ensureValidTradeAmount(amountOutScaled18);\n\n                // amountsOut are amounts exiting the Pool, so we round down.\n                // Do not mutate in place yet, as we need them scaled for the `onAfterRemoveLiquidity` hook.\n                amountOutRaw = amountOutScaled18.toRawUndoRateRoundDown(\n                    poolData.decimalScalingFactors[i],\n                    poolData.tokenRates[i]\n                );\n            }\n\n            amountsOutRaw[i] = amountOutRaw;\n\n            IERC20 token = poolData.tokens[i];\n            // 2) Check limits for raw amounts.\n            if (amountOutRaw < params.minAmountsOut[i]) {\n                revert AmountOutBelowMin(token, amountOutRaw, params.minAmountsOut[i]);\n            }\n\n            // 3) Deltas: Credit token[i] for amountOutRaw.\n            _supplyCredit(token, amountOutRaw);\n\n            // 4) Compute and charge protocol and creator fees.\n            locals.totalFeesRaw = _computeAndChargeAggregateSwapFees(\n                poolData,\n                swapFeeAmountsScaled18[i],\n                params.pool,\n                token,\n                i\n            );\n\n            // 5) Pool balances: raw and live.\n            // We need regular balances to complete the accounting, and the upscaled balances\n            // to use in the `after` hook later on.\n\n            // A Pool's token balance always decreases after an exit\n            // (potentially by 0). Also adjust by protocol and pool creator fees.\n            poolData.updateRawAndLiveBalance(\n                i,\n                poolData.balancesRaw[i] - (amountOutRaw + locals.totalFeesRaw),\n                Rounding.ROUND_DOWN\n            );\n        }\n\n        // 6) Store pool balances, raw and live.\n        _writePoolBalancesToStorage(params.pool, poolData);\n\n        // 7) BPT supply adjustment.\n        // Uses msg.sender as the router (the contract that called the vault).\n        _spendAllowance(address(params.pool), params.from, msg.sender, bptAmountIn);\n\n        if (_isQueryContext()) {\n            // Increase `from` balance to ensure the burn function succeeds.\n            _queryModeBalanceIncrease(params.pool, params.from, bptAmountIn);\n        }\n        // When removing liquidity, we must burn tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Burning will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _burn(address(params.pool), params.from, bptAmountIn);\n\n        // 8) Off-chain events\n        emit PoolBalanceChanged(\n            params.pool,\n            params.from,\n            // We can unsafely cast to int256 because balances are stored as uint128 (see PackedTokenBalance).\n            amountsOutRaw.unsafeCastToInt256(false)\n        );\n    }\n\n    /**\n     * @dev Preconditions: poolConfigBits, decimalScalingFactors, tokenRates in `poolData`.\n     * Side effects: updates `_aggregateFeeAmounts` storage.\n     * Note that this computes the aggregate total of the protocol fees and stores it, without emitting any events.\n     * Splitting the fees and event emission occur during fee collection.\n     * Should only be called in a non-reentrant context.\n     *\n     * @return totalFeesRaw Sum of protocol and pool creator fees raw\n     */\n    function _computeAndChargeAggregateSwapFees(\n        PoolData memory poolData,\n        uint256 swapFeeAmountScaled18,\n        address pool,\n        IERC20 token,\n        uint256 index\n    ) internal returns (uint256 totalFeesRaw) {\n        uint256 aggregateSwapFeePercentage = poolData.poolConfigBits.getAggregateSwapFeePercentage();\n        // If swapFeeAmount equals zero, no need to charge anything.\n        if (\n            swapFeeAmountScaled18 > 0 &&\n            aggregateSwapFeePercentage > 0 &&\n            poolData.poolConfigBits.isPoolInRecoveryMode() == false\n        ) {\n            uint256 aggregateSwapFeeAmountScaled18 = swapFeeAmountScaled18.mulUp(aggregateSwapFeePercentage);\n\n            // Ensure we can never charge more than the total swap fee.\n            if (aggregateSwapFeeAmountScaled18 > swapFeeAmountScaled18) {\n                revert ProtocolFeesExceedTotalCollected();\n            }\n\n            totalFeesRaw = aggregateSwapFeeAmountScaled18.toRawUndoRateRoundDown(\n                poolData.decimalScalingFactors[index],\n                poolData.tokenRates[index]\n            );\n\n            // Both Swap and Yield fees are stored together in a PackedTokenBalance.\n            // We have designated \"Raw\" the derived half for Swap fee storage.\n            bytes32 currentPackedBalance = _aggregateFeeAmounts[pool][token];\n            _aggregateFeeAmounts[pool][token] = currentPackedBalance.setBalanceRaw(\n                currentPackedBalance.getBalanceRaw() + totalFeesRaw\n            );\n        }\n    }\n\n    /*******************************************************************************\n                                    Pool Information\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getPoolTokenCountAndIndexOfToken(\n        address pool,\n        IERC20 token\n    ) external view withRegisteredPool(pool) returns (uint256, uint256) {\n        IERC20[] memory poolTokens = _poolTokens[pool];\n\n        uint256 index = _findTokenIndex(poolTokens, token);\n\n        return (poolTokens.length, index);\n    }\n\n    /*******************************************************************************\n                             Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function erc4626BufferWrapOrUnwrap(\n        BufferWrapOrUnwrapParams memory params\n    )\n        external\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 amountCalculatedRaw, uint256 amountInRaw, uint256 amountOutRaw)\n    {\n        IERC20 underlyingToken = IERC20(params.wrappedToken.asset());\n\n        address bufferAsset = _bufferAssets[params.wrappedToken];\n\n        if (bufferAsset != address(0) && bufferAsset != address(underlyingToken)) {\n            // Asset was changed since the first addLiquidityToBuffer call.\n            revert WrongWrappedTokenAsset(address(params.wrappedToken));\n        }\n\n        if (params.amountGivenRaw < _MINIMUM_WRAP_AMOUNT) {\n            // If amount given is too small, rounding issues can be introduced that favors the user and can drain\n            // the buffer. _MINIMUM_WRAP_AMOUNT prevents it. Most tokens have protections against it already, this\n            // is just an extra layer of security.\n            revert WrapAmountTooSmall(address(params.wrappedToken));\n        }\n\n        if (params.direction == WrappingDirection.UNWRAP) {\n            (amountInRaw, amountOutRaw) = _unwrapWithBuffer(\n                params.kind,\n                underlyingToken,\n                params.wrappedToken,\n                params.amountGivenRaw\n            );\n            emit Unwrap(params.wrappedToken, underlyingToken, amountInRaw, amountOutRaw);\n        } else {\n            (amountInRaw, amountOutRaw) = _wrapWithBuffer(\n                params.kind,\n                underlyingToken,\n                params.wrappedToken,\n                params.amountGivenRaw\n            );\n            emit Wrap(underlyingToken, params.wrappedToken, amountInRaw, amountOutRaw);\n        }\n\n        if (params.kind == SwapKind.EXACT_IN) {\n            if (amountOutRaw < params.limitRaw) {\n                revert SwapLimit(amountOutRaw, params.limitRaw);\n            }\n            amountCalculatedRaw = amountOutRaw;\n        } else {\n            if (amountInRaw > params.limitRaw) {\n                revert SwapLimit(amountInRaw, params.limitRaw);\n            }\n            amountCalculatedRaw = amountInRaw;\n        }\n    }\n\n    /**\n     * @dev If the buffer has enough liquidity, it uses the internal ERC4626 buffer to perform the wrap\n     * operation without any external calls. If not, it wraps the assets needed to fulfill the trade + the surplus\n     * of assets in the buffer, so that the buffer is rebalanced at the end of the operation.\n     *\n     * Updates `_reservesOf` and token deltas in storage.\n     */\n    function _wrapWithBuffer(\n        SwapKind kind,\n        IERC20 underlyingToken,\n        IERC4626 wrappedToken,\n        uint256 amountGiven\n    ) private returns (uint256 amountInUnderlying, uint256 amountOutWrapped) {\n        // When wrapping and in query mode, the vault needs to have enough reserves of underlying token to do the\n        // wrap operation. If the vault does not have enough tokens to do the actual wrap, use ERC4626 preview.\n        bool isQueryContext = _isQueryContext();\n\n        if (kind == SwapKind.EXACT_IN) {\n            if (isQueryContext) {\n                return (amountGiven, wrappedToken.previewDeposit(amountGiven));\n            }\n            // EXACT_IN wrap, so AmountGiven is underlying amount.\n            (amountInUnderlying, amountOutWrapped) = (amountGiven, wrappedToken.convertToShares(amountGiven));\n        } else {\n            if (isQueryContext) {\n                return (wrappedToken.previewMint(amountGiven), amountGiven);\n            }\n            // EXACT_OUT wrap, so AmountGiven is wrapped amount.\n            (amountInUnderlying, amountOutWrapped) = (wrappedToken.convertToAssets(amountGiven), amountGiven);\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (bufferBalances.getBalanceDerived() >= amountOutWrapped) {\n            // The buffer has enough liquidity to facilitate the wrap without making an external call.\n            uint256 newDerivedBalance;\n            unchecked {\n                // We have verified above that this is safe to do unchecked.\n                newDerivedBalance = bufferBalances.getBalanceDerived() - amountOutWrapped;\n            }\n\n            bufferBalances = PackedTokenBalance.toPackedBalance(\n                bufferBalances.getBalanceRaw() + amountInUnderlying,\n                newDerivedBalance\n            );\n            _bufferTokenBalances[wrappedToken] = bufferBalances;\n        } else {\n            // The buffer does not have enough liquidity to facilitate the wrap without making an external call.\n            // We wrap the user's tokens via an external call and additionally rebalance the buffer if it has a\n            // surplus of underlying tokens.\n\n            // Gets the amount of underlying to wrap in order to rebalance the buffer.\n            uint256 bufferUnderlyingSurplus = bufferBalances.getBufferUnderlyingSurplus(wrappedToken);\n            uint256 bufferWrappedSurplus;\n\n            if (kind == SwapKind.EXACT_IN) {\n                // The amount of underlying tokens to deposit is the necessary amount to fulfill the trade\n                // (amountInUnderlying), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferUnderlyingSurplus).\n                uint256 amountToDeposit = amountInUnderlying + bufferUnderlyingSurplus;\n                underlyingToken.forceApprove(address(wrappedToken), amountToDeposit);\n                // EXACT_IN requires the exact amount of underlying tokens to be deposited, so deposit is called.\n                wrappedToken.deposit(amountToDeposit, address(this));\n            } else {\n                if (bufferUnderlyingSurplus > 0) {\n                    bufferWrappedSurplus = wrappedToken.convertToShares(bufferUnderlyingSurplus);\n                }\n\n                // The mint operation returns exactly `vaultWrappedDelta` shares. To do so, it withdraws underlying\n                // from the vault and returns the shares. So, the vault needs to approve the transfer of underlying\n                // tokens to the wrapper.\n                // Add 2 because mint can consume up to 2 wei more tokens than we anticipated.\n                underlyingToken.forceApprove(address(wrappedToken), amountInUnderlying + bufferUnderlyingSurplus + 2);\n\n                // EXACT_OUT requires the exact amount of wrapped tokens to be returned, so mint is called.\n                wrappedToken.mint(amountOutWrapped + bufferWrappedSurplus, address(this));\n\n                // Remove approval, in case mint consumed less tokens than we approved, due to convert error.\n                underlyingToken.forceApprove(address(wrappedToken), 0);\n            }\n\n            // ERC4626 output should not be trusted, so it's a good practice to measure the amount of\n            // deposited and returned tokens.\n            (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) = _updateReservesAfterWrapping(\n                underlyingToken,\n                IERC20(wrappedToken)\n            );\n\n            // Only updates buffer balances if buffer has a surplus of underlying tokens.\n            if (bufferUnderlyingSurplus > 0) {\n                if (kind == SwapKind.EXACT_IN) {\n                    // amountInUnderlying is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultUnderlyingDelta should be absorbed by the buffer.\n                    bufferUnderlyingSurplus = vaultUnderlyingDelta - amountInUnderlying;\n                    // Since bufferUnderlyingSurplus was wrapped, the final amountOut needs to discount the wrapped\n                    // amount that will stay in the buffer. Refresh `bufferWrappedSurplus` after external calls on the\n                    // wrapped token.\n                    bufferWrappedSurplus = wrappedToken.convertToShares(bufferUnderlyingSurplus);\n                    amountOutWrapped = vaultWrappedDelta - bufferWrappedSurplus;\n                } else {\n                    // If buffer has an underlying surplus, it wraps the surplus + amountIn, so the final amountIn needs\n                    // to be discounted for that.\n                    amountInUnderlying = vaultUnderlyingDelta - bufferUnderlyingSurplus;\n                    // amountOutWrapped is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultWrappedDelta should be absorbed by the buffer.\n                    bufferWrappedSurplus = vaultWrappedDelta - amountOutWrapped;\n                }\n\n                // In a wrap operation, the underlying balance of the buffer will decrease and the wrapped balance will\n                // increase. To decrease underlying balance, we get the delta amount that was deposited\n                // (vaultUnderlyingDelta) and discounts the amount needed in the wrapping operation\n                // (amountInUnderlying). Same logic applies to wrapped balances.\n                //\n                // Note: bufferUnderlyingSurplus = vaultUnderlyingDelta - amountInUnderlying\n                //       bufferWrappedSurplus = vaultWrappedDelta - amountOutWrapped\n                bufferBalances = PackedTokenBalance.toPackedBalance(\n                    bufferBalances.getBalanceRaw() - bufferUnderlyingSurplus,\n                    bufferBalances.getBalanceDerived() + bufferWrappedSurplus\n                );\n                _bufferTokenBalances[wrappedToken] = bufferBalances;\n            } else {\n                amountInUnderlying = vaultUnderlyingDelta;\n                amountOutWrapped = vaultWrappedDelta;\n            }\n        }\n\n        _takeDebt(underlyingToken, amountInUnderlying);\n        _supplyCredit(wrappedToken, amountOutWrapped);\n    }\n\n    /**\n     * @dev If the buffer has enough liquidity, it uses the internal ERC4626 buffer to perform the unwrap\n     * operation without any external calls. If not, it unwraps the assets needed to fulfill the trade + the surplus\n     * of assets in the buffer, so that the buffer is rebalanced at the end of the operation.\n     *\n     * Updates `_reservesOf` and token deltas in storage.\n     */\n    function _unwrapWithBuffer(\n        SwapKind kind,\n        IERC20 underlyingToken,\n        IERC4626 wrappedToken,\n        uint256 amountGiven\n    ) private returns (uint256 amountInWrapped, uint256 amountOutUnderlying) {\n        bool isQueryContext = _isQueryContext();\n\n        if (kind == SwapKind.EXACT_IN) {\n            if (isQueryContext) {\n                return (amountGiven, wrappedToken.previewRedeem(amountGiven));\n            }\n            // EXACT_IN unwrap, so AmountGiven is wrapped amount.\n            (amountOutUnderlying, amountInWrapped) = (wrappedToken.convertToAssets(amountGiven), amountGiven);\n        } else {\n            if (isQueryContext) {\n                return (wrappedToken.previewWithdraw(amountGiven), amountGiven);\n            }\n            // EXACT_OUT unwrap, so AmountGiven is underlying amount.\n            (amountOutUnderlying, amountInWrapped) = (amountGiven, wrappedToken.convertToShares(amountGiven));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (bufferBalances.getBalanceRaw() >= amountOutUnderlying) {\n            // The buffer has enough liquidity to facilitate the wrap without making an external call.\n            uint256 newRawBalance;\n            unchecked {\n                // We have verified above that this is safe to do unchecked.\n                newRawBalance = bufferBalances.getBalanceRaw() - amountOutUnderlying;\n            }\n            bufferBalances = PackedTokenBalance.toPackedBalance(\n                newRawBalance,\n                bufferBalances.getBalanceDerived() + amountInWrapped\n            );\n            _bufferTokenBalances[wrappedToken] = bufferBalances;\n        } else {\n            // The buffer does not have enough liquidity to facilitate the unwrap without making an external call.\n            // We unwrap the user's tokens via an external call and additionally rebalance the buffer if it has a\n            // surplus of underlying tokens.\n\n            // Gets the amount of wrapped tokens to unwrap in order to rebalance the buffer.\n            uint256 bufferWrappedSurplus = bufferBalances.getBufferWrappedSurplus(wrappedToken);\n            uint256 bufferUnderlyingSurplus;\n\n            if (kind == SwapKind.EXACT_IN) {\n                // EXACT_IN requires the exact amount of wrapped tokens to be unwrapped, so redeem is called\n                // The amount of wrapped tokens to redeem is the necessary amount to fulfill the trade\n                // (amountInWrapped), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferWrappedSurplus).\n                wrappedToken.redeem(amountInWrapped + bufferWrappedSurplus, address(this), address(this));\n            } else {\n                // EXACT_OUT requires the exact amount of underlying tokens to be returned, so withdraw is called.\n                // The amount of underlying tokens to withdraw is the necessary amount to fulfill the trade\n                // (amountOutUnderlying), plus the amount needed to leave the buffer rebalanced 50/50 at the end\n                // (bufferUnderlyingSurplus).\n                if (bufferWrappedSurplus > 0) {\n                    bufferUnderlyingSurplus = wrappedToken.convertToAssets(bufferWrappedSurplus);\n                }\n                wrappedToken.withdraw(amountOutUnderlying + bufferUnderlyingSurplus, address(this), address(this));\n            }\n\n            // ERC4626 output should not be trusted, so it's a good practice to measure the amount of\n            // deposited and returned tokens.\n            (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) = _updateReservesAfterWrapping(\n                underlyingToken,\n                IERC20(wrappedToken)\n            );\n\n            // Only updates buffer balances if buffer has a surplus of wrapped tokens.\n            if (bufferWrappedSurplus > 0) {\n                if (kind == SwapKind.EXACT_IN) {\n                    // amountInWrapped is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultWrappedDelta should be absorbed by the buffer.\n                    bufferWrappedSurplus = vaultWrappedDelta - amountInWrapped;\n                    // Since bufferWrappedSurplus was unwrapped, the final amountOut needs to discount the underlying\n                    // amount that will stay in the buffer. Refresh `bufferUnderlyingSurplus` after external calls\n                    // on the wrapped token.\n                    bufferUnderlyingSurplus = wrappedToken.convertToAssets(bufferWrappedSurplus);\n                    amountOutUnderlying = vaultUnderlyingDelta - bufferUnderlyingSurplus;\n                } else {\n                    // If buffer has a wrapped surplus, it unwraps surplus + amountIn, so the final amountIn needs to\n                    // be discounted for that.\n                    amountInWrapped = vaultWrappedDelta - bufferWrappedSurplus;\n                    // amountOutUnderlying is the amountGiven and should not be changed. Any rounding issue that occurs\n                    // in the vaultUnderlyingDelta should be absorbed by the buffer.\n                    bufferUnderlyingSurplus = vaultUnderlyingDelta - amountOutUnderlying;\n                }\n\n                // In an unwrap operation, the underlying balance of the buffer will increase and the wrapped balance\n                // will decrease. To increase the underlying balance, we get the delta amount that was withdrawn\n                // (vaultUnderlyingDelta) and discount the amount expected in the unwrapping operation\n                // (amountOutUnderlying). The same logic applies to wrapped balances.\n                //\n                // Note: bufferUnderlyingSurplus = vaultUnderlyingDelta - amountOutUnderlying\n                //       bufferWrappedSurplus = vaultWrappedDelta - amountInWrapped\n                bufferBalances = PackedTokenBalance.toPackedBalance(\n                    bufferBalances.getBalanceRaw() + bufferUnderlyingSurplus,\n                    bufferBalances.getBalanceDerived() - bufferWrappedSurplus\n                );\n                _bufferTokenBalances[wrappedToken] = bufferBalances;\n            } else {\n                amountOutUnderlying = vaultUnderlyingDelta;\n                amountInWrapped = vaultWrappedDelta;\n            }\n        }\n\n        _takeDebt(wrappedToken, amountInWrapped);\n        _supplyCredit(underlyingToken, amountOutUnderlying);\n    }\n\n    function _isQueryContext() internal view returns (bool) {\n        return EVMCallModeHelpers.isStaticCall() && _vaultStateBits.isQueryDisabled() == false;\n    }\n\n    /**\n     * @dev Updates reserves for underlying and wrapped tokens after wrap/unwrap operation:\n     * - updates `_reservesOf`\n     * - returns the delta underlying and wrapped tokens that were deposited/withdrawn from vault reserves\n     */\n    function _updateReservesAfterWrapping(\n        IERC20 underlyingToken,\n        IERC20 wrappedToken\n    ) internal returns (uint256 vaultUnderlyingDelta, uint256 vaultWrappedDelta) {\n        uint256 vaultUnderlyingBefore = _reservesOf[underlyingToken];\n        uint256 vaultUnderlyingAfter = underlyingToken.balanceOf(address(this));\n        _reservesOf[underlyingToken] = vaultUnderlyingAfter;\n\n        uint256 vaultWrappedBefore = _reservesOf[wrappedToken];\n        uint256 vaultWrappedAfter = wrappedToken.balanceOf(address(this));\n        _reservesOf[wrappedToken] = vaultWrappedAfter;\n\n        if (vaultUnderlyingBefore > vaultUnderlyingAfter) {\n            // Wrap\n            // Since deposit takes underlying tokens from the vault, the actual underlying tokens deposited is\n            // underlyingBefore - underlyingAfter\n            // checked against underflow: vaultUnderlyingBefore > vaultUnderlyingAfter in `if` clause.\n            unchecked {\n                vaultUnderlyingDelta = vaultUnderlyingBefore - vaultUnderlyingAfter;\n            }\n            // Since deposit puts wrapped tokens into the vault, the actual wrapped minted is\n            // wrappedAfter - wrappedBefore.\n            vaultWrappedDelta = vaultWrappedAfter - vaultWrappedBefore;\n        } else {\n            // Unwrap\n            // Since withdraw puts underlying tokens into the vault, the actual underlying token amount withdrawn is\n            // assetsAfter - assetsBefore.\n            // checked against underflow: vaultUnderlyingAfter > vaultUnderlyingBefore in `else` clause.\n            unchecked {\n                vaultUnderlyingDelta = vaultUnderlyingAfter - vaultUnderlyingBefore;\n            }\n            // Since withdraw takes wrapped tokens from the vault, the actual wrapped token amount burned is\n            // wrappedBefore - wrappedAfter.\n            vaultWrappedDelta = vaultWrappedBefore - vaultWrappedAfter;\n        }\n    }\n\n    // Minimum swap amount (applied to scaled18 values), enforced as a security measure to block potential\n    // exploitation of rounding errors.\n    function _ensureValidTradeAmount(uint256 tradeAmount) private pure {\n        if (tradeAmount != 0 && tradeAmount < _MINIMUM_TRADE_AMOUNT) {\n            revert TradeAmountTooSmall();\n        }\n    }\n\n    /*******************************************************************************\n                                    Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getAuthorizer() external view returns (IAuthorizer) {\n        return _authorizer;\n    }\n\n    /*******************************************************************************\n                                     Default handlers\n    *******************************************************************************/\n\n    receive() external payable {\n        revert CannotReceiveEth();\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Override proxy implementation of `fallback` to disallow incoming ETH transfers.\n     * This function actually returns whatever the Vault Extension does when handling the request.\n     */\n    fallback() external payable override {\n        if (msg.value > 0) {\n            revert CannotReceiveEth();\n        }\n\n        _fallback();\n    }\n\n    /*******************************************************************************\n                                     Miscellaneous\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultMain\n    function getVaultExtension() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Returns Vault Extension, where fallback requests are forwarded.\n     */\n    function _implementation() internal view override returns (address) {\n        return address(_vaultExtension);\n    }\n}\n",
        "VaultAdmin.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { PoolFunctionPermission, Rounding } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { Authentication } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/Authentication.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { VaultStateBits, VaultStateLib } from \"./lib/VaultStateLib.sol\";\nimport { VaultExtensionsLib } from \"./lib/VaultExtensionsLib.sol\";\nimport { PoolConfigLib, PoolConfigBits } from \"./lib/PoolConfigLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\n/**\n * @dev Bytecode extension for the Vault containing permissioned functions. Complementary to `VaultExtension`,\n * it has access to the same storage layout as the main vault.\n *\n * The functions in this contract are not meant to be called directly. They must only be called by the Vault\n * via delegate calls, so that any state modifications produced by this contract's code will actually target\n * the main Vault's state.\n *\n * The storage of this contract is in practice unused.\n */\ncontract VaultAdmin is IVaultAdmin, VaultCommon, Authentication {\n    using PackedTokenBalance for bytes32;\n    using PoolConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using VaultExtensionsLib for IVault;\n    using SafeERC20 for IERC20;\n\n    IVault private immutable _vault;\n\n    /// @dev Functions with this modifier can only be delegate-called by the vault.\n    modifier onlyVaultDelegateCall() {\n        _vault.ensureVaultDelegateCall();\n        _;\n    }\n\n    /// @dev Functions with this modifier can only be called by the pool creator.\n    modifier onlyProtocolFeeController() {\n        if (msg.sender != address(_protocolFeeController)) {\n            revert SenderNotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Validate aggregate percentage values.\n    modifier withValidPercentage(uint256 aggregatePercentage) {\n        if (aggregatePercentage > FixedPoint.ONE) {\n            revert ProtocolFeesExceedTotalCollected();\n        }\n        _;\n    }\n\n    /// @dev Use with permissioned functions that use `PoolRoleAccounts`.\n    modifier authenticateByRole(address pool) {\n        _ensureAuthenticatedByRole(pool);\n        _;\n    }\n\n    function _ensureAuthenticatedByRole(address pool) private view {\n        bytes32 actionId = getActionId(msg.sig);\n\n        PoolFunctionPermission memory roleAssignment = _poolFunctionPermissions[pool][actionId];\n\n        // If there is no role assignment, fall through and delegate to governance.\n        if (roleAssignment.account != address(0)) {\n            // If the sender matches the permissioned account, all good; just return.\n            if (msg.sender == roleAssignment.account) {\n                return;\n            }\n\n            // If it doesn't, check whether it's onlyOwner. onlyOwner means *only* the permissioned account\n            // may call the function, so revert if this is the case. Otherwise, fall through and check\n            // governance.\n            if (roleAssignment.onlyOwner) {\n                revert SenderNotAllowed();\n            }\n        }\n\n        // Delegate to governance.\n        if (_canPerform(actionId, msg.sender, pool) == false) {\n            revert SenderNotAllowed();\n        }\n    }\n\n    constructor(\n        IVault mainVault,\n        uint32 pauseWindowDuration,\n        uint32 bufferPeriodDuration\n    ) Authentication(bytes32(uint256(uint160(address(mainVault))))) {\n        if (pauseWindowDuration > _MAX_PAUSE_WINDOW_DURATION) {\n            revert VaultPauseWindowDurationTooLarge();\n        }\n        if (bufferPeriodDuration > _MAX_BUFFER_PERIOD_DURATION) {\n            revert PauseBufferPeriodDurationTooLarge();\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint32 pauseWindowEndTime = uint32(block.timestamp) + pauseWindowDuration;\n\n        _vaultPauseWindowEndTime = pauseWindowEndTime;\n        _vaultBufferPeriodDuration = bufferPeriodDuration;\n        _vaultBufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n\n        _vault = mainVault;\n    }\n\n    /*******************************************************************************\n                               Constants and immutables\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function vault() external view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getPauseWindowEndTime() external view returns (uint32) {\n        return _vaultPauseWindowEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodDuration() external view returns (uint32) {\n        return _vaultBufferPeriodDuration;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodEndTime() external view returns (uint32) {\n        return _vaultBufferPeriodEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMinimumPoolTokens() external pure returns (uint256) {\n        return _MIN_TOKENS;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMaximumPoolTokens() external pure returns (uint256) {\n        return _MAX_TOKENS;\n    }\n\n    /*******************************************************************************\n                                    Vault Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function isVaultPaused() external view onlyVaultDelegateCall returns (bool) {\n        return _isVaultPaused();\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getVaultPausedState() external view onlyVaultDelegateCall returns (bool, uint32, uint32) {\n        return (_isVaultPaused(), _vaultPauseWindowEndTime, _vaultBufferPeriodEndTime);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(false);\n    }\n\n    /**\n     * @dev The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     */\n    function _setVaultPaused(bool pausing) internal {\n        if (_isVaultPaused()) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert VaultPaused();\n            }\n\n            // The Vault can always be unpaused while it's paused.\n            // When the buffer period expires, `_isVaultPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= _vaultPauseWindowEndTime) {\n                    revert VaultPauseWindowExpired();\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert VaultNotPaused();\n            }\n        }\n\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setVaultPaused(pausing);\n        _vaultStateBits = vaultState;\n\n        emit VaultPausedStateChanged(pausing);\n    }\n\n    /*******************************************************************************\n                                     Pool Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pausePool(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpausePool(\n        address pool\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, false);\n    }\n\n    function _setPoolPaused(address pool, bool pausing) internal {\n        PoolConfigBits config = _poolConfigBits[pool];\n\n        if (_isPoolPaused(pool)) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert PoolPaused(pool);\n            }\n\n            // The pool can always be unpaused while it's paused.\n            // When the buffer period expires, `_isPoolPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= config.getPauseWindowEndTime()) {\n                    revert PoolPauseWindowExpired(pool);\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert PoolNotPaused(pool);\n            }\n        }\n\n        // Update poolConfigBits.\n        _poolConfigBits[pool] = config.setPoolPaused(pausing);\n\n        emit PoolPausedStateChanged(pool, pausing);\n    }\n\n    /*******************************************************************************\n                                        Fees\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setStaticSwapFeePercentage(\n        address pool,\n        uint256 swapFeePercentage\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        // Saving bits by not implementing a new modifier.\n        _ensureUnpaused(pool);\n        _setStaticSwapFeePercentage(pool, swapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function collectAggregateFees(address pool) public onlyVaultDelegateCall nonReentrant withRegisteredPool(pool) {\n        IERC20[] memory poolTokens = _vault.getPoolTokens(pool);\n        address feeController = address(_protocolFeeController);\n        uint256 numTokens = poolTokens.length;\n\n        uint256[] memory totalSwapFees = new uint256[](numTokens);\n        uint256[] memory totalYieldFees = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < poolTokens.length; ++i) {\n            IERC20 token = poolTokens[i];\n\n            (totalSwapFees[i], totalYieldFees[i]) = _aggregateFeeAmounts[pool][token].fromPackedBalance();\n\n            if (totalSwapFees[i] > 0 || totalYieldFees[i] > 0) {\n                // The ProtocolFeeController will pull tokens from the Vault.\n                token.forceApprove(feeController, totalSwapFees[i] + totalYieldFees[i]);\n\n                _aggregateFeeAmounts[pool][token] = 0;\n            }\n        }\n\n        _protocolFeeController.receiveAggregateFees(pool, totalSwapFees, totalYieldFees);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateSwapFeePercentage(\n        address pool,\n        uint256 newAggregateSwapFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateSwapFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateSwapFeePercentage(newAggregateSwapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateYieldFeePercentage(\n        address pool,\n        uint256 newAggregateYieldFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateYieldFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateYieldFeePercentage(newAggregateYieldFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function setProtocolFeeController(\n        IProtocolFeeController newProtocolFeeController\n    ) external onlyVaultDelegateCall authenticate nonReentrant {\n        _protocolFeeController = newProtocolFeeController;\n\n        emit ProtocolFeeControllerChanged(newProtocolFeeController);\n    }\n\n    /*******************************************************************************\n                                    Recovery Mode\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function enableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) {\n        _ensurePoolNotInRecoveryMode(pool);\n\n        // If the Vault or pool is pausable (and currently paused), this call is permissionless.\n        if (_isPoolPaused(pool) == false && _isVaultPaused() == false) {\n            // If not permissionless, authenticate with governance.\n            _authenticateCaller();\n        }\n\n        _setPoolRecoveryMode(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function disableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticate {\n        _ensurePoolInRecoveryMode(pool);\n        _setPoolRecoveryMode(pool, false);\n    }\n\n    /**\n     * @dev Reverts if the pool is in recovery mode.\n     * @param pool The pool\n     */\n    function _ensurePoolNotInRecoveryMode(address pool) internal view {\n        if (_isPoolInRecoveryMode(pool)) {\n            revert PoolInRecoveryMode(pool);\n        }\n    }\n\n    /**\n     * @dev Change the recovery mode state of a pool, and emit an event. Assumes any validation (e.g., whether\n     * the proposed state change is consistent) has already been done.\n     *\n     * @param pool The pool\n     * @param recoveryMode The desired recovery mode state\n     */\n    function _setPoolRecoveryMode(address pool, bool recoveryMode) internal {\n        // Update poolConfigBits\n        _poolConfigBits[pool] = _poolConfigBits[pool].setPoolInRecoveryMode(recoveryMode);\n\n        if (recoveryMode == false) {\n            _writePoolBalancesToStorage(pool, _loadPoolData(pool, Rounding.ROUND_DOWN));\n        }\n\n        emit PoolRecoveryModeStateChanged(pool, recoveryMode);\n    }\n\n    /*******************************************************************************\n                                        Queries\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function disableQuery() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setQueryDisabled(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /*******************************************************************************\n                                Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(false);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function addLiquidityToBuffer(\n        IERC4626 wrappedToken,\n        uint256 amountUnderlying,\n        uint256 amountWrapped,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 issuedShares)\n    {\n        address underlyingToken = wrappedToken.asset();\n\n        // Amount of shares to issue is the total underlying token that the user is depositing.\n        issuedShares = wrappedToken.convertToAssets(amountWrapped) + amountUnderlying;\n\n        if (_bufferAssets[wrappedToken] == address(0)) {\n            // Buffer is not initialized yet, so we initialize it.\n\n            // Register asset of wrapper, so it cannot change.\n            _bufferAssets[wrappedToken] = underlyingToken;\n\n            // Burn MINIMUM_TOTAL_SUPPLY shares, so the buffer can never go back to zero liquidity\n            // (avoids rounding issues with low liquidity).\n            _bufferTotalShares[wrappedToken] = _MINIMUM_TOTAL_SUPPLY;\n            issuedShares -= _MINIMUM_TOTAL_SUPPLY;\n        } else if (_bufferAssets[wrappedToken] != underlyingToken) {\n            // Asset was changed since the first bufferAddLiquidity call.\n            revert WrongWrappedTokenAsset(address(wrappedToken));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        // Adds the issued shares to the total shares of the liquidity pool.\n        _bufferLpShares[wrappedToken][sharesOwner] += issuedShares;\n        _bufferTotalShares[wrappedToken] += issuedShares;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() + amountUnderlying,\n            bufferBalances.getBalanceDerived() + amountWrapped\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _takeDebt(IERC20(underlyingToken), amountUnderlying);\n        _takeDebt(wrappedToken, amountWrapped);\n\n        emit LiquidityAddedToBuffer(wrappedToken, sharesOwner, amountWrapped, amountUnderlying, issuedShares);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function removeLiquidityFromBuffer(\n        IERC4626 wrappedToken,\n        uint256 sharesToRemove,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        authenticate\n        nonReentrant\n        returns (uint256 removedUnderlyingBalance, uint256 removedWrappedBalance)\n    {\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (sharesToRemove > _bufferLpShares[wrappedToken][sharesOwner]) {\n            revert NotEnoughBufferShares();\n        }\n        uint256 totalShares = _bufferTotalShares[wrappedToken];\n\n        removedUnderlyingBalance = (bufferBalances.getBalanceRaw() * sharesToRemove) / totalShares;\n        removedWrappedBalance = (bufferBalances.getBalanceDerived() * sharesToRemove) / totalShares;\n\n        _bufferLpShares[wrappedToken][sharesOwner] -= sharesToRemove;\n        _bufferTotalShares[wrappedToken] -= sharesToRemove;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() - removedUnderlyingBalance,\n            bufferBalances.getBalanceDerived() - removedWrappedBalance\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _supplyCredit(IERC20(_bufferAssets[wrappedToken]), removedUnderlyingBalance);\n        _supplyCredit(wrappedToken, removedWrappedBalance);\n\n        emit LiquidityRemovedFromBuffer(\n            wrappedToken,\n            sharesOwner,\n            removedWrappedBalance,\n            removedUnderlyingBalance,\n            sharesToRemove\n        );\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferOwnerShares(\n        IERC4626 token,\n        address user\n    ) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferLpShares[token][user];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferTotalShares(IERC4626 token) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferTotalShares[token];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferBalance(IERC4626 token) external view onlyVaultDelegateCall returns (uint256, uint256) {\n        // The first balance is underlying, and the last is wrapped balance.\n        return (_bufferTokenBalances[token].getBalanceRaw(), _bufferTokenBalances[token].getBalanceDerived());\n    }\n\n    /*******************************************************************************\n                                Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setAuthorizer(IAuthorizer newAuthorizer) external onlyVaultDelegateCall authenticate {\n        _authorizer = newAuthorizer;\n\n        emit AuthorizerChanged(newAuthorizer);\n    }\n\n    /// @dev Access control is delegated to the Authorizer.\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\n        return _authorizer.canPerform(actionId, user, address(this));\n    }\n\n    /// @dev Access control is delegated to the Authorizer. `where` refers to the target contract.\n    function _canPerform(bytes32 actionId, address user, address where) internal view returns (bool) {\n        return _authorizer.canPerform(actionId, user, where);\n    }\n}\n"
    }
}