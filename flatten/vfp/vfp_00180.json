{
    "vfp_id": "vfp_00180",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Naming Suggestions",
            "description": "Several functions have misleading or inconsistent names. For example, `performBatchTransfer` should be renamed to `processBatchTransfer` for consistency with `processTransfer`, and `_buildIdsAndAmounts` should reflect its additional validation logic in its name. These issues stem from inconsistent naming conventions and lack of semantic clarity. Poor naming reduces code readability and increases the cognitive load on developers, making it harder to understand function behavior. The impact is reduced maintainability and increased risk of misuse or bugs during future development.\n",
            "severity": "Low",
            "location": [
                "ComponentLib.sol::performBatchTransfer#69",
                "ComponentLib.sol::_buildIdsAndAmounts#215"
            ],
            "files": [
                "the-compact/src/lib/ComponentLib.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Custom Errors in `require` Statements",
            "description": "The codebase uses `if-revert` patterns in several locations instead of the more gas-efficient and concise `require` statements with custom errors, despite Solidity 0.8.27 supporting this feature. Examples include checks in `BenchmarkERC20.sol` and `ComponentLib.sol`. This results in higher gas costs and less readable code. Using `require` with custom errors would reduce bytecode size and improve user experience by providing clearer error messages. While not a direct security vulnerability, it represents a missed optimization opportunity that affects both cost and maintainability.\n",
            "severity": "Informational",
            "location": [
                "BenchmarkERC20.sol#55-57",
                "ComponentLib.sol#221-223",
                "ComponentLib.sol#328-330",
                "EmissaryLib.sol#146-148",
                "EmissaryLib.sol#168-170",
                "EmissaryLib.sol#187-189"
            ],
            "files": [
                "the-compact/src/lib/BenchmarkERC20.sol",
                "the-compact/src/lib/ComponentLib.sol"
            ]
        }
    ],
    "affected_files": {
        "ComponentLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\nimport { TransferComponent, Component, ComponentsById, BatchClaimComponent } from \"../types/Components.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { EventLib } from \"./EventLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { TransferLib } from \"./TransferLib.sol\";\n\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\n\n/**\n * @title ComponentLib\n * @notice Library contract implementing internal functions with helper logic for\n * processing claims including those with batch components.\n * @dev IMPORTANT NOTE: logic for processing claims assumes that the utilized structs are\n * formatted in a very specific manner — if parameters are rearranged or new parameters\n * are inserted, much of this functionality will break. Proceed with caution when making\n * any changes.\n */\nlibrary ComponentLib {\n    using TransferLib for address;\n    using ComponentLib for Component[];\n    using EfficiencyLib for bool;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for bytes32;\n    using EventLib for address;\n    using HashLib for uint256;\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using ValidityLib for uint256;\n    using ValidityLib for uint96;\n    using ValidityLib for bytes32;\n    using RegistrationLib for address;\n    using FixedPointMathLib for uint256;\n\n    error Overflow();\n    error NoIdsAndAmountsProvided();\n\n    /**\n     * @notice Internal function for performing a set of transfers or withdrawals.\n     * Executes the transfer or withdrawal operation targeting multiple recipients from\n     * a single resource lock.\n     * @param transfer  An AllocatedTransfer struct containing transfer details.\n     * @return          Whether the transfer was successfully processed.\n     */\n    function processTransfer(AllocatedTransfer calldata transfer) internal returns (bool) {\n        // Process the transfer for each component.\n        _processTransferComponents(transfer.recipients, transfer.id);\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function for performing a set of batch transfers or withdrawals.\n     * Executes the transfer or withdrawal operation for multiple recipients from multiple\n     * resource locks.\n     * @param transfer  An AllocatedBatchTransfer struct containing batch transfer details.\n     */\n    function performBatchTransfer(AllocatedBatchTransfer calldata transfer) internal {\n        // Navigate to the batch components array in calldata.\n        ComponentsById[] calldata transfers = transfer.transfers;\n\n        // Retrieve the total number of components.\n        uint256 totalIds = transfers.length;\n\n        unchecked {\n            // Iterate over each component in calldata.\n            for (uint256 i = 0; i < totalIds; ++i) {\n                // Navigate to location of the component in calldata.\n                ComponentsById calldata component = transfers[i];\n\n                // Process transfer for each component in the set.\n                _processTransferComponents(component.portions, component.id);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for processing claims with potentially exogenous sponsor\n     * signatures. Extracts claim parameters from calldata, validates the claim, validates\n     * the scope, and executes either releases of ERC6909 tokens or withdrawals of underlying\n     * tokens to multiple recipients.\n     * @param messageHash              The EIP-712 hash of the claim message.\n     * @param calldataPointer          Pointer to the location of the associated struct in calldata.\n     * @param offsetToId               Offset to segment of calldata where relevant claim parameters begin.\n     * @param sponsorDomainSeparator   The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param typehash                 The EIP-712 typehash used for the claim message.\n     * @param domainSeparator          The local domain separator.\n     * @param validation               Function pointer to the _validate function.\n     */\n    function processClaimWithComponents(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        uint256 offsetToId,\n        bytes32 sponsorDomainSeparator,\n        bytes32 typehash,\n        bytes32 domainSeparator,\n        function(bytes32, uint96, uint256, bytes32, bytes32, bytes32, uint256[2][] memory, uint256) internal returns (address)\n            validation\n    ) internal {\n        // Declare variables for parameters that will be extracted from calldata.\n        uint256 id;\n        uint256 allocatedAmount;\n        Component[] calldata components;\n\n        assembly (\"memory-safe\") {\n            // Calculate pointer to claim parameters using provided offset.\n            let calldataPointerWithOffset := add(calldataPointer, offsetToId)\n\n            // Extract resource lock id and allocated amount.\n            id := calldataload(calldataPointerWithOffset)\n            allocatedAmount := calldataload(add(calldataPointerWithOffset, 0x20))\n\n            // Extract array of components containing claimant addresses and amounts.\n            let componentsPtr := add(calldataPointer, calldataload(add(calldataPointerWithOffset, 0x40)))\n            components.offset := add(0x20, componentsPtr)\n            components.length := calldataload(componentsPtr)\n        }\n\n        // Initialize idsAndAmounts array.\n        uint256[2][] memory idsAndAmounts = new uint256[2][](1);\n        idsAndAmounts[0] = [id, allocatedAmount];\n\n        // Validate the claim and extract the sponsor address.\n        address sponsor = validation(\n            messageHash,\n            id.toAllocatorId(),\n            calldataPointer,\n            domainSeparator,\n            sponsorDomainSeparator,\n            typehash,\n            idsAndAmounts,\n            id.toResetPeriod().toSeconds()\n        );\n\n        // Verify the resource lock scope is compatible with the provided domain separator.\n        sponsorDomainSeparator.ensureValidScope(id);\n\n        // Process each component, verifying total amount and executing operations.\n        components.verifyAndProcessComponents(sponsor, id, allocatedAmount);\n    }\n\n    /**\n     * @notice Internal function for processing qualified batch claims with potentially\n     * exogenous sponsor signatures. Extracts batch claim parameters from calldata,\n     * validates the claim, and executes operations for each resource lock. Uses optimized\n     * validation of allocator consistency and scopes, with explicit validation on failure to\n     * identify specific issues. Each resource lock can be split among multiple recipients.\n     * @param messageHash              The EIP-712 hash of the claim message.\n     * @param calldataPointer          Pointer to the location of the associated struct in calldata.\n     * @param offsetToId               Offset to segment of calldata where relevant claim parameters begin.\n     * @param sponsorDomainSeparator   The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param typehash                 The EIP-712 typehash used for the claim message.\n     * @param domainSeparator          The local domain separator.\n     * @param validation               Function pointer to the _validate function.\n     */\n    function processClaimWithBatchComponents(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        uint256 offsetToId,\n        bytes32 sponsorDomainSeparator,\n        bytes32 typehash,\n        bytes32 domainSeparator,\n        function(bytes32, uint96, uint256, bytes32, bytes32, bytes32, uint256[2][] memory, uint256) internal returns (address)\n            validation\n    ) internal {\n        // Declare variable for BatchClaimComponent array that will be extracted from calldata.\n        BatchClaimComponent[] calldata claims;\n        assembly (\"memory-safe\") {\n            // Extract array of batch claim components.\n            let claimsPtr := add(calldataPointer, calldataload(add(calldataPointer, offsetToId)))\n            claims.offset := add(0x20, claimsPtr)\n            claims.length := calldataload(claimsPtr)\n        }\n\n        // Parse into idsAndAmounts & extract shortest reset period & first allocatorId.\n        (uint256[2][] memory idsAndAmounts, uint96 firstAllocatorId, uint256 shortestResetPeriod) =\n            _buildIdsAndAmounts(claims, sponsorDomainSeparator);\n\n        // Validate the claim and extract the sponsor address.\n        address sponsor = validation(\n            messageHash,\n            firstAllocatorId,\n            calldataPointer,\n            domainSeparator,\n            sponsorDomainSeparator,\n            typehash,\n            idsAndAmounts,\n            shortestResetPeriod.asResetPeriod().toSeconds()\n        );\n\n        unchecked {\n            // Process each claim component.\n            for (uint256 i = 0; i < idsAndAmounts.length; ++i) {\n                BatchClaimComponent calldata claimComponent = claims[i];\n\n                // Process each component, verifying total amount and executing operations.\n                claimComponent.portions.verifyAndProcessComponents(\n                    sponsor, claimComponent.id, claimComponent.allocatedAmount\n                );\n            }\n        }\n    }\n\n    function _buildIdsAndAmounts(BatchClaimComponent[] calldata claims, bytes32 sponsorDomainSeparator)\n        internal\n        pure\n        returns (uint256[2][] memory idsAndAmounts, uint96 firstAllocatorId, uint256 shortestResetPeriod)\n    {\n        uint256 totalClaims = claims.length;\n        if (totalClaims == 0) {\n            revert NoIdsAndAmountsProvided();\n        }\n\n        // Extract allocator id and amount from first claim for validation.\n        BatchClaimComponent calldata claimComponent = claims[0];\n        uint256 id = claimComponent.id;\n        firstAllocatorId = id.toAllocatorId();\n        shortestResetPeriod = id.toResetPeriod().asUint256();\n\n        // Initialize idsAndAmounts array and register the first element.\n        idsAndAmounts = new uint256[2][](totalClaims);\n        idsAndAmounts[0] = [id, claimComponent.allocatedAmount];\n\n        // Initialize error tracking variable.\n        uint256 errorBuffer = id.scopeNotMultichain(sponsorDomainSeparator).asUint256();\n\n        unchecked {\n            // Register each additional element & accumulate potential errors.\n            for (uint256 i = 1; i < totalClaims; ++i) {\n                claimComponent = claims[i];\n                id = claimComponent.id;\n\n                shortestResetPeriod = shortestResetPeriod.min(id.toResetPeriod().asUint256());\n\n                errorBuffer |= (id.toAllocatorId() != firstAllocatorId).or(\n                    id.scopeNotMultichain(sponsorDomainSeparator)\n                ).asUint256();\n\n                // Include the id and amount in idsAndAmounts.\n                idsAndAmounts[i] = [id, claimComponent.allocatedAmount];\n            }\n\n            // Revert if any errors occurred.\n            _revertWithInvalidBatchAllocationIfError(errorBuffer);\n        }\n    }\n\n    /**\n     * @notice Internal function for verifying and processing components. Ensures that the\n     * sum of amounts doesn't exceed the allocated amount, checks for arithmetic overflow,\n     * and executes the specified operation for each recipient. Reverts if the total claimed\n     * amount exceeds the allocation or if arithmetic overflow occurs during summation.\n     * @param claimants       Array of components specifying recipients and their amounts.\n     * @param sponsor         The address of the claim sponsor.\n     * @param id              The ERC6909 token identifier of the resource lock.\n     * @param allocatedAmount The total amount allocated for this claim.\n     */\n    function verifyAndProcessComponents(\n        Component[] calldata claimants,\n        address sponsor,\n        uint256 id,\n        uint256 allocatedAmount\n    ) internal {\n        // Initialize tracking variables.\n        uint256 totalClaims = claimants.length;\n        uint256 spentAmount = 0;\n        uint256 errorBuffer = (totalClaims == 0).asUint256();\n\n        unchecked {\n            // Process each component while tracking total amount and checking for overflow.\n            for (uint256 i = 0; i < totalClaims; ++i) {\n                Component calldata component = claimants[i];\n                uint256 amount = component.amount;\n\n                // Track total amount claimed, checking for overflow.\n                uint256 updatedSpentAmount = amount + spentAmount;\n                errorBuffer |= (updatedSpentAmount < spentAmount).asUint256();\n                spentAmount = updatedSpentAmount;\n\n                sponsor.performOperation(id, component.claimant, amount);\n            }\n        }\n\n        // Revert if an overflow occurred or if total claimed amount exceeds allocation.\n        errorBuffer |= (allocatedAmount < spentAmount).asUint256();\n        assembly (\"memory-safe\") {\n            if errorBuffer {\n                // revert AllocatedAmountExceeded(allocatedAmount, amount);\n                mstore(0, 0x3078b2f6)\n                mstore(0x20, allocatedAmount)\n                mstore(0x40, spentAmount)\n                revert(0x1c, 0x44)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function for summing all amounts in a Component array.\n     * @param recipients A Component struct array containing transfer details.\n     * @return sum Total amount across all components.\n     */\n    function aggregate(Component[] calldata recipients) internal pure returns (uint256 sum) {\n        // Retrieve the total number of components.\n        uint256 totalComponents = recipients.length;\n\n        uint256 errorBuffer;\n        uint256 amount;\n        unchecked {\n            // Iterate over each additional component in calldata.\n            for (uint256 i = 0; i < totalComponents; ++i) {\n                amount = recipients[i].amount;\n                sum += amount;\n                errorBuffer |= (sum < amount).asUint256();\n            }\n        }\n\n        if (errorBuffer.asBool()) {\n            revert Overflow();\n        }\n    }\n\n    /**\n     * @notice Private function for performing a set of transfers or withdrawals\n     * given an array of components and an ID for an associated resource lock.\n     * Executes the transfer or withdrawal operation targeting multiple recipients.\n     * @param recipients A Component struct array containing transfer details.\n     * @param id         The ERC6909 token identifier of the resource lock.\n     */\n    function _processTransferComponents(Component[] calldata recipients, uint256 id) private {\n        // Retrieve the total number of components.\n        uint256 totalComponents = recipients.length;\n\n        unchecked {\n            // Iterate over each additional component in calldata.\n            for (uint256 i = 0; i < totalComponents; ++i) {\n                // Navigate to location of the component in calldata.\n                Component calldata component = recipients[i];\n\n                // Perform the transfer or withdrawal for the portion.\n                msg.sender.performOperation(id, component.claimant, component.amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Private pure function that reverts with an InvalidBatchAllocation error\n     * if an error buffer is nonzero.\n     * @param errorBuffer The error buffer to check.\n     */\n    function _revertWithInvalidBatchAllocationIfError(uint256 errorBuffer) private pure {\n        // Revert if any errors occurred.\n        assembly (\"memory-safe\") {\n            if errorBuffer {\n                // revert InvalidBatchAllocation()\n                mstore(0, 0x3a03d3bb)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n",
        "BenchmarkERC20.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ERC20 } from \"solady/tokens/ERC20.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\n\n/**\n * @title BenchmarkERC20\n * @notice Contract implementing a simple ERC20 token used for benchmarking purposes.\n * The deployer receives the maximum possible token supply and has exclusive rights\n * to burn tokens from any address.\n */\ncontract BenchmarkERC20 is ERC20 {\n    using EfficiencyLib for bool;\n\n    address private immutable deployer;\n\n    /**\n     * @notice Error thrown when a non-deployer address attempts to burn tokens or\n     * when the target for the token burn is the deployer address.\n     */\n    error InvalidBurn();\n\n    /**\n     * @notice Returns the name of the token.\n     * @return The name of the token as a string.\n     */\n    function name() public view virtual override returns (string memory) {\n        return \"Benchmark ERC20\";\n    }\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return The symbol of the token as a string.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return \"BENCHMARK_ERC20\";\n    }\n\n    /**\n     * @notice Constructor that sets the deployer address and mints the maximum\n     * possible token supply to the deployer.\n     */\n    constructor() {\n        deployer = msg.sender;\n\n        _mint(deployer, type(uint256).max);\n    }\n\n    /**\n     * @notice Burns all tokens from a target address. Can only be called by the deployer.\n     * @param target The address from which to burn all tokens.\n     */\n    function burn(address target) external {\n        if ((msg.sender != deployer).or(target == deployer)) {\n            revert InvalidBurn();\n        }\n\n        _burn(target, balanceOf(target));\n    }\n}\n"
    }
}