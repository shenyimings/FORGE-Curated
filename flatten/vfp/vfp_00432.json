{
    "vfp_id": "vfp_00432",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Safe setup may emit outdated information",
            "description": "The Safe.setup function emits the SafeSetup event after calling setupModules, which performs an arbitrary delegatecall that may modify the contract's state. However, the event uses local variables (_owners, _threshold, etc.) that were captured before the delegatecall, meaning the emitted event data may not reflect the actual final state of the contract after module initialization. This discrepancy can mislead off-chain indexing services or monitoring tools that rely on event data for state reconstruction. The root cause is the incorrect ordering of event emission relative to state-modifying external calls. An attacker or malicious module could exploit this by manipulating state post-event to create a divergence between observed and actual state. The impact is a warning due to potential data inconsistency in event logs, though it does not directly compromise fund safety or access control.\n",
            "severity": "Informational",
            "location": [
                "Safe.sol::setup#98-105"
            ],
            "files": [
                "safe-smart-account/contracts/Safe.sol"
            ]
        }
    ],
    "affected_files": {
        "Safe.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {FallbackManager} from \"./base/FallbackManager.sol\";\nimport {ITransactionGuard, GuardManager} from \"./base/GuardManager.sol\";\nimport {ModuleManager} from \"./base/ModuleManager.sol\";\nimport {OwnerManager} from \"./base/OwnerManager.sol\";\nimport {NativeCurrencyPaymentFallback} from \"./common/NativeCurrencyPaymentFallback.sol\";\nimport {SecuredTokenTransfer} from \"./common/SecuredTokenTransfer.sol\";\nimport {SignatureDecoder} from \"./common/SignatureDecoder.sol\";\nimport {Singleton} from \"./common/Singleton.sol\";\nimport {StorageAccessible} from \"./common/StorageAccessible.sol\";\nimport {SafeMath} from \"./external/SafeMath.sol\";\nimport {ISafe} from \"./interfaces/ISafe.sol\";\nimport {ISignatureValidator, ISignatureValidatorConstants} from \"./interfaces/ISignatureValidator.sol\";\nimport {Enum} from \"./libraries/Enum.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guards: Guards are contracts that can execute pre- and post- transaction checks. There are two types of guards:\n *          1. Transaction Guard: managed in `GuardManager` for transactions executed with `execTransaction`.\n *          2. Module Guard: managed in `ModuleManager` for transactions executed with `execTransactionFromModule`\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional functionality for Safe. Managed in `FallbackManager`. Please read the security risks in the `IFallbackManager` interface.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    GuardManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    ISafe\n{\n    using SafeMath for uint256;\n\n    string public constant override VERSION = \"1.5.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    uint256 public override nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public override signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public override approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external override {\n        // setupOwners checks if the Threshold is already set, therefore preventing this method from being called more than once\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable override returns (bool success) {\n        onBeforeExecTransaction(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            txHash = getTransactionHash( // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                // We use the post-increment here, so the current nonce value is used and incremented afterwards.\n                nonce++\n            );\n            checkSignatures(msg.sender, txHash, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                ITransactionGuard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not sent along with a call to counteract potential shortings because of EIP-150\n        // We use `<< 6` instead of `* 64` as SHR / SHL opcode only uses 3 gas, while DIV / MUL opcode uses 5 gas.\n        if (gasleft() < ((safeTxGas << 6) / 63).max(safeTxGas + 2500) + 500) revertWithError(\"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only subtract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            if (!success && safeTxGas == 0 && gasPrice == 0) {\n                /* solhint-disable no-inline-assembly */\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n                /* solhint-enable no-inline-assembly */\n            }\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                ITransactionGuard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For native tokens, we will only adjust the gas price to not be higher than the actually used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool refundSuccess, ) = receiver.call{value: payment}(\"\");\n            if (!refundSuccess) revertWithError(\"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            if (!transferToken(gasToken, receiver, payment)) revertWithError(\"GS012\");\n        }\n    }\n\n    /**\n     * @notice Checks whether the contract signature is valid. Reverts otherwise.\n     * @dev This is extracted to a separate function for better compatibility with Certora's prover.\n     *      More info here: https://github.com/safe-global/safe-smart-account/pull/661\n     * @param owner Address of the owner used to sign the message\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     * @param offset Offset to the start of the contract signature in the signatures byte array\n     */\n    function checkContractSignature(address owner, bytes32 dataHash, bytes memory signatures, uint256 offset) internal view {\n        // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n        if (offset.add(32) > signatures.length) revertWithError(\"GS022\");\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n        uint256 contractSignatureLen;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, offset), 0x20))\n        }\n        /* solhint-enable no-inline-assembly */\n        if (offset.add(32).add(contractSignatureLen) > signatures.length) revertWithError(\"GS023\");\n\n        // Check signature\n        bytes memory contractSignature;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n            contractSignature := add(add(signatures, offset), 0x20)\n        }\n        /* solhint-enable no-inline-assembly */\n\n        if (ISignatureValidator(owner).isValidSignature(dataHash, contractSignature) != EIP1271_MAGIC_VALUE) revertWithError(\"GS024\");\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function checkSignatures(address executor, bytes32 dataHash, bytes memory signatures) public view override {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        if (_threshold == 0) revertWithError(\"GS001\");\n        checkNSignatures(executor, dataHash, signatures, _threshold);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function checkNSignatures(\n        address executor,\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view override {\n        // Check that the provided signature data is not too short\n        if (signatures.length < requiredSignatures.mul(65)) revertWithError(\"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 v; // Implicit conversion from uint8 to uint256 will be done for v received from signatureSplit(...).\n        bytes32 r;\n        // NOTE: We do not enforce the `s` to be from the lower half of the curve\n        // This essentially means that for every signature, there's another valid signature (known as ECDSA malleability)\n        // Since we have other mechanisms to prevent duplicated signatures (ordered owners array) and replay protection (nonce),\n        // we can safely ignore this malleability.\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; ++i) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are sent.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                if (uint256(s) < requiredSignatures.mul(65)) revertWithError(\"GS021\");\n\n                // The contract signature check is extracted to a separate function for better compatibility with formal verification\n                // A quote from the Certora team:\n                // \"The assembly code broke the pointer analysis, which switched the prover in failsafe mode, where it is (a) much slower and (b) computes different hashes than in the normal mode.\"\n                // More info here: https://github.com/safe-global/safe-smart-account/pull/661\n                checkContractSignature(currentOwner, dataHash, signatures, uint256(s));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                if (executor != currentOwner && approvedHashes[currentOwner][dataHash] == 0) revertWithError(\"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), uint8(v - 4), r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, uint8(v), r, s);\n            }\n            if (currentOwner <= lastOwner || owners[currentOwner] == address(0) || currentOwner == SENTINEL_OWNERS)\n                revertWithError(\"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided hash. Reverts otherwise.\n     *         The `data` parameter is completely ignored during signature verification.\n     * @dev This function is provided for compatibility with previous versions.\n     *      Use `checkSignatures(address,bytes32,bytes)` instead.\n     *      ⚠️⚠️⚠️ If the caller is an owner of the Safe, it can trivially sign any hash with a pre-approve signature and may reduce the threshold of the signature by 1. ⚠️⚠️⚠️\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash).\n     * @param data **IGNORED** The data pre-image.\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 dataHash, bytes calldata data, bytes memory signatures) external view {\n        data;\n        checkSignatures(msg.sender, dataHash, signatures);\n    }\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided hash. Reverts otherwise.\n     *         The `data` parameter is completely ignored during signature verification.\n     * @dev This function is provided for compatibility with previous versions.\n     *      Use `checkNSignatures(address,bytes32,bytes,uint256)` instead.\n     *      ⚠️⚠️⚠️ If the caller is an owner of the Safe, it can trivially sign any hash with a pre-approve signature and may reduce the threshold of the signature by 1. ⚠️⚠️⚠️\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data **IGNORED** The data pre-image.\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(bytes32 dataHash, bytes calldata data, bytes memory signatures, uint256 requiredSignatures) external view {\n        data;\n        checkNSignatures(msg.sender, dataHash, signatures, requiredSignatures);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function approveHash(bytes32 hashToApprove) external override {\n        if (owners[msg.sender] == address(0)) revertWithError(\"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function domainSeparator() public view override returns (bytes32) {\n        uint256 chainId;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            chainId := chainid()\n        }\n        /* solhint-enable no-inline-assembly */\n\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view override returns (bytes32 txHash) {\n        bytes32 domainHash = domainSeparator();\n\n        // We opted for using assembly code here, because the way Solidity compiler we use (0.7.6) allocates memory is\n        // inefficient. We do not need to allocate memory for temporary variables to be used in the keccak256 call.\n        //\n        // WARNING: We do not clean potential dirty bits in types that are less than 256 bits (addresses and Enum.Operation)\n        // The solidity assembly types that are smaller than 256 bit can have dirty high bits according to the spec (see the Warning in https://docs.soliditylang.org/en/latest/assembly.html#access-to-external-variables-functions-and-libraries).\n        // However, we read most of the data from calldata, where the variables are not packed, and the only variable we read from storage is uint256 nonce.\n        // This is not a problem, however, we must consider this for potential future changes.\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get the free memory pointer\n            let ptr := mload(0x40)\n\n            // Step 1: Hash the transaction data\n            // Copy transaction data to memory and hash it\n            calldatacopy(ptr, data.offset, data.length)\n            let calldataHash := keccak256(ptr, data.length)\n\n            // Step 2: Prepare the SafeTX struct for hashing\n            // Layout in memory:\n            // ptr +   0: SAFE_TX_TYPEHASH (constant defining the struct hash)\n            // ptr +  32: to address\n            // ptr +  64: value\n            // ptr +  96: calldataHash\n            // ptr + 128: operation\n            // ptr + 160: safeTxGas\n            // ptr + 192: baseGas\n            // ptr + 224: gasPrice\n            // ptr + 256: gasToken\n            // ptr + 288: refundReceiver\n            // ptr + 320: nonce\n            mstore(ptr, SAFE_TX_TYPEHASH)\n            mstore(add(ptr, 32), to)\n            mstore(add(ptr, 64), value)\n            mstore(add(ptr, 96), calldataHash)\n            mstore(add(ptr, 128), operation)\n            mstore(add(ptr, 160), safeTxGas)\n            mstore(add(ptr, 192), baseGas)\n            mstore(add(ptr, 224), gasPrice)\n            mstore(add(ptr, 256), gasToken)\n            mstore(add(ptr, 288), refundReceiver)\n            mstore(add(ptr, 320), _nonce)\n\n            // Step 3: Calculate the final EIP-712 hash\n            // First, hash the SafeTX struct (352 bytes total length)\n            mstore(add(ptr, 64), keccak256(ptr, 352))\n            // Store the EIP-712 prefix (0x1901), note that integers are left-padded\n            // so the EIP-712 encoded data starts at add(ptr, 30)\n            mstore(ptr, 0x1901)\n            // Store the domain separator\n            mstore(add(ptr, 32), domainHash)\n            // Calculate the hash\n            txHash := keccak256(add(ptr, 30), 66)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @notice A hook that gets called before execution of {execTransaction} method.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function onBeforeExecTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) internal virtual {}\n}\n"
    }
}