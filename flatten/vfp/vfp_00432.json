{
    "vfp_id": "vfp_00432",
    "project_name": "ChainSecurity_Steakhouse_Box_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Stale Total Assets Value During Flash Operation",
            "description": "The vulnerability arises because during a flash operation, the Net Asset Value (NAV) is cached to prevent read-only reentrancy, and totalAssets() returns this cached value. However, this cached value is not updated during deposit(), mint(), withdraw(), or redeem() operations that may be called during the flash callback. If two such functions are called during a single flash operation, the second call will operate on an outdated totalAssets value. An attacker can exploit this by initiating a flash loan, calling withdraw() twice during the callback: the first call uses the correct cached value, but the cached NAV is not updated; the second call then uses the stale NAV, allowing withdrawal at an inflated price. This enables a liquidity provider (LP) of one VaultV2 to steal liquidity from another VaultV2 sharing the same Box. Although not immediately profitable, the attack can be repeated and is most likely during winddown, though it can also be triggered during normal operations by a malicious allocator.\n",
            "severity": "High",
            "location": [
                "Box.sol::flash",
                "VaultV2.sol::forceDeallocate"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Funds Can Be Locked in FundingAave During Winddown",
            "description": "This vulnerability occurs when the Box has an open debt position on Aave during winddown. The Box.repay() function allows repayAmount to exceed the actual debt, but AaveV3 caps the repayment to the debt amount, leaving the excess funds stuck in the FundingAave module. During winddown, an attacker can exploit this by swapping the underlying asset into the debt token in multiple transactions equal to the debt size, then calling Box.repay() with the full contract balance in the debt token—exceeding the debt. The excess amount remains locked in FundingAave. Even without winddown, allocators could accidentally or maliciously cause fund loss by over-repaying. The issue stems from inconsistent handling between Morpho (which reverts on over-repayment) and Aave (which silently caps), combined with winddown logic that doesn't account for existing debt tokens in the Box.\n",
            "severity": "High",
            "location": [
                "Box.sol::repay",
                "FundingAave.sol"
            ],
            "files": [
                "box/src/Box.sol",
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Read-only Reentrancy",
            "description": "The swapping functions allocate(), deallocate(), and reallocate() accept an arbitrary swapper address, creating a read-only reentrancy vector. A malicious swapper can pull tokens out of the Box during a swap, causing the total assets to be undervalued when queried. If BoxAdapterCache is used, calling VaultV2.forceDeallocate() with assets = 0 updates the cached total assets to this lower value. An attacker can then mint cheap shares in a connected VaultV2 due to the artificially low NAV. After the swap completes, the correct total assets are restored, but the newly minted shares retain their artificially low valuation until the maxRate-per-second increase rule allows gradual recovery. This delay allows others to profit from the cheap share price. The attack can be repeated and is most dangerous during winddown, though possible during normal operations via a malicious allocator.\n",
            "severity": "High",
            "location": [
                "Box.sol::allocate",
                "Box.sol::deallocate",
                "Box.sol::reallocate",
                "VaultV2.sol::forceDeallocate"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ]
            },
            "title": "Gas Griefing Problems",
            "description": "Multiple functions in the codebase are vulnerable to gas griefing attacks due to checks that require token balances to be zero before certain operations can proceed. For example, Box.removeToken() reverts if the token balance is non-zero, allowing an attacker to send a minimal amount of the token to block removal and force allocators to perform costly swaps. Similarly, the nav() functions in funding modules perform additional oracle calls and computations if a whitelisted but unused token has a non-zero balance, enabling an attacker to inflate gas costs by sending small amounts to multiple such tokens. Additionally, _isFacilityUsed() in funding modules returns true if a facility has any collateral or debt, which can be manipulated by sending a small aToken balance or opening a minor Morpho position. The root cause is the lack of anti-griefing measures such as token sweeps or gas limits. Exploitation involves low-cost transactions by an attacker to induce high-gas operations for legitimate users. The impact includes increased operational costs, potential denial of service due to gas limits, and degraded system efficiency.\n",
            "severity": "Medium",
            "location": [
                "Box.sol::removeToken",
                "FundingAave.sol::nav",
                "FundingMorpho.sol::nav",
                "FundingAave.sol::_isFacilityUsed",
                "FundingMorpho.sol::_isFacilityUsed"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Box Cannot Receive Native Currency",
            "description": "The Box contract lacks a receive() or fallback() function, making it impossible to send native currency (e.g., ETH) directly to the contract. Any attempt to transfer native tokens—such as skimming from a funding module—will revert. This limits functionality and creates operational friction, especially in scenarios where native token recovery is necessary. The issue stems from the absence of required functions to accept native token transfers, violating expected behavior for contracts interacting with native assets.\n",
            "severity": "Medium",
            "location": [
                "Box.sol"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Discrepancy in Cumulated Slippage Computation",
            "description": "There is an inconsistency in how slippage percentage is calculated depending on whether the system is in a flash operation. Normally, slippage is computed as 100 * PRECISION / (X - 100), where X is the totalAssets before the loss. However, during a flash operation, the cached NAV is used, resulting in 100 * PRECISION / X. This means the slippage percentage is higher in non-flash scenarios for the same loss, leading to inconsistent behavior. The discrepancy arises because the cached NAV used during flash operations does not reflect intermediate changes, while the normal path uses the updated value. This can affect risk assessment and slippage tolerance logic differently based on context.\n",
            "severity": "Medium",
            "location": [
                "Box.sol::_navForSlippage"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-657"
                ],
                "3": [
                    "CWE-637"
                ]
            },
            "title": "Excessive Access Control for addFundingCollateral()",
            "description": "The function Box.addFundingCollateral() enforces both a timelock and requires msg.sender to be the curator. This dual restriction is overly strict compared to other similar addFundingXYZ() functions, which only require the timelock. Since the timelock mechanism already ensures that only the curator can initiate the action (via governance), the additional msg.sender check is redundant. This excessive access control reduces operational flexibility without adding meaningful security, making the design unnecessarily restrictive and inconsistent with the rest of the system.\n",
            "severity": "Medium",
            "location": [
                "Box.sol::addFundingCollateral"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "FundingMorpho.depledge() Does Not Sanitize collateralToken",
            "description": "The depledge() function in FundingMorpho allows callers to specify any whitelisted collateral token, not necessarily the one associated with the market. If a different whitelisted token is provided, the function withdraws the correct collateral from Morpho but transfers the specified token (e.g., DAI) to the owner instead. This causes the actual withdrawn collateral (e.g., WETH) to remain stuck in the funding module. During winddown, anyone can exploit this to drain mismatched tokens. In normal mode, only privileged allocators can trigger it. A similar issue exists in borrow(). The root cause is the lack of validation that the supplied collateralToken matches the market's actual collateral token.\n",
            "severity": "Medium",
            "location": [
                "FundingMorpho.sol::depledge",
                "FundingMorpho.sol::borrow"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Box Decimals Fixed to 18",
            "description": "The Box.decimals() function always returns 18 and is never overridden, even when the underlying asset has a different number of decimals (e.g., USDC with 6 decimals). This causes a 1:1 minting of shares relative to assets without proper normalization, leading to incorrect share amounts and potential integration issues with systems expecting correct decimal alignment. The issue stems from the lack of dynamic decimal adjustment based on the underlying asset, violating ERC-20 and ERC-4626 expectations for tokenized vaults.\n",
            "severity": "Medium",
            "location": [
                "Box.sol::decimals"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Effects of Function Abdication Are Not Immediate",
            "description": "When a function is abdicated using abdicateTimelock(), pending timelocked operations for that function can still be executed, which contradicts the expectation that abdication immediately disables the function. The root cause is that the abdication mechanism does not invalidate already-queued operations, only preventing new ones from being submitted. An attacker or malicious actor who has queued an operation before abdication can still execute it afterward, leading to unexpected behavior. For example, a privileged role could queue a dangerous operation, abdicate to appear to relinquish control, and then execute the operation later. The exception is decreaseTimelock(), which cannot be called on an abdicated function. Exploitation requires prior knowledge of the timelock queue and the ability to execute after abdication. The impact is a potential breach of expected security guarantees, undermining trust in the timelock and abdication system.\n",
            "severity": "Low",
            "location": [
                "Box.sol::abdicateTimelock",
                "Box.sol::decreaseTimelock"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1285"
                ],
                "4": [
                    "CWE-129"
                ]
            },
            "title": "Inconsistency in FundingAave facilities()",
            "description": "The FundingAave.facilities() function returns empty bytes regardless of input index, even if no facility was added. This behavior is inconsistent with FundingMorpho.facilities(), which reverts on invalid indices. Given that FundingAave supports only one facility, returning empty bytes for any index—including invalid ones—creates ambiguity and breaks expected access patterns. The inconsistency can lead to integration errors or incorrect assumptions by external systems querying the facilities list.\n",
            "severity": "Low",
            "location": [
                "FundingAave.sol::facilities"
            ],
            "files": [
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "ERC-4626 Violations",
            "description": "The Box contract claims EIP-4626 compliance but violates key requirements. First, maxWithdraw() and maxRedeem() do not consider actual liquidity, returning a user’s full pro-rata share of totalAssets() even if funds are locked in funding modules, which can cause reverts during withdrawal. Second, totalAssets() reverts during flash operations, violating the standard’s requirement that it MUST NOT REVERT. This also causes convertToAssets() and convertToShares() to revert unnecessarily. Additionally, previewMint() and previewDeposit() may return 0 for non-whitelisted addresses (isFeeder), which could be interpreted as a violation depending on whether such restrictions are considered part of user limits or unexpected reverts.\n",
            "severity": "Low",
            "location": [
                "Box.sol::maxWithdraw",
                "Box.sol::maxRedeem",
                "Box.sol::totalAssets",
                "Box.sol::previewMint",
                "Box.sol::previewDeposit"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Floating Pragma",
            "description": "The Box contract uses a floating pragma ^0.8.28, which allows compilation with any minor version of Solidity 0.8.x. This introduces risk because different compiler versions may introduce subtle bugs or optimizations that affect contract behavior. Contracts should be locked to a specific compiler version used during testing and auditing to ensure deterministic and predictable deployment. Using a floating pragma increases the chance of deploying with an untested or outdated compiler version, potentially introducing vulnerabilities.\n",
            "severity": "Low",
            "location": [
                "Box.sol"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Inaccurate Naming, Comments and NatSpec",
            "description": "Several inaccuracies exist in naming, comments, and NatSpec documentation. The _winddownSlippageTolerance() function's NatSpec claims slippage ranges from 0% to 100%, but implementation limits it to 0%–1%. Comments in BoxAdapter and BoxAdapterCached incorrectly claim safe casting due to supply bounds that don’t exist. The _findFundingIndex() parameter is named fundingData but refers to a funding module. A typo exists in Box’s main NatSpec: \"forApprove\" instead of \"forceApprove\". Factory elements refer to BoxAdapter instead of BoxAdapterCached. In Version 2, a typo remains in abdicateTimelock(): \"previsously\" instead of \"previously\". These inaccuracies reduce code clarity and increase the risk of misinterpretation.\n",
            "severity": "Low",
            "location": [
                "Box.sol::_winddownSlippageTolerance",
                "BoxAdapter.sol",
                "BoxAdapterCached.sol",
                "Box.sol::_findFundingIndex",
                "Box.sol",
                "BoxAdapterCachedFactory.sol",
                "Box.sol::abdicateTimelock"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Inconsistent and Missing Input Sanitization",
            "description": "Input validation is inconsistently applied across the codebase. The _curator address is not checked for zero in the constructor. Functions like transferOwnership(), setCurator(), setGuardian(), setIsAllocator(), setIsFeeder(), setMaxSlippage(), and changeTokenOracle() lack checks for unchanged values or zero addresses, leading to spurious events. addToken() does not prevent adding the underlying asset, which would double-count it in NAV. addFunding() does not verify that the Box owns the funding module, potentially adding unusable modules. These omissions result in unnecessary events and potential logic errors.\n",
            "severity": "Low",
            "location": [
                "Box.sol::constructor",
                "Box.sol::transferOwnership",
                "Box.sol::setCurator",
                "Box.sol::setGuardian",
                "Box.sol::setIsAllocator",
                "Box.sol::setIsFeeder",
                "Box.sol::setMaxSlippage",
                "Box.sol::changeTokenOracle",
                "Box.sol::addToken",
                "Box.sol::addFunding"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding Direction",
            "description": "In several places, rounding down exposes the system to insolvency risks. The minTokens value in swapping functions should be rounded up to ensure slippage never exceeds tolerance. Similarly, the value passed to _increaseSlippage() should be rounded up to guarantee sufficient slippage is recorded. Rounding down in these cases allows attackers to exploit small discrepancies, potentially leading to under-collateralization or incorrect accounting during high-volatility events.\n",
            "severity": "Low",
            "location": [
                "Box.sol::allocate",
                "Box.sol::deallocate",
                "Box.sol::_increaseSlippage"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unreachable Code",
            "description": "The condition repayAmount == type(uint256).max in FundingMorpho.repay() is almost never true because the same check is performed in Box.repay(). The only scenario where it could trigger is if debtAmount in Box.repay() returns type(uint256).max, but in that case, debtAmount in FundingMorpho.repay() would also be type(uint256).max, making the assignment redundant. This creates dead code that serves no functional purpose and should be removed to improve code clarity and reduce bytecode size.\n",
            "severity": "Low",
            "location": [
                "FundingMorpho.sol::repay"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Wrong LTV on Total Loss",
            "description": "The ltv() functions in both FundingMorpho and FundingAave return 0 when there is no collateral, even if there is outstanding debt. An LTV of 0 implies a healthy position, but a position with debt and no collateral is critically undercollateralized and should have an infinite or very high LTV. Returning 0 misrepresents the risk and can mislead risk assessment systems or users relying on this data, potentially leading to financial losses. This is a data integrity issue that provides dangerously incorrect information.\n",
            "severity": "Low",
            "location": [
                "FundingMorpho.sol::ltv",
                "FundingAave.sol::ltv"
            ],
            "files": [
                "box/src/FundingMorpho.sol",
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing Constructor Parameter in Event",
            "description": "The Box constructor emits the BoxCreated event, but this event does not include the shutdownWarmup parameter, despite it being a constructor input. This omission makes it impossible for off-chain systems to track the initial value of shutdownWarmup via events, reducing transparency and auditability. All constructor parameters should be logged in creation events to ensure complete event-based reconstruction of contract state.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::constructor",
                "EventsLib.sol::BoxCreated"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Unchecked Block for Loop Iterator",
            "description": "Several functions, including Box.removeToken() and Box._nav(), use explicit unchecked { i++ } blocks for loop counters. Since Solidity 0.8.22, the compiler automatically wraps loop increments in unchecked blocks, making explicit unchecked blocks redundant and less readable. Removing them improves code clarity and aligns with modern Solidity best practices.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::removeToken",
                "Box.sol::_nav"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "LTV of FundingAave Can Report More Than Managed Collateral",
            "description": "The FundingAave.ltv() function calculates the loan-to-value ratio using collateral and debt values, but the collateral value can be inflated by external donations of aTokens, even for non-whitelisted tokens. Since Aave automatically activates deposited aTokens as collateral, an attacker can donate aToken to artificially increase the reported collateral, thereby inflating the LTV ratio. The root cause is the lack of filtering for only whitelisted or managed collateral in the LTV calculation. An allocator relying on this LTV value might open debt positions under the false assumption of sufficient collateral, exposing the system to higher risk than intended. Exploitation involves donating a small amount of aToken to manipulate risk metrics. The impact is incorrect risk assessment, potential over-leveraging, and deviation from the intended risk profile of the strategy, though no direct fund loss occurs.\n",
            "severity": "Low",
            "location": [
                "FundingAave.sol::ltv"
            ],
            "files": [
                "box/src/FundingAave.sol"
            ]
        }
    ],
    "affected_files": {
        "FundingMorpho.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IMorpho, Id, MarketParams, Position} from \"@morpho-blue/interfaces/IMorpho.sol\";\nimport \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MarketParamsLib} from \"@morpho-blue/libraries/MarketParamsLib.sol\";\nimport {MorphoBalancesLib} from \"@morpho-blue/libraries/periphery/MorphoBalancesLib.sol\";\nimport {MorphoLib} from \"@morpho-blue/libraries/periphery/MorphoLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {MathLib} from \"./../lib/morpho-blue/src/libraries/MathLib.sol\";\nimport {FundingBase} from \"./FundingBase.sol\";\nimport {IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\n\ncontract FundingMorpho is FundingBase {\n    using SafeERC20 for IERC20;\n    using MarketParamsLib for MarketParams;\n    using MorphoBalancesLib for IMorpho;\n    using MorphoLib for IMorpho;\n    using MathLib for uint256;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IMorpho public immutable morpho;\n    uint256 public immutable lltvCap; // Maximum LTV/LTTV ration in 18 decimals, e.g. 80e16 for 80%\n\n    mapping(bytes32 => bytes) public facilityDataMap; // hash => facility data\n\n    constructor(address owner_, address morpho_, uint256 lltvCap_) FundingBase(owner_) {\n        require(morpho_ != address(0), ErrorsLib.InvalidAddress());\n        require(lltvCap_ <= 100e16, ErrorsLib.InvalidValue()); // Max 100%\n        require(lltvCap_ > 0, ErrorsLib.InvalidValue()); // Min above 0%\n\n        morpho = IMorpho(morpho_);\n        lltvCap = lltvCap_;\n    }\n\n    // ========== ADMIN ==========\n\n    /// @dev Before adding a facility, you need to add the underlying tokens as collateral/debt tokens\n    function addFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(isCollateralToken(IERC20(market.collateralToken)), ErrorsLib.TokenNotWhitelisted());\n        require(isDebtToken(IERC20(market.loanToken)), ErrorsLib.TokenNotWhitelisted());\n\n        bytes32 facilityHash = keccak256(facilityData);\n        require(facilitiesSet.add(facilityHash), ErrorsLib.AlreadyWhitelisted());\n        facilityDataMap[facilityHash] = facilityData;\n    }\n\n    function removeFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!_isFacilityUsed(facilityData), ErrorsLib.CannotRemove());\n\n        bytes32 facilityHash = keccak256(facilityData);\n        require(facilitiesSet.remove(facilityHash), ErrorsLib.NotWhitelisted());\n        delete facilityDataMap[facilityHash];\n    }\n\n    function facilities(uint256 index) external view returns (bytes memory) {\n        bytes32 facilityHash = facilitiesSet.at(index);\n        return facilityDataMap[facilityHash];\n    }\n\n    /// @dev Before being able to remove a collateral, no facility should reference it and the balance should be 0\n    function removeCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_collateralBalance(collateralToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 length = facilitiesSet.length();\n        for (uint i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            require(address(market.collateralToken) != address(collateralToken), ErrorsLib.CannotRemove());\n        }\n\n        require(collateralTokensSet.remove(address(collateralToken)), ErrorsLib.NotWhitelisted());\n    }\n\n    /// @dev Before being able to remove a debt, no facility should reference it and the balance should be 0\n    function removeDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_debtBalance(debtToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 length = facilitiesSet.length();\n        for (uint i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            require(address(market.loanToken) != address(debtToken), ErrorsLib.CannotRemove());\n        }\n\n        require(debtTokensSet.remove(address(debtToken)), ErrorsLib.NotWhitelisted());\n    }\n\n    // ========== ACTIONS ==========\n\n    /// @dev Assume caller did transfer the collateral tokens to this contract before calling\n    function pledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n\n        collateralToken.forceApprove(address(morpho), collateralAmount);\n        morpho.supplyCollateral(market, collateralAmount, address(this), \"\");\n    }\n\n    function depledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n\n        morpho.withdrawCollateral(market, collateralAmount, address(this), owner);\n\n        require(ltv(facilityData) <= (market.lltv * lltvCap) / 100e16, ErrorsLib.ExcessiveLTV());\n    }\n\n    function borrow(bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n\n        morpho.borrow(market, borrowAmount, 0, address(this), owner);\n\n        require(ltv(facilityData) <= (market.lltv * lltvCap) / 100e16, ErrorsLib.ExcessiveLTV());\n    }\n\n    /// @dev Assume caller did transfer the debt tokens to this contract before calling\n    function repay(bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n\n        uint256 debtAmount = morpho.expectedBorrowAssets(market, address(this));\n\n        debtToken.forceApprove(address(morpho), repayAmount);\n\n        // If the amount repaid is all the debt, we convert to all shares\n        // amount repaid would internally get translated to more shares that there is to repaid\n        if (repayAmount == debtAmount) {\n            morpho.repay(market, 0, morpho.borrowShares(market.id(), address(this)), address(this), \"\");\n        } else {\n            morpho.repay(market, repayAmount, 0, address(this), \"\");\n        }\n    }\n\n    // ========== POSITION ==========\n\n    /// @dev returns 0 if there is no collateral\n    function ltv(bytes calldata facilityData) public view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        Id marketId = market.id();\n        uint256 borrowedAssets = morpho.expectedBorrowAssets(market, address(this));\n        uint256 collateralAmount = morpho.collateral(marketId, address(this));\n        if (collateralAmount == 0) return 0;\n        require(market.oracle != address(0), ErrorsLib.NoOracleForToken());\n        uint256 collateralPrice = IOracle(market.oracle).price();\n        uint256 collateralValue = collateralAmount.mulDivDown(collateralPrice, ORACLE_PRICE_SCALE);\n        return (collateralValue == 0) ? 0 : borrowedAssets.wDivUp(collateralValue);\n    }\n\n    function debtBalance(bytes calldata facilityData, IERC20 debtToken) external view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n        return morpho.expectedBorrowAssets(market, address(this));\n    }\n\n    function collateralBalance(bytes calldata facilityData, IERC20 collateralToken) external view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n        return morpho.collateral(market.id(), address(this));\n    }\n\n    /// @dev The NAV for a given lending market can be negative but there is no recourse so it can be floored to 0.\n    function nav(IOracleCallback oraclesProvider) public view override returns (uint256) {\n        uint256 nav_ = 0;\n        address asset = oraclesProvider.asset();\n        uint256 length = facilitiesSet.length();\n        for (uint256 i = 0; i < length; i++) {\n            uint256 facilityNav = 0;\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            uint256 collateralBalance_ = morpho.collateral(market.id(), address(this));\n\n            if (collateralBalance_ == 0) continue; // No debt if no collateral\n\n            if (market.collateralToken == asset) {\n                // RIs are considered to have a price of ORACLE_PRECISION\n                facilityNav += collateralBalance_;\n            } else {\n                IOracle oracle = oraclesProvider.oracles(IERC20(market.collateralToken));\n                facilityNav += collateralBalance_.mulDivDown(oracle.price(), ORACLE_PRICE_SCALE);\n            }\n\n            uint256 debtBalance_ = morpho.expectedBorrowAssets(market, address(this));\n\n            if (market.loanToken == asset) {\n                facilityNav = (facilityNav > debtBalance_) ? facilityNav - debtBalance_ : 0;\n            } else {\n                IOracle oracle = oraclesProvider.oracles(IERC20(market.loanToken));\n                uint256 value = debtBalance_.mulDivUp(oracle.price(), ORACLE_PRICE_SCALE);\n                facilityNav = (facilityNav > value) ? facilityNav - value : 0;\n            }\n\n            nav_ += facilityNav;\n        }\n        return nav_;\n    }\n\n    // ========== Other exposed view functions ==========\n\n    function decodeFacilityData(bytes memory facilityData) public pure returns (MarketParams memory market) {\n        // MarketParams has 4 addresses (32 bytes each) + 1 uint256 (32 bytes) = 160 bytes\n        require(facilityData.length == 160, ErrorsLib.InvalidFacilityData());\n        (MarketParams memory marketParams) = abi.decode(facilityData, (MarketParams));\n        return (marketParams);\n    }\n\n    function encodeFacilityData(MarketParams memory market) public pure returns (bytes memory) {\n        return abi.encode(market);\n    }\n\n    // ========== Internal functions ==========\n    function _debtBalance(IERC20 debtToken) internal view override returns (uint256 balance) {\n        uint256 length = facilitiesSet.length();\n        for (uint256 i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            if (address(debtToken) == market.loanToken) {\n                balance += morpho.expectedBorrowAssets(market, address(this));\n            }\n        }\n    }\n\n    function _collateralBalance(IERC20 collateralToken) internal view override returns (uint256 balance) {\n        uint256 length = facilitiesSet.length();\n        for (uint256 i = 0; i < length; i++) {\n            bytes32 facilityHash = facilitiesSet.at(i);\n            MarketParams memory market = decodeFacilityData(facilityDataMap[facilityHash]);\n            if (address(collateralToken) == market.collateralToken) {\n                balance += morpho.collateral(market.id(), address(this));\n            }\n        }\n    }\n\n    function _isFacilityUsed(bytes calldata facilityData) internal view override returns (bool) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        Position memory position = morpho.position(market.id(), address(this));\n        return position.collateral > 0 || position.borrowShares > 0;\n    }\n}\n",
        "FundingAave.sol": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MathLib} from \"@morpho-blue/libraries/MathLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {FundingBase} from \"./FundingBase.sol\";\nimport {IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\n\ninterface IPool {\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external returns (uint256);\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n    function setUserEMode(uint8 categoryId) external;\n    function getUserEMode(address user) external view returns (uint256);\n    function getEModeCategoryData(\n        uint8 categoryId\n    ) external view returns (uint16 ltv, uint16 liquidationThreshold, uint16 liquidationBonus, address priceSource, string memory label);\n    function getReserveEModeCategory(address asset) external view returns (uint256);\n\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function getReserveData(\n        address asset\n    )\n        external\n        view\n        returns (\n            uint256 configuration,\n            uint128 liquidityIndex,\n            uint128 currentLiquidityRate,\n            uint128 variableBorrowIndex,\n            uint128 currentVariableBorrowRate,\n            uint128 currentStableBorrowRate,\n            uint40 lastUpdateTimestamp,\n            uint16 id,\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress,\n            address interestRateStrategyAddress,\n            uint128 accruedToTreasury,\n            uint128 unbacked,\n            uint128 isolationModeTotalDebt\n        );\n\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n}\n\ninterface IScaledBalanceToken {\n    function scaledBalanceOf(address user) external view returns (uint256);\n}\n\ncontract FundingAave is FundingBase {\n    using SafeERC20 for IERC20;\n    using MathLib for uint256;\n    using Math for uint256;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IPool public immutable pool;\n    uint256 public immutable rateMode = 2; // 1 = Stable, 2 = Variable (Aave v3 constant)\n    uint8 public immutable eMode; // 0 = no e-mode\n\n    constructor(address _owner, IPool _pool, uint8 _eMode) FundingBase(_owner) {\n        pool = _pool;\n        eMode = _eMode;\n        if (pool.getUserEMode(address(this)) != eMode) {\n            pool.setUserEMode(eMode);\n        }\n    }\n\n    // ========== ADMIN ==========\n\n    /// @dev FundingAave always expect \"\" as facilityData\n    function addFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(facilityData.length == 0, ErrorsLib.InvalidValue());\n\n        bytes32 facilityHash = keccak256(facilityData);\n        require(facilitiesSet.add(facilityHash), ErrorsLib.AlreadyWhitelisted());\n    }\n\n    function removeFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!_isFacilityUsed(facilityData), ErrorsLib.CannotRemove());\n\n        bytes32 facilityHash = keccak256(facilityData);\n        require(facilitiesSet.remove(facilityHash), ErrorsLib.NotWhitelisted());\n    }\n\n    function facilities(uint256 index) external view returns (bytes memory) {\n        // Validate index to be consistent with FundingMorpho behavior (reverts on invalid index)\n        facilitiesSet.at(index);\n        // For FundingAave, facilities are always empty bytes\n        return \"\";\n    }\n\n    function removeCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_collateralBalance(collateralToken) == 0, ErrorsLib.CannotRemove());\n        require(collateralTokensSet.remove(address(collateralToken)), ErrorsLib.NotWhitelisted());\n    }\n\n    function removeDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_debtBalance(debtToken) == 0, ErrorsLib.CannotRemove());\n        require(debtTokensSet.remove(address(debtToken)), ErrorsLib.NotWhitelisted());\n    }\n\n    // ========== ACTIONS ==========\n\n    /// @dev Assume caller did transfer the collateral tokens to this contract before calling\n    function pledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        IERC20(collateralToken).forceApprove(address(pool), collateralAmount);\n        pool.supply(address(collateralToken), collateralAmount, address(this), 0);\n        pool.setUserUseReserveAsCollateral(address(collateralToken), true);\n    }\n\n    function depledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        pool.withdraw(address(collateralToken), collateralAmount, owner);\n    }\n\n    function borrow(bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        pool.borrow(address(debtToken), borrowAmount, rateMode, 0, address(this));\n        debtToken.safeTransfer(owner, borrowAmount);\n    }\n\n    /// @dev Assume caller did transfer the debt tokens to this contract before calling\n    function repay(bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        debtToken.forceApprove(address(pool), repayAmount);\n        uint256 actualRepaid = pool.repay(address(debtToken), repayAmount, rateMode, address(this));\n\n        if (actualRepaid < repayAmount) {\n            debtToken.safeTransfer(owner, repayAmount - actualRepaid);\n        }\n    }\n\n    // ========== POSITION ==========\n\n    /// @dev ltv can also use non whitelisted collaterals (donated)\n    /// @dev returns 0 if there is no collateral\n    function ltv(bytes calldata data) external view override returns (uint256) {\n        (uint256 totalCollateralBase, uint256 totalDebtBase, , , , ) = pool.getUserAccountData(address(this));\n\n        return totalCollateralBase == 0 ? 0 : totalDebtBase.wDivUp(totalCollateralBase);\n    }\n\n    function debtBalance(bytes calldata facilityData, IERC20 debtToken) external view override returns (uint256) {\n        return _debtBalance(debtToken);\n    }\n\n    function collateralBalance(bytes calldata facilityData, IERC20 collateralToken) external view override returns (uint256) {\n        return _collateralBalance(collateralToken);\n    }\n\n    /// @dev The NAV for a given lending market can be negative but there is no recourse so it can be floored to 0.\n    function nav(IOracleCallback oraclesProvider) public view override returns (uint256) {\n        uint256 totalCollateralValue;\n        uint256 totalDebtValue;\n        address asset = oraclesProvider.asset();\n\n        // Calculate total collateral value\n        uint256 collateralLength = collateralTokensSet.length();\n        for (uint256 i = 0; i < collateralLength; i++) {\n            IERC20 collateralToken = IERC20(collateralTokensSet.at(i));\n            uint256 collateralBalance_ = _collateralBalance(collateralToken);\n\n            if (collateralBalance_ > 0) {\n                if (address(collateralToken) == asset) {\n                    totalCollateralValue += collateralBalance_;\n                } else {\n                    IOracle oracle = oraclesProvider.oracles(collateralToken);\n                    uint256 price = oracle.price();\n                    uint256 value = collateralBalance_.mulDivDown(price, ORACLE_PRICE_SCALE);\n                    totalCollateralValue += value;\n                }\n            }\n        }\n\n        // Calculate total debt value\n        uint256 debtLength = debtTokensSet.length();\n        for (uint256 i = 0; i < debtLength; i++) {\n            IERC20 debtToken = IERC20(debtTokensSet.at(i));\n            uint256 debtBalance_ = _debtBalance(debtToken);\n\n            if (debtBalance_ > 0) {\n                if (address(debtToken) == asset) {\n                    totalDebtValue += debtBalance_;\n                } else {\n                    IOracle oracle = oraclesProvider.oracles(debtToken);\n                    uint256 price = oracle.price();\n                    uint256 value = debtBalance_.mulDivUp(price, ORACLE_PRICE_SCALE);\n                    totalDebtValue += value;\n                }\n            }\n        }\n\n        // Return NAV = collateral - debt (floor at 0)\n        if (totalCollateralValue <= totalDebtValue) return 0;\n        unchecked {\n            return totalCollateralValue - totalDebtValue;\n        }\n    }\n\n    function _debtBalance(IERC20 debtToken) internal view override returns (uint256 balance) {\n        (, , , , , , , , , , address variableDebtToken, , , , ) = pool.getReserveData(address(debtToken));\n        return IERC20(variableDebtToken).balanceOf(address(this));\n    }\n\n    function _collateralBalance(IERC20 collateralToken) internal view override returns (uint256 balance) {\n        (, , , , , , , , address aTokenAddress, , , , , , ) = pool.getReserveData(address(collateralToken));\n        return IERC20(aTokenAddress).balanceOf(address(this));\n    }\n\n    function _isFacilityUsed(bytes calldata facilityData) internal view override returns (bool) {\n        (uint256 totalCollateralBase, uint256 totalDebtBase, , , , ) = pool.getUserAccountData(address(this));\n\n        return totalCollateralBase > 0 || totalDebtBase > 0;\n    }\n}\n",
        "Box.sol": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IBox} from \"./interfaces/IBox.sol\";\nimport {IBoxFlashCallback} from \"./interfaces/IBox.sol\";\nimport {IFunding, IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport \"./libraries/Constants.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\nimport {EventsLib} from \"./libraries/EventsLib.sol\";\n\n/**\n * @title Box\n * @notice An ERC4626 vault that holds a base asset, invest in other ERC20 tokens and can borrow/lend via funding modules.\n * @dev Features role-based access control, timelocked governance, and slippage protection\n * @dev Box is not inflation or donation resistant as deposits are strictly controlled via the isFeeder role.\n * @dev Should deposit happen in an automated way (liquidity on a Vault V2) and from multiple feeders, it should be seeded first.\n * @dev Oracles can be manipulated to give an unfair price\n * @dev It is recommanded to create resiliency by using the BoxAdapterCached\n * @dev and/or by using a Vault V2 as a parent vault, which can have a reported price a but lower the NAV price and a setMaxRate()\n * @dev During flash operations there is no totalAssets() calculation possible to avoid NAV based attacks\n * @dev There is no protection against ERC4626 inflation attacks, as deposits are controlled via the isFeeder role.\n * @dev Users shouldn't be able to deposited directly or indirectly to a Box.\n * @dev The Box uses forceApprove with 0 value, making it incompatible with the BNB ERC-20 token (reverts on zero-value approvals)\n * @dev Token removal can be stopped by sending dust amount of tokens. Can be fixed by deallocating then removing the token atomically\n * @dev The epoch-based slippage protection is relative to Box total assets, but a bad allocator can deposit all parent Vault V2\n * @dev fund into one Box to temporarily inflate its total asset and extract more value than expected.\n */\ncontract Box is IBox, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // ========== IMMUTABLE STATE ==========\n\n    /// @notice Base currency token (e.g., USDC)\n    address public immutable override asset;\n\n    /// @notice Number of decimals for the vault shares (normalized to 18 for assets with fewer decimals)\n    uint8 private immutable _decimals;\n\n    /// @notice Virtual shares used for inflation attack protection\n    uint256 public immutable virtualShares;\n\n    /// @notice Duration of slippage tracking epochs\n    uint256 public immutable slippageEpochDuration;\n\n    /// @notice Duration over which shutdown slippage tolerance increases\n    uint256 public immutable shutdownSlippageDuration;\n\n    /// @notice Duration between shutdown and wind-down phase\n    uint256 public immutable shutdownWarmup;\n\n    // ========== MUTABLE STATE ==========\n\n    /// @notice Contract owner with administrative privileges\n    address public owner;\n\n    /// @notice Curator who manages tokens and funding modules\n    address public curator;\n\n    /// @notice Guardian who can trigger shutdowns and revoke timelocked actions\n    address public guardian;\n\n    /// @notice Timestamp when shutdown was triggered, no shutdown if type(uint256).max\n    uint256 public shutdownTime;\n\n    /// @notice Recipient of skimmed tokens that aren't part of the vault's strategy\n    address public skimRecipient;\n\n    /// @notice Tracks which addresses can execute allocation strategies\n    mapping(address => bool) public isAllocator;\n\n    /// @notice Tracks which addresses can deposit into the vault\n    mapping(address => bool) public isFeeder;\n\n    /// @notice List of whitelisted investment tokens\n    IERC20[] public tokens;\n\n    /// @notice Maps each token to its price oracle\n    mapping(IERC20 => IOracle) public oracles;\n\n    /// @notice Maximum allowed slippage per operation and per epoch (scaled by PRECISION = 1e18)\n    uint256 public maxSlippage;\n\n    /// @notice Accumulated slippage within current epoch (scaled by PRECISION = 1e18)\n    uint256 public accumulatedSlippage;\n\n    /// @notice Timestamp when the current slippage tracking epoch started\n    uint256 public slippageEpochStart;\n\n    /// @notice Delay duration for each function selector (in seconds)\n    mapping(bytes4 => uint256) public timelock;\n\n    /// @notice Timestamp when specific calldata becomes executable\n    mapping(bytes => uint256) public executableAt;\n\n    /// @notice List of whitelisted funding modules for borrowing/lending\n    IFunding[] public fundings;\n\n    /// @notice Quick lookup to check if a funding module is whitelisted\n    mapping(IFunding => bool) internal fundingMap;\n\n    /// @notice Depth counter for nested NAV-caching operations (flash and swaps)\n    uint8 private transient _cachedNavDepth;\n\n    /// @notice Cached NAV value during flash and swap operations to prevent manipulation\n    uint256 private transient _cachedNav;\n\n    // ========== CONSTRUCTOR ==========\n\n    /**\n     * @notice Allows the contract to receive native currency\n     * @dev Required for skimming native currency from funding modules\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Fallback function to receive native currency\n     * @dev Required for skimming native currency from funding modules\n     */\n    fallback() external payable {}\n\n    /**\n     * @notice Initializes the Box vault\n     * @param _asset Base currency token (e.g., USDC)\n     * @param _owner Initial owner address\n     * @param _curator Initial curator address\n     * @param _name ERC20 token name\n     * @param _symbol ERC20 token symbol\n     * @param _maxSlippage Max allowed slippage for a swap or aggregated over `_slippageEpochDuration`\n     * @param _slippageEpochDuration Duration for which slippage is measured\n     * @param _shutdownSlippageDuration When shutdown duration for slippage allowance to widen\n     * @param _shutdownWarmup Duration between shutdown and wind-down phase\n     * @dev To mitigate donation attacks, make an initial \"dead\" deposit after deployment\n     *      (e.g., deposit a small amount and transfer the shares to address(0xdead)).\n     */\n    constructor(\n        address _asset,\n        address _owner,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _maxSlippage,\n        uint256 _slippageEpochDuration,\n        uint256 _shutdownSlippageDuration,\n        uint256 _shutdownWarmup\n    ) ERC20(_name, _symbol) {\n        _requireNonZeroAddress(_asset);\n        _requireNonZeroAddress(_owner);\n        _requireNonZeroAddress(_curator);\n        require(_maxSlippage <= MAX_SLIPPAGE_LIMIT, ErrorsLib.SlippageTooHigh());\n        _requireNotEqual(_slippageEpochDuration, 0);\n        _requireNotEqual(_shutdownSlippageDuration, 0);\n        require(_shutdownWarmup <= MAX_SHUTDOWN_WARMUP, ErrorsLib.InvalidValue());\n\n        asset = _asset;\n        owner = _owner;\n        curator = _curator;\n        maxSlippage = _maxSlippage;\n        slippageEpochDuration = _slippageEpochDuration;\n        shutdownSlippageDuration = _shutdownSlippageDuration;\n        shutdownWarmup = _shutdownWarmup;\n        slippageEpochStart = block.timestamp;\n        shutdownTime = type(uint256).max; // No shutdown initially\n\n        // Set up decimals following VaultV2 pattern\n        uint256 assetDecimals = IERC20Metadata(asset).decimals();\n        uint256 decimalOffset = uint256(18) > assetDecimals ? uint256(18) - assetDecimals : 0;\n        _decimals = uint8(assetDecimals + decimalOffset);\n        virtualShares = 10 ** decimalOffset;\n\n        emit EventsLib.BoxCreated(\n            address(this),\n            asset,\n            owner,\n            curator,\n            _name,\n            _symbol,\n            maxSlippage,\n            slippageEpochDuration,\n            shutdownSlippageDuration,\n            shutdownWarmup\n        );\n        emit EventsLib.OwnershipTransferred(address(0), _owner);\n        emit EventsLib.CuratorUpdated(address(0), _curator);\n    }\n\n    // ========== ERC4626 IMPLEMENTATION ==========\n\n    /// @notice Returns the number of decimals for the vault shares\n    /// @dev Overrides ERC20.decimals() to support assets with different decimal values\n    function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {\n        return _decimals;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Returns the total value of assets managed by the vault\n    /// @dev Returns cached NAV during flash and swap operations to prevent manipulation\n    function totalAssets() public view returns (uint256) {\n        return _cachedNavDepth > 0 ? _cachedNav : _nav();\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Calculates shares received for a given asset amount\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return assets.mulDiv(supply + virtualShares, totalAssets() + 1, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Calculates assets received for redeeming shares\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return shares.mulDiv(totalAssets() + 1, supply + virtualShares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum assets that can be deposited\n    function maxDeposit(address) external view returns (uint256) {\n        return (isShutdown()) ? 0 : type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates share minting for a deposit\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Deposits base asset and mints shares to receiver\n    /// @dev Only authorized feeders can deposit\n    function deposit(uint256 assets, address receiver) public nonReentrant returns (uint256 shares) {\n        shares = previewDeposit(assets);\n        _depositMint(assets, shares, receiver);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum shares that can be minted\n    function maxMint(address) external view returns (uint256) {\n        return (isShutdown()) ? 0 : type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates assets needed to mint shares\n    function previewMint(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return shares.mulDiv(totalAssets() + 1, supply + virtualShares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Mints exact shares by depositing necessary base asset\n    /// @dev Only authorized feeders can mint\n    function mint(uint256 shares, address receiver) external nonReentrant returns (uint256 assets) {\n        assets = previewMint(shares);\n        _depositMint(assets, shares, receiver);\n    }\n\n    /// @dev Internal helper for deposit and mint to reduce bytecode duplication\n    function _depositMint(uint256 assets, uint256 shares, address receiver) internal {\n        require(_cachedNavDepth == 0, ErrorsLib.ReentryNotAllowed());\n        _onlyFeeder();\n        _requireNotShutdown();\n        _requireNonZeroAddress(receiver);\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum assets owner can withdraw\n    function maxWithdraw(address owner_) external view returns (uint256) {\n        uint256 ownerAssets = convertToAssets(balanceOf(owner_));\n        uint256 availableLiquidity = IERC20(asset).balanceOf(address(this));\n        return ownerAssets < availableLiquidity ? ownerAssets : availableLiquidity;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates shares burned for withdrawing assets\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return assets.mulDiv(supply + virtualShares, totalAssets() + 1, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Withdraws base asset by burning owner's shares\n    /// @dev Requires sufficient shares and vault liquidity\n    function withdraw(uint256 assets, address receiver, address owner_) public nonReentrant returns (uint256 shares) {\n        shares = previewWithdraw(assets);\n        _withdrawRedeem(assets, shares, receiver, owner_);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum shares owner can redeem\n    function maxRedeem(address owner_) external view returns (uint256) {\n        uint256 ownerShares = balanceOf(owner_);\n        uint256 availableLiquidity = IERC20(asset).balanceOf(address(this));\n        uint256 liquidityShares = convertToShares(availableLiquidity);\n        return ownerShares < liquidityShares ? ownerShares : liquidityShares;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates assets received for redeeming shares\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Redeems shares for underlying base asset\n    /// @dev Burns shares and transfers base asset to receiver\n    function redeem(uint256 shares, address receiver, address owner_) external nonReentrant returns (uint256 assets) {\n        assets = previewRedeem(shares);\n        _withdrawRedeem(assets, shares, receiver, owner_);\n    }\n\n    /// @dev Internal helper for withdraw and redeem to reduce bytecode duplication\n    function _withdrawRedeem(uint256 assets, uint256 shares, address receiver, address owner_) internal {\n        require(_cachedNavDepth == 0, ErrorsLib.ReentryNotAllowed());\n        _requireNonZeroAddress(receiver);\n\n        if (msg.sender != owner_) {\n            uint256 allowed = allowance(owner_, msg.sender);\n            if (allowed < shares) revert ErrorsLib.InsufficientAllowance();\n            if (allowed != type(uint256).max) {\n                _approve(owner_, msg.sender, allowed - shares);\n            }\n        }\n\n        if (balanceOf(owner_) < shares) revert ErrorsLib.InsufficientShares();\n        if (IERC20(asset).balanceOf(address(this)) < assets) revert ErrorsLib.InsufficientLiquidity();\n\n        _burn(owner_, shares);\n        IERC20(asset).safeTransfer(receiver, assets);\n\n        emit Withdraw(msg.sender, receiver, owner_, assets, shares);\n    }\n\n    // ========== SWAP FUNCTIONS ==========\n\n    /**\n     * @notice Transfers accidentally sent tokens to the skim recipient\n     * @param token Token to skim from the contract\n     * @dev Cannot skim the base asset or whitelisted investment tokens\n     */\n    function skim(IERC20 token) external nonReentrant {\n        require(msg.sender == skimRecipient, ErrorsLib.OnlySkimRecipient());\n        _requireNotEqualAddress(address(token), asset);\n        require(!isToken(token), ErrorsLib.CannotSkimToken());\n\n        uint256 balance;\n\n        if (address(token) != address(0)) {\n            // ERC-20 tokens\n            balance = token.balanceOf(address(this));\n            require(balance > 0, ErrorsLib.CannotSkimZero());\n            token.safeTransfer(skimRecipient, balance);\n        } else {\n            // ETH\n            balance = address(this).balance;\n            require(balance > 0, ErrorsLib.CannotSkimZero());\n            (bool ok, ) = skimRecipient.call{value: balance}(\"\");\n            require(ok, ErrorsLib.TransferFailed());\n        }\n\n        emit EventsLib.Skim(token, skimRecipient, balance);\n    }\n\n    /**\n     * @notice Swaps base asset for investment tokens\n     * @param token Target token to acquire\n     * @param assetsAmount Maximum amount of base asset to spend\n     * @param swapper Contract that will execute the swap\n     * @param data Custom data for the swapper implementation\n     * @return expected Expected amount of target token based on oracle price\n     * @return received Actual amount of target token received from the allocation\n     * @dev Enforces slippage protection based on oracle prices\n     * @dev During wind-down, slippage tolerance increases over time\n     */\n    function allocate(\n        IERC20 token,\n        uint256 assetsAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) public nonReentrant returns (uint256 expected, uint256 received) {\n        _startNavCache();\n\n        bool winddown = isWinddown();\n        require((isAllocator[msg.sender] && !winddown) || (winddown && _debtBalance(token) > 0), ErrorsLib.OnlyAllocatorsOrWinddown());\n        _requireIsToken(token);\n\n        uint256 oraclePrice = oracles[token].price();\n        uint256 slippageTolerance = winddown ? _winddownSlippageTolerance() : maxSlippage;\n\n        if (winddown) {\n            // Limit allocation to debt shortfall adjusted for slippage tolerance\n            uint256 debtAmount = _debtBalance(token);\n            uint256 existingBalance = token.balanceOf(address(this));\n            uint256 neededTokens = debtAmount > existingBalance ? debtAmount - existingBalance : 0;\n            uint256 neededValue = neededTokens.mulDiv(oraclePrice, ORACLE_PRECISION, Math.Rounding.Ceil);\n            uint256 maxAllocation = neededValue.mulDiv(PRECISION, PRECISION - slippageTolerance, Math.Rounding.Ceil);\n            require(assetsAmount <= maxAllocation, ErrorsLib.InvalidAmount());\n        }\n\n        // Execute swap\n        (uint256 assetsSpent, uint256 tokensReceived) = _executeSwap(IERC20(asset), token, assetsAmount, swapper, data);\n\n        // Calculate and validate slippage\n        uint256 expectedTokens = assetsAmount.mulDiv(ORACLE_PRECISION, oraclePrice, Math.Rounding.Ceil);\n        uint256 minTokens = _calculateMinAmount(expectedTokens, slippageTolerance);\n        require(tokensReceived >= minTokens, ErrorsLib.AllocationTooExpensive());\n\n        int256 slippagePct = _calculateSlippagePct(expectedTokens, tokensReceived);\n\n        // Track slippage if we are not in winddown and have positive slippage\n        if (!winddown && tokensReceived < expectedTokens) {\n            uint256 slippageValue = (expectedTokens - tokensReceived).mulDiv(oraclePrice, ORACLE_PRECISION, Math.Rounding.Ceil);\n            _increaseSlippage(slippageValue.mulDiv(PRECISION, totalAssets(), Math.Rounding.Ceil));\n        }\n\n        emit EventsLib.Allocation(token, assetsSpent, expectedTokens, tokensReceived, slippagePct, swapper, data);\n\n        _endNavCache();\n        return (expectedTokens, tokensReceived);\n    }\n\n    /**\n     * @notice Swaps investment tokens back to base asset\n     * @param token Token to sell\n     * @param tokensAmount Maximum amount of tokens to sell\n     * @param swapper Contract that will execute the swap\n     * @param data Custom data for the swapper implementation\n     * @return expected Expected amount of base asset based on oracle price\n     * @return received Actual amount of base asset received from the deallocation\n     * @dev Enforces slippage protection based on oracle prices\n     * @dev During wind-down, anyone can deallocate tokens with no outstanding debt\n     */\n    function deallocate(\n        IERC20 token,\n        uint256 tokensAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) external nonReentrant returns (uint256 expected, uint256 received) {\n        _startNavCache();\n\n        bool winddown = isWinddown();\n        require((isAllocator[msg.sender] && !winddown) || (winddown && _debtBalance(token) == 0), ErrorsLib.OnlyAllocatorsOrWinddown());\n        _requireIsToken(token);\n\n        uint256 oraclePrice = oracles[token].price();\n        uint256 slippageTolerance = winddown ? _winddownSlippageTolerance() : maxSlippage;\n\n        // Execute swap\n        (uint256 tokensSpent, uint256 assetsReceived) = _executeSwap(token, IERC20(asset), tokensAmount, swapper, data);\n\n        // Calculate and validate slippage\n        uint256 expectedAssets = tokensAmount.mulDiv(oraclePrice, ORACLE_PRECISION, Math.Rounding.Ceil);\n        uint256 minAssets = _calculateMinAmount(expectedAssets, slippageTolerance);\n        require(assetsReceived >= minAssets, ErrorsLib.TokenSaleNotGeneratingEnoughAssets());\n\n        int256 slippagePct = _calculateSlippagePct(expectedAssets, assetsReceived);\n\n        // Track slippage if not in winddown and we have positive slippage\n        if (!winddown && assetsReceived < expectedAssets) {\n            // slippage is already in asset units\n            uint256 slippageValue = expectedAssets - assetsReceived;\n            _increaseSlippage(slippageValue.mulDiv(PRECISION, totalAssets(), Math.Rounding.Ceil));\n        }\n\n        emit EventsLib.Deallocation(token, tokensSpent, expectedAssets, assetsReceived, slippagePct, swapper, data);\n\n        _endNavCache();\n        return (expectedAssets, assetsReceived);\n    }\n\n    /**\n     * @notice Swaps between two investment tokens directly\n     * @param from Source token to sell\n     * @param to Target token to buy\n     * @param tokensAmount Maximum amount of source token to sell\n     * @param swapper Contract that will execute the swap\n     * @param data Custom data for the swapper implementation\n     * @return expected Expected amount of target token based on oracle prices\n     * @return received Actual amount of target token received from the reallocation\n     * @dev More gas efficient than separate deallocate + allocate\n     */\n    function reallocate(\n        IERC20 from,\n        IERC20 to,\n        uint256 tokensAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) external nonReentrant returns (uint256 expected, uint256 received) {\n        _startNavCache();\n\n        _onlyAllocator();\n        _requireNotWinddown();\n        _requireIsToken(from);\n        _requireIsToken(to);\n\n        uint256 fromOraclePrice = oracles[from].price();\n        uint256 toOraclePrice = oracles[to].price();\n\n        // Execute swap\n        (uint256 fromSpent, uint256 toReceived) = _executeSwap(from, to, tokensAmount, swapper, data);\n\n        // Calculate expected amounts and validate slippage\n        uint256 fromValue = tokensAmount.mulDiv(fromOraclePrice, ORACLE_PRECISION, Math.Rounding.Ceil);\n        uint256 expectedToTokens = fromValue.mulDiv(ORACLE_PRECISION, toOraclePrice, Math.Rounding.Ceil);\n        uint256 minToTokens = _calculateMinAmount(expectedToTokens, maxSlippage);\n        require(toReceived >= minToTokens, ErrorsLib.ReallocationSlippageTooHigh());\n\n        int256 slippagePct = _calculateSlippagePct(expectedToTokens, toReceived);\n\n        // Track slippage if we have positive slippage\n        // Note: No winddown check needed as reallocate cannot be called during winddown\n        if (toReceived < expectedToTokens) {\n            uint256 slippageValue = (expectedToTokens - toReceived).mulDiv(toOraclePrice, ORACLE_PRECISION, Math.Rounding.Ceil);\n            _increaseSlippage(slippageValue.mulDiv(PRECISION, totalAssets(), Math.Rounding.Ceil));\n        }\n\n        emit EventsLib.Reallocation(from, to, fromSpent, expectedToTokens, toReceived, slippagePct, swapper, data);\n\n        _endNavCache();\n        return (expectedToTokens, toReceived);\n    }\n\n    // ========== FUNDING FUNCTIONS ==========\n\n    /**\n     * @notice Posts collateral to a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param collateralToken Token to pledge as collateral\n     * @param collateralAmount Amount to pledge\n     * @dev Transfers tokens to module and updates collateral position\n     */\n    function pledge(\n        IFunding fundingModule,\n        bytes calldata facilityData,\n        IERC20 collateralToken,\n        uint256 collateralAmount\n    ) external nonReentrant {\n        _onlyAllocatorNotWinddown();\n        _requireIsFunding(fundingModule);\n\n        collateralToken.safeTransfer(address(fundingModule), collateralAmount);\n        fundingModule.pledge(facilityData, collateralToken, collateralAmount);\n\n        emit EventsLib.Pledge(fundingModule, facilityData, collateralToken, collateralAmount);\n    }\n\n    /**\n     * @notice Withdraws collateral from a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param collateralToken Token to withdraw\n     * @param collateralAmount Amount to withdraw (max uint256 = all)\n     * @dev Returns tokens to vault, must maintain required collateral ratios\n     */\n    function depledge(\n        IFunding fundingModule,\n        bytes calldata facilityData,\n        IERC20 collateralToken,\n        uint256 collateralAmount\n    ) external nonReentrant {\n        _onlyAllocatorOrWinddown();\n        _requireIsFunding(fundingModule);\n\n        uint256 pledgeAmount = fundingModule.collateralBalance(facilityData, collateralToken);\n\n        if (collateralAmount == type(uint256).max) {\n            collateralAmount = pledgeAmount;\n        }\n\n        fundingModule.depledge(facilityData, collateralToken, collateralAmount);\n\n        emit EventsLib.Depledge(fundingModule, facilityData, collateralToken, collateralAmount);\n    }\n\n    /**\n     * @notice Takes out a loan from a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param debtToken Token to borrow\n     * @param borrowAmount Amount to borrow\n     * @dev Requires sufficient collateral, borrowed tokens sent to vault\n     */\n    function borrow(IFunding fundingModule, bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external nonReentrant {\n        _onlyAllocatorNotWinddown();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.borrow(facilityData, debtToken, borrowAmount);\n\n        emit EventsLib.Borrow(fundingModule, facilityData, debtToken, borrowAmount);\n    }\n\n    /**\n     * @notice Repays borrowed tokens to a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param debtToken Token to repay\n     * @param repayAmount Amount to repay (max uint256 = full debt)\n     * @dev Transfers tokens from vault to module, reduces debt position\n     */\n    function repay(IFunding fundingModule, bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external nonReentrant {\n        _onlyAllocatorOrWinddown();\n        _requireIsFunding(fundingModule);\n\n        uint256 debtAmount = fundingModule.debtBalance(facilityData, debtToken);\n\n        if (repayAmount > debtAmount) {\n            repayAmount = debtAmount;\n        }\n\n        debtToken.safeTransfer(address(fundingModule), repayAmount);\n        fundingModule.repay(facilityData, debtToken, repayAmount);\n\n        emit EventsLib.Repay(fundingModule, facilityData, debtToken, repayAmount);\n    }\n\n    /**\n     * @notice Recovers non-position tokens from a funding module\n     * @param fundingModule Module to skim from\n     * @param token Token to recover\n     * @dev NAV must remain unchanged to prevent skimming tokenized positions\n     */\n    function skimFunding(IFunding fundingModule, IERC20 token) external nonReentrant {\n        _onlyAllocatorOrWinddown();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.skim(token);\n    }\n\n    /**\n     * @notice Provides temporary liquidity for complex operations\n     * @param flashToken Token to flash loan\n     * @param flashAmount Amount to provide temporarily\n     * @param data Custom data passed to the callback\n     * @dev Caller must implement IBoxFlashCallback; the Box returns the tokens within the same transaction\n     * @dev NAV is cached during flash to prevent manipulation\n     */\n    function flash(IERC20 flashToken, uint256 flashAmount, bytes calldata data) external {\n        _onlyAllocatorOrWinddown();\n        _requireNonZeroAddress(address(flashToken));\n        _requireIsTokenOrAsset(flashToken);\n        // Prevent re-entrancy. Can't use nonReentrant modifier because of conflict with allocate/deallocate/reallocate\n        require(_cachedNavDepth == 0, ErrorsLib.ReentryNotAllowed());\n\n        // Cache NAV before starting flash operation for slippage calculations\n        _startNavCache();\n\n        // Transfer flash amount FROM caller TO this contract\n        flashToken.safeTransferFrom(msg.sender, address(this), flashAmount);\n\n        // Call the callback function on the caller\n        IBoxFlashCallback(msg.sender).onBoxFlash(flashToken, flashAmount, data);\n\n        // Repay the flash loan by transferring back TO caller\n        flashToken.safeTransfer(msg.sender, flashAmount);\n\n        _endNavCache();\n\n        emit EventsLib.Flash(msg.sender, flashToken, flashAmount);\n    }\n\n    /**\n     * @notice Executes multiple calls in a single transaction\n     * @param data Array of encoded function calls\n     * @dev Allows EOAs to execute multiple operations atomically\n     */\n    function multicall(bytes[] calldata data) external {\n        uint256 length = data.length;\n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);\n            if (!success) {\n                assembly (\"memory-safe\") {\n                    revert(add(32, returnData), mload(returnData))\n                }\n            }\n        }\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Sets the address that receives skimmed tokens\n     * @param newSkimRecipient New recipient address for skimmed tokens\n     * @dev Only owner can call this function\n     */\n    function setSkimRecipient(address newSkimRecipient) external {\n        _onlyOwner();\n        _requireNonZeroAddress(newSkimRecipient);\n        address oldRecipient = skimRecipient;\n        _requireNotEqualAddress(newSkimRecipient, oldRecipient);\n\n        skimRecipient = newSkimRecipient;\n\n        emit EventsLib.SkimRecipientUpdated(oldRecipient, newSkimRecipient);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract\n     * @param newOwner Address that will become the new owner\n     * @dev Immediately transfers all owner privileges\n     */\n    function transferOwnership(address newOwner) external {\n        _requireNonZeroAddress(newOwner);\n        address oldOwner = owner;\n        _onlyOwner();\n        _requireNotEqualAddress(newOwner, oldOwner);\n\n        owner = newOwner;\n\n        emit EventsLib.OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @notice Sets a new curator for the vault\n     * @param newCurator Address that will manage tokens and funding\n     * @dev Only owner can update the curator\n     */\n    function setCurator(address newCurator) external {\n        _onlyOwner();\n        _requireNonZeroAddress(newCurator);\n        _requireNotEqualAddress(newCurator, curator);\n\n        address oldCurator = curator;\n        curator = newCurator;\n\n        emit EventsLib.CuratorUpdated(oldCurator, newCurator);\n    }\n\n    /**\n     * @notice Sets a new guardian with emergency powers\n     * @param newGuardian Address that can trigger shutdowns and revoke actions\n     * @dev Requires timelock, only curator can execute\n     */\n    function setGuardian(address newGuardian) external {\n        _requireNotWinddown();\n        timelocked();\n        _onlyCurator();\n        _requireNonZeroAddress(newGuardian);\n        _requireNotEqualAddress(newGuardian, guardian);\n\n        address oldGuardian = guardian;\n        guardian = newGuardian;\n\n        emit EventsLib.GuardianUpdated(oldGuardian, newGuardian);\n    }\n\n    /**\n     * @notice Grants or revokes allocator privileges\n     * @param account Address to modify permissions for\n     * @param newIsAllocator True to grant allocator role, false to revoke\n     * @dev Allocators can execute investment strategies\n     */\n    function setIsAllocator(address account, bool newIsAllocator) external {\n        _onlyCurator();\n        _requireNonZeroAddress(account);\n        require(isAllocator[account] != newIsAllocator, ErrorsLib.InvalidValue());\n\n        isAllocator[account] = newIsAllocator;\n\n        emit EventsLib.AllocatorUpdated(account, newIsAllocator);\n    }\n\n    /**\n     * @notice Initiates emergency shutdown of the vault\n     * @dev Stops deposits and starts the wind-down process after warmup period\n     * @dev Guardian or curator can trigger shutdown\n     */\n    function shutdown() external {\n        require(msg.sender == guardian || msg.sender == curator, ErrorsLib.OnlyGuardianOrCuratorCanShutdown());\n        require(!isShutdown(), ErrorsLib.AlreadyShutdown());\n\n        shutdownTime = block.timestamp;\n\n        emit EventsLib.Shutdown(msg.sender);\n    }\n\n    /**\n     * @notice Cancels shutdown and returns vault to normal operation\n     * @dev Only guardian can recover, must be before wind-down phase starts\n     */\n    function recover() external {\n        require(msg.sender == guardian, ErrorsLib.OnlyGuardianCanRecover());\n        require(isShutdown(), ErrorsLib.NotShutdown());\n        require(!isWinddown(), ErrorsLib.CannotRecoverAfterWinddown());\n\n        shutdownTime = type(uint256).max;\n\n        emit EventsLib.Recover(msg.sender);\n    }\n\n    // ========== TIMELOCK GOVERNANCE ==========\n\n    /**\n     * @notice Submits a function call to the timelock queue\n     * @param data Encoded function call to be executed after delay\n     * @dev Delay duration depends on the function selector\n     * @dev WARNING: Timelock periods are 0 by default. Users and the box owner should ensure that\n     *      sufficiently long timelock periods are set for all critical functions (especially setGuardian)\n     *      to allow the guardian time to react if the curator is compromised.\n     */\n    function submit(bytes calldata data) external {\n        _onlyCurator();\n        require(executableAt[data] == 0, ErrorsLib.DataAlreadyTimelocked());\n        require(data.length >= 4, ErrorsLib.InvalidAmount());\n\n        bytes4 selector = bytes4(data);\n        uint256 delay = selector == IBox.decreaseTimelock.selector ? timelock[bytes4(data[4:8])] : timelock[selector];\n        require(delay != TIMELOCK_DISABLED, ErrorsLib.FunctionDisabled());\n        executableAt[data] = block.timestamp + delay;\n\n        emit EventsLib.TimelockSubmitted(selector, data, executableAt[data], msg.sender);\n    }\n\n    /**\n     * @dev Validates and consumes a timelocked transaction\n     * @dev Checks if current calldata is timelocked and ready for execution\n     */\n    function timelocked() internal {\n        require(executableAt[msg.data] > 0, ErrorsLib.DataNotTimelocked());\n        require(block.timestamp >= executableAt[msg.data], ErrorsLib.TimelockNotExpired());\n\n        executableAt[msg.data] = 0;\n\n        emit EventsLib.TimelockExecuted(bytes4(msg.data), msg.data, msg.sender);\n    }\n\n    /**\n     * @notice Cancels a pending timelocked transaction\n     * @param data Encoded function call to cancel\n     * @dev Guardian or curator can revoke pending transactions\n     */\n    function revoke(bytes calldata data) external {\n        require(msg.sender == curator || msg.sender == guardian, ErrorsLib.OnlyCuratorOrGuardian());\n        require(executableAt[data] > 0, ErrorsLib.DataNotTimelocked());\n\n        executableAt[data] = 0;\n\n        emit EventsLib.TimelockRevoked(bytes4(data), data, msg.sender);\n    }\n\n    /**\n     * @notice Extends the timelock delay for a function\n     * @param selector Function signature to modify\n     * @param newDuration New delay in seconds (must be longer than current)\n     * @dev No timelock required to increase delays\n     */\n    function increaseTimelock(bytes4 selector, uint256 newDuration) external {\n        _onlyCurator();\n        require(newDuration <= TIMELOCK_CAP, ErrorsLib.InvalidTimelock());\n        require(newDuration > timelock[selector], ErrorsLib.TimelockNotIncreasing());\n\n        timelock[selector] = newDuration;\n\n        emit EventsLib.TimelockIncreased(selector, newDuration, msg.sender);\n    }\n\n    /**\n     * @notice Reduces the timelock delay for a function\n     * @param selector Function signature to modify\n     * @param newDuration New delay in seconds (must be shorter than current)\n     * @dev Requires timelock to prevent governance attacks\n     */\n    function decreaseTimelock(bytes4 selector, uint256 newDuration) external {\n        timelocked();\n        _onlyCurator();\n        uint256 currentTimelock = timelock[selector];\n        require(currentTimelock != TIMELOCK_DISABLED, ErrorsLib.InvalidTimelock());\n        require(newDuration < currentTimelock, ErrorsLib.TimelockNotDecreasing());\n\n        timelock[selector] = newDuration;\n\n        emit EventsLib.TimelockDecreased(selector, newDuration, msg.sender);\n    }\n\n    /**\n     * @notice Permanently disables a function by setting infinite timelock\n     * @param selector Function signature to disable\n     * @dev Irreversible - function becomes permanently inaccessible\n     * @dev Does not impact previsously queued changes\n     */\n    function abdicateTimelock(bytes4 selector) external {\n        _onlyCurator();\n\n        timelock[selector] = TIMELOCK_DISABLED;\n\n        emit EventsLib.TimelockIncreased(selector, TIMELOCK_DISABLED, msg.sender);\n    }\n\n    // ========== TIMELOCKED FUNCTIONS ==========\n\n    /**\n     * @notice Grants or revokes deposit privileges\n     * @param account Address to modify permissions for\n     * @param newIsFeeder True to allow deposits, false to revoke\n     * @dev Requires timelock to add feeders\n     */\n    function setIsFeeder(address account, bool newIsFeeder) external {\n        timelocked();\n        _requireNonZeroAddress(account);\n        require(isFeeder[account] != newIsFeeder, ErrorsLib.InvalidValue());\n\n        isFeeder[account] = newIsFeeder;\n\n        emit EventsLib.FeederUpdated(account, newIsFeeder);\n    }\n\n    /**\n     * @notice Sets the maximum tolerated slippage for swaps\n     * @param newMaxSlippage New limit scaled by PRECISION (e.g., 0.01e18 = 1%)\n     * @dev Requires timelock, applies per-swap and per-epoch\n     */\n    function setMaxSlippage(uint256 newMaxSlippage) external {\n        timelocked();\n        require(newMaxSlippage <= MAX_SLIPPAGE_LIMIT, ErrorsLib.SlippageTooHigh());\n        _requireNotEqual(newMaxSlippage, maxSlippage);\n\n        uint256 oldMaxSlippage = maxSlippage;\n        maxSlippage = newMaxSlippage;\n\n        emit EventsLib.MaxSlippageUpdated(oldMaxSlippage, newMaxSlippage);\n    }\n\n    /**\n     * @notice Whitelists a new investment token\n     * @param token Token contract to add\n     * @param oracle Price feed for the token\n     * @dev Requires timelock, oracle must return prices in base asset terms\n     */\n    function addToken(IERC20 token, IOracle oracle) external {\n        timelocked();\n        _requireNonZeroAddress(address(token));\n        _requireNotEqualAddress(address(token), asset);\n        require(address(oracle) != address(0), ErrorsLib.OracleRequired());\n        require(!isToken(token), ErrorsLib.TokenAlreadyWhitelisted());\n        require(tokens.length < MAX_TOKENS, ErrorsLib.TooManyTokens());\n\n        tokens.push(token);\n        oracles[token] = oracle;\n\n        emit EventsLib.TokenAdded(token, oracle);\n    }\n\n    /**\n     * @notice Removes a token from the whitelist\n     * @param token Token to delist\n     * @dev Token balance must be zero and not used in any funding module\n     */\n    function removeToken(IERC20 token) external {\n        _onlyCurator();\n        _requireIsToken(token);\n        require(token.balanceOf(address(this)) == 0, ErrorsLib.TokenBalanceMustBeZero());\n        require(!_isTokenUsedInFunding(token), ErrorsLib.CannotRemove());\n\n        uint256 length = tokens.length;\n        for (uint256 i; i < length; i++) {\n            if (tokens[i] == token) {\n                tokens[i] = tokens[length - 1];\n                tokens.pop();\n                break;\n            }\n        }\n\n        delete oracles[token];\n\n        emit EventsLib.TokenRemoved(token);\n    }\n\n    /**\n     * @notice Updates the price oracle for a whitelisted token\n     * @param token Token to update oracle for\n     * @param oracle New price feed contract\n     * @dev Requires timelock in normal operation, guardian can update during final wind-down\n     */\n    function changeTokenOracle(IERC20 token, IOracle oracle) external {\n        if (isWinddown()) {\n            require(block.timestamp >= shutdownTime + shutdownWarmup + shutdownSlippageDuration, ErrorsLib.NotAllowed());\n            _onlyGuardian();\n        } else {\n            _onlyCurator();\n            timelocked();\n        }\n        _requireNonZeroAddress(address(oracle));\n        _requireIsToken(token);\n        _requireNotEqualAddress(address(oracles[token]), address(oracle));\n\n        oracles[token] = oracle;\n\n        emit EventsLib.TokenOracleChanged(token, oracle);\n    }\n\n    /**\n     * @notice Adds a new funding module for borrowing/lending\n     * @param fundingModule Module contract to whitelist\n     * @dev Module must be empty with no facilities, collateral, or debt\n     */\n    function addFunding(IFunding fundingModule) external {\n        timelocked();\n        require(!fundingMap[fundingModule], ErrorsLib.AlreadyWhitelisted());\n        _requireNonZeroAddress(address(fundingModule));\n        // Check that Box is the owner of the funding module\n        (bool success, bytes memory data) = address(fundingModule).staticcall(abi.encodeWithSignature(\"owner()\"));\n        require(success && data.length == 32, ErrorsLib.InvalidValue());\n        address fundingOwner = abi.decode(data, (address));\n        require(fundingOwner == address(this), ErrorsLib.InvalidValue());\n        require(fundingModule.facilitiesLength() == 0, ErrorsLib.NotClean());\n        require(fundingModule.collateralTokensLength() == 0, ErrorsLib.NotClean());\n        require(fundingModule.debtTokensLength() == 0, ErrorsLib.NotClean());\n\n        fundingMap[fundingModule] = true;\n        fundings.push(fundingModule);\n\n        emit EventsLib.FundingModuleAdded(fundingModule);\n    }\n\n    /**\n     * @notice Registers a lending facility within a funding module\n     * @param fundingModule Module to add facility to\n     * @param facilityData Encoded facility parameters\n     * @dev Requires timelock, facility specifics depend on module implementation\n     */\n    function addFundingFacility(IFunding fundingModule, bytes calldata facilityData) external {\n        timelocked();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.addFacility(facilityData);\n\n        emit EventsLib.FundingFacilityAdded(fundingModule, facilityData);\n    }\n\n    /**\n     * @notice Enables a token as collateral in a funding module\n     * @param fundingModule Module to configure\n     * @param collateralToken Token to use as collateral\n     * @dev Token must be whitelisted in the vault first\n     */\n    function addFundingCollateral(IFunding fundingModule, IERC20 collateralToken) external {\n        timelocked();\n        _requireIsFunding(fundingModule);\n        _requireIsTokenOrAsset(collateralToken);\n\n        fundingModule.addCollateralToken(collateralToken);\n\n        emit EventsLib.FundingCollateralAdded(fundingModule, collateralToken);\n    }\n\n    /**\n     * @notice Enables a token for borrowing in a funding module\n     * @param fundingModule Module to configure\n     * @param debtToken Token that can be borrowed\n     * @dev Token must be whitelisted in the vault first\n     */\n    function addFundingDebt(IFunding fundingModule, IERC20 debtToken) external {\n        timelocked();\n        _requireIsFunding(fundingModule);\n        _requireIsTokenOrAsset(debtToken);\n\n        fundingModule.addDebtToken(debtToken);\n\n        emit EventsLib.FundingDebtAdded(fundingModule, debtToken);\n    }\n\n    /**\n     * @notice Removes a funding module from the vault\n     * @param fundingModule Module to remove\n     * @dev Module must be empty with no active facilities, collateral, or debt\n     */\n    function removeFunding(IFunding fundingModule) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        require(fundingModule.facilitiesLength() == 0, ErrorsLib.CannotRemove());\n        require(fundingModule.collateralTokensLength() == 0, ErrorsLib.CannotRemove());\n        require(fundingModule.debtTokensLength() == 0, ErrorsLib.CannotRemove());\n\n        fundingMap[fundingModule] = false;\n        uint256 index = _findFundingIndex(fundingModule);\n        fundings[index] = fundings[fundings.length - 1];\n        fundings.pop();\n\n        emit EventsLib.FundingModuleRemoved(fundingModule);\n    }\n\n    /**\n     * @notice Deregisters a lending facility from a funding module\n     * @param fundingModule Module containing the facility\n     * @param facilityData Encoded facility identifier\n     * @dev Facility must have no outstanding positions\n     */\n    function removeFundingFacility(IFunding fundingModule, bytes calldata facilityData) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.removeFacility(facilityData);\n\n        emit EventsLib.FundingFacilityRemoved(fundingModule, facilityData);\n    }\n\n    /**\n     * @notice Disables a token as collateral in a funding module\n     * @param fundingModule Module to update\n     * @param collateralToken Token to remove from collateral list\n     * @dev Token must not be actively used as collateral\n     */\n    function removeFundingCollateral(IFunding fundingModule, IERC20 collateralToken) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.removeCollateralToken(collateralToken);\n\n        emit EventsLib.FundingCollateralRemoved(fundingModule, collateralToken);\n    }\n\n    /**\n     * @notice Disables borrowing of a token in a funding module\n     * @param fundingModule Module to update\n     * @param debtToken Token to remove from debt list\n     * @dev No outstanding debt must exist for this token\n     */\n    function removeFundingDebt(IFunding fundingModule, IERC20 debtToken) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.removeDebtToken(debtToken);\n\n        emit EventsLib.FundingDebtRemoved(fundingModule, debtToken);\n    }\n\n    // ========== VIEW FUNCTIONS ==========\n    /**\n     * @notice Checks if a token is whitelisted for investment\n     * @param token Token to check\n     * @return True if the token has an associated oracle\n     */\n    function isToken(IERC20 token) public view returns (bool) {\n        return address(oracles[token]) != address(0);\n    }\n\n    /**\n     * @notice Checks if a token is the base asset or a whitelisted token\n     * @param token Token to check\n     * @return True if it's the base asset or has an oracle\n     */\n    function isTokenOrAsset(IERC20 token) public view returns (bool) {\n        return address(token) == asset || address(oracles[token]) != address(0);\n    }\n\n    /**\n     * @notice Gets the count of whitelisted tokens\n     * @return Number of tokens in the investment list\n     */\n    function tokensLength() external view returns (uint256) {\n        return tokens.length;\n    }\n\n    /**\n     * @notice Checks if a funding module is authorized\n     * @param fundingModule Module to verify\n     * @return True if the module can be used for borrowing/lending\n     */\n    function isFunding(IFunding fundingModule) public view returns (bool) {\n        return fundingMap[fundingModule];\n    }\n\n    /**\n     * @notice Gets the count of active funding modules\n     * @return Number of modules available for borrowing/lending\n     */\n    function fundingsLength() external view override returns (uint256) {\n        return fundings.length;\n    }\n\n    /**\n     * @notice Checks if the vault is in shutdown mode\n     * @return True if shutdown has been triggered\n     */\n    function isShutdown() public view returns (bool) {\n        return shutdownTime != type(uint256).max;\n    }\n\n    /**\n     * @notice Checks if the vault has entered wind-down phase\n     * @return True if past the warmup period after shutdown\n     */\n    function isWinddown() public view returns (bool) {\n        return shutdownTime != type(uint256).max && block.timestamp >= shutdownTime + shutdownWarmup;\n    }\n\n    // ========== INTERNAL FUNCTIONS ==========\n\n    /**\n     * @dev Checks if msg.sender is the owner\n     */\n    function _onlyOwner() internal view {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n    }\n\n    /**\n     * @dev Checks if msg.sender is the curator\n     */\n    function _onlyCurator() internal view {\n        require(msg.sender == curator, ErrorsLib.OnlyCurator());\n    }\n\n    /**\n     * @dev Checks that an address is not zero\n     */\n    function _requireNonZeroAddress(address addr) internal pure {\n        require(addr != address(0), ErrorsLib.InvalidAddress());\n    }\n\n    /**\n     * @dev Checks if a token is whitelisted\n     */\n    function _requireIsToken(IERC20 token) internal view {\n        require(isToken(token), ErrorsLib.TokenNotWhitelisted());\n    }\n\n    /**\n     * @dev Checks if a funding module is whitelisted\n     */\n    function _requireIsFunding(IFunding fundingModule) internal view {\n        require(isFunding(fundingModule), ErrorsLib.NotWhitelisted());\n    }\n\n    /**\n     * @dev Checks that vault is not in winddown\n     */\n    function _requireNotWinddown() internal view {\n        require(!isWinddown(), ErrorsLib.CannotDuringWinddown());\n    }\n\n    /**\n     * @dev Checks if msg.sender is allocator and not in winddown\n     */\n    function _onlyAllocatorNotWinddown() internal view {\n        require(isAllocator[msg.sender] && !isWinddown(), ErrorsLib.OnlyAllocators());\n    }\n\n    /**\n     * @dev Checks if msg.sender is allocator or in winddown\n     */\n    function _onlyAllocatorOrWinddown() internal view {\n        require(isAllocator[msg.sender] || isWinddown(), ErrorsLib.OnlyAllocatorsOrWinddown());\n    }\n\n    /**\n     * @dev Checks that two values are not equal\n     */\n    function _requireNotEqual(uint256 a, uint256 b) internal pure {\n        require(a != b, ErrorsLib.InvalidValue());\n    }\n\n    /**\n     * @dev Checks that two addresses are not equal\n     */\n    function _requireNotEqualAddress(address a, address b) internal pure {\n        require(a != b, ErrorsLib.InvalidValue());\n    }\n\n    /**\n     * @dev Checks if msg.sender is the guardian\n     */\n    function _onlyGuardian() internal view {\n        require(msg.sender == guardian, ErrorsLib.OnlyGuardian());\n    }\n\n    /**\n     * @dev Checks if msg.sender is allocator\n     */\n    function _onlyAllocator() internal view {\n        require(isAllocator[msg.sender], ErrorsLib.OnlyAllocators());\n    }\n\n    /**\n     * @dev Checks if msg.sender is feeder\n     */\n    function _onlyFeeder() internal view {\n        require(isFeeder[msg.sender], ErrorsLib.OnlyFeeders());\n    }\n\n    /**\n     * @dev Checks that vault is not shutdown\n     */\n    function _requireNotShutdown() internal view {\n        require(!isShutdown(), ErrorsLib.CannotDuringShutdown());\n    }\n\n    /**\n     * @dev Checks if token is whitelisted or is the base asset\n     */\n    function _requireIsTokenOrAsset(IERC20 token) internal view {\n        require(isTokenOrAsset(token), ErrorsLib.TokenNotWhitelisted());\n    }\n\n    /**\n     * @dev Starts NAV caching for the current operation\n     * @dev Caches NAV on first call (depth 0 -> 1), increments depth on nested calls\n     * @dev Properly handles nesting when swaps are called from flash callbacks\n     */\n    function _startNavCache() internal {\n        if (_cachedNavDepth == 0) {\n            _cachedNav = _nav();\n        }\n        _cachedNavDepth++;\n    }\n\n    /**\n     * @dev Ends NAV caching for the current operation\n     * @dev Decrements the depth counter\n     */\n    function _endNavCache() internal {\n        _cachedNavDepth--;\n    }\n\n    /**\n     * @dev Executes a swap through a swapper contract with approval management\n     * @param fromToken Token to sell\n     * @param toToken Token to buy\n     * @param maxAmount Maximum amount of fromToken to sell\n     * @param swapper Swapper contract to execute the trade\n     * @param data Custom data for the swapper\n     * @return spent Actual amount of fromToken spent\n     * @return received Amount of toToken received\n     */\n    function _executeSwap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 maxAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) internal returns (uint256 spent, uint256 received) {\n        uint256 fromBefore = fromToken.balanceOf(address(this));\n        uint256 toBefore = toToken.balanceOf(address(this));\n\n        fromToken.forceApprove(address(swapper), maxAmount);\n        swapper.sell(fromToken, toToken, maxAmount, data);\n        fromToken.forceApprove(address(swapper), 0);\n\n        spent = fromBefore - fromToken.balanceOf(address(this));\n        received = toToken.balanceOf(address(this)) - toBefore;\n\n        require(spent <= maxAmount, ErrorsLib.SwapperDidSpendTooMuch());\n    }\n\n    /**\n     * @dev Calculates slippage percentage from expected vs actual amounts\n     * @param expectedAmount Expected amount based on oracle price\n     * @param actualAmount Actual amount received/spent\n     * @return slippagePct Slippage as a percentage scaled by PRECISION\n     */\n    function _calculateSlippagePct(uint256 expectedAmount, uint256 actualAmount) internal pure returns (int256 slippagePct) {\n        if (expectedAmount == 0) return 0;\n\n        int256 slippage = expectedAmount.toInt256() - actualAmount.toInt256();\n        // Round up when calculating slippage to be conservative\n        if (slippage >= 0) {\n            // Positive slippage (loss): round up\n            slippagePct = int256(uint256(slippage).mulDiv(PRECISION, expectedAmount, Math.Rounding.Ceil));\n        } else {\n            // Negative slippage (gain): round down (more conservative)\n            slippagePct = -int256(uint256(-slippage).mulDiv(PRECISION, expectedAmount, Math.Rounding.Floor));\n        }\n    }\n\n    /**\n     * @dev Calculates minimum acceptable amount based on slippage tolerance\n     * @param expectedAmount Expected amount based on oracle price\n     * @param tolerance Maximum allowed slippage scaled by PRECISION\n     * @return minAmount Minimum acceptable amount after slippage\n     */\n    function _calculateMinAmount(uint256 expectedAmount, uint256 tolerance) internal pure returns (uint256 minAmount) {\n        minAmount = expectedAmount.mulDiv(PRECISION - tolerance, PRECISION, Math.Rounding.Ceil);\n    }\n\n    /**\n     * @dev Tracks slippage within current epoch and enforces limits\n     * @param slippagePct Slippage to add scaled by PRECISION\n     * @dev Resets epoch if duration has passed\n     */\n    function _increaseSlippage(uint256 slippagePct) internal {\n        // Reset epoch if expired\n        if (block.timestamp >= slippageEpochStart + slippageEpochDuration) {\n            slippageEpochStart = block.timestamp;\n            accumulatedSlippage = slippagePct;\n            emit EventsLib.SlippageEpochReset(block.timestamp);\n        } else {\n            accumulatedSlippage += slippagePct;\n        }\n\n        require(accumulatedSlippage < maxSlippage, ErrorsLib.TooMuchAccumulatedSlippage());\n\n        emit EventsLib.SlippageAccumulated(slippagePct, accumulatedSlippage);\n    }\n\n    /**\n     * @dev Calculates total vault value across all positions\n     * @return nav Sum of base asset, token values, and funding positions\n     * @dev Negative funding NAV is floored to zero\n     * @dev Reverts if called during NAV-cached operations (swaps or flash) to prevent read-only reentrancy\n     */\n    function _nav() internal view returns (uint256 nav) {\n        require(_cachedNavDepth == 0, ErrorsLib.NoNavDuringCache());\n        nav = IERC20(asset).balanceOf(address(this));\n\n        // Add value of all tokens\n        uint256 length = tokens.length;\n        for (uint256 i; i < length; i++) {\n            IERC20 token = tokens[i];\n            IOracle oracle = oracles[token];\n            uint256 tokenBalance = token.balanceOf(address(this));\n            if (tokenBalance > 0) {\n                nav += tokenBalance.mulDiv(oracle.price(), ORACLE_PRECISION);\n            }\n        }\n        // Loop over funding sources\n        length = fundings.length;\n        for (uint256 i; i < length; i++) {\n            IFunding funding = fundings[i];\n            nav += funding.nav(IOracleCallback(address(this)));\n        }\n    }\n\n    /**\n     * @dev Calculates dynamic slippage tolerance during wind-down\n     * @return Slippage limit that increases linearly over shutdown duration\n     * @dev Returns up to 1% slippage after full duration\n     */\n    function _winddownSlippageTolerance() internal view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - shutdownWarmup - shutdownTime;\n        return\n            (timeElapsed < shutdownSlippageDuration)\n                ? timeElapsed.mulDiv(MAX_SLIPPAGE_LIMIT, shutdownSlippageDuration)\n                : MAX_SLIPPAGE_LIMIT;\n    }\n\n    /**\n     * @dev Locates a funding module's position in the array\n     * @param fundingModule Module to find\n     * @return Index in the fundings array\n     * @dev Reverts if module is not whitelisted\n     */\n    function _findFundingIndex(IFunding fundingModule) internal view returns (uint256) {\n        uint256 length = fundings.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (fundings[i] == fundingModule) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n\n    /**\n     * @dev Checks if a token is used in any funding module\n     * @param token Token to check\n     * @return True if token is used as collateral or debt anywhere\n     */\n    function _isTokenUsedInFunding(IERC20 token) internal view returns (bool) {\n        uint256 length = fundings.length;\n        for (uint256 i; i < length; i++) {\n            IFunding funding = fundings[i];\n            if (funding.isCollateralToken(token) || funding.isDebtToken(token)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Sums outstanding debt for a token across all modules\n     * @param debtToken Token to check debt for\n     * @return totalDebt Combined debt balance from all facilities\n     */\n    function _debtBalance(IERC20 debtToken) internal view returns (uint256 totalDebt) {\n        uint256 length = fundings.length;\n        for (uint256 i; i < length; i++) {\n            IFunding funding = fundings[i];\n            totalDebt += funding.debtBalance(debtToken);\n        }\n    }\n}\n"
    }
}