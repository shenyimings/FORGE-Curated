{
    "vfp_id": "vfp_00129",
    "project_name": "cantina_euler_swap_april2025.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "maxWithdraw in QuoteLib.calcLimits() double-counts deposited assets",
            "description": "The calcLimits function adds deposited assets to maxWithdraw after already including them in cash, leading to double-counting. However, a subsequent check ensures maxWithdraw does not exceed cash, which mitigates the issue. The root cause is redundant logic. While the double-counting is incorrect, it does not result in incorrect final values due to the override. The impact is informational, as it represents a code inefficiency and potential confusion rather than a functional bug.\n",
            "severity": "Informational",
            "location": [
                "QuoteLib.sol#L98-L103"
            ],
            "files": [
                "euler-swap/src/libraries/QuoteLib.sol"
            ]
        }
    ],
    "affected_files": {
        "QuoteLib.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport {IEVC} from \"evc/interfaces/IEthereumVaultConnector.sol\";\nimport {IEVault} from \"evk/EVault/IEVault.sol\";\nimport {IEulerSwap} from \"../interfaces/IEulerSwap.sol\";\nimport {CtxLib} from \"./CtxLib.sol\";\nimport {CurveLib} from \"./CurveLib.sol\";\n\nlibrary QuoteLib {\n    error UnsupportedPair();\n    error OperatorNotInstalled();\n    error SwapLimitExceeded();\n\n    /// @dev Computes the quote for a swap by applying fees and validating state conditions\n    /// @param evc EVC instance\n    /// @param p The EulerSwap params\n    /// @param asset0IsInput Swap direction\n    /// @param amount The amount to quote (input amount if exactIn=true, output amount if exactIn=false)\n    /// @param exactIn True if quoting for exact input amount, false if quoting for exact output amount\n    /// @return The quoted amount (output amount if exactIn=true, input amount if exactIn=false)\n    /// @dev Validates:\n    ///      - EulerSwap operator is installed\n    ///      - Token pair is supported\n    ///      - Sufficient reserves exist\n    ///      - Sufficient cash is available\n    function computeQuote(address evc, IEulerSwap.Params memory p, bool asset0IsInput, uint256 amount, bool exactIn)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount == 0) return 0;\n\n        require(IEVC(evc).isAccountOperatorAuthorized(p.eulerAccount, address(this)), OperatorNotInstalled());\n        require(amount <= type(uint112).max, SwapLimitExceeded());\n\n        uint256 fee = p.fee;\n\n        // exactIn: decrease effective amountIn\n        if (exactIn) amount = amount - (amount * fee / 1e18);\n\n        (uint256 inLimit, uint256 outLimit) = calcLimits(p, asset0IsInput);\n\n        uint256 quote = findCurvePoint(p, amount, exactIn, asset0IsInput);\n\n        if (exactIn) {\n            // if `exactIn`, `quote` is the amount of assets to buy from the AMM\n            require(amount <= inLimit && quote <= outLimit, SwapLimitExceeded());\n        } else {\n            // if `!exactIn`, `amount` is the amount of assets to buy from the AMM\n            require(amount <= outLimit && quote <= inLimit, SwapLimitExceeded());\n        }\n\n        // exactOut: inflate required amountIn\n        if (!exactIn) quote = (quote * 1e18) / (1e18 - fee);\n\n        return quote;\n    }\n\n    /// @notice Calculates the maximum input and output amounts for a swap based on protocol constraints\n    /// @dev Determines limits by checking multiple factors:\n    ///      1. Supply caps and existing debt for the input token\n    ///      2. Available reserves in the EulerSwap for the output token\n    ///      3. Available cash and borrow caps for the output token\n    ///      4. Account balances in the respective vaults\n    /// @param p The EulerSwap params\n    /// @param asset0IsInput Boolean indicating whether asset0 (true) or asset1 (false) is the input token\n    /// @return uint256 Maximum amount of input token that can be deposited\n    /// @return uint256 Maximum amount of output token that can be withdrawn\n    function calcLimits(IEulerSwap.Params memory p, bool asset0IsInput) internal view returns (uint256, uint256) {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n\n        uint256 inLimit = type(uint112).max;\n        uint256 outLimit = type(uint112).max;\n\n        address eulerAccount = p.eulerAccount;\n        (IEVault vault0, IEVault vault1) = (IEVault(p.vault0), IEVault(p.vault1));\n        // Supply caps on input\n        {\n            IEVault vault = (asset0IsInput ? vault0 : vault1);\n            uint256 maxDeposit = vault.debtOf(eulerAccount) + vault.maxDeposit(eulerAccount);\n            if (maxDeposit < inLimit) inLimit = maxDeposit;\n        }\n\n        // Remaining reserves of output\n        {\n            uint112 reserveLimit = asset0IsInput ? s.reserve1 : s.reserve0;\n            if (reserveLimit < outLimit) outLimit = reserveLimit;\n        }\n\n        // Remaining cash and borrow caps in output\n        {\n            IEVault vault = (asset0IsInput ? vault1 : vault0);\n\n            uint256 cash = vault.cash();\n            if (cash < outLimit) outLimit = cash;\n\n            (, uint16 borrowCap) = vault.caps();\n            uint256 maxWithdraw = decodeCap(uint256(borrowCap));\n            maxWithdraw = vault.totalBorrows() > maxWithdraw ? 0 : maxWithdraw - vault.totalBorrows();\n            if (maxWithdraw > cash) maxWithdraw = cash;\n            maxWithdraw += vault.convertToAssets(vault.balanceOf(eulerAccount));\n            if (maxWithdraw < outLimit) outLimit = maxWithdraw;\n        }\n\n        return (inLimit, outLimit);\n    }\n\n    /// @notice Decodes a compact-format cap value to its actual numerical value\n    /// @dev The cap uses a compact-format where:\n    ///      - If amountCap == 0, there's no cap (returns max uint256)\n    ///      - Otherwise, the lower 6 bits represent the exponent (10^exp)\n    ///      - The upper bits (>> 6) represent the mantissa\n    ///      - The formula is: (10^exponent * mantissa) / 100\n    /// @param amountCap The compact-format cap value to decode\n    /// @return The actual numerical cap value (type(uint256).max if uncapped)\n    /// @custom:security Uses unchecked math for gas optimization as calculations cannot overflow:\n    ///                  maximum possible value 10^(2^6-1) * (2^10-1) â‰ˆ 1.023e+66 < 2^256\n    function decodeCap(uint256 amountCap) internal pure returns (uint256) {\n        if (amountCap == 0) return type(uint256).max;\n\n        unchecked {\n            // Cannot overflow because this is less than 2**256:\n            //   10**(2**6 - 1) * (2**10 - 1) = 1.023e+66\n            return 10 ** (amountCap & 63) * (amountCap >> 6) / 100;\n        }\n    }\n\n    /// @notice Verifies that the given tokens are supported by the EulerSwap pool and determines swap direction\n    /// @dev Returns a boolean indicating whether the input token is asset0 (true) or asset1 (false)\n    /// @param p The EulerSwap params\n    /// @param tokenIn The input token address for the swap\n    /// @param tokenOut The output token address for the swap\n    /// @return asset0IsInput True if tokenIn is asset0 and tokenOut is asset1, false if reversed\n    /// @custom:error UnsupportedPair Thrown if the token pair is not supported by the EulerSwap pool\n    function checkTokens(IEulerSwap.Params memory p, address tokenIn, address tokenOut)\n        internal\n        view\n        returns (bool asset0IsInput)\n    {\n        address asset0 = IEVault(p.vault0).asset();\n        address asset1 = IEVault(p.vault1).asset();\n\n        if (tokenIn == asset0 && tokenOut == asset1) asset0IsInput = true;\n        else if (tokenIn == asset1 && tokenOut == asset0) asset0IsInput = false;\n        else revert UnsupportedPair();\n    }\n\n    function findCurvePoint(IEulerSwap.Params memory p, uint256 amount, bool exactIn, bool asset0IsInput)\n        internal\n        view\n        returns (uint256 output)\n    {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n\n        uint256 px = p.priceX;\n        uint256 py = p.priceY;\n        uint256 x0 = p.equilibriumReserve0;\n        uint256 y0 = p.equilibriumReserve1;\n        uint256 cx = p.concentrationX;\n        uint256 cy = p.concentrationY;\n        uint112 reserve0 = s.reserve0;\n        uint112 reserve1 = s.reserve1;\n\n        uint256 xNew;\n        uint256 yNew;\n\n        if (exactIn) {\n            // exact in\n            if (asset0IsInput) {\n                // swap X in and Y out\n                xNew = reserve0 + amount;\n                if (xNew < x0) {\n                    // remain on f()\n                    yNew = CurveLib.f(xNew, px, py, x0, y0, cx);\n                } else {\n                    // move to g()\n                    yNew = CurveLib.fInverse(xNew, py, px, y0, x0, cy);\n                }\n                output = reserve1 > yNew ? reserve1 - yNew : 0;\n            } else {\n                // swap Y in and X out\n                yNew = reserve1 + amount;\n                if (yNew < y0) {\n                    // remain on g()\n                    xNew = CurveLib.f(yNew, py, px, y0, x0, cy);\n                } else {\n                    // move to f()\n                    xNew = CurveLib.fInverse(yNew, px, py, x0, y0, cx);\n                }\n                output = reserve0 > xNew ? reserve0 - xNew : 0;\n            }\n        } else {\n            // exact out\n            if (asset0IsInput) {\n                // swap Y out and X in\n                require(reserve1 > amount, SwapLimitExceeded());\n                yNew = reserve1 - amount;\n                if (yNew < y0) {\n                    // remain on g()\n                    xNew = CurveLib.f(yNew, py, px, y0, x0, cy);\n                } else {\n                    // move to f()\n                    xNew = CurveLib.fInverse(yNew, px, py, x0, y0, cx);\n                }\n                output = xNew > reserve0 ? xNew - reserve0 : 0;\n            } else {\n                // swap X out and Y in\n                require(reserve0 > amount, SwapLimitExceeded());\n                xNew = reserve0 - amount;\n                if (xNew < x0) {\n                    // remain on f()\n                    yNew = CurveLib.f(xNew, py, px, y0, x0, cx);\n                } else {\n                    // move to g()\n                    yNew = CurveLib.fInverse(xNew, py, px, y0, x0, cy);\n                }\n                output = yNew > reserve1 ? yNew - reserve1 : 0;\n            }\n        }\n    }\n}\n"
    }
}