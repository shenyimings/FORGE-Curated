{
    "vfp_id": "vfp_00015",
    "project_name": "cantina_level_money_february2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-348"
                ]
            },
            "title": "Implications of including 3rd party Eigenlayer strategy deposits",
            "description": "The LevelReserveLens._getReserves function includes the total collateral balance from third-party Eigenlayer strategy deposits in its calculation. This inclusion introduces uncertainty due to the lack of clarity around Eigenlayer's slashing conditions, which could affect the accuracy of reserve calculations. The root cause is the integration of external, unverified balances without safeguards. An attacker could potentially manipulate or exploit the system if Eigenlayer experiences slashing events or reporting inconsistencies. The impact is limited, as the team has chosen to exclude Eigenlayer balances until further updates, reducing immediate risk. However, the design decision carries low-risk implications for future integration.\n",
            "severity": "Low",
            "location": [
                "LevelReserveLens.sol#L263-L270"
            ],
            "files": [
                "contracts/src/lens/LevelReserveLens.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1120"
                ]
            },
            "title": "Decimal conversion could be simpler",
            "description": "The decimal conversion logic in LevelReserveLens.sol is more complex than necessary, particularly in cases involving USDC and USDT, where the fromDecimals and toDecimals values are known to be 6 and 18 respectively. The root cause is the use of a generalized conversion function when a hardcoded or simplified version would suffice. This does not introduce a security vulnerability but increases gas usage and code complexity unnecessarily. An attacker cannot exploit this directly, but it represents an inefficiency. The impact is purely informational, relating to code quality and optimization.\n",
            "severity": "Informational",
            "location": [
                "LevelReserveLens.sol#L236-L244"
            ],
            "files": [
                "contracts/src/lens/LevelReserveLens.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "getEigenStake simplification",
            "description": "The getEigenStake function in LevelReserveLens.sol declares a collateralToken variable that is not necessary for its logic. The root cause is redundant code that does not contribute to functionality. This has no security impact and cannot be exploited by an attacker. The recommendation was to simplify the function, which has since been made obsolete due to the exclusion of Eigenlayer integrations. The impact is informational, relating only to code clarity and maintainability.\n",
            "severity": "Informational",
            "location": [
                "LevelReserveLens.sol#L200-L203"
            ],
            "files": [
                "contracts/src/lens/LevelReserveLens.sol"
            ]
        }
    ],
    "affected_files": {
        "LevelReserveLens.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21;\n\nimport {Initializable} from \"@openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\n\nimport {ILevelMinting} from \"../interfaces/ILevelMinting.sol\";\nimport {IVault} from \"../interfaces/ISymbioticVault.sol\";\nimport {AggregatorV3Interface} from \"../interfaces/AggregatorV3Interface.sol\";\nimport {ILevelReserveLens} from \"../interfaces/lens/ILevelReserveLens.sol\";\n\n/**\n *                                     .-==+=======+:\n *                                      :---=-::-==:\n *                                      .-:-==-:-==:\n *                    .:::--::::::.     .--:-=--:--.       .:--:::--..\n *                   .=++=++:::::..     .:::---::--.    ....::...:::.\n *                    :::-::..::..      .::::-:::::.     ...::...:::.\n *                    ...::..::::..     .::::--::-:.    ....::...:::..\n *                    ............      ....:::..::.    ------:......\n *    ...........     ........:....     .....::..:..    ======-......      ...........\n *    :------:.:...   ...:+***++*#+     .------:---.    ...::::.:::...   .....:-----::.\n *    .::::::::-:..   .::--..:-::..    .-=+===++=-==:   ...:::..:--:..   .:==+=++++++*:\n *\n * @title LevelReserveLens\n * @author Level (https://level.money)\n * @notice The LevelReserveLens contract is a simple contract that allows users to query the reserves backing lvlUSD per underlying collateral token address.\n * @dev It is upgradeable so that we can add future reserve managers without affecting downstream consumers.\n */\ncontract LevelReserveLens is ILevelReserveLens, Initializable, OwnableUpgradeable, UUPSUpgradeable {\n    // Addresses that store lvlUSD reserves\n    address public constant levelMintingAddress = 0x8E7046e27D14d09bdacDE9260ff7c8c2be68a41f;\n    address public constant eigenReserveManager = 0x7B2c2C905184CEf1FABe920D4CbEA525acAa6f14;\n    address public constant symbioticReserveManager = 0x21C937d436f2D86859ce60311290a8072368932D;\n    address public constant karakReserveManager = 0x329F91FE82c1799C3e089FabE9D3A7efDC2D3151;\n    address public constant waUsdcSymbioticVault = 0x67F91a36c5287709E68E3420cd17dd5B13c60D6d;\n    address public constant waUsdtSymbioticVault = 0x9BF93077Ad7BB7f43E177b6AbBf8Dae914761599;\n    address public constant usdcEigenStrategy = 0x82A2e702C4CeCA35D8c474e218eD6f0852827380;\n    address public constant usdtEigenStrategy = 0x38fb62B973e4515a2A2A8B819a3B2217101Ad691;\n\n    address public constant usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public constant usdtAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address public constant waUsdcAddress = 0x78c6B27Be6DB520d332b1b44323F94bC831F5e33;\n    address public constant waUsdtAddress = 0xb723377679b807370Ae8615ae3E76F6D1E75a5F2;\n    address public constant lvlusdAddress = 0x7C1156E515aA1A2E851674120074968C905aAF37;\n\n    address public constant usdcOracle = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\n    address public constant usdtOracle = 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D;\n\n    uint8 public constant LVLUSD_DECIMALS = 18;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     * @param admin The address of the admin of the contract.\n     */\n    function initialize(address admin) public initializer {\n        __Ownable_init(admin);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getReserves(address collateral) public view virtual override returns (uint256) {\n        IERC20Metadata usdc = IERC20Metadata(usdcAddress);\n        IERC20Metadata usdt = IERC20Metadata(usdtAddress);\n\n        uint256 reserves;\n        if (collateral == address(usdc)) {\n            reserves = _getReserves(usdc, waUsdcAddress, usdcEigenStrategy, waUsdcSymbioticVault);\n\n            return safeAdjustForDecimals(reserves, usdc.decimals(), LVLUSD_DECIMALS);\n        } else if (collateral == address(usdt)) {\n            reserves = _getReserves(usdt, waUsdtAddress, usdtEigenStrategy, waUsdtSymbioticVault);\n\n            return safeAdjustForDecimals(reserves, usdt.decimals(), LVLUSD_DECIMALS);\n        } else {\n            revert(\"Invalid collateral token\");\n        }\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getReserveValue(address collateral) public view override returns (uint256 usdReserves) {\n        uint256 reserves = getReserves(collateral);\n\n        AggregatorV3Interface oracle;\n        if (collateral == usdcAddress) {\n            oracle = AggregatorV3Interface(usdcOracle);\n        } else if (collateral == usdtAddress) {\n            oracle = AggregatorV3Interface(usdtOracle);\n        } else {\n            revert(\"Invalid collateral token\");\n        }\n        (, int256 answer,,,) = oracle.latestRoundData();\n\n        if (answer == 0) {\n            revert(\"Oracle price is 0\");\n        }\n\n        uint8 oracleDecimals = oracle.decimals();\n\n        return (reserves * uint256(answer)) / (10 ** oracleDecimals);\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getReserveValue() public view override returns (uint256 usdReserves) {\n        address[] memory collateral = new address[](2);\n        collateral[0] = usdcAddress;\n        collateral[1] = usdtAddress;\n\n        uint256 totalReservesUsd;\n\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalReservesUsd += getReserveValue(collateral[i]);\n        }\n\n        return totalReservesUsd;\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getReservePrice() public view override returns (uint256) {\n        uint256 usdReserves = getReserveValue();\n        uint256 totalSupply = IERC20Metadata(lvlusdAddress).totalSupply();\n\n        uint256 answer;\n\n        if (usdReserves >= totalSupply) {\n            answer = 1e18;\n        } else {\n            answer = usdReserves * 1e18 / totalSupply;\n        }\n\n        return answer;\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getReservePriceDecimals() external pure override returns (uint8) {\n        return LVLUSD_DECIMALS;\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getMintPrice(IERC20Metadata collateral) external view override returns (uint256) {\n        ILevelMinting levelMinting = ILevelMinting(levelMintingAddress);\n\n        (int256 price, uint256 oracleDecimals) = levelMinting.getPriceAndDecimals(address(collateral));\n        if (price == 0) {\n            revert(\"Oracle price is 0\");\n        }\n\n        uint8 collateralAssetDecimals = collateral.decimals();\n        uint256 oneUnit = 10 ** (collateralAssetDecimals);\n\n        uint256 mintPrice;\n        if (uint256(price) < 10 ** oracleDecimals) {\n            mintPrice = (oneUnit * uint256(price) * 10 ** 18) / 10 ** (oracleDecimals) / 10 ** (collateralAssetDecimals);\n        } else {\n            mintPrice = (oneUnit * (10 ** 18)) / (10 ** (collateralAssetDecimals));\n        }\n\n        return mintPrice;\n    }\n\n    /// @inheritdoc ILevelReserveLens\n    function getRedeemPrice(IERC20Metadata collateral) external view override returns (uint256) {\n        ILevelMinting levelMinting = ILevelMinting(levelMintingAddress);\n\n        (int256 price, uint256 oracleDecimals) = levelMinting.getPriceAndDecimals(address(collateral));\n        if (price == 0) {\n            revert(\"Oracle price is 0\");\n        }\n\n        uint8 collateralAssetDecimals = collateral.decimals();\n        uint256 oneLvlUsd = 1e18;\n\n        uint256 redeemPrice;\n        if (uint256(price) > 10 ** oracleDecimals) {\n            redeemPrice =\n                (oneLvlUsd * (10 ** oracleDecimals) * (10 ** (collateralAssetDecimals))) / uint256(price) / (10 ** 18);\n        } else {\n            redeemPrice = (oneLvlUsd * (10 ** (collateralAssetDecimals))) / (10 ** 18);\n        }\n\n        return redeemPrice;\n    }\n\n    /**\n     * @notice Returns the underlying tokens staked in a given Eigen strategy\n     * @dev Note: this function returns everything held in the strategy, which may include deposits from non-Level participants\n     * @param collateral The address of the collateral token\n     * @param strategy The address of the strategy\n     * @return eigenStake The total collateral tokens held by the given Level strategy\n     */\n    function getEigenStake(IERC20Metadata collateral, address strategy) public view returns (uint256) {\n        IERC20Metadata collateralToken = IERC20Metadata(collateral);\n        return collateralToken.balanceOf(strategy);\n    }\n\n    /**\n     * @notice Returns the underlying tokens staked in a given Symbiotic vault and burner\n     * @dev Note: this function returns everything held in the strategy, which may include deposits from non-Level participants\n     * @param collateral The address of the collateral token\n     * @param vault The address of the Symbiotic vault\n     * @return symbioticStake The total collateral tokens held by the given vault and vault burner\n     */\n    function getSymbioticStake(IERC20Metadata collateral, address vault) public view returns (uint256) {\n        IERC20Metadata collateralToken = IERC20Metadata(collateral);\n        IVault symbioticVault = IVault(vault);\n\n        uint256 balance = collateralToken.balanceOf(vault);\n\n        if (symbioticVault.burner() != address(0)) {\n            balance += collateralToken.balanceOf(symbioticVault.burner());\n        }\n        return balance;\n    }\n\n    /**\n     * @notice Adjusts the amount for the difference in decimals. Reverts if the amount would lose precision.\n     * @param amount The amount to adjust\n     * @param fromDecimals The decimals of the amount\n     * @param toDecimals The decimals to adjust to\n     * @return adjustedAmount The adjusted amount\n     */\n    function safeAdjustForDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals)\n        public\n        pure\n        returns (uint256)\n    {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n\n        if (fromDecimals > toDecimals) {\n            revert(\"Cannot lose precision\");\n        } else {\n            return amount * (10 ** (toDecimals - fromDecimals));\n        }\n    }\n\n    /**\n     * @notice Helper function to get the reserves of the given collateral token.\n     * @param collateral The address of the collateral token.\n     * @param waCollateralAddress The address of the wrapped Aave token for the collateral.\n     * @param eigenStrategy The address of the Eigen strategy for the collateral.\n     * @param symbioticVault The address of the Symbiotic vault for the collateral.\n     * @return reserves The lvlUSD reserves for a given collateral token, in the given token's decimals.\n     */\n    function _getReserves(\n        IERC20Metadata collateral,\n        address waCollateralAddress,\n        address eigenStrategy,\n        address symbioticVault\n    ) internal view returns (uint256) {\n        IERC20Metadata waCollateral = IERC20Metadata(waCollateralAddress);\n\n        uint256 waCollateralInEigenStrategy = getEigenStake(waCollateral, eigenStrategy);\n        uint256 waCollateralInSymbiotic = getSymbioticStake(waCollateral, symbioticVault);\n\n        uint256 waCollateralBalance = waCollateral.balanceOf(eigenReserveManager)\n            + waCollateral.balanceOf(symbioticReserveManager) + waCollateral.balanceOf(karakReserveManager);\n        uint256 collateralBalance = collateral.balanceOf(eigenReserveManager)\n            + collateral.balanceOf(symbioticReserveManager) + collateral.balanceOf(karakReserveManager)\n            + collateral.balanceOf(levelMintingAddress);\n\n        return waCollateralBalance + collateralBalance + waCollateralInEigenStrategy + waCollateralInSymbiotic;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}\n"
    }
}