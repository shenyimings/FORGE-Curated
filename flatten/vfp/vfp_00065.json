{
    "vfp_id": "vfp_00065",
    "project_name": "Spectral (PR-29) - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "[H-1] The withdrawn amount should be tracked separately for each token",
            "description": "1. **Description:** The vulnerability arises because the `userPointsWithdrawn` state variable tracks the total withdrawn points per user across all tokens, rather than tracking withdrawals separately per token. This causes incorrect reversion when a user attempts to withdraw points for one token after having already withdrawn points for another.\n\n2. **Cause:** The root cause is the use of a single-level mapping `mapping(address => uint256)` to store withdrawn amounts, which does not differentiate between different token types. As a result, the withdrawal limit check aggregates withdrawals across tokens, leading to incorrect validation.\n\n3. **Exploitation:** An attacker cannot directly steal funds, but legitimate users are prevented from withdrawing their entitled tokens if they have already withdrawn points for another token. This could be exploited in a denial-of-service manner against specific users by forcing early withdrawals.\n\n4. **Impact:** Users may be unable to claim their full allocated rewards for certain tokens, leading to loss of access to entitled funds and reduced user trust in the system.\n",
            "severity": "High",
            "location": [
                "OctoDistributor.sol::withdrawPoints#524-531"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "[L-1] The rewards could be withdrawn for both tokens if the same Merkle Root is updated",
            "description": "1. **Description:** If the same Merkle root is accidentally set for two different tokens, users can claim their allocated rewards for both tokens using the same proof, because the leaf node does not include the token address.\n\n2. **Cause:** The leaf in the Merkle tree is constructed only from the user address and total amount (`keccak256(abi.encodePacked(msg.sender, totalAmount))`), omitting the `_token` parameter. This allows the same proof to validate claims across multiple tokens if the root is duplicated.\n\n3. **Exploitation:** An attacker could monitor root updates and, upon detecting identical roots for different tokens, submit duplicate claims using the same Merkle proof for multiple tokens.\n\n4. **Impact:** This could lead to an over-distribution of rewards, where users receive more tokens than allocated, potentially depleting the reward pool and causing financial loss to the protocol.\n",
            "severity": "Low",
            "location": [
                "OctoDistributor.sol#L517"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "[I-1] MerkleRootUpdated event omits the token address",
            "description": "1. **Description:** The `MerkleRootUpdated` event does not include the token address, making it impossible for off-chain services to determine which token's Merkle root was updated.\n\n2. **Cause:** The event is defined as `event MerkleRootUpdated(bytes32 oldRoot, bytes32 newRoot);`, lacking the `_token` parameter that would identify the affected token.\n\n3. **Exploitation:** While not directly exploitable by an attacker, this omission hampers monitoring tools and indexing services, increasing the risk of delayed detection of malicious or erroneous root changes.\n\n4. **Impact:** Reduced observability and auditability of the system, potentially delaying incident response and reducing transparency for users and administrators.\n",
            "severity": "Informational",
            "location": [
                "OctoDistributor.sol#L96",
                "OctoDistributor.sol#L501"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "[I-2] withdrawPoints doesn't implement nonReentrant modifier",
            "description": "1. **Description:** The `withdrawPoints` function lacks the `nonReentrant` modifier, while other similar functions in the contract do include it, creating an inconsistency in reentrancy protection.\n\n2. **Cause:** The omission of the `nonReentrant` modifier exposes the function to potential reentrancy attacks if combined with external calls that can be manipulated by malicious contracts.\n\n3. **Exploitation:** An attacker could potentially re-enter the `withdrawPoints` function during execution (e.g., via a malicious token's `transfer` callback) to withdraw rewards multiple times before the state is updated.\n\n4. **Impact:** Although the risk is low due to the use of `safeTransfer` and the structure of the function, the absence of the modifier increases the attack surface and contradicts the project's own security practices.\n",
            "severity": "Informational",
            "location": [
                "OctoDistributor.sol#L510"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/octoDistributor/OctoDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "OctoDistributor.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IAutonomousAgentDeployer.sol\";\nimport \"../interfaces/IAgenticCompany.sol\";\nimport \"../interfaces/IAgenticCompanyFactory.sol\";\nimport \"../interfaces/IANSReverseRegistrar.sol\";\nimport \"../interfaces/IANSResolver.sol\";\nimport \"../interfaces/IAgentBalances.sol\";\nimport \"../interfaces/IAgentToken.sol\";\n\ncontract OctoDistributor is\n    IOctoDistributor,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    UUPSUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20 for IERC20;\n\n    struct SystemAddresses {\n        IAutonomousAgentDeployer autonomousDeployer;\n        IAgenticCompanyFactory agenticCompanyFactory;\n        IANSResolver ansResolver;\n        IANSReverseRegistrar ansReverseRegistrar;\n        address spectralTreasury;\n    }\n\n    uint256 public spectraCompanyIndex;\n\n    IERC20Upgradeable public spectral_token;\n    IERC20 public usdc_token;\n\n    uint8 public version;\n    address public admin;\n    uint256 public constant PRECISION = 10**4;\n\n    enum Parameter {\n        TRADING_REWARDS_TREASURY_CUT,\n        TRADING_REWARDS_CREATOR_CUT,\n        TRADING_REWARDS_SPECTRA_CUT,\n        TRADING_REWARDS_EMPLOYEES_CUT\n    }\n\n    struct UserBalances {\n        uint256 spectral;\n        uint256 usdc;\n        mapping(address => uint256 balance) agent_tokens_list;\n        mapping(address => uint256 index) agent_tokens_indecies;\n        address[] agent_tokens;\n    }\n\n    SystemAddresses public systemAddresses;\n    mapping(Parameter => uint256) public parameters;\n    mapping(address => UserBalances) public userBalances;\n    mapping(address => address) public agentCreators;\n\n    // Added in v2\n    bytes32 public pointsMerkleRoot;\n    mapping(address => uint256) public userPointsWithdrawn;\n    uint256[50] private __gap;\n\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n    event DistributeHiringBonuses(\n        address indexed company,\n        address indexed agentToken,\n        uint256 count,\n        uint256 totalSpec,\n        uint256 totalAgentToken,\n        uint256 totalUsdc,\n        HiringDistributionByAddress[] distributions\n    );\n    event DistributeTradingRewards (\n        address indexed agentToken,\n        uint256 usdcAmount,\n        address[] beneficiaries,\n        uint256[] amounts\n    );\n    event SetParameter(Parameter parameter, uint256 value);\n    event SetAgentCreator(address agentToken, address creator);\n    event SetAdmin(address admin);\n    event SetSpectraCompanyIndex(uint256 index);\n    event UpdateSystemAddress(uint8 index, address newAddress);\n    event Upgrade(address newImplementation, uint8 version);\n\n    // Events for v2\n    event MerkleRootUpdated(bytes32 oldRoot, bytes32 newRoot);\n    event RewardsClaimed(address indexed user, uint256 amount);\n\n    modifier onlyAutonomousDeployer() {\n        require(\n            msg.sender == address(systemAddresses.autonomousDeployer),\n            \"ONLY_AUTONOMOUS_DEPLOYER\"\n        );\n        _;\n    }\n    modifier onlyAgenticCompany() {\n        require(\n            systemAddresses.agenticCompanyFactory.isCompany(msg.sender) || msg.sender == admin,\n            \"ONLY_AGENTIC_COMPANY_CAN_DISTRIBUTE\"\n        );\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"ONLY_ADMIN\");\n        _;\n    }\n\n    modifier onlyAdminOrOwner() {\n        require(msg.sender == admin || msg.sender == owner(), \"ONLY_ADMIN_OR_OWNER\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _autonomousDeployer,\n        address _agenticCompanyFactory,\n        address _ansResolver,\n        address _ansReverseRegistrar,\n        address _spectralTreasury,\n        uint256 _spectraCompanyIndex,\n        address _usdc_token,\n        address _spectral_token,\n        bytes32 _initialMerkleRoot\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        admin = msg.sender;\n        require(_autonomousDeployer != address(0), \"AUTONOMOUS_ZERO_ADDRESS\");\n        require(_ansResolver != address(0), \"ANS_RESOLVER_ZERO_ADDRESS\");\n        require(_ansReverseRegistrar != address(0), \"ANS_REVERSE_REGISTRY_ZERO_ADDRESS\");\n        require(_spectralTreasury != address(0), \"SPECTRAL_TREASURY_ZERO_ADDRESS\");\n        require(_usdc_token != address(0), \"USDC_ZERO_ADDRESS\");\n        require(_spectral_token != address(0), \"SPEC_ZERO_ADDRESS\");\n        // We don't check the _agenticCompanyFactory since both contracts depend on each other and we may deploy this contract first then set the factory address\n        systemAddresses.autonomousDeployer = IAutonomousAgentDeployer(_autonomousDeployer);\n        systemAddresses.agenticCompanyFactory = IAgenticCompanyFactory(_agenticCompanyFactory);\n        systemAddresses.ansResolver = IANSResolver(_ansResolver);\n        systemAddresses.ansReverseRegistrar = IANSReverseRegistrar(_ansReverseRegistrar);\n        systemAddresses.spectralTreasury = _spectralTreasury;\n        usdc_token = IERC20(_usdc_token);\n        spectral_token = IERC20Upgradeable(_spectral_token);\n        spectraCompanyIndex = _spectraCompanyIndex;\n        parameters[Parameter.TRADING_REWARDS_TREASURY_CUT] = 2500;\n        parameters[Parameter.TRADING_REWARDS_CREATOR_CUT] = 7500;\n        parameters[Parameter.TRADING_REWARDS_SPECTRA_CUT] = 0;\n        parameters[Parameter.TRADING_REWARDS_EMPLOYEES_CUT] = 2500;\n        pointsMerkleRoot = _initialMerkleRoot;\n        version = 1;\n    }\n\n    function setAgenticCompanyFactory(address _agenticCompanyFactory) external onlyOwner {\n        require(_agenticCompanyFactory != address(0), \"ZERO_ADDRESS\");\n        systemAddresses.agenticCompanyFactory = IAgenticCompanyFactory(_agenticCompanyFactory);\n        emit UpdateSystemAddress(1, _agenticCompanyFactory);\n    }\n\n    function withdraw(address _token, uint256 _amount) external nonReentrant {\n        require(_amount > 0, \"AMOUNT_ZERO\");\n        require(_token != address(0), \"ZERO_ADDRESS\");\n        UserBalances storage user = userBalances[msg.sender];\n        if (_token == address(spectral_token)) {\n            require(user.spectral >= _amount, \"INSUFFICIENT_BALANCE\");\n            user.spectral -= _amount;\n        } else if (_token == address(usdc_token)) {\n            require(user.usdc >= _amount, \"INSUFFICIENT_BALANCE\");\n            user.usdc -= _amount;\n        } else {\n            require(\n                user.agent_tokens_list[_token] >= _amount,\n                \"INSUFFICIENT_BALANCE\"\n            );\n            user.agent_tokens_list[_token] -= _amount;\n            if (user.agent_tokens_list[_token] == 0) {\n                _removeAgentToken(user, _token);\n            }\n        }\n        IERC20Upgradeable(_token).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _token, _amount);\n    }\n\n    function getUserAgentTokensCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userBalances[user].agent_tokens.length;\n    }\n\n    function setParameters(\n        Parameter[] calldata _parameters,\n        uint256[] calldata _values\n    ) external onlyOwner {\n        // Parameters need to be checked:\n        // parameters[Parameter.TRADING_REWARDS_TREASURY_CUT] + parameters[Parameter.TRADING_REWARDS_CREATOR_CUT] = 10000;\n        // parameters[Parameter.TRADING_REWARDS_TREASURY_CUT] + parameters[Parameter.TRADING_REWARDS_SPECTRA_CUT] + parameters[Parameter.TRADING_REWARDS_EMPLOYEES_CUT] = 5000;\n        require(_parameters.length == _values.length, \"INVALID_LENGTH\");\n        for (uint256 i = 0; i < _parameters.length; i++) {\n            require(_values[i] <= PRECISION, \"PARAMETER_OUT_OF_RANGE\");\n            parameters[_parameters[i]] = _values[i];\n            emit SetParameter(_parameters[i], _values[i]);\n        }\n        require(\n            parameters[Parameter.TRADING_REWARDS_TREASURY_CUT] +\n                parameters[Parameter.TRADING_REWARDS_CREATOR_CUT] ==\n                PRECISION,\n            \"INVALID_CREATOR_CUT\"\n        );\n        require(\n            parameters[Parameter.TRADING_REWARDS_TREASURY_CUT] +\n                parameters[Parameter.TRADING_REWARDS_SPECTRA_CUT] +\n                parameters[Parameter.TRADING_REWARDS_EMPLOYEES_CUT] ==\n                PRECISION / 2,\n            \"INVALID_SPECTRA_CUT\"\n        );\n    }\n\n    function withdrawAllAgentTokens(uint256 start_index, uint256 end_index) external nonReentrant {\n        require(start_index < end_index, \"INVALID_INDEX\");\n        require(end_index <= userBalances[msg.sender].agent_tokens.length, \"INVALID_INDEX\");\n        for (uint256 i = start_index; i < end_index; i++) {\n            address token = userBalances[msg.sender].agent_tokens[i];\n            uint256 amount = userBalances[msg.sender].agent_tokens_list[token];\n            require(amount > 0, \"AMOUNT_ZERO\");\n            userBalances[msg.sender].agent_tokens_list[token] = 0;\n            IERC20Upgradeable(token).safeTransfer(msg.sender, amount);\n            emit Withdraw(msg.sender, token, amount);\n        }\n        \n        for (uint256 i = end_index - 1; i >= start_index; ) {\n        \t_removeAgentToken(userBalances[msg.sender], userBalances[msg.sender].agent_tokens[i]);\n        \tif (i == 0) {\n        \t\tbreak;\n        \t}\n        \ti --;\n        }\n    }\n\n    function withdrawAllAgentTokensByAddresses(address[] calldata tokens) external nonReentrant {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 amount = userBalances[msg.sender].agent_tokens_list[tokens[i]];\n            require(amount > 0, \"AMOUNT_ZERO\");\n            userBalances[msg.sender].agent_tokens_list[tokens[i]] = 0;\n            _removeAgentToken(userBalances[msg.sender], tokens[i]);\n            IERC20Upgradeable(tokens[i]).safeTransfer(msg.sender, amount);\n            emit Withdraw(msg.sender, tokens[i], amount);\n        }\n    }\n\n    function transferTradingRewards(\n        address agentToken,\n        uint256 usdcAmount,\n        TradingDistribution[] calldata contributors,\n        address altTreasury\n    ) external nonReentrant onlyAdmin() {\n        require(agentToken != address(0), \"ZERO_ADDRESS\");\n        require(usdcAmount > 0, \"AMOUNT_ZERO\");\n        address[] memory beneficiaries;\n        uint256[] memory amounts;\n        usdc_token.safeTransferFrom(msg.sender, address(this), usdcAmount);\n        uint256 remaining = usdcAmount;\n        if(keccak256(abi.encodePacked(\"SPECTR\")) == keccak256(abi.encodePacked(IAgentToken(agentToken).symbol()))) {\n            uint256 employeesAmount = (usdcAmount * parameters[Parameter.TRADING_REWARDS_EMPLOYEES_CUT]) / PRECISION;\n            uint256 socialContributorsAmount = (usdcAmount * 2500) / PRECISION;\n            uint256 stakersAmount = (usdcAmount * 2500) / PRECISION;\n            remaining -= stakersAmount;\n            usdc_token.approve(address(systemAddresses.autonomousDeployer), stakersAmount);\n            systemAddresses.autonomousDeployer.distributeTradingProfitsToStakers(stakersAmount, address(usdc_token));\n            uint256 employeeCount = IAgenticCompany(systemAddresses.agenticCompanyFactory.getCompanyAddressAtIndex(spectraCompanyIndex)).employeeCount();\n            require(employeeCount > 0, \"NO_EMPLOYEES\");\n            // If contributors are 0 though, it will increase remaining and end up in treasury\n            uint256 contributorCount = contributors.length;\n            beneficiaries = new address[](employeeCount + contributorCount);\n            amounts = new uint256[](employeeCount + contributorCount);\n            uint256 perEmployeeAmount = employeesAmount / employeeCount;\n            remaining -= (perEmployeeAmount * employeeCount);\n            for (uint256 i = 0; i < employeeCount; i++) {\n                address employee = _getAnsAddress(IAgenticCompany(systemAddresses.agenticCompanyFactory.getCompanyAddressAtIndex(spectraCompanyIndex)).getEmployeeAtIndex(i));\n                userBalances[employee].usdc += perEmployeeAmount;\n                beneficiaries[i] = employee;\n                amounts[i] = perEmployeeAmount;\n            }\n            if(contributorCount == 0) {\n                require(altTreasury != address(0), \"ALT_TREASURY_ZERO_ADDRESS\");\n                usdc_token.safeTransfer(altTreasury, socialContributorsAmount);\n                remaining -= socialContributorsAmount;\n            }else\n            {\n                uint256 contributorSum = 0;\n                for (uint256 j = 0; j < contributorCount; j++) {\n                    remaining -= contributors[j].amount;\n                    contributorSum += contributors[j].amount;\n                    address contributor = _getAnsAddress(contributors[j].recipientAnsNode);\n                    userBalances[contributor].usdc += contributors[j].amount;\n                    beneficiaries[employeeCount + j] = contributor;\n                    amounts[employeeCount + j] = contributors[j].amount;\n                }\n                require(contributorSum <= socialContributorsAmount, \"INCORRECT_CONTRIBUTORS_AMOUNT\");\n            }\n            emit DistributeTradingRewards(agentToken, usdcAmount, beneficiaries, amounts);\n        } else {\n            uint256 creatorAmount = (usdcAmount * parameters[Parameter.TRADING_REWARDS_CREATOR_CUT]) / PRECISION;\n            remaining -= creatorAmount;\n            require(agentCreators[agentToken] != address(0), \"CREATOR_NOT_SET\");\n            userBalances[agentCreators[agentToken]].usdc += creatorAmount;\n            beneficiaries = new address[](1);\n            amounts = new uint256[](1);\n            beneficiaries[0] = agentCreators[agentToken];\n            amounts[0] = creatorAmount;\n            emit DistributeTradingRewards(agentToken, usdcAmount,beneficiaries,amounts);\n        }\n        require(remaining >= (usdcAmount * parameters[Parameter.TRADING_REWARDS_TREASURY_CUT]) / PRECISION, \"INSUFFICIENT_TREASURY_CUT\");\n        usdc_token.safeTransfer(systemAddresses.spectralTreasury, remaining);\n    }\n    \n    \n    function _addOrGetAgentToken(UserBalances storage user, address token) internal returns (uint256) {\n        uint256 index = user.agent_tokens_indecies[token];\n        \n        if (index >= user.agent_tokens.length || user.agent_tokens[index] != token) {\n            // Add to array\n            user.agent_tokens.push(token);\n            // Store and return new array index\n            index = user.agent_tokens.length - 1;\n            user.agent_tokens_indecies[token] = index;\n        }\n        \n        return index;\n    }\n\n    function _removeAgentToken(UserBalances storage user, address token) internal {\n        uint256 index = user.agent_tokens_indecies[token];\n        require(index < user.agent_tokens.length, \"Token not found\");\n        \n        // Get the last element\n        address lastToken = user.agent_tokens[user.agent_tokens.length - 1];\n\n        // Move last element to the position we're deleting\n        user.agent_tokens[index] = lastToken;\n        // Update the index mapping for the moved token\n        user.agent_tokens_indecies[lastToken] = index;\n        \n        // Remove token's index from mapping\n        delete user.agent_tokens_indecies[token];\n        \n        // Remove last element\n        user.agent_tokens.pop();\n    }\n\n    function transferHiringDistributions(\n        HiringDistribution[] calldata distributions,\n        address agentToken,\n        uint256 totalSpec,\n        uint256 totalAgentToken,\n        uint256 totalUsdc\n    ) external nonReentrant onlyAgenticCompany() {\n        require(\n            distributions.length > 0,\n            \"DISTRIBUTIONS_MUST_BE_PROVIDED\"\n        );\n        HiringDistributionByAddress[] memory distributionsByAddress = new HiringDistributionByAddress[](distributions.length);\n        usdc_token.safeTransferFrom(msg.sender, address(this), totalUsdc);\n        spectral_token.safeTransferFrom(msg.sender, address(this), totalSpec);\n        if(agentToken != address(0) && totalAgentToken > 0) {\n            IERC20Upgradeable(agentToken).safeTransferFrom(msg.sender, address(this), totalAgentToken);\n        }\n        uint256 accSpecAmount = 0;\n        uint256 accAgentTokenAmount = 0;\n        uint256 accUsdcAmount = 0;\n        for (uint256 i = 0; i < distributions.length; i++) {\n            address recipient = _getAnsAddress(distributions[i].recipientAnsNode);\n            distributionsByAddress[i] = HiringDistributionByAddress(\n                recipient,\n                distributions[i].specAmount,\n                distributions[i].agentTokenAmount,\n                distributions[i].usdcAmount\n            );\n            UserBalances storage user = userBalances[\n                recipient\n            ];\n            user.spectral += distributions[i].specAmount;\n            accSpecAmount += distributions[i].specAmount;\n            if (agentToken != address(0) && totalAgentToken > 0) {\n                _addOrGetAgentToken(user, agentToken);\n                user.agent_tokens_list[agentToken] += distributions[i].agentTokenAmount;\n                accAgentTokenAmount += distributions[i].agentTokenAmount;\n            }\n            user.usdc += distributions[i].usdcAmount;\n            accUsdcAmount += distributions[i].usdcAmount;\n        }\n        require(accSpecAmount == totalSpec, \"INCORRECT_SPEC_AMOUNT\");\n        require(agentToken == address(0) || totalAgentToken == 0 || accAgentTokenAmount == totalAgentToken, \"INCORRECT_AGENT_TOKEN_AMOUNT\");\n        require(accUsdcAmount == totalUsdc, \"INCORRECT_USDC_AMOUNT\");\n        emit DistributeHiringBonuses(\n            msg.sender,\n            agentToken,\n            distributions.length,\n            totalSpec,\n            totalAgentToken,\n            totalUsdc,\n            distributionsByAddress\n        );\n    }\n\n    function setAgentCreator(address agentToken, address creator)\n        external\n        onlyAutonomousDeployer\n    {\n        require(agentToken != address(0), \"ZERO_ADDRESS\");\n        require(creator != address(0), \"ZERO_ADDRESS\");\n        agentCreators[agentToken] = creator;\n        emit SetAgentCreator(agentToken, creator);\n    }\n\n    function _getAnsAddress(bytes32 node) internal view returns (address add_) {\n        add_ = systemAddresses.ansResolver.addr(node);\n        if (add_ == address(0)) {\n            revert AnsNodeMustResolveToAddress(node);\n        }\n    }\n\n    function setAgentCreatorsBatch(\n        address[] calldata agentTokens,\n        address[] calldata creators\n    ) external onlyOwner {\n        require(agentTokens.length == creators.length, \"INVALID_LENGTH\");\n        for (uint256 i = 0; i < agentTokens.length; i++) {\n            require(agentTokens[i] != address(0), \"ZERO_ADDRESS\");\n            require(creators[i] != address(0), \"ZERO_ADDRESS\");\n            agentCreators[agentTokens[i]] = creators[i];\n            emit SetAgentCreator(agentTokens[i], creators[i]);\n        }\n    }\n\n    function setAdmin(address _admin) external onlyOwner {\n        require(_admin != address(0), \"ZERO_ADDRESS\");\n        admin = _admin;\n        emit SetAdmin(_admin);\n    }\n\n    function updateSystemAddress(\n    uint8 index,\n    address newAddress\n    ) external onlyOwner {\n        require(index < 5, \"INVALID_INDEX\");\n        require(newAddress != address(0), \"ZERO_ADDRESS\");\n        \n        assembly {\n            // Store new address at the correct slot\n            sstore(add(systemAddresses.slot, index), newAddress)\n        }\n        emit UpdateSystemAddress(index, newAddress);\n    }\n\n    function setSpectraCompanyIndex(uint256 index) external onlyOwner {\n        require(index < systemAddresses.agenticCompanyFactory.companyCount(), \"INVALID_INDEX\");\n        spectraCompanyIndex = index;\n        emit SetSpectraCompanyIndex(index);\n    }\n\n    function _authorizeUpgrade(\n        address newImplementation\n    ) internal override onlyOwner {\n        require(newImplementation != address(0), \"ZERO_ADDRESS\");\n        ++version;\n        emit Upgrade(newImplementation, version);\n    }\n\n    function getUserAgentBalance(address user, address agentToken)\n        external\n        view\n        returns (uint256)\n    {\n        return userBalances[user].agent_tokens_list[agentToken];\n    }\n    \n    /**\n     * @dev Updates the merkle root\n     * @param newMerkleRoot The new merkle root to set\n     */\n    function updateMerkleRoot(bytes32 newMerkleRoot) external onlyOwner {\n        bytes32 oldRoot = pointsMerkleRoot;\n        pointsMerkleRoot = newMerkleRoot;\n        emit MerkleRootUpdated(oldRoot, newMerkleRoot);\n    }\n    \n    /**\n     * @dev Allows a user to withdraw their rewards\n     * @param amount The amount to withdraw\n     * @param totalAmount The total claimable amount for the user\n     * @param merkleProof The merkle proof for the user's allocation\n     */\n    function withdrawPoints(\n        uint256 amount,\n        uint256 totalAmount,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Verify the user has this allocation in the merkle tree\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, totalAmount));\n        require(\n            MerkleProofUpgradeable.verify(merkleProof, pointsMerkleRoot, leaf),\n            \"Invalid merkle proof\"\n        );\n        \n        // Check how much is already withdrawn and how much can be withdrawn\n        uint256 alreadyWithdrawn = userPointsWithdrawn[msg.sender];\n        require(\n            alreadyWithdrawn + amount <= totalAmount,\n            \"Attempting to withdraw more than allocated\"\n        );\n        \n        // Update the withdrawn amount\n        userPointsWithdrawn[msg.sender] = alreadyWithdrawn + amount;\n        \n        // Transfer the tokens\n        spectral_token.safeTransfer(msg.sender, amount);\n        \n        emit RewardsClaimed(msg.sender, amount);\n    }\n}\n"
    }
}