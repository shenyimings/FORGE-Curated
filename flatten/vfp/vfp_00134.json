{
    "vfp_id": "vfp_00134",
    "project_name": "cantina_liminal_oct2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Custom Fees Settable up to 100% in fulfillFastRedeems Can Seize Redemptions",
            "description": "The fulfillFastRedeems function allows a caller with the FULFILL_MANAGER_ROLE to specify a customFees array. While the code checks that the fee does not exceed 100% (feeBps <= BASIS_POINTS), it lacks a stricter, more reasonable upper bound. This allows a privileged manager to set a punitive fee of up to almost 100%, which could be used to unfairly seize the majority or almost all of a user's redemption value.\nThe root cause is the absence of a configurable or hardcoded sane maximum fee limit enforced on-chain. An attacker with the FULFILL_MANAGER_ROLE could exploit this by setting an excessively high fee during redemption processing.\nThe exploitation would occur when the attacker calls fulfillFastRedeems with a near-100% fee, causing users to lose most of their redemption value to the fee recipient.\nThe impact is financial loss for users during fast redemption, undermining trust in the system's fairness and potentially enabling abuse by privileged actors.\n",
            "severity": "Medium",
            "location": [
                "RedemptionPipe.sol#L439-L466"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-179"
                ]
            },
            "title": "Unsafe Type Conversion for Refund Recipient Can Lead to Funds Lost to 0xdead Address",
            "description": "In the lzCompose function's catch block, the logic to determine the refund recipient contains an unsafe type conversion. The code extracts a bytes32 value (extractedRecipient) and checks if it is non-zero before converting it to an address. However, a bytes32 value can be non-zero while its lower 20 bytes (used for address conversion) are zero, resulting in address(0). This causes refunded assets to be sent to LayerZero's null address (0xdead), leading to permanent loss of funds.\nThe root cause is validating the bytes32 value before conversion instead of validating the resulting address after conversion.\nAn attacker could craft a malicious payload where the upper bytes of the bytes32 are non-zero but the lower 20 bytes are zero, triggering the vulnerability.\nThe impact is permanent loss of user funds during cross-chain refund operations, reducing recoverability of assets in failure scenarios.\n",
            "severity": "Medium",
            "location": [
                "VaultComposerBase.sol#L101-L105"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultComposerBase.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Critical Oracle Parameters Lack Timelock Protection",
            "description": "The setPriceId and setPriceIds functions in PythPriceOracle.sol, which configure Pyth price feed IDs and decimals, are only protected by PRICE_MANAGER_ROLE and lack timelock protection. A compromised or malicious price manager could instantly change price feed configurations, enabling manipulation of all price conversions within the system.\nThe root cause is the absence of the onlyTimelock modifier on critical configuration functions, deviating from security best practices used elsewhere in the system.\nAn attacker with PRICE_MANAGER_ROLE could change price feeds to manipulated ones or set incorrect decimals, leading to incorrect share calculations and enabling fund siphoning from DepositPipe and RedemptionPipe.\nThe impact includes systemic financial manipulation, incorrect valuation of assets, and potential draining of protocol funds through frontrunning or artificial price manipulation.\n",
            "severity": "Medium",
            "location": [
                "PythPriceOracle.sol#L101-L117",
                "PythPriceOracle.sol#L119-L143"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Timelock Admin Can Instantly Change Delays, Bypassing Governance Safeguards",
            "description": "The VaultTimelockController's setFunctionDelay and setDefaultFunctionDelay functions are protected only by DEFAULT_ADMIN_ROLE without any timelock, allowing immediate changes to delay periods. This undermines the entire purpose of the timelock as a governance safeguard.\nThe root cause is the lack of self-enforced timelocking on the timelock's own configuration functions, enabling an admin to reduce delays instantly.\nAn attacker with DEFAULT_ADMIN_ROLE could reduce the delay of a critical function (e.g., contract upgrade) from 7 days to 1 hour and execute a malicious upgrade within that short window, leaving users no time to react.\nThe impact is complete bypass of governance safeguards, enabling rapid malicious upgrades and potential theft of all protocol funds, effectively negating the security model.\n",
            "severity": "Medium",
            "location": [
                "VaultTimelockController.sol#L314-L350"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Privileged Role Can Arbitrarily Set NAV and Drain Instant Redeemable Funds Due to Circumventable & Missing Safeguards",
            "description": "The NAVOracle contract allows the VALUATION_MANAGER_ROLE to call setTotalAssets and directly overwrite the Net Asset Value (NAV). While a maxPercentageIncrease check exists, it can be bypassed via sequential calls in the same block or by setting NAV to zero first (which skips the check), then inflating it.\nThe root cause is the lack of downside protection (maxPercentageDecrease) and intra-block cooldown mechanisms, making the safeguard easily circumventable.\nAn attacker could set NAV to near-zero, deposit a small amount to mint nearly all shares, then reset NAV to steal all assets. Alternatively, they could inflate NAV before redeeming to extract excessive assets.\nThe impact includes total loss of funds for depositors and redemption holders, enabling complete vault draining by a privileged role.\n",
            "severity": "Medium",
            "location": [
                "NAVOracle.sol#L182-L205"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/NAVOracle.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Oracle Manipulation Enables Attackers Unfair Share Minting and Inflated Redemptions",
            "description": "The protocol uses spot prices from PythPriceOracle for asset valuation, making it vulnerable to price manipulation via flash loans or other means. Attackers can exploit this during deposits (to mint excessive shares) or redemptions (to withdraw inflated amounts).\nThe root cause is reliance on volatile spot prices without using time-averaged prices (like EMA) or confidence interval checks, which are necessary defenses against manipulation.\nIn Attack Vector 1, an attacker manipulates the price upward, deposits a small amount, and receives disproportionately high shares. In Attack Vector 2, they inflate NAV before redeeming to extract more assets than deserved.\nThe impact includes unfair dilution of existing holders, loss of funds from the vault, and systemic risk from oracle manipulation, undermining the integrity of share pricing and redemption.\n",
            "severity": "Medium",
            "location": [
                "PythPriceOracle.sol#L219-L237"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Refund Logic Fails in Multi-Hop Scenarios, Risking Stuck Funds",
            "description": "The _refund function in VaultComposerBase refunds failed cross-chain messages to the immediate source (_message.srcEid()), not the original sender's chain. In multi-hop scenarios (e.g., Chain A → Chain B → Chain C), if the final leg fails, funds are refunded to the intermediate chain (B), not the origin (A).\nThe root cause is the lack of origin chain tracking in the message payload, causing incorrect refund routing.\nAn attacker or user error could result in funds being stranded on an intermediate chain where the user has no access, requiring manual recovery.\nThe impact is temporary or permanent loss of user funds due to incorrect refund routing in complex cross-chain paths, increasing operational risk and user friction.\n",
            "severity": "Low",
            "location": [
                "VaultComposerBase.sol#L133-L142"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultComposerBase.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Potential Value Leakage and Over-Approval Due to OFT Dedusting",
            "description": "The depositAssetAndSend and redeemAndSend functions approve and transfer the full calculated amount of an asset, but LayerZero's OFT performs dedusting (handling decimal differences), resulting in slightly less arriving at the destination. The dust remains in the contract, and the full amount is over-approved.\nThe root cause is not pre-calculating the actual bridged amount using IOFT.quoteOFT() before approval and transfer.\nOver many transactions, accumulated dust represents lost user value, and over-approval increases security risk if the OFT contract is compromised.\nThe impact includes gradual value leakage from users and unnecessary approval exposure, reducing capital efficiency and increasing attack surface.\n",
            "severity": "Low",
            "location": [
                "OVaultComposerMulti.sol#L139-L162",
                "OVaultComposerMulti.sol#L164-L192"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/omnichain/OVaultComposerMulti.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Null Address Can Be Set as Receiver in Cross-Chain Deposits",
            "description": "The _handleDepositAsset function in OVaultComposerMulti decodes a receiver address from the payload but does not validate that it is non-zero. If a malformed message sets the receiver to address(0), the mint operation will revert due to ERC20 safeguards, triggering a refund process.\nThe root cause is missing input validation for the receiver address in the cross-chain message handler.\nWhile the mint reverts, this results in unnecessary cross-chain refund transactions, increasing gas costs and complexity.\nThe impact is inefficient use of gas and potential user confusion due to failed deposits and refunds, though funds are not permanently lost.\n",
            "severity": "Low",
            "location": [
                "OVaultComposerMulti.sol#L344-L347"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/omnichain/OVaultComposerMulti.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Management fee accrues over zero-supply periods",
            "description": "In FeeManager.sol, when currentSupply == 0, the function returns early without updating lastManagementFeeTimestamp. If the vault remains empty and later receives a deposit, fees may be accrued for the entire idle period, charging for time when no assets under management existed.\nThe root cause is failure to update the timestamp during zero-supply periods, leading to stale state.\nThis could result in retroactive fee accrual upon deposit, unfairly charging users for periods with no supply.\nThe impact is potential overcharging of management fees, leading to unfair distribution of fees and reduced transparency in fee calculation.\n",
            "severity": "Low",
            "location": [
                "FeeManager.sol#L208"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unsafe ERC20 approval pattern",
            "description": "OVaultComposerMulti directly calls approve on ERC20 tokens without first resetting the allowance to zero. This can fail on tokens that require a zero-approval before setting a new allowance (e.g., USDT, USDC).\nThe root cause is using an unsafe approval pattern that does not comply with the requirements of certain ERC20 tokens.\nAn attacker or user could be affected if a previous non-zero allowance blocks a new approval, preventing intended transfers.\nThe impact is potential transaction failure for certain tokens, reducing interoperability and reliability of cross-chain operations.\n",
            "severity": "Low",
            "location": [
                "OVaultComposerMulti.sol#L159"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/omnichain/OVaultComposerMulti.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Incorrect upgrade function selectors in timelock",
            "description": "VaultTimelockController configures delays for upgradeProxy(address,address) and upgradeProxyAndCall(address,address,bytes), but these selectors do not match standard upgrade patterns like Transparent Proxy (upgrade(address,address)) or UUPS (upgradeTo(address)).\nThe root cause is misconfiguration of function selectors in the timelock, leading to potential gaps in protection.\nIf the actual upgrade functions use standard selectors, they would not be subject to the timelock delay, allowing instant upgrades by the admin.\nThe impact is a critical governance bypass risk, where contract upgrades can occur without delay, undermining the security model.\n",
            "severity": "Low",
            "location": [
                "VaultTimelockController.sol#L159-L160"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing validation of decimals against token metadata",
            "description": "The PythPriceOracle contract stores the number of decimals for an asset based on external input without validating that it matches the actual value returned by IERC20Metadata(asset).decimals(). This lack of validation can result in a mismatch between the stored and actual decimals.\nThe root cause is the absence of a validation check against the token's metadata, relying instead on potentially incorrect external input.\nAn attacker or misconfiguration could supply an incorrect decimals value, which would skew the scaling logic used for price normalization.\nThis would lead to incorrect price calculations, affecting downstream systems that rely on accurate normalized prices, potentially causing financial loss or incorrect state transitions.\n",
            "severity": "Low",
            "location": [
                "PythPriceOracle.sol#L114"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Missing setter for timeLockController",
            "description": "The PythPriceOracle contract declares a timeLockController address but does not provide a function to set or update it after deployment. This prevents necessary governance operations such as rotating the timelock, fixing misconfigurations, or aligning with other protocol components.\nThe root cause is the omission of a setter function for the timeLockController state variable, despite its critical role in access control.\nAn attacker cannot directly exploit this, but it creates operational risk if the current timelock becomes compromised or needs updating.\nThe impact is reduced system flexibility and inability to perform essential maintenance or security updates, potentially leading to permanent lock-in of a compromised or outdated timelock address.\n",
            "severity": "Low",
            "location": [
                "PythPriceOracle.sol#L22"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-570"
                ]
            },
            "title": "Unreachable Code in Decimal Normalization Logic",
            "description": "The DepositPipe contract includes a require(underlyingDecimals <= 18) check in its initializer, which ensures that the contract cannot be deployed with more than 18 decimals. However, helper functions _normalizeToDecimals18 and _normalizeFromDecimals18 contain else branches that handle cases where underlyingDecimals > 18, which are unreachable due to the initializer check.\nThe root cause is redundant logic that was not removed after the deployment guard was implemented.\nAn attacker cannot exploit this, but it represents dead code that increases deployment cost and reduces code clarity.\nThe impact is higher gas costs for deployment due to larger bytecode size and increased cognitive load for auditors and developers, potentially leading to confusion about intended behavior.\n",
            "severity": "Informational",
            "location": [
                "DepositPipe.sol#L385-L388",
                "DepositPipe.sol#L405-L408"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/DepositPipe.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Various Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified across several contracts. These include: redundant manual refund logic in VaultComposerBase.sol, suboptimal storage packing in NAVOracle.sol and RedemptionPipe.sol, inefficient use of external self-calls in VaultComposerBase.sol, an unused constant in VaultTimelockController.sol, and redundant replay protection in OVaultComposerMulti.sol that duplicates LayerZero's built-in mechanism.\nThe root causes vary: some stem from using larger data types than necessary (e.g., uint256 instead of uint96), others from architectural decisions like manual refund handling when LayerZero already provides it, and some from unused or redundant code patterns.\nWhile not directly exploitable, these inefficiencies increase transaction costs and deployment overhead.\nThe impact is higher gas consumption for users and operators, increased deployment costs, and unnecessarily complex code that could obscure real vulnerabilities.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultComposerBase.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/NAVOracle.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/omnichain/OVaultComposerMulti.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "PythPriceOracle duplicates positivity check on price",
            "description": "The PythPriceOracle contract performs two equivalent checks on the positivity of a fetched price: `price.price > 0` and `int256(price.price) > 0`. Since `price.price` is already a signed integer (int64), casting it to int256 and rechecking positivity adds no additional safety.\nThe root cause is redundant validation logic that fails to recognize type equivalence during comparison.\nThis does not create a security vulnerability but represents wasted computation.\nThe impact is unnecessary gas consumption during price validation, slightly increasing the cost of every price update operation.\n",
            "severity": "Informational",
            "location": [
                "PythPriceOracle.sol#L232-L234"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Encapsulate authorization check in a modifier",
            "description": "The DepositPipe contract repeats the same authorization logic (`controller == msg.sender || shareManager.isOperator(controller, msg.sender)`) in multiple locations (e.g., L202, L289), leading to code duplication.\nThe root cause is the lack of a dedicated modifier or internal function to encapsulate this common access control pattern.\nWhile not directly exploitable, duplicated logic increases the risk of inconsistent checks or errors during future modifications.\nThe impact is increased bytecode size, higher maintenance burden, and potential for security drift if one instance is updated while others are not, leading to inconsistent access control behavior.\n",
            "severity": "Informational",
            "location": [
                "DepositPipe.sol#L202-L204"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/DepositPipe.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Remove unused Ownable2StepUpgradeable",
            "description": "The Ownable2StepUpgradeable contract is imported but not used in multiple files including ShareManager.sol, NAVOracle.sol, FeeManager.sol, DepositPipe.sol, RedemptionPipe.sol, OVaultComposerMulti.sol, PythPriceOracle.sol, and VaultTimelockController.sol.\nThe root cause is unnecessary inheritance or import of a base contract that provides no functional benefit in these contexts.\nThis does not create a direct security risk but increases deployment cost and maintenance surface.\nThe impact is higher gas costs due to larger bytecode and increased complexity in the codebase, making audits and upgrades more difficult than necessary.\n",
            "severity": "Informational",
            "location": [
                "DepositForwarder.sol#L19"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/ShareManager.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/NAVOracle.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/DepositPipe.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/omnichain/OVaultComposerMulti.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/PythPriceOracle.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol",
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/DepositForwarder.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused boolean return value",
            "description": "In ShareManager.sol, the function at line 192 returns a boolean value (true), but this return value is not used by any callers (e.g., in FeeManager). This pattern adds no functional value.\nThe root cause is a design choice to return success indicators instead of using Solidity's revert-on-failure pattern.\nThis does not create a security vulnerability but represents unnecessary complexity.\nThe impact is slightly increased bytecode size and cognitive load for developers, with no benefit since callers do not check the return value.\n",
            "severity": "Informational",
            "location": [
                "ShareManager.sol#L192"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/ShareManager.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1093"
                ]
            },
            "title": "Redundant owner field in pending request structs",
            "description": "In RedemptionPipe, both PendingRedeemRequest and PendingFastRedeemRequest structs include an owner field, even though the mappings are already keyed by owner. This creates redundant data storage.\nThe root cause is poor data modeling that duplicates information already available via the mapping key.\nThis increases storage costs and introduces the risk of inconsistency if the key and stored value ever diverge.\nThe impact is higher gas costs for storage operations and potential for logic errors if the redundant field is updated independently of the key.\n",
            "severity": "Informational",
            "location": [
                "RedemptionPipe.sol#L88-L98"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ]
            },
            "title": "Avoid external self-calls via this for getDelay",
            "description": "In VaultTimelockController, the pattern `this.getDelay(data)` triggers an external call to the same contract, which is unnecessary for a pure/view function.\nThe root cause is using external visibility and `this.` syntax instead of internal calls for functions that could be accessed internally.\nThis creates unnecessary gas overhead due to the external call frame.\nThe impact is increased gas consumption for time delay checks, which are likely frequent operations in a timelock system.\n",
            "severity": "Informational",
            "location": [
                "VaultTimelockController.sol#L205"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Incompatibility with Non-Standard Tokens Due to Strict Balance Check Upon Transfer",
            "description": "The redeem function in RedemptionPipe performs a strict balance check that the liquidityProvider's balance decreases by exactly the transferred amount. This makes the protocol incompatible with fee-on-transfer, rebasing, or proxy tokens.\nThe root cause is a design decision to prioritize security against certain token behaviors over flexibility.\nWhile this protects against some malicious token designs, it limits the range of supported assets.\nThe impact is reduced composability and future-proofing of the protocol, potentially excluding legitimate token types from integration.\n",
            "severity": "Informational",
            "location": [
                "RedemptionPipe.sol#L329-L334"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1078"
                ]
            },
            "title": "Code Readability Improvements",
            "description": "Two minor code quality issues were identified: the redeemAndSend function in OVaultComposerMulti.sol is marked virtual with no apparent need for inheritance, and there is incorrect indentation at line 304 in the same file.\nThe root cause is inconsistent coding style and potentially misleading use of the virtual keyword.\nThese do not affect security or functionality.\nThe impact is reduced code clarity and consistency, making the codebase slightly harder to read and maintain.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/omnichain/OVaultComposerMulti.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Inspired ERC-7540 Interface Does Not Strictly Adhere to the Spec",
            "description": "The RedemptionPipe contract claims to be \"7540 like\" but deviates from the ERC-7540 standard by using a push mechanism (directly sending assets) instead of the required pull pattern (requiring users to claim). It also allows short-circuiting of redemption processes.\nThe root cause is a deliberate design choice that prioritizes user experience over standard compliance.\nThis could mislead developers who expect strict adherence to ERC-7540.\nThe impact is potential integration errors by third parties who assume standard-compliant behavior, leading to incorrect assumptions about the redemption workflow.\n",
            "severity": "Informational",
            "location": [
                "RedemptionPipe.sol#L18"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Maliciously High minMsgValue Can Purposely Make Cross-Chain Transaction Stuck",
            "description": "The lzCompose function in VaultComposerBase validates that msg.value >= minMsgValue, but there is no upper bound on minMsgValue. A user can set an arbitrarily high value, causing the transaction to consistently revert and become \"stuck\" without refund.\nThe root cause is the lack of an on-chain ceiling for minMsgValue, combined with a short-circuit in the catch block that prevents refund in this specific failure case.\nAn attacker could exploit this to create a denial-of-service condition for specific cross-chain messages.\nThe impact is that affected transactions become permanently stuck, requiring manual administrative intervention via recoverToken to rescue funds, increasing operational burden.\n",
            "severity": "Informational",
            "location": [
                "VaultComposerBase.sol#L89-L96"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultComposerBase.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Function Selector Collision in Timelock Could Weaken Security Guarantees",
            "description": "The VaultTimelockController uses four-byte function selectors to assign time delays to critical functions. There is a low-probability risk that two different functions could have the same selector (collision), potentially assigning a short delay to a critical function if a non-critical function with the same selector was configured last.\nThe root cause is the inherent limitation of 4-byte selector space and the lack of collision detection in the timelock configuration.\nWhile no collisions exist in the current codebase, future upgrades could introduce them.\nThe impact is a potential weakening of the timelock security model, where critical functions could be executed with shorter delays than intended, increasing risk of unauthorized upgrades or parameter changes.\n",
            "severity": "Informational",
            "location": [
                "VaultTimelockController.sol#L122-L134"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Emit event on state transition functions",
            "description": "Functions in ShareManager such as setOVaultComposerMulti, setMaxDeposit, setMaxSupply, and setMaxWithdraw modify critical governance state but do not emit events.\nThe root cause is the omission of event emissions for state-changing operations.\nThis reduces on-chain observability and makes it difficult to monitor or audit configuration changes.\nThe impact is reduced transparency and increased difficulty in incident response, as external parties cannot easily track when and how critical parameters were modified.\n",
            "severity": "Informational",
            "location": [
                "ShareManager.sol#L322-L326",
                "ShareManager.sol#L333-L337",
                "ShareManager.sol#L343-L347",
                "ShareManager.sol#L353-L357"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/ShareManager.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "NAVOracle does not support underlying tokens with decimals > 18",
            "description": "The _normalizeToDecimals18 function in NAVOracle.sol only handles cases where underlyingDecimals < 18, leaving == 18 and > 18 unhandled. This means tokens with more than 18 decimals are not supported.\nThe root cause is incomplete logic in the normalization function that fails to account for all possible decimal values.\nThis limits the range of supported assets and could lead to incorrect normalization if such tokens were somehow used.\nThe impact is reduced flexibility in asset selection and potential for incorrect NAV calculations if the constraint is not properly enforced or documented.\n",
            "severity": "Informational",
            "location": [
                "NAVOracle.sol#L140-L145"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/NAVOracle.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ]
            },
            "title": "Non compliant ERC4626 deposit event",
            "description": "The deposit function in DepositPipe emits the controller as the sender in the ERC-4626 Deposit event, but the standard requires msg.sender to be the first parameter. This divergence can mislead indexers and aggregators.\nThe root cause is incorrect event emission that does not follow ERC-4626 semantics.\nThis could cause indexing services to incorrectly attribute deposits to the controller rather than the actual transaction sender.\nThe impact is reduced compatibility with DeFi infrastructure tools that rely on standard event patterns, potentially leading to incorrect analytics or user interface displays.\n",
            "severity": "Informational",
            "location": [
                "DepositPipe.sol#L234"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/DepositPipe.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Non-upgradeable deployments due to proxy/implementation mismatch",
            "description": "Contracts are deployed behind ERC1967Proxy but do not inherit UUPSUpgradeable or expose upgrade functions. The proxy is also not a Transparent proxy, resulting in effectively non-upgradeable deployments.\nThe root cause is a mismatch between proxy type and implementation pattern, where the infrastructure assumes upgradeability but the contracts lack the necessary entrypoints.\nThis eliminates the intended benefit of using proxies for upgradeability.\nThe impact is that the contracts are permanently immutable after deployment, removing the ability to fix bugs or add features through upgrades.\n",
            "severity": "Informational",
            "location": [
                "DepositForwarder.sol#L18"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/DepositForwarder.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Request redeem payout forced to owner",
            "description": "In RedemptionPipe, the queued redemption functions (requestRedeemFast and requestRedeem) always pay proceeds to the owner, unlike instant paths which allow specifying a receiver. This creates inconsistent semantics.\nThe root cause is the lack of a receiver parameter in the request functions and fulfillment logic.\nThis limits custody and payment routing use cases, forcing funds to go to the owner regardless of intent.\nThe impact is reduced flexibility in fund routing and asymmetric behavior between instant and queued redemption paths.\n",
            "severity": "Informational",
            "location": [
                "RedemptionPipe.sol#L410-L437",
                "RedemptionPipe.sol#L507-L535"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Redundant controller parameter in queued requests",
            "description": "The controller parameter in requestRedeemFast and requestRedeem is used only for authorization but is not stored or used for custody or payout. Shares are taken from and paid to the owner, making the controller parameter semantically misleading.\nThe root cause is an unnecessary parameter that adds complexity without functional benefit.\nThis increases friction for users and creates confusion about the role of the controller in queued redemptions.\nThe impact is a more complex interface than necessary and potential for misuse or misunderstanding of the parameter's purpose.\n",
            "severity": "Informational",
            "location": [
                "RedemptionPipe.sol#L418-L421",
                "RedemptionPipe.sol#L515-L518"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/RedemptionPipe.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Mis-targeted function selector in timelock config",
            "description": "VaultTimelockController sets a delay for setOVaultComposerMulti(address,address) using a hard-coded selector string. This is fragile because if the target signature changes or the intent was to gate a function on this contract, the configuration will silently drift.\nThe root cause is the use of magic strings for function selectors instead of deriving them from ABI or using constants.\nThis creates a risk of misconfiguration that could leave critical functions unprotected or apply delays to unintended functions.\nThe impact is potential security gaps due to incorrect timelock configuration, especially during future upgrades or refactors.\n",
            "severity": "Informational",
            "location": [
                "VaultTimelockController.sol#L149"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/VaultTimelockController.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "High-Water Mark Logic Penalizes Performance Fee Collection",
            "description": "The collectPerformanceFee function in FeeManager updates the lastSupplyForPerformance state variable before minting fee shares. This causes the high-water mark to be set pre-dilution, so the next fee calculation interprets the dilution as a performance loss.\nThe root cause is incorrect ordering of state updates relative to share minting, violating the intended economic model.\nThis unfairly penalizes the fee recipient by requiring performance to \"recover\" the value of previously taken fees before new fees can accrue.\nThe impact is a disincentive for fee collection and potential misalignment of economic incentives, even when underlying strategies are profitable net of fees.\n",
            "severity": "Medium",
            "location": [
                "FeeManager.sol#L135-L190"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Client-Identified Flaw in Performance Fee Calculation Under Rework",
            "description": "A flaw was identified in the performance fee calculation logic in FeeManager.sol where the high-water mark is updated before minting fee shares, leading to incorrect performance tracking.\nThe root cause is the same as in finding 4.1 — improper sequencing of state updates in the fee collection process.\nThis results in the protocol requiring recovery of previously taken fees before accruing new ones, distorting the performance fee mechanism.\nThe impact is economic inefficiency and misaligned incentives in the fee structure, potentially affecting protocol sustainability and participant rewards.\n",
            "severity": "Medium",
            "location": [
                "FeeManager.sol#L135-L143"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Performance Fee Calculation",
            "description": "1. **Description:** The collectPerformanceFee function in the FeeManager contract fails to differentiate between actual yield generated by the vault's investment strategies and new capital deposited by users. This leads to inaccurate performance fee calculations.\n2. **Cause:** The root cause is a logical flaw in the fee calculation mechanism, which uses a metric that does not isolate real gains from simple inflows of new capital.\n3. **Exploitation:** An attacker or large depositor could potentially manipulate the timing and size of deposits to artificially inflate the perceived performance, thereby either avoiding fair fee payments or causing the system to overcharge other users.\n4. **Impact:** The impact includes economic unfairness, misallocation of fees, potential loss of user funds due to incorrect fee distribution, and erosion of trust in the vault's financial integrity.\n",
            "severity": "Medium",
            "location": [
                "FeeManager.sol::collectPerformanceFee"
            ],
            "files": [
                "55346a53cccfbaa5ef9d3ec8e73a1ab2e40a9aae/liminal-contracts/src/FeeManager.sol"
            ]
        }
    ],
    "affected_files": {
        "FeeManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {INAVOracle} from \"./interfaces/INAVOracle.sol\";\nimport {IShareManager} from \"./interfaces/IShareManager.sol\";\n\n/**\n * @title FeeManager\n * @notice Centralized fee management for the vault system\n * @dev FEE_COLLECTOR_ROLE must be granted to the fee manager address\n * @dev Handles performance fees and management fees across all pipes\n */\ncontract FeeManager is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using Math for uint256;\n\n    /// @notice Role for timelock operations\n    bytes32 public constant SAFE_MANAGER_ROLE = keccak256(\"SAFE_MANAGER_ROLE\");\n    bytes32 public constant FEE_COLLECTOR_ROLE = keccak256(\"FEE_COLLECTOR_ROLE\");\n\n    /// @notice Fee configuration\n    struct FeeConfig {\n        uint256 managementFeeBps; // Annual management fee in basis points\n        uint256 performanceFeeBps; // Performance fee in basis points\n    }\n\n    /// @custom:storage-location erc7201:liminal.feeManager.v1\n    struct FeeManagerStorage {\n        /// @notice Core contracts\n        IShareManager shareManager;\n        INAVOracle navOracle;\n        /// @notice Fee receiver address\n        address feeReceiver;\n        /// @notice Fee configuration\n        FeeConfig fees;\n        /// @notice Performance fee tracking\n        uint256 lastNAVForPerformance;\n        uint256 lastSupplyForPerformance;\n        uint256 lastManagementFeeTimestamp;\n        /// @notice High-Water Mark accumulator for performance fee tracking (PPS-based)\n        /// @dev Stores the Price Per Share (PPS) at the last point fees were accrued\n        /// @dev Stored with 1e18 precision. Fees only charged when PPS increases above this mark\n        uint256 ppsTrack;\n        /// @notice Accrued performance fees in assets (18 decimals) calculated but not yet minted\n        /// @dev Accumulates on every deposit/withdrawal to prevent yield loss with infrequent collections\n        /// @dev Only converted to shares when collectPerformanceFee() is called\n        uint256 accruedPerformanceFeeInAssets;\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Safe manager address\n        address safeManager;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.feesManager.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant FEE_MANAGER_STORAGE_LOCATION =\n        0x4b4022d112866c56e7ce4fba50b143067d70699d5800adf7d8c91134a5bcaf00;\n\n    function _getFeeManagerStorage() private pure returns (FeeManagerStorage storage $) {\n        assembly {\n            $.slot := FEE_MANAGER_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Events\n    event PerformanceFeeTaken(uint256 sharesMinted, uint256 feeInAssets, uint256 newHighWatermarkPPS);\n    event NoPerformanceFeeTaken(uint256 currentPPS, uint256 highWatermarkPPS);\n    event ManagementFeeTaken(uint256 sharesMinted, uint256 annualizedValue, uint256 timestamp);\n    event FeeConfigUpdated(uint256 managementFeeBps, uint256 performanceFeeBps);\n    event FeeReceiverUpdated(address indexed newReceiver);\n    event TimeLockControllerUpdated(address indexed oldTimeLockController, address indexed newTimeLockController);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        require(msg.sender == $.timeLockController, \"FeeManager: only timelock\");\n        _;\n    }\n\n    /// @notice Modifier for safe manager-protected functions\n    modifier onlySafeManager() {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        require(msg.sender == $.safeManager, \"FeeManager: only safe manager\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the fee manager\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param _shareManager Share manager contract\n     * @param _navOracle NAV oracle contract\n     * @param _feeReceiver Address to receive fees\n     * @param _deployer Deployer address (receives DEFAULT_ADMIN_ROLE)\n     * @param _safeManager Safe manager address (for operational functions, not ownership)\n     * @param _managementFeeBps Annual management fee in basis points\n     * @param _performanceFeeBps Performance fee in basis points\n     * @param _timeLockController Timelock controller for critical operations\n     */\n    function initialize(\n        address _shareManager,\n        address _navOracle,\n        address _feeReceiver,\n        address _deployer,\n        address _safeManager,\n        uint256 _managementFeeBps,\n        uint256 _performanceFeeBps,\n        address _timeLockController\n    ) external initializer {\n        require(_shareManager != address(0), \"FeeManager: zero share manager\");\n        require(_navOracle != address(0), \"FeeManager: zero nav oracle\");\n        require(_feeReceiver != address(0), \"FeeManager: zero fee receiver\");\n        require(_deployer != address(0), \"FeeManager: zero deployer\");\n        require(_safeManager != address(0), \"FeeManager: zero safe manager\");\n        require(_timeLockController != address(0), \"FeeManager: zero timelock\");\n        require(_managementFeeBps <= 500, \"FeeManager: management fee too high\"); // Max 5%\n        require(_performanceFeeBps <= 3000, \"FeeManager: performance fee too high\"); // Max 30%\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        $.shareManager = IShareManager(_shareManager);\n        $.navOracle = INAVOracle(_navOracle);\n        $.feeReceiver = _feeReceiver;\n        $.timeLockController = _timeLockController;\n        $.safeManager = _safeManager;\n\n        $.fees = FeeConfig({managementFeeBps: _managementFeeBps, performanceFeeBps: _performanceFeeBps});\n\n        // Initialize high-water mark accumulator to initial PPS (1e18 = 1.0 share price)\n        // This is fair: sets the baseline at the initial share price\n        $.ppsTrack = 1e18;\n        $.lastNAVForPerformance = $.navOracle.getNAV();\n        $.lastSupplyForPerformance = $.shareManager.totalSupply();\n        $.lastManagementFeeTimestamp = block.timestamp;\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(SAFE_MANAGER_ROLE, _safeManager);\n    }\n\n    /**\n     * @notice Internal function to accrue performance fees without minting shares\n     * @dev Called on deposits/withdrawals to checkpoint fees earned so far\n     * @dev Prevents yield loss with infrequent collections while avoiding dilution on every deposit\n     */\n    function _accruePerformanceFee() internal {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        \n        if ($.fees.performanceFeeBps == 0) return;\n        \n        uint256 currentNAV = $.navOracle.getNAV();\n        uint256 currentSupply = $.shareManager.totalSupply();\n        \n        if (currentSupply == 0) return;\n        if ($.lastSupplyForPerformance == 0) {\n            // First time setup\n            $.ppsTrack = currentNAV.mulDiv(1e18, currentSupply, Math.Rounding.Floor);\n            $.lastSupplyForPerformance = currentSupply;\n            $.lastNAVForPerformance = currentNAV;\n            return;\n        }\n        \n        // Calculate current PPS\n        uint256 currentPPS = currentNAV.mulDiv(1e18, currentSupply, Math.Rounding.Floor);\n        \n        // If PPS increased, accrue the fee (but don't mint shares yet)\n        if (currentPPS > $.ppsTrack) {\n            uint256 ppsIncrease = currentPPS - $.ppsTrack;\n            uint256 profitInAssets = ppsIncrease.mulDiv($.lastSupplyForPerformance, 1e18, Math.Rounding.Floor);\n            uint256 feeInAssets = profitInAssets.mulDiv($.fees.performanceFeeBps, 10_000, Math.Rounding.Floor);\n            \n            // Add to accrued fees\n            $.accruedPerformanceFeeInAssets += feeInAssets;\n            \n            // Update checkpoint for next accrual\n            $.ppsTrack = currentPPS;\n        }\n        \n        // Always update supply and NAV tracking\n        $.lastSupplyForPerformance = currentSupply;\n        $.lastNAVForPerformance = currentNAV;\n    }\n\n    /**\n     * @notice Collect all accrued performance fees by minting shares\n     * @dev Accrues any new fees first, then mints shares for all accrued fees\n     * @dev This is the ONLY function that actually mints performance fee shares\n     * @return sharesMinted Amount of shares minted as fee\n     */\n    function collectPerformanceFee() external onlySafeManager nonReentrant returns (uint256 sharesMinted) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        \n        // First accrue any new performance fees\n        _accruePerformanceFee();\n        \n        // If no accrued fees, nothing to collect\n        if ($.accruedPerformanceFeeInAssets == 0) {\n            emit NoPerformanceFeeTaken(0, $.ppsTrack);\n            return 0;\n        }\n        \n        uint256 currentNAV = $.navOracle.getNAV();\n        uint256 currentSupply = $.shareManager.totalSupply();\n        \n        if (currentSupply == 0) return 0;\n        \n        // Convert all accrued fees to shares\n        uint256 feeInAssets = $.accruedPerformanceFeeInAssets;\n        uint256 navPostFee = currentNAV - feeInAssets;\n        sharesMinted = feeInAssets.mulDiv(currentSupply, navPostFee, Math.Rounding.Floor);\n        \n        if (sharesMinted > 0) {\n            $.shareManager.mintFeesShares($.feeReceiver, sharesMinted);\n            \n            // Reset accrued fees after minting\n            $.accruedPerformanceFeeInAssets = 0;\n            \n            // Update tracking after minting\n            $.lastSupplyForPerformance = $.shareManager.totalSupply();\n            $.lastNAVForPerformance = currentNAV;\n            \n            emit PerformanceFeeTaken(sharesMinted, feeInAssets, $.ppsTrack);\n        }\n        \n        return sharesMinted;\n    }\n\n    /**\n     * @notice Public function to accrue performance fees without collecting them\n     * @dev Can be called by DepositPipe/RedemptionPipe before mints/burns\n     * @dev Checkpoints fees so they're not lost with infrequent collections\n     */\n    function accruePerformanceFee() external {\n        _accruePerformanceFee();\n    }\n\n    /**\n     * @notice Collect management fee based on time elapsed\n     * @dev Mints shares to fee receiver proportional to time passed\n     * @return sharesMinted Amount of shares minted as fee\n     */\n    function collectManagementFee() external nonReentrant onlySafeManager returns (uint256 sharesMinted) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        if ($.fees.managementFeeBps == 0) return 0;\n\n        uint256 currentTime = block.timestamp;\n        uint256 timeElapsed = currentTime - $.lastManagementFeeTimestamp;\n\n        // Only collect if more than 1 day has passed\n        if (timeElapsed < 1 days) return 0;\n\n        uint256 currentSupply = $.shareManager.totalSupply();\n        if (currentSupply == 0) return 0;\n\n        // Calculate annualized management fee with dilution adjustment\n        // Formula: shares = supply * feeRate / (1 - feeRate)\n        // This ensures fee recipient receives exactly the intended percentage after dilution\n        uint256 feeRateNumerator = $.fees.managementFeeBps * timeElapsed;\n        uint256 feeRateDenominator = 10_000 * 365 days;\n\n        sharesMinted = currentSupply.mulDiv(\n            feeRateNumerator,\n            feeRateDenominator - feeRateNumerator,\n            Math.Rounding.Floor\n        );\n\n        if (sharesMinted > 0) {\n            $.shareManager.mintFeesShares($.feeReceiver, sharesMinted);\n\n            // Calculate annualized value for event\n            uint256 currentNAV = $.navOracle.getNAV();\n            uint256 annualizedValue = currentNAV.mulDiv($.fees.managementFeeBps, 10_000);\n\n            emit ManagementFeeTaken(sharesMinted, annualizedValue, currentTime);\n\n            // Management fee mints dilute PPS without changing NAV.\n            // Recalculate and update the PPS-based high-water mark after the dilution.\n            // New supply includes the minted management fee shares.\n            uint256 newSupply = $.shareManager.totalSupply();\n            uint256 newPPS = currentNAV.mulDiv(1e18, newSupply, Math.Rounding.Floor);\n            $.ppsTrack = newPPS;\n            \n            // Also update the tracking variables\n            $.lastNAVForPerformance = currentNAV;\n            $.lastSupplyForPerformance = newSupply;\n        }\n\n        $.lastManagementFeeTimestamp = currentTime;\n        return sharesMinted;\n    }\n\n    /**\n     * @notice Update timelock controller address\n     * @param _timelockController New timelock controller address\n     */\n    function setTimelockController(address _timelockController) external onlyTimelock {\n        require(_timelockController != address(0), \"FeeManager: zero timelock\");\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        address oldTimeLockController = $.timeLockController;\n        $.timeLockController = _timelockController;\n        emit TimeLockControllerUpdated(oldTimeLockController, _timelockController);\n    }\n\n    /**\n     * @notice Update fee configuration\n     * @param _managementFeeBps New management fee in basis points\n     * @param _performanceFeeBps New performance fee in basis points\n     */\n    function setFees(uint256 _managementFeeBps, uint256 _performanceFeeBps) external onlyTimelock {\n        require(_managementFeeBps <= 500, \"FeeManager: management fee too high\");\n        require(_performanceFeeBps <= 3000, \"FeeManager: performance fee too high\");\n\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        $.fees.managementFeeBps = _managementFeeBps;\n        $.fees.performanceFeeBps = _performanceFeeBps;\n\n        emit FeeConfigUpdated(_managementFeeBps, _performanceFeeBps);\n    }\n\n    /**\n     * @notice Update fee receiver address\n     * @param _feeReceiver New fee receiver address\n     */\n    function setFeeReceiver(address _feeReceiver) external onlyTimelock {\n        require(_feeReceiver != address(0), \"FeeManager: zero address\");\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        $.feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    /**\n     * @notice Reset performance fee baseline and PPS high-water mark accumulator\n     * @dev Used after significant events or initial setup\n     * @dev Resets the high-water mark to current PPS\n     */\n    function resetPerformanceBaseline() external onlyRole(SAFE_MANAGER_ROLE) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        uint256 currentNAV = $.navOracle.getNAV();\n        uint256 currentSupply = $.shareManager.totalSupply();\n        \n        uint256 currentPPS;\n        if (currentSupply == 0) {\n            currentPPS = 1e18; // Default to 1.0 if no shares\n        } else {\n            currentPPS = currentNAV.mulDiv(1e18, currentSupply, Math.Rounding.Floor);\n        }\n        \n        $.ppsTrack = currentPPS;\n        $.lastNAVForPerformance = currentNAV;\n        $.lastSupplyForPerformance = currentSupply;\n    }\n\n\n    /**\n     * @notice Get current fee configuration\n     * @return managementFeeBps Annual management fee in basis points\n     * @return performanceFeeBps Performance fee in basis points\n     */\n    function getFees() external view returns (uint256 managementFeeBps, uint256 performanceFeeBps) {\n        FeeManagerStorage storage $ = _getFeeManagerStorage();\n        return ($.fees.managementFeeBps, $.fees.performanceFeeBps);\n    }\n\n    /// @notice Get last NAV for performance fee calculation\n    function lastNAVForPerformance() external view returns (uint256) {\n        return _getFeeManagerStorage().lastNAVForPerformance;\n    }\n\n    /// @notice Get last supply for performance fee calculation\n    function lastSupplyForPerformance() external view returns (uint256) {\n        return _getFeeManagerStorage().lastSupplyForPerformance;\n    }\n\n    /// @notice Get last management fee timestamp\n    function lastManagementFeeTimestamp() external view returns (uint256) {\n        return _getFeeManagerStorage().lastManagementFeeTimestamp;\n    }\n\n    /// @notice Get fee receiver address\n    function feeReceiver() external view returns (address) {\n        return _getFeeManagerStorage().feeReceiver;\n    }\n\n    /// @notice Get timelock controller address\n    function timeLockController() external view returns (address) {\n        return _getFeeManagerStorage().timeLockController;\n    }\n\n    /// @notice Get high-water mark accumulator (PPS at last performance fee collection, stored with 1e18 precision)\n    function highWatermarkPPS() external view returns (uint256) {\n        return _getFeeManagerStorage().ppsTrack;\n    }\n\n    /// @notice Get accrued performance fees in assets (18 decimals) not yet minted as shares\n    function accruedPerformanceFeeInAssets() external view returns (uint256) {\n        return _getFeeManagerStorage().accruedPerformanceFeeInAssets;\n    }\n}\n",
        "VaultTimelockController.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {TimelockControllerUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\n\n/**\n * @title VaultTimelockController\n * @notice Enhanced timelock controller with per-function delay configuration\n * @dev Extends OpenZeppelin's TimelockControllerUpgradeable with intelligent delay detection\n */\ncontract VaultTimelockController is TimelockControllerUpgradeable {\n    // ERC-7201: Namespaced Storage Layout\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.vaultTimelock.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VAULT_TIMELOCK_STORAGE_POSITION =\n        0x58dfca5daecbbb3808b7a2399a82d70b8b7f873e64331c276767d397a9844400;\n\n    /**\n     * @dev Storage struct for VaultTimelockController-specific data\n     * @dev This struct is stored in a namespaced storage slot to prevent collisions\n     */\n    struct VaultTimelockStorage {\n        /// @notice Mapping of function selectors to their required delays\n        mapping(bytes4 => uint256) functionDelays;\n        /// @notice Mapping to track which functions have explicit delay configuration\n        mapping(bytes4 => bool) hasExplicitDelay;\n        /// @notice Default delay for functions without specific configuration\n        uint256 defaultFunctionDelay;\n    }\n\n    /**\n     * @dev Returns the storage struct at the namespaced storage position\n     * @return $ The VaultTimelockStorage struct\n     */\n    function _getVaultTimelockStorage() private pure returns (VaultTimelockStorage storage $) {\n        assembly {\n            $.slot := VAULT_TIMELOCK_STORAGE_POSITION\n        }\n    }\n    /// @notice Time delay constants\n\n    uint256 public constant MIN_FUNCTION_DELAY = 1 hours;\n    uint256 public constant RECOVERY_DELAY = 12 hours;\n    uint256 public constant MIN_DEFAULT_DELAY = 12 hours;\n    uint256 public constant PARAMETER_DELAY = 24 hours;\n    uint256 public constant ORACLE_DELAY = 36 hours;\n    uint256 public constant CONFIG_DELAY = 48 hours;\n    uint256 public constant ROLE_DELAY = 72 hours;\n    uint256 public constant MAX_DELAY = 7 days;\n\n    /// @notice Events\n    event FunctionDelaySet(bytes4 indexed selector, uint256 delay);\n    event DefaultDelayUpdated(uint256 newDelay);\n    event OperationScheduledWithAutoDelay(\n        bytes32 indexed id, address indexed target, bytes4 indexed selector, uint256 delay\n    );\n    event OperationExecuted(bytes32 indexed id, address indexed target, bytes4 indexed selector);\n    event OperationBatchExecuted(bytes32 indexed id, uint256 operationCount);\n\n    /**\n     * @notice Get the delay for a specific function selector\n     * @param selector Function selector\n     * @return delay The delay in seconds\n     */\n    function functionDelays(bytes4 selector) public view returns (uint256 delay) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        return $.functionDelays[selector];\n    }\n\n    /**\n     * @notice Check if a function selector has explicit delay configuration\n     * @param selector Function selector\n     * @return hasExplicit True if the function has explicit delay configuration\n     */\n    function hasExplicitDelay(bytes4 selector) public view returns (bool hasExplicit) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        return $.hasExplicitDelay[selector];\n    }\n\n    /**\n     * @notice Get the default delay for unconfigured functions\n     * @return delay The default delay in seconds\n     */\n    function defaultFunctionDelay() public view returns (uint256 delay) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        return $.defaultFunctionDelay;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the enhanced timelock controller\n     * @param minDelay Minimum delay for operations\n     * @param proposers Array of proposer addresses\n     * @param executors Array of executor addresses\n     * @param admin Optional admin address\n     */\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin)\n        public\n        override\n        initializer\n    {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n\n        // Set default delay for unconfigured functions\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        $.defaultFunctionDelay = CONFIG_DELAY;\n\n        // Configure critical function selectors with their specific delays\n        _configureCriticalFunctions();\n    }\n\n    /**\n     * @notice Configure function selectors with their specific delays\n     */\n    function _configureCriticalFunctions() internal {\n        // Role management functions - Most critical\n        _setFunctionDelay(bytes4(keccak256(\"addMinter(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"addBurner(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeMinter(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeBurner(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"grantRole(bytes32,address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"revokeRole(bytes32,address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"addFeeCollector(address)\")), ROLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeFeeCollector(address)\")), ROLE_DELAY);\n\n        // Critical config updates\n        _setFunctionDelay(bytes4(keccak256(\"setFees((uint256,uint256))\")), CONFIG_DELAY); // since it's a struct we must consider this as a tuple\n        _setFunctionDelay(bytes4(keccak256(\"setFees(uint256,uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setLiquidityProvider(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setPythContract(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setUnderlyingAsset(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"registerDepositPipe(address,address,address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"removeDepositPipe(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRedemptionPipe(address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxDeposit(uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxSupply(uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxWithdraw(uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setMaxPercentageIncrease(uint256)\")), CONFIG_DELAY);\n\n        // Oracle price feed configuration\n        _setFunctionDelay(bytes4(keccak256(\"setMaxPriceAge(uint256)\")), ORACLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setPriceId(address,bytes32,uint8)\")), ORACLE_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setPriceIds(address[],bytes32[],uint8[])\")), ORACLE_DELAY);\n\n        // OVaultComposerMulti functions\n        _setFunctionDelay(bytes4(keccak256(\"setOVaultComposerMulti(address,address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setOFTApproval(address,bool)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRemotePeer(address,uint32,bytes32)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRemotePeer(address,uint32,address)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setTimelockController(address)\")), MAX_DELAY);\n\n        // Deposit forwarder\n        _setFunctionDelay(bytes4(keccak256(\"addDepositPipe(address)\")), CONFIG_DELAY);\n\n        // Proxy upgrade functions\n        // ProxyAdmin (TransparentUpgradeable)\n        _setFunctionDelay(bytes4(keccak256(\"upgradeAndCall(address,address,bytes)\")), CONFIG_DELAY);\n        // UUPS\n        _setFunctionDelay(bytes4(keccak256(\"upgradeToAndCall(address,bytes)\")), CONFIG_DELAY);\n\n        // Parameter changes\n        _setFunctionDelay(bytes4(keccak256(\"setStrategist(address)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setFeeReceiver(address)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setDepositFee(uint256)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setRecoveryDelay(uint256)\")), PARAMETER_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setTreasury(address)\")), PARAMETER_DELAY);\n\n        // Token recovery\n        _setFunctionDelay(bytes4(keccak256(\"recoverToken(address,address,uint256)\")), RECOVERY_DELAY);\n\n        // Timelock configuration functions - self-referential protection\n        _setFunctionDelay(bytes4(keccak256(\"setFunctionDelay(bytes4,uint256)\")), CONFIG_DELAY);\n        _setFunctionDelay(bytes4(keccak256(\"setDefaultFunctionDelay(uint256)\")), CONFIG_DELAY);\n    }\n    /**\n     * @notice Get suggested delay for a function\n     * @param data Function call data\n     * @return Suggested delay in seconds\n     */\n    function _getDelay(bytes calldata data) internal view returns (uint256) {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n\n        if (data.length < 4) return $.defaultFunctionDelay;\n\n        bytes4 selector = bytes4(data[:4]);\n        uint256 functionDelay = $.functionDelays[selector];\n\n        // Return specific delay if explicitly configured, otherwise default delay\n        return $.hasExplicitDelay[selector] ? functionDelay : $.defaultFunctionDelay;\n    }\n\n    /**\n     * @notice Get suggested delay for a function (external version)\n     * @param data Function call data\n     * @return Suggested delay in seconds\n     */\n    function getDelay(bytes calldata data) external view returns (uint256) {\n        return _getDelay(data);\n    }\n\n    /**\n     * @notice Schedule operation with automatic delay detection\n     * @param target Target contract\n     * @param value ETH value\n     * @param data Function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     * @return Operation ID\n     */\n    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt)\n        external\n        returns (bytes32)\n    {\n        require(hasRole(PROPOSER_ROLE, msg.sender), \"VaultTimelock: not proposer\");\n\n        uint256 delay = _getDelay(data);\n\n        // Calculate operation ID and schedule\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        super.schedule(target, value, data, predecessor, salt, delay);\n\n        bytes4 selector = data.length >= 4 ? bytes4(data[:4]) : bytes4(0);\n        emit OperationScheduledWithAutoDelay(id, target, selector, delay);\n\n        return id;\n    }\n\n    /**\n     * @notice Schedule multiple operations with automatic delay detection\n     * @param targets Array of target contracts\n     * @param values Array of ETH values\n     * @param payloads Array of function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     * @return Operation ID for the batch\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external returns (bytes32) {\n        require(hasRole(PROPOSER_ROLE, msg.sender), \"VaultTimelock: not proposer\");\n        uint256 length = targets.length;\n        require(length == values.length, \"VaultTimelock: length mismatch\");\n        require(length == payloads.length, \"VaultTimelock: length mismatch\");\n        require(length > 0, \"VaultTimelock: empty batch\");\n\n        // Calculate the maximum delay required for all operations\n        uint256 maxDelay = 0;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 operationDelay = _getDelay(payloads[i]);\n            if (operationDelay > maxDelay) {\n                maxDelay = operationDelay;\n            }\n        }\n\n        // Schedule the batch with the maximum delay\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        super.scheduleBatch(targets, values, payloads, predecessor, salt, maxDelay);\n\n        // Emit events for each operation in the batch\n        for (uint256 i = 0; i < length; i++) {\n            bytes4 selector = payloads[i].length >= 4 ? bytes4(payloads[i][:4]) : bytes4(0);\n            emit OperationScheduledWithAutoDelay(id, targets[i], selector, maxDelay);\n        }\n\n        return id;\n    }\n\n    /**\n     * @notice Execute operation with automatic delay verification\n     * @param target Target contract\n     * @param value ETH value\n     * @param data Function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     */\n    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt)\n        public\n        payable\n        override\n    {\n        require(hasRole(EXECUTOR_ROLE, msg.sender), \"VaultTimelock: not executor\");\n\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        require(isOperationReady(id), \"VaultTimelock: operation not ready\");\n\n        super.execute(target, value, data, predecessor, salt);\n\n        bytes4 selector = data.length >= 4 ? bytes4(data[:4]) : bytes4(0);\n        emit OperationExecuted(id, target, selector);\n    }\n\n    /**\n     * @notice Execute multiple operations with automatic delay verification\n     * @param targets Array of target contracts\n     * @param values Array of ETH values\n     * @param payloads Array of function call data\n     * @param predecessor Predecessor operation ID\n     * @param salt Random salt for uniqueness\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable override {\n        require(hasRole(EXECUTOR_ROLE, msg.sender), \"VaultTimelock: not executor\");\n        uint256 length = targets.length;\n        require(length == values.length, \"VaultTimelock: length mismatch\");\n        require(length == payloads.length, \"VaultTimelock: length mismatch\");\n        require(length > 0, \"VaultTimelock: empty batch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        require(isOperationReady(id), \"VaultTimelock: operation not ready\");\n\n        super.executeBatch(targets, values, payloads, predecessor, salt);\n\n        emit OperationBatchExecuted(id, length);\n    }\n\n    /**\n     * @notice Set delay for a specific function\n     * @dev Must be called through the timelock itself (via schedule/execute) to enforce the configured delay\n     * @param selector Function selector\n     * @param delay Delay in seconds\n     */\n    function setFunctionDelay(bytes4 selector, uint256 delay) external {\n        require(msg.sender == address(this), \"VaultTimelock: must call through timelock\");\n        require(delay >= MIN_FUNCTION_DELAY, \"VaultTimelock: delay too short\");\n        require(delay <= MAX_DELAY, \"VaultTimelock: delay too long\");\n\n        _updateFunctionDelay(selector, delay);\n        emit FunctionDelaySet(selector, delay);\n    }\n\n    /**\n     * @notice Update default delay for unconfigured functions\n     * @dev Must be called through the timelock itself (via schedule/execute) to enforce the configured delay\n     * @param newDefaultDelay New default delay in seconds\n     */\n    function setDefaultFunctionDelay(uint256 newDefaultDelay) external {\n        require(msg.sender == address(this), \"VaultTimelock: must call through timelock\");\n        require(newDefaultDelay >= MIN_DEFAULT_DELAY, \"VaultTimelock: default delay too short\");\n        require(newDefaultDelay <= MAX_DELAY, \"VaultTimelock: default delay too long\");\n\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        require(newDefaultDelay != $.defaultFunctionDelay, \"VaultTimelock: same default delay\");\n\n        $.defaultFunctionDelay = newDefaultDelay;\n        emit DefaultDelayUpdated(newDefaultDelay);\n    }\n\n    /**\n     * @notice Internal helper to set function delay and mark as explicit\n     * @dev Reverts if a delay is already explicitly set for the selector to prevent collisions\n     * @param selector Function selector\n     * @param delay Delay in seconds\n     */\n    function _setFunctionDelay(bytes4 selector, uint256 delay) internal {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        require(!$.hasExplicitDelay[selector], \"VaultTimelock: Selector collision detected\");\n        $.functionDelays[selector] = delay;\n        $.hasExplicitDelay[selector] = true;\n    }\n\n    /**\n     * @notice Internal helper to update function delay (allows overwriting existing delay)\n     * @param selector Function selector\n     * @param delay Delay in seconds\n     */\n    function _updateFunctionDelay(bytes4 selector, uint256 delay) internal {\n        VaultTimelockStorage storage $ = _getVaultTimelockStorage();\n        $.functionDelays[selector] = delay;\n        $.hasExplicitDelay[selector] = true;\n    }\n}\n",
        "DepositPipe.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {INAVOracle} from \"./interfaces/INAVOracle.sol\";\nimport {IShareManager} from \"./interfaces/IShareManager.sol\";\n\ninterface IFeeManager {\n    function accruePerformanceFee() external;\n}\n\n/**\n * @title DepositPipe\n * @notice Handles deposits for a specific asset\n * @dev Implements IERC4626 interface for compatibility, delegates share management to ShareManager\n * @dev Inherits ERC20Upgradeable only for IERC4626 compatibility (name, symbol, decimals)\n *      The actual share balances and transfers are NOT managed by this contract but by ShareManager\n */\ncontract DepositPipe is\n    ERC20Upgradeable,\n    IERC4626,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    /// @notice Role for emergency pause/unpause operations\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n\n    /// @notice Role for keeper operations\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @custom:storage-location erc7201:liminal.depositPipe.v1\n    struct DepositPipeStorage {\n        /// @notice Share manager contract\n        IShareManager shareManager;\n        /// @notice Price oracle for conversions\n        IPriceOracle priceOracle;\n        /// @notice NAV oracle for total value tracking\n        INAVOracle navOracle;\n        /// @notice Deposit asset (the asset accepted for deposits)\n        address depositAsset;\n        /// @notice Underlying asset of the vault (redemption asset)\n        address underlyingAsset;\n        /// @notice Strategist address to receive deposits\n        address strategist;\n        /// @notice Keeper address for depositFor operations\n        address keeper;\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Minimum shares to prevent rounding to zero assets (OZ recommendation: 1000 units)\n        /// Calculated as 1000 * 10^(18 - assetDecimals)\n        uint256 MIN_AMOUNT_SHARES;\n        /// @notice Optional fee manager to crystallize performance fee before deposits\n        address feeManager;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.depositPipe.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant DEPOSIT_PIPE_STORAGE_LOCATION =\n        0x8181ed37ae785402ef857f5d1a6b18f3cfc3c3050c29b53fffd1ba0acd9e0600;\n\n    function _getDepositPipeStorage() private pure returns (DepositPipeStorage storage $) {\n        assembly {\n            $.slot := DEPOSIT_PIPE_STORAGE_LOCATION\n        }\n    }\n\n    /// Events\n    event DepositProcessed(\n        address indexed depositor, address indexed receiver, uint256 assetsIn, uint256 sharesOut\n    );\n    event StrategistUpdated(address indexed oldStrategist, address indexed newStrategist);\n\n    event TimeLockControllerUpdated(address indexed oldTimeLockController, address indexed newTimeLockController);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        require(msg.sender == $.timeLockController, \"DepositPipe: only timelock\");\n        _;\n    }\n\n    /// @notice Modifier to accrue performance fees before operations\n    modifier accruePerformanceFee() {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        if ($.feeManager != address(0)) {\n            IFeeManager($.feeManager).accruePerformanceFee();\n        }\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Parameters for initialization\n    struct InitializeParams {\n        address depositAsset;\n        string name;\n        string symbol;\n        address shareManager;\n        address priceOracle;\n        address navOracle;\n        address underlyingAsset;\n        address strategist;\n        address deployer;\n        address emergencyManager;\n        address keeper;\n        address timeLockController;\n        address feeManager;\n    }\n\n    /**\n     * @notice Initialize the deposit pipe\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param params Struct containing all initialization parameters\n     */\n    function initialize(InitializeParams calldata params) external initializer {\n        require(params.depositAsset != address(0), \"DepositPipe: zero asset\");\n        require(params.shareManager != address(0), \"DepositPipe: zero share manager\");\n        require(params.priceOracle != address(0), \"DepositPipe: zero oracle\");\n        require(params.navOracle != address(0), \"DepositPipe: zero nav oracle\");\n        require(params.underlyingAsset != address(0), \"DepositPipe: zero underlying\");\n        require(params.strategist != address(0), \"DepositPipe: zero strategist\");\n        require(params.deployer != address(0), \"DepositPipe: zero deployer\");\n        require(params.keeper != address(0), \"DepositPipe: zero keeper\");\n        require(params.timeLockController != address(0), \"DepositPipe: zero timelock\");\n        require(params.feeManager != address(0), \"DepositPipe: zero fee manager\");\n\n        __ERC20_init(params.name, params.symbol);\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        $.shareManager = IShareManager(params.shareManager);\n        $.priceOracle = IPriceOracle(params.priceOracle);\n        $.navOracle = INAVOracle(params.navOracle);\n        $.depositAsset = params.depositAsset;\n        $.underlyingAsset = params.underlyingAsset;\n        $.strategist = params.strategist;\n        $.keeper = params.keeper;\n        $.timeLockController = params.timeLockController;\n        $.feeManager = params.feeManager;\n        // Calculate minimum shares based on underlying asset decimals\n        // MIN_AMOUNT_SHARES = 1000 * 10^(18 - assetDecimals) to ensure at least 1000 units of assets\n        uint8 underlyingDecimals = IERC20Metadata(params.underlyingAsset).decimals();\n        require(underlyingDecimals <= 18, \"DepositPipe: unsupported underlying decimals\");\n        $.MIN_AMOUNT_SHARES = 1000 * 10**(18 - underlyingDecimals);\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, params.deployer);\n        _grantRole(EMERGENCY_MANAGER_ROLE, params.emergencyManager);\n        _grantRole(KEEPER_ROLE, params.keeper);\n    }\n\n\n    /**\n     * @notice Deposit assets and receive shares (ERC4626 standard)\n     * @param assets Amount of deposit asset\n     * @param receiver Address to receive shares\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256 shares) {\n        return deposit(assets, receiver, msg.sender, 0);\n    }\n\n    /**\n     * @notice Deposit assets with controller\n     * @param assets Amount of deposit asset\n     * @param receiver Address to receive shares\n     * @param controller Address that owns the assets\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver, address controller) public returns (uint256 shares) {\n        return deposit(assets, receiver, controller, 0);\n    }\n\n    /**\n     * @notice Deposit assets with slippage protection\n     * @param assets Amount of deposit asset\n     * @param receiver Address to receive shares\n     * @param minShares Minimum shares to receive (slippage protection)\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver, uint256 minShares) public returns (uint256 shares) {\n        return deposit(assets, receiver, msg.sender, minShares);\n    }\n\n    /**\n     * @notice Deposit with controller and slippage protection\n     * @param assets Amount of deposit asset\n     * @param receiver Address to receive shares\n     * @param controller Address that owns the assets\n     * @param minShares Minimum shares to receive (slippage protection)\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver, address controller, uint256 minShares)\n        public\n        whenNotPaused\n        nonReentrant\n        accruePerformanceFee\n        returns (uint256 shares)\n    {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n\n        // Check authorization\n        require(\n            controller == msg.sender || $.shareManager.isOperator(controller, msg.sender), \"DepositPipe: unauthorized\"\n        );\n\n        require(assets > 0, \"DepositPipe: zero assets\");\n\n        // Transfer assets from controller\n        IERC20($.depositAsset).safeTransferFrom(controller, address(this), assets);\n\n        // Convert to underlying asset value (oracle returns native decimals)\n        uint256 underlyingValue = $.priceOracle.convertAmount($.depositAsset, $.underlyingAsset, assets);\n        uint256 underlyingValue18 = _normalizeToDecimals18(underlyingValue);\n\n        // Calculate shares based on NAV (now both in 18 decimals)\n        shares = _convertToShares(underlyingValue18);\n        require(shares >= $.MIN_AMOUNT_SHARES, \"DepositPipe: shares below minimum\");\n        require(shares >= minShares, \"DepositPipe: slippage exceeded\");\n\n        // Check max deposit per user before minting\n        require($.shareManager.balanceOf(receiver) + shares <= $.shareManager.maxDeposit(), \"ShareManager: max deposit exceeded\");\n        require($.shareManager.totalSupply() + shares <= $.shareManager.maxSupply(), \"DepositPipe: max supply exceeded\");\n\n        // Transfer assets to strategist\n        IERC20($.depositAsset).safeTransfer($.strategist, assets);\n\n        // Update NAV oracle\n        $.navOracle.increaseTotalAssets(underlyingValue);\n\n        // Mint shares via ShareManager\n        $.shareManager.mintShares(receiver, shares);\n\n        emit DepositProcessed(controller, receiver, assets, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Mint specific amount of shares (ERC4626 standard)\n     * @param shares Amount of shares to mint\n     * @param receiver Address to receive shares\n     * @return assets Amount of assets required\n     */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        return mint(shares, receiver, msg.sender);\n    }\n\n    /**\n     * @notice Mint shares with controller\n     * @param shares Amount of shares to mint\n     * @param receiver Address to receive shares\n     * @param controller Address that owns the assets\n     * @return assets Amount of assets required\n     */\n    function mint(uint256 shares, address receiver, address controller) public returns (uint256 assets) {\n        return mint(shares, receiver, controller, type(uint256).max);\n    }\n\n    /**\n     * @notice Mint shares with slippage protection\n     * @param shares Amount of shares to mint\n     * @param receiver Address to receive shares\n     * @param maxAssets Maximum assets to spend (slippage protection)\n     * @return assets Amount of assets required\n     */\n    function mint(uint256 shares, address receiver, uint256 maxAssets) public returns (uint256 assets) {\n        return mint(shares, receiver, msg.sender, maxAssets);\n    }\n\n    /**\n     * @notice Mint with controller and slippage protection\n     * @param shares Amount of shares to mint\n     * @param receiver Address to receive shares\n     * @param controller Address that owns the assets\n     * @param maxAssets Maximum assets to spend (slippage protection)\n     * @return assets Amount of assets required\n     */\n    function mint(uint256 shares, address receiver, address controller, uint256 maxAssets)\n        public\n        whenNotPaused\n        nonReentrant\n        accruePerformanceFee\n        returns (uint256 assets)\n    {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n\n        // Check authorization\n        require(\n            controller == msg.sender || $.shareManager.isOperator(controller, msg.sender), \"DepositPipe: unauthorized\"\n        );\n\n        require(shares >= $.MIN_AMOUNT_SHARES, \"DepositPipe: shares below minimum\");\n        require($.shareManager.balanceOf(receiver) + shares <= $.shareManager.maxDeposit(), \"ShareManager: max deposit exceeded\");\n        require($.shareManager.totalSupply() + shares <= $.shareManager.maxSupply(), \"DepositPipe: max supply exceeded\");\n\n        // Calculate required underlying value for shares (returns 18 decimals)\n        uint256 underlyingValue18 = _convertToAssets(shares);\n\n        // Convert from 18 decimals to underlying asset's native decimals\n        uint256 underlyingValueNative = _normalizeFromDecimals18(underlyingValue18);\n\n        // Convert from underlying to deposit asset (using native decimals)\n        assets = $.priceOracle.convertAmount($.underlyingAsset, $.depositAsset, underlyingValueNative);\n\n        // Check slippage protection\n        require(assets <= maxAssets, \"DepositPipe: slippage exceeded\");\n\n        // Transfer assets from controller\n        IERC20($.depositAsset).safeTransferFrom(controller, address(this), assets);\n\n        // Transfer assets to strategist\n        IERC20($.depositAsset).safeTransfer($.strategist, assets);\n\n        // Update NAV oracle\n        $.navOracle.increaseTotalAssets(underlyingValueNative);\n\n        // Mint shares via ShareManager\n        $.shareManager.mintShares(receiver, shares);\n\n        emit DepositProcessed(controller, receiver, assets, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Convert underlying value to shares\n     * @param underlyingValue Value in underlying asset\n     * @return shares Amount of shares\n     */\n    function _convertToShares(uint256 underlyingValue) internal view returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint256 sharesTotalSupply = $.shareManager.totalSupply();\n        uint256 totalAssets_ = $.navOracle.getNAV();\n\n        if (sharesTotalSupply == 0) {\n            // For first deposit, underlyingValue is already in 18 decimals (underlying asset decimals)\n            // Shares should also be in 18 decimals, so return 1:1\n            return underlyingValue;\n        }\n\n        // Both underlyingValue and totalAssets_ are in 18 decimals (underlying asset decimals)\n        // totalSupply is in 18 decimals (shares decimals)\n        // To maintain the ratio: shares/totalSupply = value/totalAssets\n        // We need: shares = (value * totalSupply) / totalAssets\n        // Since the result should be in 18 decimals like totalSupply, this works correctly\n        return underlyingValue.mulDiv(sharesTotalSupply, totalAssets_, Math.Rounding.Floor);\n    }\n\n    /**\n     * @notice Convert shares to underlying value\n     * @param shares Amount of shares\n     * @return underlyingValue Value in underlying asset\n     */\n    function _convertToAssets(uint256 shares) internal view returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint256 sharesTotalSupply = $.shareManager.totalSupply();\n        uint256 totalAssets_ = $.navOracle.getNAV();\n\n        if (sharesTotalSupply == 0) {\n            // When no shares exist, 1 share = 1 underlying token (both 18 decimals)\n            return shares;\n        }\n\n        // value = shares * totalAssets / totalSupply\n        return shares.mulDiv(totalAssets_, sharesTotalSupply, Math.Rounding.Ceil);\n    }\n\n    // ========== INTERNAL HELPERS ==========\n\n    /**\n     * @notice Normalize value to 18 decimals from underlying asset's decimals\n     * @param valueNative Value in underlying asset's native decimals\n     * @return value18 Value normalized to 18 decimals\n     */\n    function _normalizeToDecimals18(uint256 valueNative) internal view returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint8 underlyingDecimals = IERC20Metadata($.underlyingAsset).decimals();\n\n        if (underlyingDecimals == 18) {\n            return valueNative;\n        } else {\n            // This is safe because underlyingDecimals is always 18 or less\n            uint256 scaleFactor = 10 ** (18 - underlyingDecimals);\n            return valueNative * scaleFactor;\n        }\n    }\n\n    /**\n     * @notice Convert value from 18 decimals to underlying asset's decimals\n     * @param value18 Value in 18 decimals\n     * @return valueNative Value in underlying asset's native decimals\n     */\n    function _normalizeFromDecimals18(uint256 value18) internal view returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint8 underlyingDecimals = IERC20Metadata($.underlyingAsset).decimals();\n\n        if (underlyingDecimals == 18) {\n            return value18;\n        } else {\n            // This is safe because underlyingDecimals is always 18 or less\n            uint256 scaleFactor = 10 ** (18 - underlyingDecimals);\n            return value18 / scaleFactor;\n        }\n    }\n\n    // ========== VIEW FUNCTIONS ==========\n\n    /**\n     * @notice Get the deposit asset address\n     * @return Address of the deposit asset\n     */\n    function asset() public view virtual override returns (address) {\n        return _getDepositPipeStorage().depositAsset;\n    }\n\n    /**\n     * @notice Override totalSupply to return 0 (shares managed by ShareManager)\n     */\n    function totalSupply() public view virtual override(ERC20Upgradeable, IERC20) returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Override balanceOf to return 0 (shares managed by ShareManager)\n     */\n    function balanceOf(address) public view virtual override(ERC20Upgradeable, IERC20) returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Override transfer to revert (shares managed by ShareManager)\n     */\n    function transfer(address, uint256) public virtual override(ERC20Upgradeable, IERC20) returns (bool) {\n        revert(\"DepositPipe: transfers not supported\");\n    }\n\n    /**\n     * @notice Override allowance to return 0 (shares managed by ShareManager)\n     */\n    function allowance(address, address) public view virtual override(ERC20Upgradeable, IERC20) returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Override approve to revert (shares managed by ShareManager)\n     */\n    function approve(address, uint256) public virtual override(ERC20Upgradeable, IERC20) returns (bool) {\n        revert(\"DepositPipe: approvals not supported\");\n    }\n\n    /**\n     * @notice Override transferFrom to revert (shares managed by ShareManager)\n     */\n    function transferFrom(address, address, uint256) public virtual override(ERC20Upgradeable, IERC20) returns (bool) {\n        revert(\"DepositPipe: transfers not supported\");\n    }\n\n    /**\n     * @notice Preview deposit - converts assets to shares\n     * @param assets Amount of deposit asset\n     * @return shares Expected shares\n     */\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        require(assets > 0, \"DepositPipe: zero assets\");\n\n        uint256 underlyingValueNative = $.priceOracle.convertAmount($.depositAsset, $.underlyingAsset, assets);\n\n        // Normalize to 18 decimals\n        uint256 underlyingValue18 = _normalizeToDecimals18(underlyingValueNative);\n\n        uint256 shares = _convertToShares(underlyingValue18);\n        require(shares >= $.MIN_AMOUNT_SHARES, \"DepositPipe: shares below minimum\");\n        require($.shareManager.balanceOf(msg.sender) + shares <= $.shareManager.maxDeposit(), \"ShareManager: max deposit exceeded\");\n        require($.shareManager.totalSupply() + shares <= $.shareManager.maxSupply(), \"DepositPipe: max supply exceeded\");\n\n        return shares;\n    }\n\n    /**\n     * @notice Preview mint - calculates required assets\n     * @param shares Desired shares\n     * @return assets Required deposit assets\n     */\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        require(shares >= $.MIN_AMOUNT_SHARES, \"DepositPipe: shares below minimum\");\n        require($.shareManager.balanceOf(msg.sender) + shares <= $.shareManager.maxDeposit(), \"ShareManager: max deposit exceeded\");\n        require($.shareManager.totalSupply() + shares <= $.shareManager.maxSupply(), \"DepositPipe: max supply exceeded\");\n\n        uint256 underlyingValue18 = _convertToAssets(shares);\n\n        // Convert from 18 decimals to underlying asset's native decimals\n        uint256 underlyingValueNative = _normalizeFromDecimals18(underlyingValue18);\n\n        uint256 assets = $.priceOracle.convertAmount($.underlyingAsset, $.depositAsset, underlyingValueNative);\n        return assets;\n    }\n\n    /**\n     * @notice Preview deposit for a specific user - converts assets to shares\n     * @param assets Amount of deposit asset\n     * @param user Address of the user to check limits for\n     * @return shares Expected shares\n     */\n    function previewDeposit(uint256 assets, address user) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        require(assets > 0, \"DepositPipe: zero assets\");\n\n        uint256 underlyingValueNative = $.priceOracle.convertAmount($.depositAsset, $.underlyingAsset, assets);\n\n        // Normalize to 18 decimals\n        uint256 underlyingValue18 = _normalizeToDecimals18(underlyingValueNative);\n\n        uint256 shares = _convertToShares(underlyingValue18);\n        require(shares >= $.MIN_AMOUNT_SHARES, \"DepositPipe: shares below minimum\");\n        require($.shareManager.balanceOf(user) + shares <= $.shareManager.maxDeposit(), \"ShareManager: max deposit exceeded\");\n        require($.shareManager.totalSupply() + shares <= $.shareManager.maxSupply(), \"DepositPipe: max supply exceeded\");\n\n        return shares;\n    }\n\n    /**\n     * @notice Preview mint for a specific user - calculates required assets\n     * @param shares Desired shares\n     * @param user Address of the user to check limits for\n     * @return assets Required deposit assets\n     */\n    function previewMint(uint256 shares, address user) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        require(shares >= $.MIN_AMOUNT_SHARES, \"DepositPipe: shares below minimum\");\n        require($.shareManager.balanceOf(user) + shares <= $.shareManager.maxDeposit(), \"ShareManager: max deposit exceeded\");\n        require($.shareManager.totalSupply() + shares <= $.shareManager.maxSupply(), \"DepositPipe: max supply exceeded\");\n\n        uint256 underlyingValue18 = _convertToAssets(shares);\n\n        // Convert from 18 decimals to underlying asset's native decimals\n        uint256 underlyingValueNative = _normalizeFromDecimals18(underlyingValue18);\n\n        uint256 assets = $.priceOracle.convertAmount($.underlyingAsset, $.depositAsset, underlyingValueNative);\n        return assets;\n    }\n\n    /**\n     * @notice Convert deposit assets to shares\n     * @param assets Amount of deposit asset\n     * @return shares Equivalent shares\n     */\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint256 underlyingValueNative = $.priceOracle.convertAmount($.depositAsset, $.underlyingAsset, assets);\n        uint256 underlyingValue18 = _normalizeToDecimals18(underlyingValueNative);\n        return _convertToShares(underlyingValue18);\n    }\n\n    /**\n     * @notice Convert shares to deposit assets\n     * @param shares Amount of shares\n     * @return assets Equivalent deposit assets\n     */\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint256 underlyingValue18 = _convertToAssets(shares);\n        uint256 underlyingValueNative = _normalizeFromDecimals18(underlyingValue18);\n        return $.priceOracle.convertAmount($.underlyingAsset, $.depositAsset, underlyingValueNative);\n    }\n\n    /**\n     * @notice Total assets managed by this pipe (always 0 as assets are forwarded)\n     */\n    function totalAssets() public view virtual returns (uint256) {\n        return 0; // Assets are forwarded to strategist\n    }\n\n    /**\n     * @notice Maximum deposit amount for a user\n     * @param user User address\n     * @return Maximum deposit amount in deposit asset\n     */\n    function maxDeposit(address user) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint256 currentUserShares = $.shareManager.balanceOf(user);\n        uint256 maxDepositUserShares = $.shareManager.maxDeposit();\n        uint256 currentTotalSupply = $.shareManager.totalSupply();\n        uint256 maxSupply = $.shareManager.maxSupply();\n        \n        // Calculate remaining shares based on user limit\n        uint256 remainingUserShares = 0;\n        if (currentUserShares < maxDepositUserShares) {\n            remainingUserShares = maxDepositUserShares - currentUserShares;\n        }\n        \n        // Calculate remaining shares based on global supply limit\n        uint256 remainingSupplyShares = 0;\n        if (currentTotalSupply < maxSupply) {\n            remainingSupplyShares = maxSupply - currentTotalSupply;\n        }\n        \n        // Take the minimum of both limits\n        uint256 maxShares = remainingUserShares < remainingSupplyShares ? remainingUserShares : remainingSupplyShares;\n        \n        if (maxShares < $.MIN_AMOUNT_SHARES) {\n            return 0;\n        }\n        \n        return convertToAssets(maxShares);\n    }\n\n    /**\n     * @notice Maximum mint amount for a user\n     * @param user User address\n     * @return Maximum shares that can be minted\n     */\n    function maxMint(address user) public view virtual returns (uint256) {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        uint256 currentUserShares = $.shareManager.balanceOf(user);\n        uint256 maxDepositUserShares = $.shareManager.maxDeposit();\n        uint256 currentTotalSupply = $.shareManager.totalSupply();\n        uint256 maxSupply = $.shareManager.maxSupply();\n        \n        // Calculate remaining shares based on user limit\n        uint256 remainingUserShares = 0;\n        if (currentUserShares < maxDepositUserShares) {\n            remainingUserShares = maxDepositUserShares - currentUserShares;\n        }\n        \n        // Calculate remaining shares based on global supply limit\n        uint256 remainingSupplyShares = 0;\n        if (currentTotalSupply < maxSupply) {\n            remainingSupplyShares = maxSupply - currentTotalSupply;\n        }\n        \n        // Take the minimum of both limits\n        uint256 maxShares = remainingUserShares < remainingSupplyShares ? remainingUserShares : remainingSupplyShares;\n        if (maxShares < $.MIN_AMOUNT_SHARES) {\n            return 0;\n        }\n\n        return maxShares;\n    }\n\n    // Note: Redemption functions revert as this is deposit-only\n\n    function maxWithdraw(address) public pure virtual returns (uint256) {\n        return 0; // No withdrawals through deposit pipe\n    }\n\n    function maxRedeem(address) public pure virtual returns (uint256) {\n        return 0; // No redemptions through deposit pipe\n    }\n\n    function previewWithdraw(uint256) public pure virtual returns (uint256) {\n        revert(\"DepositPipe: withdraw not supported\");\n    }\n\n    function previewRedeem(uint256) public pure virtual returns (uint256) {\n        revert(\"DepositPipe: redeem not supported\");\n    }\n\n    function withdraw(uint256, address, address) public pure virtual returns (uint256) {\n        revert(\"DepositPipe: withdraw not supported\");\n    }\n\n    function redeem(uint256, address, address) public pure virtual returns (uint256) {\n        revert(\"DepositPipe: redeem not supported\");\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Update deposit asset address\n     * @param _timelockController New timelock controller address\n     */\n    function setTimelockController(address _timelockController) external onlyTimelock {\n        require(_timelockController != address(0), \"DepositPipe: zero timelock\");\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        address oldTimeLockController = $.timeLockController;\n        $.timeLockController = _timelockController;\n        emit TimeLockControllerUpdated(oldTimeLockController, _timelockController);\n    }\n\n    /**\n     * @notice Update strategist address\n     * @param _strategist New strategist address\n     */\n    function setStrategist(address _strategist) external onlyTimelock {\n        require(_strategist != address(0), \"DepositPipe: zero address\");\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        address oldStrategist = $.strategist;\n        $.strategist = _strategist;\n        emit StrategistUpdated(oldStrategist, _strategist);\n    }\n\n    /**\n     * @notice Set FeeManager hook for crystallizing performance fees pre-deposit\n     * @param _feeManager Address of the fee manager (set 0 to disable)\n     */\n    function setFeeManager(address _feeManager) external onlyTimelock {\n        DepositPipeStorage storage $ = _getDepositPipeStorage();\n        $.feeManager = _feeManager;\n    }\n\n    /// @notice Get configured FeeManager address\n    function feeManager() public view returns (address) {\n        return _getDepositPipeStorage().feeManager;\n    }\n\n    /// @notice Get strategist address\n    function strategist() public view returns (address) {\n        return _getDepositPipeStorage().strategist;\n    }\n\n    /// @notice Get timelock controller address\n    function timeLockController() public view returns (address) {\n        return _getDepositPipeStorage().timeLockController;\n    }\n\n    /// @notice Get minimum amount required for shares\n    function MIN_AMOUNT_SHARES() public view returns (uint256) {\n        return _getDepositPipeStorage().MIN_AMOUNT_SHARES;\n    }\n\n    /**\n     * @notice Emergency pause\n     */\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause operations\n     */\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Recover tokens from the contract (timelock-protected)\n     * @param token Token address to recover\n     * @param to Recipient address\n     * @param amount Amount to recover\n     */\n    function recoverToken(address token, address to, uint256 amount) external onlyTimelock {\n        require(token != address(0), \"DepositPipe: zero token\");\n        require(to != address(0), \"DepositPipe: zero recipient\");\n        require(amount > 0, \"DepositPipe: zero amount\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n",
        "PythPriceOracle.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IPyth} from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/**\n * @title PythPriceOracle\n * @notice Oracle integration with Pyth Network price feeds\n * @dev Uses Pyth's pull-based price model with real-time updates\n */\ncontract PythPriceOracle is AccessControlUpgradeable, IPriceOracle {\n    /// @notice Role for managing price IDs\n    bytes32 public constant PRICE_MANAGER_ROLE = keccak256(\"PRICE_MANAGER_ROLE\");\n\n    /// @notice Maximum confidence interval threshold in basis points\n    uint256 public constant BASIS_POINTS = 10_000;\n\n    /// @custom:storage-location erc7201:liminal.pythPriceOracle.v1\n    struct PythPriceOracleStorage {\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Asset address to Pyth price ID mapping\n        mapping(address => bytes32) priceIds;\n        /// @notice Asset decimals for conversion\n        mapping(address => uint8) assetDecimals;\n        /// @notice Underlying asset of the vault (for redemptions)\n        address underlyingAsset;\n        /// @notice Pyth Network oracle contract\n        IPyth pyth;\n        /// @notice Maximum price age for staleness check (default 60 seconds)\n        uint96 maxPriceAge;\n        /// @notice Maximum confidence interval threshold in basis points (default 50 bps = 0.5%)\n        uint256 maxConfidenceBps;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.pythPriceOracle.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PYTH_PRICE_ORACLE_STORAGE_LOCATION =\n        0x79f8fe64cf697304b8736b5ceebe50109f667154b58cb0fe6be0d930c76b5e00;\n\n    function _getPythPriceOracleStorage() private pure returns (PythPriceOracleStorage storage $) {\n        assembly {\n            $.slot := PYTH_PRICE_ORACLE_STORAGE_LOCATION\n        }\n    }\n\n    /// Events\n    event PriceIdSet(address indexed asset, bytes32 priceId, uint8 decimals);\n    event UnderlyingAssetSet(address indexed asset);\n    event MaxPriceAgeUpdated(uint96 newMaxAge);\n    event PythContractUpdated(address indexed newPyth);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n    event MaxConfidenceBpsUpdated(uint256 newMaxConfidenceBps);\n\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        require(msg.sender == $.timeLockController, \"PythOracle: only timelock\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the oracle\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param _deployer Deployer address (receives DEFAULT_ADMIN_ROLE)\n     * @param _priceManager Initial price manager for setting price IDs\n     * @param _pyth Pyth Network contract address\n     * @param _underlyingAsset Vault's underlying asset for redemptions\n     * @param _timeLockController Timelock controller for critical operations\n     * @param _maxConfidenceBps Maximum confidence interval threshold in basis points (default 50 bps = 0.5%)\n     */\n    function initialize(\n        address _deployer,\n        address _priceManager,\n        address _pyth,\n        address _underlyingAsset,\n        address _timeLockController,\n        uint256 _maxConfidenceBps\n    ) external initializer {\n        require(_deployer != address(0), \"PythOracle: zero deployer\");\n        require(_priceManager != address(0), \"PythOracle: zero manager\");\n        require(_pyth != address(0), \"PythOracle: zero pyth\");\n        require(_underlyingAsset != address(0), \"PythOracle: zero underlying\");\n        require(_timeLockController != address(0), \"PythOracle: zero timelock\");\n        require(_maxConfidenceBps > 0, \"PythOracle: zero confidence threshold\");\n        require(_maxConfidenceBps <= BASIS_POINTS, \"PythOracle: confidence threshold too high\");\n\n        __AccessControl_init();\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(PRICE_MANAGER_ROLE, _priceManager);\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.pyth = IPyth(_pyth);\n        $.underlyingAsset = _underlyingAsset;\n        $.maxPriceAge = 3600; // 1 hour default\n        $.timeLockController = _timeLockController;\n        $.maxConfidenceBps = _maxConfidenceBps;\n\n        emit UnderlyingAssetSet(_underlyingAsset);\n    }\n\n    /**\n     * @notice Set Pyth price ID for an asset\n     * @param asset Asset address\n     * @param priceId Pyth price feed ID (32 bytes)\n     * @param decimals Asset token decimals\n     */\n    function setPriceId(address asset, bytes32 priceId, uint8 decimals) external onlyTimelock {\n        require(asset != address(0), \"PythOracle: zero asset\");\n        require(priceId != bytes32(0), \"PythOracle: zero price ID\");\n        require(decimals <= 18, \"PythOracle: invalid decimals\");\n        require(decimals == IERC20Metadata(asset).decimals(), \"PythOracle: decimals mismatch\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.priceIds[asset] = priceId;\n        $.assetDecimals[asset] = decimals;\n\n        emit PriceIdSet(asset, priceId, decimals);\n    }\n\n    /**\n     * @notice Batch set price IDs for multiple assets\n     * @param assets Array of asset addresses\n     * @param _priceIds Array of Pyth price feed IDs\n     * @param decimalsArray Array of token decimals\n     */\n    function setPriceIds(address[] calldata assets, bytes32[] calldata _priceIds, uint8[] calldata decimalsArray)\n        external\n        onlyTimelock\n    {\n        require(assets.length == _priceIds.length, \"PythOracle: length mismatch\");\n        require(assets.length == decimalsArray.length, \"PythOracle: decimals mismatch\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(assets[i] != address(0), \"PythOracle: zero asset\");\n            require(_priceIds[i] != bytes32(0), \"PythOracle: zero price ID\");\n            require(decimalsArray[i] <= 18, \"PythOracle: invalid decimals\");\n            require(decimalsArray[i] == IERC20Metadata(assets[i]).decimals(), \"PythOracle: decimals mismatch\");\n\n            $.priceIds[assets[i]] = _priceIds[i];\n            $.assetDecimals[assets[i]] = decimalsArray[i];\n\n            emit PriceIdSet(assets[i], _priceIds[i], decimalsArray[i]);\n        }\n    }\n\n    /**\n     * @notice Get price of asset in terms of underlying asset\n     * @param asset Asset to price\n     * @return Price scaled to 18 decimals\n     */\n    function getPrice(address asset) external view override returns (uint256) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        if (asset == $.underlyingAsset) {\n            return 1e18; // 1:1 for underlying asset\n        }\n\n        PythStructs.Price memory assetPrice = _getPythPrice(asset);\n        PythStructs.Price memory underlyingPrice = _getPythPrice($.underlyingAsset);\n\n        // Convert Pyth prices (with expo) to 18 decimal format\n        uint256 assetPriceUSD = _convertPythPrice(assetPrice);\n        uint256 underlyingPriceUSD = _convertPythPrice(underlyingPrice);\n\n        // Price = (asset price in USD / underlying price in USD) * 1e18\n        return (assetPriceUSD * 1e18) / underlyingPriceUSD;\n    }\n\n    /**\n     * @notice Get USD price of an asset\n     * @param asset Asset address\n     * @return Price in USD with 8 decimals (Pyth standard)\n     */\n    function getPriceInUSD(address asset) external view override returns (uint256) {\n        PythStructs.Price memory price = _getPythPrice(asset);\n        return _convertPythPrice(price);\n    }\n\n    /**\n     * @notice Convert amount between assets using Pyth prices\n     * @param fromAsset Source asset\n     * @param toAsset Target asset\n     * @param amount Amount in source asset\n     * @return Converted amount in target asset's native decimals (eg: USDC 6 decimals, WETH 18 decimals)\n     */\n    function convertAmount(address fromAsset, address toAsset, uint256 amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n\n        if (fromAsset == toAsset) {\n            // Same asset conversion - always return the same amount\n            return amount;\n        }\n\n        PythStructs.Price memory fromPrice = _getPythPrice(fromAsset);\n        PythStructs.Price memory toPrice = _getPythPrice(toAsset);\n\n        uint8 fromDecimals = $.assetDecimals[fromAsset];\n        uint8 toDecimals = $.assetDecimals[toAsset];\n\n        require(amount > 0, \"PythOracle: zero amount\");\n\n        // Convert prices to 18 decimals for high precision calculation\n        uint256 fromPrice18 = _convertPythPriceTo18Decimals(fromPrice);\n        uint256 toPrice18 = _convertPythPriceTo18Decimals(toPrice);\n\n        // Normalize amount to 18 decimals\n        uint256 amount18 = _normalizeDecimals(amount, fromDecimals, 18);\n\n        // Calculate: (amount18 * fromPrice18) / toPrice18\n        uint256 result18 = (amount18 * fromPrice18) / toPrice18;\n\n        // Always return in the target asset's native decimals\n        return _normalizeDecimals(result18, 18, toDecimals);\n    }\n\n    /**\n     * @notice Get Pyth price with staleness check\n     * @param asset Asset address\n     * @return Pyth price struct\n     */\n    function _getPythPrice(address asset) internal view returns (PythStructs.Price memory) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        bytes32 priceId = $.priceIds[asset];\n        require(priceId != bytes32(0), \"PythOracle: price ID not set\");\n\n        // Check staleness\n        PythStructs.Price memory price = $.pyth.getPriceNoOlderThan(priceId, $.maxPriceAge);\n        // Check that price is positive (price.price is int64)\n        require(price.price > 0, \"PythOracle: invalid price\");\n\n        // Check confidence interval\n        _validateConfidence(price, $.maxConfidenceBps);\n\n\n        return price;\n    }\n\n     /**\n     * @notice Validate price confidence interval against threshold\n     * @param price Pyth price struct\n     * @param maxConfThreshold Maximum allowed confidence interval in basis points\n     * @dev Reverts if conf/price ratio exceeds the threshold\n     */\n    function _validateConfidence(PythStructs.Price memory price, uint256 maxConfThreshold) internal pure {\n        // Calculate confidence ratio: (conf / price) * BASIS_POINTS\n        // Both conf and price have the same exponent, so we can compare them directly\n        uint256 confidenceRatioBps = (uint256(price.conf) * BASIS_POINTS) / uint256(uint64(price.price));\n\n        require(\n            confidenceRatioBps <= maxConfThreshold,\n            \"PythOracle: confidence interval too wide\"\n        );\n    }\n\n    /**\n     * @notice Convert Pyth price to standard 8-decimal format\n     * @param price Pyth price struct\n     * @return Price in 8 decimals\n     */\n    function _convertPythPrice(PythStructs.Price memory price) internal pure returns (uint256) {\n        require(price.price > 0, \"PythOracle: invalid price\");\n\n        // Convert to 8 decimal places\n        // If expo = -6 and we want -8, we need to multiply by 10^2\n        // If expo = -10 and we want -8, we need to divide by 10^2\n\n        int256 normalizedPrice;\n        int32 targetExpo = -8;\n\n        if (price.expo == targetExpo) {\n            normalizedPrice = price.price;\n        } else if (price.expo > targetExpo) {\n            // expo is less negative (fewer decimals), need to add decimals\n            // expo=-6, target=-8: multiply by 10^2\n            uint256 scaleFactor = 10 ** uint256(int256(price.expo - targetExpo));\n            normalizedPrice = price.price * int256(scaleFactor);\n        } else {\n            // expo is more negative (more decimals), need to remove decimals\n            // expo=-10, target=-8: divide by 10^2\n            uint256 scaleFactor = 10 ** uint256(int256(targetExpo - price.expo));\n            normalizedPrice = price.price / int256(scaleFactor);\n        }\n\n        require(normalizedPrice > 0, \"PythOracle: price conversion failed\");\n        return uint256(normalizedPrice);\n    }\n\n    /**\n     * @notice Convert Pyth price to 18-decimal format for high precision calculations\n     * @param price Pyth price struct\n     * @return Price in 18 decimals\n     */\n    function _convertPythPriceTo18Decimals(PythStructs.Price memory price) internal pure returns (uint256) {\n        require(price.price > 0, \"PythOracle: invalid price\");\n\n        // First convert to 8 decimals using existing logic\n        uint256 price8Decimals = _convertPythPrice(price);\n\n        // Then convert from 8 decimals to 18 decimals\n        return price8Decimals * 1e10; // 18 - 8 = 10\n    }\n\n    /**\n     * @notice Get maximum of two values\n     * @param a First value\n     * @param b Second value\n     * @return Maximum value\n     */\n    function max(uint8 a, uint8 b) internal pure returns (uint8) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @notice Normalize decimals for calculations\n     * @param amount Amount to normalize\n     * @param fromDecimals Current decimals\n     * @param toDecimals Target decimals\n     * @return Normalized amount\n     */\n    function _normalizeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n\n        if (fromDecimals > toDecimals) {\n            return amount / (10 ** (fromDecimals - toDecimals));\n        } else {\n            return amount * (10 ** (toDecimals - fromDecimals));\n        }\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Update Pyth contract address\n     * @param _pyth New Pyth contract address\n     */\n    function setPythContract(address _pyth) external onlyTimelock {\n        require(_pyth != address(0), \"PythOracle: zero address\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.pyth = IPyth(_pyth);\n        emit PythContractUpdated(_pyth);\n    }\n\n    /**\n     * @notice Update underlying asset\n     * @param _underlyingAsset New underlying asset address\n     */\n    function setUnderlyingAsset(address _underlyingAsset) external onlyTimelock {\n        require(_underlyingAsset != address(0), \"PythOracle: zero address\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.underlyingAsset = _underlyingAsset;\n        emit UnderlyingAssetSet(_underlyingAsset);\n    }\n\n    /**\n     * @notice Update maximum price age\n     * @param _maxPriceAge New maximum age in seconds\n     */\n    function setMaxPriceAge(uint96 _maxPriceAge) external onlyTimelock {\n        require(_maxPriceAge > 0, \"PythOracle: zero max age\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.maxPriceAge = _maxPriceAge;\n        emit MaxPriceAgeUpdated(_maxPriceAge);\n    }\n\n    /**\n     * @notice Set the timelock controller\n     * @param _timeLockController New timelock controller address\n     * @dev Can only be called by the current timelock (with delay enforced by VaultTimelockController)\n     */\n    function setTimelockController(address _timeLockController) external onlyTimelock {\n        require(_timeLockController != address(0), \"PythOracle: zero timelock\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        address oldTimelock = $.timeLockController;\n        $.timeLockController = _timeLockController;\n\n        emit TimelockControllerSet(oldTimelock, _timeLockController);\n    }\n\n     /**\n     * @notice Update maximum confidence interval threshold\n     * @param _maxConfidenceBps New maximum confidence interval in basis points\n     */\n    function setMaxConfidenceBps(uint256 _maxConfidenceBps) external onlyTimelock {\n        require(_maxConfidenceBps > 0, \"PythOracle: zero confidence threshold\");\n        require(_maxConfidenceBps <= BASIS_POINTS, \"PythOracle: confidence threshold too high\");\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.maxConfidenceBps = _maxConfidenceBps;\n        emit MaxConfidenceBpsUpdated(_maxConfidenceBps);\n    }\n\n\n    /**\n     * @notice Check if asset has price feed configured\n     * @param asset Asset address\n     * @return True if price ID is set\n     */\n    function hasPriceFeed(address asset) external view returns (bool) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        return $.priceIds[asset] != bytes32(0);\n    }\n\n    /**\n     * @notice Get the latest price update fee for Pyth\n     * @param updateData Array of price update data\n     * @return fee Update fee in wei\n     */\n    function getUpdateFee(bytes[] calldata updateData) external view returns (uint256) {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        return $.pyth.getUpdateFee(updateData);\n    }\n\n    // ========== GETTER FUNCTIONS ==========\n\n    /// @notice Get timelock controller address\n    function timeLockController() external view returns (address) {\n        return _getPythPriceOracleStorage().timeLockController;\n    }\n\n    /// @notice Get Pyth contract address\n    function pyth() external view returns (IPyth) {\n        return _getPythPriceOracleStorage().pyth;\n    }\n\n    /// @notice Get price ID for an asset\n    function priceIds(address asset) external view returns (bytes32) {\n        return _getPythPriceOracleStorage().priceIds[asset];\n    }\n\n    /// @notice Get asset decimals\n    function assetDecimals(address asset) external view returns (uint8) {\n        return _getPythPriceOracleStorage().assetDecimals[asset];\n    }\n\n    /// @notice Get underlying asset address\n    function underlyingAsset() external view returns (address) {\n        return _getPythPriceOracleStorage().underlyingAsset;\n    }\n\n    /// @notice Get maximum price age\n    function maxPriceAge() external view returns (uint96) {\n        return _getPythPriceOracleStorage().maxPriceAge;\n    }\n\n    /// @notice Get maximum confidence interval threshold\n    function maxConfidenceBps() external view returns (uint256) {\n        return _getPythPriceOracleStorage().maxConfidenceBps;\n    }\n}\n",
        "OVaultComposerMulti.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\npragma solidity 0.8.28;\n\nimport {VaultComposerBase} from \"../VaultComposerBase.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol\";\nimport {AccessControlUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IOFT, SendParam, MessagingFee, OFTReceipt} from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport {IDepositPipe} from \"../interfaces/IDepositPipe.sol\";\nimport {IRedemptionPipe} from \"../interfaces/IRedemptionPipe.sol\";\n\n/**\n * @title OVaultComposerMulti\n * @notice Cross-chain composer for multi-asset vault system\n * @dev Routes deposits to appropriate pipes based on asset type\n */\ncontract OVaultComposerMulti is\n    VaultComposerBase,\n    AccessControlUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using OFTComposeMsgCodec for bytes;\n    using OFTComposeMsgCodec for bytes32;\n\n    // Compose message types\n    uint8 constant ACTION_DEPOSIT_ASSET = 1;\n    uint8 constant ACTION_REDEEM_SHARES = 2;\n\n    // Roles\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n    bytes32 public constant RECOVER_ASSETS_MANAGER_ROLE = keccak256(\"RECOVER_ASSETS_MANAGER_ROLE\");\n\n    /// @custom:storage-location erc7201:liminal.storage.OVaultComposerMulti\n    struct OVaultComposerMultiStorage {\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        // Asset management\n        mapping(address => address) depositPipes;\n        mapping(address => address) assetOFTs; // Asset to OFT mapping\n        // array to handle assets from depositPipes\n        address[] supportedAssets;\n        // For efficient removal. A mapping to store index of each asset in the array\n        mapping(address => uint256) assetIndex;\n        address redemptionPipe;\n        address underlyingAsset;\n        address underlyingAssetOFT;\n        mapping(address => bool) approvedOFTs;\n        mapping(address => mapping(uint32 => bytes32)) remotePeers;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.OVaultComposerMulti.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OVaultComposerMultiStorageLocation =\n        0xcad0c23afae839586aab4f80ae20039159400eb78664ff0bdd704907083fac00;\n\n    function _getOVaultComposerMultiStorage()\n        private\n        pure\n        returns (OVaultComposerMultiStorage storage $)\n    {\n        assembly {\n            $.slot := OVaultComposerMultiStorageLocation\n        }\n    }\n\n    // Events\n    event DepositPipeRegistered(address indexed asset, address indexed pipe, address indexed oft);\n    event DepositPipeRemoved(address indexed asset);\n    event RedemptionPipeUpdated(address indexed oldPipe, address indexed newPipe);\n    event UnderlyingAssetUpdated(address indexed oldAsset, address indexed newAsset);\n    event OFTApprovalSet(address indexed oft, bool approved);\n    event RemotePeerSet(address indexed oft, uint32 indexed srcEid, bytes32 remotePeer);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        require(msg.sender == $.timeLockController, \"OVaultComposerMulti: only timelock\");\n        _;\n    }\n\n    // Errors\n    error NoPipeForAsset(address asset);\n    error InvalidPipe();\n    error NoOFTForAsset(address asset);\n    error OnlySelf(address caller);\n    error InvalidAction(uint8 action);\n    error InvalidOFT(address oft);\n    error SlippageExceedsDustRemoval(uint256 amountAfterDust, uint256 slippageAmount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Constructor\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param _shareOFT Share OFT adapter address\n     * @param _redemptionPipe Redemption pipe address\n     * @param _underlyingAsset Underlying redemption asset\n     * @param _underlyingAssetOFT Underlying asset OFT\n     * @param _deployer Deployer address (receives DEFAULT_ADMIN_ROLE)\n     * @param _timeLockController Timelock controller for critical operations (deployer initially, then set to real timelock)\n     */\n    function initialize(\n        address _shareOFT,\n        address _redemptionPipe,\n        address _underlyingAsset,\n        address _underlyingAssetOFT,\n        address _deployer,\n        address _emergencyManager,\n        address _timeLockController,\n        address _recoverAssetsManager\n    ) external initializer {\n        require(_redemptionPipe != address(0), \"OVaultComposerMulti: zero redemption pipe\");\n        require(_underlyingAsset != address(0), \"OVaultComposerMulti: zero underlying\");\n        require(_underlyingAssetOFT != address(0), \"OVaultComposerMulti: zero underlying OFT\");\n        require(_deployer != address(0), \"OVaultComposerMulti: zero deployer\");\n        require(_emergencyManager != address(0), \"OVaultComposerMulti: zero emergency manager\");\n        require(_recoverAssetsManager != address(0), \"OVaultComposerMulti: zero recover assets manager\");\n\n        __VaultComposerBase_init(_shareOFT);\n        __AccessControl_init();\n        __Pausable_init();\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(EMERGENCY_MANAGER_ROLE, _emergencyManager);\n        _grantRole(RECOVER_ASSETS_MANAGER_ROLE, _recoverAssetsManager);\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        $.redemptionPipe = _redemptionPipe;\n        $.underlyingAsset = _underlyingAsset;\n        $.underlyingAssetOFT = _underlyingAssetOFT;\n        $.timeLockController = _timeLockController;\n\n        // Approve SHARE_OFT for compose messages\n        $.approvedOFTs[_shareOFT] = true;\n\n        // Approve underlying asset OFT for compose messages\n        $.approvedOFTs[_underlyingAssetOFT] = true;\n    }\n\n    /**\n     * @notice Redeem and send assets cross-chain\n     * @param _shareAmount Amount of shares to redeem\n     * @param _sendParam Cross-chain send parameters\n     * @param _refundAddress Address for fee refunds\n     */\n    function redeemAndSend(\n        uint256 _shareAmount,\n        SendParam memory _sendParam,\n        address _refundAddress\n    ) external payable whenNotPaused nonReentrant {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        uint256 assets = IRedemptionPipe($.redemptionPipe).redeem(_shareAmount, address(this), msg.sender);\n\n        _assertSlippage(assets, _sendParam.minAmountLD);\n        _sendParam.amountLD = assets;\n\n        // Calculate minimum after dust removal to protect against decimal conversion losses\n        _sendParam.minAmountLD = _calculateMinAmountAfterDust(\n            $.underlyingAssetOFT,\n            assets,\n            _sendParam.minAmountLD\n        );\n\n        // Quote OFT to get exact amount after dedusting\n        (,, OFTReceipt memory receipt) = IOFT($.underlyingAssetOFT).quoteOFT(_sendParam);\n        uint256 amountToSend = receipt.amountSentLD;\n\n        // Approve only the exact amount that will be sent\n        IERC20($.underlyingAsset).forceApprove($.underlyingAssetOFT, amountToSend);\n\n        // Update sendParam with the exact amount\n        _sendParam.amountLD = amountToSend;\n\n        _send($.underlyingAssetOFT, _sendParam, _refundAddress);\n\n        // Refund dust to user\n        uint256 dust = assets - amountToSend;\n        if (dust > 0) {\n            IERC20($.underlyingAsset).safeTransfer(msg.sender, dust);\n            emit DustRefunded($.underlyingAsset, msg.sender, dust);\n        }\n    }\n\n    /**\n     * @notice Deposit specific asset and send shares cross-chain\n     * @param asset Asset address to deposit\n     * @param _assetAmount Amount to deposit\n     * @param _sendParam Cross-chain send parameters\n     * @param _refundAddress Address for fee refunds\n     */\n    function depositAssetAndSend(\n        address asset,\n        uint256 _assetAmount,\n        SendParam memory _sendParam,\n        address _refundAddress\n    ) external payable whenNotPaused nonReentrant {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        address pipe = $.depositPipes[asset];\n        if (pipe == address(0)) revert NoPipeForAsset(asset);\n\n        uint256 shares = IDepositPipe(pipe).deposit(_assetAmount, address(this), msg.sender);\n\n        _assertSlippage(shares, _sendParam.minAmountLD);\n        _sendParam.amountLD = shares;\n\n        // Quote OFT to get exact amount after dedusting\n        (,, OFTReceipt memory receipt) = IOFT(SHARE_OFT).quoteOFT(_sendParam);\n        uint256 amountToSend = receipt.amountSentLD;\n\n        // Approve only the exact amount that will be sent\n        IERC20(SHARE_ERC20).forceApprove(SHARE_OFT, amountToSend);\n\n        // Update sendParam with the exact amount\n        _sendParam.amountLD = amountToSend;\n\n        _send(SHARE_OFT, _sendParam, _refundAddress);\n        \n        // Determine share recipient: if cross-chain, use sendParam.to, otherwise shares stay with depositor\n        address shareRecipient = _sendParam.dstEid != 0 \n            ? _sendParam.to.bytes32ToAddress() \n            : msg.sender;\n        \n        // For direct calls (not via LayerZero), srcEid is the current chain (VAULT_EID)\n        emit CrossChainDeposit(asset, msg.sender, shareRecipient, VAULT_EID, _sendParam.dstEid, _assetAmount, shares);\n\n        // Refund dust to user\n        uint256 dust = shares - amountToSend;\n        if (dust > 0) {\n            IERC20(SHARE_ERC20).safeTransfer(msg.sender, dust);\n            emit DustRefunded(SHARE_ERC20, msg.sender, dust);\n        }\n    }\n\n    /**\n     * @notice Register a deposit pipe for an asset\n     * @param asset Asset address\n     * @param pipe Deposit pipe address\n     * @param assetOFT Asset's OFT address\n     */\n    function registerDepositPipe(address asset, address pipe, address assetOFT)\n        external\n        onlyTimelock\n    {\n        require(asset != address(0), \"OVaultComposerMulti: zero asset\");\n        require(pipe != address(0), \"OVaultComposerMulti: zero pipe\");\n        require(assetOFT != address(0), \"OVaultComposerMulti: zero OFT\");\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        require($.depositPipes[asset] != pipe, \"OVaultComposerMulti: same pipe\");\n\n        // Verify pipe accepts this asset\n        address pipeAsset = IDepositPipe(pipe).asset();\n        if (pipeAsset != asset) revert InvalidPipe();\n\n        _addAsset(asset, pipe); // updates mapping and array\n        $.assetOFTs[asset] = assetOFT;\n\n        // Approve the asset OFT for compose messages\n        $.approvedOFTs[assetOFT] = true;\n\n        emit DepositPipeRegistered(asset, pipe, assetOFT);\n    }\n\n    /**\n     * @notice Remove a deposit pipe\n     */\n    function removeDepositPipe(address asset) external onlyTimelock {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        address pipe = $.depositPipes[asset];\n        if (pipe != address(0)) {\n            IERC20(asset).forceApprove(pipe, 0);\n            address assetOFT = $.assetOFTs[asset];\n\n            // Remove OFT approval\n            if (assetOFT != address(0)) {\n                $.approvedOFTs[assetOFT] = false;\n            }\n\n            _removeAsset(asset); // updates mapping and array\n            delete $.assetOFTs[asset];\n            emit DepositPipeRemoved(asset);\n        }\n    }\n\n    /**\n     * @notice Update redemption pipe\n     * @param _redemptionPipe New redemption pipe address\n     */\n    function setRedemptionPipe(address _redemptionPipe) external onlyTimelock {\n        require(_redemptionPipe != address(0), \"OVaultComposerMulti: zero pipe\");\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        address oldPipe = $.redemptionPipe;\n        $.redemptionPipe = _redemptionPipe;\n        emit RedemptionPipeUpdated(oldPipe, _redemptionPipe);\n    }\n\n    /**\n     * @notice Update underlying asset (kept as SAFE_MANAGER for operational flexibility)\n     * @param _underlyingAsset New underlying asset address\n     */\n    function setUnderlyingAsset(address _underlyingAsset) external onlyTimelock {\n        require(_underlyingAsset != address(0), \"OVaultComposerMulti: zero asset\");\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        address oldAsset = $.underlyingAsset;\n        $.underlyingAsset = _underlyingAsset;\n        emit UnderlyingAssetUpdated(oldAsset, _underlyingAsset);\n    }\n\n    /**\n     * @notice Handle compose operations for multi-asset vault\n     */\n    function handleCompose(\n        address _oftIn,\n        bytes32 _composeFrom,\n        bytes32 /* _guid */,\n        bytes memory _composeMsg,\n        uint256 _amount,\n        uint32 _srcEid\n    ) public payable override whenNotPaused nonReentrant {\n        // Only self can call\n        if (msg.sender != address(this)) revert OnlySelf(msg.sender);\n\n        // Decode the compose message\n        (uint8 action, bytes memory params) = abi.decode(_composeMsg, (uint8, bytes));\n\n        // For redemption actions, ONLY the legitimate SHARE_OFT can trigger them\n        // This prevents the attack where an approved asset OFT tries to steal shares\n        // sitting in the composer by sending a redemption compose message\n        // Note: Deposit actions validate against assetOFTs[targetAsset] in _handleDepositAsset\n        if (action == ACTION_REDEEM_SHARES) {\n            if (_oftIn != SHARE_OFT) revert InvalidOFT(_oftIn);\n        }\n\n        if (action == ACTION_DEPOSIT_ASSET) {\n            _handleDepositAsset(_oftIn, _composeFrom, params, _amount, _srcEid);\n        } else if (action == ACTION_REDEEM_SHARES) {\n            _handleRedeemShares(_composeFrom, params, _amount, _srcEid);\n        } else {\n            revert InvalidAction(action);\n        }\n    }\n\n    /**\n     * @notice Handle cross-chain asset deposit\n     */\n    function _handleDepositAsset(\n        address _oftIn,\n        bytes32 _composeFrom,\n        bytes memory _params,\n        uint256 _amount,\n        uint32 _srcEid\n    ) internal {\n        (address targetAsset, bytes32 receiver, SendParam memory sendParam, uint256 minMsgValue, bytes32 feeRefundRecipient, ) =\n            abi.decode(_params, (address, bytes32, SendParam, uint256, bytes32, uint32));\n\n        // Defense in depth: These validations are also performed by OVaultMsgInspector on the source chain\n        // before sending. However, we keep them here as a safety net in case:\n        // 1. MsgInspector is disabled/removed on the source OFT\n        // 2. Messages arrive from unexpected sources\n        // 3. Additional security layer following principle of \"never trust external input\"\n        require(receiver != bytes32(0), \"OVaultComposerMulti: zero receiver\");\n        if (sendParam.dstEid != 0) {\n            require(sendParam.to != bytes32(0), \"OVaultComposerMulti: zero destination\");\n        }\n\n        // Validate msg.value\n        if (msg.value < minMsgValue) revert InsufficientMsgValue();\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        // Get deposit pipe for asset\n        address pipe = $.depositPipes[targetAsset];\n        if (pipe == address(0)) revert NoPipeForAsset(targetAsset);\n\n        // Verify _oftIn matches the registered OFT for this asset\n        if (_oftIn != $.assetOFTs[targetAsset]) revert InvalidOFT(_oftIn);\n\n        // When OFT receives tokens and triggers compose, it mints tokens directly to this composer\n        // So tokens should already be in our balance\n        uint256 composerBalance = IERC20(targetAsset).balanceOf(address(this));\n        require(composerBalance >= _amount, \"Insufficient balance in composer\");\n\n        // Deposit through pipe\n        address depositor = _composeFrom.bytes32ToAddress();\n\n        // If cross-chain send is needed, mint shares to composer first\n        // Otherwise mint directly to receiver (convert bytes32 to address for EVM delivery)\n        address shareMintRecipient =\n            sendParam.dstEid != 0 ? address(this) : receiver.bytes32ToAddress();\n\n        // Approve exact amount for deposit\n        IERC20(targetAsset).forceApprove(pipe, _amount);\n\n        uint256 shares = IDepositPipe(pipe).deposit(\n            _amount,\n            shareMintRecipient, // Mint to composer if cross-chain send, else to receiver\n            address(this) // Tokens are in composer, not original depositor\n        );\n\n        // Determine share recipient: if cross-chain, use sendParam.to, otherwise use receiver\n        address shareRecipient = sendParam.dstEid != 0 \n            ? sendParam.to.bytes32ToAddress() \n            : receiver.bytes32ToAddress();\n\n        emit CrossChainDeposit(targetAsset, depositor, shareRecipient, _srcEid, sendParam.dstEid, _amount, shares);\n\n        _assertSlippage(shares, sendParam.minAmountLD);\n\n        // If sendParam is provided, send shares cross-chain\n        if (sendParam.dstEid != 0) {\n            sendParam.amountLD = shares;\n\n            // Quote OFT to get exact amount after dedusting\n            (,, OFTReceipt memory receipt) = IOFT(SHARE_OFT).quoteOFT(sendParam);\n            uint256 amountToSend = receipt.amountSentLD;\n\n            // Approve only the exact amount that will be sent\n            IERC20(SHARE_ERC20).forceApprove(SHARE_OFT, amountToSend);\n\n            // Update sendParam with the exact amount\n            sendParam.amountLD = amountToSend;\n            \n            // Use feeRefundRecipient if provided, otherwise fallback to depositor\n            address refundRecipient = feeRefundRecipient != bytes32(0)\n                ? feeRefundRecipient.bytes32ToAddress()\n                : depositor;\n\n            _send(SHARE_OFT, sendParam, refundRecipient);\n\n            // Refund dust to depositor\n            uint256 dust = shares - amountToSend;\n            if (dust > 0) {\n                IERC20(SHARE_ERC20).safeTransfer(depositor, dust);\n                emit DustRefunded(SHARE_ERC20, depositor, dust);\n            }\n        }\n        // If no cross-chain send, shares are already at receiver address\n    }\n\n    /**\n     * @notice Handle share redemption\n     */\n    function _handleRedeemShares(bytes32 _composeFrom, bytes memory _params, uint256 _shareAmount, uint32 _srcEid)\n        internal\n    {\n        (address receiver, SendParam memory sendParam, uint256 minMsgValue, uint256 minAssets, bytes32 feeRefundRecipient, ) =\n            abi.decode(_params, (address, SendParam, uint256, uint256, bytes32, uint32));\n\n        // Defense in depth: These validations are also performed by OVaultMsgInspector on the source chain\n        // before sending. We keep them here as a safety net (see _handleDepositAsset for rationale)\n        require(receiver != address(0), \"OVaultComposerMulti: zero receiver\");\n        if (sendParam.dstEid != 0) {\n            require(sendParam.to != bytes32(0), \"OVaultComposerMulti: zero destination\");\n        }\n\n        // Validate msg.value\n        if (msg.value < minMsgValue) revert InsufficientMsgValue();\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        // Approve exact amount for redemption\n        IERC20(SHARE_ERC20).forceApprove($.redemptionPipe, _shareAmount);\n\n        // Redeem shares for underlying asset\n        address redeemer = _composeFrom.bytes32ToAddress();\n\n        // If cross-chain send is needed, redeem to composer first, otherwise to receiver\n        address assetReceiver = sendParam.dstEid != 0 ? address(this) : receiver;\n\n        // Composer owns the shares (received via LayerZero), so composer is the controller\n        uint256 assets = IRedemptionPipe($.redemptionPipe).redeem(_shareAmount, assetReceiver, address(this));\n\n        // Check slippage\n        _assertSlippage(assets, minAssets);\n\n        // Determine asset recipient: if cross-chain, use sendParam.to, otherwise use receiver\n        address assetRecipient = sendParam.dstEid != 0 \n            ? sendParam.to.bytes32ToAddress() \n            : receiver;\n\n        emit CrossChainRedemption(redeemer, assetRecipient, _srcEid, sendParam.dstEid, _shareAmount, assets);\n\n        // If sendParam provided, send assets cross-chain\n        if (sendParam.dstEid != 0) {\n            sendParam.amountLD = assets;\n\n            // Calculate minimum after dust removal to protect against decimal conversion losses\n            sendParam.minAmountLD = _calculateMinAmountAfterDust(\n                $.underlyingAssetOFT,\n                assets,\n                minAssets\n            );\n\n            // Quote OFT to get exact amount after dedusting\n            (,, OFTReceipt memory receipt) = IOFT($.underlyingAssetOFT).quoteOFT(sendParam);\n            uint256 amountToSend = receipt.amountSentLD;\n\n            // Approve only the exact amount that will be sent\n            IERC20($.underlyingAsset).forceApprove($.underlyingAssetOFT, amountToSend);\n\n            // Update sendParam with the exact amount\n            sendParam.amountLD = amountToSend;\n            \n            \n            // Use feeRefundRecipient if provided, otherwise fallback to redeemer\n            address refundRecipient = feeRefundRecipient != bytes32(0)\n                ? feeRefundRecipient.bytes32ToAddress()\n                : redeemer;\n\n            _send($.underlyingAssetOFT, sendParam, refundRecipient);\n\n            // Refund dust to redeemer\n            uint256 dust = assets - amountToSend;\n            if (dust > 0) {\n                IERC20($.underlyingAsset).safeTransfer(redeemer, dust);\n                emit DustRefunded($.underlyingAsset, redeemer, dust);\n            }\n        }\n    }\n\n    /**\n     * @notice Check if asset is supported\n     */\n    function isAssetSupported(address asset) external view returns (bool) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.depositPipes[asset] != address(0);\n    }\n\n    /**\n     * @notice Returns the list of all supported asset addresses.\n     * @dev uses \"parallel\" array to track assets in depositPipes mapping\n     */\n    function getSupportedAssets() external view returns (address[] memory) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.supportedAssets;\n    }\n\n    /**\n     * @notice Recover tokens from the contract (timelock-protected)\n     * @param token Token address to recover\n     * @param to Recipient address\n     * @param amount Amount to recover\n     */\n    function recoverToken(address token, address to, uint256 amount)\n        external\n        onlyRole(RECOVER_ASSETS_MANAGER_ROLE)\n    {\n        require(token != address(0), \"OVaultComposerMulti: zero token\");\n        require(to != address(0), \"OVaultComposerMulti: zero recipient\");\n        require(amount > 0, \"OVaultComposerMulti: zero amount\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Set the timelock controller\n     * @param _timeLockController New timelock controller address\n     * @dev Can only be called by the current timelock (with delay enforced by VaultTimelockController)\n     */\n    function setTimelockController(address _timeLockController) external onlyTimelock {\n        require(_timeLockController != address(0), \"OVaultComposerMulti: zero timelock\");\n\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        address oldTimelock = $.timeLockController;\n        $.timeLockController = _timeLockController;\n\n        emit TimelockControllerSet(oldTimelock, _timeLockController);\n    }\n\n    // Public getter functions for storage variables\n    function timeLockController() external view returns (address) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.timeLockController;\n    }\n\n    function depositPipes(address asset) external view returns (address) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.depositPipes[asset];\n    }\n\n    function assetOFTs(address asset) external view returns (address) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.assetOFTs[asset];\n    }\n\n    function redemptionPipe() external view returns (address) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.redemptionPipe;\n    }\n\n    function underlyingAsset() external view returns (address) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.underlyingAsset;\n    }\n\n    function underlyingAssetOFT() external view returns (address) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.underlyingAssetOFT;\n    }\n\n    function approvedOFTs(address oft) external view returns (bool) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.approvedOFTs[oft];\n    }\n\n    function remotePeers(address oft, uint32 srcEid) external view returns (bytes32) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.remotePeers[oft][srcEid];\n    }\n\n    /**\n     * @notice Pause the contract (emergency stop)\n     * @dev Can only be called by EMERGENCY_MANAGER_ROLE\n     */\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Can only be called by EMERGENCY_MANAGER_ROLE\n     */\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Set OFT approval status for compose messages\n     * @param oft OFT address\n     * @param approved Approval status\n     */\n    function setOFTApproval(address oft, bool approved) external onlyTimelock {\n        require(oft != address(0), \"OVaultComposerMulti: zero OFT\");\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        $.approvedOFTs[oft] = approved;\n        emit OFTApprovalSet(oft, approved);\n    }\n\n    /**\n     * @notice Set remote peer for an OFT on a specific source chain\n     * @param oft The OFT address\n     * @param srcEid The source endpoint ID\n     * @param remotePeer The expected peer address on the source chain\n     */\n    function setRemotePeer(address oft, uint32 srcEid, bytes32 remotePeer) external onlyTimelock {\n        require(oft != address(0), \"OVaultComposerMulti: zero OFT\");\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        $.remotePeers[oft][srcEid] = remotePeer;\n        emit RemotePeerSet(oft, srcEid, remotePeer);\n    }\n\n    /**\n     * @notice Set remote peer using address (converts to bytes32)\n     * @param oft The OFT address\n     * @param srcEid The source endpoint ID\n     * @param remotePeer The expected peer address on the source chain\n     */\n    function setRemotePeer(address oft, uint32 srcEid, address remotePeer) external onlyTimelock {\n        require(oft != address(0), \"OVaultComposerMulti: zero OFT\");\n        require(remotePeer != address(0), \"OVaultComposerMulti: zero peer\");\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        bytes32 peer = bytes32(uint256(uint160(remotePeer)));\n        $.remotePeers[oft][srcEid] = peer;\n        emit RemotePeerSet(oft, srcEid, peer);\n    }\n\n    /**\n     * @notice Calculate minimum amount after accounting for OFT dust removal\n     * @dev Ensures slippage protection accounts for decimal conversion rate dust removal\n     * @param _oft The OFT address to query for decimal conversion rate\n     * @param _actualAmount The actual amount being sent\n     * @param _userMinAmount The user's original minimum amount requirement\n     * @return minAmountLD The adjusted minimum amount after dust removal\n     */\n    function _calculateMinAmountAfterDust(\n        address _oft,\n        uint256 _actualAmount,\n        uint256 _userMinAmount\n    ) internal view returns (uint256 minAmountLD) {\n        // Get the decimal conversion rate from the OFT\n        // This is the rate used by LayerZero's _removeDust function\n        uint256 conversionRate = _getDecimalConversionRate(_oft);\n\n        // Simulate dust removal: (_actualAmount / conversionRate) * conversionRate\n        uint256 amountAfterDust = (_actualAmount / conversionRate) * conversionRate;\n\n        // Apply user's slippage tolerance to the dust-removed amount\n        // If user wanted at least X, and dust removal reduces the amount,\n        // we need to ensure the final amount meets the slippage requirement\n        if (_userMinAmount > 0) {\n            // Calculate what percentage of the actual amount the user minimum represents\n            // Then apply that percentage to the dust-removed amount\n            // This maintains the user's slippage tolerance relative to what they'll actually receive\n            uint256 slippageAmount = _actualAmount - _userMinAmount;\n\n            // If dust removal would exceed the user's slippage tolerance, revert\n            // This protects users from excessive losses due to decimal conversion\n            if (_actualAmount - amountAfterDust > slippageAmount) {\n                revert SlippageExceedsDustRemoval(amountAfterDust, slippageAmount);\n            }\n            if (amountAfterDust <= slippageAmount) {\n                minAmountLD = 0;\n                return minAmountLD;\n            }\n\n            // Calculate minimum as: amountAfterDust - (proportional slippage)\n            minAmountLD = amountAfterDust - slippageAmount;\n        } else {\n            // If user set minAmount to 0, maintain that (accept any amount)\n            minAmountLD = 0;\n        }\n        \n        return minAmountLD;\n    }\n\n    /**\n     * @notice Get the decimal conversion rate from an OFT contract\n     * @dev Computes the rate as 10 ** (localDecimals - sharedDecimals)\n     * @param _oft The OFT address to query\n     * @return conversionRate The decimal conversion rate\n     */\n    function _getDecimalConversionRate(address _oft) internal view returns (uint256 conversionRate) {\n        IOFT oft = IOFT(_oft);\n\n        // Get the underlying token address\n        address token = oft.token();\n\n        // Get local decimals from the token\n        uint8 localDecimals = IERC20Metadata(token).decimals();\n\n        // Get shared decimals from the OFT\n        uint8 sharedDecimals = oft.sharedDecimals();\n\n        // Calculate conversion rate: 10 ** (localDecimals - sharedDecimals)\n        conversionRate = 10 ** (localDecimals - sharedDecimals);\n    }\n\n    /**\n     * @dev Adds a new supported asset.\n     * @dev The calling function should ensure that pipe and asset exist, and depositPipes[asset] != pipe\n     */\n    function _addAsset(address asset, address pipe) internal {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        // Ensure the asset is not already added\n        if ($.depositPipes[asset] == address(0)) {\n            $.assetIndex[asset] = $.supportedAssets.length;\n            $.supportedAssets.push(asset);\n        }\n        $.depositPipes[asset] = pipe;\n    }\n\n    /**\n     * @dev Removes a supported asset efficiently using the \"swap-and-pop\" pattern.\n     * This avoids a costly loop to shift all elements in the array.\n     * @dev The calling function should ensure that depositPipes[asset] mapping exists\n     */\n    function _removeAsset(address asset) internal {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n\n        // Get the index of the asset to remove\n        uint256 indexToRemove = $.assetIndex[asset];\n\n        // Get the address of the last asset in the array\n        address lastAsset = $.supportedAssets[$.supportedAssets.length - 1];\n\n        // Move the last asset to the position of the one being removed\n        $.supportedAssets[indexToRemove] = lastAsset;\n\n        // Update the index mapping for the moved asset\n        $.assetIndex[lastAsset] = indexToRemove;\n\n        // Remove the last element from the array (which is now a duplicate)\n        $.supportedAssets.pop();\n\n        // Delete the original asset from the mappings\n        delete $.depositPipes[asset];\n        delete $.assetIndex[asset];\n    }\n\n    /**\n     * @notice Implementation of _isApprovedOFT from VaultComposerBase\n     * @param _oft The OFT address to check\n     * @return bool True if the OFT is approved\n     */\n    function _isApprovedOFT(address _oft) internal view override returns (bool) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.approvedOFTs[_oft];\n    }\n\n    /**\n     * @notice Implementation of _getRemotePeer from VaultComposerBase\n     * @param _oft The OFT address\n     * @param _srcEid The source endpoint ID\n     * @return bytes32 The expected peer address\n     */\n    function _getRemotePeer(address _oft, uint32 _srcEid) internal view override returns (bytes32) {\n        OVaultComposerMultiStorage storage $ = _getOVaultComposerMultiStorage();\n        return $.remotePeers[_oft][_srcEid];\n    }\n}",
        "RedemptionPipe.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {INAVOracle} from \"./interfaces/INAVOracle.sol\";\nimport {IShareManager} from \"./interfaces/IShareManager.sol\";\n\ninterface IFeeManager {\n    function accruePerformanceFee() external;\n}\n\n/**\n * @title RedemptionPipe\n * @notice Handles all redemptions (instant, fast, standard) for the vault\n * @dev Implements ERC7540-like interface with multiple redemption types\n * Does not strictly follow the ERC7540 spec as it has short-circuits and \n * pushes the async request's assets on users instead of allowing for claim/pull.\n */\ncontract RedemptionPipe is\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /// @notice Roles\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n    bytes32 public constant FULFILL_MANAGER_ROLE = keccak256(\"FULFILL_MANAGER_ROLE\");\n    bytes32 public constant SAFE_MANAGER_ROLE = keccak256(\"SAFE_MANAGER_ROLE\");\n\n    /// @notice Basis points constant (100% = 10000 basis points)\n    uint256 public constant BASIS_POINTS = 10_000;\n\n    /// @notice Request ID (ERC7540 compatibility)\n    uint256 internal constant REQUEST_ID = 0;\n\n    /// @custom:storage-location erc7201:liminal.redemptionPipe.v1\n    struct RedemptionPipeStorage {\n        /// @notice Share manager contract\n        IShareManager shareManager;\n        /// @notice NAV oracle contract\n        INAVOracle navOracle;\n        /// @notice Underlying asset for redemptions\n        IERC20Metadata underlyingAsset;\n        /// @notice Liquidity provider for fulfillments\n        address liquidityProvider;\n        /// @notice Fee configuration\n        FeeConfig fees;\n        uint256 lastNAVForPerformance;\n        /// @notice Recovery delay period (configurable) - uint24 safely fits 194 days in seconds\n        uint24 recoveryDelay;\n        /// @notice Last redemption timestamp for recovery check \n        uint72 lastRedemptionTime;\n        /// @notice Treasury address for recovered assets\n        address treasury;\n        /// @notice Standard redemption mappings\n        mapping(address => PendingRedeemRequest) pendingRedeem;\n        /// @notice Fast redemption mappings\n        mapping(address => PendingFastRedeemRequest) pendingFastRedeem;\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n        /// @notice Minimum shares to prevent rounding to zero assets (OZ recommendation: 1000 units)\n        /// Calculated as 1000 * 10^(18 - assetDecimals)\n        uint256 MIN_AMOUNT_SHARES;\n        /// @notice Fee manager for performance fee accrual\n        IFeeManager feeManager;\n        /// @notice Maximum custom fee in basis points for fast redeems\n        uint256 maxCustomFeeBps;\n        /// @notice Whether fast redemption is enabled\n        bool fastRedeemEnabled;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.redemptionPipe.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REDEMPTION_PIPE_STORAGE_LOCATION =\n        0x29501c6d0a5cf7bef3f2db502c4a21ddfa1dc6ae30f842b9bba4cfdd2f8c2a00;\n\n    function _getRedemptionPipeStorage() private pure returns (RedemptionPipeStorage storage $) {\n        assembly {\n            $.slot := REDEMPTION_PIPE_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Fee structure\n    struct FeeConfig {\n        uint256 instantRedeemFeeBps; // Basis points for instant redemption\n        uint256 fastRedeemFeeBps; // Basis points for fast redemption\n    }\n\n    /// @notice Standard redemption request\n    struct PendingRedeemRequest {\n        uint256 shares;\n        address receiver;\n    }\n\n    /// @notice Fast redemption request\n    struct PendingFastRedeemRequest {\n        uint256 shares;\n        uint256 timestamp;\n        address receiver;\n    }\n\n    /// Events\n    event InstantRedeem(address indexed user, address indexed receiver, uint256 shares, uint256 assets, uint256 fee);\n    event FastRedeemRequested(address indexed owner, address indexed receiver, uint256 shares, uint256 timestamp);\n    event FastRedeemFulfilled(address indexed owner, address indexed receiver, uint256 assets, uint256 shares, uint256 fee);\n    event RedeemRequested(address indexed owner, address indexed receiver, uint256 shares);\n    event RedeemFulfilled(address indexed owner, address indexed receiver, uint256 assets, uint256 shares);\n    event FeesUpdated(FeeConfig newFees);\n    event RecoveryDelayUpdated(uint256 newDelay);\n    event TreasuryUpdated(address indexed newTreasury);\n    event AssetsRecovered(address indexed token, uint256 amount, address indexed treasury);\n    event LiquidityProviderUpdated(address indexed oldProvider, address indexed newProvider);\n    event MaxCustomFeeBpsUpdated(uint256 newMaxCustomFeeBps);\n    event FastRedeemEnabledUpdated(bool enabled);\n    event TimeLockControllerUpdated(address indexed oldTimeLockController, address indexed newTimeLockController);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require(msg.sender == $.timeLockController, \"RedemptionPipe: only timelock\");\n        _;\n    }\n\n    /// @notice Modifier to accrue performance fees before operations\n    modifier accruePerformanceFee() {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.feeManager.accruePerformanceFee();\n        _;\n    }\n\n    /// @notice Modifier to check if fast redemption is enabled\n    modifier fastRedeemEnabledCheck() {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require($.fastRedeemEnabled, \"RedemptionPipe: fast redeem disabled\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Parameters for initialization\n    struct InitializeParams {\n        address shareManager;\n        address navOracle;\n        address underlyingAsset;\n        address liquidityProvider;\n        address deployer;\n        address safeManager;\n        address emergencyManager;\n        address requestManager;\n        address treasury;\n        uint256 recoveryDelay;\n        address timeLockController;\n        address feeManager;\n        uint256 maxCustomFeeBps;\n    }\n\n    /**\n     * @notice Initialize the redemption pipe\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param params Struct containing all initialization parameters\n     */\n    function initialize(InitializeParams calldata params) external initializer {\n        require(params.shareManager != address(0), \"RedemptionPipe: zero share manager\");\n        require(params.navOracle != address(0), \"RedemptionPipe: zero nav oracle\");\n        require(params.underlyingAsset != address(0), \"RedemptionPipe: zero underlying\");\n        require(params.deployer != address(0), \"RedemptionPipe: zero deployer\");\n        require(params.safeManager != address(0), \"RedemptionPipe: zero safe manager\");\n        require(params.liquidityProvider != address(0), \"RedemptionPipe: zero liquidity provider\");\n        require(params.emergencyManager != address(0), \"RedemptionPipe: zero emergency manager\");\n        require(params.timeLockController != address(0), \"RedemptionPipe: zero timelock\");\n        require(params.requestManager != address(0), \"RedemptionPipe: zero request manager\");\n        require(params.treasury != address(0), \"RedemptionPipe: zero treasury address\");\n        require(params.recoveryDelay > 0, \"RedemptionPipe: zero delay\");\n        require(params.feeManager != address(0), \"RedemptionPipe: zero fee manager\");\n        require(params.maxCustomFeeBps <= BASIS_POINTS, \"RedemptionPipe: max custom fee exceeds 100%\");\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.shareManager = IShareManager(params.shareManager);\n        $.navOracle = INAVOracle(params.navOracle);\n        $.underlyingAsset = IERC20Metadata(params.underlyingAsset);\n        $.liquidityProvider = params.liquidityProvider;\n        $.treasury = params.treasury;\n        $.recoveryDelay = uint24(params.recoveryDelay);\n        $.timeLockController = params.timeLockController;\n        $.feeManager = IFeeManager(params.feeManager);\n        $.maxCustomFeeBps = params.maxCustomFeeBps;\n        $.fastRedeemEnabled = false; // Default to disabled\n\n        // Calculate minimum shares based on underlying asset decimals\n        // MIN_AMOUNT = 1000 * 10^(18 - assetDecimals) to ensure at least 1000 units of assets\n        uint8 assetDecimals = IERC20Metadata(params.underlyingAsset).decimals();\n        require(assetDecimals <= 18, \"RedemptionPipe: unsupported decimals\");\n        $.MIN_AMOUNT_SHARES = 1000 * 10 ** (18 - assetDecimals);\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, params.deployer);\n        _grantRole(SAFE_MANAGER_ROLE, params.safeManager);\n        _grantRole(EMERGENCY_MANAGER_ROLE, params.emergencyManager);\n        _grantRole(FULFILL_MANAGER_ROLE, params.requestManager);\n\n        $.lastNAVForPerformance = $.navOracle.getNAV();\n    }\n\n    /**\n     * @notice Recover stuck assets after recovery delay\n     * @dev Can only be called when paused and after recovery delay since last redemption\n     * @param token Address of token to recover\n     * @param amount Amount to recover\n     */\n    function recoverAssets(address token, uint256 amount)\n        external\n        onlyRole(SAFE_MANAGER_ROLE)\n        whenPaused\n        nonReentrant\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require($.treasury != address(0), \"RedemptionPipe: treasury not set\");\n        require(block.timestamp > $.lastRedemptionTime + $.recoveryDelay, \"RedemptionPipe: recovery delay not met\");\n        require(token != address(0), \"RedemptionPipe: zero token address\");\n        require(amount > 0, \"RedemptionPipe: zero amount\");\n\n        // Check balance\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance >= amount, \"RedemptionPipe: insufficient balance\");\n\n        // Transfer to treasury\n        IERC20(token).safeTransfer($.treasury, amount);\n\n        emit AssetsRecovered(token, amount, $.treasury);\n    }\n\n    /**\n     * @notice Update recovery delay\n     * @param _recoveryDelay New recovery delay in seconds\n     */\n    function setRecoveryDelay(uint256 _recoveryDelay) external onlyTimelock {\n        require(_recoveryDelay >= 7 days, \"RedemptionPipe: delay too short\");\n        require(_recoveryDelay <= 90 days, \"RedemptionPipe: delay too long\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.recoveryDelay = uint24(_recoveryDelay);\n        emit RecoveryDelayUpdated(_recoveryDelay);\n    }\n\n    /**\n     * @notice Update treasury address\n     * @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) external onlyTimelock {\n        require(_treasury != address(0), \"RedemptionPipe: zero address\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// @notice Get current fee configuration (returns individual values for backward compatibility)\n    function fees() public view returns (uint256 _instantRedeemFeeBps, uint256 _fastRedeemFeeBps) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        return ($.fees.instantRedeemFeeBps, $.fees.fastRedeemFeeBps);\n    }\n\n    /// @notice Get individual fee components for backward compatibility\n    function instantRedeemFeeBps() public view returns (uint256) {\n        return _getRedemptionPipeStorage().fees.instantRedeemFeeBps;\n    }\n\n    function fastRedeemFeeBps() public view returns (uint256) {\n        return _getRedemptionPipeStorage().fees.fastRedeemFeeBps;\n    }\n\n    /// @notice Get recovery delay\n    function recoveryDelay() public view returns (uint256) {\n        return _getRedemptionPipeStorage().recoveryDelay;\n    }\n\n    /// @notice Get treasury address\n    function treasury() public view returns (address) {\n        return _getRedemptionPipeStorage().treasury;\n    }\n\n    /// @notice Get liquidity provider address\n    function liquidityProvider() public view returns (address) {\n        return _getRedemptionPipeStorage().liquidityProvider;\n    }\n\n    /// @notice Get minimum amount required for redemption\n    function MIN_AMOUNT_SHARES() public view returns (uint256) {\n        return _getRedemptionPipeStorage().MIN_AMOUNT_SHARES;\n    }\n\n    /// @notice Get maximum custom fee in basis points\n    function maxCustomFeeBps() public view returns (uint256) {\n        return _getRedemptionPipeStorage().maxCustomFeeBps;\n    }\n\n    /// @notice Get fast redemption enabled status\n    function fastRedeemEnabled() public view returns (bool) {\n        return _getRedemptionPipeStorage().fastRedeemEnabled;\n    }\n\n    /// @notice Get timelock controller address\n    function timeLockController() public view returns (address) {\n        return _getRedemptionPipeStorage().timeLockController;\n    }\n\n    /**\n     * @notice Update liquidity provider\n     * @param _liquidityProvider New liquidity provider address\n     */\n    function setLiquidityProvider(address _liquidityProvider) external onlyTimelock {\n        require(_liquidityProvider != address(0), \"RedemptionPipe: zero address\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        address oldProvider = $.liquidityProvider;\n        $.liquidityProvider = _liquidityProvider;\n        emit LiquidityProviderUpdated(oldProvider, _liquidityProvider);\n    }\n\n    /**\n     * @notice Update maximum custom fee for fast redeems\n     * @param _maxCustomFeeBps New maximum custom fee in basis points\n     */\n    function setMaxCustomFeeBps(uint256 _maxCustomFeeBps) external onlyTimelock {\n        require(_maxCustomFeeBps <= BASIS_POINTS, \"RedemptionPipe: max custom fee exceeds 100%\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.maxCustomFeeBps = _maxCustomFeeBps;\n        emit MaxCustomFeeBpsUpdated(_maxCustomFeeBps);\n    }\n\n    // ========== INSTANT REDEMPTION ==========\n\n    /**\n     * @notice Instant redemption using vault liquidity\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive assets\n     * @param controller Address that controls the shares\n     * @return assets Amount of assets received\n     */\n    function redeem(uint256 shares, address receiver, address controller)\n        external\n        whenNotPaused\n        nonReentrant\n        accruePerformanceFee\n        returns (uint256 assets)\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(\n            controller == msg.sender || $.shareManager.isOperator(controller, msg.sender),\n            \"RedemptionPipe: unauthorized\"\n        );\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require($.shareManager.balanceOf(controller) >= shares, \"RedemptionPipe: insufficient shares\");\n\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n\n\n        // Calculate assets based on NAV\n        assets = convertToAssets(shares);\n\n        // Calculate fee in basis points (fee = assets * feeBps / BASIS_POINTS)\n        uint256 fee = (assets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n        uint256 assetsAfterFee = assets - fee;\n\n\n        // Update NAV. Fees stay with liquidityProvider, only decrease NAV by user's portion\n        uint256 navDecrease = assetsAfterFee;\n        $.navOracle.decreaseTotalAssets(navDecrease);\n\n        // Burn shares\n        $.shareManager.burnShares(controller, shares);\n\n        uint256 lpBalance = $.underlyingAsset.balanceOf($.liquidityProvider);\n        require(lpBalance >= assetsAfterFee, \"RedemptionPipe: insufficient liquidity\");\n\n        // Transfer assets to user (fee stays with liquidity provider)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, receiver, assetsAfterFee);\n\n        // Check if transfer was successful\n        uint256 expectedLpBalance = lpBalance - assetsAfterFee; // Only user assets left LP\n        require(\n            $.underlyingAsset.balanceOf($.liquidityProvider) == expectedLpBalance,\n            \"RedemptionPipe: liquidity provider balance mismatch\"\n        );\n        $.lastRedemptionTime = uint72(block.timestamp);\n\n        emit InstantRedeem(controller, receiver, shares, assetsAfterFee, fee);\n\n        return assetsAfterFee;\n    }\n\n    /**\n     * @notice Instant withdrawal of specific asset amount\n     * @param assets Amount of assets to withdraw\n     * @param receiver Address to receive assets\n     * @param controller Address that controls the shares\n     * @return shares Amount of shares burned\n     */\n    function withdraw(\n        uint256 assets,  // NET amount user wants to receive\n        address receiver,\n        address controller\n    ) external whenNotPaused nonReentrant accruePerformanceFee returns (uint256 shares) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        \n        require(\n            controller == msg.sender ||\n                $.shareManager.isOperator(controller, msg.sender),\n            \"RedemptionPipe: unauthorized\"\n        );\n        require(assets > 0, \"RedemptionPipe: zero assets\");\n        \n        \n        // Calculate gross assets needed (same calculation as redeem() but in reverse)\n        uint256 grossAssets = assets.mulDiv(\n            BASIS_POINTS, \n            BASIS_POINTS - $.fees.instantRedeemFeeBps,\n            Math.Rounding.Floor\n        );\n        \n        // Calculate shares needed based on gross assets (before fee)\n        shares = convertToShares(grossAssets);\n\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require(\n            $.shareManager.balanceOf(controller) >= shares,\n            \"RedemptionPipe: insufficient shares\"\n        );\n        \n        // Calculate the actual assets and fee that this shares amount would produce\n        uint256 actualAssets = convertToAssets(shares);\n        uint256 fee = (actualAssets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n        uint256 actualNetAssets = actualAssets - fee;\n        \n        \n        // Update NAV by user's net portion (fees stay with liquidity provider)\n        $.navOracle.decreaseTotalAssets(actualNetAssets);\n        \n        // Burn shares\n        $.shareManager.burnShares(controller, shares);\n        \n        // Transfer NET assets to user (what they requested)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, receiver, actualNetAssets);\n        $.lastRedemptionTime = uint72(block.timestamp);\n        \n        emit InstantRedeem(controller, receiver, shares, actualNetAssets, fee);\n        \n        return shares;\n    }\n\n    // ========== FAST REDEMPTION ==========\n\n    /**\n     * @notice Request fast redemption\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive assets when fulfilled\n     * @param controller Address that will control the redemption\n     * @param owner Owner of the shares\n     * @return requestId Always returns 0 (single request per owner)\n     */\n    function requestRedeemFast(uint256 shares, address receiver, address controller, address owner)\n        external\n        whenNotPaused\n        fastRedeemEnabledCheck\n        returns (uint256 requestId)\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(owner == msg.sender || $.shareManager.isOperator(owner, msg.sender), \"RedemptionPipe: unauthorized\");\n        require(\n            controller == msg.sender || $.shareManager.isOperator(controller, msg.sender),\n            \"RedemptionPipe: unauthorized controller\"\n        );\n        require(receiver != address(0), \"RedemptionPipe: zero receiver\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require($.shareManager.balanceOf(owner) >= shares, \"RedemptionPipe: insufficient shares\");\n\n        // Check total pending shares (existing + new request) against maxWithdraw\n        uint256 totalPendingAfter = _getTotalPendingShares(owner) + shares;\n        require(totalPendingAfter <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n\n        // Transfer shares to this contract for custody\n        $.shareManager.transferFrom(owner, address(this), shares);\n\n        uint256 currentPendingShares = $.pendingFastRedeem[owner].shares;\n        $.pendingFastRedeem[owner] = PendingFastRedeemRequest(shares + currentPendingShares, block.timestamp, receiver);\n\n        emit FastRedeemRequested(owner, receiver, shares, block.timestamp);\n        return REQUEST_ID;\n    }\n\n    /**\n     * @notice Fulfill fast redemption requests\n     * @param owners Array of owners\n     * @param shares Array of share amounts\n     * @param customFees Array of custom _getRedemptionPipeStorage().fees (or use default)\n     */\n    function fulfillFastRedeems(address[] calldata owners, uint256[] calldata shares, uint256[] calldata customFees)\n        external\n        onlyRole(FULFILL_MANAGER_ROLE)\n        fastRedeemEnabledCheck\n        accruePerformanceFee\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        uint256 length = owners.length;\n        require(length == shares.length, \"RedemptionPipe: length mismatch\");\n\n        for (uint256 i = 0; i < length; i++) {\n            if (shares[i] > 0) {\n                // Calculate assets for fee calculation\n                uint256 assets = convertToAssets(shares[i]);\n                // Use custom fee basis points if provided, otherwise use default\n                uint256 feeBps = customFees.length > i ? customFees[i] : $.fees.fastRedeemFeeBps;\n                require(feeBps <= BASIS_POINTS, \"RedemptionPipe: Incorrect Custom Fee\");\n                require(feeBps <= $.maxCustomFeeBps, \"RedemptionPipe: Custom fee exceeds maximum\");\n                uint256 fee = (assets * feeBps) / BASIS_POINTS;\n                _fulfillFastRedeem(owners[i], shares[i], fee);\n            }\n        }\n        $.lastRedemptionTime = uint72(block.timestamp);\n    }\n\n    /**\n     * @notice Internal fast redeem fulfillment\n     */\n    function _fulfillFastRedeem(address owner, uint256 shares, uint256 fee) internal {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(!$.shareManager.isBlacklisted(owner), \"RedemptionPipe: owner is blacklisted\");\n\n        PendingFastRedeemRequest storage request = $.pendingFastRedeem[owner];\n        require(request.shares >= shares, \"RedemptionPipe: insufficient pending\");\n\n        // Performance fees are accrued via modifier\n\n        // Calculate assets based on current NAV\n        uint256 assets = convertToAssets(shares);\n\n        uint256 assetsAfterFee = assets - fee;\n\n        // Update NAV. Fees stay with liquidityProvider, only decrease NAV by user's portion\n        uint256 navDecrease = assetsAfterFee;\n        $.navOracle.decreaseTotalAssets(navDecrease);\n\n        // Update pending\n        request.shares -= shares;\n\n        // Burn shares held in custody\n        $.shareManager.burnSharesFromSelf(shares);\n\n        // Transfer assets to receiver (fee stays with liquidity provider)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, request.receiver, assetsAfterFee);\n\n        emit FastRedeemFulfilled(owner, request.receiver, assetsAfterFee, shares, fee);\n    }\n\n    // ========== STANDARD REDEMPTION ==========\n\n    /**\n     * @notice Request standard redemption\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive assets when fulfilled\n     * @param controller Address that will control the redemption (for ERC7540 compatibility)\n     * @param owner Owner of the shares\n     * @return requestId Always returns 0\n     */\n    function requestRedeem(uint256 shares, address receiver, address controller, address owner)\n        external\n        whenNotPaused\n        returns (uint256 requestId)\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        PendingRedeemRequest storage request = $.pendingRedeem[owner];\n\n        require(owner != address(0), \"RedemptionPipe: unauthorized\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares below minimum\");\n        require($.shareManager.balanceOf(msg.sender) >= shares, \"RedemptionPipe: insufficient shares\");\n\n        // Check authorization: msg.sender must be owner or operator of owner\n        require(\n            msg.sender == owner || $.shareManager.isOperator(owner, msg.sender),\n            \"RedemptionPipe: unauthorized\"\n        );\n\n        // Check controller authorization\n        require(controller != address(0), \"RedemptionPipe: unauthorized controller\");\n        require(\n            controller == owner || $.shareManager.isOperator(owner, controller),\n            \"RedemptionPipe: unauthorized controller\"\n        );\n\n        require(receiver != address(0), \"RedemptionPipe: zero receiver\");\n\n        // Check maximum withdraw limit\n        uint256 currentPendingShares = request.shares;\n        uint256 totalPendingAfterRequest = currentPendingShares + shares + $.pendingFastRedeem[owner].shares;\n        require(\n            totalPendingAfterRequest <= $.shareManager.maxWithdraw(),\n            \"RedemptionPipe: maximum redeem per user exceeded\"\n        );\n\n        // Transfer shares to this contract for custody\n        $.shareManager.transferFrom(msg.sender, address(this), shares);\n\n        // Add to pending\n        request.shares = shares + currentPendingShares;\n        request.receiver = receiver;\n\n        emit RedeemRequested(owner, receiver, shares);\n        return REQUEST_ID;\n    }\n\n    /**\n     * @notice Fulfill standard redemption requests\n     * @param owners Array of owners\n     * @param shares Array of share amounts\n     */\n    function fulfillRedeems(address[] calldata owners, uint256[] calldata shares)\n        external\n        onlyRole(FULFILL_MANAGER_ROLE)\n        accruePerformanceFee\n    {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        uint256 length = owners.length;\n        require(length == shares.length, \"RedemptionPipe: length mismatch\");\n\n        for (uint256 i = 0; i < length; i++) {\n            if (shares[i] > 0) {\n                _fulfillRedeem(owners[i], shares[i]);\n            }\n        }\n        $.lastRedemptionTime = uint72(block.timestamp);\n    }\n\n    /**\n     * @notice Internal standard redeem fulfillment\n     */\n    function _fulfillRedeem(address owner, uint256 shares) internal {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        require(!$.shareManager.isBlacklisted(owner), \"RedemptionPipe: owner is blacklisted\");\n\n        PendingRedeemRequest storage request = $.pendingRedeem[owner];\n        require(request.shares >= shares, \"RedemptionPipe: insufficient pending\");\n\n        // Performance fees are accrued via modifier\n\n        // Calculate assets\n        uint256 assets = convertToAssets(shares);\n\n        // Update NAV - full amount leaves system (no fees)\n        $.navOracle.decreaseTotalAssets(assets);\n\n        // Update pending\n        request.shares -= shares;\n\n        // Burn shares\n        $.shareManager.burnSharesFromSelf(shares);\n\n        // Transfer full assets to receiver (no fees)\n        $.underlyingAsset.safeTransferFrom($.liquidityProvider, request.receiver, assets);\n\n        emit RedeemFulfilled(owner, request.receiver, assets, shares);\n    }\n\n    // ========== VIEW FUNCTIONS ==========\n\n    /**\n     * @notice Get total pending shares for a user (both standard and fast redemptions)\n     * @param owner Owner address\n     * @return Total pending shares\n     */\n    function _getTotalPendingShares(address owner) internal view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        return $.pendingRedeem[owner].shares + $.pendingFastRedeem[owner].shares;\n    }\n\n    /**\n     * @notice Preview redeem - converts shares to underlying assets after instant fees\n     * @param shares Amount of shares to redeem\n     * @return assets Expected underlying assets received (after instant fees)\n     */\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require(shares > 0, \"RedemptionPipe: zero shares\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares less than min amount\");\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n\n        // Convert shares to underlying assets (in native decimals)\n        uint256 assets = convertToAssets(shares);\n        \n        // Calculate instant redemption fee in basis points\n        uint256 fee = (assets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n        \n        // Return assets after fee (what user actually receives from instant redemption)\n        return assets - fee;\n    }\n\n    /**\n     * @notice Preview withdraw - calculates required shares for net asset amount\n     * @param assets Net asset amount (what user wants to receive after fees)\n     * @return shares Required shares to burn\n     */\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        require(assets > 0, \"RedemptionPipe: zero assets\");\n\n        // Calculate gross assets needed (same calculation as withdraw() but in reverse)\n        uint256 grossAssets = assets.mulDiv(\n            BASIS_POINTS, \n            BASIS_POINTS - $.fees.instantRedeemFeeBps,\n            Math.Rounding.Floor\n        );\n        \n        uint256 shares = convertToShares(grossAssets);\n\n        require(shares <= $.shareManager.maxWithdraw(), \"RedemptionPipe: maximum redeem per user exceeded\");\n        require(shares >= $.MIN_AMOUNT_SHARES, \"RedemptionPipe: shares less than min amount\");\n        return shares;\n    }\n\n    /**\n     * @notice Convert shares to assets\n     * @param shares Amount of shares\n     * @return assets Equivalent asset amount\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        uint256 totalSupply = $.shareManager.totalSupply();\n        uint256 totalAssets = $.navOracle.getNAV();\n\n        uint8 underlyingDecimals = $.underlyingAsset.decimals();\n        uint256 decimalsDiff = 18 - underlyingDecimals;\n        uint256 scaleFactor = 10 ** decimalsDiff;\n\n        if (totalSupply == 0) {\n            // When no supply, convert decimals directly\n            return shares / scaleFactor;\n        }\n\n        // Calculate value in 18 decimals\n        uint256 value18 = shares.mulDiv(totalAssets, totalSupply, Math.Rounding.Floor);\n\n        // Convert from 18 decimals to underlying asset decimals\n        return value18 / scaleFactor;\n    }\n\n    /**\n     * @notice Convert assets to shares\n     * @param assets Amount of assets\n     * @return shares Equivalent share amount\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        if (assets == 0) {\n            return 0;\n        }\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        uint256 totalSupply = $.shareManager.totalSupply();\n        uint256 totalAssets = $.navOracle.getNAV();\n\n        uint8 underlyingDecimals = $.underlyingAsset.decimals();\n        uint256 decimalsDiff = 18 - underlyingDecimals;\n        uint256 scaleFactor = 10 ** decimalsDiff;\n\n        if (totalSupply == 0) {\n            // When no supply, convert decimals directly\n            return assets * scaleFactor;\n        }\n\n        // Convert from underlying asset decimals to 18 decimals\n        uint256 value18 = assets * scaleFactor;\n\n        // Calculate shares\n        return value18.mulDiv(totalSupply, totalAssets, Math.Rounding.Ceil);\n    }\n\n    /**\n     * @notice Get pending fast redeem request\n     * @param owner Owner address\n     * @return shares Amount of pending shares\n     * @return timestamp Request timestamp\n     * @return receiver Address that will receive the assets\n     */\n    function pendingFastRedeemRequest(address owner) external view returns (uint256 shares, uint256 timestamp, address receiver) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        PendingFastRedeemRequest memory request = $.pendingFastRedeem[owner];\n        return (request.shares, request.timestamp, request.receiver);\n    }\n\n    /**\n     * @notice Get pending standard redeem request\n     * @param owner Owner address\n     * @return shares Amount of pending shares\n     * @return receiver Address that will receive the assets\n     */\n    function pendingRedeemRequest(address owner) external view returns (uint256 shares, address receiver) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        PendingRedeemRequest memory request = $.pendingRedeem[owner];\n        return (request.shares, request.receiver);\n    }\n\n    /**\n     * @notice Maximum amount of shares that can be redeemed from the owner balance through a redeem call\n     * @param owner Address of the owner\n     * @return Maximum amount of shares that can be redeemed\n     * @dev ERC4626 compliant - considers balance, pending requests, and maxWithdraw limit\n     */\n    function maxRedeem(address owner) external view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        // Get owner's balance\n        uint256 balance = $.shareManager.balanceOf(owner);\n        if (balance == 0) {\n            return 0;\n        }\n\n        // Get total pending shares (both standard and fast redemptions)\n        uint256 totalPending = _getTotalPendingShares(owner);\n\n        // Get maximum shares allowed by ShareManager policy\n        uint256 maxWithdrawShares = $.shareManager.maxWithdraw();\n\n        // Calculate remaining capacity for new redemptions\n        uint256 remainingCapacity = maxWithdrawShares > totalPending ? maxWithdrawShares - totalPending : 0;\n\n        // Return the minimum of owner's balance and remaining capacity\n        uint256 maxShares = balance < remainingCapacity ? balance : remainingCapacity;\n\n        // Ensure it meets minimum requirement, otherwise return 0\n        if (maxShares < $.MIN_AMOUNT_SHARES) {\n            return 0;\n        }\n\n        return maxShares;\n    }\n\n    /**\n     * @notice Maximum amount of underlying assets that can be withdrawn from the owner balance through a withdraw call\n     * @param owner Address of the owner\n     * @return Maximum amount of assets that can be withdrawn\n     * @dev ERC4626 compliant - converts maxRedeem to assets after accounting for instant redemption fees\n     */\n    function maxWithdraw(address owner) external view returns (uint256) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n\n        // Return 0 if contract is paused\n        if (paused()) {\n            return 0;\n        }\n\n        // Get owner's balance\n        uint256 balance = $.shareManager.balanceOf(owner);\n        if (balance == 0) {\n            return 0;\n        }\n\n        // Get total pending shares (both standard and fast redemptions)\n        uint256 totalPending = _getTotalPendingShares(owner);\n\n        // Get maximum shares allowed by ShareManager policy\n        uint256 maxWithdrawShares = $.shareManager.maxWithdraw();\n\n        // Calculate remaining capacity for new redemptions\n        uint256 remainingCapacity = maxWithdrawShares > totalPending ? maxWithdrawShares - totalPending : 0;\n\n        // Return the minimum of owner's balance and remaining capacity\n        uint256 maxAllowedShares = balance < remainingCapacity ? balance : remainingCapacity;\n\n        // Ensure it meets minimum requirement, otherwise return 0\n        if (maxAllowedShares < $.MIN_AMOUNT_SHARES) {\n            return 0;\n        }\n\n        // Convert to assets and apply instant redemption fee\n        uint256 assets = convertToAssets(maxAllowedShares);\n        uint256 fee = (assets * $.fees.instantRedeemFeeBps) / BASIS_POINTS;\n\n        return assets - fee;\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Update timelock controller address\n     * @param _timelockController New timelock controller address\n     */\n    function setTimelockController(address _timelockController) external onlyTimelock {\n        require(_timelockController != address(0), \"RedemptionPipe: zero timelock\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        address oldTimeLockController = $.timeLockController;\n        $.timeLockController = _timelockController;\n        emit TimeLockControllerUpdated(oldTimeLockController, _timelockController);\n    }\n\n    /**\n     * @notice Update fee configuration\n     * @param _fees New fee configuration\n     */\n    function setFees(FeeConfig calldata _fees) external onlyTimelock {\n        require(_fees.instantRedeemFeeBps <= BASIS_POINTS, \"RedemptionPipe: instant fee exceeds 100%\");\n        require(_fees.fastRedeemFeeBps <= BASIS_POINTS, \"RedemptionPipe: fast fee exceeds 100%\");\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.fees = _fees;\n        emit FeesUpdated(_fees);\n    }\n\n    /**\n     * @notice Emergency pause\n     */\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause operations\n     */\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Update fast redemption enabled status\n     * @param _enabled New fast redemption enabled status\n     */\n    function setFastRedeemEnabled(bool _enabled) external onlyRole(SAFE_MANAGER_ROLE) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.fastRedeemEnabled = _enabled;\n        emit FastRedeemEnabledUpdated(_enabled);\n    }\n}\n",
        "DepositForwarder.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {IDepositPipe} from \"./interfaces/IDepositPipe.sol\";\n\n/**\n * @title DepositForwarder\n * @notice Forwarder contract for depositing tokens on behalf of users into a specific deposit pipe\n * @dev One forwarder is deployed per XToken, handling deposits for that specific token\n */\ncontract DepositForwarder is\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for keeper operations\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @notice Role for emergency pause/unpause operations\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n\n    /// @custom:storage-location erc7201:liminal.depositProxy.v1\n    struct DepositForwarderStorage {\n        /// @notice Mapping from asset address to deposit pipe address\n        mapping(address => address) assetToDepositPipe;\n        /// @notice Array of supported assets for enumeration\n        address[] supportedAssets;\n        /// @notice Mapping to check if asset is supported\n        mapping(address => bool) isSupportedAsset;\n        /// @notice Timelock controller for critical operations\n        address timeLockController;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.depositForwarder.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant DEPOSIT_FORWARDER_STORAGE_LOCATION =\n        0x43639106a183763e0d79da866d4c04316816dabf62bf4e69044fc03f2bdc7100;\n\n    function _getDepositForwarderStorage() private pure returns (DepositForwarderStorage storage $) {\n        assembly {\n            $.slot := DEPOSIT_FORWARDER_STORAGE_LOCATION\n        }\n    }\n\n    /// Events\n    event DepositForUser(\n        address indexed asset,\n        address indexed user,\n        address indexed depositPipe,\n        uint256 amount,\n        uint256 shares,\n        bool permitUsed\n    );\n    event DepositPipeAdded(address indexed asset, address indexed depositPipe);\n    event DepositPipeRemoved(address indexed asset, address indexed depositPipe);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n\n    /// @notice Modifier for timelock-protected functions\n    modifier onlyTimelock() {\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        require(msg.sender == $.timeLockController, \"DepositForwarder: only timelock\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the deposit proxy\n     * @dev Ownership (DEFAULT_ADMIN_ROLE) is granted to deployer\n     * @param _deployer Deployer address (receives DEFAULT_ADMIN_ROLE)\n     * @param _keeper The keeper address\n     * @param _timeLockController The timelock controller address\n     * @param _emergencyManager The emergency manager MPC address (receives EMERGENCY_MANAGER_ROLE)\n     */\n    function initialize(address _deployer, address _keeper, address _timeLockController, address _emergencyManager) external initializer {\n        require(_deployer != address(0), \"DepositForwarder: zero deployer\");\n        require(_keeper != address(0), \"DepositForwarder: zero keeper\");\n        require(_timeLockController != address(0), \"DepositForwarder: zero timelock\");\n        require(_emergencyManager != address(0), \"DepositForwarder: zero emergency manager\");\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        $.timeLockController = _timeLockController;\n\n        // Grant ownership to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(EMERGENCY_MANAGER_ROLE, _emergencyManager);\n        _grantRole(KEEPER_ROLE, _keeper);\n    }\n\n    /**\n     * @notice Deposit tokens on behalf of a user using permit signature\n     * @param asset The asset to deposit\n     * @param user The user to deposit for (will receive shares)\n     * @param amount The amount to deposit\n     * @param deadline The permit deadline\n     * @param v The recovery id of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     * @return shares The amount of shares minted\n     */\n    function depositFor(address asset, address user, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        onlyRole(KEEPER_ROLE)\n        whenNotPaused\n        nonReentrant\n        returns (uint256 shares)\n    {\n        require(asset != address(0), \"DepositForwarder: zero asset\");\n        require(user != address(0), \"DepositForwarder: zero user\");\n        require(amount > 0, \"DepositForwarder: zero amount\");\n\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        address depositPipe = $.assetToDepositPipe[asset];\n        require(depositPipe != address(0), \"DepositForwarder: unsupported asset\");\n\n        // Attempt to use permit - follow OpenZeppelin's recommended pattern\n        bool permitUsed = false;\n        try IERC20Permit(asset).permit(user, address(this), amount, deadline, v, r, s) {\n            permitUsed = true;\n        } catch {\n            // Permit failed - will rely on existing allowance\n            // This handles frontrunning, already used permits, and non-permit tokens gracefully\n        }\n\n        // Transfer tokens from user to this contract\n        IERC20(asset).safeTransferFrom(user, address(this), amount);\n\n        // Approve deposit pipe to spend tokens\n        IERC20(asset).forceApprove(depositPipe, amount);\n\n        // Deposit into the deposit pipe with user as receiver and this contract as controller\n        shares = IDepositPipe(depositPipe).deposit(amount, user, address(this));\n\n        // Reset allowance to 0 for security\n        IERC20(asset).forceApprove(depositPipe, 0);\n\n        emit DepositForUser(asset, user, depositPipe, amount, shares, permitUsed);\n\n        return shares;\n    }\n\n    /**\n     * @notice Deposit tokens on behalf of a user using pre-existing approval\n     * @dev Fallback function for wallets that don't support permits\n     * @param asset The asset to deposit\n     * @param user The user to deposit for (will receive shares)\n     * @param amount The amount to deposit\n     * @return shares The amount of shares minted\n     */\n    function depositForWithApproval(address asset, address user, uint256 amount)\n        external\n        onlyRole(KEEPER_ROLE)\n        whenNotPaused\n        nonReentrant\n        returns (uint256 shares)\n    {\n        require(asset != address(0), \"DepositForwarder: zero asset\");\n        require(user != address(0), \"DepositForwarder: zero user\");\n        require(amount > 0, \"DepositForwarder: zero amount\");\n\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        address depositPipe = $.assetToDepositPipe[asset];\n        require(depositPipe != address(0), \"DepositForwarder: unsupported asset\");\n\n        // Transfer tokens from user to this contract\n        IERC20(asset).safeTransferFrom(user, address(this), amount);\n\n        // Approve deposit pipe to spend tokens\n        IERC20(asset).forceApprove(depositPipe, amount);\n\n        // Deposit into the deposit pipe with user as receiver and this contract as controller\n        shares = IDepositPipe(depositPipe).deposit(amount, user, address(this));\n\n        // Reset allowance to 0 for security\n        IERC20(asset).forceApprove(depositPipe, 0);\n\n        emit DepositForUser(asset, user, depositPipe, amount, shares, false);\n\n        return shares;\n    }\n\n    /**\n     * @notice Add a new deposit pipe for an asset\n     * @param _depositPipe The deposit pipe address to add\n     */\n    function addDepositPipe(address _depositPipe) external onlyTimelock {\n        require(_depositPipe != address(0), \"DepositForwarder: zero deposit pipe\");\n\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        address asset = IDepositPipe(_depositPipe).asset();\n\n        require($.assetToDepositPipe[asset] == address(0), \"DepositForwarder: asset already supported\");\n\n        $.assetToDepositPipe[asset] = _depositPipe;\n\n        if (!$.isSupportedAsset[asset]) {\n            $.supportedAssets.push(asset);\n            $.isSupportedAsset[asset] = true;\n        }\n\n        emit DepositPipeAdded(asset, _depositPipe);\n    }\n\n    /**\n     * @notice Remove a deposit pipe for an asset\n     * @param asset The asset address to remove support for\n     */\n    function removeDepositPipe(address asset) external onlyTimelock {\n        require(asset != address(0), \"DepositForwarder: zero asset\");\n\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        address depositPipe = $.assetToDepositPipe[asset];\n        require(depositPipe != address(0), \"DepositForwarder: asset not supported\");\n\n        delete $.assetToDepositPipe[asset];\n        $.isSupportedAsset[asset] = false;\n\n        uint256 supportedAssetsLength = $.supportedAssets.length;\n\n        // Remove from supportedAssets array\n        for (uint256 i = 0; i < supportedAssetsLength; i++) {\n            if ($.supportedAssets[i] == asset) {\n                $.supportedAssets[i] = $.supportedAssets[supportedAssetsLength - 1];\n                $.supportedAssets.pop();\n                break;\n            }\n        }\n\n        emit DepositPipeRemoved(asset, depositPipe);\n    }\n\n /**\n     * @notice Set the timelock controller\n     * @param _timeLockController New timelock controller address\n     * @dev Can only be called by the current timelock (with delay enforced by VaultTimelockController)\n     */\n    function setTimelockController(address _timeLockController) external onlyTimelock {\n        require(_timeLockController != address(0), \"NAVOracle: zero timelock\");\n\n        DepositForwarderStorage storage $ = _getDepositForwarderStorage();\n        address oldTimelock = $.timeLockController;\n        $.timeLockController = _timeLockController;\n\n        emit TimelockControllerSet(oldTimelock, _timeLockController);\n    }\n\n\n    // ========== VIEW FUNCTIONS ==========\n\n    /**\n     * @notice Get the deposit pipe for an asset\n     * @param asset The asset address\n     * @return The deposit pipe address\n     */\n    function getDepositPipe(address asset) external view returns (address) {\n        return _getDepositForwarderStorage().assetToDepositPipe[asset];\n    }\n\n    /**\n     * @notice Check if an asset is supported\n     * @param asset The asset address\n     * @return True if the asset is supported\n     */\n    function isAssetSupported(address asset) external view returns (bool) {\n        return _getDepositForwarderStorage().assetToDepositPipe[asset] != address(0);\n    }\n\n    /**\n     * @notice Get all supported assets\n     * @return Array of supported asset addresses\n     */\n    function getSupportedAssets() external view returns (address[] memory) {\n        return _getDepositForwarderStorage().supportedAssets;\n    }\n\n    /**\n     * @notice Get the number of supported assets\n     * @return The count of supported assets\n     */\n    function getSupportedAssetsCount() external view returns (uint256) {\n        return _getDepositForwarderStorage().supportedAssets.length;\n    }\n\n    /**\n     * @notice Get the timelock controller address\n     * @return The timelock controller address\n     */\n    function timeLockController() external view returns (address) {\n        return _getDepositForwarderStorage().timeLockController;\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Emergency pause\n     */\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause operations\n     */\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Recover tokens from the contract (timelock-protected)\n     * @param token The token to recover\n     * @param to The address to send tokens to\n     * @param amount The amount to recover\n     */\n    function recoverToken(address token, address to, uint256 amount) external onlyTimelock {\n        require(token != address(0), \"DepositForwarder: zero token\");\n        require(to != address(0), \"DepositForwarder: zero recipient\");\n        require(amount > 0, \"DepositForwarder: zero amount\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n",
        "NAVOracle.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ncontract NAVOracle is AccessControlUpgradeable {\n    using Math for uint256;\n\n    bytes32 public constant VALUATION_MANAGER_ROLE = keccak256(\"VALUATION_MANAGER_ROLE\");\n\n    bytes32 public constant VAULT_ROLE = keccak256(\"VAULT_ROLE\");\n\n    struct NAVOracleStorage {\n        uint256 currentTotalAssets;\n        uint256 lastUpdateTime;\n        uint256 maxPercentageIncrease;\n        uint256 maxPercentageDecrease;\n        IERC20Metadata underlyingAsset;\n        address timeLockController;\n        uint256 lastSetTotalAssetsBlock;\n    }\n\n    bytes32 private constant NAV_ORACLE_STORAGE_LOCATION =\n        0x530b86cfd76ace1cbd39c58faa3d0b7c3932db3408b4deb9aecf4ab72aef1d00;\n\n    function _getNAVOracleStorage() private pure returns (NAVOracleStorage storage $) {\n        assembly {\n            $.slot := NAV_ORACLE_STORAGE_LOCATION\n        }\n    }\n\n    event NAVUpdated(uint256 newNAV, uint256 timestamp);\n    event NAVUpdatedVault(uint256 newNAV, uint256 timestamp);\n    event NAVIncreased(uint256 amount, uint256 newNAV, uint256 timestamp);\n    event NAVDecreased(uint256 amount, uint256 newNAV, uint256 timestamp);\n    event MaxPercentageIncreaseUpdated(uint256 oldValue, uint256 newValue);\n    event MaxPercentageDecreaseUpdated(uint256 oldValue, uint256 newValue);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n    event UnderlyingAssetUpdated(address indexed oldAsset, address indexed newAsset);\n\n    error NAVIncreaseExceedsLimit(uint256 currentNAV, uint256 newNAV, uint256 maxAllowed);\n    error NAVDecreaseExceedsLimit(uint256 currentNAV, uint256 newNAV, uint256 maxAllowed);\n    error InvalidPercentage(uint256 percentage);\n    error IntraBlockCooldownActive(uint256 lastBlock, uint256 currentBlock);\n\n    modifier onlyTimelock() {\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        require(msg.sender == $.timeLockController, \"NAVOracle: only timelock\");\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _deployer,\n        address _valuationManager,\n        uint256 _initialNAV,\n        uint256 _maxPercentageIncrease,\n        uint256 _maxPercentageDecrease,\n        address _underlyingAsset,\n        address _timeLockController\n    ) external initializer {\n        require(_deployer != address(0), \"NAVOracle: zero deployer\");\n        require(_valuationManager != address(0), \"NAVOracle: zero address\");\n        require(_underlyingAsset != address(0), \"NAVOracle: zero address\");\n        require(_timeLockController != address(0), \"NAVOracle: zero timelock\");\n        if (_maxPercentageIncrease == 0 || _maxPercentageIncrease > 10_000) {\n            revert InvalidPercentage(_maxPercentageIncrease);\n        }\n        if (_maxPercentageDecrease == 0 || _maxPercentageDecrease > 10_000) {\n            revert InvalidPercentage(_maxPercentageDecrease);\n        }\n\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(VALUATION_MANAGER_ROLE, _valuationManager);\n\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        $.currentTotalAssets = _initialNAV;\n        $.maxPercentageIncrease = _maxPercentageIncrease;\n        $.maxPercentageDecrease = _maxPercentageDecrease;\n        $.underlyingAsset = IERC20Metadata(_underlyingAsset);\n        $.timeLockController = _timeLockController;\n        $.lastUpdateTime = block.timestamp;\n        emit NAVUpdated(_initialNAV, block.timestamp);\n    }\n\n    function setMaxPercentageIncrease(uint16 _newMaxPercentage) external onlyTimelock {\n        if (_newMaxPercentage == 0 || _newMaxPercentage > 10_000) {\n            revert InvalidPercentage(_newMaxPercentage);\n        }\n\n        uint256 oldValue = _getNAVOracleStorage().maxPercentageIncrease;\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        $.maxPercentageIncrease = _newMaxPercentage;\n        emit MaxPercentageIncreaseUpdated(oldValue, _newMaxPercentage);\n    }\n\n    function setMaxPercentageDecrease(uint256 _newMaxPercentage) external onlyTimelock {\n        if (_newMaxPercentage == 0 || _newMaxPercentage > 10_000) {\n            revert InvalidPercentage(_newMaxPercentage);\n        }\n\n        uint256 oldValue = _getNAVOracleStorage().maxPercentageDecrease;\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        $.maxPercentageDecrease = _newMaxPercentage;\n        emit MaxPercentageDecreaseUpdated(oldValue, _newMaxPercentage);\n    }\n\n    function _normalizeToDecimals18(uint256 amount) private view returns (uint256) {\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        uint8 underlyingDecimals = $.underlyingAsset.decimals();\n        if (underlyingDecimals < 18) {\n            return amount * (10 ** (18 - underlyingDecimals));\n        }\n        return amount;\n    }\n\n    function increaseTotalAssets(uint256 amount) external onlyRole(VAULT_ROLE) {\n        require(amount > 0, \"NAVOracle: zero amount\");\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n\n        uint256 normalizedAmount = _normalizeToDecimals18(amount);\n\n        $.currentTotalAssets += normalizedAmount;\n        $.lastUpdateTime = block.timestamp;\n        emit NAVIncreased(normalizedAmount, $.currentTotalAssets, block.timestamp);\n    }\n\n    function decreaseTotalAssets(uint256 amount) external onlyRole(VAULT_ROLE) {\n        require(amount > 0, \"NAVOracle: zero amount\");\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n\n        uint256 normalizedAmount = _normalizeToDecimals18(amount);\n\n        require($.currentTotalAssets >= normalizedAmount, \"NAVOracle: insufficient NAV\");\n        $.currentTotalAssets -= normalizedAmount;\n        $.lastUpdateTime = block.timestamp;\n        emit NAVDecreased(normalizedAmount, $.currentTotalAssets, block.timestamp);\n    }\n\n    function setTotalAssets(uint256 newTotalAssets, uint256 expectedNav) external onlyRole(VALUATION_MANAGER_ROLE) {\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n\n        if ($.lastSetTotalAssetsBlock == block.number) {\n            revert IntraBlockCooldownActive($.lastSetTotalAssetsBlock, block.number);\n        }\n\n        uint256 currentNAV = $.currentTotalAssets;\n        require(currentNAV == expectedNav, \"NAVOracle: expected NAV mismatch\");\n\n        if (newTotalAssets > currentNAV && currentNAV > 0) {\n            uint256 maxAllowed = currentNAV + currentNAV.mulDiv($.maxPercentageIncrease, 10_000);\n\n            if (newTotalAssets > maxAllowed) {\n                revert NAVIncreaseExceedsLimit(currentNAV, newTotalAssets, maxAllowed);\n            }\n        }\n\n        if (newTotalAssets < currentNAV && currentNAV > 0) {\n            uint256 maxAllowed = currentNAV - currentNAV.mulDiv($.maxPercentageDecrease, 10_000);\n\n            if (newTotalAssets < maxAllowed) {\n                revert NAVDecreaseExceedsLimit(currentNAV, newTotalAssets, maxAllowed);\n            }\n        }\n\n        $.currentTotalAssets = newTotalAssets;\n        $.lastUpdateTime = block.timestamp;\n        $.lastSetTotalAssetsBlock = block.number;\n        emit NAVUpdated(newTotalAssets, block.timestamp);\n    }\n\n    function setUnderlyingAsset(address _newUnderlyingAsset) external onlyTimelock {\n        require(_newUnderlyingAsset != address(0), \"NAVOracle: zero address\");\n\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        address oldAsset = address($.underlyingAsset);\n        require(oldAsset != _newUnderlyingAsset, \"NAVOracle: same asset\");\n\n        $.underlyingAsset = IERC20Metadata(_newUnderlyingAsset);\n\n        emit UnderlyingAssetUpdated(oldAsset, _newUnderlyingAsset);\n    }\n\n    function setTimelockController(address _timeLockController) external onlyTimelock {\n        require(_timeLockController != address(0), \"NAVOracle: zero timelock\");\n\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        address oldTimelock = $.timeLockController;\n        $.timeLockController = _timeLockController;\n\n        emit TimelockControllerSet(oldTimelock, _timeLockController);\n    }\n\n    function getNAV() external view returns (uint256) {\n        return _getNAVOracleStorage().currentTotalAssets;\n    }\n\n    function getMaxAllowedNAV() external view returns (uint256) {\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        return $.currentTotalAssets + $.currentTotalAssets.mulDiv($.maxPercentageIncrease, 10_000);\n    }\n\n    function getMinAllowedNAV() external view returns (uint256) {\n        NAVOracleStorage storage $ = _getNAVOracleStorage();\n        return $.currentTotalAssets - $.currentTotalAssets.mulDiv($.maxPercentageDecrease, 10_000);\n    }\n\n    function maxPercentageIncrease() external view returns (uint256) {\n        return _getNAVOracleStorage().maxPercentageIncrease;\n    }\n\n    function maxPercentageDecrease() external view returns (uint256) {\n        return _getNAVOracleStorage().maxPercentageDecrease;\n    }\n\n    function lastUpdateTime() external view returns (uint256) {\n        return _getNAVOracleStorage().lastUpdateTime;\n    }\n\n    function getUnderlyingAsset() external view returns (address) {\n        return address(_getNAVOracleStorage().underlyingAsset);\n    }\n\n    function timeLockController() external view returns (address) {\n        return _getNAVOracleStorage().timeLockController;\n    }\n\n    function lastSetTotalAssetsBlock() external view returns (uint256) {\n        return _getNAVOracleStorage().lastSetTotalAssetsBlock;\n    }\n}\n",
        "VaultComposerBase.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {IOAppCore} from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol\";\nimport {ILayerZeroEndpointV2} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title VaultComposerBase - Multi-Asset Vault Composer Base\n * @notice Minimal base contract for cross-chain vault operations\n */\nabstract contract VaultComposerBase is IOAppComposer, ReentrancyGuardUpgradeable {\n    using OFTComposeMsgCodec for bytes;\n    using OFTComposeMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    address public SHARE_OFT;\n    address public SHARE_ERC20;\n    address public ENDPOINT;\n    uint32 public VAULT_EID;\n\n    // Events\n    event Sent(bytes32 indexed guid);\n    event Refunded(bytes32 indexed guid);\n    event CrossChainDeposit(address indexed asset, address indexed depositor, address indexed shareRecipient, uint32 srcEid, uint256 dstEid, uint256 amount, uint256 shares);\n    event CrossChainRedemption(address indexed redeemer, address indexed assetRecipient, uint32 srcEid, uint256 dstEid, uint256 shares, uint256 assets);\n    event NativeRefunded(address indexed recipient, uint256 amount);\n    event AssetRefunded(address indexed asset, address indexed from, address indexed to, uint256 amount, uint32 dstEid);\n    event DustRefunded(address indexed asset, address indexed recipient, uint256 amount);\n\n    // Errors\n    error OnlyEndpoint(address caller);\n    error ShareOFTNotAdapter(address shareOFT);\n    error InvalidSendParam();\n    error InsufficientMsgValue();\n    error Slippage(uint256 actual, uint256 minimum);\n    error UnauthorizedOFTSender(address sender);\n    error InvalidSourceChain(uint32 srcEid);\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.VaultComposerBase.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0x6c0f4739f9b140a9470c9589ba863e64a556e1c02777b0938a3c35b5956b9000;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __VaultComposerBase_init(address _shareOFT) internal onlyInitializing {\n        SHARE_OFT = _shareOFT;\n        SHARE_ERC20 = IOFT(SHARE_OFT).token();\n        ENDPOINT = address(IOAppCore(SHARE_OFT).endpoint());\n        VAULT_EID = ILayerZeroEndpointV2(ENDPOINT).eid();\n\n        __ReentrancyGuard_init();\n\n        if (!IOFT(SHARE_OFT).approvalRequired()) {\n            revert ShareOFTNotAdapter(SHARE_OFT);\n        }\n    }\n\n    function lzCompose(address _composeSender, bytes32 _guid, bytes calldata _message, address, bytes calldata)\n        public\n        payable\n        virtual\n        override\n    {\n        if (msg.sender != ENDPOINT) revert OnlyEndpoint(msg.sender);\n\n        // Verify that the OFT calling lzCompose is in our approved list\n        // This prevents arbitrary malicious OFTs from triggering compose actions\n        if (!_isApprovedOFT(_composeSender)) {\n            revert UnauthorizedOFTSender(_composeSender);\n        }\n\n        // Verify that messages from this OFT are only accepted from configured source chains\n        // This prevents messages from unauthorized chains even if the OFT is approved\n        {\n            bytes32 expectedPeer = _getRemotePeer(_composeSender, _message.srcEid());\n            if (expectedPeer == bytes32(0)) {\n                revert InvalidSourceChain(_message.srcEid());\n            }\n        }\n\n        bytes32 composeFrom = _message.composeFrom();\n        uint256 amount = _message.amountLD();\n        bytes memory composeMsg = _message.composeMsg();\n        uint32 srcEid = _message.srcEid();\n\n        try this.handleCompose{value: msg.value}(_composeSender, composeFrom, _guid, composeMsg, amount, srcEid) {\n            emit Sent(_guid);\n        } catch (bytes memory _err) {\n            if (bytes4(_err) == InsufficientMsgValue.selector) {\n                assembly {\n                    revert(add(32, _err), mload(_err))\n                }\n            }\n            _handleRefund(_composeSender, _message, composeFrom, composeMsg, amount);\n            emit Refunded(_guid);\n        }\n    }\n\n    function handleCompose(\n        address _oftIn,\n        bytes32 _composeFrom,\n        bytes32 _guid,\n        bytes memory _composeMsg,\n        uint256 _amount,\n        uint32 _srcEid\n    ) public payable virtual;\n\n    /**\n     * @notice Handle refund logic by extracting recipients from compose message\n     * Assets are returned to composeFrom on the ORIGIN chain (for multi-hop support)\n     * Native fees are returned to feeRefundRecipient on this chain\n     * Useful if using a wallet contract on the source chain.\n     * The wallet contract must receive the tokens, but may not\n     * exist on the hub chain, so trying to refund them the fees\n     * on the hub chain would be a mistake.\n     */\n    function _handleRefund(\n        address _composeSender,\n        bytes calldata _message,\n        bytes32 _composeFrom,\n        bytes memory _composeMsg,\n        uint256 _amount\n    ) internal virtual {\n        // Assets ALWAYS go back to composeFrom on origin chain\n        address assetRecipient = _composeFrom.bytes32ToAddress();\n\n        // Fees default to composeFrom but can be overridden\n        address feeRecipient = _composeFrom.bytes32ToAddress();\n\n        (uint8 action, bytes memory params) = abi.decode(_composeMsg, (uint8, bytes));\n\n        // Extract fee refund recipient and originEid (ignore receiver since assets always go to composeFrom)\n        (, bytes32 extractedFeeRecipient, uint32 originEid) = _decodeReceivers(action, params);\n\n        address feeRecipientAddr = extractedFeeRecipient.bytes32ToAddress();\n        if (feeRecipientAddr != address(0)) {\n            feeRecipient = feeRecipientAddr;\n        }\n\n        // Use originEid if provided, otherwise fallback to srcEid for single-hop scenarios\n        uint32 refundEid = originEid != 0 ? originEid : _message.srcEid();\n\n        _refund(_composeSender, _message, _amount, assetRecipient, feeRecipient, refundEid);\n    }\n\n    function _send(address _oft, SendParam memory _sendParam, address _refundAddress) internal virtual {\n        if (_sendParam.to == bytes32(0) || _sendParam.amountLD == 0) revert InvalidSendParam();\n\n        MessagingFee memory fee = IOFT(_oft).quoteSend(_sendParam, false);\n        if (msg.value < fee.nativeFee) revert InsufficientMsgValue();\n\n        IOFT(_oft).send{value: fee.nativeFee}(_sendParam, fee, _refundAddress);\n\n        // Refund excess native\n        if (msg.value > fee.nativeFee) {\n            uint256 refundAmount = msg.value - fee.nativeFee;\n            payable(_refundAddress).transfer(refundAmount);\n            emit NativeRefunded(_refundAddress, refundAmount);\n        }\n    }\n\n    function _refund(\n        address _oft,\n        bytes calldata /* _message */,\n        uint256 _amount,\n        address _assetRecipient,\n        address _feeRecipient,\n        uint32 _refundEid\n    ) internal virtual {\n        SendParam memory refundParam = SendParam({\n            dstEid: _refundEid,  // Use originEid for multi-hop support\n            to: bytes32(uint256(uint160(_assetRecipient))),  // Assets go to receiver on origin chain\n            amountLD: _amount,\n            minAmountLD: 0,\n            extraOptions: \"\",\n            composeMsg: \"\",\n            oftCmd: \"\"\n        });\n\n        // Assets are sent to _assetRecipient on origin chain\n        // Excess native fees are refunded to _feeRecipient on this chain\n        IOFT(_oft).send{value: msg.value}(refundParam, MessagingFee(msg.value, 0), _feeRecipient);\n\n        address asset = IOFT(_oft).token();\n        emit AssetRefunded(asset, address(this), _assetRecipient, _amount, _refundEid);\n    }\n\n    function _assertSlippage(uint256 _amount, uint256 _minAmount) internal pure {\n        if (_amount < _minAmount) revert Slippage(_amount, _minAmount);\n    }\n\n    /**\n     * @notice Internal helper to decode receivers and originEid from compose params\n     * @dev Used in try-catch pattern to extract asset receiver, fee refund recipient, and origin chain ID\n     * @param _action The action type (1=deposit, 2=redeem, 3=withdraw)\n     * @param _params The encoded parameters\n     * @return receiver The receiver address where assets should be delivered on this chain (bytes32(0) if not provided)\n     * @return feeRefundRecipient The fee refund recipient address on this chain (bytes32(0) if not provided)\n     * @return originEid The origin chain ID for multi-hop refunds\n     */\n    function _decodeReceivers(uint8 _action, bytes memory _params)\n        internal\n        pure\n        returns (bytes32 receiver, bytes32 feeRefundRecipient, uint32 originEid)\n    {\n        if (_action == 1) {\n            // ACTION_DEPOSIT_ASSET: (address targetAsset, bytes32 receiver, SendParam, uint256 minMsgValue, bytes32 feeRefundRecipient, uint32 originEid)\n            (, receiver, , , feeRefundRecipient, originEid) = abi.decode(_params, (address, bytes32, SendParam, uint256, bytes32, uint32));\n        } else if (_action == 2) {\n            // ACTION_REDEEM_SHARES: (address receiver, SendParam, uint256 minMsgValue, uint256 minAssets, bytes32 feeRefundRecipient, uint32 originEid)\n            address receiverAddr;\n            (receiverAddr, , , , feeRefundRecipient, originEid) = abi.decode(_params, (address, SendParam, uint256, uint256, bytes32, uint32));\n            receiver = bytes32(uint256(uint160(receiverAddr)));\n        }\n        // Returns (bytes32(0), bytes32(0), 0) for unknown actions\n    }\n\n    /**\n     * @notice Check if an OFT is approved to send compose messages\n     * @dev Must be implemented by derived contracts\n     * @param _oft The OFT address to check\n     * @return bool True if the OFT is approved\n     */\n    function _isApprovedOFT(address _oft) internal view virtual returns (bool);\n\n    /**\n     * @notice Get the expected remote peer for an OFT on a specific source chain\n     * @dev Must be implemented by derived contracts\n     * @param _oft The OFT address\n     * @param _srcEid The source endpoint ID\n     * @return bytes32 The expected peer address (bytes32(0) if not configured)\n     */\n    function _getRemotePeer(address _oft, uint32 _srcEid) internal view virtual returns (bytes32);\n}",
        "ShareManager.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\ncontract ShareManager is\n    ERC20Upgradeable,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    bytes32 public constant FEE_COLLECTOR_ROLE = keccak256(\"FEE_COLLECTOR_ROLE\");\n\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n\n    bytes32 public constant SAFE_MANAGER_ROLE = keccak256(\"SAFE_MANAGER_ROLE\");\n\n    struct ShareManagerStorage {\n        mapping(address => mapping(address => bool)) isOperator;\n        address timeLockController;\n        address oVaultComposerMulti;\n        uint256 maxDeposit;\n        uint256 maxSupply;\n        uint256 maxWithdraw;\n        mapping(address => bool) blacklisted;\n    }\n\n    bytes32 private constant SHARE_MANAGER_STORAGE_LOCATION =\n        0x337847f0cd9f9997f865bb5bc45c11df60e99bcb99c84221ba315731aed2fc00;\n\n    function _getShareManagerStorage() private pure returns (ShareManagerStorage storage $) {\n        assembly {\n            $.slot := SHARE_MANAGER_STORAGE_LOCATION\n        }\n    }\n\n    function isOperator(address controller, address operator) public view returns (bool) {\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        return $.isOperator[controller][operator] || $.oVaultComposerMulti == operator;\n    }\n\n    event OperatorSet(address indexed controller, address indexed operator, bool approved);\n    event SharesMinted(address indexed to, uint256 amount, address indexed minter);\n    event SharesBurned(address indexed from, uint256 amount, address indexed burner);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n    event OVaultComposerMultiSet(address indexed oldOVaultComposerMulti, address indexed newOVaultComposerMulti, address indexed shareOftAdapter);\n    event MaxDepositSet(uint256 oldMaxDeposit, uint256 newMaxDeposit);\n    event MaxSupplySet(uint256 oldMaxSupply, uint256 newMaxSupply);\n    event MaxWithdrawSet(uint256 oldMaxWithdraw, uint256 newMaxWithdraw);\n    event Blacklisted(address indexed account);\n    event Unblacklisted(address indexed account);\n\n    modifier onlyTimelock() {\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        require(msg.sender == $.timeLockController, \"ShareManager: only timelock\");\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _deployer,\n        address _safeManager,\n        address _emergencyManager,\n        address _timeLockController,\n        uint256 _maxDeposit,\n        uint256 _maxSupply,\n        uint256 _maxWithdraw\n    ) external initializer {\n        require(_deployer != address(0), \"ShareManager: zero deployer\");\n        require(_safeManager != address(0), \"ShareManager: zero safe manager\");\n        require(_timeLockController != address(0), \"ShareManager: zero timelock\");\n\n        __ERC20_init(_name, _symbol);\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        $.timeLockController = _timeLockController;\n        $.maxDeposit = _maxDeposit;\n        $.maxSupply = _maxSupply;\n        $.maxWithdraw = _maxWithdraw;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(SAFE_MANAGER_ROLE, _safeManager);\n        _grantRole(EMERGENCY_MANAGER_ROLE, _emergencyManager);\n    }\n\n    function mintShares(address to, uint256 amount) external onlyRole(MINTER_ROLE) whenNotPaused nonReentrant {\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        require(!$.blacklisted[to], \"ShareManager: receiver address is blacklisted\");\n        require(to != address(0), \"ShareManager: mint to zero\");\n        require(amount > 0, \"ShareManager: zero amount\");\n\n        _mint(to, amount);\n        emit SharesMinted(to, amount, msg.sender);\n    }\n\n    function burnShares(address from, uint256 amount) external onlyRole(BURNER_ROLE) whenNotPaused nonReentrant {\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        require(!$.blacklisted[from], \"ShareManager: address is blacklisted\");\n        require(from != address(0), \"ShareManager: burn from zero\");\n        require(amount > 0, \"ShareManager: zero amount\");\n        require(balanceOf(from) >= amount, \"ShareManager: insufficient balance\");\n\n        _burn(from, amount);\n        emit SharesBurned(from, amount, msg.sender);\n    }\n\n    function burnSharesFromSelf(uint256 amount) external onlyRole(BURNER_ROLE) whenNotPaused nonReentrant {\n        require(amount > 0, \"ShareManager: zero amount\");\n        _burn(msg.sender, amount);\n\n        emit SharesBurned(msg.sender, amount, msg.sender);\n    }\n\n    function mintFeesShares(address to, uint256 amount)\n        external\n        onlyRole(FEE_COLLECTOR_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        require(to != address(0), \"ShareManager: mint to zero\");\n        require(amount > 0, \"ShareManager: zero amount\");\n\n        _mint(to, amount);\n\n        emit SharesMinted(to, amount, msg.sender);\n    }\n\n    function setOperator(address operator, bool approved) external returns (bool) {\n        require(msg.sender != operator, \"ShareManager: self operator\");\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        $.isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n\n    function setTimelockController(address _timeLockController) external onlyTimelock {\n        require(_timeLockController != address(0), \"ShareManager: zero timelock\");\n\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        address oldTimelock = $.timeLockController;\n        $.timeLockController = _timeLockController;\n\n        emit TimelockControllerSet(oldTimelock, _timeLockController);\n    }\n\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        require(!$.blacklisted[from], \"ShareManager: sender address is blacklisted\");\n        require(!$.blacklisted[to], \"ShareManager: receiver address is blacklisted\");\n\n        address spender = _msgSender();\n\n        if (from != spender) {\n            if (!isOperator(from, spender)) {\n                _spendAllowance(from, spender, amount);\n            }\n        }\n\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual override whenNotPaused returns (bool) {\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        require(!$.blacklisted[_msgSender()], \"ShareManager: sender address is blacklisted\");\n        require(!$.blacklisted[to], \"ShareManager: receiver address is blacklisted\");\n        return super.transfer(to, amount);\n    }\n\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    function addMinter(address pipe) external onlyTimelock {\n        require(pipe != address(0), \"ShareManager: zero address\");\n        grantRole(MINTER_ROLE, pipe);\n    }\n\n    function addBurner(address dst) external onlyTimelock {\n        require(dst != address(0), \"ShareManager: zero address\");\n        grantRole(BURNER_ROLE, dst);\n    }\n\n    function removeMinter(address pipe) external onlyTimelock {\n        revokeRole(MINTER_ROLE, pipe);\n    }\n\n    function removeBurner(address dst) external onlyTimelock {\n        revokeRole(BURNER_ROLE, dst);\n    }\n\n    function addFeeCollector(address feeCollector) external onlyTimelock {\n        require(feeCollector != address(0), \"ShareManager: zero address\");\n        grantRole(FEE_COLLECTOR_ROLE, feeCollector);\n    }\n\n    function removeFeeCollector(address feeCollector) external onlyTimelock {\n        revokeRole(FEE_COLLECTOR_ROLE, feeCollector);\n    }\n\n    function setOVaultComposerMulti(address oVaultComposerMulti, address shareOftAdapter) external onlyTimelock {\n        require(oVaultComposerMulti != address(0), \"ShareManager: zero address\");\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        address oldOVaultComposerMulti = $.oVaultComposerMulti;\n        $.isOperator[oVaultComposerMulti][shareOftAdapter] = true;\n        $.oVaultComposerMulti = oVaultComposerMulti;\n        emit OVaultComposerMultiSet(oldOVaultComposerMulti, oVaultComposerMulti, shareOftAdapter);\n    }\n\n    function setMaxDeposit(uint256 _maxDeposit) external onlyTimelock {\n        require(_maxDeposit > 0, \"ShareManager: zero max deposit\");\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        uint256 oldMaxDeposit = $.maxDeposit;\n        $.maxDeposit = _maxDeposit;\n        emit MaxDepositSet(oldMaxDeposit, _maxDeposit);\n    }\n\n    function setMaxSupply(uint256 _maxSupply) external onlyTimelock {\n        require(_maxSupply > 0, \"ShareManager: zero max supply\");\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        uint256 oldMaxSupply = $.maxSupply;\n        $.maxSupply = _maxSupply;\n        emit MaxSupplySet(oldMaxSupply, _maxSupply);\n    }\n\n    function setMaxWithdraw(uint256 _maxWithdraw) external onlyTimelock {\n        require(_maxWithdraw > 0, \"ShareManager: zero max withdraw\");\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        uint256 oldMaxWithdraw = $.maxWithdraw;\n        $.maxWithdraw = _maxWithdraw;\n        emit MaxWithdrawSet(oldMaxWithdraw, _maxWithdraw);\n    }\n\n    function setBlacklist(address account, bool blacklisted) external onlyRole(SAFE_MANAGER_ROLE) {\n        require(account != address(0), \"ShareManager: zero address\");\n        ShareManagerStorage storage $ = _getShareManagerStorage();\n        require($.blacklisted[account] != blacklisted, \"ShareManager: status unchanged\");\n        $.blacklisted[account] = blacklisted;\n        if (blacklisted) {\n          emit Blacklisted(account);\n        } else {\n          emit Unblacklisted(account);\n        }\n    }\n\n    function isBlacklisted(address account) public view returns (bool) {\n        return _getShareManagerStorage().blacklisted[account];\n    }\n\n    function maxDeposit() public view returns (uint256) {\n        return _getShareManagerStorage().maxDeposit;\n    }\n\n    function maxSupply() public view returns (uint256) {\n        return _getShareManagerStorage().maxSupply;\n    }\n\n    function maxWithdraw() public view returns (uint256) {\n        return _getShareManagerStorage().maxWithdraw;\n    }\n\n    function timeLockController() external view returns (address) {\n        return _getShareManagerStorage().timeLockController;\n    }\n\n    function oVaultComposerMulti() external view returns (address) {\n        return _getShareManagerStorage().oVaultComposerMulti;\n    }\n}\n"
    }
}