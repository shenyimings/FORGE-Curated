{
    "vfp_id": "vfp_00021",
    "project_name": "cantina_aragon_oct2025.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Call _pause() before other initializer settings",
            "description": "In AvKATVault.sol, the _pause() function is called after other initialization steps, including calls that interact with external contracts like escrow.token(). The root cause is the incorrect ordering of initialization logic. If any of these earlier calls trigger a reentrant call to a function that should be paused, it could lead to unintended behavior, although the risk is low due to the controlled context. The impact is a potential edge-case vulnerability during initialization where a reentrant call bypasses expected paused-state protections. To follow secure initialization patterns, _pause() should be called first to ensure the contract starts in a paused state, minimizing the window for reentrancy or unauthorized access.\n",
            "severity": "Informational",
            "location": [
                "AvKATVault.sol#L101"
            ],
            "files": [
                "katana-governance/src/AvKATVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "safeTransferFrom() unecessary to known contracts",
            "description": "The AvKATVault contract uses safeTransferFrom() when transferring NFTs to known and trusted contracts such as itself or designated strategies. While safeTransferFrom() is appropriate for transfers to untrusted or unknown recipients to prevent loss of funds due to non-compliant receivers, it is unnecessary overhead when the recipient is a known contract that correctly implements the ERC721Receiver interface. The root cause is the lack of optimization in transfer logic based on recipient trust context. Although this does not pose a direct security risk, it results in higher gas costs for every transfer. An attacker cannot exploit this, but users bear increased transaction fees. The impact is inefficient gas usage, which affects user experience and transaction cost, especially in frequent operations.\n",
            "severity": "Informational",
            "location": [
                "AvKATVault.sol#L150",
                "AvKATVault.sol#L242"
            ],
            "files": [
                "katana-governance/src/AvKATVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Avoid redundant storage writes",
            "description": "In the _setStrategy() function of AvKATVault.sol, the strategy variable is potentially written to storage twice: once unconditionally and again conditionally. This occurs when the logic first assigns strategy = _strategy and later overwrites it with strategy = defaultStrategy if _strategy is zero. The root cause is inefficient state variable assignment without prior validation. This leads to an avoidable storage write, which increases gas consumption because each storage modification is expensive on the EVM. While this does not introduce a security vulnerability, it represents a suboptimal implementation. The impact is higher transaction costs for governance operations that update the strategy, which could be minimized by consolidating the assignment into a single conditional expression.\n",
            "severity": "Informational",
            "location": [
                "AvKATVault.sol#L340-L344"
            ],
            "files": [
                "katana-governance/src/AvKATVault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ]
            },
            "title": "Ensure no approvals linger unnecessarily",
            "description": "After calling deposit() in the AvKATVault contract, any remaining ERC20 token approvals may persist if not explicitly reset. The root cause is the absence of an approval revocation step after the transfer. While the immediate risk is low if the target is trusted, lingering approvals represent a potential security liability if the approved contract is later compromised or upgraded maliciously. The impact is an increased attack surface for future exploits, where an attacker could drain remaining or newly deposited funds. This is a defensive programming best practice. The recommendation is to call approve(0) after the deposit to eliminate unnecessary allowances, reducing long-term risk.\n",
            "severity": "Informational",
            "location": [
                "AvKATVault.sol#L301-L304"
            ],
            "files": [
                "katana-governance/src/AvKATVault.sol"
            ]
        }
    ],
    "affected_files": {
        "AvKATVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC4626Upgradeable as ERC4626 } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ERC721HolderUpgradeable as ERC721Holder } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { PausableUpgradeable as Pausable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport { SafeERC20Upgradeable as SafeERC20 } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { VotingEscrow, Lock as LockNFT } from \"@setup/GaugeVoterSetup_v1_4_0.sol\";\n\nimport { DaoAuthorizableUpgradeable as DaoAuthorizable } from\n    \"@aragon/osx-commons-contracts/src/permission/auth/DaoAuthorizableUpgradeable.sol\";\nimport { IDAO } from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\n\nimport { IStrategyNFT as IStrategy } from \"src/interfaces/IStrategyNFT.sol\";\nimport { IVaultNFT } from \"src/interfaces/IVaultNFT.sol\";\nimport { console2 as console } from \"forge-std/console2.sol\";\n\ncontract AvKATVault is Initializable, IVaultNFT, ERC721Holder, Pausable, ERC4626, UUPSUpgradeable, DaoAuthorizable {\n    using SafeERC20 for IERC20;\n\n    /// @notice bytes32 identifier for admin role functions.\n    bytes32 public constant VAULT_ADMIN_ROLE = keccak256(\"VAULT_ADMIN_ROLE\");\n\n    /// @notice bytes32 identifier of sweeper that can withdraw mistakenly depositted funds.\n    bytes32 public constant SWEEPER_ROLE = keccak256(\"SWEEPER_ROLE\");\n\n    /// @notice The escrow contract address.\n    VotingEscrow public escrow;\n\n    /// @notice The nft contract that escrow mints in exchange of erc20 tokens.\n    LockNFT public lockNft;\n\n    /// @notice The strategy contract that holds the master token and handles escrow operations.\n    IStrategy public strategy;\n\n    /// @notice The address of default strategy that will handle deposit/withdrawals\n    ///         in case custom strategy is set to zero.\n    IStrategy public defaultStrategy;\n\n    /// The single tokenId that this vault will hold and\n    /// will contain all users' token ids accumulated.\n    uint256 public masterTokenId;\n\n    error MasterTokenNotSet();\n    error SameStrategyNotAllowed();\n    error MinMasterTokenInitAmountTooLow();\n    error DefaultStrategyCannotBeZero();\n\n    event StrategySet(address strategy);\n    event AssetsDonated(uint256 assets);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @param _dao The dao address.\n    /// @param _escrow The escrow contract providing the asset and NFT tokens.\n    /// @param _defaultStrategy The address of default strategy that handles deposit/withdraws\n    ///        In case admin chooses to remove custom strategy.\n    /// @param _name The name of the share token minted by this vault.\n    /// @param _symbol The symbol of the share token minted by this vault.\n    function initialize(\n        address _dao,\n        address _escrow,\n        address _defaultStrategy,\n        string memory _name,\n        string memory _symbol\n    )\n        external\n        initializer\n    {\n        __DaoAuthorizableUpgradeable_init(IDAO(_dao));\n        __ERC20_init(_name, _symbol);\n\n        escrow = VotingEscrow(_escrow);\n\n        __ERC4626_init(IERC20(escrow.token()));\n\n        lockNft = LockNFT(escrow.lockNFT());\n\n        if (_defaultStrategy == address(0)) {\n            revert DefaultStrategyCannotBeZero();\n        }\n\n        // Note: `strategy` is not set here since it should only be assigned\n        // once the master token is initialized.\n        // See `initializeMasterTokenAndStrategy` for details.\n        defaultStrategy = IStrategy(_defaultStrategy);\n\n        // Always start with paused state to ensure that deposits/withdrawals can not occur.\n        // Once `initializeMasterTokenAndStrategy` is called(which fills in vault), it's safer\n        // to unpause at that point to avoid loses with inflation attack situations.\n        _pause();\n    }\n\n    /// @notice Pauses the contract, disallowing deposits/withdrawals.\n    function pause() external auth(VAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract, allowing deposits/withdrawals.\n    function unpause() external auth(VAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /// @inheritdoc IVaultNFT\n    /// @dev Initializes the vault with a master token and strategy. This function:\n    ///      1. Transfers an existing NFT token from sender to become the vault's master token\n    ///      2. Mints vault shares to sender proportional to the token's locked amount\n    ///      3. Sets the strategy (uses defaultStrategy if _strategy is address(0))\n    ///      4. Transfers the master token to the selected strategy for management\n    ///\n    ///      Requirements:\n    ///      - Can only be called once (masterTokenId must be 0)\n    ///      - Token must exist (_tokenId != 0) and be owned/approved by sender\n    ///      - Token's locked amount must meet minimum threshold for security\n    ///      - Caller must have VAULT_ADMIN_ROLE\n    ///\n    ///      After this call, the vault becomes operational and can accept deposits/withdrawals.\n    ///      Until this is called, most vault operations will revert.\n    function initializeMasterTokenAndStrategy(\n        uint256 _tokenId,\n        address _strategy\n    )\n        public\n        virtual\n        auth(VAULT_ADMIN_ROLE)\n    {\n        if (_tokenId == 0) revert TokenIdCannotBeZero();\n        if (masterTokenId != 0) revert MasterTokenAlreadySet();\n\n        // To start vault with non-trivial amount to avoid inflation attack,\n        // require that `_tokenId` contains at least `minMasterTokenInitAmount()`.\n        uint256 assetAmount = _getTokenIdAmount(_tokenId);\n        if (assetAmount < minMasterTokenInitAmount()) {\n            revert MinMasterTokenInitAmountTooLow();\n        }\n\n        uint256 shares = convertToShares(assetAmount);\n\n        // Transfer `_tokenId` from sender and set it to masterTokenId\n        lockNft.safeTransferFrom(msg.sender, address(this), _tokenId);\n        masterTokenId = _tokenId;\n\n        // If _strategy is zero address, it will use default strategy.\n        // This automatically will transfer masterTokenId either\n        // to defaultStrategy or sender's passed strategy.\n        _setStrategy(_strategy);\n\n        // mint shares to the sender.\n        _mint(msg.sender, shares);\n    }\n\n    /// @notice Allows to change a strategy contract.\n    /// @param _strategy The new strategy contract.\n    function setStrategy(address _strategy) public auth(VAULT_ADMIN_ROLE) {\n        _setStrategy(_strategy);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 OVERRIDDEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Delegates to the active strategy which holds the master token\n    ///      and tracks the actual asset amounts.\n    /// @return Total amount of underlying assets managed by the vault.\n    ///         Returns 0 if no strategy is set (vault not initialized),\n    ///         otherwise returns the total locked amount from the strategy's master token.\n    function totalAssets() public view virtual override returns (uint256) {\n        if (address(strategy) == address(0)) {\n            return 0;\n        }\n\n        return strategy.totalAssets();\n    }\n\n    /// @notice Transfer `assets` from caller to Vault, then to Strategy.\n    ///      User must have approved `Vault` for this.\n    function _deposit(\n        address _caller,\n        address _receiver,\n        uint256 _assets,\n        uint256 _shares\n    )\n        internal\n        virtual\n        override\n        whenNotPaused\n    {\n        super._deposit(_caller, _receiver, _assets, _shares);\n\n        // Approve strategy so it can transfer `_assets`.\n        IERC20(asset()).approve(address(strategy), _assets);\n\n        // Strategy handles createLock and merge to masterTokenId\n        strategy.deposit(_assets);\n    }\n\n    /// @notice Overrides withdraw function from ERC4626 to allow\n    ///         custom logic through strategy.\n    function _withdraw(\n        address _caller,\n        address _receiver,\n        address _owner,\n        uint256 _assets,\n        uint256 _shares\n    )\n        internal\n        virtual\n        override\n        whenNotPaused\n    {\n        _withdrawWithTokenId(_caller, _receiver, _owner, _assets, _shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       AvKatVault Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVaultNFT\n    /// @dev Allows deposits even if `_tokenId` is already created in the escrow.\n    ///      Shares are minted based on the amount locked for that tokenId in the escrow.\n    function depositTokenId(uint256 _tokenId, address _receiver) public virtual whenNotPaused returns (uint256) {\n        address sender = _msgSender();\n        uint256 assets = _getTokenIdAmount(_tokenId);\n\n        require(assets <= maxDeposit(_receiver), \"ERC4626: deposit more than max\");\n        uint256 shares = previewDeposit(assets);\n\n        // Transfer NFT directly to strategy (not vault)\n        // Reverts if the caller does not own a veNFT.\n        // If `amount` on tokenId is 0, either merge or withdrawal occurred in which case\n        // `transferFrom` will anyways fail.\n        lockNft.transferFrom(sender, address(strategy), _tokenId);\n\n        // Strategy handles merge to masterTokenId\n        strategy.depositTokenId(_tokenId);\n\n        _mint(_receiver, shares);\n\n        emit Deposit(sender, _receiver, assets, shares);\n        emit TokenIdDepositted(_tokenId, sender);\n\n        return shares;\n    }\n\n    /// @inheritdoc IVaultNFT\n    function withdrawTokenId(\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    )\n        public\n        virtual\n        whenNotPaused\n        returns (uint256 tokenId)\n    {\n        uint256 shares = previewWithdraw(_assets);\n        return _withdrawWithTokenId(_msgSender(), _receiver, _owner, _assets, shares);\n    }\n\n    /// @dev Core withdraw logic that both `_withdraw` and `withdrawTokenId` rely on.\n    function _withdrawWithTokenId(\n        address _caller,\n        address _receiver,\n        address _owner,\n        uint256 _assets,\n        uint256 _shares\n    )\n        internal\n        returns (uint256 tokenId)\n    {\n        if (_caller != _owner) {\n            _spendAllowance(_owner, _caller, _shares);\n        }\n\n        _burn(_owner, _shares);\n\n        // Strategy handles split and transfer to receiver\n        tokenId = strategy.withdraw(_receiver, _assets);\n\n        emit TokenIdWithdrawn(tokenId, _receiver);\n        emit Withdraw(_caller, _receiver, _owner, _assets, _shares);\n    }\n\n    /// @notice Allows to donate the assets only without minting shares.\n    ///         This increases assets causing each share to cost more.\n    /// @param _assets How much to donate.\n    function donate(uint256 _assets) public virtual whenNotPaused {\n        SafeERC20.safeTransferFrom(IERC20(asset()), _msgSender(), address(this), _assets);\n\n        // Approve strategy so it can transfer `_assets`.\n        IERC20(asset()).approve(address(strategy), _assets);\n\n        // Strategy handles createLock and merge to masterTokenId\n        strategy.deposit(_assets);\n\n        emit AssetsDonated(_assets);\n    }\n\n    /// @inheritdoc IVaultNFT\n    function recoverNFT(uint256 _tokenId, address _receiver) external virtual auth(SWEEPER_ROLE) {\n        if (_tokenId == masterTokenId) {\n            revert CannotTransferMasterToken();\n        }\n\n        lockNft.safeTransferFrom(address(this), _receiver, _tokenId);\n\n        emit Sweep(_tokenId, _receiver);\n    }\n\n    /// @inheritdoc IVaultNFT\n    function minMasterTokenInitAmount() public view virtual returns (uint256) {\n        return 1e6;\n    }\n\n    /// @dev Internal function to change the vault's active strategy.\n    ///      1. Sets new strategy (uses defaultStrategy if _strategy is address(0))\n    ///      2. Retrieves master token from old strategy via retireStrategy()\n    ///      3. Transfers master token to new strategy via receiveMasterToken()\n    ///      Requirements:\n    ///      - Master token must be initialized (masterTokenId != 0)\n    ///      - New strategy must be different from current strategy\n    /// @param _strategy Address of the new strategy contract.\n    function _setStrategy(address _strategy) internal virtual {\n        address currentStrategy = address(strategy);\n        if (currentStrategy == _strategy) {\n            revert SameStrategyNotAllowed();\n        }\n\n        // If new strategy being set is zero, use the default one.\n        strategy = defaultStrategy;\n\n        if (_strategy != address(0)) {\n            strategy = IStrategy(_strategy);\n        }\n\n        // If the strategy was set, retire it and get masterTokenId back.\n        if (currentStrategy != address(0)) {\n            IStrategy(currentStrategy).retireStrategy();\n        }\n\n        // strategy can only be set if master token was already initialized.\n        if (masterTokenId == 0) revert MasterTokenNotSet();\n\n        _sendMasterTokenToStrategy();\n\n        emit StrategySet(address(strategy));\n    }\n\n    /// @notice Sends master token to strategy.\n    /// @dev Caller's responsibility to ensure that `strategy` and masterTokenId are both set.\n    function _sendMasterTokenToStrategy() internal virtual {\n        // transfer masterTokenId to new strategy\n        lockNft.safeTransferFrom(address(this), address(strategy), masterTokenId);\n\n        // let new strategy what the master token id is\n        strategy.receiveMasterToken(masterTokenId);\n    }\n\n    /// @notice Returns the amount of ERC20 tokens locked in the escrow for a given token ID.\n    /// @dev The current implementation fetches this information from `escrow`, but can be overridden if needed.\n    /// @param _tokenId The token ID whose locked token balance is being retrieved.\n    function _getTokenIdAmount(uint256 _tokenId) internal view virtual returns (uint256) {\n        return escrow.locked(_tokenId).amount;\n    }\n\n    // =========== Upgrade Related Functions ===========\n    function _authorizeUpgrade(address) internal virtual override auth(VAULT_ADMIN_ROLE) { }\n\n    function implementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Reserved storage space to allow for layout changes in the future.\n    uint256[45] private __gap;\n}\n"
    }
}