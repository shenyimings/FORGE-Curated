{
    "vfp_id": "vfp_00425",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "H1: Deposits denial of service",
            "description": "The migrateToPriorityQueue function in the CSModule contract allows permissionless migration of validator keys into a higher priority queue. The function increments the Community Staking Module (CSM) nonce even if the node operator has no keys to migrate or does not exist. This behavior is a vulnerability because the nonce is used by the Deposit Security Module (DSM) to validate deposit data signatures. An attacker can repeatedly call this function with invalid or non-existent node operator IDs, causing the nonce to increment and invalidate existing DSM signatures. This would prevent new validators from being deposited, resulting in a denial of service for the staking process. The root cause is the lack of validation on the existence and eligibility of the node operator before incrementing the nonce.\n",
            "severity": "High",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#589-614"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "H2: Incorrect enqueued keys accounting",
            "description": "The migrateToPriorityQueue function in CSModule.sol computes the number of keys to migrate and then subtracts that number from the enqueued count as a \"hack\" to ensure correct behavior in the subsequent _enqueueNodeOperatorKeys call. However, this subtraction is not reverted or compensated, and the legacy queue slots remain in place. As a result, the enqueued count becomes inconsistent with the actual number of queue slots, leading to a logic error. This discrepancy can cause an underflow in the QueueLib.clean function or prevent node operators from depositing new keys because the enqueued count appears higher than the depositable count. The root cause is the incorrect accounting due to an unbalanced decrement operation. An attacker can exploit this by calling the function for any node operator with queue slots, breaking the accounting system.\n",
            "severity": "High",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#603-609"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "L2: Depositable count not updated in migrateToPriorityQueue",
            "description": "The migrateToPriorityQueue function uses the depositable count to determine how many keys can be migrated. However, this count may be outdated if the node operator's bond lock has expired or bond curve parameters have changed. Since the function is permissionless, an attacker can call it with an outdated depositable count, resulting in fewer keys being migrated than should be allowed. Because migration can only occur once per node operator, this permanently limits their ability to migrate. The root cause is the reliance on a potentially stale depositable count without first updating it. This is a logic error that can be exploited to harm node operators' operational efficiency.\n",
            "severity": "Low",
            "location": [
                "CSModule.sol::migrateToPriorityQueue",
                "CSModule.sol::_enqueueNodeOperatorKeys#1512-1513"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "L3: Incorrect number of migrated keys",
            "description": "The migrateToPriorityQueue function calculates the number of keys to migrate as min(maxDeposits - deposited, enqueuedCount), subtracts this from enqueuedCount, and passes it to _enqueueNodeOperatorKeys. However, _enqueueNodeOperatorKeys then computes the final number of keys as min(depositable - enqueued, maxKeys), where enqueued is the updated (lower) value. This leads to an incorrect final count because the function uses a stale enqueued value in its logic. The expected behavior is to migrate min(depositable, toMigrate) keys, but the actual behavior results in min(depositable - enqueued + toMigrate, toMigrate), which can be less. The root cause is inconsistent state handling between the two functions, leading to a logic error in key migration.\n",
            "severity": "Low",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#603-610",
                "CSModule.sol::_enqueueNodeOperatorKeys#1512-1513"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "W2: Depositable validators count can be updated on non-existing node operators",
            "description": "The updateDepositableValidatorsCount function in CSModule.sol can be called for non-existing node operators. While the function safely does nothing in such cases, this behavior may not be intended and could lead to unnecessary transactions. The root cause is the lack of a validation check to ensure the node operator exists before attempting to update their depositable count. Although the team acknowledged this as intentional due to backward compatibility and existing safeguards in calling contexts, it represents a logic inconsistency that could confuse external callers or lead to wasted gas.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::updateDepositableValidatorsCount#579-583"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "W3: ValidatorWithdrawalInfo struct contains unused isSlashed field",
            "description": "The ValidatorWithdrawalInfo struct in CSModule.sol contains an isSlashed field that is no longer used in CSM v2. This field was carried over from CSM v1 but is obsolete because slashing reporting during withdrawal proofs has been removed. The presence of unused code increases contract complexity and storage footprint without benefit. The root cause is failure to clean up legacy fields during the upgrade. This is a code quality issue that should be addressed to improve maintainability and reduce potential confusion.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::ValidatorWithdrawalInfo"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "W7: Node operator creation transient flag not cleared",
            "description": "The CSModule contract uses a boolean flag stored in transient storage to track whether a node operator was created within the current transaction. This flag is set during node operator creation but is never cleared afterward. The root cause is the lack of cleanup logic after the flag has served its purpose. An attacker could exploit this by structuring a transaction sequence where a victim creates a node operator, and then an untrusted contract (controlled by the attacker) is called within the same transaction, allowing the attacker to add validator keys to the newly created operator. Alternatively, if the victim’s transaction is bundled with the attacker’s via ERC-4337 and executed first, the attacker can exploit the still-set flag. This leads to unauthorized addition of validator keys, violating intended access control logic and enabling potential abuse of permissioned functionality.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::_isOperatorCreatedInTX#1531"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "W9: submitWithdrawals griefing",
            "description": "The `submitWithdrawals` function in CSModule does not handle edge cases in input array size securely. If an empty array is passed, the module nonce is unnecessarily incremented, potentially leading to a denial of service for future deposit operations that depend on the nonce. Additionally, if multiple withdrawal items are passed, an attacker can front-run the transaction by submitting a withdrawal for one validator, causing the entire transaction to revert and wasting the caller's gas. The root cause is the lack of input validation and improper control flow: the function reverts upon encountering an already-reported validator instead of skipping it. This enables griefing attacks where an attacker can disrupt legitimate operations at low cost, impacting reliability and user experience.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::submitWithdrawals#719"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "I1: Lido and StETH ambiguous naming",
            "description": "The codebase uses inconsistent variable names for the same contract address: `STETH` in CSModule and CSFeeDistributor, while using `LIDO` in CSBondCurve and CSAccounting. This inconsistency stems from differing naming conventions across contracts despite referring to the same underlying contract. The ambiguity can mislead auditors or developers into believing these are different contracts, increasing the risk of errors during code review or integration. Although the functionality remains correct, the lack of naming uniformity reduces code clarity and maintainability. This is a code quality issue that could indirectly contribute to future bugs if assumptions are made based on variable names.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol",
                "CSFeeDistributor.sol",
                "CSBondCurve.sol",
                "CSAccounting.sol"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSFeeDistributor.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/abstract/CSBondCurve.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSAccounting.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "I2: Typos",
            "description": "Multiple typographical errors were found in the codebase: \"internals\" instead of \"intervals\", \"Invariat\" instead of \"Invariant\", and \"kes\" instead of \"keys\". These typos appear in comments and parameter documentation, such as in ICSBondCurve's interface documentation, CSModule's invariant comment, and SigningKeys' function parameters. While these do not affect runtime behavior, they reduce code readability and professionalism. Misleading or incorrect comments can confuse developers and auditors, especially when relying on documentation to understand complex logic. The root cause is insufficient code review or lack of automated linting for comments.\n",
            "severity": "Informational",
            "location": [
                "ICSBondCurve.sol#10",
                "CSModule.sol#1402",
                "SigningKeys.sol#165"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/interfaces/ICSBondCurve.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "I3: Inconsistent unchecked use in CSBondCurve",
            "description": "The CSBondCurve contract inconsistently applies the `unchecked` block around out-of-bounds checks for `curveId`. Functions `_getCurveInfo` and `_updateBondCurve` perform bounds checks outside of `unchecked`, while `_setBondCurve` wraps the same type of check inside an `unchecked` block. This inconsistency suggests a lack of clear coding standards. Although all checks correctly revert on invalid input, the mixed usage may confuse reviewers about the intent—whether overflow is expected or not. The issue does not introduce runtime risks but affects code maintainability and clarity. Uniform application of `unchecked` is recommended to reflect intentional design choices.\n",
            "severity": "Informational",
            "location": [
                "CSBondCurve.sol::_getCurveInfo#248",
                "CSBondCurve.sol::_updateBondCurve#114",
                "CSBondCurve.sol::_setBondCurve#134"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/abstract/CSBondCurve.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "I4: Unused code",
            "description": "The codebase contains unused elements: the error `InvalidBondCurveMaxLength` in ICSBondCurve.sol and the modifier `whenPaused` and function `_pauseUntil` in PausableUntil.sol. These artifacts are not referenced anywhere in the code, making them dead code. While some were removed (e.g., the unused error), others were retained for future use. Unused code increases complexity, reduces readability, and may mislead developers into thinking functionality is active. Although the team decided to keep some for forward compatibility, their presence still constitutes a code quality concern and should be well-documented to avoid confusion.\n",
            "severity": "Informational",
            "location": [
                "ICSBondCurve.sol",
                "PausableUntil.sol"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/interfaces/ICSBondCurve.sol"
            ]
        }
    ],
    "affected_files": {
        "CSAccounting.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\n\nimport { CSBondCore } from \"./abstract/CSBondCore.sol\";\nimport { CSBondCurve } from \"./abstract/CSBondCurve.sol\";\nimport { CSBondLock } from \"./abstract/CSBondLock.sol\";\nimport { AssetRecoverer } from \"./abstract/AssetRecoverer.sol\";\n\nimport { PausableUntil } from \"./lib/utils/PausableUntil.sol\";\nimport { AssetRecovererLib } from \"./lib/AssetRecovererLib.sol\";\n\nimport { IStakingModule } from \"./interfaces/IStakingModule.sol\";\nimport { ICSModule, NodeOperatorManagementProperties } from \"./interfaces/ICSModule.sol\";\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSFeeDistributor } from \"./interfaces/ICSFeeDistributor.sol\";\n\n/// @author vgorkavenko\n/// @notice This contract stores the Node Operators' bonds in the form of stETH shares,\n///         so it should be considered in the recovery process\ncontract CSAccounting is\n    ICSAccounting,\n    CSBondCore,\n    CSBondCurve,\n    CSBondLock,\n    PausableUntil,\n    AccessControlEnumerableUpgradeable,\n    AssetRecoverer\n{\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n    bytes32 public constant MANAGE_BOND_CURVES_ROLE =\n        keccak256(\"MANAGE_BOND_CURVES_ROLE\");\n    bytes32 public constant SET_BOND_CURVE_ROLE =\n        keccak256(\"SET_BOND_CURVE_ROLE\");\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n\n    ICSModule public immutable MODULE;\n    ICSFeeDistributor public immutable FEE_DISTRIBUTOR;\n    /// @dev DEPRECATED\n    /// @custom:oz-renamed-from feeDistributor\n    ICSFeeDistributor internal _feeDistributorOld;\n    address public chargePenaltyRecipient;\n\n    modifier onlyModule() {\n        if (msg.sender != address(MODULE)) {\n            revert SenderIsNotModule();\n        }\n\n        _;\n    }\n\n    /// @param lidoLocator Lido locator contract address\n    /// @param module Community Staking Module contract address\n    /// @param minBondLockPeriod Min time in seconds for the bondLock period\n    /// @param maxBondLockPeriod Max time in seconds for the bondLock period\n    constructor(\n        address lidoLocator,\n        address module,\n        address _feeDistributor,\n        uint256 minBondLockPeriod,\n        uint256 maxBondLockPeriod\n    ) CSBondCore(lidoLocator) CSBondLock(minBondLockPeriod, maxBondLockPeriod) {\n        if (module == address(0)) {\n            revert ZeroModuleAddress();\n        }\n        if (_feeDistributor == address(0)) {\n            revert ZeroFeeDistributorAddress();\n        }\n\n        MODULE = ICSModule(module);\n        FEE_DISTRIBUTOR = ICSFeeDistributor(_feeDistributor);\n\n        _disableInitializers();\n    }\n\n    /// @param bondCurve Initial bond curve\n    /// @param admin Admin role member address\n    /// @param bondLockPeriod Bond lock period in seconds\n    /// @param _chargePenaltyRecipient Recipient of the charge penalty type\n    function initialize(\n        BondCurveIntervalInput[] calldata bondCurve,\n        address admin,\n        uint256 bondLockPeriod,\n        address _chargePenaltyRecipient\n    ) external reinitializer(2) {\n        __AccessControlEnumerable_init();\n        __CSBondCurve_init(bondCurve);\n        __CSBondLock_init(bondLockPeriod);\n\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n        _setChargePenaltyRecipient(_chargePenaltyRecipient);\n\n        LIDO.approve(address(WSTETH), type(uint256).max);\n        LIDO.approve(address(WITHDRAWAL_QUEUE), type(uint256).max);\n        LIDO.approve(LIDO_LOCATOR.burner(), type(uint256).max);\n    }\n\n    function finalizeUpgradeV2(\n        BondCurveIntervalInput[][] calldata bondCurvesInputs\n    ) external reinitializer(2) {\n        assembly (\"memory-safe\") {\n            sstore(_feeDistributorOld.slot, 0x00)\n        }\n\n        // NOTE: This method is not for adding new bond curves, but for migration of the existing ones to the new format (`BondCurve` to `BondCurveInterval[]`). However, bond values can be different from the current.\n        if (bondCurvesInputs.length != _getLegacyBondCurvesLength()) {\n            revert InvalidBondCurvesLength();\n        }\n\n        // NOTE: Re-init `CSBondCurve` due to the new format. Contains a check that the first added curve id is `DEFAULT_BOND_CURVE_ID`\n        __CSBondCurve_init(bondCurvesInputs[0]);\n        for (uint256 i = 1; i < bondCurvesInputs.length; ++i) {\n            _addBondCurve(bondCurvesInputs[i]);\n        }\n    }\n\n    /// @inheritdoc ICSAccounting\n    function resume() external onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /// @inheritdoc ICSAccounting\n    function pauseFor(uint256 duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(duration);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function setChargePenaltyRecipient(\n        address _chargePenaltyRecipient\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setChargePenaltyRecipient(_chargePenaltyRecipient);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function setBondLockPeriod(\n        uint256 period\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        CSBondLock._setBondLockPeriod(period);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function addBondCurve(\n        BondCurveIntervalInput[] calldata bondCurve\n    ) external onlyRole(MANAGE_BOND_CURVES_ROLE) returns (uint256 id) {\n        id = CSBondCurve._addBondCurve(bondCurve);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function updateBondCurve(\n        uint256 curveId,\n        BondCurveIntervalInput[] calldata bondCurve\n    ) external onlyRole(MANAGE_BOND_CURVES_ROLE) {\n        CSBondCurve._updateBondCurve(curveId, bondCurve);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function setBondCurve(\n        uint256 nodeOperatorId,\n        uint256 curveId\n    ) external onlyRole(SET_BOND_CURVE_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        CSBondCurve._setBondCurve(nodeOperatorId, curveId);\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function depositETH(\n        address from,\n        uint256 nodeOperatorId\n    ) external payable whenResumed onlyModule {\n        CSBondCore._depositETH(from, nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function depositETH(uint256 nodeOperatorId) external payable whenResumed {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        CSBondCore._depositETH(msg.sender, nodeOperatorId);\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function depositStETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 stETHAmount,\n        PermitInput calldata permit\n    ) external whenResumed onlyModule {\n        _unwrapStETHPermitIfRequired(from, permit);\n        CSBondCore._depositStETH(from, nodeOperatorId, stETHAmount);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function depositStETH(\n        uint256 nodeOperatorId,\n        uint256 stETHAmount,\n        PermitInput calldata permit\n    ) external whenResumed {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        _unwrapStETHPermitIfRequired(msg.sender, permit);\n        CSBondCore._depositStETH(msg.sender, nodeOperatorId, stETHAmount);\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function depositWstETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 wstETHAmount,\n        PermitInput calldata permit\n    ) external whenResumed onlyModule {\n        _unwrapWstETHPermitIfRequired(from, permit);\n        CSBondCore._depositWstETH(from, nodeOperatorId, wstETHAmount);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function depositWstETH(\n        uint256 nodeOperatorId,\n        uint256 wstETHAmount,\n        PermitInput calldata permit\n    ) external whenResumed {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        _unwrapWstETHPermitIfRequired(msg.sender, permit);\n        CSBondCore._depositWstETH(msg.sender, nodeOperatorId, wstETHAmount);\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function claimRewardsStETH(\n        uint256 nodeOperatorId,\n        uint256 stETHAmount,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata rewardsProof\n    ) external whenResumed returns (uint256 claimedShares) {\n        NodeOperatorManagementProperties memory no = MODULE\n            .getNodeOperatorManagementProperties(nodeOperatorId);\n        _onlyNodeOperatorManagerOrRewardAddresses(no);\n\n        if (rewardsProof.length != 0) {\n            _pullFeeRewards(nodeOperatorId, cumulativeFeeShares, rewardsProof);\n        }\n        claimedShares = CSBondCore._claimStETH(\n            nodeOperatorId,\n            stETHAmount,\n            no.rewardAddress\n        );\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function claimRewardsWstETH(\n        uint256 nodeOperatorId,\n        uint256 wstETHAmount,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata rewardsProof\n    ) external whenResumed returns (uint256 claimedWstETH) {\n        NodeOperatorManagementProperties memory no = MODULE\n            .getNodeOperatorManagementProperties(nodeOperatorId);\n        _onlyNodeOperatorManagerOrRewardAddresses(no);\n\n        if (rewardsProof.length != 0) {\n            _pullFeeRewards(nodeOperatorId, cumulativeFeeShares, rewardsProof);\n        }\n        claimedWstETH = CSBondCore._claimWstETH(\n            nodeOperatorId,\n            wstETHAmount,\n            no.rewardAddress\n        );\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function claimRewardsUnstETH(\n        uint256 nodeOperatorId,\n        uint256 stETHAmount,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata rewardsProof\n    ) external whenResumed returns (uint256 requestId) {\n        NodeOperatorManagementProperties memory no = MODULE\n            .getNodeOperatorManagementProperties(nodeOperatorId);\n        _onlyNodeOperatorManagerOrRewardAddresses(no);\n\n        if (rewardsProof.length != 0) {\n            _pullFeeRewards(nodeOperatorId, cumulativeFeeShares, rewardsProof);\n        }\n        requestId = CSBondCore._claimUnstETH(\n            nodeOperatorId,\n            stETHAmount,\n            no.rewardAddress\n        );\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function lockBondETH(\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) external onlyModule {\n        CSBondLock._lock(nodeOperatorId, amount);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function releaseLockedBondETH(\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) external onlyModule {\n        CSBondLock._reduceAmount(nodeOperatorId, amount);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function compensateLockedBondETH(\n        uint256 nodeOperatorId\n    ) external payable onlyModule {\n        (bool success, ) = LIDO_LOCATOR.elRewardsVault().call{\n            value: msg.value\n        }(\"\");\n        if (!success) {\n            revert ElRewardsVaultReceiveFailed();\n        }\n\n        CSBondLock._reduceAmount(nodeOperatorId, msg.value);\n        emit BondLockCompensated(nodeOperatorId, msg.value);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function settleLockedBondETH(\n        uint256 nodeOperatorId\n    ) external onlyModule returns (bool applied) {\n        applied = false;\n\n        uint256 lockedAmount = CSBondLock.getActualLockedBond(nodeOperatorId);\n        if (lockedAmount > 0) {\n            CSBondCore._burn(nodeOperatorId, lockedAmount);\n            // reduce all locked bond even if bond isn't covered lock fully\n            CSBondLock._remove(nodeOperatorId);\n            applied = true;\n        }\n    }\n\n    /// @inheritdoc ICSAccounting\n    function penalize(\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) external onlyModule {\n        CSBondCore._burn(nodeOperatorId, amount);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function chargeFee(\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) external onlyModule {\n        CSBondCore._charge(nodeOperatorId, amount, chargePenaltyRecipient);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function pullFeeRewards(\n        uint256 nodeOperatorId,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata rewardsProof\n    ) external {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        _pullFeeRewards(nodeOperatorId, cumulativeFeeShares, rewardsProof);\n        MODULE.updateDepositableValidatorsCount(nodeOperatorId);\n    }\n\n    /// @inheritdoc AssetRecoverer\n    function recoverERC20(address token, uint256 amount) external override {\n        _onlyRecoverer();\n        if (token == address(LIDO)) {\n            revert NotAllowedToRecover();\n        }\n        AssetRecovererLib.recoverERC20(token, amount);\n    }\n\n    /// @notice Recover all stETH shares from the contract\n    /// @dev Accounts for the bond funds stored during recovery\n    function recoverStETHShares() external {\n        _onlyRecoverer();\n        uint256 shares = LIDO.sharesOf(address(this)) - totalBondShares();\n        AssetRecovererLib.recoverStETHShares(address(LIDO), shares);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function renewBurnerAllowance() external {\n        LIDO.approve(LIDO_LOCATOR.burner(), type(uint256).max);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getBondSummary(\n        uint256 nodeOperatorId\n    ) external view returns (uint256 current, uint256 required) {\n        current = CSBondCore.getBond(nodeOperatorId);\n        required = _getRequiredBond(nodeOperatorId, 0);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getUnbondedKeysCount(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        return\n            _getUnbondedKeysCount({\n                nodeOperatorId: nodeOperatorId,\n                includeLockedBond: true\n            });\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getUnbondedKeysCountToEject(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        return\n            _getUnbondedKeysCount({\n                nodeOperatorId: nodeOperatorId,\n                includeLockedBond: false\n            });\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getBondAmountByKeysCountWstETH(\n        uint256 keysCount,\n        uint256 curveId\n    ) external view returns (uint256) {\n        return\n            _sharesByEth(\n                CSBondCurve.getBondAmountByKeysCount(keysCount, curveId)\n            );\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getRequiredBondForNextKeysWstETH(\n        uint256 nodeOperatorId,\n        uint256 additionalKeys\n    ) external view returns (uint256) {\n        return\n            _sharesByEth(\n                getRequiredBondForNextKeys(nodeOperatorId, additionalKeys)\n            );\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getClaimableBondShares(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        return _getClaimableBondShares(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getClaimableRewardsAndBondShares(\n        uint256 nodeOperatorId,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata rewardsProof\n    ) external view returns (uint256 claimableShares) {\n        uint256 feesToDistribute = FEE_DISTRIBUTOR.getFeesToDistribute(\n            nodeOperatorId,\n            cumulativeFeeShares,\n            rewardsProof\n        );\n\n        (uint256 current, uint256 required) = getBondSummaryShares(\n            nodeOperatorId\n        );\n        current = current + feesToDistribute;\n\n        return current > required ? current - required : 0;\n    }\n\n    /// @dev TODO: Remove in the next major release\n    /// @inheritdoc ICSAccounting\n    function feeDistributor() external view returns (ICSFeeDistributor) {\n        return FEE_DISTRIBUTOR;\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getBondSummaryShares(\n        uint256 nodeOperatorId\n    ) public view returns (uint256 current, uint256 required) {\n        current = CSBondCore.getBondShares(nodeOperatorId);\n        required = _getRequiredBondShares(nodeOperatorId, 0);\n    }\n\n    /// @inheritdoc ICSAccounting\n    function getRequiredBondForNextKeys(\n        uint256 nodeOperatorId,\n        uint256 additionalKeys\n    ) public view returns (uint256) {\n        uint256 current = CSBondCore.getBond(nodeOperatorId);\n        uint256 totalRequired = _getRequiredBond(\n            nodeOperatorId,\n            additionalKeys\n        );\n\n        unchecked {\n            return totalRequired > current ? totalRequired - current : 0;\n        }\n    }\n\n    function _pullFeeRewards(\n        uint256 nodeOperatorId,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata rewardsProof\n    ) internal {\n        uint256 distributed = FEE_DISTRIBUTOR.distributeFees(\n            nodeOperatorId,\n            cumulativeFeeShares,\n            rewardsProof\n        );\n        CSBondCore._increaseBond(nodeOperatorId, distributed);\n    }\n\n    function _unwrapStETHPermitIfRequired(\n        address from,\n        PermitInput calldata permit\n    ) internal {\n        if (\n            permit.value > 0 &&\n            LIDO.allowance(from, address(this)) < permit.value\n        ) {\n            LIDO.permit({\n                owner: from,\n                spender: address(this),\n                value: permit.value,\n                deadline: permit.deadline,\n                v: permit.v,\n                r: permit.r,\n                s: permit.s\n            });\n        }\n    }\n\n    function _unwrapWstETHPermitIfRequired(\n        address from,\n        PermitInput calldata permit\n    ) internal {\n        if (\n            permit.value > 0 &&\n            WSTETH.allowance(from, address(this)) < permit.value\n        ) {\n            WSTETH.permit({\n                owner: from,\n                spender: address(this),\n                value: permit.value,\n                deadline: permit.deadline,\n                v: permit.v,\n                r: permit.r,\n                s: permit.s\n            });\n        }\n    }\n\n    /// @dev Overrides the original implementation to account for a locked bond and withdrawn validators\n    function _getClaimableBondShares(\n        uint256 nodeOperatorId\n    ) internal view override returns (uint256) {\n        unchecked {\n            (\n                uint256 currentShares,\n                uint256 requiredShares\n            ) = getBondSummaryShares(nodeOperatorId);\n            return\n                currentShares > requiredShares\n                    ? currentShares - requiredShares\n                    : 0;\n        }\n    }\n\n    function _getRequiredBond(\n        uint256 nodeOperatorId,\n        uint256 additionalKeys\n    ) internal view returns (uint256) {\n        uint256 curveId = CSBondCurve.getBondCurveId(nodeOperatorId);\n        uint256 nonWithdrawnKeys = MODULE.getNodeOperatorNonWithdrawnKeys(\n            nodeOperatorId\n        );\n        uint256 requiredBondForKeys = CSBondCurve.getBondAmountByKeysCount(\n            nonWithdrawnKeys + additionalKeys,\n            curveId\n        );\n        uint256 actualLockedBond = CSBondLock.getActualLockedBond(\n            nodeOperatorId\n        );\n\n        return requiredBondForKeys + actualLockedBond;\n    }\n\n    function _getRequiredBondShares(\n        uint256 nodeOperatorId,\n        uint256 additionalKeys\n    ) internal view returns (uint256) {\n        return _sharesByEth(_getRequiredBond(nodeOperatorId, additionalKeys));\n    }\n\n    /// @dev Unbonded stands for the amount of keys not fully covered with bond\n    function _getUnbondedKeysCount(\n        uint256 nodeOperatorId,\n        bool includeLockedBond\n    ) internal view returns (uint256) {\n        uint256 nonWithdrawnKeys = MODULE.getNodeOperatorNonWithdrawnKeys(\n            nodeOperatorId\n        );\n        unchecked {\n            uint256 currentBond = CSBondCore.getBond(nodeOperatorId);\n            if (includeLockedBond) {\n                uint256 lockedBond = CSBondLock.getActualLockedBond(\n                    nodeOperatorId\n                );\n                // We use strict condition here since in rare case of equality the outcome of the function will not change\n                if (lockedBond > currentBond) {\n                    return nonWithdrawnKeys;\n                }\n\n                currentBond -= lockedBond;\n            }\n            // 10 wei is added to account for possible stETH rounding errors\n            // https://github.com/lidofinance/lido-dao/issues/442#issuecomment-1182264205.\n            // Should be sufficient for ~ 40 years\n            uint256 bondedKeys = CSBondCurve.getKeysCountByBondAmount(\n                currentBond + 10 wei,\n                CSBondCurve.getBondCurveId(nodeOperatorId)\n            );\n            return\n                nonWithdrawnKeys > bondedKeys\n                    ? nonWithdrawnKeys - bondedKeys\n                    : 0;\n        }\n    }\n\n    function _onlyRecoverer() internal view override {\n        _checkRole(RECOVERER_ROLE);\n    }\n\n    function _onlyExistingNodeOperator(uint256 nodeOperatorId) internal view {\n        if (\n            nodeOperatorId <\n            IStakingModule(address(MODULE)).getNodeOperatorsCount()\n        ) {\n            return;\n        }\n\n        revert NodeOperatorDoesNotExist();\n    }\n\n    function _onlyNodeOperatorManagerOrRewardAddresses(\n        NodeOperatorManagementProperties memory no\n    ) internal view {\n        if (no.managerAddress == address(0)) {\n            revert NodeOperatorDoesNotExist();\n        }\n\n        if (no.managerAddress == msg.sender || no.rewardAddress == msg.sender) {\n            return;\n        }\n\n        revert SenderIsNotEligible();\n    }\n\n    function _setChargePenaltyRecipient(\n        address _chargePenaltyRecipient\n    ) private {\n        if (_chargePenaltyRecipient == address(0)) {\n            revert ZeroChargePenaltyRecipientAddress();\n        }\n        chargePenaltyRecipient = _chargePenaltyRecipient;\n        emit ChargePenaltyRecipientSet(_chargePenaltyRecipient);\n    }\n}\n",
        "CSBondCurve.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { ICSBondCurve } from \"../interfaces/ICSBondCurve.sol\";\n\n/// @dev Bond curve mechanics abstract contract\n///\n/// It gives the ability to build bond curves for flexible bond math.\n/// There is a default bond curve for all Node Operators, which might be 'overridden' for a particular Node Operator.\n///\n/// It contains:\n///  - add bond curve\n///  - get bond curve info\n///  - set default bond curve\n///  - set bond curve for the given Node Operator\n///  - get bond curve for the given Node Operator\n///  - get required bond amount for the given keys count\n///  - get keys count for the given bond amount\n///\n/// It should be inherited by a module contract or a module-related contract.\n/// Internal non-view methods should be used in the Module contract with additional requirements (if any).\n///\n/// @author vgorkavenko\nabstract contract CSBondCurve is ICSBondCurve, Initializable {\n    /// @custom:storage-location erc7201:CSBondCurve\n    struct CSBondCurveStorage {\n        /// @dev DEPRECATED. DO NOT USE. Preserves storage layout.\n        bytes32[] legacyBondCurves;\n        /// @dev Mapping of Node Operator id to bond curve id\n        mapping(uint256 nodeOperatorId => uint256 bondCurveId) operatorBondCurveId;\n        BondCurve[] bondCurves;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"CSBondCurve\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant CS_BOND_CURVE_STORAGE_LOCATION =\n        0x8f22e270e477f5becb8793b61d439ab7ae990ed8eba045eb72061c0e6cfe1500;\n\n    uint256 public constant MIN_CURVE_LENGTH = 1;\n    uint256 public constant DEFAULT_BOND_CURVE_ID = 0;\n    uint256 public constant MAX_CURVE_LENGTH = 100;\n\n    // @inheritdoc ICSBondCurve\n    function getCurvesCount() external view returns (uint256) {\n        return _getCSBondCurveStorage().bondCurves.length;\n    }\n\n    /// @inheritdoc ICSBondCurve\n    function getCurveInfo(\n        uint256 curveId\n    ) external view returns (BondCurve memory) {\n        return _getCurveInfo(curveId);\n    }\n\n    /// @inheritdoc ICSBondCurve\n    function getBondCurve(\n        uint256 nodeOperatorId\n    ) external view returns (BondCurve memory) {\n        return _getCurveInfo(getBondCurveId(nodeOperatorId));\n    }\n\n    /// @inheritdoc ICSBondCurve\n    function getBondCurveId(\n        uint256 nodeOperatorId\n    ) public view returns (uint256) {\n        return _getCSBondCurveStorage().operatorBondCurveId[nodeOperatorId];\n    }\n\n    /// @inheritdoc ICSBondCurve\n    function getBondAmountByKeysCount(\n        uint256 keys,\n        uint256 curveId\n    ) public view returns (uint256) {\n        return _getBondAmountByKeysCount(keys, _getCurveInfo(curveId));\n    }\n\n    /// @inheritdoc ICSBondCurve\n    function getKeysCountByBondAmount(\n        uint256 amount,\n        uint256 curveId\n    ) public view returns (uint256) {\n        return _getKeysCountByBondAmount(amount, _getCurveInfo(curveId));\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __CSBondCurve_init(\n        BondCurveIntervalInput[] calldata defaultBondCurveIntervals\n    ) internal onlyInitializing {\n        uint256 addedId = _addBondCurve(defaultBondCurveIntervals);\n        if (addedId != DEFAULT_BOND_CURVE_ID) {\n            revert InvalidInitializationCurveId();\n        }\n    }\n\n    /// @dev Add a new bond curve to the array\n    function _addBondCurve(\n        BondCurveIntervalInput[] calldata intervals\n    ) internal returns (uint256 curveId) {\n        CSBondCurveStorage storage $ = _getCSBondCurveStorage();\n\n        _checkBondCurve(intervals);\n\n        curveId = $.bondCurves.length;\n        _addIntervalsToBondCurve($.bondCurves.push(), intervals);\n\n        emit BondCurveAdded(curveId, intervals);\n    }\n\n    /// @dev Update existing bond curve\n    // TODO: add fuzzing tests for 5 calls with the same curveId\n    function _updateBondCurve(\n        uint256 curveId,\n        BondCurveIntervalInput[] calldata intervals\n    ) internal {\n        CSBondCurveStorage storage $ = _getCSBondCurveStorage();\n        if (curveId > $.bondCurves.length - 1) {\n            revert InvalidBondCurveId();\n        }\n\n        _checkBondCurve(intervals);\n\n        delete $.bondCurves[curveId];\n\n        _addIntervalsToBondCurve($.bondCurves[curveId], intervals);\n\n        emit BondCurveUpdated(curveId, intervals);\n    }\n\n    /// @dev Sets bond curve for the given Node Operator\n    ///      It will be used for the Node Operator instead of the previously set curve\n    function _setBondCurve(uint256 nodeOperatorId, uint256 curveId) internal {\n        CSBondCurveStorage storage $ = _getCSBondCurveStorage();\n        unchecked {\n            if (curveId > $.bondCurves.length - 1) {\n                revert InvalidBondCurveId();\n            }\n        }\n        $.operatorBondCurveId[nodeOperatorId] = curveId;\n        emit BondCurveSet(nodeOperatorId, curveId);\n    }\n\n    function _getBondAmountByKeysCount(\n        uint256 keys,\n        BondCurve storage curve\n    ) internal view returns (uint256) {\n        BondCurveInterval[] storage intervals = curve.intervals;\n        if (keys == 0) {\n            return 0;\n        }\n\n        unchecked {\n            uint256 low = 0;\n            uint256 high = intervals.length - 1;\n            while (low < high) {\n                uint256 mid = (low + high + 1) / 2;\n                if (keys < intervals[mid].minKeysCount) {\n                    high = mid - 1;\n                } else {\n                    low = mid;\n                }\n            }\n            BondCurveInterval storage interval = intervals[low];\n            return\n                interval.minBond +\n                (keys - interval.minKeysCount) *\n                interval.trend;\n        }\n    }\n\n    function _getKeysCountByBondAmount(\n        uint256 amount,\n        BondCurve storage curve\n    ) internal view returns (uint256) {\n        BondCurveInterval[] storage intervals = curve.intervals;\n\n        // intervals[0].minBond is essentially the amount of bond required for the very first key\n        if (amount < intervals[0].minBond) {\n            return 0;\n        }\n\n        unchecked {\n            uint256 low = 0;\n            uint256 high = intervals.length - 1;\n            while (low < high) {\n                uint256 mid = (low + high + 1) / 2;\n                if (amount < intervals[mid].minBond) {\n                    high = mid - 1;\n                } else {\n                    low = mid;\n                }\n            }\n\n            BondCurveInterval storage interval;\n\n            //\n            // Imagine we have:\n            //  Interval 0: minKeysCount = 1, minBond = 2 ETH, trend = 2 ETH\n            //  Interval 1: minKeysCount = 4, minBond = 9 ETH, trend = 3 ETH (more expensive than Interval 0)\n            //  Amount = 8.5 ETH\n            // In this case low = 0, and if we count the keys count using data from Interval 0 we will get 4 keys, which is wrong.\n            // So we need a special check for bond amounts between Interval 0 maxBond and Interval 1 minBond.\n            //\n            if (low < intervals.length - 1) {\n                interval = intervals[low + 1];\n                if (amount > interval.minBond - interval.trend) {\n                    return interval.minKeysCount - 1;\n                }\n            }\n            interval = intervals[low];\n            return\n                interval.minKeysCount +\n                (amount - interval.minBond) /\n                interval.trend;\n        }\n    }\n\n    // Deprecated. To be removed in the next upgrade\n    function _getLegacyBondCurvesLength() internal view returns (uint256) {\n        return _getCSBondCurveStorage().legacyBondCurves.length;\n    }\n\n    function _addIntervalsToBondCurve(\n        BondCurve storage bondCurve,\n        BondCurveIntervalInput[] calldata intervals\n    ) private {\n        BondCurveInterval storage interval = bondCurve.intervals.push();\n\n        interval.minKeysCount = intervals[0].minKeysCount;\n        interval.trend = intervals[0].trend;\n        interval.minBond = intervals[0].trend;\n\n        for (uint256 i = 1; i < intervals.length; ++i) {\n            BondCurveInterval storage prev = interval;\n            interval = bondCurve.intervals.push();\n            interval.minKeysCount = intervals[i].minKeysCount;\n            interval.trend = intervals[i].trend;\n            interval.minBond =\n                intervals[i].trend +\n                prev.minBond +\n                (intervals[i].minKeysCount - prev.minKeysCount - 1) *\n                prev.trend;\n        }\n    }\n\n    function _getCurveInfo(\n        uint256 curveId\n    ) private view returns (BondCurve storage) {\n        CSBondCurveStorage storage $ = _getCSBondCurveStorage();\n        if (curveId > $.bondCurves.length - 1) {\n            revert InvalidBondCurveId();\n        }\n\n        return $.bondCurves[curveId];\n    }\n\n    function _checkBondCurve(\n        BondCurveIntervalInput[] calldata intervals\n    ) private pure {\n        if (\n            intervals.length < MIN_CURVE_LENGTH ||\n            intervals.length > MAX_CURVE_LENGTH\n        ) {\n            revert InvalidBondCurveLength();\n        }\n\n        if (intervals[0].minKeysCount != 1) {\n            revert InvalidBondCurveValues();\n        }\n\n        if (intervals[0].trend == 0) {\n            revert InvalidBondCurveValues();\n        }\n\n        for (uint256 i = 1; i < intervals.length; ++i) {\n            unchecked {\n                if (\n                    intervals[i].minKeysCount <= intervals[i - 1].minKeysCount\n                ) {\n                    revert InvalidBondCurveValues();\n                }\n                if (intervals[i].trend == 0) {\n                    revert InvalidBondCurveValues();\n                }\n            }\n        }\n    }\n\n    function _getCSBondCurveStorage()\n        private\n        pure\n        returns (CSBondCurveStorage storage $)\n    {\n        assembly {\n            $.slot := CS_BOND_CURVE_STORAGE_LOCATION\n        }\n    }\n}\n",
        "ICSBondCurve.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\ninterface ICSBondCurve {\n    /// @dev Bond curve structure.\n    ///\n    /// It contains:\n    ///  - internals    |> intervals-based representation of the bond curve\n    ///\n    /// The interval is defined by:\n    ///  - minKeysCount |> minimum keys count (inclusive) of the interval\n    ///  - minBond      |> minimum bond amount (inclusive) of the interval\n    ///  - trend        |> trend of the bond amount in the interval\n    ///\n    /// For example, how the curve intervals look like:\n    ///   Interval 0: minKeysCount = 1, minBond = 2 ETH, trend = 2 ETH\n    ///   Interval 1: minKeysCount = 2, minBond = 3.9 ETH, trend = 1.9 ETH\n    ///   Interval 2: minKeysCount = 3, minBond = 5.7 ETH, trend = 1.8 ETH\n    ///\n    ///   Bond Amount (ETH)\n    ///       ^\n    ///       |\n    ///     6 -\n    ///       | ------------------ 5.7 ETH --> .\n    ///   5.5 -                              ..^\n    ///       |                             .  |\n    ///     5 -                            .   |\n    ///       |                           .    |\n    ///   4.5 -                          .     |\n    ///       |                         .      |\n    ///     4 -                       ..       |\n    ///       | ------- 3.9 ETH --> ..         |\n    ///   3.5 -                    .^          |\n    ///       |                  .. |          |\n    ///     3 -                ..   |          |\n    ///       |               .     |          |\n    ///   2.5 -              .      |          |\n    ///       |            ..       |          |\n    ///     2 - -------->..         |          |\n    ///       |          ^          |          |\n    ///       |----------|----------|----------|----------|----> Keys Count\n    ///       |          1          2          3          i\n    ///\n    struct BondCurve {\n        BondCurveInterval[] intervals;\n    }\n\n    struct BondCurveInterval {\n        uint256 minKeysCount;\n        uint256 minBond;\n        uint256 trend;\n    }\n\n    struct BondCurveIntervalInput {\n        uint256 minKeysCount;\n        uint256 trend;\n    }\n\n    event BondCurveAdded(\n        uint256 indexed curveId,\n        BondCurveIntervalInput[] bondCurveIntervals\n    );\n    event BondCurveUpdated(\n        uint256 indexed curveId,\n        BondCurveIntervalInput[] bondCurveIntervals\n    );\n    event BondCurveSet(uint256 indexed nodeOperatorId, uint256 curveId);\n\n    error InvalidBondCurveLength();\n    error InvalidBondCurveMaxLength();\n    error InvalidBondCurveValues();\n    error InvalidBondCurveId();\n    error InvalidInitializationCurveId();\n\n    function MIN_CURVE_LENGTH() external view returns (uint256);\n\n    function MAX_CURVE_LENGTH() external view returns (uint256);\n\n    function DEFAULT_BOND_CURVE_ID() external view returns (uint256);\n\n    /// @notice Get the number of available curves\n    /// @return Number of available curves\n    function getCurvesCount() external view returns (uint256);\n\n    /// @notice Return bond curve for the given curve id\n    /// @param curveId Curve id to get bond curve for\n    /// @return Bond curve\n    /// @dev Reverts if `curveId` is invalid\n    function getCurveInfo(\n        uint256 curveId\n    ) external view returns (BondCurve memory);\n\n    /// @notice Get bond curve for the given Node Operator\n    /// @param nodeOperatorId ID of the Node Operator\n    /// @return Bond curve\n    function getBondCurve(\n        uint256 nodeOperatorId\n    ) external view returns (BondCurve memory);\n\n    /// @notice Get bond curve ID for the given Node Operator\n    /// @param nodeOperatorId ID of the Node Operator\n    /// @return Bond curve ID\n    function getBondCurveId(\n        uint256 nodeOperatorId\n    ) external view returns (uint256);\n\n    /// @notice Get required bond in ETH for the given number of keys for default bond curve\n    /// @dev To calculate the amount for the new keys 2 calls are required:\n    ///      getBondAmountByKeysCount(newTotal) - getBondAmountByKeysCount(currentTotal)\n    /// @param keys Number of keys to get required bond for\n    /// @param curveId Id of the curve to perform calculations against\n    /// @return Amount for particular keys count\n    function getBondAmountByKeysCount(\n        uint256 keys,\n        uint256 curveId\n    ) external view returns (uint256);\n\n    /// @notice Get keys count for the given bond amount with default bond curve\n    /// @param amount Bond amount in ETH (stETH)to get keys count for\n    /// @param curveId Id of the curve to perform calculations against\n    /// @return Keys count\n    function getKeysCountByBondAmount(\n        uint256 amount,\n        uint256 curveId\n    ) external view returns (uint256);\n}\n",
        "CSFeeDistributor.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { AssetRecoverer } from \"./abstract/AssetRecoverer.sol\";\n\nimport { AssetRecovererLib } from \"./lib/AssetRecovererLib.sol\";\n\nimport { ICSFeeDistributor } from \"./interfaces/ICSFeeDistributor.sol\";\nimport { IStETH } from \"./interfaces/IStETH.sol\";\n\n/// @author madlabman\ncontract CSFeeDistributor is\n    ICSFeeDistributor,\n    Initializable,\n    AccessControlEnumerableUpgradeable,\n    AssetRecoverer\n{\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n\n    IStETH public immutable STETH;\n    address public immutable ACCOUNTING;\n    address public immutable ORACLE;\n\n    /// @notice The latest Merkle Tree root\n    bytes32 public treeRoot;\n\n    /// @notice CID of the last published Merkle tree\n    string public treeCid;\n\n    /// @notice CID of the file with log for the last frame reported\n    string public logCid;\n\n    /// @notice Amount of stETH shares sent to the Accounting in favor of the NO\n    mapping(uint256 nodeOperatorId => uint256 distributed)\n        public distributedShares;\n\n    /// @notice Total Amount of stETH shares available for claiming by NOs\n    uint256 public totalClaimableShares;\n\n    /// @notice Array of the distribution data history\n    mapping(uint256 index => DistributionData)\n        internal _distributionDataHistory;\n\n    /// @notice The number of _distributionDataHistory records\n    uint256 public distributionDataHistoryCount;\n\n    /// @notice The address to transfer rebate to\n    address public rebateRecipient;\n\n    modifier onlyAccounting() {\n        if (msg.sender != ACCOUNTING) {\n            revert SenderIsNotAccounting();\n        }\n\n        _;\n    }\n\n    modifier onlyOracle() {\n        if (msg.sender != ORACLE) {\n            revert SenderIsNotOracle();\n        }\n\n        _;\n    }\n\n    constructor(address stETH, address accounting, address oracle) {\n        if (accounting == address(0)) {\n            revert ZeroAccountingAddress();\n        }\n        if (oracle == address(0)) {\n            revert ZeroOracleAddress();\n        }\n\n        if (stETH == address(0)) {\n            revert ZeroStEthAddress();\n        }\n\n        ACCOUNTING = accounting;\n        STETH = IStETH(stETH);\n        ORACLE = oracle;\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        address admin,\n        address _rebateRecipient\n    ) external reinitializer(2) {\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        _setRebateRecipient(_rebateRecipient);\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    function finalizeUpgradeV2(\n        address _rebateRecipient\n    ) external reinitializer(2) {\n        _setRebateRecipient(_rebateRecipient);\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function setRebateRecipient(\n        address _rebateRecipient\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRebateRecipient(_rebateRecipient);\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function distributeFees(\n        uint256 nodeOperatorId,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata proof\n    ) external onlyAccounting returns (uint256 sharesToDistribute) {\n        sharesToDistribute = getFeesToDistribute(\n            nodeOperatorId,\n            cumulativeFeeShares,\n            proof\n        );\n\n        if (sharesToDistribute == 0) {\n            return 0;\n        }\n\n        if (totalClaimableShares < sharesToDistribute) {\n            revert NotEnoughShares();\n        }\n\n        unchecked {\n            totalClaimableShares -= sharesToDistribute;\n            distributedShares[nodeOperatorId] += sharesToDistribute;\n        }\n\n        STETH.transferShares(ACCOUNTING, sharesToDistribute);\n        emit OperatorFeeDistributed(nodeOperatorId, sharesToDistribute);\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function processOracleReport(\n        bytes32 _treeRoot,\n        string calldata _treeCid,\n        string calldata _logCid,\n        uint256 distributed,\n        uint256 rebate,\n        uint256 refSlot\n    ) external onlyOracle {\n        if (\n            totalClaimableShares + distributed + rebate >\n            STETH.sharesOf(address(this))\n        ) {\n            revert InvalidShares();\n        }\n\n        if (distributed == 0 && rebate > 0) {\n            revert InvalidReportData();\n        }\n\n        if (distributed > 0) {\n            if (bytes(_treeCid).length == 0) {\n                revert InvalidTreeCid();\n            }\n            if (keccak256(bytes(_treeCid)) == keccak256(bytes(treeCid))) {\n                revert InvalidTreeCid();\n            }\n\n            if (_treeRoot == bytes32(0)) {\n                revert InvalidTreeRoot();\n            }\n            if (_treeRoot == treeRoot) {\n                revert InvalidTreeRoot();\n            }\n\n            // Doesn't overflow because of the very first check.\n            unchecked {\n                totalClaimableShares += distributed;\n            }\n\n            treeRoot = _treeRoot;\n            treeCid = _treeCid;\n\n            emit DistributionDataUpdated(\n                totalClaimableShares,\n                _treeRoot,\n                _treeCid\n            );\n        }\n\n        emit ModuleFeeDistributed(distributed);\n\n        if (rebate > 0) {\n            STETH.transferShares(rebateRecipient, rebate);\n            emit RebateTransferred(rebate);\n        }\n\n        // NOTE: Make sure off-chain tooling provides a distinct CID of a log even for empty reports, e.g. by mixing\n        // in a frame identifier such as reference slot to a file.\n        if (bytes(_logCid).length == 0) {\n            revert InvalidLogCID();\n        }\n        if (keccak256(bytes(_logCid)) == keccak256(bytes(logCid))) {\n            revert InvalidLogCID();\n        }\n\n        logCid = _logCid;\n        emit DistributionLogUpdated(_logCid);\n\n        _distributionDataHistory[\n            distributionDataHistoryCount\n        ] = DistributionData({\n            refSlot: refSlot,\n            treeRoot: treeRoot,\n            treeCid: treeCid,\n            logCid: _logCid,\n            distributed: distributed,\n            rebate: rebate\n        });\n\n        unchecked {\n            ++distributionDataHistoryCount;\n        }\n    }\n\n    /// @inheritdoc AssetRecoverer\n    function recoverERC20(address token, uint256 amount) external override {\n        _onlyRecoverer();\n        if (token == address(STETH)) {\n            revert NotAllowedToRecover();\n        }\n        AssetRecovererLib.recoverERC20(token, amount);\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function pendingSharesToDistribute() external view returns (uint256) {\n        return STETH.sharesOf(address(this)) - totalClaimableShares;\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function getHistoricalDistributionData(\n        uint256 index\n    ) external view returns (DistributionData memory) {\n        return _distributionDataHistory[index];\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function getFeesToDistribute(\n        uint256 nodeOperatorId,\n        uint256 cumulativeFeeShares,\n        bytes32[] calldata proof\n    ) public view returns (uint256 sharesToDistribute) {\n        // NOTE: We reject empty proofs to separate two business logic paths on the level of\n        // CSAccounting.sol (see _pullFeeRewards function invocations) with and without a proof.\n        if (proof.length == 0) {\n            revert InvalidProof();\n        }\n\n        bool isValid = MerkleProof.verifyCalldata(\n            proof,\n            treeRoot,\n            hashLeaf(nodeOperatorId, cumulativeFeeShares)\n        );\n        if (!isValid) {\n            revert InvalidProof();\n        }\n\n        uint256 _distributedShares = distributedShares[nodeOperatorId];\n        if (_distributedShares > cumulativeFeeShares) {\n            // This error means the fee oracle brought invalid data.\n            revert FeeSharesDecrease();\n        }\n\n        unchecked {\n            sharesToDistribute = cumulativeFeeShares - _distributedShares;\n        }\n    }\n\n    /// @inheritdoc ICSFeeDistributor\n    function hashLeaf(\n        uint256 nodeOperatorId,\n        uint256 shares\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                bytes.concat(keccak256(abi.encode(nodeOperatorId, shares)))\n            );\n    }\n\n    function _setRebateRecipient(address _rebateRecipient) internal {\n        if (_rebateRecipient == address(0)) {\n            revert ZeroRebateRecipientAddress();\n        }\n\n        rebateRecipient = _rebateRecipient;\n        emit RebateRecipientSet(_rebateRecipient);\n    }\n\n    function _onlyRecoverer() internal view override {\n        _checkRole(RECOVERER_ROLE);\n    }\n}\n",
        "CSModule.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { AssetRecoverer } from \"./abstract/AssetRecoverer.sol\";\n\nimport { IStakingModule } from \"./interfaces/IStakingModule.sol\";\nimport { ILidoLocator } from \"./interfaces/ILidoLocator.sol\";\nimport { IStETH } from \"./interfaces/IStETH.sol\";\nimport { ICSParametersRegistry } from \"./interfaces/ICSParametersRegistry.sol\";\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSExitPenalties } from \"./interfaces/ICSExitPenalties.sol\";\nimport { ICSModule, NodeOperator, NodeOperatorManagementProperties, ValidatorWithdrawalInfo } from \"./interfaces/ICSModule.sol\";\nimport { ExitPenaltyInfo } from \"./interfaces/ICSExitPenalties.sol\";\n\nimport { PausableUntil } from \"./lib/utils/PausableUntil.sol\";\nimport { QueueLib, Batch } from \"./lib/QueueLib.sol\";\nimport { ValidatorCountsReport } from \"./lib/ValidatorCountsReport.sol\";\nimport { NOAddresses } from \"./lib/NOAddresses.sol\";\nimport { TransientUintUintMap, TransientUintUintMapLib } from \"./lib/TransientUintUintMapLib.sol\";\nimport { SigningKeys } from \"./lib/SigningKeys.sol\";\n\ncontract CSModule is\n    ICSModule,\n    Initializable,\n    AccessControlEnumerableUpgradeable,\n    PausableUntil,\n    AssetRecoverer\n{\n    using QueueLib for QueueLib.Queue;\n\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n    bytes32 public constant STAKING_ROUTER_ROLE =\n        keccak256(\"STAKING_ROUTER_ROLE\");\n    bytes32 public constant REPORT_EL_REWARDS_STEALING_PENALTY_ROLE =\n        keccak256(\"REPORT_EL_REWARDS_STEALING_PENALTY_ROLE\");\n    bytes32 public constant SETTLE_EL_REWARDS_STEALING_PENALTY_ROLE =\n        keccak256(\"SETTLE_EL_REWARDS_STEALING_PENALTY_ROLE\");\n    bytes32 public constant VERIFIER_ROLE = keccak256(\"VERIFIER_ROLE\");\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n    bytes32 public constant CREATE_NODE_OPERATOR_ROLE =\n        keccak256(\"CREATE_NODE_OPERATOR_ROLE\");\n\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n    // @dev see IStakingModule.sol\n    uint8 private constant FORCED_TARGET_LIMIT_MODE_ID = 2;\n    // keccak256(abi.encode(uint256(keccak256(\"OPERATORS_CREATED_IN_TX_MAP_TSLOT\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OPERATORS_CREATED_IN_TX_MAP_TSLOT =\n        0x1b07bc0838fdc4254cbabb5dd0c94d936f872c6758547168d513d8ad1dc3a500;\n\n    bytes32 private immutable MODULE_TYPE;\n    ILidoLocator public immutable LIDO_LOCATOR;\n    IStETH public immutable STETH;\n    ICSParametersRegistry public immutable PARAMETERS_REGISTRY;\n    ICSAccounting public immutable ACCOUNTING;\n    ICSExitPenalties public immutable EXIT_PENALTIES;\n    address public immutable FEE_DISTRIBUTOR;\n\n    /// @dev QUEUE_LOWEST_PRIORITY identifies the range of available priorities: [0; QUEUE_LOWEST_PRIORITY].\n    uint256 public immutable QUEUE_LOWEST_PRIORITY;\n    /// @dev QUEUE_LEGACY_PRIORITY is the priority for the CSM v1 queue.\n    uint256 public immutable QUEUE_LEGACY_PRIORITY;\n\n    ////////////////////////\n    // State variables below\n    ////////////////////////\n\n    /// @custom:oz-renamed-from keyRemovalCharge\n    /// @custom:oz-retyped-from uint256\n    mapping(uint256 queuePriority => QueueLib.Queue queue)\n        internal _queueByPriority;\n\n    /// @dev Legacy queue (priority=QUEUE_LEGACY_PRIORITY), that should be removed in the future once there are no more batches in it.\n    /// @custom:oz-renamed-from depositQueue\n    QueueLib.Queue internal _legacyQueue;\n\n    /// @dev Unused. Nullified in the finalizeUpgradeV2\n    /// @custom:oz-renamed-from accounting\n    ICSAccounting internal _accountingOld;\n\n    /// @dev Unused. Nullified in the finalizeUpgradeV2\n    /// @custom:oz-renamed-from earlyAdoption\n    address internal _earlyAdoption;\n    /// @dev deprecated. Nullified in the finalizeUpgradeV2\n    /// @custom:oz-renamed-from publicRelease\n    bool internal _publicRelease;\n\n    uint256 private _nonce;\n    mapping(uint256 => NodeOperator) private _nodeOperators;\n    /// @dev see _keyPointer function for details of noKeyIndexPacked structure\n    mapping(uint256 noKeyIndexPacked => bool) private _isValidatorWithdrawn;\n    /// @dev DEPRECATED! No writes expected after CSM v2\n    mapping(uint256 noKeyIndexPacked => bool) private _isValidatorSlashed;\n\n    uint64 private _totalDepositedValidators;\n    uint64 private _totalExitedValidators;\n    uint64 private _depositableValidatorsCount;\n    uint64 private _nodeOperatorsCount;\n\n    constructor(\n        bytes32 moduleType,\n        address lidoLocator,\n        address parametersRegistry,\n        address _accounting,\n        address exitPenalties\n    ) {\n        if (lidoLocator == address(0)) {\n            revert ZeroLocatorAddress();\n        }\n\n        if (parametersRegistry == address(0)) {\n            revert ZeroParametersRegistryAddress();\n        }\n\n        if (_accounting == address(0)) {\n            revert ZeroAccountingAddress();\n        }\n\n        if (exitPenalties == address(0)) {\n            revert ZeroExitPenaltiesAddress();\n        }\n\n        MODULE_TYPE = moduleType;\n        LIDO_LOCATOR = ILidoLocator(lidoLocator);\n        STETH = IStETH(LIDO_LOCATOR.lido());\n        PARAMETERS_REGISTRY = ICSParametersRegistry(parametersRegistry);\n        QUEUE_LOWEST_PRIORITY = PARAMETERS_REGISTRY.QUEUE_LOWEST_PRIORITY();\n        QUEUE_LEGACY_PRIORITY = PARAMETERS_REGISTRY.QUEUE_LEGACY_PRIORITY();\n        ACCOUNTING = ICSAccounting(_accounting);\n        EXIT_PENALTIES = ICSExitPenalties(exitPenalties);\n        FEE_DISTRIBUTOR = address(ACCOUNTING.feeDistributor());\n\n        _disableInitializers();\n    }\n\n    /// @notice initialize the module from scratch\n    function initialize(address admin) external reinitializer(2) {\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(STAKING_ROUTER_ROLE, address(LIDO_LOCATOR.stakingRouter()));\n\n        // CSM is on pause initially and should be resumed during the vote\n        _pauseFor(PausableUntil.PAUSE_INFINITELY);\n    }\n\n    /// @dev should be called after update on the proxy\n    function finalizeUpgradeV2() external reinitializer(2) {\n        assembly (\"memory-safe\") {\n            sstore(_queueByPriority.slot, 0x00)\n            sstore(_earlyAdoption.slot, 0x00)\n            sstore(_accountingOld.slot, 0x00)\n        }\n    }\n\n    /// @inheritdoc ICSModule\n    function resume() external onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /// @inheritdoc ICSModule\n    function pauseFor(uint256 duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(duration);\n    }\n\n    /// @inheritdoc ICSModule\n    function createNodeOperator(\n        address from,\n        NodeOperatorManagementProperties calldata managementProperties,\n        address referrer\n    )\n        external\n        onlyRole(CREATE_NODE_OPERATOR_ROLE)\n        whenResumed\n        returns (uint256 nodeOperatorId)\n    {\n        if (from == address(0)) {\n            revert ZeroSenderAddress();\n        }\n\n        nodeOperatorId = _nodeOperatorsCount;\n        _markOperatorIsCreatedInTX(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        address managerAddress = managementProperties.managerAddress ==\n            address(0)\n            ? from\n            : managementProperties.managerAddress;\n        address rewardAddress = managementProperties.rewardAddress == address(0)\n            ? from\n            : managementProperties.rewardAddress;\n        no.managerAddress = managerAddress;\n        no.rewardAddress = rewardAddress;\n        if (managementProperties.extendedManagerPermissions) {\n            no.extendedManagerPermissions = true;\n        }\n\n        unchecked {\n            ++_nodeOperatorsCount;\n        }\n\n        emit NodeOperatorAdded(\n            nodeOperatorId,\n            managerAddress,\n            rewardAddress,\n            managementProperties.extendedManagerPermissions\n        );\n\n        if (referrer != address(0)) {\n            emit ReferrerSet(nodeOperatorId, referrer);\n        }\n\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function addValidatorKeysETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures\n    ) external payable whenResumed {\n        _checkCanAddKeys(nodeOperatorId, from);\n\n        if (\n            msg.value <\n            accounting().getRequiredBondForNextKeys(nodeOperatorId, keysCount)\n        ) {\n            revert InvalidAmount();\n        }\n\n        if (msg.value != 0) {\n            accounting().depositETH{ value: msg.value }(from, nodeOperatorId);\n        }\n\n        _addKeysAndUpdateDepositableValidatorsCount(\n            nodeOperatorId,\n            keysCount,\n            publicKeys,\n            signatures\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function addValidatorKeysStETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        ICSAccounting.PermitInput calldata permit\n    ) external whenResumed {\n        _checkCanAddKeys(nodeOperatorId, from);\n\n        uint256 amount = accounting().getRequiredBondForNextKeys(\n            nodeOperatorId,\n            keysCount\n        );\n\n        if (amount != 0) {\n            accounting().depositStETH(from, nodeOperatorId, amount, permit);\n        }\n\n        _addKeysAndUpdateDepositableValidatorsCount(\n            nodeOperatorId,\n            keysCount,\n            publicKeys,\n            signatures\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function addValidatorKeysWstETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        ICSAccounting.PermitInput calldata permit\n    ) external whenResumed {\n        _checkCanAddKeys(nodeOperatorId, from);\n\n        uint256 amount = accounting().getRequiredBondForNextKeysWstETH(\n            nodeOperatorId,\n            keysCount\n        );\n\n        if (amount != 0) {\n            accounting().depositWstETH(from, nodeOperatorId, amount, permit);\n        }\n\n        _addKeysAndUpdateDepositableValidatorsCount(\n            nodeOperatorId,\n            keysCount,\n            publicKeys,\n            signatures\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function proposeNodeOperatorManagerAddressChange(\n        uint256 nodeOperatorId,\n        address proposedAddress\n    ) external {\n        NOAddresses.proposeNodeOperatorManagerAddressChange(\n            _nodeOperators,\n            nodeOperatorId,\n            proposedAddress\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function confirmNodeOperatorManagerAddressChange(\n        uint256 nodeOperatorId\n    ) external {\n        NOAddresses.confirmNodeOperatorManagerAddressChange(\n            _nodeOperators,\n            nodeOperatorId\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function proposeNodeOperatorRewardAddressChange(\n        uint256 nodeOperatorId,\n        address proposedAddress\n    ) external {\n        NOAddresses.proposeNodeOperatorRewardAddressChange(\n            _nodeOperators,\n            nodeOperatorId,\n            proposedAddress\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function confirmNodeOperatorRewardAddressChange(\n        uint256 nodeOperatorId\n    ) external {\n        NOAddresses.confirmNodeOperatorRewardAddressChange(\n            _nodeOperators,\n            nodeOperatorId\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function resetNodeOperatorManagerAddress(uint256 nodeOperatorId) external {\n        NOAddresses.resetNodeOperatorManagerAddress(\n            _nodeOperators,\n            nodeOperatorId\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function changeNodeOperatorRewardAddress(\n        uint256 nodeOperatorId,\n        address newAddress\n    ) external {\n        NOAddresses.changeNodeOperatorRewardAddress(\n            _nodeOperators,\n            nodeOperatorId,\n            newAddress\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @dev Passes through the minted stETH shares to the fee distributor\n    function onRewardsMinted(\n        uint256 totalShares\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        STETH.transferShares(FEE_DISTRIBUTOR, totalShares);\n    }\n\n    /// @inheritdoc IStakingModule\n    function updateExitedValidatorsCount(\n        bytes calldata nodeOperatorIds,\n        bytes calldata exitedValidatorsCounts\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        uint256 operatorsInReport = ValidatorCountsReport.safeCountOperators(\n            nodeOperatorIds,\n            exitedValidatorsCounts\n        );\n\n        for (uint256 i = 0; i < operatorsInReport; ++i) {\n            (\n                uint256 nodeOperatorId,\n                uint256 exitedValidatorsCount\n            ) = ValidatorCountsReport.next(\n                    nodeOperatorIds,\n                    exitedValidatorsCounts,\n                    i\n                );\n            _updateExitedValidatorsCount({\n                nodeOperatorId: nodeOperatorId,\n                exitedValidatorsCount: exitedValidatorsCount,\n                allowDecrease: false\n            });\n        }\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    function updateTargetValidatorsLimits(\n        uint256 nodeOperatorId,\n        uint256 targetLimitMode,\n        uint256 targetLimit\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        if (targetLimitMode > FORCED_TARGET_LIMIT_MODE_ID) {\n            revert InvalidInput();\n        }\n        if (targetLimit > type(uint32).max) {\n            revert InvalidInput();\n        }\n        _onlyExistingNodeOperator(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        if (targetLimitMode == 0) {\n            targetLimit = 0;\n        }\n\n        // NOTE: Bytecode saving trick; increased gas cost in rare cases is fine.\n        // if (\n        //     no.targetLimitMode == targetLimitMode &&\n        //     no.targetLimit == targetLimit\n        // ) {\n        //     return;\n        // }\n\n        // @dev No need to safe cast due to conditions above\n        no.targetLimitMode = uint8(targetLimitMode);\n        no.targetLimit = uint32(targetLimit);\n\n        emit TargetValidatorsCountChanged(\n            nodeOperatorId,\n            targetLimitMode,\n            targetLimit\n        );\n\n        // Nonce will be updated below even if depositable count was not changed\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: false\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @dev This method is not used in CSM, hence it is do nothing\n    /// @dev NOTE: No role checks because of empty body to save bytecode.\n    function onExitedAndStuckValidatorsCountsUpdated() external {\n        // solhint-disable-previous-line no-empty-blocks\n        // Nothing to do, rewards are distributed by a performance oracle.\n    }\n\n    /// @inheritdoc IStakingModule\n    function unsafeUpdateValidatorsCount(\n        uint256 nodeOperatorId,\n        uint256 exitedValidatorsKeysCount\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        _updateExitedValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            exitedValidatorsCount: exitedValidatorsKeysCount,\n            allowDecrease: true\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    function decreaseVettedSigningKeysCount(\n        bytes calldata nodeOperatorIds,\n        bytes calldata vettedSigningKeysCounts\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        uint256 operatorsInReport = ValidatorCountsReport.safeCountOperators(\n            nodeOperatorIds,\n            vettedSigningKeysCounts\n        );\n\n        for (uint256 i = 0; i < operatorsInReport; ++i) {\n            (\n                uint256 nodeOperatorId,\n                uint256 vettedSigningKeysCount\n            ) = ValidatorCountsReport.next(\n                    nodeOperatorIds,\n                    vettedSigningKeysCounts,\n                    i\n                );\n\n            _onlyExistingNodeOperator(nodeOperatorId);\n\n            NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n            if (vettedSigningKeysCount >= no.totalVettedKeys) {\n                revert InvalidVetKeysPointer();\n            }\n\n            if (vettedSigningKeysCount < no.totalDepositedKeys) {\n                revert InvalidVetKeysPointer();\n            }\n\n            // @dev No need to safe cast due to conditions above\n            no.totalVettedKeys = uint32(vettedSigningKeysCount);\n            emit VettedSigningKeysCountChanged(\n                nodeOperatorId,\n                vettedSigningKeysCount\n            );\n\n            // @dev separate event for intentional decrease from Staking Router\n            emit VettedSigningKeysCountDecreased(nodeOperatorId);\n\n            // Nonce will be updated below once\n            _updateDepositableValidatorsCount({\n                nodeOperatorId: nodeOperatorId,\n                incrementNonceIfUpdated: false\n            });\n        }\n\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function removeKeys(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) external {\n        _onlyNodeOperatorManager(nodeOperatorId, msg.sender);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        if (startIndex < no.totalDepositedKeys) {\n            revert SigningKeysInvalidOffset();\n        }\n\n        // solhint-disable-next-line func-named-parameters\n        uint256 newTotalSigningKeys = SigningKeys.removeKeysSigs(\n            nodeOperatorId,\n            startIndex,\n            keysCount,\n            no.totalAddedKeys\n        );\n\n        // The Node Operator is charged for the every removed key. It's motivated by the fact that the DAO should cleanup\n        // the queue from the empty batches related to the Node Operator. It's possible to have multiple batches with only one\n        // key in it, so it means the DAO should be able to cover removal costs for as much batches as keys removed in this case.\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        uint256 amountToCharge = PARAMETERS_REGISTRY.getKeyRemovalCharge(\n            curveId\n        ) * keysCount;\n        if (amountToCharge != 0) {\n            accounting().chargeFee(nodeOperatorId, amountToCharge);\n            emit KeyRemovalChargeApplied(nodeOperatorId);\n        }\n\n        // @dev No need to safe cast due to checks in the func above\n        no.totalAddedKeys = uint32(newTotalSigningKeys);\n        emit TotalSigningKeysCountChanged(nodeOperatorId, newTotalSigningKeys);\n\n        // @dev No need to safe cast due to checks in the func above\n        no.totalVettedKeys = uint32(newTotalSigningKeys);\n        emit VettedSigningKeysCountChanged(nodeOperatorId, newTotalSigningKeys);\n\n        // Nonce is updated below due to keys state change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: false\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function updateDepositableValidatorsCount(uint256 nodeOperatorId) external {\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @dev TODO: Remove the method in the next major release.\n    /// @inheritdoc ICSModule\n    function migrateToPriorityQueue(uint256 nodeOperatorId) external {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        if (no.usedPriorityQueue) {\n            revert PriorityQueueAlreadyUsed();\n        }\n\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        (uint32 priority, uint32 maxDeposits) = PARAMETERS_REGISTRY\n            .getQueueConfig(curveId);\n\n        if (priority < QUEUE_LEGACY_PRIORITY) {\n            uint32 deposited = no.totalDepositedKeys;\n\n            if (maxDeposits > deposited) {\n                uint32 toMigrate = uint32(\n                    Math.min(maxDeposits - deposited, no.enqueuedCount)\n                );\n\n                unchecked {\n                    no.enqueuedCount -= toMigrate;\n                }\n                _enqueueNodeOperatorKeys(nodeOperatorId, priority, toMigrate);\n            }\n\n            no.usedPriorityQueue = true;\n        }\n        _incrementModuleNonce();\n\n        // An alternative version to fit into the bytecode requirements is below. Please consider\n        // the described caveat of the approach.\n\n        // NOTE: We allow a node operator (NO) to reset their enqueued counter to zero only once to\n        // migrate their keys from the legacy queue to a priority queue, if any. As a downside, the\n        // node operator effectively can have their seats doubled in the queue.\n        // Let's say we have a priority queue with a maximum of 10 deposits. Imagine a NO has 20\n        // keys queued in the legacy queue. Then, the NO calls this method and gets their enqueued\n        // counter reset to zero. As a result, the module will place 10 keys into the priority queue\n        // and 10 more keys at the end of the overall queue. The original batches are kept in the\n        // queue, so in total, the NO will have batches with 40 keys queued altogether.\n        // _nodeOperators[nodeOperatorId].enqueuedCount = 0;\n        // _enqueueNodeOperatorKeys(nodeOperatorId);\n    }\n\n    /// @inheritdoc ICSModule\n    function reportELRewardsStealingPenalty(\n        uint256 nodeOperatorId,\n        bytes32 blockHash,\n        uint256 amount\n    ) external onlyRole(REPORT_EL_REWARDS_STEALING_PENALTY_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        if (amount == 0) {\n            revert InvalidAmount();\n        }\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        uint256 additionalFine = PARAMETERS_REGISTRY\n            .getElRewardsStealingAdditionalFine(curveId);\n        accounting().lockBondETH(nodeOperatorId, amount + additionalFine);\n\n        emit ELRewardsStealingPenaltyReported(\n            nodeOperatorId,\n            blockHash,\n            amount\n        );\n\n        // Nonce should be updated if depositableValidators change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @inheritdoc ICSModule\n    function cancelELRewardsStealingPenalty(\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) external onlyRole(REPORT_EL_REWARDS_STEALING_PENALTY_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        accounting().releaseLockedBondETH(nodeOperatorId, amount);\n\n        emit ELRewardsStealingPenaltyCancelled(nodeOperatorId, amount);\n\n        // Nonce should be updated if depositableValidators change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @inheritdoc ICSModule\n    function settleELRewardsStealingPenalty(\n        uint256[] calldata nodeOperatorIds\n    ) external onlyRole(SETTLE_EL_REWARDS_STEALING_PENALTY_ROLE) {\n        for (uint256 i; i < nodeOperatorIds.length; ++i) {\n            uint256 nodeOperatorId = nodeOperatorIds[i];\n            _onlyExistingNodeOperator(nodeOperatorId);\n\n            // Settled amount might be zero either if the lock expired, or the bond is zero so we\n            // need to check if the penalty was applied.\n            bool applied = accounting().settleLockedBondETH(nodeOperatorId);\n            if (applied) {\n                emit ELRewardsStealingPenaltySettled(nodeOperatorId);\n\n                // Nonce should be updated if depositableValidators change\n                _updateDepositableValidatorsCount({\n                    nodeOperatorId: nodeOperatorId,\n                    incrementNonceIfUpdated: true\n                });\n            }\n        }\n    }\n\n    /// @inheritdoc ICSModule\n    function compensateELRewardsStealingPenalty(\n        uint256 nodeOperatorId\n    ) external payable {\n        _onlyNodeOperatorManager(nodeOperatorId, msg.sender);\n        accounting().compensateLockedBondETH{ value: msg.value }(\n            nodeOperatorId\n        );\n\n        emit ELRewardsStealingPenaltyCompensated(nodeOperatorId, msg.value);\n\n        // Nonce should be updated if depositableValidators change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: true\n        });\n    }\n\n    /// @inheritdoc ICSModule\n    function submitWithdrawals(\n        ValidatorWithdrawalInfo[] calldata withdrawalsInfo\n    ) external onlyRole(VERIFIER_ROLE) {\n        for (uint256 i; i < withdrawalsInfo.length; ++i) {\n            ValidatorWithdrawalInfo memory withdrawalInfo = withdrawalsInfo[i];\n\n            _onlyExistingNodeOperator(withdrawalInfo.nodeOperatorId);\n            NodeOperator storage no = _nodeOperators[\n                withdrawalInfo.nodeOperatorId\n            ];\n\n            if (withdrawalInfo.keyIndex >= no.totalDepositedKeys) {\n                revert SigningKeysInvalidOffset();\n            }\n\n            uint256 pointer = _keyPointer(\n                withdrawalInfo.nodeOperatorId,\n                withdrawalInfo.keyIndex\n            );\n            if (_isValidatorWithdrawn[pointer]) {\n                revert AlreadyWithdrawn();\n            }\n\n            _isValidatorWithdrawn[pointer] = true;\n            unchecked {\n                ++no.totalWithdrawnKeys;\n            }\n\n            bytes memory pubkey = SigningKeys.loadKeys(\n                withdrawalInfo.nodeOperatorId,\n                withdrawalInfo.keyIndex,\n                1\n            );\n\n            emit WithdrawalSubmitted(\n                withdrawalInfo.nodeOperatorId,\n                withdrawalInfo.keyIndex,\n                withdrawalInfo.amount,\n                pubkey\n            );\n\n            // It is safe to use unchecked for penalty sum, due to it's limited to uint248 in the\n            // structure.\n            uint256 penaltySum;\n            bool chargeWithdrawalRequestFee;\n\n            ExitPenaltyInfo memory exitPenaltyInfo = EXIT_PENALTIES\n                .getExitPenaltyInfo(withdrawalInfo.nodeOperatorId, pubkey);\n            if (exitPenaltyInfo.delayPenalty.isValue) {\n                unchecked {\n                    penaltySum += exitPenaltyInfo.delayPenalty.value;\n                }\n                chargeWithdrawalRequestFee = true;\n            }\n            if (exitPenaltyInfo.strikesPenalty.isValue) {\n                unchecked {\n                    penaltySum += exitPenaltyInfo.strikesPenalty.value;\n                }\n                chargeWithdrawalRequestFee = true;\n            }\n            // The withdrawal request fee is taken only if the penalty is applied if no penalty, the\n            // fee has been paid by the node operator on the withdrawal trigger, or it is the DAO\n            // decision to withdraw the validator before that the withdrawal request becomes\n            // delayed.\n            if (\n                chargeWithdrawalRequestFee &&\n                exitPenaltyInfo.withdrawalRequestFee.value != 0\n            ) {\n                accounting().chargeFee(\n                    withdrawalInfo.nodeOperatorId,\n                    exitPenaltyInfo.withdrawalRequestFee.value\n                );\n            }\n\n            if (DEPOSIT_SIZE > withdrawalInfo.amount) {\n                unchecked {\n                    penaltySum += DEPOSIT_SIZE - withdrawalInfo.amount;\n                }\n            }\n            if (penaltySum > 0) {\n                accounting().penalize(\n                    withdrawalInfo.nodeOperatorId,\n                    penaltySum\n                );\n            }\n\n            // Nonce will be updated below even if depositable count was not changed\n            _updateDepositableValidatorsCount({\n                nodeOperatorId: withdrawalInfo.nodeOperatorId,\n                incrementNonceIfUpdated: false\n            });\n        }\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @dev Changing the WC means that the current deposit data in the queue is not valid anymore and can't be deposited.\n    ///      DSM will unvet current keys.\n    ///      The key removal charge should be reset to 0 to allow Node Operators to remove the keys without any charge.\n    ///      After keys removal the DAO should set the new key removal charge.\n    function onWithdrawalCredentialsChanged()\n        external\n        onlyRole(STAKING_ROUTER_ROLE)\n    {\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc IStakingModule\n    function reportValidatorExitDelay(\n        uint256 nodeOperatorId,\n        uint256 /* proofSlotTimestamp */,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        EXIT_PENALTIES.processExitDelayReport(\n            nodeOperatorId,\n            publicKey,\n            eligibleToExitInSec\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    function onValidatorExitTriggered(\n        uint256 nodeOperatorId,\n        bytes calldata publicKey,\n        uint256 withdrawalRequestPaidFee,\n        uint256 exitType\n    ) external onlyRole(STAKING_ROUTER_ROLE) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        EXIT_PENALTIES.processTriggeredExit(\n            nodeOperatorId,\n            publicKey,\n            withdrawalRequestPaidFee,\n            exitType\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @notice Get the next `depositsCount` of depositable keys with signatures from the queue\n    /// @dev Second param `depositCalldata` is not used\n    function obtainDepositData(\n        uint256 depositsCount,\n        bytes calldata /* depositCalldata */\n    )\n        external\n        onlyRole(STAKING_ROUTER_ROLE)\n        returns (bytes memory publicKeys, bytes memory signatures)\n    {\n        (publicKeys, signatures) = SigningKeys.initKeysSigsBuf(depositsCount);\n        if (depositsCount == 0) {\n            return (publicKeys, signatures);\n        }\n\n        uint256 depositsLeft = depositsCount;\n        uint256 loadedKeysCount = 0;\n\n        QueueLib.Queue storage queue;\n        // Note: The highest priority to start iterations with. Priorities are ordered like 0, 1, 2, ...\n        uint256 priority = 0;\n\n        while (true) {\n            if (priority > QUEUE_LOWEST_PRIORITY || depositsLeft == 0) {\n                break;\n            }\n\n            queue = _getQueue(priority);\n            unchecked {\n                // Note: unused below\n                ++priority;\n            }\n\n            for (\n                Batch item = queue.peek();\n                !item.isNil();\n                item = queue.peek()\n            ) {\n                // NOTE: see the `enqueuedCount` note below.\n                unchecked {\n                    uint256 noId = item.noId();\n                    uint256 keysInBatch = item.keys();\n                    NodeOperator storage no = _nodeOperators[noId];\n\n                    uint256 keysCount = Math.min(\n                        Math.min(no.depositableValidatorsCount, keysInBatch),\n                        depositsLeft\n                    );\n                    // `depositsLeft` is non-zero at this point all the time, so the check `depositsLeft > keysCount`\n                    // covers the case when no depositable keys on the Node Operator have been left.\n                    if (depositsLeft > keysCount || keysCount == keysInBatch) {\n                        // NOTE: `enqueuedCount` >= keysInBatch invariant should be checked.\n                        // @dev No need to safe cast due to internal logic\n                        no.enqueuedCount -= uint32(keysInBatch);\n                        // We've consumed all the keys in the batch, so we dequeue it.\n                        queue.dequeue();\n                    } else {\n                        // This branch covers the case when we stop in the middle of the batch.\n                        // We release the amount of keys consumed only, the rest will be kept.\n                        // @dev No need to safe cast due to internal logic\n                        no.enqueuedCount -= uint32(keysCount);\n                        // NOTE: `keysInBatch` can't be less than `keysCount` at this point.\n                        // We update the batch with the remaining keys.\n                        item = item.setKeys(keysInBatch - keysCount);\n                        // Store the updated batch back to the queue.\n                        queue.queue[queue.head] = item;\n                    }\n\n                    // Note: This condition is located here to allow for the correct removal of the batch for the Node Operators with no depositable keys\n                    if (keysCount == 0) {\n                        continue;\n                    }\n\n                    // solhint-disable-next-line func-named-parameters\n                    SigningKeys.loadKeysSigs(\n                        noId,\n                        no.totalDepositedKeys,\n                        keysCount,\n                        publicKeys,\n                        signatures,\n                        loadedKeysCount\n                    );\n\n                    // It's impossible in practice to reach the limit of these variables.\n                    loadedKeysCount += keysCount;\n                    // @dev No need to safe cast due to internal logic\n                    uint32 totalDepositedKeys = no.totalDepositedKeys +\n                        uint32(keysCount);\n                    no.totalDepositedKeys = totalDepositedKeys;\n\n                    emit DepositedSigningKeysCountChanged(\n                        noId,\n                        totalDepositedKeys\n                    );\n\n                    // No need for `_updateDepositableValidatorsCount` call since we update the number directly.\n                    // `keysCount` is min of `depositableValidatorsCount` and `depositsLeft`.\n                    // @dev No need to safe cast due to internal logic\n                    uint32 newCount = no.depositableValidatorsCount -\n                        uint32(keysCount);\n                    no.depositableValidatorsCount = newCount;\n                    emit DepositableSigningKeysCountChanged(noId, newCount);\n\n                    depositsLeft -= keysCount;\n                    if (depositsLeft == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (loadedKeysCount != depositsCount) {\n            revert NotEnoughKeys();\n        }\n\n        unchecked {\n            // @dev depositsCount can not overflow in practice due to memory and gas limits\n            _depositableValidatorsCount -= uint64(depositsCount);\n            _totalDepositedValidators += uint64(depositsCount);\n        }\n\n        _incrementModuleNonce();\n    }\n\n    /// @inheritdoc ICSModule\n    function cleanDepositQueue(\n        uint256 maxItems\n    ) external returns (uint256 removed, uint256 lastRemovedAtDepth) {\n        removed = 0;\n        lastRemovedAtDepth = 0;\n\n        if (maxItems == 0) {\n            return (0, 0);\n        }\n\n        // NOTE: We need one unique hash map per function invocation to be able to track batches of\n        // the same operator across multiple queues.\n        TransientUintUintMap queueLookup = TransientUintUintMapLib.create();\n\n        QueueLib.Queue storage queue;\n\n        uint256 totalVisited = 0;\n        // Note: The highest priority to start iterations with. Priorities are ordered like 0, 1, 2, ...\n        uint256 priority = 0;\n\n        while (true) {\n            if (priority > QUEUE_LOWEST_PRIORITY) {\n                break;\n            }\n\n            queue = _getQueue(priority);\n            unchecked {\n                ++priority;\n            }\n\n            (\n                uint256 removedPerQueue,\n                uint256 lastRemovedAtDepthPerQueue,\n                uint256 visitedPerQueue,\n                bool reachedOutOfQueue\n            ) = queue.clean(_nodeOperators, maxItems, queueLookup);\n\n            if (removedPerQueue > 0) {\n                unchecked {\n                    // 1234 56 789A     <- cumulative depth (A=10)\n                    // 1234 12 1234     <- depth per queue\n                    // **R*|**|**R*     <- queue with [R]emoved elements\n                    //\n                    // Given that we observed all 3 queues:\n                    // totalVisited: 4+2=6\n                    // lastRemovedAtDepthPerQueue: 3\n                    // lastRemovedAtDepth: 6+3=9\n\n                    lastRemovedAtDepth =\n                        totalVisited +\n                        lastRemovedAtDepthPerQueue;\n                    removed += removedPerQueue;\n                }\n            }\n\n            // NOTE: If `maxItems` is set to the total length of the queue(s), `reachedOutOfQueue` is equal\n            // to `false`, effectively breaking the cycle, because in `QueueLib.clean` we don't reach\n            // an empty batch after the end of a queue.\n            if (!reachedOutOfQueue) {\n                break;\n            }\n\n            unchecked {\n                totalVisited += visitedPerQueue;\n                maxItems -= visitedPerQueue;\n            }\n        }\n    }\n\n    /// @inheritdoc ICSModule\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /// @inheritdoc ICSModule\n    function depositQueuePointers(\n        uint256 queuePriority\n    ) external view returns (uint128 head, uint128 tail) {\n        QueueLib.Queue storage q = _getQueue(queuePriority);\n        return (q.head, q.tail);\n    }\n\n    /// @inheritdoc ICSModule\n    function depositQueueItem(\n        uint256 queuePriority,\n        uint128 index\n    ) external view returns (Batch) {\n        return _getQueue(queuePriority).at(index);\n    }\n\n    /// @inheritdoc ICSModule\n    function isValidatorWithdrawn(\n        uint256 nodeOperatorId,\n        uint256 keyIndex\n    ) external view returns (bool) {\n        return _isValidatorWithdrawn[_keyPointer(nodeOperatorId, keyIndex)];\n    }\n\n    /// @inheritdoc IStakingModule\n    function getType() external view returns (bytes32) {\n        return MODULE_TYPE;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getStakingModuleSummary()\n        external\n        view\n        returns (\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n        )\n    {\n        totalExitedValidators = _totalExitedValidators;\n        totalDepositedValidators = _totalDepositedValidators;\n        depositableValidatorsCount = _depositableValidatorsCount;\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperator(\n        uint256 nodeOperatorId\n    ) external view returns (NodeOperator memory) {\n        return _nodeOperators[nodeOperatorId];\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorManagementProperties(\n        uint256 nodeOperatorId\n    ) external view returns (NodeOperatorManagementProperties memory) {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        return (\n            NodeOperatorManagementProperties(\n                no.managerAddress,\n                no.rewardAddress,\n                no.extendedManagerPermissions\n            )\n        );\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorOwner(\n        uint256 nodeOperatorId\n    ) external view returns (address) {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        return\n            no.extendedManagerPermissions\n                ? no.managerAddress\n                : no.rewardAddress;\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorNonWithdrawnKeys(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        unchecked {\n            return no.totalAddedKeys - no.totalWithdrawnKeys;\n        }\n    }\n\n    /// @inheritdoc IStakingModule\n    /// @notice depositableValidatorsCount depends on:\n    ///      - totalVettedKeys\n    ///      - totalDepositedKeys\n    ///      - totalExitedKeys\n    ///      - targetLimitMode\n    ///      - targetValidatorsCount\n    ///      - totalUnbondedKeys\n    function getNodeOperatorSummary(\n        uint256 nodeOperatorId\n    )\n        external\n        view\n        returns (\n            uint256 targetLimitMode,\n            uint256 targetValidatorsCount,\n            uint256 stuckValidatorsCount,\n            uint256 refundedValidatorsCount,\n            uint256 stuckPenaltyEndTimestamp,\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n        )\n    {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint256 totalUnbondedKeys = accounting().getUnbondedKeysCountToEject(\n            nodeOperatorId\n        );\n        uint256 totalNonDepositedKeys = no.totalAddedKeys -\n            no.totalDepositedKeys;\n        // Force mode enabled and unbonded deposited keys\n        if (\n            totalUnbondedKeys > totalNonDepositedKeys &&\n            no.targetLimitMode == FORCED_TARGET_LIMIT_MODE_ID\n        ) {\n            targetLimitMode = FORCED_TARGET_LIMIT_MODE_ID;\n            unchecked {\n                targetValidatorsCount = Math.min(\n                    no.targetLimit,\n                    no.totalAddedKeys -\n                        no.totalWithdrawnKeys -\n                        totalUnbondedKeys\n                );\n            }\n            // No force mode enabled but unbonded deposited keys\n        } else if (totalUnbondedKeys > totalNonDepositedKeys) {\n            targetLimitMode = FORCED_TARGET_LIMIT_MODE_ID;\n            unchecked {\n                targetValidatorsCount =\n                    no.totalAddedKeys -\n                    no.totalWithdrawnKeys -\n                    totalUnbondedKeys;\n            }\n        } else {\n            targetLimitMode = no.targetLimitMode;\n            targetValidatorsCount = no.targetLimit;\n        }\n        stuckValidatorsCount = 0;\n        refundedValidatorsCount = 0;\n        stuckPenaltyEndTimestamp = 0;\n        totalExitedValidators = no.totalExitedKeys;\n        totalDepositedValidators = no.totalDepositedKeys;\n        depositableValidatorsCount = no.depositableValidatorsCount;\n    }\n\n    /// @inheritdoc ICSModule\n    function getNodeOperatorTotalDepositedKeys(\n        uint256 nodeOperatorId\n    ) external view returns (uint256 totalDepositedKeys) {\n        totalDepositedKeys = _nodeOperators[nodeOperatorId].totalDepositedKeys;\n    }\n\n    /// @inheritdoc ICSModule\n    function getSigningKeys(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) external view returns (bytes memory) {\n        _onlyValidIndexRange(nodeOperatorId, startIndex, keysCount);\n\n        return SigningKeys.loadKeys(nodeOperatorId, startIndex, keysCount);\n    }\n\n    /// @inheritdoc ICSModule\n    function getSigningKeysWithSignatures(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) external view returns (bytes memory keys, bytes memory signatures) {\n        _onlyValidIndexRange(nodeOperatorId, startIndex, keysCount);\n\n        (keys, signatures) = SigningKeys.initKeysSigsBuf(keysCount);\n        // solhint-disable-next-line func-named-parameters\n        SigningKeys.loadKeysSigs(\n            nodeOperatorId,\n            startIndex,\n            keysCount,\n            keys,\n            signatures,\n            0\n        );\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNonce() external view returns (uint256) {\n        return _nonce;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNodeOperatorsCount() external view returns (uint256) {\n        return _nodeOperatorsCount;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getActiveNodeOperatorsCount() external view returns (uint256) {\n        return _nodeOperatorsCount;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNodeOperatorIsActive(\n        uint256 nodeOperatorId\n    ) external view returns (bool) {\n        return nodeOperatorId < _nodeOperatorsCount;\n    }\n\n    /// @inheritdoc IStakingModule\n    function getNodeOperatorIds(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory nodeOperatorIds) {\n        uint256 nodeOperatorsCount = _nodeOperatorsCount;\n        if (offset >= nodeOperatorsCount || limit == 0) {\n            return new uint256[](0);\n        }\n\n        uint256 idsCount = limit < nodeOperatorsCount - offset\n            ? limit\n            : nodeOperatorsCount - offset;\n        nodeOperatorIds = new uint256[](idsCount);\n        for (uint256 i = 0; i < nodeOperatorIds.length; ++i) {\n            nodeOperatorIds[i] = offset + i;\n        }\n    }\n\n    /// @inheritdoc IStakingModule\n    function isValidatorExitDelayPenaltyApplicable(\n        uint256 nodeOperatorId,\n        uint256 /* proofSlotTimestamp */,\n        bytes calldata publicKey,\n        uint256 eligibleToExitInSec\n    ) external view returns (bool) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        return\n            EXIT_PENALTIES.isValidatorExitDelayPenaltyApplicable(\n                nodeOperatorId,\n                publicKey,\n                eligibleToExitInSec\n            );\n    }\n\n    /// @inheritdoc IStakingModule\n    function exitDeadlineThreshold(\n        uint256 nodeOperatorId\n    ) external view returns (uint256) {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        return\n            PARAMETERS_REGISTRY.getAllowedExitDelay(\n                accounting().getBondCurveId(nodeOperatorId)\n            );\n    }\n\n    /// @dev This function is used to get the accounting contract from immutables to save bytecode and for backwards compatibility\n    function accounting() public view returns (ICSAccounting) {\n        return ACCOUNTING;\n    }\n\n    function _incrementModuleNonce() internal {\n        unchecked {\n            emit NonceChanged(++_nonce);\n        }\n    }\n\n    function _addKeysAndUpdateDepositableValidatorsCount(\n        uint256 nodeOperatorId,\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures\n    ) internal {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint256 totalAddedKeys = no.totalAddedKeys;\n\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        uint256 keysLimit = PARAMETERS_REGISTRY.getKeysLimit(curveId);\n\n        unchecked {\n            if (\n                totalAddedKeys + keysCount - no.totalWithdrawnKeys > keysLimit\n            ) {\n                revert KeysLimitExceeded();\n            }\n\n            // solhint-disable-next-line func-named-parameters\n            uint256 newTotalAddedKeys = SigningKeys.saveKeysSigs(\n                nodeOperatorId,\n                totalAddedKeys,\n                keysCount,\n                publicKeys,\n                signatures\n            );\n            // Optimistic vetting takes place.\n            if (totalAddedKeys == no.totalVettedKeys) {\n                // @dev No need to safe cast due to internal logic\n                uint32 totalVettedKeys = no.totalVettedKeys + uint32(keysCount);\n                no.totalVettedKeys = totalVettedKeys;\n                emit VettedSigningKeysCountChanged(\n                    nodeOperatorId,\n                    totalVettedKeys\n                );\n            }\n\n            // @dev No need to safe cast due to internal logic\n            no.totalAddedKeys = uint32(newTotalAddedKeys);\n\n            emit TotalSigningKeysCountChanged(\n                nodeOperatorId,\n                newTotalAddedKeys\n            );\n        }\n\n        // Nonce is updated below since in case of target limit depositable keys might not change\n        _updateDepositableValidatorsCount({\n            nodeOperatorId: nodeOperatorId,\n            incrementNonceIfUpdated: false\n        });\n        _incrementModuleNonce();\n    }\n\n    /// @dev Update exited validators count for a single Node Operator\n    /// @dev Allows decrease the count for unsafe updates\n    function _updateExitedValidatorsCount(\n        uint256 nodeOperatorId,\n        uint256 exitedValidatorsCount,\n        bool allowDecrease\n    ) internal {\n        _onlyExistingNodeOperator(nodeOperatorId);\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint32 totalExitedKeys = no.totalExitedKeys;\n        if (exitedValidatorsCount == totalExitedKeys) {\n            return;\n        }\n        if (exitedValidatorsCount > no.totalDepositedKeys) {\n            revert ExitedKeysHigherThanTotalDeposited();\n        }\n        if (!allowDecrease && exitedValidatorsCount < totalExitedKeys) {\n            revert ExitedKeysDecrease();\n        }\n\n        unchecked {\n            // @dev Invariat sum(no.totalExitedKeys for no in nos) == _totalExitedValidators.\n            _totalExitedValidators =\n                (_totalExitedValidators - totalExitedKeys) +\n                uint64(exitedValidatorsCount);\n        }\n        // @dev No need to safe cast due to conditions above\n        no.totalExitedKeys = uint32(exitedValidatorsCount);\n\n        emit ExitedSigningKeysCountChanged(\n            nodeOperatorId,\n            exitedValidatorsCount\n        );\n    }\n\n    function _updateDepositableValidatorsCount(\n        uint256 nodeOperatorId,\n        bool incrementNonceIfUpdated\n    ) internal {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n\n        uint32 totalDepositedKeys = no.totalDepositedKeys;\n        uint256 newCount = no.totalVettedKeys - totalDepositedKeys;\n        uint256 unbondedKeys = accounting().getUnbondedKeysCount(\n            nodeOperatorId\n        );\n\n        {\n            uint256 nonDeposited = no.totalAddedKeys - totalDepositedKeys;\n            if (unbondedKeys >= nonDeposited) {\n                newCount = 0;\n            } else if (unbondedKeys > no.totalAddedKeys - no.totalVettedKeys) {\n                newCount = nonDeposited - unbondedKeys;\n            }\n        }\n\n        if (no.targetLimitMode > 0 && newCount > 0) {\n            unchecked {\n                uint256 nonWithdrawnValidators = totalDepositedKeys -\n                    no.totalWithdrawnKeys;\n                newCount = Math.min(\n                    no.targetLimit > nonWithdrawnValidators\n                        ? no.targetLimit - nonWithdrawnValidators\n                        : 0,\n                    newCount\n                );\n            }\n        }\n\n        if (no.depositableValidatorsCount != newCount) {\n            // Updating the global counter.\n            // @dev No need to safe cast due to internal logic\n            unchecked {\n                _depositableValidatorsCount =\n                    _depositableValidatorsCount -\n                    no.depositableValidatorsCount +\n                    uint64(newCount);\n            }\n            // @dev No need to safe cast due to internal logic\n            no.depositableValidatorsCount = uint32(newCount);\n            emit DepositableSigningKeysCountChanged(nodeOperatorId, newCount);\n            if (incrementNonceIfUpdated) {\n                _incrementModuleNonce();\n            }\n            _enqueueNodeOperatorKeys(nodeOperatorId);\n        }\n    }\n\n    function _enqueueNodeOperatorKeys(uint256 nodeOperatorId) internal {\n        uint256 curveId = accounting().getBondCurveId(nodeOperatorId);\n        (uint32 priority, uint32 maxDeposits) = PARAMETERS_REGISTRY\n            .getQueueConfig(curveId);\n        // TODO Replace QUEUE_LEGACY_PRIORITY with QUEUE_LOWEST_PRIORITY after legacy queue removal in CSM v3\n        if (priority < QUEUE_LEGACY_PRIORITY) {\n            unchecked {\n                NodeOperator storage no = _nodeOperators[nodeOperatorId];\n                uint32 enqueuedSoFar = no.totalDepositedKeys + no.enqueuedCount;\n\n                if (maxDeposits > enqueuedSoFar) {\n                    uint32 leftForQueue = maxDeposits - enqueuedSoFar;\n                    _enqueueNodeOperatorKeys(\n                        nodeOperatorId,\n                        priority,\n                        leftForQueue\n                    );\n                    if (!no.usedPriorityQueue) {\n                        no.usedPriorityQueue = true;\n                    }\n                }\n            }\n        }\n\n        _enqueueNodeOperatorKeys(\n            nodeOperatorId,\n            QUEUE_LOWEST_PRIORITY,\n            type(uint32).max\n        );\n    }\n\n    // TODO refactor this method after removing migrateToPriorityQueue\n    function _enqueueNodeOperatorKeys(\n        uint256 nodeOperatorId,\n        uint256 queuePriority,\n        uint32 maxKeys\n    ) internal {\n        NodeOperator storage no = _nodeOperators[nodeOperatorId];\n        uint32 depositable = no.depositableValidatorsCount;\n        uint32 enqueued = no.enqueuedCount;\n\n        if (enqueued < depositable) {\n            unchecked {\n                uint32 count = depositable - enqueued;\n                count = uint32(Math.min(count, maxKeys));\n\n                no.enqueuedCount = enqueued + count;\n\n                QueueLib.Queue storage q = _getQueue(queuePriority);\n                q.enqueue(nodeOperatorId, count);\n                emit BatchEnqueued(queuePriority, nodeOperatorId, count);\n            }\n        }\n    }\n\n    function _markOperatorIsCreatedInTX(uint256 nodeOperatorId) internal {\n        TransientUintUintMap map = TransientUintUintMapLib.load(\n            OPERATORS_CREATED_IN_TX_MAP_TSLOT\n        );\n        map.set(nodeOperatorId, 1);\n    }\n\n    function _isOperatorCreatedInTX(\n        uint256 nodeOperatorId\n    ) internal view returns (bool) {\n        TransientUintUintMap map = TransientUintUintMapLib.load(\n            OPERATORS_CREATED_IN_TX_MAP_TSLOT\n        );\n        return map.get(nodeOperatorId) == 1;\n    }\n\n    /// @dev Acts as a proxy to `_queueByPriority` till `_legacyQueue` deprecation.\n    /// @dev TODO: Remove the method in the next major release.\n    function _getQueue(\n        uint256 priority\n    ) internal view returns (QueueLib.Queue storage q) {\n        if (priority == QUEUE_LEGACY_PRIORITY) {\n            assembly {\n                q.slot := _legacyQueue.slot\n            }\n        } else {\n            q = _queueByPriority[priority];\n        }\n    }\n\n    function _checkCanAddKeys(\n        uint256 nodeOperatorId,\n        address who\n    ) internal view {\n        // Most likely a direct call, so check the sender is a manager.\n        if (who == msg.sender) {\n            _onlyNodeOperatorManager(nodeOperatorId, msg.sender);\n        } else {\n            // We're trying to add keys via gate, check if we can do it.\n            _checkRole(CREATE_NODE_OPERATOR_ROLE);\n            if (!_isOperatorCreatedInTX(nodeOperatorId)) {\n                revert CannotAddKeys();\n            }\n        }\n    }\n\n    function _onlyNodeOperatorManager(\n        uint256 nodeOperatorId,\n        address from\n    ) internal view {\n        address managerAddress = _nodeOperators[nodeOperatorId].managerAddress;\n        if (managerAddress == address(0)) {\n            revert NodeOperatorDoesNotExist();\n        }\n\n        if (managerAddress != from) {\n            revert SenderIsNotEligible();\n        }\n    }\n\n    function _onlyExistingNodeOperator(uint256 nodeOperatorId) internal view {\n        if (nodeOperatorId < _nodeOperatorsCount) {\n            return;\n        }\n\n        revert NodeOperatorDoesNotExist();\n    }\n\n    function _onlyValidIndexRange(\n        uint256 nodeOperatorId,\n        uint256 startIndex,\n        uint256 keysCount\n    ) internal view {\n        if (\n            startIndex + keysCount >\n            _nodeOperators[nodeOperatorId].totalAddedKeys\n        ) {\n            revert SigningKeysInvalidOffset();\n        }\n    }\n\n    function _onlyRecoverer() internal view override {\n        _checkRole(RECOVERER_ROLE);\n    }\n\n    /// @dev Both nodeOperatorId and keyIndex are limited to uint64 by the contract\n    function _keyPointer(\n        uint256 nodeOperatorId,\n        uint256 keyIndex\n    ) internal pure returns (uint256) {\n        return (nodeOperatorId << 128) | keyIndex;\n    }\n}\n"
    }
}