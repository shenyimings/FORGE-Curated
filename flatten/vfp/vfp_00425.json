{
    "vfp_id": "vfp_00425",
    "project_name": "ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "findings": [
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Backed Tokens Can Be Redeemed Unproportionally",
            "description": "When redeeming collateral, the system may disproportionately redeem from a branch that is nearly fully backed, violating proportional distribution expectations.\n\nThe root cause is that the redemption logic does not cap the amount by unbacked debt when not all branches are fully backed.\n\nAn attacker could target a nearly backed branch to extract more collateral than fair share.\n\nThe impact is unfair distribution of collateral during redemptions, potentially leading to economic imbalance between branches.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        }
    ],
    "affected_files": {
        "CollateralRegistry.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Dependencies/Constants.sol\";\nimport \"./Dependencies/LiquityMath.sol\";\n\nimport \"./Interfaces/ICollateralRegistry.sol\";\n\ncontract CollateralRegistry is ICollateralRegistry {\n    // See: https://github.com/ethereum/solidity/issues/12587\n    uint256 public immutable totalCollaterals;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n    IERC20Metadata internal immutable token4;\n    IERC20Metadata internal immutable token5;\n    IERC20Metadata internal immutable token6;\n    IERC20Metadata internal immutable token7;\n    IERC20Metadata internal immutable token8;\n    IERC20Metadata internal immutable token9;\n\n    ITroveManager internal immutable troveManager0;\n    ITroveManager internal immutable troveManager1;\n    ITroveManager internal immutable troveManager2;\n    ITroveManager internal immutable troveManager3;\n    ITroveManager internal immutable troveManager4;\n    ITroveManager internal immutable troveManager5;\n    ITroveManager internal immutable troveManager6;\n    ITroveManager internal immutable troveManager7;\n    ITroveManager internal immutable troveManager8;\n    ITroveManager internal immutable troveManager9;\n\n    IBoldToken public immutable boldToken;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new Bold issuance)\n    uint256 public lastFeeOperationTime = block.timestamp;\n\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n\n    constructor(IBoldToken _boldToken, IERC20Metadata[] memory _tokens, ITroveManager[] memory _troveManagers) {\n        uint256 numTokens = _tokens.length;\n        require(numTokens > 0, \"Collateral list cannot be empty\");\n        require(numTokens <= 10, \"Collateral list too long\");\n        totalCollaterals = numTokens;\n\n        boldToken = _boldToken;\n\n        token0 = _tokens[0];\n        token1 = numTokens > 1 ? _tokens[1] : IERC20Metadata(address(0));\n        token2 = numTokens > 2 ? _tokens[2] : IERC20Metadata(address(0));\n        token3 = numTokens > 3 ? _tokens[3] : IERC20Metadata(address(0));\n        token4 = numTokens > 4 ? _tokens[4] : IERC20Metadata(address(0));\n        token5 = numTokens > 5 ? _tokens[5] : IERC20Metadata(address(0));\n        token6 = numTokens > 6 ? _tokens[6] : IERC20Metadata(address(0));\n        token7 = numTokens > 7 ? _tokens[7] : IERC20Metadata(address(0));\n        token8 = numTokens > 8 ? _tokens[8] : IERC20Metadata(address(0));\n        token9 = numTokens > 9 ? _tokens[9] : IERC20Metadata(address(0));\n\n        troveManager0 = _troveManagers[0];\n        troveManager1 = numTokens > 1 ? _troveManagers[1] : ITroveManager(address(0));\n        troveManager2 = numTokens > 2 ? _troveManagers[2] : ITroveManager(address(0));\n        troveManager3 = numTokens > 3 ? _troveManagers[3] : ITroveManager(address(0));\n        troveManager4 = numTokens > 4 ? _troveManagers[4] : ITroveManager(address(0));\n        troveManager5 = numTokens > 5 ? _troveManagers[5] : ITroveManager(address(0));\n        troveManager6 = numTokens > 6 ? _troveManagers[6] : ITroveManager(address(0));\n        troveManager7 = numTokens > 7 ? _troveManagers[7] : ITroveManager(address(0));\n        troveManager8 = numTokens > 8 ? _troveManagers[8] : ITroveManager(address(0));\n        troveManager9 = numTokens > 9 ? _troveManagers[9] : ITroveManager(address(0));\n\n        // Initialize the baseRate state variable\n        baseRate = INITIAL_BASE_RATE;\n        emit BaseRateUpdated(INITIAL_BASE_RATE);\n    }\n\n    struct RedemptionTotals {\n        uint256 numCollaterals;\n        uint256 boldSupplyAtStart;\n        uint256 unbacked;\n        uint256 redeemedAmount;\n    }\n\n    function redeemCollateral(uint256 _boldAmount, uint256 _maxIterationsPerCollateral, uint256 _maxFeePercentage)\n        external\n    {\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAmountGreaterThanZero(_boldAmount);\n\n        RedemptionTotals memory totals;\n\n        totals.numCollaterals = totalCollaterals;\n        uint256[] memory unbackedPortions = new uint256[](totals.numCollaterals);\n        uint256[] memory prices = new uint256[](totals.numCollaterals);\n\n        // Gather and accumulate unbacked portions\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            ITroveManager troveManager = getTroveManager(index);\n            (uint256 unbackedPortion, uint256 price, bool redeemable) =\n                troveManager.getUnbackedPortionPriceAndRedeemability();\n            prices[index] = price;\n            if (redeemable) {\n                totals.unbacked += unbackedPortion;\n                unbackedPortions[index] = unbackedPortion;\n            }\n        }\n\n        // Thereâ€™s an unlikely scenario where all the normally redeemable branches (i.e. having TCR > SCR) have 0 unbacked\n        // In that case, we redeem proportionally to branch size\n        if (totals.unbacked == 0) {\n            unbackedPortions = new uint256[](totals.numCollaterals);\n            for (uint256 index = 0; index < totals.numCollaterals; index++) {\n                ITroveManager troveManager = getTroveManager(index);\n                (,, bool redeemable) = troveManager.getUnbackedPortionPriceAndRedeemability();\n                if (redeemable) {\n                    uint256 unbackedPortion = troveManager.getEntireBranchDebt();\n                    totals.unbacked += unbackedPortion;\n                    unbackedPortions[index] = unbackedPortion;\n                }\n            }\n        } else {\n            // Don't allow redeeming more than the total unbacked in one go, as that would result in a disproportionate\n            // redemption (see CS-BOLD-013). Instead, truncate the redemption to total unbacked. If this happens, the\n            // redeemer can call `redeemCollateral()` a second time to redeem the remainder of their BOLD.\n            if (_boldAmount > totals.unbacked) {\n                _boldAmount = totals.unbacked;\n            }\n        }\n\n        totals.boldSupplyAtStart = boldToken.totalSupply();\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total Bold supply value, from before it was reduced by the redemption.\n        // We only compute it here, and update it at the end,\n        // because the final redeemed amount may be less than the requested amount\n        // Redeemers should take this into account in order to request the optimal amount to not overpay\n        uint256 redemptionRate =\n            _calcRedemptionRate(_getUpdatedBaseRateFromRedemption(_boldAmount, totals.boldSupplyAtStart));\n        require(redemptionRate <= _maxFeePercentage, \"CR: Fee exceeded provided maximum\");\n        // Implicit by the above and the _requireValidMaxFeePercentage checks\n        //require(newBaseRate < DECIMAL_PRECISION, \"CR: Fee would eat up all collateral\");\n\n        // Compute redemption amount for each collateral and redeem against the corresponding TroveManager\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            //uint256 unbackedPortion = unbackedPortions[index];\n            if (unbackedPortions[index] > 0) {\n                uint256 redeemAmount = _boldAmount * unbackedPortions[index] / totals.unbacked;\n                if (redeemAmount > 0) {\n                    ITroveManager troveManager = getTroveManager(index);\n                    uint256 redeemedAmount = troveManager.redeemCollateral(\n                        msg.sender, redeemAmount, prices[index], redemptionRate, _maxIterationsPerCollateral\n                    );\n                    totals.redeemedAmount += redeemedAmount;\n                }\n\n                // Ensure that per-branch redeems add up to `_boldAmount` exactly\n                _boldAmount -= redeemAmount;\n                totals.unbacked -= unbackedPortions[index];\n            }\n        }\n\n        _updateBaseRateAndGetRedemptionRate(totals.redeemedAmount, totals.boldSupplyAtStart);\n\n        // Burn the total Bold that is cancelled with debt\n        if (totals.redeemedAmount > 0) {\n            boldToken.burn(msg.sender, totals.redeemedAmount);\n        }\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n\n        if (minutesPassed > 0) {\n            lastFeeOperationTime += ONE_MINUTE * minutesPassed;\n            emit LastFeeOpTimeUpdated(lastFeeOperationTime);\n        }\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint256) {\n        return (block.timestamp - lastFeeOperationTime) / ONE_MINUTE;\n    }\n\n    // Updates the `baseRate` state with math from `_getUpdatedBaseRateFromRedemption`\n    function _updateBaseRateAndGetRedemptionRate(uint256 _boldAmount, uint256 _totalBoldSupplyAtStart) internal {\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_boldAmount, _totalBoldSupplyAtStart);\n\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in `_getUpdatedBaseRateFromRedemption`\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    /*\n     * This function calculates the new baseRate in the following way:\n     * 1) decays the baseRate based on time passed since last redemption or Bold borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _getUpdatedBaseRateFromRedemption(uint256 _redeemAmount, uint256 _totalBoldSupply)\n        internal\n        view\n        returns (uint256)\n    {\n        // decay the base rate\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        // get the fraction of total supply that was redeemed\n        uint256 redeemedBoldFraction = _redeemAmount * DECIMAL_PRECISION / _totalBoldSupply;\n\n        uint256 newBaseRate = decayedBaseRate + redeemedBoldFraction / REDEMPTION_BETA;\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n\n        return newBaseRate;\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint256 decayFactor = LiquityMath._decPow(REDEMPTION_MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate * decayFactor / DECIMAL_PRECISION;\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal pure returns (uint256) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR + _baseRate,\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _amount) internal pure returns (uint256) {\n        uint256 redemptionFee = _redemptionRate * _amount / DECIMAL_PRECISION;\n        return redemptionFee;\n    }\n\n    // external redemption rate/fee getters\n\n    function getRedemptionRate() external view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionRate(newBaseRate);\n    }\n\n    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);\n    }\n\n    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view override returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionFee(_calcRedemptionRate(newBaseRate), _redeemAmount);\n    }\n\n    // getters\n\n    function getToken(uint256 _index) external view returns (IERC20Metadata) {\n        if (_index == 0) return token0;\n        else if (_index == 1) return token1;\n        else if (_index == 2) return token2;\n        else if (_index == 3) return token3;\n        else if (_index == 4) return token4;\n        else if (_index == 5) return token5;\n        else if (_index == 6) return token6;\n        else if (_index == 7) return token7;\n        else if (_index == 8) return token8;\n        else if (_index == 9) return token9;\n        else revert(\"Invalid index\");\n    }\n\n    function getTroveManager(uint256 _index) public view returns (ITroveManager) {\n        if (_index == 0) return troveManager0;\n        else if (_index == 1) return troveManager1;\n        else if (_index == 2) return troveManager2;\n        else if (_index == 3) return troveManager3;\n        else if (_index == 4) return troveManager4;\n        else if (_index == 5) return troveManager5;\n        else if (_index == 6) return troveManager6;\n        else if (_index == 7) return troveManager7;\n        else if (_index == 8) return troveManager8;\n        else if (_index == 9) return troveManager9;\n        else revert(\"Invalid index\");\n    }\n\n    // require functions\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        require(_amount > 0, \"CollateralRegistry: Amount must be greater than zero\");\n    }\n}\n"
    }
}