{
    "vfp_id": "vfp_00152",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant getAmountIn() call in swap fee calculation",
            "description": "The getAmountIn() function in SwapMath.sol calls itself redundantly when calculating approxAmountIn for getPriceDegree(), which is then used for dynamic fee calculation. However, getPriceDegree() only uses approxAmountIn and ignores the provided amountOut, making the initial getAmountIn() call unnecessary. The root cause is inefficient code design. This leads to wasted gas and introduces unnecessary rounding errors. The impact is increased transaction costs and potential inaccuracies in fee calculations, reducing economic efficiency.\n",
            "severity": "Low",
            "location": [
                "SwapMath.sol"
            ],
            "files": [
                "likwid-margin/src/libraries/SwapMath.sol"
            ]
        }
    ],
    "affected_files": {
        "SwapMath.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Reserves} from \"../types/Reserves.sol\";\nimport {Math} from \"./Math.sol\";\nimport {FeeLibrary} from \"./FeeLibrary.sol\";\nimport {PerLibrary} from \"./PerLibrary.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\nlibrary SwapMath {\n    using CustomRevert for bytes4;\n    using FeeLibrary for uint24;\n    using PerLibrary for uint256;\n\n    /// @notice The maximum swap fee in hundredths of a bip (1e6 = 100%).\n    uint256 internal constant MAX_SWAP_FEE = 1e6;\n\n    error InsufficientLiquidity();\n    error InsufficientInputAmount();\n\n    /**\n     * @notice Calculates the absolute difference between two prices.\n     * @param price The current price.\n     * @param lastPrice The previous price.\n     * @return priceDiff The absolute difference.\n     */\n    function differencePrice(uint256 price, uint256 lastPrice) internal pure returns (uint256 priceDiff) {\n        priceDiff = price > lastPrice ? price - lastPrice : lastPrice - price;\n    }\n\n    /**\n     * @notice Calculates the degree of price change caused by a swap, used for dynamic fee calculation.\n     * @dev This function calculates price impact based on reserves and swap amounts.\n     * @param pairReserves The current reserves of the pair.\n     * @param truncatedReserves The reserves at the last fee calculation checkpoint.\n     * @param lpFee The base liquidity provider fee.\n     * @param zeroForOne The direction of the swap.\n     * @param amountIn The amount of tokens being swapped in.\n     * @param amountOut The amount of tokens being swapped out.\n     * @return degree The calculated degree of price change.\n     */\n    function getPriceDegree(\n        Reserves pairReserves,\n        Reserves truncatedReserves,\n        uint24 lpFee,\n        bool zeroForOne,\n        uint256 amountIn,\n        uint256 amountOut\n    ) internal pure returns (uint256 degree) {\n        if (truncatedReserves.bothPositive()) {\n            uint256 lastPrice0X96 = truncatedReserves.getPrice0X96();\n            uint256 lastPrice1X96 = truncatedReserves.getPrice1X96();\n            (uint256 _reserve0, uint256 _reserve1) = pairReserves.reserves();\n            if (_reserve0 == 0 || _reserve1 == 0) {\n                return degree;\n            }\n            if (amountIn > 0) {\n                (amountOut,) = getAmountOut(pairReserves, lpFee, zeroForOne, amountIn);\n            } else if (amountOut > 0) {\n                (amountIn,) = getAmountIn(pairReserves, lpFee, zeroForOne, amountOut);\n            }\n            unchecked {\n                if (zeroForOne) {\n                    _reserve1 -= amountOut;\n                    _reserve0 += amountIn;\n                } else {\n                    _reserve0 -= amountOut;\n                    _reserve1 += amountIn;\n                }\n            }\n            uint256 price0X96 = Math.mulDiv(_reserve1, FixedPoint96.Q96, _reserve0);\n            uint256 price1X96 = Math.mulDiv(_reserve0, FixedPoint96.Q96, _reserve1);\n            uint256 degree0 = differencePrice(price0X96, lastPrice0X96).mulMillionDiv(lastPrice0X96);\n            uint256 degree1 = differencePrice(price1X96, lastPrice1X96).mulMillionDiv(lastPrice1X96);\n            degree = Math.max(degree0, degree1);\n        }\n    }\n\n    /**\n     * @notice Calculates a dynamic fee based on the degree of price change.\n     * @dev The fee increases with the price impact (degree).\n     * @param swapFee The base swap fee.\n     * @param degree The degree of price change.\n     * @return _fee The calculated dynamic fee.\n     */\n    function dynamicFee(uint24 swapFee, uint256 degree) internal pure returns (uint24 _fee) {\n        _fee = swapFee;\n        if (degree > MAX_SWAP_FEE) {\n            _fee = uint24(MAX_SWAP_FEE) - 10000;\n        } else if (degree > 100000) {\n            uint256 dFee = Math.mulDiv((degree * 10) ** 3, _fee, MAX_SWAP_FEE ** 3);\n            if (dFee >= MAX_SWAP_FEE) {\n                _fee = uint24(MAX_SWAP_FEE) - 10000;\n            } else {\n                _fee = uint24(dFee);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the output amount and fee for a given input amount and fixed fee.\n     * @param pairReserves The reserves of the token pair.\n     * @param lpFee The liquidity provider fee.\n     * @param zeroForOne The direction of the swap.\n     * @param amountIn The amount of input tokens.\n     * @return amountOut The calculated amount of output tokens.\n     * @return feeAmount The amount of fees paid.\n     */\n    function getAmountOut(Reserves pairReserves, uint24 lpFee, bool zeroForOne, uint256 amountIn)\n        internal\n        pure\n        returns (uint256 amountOut, uint256 feeAmount)\n    {\n        if (amountIn == 0) InsufficientInputAmount.selector.revertWith();\n        (uint128 _reserve0, uint128 _reserve1) = pairReserves.reserves();\n        (uint256 reserveIn, uint256 reserveOut) = zeroForOne ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n        if (reserveIn == 0 || reserveOut == 0) InsufficientLiquidity.selector.revertWith();\n        uint256 amountInWithoutFee;\n        (amountInWithoutFee, feeAmount) = lpFee.deduct(amountIn);\n        uint256 numerator = amountInWithoutFee * reserveOut;\n        uint256 denominator = reserveIn + amountInWithoutFee;\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @notice Calculates the output amount using a dynamic fee based on price impact.\n     * @param pairReserves The current reserves of the pair.\n     * @param truncatedReserves The reserves at the last fee calculation checkpoint.\n     * @param lpFee The base liquidity provider fee.\n     * @param zeroForOne The direction of the swap.\n     * @param amountIn The amount of input tokens.\n     * @return amountOut The calculated amount of output tokens.\n     * @return fee The dynamic fee applied.\n     * @return feeAmount The amount of fees paid.\n     */\n    function getAmountOut(\n        Reserves pairReserves,\n        Reserves truncatedReserves,\n        uint24 lpFee,\n        bool zeroForOne,\n        uint256 amountIn\n    ) internal pure returns (uint256 amountOut, uint24 fee, uint256 feeAmount) {\n        uint256 degree = getPriceDegree(pairReserves, truncatedReserves, lpFee, zeroForOne, amountIn, 0);\n        fee = dynamicFee(lpFee, degree);\n        (amountOut, feeAmount) = getAmountOut(pairReserves, fee, zeroForOne, amountIn);\n    }\n\n    /**\n     * @notice Calculates the required input amount and fee for a given output amount and fixed fee.\n     * @param pairReserves The reserves of the token pair.\n     * @param lpFee The liquidity provider fee.\n     * @param zeroForOne The direction of the swap.\n     * @param amountOut The desired amount of output tokens.\n     * @return amountIn The required amount of input tokens.\n     * @return feeAmount The amount of fees paid from the input tokens.\n     */\n    function getAmountIn(Reserves pairReserves, uint24 lpFee, bool zeroForOne, uint256 amountOut)\n        internal\n        pure\n        returns (uint256 amountIn, uint256 feeAmount)\n    {\n        (uint128 _reserve0, uint128 _reserve1) = pairReserves.reserves();\n        (uint256 reserveIn, uint256 reserveOut) = zeroForOne ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n        if (reserveIn == 0 || reserveOut == 0) InsufficientLiquidity.selector.revertWith();\n        if (amountOut >= reserveOut) InsufficientLiquidity.selector.revertWith();\n\n        uint256 amountInWithoutFee = Math.mulDiv(reserveIn, amountOut, reserveOut - amountOut) + 1;\n\n        uint256 numerator = amountInWithoutFee * MAX_SWAP_FEE;\n        uint256 denominator = MAX_SWAP_FEE - lpFee;\n        amountIn = (numerator + denominator - 1) / denominator;\n        feeAmount = amountIn - amountInWithoutFee;\n    }\n\n    /**\n     * @notice Calculates the required input amount using a dynamic fee based on price impact.\n     * @param pairReserves The current reserves of the pair.\n     * @param truncatedReserves The reserves at the last fee calculation checkpoint.\n     * @param lpFee The base liquidity provider fee.\n     * @param zeroForOne The direction of the swap.\n     * @param amountOut The desired amount of output tokens.\n     * @return amountIn The required amount of input tokens.\n     * @return fee The dynamic fee applied.\n     * @return feeAmount The amount of fees paid.\n     */\n    function getAmountIn(\n        Reserves pairReserves,\n        Reserves truncatedReserves,\n        uint24 lpFee,\n        bool zeroForOne,\n        uint256 amountOut\n    ) internal pure returns (uint256 amountIn, uint24 fee, uint256 feeAmount) {\n        (uint256 approxAmountIn,) = getAmountIn(pairReserves, lpFee, zeroForOne, amountOut);\n        uint256 degree = getPriceDegree(pairReserves, truncatedReserves, lpFee, zeroForOne, approxAmountIn, amountOut);\n        fee = dynamicFee(lpFee, degree);\n        (amountIn, feeAmount) = getAmountIn(pairReserves, fee, zeroForOne, amountOut);\n    }\n}\n"
    }
}