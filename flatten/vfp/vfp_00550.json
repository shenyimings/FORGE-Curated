{
    "vfp_id": "vfp_00550",
    "project_name": "ZKsync Paymaster Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Race Condition During Cancelation",
            "description": "The `cancelNonce` function in the `SignatureBasedPaymaster` contract is vulnerable to a race condition. The issue arises because the function cancels the next nonce instead of a specific targeted nonce. If the owner or signer calls `cancelNonce` but a transaction using the current nonce is confirmed first, the cancellation will incorrectly apply to the subsequent nonce, potentially blocking legitimate future transactions. This behavior stems from the function's inability to validate the current state of the nonce before cancellation. An attacker (or even a legitimate sender experiencing latency) could exploit this by rushing a transaction just before the cancellation, causing the wrong nonce to be invalidated. The impact includes potential disruption of valid sender operations and reduced reliability of the paymaster system.\n",
            "severity": "Low",
            "location": [
                "SignatureBasedPaymaster.sol::cancelNonce#175"
            ],
            "files": [
                "zk-governance/contracts/SignatureBasedPaymaster.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Incomplete Docstrings",
            "description": "Multiple functions and parameters across the codebase lack complete NatSpec documentation. For example, the `postTransaction` function in `IPaymaster.sol` does not document the `_txHash` and `_suggestedSignedHash` parameters, and the `domainSeparator` function in `SignatureBasedPaymaster.sol` does not describe its return value. This omission reduces code readability and increases the risk of misuse by external developers or auditors who rely on documentation to understand expected behavior. The root cause is incomplete documentation practices. While this does not introduce a direct security vulnerability, it can lead to integration errors or misunderstandings about security guarantees. The impact is a reduction in code maintainability and increased potential for human error during development or review.\n",
            "severity": "Low",
            "location": [
                "IPaymaster.sol::postTransaction#90-97",
                "SignatureBasedPaymaster.sol::domainSeparator#190-192"
            ],
            "files": [
                "zk-governance/contracts/interfaces/IPaymaster.sol",
                "zk-governance/contracts/SignatureBasedPaymaster.sol"
            ]
        }
    ],
    "affected_files": {
        "IPaymaster.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nenum ExecutionResult {\n    Revert,\n    Success\n}\n\nbytes4 constant PAYMASTER_VALIDATION_SUCCESS_MAGIC = IPaymaster.validateAndPayForPaymasterTransaction.selector;\n\n/// @notice Structure used to represent a zkSync transaction.\nstruct Transaction {\n    // The type of the transaction.\n    uint256 txType;\n    // The caller.\n    uint256 from;\n    // The callee.\n    uint256 to;\n    // The gasLimit to pass with the transaction.\n    // It has the same meaning as Ethereum's gasLimit.\n    uint256 gasLimit;\n    // The maximum amount of gas the user is willing to pay for a byte of pubdata.\n    uint256 gasPerPubdataByteLimit;\n    // The maximum fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxFeePerGas.\n    uint256 maxFeePerGas;\n    // The maximum priority fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxPriorityFeePerGas.\n    uint256 maxPriorityFeePerGas;\n    // The transaction's paymaster. If there is no paymaster, it is equal to 0.\n    uint256 paymaster;\n    // The nonce of the transaction.\n    uint256 nonce;\n    // The value to pass with the transaction.\n    uint256 value;\n    // In the future, we might want to add some\n    // new fields to the struct. The `txData` struct\n    // is to be passed to account and any changes to its structure\n    // would mean a breaking change to these accounts. In order to prevent this,\n    // we should keep some fields as \"reserved\".\n    // It is also recommended that their length is fixed, since\n    // it would allow easier proof integration (in case we will need\n    // some special circuit for preprocessing transactions).\n    uint256[4] reserved;\n    // The transaction's calldata.\n    bytes data;\n    // The signature of the transaction.\n    bytes signature;\n    // The properly formatted hashes of bytecodes that must be published on L1\n    // with the inclusion of this transaction. Note, that a bytecode has been published\n    // before, the user won't pay fees for its republishing.\n    bytes32[] factoryDeps;\n    // The input to the paymaster.\n    bytes paymasterInput;\n    // Reserved dynamic type for the future use-case. Using it should be avoided,\n    // But it is still here, just in case we want to enable some additional functionality.\n    bytes reservedDynamic;\n}\n\ninterface IPaymaster {\n    /// @dev Called by the bootloader to verify that the paymaster agrees to pay for the\n    /// fee for the transaction. This transaction should also send the necessary amount of funds onto the bootloader\n    /// address.\n    /// @param _txHash The hash of the transaction\n    /// @param _suggestedSignedHash The hash of the transaction that is signed by an EOA\n    /// @param _transaction The transaction itself.\n    /// @return magic The value that should be equal to the signature of the validateAndPayForPaymasterTransaction\n    /// if the paymaster agrees to pay for the transaction.\n    /// @return context The \"context\" of the transaction: an array of bytes of length at most 1024 bytes, which will be\n    /// passed to the `postTransaction` method of the account.\n    /// @dev The developer should strive to preserve as many steps as possible both for valid\n    /// and invalid transactions as this very method is also used during the gas fee estimation\n    /// (without some of the necessary data, e.g. signature).\n    function validateAndPayForPaymasterTransaction(\n        bytes32 _txHash,\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable returns (bytes4 magic, bytes memory context);\n\n    /// @dev Called by the bootloader after the execution of the transaction. Please note that\n    /// there is no guarantee that this method will be called at all. Unlike the original EIP4337,\n    /// this method won't be called if the transaction execution results in out-of-gas.\n    /// @param _context, the context of the execution, returned by the \"validateAndPayForPaymasterTransaction\" method.\n    /// @param _transaction, the users' transaction.\n    /// @param _txResult, the result of the transaction execution (success or failure).\n    /// @param _maxRefundedGas, the upper bound on the amout of gas that could be refunded to the paymaster.\n    /// @dev The exact amount refunded depends on the gas spent by the \"postOp\" itself and so the developers should\n    /// take that into account.\n    function postTransaction(\n        bytes calldata _context,\n        Transaction calldata _transaction,\n        bytes32 _txHash,\n        bytes32 _suggestedSignedHash,\n        ExecutionResult _txResult,\n        uint256 _maxRefundedGas\n    ) external payable;\n}\n",
        "SignatureBasedPaymaster.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport {\n    IPaymaster, ExecutionResult, PAYMASTER_VALIDATION_SUCCESS_MAGIC, Transaction\n} from \"./interfaces/IPaymaster.sol\";\nimport {IPaymasterFlow} from \"./interfaces/IPaymasterFlow.sol\";\nimport {ISignatureBasedPaymaster} from \"./interfaces/ISignatureBasedPaymaster.sol\";\n\nimport {BOOTLOADER_FORMAL_ADDRESS} from \"./Constants.sol\";\n\n/// @title Signature based paymaster\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This paymaster contract pays transaction fees for transactions initiated by approved addresses.\n/// The contract aims to serve as a centralized paymaster for hot wallets, addressing an issue where each wallet needs to maintain\n/// a balance and be regularly funded. With this solution, there's a single funding source, simplifying the management of multiple\n/// hot wallets.\n///\n/// The contract has two roles: **owner** and **signer**.\n/// - The owner can change the signer.\n/// - The signer is responsible for managing the list of addresses approved to utilize this paymaster for their transaction fees.\ncontract SignatureBasedPaymaster is IPaymaster, ISignatureBasedPaymaster, Ownable, EIP712 {\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    /// @notice EIP-712 TypeHash for an approval for the transaction senders.\n    /// @dev Used for signature validation, ensuring the signer approves the transaction sender, validity period, and nonce.\n    bytes32 public constant APPROVED_TRANSACTION_SENDER_TYPEHASH =\n        keccak256(\"ApprovedTransactionSender(address sender,uint256 validUntil,uint256 nonce)\");\n\n    /// @notice The signer authorized to approve sender accounts for which this paymaster pay for.\n    /// @dev Transactions with a valid signature from this address are considered approved for fee coverage.\n    address public signer;\n\n    /// @notice Stores the validity period for approved senders.\n    /// @dev Maps each sender to the timestamp until which their transactions are approved for fee coverage.\n    mapping(address sender => uint256 validUntil) public approvedSenders;\n\n    /// @notice Tracks nonces for each sender to prevent replay attacks.\n    /// @dev Each sender has a unique nonce that must match and increment with changing the\n    /// timestamp until which their transactions are approved for fee coverage.\n    mapping(address sender => uint256 nonce) public nonces;\n\n    /// @dev Ensures that only the bootloader can call certain functions.\n    modifier onlyBootloader() {\n        require(msg.sender == BOOTLOADER_FORMAL_ADDRESS, \"Only bootloader can call this method\");\n        // Continue execution if called from the bootloader.\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active owner or an active signer.\n    modifier onlyOwnerOrSigner() {\n        require(msg.sender == signer || msg.sender == owner(), \"Only signer or owner can call this method\");\n        _;\n    }\n\n    /// @param _signer The initial signer address that is authorized to approve transactions for this paymaster.\n    constructor(address _signer) EIP712(\"SignatureBasedPaymaster\", \"1\") {\n        require(_signer != address(0), \"Signer cannot be address(0)\");\n        signer = _signer;\n        emit SignerChanged(address(0), _signer);\n    }\n\n    /// @inheritdoc IPaymaster\n    function validateAndPayForPaymasterTransaction(bytes32, bytes32, Transaction calldata _transaction)\n        external\n        payable\n        onlyBootloader\n        returns (bytes4, bytes memory)\n    {\n        bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);\n        require(paymasterInputSelector == IPaymasterFlow.general.selector, \"Paymaster: Unsupported paymaster flow\");\n\n        // `general` paymaster flow accepts the raw `bytes`, so decode it first.\n        (bytes memory innerInputs) = abi.decode(_transaction.paymasterInput[4:], (bytes));\n        // Get the sender address.\n        address sender = address(uint160(_transaction.from));\n\n        // Decode the real paymaster input parameters from the raw bytes.\n        try this.decodePaymasterInput(innerInputs) returns (uint256 validUntil, bytes memory signature) {\n            // Verify that the timestamp for which transactions from the sender should be\n            // paid by the paymaster is not expired.\n            require(block.timestamp <= validUntil, \"Paymaster: Signature expired\");\n            approveSenderBySignature(sender, validUntil, signature);\n        } catch {\n            // If the decoding failed just check that sender was pre-approved.\n            require(\n                block.timestamp <= approvedSenders[sender],\n                \"Paymaster: Sender has no permission for sending transaction with this paymaster\"\n            );\n        }\n\n        // Note, that while the minimal amount of ETH needed is tx.gasPrice * tx.gasLimit,\n        // neither paymaster nor account are allowed to access this context variable.\n        uint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas;\n\n        // The bootloader never returns any data, so it can safely be ignored here.\n        (bool success,) = payable(BOOTLOADER_FORMAL_ADDRESS).call{value: requiredETH}(\"\");\n        require(success, \"Paymaster: Failed to transfer tx fee to the bootloader\");\n\n        return (PAYMASTER_VALIDATION_SUCCESS_MAGIC, new bytes(0));\n    }\n\n    /// @notice Decodes the paymaster input data into its constituent components.\n    /// @param _data The raw bytes input to the paymaster.\n    /// @return validUntil The timestamp until which the transaction from the sender is considered valid.\n    /// @return signature The ECDSA signature from the paymaster signer that approves the account for fee coverage.\n    function decodePaymasterInput(bytes memory _data)\n        external\n        pure\n        returns (uint256 validUntil, bytes memory signature)\n    {\n        (validUntil, signature) = abi.decode(_data, (uint256, bytes));\n    }\n\n    /// @inheritdoc IPaymaster\n    function postTransaction(bytes calldata, Transaction calldata, bytes32, bytes32, ExecutionResult, uint256)\n        external\n        payable\n        override\n        onlyBootloader\n    {\n        // Do nothing as the transaction initiator address shouldn't get any refund.\n    }\n\n    /// @notice Approves a sender address to use the paymaster for paying fees until a specified timestamp by signature.\n    /// @param _sender The address of the sender to be approved.\n    /// @param _validUntil The timestamp until which the sender can use paymaster.\n    /// @param _signature The signature proving the approval.\n    function approveSenderBySignature(address _sender, uint256 _validUntil, bytes memory _signature) public {\n        // Generate the EIP-712 digest.\n        bytes32 structHash =\n            keccak256(abi.encode(APPROVED_TRANSACTION_SENDER_TYPEHASH, _sender, _validUntil, nonces[_sender]++));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        // Revert if signer doesn't match recovered address. Reverts on address(0) as well.\n        require(signer == digest.recover(_signature), \"Paymaster: Invalid signer\");\n        approvedSenders[_sender] = _validUntil;\n        emit SenderApproved(_sender, _validUntil);\n    }\n\n    /// @notice Withdraw funds from the contract to the specified address.\n    /// @param _to The address where to send funds.\n    /// @param _token Address of the token to be withdrawn.\n    function withdraw(address _to, address _token) public onlyOwner {\n        uint256 amount;\n        if (_token == address(0)) {\n            amount = address(this).balance;\n            (bool success,) = _to.call{value: amount}(\"\");\n            require(success, \"Failed to withdraw ether\");\n        } else {\n            amount = IERC20(_token).balanceOf(address(this));\n            // We use safeTransfer to escape any tokens even if they implemented ERC-20 standard wrongly (e.g. don't return bool value)\n            IERC20(_token).safeTransfer(_to, amount);\n        }\n        emit Withdrawn(_token, amount);\n    }\n\n    /// @notice Change the active signer address.\n    /// @param _signer The new signer address.\n    function changeSigner(address _signer) external onlyOwnerOrSigner {\n        emit SignerChanged(signer, _signer);\n        signer = _signer;\n    }\n\n    /// @notice Increments the nonce for a given sender address, effectively canceling the current nonce.\n    /// @param _sender The address of the sender whose nonce is to be incremented.\n    function cancelNonce(address _sender) external onlyOwnerOrSigner {\n        uint256 nonce = nonces[_sender];\n        nonces[_sender]++;\n        emit NonceCanceled(_sender, nonce);\n    }\n\n    /// @notice Approves a sender address to use the paymaster for paying transaction fees until a specified timestamp.\n    /// @param _sender The address of the sender to be approved.\n    /// @param _validUntil The timestamp until which the sender can use paymaster.\n    function approveSender(address _sender, uint256 _validUntil) external onlyOwnerOrSigner {\n        approvedSenders[_sender] = _validUntil;\n        emit SenderApproved(_sender, _validUntil);\n    }\n\n    /// @notice Returns the EIP-712 domain separator for this contract.\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /// @dev Contract should receive/hold ETH to pay fees as a paymaster.\n    receive() external payable {}\n}\n"
    }
}