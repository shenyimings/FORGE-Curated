{
    "vfp_id": "vfp_00127",
    "project_name": "2025-07-scroll-feynmanupgradesmartcontractchanges-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Old failed L1 to L2 messages can be executed by anyone on behalf of a user",
            "description": "This vulnerability allows any user to retry a failed L1 to L2 message originally sent by another user. The replayMessage function in the L1ScrollMessenger contract does not restrict who can trigger the replay, and there is no mechanism for a user to cancel a failed message. The root cause is the lack of access control and expiration mechanism for replayable messages. An attacker can monitor failed messages and replay them at a later time when conditions have changed (e.g., a previously paused contract is unpaused), leading to unexpected execution of old user intents. The impact includes potential confusion and financial loss for the original sender, who may believe the transaction was permanently failed, while also creating a user experience risk where users suspect wallet compromise.\n",
            "severity": "Informational",
            "location": [
                "src/L1/L1ScrollMessenger.sol::replayMessage#221-280"
            ],
            "files": [
                "scroll-contracts/src/L1/L1ScrollMessenger.sol"
            ]
        }
    ],
    "affected_files": {
        "L1ScrollMessenger.sol": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.24;\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueueV1} from \"./rollup/IL1MessageQueueV1.sol\";\nimport {IL1MessageQueueV2} from \"./rollup/IL1MessageQueueV2.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\nimport {IMessageDropCallback} from \"../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable not-rely-on-time\n// solhint-disable reason-string\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\n///\n/// The messages sent through this contract may failed due to out of gas or some contract errors layer 2. In such case,\n/// users can initiate `replayMessage` to retry this message in layer 2. If it is because out of gas, users can provide\n/// a larger `gasLimit`. Users need also to pay the cross domain relay fee again.\n///\n/// The messages sent through this contract may possibly be skipped in layer 2 due to circuit capacity overflow.\n/// In such case, users can initiate `dropMessage` to claim refunds. But the cross domain relay fee won't be refunded.\ncontract L1ScrollMessenger is ScrollMessengerBase, IL1ScrollMessenger {\n    /**********\n     * Errors *\n     **********/\n\n    error ErrorForbidToCallMessageQueue();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueueV1 contract.\n    address public immutable messageQueueV1;\n\n    /// @notice The address of L1MessageQueueV2 contract.\n    address public immutable messageQueueV2;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueueV1,\n        address _messageQueueV2\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueueV1 == address(0) || _messageQueueV2 == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueueV1 = _messageQueueV1;\n        messageQueueV2 = _messageQueueV2;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        if (_to == messageQueueV1 || _to == messageQueueV2) {\n            revert ErrorForbidToCallMessageQueue();\n        }\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, \"Provided message has not been enqueued\");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueueV2(messageQueueV2).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueueV2(messageQueueV2).nextCrossDomainMessageIndex();\n        IL1MessageQueueV2(messageQueueV2).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, \"Exceed maximum replay times\");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    /// @dev Since we don't skip any messages in `L1MessageQueueV2`, only messages from `L1MessageQueueV1` can be dropped.\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, \"Provided message has not been enqueued\");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            // If the `_lastIndex` is from `messageQueueV2`, it will revert in `messageQueueV1.dropCrossDomainMessage`.\n            IL1MessageQueueV1(messageQueueV1).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueueV2(messageQueueV2).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueueV2(messageQueueV2).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueueV2(messageQueueV2).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, \"Duplicated message\");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}\n"
    }
}