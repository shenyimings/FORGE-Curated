{
    "vfp_id": "vfp_00559",
    "project_name": "blocksec_astherus_202502-signed.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Lack of refunding mechanism for excessive cross-chain fees",
            "description": "The mintAsBnbToChain() function in AsBnbMinter.sol accepts a msg.value for cross-chain fees but only requires that it is greater than or equal to the required fee. If a user sends more than the required amount, the excess is not refunded. This is due to the lack of a refund mechanism after the fee validation. The root cause is improper handling of excess Ether sent by users. An attacker cannot directly exploit this for gain, but users are at risk of losing excess funds due to honest overpayment or front-running. The impact is financial loss for users who overpay fees, reducing trust and usability of the system.\n",
            "severity": "Low",
            "location": [
                "AsBnbMinter.sol::mintAsBnbToChain#243"
            ],
            "files": [
                "61fc9f5610914cf94dddc3ab83e21ca22d388e92/ass-bnb-earn-contract/src/AsBnbMinter.sol"
            ]
        }
    ],
    "affected_files": {
        "AsBnbMinter.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { SendParam, MessagingFee } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport { IOFTAdapter } from \"./interfaces/IOFTAdapter.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./interfaces/IAsBnbMinter.sol\";\nimport \"./interfaces/IAsBNB.sol\";\nimport \"./interfaces/IYieldProxy.sol\";\nimport \"./interfaces/IListaStakeManager.sol\";\nimport { YieldProxy } from \"./YieldProxy.sol\";\n\ncontract AsBnbMinter is\n  IAsBnbMinter,\n  Initializable,\n  AccessControlUpgradeable,\n  PausableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  UUPSUpgradeable\n{\n  using SafeERC20 for IERC20;\n  using SafeERC20 for IAsBNB;\n  // pause role\n  bytes32 public constant PAUSER = keccak256(\"PAUSER\");\n  // manager role\n  bytes32 public constant MANAGER = keccak256(\"MANAGER\");\n  // bot role\n  bytes32 public constant BOT = keccak256(\"BOT\");\n  // denominator\n  uint256 public constant DENOMINATOR = 10000;\n  // withdraw helper\n  bytes32 public constant WITHDRAW_HELPER = keccak256(\"WITHDRAW_HELPER\");\n\n  /* ======================\n        State Variables\n   ====================== */\n  // original token address\n  IERC20 public token;\n  // asBnb address\n  IAsBNB public asBnb;\n  // total tokens deposited\n  uint256 public totalTokens;\n  // fee will be charged when LaunchPool rewards are compounded\n  uint256 public feeRate;\n  // rewards available to withdraw\n  uint256 public feeAvailable;\n  // yield proxy\n  address public yieldProxy;\n  // mint queue, pending mint requests\n  // @notice when there is activity on going, the mint request will be added to this queue\n  mapping(uint256 => TokenMintReq) public tokenMintReqQueue;\n  // when the req at queueFront is processed, queueFront will be incremented\n  uint256 public queueFront;\n  // when there is a new mint req, queueRear will be incremented\n  uint256 public queueRear;\n  // minimum amount of token to mint\n  uint256 public minMintAmount;\n  // can withdraw\n  bool public canWithdraw;\n  // can deposit\n  bool public canDeposit;\n  // asBnb OFT Adapters (LayerZero Endpoint ID => asBnbOFTAdapter Address)\n  mapping(uint32 => address) public asBnbOFTAdapters;\n\n  /* ======================\n          Modifiers\n   ====================== */\n  modifier onlyYieldProxy() {\n    require(msg.sender == yieldProxy, \"Caller is not yieldProxy\");\n    _;\n  }\n\n  modifier depositEnabled() {\n    require(canDeposit, \"Deposit is disabled\");\n    _;\n  }\n\n  modifier withdrawalEnabled() {\n    require(canWithdraw, \"Withdrawal is disabled\");\n    _;\n  }\n\n  /* ======================\n            Events\n   ====================== */\n  event RewardsCompounded(address indexed sender, uint256 amountIn, uint256 lockAmount, uint256 fee);\n  event FeeRateUpdated(address indexed sender, uint256 oldFeeRate, uint256 newFeeRate);\n  event FeeWithdrawn(address indexed sender, address recipient, uint256 amount);\n  event AddToken(address indexed asBnb, address indexed token);\n  event TokenMintReqQueued(address indexed user, uint256 amountIn);\n  event TokenMintReqProcessed(address indexed user, uint256 amountIn, uint256 amountToMint);\n  event AsBnbMinted(address indexed user, uint256 amountIn, uint256 amountOut);\n  event AsBnbBurned(address indexed user, uint256 amountToBurn, uint256 releaseTokenAmount);\n  event MinMintAmountUpdated(address indexed sender, uint256 oldMinMintAmount, uint256 newMinMintAmount);\n  event CanDepositUpdated(address indexed sender, bool canDeposit);\n  event CanWithdrawUpdated(address indexed sender, bool canWithdraw);\n  event AsBnbOFTAdapterUpdated(uint32 indexed eid, address adapter);\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev initialize the contract\n   * @param _admin - Address of the admin\n   * @param _manager - Address of the manager\n   * @param _pauser - Address of the pauser\n   * @param _bot - Address of the bot\n   * @param _token - Address of the token\n   * @param _asBnb - Address of the asBnb\n   * @param _yieldProxy - Address of the yieldProxy\n   */\n  function initialize(\n    address _admin,\n    address _manager,\n    address _pauser,\n    address _bot,\n    address _token,\n    address _asBnb,\n    address _yieldProxy\n  ) external initializer {\n    require(_admin != address(0), \"Invalid admin address\");\n    require(_manager != address(0), \"Invalid manager address\");\n    require(_pauser != address(0), \"Invalid pauser address\");\n    require(_bot != address(0), \"Invalid bot address\");\n    require(_token != address(0), \"Invalid token address\");\n    require(_asBnb != address(0), \"Invalid AsBnb address\");\n    require(_yieldProxy != address(0), \"Invalid yieldProxy address\");\n\n    __Pausable_init();\n    __ReentrancyGuard_init();\n    __AccessControl_init();\n    __UUPSUpgradeable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    _grantRole(MANAGER, _manager);\n    _grantRole(PAUSER, _pauser);\n    _grantRole(BOT, _bot);\n\n    feeRate = 0;\n    token = IERC20(_token);\n    asBnb = IAsBNB(_asBnb);\n    yieldProxy = _yieldProxy;\n\n    // all open by default\n    canWithdraw = true;\n    canDeposit = true;\n\n    emit AddToken(_asBnb, _token);\n  }\n\n  /* ============================\n          External Getters\n  ============================ */\n  /**\n   * @dev convertToTokens  get token amount\n   * @param asBnbAmt - amount of asBnb\n   */\n  function convertToTokens(uint256 asBnbAmt) public view returns (uint256) {\n    uint256 totalSupply = asBnb.totalSupply();\n    // Refer to ERC4626\n    // https://docs.openzeppelin.com/contracts/4.x/erc4626#defending_with_a_virtual_offset\n    return FullMath.mulDiv(asBnbAmt, totalTokens + 1, totalSupply + 1);\n  }\n\n  /**\n   * @dev convertToAsBnb  get asBnb amount\n   * @param tokens - amount of token\n   */\n  function convertToAsBnb(uint256 tokens) public view returns (uint256) {\n    uint256 totalSupply = asBnb.totalSupply();\n    // refer to ERC4626's standard\n    return FullMath.mulDiv(tokens, totalSupply + 1, totalTokens + 1);\n  }\n\n  /* ============================\n        External Functions\n  ============================ */\n  /**\n   * @dev mint asBnb\n   * @param amountIn - amount of token\n   */\n  function mintAsBnb(uint256 amountIn) external override whenNotPaused depositEnabled nonReentrant returns (uint256) {\n    // transfer token from user to this contract\n    token.safeTransferFrom(msg.sender, address(this), amountIn);\n    return _mint(amountIn, msg.sender);\n  }\n\n  /**\n   * @dev mint asBnb with BNB\n   * @dev overload mintAsBnb\n   */\n  function mintAsBnb() external payable override whenNotPaused depositEnabled nonReentrant returns (uint256) {\n    // get transferred native token amount\n    uint256 nativeAmountIn = msg.value;\n    require(nativeAmountIn > 0, \"Invalid amount\");\n    uint256 amountIn = convertBnbToSlisBnb(nativeAmountIn);\n    return _mint(amountIn, msg.sender);\n  }\n\n  /**\n   * @dev mint asBnb for a user\n   * @param amountIn - amount of token\n   * @param forAddr - address of user\n   */\n  function mintAsBnbFor(\n    uint256 amountIn,\n    address forAddr\n  ) external override whenNotPaused depositEnabled nonReentrant onlyRole(WITHDRAW_HELPER) returns (uint256) {\n    // transfer token from user to this contract\n    token.safeTransferFrom(msg.sender, address(this), amountIn);\n    return _mint(amountIn, forAddr);\n  }\n\n  /**\n   * @dev mint asBnb for a user\n   * @dev overload mintAsBnbFor\n   * @param forAddr - address of user\n   */\n  function mintAsBnbFor(\n    address forAddr\n  ) external payable override whenNotPaused depositEnabled nonReentrant onlyRole(WITHDRAW_HELPER) returns (uint256) {\n    // get transferred native token amount\n    uint256 nativeAmountIn = msg.value;\n    require(nativeAmountIn > 0, \"Invalid amount\");\n    uint256 amountIn = convertBnbToSlisBnb(nativeAmountIn);\n    return _mint(amountIn, forAddr);\n  }\n\n  /**\n   * @dev mint asBnb and send to specific receiver at another chain\n   * @param amountIn - amount of token\n   * @param sendParam - SendParam of OFT\n   */\n  function mintAsBnbToChain(\n    uint256 amountIn,\n    SendParam memory sendParam\n  ) external payable override whenNotPaused depositEnabled nonReentrant returns (uint256) {\n    // get cross chain fee and validate the existence of OFTAdapter\n    MessagingFee memory fee = getCrossChainFee(sendParam);\n    require(msg.value >= fee.nativeFee, \"Invalid fee\");\n    // transfer token from user to this contract\n    token.safeTransferFrom(msg.sender, address(this), amountIn);\n\n    return _mintToChain(amountIn, sendParam, fee);\n  }\n\n  /**\n   * @dev mint asBnb and send to specific receiver at another chain\n   * @dev overload mintAsBnbToChain\n   * @param sendParam - SendParam of OFT\n   */\n  function mintAsBnbToChain(\n    SendParam memory sendParam\n  ) external payable override whenNotPaused depositEnabled nonReentrant returns (uint256) {\n    // get cross chain fee and validate the existence of OFTAdapter\n    MessagingFee memory fee = getCrossChainFee(sendParam);\n    require(msg.value >= fee.nativeFee, \"Invalid fee\");\n    // BNB left to mint slisBNB after fee is deducted\n    uint256 tokenAmtLeft = msg.value - fee.nativeFee;\n    // get amount in of slisBNB\n    uint256 amountIn = convertBnbToSlisBnb(tokenAmtLeft);\n\n    return _mintToChain(amountIn, sendParam, fee);\n  }\n\n  /**\n   * @dev burn asBnb\n   * @notice supports withdraw as slisBNB only\n   * @param amountToBurn - amount of asBnb to burn\n   */\n  function burnAsBnb(\n    uint256 amountToBurn\n  ) external override whenNotPaused withdrawalEnabled nonReentrant returns (uint256) {\n    require(amountToBurn > 0, \"Invalid amount to burn\");\n    // transfer asBnb from user to this contract\n    asBnb.safeTransferFrom(msg.sender, address(this), amountToBurn);\n    // get amount of token can be released\n    uint256 releaseTokenAmount = convertToTokens(amountToBurn);\n    // record token amount decrement\n    totalTokens -= releaseTokenAmount;\n    // burn asBnb\n    asBnb.burn(address(this), amountToBurn);\n    // withdraw slisBNB\n    IYieldProxy(yieldProxy).withdraw(releaseTokenAmount);\n    // transfer token to user\n    token.safeTransfer(msg.sender, releaseTokenAmount);\n\n    emit AsBnbBurned(msg.sender, amountToBurn, releaseTokenAmount);\n    return amountToBurn;\n  }\n\n  /**\n   * @dev compoundRewards\n   * @param amountIn - amount of token\n   */\n  function compoundRewards(uint256 amountIn) external override onlyYieldProxy whenNotPaused nonReentrant {\n    require(amountIn > 0, \"Invalid amount\");\n    // transfer token from YieldProxy\n    token.safeTransferFrom(msg.sender, address(this), amountIn);\n\n    // calculate fee and compound amount\n    uint256 fee = (amountIn * feeRate) / DENOMINATOR;\n    uint256 lockAmount = amountIn - fee;\n\n    // add up fees and total deposited tokens\n    feeAvailable += fee;\n    totalTokens += lockAmount;\n\n    // compound rewards\n    token.safeIncreaseAllowance(yieldProxy, lockAmount);\n    IYieldProxy(yieldProxy).deposit(lockAmount);\n\n    emit RewardsCompounded(msg.sender, amountIn, lockAmount, fee);\n  }\n\n  /**\n   * @dev process mint queue\n   *      token has been transferred to YieldProxy before queued,\n   *      the function will mint AsBNB to the defined recipient\n   * @notice this can be executed if and only if there is no on going activity\n   * @param batchSize - size of how much to process this time\n   */\n  function processMintQueue(uint256 batchSize) external whenNotPaused onlyRole(BOT) {\n    require(!IYieldProxy(yieldProxy).activitiesOnGoing(), \"Activity is on going\");\n    require(batchSize > 0, \"Invalid batch size\");\n    require(queueFront != queueRear, \"No pending mint request\");\n    for (uint256 i = 0; i < batchSize; ++i) {\n      // stop when batchSize is greater than the remaining queue size\n      // or reach to the end of the queue\n      if (queueFront == queueRear) {\n        break;\n      }\n      // get token mint req. from the queue\n      TokenMintReq memory req = tokenMintReqQueue[queueFront];\n      uint256 amountToMint = convertToAsBnb(req.amountIn);\n      // record token amount increment\n      totalTokens += req.amountIn;\n      // mint asBnb\n      asBnb.mint(req.user, amountToMint);\n      // remove request from the queue\n      delete tokenMintReqQueue[queueFront];\n      // increment queueFront\n      ++queueFront;\n      // emit event\n      emit TokenMintReqProcessed(req.user, req.amountIn, amountToMint);\n    }\n  }\n\n  /* ============================\n          Admin Functions\n  ============================ */\n  /**\n   * @dev Flips the pause state\n   */\n  function unpause() external onlyRole(MANAGER) {\n    _unpause();\n  }\n\n  /**\n   * @dev pause the contract\n   */\n  function pause() external onlyRole(PAUSER) {\n    _pause();\n  }\n\n  /**\n   * @dev toggle canDeposit\n   */\n  function toggleCanDeposit() external onlyRole(MANAGER) {\n    canDeposit = !canDeposit;\n    emit CanDepositUpdated(msg.sender, canDeposit);\n  }\n\n  /**\n   * @dev toggle canWithdraw\n   */\n  function toggleCanWithdraw() external onlyRole(MANAGER) {\n    canWithdraw = !canWithdraw;\n    emit CanWithdrawUpdated(msg.sender, canWithdraw);\n  }\n\n  /**\n   * @dev set fee rate\n   * @param _feeRate - fee rate which can be zero\n   */\n  function setFeeRate(uint256 _feeRate) external onlyRole(MANAGER) {\n    require(_feeRate >= 0 && _feeRate <= DENOMINATOR, \"Invalid fee rate\");\n    require(_feeRate != feeRate, \"_fee rate can't equals to old fee rate\");\n\n    uint256 oldFeeRate = feeRate;\n    // update new fee rate\n    feeRate = _feeRate;\n\n    emit FeeRateUpdated(msg.sender, oldFeeRate, _feeRate);\n  }\n\n  /**\n   * @dev set min. amount to mint\n   * @param _minMintAmount - minimum amount of token to mint\n   */\n  function setMinMintAmount(uint256 _minMintAmount) external onlyRole(MANAGER) {\n    require(_minMintAmount > 0 && _minMintAmount != minMintAmount, \"Invalid minMintAmount\");\n    uint256 oldMinMintAmount = minMintAmount;\n    minMintAmount = _minMintAmount;\n    emit MinMintAmountUpdated(msg.sender, oldMinMintAmount, _minMintAmount);\n  }\n\n  /**\n   * @dev withdraw collected fee from launchpool profits\n   * @param recipient - Address of the recipient\n   * @param withdrawAmount - amount of token\n   */\n  function withdrawFee(address recipient, uint256 withdrawAmount) external nonReentrant onlyRole(MANAGER) {\n    require(recipient != address(0), \"Invalid recipient address\");\n    require(withdrawAmount > 0 && withdrawAmount <= feeAvailable, \"Invalid withdrawAmount\");\n\n    feeAvailable -= withdrawAmount;\n    token.safeTransfer(recipient, withdrawAmount);\n\n    emit FeeWithdrawn(msg.sender, recipient, withdrawAmount);\n  }\n\n  function setAsBnbOFTAdapter(uint32 eid, address adapter) external onlyRole(MANAGER) {\n    // check eid only, adapter can be zero address if we want to disable it\n    require(eid > 0, \"Invalid eid\");\n    asBnbOFTAdapters[eid] = adapter;\n    emit AsBnbOFTAdapterUpdated(eid, adapter);\n  }\n\n  /* ============================\n        Internal Functions\n  ============================ */\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n  /**\n   * @dev Converts native token(BNB) to slisBNB\n   * @notice interacts with Lista's StakeManager\n   * @param amount - amount of BNB\n   */\n  function convertBnbToSlisBnb(uint256 amount) private returns (uint256 net) {\n    // get pre-balance of slisBNB\n    uint256 preBalance = token.balanceOf(address(this));\n    // get stake manager address from YieldProxy\n    address _stakeManagerAddress = IYieldProxy(yieldProxy).stakeManager();\n    // convert BNB to slisBNB\n    IListaStakeManager(_stakeManagerAddress).deposit{ value: amount }();\n    // get post-balance of slisBNB\n    uint256 postBalance = token.balanceOf(address(this));\n    // get amount of slisBNB minted\n    net = postBalance - preBalance;\n  }\n\n  /**\n   * @dev mint asBnb\n   * @param amountIn - amount of token\n   * @param forAddr - address of user\n   */\n  function _mint(uint256 amountIn, address forAddr) private returns (uint256) {\n    require(amountIn >= minMintAmount, \"amount is less than minMintAmount\");\n    // transfer slisBNB to yieldProxy\n    token.safeIncreaseAllowance(yieldProxy, amountIn);\n    IYieldProxy(yieldProxy).deposit(amountIn);\n\n    // queue mint request if there is on going activity\n    if (IYieldProxy(yieldProxy).activitiesOnGoing()) {\n      // set queueFront tokenMintReq\n      tokenMintReqQueue[queueRear] = TokenMintReq(forAddr, amountIn);\n      // increment queueRear\n      ++queueRear;\n      // emit event\n      emit TokenMintReqQueued(forAddr, amountIn);\n      return 0;\n    } else {\n      // calculate amount to mint\n      uint256 amountToMint = convertToAsBnb(amountIn);\n      // record token amount increment\n      totalTokens += amountIn;\n      // mint asBnb\n      asBnb.mint(forAddr, amountToMint);\n      // emit event\n      emit AsBnbMinted(forAddr, amountIn, amountToMint);\n      return amountToMint;\n    }\n  }\n\n  /**\n   * @dev mint asBnb and send to receiver at another chain\n   * @param amountIn - amount of token to mint and send\n   * @param sendParam - SendParam of OFT\n   */\n  function _mintToChain(\n    uint256 amountIn,\n    SendParam memory sendParam,\n    MessagingFee memory fee\n  ) private returns (uint256) {\n    require(!IYieldProxy(yieldProxy).activitiesOnGoing(), \"Activity is on going\");\n    require(amountIn >= minMintAmount, \"amount is less than minMintAmount\");\n\n    // transfer slisBNB to yieldProxy\n    token.safeIncreaseAllowance(yieldProxy, amountIn);\n    IYieldProxy(yieldProxy).deposit(amountIn);\n\n    // calculate amount to mint\n    uint256 amountToMint = convertToAsBnb(amountIn);\n    /**\n      @dev referring to the _debitView() method in OFTCoreUpgradeable.sol,\n      only 6 decimal places will be counted when cross-chain,\n\n      so the actual minted amount will less than the amount to mint,\n      for example, amountToMint = 0.123456789012345678\n      but only 0.123456 will be mint and send across the chain\n\n      user will mint less asBNB with the same amount of slisBNB\n      but the loss is negligible (0.000000xxxx slisBNB)\n    */\n    // get decimal conversion rate\n    uint256 decimalConversionRate = IOFTAdapter(asBnbOFTAdapters[sendParam.dstEid]).decimalConversionRate();\n    // remove numbers after 6th decimal place\n    uint256 actualAmountToMint = (amountToMint / decimalConversionRate) * decimalConversionRate;\n    // ensure amount to mint is the same as the amount to cross-chain\n    require(actualAmountToMint == sendParam.amountLD, \"Amount to cross-chain is not the same as actual amount to mint\");\n    // record token amount increment\n    totalTokens += amountIn;\n    // mint asBnb\n    asBnb.mint(address(this), actualAmountToMint);\n\n    // request cross-chain\n    asBnb.safeIncreaseAllowance(asBnbOFTAdapters[sendParam.dstEid], actualAmountToMint);\n    IOFTAdapter(asBnbOFTAdapters[sendParam.dstEid]).send{ value: fee.nativeFee }(sendParam, fee, msg.sender);\n\n    // emit event\n    emit AsBnbMinted(msg.sender, amountIn, actualAmountToMint);\n\n    return actualAmountToMint;\n  }\n\n  /**\n   * @dev get cross chain fee\n   * @param sendParam - SendParam of OFT\n   * @return fee - cross chain fee (in BNB)\n   */\n  function getCrossChainFee(SendParam memory sendParam) private view returns (MessagingFee memory fee) {\n    require(asBnbOFTAdapters[sendParam.dstEid] != address(0), \"OFTAdapter not found\");\n    // get OFTAdapter\n    IOFTAdapter oftAdapter = IOFTAdapter(asBnbOFTAdapters[sendParam.dstEid]);\n    // quote fee\n    fee = oftAdapter.quoteSend(sendParam, false);\n  }\n}\n"
    }
}