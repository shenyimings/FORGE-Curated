{
    "vfp_id": "vfp_00334",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Missing forced distribution before changed capital ratio scenarios causes incorrect accrued staking rewards distribution",
            "description": "The reduceBond() function correctly forces a reward distribution before adjusting the capital ratio, but other functions that affect the capital ratio—dequeue(), dissolveValidator(), and notifyFinalBalance()—do not perform this step.\n\nThe root cause is inconsistent implementation of reward distribution logic across functions that modify the capital ratio.\n\nA node operator could exploit this by calling these functions without triggering distribution, thereby deferring rewards to a later time when the capital ratio is less favorable, resulting in incorrect reward allocation.\n\nThe impact is incorrect distribution of staking rewards, potentially leading to financial loss for node operators or unfair advantage depending on timing.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolDelegate.sol#L255-L259"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Allowing distribute() to be called before the first staked validator may cause inaccuracy in rewards distribution",
            "description": "The distribute() function updates lastDistributionBlock to block.number even if no validator has been staked yet. This allows anyone who donates ETH and calls distribute() to set this value prematurely.\n\nThe root cause is the lack of a guard clause preventing distribute() from being called before the first validator is staked.\n\nAn attacker could manipulate the time-weighted average commission calculation by forcing an early distribution, skewing future reward calculations if the commission rate changes before the first validator is staked.\n\nThe impact is inaccuracy in staking reward calculations, potentially leading to unfair distribution of rewards.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolDelegate.sol#L306-L308",
                "RocketMegapoolDelegate.sol#L411"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Missing conditional check for exit challenge creation deviates from RPIP-72 specification",
            "description": "RPIP-72 specifies that oDAO members should only be able to create an exit challenge if a node operator fails to notify exit more than notify_threshold before withdrawable_epoch. However, challengeExit() lacks this check.\n\nThe root cause is the omission of time-based validation in the challengeExit() function, unlike notifyExit(), which enforces the rule.\n\nThis allows oDAO members to create challenges at any time, deviating from the specification and potentially enabling premature or unjust challenges.\n\nThe impact is a deviation from protocol specification and potential for abuse in the challenge system, though RocketPool acknowledges this as an intentional optimistic safeguard.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolDelegate.sol#L496-L514",
                "RocketMegapoolDelegate.sol#L560-L564"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 62,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Not using leading underscore for private/internal function names reduces readability",
            "description": "Several internal or private functions do not follow the Solidity naming convention of prefixing with an underscore, reducing code readability and maintainability. \nThe root cause is deviation from established naming conventions, likely due to inconsistent coding standards. \nWhile this cannot be directly exploited by an attacker, it may lead to confusion during code review or maintenance, increasing the risk of introducing bugs. \nThe impact is limited to developer experience and long-term codebase hygiene.\n",
            "severity": "Informational",
            "location": [
                "RocketMegapoolDelegate.sol#L690",
                "RocketMegapoolDelegate.sol#L699",
                "RocketMegapoolDelegate.sol#L707",
                "RocketMegapoolDelegate.sol#L718",
                "RocketStorage.sol#L145"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 63,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Resetting validator.expressUsed and validator.lastAssignmentTime will avoid stale values",
            "description": "The state variables `validator.expressUsed` in `dequeue()` and `validator.lastAssignmentTime` in `dissolveValidator()` are not reset, potentially leaving stale values in storage. \nThe root cause is incomplete state cleanup upon validator removal or dequeueing. \nAn attacker could potentially exploit this by reusing old validator data if the system relies on these fields for decision-making without proper initialization checks. \nThe impact is limited to potential logic errors or incorrect state assumptions in validator management, with low security risk.\n",
            "severity": "Informational",
            "location": [
                "RocketMegapoolDelegate.sol#L215-L242",
                "RocketMegapoolDelegate.sol#L334-L367"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketMegapoolDelegate.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {DepositInterface} from \"../../interface/casper/DepositInterface.sol\";\nimport {RocketDAOProtocolSettingsMegapoolInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMegapoolInterface.sol\";\nimport {RocketDepositPoolInterface} from \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport {RocketMegapoolDelegateBase} from \"./RocketMegapoolDelegateBase.sol\";\nimport {RocketMegapoolDelegateInterface} from \"../../interface/megapool/RocketMegapoolDelegateInterface.sol\";\nimport {RocketMegapoolStorageLayout} from \"./RocketMegapoolStorageLayout.sol\";\nimport {RocketNetworkRevenuesInterface} from \"../../interface/network/RocketNetworkRevenuesInterface.sol\";\nimport {RocketNodeDepositInterface} from \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport {RocketRewardsPoolInterface} from \"../../interface/rewards/RocketRewardsPoolInterface.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketTokenRETHInterface} from \"../../interface/token/RocketTokenRETHInterface.sol\";\n\n/// @notice This contract manages multiple validators belonging to an individual node operator.\n///         It serves as the withdrawal credentials for all Beacon Chain validators managed by it.\ncontract RocketMegapoolDelegate is RocketMegapoolDelegateBase, RocketMegapoolDelegateInterface {\n    // Constants\n    uint256 constant internal prestakeValue = 1 ether;\n    uint256 constant internal fullDepositValue = 32 ether;\n    uint256 constant internal milliToWei = 10 ** 15;\n    uint256 constant internal calcBase = 1 ether;\n    uint256 constant internal secondsPerSlot = 12;\n    uint256 constant internal slotsPerEpoch = 32;\n\n    // Events\n    event MegapoolValidatorEnqueued(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorDequeued(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorAssigned(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorExited(uint32 indexed validatorId, uint256 time);\n    event MegapoolValidatorExiting(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorLocked(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorUnlocked(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorDissolved(uint256 indexed validatorId, uint256 time);\n    event MegapoolValidatorStaked(uint256 indexed validatorId, uint256 time);\n    event MegapoolPenaltyApplied(uint256 amount, uint256 time);\n    event MegapoolDebtIncreased(uint256 amount, uint256 time);\n    event MegapoolDebtReduced(uint256 amount, uint256 time);\n    event MegapoolBondReduced(uint256 amount, uint256 time);\n    event RewardsDistributed(uint256 nodeAmount, uint256 voterAmount, uint256 rethAmount, uint256 time);\n    event RewardsClaimed(uint256 amount, uint256 time);\n\n    // Immutables\n    bytes32 immutable internal rocketDepositPoolKey;\n    bytes32 immutable internal rocketMegapoolManagerKey;\n    bytes32 immutable internal rocketNodeDepositKey;\n    address payable immutable internal rocketTokenRETH;\n    DepositInterface immutable internal casperDeposit;\n    uint256 immutable internal genesisTime;\n\n    modifier onlyRocketMegapoolManager() {\n        require(msg.sender == rocketStorage.getAddress(rocketMegapoolManagerKey), \"Invalid or outdated contract\");\n        _;\n    }\n\n    modifier onlyRocketNodeDeposit() {\n        require(msg.sender == rocketStorage.getAddress(rocketNodeDepositKey), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _rocketStorageAddress Address of the deployments RocketStorage\n    /// @param _beaconGenesisTime Chain specific genesis time for calculating current slots and epochs\n    constructor(RocketStorageInterface _rocketStorageAddress, uint256 _beaconGenesisTime) RocketMegapoolDelegateBase(_rocketStorageAddress, 1) {\n        // Precompute static storage keys\n        rocketDepositPoolKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketDepositPool\"));\n        rocketMegapoolManagerKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketMegapoolManager\"));\n        rocketNodeDepositKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketNodeDeposit\"));\n        // Prefetch immutable contracts\n        rocketTokenRETH = payable(getContractAddress(\"rocketTokenRETH\"));\n        casperDeposit = DepositInterface(getContractAddress(\"casperDeposit\"));\n        // Set other immutables\n        genesisTime = _beaconGenesisTime;\n    }\n\n    /// @notice Gets the Node address associated to this megapool\n    function getNodeAddress() public override view returns (address) {\n        return nodeAddress;\n    }\n\n    /// @notice Returns the number of validators created for this megapool\n    function getValidatorCount() override external view returns (uint32) {\n        return numValidators;\n    }\n\n    /// @notice Returns the number of validators that are considered for bond requirement\n    function getActiveValidatorCount() override public view returns (uint32) {\n        return numValidators - numInactiveValidators;\n    }\n\n    /// @notice Returns the number of validators currently exiting\n    function getExitingValidatorCount() external view returns (uint32) {\n        return numExitingValidators;\n    }\n\n    /// @notice Returns the number of validators locked by a exit challenge\n    function getLockedValidatorCount() external view returns (uint32) {\n        return numLockedValidators;\n    }\n\n    /// @notice Returns the soonest epoch a validator within this megapool can be withdrawn\n    function getSoonestWithdrawableEpoch() external view returns (uint64) {\n        return soonestWithdrawableEpoch;\n    }\n\n    /// @notice Returns information about a given validator\n    function getValidatorInfo(uint32 _validatorId) override external view returns (ValidatorInfo memory) {\n        return validators[_validatorId];\n    }\n\n    /// @notice Returns information about a given validator\n    function getValidatorPubkey(uint32 _validatorId) override external view returns (bytes memory) {\n        return pubkeys[_validatorId];\n    }\n\n    /// @notice Returns both validator information and pubkey\n    /// @param _validatorId Internal ID of the validator to query\n    function getValidatorInfoAndPubkey(uint32 _validatorId) override external view returns (ValidatorInfo memory info, bytes memory pubkey) {\n        info = validators[_validatorId];\n        pubkey = pubkeys[_validatorId];\n    }\n\n    /// @notice Returns the amount of ETH temporarily held in this contract from the protocol ready to be staked\n    function getAssignedValue() override external view returns (uint256) {\n        return assignedValue;\n    }\n\n    /// @notice Returns the amount of ETH the node operator owes the protocol\n    function getDebt() override external view returns (uint256) {\n        return debt;\n    }\n\n    /// @notice Returns the amount of ETH available to refund to the node operator\n    function getRefundValue() override external view returns (uint256) {\n        return refundValue;\n    }\n\n    /// @notice Returns the amount of ETH supplied by the node operator (Bonded ETH)\n    function getNodeBond() override external view returns (uint256) {\n        return nodeBond;\n    }\n\n    /// @notice Returns the amount of ETH capital provided by the protocol (Borrowed ETH)\n    function getUserCapital() override external view returns (uint256) {\n        return userCapital;\n    }\n\n    /// @notice Returns the amount in wei of pending rewards ready to be distributed\n    function getPendingRewards() override public view returns (uint256) {\n        return\n            address(this).balance\n            - refundValue\n            - assignedValue;\n    }\n\n    /// @notice Returns the block number of the last distribution performed\n    function getLastDistributionBlock() override external view returns (uint256) {\n        return lastDistributionBlock;\n    }\n\n    /// @notice Returns the expected withdrawal credentials for any validator within this megapool\n    function getWithdrawalCredentials() override public view returns (bytes32) {\n        return bytes32((uint256(0x01) << 248) | uint256(uint160(address(this))));\n    }\n\n    /// @notice Creates a new validator for this megapool\n    /// @param _bondAmount The bond amount supplied by the node operator\n    /// @param _useExpressTicket If an express ticket should be used\n    /// @param _validatorPubkey The pubkey of the new validator\n    /// @param _validatorSignature A signature over the deposit data root\n    /// @param _depositDataRoot Merkle root of the deposit data\n    function newValidator(uint256 _bondAmount, bool _useExpressTicket, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external onlyRocketNodeDeposit {\n        // Check bond and debt requirements\n        {\n            RocketNodeDepositInterface rocketNodeDeposit = getRocketNodeDeposit();\n            uint256 newBondRequirement = rocketNodeDeposit.getBondRequirement(getActiveValidatorCount() + 1);\n            if (newBondRequirement > nodeBond) {\n                require(_bondAmount + nodeBond == newBondRequirement, \"Bond requirement not met\");\n            }\n            require(debt == 0, \"Cannot create validator while debt exists\");\n        }\n        // Setup new validator\n        RocketDepositPoolInterface rocketDepositPool = getRocketDepositPool();\n        uint32 validatorId = uint32(numValidators);\n        unchecked { // Infeasible overflow\n            numValidators += 1;\n        }\n        {\n            ValidatorInfo memory validator;\n            validator.inQueue = true;\n            validator.lastRequestedBond = uint32(_bondAmount / milliToWei);\n            validator.lastRequestedValue = uint32(fullDepositValue / milliToWei);\n            validator.expressUsed = _useExpressTicket;\n            validators[validatorId] = validator;\n        }\n        // Store prestake data and pubkey\n        prestakeSignatures[validatorId] = _validatorSignature;\n        pubkeys[validatorId] = _validatorPubkey;\n        // Compute and verify supplied deposit data root is correct\n        // Note: We check this here to ensure the deposit contract will not revert when executing prestake\n        bytes32 depositDataRoot = computeDepositDataRoot(_validatorPubkey, _validatorSignature, uint64(prestakeValue / 1 gwei));\n        require(depositDataRoot == _depositDataRoot, \"Invalid deposit data root\");\n        // Increase total bond used for bond requirement calculations\n        nodeBond += _bondAmount;\n        userCapital += fullDepositValue - _bondAmount;\n        // Request full deposit amount from deposit pool\n        rocketDepositPool.requestFunds(_bondAmount, validatorId, fullDepositValue, _useExpressTicket);\n        // Emit event\n        emit MegapoolValidatorEnqueued(validatorId, block.timestamp);\n    }\n\n    /// @notice Removes a validator from the deposit queue\n    /// @param _validatorId the validator ID\n    function dequeue(uint32 _validatorId) external onlyMegapoolOwner {\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Validate validator status\n        require(validator.inQueue, \"Validator must be in queue\");\n        // Decrease total bond used for bond requirement calculations\n        uint256 requestedValue = uint256(validator.lastRequestedValue) * milliToWei;\n        (uint256 nodeShare, uint256 userShare) = calculateCapitalDispersal(requestedValue, getActiveValidatorCount() - 1);\n        userCapital -= userShare;\n        // Dequeue validator from the deposit pool and issue credit\n        RocketDepositPoolInterface rocketDepositPool = getRocketDepositPool();\n        rocketDepositPool.exitQueue(nodeAddress, _validatorId, validator.expressUsed);\n        rocketDepositPool.fundsReturned(nodeAddress, nodeShare, userShare);\n        if (nodeShare > 0) {\n            nodeBond -= nodeShare;\n            rocketDepositPool.applyCredit(nodeAddress, nodeShare);\n        }\n        // Increment inactive validator count\n        unchecked { // Infeasible overflow\n            numInactiveValidators += 1;\n        }\n        // Update validator state\n        validator.inQueue = false;\n        validator.lastRequestedBond = 0;\n        validator.lastRequestedValue = 0;\n        validators[_validatorId] = validator;\n        // Emit event\n        emit MegapoolValidatorDequeued(_validatorId, block.timestamp);\n    }\n\n    /// @notice Reduces this megapool's bond and applies credit if current bond exceeds requirement\n    /// @param _amount Amount in ETH to reduce bond by\n    function reduceBond(uint256 _amount) override external onlyMegapoolOwner {\n        // Check pre-conditions\n        require(_amount > 0, \"Invalid amount\");\n        require(debt == 0, \"Cannot reduce bond with debt\");\n        RocketNodeDepositInterface rocketNodeDeposit = getRocketNodeDeposit();\n        uint256 newBondRequirement = rocketNodeDeposit.getBondRequirement(getActiveValidatorCount());\n        require(nodeBond > newBondRequirement, \"Bond is at minimum\");\n        uint256 maxReduce = nodeBond - newBondRequirement;\n        require(_amount <= maxReduce, \"New bond is too low\");\n        // Force distribute at previous capital ratio\n        uint256 pendingRewards = getPendingRewards();\n        if (pendingRewards > 0) {\n            _distributeAmount(pendingRewards);\n        }\n        // Reduce node bond\n        nodeBond -= _amount;\n        userCapital += _amount;\n        // Apply credit\n        RocketDepositPoolInterface rocketDepositPool = getRocketDepositPool();\n        rocketDepositPool.applyCredit(nodeAddress, _amount);\n        rocketDepositPool.reduceBond(nodeAddress, _amount);\n        // Emit event\n        emit MegapoolBondReduced(_amount, block.timestamp);\n    }\n\n    /// @notice Accepts requested funds from the deposit pool\n    /// @param _validatorId the validator ID\n    function assignFunds(uint32 _validatorId) external payable onlyLatestContract(\"rocketDepositPool\", msg.sender) {\n        // Fetch validator data from storage\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Update validator status\n        validator.inQueue = false;\n        validator.inPrestake = true;\n        validator.lastAssignmentTime = uint32(block.timestamp);\n        // Record value assigned from deposit pool (subtract prestakeValue as it is going to deposit contract now)\n        validator.depositValue += uint32(prestakeValue / milliToWei);\n        assignedValue += msg.value - prestakeValue;\n        validators[_validatorId] = validator;\n        // Execute prestake operation\n        bytes memory signature = prestakeSignatures[_validatorId];\n        bytes memory pubkey = pubkeys[_validatorId];\n        bytes32 depositDataRoot = computeDepositDataRoot(pubkey, signature, uint64(prestakeValue / 1 gwei));\n        casperDeposit.deposit{value: prestakeValue}(pubkey, abi.encodePacked(getWithdrawalCredentials()), signature, depositDataRoot);\n        // Delete prestake signature for a small gas refund (no longer needed)\n        delete prestakeSignatures[_validatorId];\n        // Emit event\n        emit MegapoolValidatorAssigned(_validatorId, block.timestamp);\n    }\n\n    /// @notice Performs the remaining ETH deposit on the Beacon Chain\n    /// @param _validatorId The internal ID of the validator in this megapool\n    /// @param _validatorIndex The validator's index on the beacon chain\n    function stake(uint32 _validatorId, uint64 _validatorIndex) external onlyRocketMegapoolManager {\n        // Retrieve validator from storage\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Validate validator status\n        require(validator.inPrestake, \"Validator must be pre-staked\");\n        // Store last requested value for later\n        uint32 lastRequestedValue = validator.lastRequestedValue;\n        // If this is the first validator, then set the last distribution block\n        if (lastDistributionBlock == 0) {\n            lastDistributionBlock = block.number;\n        }\n        // Account for assigned value\n        uint256 assignedUsed = lastRequestedValue * milliToWei - prestakeValue;\n        assignedValue -= assignedUsed;\n        // Update validator status\n        validator.staked = true;\n        validator.inPrestake = false;\n        validator.lastAssignmentTime = 0;\n        validator.lastRequestedBond = 0;\n        validator.lastRequestedValue = 0;\n        validator.validatorIndex = _validatorIndex;\n        validator.depositValue += uint32(lastRequestedValue - prestakeValue / milliToWei);\n        validators[_validatorId] = validator;\n        // Perform remaining 31 ETH stake onto beaconchain\n        // Note: Signature is not verified on subsequent deposits and we know the validator is valid due to state proof\n        bytes memory signature = hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        bytes memory pubkey = pubkeys[_validatorId];\n        bytes32 depositDataRoot = computeDepositDataRoot(pubkey, signature, uint64(assignedUsed / 1 gwei));\n        casperDeposit.deposit{value: assignedUsed}(pubkey, abi.encodePacked(getWithdrawalCredentials()), signature, depositDataRoot);\n        // Emit event\n        emit MegapoolValidatorStaked(_validatorId, block.timestamp);\n    }\n\n    /// @notice Dissolves a validator that has not staked within the required period\n    /// @param _validatorId the validator ID to dissolve\n    /// @dev \"Time before dissolve\" parameter must be respected if not called from RocketMegapoolManager\n    function dissolveValidator(uint32 _validatorId) override external {\n        // Retrieve validator from storage\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Check current status\n        require(validator.inPrestake, \"Validator not prestaked\");\n        // Ensure scrub period has passed before allowing dissolution\n        if (msg.sender != rocketStorage.getAddress(rocketMegapoolManagerKey)) {\n            RocketDAOProtocolSettingsMegapoolInterface rocketDAOProtocolSettingsMegapool = RocketDAOProtocolSettingsMegapoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMegapool\"));\n            uint256 timeBeforeDissolve = rocketDAOProtocolSettingsMegapool.getTimeBeforeDissolve();\n            require(block.timestamp > validator.lastAssignmentTime + timeBeforeDissolve, \"Not enough time has passed\");\n        }\n        // Update validator info\n        validator.inPrestake = false;\n        validator.dissolved = true;\n        validators[_validatorId] = validator;\n        // Decrease total bond used for bond requirement calculations\n        uint256 recycleValue = uint256(validator.lastRequestedValue) * milliToWei;\n        (uint256 nodeShare, uint256 userShare) = calculateCapitalDispersal(recycleValue, getActiveValidatorCount() - 1);\n        nodeBond -= nodeShare;\n        userCapital -= userShare;\n        unchecked { // Infeasible overflow\n            numInactiveValidators += 1;\n        }\n        // Recycle ETH\n        assignedValue -= recycleValue - prestakeValue;\n        if (userShare > 0) {\n            RocketDepositPoolInterface rocketDepositPool = getRocketDepositPool();\n            rocketDepositPool.recycleDissolvedDeposit{value: userShare}();\n            rocketDepositPool.fundsReturned(nodeAddress, nodeShare, userShare);\n        }\n        refundValue += nodeShare - prestakeValue;\n        // Emit event\n        emit MegapoolValidatorDissolved(_validatorId, block.timestamp);\n    }\n\n    /// @notice Receives ETH, which is sent to the rETH contract, to repay a debt owed by the node operator\n    function repayDebt() override external payable {\n        require(msg.value > 0, \"Invalid value received\");\n        _repayDebt(msg.value);\n    }\n\n    /// @dev Internal implementation of the repay debt function\n    /// @param _amount Amount of debt to repay\n    function _repayDebt(uint256 _amount) internal {\n        require(debt >= _amount, \"Not enough debt\");\n        sendToRETH(_amount);\n        _reduceDebt(_amount);\n    }\n\n    /// @notice Distributes any accrued staking rewards\n    function distribute() override public {\n        // Calculate split of rewards\n        uint256 rewards = getPendingRewards();\n        if (rewards == 0) {\n            return;\n        }\n        _distributeAmount(rewards);\n        // If owner is calling, claim immediately\n        if (isNodeCalling(msg.sender)) {\n            _claim();\n        }\n    }\n\n    /// @dev Internal implementation of distribute process\n    /// @param _rewards Amount of rewards to distribute\n    function _distributeAmount(uint256 _rewards) internal {\n        // Cannot distribute a megapool with exiting validators\n        if (numExitingValidators > 0) {\n            uint256 currentEpoch = getCurrentEpoch();\n            if (currentEpoch >= soonestWithdrawableEpoch) {\n                revert(\"Pending validator exit\");\n            }\n        }\n        // Cannot distribute if challenged by oDAO\n        require(numLockedValidators == 0, \"Megapool locked\");\n        (uint256 nodeAmount, uint256 voterAmount, uint256 protocolDAOAmount, uint256 rethAmount) = calculateRewards(_rewards);\n        // Update last distribution block for use in calculating time-weighted average commission\n        lastDistributionBlock = block.number;\n        // Maybe repay debt from node share\n        if (debt > 0) {\n            uint256 amountToRepay = nodeAmount;\n            if (amountToRepay > debt) {\n                amountToRepay = debt;\n            }\n            nodeAmount -= amountToRepay;\n            _repayDebt(amountToRepay);\n        }\n        // Send user share to rETH\n        sendToRETH(rethAmount);\n        // Send voter share to rewards pool\n        if (voterAmount > 0) {\n            RocketRewardsPoolInterface rocketRewardsPool = RocketRewardsPoolInterface(getContractAddress(\"rocketRewardsPool\"));\n            rocketRewardsPool.depositVoterShare{value: voterAmount}();\n        }\n        // Protocol DAO share to rocketClaimDAO\n        if (protocolDAOAmount > 0) {\n            address rocketClaimDAO = getContractAddress(\"rocketClaimDAO\");\n            (bool success,) = rocketClaimDAO.call{value: protocolDAOAmount}(\"\");\n            require(success, \"Failed to send protocol DAO rewards\");\n        }\n        // Increase node rewards value\n        refundValue += nodeAmount;\n        // Emit event\n        emit RewardsDistributed(nodeAmount, voterAmount, rethAmount, block.timestamp);\n    }\n\n    /// @notice Claims any distributed but unclaimed rewards\n    function claim() override public onlyMegapoolOwner() {\n        _claim();\n    }\n\n    /// @dev Internal implementation of claim process\n    function _claim() internal {\n        uint256 amountToSend = refundValue;\n        // If node operator has a debt, pay that off first\n        if (debt > 0) {\n            if (debt > amountToSend) {\n                _repayDebt(amountToSend);\n                amountToSend = 0;\n            } else {\n                amountToSend -= debt;\n                _repayDebt(debt);\n            }\n        }\n        // Zero out refund value\n        refundValue = 0;\n        // If there is still an amount to send after debt, do so now\n        if (amountToSend > 0) {\n            address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n            (bool success,) = nodeWithdrawalAddress.call{value: amountToSend}(\"\");\n            require(success, \"Failed to send ETH\");\n        }\n        // Emit event\n        emit RewardsClaimed(amountToSend, block.timestamp);\n    }\n\n    /// @notice Returns the calculated split of pending rewards\n    function calculatePendingRewards() override external view returns (uint256 nodeRewards, uint256 voterRewards, uint256 protocolDAORewards, uint256 rethRewards) {\n        return calculateRewards(getPendingRewards());\n    }\n\n    /// @notice Calculates the split of rewards for a given amount of ETH\n    /// @param _amount Amount of rewards in gwei to calculate the split of\n    function calculateRewards(uint256 _amount) public view returns (uint256 nodeRewards, uint256 voterRewards, uint256 protocolDAORewards, uint256 rethRewards) {\n        // Early out for edge cases\n        if (_amount == 0) return (0, 0, 0, 0);\n        uint256 totalCapital = nodeBond + userCapital;\n        if (totalCapital == 0) return (_amount, 0, 0, 0);\n        // Calculate split based on capital ratio and average commission since last distribute\n        RocketNetworkRevenuesInterface rocketNetworkRevenues = RocketNetworkRevenuesInterface(getContractAddress(\"rocketNetworkRevenues\"));\n        (, uint256 voterShare, uint256 protocolDAOShare, uint256 rethShare) = rocketNetworkRevenues.calculateSplit(lastDistributionBlock);\n        unchecked {\n            uint256 borrowedPortion = _amount * userCapital / (nodeBond + userCapital);\n            rethRewards = rethShare * borrowedPortion / calcBase;\n            voterRewards = voterShare * borrowedPortion / calcBase;\n            protocolDAORewards = protocolDAOShare * borrowedPortion / calcBase;\n            nodeRewards = _amount - rethRewards - voterRewards - protocolDAORewards;\n        }\n    }\n\n    /// @notice Used to optimistically lock a megapool with an oDAO challenging that a validator has exited\n    /// @param _validatorId Internal ID of the validator to lock\n    function challengeExit(uint32 _validatorId) override external onlyRocketMegapoolManager {\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Check required state\n        require(validator.staked, \"Validator not staked\");\n        require(!validator.exiting, \"Already exiting\");\n        require(!validator.exited, \"Already exited\");\n        // Only the first challenge increments the lock counter, subsequent challenges only update the lockedSlot\n        if (!validator.locked) {\n            validator.locked = true;\n            unchecked { // Infeasible overflow\n                numLockedValidators += 1;\n            }\n        }\n        // Update locked slot to current slot\n        validator.lockedSlot = getCurrentSlot();\n        validators[_validatorId] = validator;\n        // Emit event\n        emit MegapoolValidatorLocked(_validatorId, block.timestamp);\n    }\n\n    /// @notice Unlocks a challenged validator\n    /// @param _validatorId Internal ID of the validator to lock\n    /// @param _slot The slot at which it was proved the validator is not exiting\n    function notifyNotExit(uint32 _validatorId, uint64 _slot) override external onlyRocketMegapoolManager {\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Check required state\n        require(validator.locked, \"Validator not locked\");\n        require(_slot >= validator.lockedSlot, \"Proof is older than challenge\");\n        // Update validator state to exiting/locked\n        validator.locked = false;\n        // Decrement locked validator counter\n        numLockedValidators -= 1;\n        validators[_validatorId] = validator;\n        // Emit event\n        emit MegapoolValidatorUnlocked(_validatorId, block.timestamp);\n    }\n\n    /// @notice Used to notify the megapool that one of its validators is exiting the beaconchain\n    /// @param _validatorId Internal ID of the validator to notify exit for\n    /// @param _withdrawableEpoch The proven withdrawable_epoch value for the validator\n    function notifyExit(uint32 _validatorId, uint64 _withdrawableEpoch) override external onlyRocketMegapoolManager {\n        ValidatorInfo memory validator = validators[_validatorId];\n        // Check required state\n        require(validator.staked || validator.dissolved, \"Not staking or dissolved\");\n        require(!validator.exiting, \"Already notified\");\n        require(!validator.exited, \"Already exited\");\n        // Update validator state to exiting\n        validator.exiting = true;\n        validator.withdrawableEpoch = _withdrawableEpoch;\n        // Setup distribution lock\n        unchecked { // Infeasible overflow\n            numExitingValidators += 1;\n        }\n        if (_withdrawableEpoch < soonestWithdrawableEpoch || soonestWithdrawableEpoch == 0) {\n            soonestWithdrawableEpoch = _withdrawableEpoch;\n        }\n        // If validator was locked, notifying exit unlocks it\n        if (validator.locked) {\n            validator.locked = false;\n            numLockedValidators -= 1;\n        }\n        validators[_validatorId] = validator;\n        // Apply penalty for late submission\n        RocketDAOProtocolSettingsMegapoolInterface rocketDAOProtocolSettingsMegapool = RocketDAOProtocolSettingsMegapoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMegapool\"));\n        uint256 notifyThreshold = rocketDAOProtocolSettingsMegapool.getNotifyThreshold();\n        uint256 withdrawableTime = genesisTime + (_withdrawableEpoch * secondsPerSlot * slotsPerEpoch);\n        if (block.timestamp + notifyThreshold > withdrawableTime) {\n            _increaseDebt(rocketDAOProtocolSettingsMegapool.getLateNotifyFine());\n        }\n        // Emit event\n        emit MegapoolValidatorExiting(_validatorId, block.timestamp);\n    }\n\n    /// @notice Used to notify the megapool of the final balance of an exited validator\n    /// @param _validatorId Internal ID of the validator to notify final balance of\n    /// @param _amountInGwei The amount in the final withdrawal\n    /// @param _caller The address which is submitted the final balance (i.e. msg.sender passed from RocketMegapoolManager)\n    /// @param _withdrawalSlot The slot containing the withdrawal\n    function notifyFinalBalance(uint32 _validatorId, uint64 _amountInGwei, address _caller, uint64 _withdrawalSlot) override external onlyRocketMegapoolManager {\n        // Perform notification process\n        _notifyFinalBalance(_validatorId, _amountInGwei, _withdrawalSlot);\n        // Trigger a deposit of excess collateral from rETH contract to deposit pool\n        RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral();\n        // If owner is calling, claim immediately\n        if (isNodeCalling(_caller)) {\n            _claim();\n        } else {\n            // Permissionless distribute requires a wait time\n            RocketDAOProtocolSettingsMegapoolInterface rocketDAOProtocolSettingsMegapool = RocketDAOProtocolSettingsMegapoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMegapool\"));\n            uint256 distributeWindowStart = rocketDAOProtocolSettingsMegapool.getUserDistributeWindowLength();\n            uint256 withdrawableEpoch = uint256(validators[_validatorId].withdrawableEpoch);\n            uint256 distributableTime = (withdrawableEpoch * secondsPerSlot * slotsPerEpoch + genesisTime) + distributeWindowStart;\n            require(block.timestamp > distributableTime, \"Not enough time has passed\");\n        }\n    }\n\n    /// @dev Internal implementation of final balance notification process\n    /// @param _validatorId Internal ID of the validator to notify final balance of\n    /// @param _amountInGwei The amount in the final withdrawal\n    /// @param _withdrawalSlot The slot containing the withdrawal\n    function _notifyFinalBalance(uint32 _validatorId, uint64 _amountInGwei, uint64 _withdrawalSlot) internal {\n        ValidatorInfo memory validator = validators[_validatorId];\n        require(!validator.exited, \"Already exited\");\n        require(validator.exiting, \"Validator not exiting\");\n        require(_withdrawalSlot >= validator.withdrawableEpoch * slotsPerEpoch, \"Not full withdrawal\");\n        // Mark as exited\n        validator.exited = true;\n        validator.exiting = false;\n        validator.exitBalance = uint64(_amountInGwei);\n        uint256 withdrawalBalance = uint256(_amountInGwei) * 1 gwei;\n        validators[_validatorId] = validator;\n        // Handle dissolved recovery\n        if (validator.dissolved) {\n            // Send full withdrawal balance to NO\n            refundValue += withdrawalBalance;\n        } else {\n            // Calculate capital distribution amounts\n            uint256 depositBalance = uint256(validator.depositValue) * milliToWei;\n            (uint256 nodeShare, uint256 userShare) = calculateCapitalDispersal(depositBalance, getActiveValidatorCount() - 1);\n            {\n                uint256 toNode = nodeShare;\n                if (withdrawalBalance < depositBalance) {\n                    uint256 shortfall = depositBalance - withdrawalBalance;\n                    if (shortfall > toNode) {\n                        toNode = 0;\n                    } else {\n                        toNode -= shortfall;\n                    }\n                }\n                uint256 toUser = withdrawalBalance - toNode;\n                // Pay off any existing debt and any new debt introduced by this exit\n                if (toUser < userShare) {\n                    _increaseDebt(userShare - toUser);\n                }\n                if (toNode > 0 && debt > 0) {\n                    if (toNode > debt) {\n                        toNode -= debt;\n                        toUser += debt;\n                        _reduceDebt(debt);\n                    } else {\n                        toUser += toNode;\n                        _reduceDebt(toNode);\n                        toNode = 0;\n                    }\n                }\n                // Send funds\n                sendToRETH(toUser);\n                if (toNode > 0) {\n                    refundValue += toNode;\n                }\n            }\n            // Update state\n            if (nodeShare > 0) {\n                nodeBond -= nodeShare;\n            }\n            if (userShare > 0) {\n                userCapital -= userShare;\n            }\n            unchecked { // Infeasible overflow\n                numInactiveValidators += 1;\n            }\n            // Handle collateral change\n            RocketDepositPoolInterface rocketDepositPool = getRocketDepositPool();\n            rocketDepositPool.fundsReturned(nodeAddress, nodeShare, userShare);\n        }\n        // Remove distribution lock\n        numExitingValidators -= 1;\n        if (numExitingValidators == 0) {\n            soonestWithdrawableEpoch = 0;\n        }\n        // Emit event\n        emit MegapoolValidatorExited(_validatorId, block.timestamp);\n    }\n\n    /// @notice Applies a penalty via increase debt (only callable from rocketMegapoolPenalties)\n    /// @param _amount Amount of the penalty\n    function applyPenalty(uint256 _amount) override external onlyLatestContract(\"rocketMegapoolPenalties\", msg.sender) {\n        _increaseDebt(_amount);\n        emit MegapoolPenaltyApplied(_amount, block.timestamp);\n    }\n\n    /// @dev Increases debt of this megapool\n    function _increaseDebt(uint256 _amount) internal {\n        debt += _amount;\n        emit MegapoolDebtIncreased(_amount, block.timestamp);\n    }\n\n    /// @dev Reduces debt of this megapool\n    function _reduceDebt(uint256 _amount) internal {\n        debt -= _amount;\n        emit MegapoolDebtReduced(_amount, block.timestamp);\n    }\n\n    /// @dev Calculates the current epoch on the beacon chain\n    function getCurrentEpoch() internal view returns (uint256) {\n        unchecked {\n            uint256 currentTime = block.timestamp;\n            uint256 slotsPassed = (currentTime - genesisTime) / secondsPerSlot;\n            return slotsPassed / slotsPerEpoch;\n        }\n    }\n\n    /// @dev Calculates the current slot on the beacon chain\n    function getCurrentSlot() internal view returns (uint64) {\n        unchecked {\n            uint256 currentTime = block.timestamp;\n            return uint64((currentTime - genesisTime) / secondsPerSlot);\n        }\n    }\n\n    /// @dev Helper function to send an amount of ETH to the RETH token conract\n    function sendToRETH(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n        (bool success,) = rocketTokenRETH.call{value: _amount}(\"\");\n        require(success);\n    }\n\n    /// @dev Calculates share of returned capital based on current bond level and requirement\n    /// @param _value The amount of ETH capital that is needing to be dispersed\n    /// @param _newValidatorCount The number of validators the node will have after this dispersal\n    function calculateCapitalDispersal(uint256 _value, uint256 _newValidatorCount) internal view returns (uint256 _nodeShare, uint256 _userShare) {\n        RocketNodeDepositInterface rocketNodeDeposit = getRocketNodeDeposit();\n        uint256 newBondRequirement = rocketNodeDeposit.getBondRequirement(_newValidatorCount);\n        _nodeShare = 0;\n        if (newBondRequirement < nodeBond) {\n            _nodeShare = nodeBond - newBondRequirement;\n        }\n        if (_nodeShare > _value) {\n            _nodeShare = _value;\n        }\n        _userShare = _value - _nodeShare;\n    }\n\n    /// @dev Convenience function to return interface to RocketDepositPool\n    function getRocketDepositPool() internal view returns (RocketDepositPoolInterface) {\n        return RocketDepositPoolInterface(rocketStorage.getAddress(rocketDepositPoolKey));\n    }\n\n    /// @dev Convenience function to return interface to RocketNodeDeposit\n    function getRocketNodeDeposit() internal view returns (RocketNodeDepositInterface) {\n        return RocketNodeDepositInterface(rocketStorage.getAddress(rocketNodeDepositKey));\n    }\n\n    /// @dev Mirror deposit contract deposit data root calculation but with in-memory bytes instead of calldata\n    function computeDepositDataRoot(bytes memory pubkey, bytes memory signature, uint64 amount) internal view returns (bytes32 ret) {\n        bytes32 withdrawalCredentials = getWithdrawalCredentials();\n        assembly {\n            let result\n            let temp := mload(0x40)\n\n        // [0x00] = pubkey[0x00:0x20]\n        // [0x20] = pubkey[0x20:0x30] . bytes16(0)\n            mstore(0x00, mload(add(pubkey, 0x20)))\n            mstore(0x20, and(mload(add(pubkey, 0x40)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000))\n\n        // temp[0x00] = sha256([0x00:0x40])\n            result := staticcall(84, 0x02, 0x00, 0x40, temp, 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // temp[0x20] = withdrawal_credentials\n            mstore(add(temp, 0x20), withdrawalCredentials)\n\n        // temp[0x00] = sha256(temp[0x00:0x40])\n            result := staticcall(84, 0x02, temp, 0x40, temp, 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // temp[0x20] = sha256(signature[0x00:0x40])\n            result := staticcall(84, 0x02, add(signature, 0x20), 0x40, add(temp, 0x20), 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // [0x00] = signature[0x40]\n        // [0x20] = bytes32(0)\n            mstore(0x00, mload(add(signature, 0x60)))\n            mstore(0x20, 0)\n\n        // [0x20] = sha256([0x00:0x40])\n            result := staticcall(84, 0x02, 0x00, 0x40, 0x20, 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // [0x00] = temp[0x20]\n            mstore(0x00, mload(add(temp, 0x20)))\n\n        // [0x20] = sha256([0x00:0x40])\n            result := staticcall(84, 0x02, 0x00, 0x40, 0x20, 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // [0x00] = to_little_endian(amount) . bytes24(0)\n            mstore(0x00, 0)\n            mstore8(0x00, shr(0x00, amount))\n            mstore8(0x01, shr(0x08, amount))\n            mstore8(0x02, shr(0x10, amount))\n            mstore8(0x03, shr(0x18, amount))\n            mstore8(0x04, shr(0x20, amount))\n            mstore8(0x05, shr(0x28, amount))\n            mstore8(0x06, shr(0x30, amount))\n            mstore8(0x07, shr(0x38, amount))\n\n        // [0x20] = sha256([0x00:0x40])\n            result := staticcall(84, 0x02, 0x00, 0x40, 0x20, 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // [0x00] = temp[0x00]\n            mstore(0x00, mload(temp))\n\n        // [0x00] = sha256([0x00:0x40])\n            result := staticcall(84, 0x02, 0x00, 0x40, 0x00, 0x20)\n            if iszero(result) {\n                revert(0, 0)\n            }\n\n        // Return [0x00:0x20]\n            ret := mload(0x00)\n        }\n    }\n}"
    }
}