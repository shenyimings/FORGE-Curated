{
    "vfp_id": "vfp_00224",
    "project_name": "SP1 Helios - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ]
            },
            "title": "Incorrect state-variable initialization in the constructor",
            "description": "The constructor of the SP1Helios contract incorrectly initializes the executionStateRoots mapping by using params.head as the key instead of params.executionBlockNumber. Additionally, the executionBlockNumber state variable is not initialized at all. This is a coding mistake in the contract's initialization logic. As a result, the executionStateRoots mapping does not correctly associate the execution state root with the correct block number, which is required by the updateStorageSlot function. This causes any call to updateStorageSlot before the first update to fail, as it cannot retrieve the correct state root. Furthermore, the latestExecutionStateRoot and latestExecutionBlockNumber functions will return incorrect or uninitialized data. The impact is medium because while the issue breaks expected functionality and could disrupt user operations, it does not directly lead to fund loss or complete system compromise, and can be resolved after the first update.\n",
            "severity": "Medium",
            "location": [
                "SP1Helios.sol::constructor"
            ],
            "files": [
                "sp1-helios/contracts/src/SP1Helios.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-571"
                ]
            },
            "title": "Redundant check on prevSyncCommitteeHash",
            "description": "In the update function of SP1Helios.sol, there is a redundant check that verifies currentSyncCommitteeHash against po.prevSyncCommitteeHash. Both values are derived from the same source: syncCommittees[getSyncCommitteePeriod(head)]. Therefore, this comparison is guaranteed to pass under correct execution and adds no security value. The cause is unnecessary defensive coding that does not account for the deterministic derivation of both values. This redundant check increases gas consumption and adds code complexity without benefit. The impact is informational because it does not introduce a security vulnerability, but it represents a minor inefficiency and a code quality issue that could confuse developers.\n",
            "severity": "Informational",
            "location": [
                "SP1Helios.sol::update#"
            ],
            "files": [
                "sp1-helios/contracts/src/SP1Helios.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused errors in the SP1Helios contract",
            "description": "The SP1Helios contract defines several error types—PrevHeadMismatch, PrevHeaderMismatch, HeaderRootAlreadySet, SyncCommitteeAlreadySet, and StateRootAlreadySet—that are declared but never used in the codebase. This is a code hygiene issue resulting from incomplete cleanup after development or refactoring. While these errors do not affect runtime behavior, their presence can mislead developers into thinking they are handled in certain code paths, reducing code readability and maintainability. Future developers may waste time searching for where these errors are thrown, or may incorrectly assume certain checks are in place. The impact is informational as there is no direct security risk, but it reflects poorly on code quality and long-term maintainability.\n",
            "severity": "Informational",
            "location": [
                "SP1Helios.sol"
            ],
            "files": [
                "sp1-helios/contracts/src/SP1Helios.sol"
            ]
        }
    ],
    "affected_files": {
        "SP1Helios.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {ISP1Verifier} from \"@sp1-contracts/ISP1Verifier.sol\";\n\n/// @notice Represents a storage slot in an Ethereum smart contract\nstruct StorageSlot {\n    bytes32 key;\n    bytes32 value;\n    address contractAddress;\n}\n\nstruct ProofOutputs {\n    /// The previous beacon block header hash.\n    bytes32 prevHeader;\n    /// The slot of the previous head.\n    uint256 prevHead;\n    /// The anchor sync committee hash which was used to verify the proof.\n    bytes32 prevSyncCommitteeHash;\n    /// The slot of the new head.\n    uint256 newHead;\n    /// The new beacon block header hash.\n    bytes32 newHeader;\n    /// The execution state root from the execution payload of the new beacon block.\n    bytes32 executionStateRoot;\n    /// The execution block number.\n    uint256 executionBlockNumber;\n    /// The sync committee hash of the current period.\n    bytes32 syncCommitteeHash;\n    /// The sync committee hash of the next period.\n    bytes32 nextSyncCommitteeHash;\n    /// Attested storage slots for the given block.\n    StorageSlot[] storageSlots;\n}\n\nstruct StorageSlotProofOutputs {\n    bytes32 storageRoot;\n    StorageSlot[] storageSlots;\n}\n\nstruct InitParams {\n    bytes32 executionStateRoot;\n    uint256 executionBlockNumber;\n    uint256 genesisTime;\n    bytes32 genesisValidatorsRoot;\n    address guardian;\n    uint256 head;\n    bytes32 header;\n    bytes32 lightClientVkey;\n    bytes32 storageSlotVkey;\n    uint256 secondsPerSlot;\n    uint256 slotsPerEpoch;\n    uint256 slotsPerPeriod;\n    uint256 sourceChainId;\n    bytes32 syncCommitteeHash;\n    address verifier;\n}\n\n/// @title SP1Helios\n/// @notice An Ethereum beacon chain light client, built with SP1 and Helios.\ncontract SP1Helios {\n    bytes32 public immutable GENESIS_VALIDATORS_ROOT;\n    uint256 public immutable GENESIS_TIME;\n    uint256 public immutable SECONDS_PER_SLOT;\n    uint256 public immutable SLOTS_PER_PERIOD;\n    uint256 public immutable SLOTS_PER_EPOCH;\n    uint256 public immutable SOURCE_CHAIN_ID;\n\n    modifier onlyGuardian() {\n        require(msg.sender == guardian, \"Caller is not the guardian\");\n        _;\n    }\n\n    /// @notice The latest slot the light client has a finalized header for.\n    uint256 public head = 0;\n\n    /// @notice The latest execution block number the light client has a finalized execution state root for.\n    uint256 public executionBlockNumber = 0;\n\n    /// @notice Maps from a slot to a beacon block header root.\n    mapping(uint256 => bytes32) public headers;\n\n    /// @notice Maps from a slot to the current finalized ethereum1 execution state root.\n    mapping(uint256 => bytes32) public executionStateRoots;\n\n    /// @notice Maps from a period to the hash for the sync committee.\n    mapping(uint256 => bytes32) public syncCommittees;\n\n    /// @notice A mapping from keccak256([abi.encode(blockNumber) || abi.encode(contractAddress) || abi.encode(key)])\n    /// @notice to the storage slot value.\n    mapping(bytes32 => bytes32) public storageSlots;\n\n    /// @notice The verification key for the SP1 Helios light client program.\n    bytes32 public lightClientVkey;\n\n    /// @notice The verification key for the storage slot proof program.\n    bytes32 public storageSlotVkey;\n\n    /// @notice The deployed SP1 verifier contract.\n    address public verifier;\n\n    /// @notice The address of the guardian\n    address public guardian;\n\n    /// @notice Semantic version.\n    /// @custom:semver v1.1.0\n    string public constant version = \"v1.1.0\";\n\n    event HeadUpdate(uint256 indexed slot, bytes32 indexed root);\n    event SyncCommitteeUpdate(uint256 indexed period, bytes32 indexed root);\n    event GuardianUpdate(address indexed newGuardian);\n    event GuardianRelinquished();\n    event LightClientVkeyUpdate(bytes32 indexed newVkey);\n    event StorageSlotVkeyUpdate(bytes32 indexed newVkey);\n\n    error PrevHeadMismatch(uint256 given, uint256 expected);\n    error PrevHeaderMismatch(bytes32 given, bytes32 expected);\n    error SlotBehindHead(uint256 slot);\n    error SyncCommitteeAlreadySet(uint256 period);\n    error HeaderRootAlreadySet(uint256 slot);\n    error StateRootAlreadySet(uint256 slot);\n    error SyncCommitteeStartMismatch(bytes32 given, bytes32 expected);\n    error SyncCommitteeNotSet(uint256 period);\n    error NextSyncCommitteeMismatch(bytes32 given, bytes32 expected);\n    error NonCheckpointSlot(uint256 slot);\n    error MissingStateRoot(uint256 blockNumber);\n\n    constructor(InitParams memory params) {\n        GENESIS_VALIDATORS_ROOT = params.genesisValidatorsRoot;\n        GENESIS_TIME = params.genesisTime;\n        SECONDS_PER_SLOT = params.secondsPerSlot;\n        SLOTS_PER_PERIOD = params.slotsPerPeriod;\n        SLOTS_PER_EPOCH = params.slotsPerEpoch;\n        SOURCE_CHAIN_ID = params.sourceChainId;\n        syncCommittees[getSyncCommitteePeriod(params.head)] = params.syncCommitteeHash;\n        lightClientVkey = params.lightClientVkey;\n        storageSlotVkey = params.storageSlotVkey;\n        headers[params.head] = params.header;\n        executionStateRoots[params.head] = params.executionStateRoot;\n        head = params.head;\n        verifier = params.verifier;\n        guardian = params.guardian;\n    }\n\n    /// @notice Updates the light client with a new header, execution state root, and sync committee (if changed)\n    /// @param proof The proof bytes for the SP1 proof.\n    /// @param newHead The slot of the new head.\n    /// @param newHeader The new beacon block header hash.\n    /// @param executionStateRoot The execution state root from the execution payload of the new beacon block.\n    /// @param _executionBlockNumber The execution block number.\n    /// @param syncCommitteeHash The sync committee hash of the current period.\n    /// @param nextSyncCommitteeHash The sync committee hash of the next period.\n    function update(\n        bytes calldata proof,\n        uint256 newHead,\n        bytes32 newHeader,\n        bytes32 executionStateRoot,\n        uint256 _executionBlockNumber,\n        bytes32 syncCommitteeHash,\n        bytes32 nextSyncCommitteeHash,\n        StorageSlot[] memory _storageSlots\n    ) external {\n        // Fill in the proof outputs with our expected values known by the contract\n        // instead of explicity comparing against them, the proof will not verify if they arent correct.\n        ProofOutputs memory po = ProofOutputs({\n            prevHeader: headers[head],\n            prevHead: head,\n            prevSyncCommitteeHash: syncCommittees[getSyncCommitteePeriod(head)],\n            newHead: newHead,\n            newHeader: newHeader,\n            executionStateRoot: executionStateRoot,\n            executionBlockNumber: _executionBlockNumber,\n            syncCommitteeHash: syncCommitteeHash,\n            nextSyncCommitteeHash: nextSyncCommitteeHash,\n            storageSlots: _storageSlots\n        });\n\n        // Verify the proof with the associated public values. This will revert if the proof is invalid.\n        ISP1Verifier(verifier).verifyProof(lightClientVkey, abi.encode(po), proof);\n\n        // The sync committee for the current head should always be set.\n        uint256 currentPeriod = getSyncCommitteePeriod(head);\n        bytes32 currentSyncCommitteeHash = syncCommittees[currentPeriod];\n        if (currentSyncCommitteeHash == bytes32(0)) {\n            revert SyncCommitteeNotSet(currentPeriod);\n        }\n\n        // The sync committee hash used in the proof should match the current sync committee.\n        if (currentSyncCommitteeHash != po.prevSyncCommitteeHash) {\n            revert SyncCommitteeStartMismatch(po.prevSyncCommitteeHash, currentSyncCommitteeHash);\n        }\n\n        // Confirm that the new slot is greater than the current head.\n        if (po.newHead <= head) {\n            revert SlotBehindHead(po.newHead);\n        }\n\n        // Confirm that the new slot is a checkpoint slot.\n        // This is useful if the there were ever some delay greater than 30 minutes between updates,\n        // as CL nodes typically only store checkpoint slot proofs.\n        //\n        // This condition is actually checked by the proof, but we include it here for clarity.\n        if (po.newHead % 32 != 0) {\n            revert NonCheckpointSlot(po.newHead);\n        }\n\n        // Update the new CL information.\n        head = po.newHead;\n        headers[po.newHead] = po.newHeader;\n\n        // Update the EL information.\n        executionBlockNumber = po.executionBlockNumber;\n        executionStateRoots[po.executionBlockNumber] = po.executionStateRoot;\n\n        // Get the new period associated with the new head.\n        uint256 newPeriod = getSyncCommitteePeriod(po.newHead);\n\n        // Set the sync committee for the new period if it is not set.\n        // This can happen if the light client was very behind and had a lot of updates.\n        // Note: Only the latest sync committee is stored, not the intermediate ones from every update.\n        if (syncCommittees[newPeriod] == bytes32(0)) {\n            syncCommittees[newPeriod] = po.syncCommitteeHash;\n            emit SyncCommitteeUpdate(newPeriod, po.syncCommitteeHash);\n        }\n\n        // Set the next sync committee if it is defined and not set.\n        if (po.nextSyncCommitteeHash != bytes32(0)) {\n            uint256 nextPeriod = newPeriod + 1;\n            if (syncCommittees[nextPeriod] == bytes32(0)) {\n                // If the next sync committee is not set, set it.\n                syncCommittees[nextPeriod] = po.nextSyncCommitteeHash;\n                emit SyncCommitteeUpdate(nextPeriod, po.nextSyncCommitteeHash);\n            } else if (syncCommittees[nextPeriod] != po.nextSyncCommitteeHash) {\n                // If the next sync committee is non-zero, it should match the expected value.\n                revert NextSyncCommitteeMismatch(\n                    syncCommittees[nextPeriod], po.nextSyncCommitteeHash\n                );\n            }\n        }\n\n        // Set all the storage slots.\n        for (uint256 i = 0; i < po.storageSlots.length; i++) {\n            bytes32 key = computeStorageSlotKey(\n                po.executionBlockNumber, po.storageSlots[i].contractAddress, po.storageSlots[i].key\n            );\n            storageSlots[key] = po.storageSlots[i].value;\n        }\n\n        emit HeadUpdate(po.newHead, po.newHeader);\n    }\n\n    /// @notice Verifies a storage slot proof, and saves the storage slots to the contract.\n    /// @dev Panics if the proof is invalid.\n    /// @param proof The proof bytes for the SP1 proof.\n    /// @param _storageSlots The storage slots to verify.\n    /// @param blockNumber The block number of the storage slot.\n    function updateStorageSlot(\n        bytes calldata proof,\n        StorageSlot[] memory _storageSlots,\n        uint256 blockNumber\n    ) external {\n        // Verify the proof with the associated public values. This will revert if the proof is invalid.\n        verifyStorageSlotsProof(proof, _storageSlots, blockNumber);\n\n        // Set all the storage slots.\n        for (uint256 i = 0; i < _storageSlots.length; i++) {\n            bytes32 key = computeStorageSlotKey(\n                blockNumber, _storageSlots[i].contractAddress, _storageSlots[i].key\n            );\n            storageSlots[key] = _storageSlots[i].value;\n        }\n    }\n\n    /// @notice Verifies a storage slot proof.\n    /// @dev Panics if the proof is invalid.\n    /// @param proof The proof bytes for the SP1 proof.\n    /// @param _storageSlots The storage slots to verify.\n    /// @param blockNumber The block number of the storage slot.\n    function verifyStorageSlotsProof(\n        bytes calldata proof,\n        StorageSlot[] memory _storageSlots,\n        uint256 blockNumber\n    ) public view {\n        bytes32 executionStateRoot = executionStateRoots[blockNumber];\n        if (executionStateRoot == bytes32(0)) {\n            revert MissingStateRoot(blockNumber);\n        }\n\n        // Fill in the proof outputs with our expected values known by the contract.\n        // Note: If the execution state root is not set, then the proof wil not verify.\n        StorageSlotProofOutputs memory sspo =\n            StorageSlotProofOutputs({storageRoot: executionStateRoot, storageSlots: _storageSlots});\n\n        ISP1Verifier(verifier).verifyProof(storageSlotVkey, abi.encode(sspo), proof);\n    }\n\n    function latestExecutionStateRoot() public view returns (bytes32) {\n        return executionStateRoots[executionBlockNumber];\n    }\n\n    function latestExecutionBlockNumber() public view returns (uint256) {\n        return executionBlockNumber;\n    }\n\n    /// @notice Gets the sync committee period from a slot.\n    function getSyncCommitteePeriod(uint256 slot) public view returns (uint256) {\n        return slot / SLOTS_PER_PERIOD;\n    }\n\n    /// @notice Gets the current epoch\n    function getCurrentEpoch() public view returns (uint256) {\n        return head / SLOTS_PER_EPOCH;\n    }\n\n    /// @notice Gets the storage slot for a given block number, contract address, and key.\n    function getStorageSlot(uint256 blockNumber, address contractAddress, bytes32 key)\n        external\n        view\n        returns (bytes32)\n    {\n        return storageSlots[computeStorageSlotKey(blockNumber, contractAddress, key)];\n    }\n\n    /// @notice Updates the Helios program verification key.\n    function updateLightClientVkey(bytes32 newVkey) external onlyGuardian {\n        lightClientVkey = newVkey;\n\n        emit LightClientVkeyUpdate(newVkey);\n    }\n\n    /// @notice Updates the storage slot proof verification key.\n    function updateStorageSlotVkey(bytes32 newVkey) external onlyGuardian {\n        storageSlotVkey = newVkey;\n\n        emit StorageSlotVkeyUpdate(newVkey);\n    }\n\n    function changeGuardian(address newGuardian) external onlyGuardian {\n        require(\n            newGuardian != address(0),\n            \"New guardian cannot be the zero, use relinquishGuardian instead\"\n        );\n\n        guardian = newGuardian;\n\n        emit GuardianUpdate(newGuardian);\n    }\n\n    function relinquishGuardian() external onlyGuardian {\n        guardian = address(0);\n\n        emit GuardianRelinquished();\n    }\n\n    /// @notice Computes the corresponding key for a storage slot.\n    function computeStorageSlotKey(uint256 blockNumber, address contractAddress, bytes32 key)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(blockNumber, contractAddress, key));\n    }\n}\n"
    }
}