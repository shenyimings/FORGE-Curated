{
    "vfp_id": "vfp_00080",
    "project_name": "Very Liquid Vaults Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Overly Restrictive Pause Mechanism Blocks User Transfers",
            "description": "The `_update` function in `BaseVault.sol` uses a `notPaused` modifier that blocks all ERC-20 operations, including `transfer` and `transferFrom`, during a pause. While intended to prevent deposit and withdrawal during emergencies, this design unnecessarily restricts user-to-user transfers of existing shares, effectively freezing secondary market liquidity. The root cause is the broad application of the pause flag to all state-changing ERC-20 functions instead of limiting it to vault-specific I/O (deposit, mint, withdraw, redeem). An attacker could not directly exploit this for financial gain, but a malicious or compromised guardian could trigger a pause to cause denial of service to secondary markets, integration failures, or collateral lockups in lending protocols. The impact is reduced user autonomy and potential systemic issues in DeFi integrations relying on share transferability.\n",
            "severity": "Low",
            "location": [
                "BaseVault.sol::_update#L180"
            ],
            "files": [
                "very-liquid-vaults/src/utils/BaseVault.sol"
            ]
        }
    ],
    "affected_files": {
        "BaseVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {UUPSUpgradeable} from \"@openzeppelin-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20Upgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {ERC4626Upgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\n\nimport {MulticallUpgradeable} from \"@openzeppelin-upgradeable/contracts/utils/MulticallUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin-upgradeable/contracts/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IVault} from \"@src//IVault.sol\";\nimport {Auth} from \"@src/Auth.sol\";\nimport {DEFAULT_ADMIN_ROLE, GUARDIAN_ROLE, VAULT_MANAGER_ROLE} from \"@src/Auth.sol\";\n\n/// @title BaseVault\n/// @custom:security-contact security@size.credit\n/// @author Size (https://size.credit/)\n/// @notice Abstract base contract for all vaults in the Size Meta Vault system\n/// @dev Provides common functionality including ERC4626 compliance, access control, and upgradeability\nabstract contract BaseVault is IVault, ERC4626Upgradeable, ERC20PermitUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable, MulticallUpgradeable, UUPSUpgradeable {\n  // STORAGE\n  /// @custom:storage-location erc7201:size.storage.BaseVault\n  struct BaseVaultStorage {\n    Auth _auth;\n    uint256 _totalAssetsCap;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"size.storage.BaseVault\")) - 1)) & ~bytes32(uint256(0xff));\n  bytes32 private constant BaseVaultStorageLocation = 0x404a41806115f4e0ed08eb395c0045722d1875ff8794e55da96cf8391291c100;\n\n  function _getBaseVaultStorage() private pure returns (BaseVaultStorage storage $) {\n    assembly {\n      $.slot := BaseVaultStorageLocation\n    }\n  }\n\n  // ERRORS\n  error NullAddress();\n  error NullAmount();\n\n  // EVENTS\n  event AuthSet(address indexed auth);\n  event TotalAssetsCapSet(uint256 indexed totalAssetsCapBefore, uint256 indexed totalAssetsCapAfter);\n  event VaultStatus(uint256 totalShares, uint256 totalAssets);\n\n  // CONSTRUCTOR / INITIALIZER\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the BaseVault with necessary parameters\n  /// @dev Sets up all inherited contracts and makes the first deposit to prevent inflation attacks\n  function initialize(Auth auth_, IERC20 asset_, string memory name_, string memory symbol_, address fundingAccount_, uint256 firstDepositAmount_) public virtual initializer {\n    __ERC4626_init(asset_);\n    __ERC20_init(name_, symbol_);\n    __ERC20Permit_init(name_);\n    __ReentrancyGuard_init();\n    __Pausable_init();\n    __Multicall_init();\n    __UUPSUpgradeable_init();\n\n    if (address(auth_) == address(0)) revert NullAddress();\n    if (firstDepositAmount_ == 0) revert NullAmount();\n\n    BaseVaultStorage storage $ = _getBaseVaultStorage();\n    $._auth = auth_;\n    emit AuthSet(address(auth_));\n\n    _setTotalAssetsCap(type(uint256).max);\n\n    _firstDeposit(fundingAccount_, firstDepositAmount_);\n  }\n\n  // MODIFIERS\n  /// @notice Modifier to restrict function access to addresses with specific roles\n  /// @dev Reverts if the caller doesn't have the required role\n  modifier onlyAuth(bytes32 role) {\n    if (!auth().hasRole(role, msg.sender)) revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, role);\n    _;\n  }\n\n  /// @notice Modifier to ensure the contract is not paused\n  /// @dev Checks both local pause state and global pause state from Auth\n  modifier notPaused() {\n    if (_isPaused()) revert EnforcedPause();\n    _;\n  }\n\n  /// @notice Modifier to emit the vault status\n  /// @dev Emits the vault status after the function is executed\n  modifier emitVaultStatus() {\n    _;\n    emit VaultStatus(totalSupply(), totalAssets());\n  }\n\n  // INTERNAL/PRIVATE\n  /// @notice Authorizes contract upgrades\n  /// @dev Only addresses with DEFAULT_ADMIN_ROLE can authorize upgrades\n  function _authorizeUpgrade(address newImplementation) internal override onlyAuth(DEFAULT_ADMIN_ROLE) {}\n\n  /// @notice Pauses the vault\n  /// @dev Only addresses with GUARDIAN_ROLE can pause the vault\n  function pause() external onlyAuth(GUARDIAN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Only addresses with VAULT_MANAGER_ROLE can unpause the vault\n  function unpause() external onlyAuth(VAULT_MANAGER_ROLE) {\n    _unpause();\n  }\n\n  /// @notice Sets the maximum total assets of the vault\n  /// @dev Only callable by the auth contract\n  /// @dev Lowering the total assets cap does not affect existing deposited assets\n  function setTotalAssetsCap(uint256 totalAssetsCap_) external onlyAuth(VAULT_MANAGER_ROLE) {\n    _setTotalAssetsCap(totalAssetsCap_);\n  }\n\n  /// @notice Sets the maximum total assets of the vault\n  function _setTotalAssetsCap(uint256 totalAssetsCap_) private {\n    BaseVaultStorage storage $ = _getBaseVaultStorage();\n    uint256 oldTotalAssetsCap = $._totalAssetsCap;\n    $._totalAssetsCap = totalAssetsCap_;\n    emit TotalAssetsCapSet(oldTotalAssetsCap, totalAssetsCap_);\n  }\n\n  /// @notice This function is used to deposit the first amount of assets into the vault\n  /// @dev This is equivalent to deposit(firstDepositAmount_, address(this)); with _msgSender() replaced by fundingAccount_\n  function _firstDeposit(address fundingAccount_, uint256 firstDepositAmount_) private {\n    address receiver = address(this);\n    uint256 maxAssets = maxDeposit(receiver);\n    if (firstDepositAmount_ > maxAssets) revert ERC4626ExceededMaxDeposit(receiver, firstDepositAmount_, maxAssets);\n\n    uint256 shares = previewDeposit(firstDepositAmount_);\n    _deposit(fundingAccount_, receiver, firstDepositAmount_, shares);\n  }\n\n  /// @notice Returns true if the vault is paused\n  function _isPaused() private view returns (bool) {\n    return paused() || auth().paused();\n  }\n\n  // ERC20 OVERRIDES\n  /// @notice Returns the number of decimals for the vault token\n  function decimals() public view virtual override(ERC20Upgradeable, ERC4626Upgradeable, IERC20Metadata) returns (uint8) {\n    return super.decimals();\n  }\n\n  // ERC4626 OVERRIDES\n  /// @notice Deposits assets into the vault\n  /// @dev Prevents deposits that would result in 0 shares received\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual override {\n    // slither-disable-next-line incorrect-equality\n    if (assets > 0 && shares == 0) revert NullAmount();\n    super._deposit(caller, receiver, assets, shares);\n  }\n\n  /// @notice Withdraws assets from the vault\n  /// @dev Prevents withdrawals that would result in 0 assets taken\n  function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal virtual override {\n    // slither-disable-next-line incorrect-equality\n    if (shares > 0 && assets == 0) revert NullAmount();\n    super._withdraw(caller, receiver, owner, assets, shares);\n  }\n\n  /// @notice Internal function called during token transfers\n  /// @dev This function is overridden to ensure that the vault is not paused\n  function _update(address from, address to, uint256 value) internal virtual override notPaused {\n    super._update(from, to, value);\n  }\n\n  /// @notice Returns the maximum amount that can be deposited\n  function maxDeposit(address receiver) public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256) {\n    return _isPaused() ? 0 : totalAssetsCap() == type(uint256).max ? super.maxDeposit(receiver) : _maxDeposit();\n  }\n\n  /// @notice Returns the maximum amount that can be minted\n  function maxMint(address receiver) public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256) {\n    return _isPaused() ? 0 : totalAssetsCap() == type(uint256).max ? super.maxMint(receiver) : convertToShares(_maxDeposit());\n  }\n\n  /// @notice Returns the maximum amount that can be withdrawn\n  function maxWithdraw(address owner) public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256) {\n    return _isPaused() ? 0 : super.maxWithdraw(owner);\n  }\n\n  /// @notice Returns the maximum amount that can be redeemed\n  function maxRedeem(address owner) public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256) {\n    return _isPaused() ? 0 : super.maxRedeem(owner);\n  }\n\n  /// @notice Returns the maximum amount that can be deposited\n  function _maxDeposit() private view returns (uint256) {\n    return Math.saturatingSub(totalAssetsCap(), totalAssets());\n  }\n\n  // VIEW FUNCTIONS\n  /// @notice Returns the auth contract\n  function auth() public view override returns (Auth) {\n    return _getBaseVaultStorage()._auth;\n  }\n\n  /// @notice Returns the total assets cap\n  function totalAssetsCap() public view override returns (uint256) {\n    return _getBaseVaultStorage()._totalAssetsCap;\n  }\n}\n"
    }
}