{
    "vfp_id": "vfp_00028",
    "project_name": "cantina_uniswap_nov2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Missing address(0) Validation Across Multiple Critical Functions",
            "description": "1. **Description:** Several critical functions across the codebase do not validate that address parameters are not `address(0)`, including `setReleaser`, `updateRecipient`, `release`, `setFactoryOwner`, `setThresholdSetter`, and `setFeeSetter`.\n2. **Cause:** Lack of input validation for address parameters in ownership and configuration functions.\n3. **Exploitation:** A mistaken or malicious caller could set a critical address (e.g., recipient, releaser, owner) to `address(0)`, leading to loss of funds or functionality.\n4. **Impact:** Could result in locked funds (e.g., tokens sent to `address(0)`), loss of access to functionality, or permanent misconfiguration of critical components.\n",
            "severity": "Informational",
            "location": [
                "ResourceManager.sol::setThresholdSetter#40",
                "V3FeeAdapter.sol::setFactoryOwner#71",
                "V3FeeAdapter.sol::setFeeSetter#104",
                "ExchangeReleaser.sol::release#39",
                "TokenJar.sol::setReleaser#40",
                "UNIVesting.sol::updateRecipient#73"
            ],
            "files": [
                "protocol-fees/src/base/ResourceManager.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Residual Tokens May Remain Unclaimed When Vesting Amount Is Updated",
            "description": "1. **Description:** The `updateVestingAmount()` function in `UNIVesting.sol` allows changing the quarterly vesting amount only when no quarters are claimable, but doing so can leave residual tokens unclaimable due to misalignment with the new amount.\n2. **Cause:** The vesting logic does not account for leftover tokens when the vesting amount is reduced after partial withdrawals.\n3. **Exploitation:** No active exploitation, but a change in vesting amount can inadvertently trap tokens.\n4. **Impact:** Recipients may be unable to claim all vested tokens without manual intervention or further governance action, leading to potential loss of funds.\n",
            "severity": "Informational",
            "location": [
                "UNIVesting.sol::updateVestingAmount#98"
            ],
            "files": [
                "protocol-fees/src/UNIVesting.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-282"
                ],
                "3": [
                    "CWE-283"
                ]
            },
            "title": "Single-step ownership transfer",
            "description": "1. **Description:** Contracts such as `V3FeeAdapter`, `TokenJar`, `UNIVesting`, and `ResourceManager` use a single-step ownership transfer, where setting a new owner takes effect immediately without confirmation.\n2. **Cause:** Use of basic `Ownable` pattern instead of a two-step ownership transfer.\n3. **Exploitation:** A typo or mistake in the new owner address results in permanent loss of control, with no way to revert.\n4. **Impact:** High risk of accidental ownership loss, especially in governance-controlled contracts where recovery may require complex coordination.\n",
            "severity": "Informational",
            "location": [
                "V3FeeAdapter.sol#4",
                "V3FeeAdapter.sol#21",
                "TokenJar.sol#13",
                "UNIVesting.sol#17"
            ],
            "files": [
                "protocol-fees/src/V3FeeAdapter.sol",
                "protocol-fees/src/TokenJar.sol",
                "protocol-fees/src/UNIVesting.sol",
                "protocol-fees/src/base/ResourceManager.sol"
            ]
        }
    ],
    "affected_files": {
        "UNIVesting.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n  BokkyPooBahsDateTimeLibrary as DateTime\n} from \"BokkyPooBahsDateTimeLibrary/contracts/BokkyPooBahsDateTimeLibrary.sol\";\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {IUNIVesting} from \"./interfaces/IUNIVesting.sol\";\n\n/// @title UNIVesting\n/// @notice A vesting contract that releases UNI tokens quarterly to a designated recipient\n/// @dev The contract unlocks its first tranche on Jan 1, 2026 and allows withdrawals every calendar\n/// quarter thereafter. The owner must maintain an ERC20 allowance for the contract to transfer UNI\n/// tokens. Supports partial withdrawals when allowance is less than vested amount.\ncontract UNIVesting is Owned, IUNIVesting {\n  using SafeTransferLib for ERC20;\n\n  /// @notice Number of months in a quarter\n  uint256 private constant MONTHS_PER_QUARTER = 3;\n\n  /// @dev equivalent to January 1, 2026 00:00:00 UTC\n  uint256 private constant FIRST_UNLOCK_TIMESTAMP = 1_767_225_600;\n\n  /// @inheritdoc IUNIVesting\n  ERC20 public immutable UNI;\n\n  /// @inheritdoc IUNIVesting\n  uint256 public quarterlyVestingAmount = 5_000_000 ether;\n\n  /// @inheritdoc IUNIVesting\n  address public recipient;\n\n  /// @inheritdoc IUNIVesting\n  uint48 public lastUnlockTimestamp;\n\n  /// @notice Restricts function access to either the contract owner or the recipient\n  /// @dev Reverts with NotAuthorized if caller is neither owner nor recipient\n  modifier onlyOwnerOrRecipient() {\n    require(msg.sender == recipient || msg.sender == owner, NotAuthorized());\n    _;\n  }\n\n  /// @notice Constructs a new UNIVesting contract\n  /// @param _uni The address of the UNI token contract\n  /// @param _recipient The address that will receive vested UNI tokens\n  /// @dev The deployer becomes the owner. The owner must approve this contract\n  /// to spend their UNI tokens for vesting to work properly.\n  constructor(address _uni, address _recipient) Owned(msg.sender) {\n    UNI = ERC20(_uni);\n    updateRecipient(_recipient);\n    // set the quarterly timestamp such that the first unlock occurs on FIRST_UNLOCK_TIMESTAMP\n    lastUnlockTimestamp = uint48(DateTime.subMonths(FIRST_UNLOCK_TIMESTAMP, MONTHS_PER_QUARTER));\n  }\n\n  /// @inheritdoc IUNIVesting\n  /// @dev Can only be called by the owner and only when no active quarters are available to\n  /// withdraw (i.e., quartersPassed() == 0). This prevents changing the amount when tokens have\n  /// already\n  /// vested and are waiting to be claimed\n  function updateVestingAmount(uint256 amount) external onlyOwner {\n    require(amount != quarterlyVestingAmount, NoChangeUpdate());\n    require(quartersPassed() == 0, CannotUpdateAmount());\n    quarterlyVestingAmount = amount;\n    emit VestingAmountUpdated(amount);\n  }\n\n  /// @inheritdoc IUNIVesting\n  /// @dev Both the owner and current recipient can update the recipient address.\n  /// This allows the recipient to transfer their vesting rights to another address.\n  function updateRecipient(address _recipient) public onlyOwnerOrRecipient {\n    require(_recipient != recipient, NoChangeUpdate());\n    recipient = _recipient;\n    emit RecipientUpdated(recipient);\n  }\n\n  /// @inheritdoc IUNIVesting\n  /// @dev This function can be called by anyone (not just the recipient).\n  /// Handles both full and partial withdrawals based on the owner's allowance.\n  /// If allowance < vested amount, only withdraws what's allowed and updates\n  /// the timestamp accordingly. The remaining quarters can be withdrawn later.\n  /// Relies on owner maintaining sufficient ERC20 allowance.\n  /// If owner revokes allowance, withdrawals will fail with InsufficientAllowance.\n  function withdraw() external {\n    uint48 numQuarters = quartersPassed();\n    require(numQuarters > 0, OnlyQuarterly());\n\n    uint256 _quarterlyVestingAmount = quarterlyVestingAmount;\n    uint256 vestedAmount = _quarterlyVestingAmount * uint256(numQuarters);\n    uint256 currentAllowance = UNI.allowance(owner, address(this));\n\n    uint48 quartersPaid;\n\n    if (currentAllowance < vestedAmount) {\n      // Partial withdrawal path: owner's allowance is less than vested amount\n      // Calculate how many complete quarters we can withdraw with current allowance\n      uint48 withdrawableQuarters = uint48(currentAllowance / _quarterlyVestingAmount);\n\n      require(withdrawableQuarters > 0, InsufficientAllowance());\n\n      // Only advance timestamp by the quarters we're actually paying out\n      // This ensures remaining quarters can be withdrawn later when allowance increases\n      lastUnlockTimestamp =\n        uint48(DateTime.addMonths(lastUnlockTimestamp, withdrawableQuarters * MONTHS_PER_QUARTER));\n\n      vestedAmount = _quarterlyVestingAmount * uint256(withdrawableQuarters);\n      quartersPaid = withdrawableQuarters;\n    } else {\n      // Full withdrawal path: sufficient allowance for all vested quarters\n      // Advance timestamp by all quarters that have vested\n      lastUnlockTimestamp =\n        uint48(DateTime.addMonths(lastUnlockTimestamp, numQuarters * MONTHS_PER_QUARTER));\n\n      quartersPaid = numQuarters;\n    }\n\n    UNI.safeTransferFrom(owner, recipient, vestedAmount);\n    emit Withdrawn(recipient, vestedAmount, quartersPaid);\n  }\n\n  /// @inheritdoc IUNIVesting\n  /// @dev Uses calendar-based quarters (3 months each)\n  /// Returns 0 if no quarters have passed since last withdrawal.\n  function quartersPassed() public view returns (uint48) {\n    uint48 _lastUnlockTimestamp = lastUnlockTimestamp;\n    if (block.timestamp < _lastUnlockTimestamp) return 0;\n    return uint48(DateTime.diffMonths(_lastUnlockTimestamp, block.timestamp) / MONTHS_PER_QUARTER);\n  }\n}\n",
        "ResourceManager.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IResourceManager} from \"../interfaces/base/IResourceManager.sol\";\n\n/// @title ResourceManager\n/// @notice A contract that holds immutable state for the resource token and the resource recipient\n/// address. It also maintains logic for managing the threshold of the resource token.\nabstract contract ResourceManager is IResourceManager, Owned {\n  /// @inheritdoc IResourceManager\n  uint256 public threshold;\n\n  /// @inheritdoc IResourceManager\n  address public thresholdSetter;\n\n  /// @inheritdoc IResourceManager\n  ERC20 public immutable RESOURCE;\n\n  /// @inheritdoc IResourceManager\n  address public immutable RESOURCE_RECIPIENT;\n\n  /// @notice Ensures only the threshold setter can call the setThreshold function\n  modifier onlyThresholdSetter() {\n    require(msg.sender == thresholdSetter, Unauthorized());\n    _;\n  }\n\n  /// @dev At construction the thresholdSetter defaults to 0 and its on the owner to set.\n  constructor(address _resource, uint256 _threshold, address _owner, address _recipient)\n    Owned(_owner)\n  {\n    RESOURCE = ERC20(_resource);\n    RESOURCE_RECIPIENT = _recipient;\n    threshold = _threshold;\n  }\n\n  /// @inheritdoc IResourceManager\n  function setThresholdSetter(address _thresholdSetter) external onlyOwner {\n    thresholdSetter = _thresholdSetter;\n  }\n\n  /// @inheritdoc IResourceManager\n  function setThreshold(uint256 _threshold) external onlyThresholdSetter {\n    threshold = _threshold;\n  }\n}\n",
        "TokenJar.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {Currency} from \"v4-core/types/Currency.sol\";\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {ITokenJar} from \"./interfaces/ITokenJar.sol\";\n\n/// @title TokenJar\n/// @notice A singular destination for protocol fees\n/// @dev Fees accumulate passively in this contract from external sources.\n///      Stored fees can be released by an authorized releaser contract.\n/// @custom:security-contact security@uniswap.org\ncontract TokenJar is Owned, ITokenJar {\n  /// @inheritdoc ITokenJar\n  address public releaser;\n\n  /// @notice Ensures only the releaser can call the release function\n  modifier onlyReleaser() {\n    require(msg.sender == releaser, Unauthorized());\n    _;\n  }\n\n  /// @dev creates an token jar where the deployer is the initial owner\n  /// during deployment, the deployer SHOULD set the releaser address and\n  /// transfer ownership\n  constructor() Owned(msg.sender) {}\n\n  /// @inheritdoc ITokenJar\n  function release(Currency[] calldata assets, address recipient) external onlyReleaser {\n    Currency asset;\n    uint256 amount;\n    for (uint256 i; i < assets.length; i++) {\n      asset = assets[i];\n      amount = asset.balanceOfSelf();\n      if (amount > 0) asset.transfer(recipient, amount);\n    }\n  }\n\n  /// @inheritdoc ITokenJar\n  function setReleaser(address _releaser) external onlyOwner {\n    releaser = _releaser;\n  }\n\n  receive() external payable {}\n}\n"
    }
}