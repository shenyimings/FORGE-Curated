{
    "vfp_id": "vfp_00394",
    "project_name": "P2P.org Resolv Integration Security Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "StakedTokenDistributor Immutability Breaks Claim Functionality",
            "description": "The P2pResolvProxy contract stores the StakedTokenDistributor address as an immutable variable, which prevents it from being updated after deployment. The StakedTokenDistributor contract uses an immutable Merkle root set at deployment, which must include the claiming address. However, since the P2pResolvProxy is deployed after StakedTokenDistributor, its address cannot be included in the original Merkle root. As a result, any claim attempt via P2pResolvProxy will fail due to invalid Merkle proof verification. Furthermore, even if a new StakedTokenDistributor is deployed with an updated Merkle root, the proxy cannot point to it due to the immutability of the distributor address. This renders the airdrop claim functionality permanently unusable for clients.\nThe root cause is the combination of two immutable dependencies: the proxy's hardcoded distributor address and the distributor's fixed Merkle root. An attacker or malicious actor is not required; any legitimate user attempting to claim will be reverted. The impact is that users permanently lose access to their airdropped tokens, which are effectively locked in the StakedTokenDistributor contract with no recovery path on-chain.\n",
            "severity": "High",
            "location": [
                "P2pResolvProxy.sol"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "RESOLV Withdrawal Double Fee When claimEnabled is false",
            "description": "When withdrawRESOLV() is called while claimEnabled is false, the ResolvStaking contract returns only the principal, not the rewards. However, the P2pYieldProxy calculates accruedRewards before the withdrawal using _getCurrentAssetAmount(), which includes pending rewards. This leads to a profitPortion being calculated and fees applied to rewards that were not actually withdrawn. Later, when claimEnabled is true and the user withdraws again, the same rewards are withdrawn and fees are applied a second time, resulting in a double fee on the same reward amount.\nThe root cause is the incorrect assumption that all accrued rewards are withdrawn during the call, even when claimEnabled is false. An attacker does not need to exploit this maliciously; it occurs under normal user behavior when market conditions or protocol settings disable claiming. The impact is financial loss for users due to double fee deduction on the same rewards, undermining trust in the fee model and causing accounting inconsistencies.\n",
            "severity": "Medium",
            "location": [
                "P2pResolvProxy.sol::withdrawRESOLV",
                "P2pYieldProxy.sol::_withdraw",
                "P2pResolvProxy.sol::_getCurrentAssetAmount"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Extra Reward Tokens from ResolvStaking Stuck in P2pResolvProxy",
            "description": "During a RESOLV withdrawal, the ResolvStaking contract may transfer multiple reward tokens to the proxy if multiple reward tokens are configured. However, the P2pYieldProxy._withdraw() function only tracks the balance delta of the primary _asset (RESOLV) and ignores any additional ERC-20 tokens sent during the withdrawal. These extra reward tokens remain stranded in the proxy contract with no mechanism to retrieve them.\nThe root cause is the lack of handling for secondary reward tokens in the withdrawal logic. While currently only RESOLV is configured, the ResolvStaking contract allows admins to add new reward tokens via addRewardToken(). Once added, any rewards in those tokens will be sent to the proxy but never forwarded to users. The impact is that future reward tokens will be permanently locked in the proxy, leading to user fund loss and reduced protocol functionality.\n",
            "severity": "Medium",
            "location": [
                "P2pResolvProxy.sol::withdrawRESOLV",
                "P2pYieldProxy.sol::_withdraw"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "_getCurrentAssetAmount() Uses effectiveBalance Incorrectly, Causing Wrong Accrued Rewards Calculation",
            "description": "The _getCurrentAssetAmount() function uses getUserEffectiveBalance(), which includes a time-based boost multiplier, to calculate the current asset amount. However, effectiveBalance is a virtual balance used only for reward distribution and does not represent the actual withdrawable token balance. This leads to an inflated current amount when calculating accrued rewards, as the boost multiplier is effectively counted as part of the rewards.\nThe root cause is the misuse of a boosted virtual balance in a context requiring real token balance. For example, a 2x boost on 1000 tokens results in 2000 effectiveBalance, which when added to 100 pending rewards gives 2100, leading to 1100 calculated as rewards (2100 - 1000 principal), despite only 100 actual rewards. The impact is severe miscalculation of rewards, incorrect fee application, and potential withdrawal failures or over-withdrawals.\n",
            "severity": "Medium",
            "location": [
                "P2pResolvProxy.sol::_getCurrentAssetAmount"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "initiateWithdrawalRESOLVAccruedRewards() Withdraws Both Principal and Rewards Instead of Only Rewards",
            "description": "The initiateWithdrawalRESOLVAccruedRewards() function calls initiateWithdrawal() on ResolvStaking, which burns stRESOLV tokens (principal) regardless of intent. This means that even when the goal is to withdraw only rewards, principal is still deducted. When withdraw() is later called, it returns both the burned principal and the claimed rewards, effectively withdrawing principal along with rewards.\nThe root cause is the misuse of a principal-withdrawing function for a rewards-only purpose. The ResolvStaking contract provides a claim() function that allows reward-only withdrawal without touching principal, which should be used instead. The impact is that users lose principal when intending to withdraw only rewards, breaking the expected behavior and leading to unintended capital loss.\n",
            "severity": "Medium",
            "location": [
                "P2pResolvProxy.sol::initiateWithdrawalRESOLVAccruedRewards"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "s_totalWithdrawn Can Exceed s_totalDeposited Due to Unaccounted Airdropped Tokens or Direct Transfers",
            "description": "The vulnerability arises because the P2pResolvProxy._getCurrentAssetAmount() function does not account for staked airdropped RESOLV tokens or stRESOLV tokens received via direct transfers. This leads to an incorrect calculation of the current asset amount, which is based only on getUserPrincipal() and pending rewards, excluding airdropped or externally transferred staked tokens. As a result, the actual contract balance can exceed the accounted balance, allowing s_totalWithdrawn to surpass s_totalDeposited, breaking a critical accounting invariant. An attacker could exploit this by airdropping and staking tokens or directly transferring stRESOLV to the proxy, then withdrawing more than their deposited principal. The impact includes inaccurate accounting, misleading analytics, and potential manipulation of withdrawal logic, although no direct fund loss occurs due to reward miscalculation since accrued rewards are zero in such cases.\n",
            "severity": "Low",
            "location": [
                "P2pResolvProxy.claimStakedTokenDistributor",
                "P2pResolvProxy._getCurrentAssetAmount",
                "StakedTokenDistributor"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Code Duplication in claimStakedTokenDistributor() Access Control",
            "description": "The P2pResolvProxy.claimStakedTokenDistributor() function manually reimplements access control logic that is already defined in the onlyClientOrP2pOperator modifier, leading to code duplication. This duplication increases the deployed bytecode size, reduces code maintainability, and introduces a risk of inconsistency if access control rules are updated in one place but not the other. An attacker could potentially exploit future inconsistencies if the duplicated logic diverges, though no immediate security breach is possible if both implementations remain aligned. The root cause is poor code design and failure to reuse existing modifiers. The impact is primarily on code quality and long-term security maintenance rather than direct fund loss.\n",
            "severity": "Low",
            "location": [
                "P2pResolvProxy.claimStakedTokenDistributor",
                "P2pResolvProxy.onlyClientOrP2pOperator"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing Zero-Value Validation in withdrawUSR() Leads to No-Op Withdrawals",
            "description": "The P2pResolvProxy.withdrawUSR() function does not validate that the _amount parameter is non-zero before proceeding with the withdrawal logic. This allows users to initiate zero-value withdrawals, which result in a call to IStUSR.withdraw(0). Since the underlying stUSR contract does not revert on zero amounts, the transaction succeeds silently, triggering full accounting updates and event emissions despite no actual asset transfer. This behavior pollutes monitoring metrics, creates confusion in user experience, and wastes gas. The root cause is the absence of an input validation check at the function's entry point. While no funds are lost, the impact includes degraded system observability and inefficient use of resources.\n",
            "severity": "Low",
            "location": [
                "P2pResolvProxy.withdrawUSR",
                "P2pYieldProxy._withdraw"
            ],
            "files": [
                "4a986871444ef82f1db2d49421fac046f45e9c3d/p2p-lending-proxy/src/adapters/resolv/p2pResolvProxy/P2pResolvProxy.sol"
            ]
        }
    ],
    "affected_files": {
        "P2pResolvProxy.sol": "// SPDX-FileCopyrightText: 2025 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.30;\nimport \"../../../@resolv/IResolvStaking.sol\";\nimport \"../../../@resolv/IStUSR.sol\";\nimport \"../../../@resolv/IStakedTokenDistributor.sol\";\nimport \"../../../p2pYieldProxy/P2pYieldProxy.sol\";\nimport \"./IP2pResolvProxy.sol\";\n\nerror P2pResolvProxy__ZeroAddress_USR();\nerror P2pResolvProxy__AssetNotSupported(address _asset);\nerror P2pResolvProxy__UnauthorizedAccount(address _account);\nerror P2pResolvProxy__NotP2pOperator(address _caller);\nerror P2pResolvProxy__CallerNeitherClientNorP2pOperator(address _caller);\nerror P2pResolvProxy__ZeroAccruedRewards();\nerror P2pResolvProxy__UnsupportedAsset(address _asset);\n\ncontract P2pResolvProxy is P2pYieldProxy, IP2pResolvProxy {\n    using SafeERC20 for IERC20;\n\n    /// @dev USR address\n    address internal immutable i_USR;\n\n    /// @dev stUSR address\n    address internal immutable i_stUSR;\n\n    /// @dev RESOLV address\n    address internal immutable i_RESOLV;\n\n    /// @dev stRESOLV address\n    address internal immutable i_stRESOLV;\n\n    IStakedTokenDistributor private immutable i_stakedTokenDistributor;\n\n    /// @dev Throws if called by any account other than the P2pOperator.\n    modifier onlyP2pOperator() {\n        address p2pOperator = i_factory.getP2pOperator();\n        require (msg.sender == p2pOperator, P2pResolvProxy__NotP2pOperator(msg.sender));\n        _;\n    }\n\n    /// @dev Throws if called by any account other than client or P2pOperator.\n    modifier onlyClientOrP2pOperator() {\n        if (msg.sender != s_client) {\n            address p2pOperator = i_factory.getP2pOperator();\n            require (msg.sender == p2pOperator, P2pResolvProxy__CallerNeitherClientNorP2pOperator(msg.sender));\n        }\n        _;\n    }\n\n    /// @notice Constructor for P2pResolvProxy\n    /// @param _factory Factory address\n    /// @param _p2pTreasury P2pTreasury address\n    /// @param _allowedCalldataChecker AllowedCalldataChecker\n    /// @param _stUSR stUSR address\n    /// @param _USR USR address\n    /// @param _stRESOLV stRESOLV address\n    /// @param _RESOLV RESOLV address\n    /// @param _stakedTokenDistributor StakedTokenDistributor\n    constructor(\n        address _factory,\n        address _p2pTreasury,\n        address _allowedCalldataChecker,\n        address _stUSR,\n        address _USR,\n        address _stRESOLV,\n        address _RESOLV,\n        address _stakedTokenDistributor\n    ) P2pYieldProxy(_factory, _p2pTreasury, _allowedCalldataChecker) {\n        require(_USR != address(0), P2pResolvProxy__ZeroAddress_USR());\n        i_USR = _USR;\n\n        i_stUSR = _stUSR;\n\n        i_RESOLV = _RESOLV;\n\n        i_stRESOLV = _stRESOLV;\n\n        i_stakedTokenDistributor = IStakedTokenDistributor(_stakedTokenDistributor);\n    }\n\n    /// @inheritdoc IP2pYieldProxy\n    function deposit(address _asset, uint256 _amount) external override {\n        if (_asset == i_USR) {\n            _deposit(\n                i_stUSR,\n                abi.encodeWithSelector(IStUSR.deposit.selector, _amount),\n                i_USR,\n                _amount\n            );\n        } else if (_asset == i_RESOLV) {\n            _deposit(\n                i_stRESOLV,\n                abi.encodeWithSelector(IResolvStaking.deposit.selector, _amount, address(this)),\n                i_RESOLV,\n                _amount\n            );\n        } else {\n            revert P2pResolvProxy__AssetNotSupported(_asset);\n        }\n    }\n\n    /// @inheritdoc IP2pResolvProxy\n    function withdrawUSR(uint256 _amount)\n    external\n    onlyClient {\n        uint256 currentBalance = IERC20(i_stUSR).balanceOf(address(this));\n        if (_amount >= currentBalance || currentBalance - _amount <= 1) {\n            _withdraw(\n                i_stUSR,\n                i_USR,\n                abi.encodeCall(IStUSR.withdrawAll, ())\n            );\n            return;\n        }\n        _withdraw(\n            i_stUSR,\n            i_USR,\n            abi.encodeWithSelector(IStUSR.withdraw.selector, _amount)\n        );\n    }\n\n    function withdrawUSRAccruedRewards()\n    external\n    onlyP2pOperator {\n        int256 amount = calculateAccruedRewardsUSR();\n        require (amount > 0, P2pResolvProxy__ZeroAccruedRewards());\n        _withdraw(\n            i_stUSR,\n            i_USR,\n            abi.encodeWithSelector(IStUSR.withdraw.selector, amount)\n        );\n    }\n\n    /// @inheritdoc IP2pResolvProxy\n    function withdrawAllUSR()\n    external\n    onlyClient {\n        _withdraw(\n            i_stUSR,\n            i_USR,\n            abi.encodeCall(IStUSR.withdrawAll, ())\n        );\n    }\n\n    /// @inheritdoc IP2pResolvProxy\n    function initiateWithdrawalRESOLV(uint256 _amount)\n    external\n    onlyClient {\n        return IResolvStaking(i_stRESOLV).initiateWithdrawal(_amount);\n    }\n\n    function initiateWithdrawalRESOLVAccruedRewards()\n    external\n    onlyP2pOperator {\n        int256 amount = calculateAccruedRewardsRESOLV();\n        require (amount > 0, P2pResolvProxy__ZeroAccruedRewards());\n        return IResolvStaking(i_stRESOLV).initiateWithdrawal(uint256(amount));\n    }\n\n    /// @inheritdoc IP2pResolvProxy\n    function withdrawRESOLV()\n    external\n    onlyClientOrP2pOperator {\n        bool isEnabled = IResolvStaking(i_stRESOLV).claimEnabled();\n\n        _withdraw(\n            i_stRESOLV,\n            i_RESOLV,\n            abi.encodeWithSelector(IResolvStaking.withdraw.selector, isEnabled, address(this))\n        );\n    }\n\n    /// @inheritdoc IP2pResolvProxy\n    function claimStakedTokenDistributor(\n        uint256 _index,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    )\n    external\n    nonReentrant\n    {\n        if (msg.sender != s_client) {\n            address p2pOperator = i_factory.getP2pOperator();\n            require(\n                msg.sender == p2pOperator,\n                P2pResolvProxy__UnauthorizedAccount(msg.sender)\n            );\n        }\n\n        // claim _reward token from StakedTokenDistributor\n        i_stakedTokenDistributor.claim(_index, _amount, _merkleProof);\n\n        emit P2pResolvProxy__Claimed(_amount);\n    }\n\n    function getUserPrincipalUSR() public view returns(uint256) {\n        return getUserPrincipal(i_USR);\n    }\n\n    function getUserPrincipalRESOLV() public view returns(uint256) {\n        return getUserPrincipal(i_RESOLV);\n    }\n\n    function calculateAccruedRewardsUSR() public view returns(int256) {\n        return calculateAccruedRewards(i_stUSR,i_USR);\n    }\n\n    function calculateAccruedRewardsRESOLV() public view returns(int256) {\n        return calculateAccruedRewards(i_stRESOLV,i_RESOLV);\n    }\n\n    function getLastFeeCollectionTimeUSR() public view returns(uint48) {\n        return getLastFeeCollectionTime(i_USR);\n    }\n\n    function getLastFeeCollectionTimeRESOLV() public view returns(uint48) {\n        return getLastFeeCollectionTime(i_RESOLV);\n    }\n\n    function _getCurrentAssetAmount(address _yieldProtocolAddress, address _asset) internal view override returns (uint256) {\n        if (_asset == i_RESOLV) {\n            uint256 pendingClaimable = IResolvStaking(_yieldProtocolAddress).getUserClaimableAmounts(address(this), i_RESOLV);\n            return getUserPrincipal(_asset) + pendingClaimable;\n        }\n\n        if (_asset == i_USR) {\n            return IERC20(_yieldProtocolAddress).balanceOf(address(this));\n        }\n\n        revert P2pResolvProxy__UnsupportedAsset(_asset);\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(P2pYieldProxy) returns (bool) {\n        return interfaceId == type(IP2pResolvProxy).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    }
}