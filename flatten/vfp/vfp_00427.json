{
    "vfp_id": "vfp_00427",
    "project_name": "ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "findings": [
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Floating Pragma",
            "description": "Some contracts use a floating Solidity pragma, which can lead to compilation with untested compiler versions.\n\nThe root cause is lack of version pinning in Solidity source files.\n\nDeployment with a different compiler version could introduce unexpected behavior or bugs.\n\nThe impact is risk of compilation inconsistencies and potential vulnerabilities due to compiler-specific behaviors.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry.sol",
                "Other contracts with floating pragma"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGPool.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveFactory.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGFactory.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurvePool.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3ExchangeHelpers.sol",
                "bold/contracts/src/Zappers/Interfaces/IFlashLoanReceiver.sol",
                "bold/contracts/src/Zappers/Interfaces/ILeverageZapper.sol",
                "bold/contracts/src/Zappers/Interfaces/IZapper.sol",
                "bold/contracts/src/Zappers/Interfaces/IExchangeHelpers.sol",
                "bold/contracts/src/Zappers/Interfaces/IFlashLoanProvider.sol",
                "bold/contracts/src/Zappers/Interfaces/IExchange.sol"
            ]
        }
    ],
    "affected_files": {
        "IFlashLoanReceiver.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IZapper.sol\";\nimport \"./ILeverageZapper.sol\";\n\ninterface IFlashLoanReceiver {\n    function receiveFlashLoanOnOpenLeveragedTrove(\n        ILeverageZapper.OpenLeveragedTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n    function receiveFlashLoanOnLeverUpTrove(\n        ILeverageZapper.LeverUpTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n    function receiveFlashLoanOnLeverDownTrove(\n        ILeverageZapper.LeverDownTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n    function receiveFlashLoanOnCloseTroveFromCollateral(\n        IZapper.CloseTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external;\n}\n",
        "ICurveStableswapNGPool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICurveStableswapNGPool {\n    function add_liquidity(uint256[] memory amounts, uint256 min_mint_amount) external returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256 output);\n    function get_dx(int128 i, int128 j, uint256 dy) external view returns (uint256 dx);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\n}\n",
        "IExchangeHelpers.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExchangeHelpers {\n    function getCollFromBold(uint256 _boldAmount, IERC20 _collToken, uint256 _desiredCollAmount)\n        external /* view */\n        returns (uint256, uint256);\n}\n",
        "IZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IFlashLoanProvider.sol\";\nimport \"./IExchange.sol\";\n\ninterface IZapper {\n    struct OpenTroveParams {\n        address owner;\n        uint256 ownerIndex;\n        uint256 collAmount;\n        uint256 boldAmount;\n        uint256 upperHint;\n        uint256 lowerHint;\n        uint256 annualInterestRate;\n        address batchManager;\n        uint256 maxUpfrontFee;\n        address addManager;\n        address removeManager;\n        address receiver;\n    }\n\n    struct CloseTroveParams {\n        uint256 troveId;\n        uint256 flashLoanAmount;\n        uint256 minExpectedCollateral;\n        address receiver;\n    }\n\n    function flashLoanProvider() external view returns (IFlashLoanProvider);\n\n    function exchange() external view returns (IExchange);\n\n    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256);\n\n    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount, uint256 _minExpectedCollateral)\n        external;\n}\n",
        "IExchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IExchange {\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external;\n\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256);\n}\n",
        "IFlashLoanProvider.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"./ILeverageZapper.sol\";\nimport \"./IFlashLoanReceiver.sol\";\n\ninterface IFlashLoanProvider {\n    enum Operation {\n        OpenTrove,\n        CloseTrove,\n        LeverUpTrove,\n        LeverDownTrove\n    }\n\n    function receiver() external view returns (IFlashLoanReceiver);\n\n    function makeFlashLoan(IERC20 _token, uint256 _amount, Operation _operation, bytes calldata userData) external;\n}\n",
        "ICurvePool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);\n    //function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth, address receiver) external returns (uint256 output);\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256 output);\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256 dy);\n}\n",
        "ILeverageZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IZapper.sol\";\n\ninterface ILeverageZapper is IZapper {\n    struct OpenLeveragedTroveParams {\n        address owner;\n        uint256 ownerIndex;\n        uint256 collAmount;\n        uint256 flashLoanAmount;\n        uint256 boldAmount;\n        uint256 upperHint;\n        uint256 lowerHint;\n        uint256 annualInterestRate;\n        address batchManager;\n        uint256 maxUpfrontFee;\n        address addManager;\n        address removeManager;\n        address receiver;\n    }\n\n    struct LeverUpTroveParams {\n        uint256 troveId;\n        uint256 flashLoanAmount;\n        uint256 boldAmount;\n        uint256 maxUpfrontFee;\n    }\n\n    struct LeverDownTroveParams {\n        uint256 troveId;\n        uint256 flashLoanAmount;\n        uint256 minBoldAmount;\n    }\n\n    function openLeveragedTroveWithRawETH(OpenLeveragedTroveParams calldata _params) external payable;\n\n    function leverUpTrove(LeverUpTroveParams calldata _params) external;\n\n    function leverDownTrove(LeverDownTroveParams calldata _params) external;\n\n    function leverageRatioToCollateralRatio(uint256 _inputRatio) external pure returns (uint256);\n}\n",
        "ICurveStableswapNGFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ICurveStableswapNGPool.sol\";\n\ninterface ICurveStableswapNGFactory {\n    /*\n    function deploy_plain_pool(\n        string memory name,\n        string memory symbol,\n        address[2] memory coins,\n        uint256 A,\n        uint256 fee,\n        uint256 asset_type,\n        uint256 implementation_id\n    ) external returns (ICurvePool);\n    */\n    function deploy_plain_pool(\n        string memory name,\n        string memory symbol,\n        address[] memory coins,\n        uint256 A,\n        uint256 fee,\n        uint256 offpeg_fee_multiplier,\n        uint256 ma_exp_time,\n        uint256 implementation_id,\n        uint8[] memory asset_types,\n        bytes4[] memory method_ids,\n        address[] memory oracles\n    ) external returns (ICurveStableswapNGPool);\n}\n",
        "ICurveFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ICurvePool.sol\";\n\ninterface ICurveFactory {\n    function deploy_pool(\n        string memory name,\n        string memory symbol,\n        address[2] memory coins,\n        uint256 implementation_id,\n        uint256 A,\n        uint256 gamma,\n        uint256 mid_fee,\n        uint256 out_fee,\n        uint256 fee_gamma,\n        uint256 allowed_extra_profit,\n        uint256 adjustment_step,\n        uint256 ma_exp_time,\n        uint256 initial_price\n    ) external returns (ICurvePool);\n}\n",
        "HybridCurveUniV3Exchange.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"../../../Interfaces/IWETH.sol\";\nimport \"../../LeftoversSweep.sol\";\n// Curve\nimport \"./Curve/ICurveStableswapNGPool.sol\";\n// UniV3\nimport \"./UniswapV3/ISwapRouter.sol\";\n\nimport \"../../Interfaces/IExchange.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract HybridCurveUniV3Exchange is LeftoversSweep, IExchange {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n    IBoldToken public immutable boldToken;\n    IERC20 public immutable USDC;\n    IWETH public immutable WETH;\n\n    // Curve\n    ICurveStableswapNGPool public immutable curvePool;\n    uint128 public immutable USDC_INDEX;\n    uint128 public immutable BOLD_TOKEN_INDEX;\n\n    // Uniswap\n    uint24 public immutable feeUsdcWeth;\n    uint24 public immutable feeWethColl;\n    ISwapRouter public immutable uniV3Router;\n\n    constructor(\n        IERC20 _collToken,\n        IBoldToken _boldToken,\n        IERC20 _usdc,\n        IWETH _weth,\n        // Curve\n        ICurveStableswapNGPool _curvePool,\n        uint128 _usdcIndex,\n        uint128 _boldIndex,\n        // UniV3\n        uint24 _feeUsdcWeth,\n        uint24 _feeWethColl,\n        ISwapRouter _uniV3Router\n    ) {\n        collToken = _collToken;\n        boldToken = _boldToken;\n        USDC = _usdc;\n        WETH = _weth;\n\n        // Curve\n        curvePool = _curvePool;\n        USDC_INDEX = _usdcIndex;\n        BOLD_TOKEN_INDEX = _boldIndex;\n\n        // Uniswap\n        feeUsdcWeth = _feeUsdcWeth;\n        feeWethColl = _feeWethColl;\n        uniV3Router = _uniV3Router;\n    }\n\n    // Bold -> USDC on Curve; then USDC -> WETH, and optionally WETH -> Coll, on UniV3\n    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {\n        InitialBalances memory initialBalances;\n        _setHybridExchangeInitialBalances(initialBalances);\n\n        // Curve\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n        boldToken.approve(address(curvePool), _boldAmount);\n\n        uint256 curveUsdcAmount = curvePool.exchange(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), _boldAmount, 0);\n\n        // Uniswap\n        USDC.approve(address(uniV3Router), curveUsdcAmount);\n\n        // See: https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps\n        bytes memory path;\n        if (address(WETH) == address(collToken)) {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH);\n        } else {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH, feeWethColl, collToken);\n        }\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: curveUsdcAmount,\n            amountOutMinimum: _minCollAmount\n        });\n\n        // Executes the swap.\n        uniV3Router.exactInput(params);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    // Optionally Coll -> WETH, and WETH -> USDC on UniV3; then USDC -> Bold on Curve\n    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {\n        InitialBalances memory initialBalances;\n        _setHybridExchangeInitialBalances(initialBalances);\n\n        // Uniswap\n        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);\n        collToken.approve(address(uniV3Router), _collAmount);\n\n        // See: https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps\n        bytes memory path;\n        if (address(WETH) == address(collToken)) {\n            path = abi.encodePacked(WETH, feeUsdcWeth, USDC);\n        } else {\n            path = abi.encodePacked(collToken, feeWethColl, WETH, feeUsdcWeth, USDC);\n        }\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: _collAmount,\n            amountOutMinimum: 0\n        });\n\n        // Executes the swap.\n        uint256 uniV3UsdcAmount = uniV3Router.exactInput(params);\n\n        // Curve\n        USDC.approve(address(curvePool), uniV3UsdcAmount);\n\n        uint256 boldAmount =\n            curvePool.exchange(int128(USDC_INDEX), int128(BOLD_TOKEN_INDEX), uniV3UsdcAmount, _minBoldAmount);\n        boldToken.transfer(msg.sender, boldAmount);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n\n        return boldAmount;\n    }\n\n    function _setHybridExchangeInitialBalances(InitialBalances memory initialBalances) internal view {\n        initialBalances.tokens[0] = boldToken;\n        initialBalances.tokens[1] = USDC;\n        initialBalances.tokens[2] = WETH;\n        if (address(WETH) != address(collToken)) {\n            initialBalances.tokens[3] = collToken;\n        }\n        _setInitialBalances(initialBalances);\n    }\n}\n",
        "HybridCurveUniV3ExchangeHelpers.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"../../../Interfaces/IWETH.sol\";\n// Curve\nimport \"./Curve/ICurveStableswapNGPool.sol\";\n// UniV3\nimport \"./UniswapV3/IQuoterV2.sol\";\n\nimport \"../../Interfaces/IExchangeHelpers.sol\";\n\ncontract HybridCurveUniV3ExchangeHelpers is IExchangeHelpers {\n    uint256 private constant DECIMAL_PRECISION = 1e18;\n\n    //HybridCurveUniV3Exchange public immutable exchange;\n\n    IERC20 public immutable USDC;\n    IWETH public immutable WETH;\n\n    // Curve\n    ICurveStableswapNGPool public immutable curvePool;\n    uint128 public immutable USDC_INDEX;\n    uint128 public immutable BOLD_TOKEN_INDEX;\n\n    // Uniswap\n    uint24 public immutable feeUsdcWeth;\n    uint24 public immutable feeWethColl;\n    IQuoterV2 public immutable uniV3Quoter;\n\n    /*\n    constructor(HybridCurveUniV3Exchange _exchange) {\n        exchange = _exchange;\n\n        USDC = _exchange.USDC();\n        WETH = _exchange.WETH();\n\n        curvePool = _exchange.curvePool();\n        USDC_INDEX = _exchange.USDC_INDEX();\n        BOLD_TOKEN_INDEX = _exchange.BOLD_INDEX();\n\n        // Uniswap\n        feeUsdcWeth = _exchange.feeUsdcWeth();\n        feeWethColl = _exchange.feeWethColl();\n        uniV3Quoter = _exchange.uniV3Quoter();\n    }\n    */\n\n    constructor(\n        IERC20 _usdc,\n        IWETH _weth,\n        // Curve\n        ICurveStableswapNGPool _curvePool,\n        uint128 _usdcIndex,\n        uint128 _boldIndex,\n        // UniV3\n        uint24 _feeUsdcWeth,\n        uint24 _feeWethColl,\n        IQuoterV2 _uniV3Quoter\n    ) {\n        USDC = _usdc;\n        WETH = _weth;\n\n        // Curve\n        curvePool = _curvePool;\n        USDC_INDEX = _usdcIndex;\n        BOLD_TOKEN_INDEX = _boldIndex;\n\n        // Uniswap\n        feeUsdcWeth = _feeUsdcWeth;\n        feeWethColl = _feeWethColl;\n        uniV3Quoter = _uniV3Quoter;\n    }\n\n    function getCollFromBold(uint256 _boldAmount, IERC20 _collToken, uint256 _desiredCollAmount)\n        external /* view */\n        returns (uint256 collAmount, uint256 deviation)\n    {\n        // BOLD -> USDC\n        uint256 curveUsdcAmount = curvePool.get_dy(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), _boldAmount);\n\n        // USDC -> Coll\n        bytes memory path;\n        if (address(WETH) == address(_collToken)) {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH);\n        } else {\n            path = abi.encodePacked(USDC, feeUsdcWeth, WETH, feeWethColl, _collToken);\n        }\n\n        (collAmount,,,) = uniV3Quoter.quoteExactInput(path, curveUsdcAmount);\n\n        if (_desiredCollAmount > 0 && collAmount <= _desiredCollAmount) {\n            deviation = DECIMAL_PRECISION - collAmount * DECIMAL_PRECISION / _desiredCollAmount;\n        }\n\n        return (collAmount, deviation);\n    }\n}\n"
    }
}