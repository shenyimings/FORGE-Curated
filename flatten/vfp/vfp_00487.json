{
    "vfp_id": "vfp_00487",
    "project_name": "2024.12.21 - Final - Idle Finance Credit Vaults Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Depositing to IdleCDO is vulnerable to inflation attacks",
            "description": "The IdleCDO contract is susceptible to an inflation attack where an attacker can manipulate the share price by donating a large amount of underlying assets just before a user's deposit transaction. The vulnerability arises because the share price calculation in `_tranchePrice` and `_virtualPriceAux` relies on the contract's balance via `balanceOf(address(this))`, which includes unsolicited donations. When the total supply of LP tokens is zero, the first depositor mints shares at a 1:1 ratio. An attacker can then donate a large amount of tokens, inflating the net asset value (NAV), causing subsequent depositors to receive fewer or zero shares due to rounding. The attacker later redeems their minimal share for a disproportionately large amount of assets. This results in loss of funds for users due to rounding errors and creates an implicit minimum deposit requirement to avoid value loss.\n",
            "severity": "High",
            "location": [
                "IdleCDO.sol::_deposit#128",
                "IdleCDO.sol::_mintShares#270",
                "IdleCDO.sol::_tranchePrice#188",
                "IdleCDO.sol::_virtualPriceAux#315",
                "IdleCDO.sol::getContractValue",
                "IdleCDO.sol::_contractTokenBalance"
            ],
            "files": [
                "idle-tranches/contracts/IdleCDO.sol"
            ]
        }
    ],
    "affected_files": {
        "IdleCDO.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IIdleCDOStrategy.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\n\nimport \"./GuardedLaunchUpgradable.sol\";\nimport \"./IdleCDOTranche.sol\";\nimport \"./IdleCDOStorage.sol\";\n\n/// @title A perpetual tranche implementation\n/// @author Idle Labs Inc.\n/// @notice More info and high level overview in the README\n/// @dev The contract is upgradable, to add storage slots, create IdleCDOStorageVX and inherit from IdleCDOStorage, then update the definitaion below\ncontract IdleCDO is PausableUpgradeable, GuardedLaunchUpgradable, IdleCDOStorage {\n  using SafeERC20Upgradeable for IERC20Detailed;\n\n  // ERROR MESSAGES:\n  // 0 = is 0\n  // 1 = already initialized\n  // 2 = Contract limit reached\n  // 3 = Tranche withdraw not allowed (Paused or in shutdown)\n  // 4 = Default, wait shutdown\n  // 5 = Amount too low\n  // 6 = Not authorized\n  // 7 = Amount too high\n  // 8 = Same block\n  // 9 = Invalid\n\n  // Used to prevent initialization of the implementation contract\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    token = address(1);\n  }\n\n  // ###################\n  // Initializer\n  // ###################\n\n  /// @notice can only be called once\n  /// @dev Initialize the upgradable contract\n  /// @param _limit contract value limit, can be 0\n  /// @param _guardedToken underlying token\n  /// @param _governanceFund address where funds will be sent in case of emergency\n  /// @param _owner guardian address (can pause, unpause and call emergencyShutdown)\n  /// @param _rebalancer rebalancer address\n  /// @param _strategy strategy address\n  /// @param _trancheAPRSplitRatio trancheAPRSplitRatio value\n  function initialize(\n    uint256 _limit, \n    address _guardedToken, \n    address _governanceFund, \n    address _owner, // GuardedLaunch args\n    address _rebalancer,\n    address _strategy,\n    uint256 _trancheAPRSplitRatio // for AA tranches, so eg 10000 means 10% interest to AA and 90% BB\n  ) external initializer {\n    require(token == address(0), '1');\n    require(_rebalancer != address(0), '0');\n    require(_strategy != address(0), '0');\n    require(_guardedToken != address(0), '0');\n    require( _trancheAPRSplitRatio <= FULL_ALLOC, '7');\n    // Initialize contracts\n    PausableUpgradeable.__Pausable_init();\n    // check for _governanceFund and _owner != address(0) are inside GuardedLaunchUpgradable\n    GuardedLaunchUpgradable.__GuardedLaunch_init(_limit, _governanceFund, _owner);\n    // Deploy Tranches tokens\n    address _strategyToken = IIdleCDOStrategy(_strategy).strategyToken();\n    // get strategy token symbol (eg. idleDAI)\n    string memory _symbol = IERC20Detailed(_strategyToken).symbol();\n    // create tranche tokens (concat strategy token symbol in the name and symbol of the tranche tokens)\n    AATranche = address(new IdleCDOTranche(_concat(string(\"IdleCDO AA Tranche - \"), _symbol), _concat(string(\"AA_\"), _symbol)));\n    BBTranche = address(new IdleCDOTranche(_concat(string(\"IdleCDO BB Tranche - \"), _symbol), _concat(string(\"BB_\"), _symbol)));\n    // Set CDO params\n    token = _guardedToken;\n    strategy = _strategy;\n    strategyToken = _strategyToken;\n    rebalancer = _rebalancer;\n    trancheAPRSplitRatio = _trancheAPRSplitRatio;\n    uint256 _oneToken = 10**(IERC20Detailed(_guardedToken).decimals());\n    oneToken = _oneToken;\n    uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    // incentiveTokens = _incentiveTokens; [DEPRECATED]\n    priceAA = _oneToken;\n    priceBB = _oneToken;\n    unlentPerc = 2000; // 2%\n    // # blocks, after an harvest, during which harvested rewards gets progressively unlocked\n    releaseBlocksPeriod = 6400; // about 1 day\n    // Set flags\n    allowAAWithdraw = true;\n    allowBBWithdraw = true;\n    revertIfTooLow = true;\n    // skipDefaultCheck = false is the default value\n    // Set allowance for strategy\n    _allowUnlimitedSpend(_guardedToken, _strategy);\n    _allowUnlimitedSpend(_strategyToken, _strategy);\n    // Save current strategy price\n    lastStrategyPrice = _strategyPrice();\n    // Fee params\n    fee = 15000; // 15% performance fee\n    feeReceiver = address(0xFb3bD022D5DAcF95eE28a6B07825D4Ff9C5b3814); // treasury multisig\n    guardian = _owner;\n    // feeSplit = 0; // default all to feeReceiver\n    isAYSActive = true; // adaptive yield split\n    minAprSplitAYS = AA_RATIO_LIM_DOWN; // AA tranche will get min 50% of the yield\n\n    maxDecreaseDefault = 5000; // 5% decrease for triggering a default\n    _additionalInit();\n  }\n\n  /// @notice used by child contracts (cdo variants) if anything needs to be done on/after init\n  function _additionalInit() internal virtual {}\n\n  // ###############\n  // Public methods\n  // ###############\n\n  /// @notice pausable\n  /// @dev msg.sender should approve this contract first to spend `_amount` of `token`\n  /// @param _amount amount of `token` to deposit\n  /// @return AA tranche tokens minted\n  function depositAA(uint256 _amount) external returns (uint256) {\n    return _deposit(_amount, AATranche, address(0));\n  }\n\n  /// @notice pausable in _deposit\n  /// @dev msg.sender should approve this contract first to spend `_amount` of `token`\n  /// @param _amount amount of `token` to deposit\n  /// @return BB tranche tokens minted\n  function depositBB(uint256 _amount) external returns (uint256) {\n    return _deposit(_amount, BBTranche, address(0));\n  }\n\n  /// @notice pausable\n  /// @dev msg.sender should approve this contract first to spend `_amount` of `token`\n  /// @param _amount amount of `token` to deposit\n  /// @param _referral address of the referral\n  /// @return AA tranche tokens minted\n  function depositAARef(uint256 _amount, address _referral) external virtual returns (uint256) {\n    return _deposit(_amount, AATranche, _referral);\n  }\n\n  /// @notice pausable in _deposit\n  /// @dev msg.sender should approve this contract first to spend `_amount` of `token`\n  /// @param _amount amount of `token` to deposit\n  /// @param _referral address of the referral\n  /// @return BB tranche tokens minted\n  function depositBBRef(uint256 _amount, address _referral) external virtual returns (uint256) {\n    return _deposit(_amount, BBTranche, _referral);\n  }\n\n  /// @notice pausable in _deposit\n  /// @param _amount amount of AA tranche tokens to burn\n  /// @return underlying tokens redeemed\n  function withdrawAA(uint256 _amount) external virtual returns (uint256) {\n    require(!paused() || allowAAWithdraw, '3');\n    return _withdraw(_amount, AATranche);\n  }\n\n  /// @notice pausable\n  /// @param _amount amount of BB tranche tokens to burn\n  /// @return underlying tokens redeemed\n  function withdrawBB(uint256 _amount) external virtual returns (uint256) {\n    require(!paused() || allowBBWithdraw, '3');\n    return _withdraw(_amount, BBTranche);\n  }\n\n  // ###############\n  // Views\n  // ###############\n\n  /// @param _tranche tranche address\n  /// @return tranche price, in underlyings, at the last interaction (not considering interest earned \n  /// since last interaction)\n  function tranchePrice(address _tranche) external view returns (uint256) {\n    return _tranchePrice(_tranche);\n  }\n\n  /// @notice calculates the current net TVL (in `token` terms)\n  /// @dev unclaimed rewards (gov tokens) and `unclaimedFees` are not counted. \n  /// Harvested rewards are counted only if enough blocks have passed (`_lockedRewards`)\n  function getContractValue() public override view returns (uint256) {\n    address _strategyToken = strategyToken;\n    uint256 strategyTokenDecimals = IERC20Detailed(_strategyToken).decimals();\n    // TVL is the sum of unlent balance in the contract + the balance in lending - harvested but locked rewards - unclaimedFees\n    // Balance in lending is the value of the interest bearing assets (strategyTokens) in this contract\n    // TVL = (strategyTokens * strategy token price) + unlent balance - lockedRewards - unclaimedFees\n    return (_contractTokenBalance(_strategyToken) * _strategyPrice() / (10**(strategyTokenDecimals))) +\n            _contractTokenBalance(token) -\n            _lockedRewards() -\n            unclaimedFees;\n  }\n\n  /// @param _tranche tranche address\n  /// @return actual apr given current ratio between AA and BB tranches\n  function getApr(address _tranche) external view returns (uint256) {\n    return _getApr(_tranche, _getAARatio(false));\n  }\n\n  /// @notice calculates the current AA tranches ratio\n  /// @dev _virtualBalance is used to have a more accurate/recent value for the AA ratio\n  /// because it calculates the balance after splitting the accrued interest since the\n  /// last depositXX/withdrawXX/harvest\n  /// @return AA tranches ratio (in underlying value) considering all interest\n  function getCurrentAARatio() external view returns (uint256) {\n    return _getAARatio(false);\n  }\n\n  /// @notice calculates the current tranches price considering the interest/loss that is yet to be splitted\n  /// ie the interest/loss generated since the last update of priceAA and priceBB (done on depositXX/withdrawXX/harvest)\n  /// @param _tranche address of the requested tranche\n  /// @return _virtualPrice tranche price considering all interest/losses\n  function virtualPrice(address _tranche) public virtual view returns (uint256 _virtualPrice) {\n    // get both NAVs, because we need the total NAV anyway\n    uint256 _lastNAVAA = lastNAVAA;\n    uint256 _lastNAVBB = lastNAVBB;\n\n    (_virtualPrice, ) = _virtualPriceAux(\n      _tranche,\n      getContractValue(), // nav\n      _lastNAVAA + _lastNAVBB, // lastNAV\n      _tranche == AATranche ? _lastNAVAA : _lastNAVBB, // lastTrancheNAV\n      trancheAPRSplitRatio\n    );\n  }\n\n  // ###############\n  // Internal\n  // ###############\n\n  /// @notice method used to check if depositor has enough stkIDLE per unit of underlying to access the vault.\n  /// This can be used to give priority access to new vaults to stkIDLE holders. \n  /// @dev This check is only intended for \"regular\" users as it does not strictly enforce the _stkIDLEPerUnderlying \n  /// ratio (eg: deposit+transfer). This will be mitigated by the fee rebate mechanism (airdrop) as otherwise those\n  /// rebates will be lost.\n  /// @param _amount amount of underlying to deposit\n  function _checkStkIDLEBal(address _tranche, uint256 _amount) internal view virtual {\n    uint256 _stkIDLEPerUnderlying = stkIDLEPerUnderlying;\n    // check if stkIDLE requirement is active for _tranche\n    if (_stkIDLEPerUnderlying == 0 || \n      (_tranche == BBTranche && BBStaking == address(0)) || \n      (_tranche == AATranche && AAStaking == address(0))) {\n      return;\n    }\n\n    uint256 trancheBal = IERC20Detailed(_tranche).balanceOf(msg.sender);\n    // We check if sender deposited in the same tranche previously and add the bal to _amount\n    uint256 bal = _amount + (trancheBal > 0 ? (trancheBal * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN) : 0);\n    require(\n      IERC20(STK_IDLE).balanceOf(msg.sender) >= \n      bal * _stkIDLEPerUnderlying / oneToken, \n      '7'\n    );\n  }\n\n  /// @notice method used to deposit `token` and mint tranche tokens\n  /// Ideally users should deposit right after an `harvest` call to maximize profit\n  /// @dev this contract must be approved to spend at least _amount of `token` before calling this method\n  /// automatically reverts on lending provider default (_strategyPrice decreased)\n  /// @param _amount amount of underlyings (`token`) to deposit\n  /// @param _tranche tranche address\n  /// @param _referral referral address\n  /// @return _minted number of tranche tokens minted\n  function _deposit(uint256 _amount, address _tranche, address _referral) internal virtual whenNotPaused returns (uint256 _minted) {\n    if (_amount == 0) {\n      return _minted;\n    }\n    // check that we are not depositing more than the contract available limit\n    _guarded(_amount);\n    // set _lastCallerBlock hash\n    _updateCallerBlock();\n    // check if _strategyPrice decreased\n    _checkDefault();\n    // interest accrued since last depositXX/withdrawXX/harvest is splitted between AA and BB\n    // according to trancheAPRSplitRatio. NAVs of AA and BB are updated and tranche\n    // prices adjusted accordingly\n    _updateAccounting();\n    // check if depositor has enough stkIDLE for the amount to be deposited\n    _checkStkIDLEBal(_tranche, _amount);\n    // get underlyings from sender\n    address _token = token;\n    uint256 _preBal = _contractTokenBalance(_token);\n    IERC20Detailed(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    // mint tranche tokens according to the current tranche price\n    _minted = _mintShares(_contractTokenBalance(_token) - _preBal, msg.sender, _tranche);\n    // update trancheAPRSplitRatio\n    _updateSplitRatio(_getAARatio(true));\n\n    if (directDeposit) {\n      IIdleCDOStrategy(strategy).deposit(_amount);\n    }\n\n    if (_referral != address(0)) {\n      emit Referral(_amount, _referral);\n    }\n  }\n\n  /// @notice this method is called on depositXX/withdrawXX/harvest and\n  /// updates the accounting of the contract and effectively splits the yield/loss between the\n  /// AA and BB tranches\n  /// @dev this method:\n  /// - update tranche prices (priceAA and priceBB)\n  /// - update net asset value for both tranches (lastNAVAA and lastNAVBB)\n  /// - update fee accounting (unclaimedFees)\n  function _updateAccounting() internal virtual {\n    uint256 _lastNAVAA = lastNAVAA;\n    uint256 _lastNAVBB = lastNAVBB;\n    uint256 _lastNAV = _lastNAVAA + _lastNAVBB;\n    uint256 nav = getContractValue();\n    uint256 _aprSplitRatio = trancheAPRSplitRatio;\n    // If gain is > 0, then collect some fees in `unclaimedFees`\n    if (nav > _lastNAV) {\n      unclaimedFees += (nav - _lastNAV) * fee / FULL_ALLOC;\n    }\n    (uint256 _priceAA, int256 _totalAAGain) = _virtualPriceAux(AATranche, nav, _lastNAV, _lastNAVAA, _aprSplitRatio);\n    (uint256 _priceBB, int256 _totalBBGain) = _virtualPriceAux(BBTranche, nav, _lastNAV, _lastNAVBB, _aprSplitRatio);\n    lastNAVAA = uint256(int256(_lastNAVAA) + _totalAAGain);\n\n    // if we have a loss and it's gte last junior NAV we trigger a default\n    if (_totalBBGain < 0 && -_totalBBGain >= int256(_lastNAVBB)) {\n      // revert with 'default' error (4) if skipDefaultCheck is false, as seniors will have a loss too not covered. \n      // `updateAccounting` should be manually called to distribute loss\n      require(skipDefaultCheck, \"4\");\n      // This path will be called when a default happens and guardian calls\n      // `updateAccounting` after setting skipDefaultCheck or when skipDefaultCheck is already set to true\n      lastNAVBB = 0;\n      // if skipDefaultCheck is set to true prior a default (eg because AA is used as collateral and needs to be liquid), \n      // emergencyShutdown won't prevent the current deposit/redeem (the one that called this _updateAccounting) and is \n      // still correct because:\n      // - depositBB will revert as priceBB is 0\n      // - depositAA won't revert (unless the loss is 100% of TVL) and user will get \n      //   correct number of share at a priceAA already post junior default\n      // - withdrawBB will redeem 0 and burn BB tokens because priceBB is 0\n      // - withdrawAA will redeem the correct amount of underlyings post junior default\n      // We pass true as we still want AA to be redeemable in any case even after a junior default\n      _emergencyShutdown(true);\n    } else {\n      // we add the gain to last saved NAV\n      lastNAVBB = uint256(int256(_lastNAVBB) + _totalBBGain);\n    }\n    priceAA = _priceAA;\n    priceBB = _priceBB;\n  }\n\n  /// @notice calculates the NAV for a tranche considering the interest that is yet to be splitted\n  /// @param _tranche address of the requested tranche\n  /// @return net asset value, in underlying tokens, for _tranche considering all nav\n  function _virtualBalance(address _tranche) internal view returns (uint256) {\n    // balance is: tranche supply * virtual tranche price\n    return IdleCDOTranche(_tranche).totalSupply() * virtualPrice(_tranche) / ONE_TRANCHE_TOKEN;\n  }\n\n  /// @notice calculates the NAV for a tranche without considering the interest that is yet to be splitted\n  /// @param _tranche address of the requested tranche\n  /// @return net asset value, in underlying tokens, for _tranche\n  function _instantBalance(address _tranche) internal view returns (uint256) {\n    return IdleCDOTranche(_tranche).totalSupply() * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN;\n  }\n\n  /// @notice calculates the current tranches price considering the interest/loss that is yet to be splitted and the\n  /// total gain/loss for a specific tranche\n  /// @dev Main scenarios covered:\n  /// - if there is a loss on the lending protocol (ie strategy price decrease) up to maxDecreaseDefault (_checkDefault method), the loss is\n  ///     - totally absorbed by junior holders if they have enough TVL and deposits/redeems work as normal\n  ///     - otherwise a 'default' error (4) is raised and deposits/redeems are blocked\n  /// - if there is a loss on the lending protocol (ie strategy price decrease) more than maxDecreaseDefault all deposits and redeems\n  ///   are blocked and a 'default' error (4) is raised\n  /// - if there is a loss somewhere not in the lending protocol (ie in our contracts) and the TVL decreases then the same process as above\n  ///   applies, the only difference is that maxDecreaseDefault is not considered\n  /// In any case, once a loss happens, it only gets accounted when new deposits/redeems are made, but those are blocked.\n  /// For this reason a protected updateAccounting method has been added which should be used to distributed the loss after a default event\n  /// @param _tranche address of the requested tranche\n  /// @param _nav current NAV\n  /// @param _lastNAV last saved NAV\n  /// @param _lastTrancheNAV last saved tranche NAV\n  /// @param _trancheAPRSplitRatio APR split ratio for AA tranche\n  /// @return _virtualPrice tranche price considering all interest\n  /// @return _totalTrancheGain (int256) tranche gain/loss since last update\n  function _virtualPriceAux(\n    address _tranche,\n    uint256 _nav,\n    uint256 _lastNAV,\n    uint256 _lastTrancheNAV,\n    uint256 _trancheAPRSplitRatio\n  ) internal virtual view returns (uint256 _virtualPrice, int256 _totalTrancheGain) {\n    // Check if there are tranche holders\n    uint256 trancheSupply = IdleCDOTranche(_tranche).totalSupply();\n    if (_lastNAV == 0 || trancheSupply == 0) {\n      return (oneToken, 0);\n    }\n\n    // In order to correctly split the interest generated between AA and BB tranche holders\n    // (according to the trancheAPRSplitRatio) we need to know how much interest/loss we gained\n    // since the last price update (during a depositXX/withdrawXX/harvest)\n    // To do that we need to get the current value of the assets in this contract\n    // and the last saved one (always during a depositXX/withdrawXX/harvest)\n    // Calculate the total gain/loss\n    int256 totalGain = int256(_nav) - int256(_lastNAV);\n    // If there is no gain/loss return the current price\n    if (totalGain == 0) {\n      return (_tranchePrice(_tranche), 0);\n    }\n\n    // Remove performance fee for gains\n    if (totalGain > 0) {\n      totalGain -= totalGain * int256(fee) / int256(FULL_ALLOC);\n    }\n\n    address _AATranche = AATranche;\n    address _BBTranche = BBTranche;\n    bool _isAATranche = _tranche == _AATranche;\n    // Get the supply of the other tranche and\n    // if it's 0 then give all gain to the current `_tranche` holders\n    if (IdleCDOTranche(_isAATranche ? _BBTranche : _AATranche).totalSupply() == 0) {\n      _totalTrancheGain = totalGain;\n    } else {\n      // if we gained something or the loss is between 0 and lossToleranceBps then we socialize the gain/loss\n      if (totalGain > 0) {\n        // Split the net gain, according to _trancheAPRSplitRatio, with precision loss favoring the AA tranche.\n        int256 totalBBGain = totalGain * int256(FULL_ALLOC - _trancheAPRSplitRatio) / int256(FULL_ALLOC);\n        // The new NAV for the tranche is old NAV + total gain for the tranche\n        _totalTrancheGain = _isAATranche ? (totalGain - totalBBGain) : totalBBGain;\n      } else if (uint256(-totalGain) <= (lossToleranceBps * _lastNAV) / FULL_ALLOC) {\n        // Split the loss, according to TVL ratio instead of _trancheAPRSplitRatio (loss socialized between all tranches)\n        uint256 _lastNAVBB = lastNAVBB;\n        int256 totalBBLoss = totalGain * int256(_lastNAVBB) / int256(lastNAVAA + _lastNAVBB);\n        // The new NAV for the tranche is old NAV - loss for the tranche\n        _totalTrancheGain = _isAATranche ? (totalGain - totalBBLoss) : totalBBLoss;\n      } else { // totalGain is negative here\n        // Redirect the whole loss (which should be < maxDecreaseDefault) to junior holders\n        int256 _juniorTVL = int256(_isAATranche ? _lastNAV - _lastTrancheNAV : _lastTrancheNAV);\n        int256 _newJuniorTVL = _juniorTVL + totalGain; \n        // if junior holders have enough TVL to cover\n        if (_newJuniorTVL > 0) {\n          // then juniors get all loss (totalGain) and senior gets 0 loss\n          _totalTrancheGain = _isAATranche ? int256(0) : totalGain;\n        } else {\n          // otherwise all loss minus junior tvl to senior\n          if (!_isAATranche) {\n            // juniors have no more claims, price is set to 0, gain is set to -juniorTVL\n            return (0, -_juniorTVL);\n          }\n          // seniors get the loss - old junior TVL\n          _totalTrancheGain = _newJuniorTVL;\n        }\n      }\n    }\n    // Split the new NAV (_lastTrancheNAV + _totalTrancheGain) per tranche token\n    _virtualPrice = uint256(int256(_lastTrancheNAV) + _totalTrancheGain) * ONE_TRANCHE_TOKEN / trancheSupply;\n  }\n\n  /// @notice mint tranche tokens and updates tranche last NAV\n  /// @param _amount, in underlyings, to convert in tranche tokens\n  /// @param _to receiver address of the newly minted tranche tokens\n  /// @param _tranche tranche address\n  /// @return _minted number of tranche tokens minted\n  function _mintShares(uint256 _amount, address _to, address _tranche) internal virtual returns (uint256 _minted) {\n    // calculate # of tranche token to mint based on current tranche price: _amount / tranchePrice\n    _minted = _amount * ONE_TRANCHE_TOKEN / _tranchePrice(_tranche);\n    IdleCDOTranche(_tranche).mint(_to, _minted);\n    // update NAV with the _amount of underlyings added\n    if (_tranche == AATranche) {\n      lastNAVAA += _amount;\n    } else {\n      lastNAVBB += _amount;\n    }\n  }\n\n  /// @notice convert fees (`unclaimedFees`) in AA tranche tokens\n  /// @dev this will be called only during harvests\n  function _depositFees() internal virtual {\n    uint256 _amount = unclaimedFees;\n    if (_amount != 0) {\n      // mint tranches tokens (always AA) to this contract\n      _mintShares(_amount, feeReceiver, AATranche);\n      // reset unclaimedFees counter\n      unclaimedFees = 0;\n      // update trancheAPRSplitRatio using instant balance\n      _updateSplitRatio(_getAARatio(true));\n    }\n  }\n\n  /// @notice It allows users to burn their tranche token and redeem their principal + interest back\n  /// @dev automatically reverts on lending provider default (_strategyPrice decreased).\n  /// @param _amount in tranche tokens\n  /// @param _tranche tranche address\n  /// @return toRedeem number of underlyings redeemed\n  function _withdraw(uint256 _amount, address _tranche) virtual internal nonReentrant returns (uint256 toRedeem) {\n    // check if a deposit is made in the same block from the same user\n    _checkSameTx();\n    // check if _strategyPrice decreased\n    _checkDefault();\n    // accrue interest to tranches and updates tranche prices\n    _updateAccounting();\n    // redeem all user balance if 0 is passed as _amount\n    if (_amount == 0) {\n      _amount = IERC20Detailed(_tranche).balanceOf(msg.sender);\n    }\n    require(_amount != 0, '0');\n    address _token = token;\n    // get current available unlent balance\n    uint256 balanceUnderlying = _contractTokenBalance(_token);\n    // Calculate the amount to redeem\n    toRedeem = _amount * _tranchePrice(_tranche) / ONE_TRANCHE_TOKEN;\n    uint256 _want = toRedeem;\n    if (toRedeem > balanceUnderlying) {\n      // if the unlent balance is not enough we try to redeem what's missing directly from the strategy\n      // and then add it to the current unlent balance\n      // NOTE: A difference of up to 100 wei due to rounding is tolerated\n      toRedeem = _liquidate(toRedeem - balanceUnderlying, revertIfTooLow) + balanceUnderlying;\n    }\n    // burn tranche token\n    IdleCDOTranche(_tranche).burn(msg.sender, _amount);\n\n    // update NAV with the _amount of underlyings removed\n    if (_tranche == AATranche) {\n      lastNAVAA -= _want;\n    } else {\n      lastNAVBB -= _want;\n    }\n\n    // update trancheAPRSplitRatio\n    _updateSplitRatio(_getAARatio(true));\n  \n    // send underlying to msg.sender. Keep this at the end of the function to avoid \n    // potential read only reentrancy on cdo variants that have hooks (eg with nfts)\n    IERC20Detailed(_token).safeTransfer(msg.sender, toRedeem);\n  }\n\n  /// @notice updates trancheAPRSplitRatio based on the current tranches TVL ratio between AA and BB\n  /// @dev the idea here is to limit the min and max APR that the senior tranche can get\n  function _updateSplitRatio(uint256 tvlAARatio) internal virtual {\n    uint256 _minSplit = minAprSplitAYS;\n    _minSplit = _minSplit == 0 ? AA_RATIO_LIM_DOWN : _minSplit;\n\n    if (isAYSActive) {\n      uint256 aux;\n      if (tvlAARatio >= AA_RATIO_LIM_UP) {\n        aux = tvlAARatio == FULL_ALLOC ? FULL_ALLOC : AA_RATIO_LIM_UP;\n      } else if (tvlAARatio > _minSplit) {\n        aux = tvlAARatio;\n      } else {\n        aux = _minSplit;\n      }\n      trancheAPRSplitRatio = aux * tvlAARatio / FULL_ALLOC;\n    }\n  }\n\n  /// @notice calculates the current AA tranches ratio\n  /// @dev it does count accrued interest not yet split since last\n  /// depositXX/withdrawXX/harvest only if _instant flag is true\n  /// @param _instant if true, it returns the current ratio without accrued interest\n  /// @return AA tranches ratio (in underlying value) considering all interest\n  function _getAARatio(bool _instant) internal view returns (uint256) {\n    function(address) internal view returns (uint256) _getNAV =\n      _instant ? _instantBalance : _virtualBalance;\n    uint256 AABal = _getNAV(AATranche);\n    uint256 contractVal = AABal + _getNAV(BBTranche);\n    if (contractVal == 0) {\n      return 0;\n    }\n    // Current AA tranche split ratio = AABal * FULL_ALLOC / (AABal + BBBal)\n    return AABal * FULL_ALLOC / contractVal;\n  }\n\n  /// @dev check if _strategyPrice is decreased more than X% with X configurable since last update \n  /// and updates last saved strategy price\n  function _checkDefault() virtual internal {\n    uint256 currPrice = _strategyPrice();\n    if (!skipDefaultCheck) {\n      // calculate if % of decrease of strategyPrice is within maxDecreaseDefault\n      require(lastStrategyPrice * (FULL_ALLOC - maxDecreaseDefault) / FULL_ALLOC <= currPrice, \"4\");\n    }\n    lastStrategyPrice = currPrice;\n  }\n\n  /// @return strategy price, in underlyings\n  function _strategyPrice() internal view returns (uint256) {\n    return IIdleCDOStrategy(strategy).price();\n  }\n\n  /// @dev this should liquidate at least _amount of `token` from the lending provider or revertIfNeeded\n  /// @param _amount in underlying tokens\n  /// @param _revertIfNeeded flag whether to revert or not if the redeemed amount is not enough\n  /// @return _redeemedTokens number of underlyings redeemed\n  function _liquidate(uint256 _amount, bool _revertIfNeeded) internal virtual returns (uint256 _redeemedTokens) {\n    _redeemedTokens = IIdleCDOStrategy(strategy).redeemUnderlying(_amount);\n    if (_revertIfNeeded) {\n      uint256 _tolerance = liquidationTolerance;\n      if (_tolerance == 0) {\n        _tolerance = 100;\n      }\n      // keep `_tolerance` wei as margin for rounding errors\n      require(_redeemedTokens + _tolerance >= _amount, '5');\n    }\n\n    if (_redeemedTokens > _amount) {\n      _redeemedTokens = _amount;\n    }\n  }\n\n  /// @notice method used to sell `_rewardToken` for `_token` on uniswap\n  /// @param _rewardToken address of the token to sell\n  /// @param _path to buy\n  /// @param _amount of `_rewardToken` to sell\n  /// @param _minAmount min amount of `_token` to buy\n  /// @return _amount of _rewardToken sold\n  /// @return _amount received for the sell\n  function _sellReward(address _rewardToken, bytes memory _path, uint256 _amount, uint256 _minAmount)\n    internal virtual\n    returns (uint256, uint256) {\n    // If 0 is passed as sell amount, we get the whole contract balance\n    if (_amount == 0) {\n      _amount = _contractTokenBalance(_rewardToken);\n    }\n    if (_amount == 0) {\n      return (0, 0);\n    }\n  \n    if (_path.length != 0) {\n      // Uni v3 swap\n      ISwapRouter _swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n      IERC20Detailed(_rewardToken).safeIncreaseAllowance(address(_swapRouter), _amount);\n      // multi hop swap params\n      ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n        path: _path,\n        recipient: address(this),\n        deadline: block.timestamp + 100,\n        amountIn: _amount,\n        amountOutMinimum: _minAmount\n      });\n      // do the swap and return the amount swapped and the amount received\n      return (_amount, _swapRouter.exactInput(params));\n    } else {\n      // Uni v2 swap\n      IUniswapV2Router02 _uniRouter = uniswapRouterV2;\n      // approve the uniswap router to spend our reward\n      IERC20Detailed(_rewardToken).safeIncreaseAllowance(address(_uniRouter), _amount);\n      // do the trade with all `_rewardToken` in this contract\n      address[] memory _pathUniv2 = new address[](3);\n      _pathUniv2[0] = _rewardToken;\n      _pathUniv2[1] = weth;\n      _pathUniv2[2] = token;\n      uint256[] memory _amounts = _uniRouter.swapExactTokensForTokens(\n        _amount,\n        _minAmount,\n        _pathUniv2,\n        address(this),\n        block.timestamp + 100\n      );\n      // return the amount swapped and the amount received\n      return (_amounts[0], _amounts[_amounts.length - 1]);\n    }\n  }\n\n  /// @notice method used to sell all sellable rewards for `_token` on uniswap\n  /// @param _strategy IIdleCDOStrategy stategy instance\n  /// @param _sellAmounts array with amounts of rewards to sell\n  /// @param _minAmount array with amounts of _token buy for each reward sold. (should have the same length as _sellAmounts)\n  /// @param _skipReward array of flags for skipping the market sell of specific rewards (should have the same length as _sellAmounts)\n  /// @return _soldAmounts array with amounts of rewards actually sold\n  /// @return _swappedAmounts array with amounts of _token actually bought\n  /// @return _totSold total rewards sold in `_token`\n  function _sellAllRewards(IIdleCDOStrategy _strategy, uint256[] memory _sellAmounts, uint256[] memory _minAmount, bool[] memory _skipReward, bytes memory _extraData)\n    internal virtual\n    returns (uint256[] memory _soldAmounts, uint256[] memory _swappedAmounts, uint256 _totSold) {\n    // Fetch state variables once to save gas\n    // get all rewards addresses\n    address[] memory _rewards = _strategy.getRewardTokens();\n    address _rewardToken;\n    bytes[] memory _paths = new bytes[](_rewards.length);\n    if (_extraData.length > 0) {\n      _paths = abi.decode(_extraData, (bytes[]));\n    }\n    uint256 rewardsLen = _rewards.length;\n    // Initialize the return array, containing the amounts received after swapping reward tokens\n    _soldAmounts = new uint256[](rewardsLen);\n    _swappedAmounts = new uint256[](rewardsLen);\n    // loop through all reward tokens\n    for (uint256 i; i < rewardsLen; ++i) {\n      _rewardToken = _rewards[i];\n      // check if it should be sold or not\n      if (_skipReward[i]) { continue; }\n      // do not sell stkAAVE but only AAVE if present\n      if (_rewardToken == stkAave) {\n        _rewardToken = AAVE;\n      }\n      // Market sell _rewardToken in this contract for _token\n      (_soldAmounts[i], _swappedAmounts[i]) = _sellReward(_rewardToken, _paths[i], _sellAmounts[i], _minAmount[i]);\n      _totSold += _swappedAmounts[i];\n    }\n  }\n\n  /// @param _tranche tranche address\n  /// @return last saved tranche price, in underlyings\n  function _tranchePrice(address _tranche) internal view returns (uint256) {\n    if (IdleCDOTranche(_tranche).totalSupply() == 0) {\n      return oneToken;\n    }\n    return _tranche == AATranche ? priceAA : priceBB;\n  }\n\n  /// @notice returns the current apr for a tranche based on trancheAPRSplitRatio and the provided AA ratio\n  /// @dev the apr for a tranche can be higher than the strategy apr\n  /// @param _tranche tranche token address\n  /// @param _AATrancheSplitRatio AA split ratio used for calculations\n  /// @return apr for the specific tranche\n  function _getApr(address _tranche, uint256 _AATrancheSplitRatio) internal view returns (uint256) {\n    uint256 stratApr = IIdleCDOStrategy(strategy).getApr();\n    uint256 _trancheAPRSplitRatio = trancheAPRSplitRatio;\n    bool isAATranche = _tranche == AATranche;\n    if (_AATrancheSplitRatio == 0) {\n      // if there are no AA tranches, apr for AA is 0 (all apr to BB and it will be equal to stratApr)\n      return isAATranche ? 0 : stratApr;\n    }\n    return isAATranche ?\n      // AA apr is: stratApr * AAaprSplitRatio / AASplitRatio\n      stratApr * _trancheAPRSplitRatio / _AATrancheSplitRatio :\n      // BB apr is: stratApr * BBaprSplitRatio / BBSplitRatio -> where\n      // BBaprSplitRatio is: (FULL_ALLOC - _trancheAPRSplitRatio) and\n      // BBSplitRatio is: (FULL_ALLOC - _AATrancheSplitRatio)\n      stratApr * (FULL_ALLOC - _trancheAPRSplitRatio) / (FULL_ALLOC - _AATrancheSplitRatio);\n  }\n\n  /// @return _locked amount of harvested rewards that are still not available to be redeemed\n  function _lockedRewards() internal view virtual returns (uint256 _locked) {\n    uint256 _releaseBlocksPeriod = releaseBlocksPeriod;\n    uint256 _blocksSinceLastHarvest = block.number - latestHarvestBlock;\n    uint256 _harvestedRewards = harvestedRewards;\n\n    // NOTE: _harvestedRewards is never set to 0, but rather to 1 to save some gas\n    if (_harvestedRewards > 1 && _blocksSinceLastHarvest < _releaseBlocksPeriod) {\n      // progressively release harvested rewards\n      _locked = _harvestedRewards * (_releaseBlocksPeriod - _blocksSinceLastHarvest) / _releaseBlocksPeriod;\n    }\n  }\n\n  // ###################\n  // Protected\n  // ###################\n\n  /// @notice This method is used to lend user funds in the lending provider through an IIdleCDOStrategy\n  /// The method:\n  /// - redeems rewards (if any) from the lending provider\n  /// - converts the rewards in underlyings through uniswap v2 or v3\n  /// - calls _updateAccounting to update the accounting of the system with the new underlyings received\n  /// - it then convert fees in tranche tokens\n  /// - finally it deposits the (initial unlent balance + the underlyings get from uniswap - fees) in the\n  ///   lending provider through the IIdleCDOStrategy `deposit` call\n  /// The method will be called by an external, whitelisted, keeper bot which will call the method sistematically (eg once a day)\n  /// @dev can be called only by the rebalancer or the owner\n  /// @param _skipFlags array of flags, [0] = skip reward redemption, [1] = skip incentives update, [2] = skip fee deposit, [3] = skip all\n  /// @param _skipReward array of flags for skipping the market sell of specific rewards. Length should be equal to the `IIdleCDOStrategy(strategy).getRewardTokens()` array\n  /// @param _minAmount array of min amounts for uniswap trades. Lenght should be equal to the _skipReward array\n  /// @param _sellAmounts array of amounts (of reward tokens) to sell on uniswap. Lenght should be equal to the _minAmount array\n  /// if a sellAmount is 0 the whole contract balance for that token is swapped\n  /// @param _extraData bytes to be passed to the redeemRewards call\n  /// @return _res array of arrays with the following elements:\n  ///   [0] _soldAmounts array with amounts of rewards actually sold\n  ///   [1] _swappedAmounts array with amounts of _token actually bought\n  ///   [2] _redeemedRewards array with amounts of rewards redeemed\n  function harvest(\n    // _skipFlags[0] _skipRedeem,\n    // _skipFlags[1] _skipIncentivesUpdate, [DEPRECATED]\n    // _skipFlags[2] _skipFeeDeposit,\n    // _skipFlags[3] _skipRedeem && _skipIncentivesUpdate && _skipFeeDeposit,\n    bool[] calldata _skipFlags,\n    bool[] calldata _skipReward,\n    uint256[] calldata _minAmount,\n    uint256[] calldata _sellAmounts,\n    bytes[] calldata _extraData\n  ) public\n    virtual\n    returns (uint256[][] memory _res) {\n    _checkOnlyOwnerOrRebalancer();\n    // initalize the returned array (elements will be [_soldAmounts, _swappedAmounts, _redeemedRewards])\n    _res = new uint256[][](3);\n    // Fetch state variable once to save gas\n    IIdleCDOStrategy _strategy = IIdleCDOStrategy(strategy);\n    // Check whether to redeem rewards from strategy or not\n    if (!_skipFlags[3]) {\n      uint256 _totSold;\n\n      if (!_skipFlags[0]) {\n        // Redeem all rewards associated with the strategy\n        _res[2] = _strategy.redeemRewards(_extraData[0]);\n        // Sell rewards\n        (_res[0], _res[1], _totSold) = _sellAllRewards(_strategy, _sellAmounts, _minAmount, _skipReward, _extraData[1]);\n      }\n      // update last saved harvest block number\n      latestHarvestBlock = block.number;\n      // update harvested rewards value (avoid setting it to 0 to save some gas)\n      harvestedRewards = _totSold == 0 ? 1 : _totSold;\n\n      // split converted rewards if any and update tranche prices\n      // NOTE: harvested rewards won't be counted directly but released over time\n      _updateAccounting();\n\n      if (!_skipFlags[2]) {\n        // Get fees in the form of totalSupply diluition\n        _depositFees();\n      }\n    }\n\n    // Deposit the remaining balance in the lending provider and \n    // keep some unlent balance for cheap redeems and as reserve of last resort\n    uint256 underlyingBal = _contractTokenBalance(token);\n    uint256 idealUnlent = getContractValue() * unlentPerc / FULL_ALLOC;\n    if (underlyingBal > idealUnlent) {\n      // Put unlent balance at work in the lending provider\n      _strategy.deposit(underlyingBal - idealUnlent);\n    }\n  }\n\n  /// @notice method used to redeem underlyings from the lending provider\n  /// @dev can be called only by the rebalancer or the owner\n  /// @param _amount in underlyings to liquidate from lending provider\n  /// @param _revertIfNeeded flag to revert if amount liquidated is too low\n  /// @return liquidated amount in underlyings\n  function liquidate(uint256 _amount, bool _revertIfNeeded) external virtual returns (uint256) {\n    _checkOnlyOwnerOrRebalancer();\n    return _liquidate(_amount, _revertIfNeeded);\n  }\n\n  // ###################\n  // onlyOwner\n  // ###################\n\n  /// @dev automatically reverts if strategyPrice decreased more than `_maxDecreaseDefault`\n  /// @param _maxDecreaseDefault max value, in % where `100000` = 100%, of accettable price decrease for the strategy\n  function setMaxDecreaseDefault(uint256 _maxDecreaseDefault) external virtual {\n    _checkOnlyOwner();\n    require(_maxDecreaseDefault < FULL_ALLOC, '7');\n    maxDecreaseDefault = _maxDecreaseDefault;\n  }\n\n  /// @param _active flag to allow Adaptive Yield Split\n  function setIsAYSActive(bool _active) external {\n    _checkOnlyOwner();\n    isAYSActive = _active;\n  }\n\n  /// @param _allowed flag to allow AA withdraws\n  function setAllowAAWithdraw(bool _allowed) external virtual {\n    _checkOnlyOwner();\n    allowAAWithdraw = _allowed;\n  }\n\n  /// @param _allowed flag to allow BB withdraws\n  function setAllowBBWithdraw(bool _allowed) external virtual {\n    _checkOnlyOwner();\n    allowBBWithdraw = _allowed;\n  }\n\n  /// @param _allowed flag to enable the 'default' check (whether _strategyPrice decreased or not)\n  function setSkipDefaultCheck(bool _allowed) external virtual {\n    _checkOnlyOwner();\n    skipDefaultCheck = _allowed;\n  }\n\n  /// @param _allowed flag to enable the check if redeemed amount during liquidations is enough\n  function setRevertIfTooLow(bool _allowed) external virtual {\n    _checkOnlyOwner();\n    revertIfTooLow = _allowed;\n  }\n\n  /// @param _rebalancer new rebalancer address\n  function setRebalancer(address _rebalancer) external {\n    _checkOnlyOwner();\n    require((rebalancer = _rebalancer) != address(0), '0');\n  }\n\n  /// @param _feeReceiver new fee receiver address\n  function setFeeReceiver(address _feeReceiver) external {\n    _checkOnlyOwner();\n    require((feeReceiver = _feeReceiver) != address(0), '0');\n  }\n\n  /// @param _guardian new guardian (pauser) address\n  function setGuardian(address _guardian) external {\n    _checkOnlyOwner();\n    require((guardian = _guardian) != address(0), '0');\n  }\n\n  /// @param _diff max liquidation diff tolerance in underlyings\n  function setLiquidationTolerance(uint256 _diff) external virtual {\n    _checkOnlyOwner();\n    liquidationTolerance = _diff;\n  }\n\n  /// @param _val stkIDLE per underlying required for deposits\n  function setStkIDLEPerUnderlying(uint256 _val) external virtual {\n    _checkOnlyOwner();\n    stkIDLEPerUnderlying = _val;\n  }\n\n  /// @param _aprSplit min apr split for AA, considering FULL_ALLOC = 100%\n  function setMinAprSplitAYS(uint256 _aprSplit) external {\n    _checkOnlyOwner();\n    require((minAprSplitAYS = _aprSplit) <= FULL_ALLOC, '7');\n    minAprSplitAYS = _aprSplit;\n  }\n\n  /// @param _fee new fee\n  function setFee(uint256 _fee) external {\n    _checkOnlyOwner();\n    require((fee = _fee) <= MAX_FEE, '7');\n  }\n\n  /// @param _unlentPerc new unlent percentage\n  function setUnlentPerc(uint256 _unlentPerc) external virtual {\n    _checkOnlyOwner();\n    require((unlentPerc = _unlentPerc) <= FULL_ALLOC, '7');\n  }\n\n  /// @notice set new release block period. WARN: this should be called only when there \n  /// are no active rewards being unlocked\n  /// @param _releaseBlocksPeriod new # of blocks after an harvest during which\n  /// harvested rewards gets progressively redistriburted to users\n  function setReleaseBlocksPeriod(uint256 _releaseBlocksPeriod) external virtual {\n    _checkOnlyOwner();\n    releaseBlocksPeriod = _releaseBlocksPeriod;\n  }\n\n  /// @param _trancheAPRSplitRatio new apr split ratio\n  function setTrancheAPRSplitRatio(uint256 _trancheAPRSplitRatio) external virtual {\n    _checkOnlyOwner();\n    require((trancheAPRSplitRatio = _trancheAPRSplitRatio) <= FULL_ALLOC, '7');\n  }\n\n  /// @param _diffBps tolerance in % (FULL_ALLOC = 100%) for socializing small losses \n  function setLossToleranceBps(uint256 _diffBps) external {\n    _checkOnlyOwner();\n    lossToleranceBps = _diffBps;\n  }\n\n  /// @dev toggle stkIDLE requirement for tranche\n  /// @param _tranche address\n  function toggleStkIDLEForTranche(address _tranche) external virtual {\n    _checkOnlyOwner();\n    address aa = AATranche;\n    require(_tranche == BBTranche || _tranche == aa, '9');\n    if (_tranche == aa) {\n      AAStaking = AAStaking == address(0) ? address(1) : address(0);\n      return;\n    }\n\n    BBStaking = BBStaking == address(0) ? address(1) : address(0);\n  }\n\n  /// @notice this method updates the accounting of the contract and effectively splits the yield/loss between the\n  /// AA and BB tranches. This can be called at any time as is called automatically on each deposit/redeem. It's here\n  /// just to be called when a default happened, as deposits/redeems are paused, but we need to update\n  /// the loss for junior holders\n  function updateAccounting() external {\n    _checkOnlyOwnerOrGuardian();\n    skipDefaultCheck = true;\n    _updateAccounting();\n    // _updateAccounting can set `skipDefaultCheck` to true in case of default\n    // but this can be manually be reset to true if needed\n    skipDefaultCheck = false;\n  }\n\n  /// @notice pause deposits and redeems for all classes of tranches\n  /// @dev can be called by both the owner and the guardian\n  function emergencyShutdown() external {\n    _checkOnlyOwnerOrGuardian();\n    _emergencyShutdown(false);\n  }\n\n  function _emergencyShutdown(bool isAAWithdrawAllowed) internal virtual {\n    // prevent deposits\n    if (!paused()) {\n      _pause();\n    }\n    // prevent withdraws\n    allowAAWithdraw = isAAWithdrawAllowed;\n    allowBBWithdraw = false;\n    // Allow deposits/withdraws (once selectively re-enabled, eg for AA holders)\n    // without checking for lending protocol default\n    skipDefaultCheck = true;\n    revertIfTooLow = true;\n  }\n\n  /// @notice allow deposits and redeems for all classes of tranches\n  /// @dev can be called by the owner only\n  function restoreOperations() external virtual {\n    _checkOnlyOwner();\n    // restore deposits\n    if (paused()) {\n      _unpause();\n    }\n    // restore withdraws\n    allowAAWithdraw = true;\n    allowBBWithdraw = true;\n    // Allow deposits/withdraws but checks for lending protocol default\n    skipDefaultCheck = false;\n    revertIfTooLow = true;\n  }\n\n  /// @notice Pauses deposits\n  /// @dev can be called by both the owner and the guardian\n  function pause() external  {\n    _checkOnlyOwnerOrGuardian();\n    _pause();\n  }\n\n  /// @notice Unpauses deposits\n  /// @dev can be called by both the owner and the guardian\n  function unpause() external {\n    _checkOnlyOwnerOrGuardian();\n    _unpause();\n  }\n\n  // ###################\n  // Helpers\n  // ###################\n\n  /// @dev Check that the msg.sender is the either the owner or the guardian\n  function _checkOnlyOwnerOrGuardian() internal view {\n    require(msg.sender == guardian || msg.sender == owner(), \"6\");\n  }\n\n  /// @dev Check that the msg.sender is the either the owner or the rebalancer\n  function _checkOnlyOwnerOrRebalancer() internal view {\n    require(msg.sender == rebalancer || msg.sender == owner(), \"6\");\n  }\n\n  /// @notice returns the current balance of this contract for a specific token\n  /// @param _token token address\n  /// @return balance of `_token` for this contract\n  function _contractTokenBalance(address _token) internal view returns (uint256) {\n    return IERC20Detailed(_token).balanceOf(address(this));\n  }\n\n  /// @dev Set allowance for _token to unlimited for _spender\n  /// @param _token token address\n  /// @param _spender spender address\n  function _allowUnlimitedSpend(address _token, address _spender) internal {\n    IERC20Detailed(_token).safeIncreaseAllowance(_spender, type(uint256).max);\n  }\n\n  /// @dev Set last caller and block.number hash. This should be called at the beginning of the first function to protect\n  function _updateCallerBlock() internal {\n    _lastCallerBlock = keccak256(abi.encodePacked(tx.origin, block.number));\n  }\n\n  /// @dev Check that the second function is not called in the same tx from the same tx.origin\n  function _checkSameTx() internal view {\n    require(keccak256(abi.encodePacked(tx.origin, block.number)) != _lastCallerBlock, \"8\");\n  }\n\n  /// @notice concat 2 strings in a single one\n  /// @param a first string\n  /// @param b second string\n  /// @return new string with a and b concatenated\n  function _concat(string memory a, string memory b) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b));\n  }\n}"
    }
}