{
    "vfp_id": "vfp_00328",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Security Council proposals will pass at 50% member quorum threshold",
            "description": "The members.quorum setting in RocketDAOProtocolSettingsSecurity is incorrectly initialized to 0.5 ether (50%) instead of 0.51 ether (51%) as intended. Despite guardrails requiring values between 51% and 75%, the default initialization allows proposals to pass at 50%. The root cause is a typo in the initialization value. An attacker or accidental vote could exploit this to pass proposals with less consensus than expected. The impact is reduced security margin for Security Council decisions, potentially allowing premature execution of critical actions.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L16",
                "RocketDAOProtocolSettingsSecurity.sol#L47-L49"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "A single compromised Security Council member can veto an upgrade proposal",
            "description": "The upgradeveto.quorum is set to 0.33 ether (1 out of 3 members), meaning a single compromised key can block any protocol upgrade. Given that SC members are team-controlled and replacement requires pDAO governance (which may take weeks), this creates a critical single point of failure. The root cause is insufficient quorum and small council size. An attacker with access to one SC key could exploit this to indefinitely block emergency upgrades. The impact includes prolonged exposure to known vulnerabilities and potential protocol freeze during attacks.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L21"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Upgrade delay of 7 days may be insufficient given the current validator exit queue wait times",
            "description": "The upgrade.delay is set to 7 days, but current validator exit queues can take up to ~15 days. This means users may not have enough time to exit safely before a potentially harmful upgrade is executed. The root cause is outdated parameter calibration based on historical assumptions. An attacker or malicious proposal could exploit this by timing upgrades to execute before users can exit. The impact is reduced user safety and potential loss of funds due to forced participation in risky upgrades.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L22"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Setting network.submit.prices.enabled is incorrectly implemented as SC changeable parameter without delay",
            "description": "According to RPIP-33, network.submit.prices.enabled should not be modifiable by the Security Council without delay (no * marker), but it is implemented as such. Conversely, network.submit.rewards.enabled has the * marker but is not enabled for SC changes. This inconsistency between specification and implementation could lead to confusion or unintended access control. The root cause is a mismatch in documentation and code. An attacker could exploit governance expectations to argue for or against change legitimacy. The impact is governance ambiguity and potential misconfiguration.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L29"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAOProtocolSettingsSecurity.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../../../interface/RocketStorageInterface.sol\";\nimport {RocketDAOProtocolSettings} from \"./RocketDAOProtocolSettings.sol\";\nimport {RocketDAOProtocolSettingsSecurityInterface} from \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsSecurityInterface.sol\";\n\n/// @notice Protocol parameters relating to the security council\ncontract RocketDAOProtocolSettingsSecurity is RocketDAOProtocolSettings, RocketDAOProtocolSettingsSecurityInterface {\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, \"security\") {\n        version = 2;\n        // Initialise settings on deployment\n        if (!rocketStorage.getDeployedStatus()) {\n            // Set defaults\n            _setSettingUint(\"members.quorum\", 0.5 ether);        // Member quorum threshold that must be met for proposals to pass (51%)\n            _setSettingUint(\"members.leave.time\", 4 weeks);      // How long a member must give notice for before manually leaving the security council\n            _setSettingUint(\"proposal.vote.time\", 2 weeks);      // How long a proposal can be voted on\n            _setSettingUint(\"proposal.execute.time\", 4 weeks);   // How long a proposal can be executed after its voting period is finished\n            _setSettingUint(\"proposal.action.time\", 4 weeks);    // Certain proposals require a secondary action to be run after the proposal is successful (joining, leaving etc). This is how long until that action expires\n            _setSettingUint(\"upgradeveto.quorum\", 0.33 ether);   // RPIP-60: Member quorum threshold to veto a protocol upgrade (33%)\n            _setSettingUint(\"upgrade.delay\", 7 days);            // RPIP-60: Amount of time after an upgrade proposal passes that the security has to veto it\n            // Default permissions for security council\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"deposit\", \"deposit.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"deposit\", \"deposit.assign.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"minipool\", \"minipool.submit.withdrawable.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"minipool\", \"minipool.bond.reduction.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"network\", \"network.submit.balances.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"network\", \"network.submit.prices.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"node\", \"node.registration.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"node\", \"node.smoothing.pool.registration.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"node\", \"node.deposit.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"node\", \"node.vacant.minipools.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"auction\", \"auction.lot.create.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"auction\", \"auction.lot.bidding.enabled\")), true);\n            setBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", \"network\", \"network.node.commission.share.security.council.adder\")), true);\n            // Set deploy flag\n            setBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")), true);\n        }\n    }\n\n    /// @dev Overrides inherited setting method with extra sanity checks for this contract\n    function setSettingUint(string memory _settingPath, uint256 _value) override public onlyDAOProtocolProposal {\n        // Some safety guards for certain settings\n        if(getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            bytes32 settingKey = keccak256(abi.encodePacked(_settingPath));\n            if(settingKey == keccak256(abi.encodePacked(\"members.quorum\"))) {\n                // >= 51% & < 75% (RPIP-33)\n                require(_value >= 0.51 ether && _value <= 0.75 ether, \"Quorum setting must be >= 51% & <= 75%\");\n            } else if(settingKey == keccak256(abi.encodePacked(\"members.leave.time\"))) {\n                // < 14 days (RPIP-33)\n                require(_value < 14 days, \"Value must be < 14 days\");\n            } else if(settingKey == keccak256(abi.encodePacked(\"proposal.vote.time\"))) {\n                // >= 1 day (RPIP-33)\n                require(_value >= 1 days, \"Value must be >= 1 day\");\n            } else if(settingKey == keccak256(abi.encodePacked(\"proposal.execute.time\"))) {\n                // >= 1 day (RPIP-33)\n                require(_value >= 1 days, \"Value must be >= 1 day\");\n            } else if(settingKey == keccak256(abi.encodePacked(\"proposal.action.time\"))) {\n                // >= 1 day (RPIP-33)\n                require(_value >= 1 days, \"Value must be >= 1 day\");\n            }\n        }\n        // Update setting now\n        _setSettingUint(_settingPath, _value);\n    }\n\n    /// @dev Sets a namespaced uint value skipping any guardrails\n    function _setSettingUint(string memory _settingPath, uint256 _value) internal {\n        setUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    /// @notice The member proposal quorum threshold for this DAO\n    function getQuorum() override external view returns (uint256) {\n        return getSettingUint(\"members.quorum\");\n    }\n\n    /// @notice How long a member must give notice before leaving\n    function getLeaveTime() override external view returns (uint256) {\n        return getSettingUint(\"members.leave.time\");\n    }\n\n    /// @notice How long a proposal can be voted on\n    function getVoteTime() override external view returns (uint256) {\n        return getSettingUint(\"proposal.vote.time\");\n    }\n\n    /// @notice How long a proposal can be executed after its voting period is finished\n    function getExecuteTime() override external view returns (uint256) {\n        return getSettingUint(\"proposal.execute.time\");\n    }\n\n    /// @notice Certain proposals require a secondary action to be run after the proposal is successful (joining, leaving etc). This is how long until that action expires\n    function getActionTime() override external view returns (uint256) {\n        return getSettingUint(\"proposal.action.time\");\n    }\n\n    /// @notice The quorum required by the security council to veto an upgrade\n    function getUpgradeVetoQuorum() override external view returns (uint256) {\n        return getSettingUint(\"upgradeveto.quorum\");\n    }\n\n    /// @notice The amount of time that must be waited after an upgrade before executing\n    function getUpgradeDelay() override external view returns (uint256) {\n        return getSettingUint(\"upgrade.delay\");\n    }\n}\n"
    }
}