{
    "vfp_id": "vfp_00328",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Node Operator can perpetually lock a third-party depositor funds",
            "description": "A node operator can prevent third-party depositors from withdrawing their credit, effectively locking their funds indefinitely.\n\nThe root cause is access control in the withdrawCredit() function, which is restricted to onlyRegisteredNode(msg.sender), meaning only the node operator can initiate withdrawal. While third-party depositors can deposit ETH via depositEthFor(), they cannot reclaim their credit if the node operator refuses to call withdrawCredit().\n\nAn attacker (malicious or compromised node operator) can accept large deposits from a third party (e.g., a treasury), allow the ETH to be converted into credit via bonding, and then refuse to withdraw it. This breaks the expectation that depositors retain control over their funds.\n\nThe impact is permanent loss of funds for third-party depositors, particularly concerning for large institutional deposits, undermining trust in the protocol's custodial model.\n",
            "severity": "Medium",
            "location": [
                "RocketDepositPool.sol::depositEthFor#565",
                "RocketNodeDeposit.sol::withdrawCredit#107-118"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "getQueueTop() returns an incorrect validator",
            "description": "The getQueueTop() function uses an incorrect condition (queueIndex % (expressQueueRate + 1) != 0) to determine express queue usage, while the correct logic in _assignMegapools() uses != expressQueueRate. This discrepancy causes getQueueTop() to return the wrong validator, potentially leading to unexpected behavior in client software relying on this function. The root cause is a logic error in the conditional expression. An attacker could exploit this to predict or manipulate assignment order. The impact is inconsistency between expected and actual validator assignment.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol#L383-L406",
                "RocketDepositPool.sol#L595-L618"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ],
                "4": [
                    "CWE-638"
                ]
            },
            "title": "Nodes can withdraw ETH or credits even if they have outstanding protocol debt",
            "description": "Node operators with outstanding protocol debt (from slashing, fines, or penalties) can still withdraw ETH or credited rETH via withdrawEth() or withdrawCredit(). These functions do not check for existing debt, allowing nodes to extract value despite owing funds to the protocol.\nThe cause is the lack of a debt check in the withdrawal functions. While RocketPool partially fixed this by restricting credit withdrawals, they left ETH withdrawals unchanged, citing operational workarounds.\nAn attacker could incur debt (e.g., via slashing) and then withdraw deposited ETH or credited rETH, effectively stealing funds from the deposit pool.\nThe impact is a loss of proportional funds from the user deposit pool, undermining the protocol's solvency and fairness, though the risk is mitigated by the fact that ETH withdrawals are from third-party deposits.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol#L565-L588",
                "RocketMegapoolDelegate.sol#L181",
                "RocketMegapoolDelegate.sol#L249",
                "RocketMegapoolDelegate.sol#L562-L564",
                "RocketMegapoolDelegate.sol#L617-L629",
                "RocketMegapoolDelegate.sol#L672-L681",
                "RocketNodeDeposit.sol#L123-L139"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect uint64 casts in RocketDepositPool.getQueueTop()",
            "description": "In RocketDepositPool.getQueueTop(), the function casts a 256-bit packed value using uint64, but the stored values (block numbers) are packed as uint128. This can lead to truncation and incorrect block number interpretation.\nThe cause is a type mismatch between the packing logic in setQueueMoved() (which uses uint128) and the unpacking logic in getQueueTop() (which uses uint64).\nAn attacker could manipulate queue behavior by causing incorrect block number reads, potentially affecting deposit prioritization or express queue logic.\nThe impact is incorrect state interpretation, leading to unexpected behavior in deposit processing, though it does not directly enable fund theft.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol#L637-L643",
                "RocketDepositPool.sol#L452-L454"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Missing onlyThisLatestContract modifier for functions in RocketDepositPool",
            "description": "Several functions in RocketDepositPool—requestFunds, exitQueue, applyCredit, withdrawCredit, reduceBond, and fundsReturned—lack the onlyThisLatestContract modifier. This means that if the contract is upgraded, old implementations could still be callable, potentially leading to state inconsistencies.\nThe root cause is the omission of a critical modifier that ensures only the latest contract version can execute state-changing functions.\nAn attacker could call deprecated functions on an old proxy implementation if the storage layout allows it, potentially manipulating state or causing reversion issues.\nThe impact is low risk because RocketPool noted that upgraded contracts revert on storage writes, but the lack of explicit protection increases attack surface and reduces clarity.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDepositPool.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketNetworkBalancesInterface} from \"../../interface/network/RocketNetworkBalancesInterface.sol\";\nimport {AddressQueueStorageInterface} from \"../../interface/util/AddressQueueStorageInterface.sol\";\nimport {LinkedListStorageInterface} from \"../../interface/util/LinkedListStorageInterface.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketDAOProtocolSettingsDepositInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport {RocketDAOProtocolSettingsMinipoolInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport {RocketDAOProtocolSettingsNetworkInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport {RocketDepositPoolInterface} from \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport {RocketMegapoolDelegateInterface} from \"../../interface/megapool/RocketMegapoolDelegateInterface.sol\";\nimport {RocketMegapoolInterface} from \"../../interface/megapool/RocketMegapoolInterface.sol\";\nimport {RocketMinipoolInterface} from \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport {RocketMinipoolQueueInterface} from \"../../interface/minipool/RocketMinipoolQueueInterface.sol\";\nimport {RocketNetworkSnapshotsInterface} from \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\nimport {RocketNodeManagerInterface} from \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketTokenRETHInterface} from \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport {RocketVaultInterface} from \"../../interface/RocketVaultInterface.sol\";\nimport {RocketVaultWithdrawerInterface} from \"../../interface/RocketVaultWithdrawerInterface.sol\";\n\n/// @notice Accepts user deposits and mints rETH; handles assignment of deposited ETH to megapools\ncontract RocketDepositPool is RocketBase, RocketDepositPoolInterface, RocketVaultWithdrawerInterface {\n    // Constants\n    uint256 internal constant milliToWei = 10 ** 15;\n    bytes32 internal constant queueKeyVariable = keccak256(\"minipools.available.variable\");\n    bytes32 internal constant expressQueueNamespace = keccak256(\"deposit.queue.express\");\n    bytes32 internal constant standardQueueNamespace = keccak256(\"deposit.queue.standard\");\n    bytes32 internal constant queueMovedKey = keccak256(\"megapool.queue.moved\");\n    bytes32 internal constant nodeBalanceKey = \"deposit.pool.node.balance\"; // Note: this is not hashed due to bug in earlier contract\n    bytes32 internal constant requestedTotalKey = keccak256(\"deposit.pool.requested.total\");\n    bytes32 internal constant queueIndexKey = keccak256(\"megapool.queue.index\");\n\n    // Immutables\n    RocketVaultInterface immutable internal rocketVault;\n    RocketTokenRETHInterface immutable internal rocketTokenRETH;\n\n    // Events\n    event DepositReceived(address indexed from, uint256 amount, uint256 time);\n    event DepositRecycled(address indexed from, uint256 amount, uint256 time);\n    event DepositAssigned(address indexed minipool, uint256 amount, uint256 time);\n    event ExcessWithdrawn(address indexed to, uint256 amount, uint256 time);\n    event FundsRequested(address indexed receiver, uint256 validatorId, uint256 amount, bool expressQueue, uint256 time);\n    event FundsAssigned(address indexed receiver, uint256 amount, uint256 time);\n    event QueueExited(address indexed nodeAddress, uint256 time);\n    event CreditWithdrawn(address indexed receiver, uint256 amount, uint256 time);\n\n    // Structs\n    struct MinipoolAssignment {\n        address minipoolAddress;\n        uint256 etherAssigned;\n    }\n\n    // Modifiers\n    modifier onlyThisLatestContract() {\n        // Compiler can optimise out this keccak at compile time\n        require(address(this) == getAddress(keccak256(\"contract.addressrocketDepositPool\")), \"Invalid or outdated contract\");\n        _;\n    }\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 4;\n        // Pre-retrieve non-upgradable contract addresses to save gas\n        rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketTokenRETH = RocketTokenRETHInterface(getContractAddress(\"rocketTokenRETH\"));\n    }\n\n    /// @notice Returns the current deposit pool balance\n    function getBalance() override public view returns (uint256) {\n        return rocketVault.balanceOf(\"rocketDepositPool\");\n    }\n\n    /// @notice Returns the amount of ETH contributed to the deposit pool by node operators waiting in the queue\n    function getNodeBalance() override public view returns (uint256) {\n        return getUint(nodeBalanceKey);\n    }\n\n    /// @notice Returns the user owned portion of the deposit pool\n    /// @dev Negative indicates more ETH has been \"lent\" to the deposit pool by node operators in the queue\n    ///      than is available from user deposits\n    function getUserBalance() override public view returns (int256) {\n        return int256(getBalance()) - int256(getNodeBalance());\n    }\n\n    /// @notice Returns the credit balance for a given node operator\n    /// @param _nodeAddress Address of the node operator to query\n    function getNodeCreditBalance(address _nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", _nodeAddress)));\n    }\n\n    /// @notice Excess deposit pool balance (in excess of validator queue)\n    function getExcessBalance() override public view returns (uint256) {\n        // Get minipool queue capacity\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n        uint256 capacity = rocketMinipoolQueue.getEffectiveCapacity();\n        capacity += getUint(requestedTotalKey);\n        uint256 balance = getBalance();\n        // Calculate and return\n        if (capacity >= balance) {\n            return 0;\n        } else {\n            return balance - capacity;\n        }\n    }\n\n    /// @dev Callback required to receive ETH withdrawal from the vault\n    function receiveVaultWithdrawalETH() override external payable onlyThisLatestContract onlyLatestContract(\"rocketVault\", msg.sender) {}\n\n    /// @notice Deposits ETH into Rocket Pool and mints the corresponding amount of rETH to the caller\n    function deposit() override external payable onlyThisLatestContract {\n        // Check deposit settings\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        require(rocketDAOProtocolSettingsDeposit.getDepositEnabled(), \"Deposits into Rocket Pool are currently disabled\");\n        require(msg.value >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit(), \"The deposited amount is less than the minimum deposit size\");\n        /*\n            Check if deposit exceeds limit based on current deposit size and minipool queue capacity.\n\n            The deposit pool can, at most, accept a deposit that, after assignments, matches ETH to every minipool in\n            the queue and leaves the deposit pool with maximumDepositPoolSize ETH.\n\n            capacityNeeded = depositPoolBalance + msg.value\n            maxCapacity = maximumDepositPoolSize + queueEffectiveCapacity\n            assert(capacityNeeded <= maxCapacity)\n        */\n        uint256 capacityNeeded;\n        unchecked { // Infeasible overflow\n            capacityNeeded = getBalance() + msg.value;\n        }\n        uint256 maxDepositPoolSize = rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize();\n        if (capacityNeeded > maxDepositPoolSize) {\n            // Doing a conditional require() instead of a single one optimises for the common\n            // case where capacityNeeded fits in the deposit pool without looking at the queue\n            if (rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n                RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n                uint256 capacity = rocketMinipoolQueue.getEffectiveCapacity();\n                capacity += getUint(requestedTotalKey);\n                require(capacityNeeded <= maxDepositPoolSize + capacity, \"The deposit pool size after depositing exceeds the maximum size\");\n            } else {\n                revert(\"The deposit pool size after depositing exceeds the maximum size\");\n            }\n        }\n        // Calculate deposit fee\n        unchecked { // depositFee < msg.value\n            uint256 depositFee = msg.value * rocketDAOProtocolSettingsDeposit.getDepositFee() / calcBase;\n            uint256 depositNet = msg.value - depositFee;\n            // Mint rETH to user account\n            rocketTokenRETH.mint(depositNet, msg.sender);\n        }\n        // Emit deposit received event\n        emit DepositReceived(msg.sender, msg.value, block.timestamp);\n        // Process deposit\n        processDeposit();\n    }\n\n    /// @notice Returns the maximum amount that can be accepted into the deposit pool at this time in wei\n    function getMaximumDepositAmount() override external view returns (uint256) {\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // If deposits are enabled max deposit is 0\n        if (!rocketDAOProtocolSettingsDeposit.getDepositEnabled()) {\n            return 0;\n        }\n        uint256 depositPoolBalance = getBalance();\n        uint256 maxCapacity = rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize();\n        // When assignments are enabled, we can accept the max amount plus whatever space is available in the minipool queue\n        if (rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n            RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n            maxCapacity += rocketMinipoolQueue.getEffectiveCapacity();\n            maxCapacity += getUint(requestedTotalKey);\n        }\n        // Check we aren't already over\n        if (depositPoolBalance >= maxCapacity) {\n            return 0;\n        }\n        return maxCapacity - depositPoolBalance;\n    }\n\n    /// @notice Accepts ETH deposit from the node deposit contract (does not mint rETH)\n    /// @param _bondAmount The total node deposit amount including any credit balance used\n    function nodeDeposit(uint256 _bondAmount) override external payable onlyThisLatestContract onlyLatestContract(\"rocketNodeDeposit\", msg.sender) {\n        // Deposit ETH into the vault\n        if (msg.value > 0) {\n            rocketVault.depositEther{value: msg.value}();\n        }\n        // Increase recorded node balance\n        // Note: The difference between `_bondAmount` and `msg.value` is the amount of credit being used on this deposit.\n        //       That amount of credit is already accounted for in `deposit.pool.node.balance` and therefore we only\n        //       need to add `msg.value` to the node balance.\n        addUint(nodeBalanceKey, msg.value);\n    }\n\n    /// @notice Recycle a deposit from a dissolved validator\n    function recycleDissolvedDeposit() override external payable onlyThisLatestContract onlyRegisteredMinipoolOrMegapool(msg.sender) {\n        _recycleValue();\n    }\n\n    /// @notice Recycle excess ETH from the rETH token contract\n    function recycleExcessCollateral() override external payable onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {\n        _recycleValue();\n    }\n\n    /// @notice Recycle a liquidated RPL stake from a slashed minipool\n    function recycleLiquidatedStake() override external payable onlyThisLatestContract onlyLatestContract(\"rocketAuctionManager\", msg.sender) {\n        _recycleValue();\n    }\n\n    /// @dev Recycles msg.value into the deposit pool\n    function _recycleValue() internal {\n        // Recycle ETH\n        emit DepositRecycled(msg.sender, msg.value, block.timestamp);\n        processDeposit();\n    }\n\n    /// @dev Deposits incoming funds into rETH buffer and excess into vault then performs assignment\n    function processDeposit() internal {\n        // Direct deposit ETH to rETH until target collateral is reached\n        uint256 toReth = getRethCollateralShortfall();\n        if (toReth > msg.value) {\n            toReth = msg.value;\n        }\n        uint256 toVault = msg.value - toReth;\n        if (toReth > 0) {\n            rocketTokenRETH.depositExcess{value: toReth}();\n        }\n        if (toVault > 0) {\n            rocketVault.depositEther{value: toVault}();\n        }\n        // Assign deposits if enabled\n        _assignByDeposit();\n    }\n\n    /// @dev Returns the shortfall in ETH from the target collateral rate of rETH\n    function getRethCollateralShortfall() internal returns (uint256) {\n        // Load contracts\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        RocketNetworkBalancesInterface rocketNetworkBalances = RocketNetworkBalancesInterface(getContractAddress(\"rocketNetworkBalances\"));\n        // Calculate target collateral\n        uint256 targetCollateralRate = rocketDAOProtocolSettingsNetwork.getTargetRethCollateralRate();\n        uint256 rocketTokenRETHBalance = address(rocketTokenRETH).balance;\n        uint256 totalCollateral = rocketNetworkBalances.getTotalETHBalance();\n        uint256 targetCollateral = totalCollateral * targetCollateralRate / calcBase;\n        // Calculate shortfall\n        if (targetCollateral > rocketTokenRETHBalance) {\n            return targetCollateral - rocketTokenRETHBalance;\n        }\n        return 0;\n    }\n\n    /// @notice If deposit assignments are enabled, assigns up to specified number of minipools/megapools\n    /// @param _max Maximum number of minipools/megapools to assign\n    function maybeAssignDeposits(uint256 _max) override external onlyThisLatestContract {\n        require(_max > 0, \"Must assign at least 1\");\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        if (!rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n            return;\n        }\n        _assignDeposits(_max, rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @notice Assigns up to specified number of minipools or megapools, reverts if assignments are disabled\n    /// @param _max Maximum number of minipools/megapools to assign\n    function assignDeposits(uint256 _max) override external onlyThisLatestContract {\n        require(_max > 0, \"Must assign at least 1\");\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        require(rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled(), \"Deposit assignments are disabled\");\n        _assignDeposits(_max, rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @dev Assigns up to specified number of minipools or megapools\n    /// @param _max Maximum number of minipools/megapools to assign\n    function _assignDeposits(uint256 _max, RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) internal {\n        // Get contracts\n        AddressQueueStorageInterface addressQueueStorage = AddressQueueStorageInterface(getContractAddress(\"addressQueueStorage\"));\n        // Process minipool queue first\n        uint256 minipoolQueueLength = addressQueueStorage.getLength(queueKeyVariable);\n        if (minipoolQueueLength > 0) {\n            if (minipoolQueueLength >= _max) {\n                _assignMinipools(_max, _rocketDAOProtocolSettingsDeposit);\n                return;\n            } else {\n                unchecked { // _max < minipoolQueueLength\n                    _max -= minipoolQueueLength;\n                }\n                _assignMinipools(minipoolQueueLength, _rocketDAOProtocolSettingsDeposit);\n            }\n        }\n        // Assign remainder to megapools\n        if (_max > 0) {\n            _assignMegapools(_max, _rocketDAOProtocolSettingsDeposit);\n        }\n    }\n\n    /// @dev Assigns to minipools/megapools based on `msg.value`, does nothing if assignments are disabled\n    function _assignByDeposit() internal {\n        // Get contracts\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Check if assigning deposits is enabled\n        if (!rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n            return;\n        }\n        // Continue processing legacy minipool queue until empty\n        AddressQueueStorageInterface addressQueueStorage = AddressQueueStorageInterface(getContractAddress(\"addressQueueStorage\"));\n        if (addressQueueStorage.getLength(queueKeyVariable) > 0) {\n            RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n            _assignMinipoolsByDeposit(rocketMinipoolQueue, rocketDAOProtocolSettingsDeposit);\n        } else {\n            // Then assign megapools\n            _assignMegapoolsByDeposit(rocketDAOProtocolSettingsDeposit);\n        }\n    }\n\n    /// @dev Assigns a number of minipools based on `msg.value`\n    function _assignMinipoolsByDeposit(RocketMinipoolQueueInterface _rocketMinipoolQueue, RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) internal {\n        // Load contracts\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Calculate the number of minipools to assign\n        uint256 maxAssignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositAssignments();\n        uint256 variableDepositAmount = rocketDAOProtocolSettingsMinipool.getVariableDepositAmount();\n        uint256 scalingCount = msg.value / variableDepositAmount;\n        uint256 totalEthCount = getBalance() / variableDepositAmount;\n        uint256 assignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositSocialisedAssignments() + scalingCount;\n        if (assignments > totalEthCount) {\n            assignments = totalEthCount;\n        }\n        if (assignments > maxAssignments) {\n            assignments = maxAssignments;\n        }\n        if (assignments > 0) {\n            _assignMinipools(assignments, _rocketDAOProtocolSettingsDeposit);\n        }\n    }\n\n    /// @dev Assigns a number of megapools based on `msg.value`\n    function _assignMegapoolsByDeposit(RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) internal {\n        // Calculate the number of megapool validators to assign\n        uint256 maxAssignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositAssignments();\n        uint256 scalingCount = msg.value / 32 ether;\n        uint256 assignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositSocialisedAssignments() + scalingCount;\n        if (assignments > maxAssignments) {\n            assignments = maxAssignments;\n        }\n        if (assignments > 0) {\n            _assignMegapools(assignments, _rocketDAOProtocolSettingsDeposit);\n        }\n    }\n\n    /// @dev Assigns up to `_count` number of minipools\n    /// @param _count Maximum number of entries to assign\n    function _assignMinipools(uint256 _count, RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) internal {\n        // Get contracts\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Calculate max possible assignments based on current balance\n        uint256 variableDepositAmount = rocketDAOProtocolSettingsMinipool.getVariableDepositAmount();\n        uint256 maxPossible = getBalance() / variableDepositAmount;\n        if (maxPossible == 0) {\n            return;\n        }\n        if (_count > maxPossible) {\n            _count = maxPossible;\n        }\n        // Dequeue minipools\n        address[] memory minipools = rocketMinipoolQueue.dequeueMinipools(_count);\n        if (minipools.length > 0) {\n            // Withdraw ETH from vault\n            uint256 totalEther = minipools.length * variableDepositAmount;\n            rocketVault.withdrawEther(totalEther);\n            uint256 nodeBalanceUsed = 0;\n            // Loop over minipools and deposit the amount required to reach launch balance\n            for (uint256 i = 0; i < minipools.length; ++i) {\n                RocketMinipoolInterface minipool = RocketMinipoolInterface(minipools[i]);\n                // Assign deposit to minipool\n                minipool.deposit{value: variableDepositAmount}();\n                nodeBalanceUsed = nodeBalanceUsed + minipool.getNodeTopUpValue();\n                // Emit deposit assigned event\n                emit DepositAssigned(minipools[i], variableDepositAmount, block.timestamp);\n            }\n            // Decrease node balance\n            subUint(nodeBalanceKey, nodeBalanceUsed);\n        }\n    }\n\n    /// @dev Assigns up to `_count` number of megapools\n    /// @param _count Maximum number of entries to assign\n    function _assignMegapools(uint256 _count, RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) internal {\n        // Get contracts\n        LinkedListStorageInterface linkedListStorage = LinkedListStorageInterface(getContractAddress(\"linkedListStorage\"));\n        // Get required inputs\n        uint256 expressQueueLength = linkedListStorage.getLength(expressQueueNamespace);\n        uint256 standardQueueLength = linkedListStorage.getLength(standardQueueNamespace);\n        uint256 queueIndex = getUint(queueIndexKey);\n        uint256 expressQueueRate = _rocketDAOProtocolSettingsDeposit.getExpressQueueRate();\n        // Keep track of changes to applied at the end\n        uint256 nodeBalanceUsed = 0;\n        uint256 totalSent = 0;\n        uint256 vaultBalance = getBalance();\n        // Keep track of whether heads move\n        bool expressHeadMoved = false;\n        bool standardHeadMoved = false;\n        // Iterate over maximum of `_count` entries\n        for (uint256 i = 0; i < _count; i++) {\n            if (expressQueueLength == 0 && standardQueueLength == 0) {\n                break;\n            }\n            // Determine if we are assigning an express queue entry\n            bool express = queueIndex % (expressQueueRate + 1) != expressQueueRate;\n            if (express && expressQueueLength == 0) {\n                express = false;\n            }\n            if (!express && standardQueueLength == 0) {\n                express = true;\n            }\n            // Get the entry\n            bytes32 namespace = getQueueNamespace(express);\n            LinkedListStorageInterface.DepositQueueValue memory head = linkedListStorage.peekItem(namespace);\n            uint256 ethRequired = head.requestedValue * milliToWei;\n            // Check if we have enough available to assign\n            if (vaultBalance < ethRequired) {\n                break;\n            }\n            // Withdraw the funds from the vault\n            rocketVault.withdrawEther(ethRequired);\n            vaultBalance -= ethRequired;\n            // Assign funds and dequeue megapool\n            RocketMegapoolInterface(head.receiver).assignFunds{value: ethRequired}(head.validatorId);\n            emit FundsAssigned(head.receiver, ethRequired, block.timestamp);\n            linkedListStorage.dequeueItem(namespace);\n            // Account for node balance\n            unchecked { // Infeasible overflows and impossible underflows\n                nodeBalanceUsed += head.suppliedValue * milliToWei;\n                totalSent += ethRequired;\n            // Update counts for next iteration\n                queueIndex += 1;\n                if (express) {\n                    expressQueueLength -= 1;\n                    expressHeadMoved = true;\n                } else {\n                    standardQueueLength -= 1;\n                    standardHeadMoved = true;\n                }\n            }\n        }\n        // Store state changes\n        subUint(nodeBalanceKey, nodeBalanceUsed);\n        setUint(queueIndexKey, queueIndex);\n        subUint(requestedTotalKey, totalSent);\n        setQueueMoved(expressHeadMoved, standardHeadMoved);\n    }\n\n    /// @dev Stores block number when the queues moved\n    function setQueueMoved(bool expressHeadMoved, bool standardHeadMoved) internal {\n        uint256 packed = getUint(queueMovedKey);\n        uint128 express = expressHeadMoved ? uint128(block.number) : uint128(packed >> 0);\n        uint128 standard = standardHeadMoved ? uint128(block.number) : uint128(packed >> 128);\n        packed = express << 0;\n        packed |= uint256(standard) << 128;\n        setUint(queueMovedKey, packed);\n    }\n\n    /// @dev Withdraw excess deposit pool balance for rETH collateral\n    /// @param _amount The amount of excess ETH to withdraw\n    function withdrawExcessBalance(uint256 _amount) override external onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {\n        // Check amount\n        require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");\n        // Withdraw ETH from vault\n        rocketVault.withdrawEther(_amount);\n        // Transfer to rETH contract\n        rocketTokenRETH.depositExcess{value: _amount}();\n        // Emit excess withdrawn event\n        emit ExcessWithdrawn(msg.sender, _amount, block.timestamp);\n    }\n\n    /// @notice Requests funds from the deposit queue by a megapool, places the request in the relevant queue\n    /// @param _validatorId The megapool-managed ID of the validator requesting funds\n    /// @param _amount The amount of ETH requested by the node operator\n    /// @param _expressQueue Whether to consume an express ticket to be placed in the express queue\n    function requestFunds(uint256 _bondAmount, uint32 _validatorId, uint256 _amount, bool _expressQueue) external onlyRegisteredMegapool(msg.sender) {\n        // Validate arguments\n        require(_bondAmount % milliToWei == 0, \"Invalid supplied amount\");\n        require(_amount % milliToWei == 0, \"Invalid requested amount\");\n        // Use an express ticket if requested\n        address nodeAddress = RocketMegapoolInterface(msg.sender).getNodeAddress();\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        if (_expressQueue) {\n            rocketNodeManager.useExpressTicket(nodeAddress);\n        } else {\n            rocketNodeManager.provisionExpressTickets(nodeAddress);\n        }\n        // Enqueue megapool\n        bytes32 namespace = getQueueNamespace(_expressQueue);\n        LinkedListStorageInterface.DepositQueueValue memory value = LinkedListStorageInterface.DepositQueueValue({\n            receiver: msg.sender,                             // Megapool address\n            validatorId: _validatorId,                        // Incrementing id per validator in a megapool\n            suppliedValue: uint32(_bondAmount / milliToWei),  // NO bond amount\n            requestedValue: uint32(_amount / milliToWei)      // Amount being requested\n        });\n        LinkedListStorageInterface linkedListStorage = LinkedListStorageInterface(getContractAddress(\"linkedListStorage\"));\n        linkedListStorage.enqueueItem(namespace, value);\n        // Increase requested balance and node balance\n        addUint(requestedTotalKey, _amount);\n        // Check if head moved\n        if (_expressQueue) {\n            uint256 expressQueueLength = linkedListStorage.getLength(expressQueueNamespace);\n            if (expressQueueLength == 1) {\n                setQueueMoved(true, false);\n            }\n        } else {\n            uint256 standardQueueLength = linkedListStorage.getLength(standardQueueNamespace);\n            if (standardQueueLength == 1) {\n                setQueueMoved(false, true);\n            }\n        }\n        {\n            // Update collateral balances\n            _increaseETHBonded(nodeAddress, _bondAmount);\n            _increaseETHBorrowed(nodeAddress, _amount - _bondAmount);\n        }\n        // Emit event\n        emit FundsRequested(msg.sender, _validatorId, _amount, _expressQueue, block.timestamp);\n    }\n\n    /// @dev Called from a megapool to remove an entry in the validator queue and returns funds to node by credit mechanism\n    /// @param _validatorId Internal ID of the validator to be removed\n    /// @param _expressQueue Whether the entry is in the express queue or not\n    function exitQueue(address _nodeAddress, uint32 _validatorId, bool _expressQueue) external onlyRegisteredMegapool(msg.sender) {\n        LinkedListStorageInterface linkedListStorage = LinkedListStorageInterface(getContractAddress(\"linkedListStorage\"));\n        LinkedListStorageInterface.DepositQueueKey memory key = LinkedListStorageInterface.DepositQueueKey({\n            receiver: msg.sender,\n            validatorId: _validatorId\n        });\n        bytes32 namespace = getQueueNamespace(_expressQueue);\n        uint256 index = linkedListStorage.getIndexOf(namespace, key);\n        LinkedListStorageInterface.DepositQueueValue memory value = linkedListStorage.getItem(namespace, index);\n        bool isAtHead = linkedListStorage.getHeadIndex(namespace) == index;\n        linkedListStorage.removeItem(namespace, key);\n        // Perform balance accounting\n        subUint(requestedTotalKey, value.requestedValue * milliToWei);\n        if (_expressQueue) {\n            // Refund express ticket\n            RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n            rocketNodeManager.refundExpressTicket(_nodeAddress);\n            // Update head moved block\n            if (isAtHead) {\n                setQueueMoved(true, false);\n            }\n        } else {\n            // Update head moved block\n            if (isAtHead) {\n                setQueueMoved(false, true);\n            }\n        }\n        // Emit event\n        emit QueueExited(_nodeAddress, block.timestamp);\n    }\n\n    /// @dev Called from megapool to increase a node operator's credit\n    function applyCredit(address _nodeAddress, uint256 _amount) override external onlyRegisteredMegapool(msg.sender) {\n        // Add to node's credit for the amount supplied\n        addUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", _nodeAddress)), _amount);\n        addUint(nodeBalanceKey, _amount);\n    }\n\n    /// @notice Allows node operator to withdraw any ETH credit they have as rETH\n    /// @param _amount Amount in ETH to withdraw\n    function withdrawCredit(uint256 _amount) override external onlyRegisteredNode(msg.sender) {\n        // Check deposits are enabled\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        require(rocketDAOProtocolSettingsDeposit.getDepositEnabled(), \"Deposits into Rocket Pool are currently disabled\");\n        // Check node operator has sufficient credit\n        uint256 credit = getUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", msg.sender)));\n        require(credit >= _amount, \"Amount exceeds credit available\");\n        // Account for balance changes\n        subUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", msg.sender)), _amount);\n        subUint(nodeBalanceKey, _amount);\n        // Note: The funds are already stored in RocketVault under RocketDepositPool so no ETH transfer is required\n        // Get the node operator's withdrawal address\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        address nodeWithdrawalAddress = rocketNodeManager.getNodeWithdrawalAddress(msg.sender);\n        // Calculate deposit fee\n        unchecked { // depositFee < msg.value\n            uint256 depositFee = _amount * rocketDAOProtocolSettingsDeposit.getDepositFee() / calcBase;\n            uint256 depositNet = _amount - depositFee;\n            // Mint rETH to node\n            rocketTokenRETH.mint(depositNet, nodeWithdrawalAddress);\n        }\n        // Emit event\n        emit CreditWithdrawn(msg.sender, _amount, block.timestamp);\n    }\n\n    /// @notice Gets the receiver next to be assigned and whether it can be assigned immediately\n    /// @dev During the transition period from the legacy minipool queue, this will always return null address\n    /// @return receiver Address of the receiver of the next assignment or null address for an empty queue\n    /// @return assignmentPossible Whether there is enough funds in the pool to perform an assignment now\n    /// @return headMovedBlock The block at which the receiver entered the top of the queue\n    function getQueueTop() override external view returns (address receiver, bool assignmentPossible, uint256 headMovedBlock) {\n        // If legacy queue is still being processed, return null address\n        AddressQueueStorageInterface addressQueueStorage = AddressQueueStorageInterface(getContractAddress(\"addressQueueStorage\"));\n        if (addressQueueStorage.getLength(queueKeyVariable) > 0) {\n            return (address(0x0), false, 0);\n        }\n\n        // Get contracts\n        LinkedListStorageInterface linkedListStorage = LinkedListStorageInterface(getContractAddress(\"linkedListStorage\"));\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n\n        uint256 expressQueueLength = linkedListStorage.getLength(expressQueueNamespace);\n        uint256 standardQueueLength = linkedListStorage.getLength(standardQueueNamespace);\n\n        // If both queues are empty, return null address\n        if (expressQueueLength == 0 && standardQueueLength == 0) {\n            return (address(0x0), false, 0);\n        }\n\n        uint256 queueIndex = getUint(queueIndexKey);\n\n        uint256 expressQueueRate = rocketDAOProtocolSettingsDeposit.getExpressQueueRate();\n\n        bool express = queueIndex % (expressQueueRate + 1) != 0;\n        if (express && expressQueueLength == 0) {\n            express = false;\n        }\n\n        if (!express && standardQueueLength == 0) {\n            express = true;\n        }\n\n        // Check if enough value is in the deposit pool to assign the requested value\n        bytes32 namespace = getQueueNamespace(express);\n        LinkedListStorageInterface.DepositQueueValue memory head = linkedListStorage.peekItem(namespace);\n        assignmentPossible = rocketVault.balanceOf(\"rocketDepositPool\") >= head.requestedValue * milliToWei;\n\n        // Check assignments are enabled\n        if (!rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n            assignmentPossible = false;\n        }\n\n        // Retrieve the block at which the entry at the top of the queue got to that position\n        uint256 packed = getUint(queueMovedKey);\n        if (express) {\n            headMovedBlock = uint64(packed);\n        } else {\n            headMovedBlock = uint64(packed >> 128);\n        }\n\n        return (head.receiver, assignmentPossible, headMovedBlock);\n    }\n\n    /// @notice Retrieves the queue index (used for deciding whether to assign express or standard queue next)\n    function getQueueIndex() override external view returns (uint256) {\n        return getUint(queueIndexKey);\n    }\n\n    /// @notice Returns the number of minipools in the queue\n    function getMinipoolQueueLength() override public view returns (uint256) {\n        AddressQueueStorageInterface addressQueueStorage = AddressQueueStorageInterface(getContractAddress(\"addressQueueStorage\"));\n        return addressQueueStorage.getLength(queueKeyVariable);\n    }\n\n    /// @notice Returns the number of megapools in the express queue\n    function getExpressQueueLength() override public view returns (uint256) {\n        LinkedListStorageInterface linkedListStorage = LinkedListStorageInterface(getContractAddress(\"linkedListStorage\"));\n        return linkedListStorage.getLength(expressQueueNamespace);\n    }\n\n    /// @notice Returns the number of megapools in the standard queue\n    function getStandardQueueLength() override public view returns (uint256) {\n        LinkedListStorageInterface linkedListStorage = LinkedListStorageInterface(getContractAddress(\"linkedListStorage\"));\n        return linkedListStorage.getLength(standardQueueNamespace);\n    }\n\n    /// @notice Returns the total number of minipools/megapools in the queue\n    function getTotalQueueLength() override external view returns (uint256) {\n        return getMinipoolQueueLength() + getExpressQueueLength() + getStandardQueueLength();\n    }\n\n    /// @dev Convenience method to return queue key for express and non-express queues\n    function getQueueNamespace(bool _expressQueue) internal pure returns (bytes32) {\n        if (_expressQueue) {\n            return expressQueueNamespace;\n        }\n        return standardQueueNamespace;\n    }\n\n    /// @dev Called by a megapool during a bond reduction to adjust its capital ratio\n    function reduceBond(address _nodeAddress, uint256 _amount) override external onlyRegisteredMegapool(msg.sender) {\n        // Update collateral balances\n        _increaseETHBorrowed(_nodeAddress, _amount);\n        _decreaseETHBonded(_nodeAddress, _amount);\n    }\n\n    /// @dev Called by a megapool when exiting to handle change in capital ratio\n    function fundsReturned(address _nodeAddress, uint256 _nodeAmount, uint256 _userAmount) override external onlyRegisteredMegapool(msg.sender) {\n        // Update collateral balances\n        _decreaseETHBonded(_nodeAddress, _nodeAmount);\n        _decreaseETHBorrowed(_nodeAddress, _userAmount);\n    }\n\n    /// @dev Increases the amount of ETH supplied by a node operator as bond\n    function _increaseETHBonded(address _nodeAddress, uint256 _amount) private {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"megapool.eth.provided.node.amount\", _nodeAddress));\n        uint256 ethBonded = uint256(rocketNetworkSnapshots.latestValue(key)) + _amount;\n        rocketNetworkSnapshots.push(key, uint224(ethBonded));\n    }\n\n    /// @dev Increases the amount of ETH borrowed by a node operator\n    function _increaseETHBorrowed(address _nodeAddress, uint256 _amount) private {\n        bytes32 key = keccak256(abi.encodePacked(\"megapool.eth.matched.node.amount\", _nodeAddress));\n        addUint(key, _amount);\n    }\n\n    /// @dev Decreases the amount of ETH bonded by a node operator as bond\n    function _decreaseETHBonded(address _nodeAddress, uint256 _amount) private {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"megapool.eth.provided.node.amount\", _nodeAddress));\n        uint256 ethBonded = uint256(rocketNetworkSnapshots.latestValue(key)) - _amount;\n        rocketNetworkSnapshots.push(key, uint224(ethBonded));\n    }\n\n    /// @dev Decreases the amount of ETH borrowed by a node operator\n    function _decreaseETHBorrowed(address _nodeAddress, uint256 _amount) private {\n        bytes32 key = keccak256(abi.encodePacked(\"megapool.eth.matched.node.amount\", _nodeAddress));\n        subUint(key, _amount);\n    }\n}\n"
    }
}