{
    "vfp_id": "vfp_00035",
    "project_name": "cantina_sky_spark_alm_controller_oct2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-1271"
                ]
            },
            "title": "The ForeignControllerInit missing maxSlippage set",
            "description": "1. **Description:** The ForeignControllerInit contract does not initialize the maxSlippage parameter during deployment or upgrades, unlike MainnetControllerInit which properly configures it.\n2. **Cause:** Inconsistent initialization logic between the two controller init contracts.\n3. **Exploitation:** If maxSlippage is not set on the foreign controller, it may use a default or outdated value, potentially leading to unexpected behavior during cross-chain operations.\n4. **Impact:** Could result in suboptimal or risky slippage settings on the foreign chain, increasing the chance of failed or unfavorable transactions. A minor but avoidable inconsistency.\n",
            "severity": "Informational",
            "location": [
                "ForeignControllerInit.sol#L163-L165",
                "MainnetControllerInit.sol#L183-L185"
            ],
            "files": [
                "spark-alm-controller/deploy/ForeignControllerInit.sol",
                "spark-alm-controller/deploy/MainnetControllerInit.sol"
            ]
        }
    ],
    "affected_files": {
        "ForeignControllerInit.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { ForeignController } from \"../src/ForeignController.sol\";\n\nimport { IALMProxy }   from \"../src/interfaces/IALMProxy.sol\";\nimport { IRateLimits } from \"../src/interfaces/IRateLimits.sol\";\n\nimport { ControllerInstance } from \"./ControllerInstance.sol\";\n\ninterface IPSM3Like {\n    function susds() external view returns (address);\n    function totalAssets() external view returns (uint256);\n    function totalShares() external view returns (uint256);\n    function usdc() external view returns (address);\n    function usds() external view returns (address);\n}\n\nlibrary ForeignControllerInit {\n\n    /**********************************************************************************************/\n    /*** Structs and constants                                                                  ***/\n    /**********************************************************************************************/\n\n    struct CheckAddressParams {\n        address admin;\n        address psm;\n        address cctp;\n        address usdc;\n        address susds;\n        address usds;\n    }\n\n    struct ConfigAddressParams {\n        address   freezer;\n        address[] relayers;\n        address   oldController;\n    }\n\n    struct MintRecipient {\n        uint32  domain;\n        bytes32 mintRecipient;\n    }\n\n    struct LayerZeroRecipient {\n        uint32  destinationEndpointId;\n        bytes32 recipient;\n    }\n\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**********************************************************************************************/\n    /*** Internal library functions                                                             ***/\n    /**********************************************************************************************/\n\n    function initAlmSystem(\n        ControllerInstance   memory controllerInst,\n        ConfigAddressParams  memory configAddresses,\n        CheckAddressParams   memory checkAddresses,\n        MintRecipient[]      memory mintRecipients,\n        LayerZeroRecipient[] memory layerZeroRecipients,\n        bool                 checkPsm\n    )\n        internal\n    {\n        // Step 1: Do sanity checks outside of the controller\n\n        require(IALMProxy(controllerInst.almProxy).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin),     \"ForeignControllerInit/incorrect-admin-almProxy\");\n        require(IRateLimits(controllerInst.rateLimits).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"ForeignControllerInit/incorrect-admin-rateLimits\");\n\n        // Step 2: Initialize the controller\n\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients, layerZeroRecipients, checkPsm);\n    }\n\n    function upgradeController(\n        ControllerInstance   memory controllerInst,\n        ConfigAddressParams  memory configAddresses,\n        CheckAddressParams   memory checkAddresses,\n        MintRecipient[]      memory mintRecipients,\n        LayerZeroRecipient[] memory layerZeroRecipients,\n        bool                 checkPsm\n    )\n        internal\n    {\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients, layerZeroRecipients, checkPsm);\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        require(configAddresses.oldController != address(0), \"ForeignControllerInit/old-controller-zero-address\");\n\n        require(almProxy.hasRole(almProxy.CONTROLLER(), configAddresses.oldController),     \"ForeignControllerInit/old-controller-not-almProxy-controller\");\n        require(rateLimits.hasRole(rateLimits.CONTROLLER(), configAddresses.oldController), \"ForeignControllerInit/old-controller-not-rateLimits-controller\");\n\n        almProxy.revokeRole(almProxy.CONTROLLER(), configAddresses.oldController);\n        rateLimits.revokeRole(rateLimits.CONTROLLER(), configAddresses.oldController);\n    }\n\n    /**********************************************************************************************/\n    /*** Private helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    function _initController(\n        ControllerInstance   memory controllerInst,\n        ConfigAddressParams  memory configAddresses,\n        CheckAddressParams   memory checkAddresses,\n        MintRecipient[]      memory mintRecipients,\n        LayerZeroRecipient[] memory layerZeroRecipients,\n        bool                 checkPsm\n    )\n        private\n    {\n        // Step 1: Perform controller sanity checks\n\n        ForeignController newController = ForeignController(controllerInst.controller);\n\n        require(newController.hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"ForeignControllerInit/incorrect-admin-controller\");\n\n        require(address(newController.proxy())      == controllerInst.almProxy,   \"ForeignControllerInit/incorrect-almProxy\");\n        require(address(newController.rateLimits()) == controllerInst.rateLimits, \"ForeignControllerInit/incorrect-rateLimits\");\n\n        require(address(newController.psm())  == checkAddresses.psm,  \"ForeignControllerInit/incorrect-psm\");\n        require(address(newController.usdc()) == checkAddresses.usdc, \"ForeignControllerInit/incorrect-usdc\");\n        require(address(newController.cctp()) == checkAddresses.cctp, \"ForeignControllerInit/incorrect-cctp\");\n\n        require(configAddresses.oldController != address(newController), \"ForeignControllerInit/old-controller-is-new-controller\");\n\n        // Step 2: Perform PSM sanity checks\n\n        if (checkPsm) {\n            IPSM3Like psm = IPSM3Like(checkAddresses.psm);\n\n            require(psm.totalAssets() >= 1e18, \"ForeignControllerInit/psm-totalAssets-not-seeded\");\n            require(psm.totalShares() >= 1e18, \"ForeignControllerInit/psm-totalShares-not-seeded\");\n\n            require(psm.usdc()  == checkAddresses.usdc,  \"ForeignControllerInit/psm-incorrect-usdc\");\n            require(psm.usds()  == checkAddresses.usds,  \"ForeignControllerInit/psm-incorrect-usds\");\n            require(psm.susds() == checkAddresses.susds, \"ForeignControllerInit/psm-incorrect-susds\");\n        }\n\n        // Step 3: Configure ACL permissions controller, almProxy, and rateLimits\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        almProxy.grantRole(almProxy.CONTROLLER(),        address(newController));\n        newController.grantRole(newController.FREEZER(), configAddresses.freezer);\n        rateLimits.grantRole(rateLimits.CONTROLLER(),    address(newController));\n\n        for (uint256 i; i < configAddresses.relayers.length; ++i) {\n            newController.grantRole(newController.RELAYER(), configAddresses.relayers[i]);\n        }\n\n        // Step 4: Configure the mint recipients on other domains\n\n        for (uint256 i; i < mintRecipients.length; ++i) {\n            newController.setMintRecipient(mintRecipients[i].domain, mintRecipients[i].mintRecipient);\n        }\n\n        // Step 5: Configure LayerZero recipients\n\n        for (uint256 i; i < layerZeroRecipients.length; ++i) {\n            newController.setLayerZeroRecipient(layerZeroRecipients[i].destinationEndpointId, layerZeroRecipients[i].recipient);\n        }\n    }\n\n}\n",
        "MainnetControllerInit.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { MainnetController } from \"../src/MainnetController.sol\";\n\nimport { IALMProxy }   from \"../src/interfaces/IALMProxy.sol\";\nimport { IRateLimits } from \"../src/interfaces/IRateLimits.sol\";\n\nimport { ControllerInstance } from \"./ControllerInstance.sol\";\n\ninterface IBufferLike {\n    function approve(address, address, uint256) external;\n}\n\ninterface IPSMLike {\n    function kiss(address) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function rely(address) external;\n}\n\nlibrary MainnetControllerInit {\n\n    /**********************************************************************************************/\n    /*** Structs and constants                                                                  ***/\n    /**********************************************************************************************/\n\n    struct CheckAddressParams {\n        address admin;\n        address proxy;\n        address rateLimits;\n        address vault;\n        address psm;\n        address daiUsds;\n        address cctp;\n    }\n\n    struct ConfigAddressParams {\n        address   freezer;\n        address[] relayers;\n        address   oldController;\n    }\n\n    struct MintRecipient {\n        uint32  domain;\n        bytes32 mintRecipient;\n    }\n\n    struct LayerZeroRecipient {\n        uint32  destinationEndpointId;\n        bytes32 recipient;\n    }\n\n    struct MaxSlippageParams {\n        address pool;\n        uint256 maxSlippage;\n    }\n\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**********************************************************************************************/\n    /*** Internal library functions                                                             ***/\n    /**********************************************************************************************/\n\n    function initAlmSystem(\n        address vault,\n        address usds,\n        ControllerInstance   memory controllerInst,\n        ConfigAddressParams  memory configAddresses,\n        CheckAddressParams   memory checkAddresses,\n        MintRecipient[]      memory mintRecipients,\n        LayerZeroRecipient[] memory layerZeroRecipients,\n        MaxSlippageParams[]  memory maxSlippageParams\n    )\n        internal\n    {\n        // Step 1: Do sanity checks outside of the controller\n\n        require(IALMProxy(controllerInst.almProxy).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin),     \"MainnetControllerInit/incorrect-admin-almProxy\");\n        require(IRateLimits(controllerInst.rateLimits).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"MainnetControllerInit/incorrect-admin-rateLimits\");\n\n        // Step 2: Initialize the controller\n\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients, layerZeroRecipients, maxSlippageParams);\n\n        // Step 3: Configure almProxy within the allocation system\n\n        require(vault == checkAddresses.vault, \"MainnetControllerInit/incorrect-vault\");\n\n        IVaultLike(vault).rely(controllerInst.almProxy);\n        IBufferLike(IVaultLike(vault).buffer()).approve(usds, controllerInst.almProxy, type(uint256).max);\n    }\n\n    function upgradeController(\n        ControllerInstance   memory controllerInst,\n        ConfigAddressParams  memory configAddresses,\n        CheckAddressParams   memory checkAddresses,\n        MintRecipient[]      memory mintRecipients,\n        LayerZeroRecipient[] memory layerZeroRecipients,\n        MaxSlippageParams[]  memory maxSlippageParams\n    )\n        internal\n    {\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients, layerZeroRecipients, maxSlippageParams);\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        require(configAddresses.oldController != address(0), \"MainnetControllerInit/old-controller-zero-address\");\n\n        require(almProxy.hasRole(almProxy.CONTROLLER(), configAddresses.oldController),     \"MainnetControllerInit/old-controller-not-almProxy-controller\");\n        require(rateLimits.hasRole(rateLimits.CONTROLLER(), configAddresses.oldController), \"MainnetControllerInit/old-controller-not-rateLimits-controller\");\n\n        almProxy.revokeRole(almProxy.CONTROLLER(), configAddresses.oldController);\n        rateLimits.revokeRole(rateLimits.CONTROLLER(), configAddresses.oldController);\n    }\n\n    function pauseProxyInitAlmSystem(address psm, address almProxy) internal {\n        IPSMLike(psm).kiss(almProxy);  // To allow using no fee functionality\n    }\n\n    /**********************************************************************************************/\n    /*** Private helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    function _initController(\n        ControllerInstance   memory controllerInst,\n        ConfigAddressParams  memory configAddresses,\n        CheckAddressParams   memory checkAddresses,\n        MintRecipient[]      memory mintRecipients,\n        LayerZeroRecipient[] memory layerZeroRecipients,\n        MaxSlippageParams[]  memory maxSlippageParams\n    )\n        private\n    {\n        // Step 1: Perform controller sanity checks\n\n        MainnetController newController = MainnetController(controllerInst.controller);\n\n        require(newController.hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"MainnetControllerInit/incorrect-admin-controller\");\n\n        require(address(newController.proxy())      == controllerInst.almProxy,   \"MainnetControllerInit/incorrect-almProxy\");\n        require(address(newController.rateLimits()) == controllerInst.rateLimits, \"MainnetControllerInit/incorrect-rateLimits\");\n\n        require(address(newController.vault())   == checkAddresses.vault,   \"MainnetControllerInit/incorrect-vault\");\n        require(address(newController.psm())     == checkAddresses.psm,     \"MainnetControllerInit/incorrect-psm\");\n        require(address(newController.daiUsds()) == checkAddresses.daiUsds, \"MainnetControllerInit/incorrect-daiUsds\");\n        require(address(newController.cctp())    == checkAddresses.cctp,    \"MainnetControllerInit/incorrect-cctp\");\n\n        require(newController.psmTo18ConversionFactor() == 1e12, \"MainnetControllerInit/incorrect-psmTo18ConversionFactor\");\n\n        require(configAddresses.oldController != address(newController), \"MainnetControllerInit/old-controller-is-new-controller\");\n\n        // Step 2: Configure ACL permissions controller, almProxy, and rateLimits\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        almProxy.grantRole(almProxy.CONTROLLER(),        address(newController));\n        newController.grantRole(newController.FREEZER(), configAddresses.freezer);\n        rateLimits.grantRole(rateLimits.CONTROLLER(),    address(newController));\n\n        for (uint256 i; i < configAddresses.relayers.length; ++i) {\n            newController.grantRole(newController.RELAYER(), configAddresses.relayers[i]);\n        }\n\n        // Step 3: Configure the mint recipients on other domains\n\n        for (uint256 i; i < mintRecipients.length; ++i) {\n            newController.setMintRecipient(mintRecipients[i].domain, mintRecipients[i].mintRecipient);\n        }\n\n        // Step 4: Configure LayerZero recipients\n\n        for (uint256 i; i < layerZeroRecipients.length; ++i) {\n            newController.setLayerZeroRecipient(layerZeroRecipients[i].destinationEndpointId, layerZeroRecipients[i].recipient);\n        }\n\n        // Step 5: Configure max slippage\n\n        for (uint256 i; i < maxSlippageParams.length; ++i) {\n            newController.setMaxSlippage(maxSlippageParams[i].pool, maxSlippageParams[i].maxSlippage);\n        }\n    }\n\n}\n"
    }
}