{
    "vfp_id": "vfp_00020",
    "project_name": "cantina_aragon_oct2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-250"
                ]
            },
            "title": "Auto-compound strategy can have its rewards stolen",
            "description": "The AragonMerklAutoCompoundStrategy contract sets the Swapper as its operator to allow it to claim rewards on its behalf from the Merkl Distributor. However, this design violates the security principle that the Swapper should not be trusted between transactions and grants it excessive privileges. The root cause is the permanent whitelisting of the Swapper as an operator without limiting the scope of its authority. An attacker can exploit this by calling the Swapper with a valid claim of their own and including malicious actions that re-enter the Distributor to claim rewards on behalf of the auto-compounder and transfer them to the attacker. This allows theft of the strategy’s rewards. The impact is loss of user funds and disruption of the auto-compounding mechanism, which undermines the core functionality and trust in the system.\n",
            "severity": "High",
            "location": [
                "AragonMerklAutoCompoundStrategy.sol#L93"
            ],
            "files": [
                "katana-governance/src/strategies/AragonMerklAutoCompoundStrategy.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "AragonMerklAutoCompoundStrategy does not set Swapper as its recipient for claims",
            "description": "The AragonMerklAutoCompoundStrategy fails to designate the Swapper as the recipient for reward claims in the Merkl Distributor. The vulnerability arises because the Distributor defaults to sending rewards to the user (i.e., the strategy itself) if no explicit recipient is set, and since the Swapper is the msg.sender during the claim, the strategy is not the direct caller. As a result, the claimed tokens are sent directly to the strategy, bypassing the Swapper, which then sees no token gain and returns zero claimedAmount. This causes the auto-compounding logic to skip depositing rewards into escrow, leaving tokens stranded and disrupting the strategy’s operation. An attacker cannot directly steal funds, but the malfunction leads to loss of gauge voting power and requires a contract upgrade to recover. The root cause is the omission of recipient setup in the strategy’s initialization or before claim execution.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "katana-governance/src/strategies/AragonMerklAutoCompoundStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "AragonMerklAutoCompoundStrategy.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ERC721HolderUpgradeable as ERC721Holder } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { VotingEscrow, GaugeVoter, EscrowIVotesAdapter, Lock as LockNFT } from \"@setup/GaugeVoterSetup_v1_4_0.sol\";\n\nimport { DaoAuthorizableUpgradeable as DaoAuthorizable } from\n    \"@aragon/osx-commons-contracts/src/permission/auth/DaoAuthorizableUpgradeable.sol\";\n\nimport { IDAO } from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport { Action } from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\n\nimport { AvKATVault } from \"src/AvKATVault.sol\";\nimport { Swapper } from \"src/Swapper.sol\";\nimport { ISwapper } from \"src/interfaces/ISwapper.sol\";\nimport { IRewardsDistributor } from \"src/interfaces/IRewardsDistributor.sol\";\nimport { IStrategyNFT } from \"src/interfaces/IStrategyNFT.sol\";\nimport { IStrategy } from \"src/interfaces/IStrategy.sol\";\nimport { NFTBaseStrategy } from \"../abstracts/NFTBaseStrategy.sol\";\n\ncontract AragonMerklAutoCompoundStrategy is\n    Initializable,\n    ERC721Holder,\n    UUPSUpgradeable,\n    DaoAuthorizable,\n    NFTBaseStrategy\n{\n    using SafeERC20 for IERC20;\n\n    ///@notice The bytes32 identifier for admin role functions.\n    bytes32 public constant AUTOCOMPOUND_STRATEGY_ADMIN_ROLE = keccak256(\"AUTOCOMPOUND_STRATEGY_ADMIN_ROLE\");\n\n    ///@notice The bytes32 identifier for vote function.\n    bytes32 public constant AUTOCOMPOUND_STRATEGY_VOTE_ROLE = keccak256(\"AUTOCOMPOUND_STRATEGY_VOTE_ROLE\");\n\n    ///@notice The bytes32 identifier for claimAndCompound function.\n    bytes32 public constant AUTOCOMPOUND_STRATEGY_CLAIM_COMPOUND_ROLE =\n        keccak256(\"AUTOCOMPOUND_STRATEGY_CLAIM_COMPOUND_ROLE\");\n\n    /// @notice The gauge voter where this contract votes for gauges.\n    GaugeVoter public voter;\n\n    /// @notice The vault address where this contract auto-compounds(deposits kat).\n    AvKATVault public vault;\n\n    /// @notice The swapper contract which this contract asks for claiming tokens.\n    Swapper public swapper;\n\n    /// @notice The ivotes adapter for delegation\n    EscrowIVotesAdapter public ivotesAdapter;\n\n    /// @notice The address that this strategy delegates voting power to.\n    address public delegatee;\n\n    /// @notice Emitted when the admin withdraws mistakenly withdraws token ids.\n    event Sweep(uint256[] tokenIds, address receiver);\n\n    /// @notice Thrown when the admin tries to withdraw master token id.\n    error CannotTransferMasterToken();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _dao,\n        address _escrow,\n        address _swapper,\n        address _vault,\n        address _rewardDistributor\n    )\n        external\n        initializer\n    {\n        __DaoAuthorizableUpgradeable_init(IDAO(_dao));\n\n        ivotesAdapter = EscrowIVotesAdapter(VotingEscrow(_escrow).ivotesAdapter());\n        voter = GaugeVoter(VotingEscrow(_escrow).voter());\n        swapper = Swapper(_swapper);\n        vault = AvKATVault(_vault);\n\n        __NFTBaseStrategy_init(_escrow, VotingEscrow(_escrow).token(), VotingEscrow(_escrow).lockNFT(), _vault);\n\n        // As the caller on distributor's `claim` function will be swapper,\n        // it can only work if this contract allowed swapper to claim on behalf.\n        IRewardsDistributor(_rewardDistributor).toggleOperator(address(this), _swapper);\n    }\n\n    /// @notice Sets the delegatee address for voting power delegation.\n    /// @param _delegatee The address to delegate voting power to.\n    function delegate(address _delegatee) public virtual auth(AUTOCOMPOUND_STRATEGY_ADMIN_ROLE) {\n        delegatee = _delegatee;\n        if (_delegatee != address(0)) {\n            ivotesAdapter.delegate(_delegatee);\n        }\n    }\n\n    /// @notice Claims and swaps token. If claimed amount for `token` is > 0,\n    ///         it donates(i.e increases totalAssets) without minting shares.\n    /// @param _tokens Which tokens to claim.\n    /// @param _amounts How much to claim for each token.\n    /// @param _proofs The merkle proof that this contract holds `_amounts` on merkle distributor.\n    /// @param _actions The actions that Swapper contract executes. Most times, it will be swap actions.\n    /// @return Returns shares that were minted in exchange for depositting kat tokens.\n    function claimAndCompound(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _proofs,\n        Action[] calldata _actions\n    )\n        public\n        virtual\n        auth(AUTOCOMPOUND_STRATEGY_CLAIM_COMPOUND_ROLE)\n        returns (uint256)\n    {\n        // which tokens to claim for with their proofs and amounts.\n        ISwapper.Claim memory claimTokens = ISwapper.Claim(_tokens, _amounts, _proofs);\n\n        (uint256 claimedAmount,) = swapper.claimAndSwap(claimTokens, _actions, 0);\n\n        // If claimedAmount is greater than 0, autocompound received some amounts on `token`.\n        // Donate to vault to increase totalAssets without minting shares.\n        // This increases the value of all existing shares proportionally.\n        if (claimedAmount > 0) {\n            _deposit(claimedAmount);\n        }\n\n        return claimedAmount;\n    }\n\n    /// @notice Votes on gauge voter with `_votes`.\n    /// @dev The caller must invoke `delegate` with this strategy’s address, effectively delegating to itself.\n    /// @param _votes The gauges and their weights to vote for.\n    function vote(GaugeVoter.GaugeVote[] calldata _votes) external virtual auth(AUTOCOMPOUND_STRATEGY_VOTE_ROLE) {\n        voter.vote(_votes);\n    }\n\n    /// @notice Allows the admin to withdraw specified token IDs, provided none are the master token.\n    /// @dev This allows to withdraw tokens that have been mistakenly transfered to strategy contract.\n    /// @param _tokenIds The token IDs to withdraw. All IDs must currently be held by this strategy.\n    /// @param _receiver The address that will receive the NFTs.\n    function withdrawTokens(\n        uint256[] memory _tokenIds,\n        address _receiver\n    )\n        external\n        virtual\n        auth(AUTOCOMPOUND_STRATEGY_ADMIN_ROLE)\n    {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            uint256 tokenId = _tokenIds[i];\n\n            if (tokenId == masterTokenId) {\n                revert CannotTransferMasterToken();\n            }\n\n            nft.safeTransferFrom(address(this), _receiver, tokenId);\n        }\n\n        emit Sweep(_tokenIds, _receiver);\n    }\n\n    /// @inheritdoc IStrategy\n    function retireStrategy() public virtual override {\n        // For safety reasons, revoke current delegatee\n        ivotesAdapter.delegate(address(0));\n\n        super.retireStrategy();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Upgrade\n    //////////////////////////////////////////////////////////////*/\n    function _authorizeUpgrade(address) internal virtual override auth(AUTOCOMPOUND_STRATEGY_ADMIN_ROLE) { }\n\n    function implementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Reserved storage space to allow for layout changes in the future.\n    uint256[45] private __gap;\n}\n"
    }
}