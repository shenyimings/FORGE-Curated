{
    "vfp_id": "vfp_00198",
    "project_name": "Lido Utility contract for CSM Oracle report day offset Security Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Unprotected External Functions Allow Public Execution of Phase Transitions",
            "description": "The external functions executeOffsetPhase, executeRestorePhase, and renounceRoleWhenExpired lack access control modifiers and can be called by any address. \nThe root cause is the absence of role-based access restrictions on functions that perform critical system operations, which deviates from the principle of least privilege. \nAlthough internal validation logic (_validate) ensures these functions can only succeed under specific conditions, any external actor can still attempt to call them, potentially leading to unnecessary gas costs or confusion in system state transitions. \nThe impact of this issue is limited due to the existing validation checks, meaning there is no direct exploit path for fund theft or full system compromise; however, it increases the attack surface and weakens the overall security posture by allowing unrestricted access to sensitive configuration functions.\n",
            "severity": "Low",
            "location": [
                "TwoPhaseFrameConfigUpdate.sol::executeOffsetPhase",
                "TwoPhaseFrameConfigUpdate.sol::executeRestorePhase",
                "TwoPhaseFrameConfigUpdate.sol::renounceRoleWhenExpired"
            ],
            "files": [
                "2981a28d5573266abe98097f44f9cdc086944c4b/community-staking-module/src/utils/TwoPhaseFrameConfigUpdate.sol"
            ]
        }
    ],
    "affected_files": {
        "TwoPhaseFrameConfigUpdate.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.31;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport { IReportAsyncProcessor } from \"../lib/base-oracle/interfaces/IReportAsyncProcessor.sol\";\nimport { IConsensusContract } from \"../lib/base-oracle/interfaces/IConsensusContract.sol\";\n\n/// @notice A helper to offset the Oracle report schedule (e.g., move the report window by N epochs).\n///         This is achieved via a two-phase frame configuration update in the HashConsensus contract used by the Oracle:\n///         - Offset phase: set a transitional frame size (shorter or longer than the original) and disable the fast\n///         lane after the Oracle has completed main phase in report processing for a defined number of reports with the original frame config.\n///         - Restore phase: set the original frame size and the desired fast lane length after the Oracle has\n///         completed main phase in report processing for a defined number of reports with the transitional config.\n///         As a result, the Oracle report window is shifted by the following calculation:\n///          - If currentEpochsPerFrame > offsetPhaseEpochsPerFrame:\n///            `shift = reportsToProcessBeforeRestorePhase * (currentEpochsPerFrame - offsetPhaseEpochsPerFrame)`\n///          - If offsetPhaseEpochsPerFrame > currentEpochsPerFrame:\n///            `shift = reportsToProcessBeforeRestorePhase * (offsetPhaseEpochsPerFrame - currentEpochsPerFrame)`\n///         ---\n///         Due to the CSM Oracle off-chain sanity checks, the frame config cannot be changed if there is a missing\n///         report. Also, the frame config for the CSM oracle should not be changed such that the new reference slot is\n///         in the past.\n/// @dev    The contract should have `MANAGE_FRAME_CONFIG_ROLE` role granted on the\n///         `HashConsensus` contract in order to be able to call `setFrameConfig`.\ncontract TwoPhaseFrameConfigUpdate {\n    struct PhasesConfig {\n        /// @notice Reports to complete main phase in report processing from the `lastProcessingRefSlot` (as of deployment) to enable the offset phase.\n        uint256 reportsToProcessBeforeOffsetPhase;\n        /// @notice Reports to complete main phase in report processing after the offset phase completion to enable the restore phase.\n        uint256 reportsToProcessBeforeRestorePhase;\n        /// @notice Offset phase epochs per frame.\n        uint256 offsetPhaseEpochsPerFrame;\n        /// @notice Restore phase fast lane length in slots.\n        uint256 restorePhaseFastLaneLengthSlots;\n    }\n\n    struct PhaseState {\n        /// @notice Expected oracle's last processing ref slot for phase execution.\n        ///         This phase can be executed when ORACLE.getLastProcessingRefSlot()\n        ///         equals this value (i.e., oracle has completed the expected number of main phases in report processing).\n        uint256 expectedProcessingRefSlot;\n        /// @notice Slot when this phase expires.\n        ///         This phase expires when the current slot (calculated from block.timestamp)\n        ///         is greater than or equal to this value.\n        uint256 expirationSlot;\n        uint256 epochsPerFrame;\n        uint256 fastLaneLengthSlots;\n        bool executed;\n    }\n\n    IReportAsyncProcessor public immutable ORACLE;\n    IConsensusContract public immutable HASH_CONSENSUS;\n    uint256 public immutable SECONDS_PER_SLOT;\n    uint256 public immutable GENESIS_TIME;\n    uint256 public immutable SLOTS_PER_EPOCH;\n\n    /// @dev Fast lane is expected to be disabled during the offset phase.\n    uint256 public constant OFFSET_PHASE_FAST_LANE_LENGTH = 0;\n\n    PhaseState public offsetPhase;\n    PhaseState public restorePhase;\n\n    event OffsetPhaseExecuted();\n    event RestorePhaseExecuted();\n\n    error ZeroOracleAddress();\n    error ZeroEpochsPerFrame();\n    error ZeroReportsToEnableUpdate();\n    error CurrentReportMainPhaseIsNotCompleted();\n    error FastLanePeriodCannotBeLongerThanFrame();\n    error FastLaneTooShort();\n    error NoneOfPhasesExpired();\n\n    error PhaseAlreadyExecuted();\n    error OffsetPhaseNotExecuted();\n    error PhaseExpired(uint256 currentSlot, uint256 deadlineSlot);\n    error UnexpectedLastProcessingRefSlot(uint256 actual, uint256 expected);\n\n    constructor(address oracle, PhasesConfig memory phasesConfig) {\n        if (oracle == address(0)) {\n            revert ZeroOracleAddress();\n        }\n\n        if (phasesConfig.reportsToProcessBeforeOffsetPhase == 0) {\n            revert ZeroReportsToEnableUpdate();\n        }\n\n        if (phasesConfig.reportsToProcessBeforeRestorePhase == 0) {\n            revert ZeroReportsToEnableUpdate();\n        }\n\n        if (phasesConfig.offsetPhaseEpochsPerFrame == 0) {\n            revert ZeroEpochsPerFrame();\n        }\n\n        ORACLE = IReportAsyncProcessor(oracle);\n        HASH_CONSENSUS = IConsensusContract(ORACLE.getConsensusContract());\n\n        (\n            uint256 slotsPerEpoch,\n            uint256 secondsPerSlot,\n            uint256 genesisTime\n        ) = HASH_CONSENSUS.getChainConfig();\n        SLOTS_PER_EPOCH = slotsPerEpoch;\n        SECONDS_PER_SLOT = secondsPerSlot;\n        GENESIS_TIME = genesisTime;\n\n        (, uint256 currentEpochsPerFrame, ) = HASH_CONSENSUS.getFrameConfig();\n        uint256 lastProcessingRefSlot = ORACLE.getLastProcessingRefSlot();\n\n        (uint256 currentRefSlot, ) = HASH_CONSENSUS.getCurrentFrame();\n        if (currentRefSlot != lastProcessingRefSlot) {\n            revert CurrentReportMainPhaseIsNotCompleted();\n        }\n\n        // Typically, the Lido oracles wait for ref slot finalization, which takes at least 2 epochs.\n        if (\n            phasesConfig.restorePhaseFastLaneLengthSlots < SLOTS_PER_EPOCH * 2\n        ) {\n            revert FastLaneTooShort();\n        }\n\n        if (\n            phasesConfig.restorePhaseFastLaneLengthSlots >\n            currentEpochsPerFrame * slotsPerEpoch\n        ) {\n            revert FastLanePeriodCannotBeLongerThanFrame();\n        }\n\n        // Calculate pivot ref slot for the offset phase (based on the last processing ref slot as of deployment)\n        uint256 offsetExpectedProcessingRefSlot = lastProcessingRefSlot +\n            (phasesConfig.reportsToProcessBeforeOffsetPhase *\n                currentEpochsPerFrame *\n                slotsPerEpoch);\n\n        uint256 minEpochsPerFrame = Math.min(\n            phasesConfig.offsetPhaseEpochsPerFrame,\n            currentEpochsPerFrame\n        );\n\n        // Ensure that after offset phase execution we won't end up having a missing report (offsetPhaseEpochsPerFrame <\n        // currentEpochsPerFrame) and we haven't started reaching consensus for the extra report\n        // (offsetPhaseEpochsPerFrame > currentEpochsPerFrame).\n        // Example: currentEpochsPerFrame = 28 days, offsetPhaseEpochsPerFrame = 20 days\n        //        if offset phase is executed after more than 20 days since the last report,\n        //        we will have a missing report for the new frame config.\n        uint256 offsetExpirationSlot = offsetExpectedProcessingRefSlot +\n            minEpochsPerFrame *\n            slotsPerEpoch;\n\n        uint256 currentSlot = _getCurrentSlot();\n        if (currentSlot >= offsetExpirationSlot) {\n            revert PhaseExpired(currentSlot, offsetExpirationSlot);\n        }\n\n        // Calculate pivot ref slot for the restore phase (based on the offset phase completion)\n        uint256 restoreExpectedProcessingRefSlot = offsetExpectedProcessingRefSlot +\n                (phasesConfig.reportsToProcessBeforeRestorePhase *\n                    phasesConfig.offsetPhaseEpochsPerFrame *\n                    slotsPerEpoch);\n\n        // See the comment above for the offsetExpirationSlot.\n        uint256 restoreExpirationSlot = restoreExpectedProcessingRefSlot +\n            minEpochsPerFrame *\n            slotsPerEpoch;\n\n        offsetPhase = PhaseState({\n            expectedProcessingRefSlot: offsetExpectedProcessingRefSlot,\n            expirationSlot: offsetExpirationSlot,\n            epochsPerFrame: phasesConfig.offsetPhaseEpochsPerFrame,\n            fastLaneLengthSlots: OFFSET_PHASE_FAST_LANE_LENGTH,\n            executed: false\n        });\n\n        restorePhase = PhaseState({\n            expectedProcessingRefSlot: restoreExpectedProcessingRefSlot,\n            expirationSlot: restoreExpirationSlot,\n            epochsPerFrame: currentEpochsPerFrame,\n            fastLaneLengthSlots: phasesConfig.restorePhaseFastLaneLengthSlots,\n            executed: false\n        });\n    }\n\n    function executeOffsetPhase() external {\n        PhaseState storage phase = offsetPhase;\n        _validate(phase);\n\n        HASH_CONSENSUS.setFrameConfig(\n            phase.epochsPerFrame,\n            phase.fastLaneLengthSlots\n        );\n\n        phase.executed = true;\n        emit OffsetPhaseExecuted();\n    }\n\n    function executeRestorePhase() external {\n        if (!offsetPhase.executed) {\n            revert OffsetPhaseNotExecuted();\n        }\n\n        PhaseState storage phase = restorePhase;\n        _validate(phase);\n\n        HASH_CONSENSUS.setFrameConfig(\n            phase.epochsPerFrame,\n            phase.fastLaneLengthSlots\n        );\n\n        phase.executed = true;\n        emit RestorePhaseExecuted();\n\n        _renounceRole();\n    }\n\n    /// @dev Fallback to renounce the role if phases are expired.\n    function renounceRoleWhenExpired() external {\n        if (!_isExpired(offsetPhase) && !_isExpired(restorePhase)) {\n            revert NoneOfPhasesExpired();\n        }\n\n        _renounceRole();\n    }\n\n    function isReadyForOffsetPhase() external view returns (bool ready) {\n        return _isReady(offsetPhase);\n    }\n\n    function isReadyForRestorePhase() external view returns (bool ready) {\n        if (!offsetPhase.executed) {\n            return false;\n        }\n\n        return _isReady(restorePhase);\n    }\n\n    function getExpirationStatus()\n        external\n        view\n        returns (bool offsetExpired, bool restoreExpired)\n    {\n        return (_isExpired(offsetPhase), _isExpired(restorePhase));\n    }\n\n    function _renounceRole() internal {\n        IAccessControl(address(HASH_CONSENSUS)).renounceRole(\n            HASH_CONSENSUS.MANAGE_FRAME_CONFIG_ROLE(),\n            address(this)\n        );\n    }\n\n    function _validate(PhaseState storage phaseState) internal view {\n        if (phaseState.executed) {\n            revert PhaseAlreadyExecuted();\n        }\n\n        (\n            bool hasExpectedRefSlot,\n            uint256 lastProcessingRefSlot\n        ) = _hasExpectedRefSlot(phaseState);\n        if (!hasExpectedRefSlot) {\n            revert UnexpectedLastProcessingRefSlot(\n                lastProcessingRefSlot,\n                phaseState.expectedProcessingRefSlot\n            );\n        }\n\n        uint256 currentSlot = _getCurrentSlot();\n        uint256 expirationSlot = phaseState.expirationSlot;\n        if (currentSlot >= expirationSlot) {\n            revert PhaseExpired(currentSlot, expirationSlot);\n        }\n    }\n\n    function _getCurrentSlot() internal view returns (uint256 currentSlot) {\n        return (block.timestamp - GENESIS_TIME) / SECONDS_PER_SLOT;\n    }\n\n    function _isReady(\n        PhaseState storage phaseState\n    ) internal view returns (bool ready) {\n        if (\n            phaseState.executed ||\n            _getCurrentSlot() >= phaseState.expirationSlot\n        ) {\n            return false;\n        }\n        (ready, ) = _hasExpectedRefSlot(phaseState);\n    }\n\n    function _isExpired(\n        PhaseState storage phaseState\n    ) internal view returns (bool expired) {\n        return\n            !phaseState.executed &&\n            _getCurrentSlot() >= phaseState.expirationSlot;\n    }\n\n    function _hasExpectedRefSlot(\n        PhaseState storage phaseState\n    ) internal view returns (bool matches, uint256 lastProcessingRefSlot) {\n        lastProcessingRefSlot = ORACLE.getLastProcessingRefSlot();\n        matches = lastProcessingRefSlot == phaseState.expectedProcessingRefSlot;\n    }\n}\n"
    }
}