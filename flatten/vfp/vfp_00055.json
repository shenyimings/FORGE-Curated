{
    "vfp_id": "vfp_00055",
    "project_name": "cantina_centrifuge_may2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "VaultRouter.enableLockDepositRequest can revert when wrapping underlying tokens",
            "description": "The VaultRouter.enableLockDepositRequest function can revert when attempting to wrap underlying tokens if the user's balance is less than the requested amount. The function calls VaultRouter.wrap, which wraps the minimum of the request amount and the user's balance, but then proceeds to use the full requested amount when calling lockDepositRequest. This discrepancy causes the contract to attempt to pull more funds than were actually wrapped, leading to a revert. The root cause is the failure to capture and use the actual amount of tokens wrapped. An attacker could exploit this by initiating partial wrap operations and triggering reverts during deposit locking, potentially disrupting user flows or causing failed transactions. The impact is transaction failure and denial of service for deposit functionality in edge cases.\n",
            "severity": "Low",
            "location": [
                "VaultRouter.sol::enableLockDepositRequest#130-144",
                "VaultRouter.sol::wrap#156-157",
                "VaultRouter.sol::lockDepositRequest#272-282"
            ],
            "files": [
                "protocol-v3/src/vaults/VaultRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultRouter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {Multicall, IMulticall} from \"src/misc/Multicall.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IERC20, IERC20Permit, IERC20Wrapper} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC7540Deposit} from \"src/misc/interfaces/IERC7540.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\n\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IMessageDispatcher} from \"src/common/interfaces/IMessageDispatcher.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IAsyncVault, IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IVaultRouter} from \"src/vaults/interfaces/IVaultRouter.sol\";\nimport {IPoolManager, VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {BaseSyncDepositVault} from \"src/vaults/BaseVaults.sol\";\n\n/// @title  VaultRouter\n/// @notice This is a helper contract, designed to be the entrypoint for EOAs.\n///         It removes the need to know about all other contracts and simplifies the way to interact with the protocol.\n///         It also adds the need to fully pay for each step of the transaction execution. VaultRouter allows\n///         the caller to execute multiple function into a single transaction by taking advantage of\n///         the multicall functionality which batches message calls into a single one.\n/// @dev    It is critical to ensure that at the end of any transaction, no funds remain in the\n///         VaultRouter. Any funds that do remain are at risk of being taken by other users.\ncontract VaultRouter is Auth, Multicall, Recoverable, IVaultRouter {\n    using CastLib for address;\n\n    /// @dev Requests for Centrifuge pool are non-fungible and all have ID = 0\n    uint256 private constant REQUEST_ID = 0;\n\n    IEscrow public immutable escrow;\n    IGateway public immutable gateway;\n    IPoolManager public immutable poolManager;\n    IMessageDispatcher public immutable messageDispatcher;\n\n    /// @inheritdoc IVaultRouter\n    mapping(address controller => mapping(IBaseVault vault => uint256 amount)) public lockedRequests;\n\n    constructor(\n        address escrow_,\n        IGateway gateway_,\n        IPoolManager poolManager_,\n        IMessageDispatcher messageDispatcher_,\n        address deployer\n    ) Auth(deployer) {\n        escrow = IEscrow(escrow_);\n        gateway = gateway_;\n        poolManager = poolManager_;\n        messageDispatcher = messageDispatcher_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMulticall\n    /// @notice performs a multicall but all message sent in the process will be batched\n    function multicall(bytes[] calldata data) public payable override(Multicall, IMulticall) {\n        bool wasBatching = gateway.isBatching();\n        if (!wasBatching) {\n            gateway.startBatching();\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n\n        super.multicall(data);\n\n        if (!wasBatching) {\n            gateway.endBatching();\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Enable interactions\n    //----------------------------------------------------------------------------------------------\n\n    function enable(IBaseVault vault) public payable protected {\n        vault.setEndorsedOperator(msg.sender, true);\n    }\n\n    function disable(IBaseVault vault) external payable protected {\n        vault.setEndorsedOperator(msg.sender, false);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Deposit\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function requestDeposit(IAsyncVault vault, uint256 amount, address controller, address owner)\n        external\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        if (owner == address(this)) {\n            _approveMax(vaultDetails.asset, address(vault));\n        }\n\n        _pay();\n        vault.requestDeposit(amount, controller, owner);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function deposit(BaseSyncDepositVault vault, uint256 assets, address receiver, address owner)\n        external\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        require(!vault.supportsInterface(type(IERC7540Deposit).interfaceId), NonSyncDepositVault());\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        SafeTransferLib.safeTransferFrom(vaultDetails.asset, owner, address(this), assets);\n        _approveMax(vaultDetails.asset, address(vault));\n\n        _pay();\n        vault.deposit(assets, receiver);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function lockDepositRequest(IBaseVault vault, uint256 amount, address controller, address owner)\n        public\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        require(vault.supportsInterface(type(IERC7540Deposit).interfaceId), NonAsyncVault());\n\n        lockedRequests[controller][vault] += amount;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        SafeTransferLib.safeTransferFrom(vaultDetails.asset, owner, address(escrow), amount);\n\n        emit LockDepositRequest(vault, controller, owner, msg.sender, amount);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function enableLockDepositRequest(IBaseVault vault, uint256 amount) external payable protected {\n        enable(vault);\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n\n        uint256 assetBalance;\n        assetBalance = IERC20(vaultDetails.asset).balanceOf(msg.sender);\n\n        if (vaultDetails.isWrapper && assetBalance < amount) {\n            wrap(vaultDetails.asset, amount, address(this), msg.sender);\n            lockDepositRequest(vault, amount, msg.sender, address(this));\n        } else {\n            lockDepositRequest(vault, amount, msg.sender, msg.sender);\n        }\n    }\n\n    /// @inheritdoc IVaultRouter\n    function unlockDepositRequest(IBaseVault vault, address receiver) external payable protected {\n        uint256 lockedRequest = lockedRequests[msg.sender][vault];\n        require(lockedRequest != 0, NoLockedBalance());\n        lockedRequests[msg.sender][vault] = 0;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        escrow.authTransferTo(vaultDetails.asset, receiver, lockedRequest);\n\n        emit UnlockDepositRequest(vault, msg.sender, receiver);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function executeLockedDepositRequest(IAsyncVault vault, address controller) external payable protected {\n        uint256 lockedRequest = lockedRequests[controller][vault];\n        require(lockedRequest != 0, NoLockedRequest());\n        lockedRequests[controller][vault] = 0;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        escrow.authTransferTo(vaultDetails.asset, address(this), lockedRequest);\n\n        _pay();\n        _approveMax(vaultDetails.asset, address(vault));\n        vault.requestDeposit(lockedRequest, controller, address(this));\n        emit ExecuteLockedDepositRequest(vault, controller, msg.sender);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimDeposit(IAsyncVault vault, address receiver, address controller) external payable protected {\n        _canClaim(vault, receiver, controller);\n        uint256 maxMint = vault.maxMint(controller);\n        vault.mint(maxMint, receiver, controller);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function cancelDepositRequest(IAsyncVault vault) external payable protected {\n        _pay();\n        vault.cancelDepositRequest(REQUEST_ID, msg.sender);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimCancelDepositRequest(IAsyncVault vault, address receiver, address controller)\n        external\n        payable\n        protected\n    {\n        _canClaim(vault, receiver, controller);\n        vault.claimCancelDepositRequest(REQUEST_ID, receiver, controller);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Redeem\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function requestRedeem(IAsyncVault vault, uint256 amount, address controller, address owner)\n        external\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        _pay();\n        vault.requestRedeem(amount, controller, owner);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimRedeem(IBaseVault vault, address receiver, address controller) external payable protected {\n        _canClaim(vault, receiver, controller);\n        uint256 maxWithdraw = vault.maxWithdraw(controller);\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        if (vaultDetails.isWrapper && controller != msg.sender) {\n            // Auto-unwrap if permissionlessly claiming for another controller\n            vault.withdraw(maxWithdraw, address(this), controller);\n            unwrap(vaultDetails.asset, maxWithdraw, receiver);\n        } else {\n            vault.withdraw(maxWithdraw, receiver, controller);\n        }\n    }\n\n    /// @inheritdoc IVaultRouter\n    function cancelRedeemRequest(IAsyncVault vault) external payable protected {\n        _pay();\n        vault.cancelRedeemRequest(REQUEST_ID, msg.sender);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimCancelRedeemRequest(IAsyncVault vault, address receiver, address controller)\n        external\n        payable\n        protected\n    {\n        _canClaim(vault, receiver, controller);\n        vault.claimCancelRedeemRequest(REQUEST_ID, receiver, controller);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-20 permits & wrapping\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function permit(address asset, address spender, uint256 assets, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        payable\n        protected\n    {\n        try IERC20Permit(asset).permit(msg.sender, spender, assets, deadline, v, r, s) {} catch {}\n    }\n\n    function wrap(address wrapper, uint256 amount, address receiver, address owner) public payable protected {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        address underlying = IERC20Wrapper(wrapper).underlying();\n\n        amount = MathLib.min(amount, IERC20(underlying).balanceOf(owner));\n        require(amount != 0, ZeroBalance());\n        SafeTransferLib.safeTransferFrom(underlying, owner, address(this), amount);\n\n        _approveMax(underlying, wrapper);\n        require(IERC20Wrapper(wrapper).depositFor(receiver, amount), WrapFailed());\n    }\n\n    function unwrap(address wrapper, uint256 amount, address receiver) public payable protected {\n        amount = MathLib.min(amount, IERC20(wrapper).balanceOf(address(this)));\n        require(amount != 0, ZeroBalance());\n\n        require(IERC20Wrapper(wrapper).withdrawTo(receiver, amount), UnwrapFailed());\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function getVault(PoolId poolId, ShareClassId scId, address asset) external view returns (address) {\n        return IPoolManager(poolManager).shareToken(poolId, scId).vault(asset);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256) {\n        return messageDispatcher.estimate(centrifugeId, payload);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function hasPermissions(IBaseVault vault, address controller) external view returns (bool) {\n        return vault.isPermissioned(controller);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function isEnabled(IBaseVault vault, address controller) public view returns (bool) {\n        return vault.isOperator(controller, address(this));\n    }\n\n    /// @notice Gives the max approval to `to` for spending the given `asset` if not already approved.\n    /// @dev    Assumes that `type(uint256).max` is large enough to never have to increase the allowance again.\n    function _approveMax(address asset, address spender) internal {\n        if (IERC20(asset).allowance(address(this), spender) == 0) {\n            SafeTransferLib.safeApprove(asset, spender, type(uint256).max);\n        }\n    }\n\n    /// @notice Send native tokens to the gateway for transaction payment if it's not in a multicall.\n    function _pay() internal {\n        if (!gateway.isBatching()) {\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n    }\n\n    /// @notice Ensures msg.sender is either the controller, or can permissionlessly claim\n    ///         on behalf of the controller.\n    function _canClaim(IBaseVault vault, address receiver, address controller) internal view {\n        require(controller == msg.sender || (controller == receiver && isEnabled(vault, controller)), InvalidSender());\n    }\n}\n"
    }
}