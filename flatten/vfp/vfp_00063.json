{
    "vfp_id": "vfp_00063",
    "project_name": "2025-01-bacon-labs-bunniv2-securityreview.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Dirty bits of narrow types are not cleaned",
            "description": "The getSqrtPriceTarget function in the SwapMath library uses uint160 parameters directly in assembly without clearing their higher-order bits. Solidity does not guarantee the state of unused bits in types smaller than 256 bits.\n\nThe cause is the direct use of sqrtPriceNextX96 and sqrtPriceLimitX96 in Yul assembly without masking to 160 bits. This differs from the updated Uniswap v4 implementation, which clears higher bits for safety.\n\nAn attacker could exploit this by crafting inputs with dirty upper bits that alter the arithmetic result in the assembly block, potentially leading to incorrect price calculations during swaps.\n\nThe impact could include incorrect swap execution prices, leading to loss of funds for users or the pool due to miscalculated amounts. This is particularly dangerous in price-sensitive operations.\n",
            "severity": "Informational",
            "location": [
                "src/lib/SwapMath.sol",
                "src/lib/SwapMath.sol#L19-L34"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/lib/SwapMath.sol"
            ]
        }
    ],
    "affected_files": {
        "SwapMath.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"@uniswap/v4-core/src/libraries/FullMath.sol\";\n\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    uint256 internal constant MAX_FEE_PIPS = 1e6;\n\n    /// @notice Computes the sqrt price target for the next swap step\n    /// @param zeroForOne The direction of the swap, true for currency0 to currency1, false for currency1 to currency0\n    /// @param sqrtPriceNextX96 The Q64.96 sqrt price for the next initialized tick\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value\n    /// after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @return sqrtPriceTargetX96 The price target for the next swap step\n    function getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160 sqrtPriceLimitX96)\n        internal\n        pure\n        returns (uint160 sqrtPriceTargetX96)\n    {\n        assembly {\n            // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n            // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >= sqrtPriceLimitX96\n            // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n            // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 < sqrtPriceLimitX96\n            // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n            let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), zeroForOne)\n            let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n            sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n        }\n    }\n\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev If the swap's amountSpecified is negative, the combined fee and input amount will never exceed the absolute value of the remaining amount.\n    /// @param sqrtPriceCurrentX96 The current sqrt price of the pool\n    /// @param sqrtPriceTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @return sqrtPriceNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    function computeSwapStep(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceTargetX96,\n        uint256 liquidity,\n        int256 amountRemaining\n    ) internal pure returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut) {\n        unchecked {\n            bool zeroForOne = sqrtPriceCurrentX96 >= sqrtPriceTargetX96;\n            bool exactIn = amountRemaining < 0;\n\n            if (exactIn) {\n                uint256 amountRemainingAbs = uint256(-amountRemaining);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtPriceTargetX96, sqrtPriceCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity, true);\n                if (amountRemainingAbs >= amountIn) {\n                    // `amountIn` is capped by the target price\n                    sqrtPriceNextX96 = sqrtPriceTargetX96;\n                } else {\n                    sqrtPriceNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtPriceCurrentX96, liquidity, amountRemainingAbs, zeroForOne\n                    );\n                    amountIn = zeroForOne\n                        ? SqrtPriceMath.getAmount0Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, true)\n                        : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, true);\n                }\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, false);\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtPriceTargetX96, sqrtPriceCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity, false);\n                if (uint256(amountRemaining) >= amountOut) {\n                    // `amountOut` is capped by the target price\n                    sqrtPriceNextX96 = sqrtPriceTargetX96;\n                } else {\n                    // cap the output amount to not exceed the remaining output amount\n                    amountOut = uint256(amountRemaining);\n                    sqrtPriceNextX96 =\n                        SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtPriceCurrentX96, liquidity, amountOut, zeroForOne);\n                }\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, true);\n            }\n        }\n    }\n}\n"
    }
}