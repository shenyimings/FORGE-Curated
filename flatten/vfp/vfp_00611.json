{
    "vfp_id": "vfp_00611",
    "project_name": "Filecoin Services Payments - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Infinite array could lead to out-of-gas issues",
            "description": "The `payerRails` and `payeeRails` mappings in the Payments contract store arrays of rail IDs that grow indefinitely as new rails are created, with no mechanism to remove or prune entries. This design causes the `getRailsForPayerAndToken` and similar functions to iterate over the entire array, skipping non-existent rails, which consumes gas proportional to the array length. The root cause is the lack of array cleanup or pagination, leading to unbounded growth. An attacker could exploit this by creating and terminating many rails to bloat the array, making the view function increasingly expensive to call. While the function is external and view-only, calling it within a transaction could lead to out-of-gas failures, rendering the function unusable for clients or interfaces that depend on it, especially as the array grows over time.\n",
            "severity": "Low",
            "location": [
                "Payments.sol::getRailsForPayerAndToken",
                "Payments.sol::_getRailsForAddressAndToken"
            ],
            "files": [
                "filecoin-pay/src/Payments.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused mapping hasCollectedFees in Payments",
            "description": "The `hasCollectedFees` mapping in the Payments contract is declared but never read from or written to anywhere in the codebase, making it dead state. The root cause is likely leftover code from a previous design that was not fully removed during refactoring. While this does not introduce any direct security risk or functional flaw, it reduces code clarity and increases contract size unnecessarily. An attacker cannot exploit this directly, but the presence of unused code can mislead auditors and developers, potentially leading to incorrect assumptions about the contract's behavior. The impact is limited to maintainability and code quality.\n",
            "severity": "Informational",
            "location": [
                "Payments.sol::hasCollectedFees"
            ],
            "files": [
                "filecoin-pay/src/Payments.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Documentation inconsistencies",
            "description": "The JSDoc comment for the `settleTerminatedRailWithoutValidation` function incorrectly states that it can only be called by the payee, when in fact it is intended as an emergency function for the client or payer to unblock payments in a stuck rail. The root cause is a mismatch between the implementation and its documentation, likely due to a copy-paste error or oversight during development. This could mislead developers or front-end engineers into implementing incorrect access control assumptions, potentially exposing the function in a UI where it should not be available. While the function itself is correctly implemented and secure, the incorrect documentation could lead to operational errors or misuse in integrations, reducing the overall reliability of the system.\n",
            "severity": "Informational",
            "location": [
                "Payments.sol::settleTerminatedRailWithoutValidation"
            ],
            "files": [
                "filecoin-pay/src/Payments.sol"
            ]
        }
    ],
    "affected_files": {
        "Payments.sol": "// SPDX-License-Identifier: Apache-2.0 OR MIT\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./Errors.sol\";\nimport \"./RateChangeQueue.sol\";\n\ninterface IValidator {\n    struct ValidationResult {\n        // The actual payment amount determined by the validator after validation of a rail during settlement\n        uint256 modifiedAmount;\n        // The epoch up to and including which settlement should occur.\n        uint256 settleUpto;\n        // A placeholder note for any additional information the validator wants to send to the caller of `settleRail`\n        string note;\n    }\n\n    function validatePayment(\n        uint256 railId,\n        uint256 proposedAmount,\n        // the epoch up to and including which the rail has already been settled\n        uint256 fromEpoch,\n        // the epoch up to and including which validation is requested; payment will be validated for (toEpoch - fromEpoch) epochs\n        uint256 toEpoch,\n        uint256 rate\n    ) external returns (ValidationResult memory result);\n\n    function railTerminated(uint256 railId, address terminator, uint256 endEpoch) external;\n}\n\n// @title Payments contract.\ncontract Payments is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using RateChangeQueue for RateChangeQueue.Queue;\n\n    // Maximum commission rate in basis points (100% = 10000 BPS)\n    uint256 public constant COMMISSION_MAX_BPS = 10000;\n\n    uint256 public constant NETWORK_FEE = 1300000 gwei; // equivalent to 130000 nFIL\n    address payable private constant BURN_ADDRESS = payable(0xff00000000000000000000000000000000000063);\n\n    // Events\n    event AccountLockupSettled(\n        address indexed token,\n        address indexed owner,\n        uint256 lockupCurrent,\n        uint256 lockupRate,\n        uint256 lockupLastSettledAt\n    );\n    event OperatorApprovalUpdated(\n        address indexed token,\n        address indexed client,\n        address indexed operator,\n        bool approved,\n        uint256 rateAllowance,\n        uint256 lockupAllowance,\n        uint256 maxLockupPeriod\n    );\n\n    event RailCreated(\n        uint256 indexed railId,\n        address indexed payer,\n        address indexed payee,\n        address token,\n        address operator,\n        address validator,\n        address serviceFeeRecipient,\n        uint256 commissionRateBps\n    );\n    event RailLockupModified(\n        uint256 indexed railId,\n        uint256 oldLockupPeriod,\n        uint256 newLockupPeriod,\n        uint256 oldLockupFixed,\n        uint256 newLockupFixed\n    );\n    event RailOneTimePaymentProcessed(uint256 indexed railId, uint256 netPayeeAmount, uint256 operatorCommission);\n    event RailRateModified(uint256 indexed railId, uint256 oldRate, uint256 newRate);\n    event RailSettled(\n        uint256 indexed railId,\n        uint256 totalSettledAmount,\n        uint256 totalNetPayeeAmount,\n        uint256 operatorCommission,\n        uint256 settledUpTo\n    );\n    event RailTerminated(uint256 indexed railId, address indexed by, uint256 endEpoch);\n    event RailFinalized(uint256 indexed railId);\n\n    event DepositRecorded(\n        address indexed token, address indexed from, address indexed to, uint256 amount, bool usedPermit\n    );\n    event WithdrawRecorded(address indexed token, address indexed from, address indexed to, uint256 amount);\n\n    struct Account {\n        uint256 funds;\n        uint256 lockupCurrent;\n        uint256 lockupRate;\n        // epoch up to and including which lockup has been settled for the account\n        uint256 lockupLastSettledAt;\n    }\n\n    struct Rail {\n        address token;\n        address from;\n        address to;\n        address operator;\n        address validator;\n        uint256 paymentRate;\n        uint256 lockupPeriod;\n        uint256 lockupFixed;\n        // epoch up to and including which this rail has been settled\n        uint256 settledUpTo;\n        RateChangeQueue.Queue rateChangeQueue;\n        uint256 endEpoch; // Final epoch up to which the rail can be settled (0 if not terminated)\n        // Operator commission rate in basis points (e.g., 100 BPS = 1%)\n        uint256 commissionRateBps;\n        address serviceFeeRecipient; // address to collect operator comission\n    }\n\n    struct OperatorApproval {\n        bool isApproved;\n        uint256 rateAllowance;\n        uint256 lockupAllowance;\n        uint256 rateUsage; // Track actual usage for rate\n        uint256 lockupUsage; // Track actual usage for lockup\n        uint256 maxLockupPeriod; // Maximum lockup period the operator can set for rails created on behalf of the client\n    }\n\n    // Counter for generating unique rail IDs\n    uint256 private _nextRailId = 1;\n\n    // token => owner => Account\n    mapping(address => mapping(address => Account)) public accounts;\n\n    // railId => Rail\n    mapping(uint256 => Rail) internal rails;\n\n    // Struct to hold rail data without the RateChangeQueue (for external returns)\n    struct RailView {\n        address token;\n        address from;\n        address to;\n        address operator;\n        address validator;\n        uint256 paymentRate;\n        uint256 lockupPeriod;\n        uint256 lockupFixed;\n        uint256 settledUpTo;\n        uint256 endEpoch;\n        // Operator commission rate in basis points (e.g., 100 BPS = 1%)\n        uint256 commissionRateBps;\n        address serviceFeeRecipient; // address to collect operator commission\n    }\n\n    // token => client => operator => Approval\n    mapping(address => mapping(address => mapping(address => OperatorApproval))) public operatorApprovals;\n\n    // Define a struct for rails by payee information\n    struct RailInfo {\n        uint256 railId; // The rail ID\n        bool isTerminated; // True if rail is terminated\n        uint256 endEpoch; // End epoch for terminated rails (0 for active rails)\n    }\n\n    // token => payee => array of railIds\n    mapping(address => mapping(address => uint256[])) private payeeRails;\n\n    // token => payer => array of railIds\n    mapping(address => mapping(address => uint256[])) private payerRails;\n\n    // Tracks whether a token has ever had fees collected, to prevent duplicates in feeTokens\n    mapping(address => bool) public hasCollectedFees;\n\n    struct SettlementState {\n        uint256 totalSettledAmount;\n        uint256 totalNetPayeeAmount;\n        uint256 totalOperatorCommission;\n        uint256 processedEpoch;\n        string note;\n    }\n\n    constructor() ReentrancyGuard() {\n        _nextRailId = 1;\n    }\n\n    modifier validateRailActive(uint256 railId) {\n        require(rails[railId].from != address(0), Errors.RailInactiveOrSettled(railId));\n        _;\n    }\n\n    modifier onlyRailClient(uint256 railId) {\n        require(rails[railId].from == msg.sender, Errors.OnlyRailClientAllowed(rails[railId].from, msg.sender));\n        _;\n    }\n\n    modifier onlyRailOperator(uint256 railId) {\n        require(\n            rails[railId].operator == msg.sender, Errors.OnlyRailOperatorAllowed(rails[railId].operator, msg.sender)\n        );\n        _;\n    }\n\n    modifier onlyRailParticipant(uint256 railId) {\n        require(\n            rails[railId].from == msg.sender || rails[railId].operator == msg.sender || rails[railId].to == msg.sender,\n            Errors.OnlyRailParticipantAllowed(rails[railId].from, rails[railId].operator, rails[railId].to, msg.sender)\n        );\n        _;\n    }\n\n    modifier validateRailNotTerminated(uint256 railId) {\n        require(rails[railId].endEpoch == 0, Errors.RailAlreadyTerminated(railId));\n        _;\n    }\n\n    modifier validateRailTerminated(uint256 railId) {\n        require(isRailTerminated(rails[railId], railId), Errors.RailNotTerminated(railId));\n        _;\n    }\n\n    modifier validateNonZeroAddress(address addr, string memory varName) {\n        require(addr != address(0), Errors.ZeroAddressNotAllowed(varName));\n        _;\n    }\n\n    modifier validatePermitRecipient(address to) {\n        require(to == msg.sender, Errors.PermitRecipientMustBeMsgSender(msg.sender, to));\n        _;\n    }\n\n    modifier settleAccountLockupBeforeAndAfter(address token, address owner, bool settleFull) {\n        Account storage payer = accounts[token][owner];\n\n        // Before function execution\n        performSettlementCheck(token, owner, payer, settleFull, true);\n\n        _;\n\n        // After function execution\n        performSettlementCheck(token, owner, payer, settleFull, false);\n    }\n\n    modifier settleAccountLockupBeforeAndAfterForRail(uint256 railId, bool settleFull, uint256 oneTimePayment) {\n        Rail storage rail = rails[railId];\n\n        require(rail.from != address(0), Errors.RailInactiveOrSettled(railId));\n\n        Account storage payer = accounts[rail.token][rail.from];\n\n        require(\n            rail.lockupFixed >= oneTimePayment,\n            Errors.OneTimePaymentExceedsLockup(railId, rail.lockupFixed, oneTimePayment)\n        );\n\n        // Before function execution\n        performSettlementCheck(rail.token, rail.from, payer, settleFull, true);\n\n        // ---- EXECUTE FUNCTION\n        _;\n        // ---- FUNCTION EXECUTION COMPLETE\n\n        // After function execution\n        performSettlementCheck(rail.token, rail.from, payer, settleFull, false);\n    }\n\n    function performSettlementCheck(address token, address owner, Account storage payer, bool settleFull, bool isBefore)\n        internal\n    {\n        require(\n            payer.funds >= payer.lockupCurrent,\n            isBefore\n                ? \"invariant failure: insufficient funds to cover lockup before function execution\"\n                : \"invariant failure: insufficient funds to cover lockup after function execution\"\n        );\n\n        settleAccountLockup(token, owner, payer);\n\n        // Verify full settlement if required\n        // TODO: give the user feedback on what they need to deposit in their account to complete the operation.\n        require(\n            !settleFull || isAccountLockupFullySettled(payer),\n            isBefore\n                ? \"payers's full account lockup was not met as a precondition of the requested operation\"\n                : \"payers's full account lockup was not met as a postcondition of the requested operation\"\n        );\n\n        require(\n            payer.funds >= payer.lockupCurrent,\n            isBefore\n                ? \"invariant failure: insufficient funds to cover lockup before function execution\"\n                : \"invariant failure: insufficient funds to cover lockup after function execution\"\n        );\n    }\n\n    /// @notice Gets the current state of the target rail or reverts if the rail isn't active.\n    /// @param railId the ID of the rail.\n    function getRail(uint256 railId) external view validateRailActive(railId) returns (RailView memory) {\n        Rail storage rail = rails[railId];\n        return RailView({\n            token: rail.token,\n            from: rail.from,\n            to: rail.to,\n            operator: rail.operator,\n            validator: rail.validator,\n            paymentRate: rail.paymentRate,\n            lockupPeriod: rail.lockupPeriod,\n            lockupFixed: rail.lockupFixed,\n            settledUpTo: rail.settledUpTo,\n            endEpoch: rail.endEpoch,\n            commissionRateBps: rail.commissionRateBps,\n            serviceFeeRecipient: rail.serviceFeeRecipient\n        });\n    }\n\n    /// @notice Updates the approval status and allowances for an operator on behalf of the message sender.\n    /// @param token The ERC20 token address for which the approval is being set.\n    /// @param operator The address of the operator whose approval is being modified.\n    /// @param approved Whether the operator is approved (true) or not (false) to create new rails.\n    /// @param rateAllowance The maximum payment rate the operator can set across all rails created by the operator on behalf of the message sender. If this is less than the current payment rate, the operator will only be able to reduce rates until they fall below the target.\n    /// @param lockupAllowance The maximum amount of funds the operator can lock up on behalf of the message sender towards future payments. If this exceeds the current total amount of funds locked towards future payments, the operator will only be able to reduce future lockup.\n    /// @param maxLockupPeriod The maximum number of epochs (blocks) the operator can lock funds for. If this is less than the current lockup period for a rail, the operator will only be able to reduce the lockup period.\n    function setOperatorApproval(\n        address token,\n        address operator,\n        bool approved,\n        uint256 rateAllowance,\n        uint256 lockupAllowance,\n        uint256 maxLockupPeriod\n    ) external nonReentrant validateNonZeroAddress(operator, \"operator\") {\n        _setOperatorApproval(token, operator, approved, rateAllowance, lockupAllowance, maxLockupPeriod);\n    }\n\n    function _setOperatorApproval(\n        address token,\n        address operator,\n        bool approved,\n        uint256 rateAllowance,\n        uint256 lockupAllowance,\n        uint256 maxLockupPeriod\n    ) internal {\n        OperatorApproval storage approval = operatorApprovals[token][msg.sender][operator];\n\n        // Update approval status and allowances\n        approval.isApproved = approved;\n        approval.rateAllowance = rateAllowance;\n        approval.lockupAllowance = lockupAllowance;\n        approval.maxLockupPeriod = maxLockupPeriod;\n\n        emit OperatorApprovalUpdated(\n            token, msg.sender, operator, approved, rateAllowance, lockupAllowance, maxLockupPeriod\n        );\n    }\n\n    /// @notice Increases the rate and lockup allowances for an existing operator approval.\n    /// @param token The ERC20 token address for which the approval is being increased.\n    /// @param operator The address of the operator whose allowances are being increased.\n    /// @param rateAllowanceIncrease The amount to increase the rate allowance by.\n    /// @param lockupAllowanceIncrease The amount to increase the lockup allowance by.\n    /// @custom:constraint Operator must already be approved.\n    function increaseOperatorApproval(\n        address token,\n        address operator,\n        uint256 rateAllowanceIncrease,\n        uint256 lockupAllowanceIncrease\n    ) external nonReentrant validateNonZeroAddress(operator, \"operator\") {\n        _increaseOperatorApproval(token, operator, rateAllowanceIncrease, lockupAllowanceIncrease);\n    }\n\n    function _increaseOperatorApproval(\n        address token,\n        address operator,\n        uint256 rateAllowanceIncrease,\n        uint256 lockupAllowanceIncrease\n    ) internal {\n        OperatorApproval storage approval = operatorApprovals[token][msg.sender][operator];\n\n        // Operator must already be approved\n        require(approval.isApproved, Errors.OperatorNotApproved(msg.sender, operator));\n\n        // Directly update allowances\n        approval.rateAllowance += rateAllowanceIncrease;\n        approval.lockupAllowance += lockupAllowanceIncrease;\n\n        emit OperatorApprovalUpdated(\n            token,\n            msg.sender,\n            operator,\n            approval.isApproved,\n            approval.rateAllowance,\n            approval.lockupAllowance,\n            approval.maxLockupPeriod\n        );\n    }\n\n    /// @notice Terminates a payment rail, preventing further payments after the rail's lockup period. After calling this method, the lockup period cannot be changed, and the rail's rate and fixed lockup may only be reduced.\n    /// @param railId The ID of the rail to terminate.\n    /// @custom:constraint Caller must be a rail client or operator.\n    /// @custom:constraint Rail must be active and not already terminated.\n    /// @custom:constraint If called by the client, the payer's account must be fully funded.\n    /// @custom:constraint If called by the operator, the payer's funding status isn't checked.\n    function terminateRail(uint256 railId)\n        external\n        validateRailActive(railId)\n        nonReentrant\n        validateRailNotTerminated(railId)\n        settleAccountLockupBeforeAndAfterForRail(railId, false, 0)\n    {\n        Rail storage rail = rails[railId];\n        Account storage payer = accounts[rail.token][rail.from];\n\n        // Only client with fully settled lockup or operator can terminate a rail\n        require(\n            (msg.sender == rail.from && isAccountLockupFullySettled(payer)) || msg.sender == rail.operator,\n            Errors.NotAuthorizedToTerminateRail(railId, rail.from, rail.operator, msg.sender)\n        );\n\n        rail.endEpoch = payer.lockupLastSettledAt + rail.lockupPeriod;\n\n        emit RailTerminated(railId, msg.sender, rail.endEpoch);\n\n        // Notify the validator if one exists\n        if (rail.validator != address(0)) {\n            IValidator(rail.validator).railTerminated(railId, msg.sender, rail.endEpoch);\n        }\n\n        // Remove the rail rate from account lockup rate but don't set rail rate to zero yet.\n        // The rail rate will be used to settle the rail and so we can't zero it yet.\n        // However, we remove the rail rate from the client lockup rate because we don't want to\n        // lock funds for the rail beyond `rail.endEpoch` as we're exiting the rail\n        // after that epoch.\n        require(\n            payer.lockupRate >= rail.paymentRate,\n            Errors.LockupRateInconsistent(railId, rail.from, rail.paymentRate, payer.lockupRate)\n        );\n        payer.lockupRate -= rail.paymentRate;\n\n        // Reduce operator rate allowance\n        OperatorApproval storage operatorApproval = operatorApprovals[rail.token][rail.from][rail.operator];\n        updateOperatorRateUsage(operatorApproval, rail.paymentRate, 0);\n    }\n\n    /// @notice Deposits tokens from the message sender's account into `to`'s account.\n    /// @param token The ERC20 token address to deposit.\n    /// @param to The address whose account will be credited.\n    /// @param amount The amount of tokens to deposit.\n    /// @custom:constraint The message sender must have approved this contract to spend the requested amount via the ERC-20 token (`token`).\n    function deposit(address token, address to, uint256 amount)\n        external\n        payable\n        nonReentrant\n        validateNonZeroAddress(to, \"to\")\n        settleAccountLockupBeforeAndAfter(token, to, false)\n    {\n        // Create account if it doesn't exist\n        Account storage account = accounts[token][to];\n\n        uint256 actualAmount;\n\n        // Transfer tokens from sender to contract\n        if (token == address(0)) {\n            require(msg.value == amount, Errors.MustSendExactNativeAmount(amount, msg.value));\n            actualAmount = amount;\n        } else {\n            require(msg.value == 0, Errors.NativeTokenNotAccepted(msg.value));\n\n            // Use balance-before/balance-after accounting for fee-on-transfer tokens\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n\n            actualAmount = balanceAfter - balanceBefore;\n        }\n\n        account.funds += actualAmount;\n\n        emit DepositRecorded(token, msg.sender, to, actualAmount, false);\n    }\n\n    /**\n     * @notice Deposits tokens using permit (EIP-2612) approval in a single transaction.\n     * @param token The ERC20 token address to deposit.\n     * @param to The address whose account will be credited (must be the permit signer).\n     * @param amount The amount of tokens to deposit.\n     * @param deadline Permit deadline (timestamp).\n     * @param v,r,s Permit signature.\n     */\n    function depositWithPermit(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        nonReentrant\n        validateNonZeroAddress(to, \"to\")\n        validatePermitRecipient(to)\n        settleAccountLockupBeforeAndAfter(token, to, false)\n    {\n        _depositWithPermit(token, to, amount, deadline, v, r, s);\n    }\n\n    function _depositWithPermit(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        // Revert if token is address(0) as permit is not supported for native tokens\n        require(token != address(0), Errors.NativeTokenNotSupported());\n\n        // Use 'to' as the owner in permit call (the address that signed the permit)\n        IERC20Permit(token).permit(to, address(this), amount, deadline, v, r, s);\n\n        Account storage account = accounts[token][to];\n\n        // Use balance-before/balance-after accounting for fee-on-transfer tokens\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(to, address(this), amount);\n        uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n\n        uint256 actualAmount = balanceAfter - balanceBefore;\n\n        account.funds += actualAmount;\n\n        emit DepositRecorded(token, to, to, actualAmount, true);\n    }\n\n    /**\n     * @notice Deposits tokens using permit (EIP-2612) approval in a single transaction,\n     *         while also setting operator approval.\n     * @param token The ERC20 token address to deposit and for which the operator approval is being set.\n     *             Note: The token must support EIP-2612 permit functionality.\n     * @param to The address whose account will be credited (must be the permit signer).\n     * @param amount The amount of tokens to deposit.\n     * @param deadline Permit deadline (timestamp).\n     * @param v,r,s Permit signature.\n     * @param operator The address of the operator whose approval is being modified.\n     * @param rateAllowance The maximum payment rate the operator can set across all rails created by the operator\n     *             on behalf of the message sender. If this is less than the current payment rate, the operator will\n     *             only be able to reduce rates until they fall below the target.\n     * @param lockupAllowance The maximum amount of funds the operator can lock up on behalf of the message sender\n     *             towards future payments. If this exceeds the current total amount of funds locked towards future payments,\n     *             the operator will only be able to reduce future lockup.\n     * @param maxLockupPeriod The maximum number of epochs (blocks) the operator can lock funds for. If this is less than\n     *             the current lockup period for a rail, the operator will only be able to reduce the lockup period.\n     */\n    function depositWithPermitAndApproveOperator(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address operator,\n        uint256 rateAllowance,\n        uint256 lockupAllowance,\n        uint256 maxLockupPeriod\n    )\n        external\n        nonReentrant\n        validateNonZeroAddress(operator, \"operator\")\n        validateNonZeroAddress(to, \"to\")\n        validatePermitRecipient(to)\n        settleAccountLockupBeforeAndAfter(token, to, false)\n    {\n        _setOperatorApproval(token, operator, true, rateAllowance, lockupAllowance, maxLockupPeriod);\n        _depositWithPermit(token, to, amount, deadline, v, r, s);\n    }\n\n    /**\n     * @notice Deposits tokens using permit (EIP-2612) approval in a single transaction,\n     *         while also increasing operator approval allowances.\n     * @param token The ERC20 token address to deposit and for which the operator approval is being increased.\n     *             Note: The token must support EIP-2612 permit functionality.\n     * @param to The address whose account will be credited (must be the permit signer).\n     * @param amount The amount of tokens to deposit.\n     * @param deadline Permit deadline (timestamp).\n     * @param v,r,s Permit signature.\n     * @param operator The address of the operator whose allowances are being increased.\n     * @param rateAllowanceIncrease The amount to increase the rate allowance by.\n     * @param lockupAllowanceIncrease The amount to increase the lockup allowance by.\n     * @custom:constraint Operator must already be approved.\n     */\n    function depositWithPermitAndIncreaseOperatorApproval(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address operator,\n        uint256 rateAllowanceIncrease,\n        uint256 lockupAllowanceIncrease\n    )\n        external\n        nonReentrant\n        validateNonZeroAddress(operator, \"operator\")\n        validateNonZeroAddress(to, \"to\")\n        validatePermitRecipient(to)\n        settleAccountLockupBeforeAndAfter(token, to, false)\n    {\n        _increaseOperatorApproval(token, operator, rateAllowanceIncrease, lockupAllowanceIncrease);\n        _depositWithPermit(token, to, amount, deadline, v, r, s);\n    }\n\n    /// @notice Withdraws tokens from the caller's account to the caller's account, up to the amount of currently available tokens (the tokens not currently locked in rails).\n    /// @param token The ERC20 token address to withdraw.\n    /// @param amount The amount of tokens to withdraw.\n    function withdraw(address token, uint256 amount)\n        external\n        nonReentrant\n        settleAccountLockupBeforeAndAfter(token, msg.sender, true)\n    {\n        return withdrawToInternal(token, msg.sender, amount);\n    }\n\n    /// @notice Withdraws tokens (`token`) from the caller's account to `to`, up to the amount of currently available tokens (the tokens not currently locked in rails).\n    /// @param token The ERC20 token address to withdraw.\n    /// @param to The address to receive the withdrawn tokens.\n    /// @param amount The amount of tokens to withdraw.\n    function withdrawTo(address token, address to, uint256 amount)\n        external\n        nonReentrant\n        validateNonZeroAddress(to, \"to\")\n        settleAccountLockupBeforeAndAfter(token, msg.sender, true)\n    {\n        return withdrawToInternal(token, to, amount);\n    }\n\n    function withdrawToInternal(address token, address to, uint256 amount) internal {\n        Account storage account = accounts[token][msg.sender];\n        uint256 available = account.funds - account.lockupCurrent;\n        require(amount <= available, Errors.InsufficientUnlockedFunds(available, amount));\n        account.funds -= amount;\n        if (token == address(0)) {\n            (bool success,) = payable(to).call{value: amount}(\"\");\n            require(success, Errors.NativeTransferFailed(to, amount));\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n\n        emit WithdrawRecorded(token, msg.sender, to, amount);\n    }\n\n    /// @notice Create a new rail from `from` to `to`, operated by the caller.\n    /// @param token The ERC20 token address for payments on this rail.\n    /// @param from The client address (payer) for this rail.\n    /// @param to The recipient address for payments on this rail.\n    /// @param validator Optional address of an validator contract (can be address(0) for no validation).\n    /// @param commissionRateBps Optional operator commission in basis points (0-10000).\n    /// @param serviceFeeRecipient Address to receive operator commission\n    /// @return The ID of the newly created rail.\n    /// @custom:constraint Caller must be approved as an operator by the client (from address).\n    function createRail(\n        address token,\n        address from,\n        address to,\n        address validator,\n        uint256 commissionRateBps,\n        address serviceFeeRecipient\n    ) external nonReentrant validateNonZeroAddress(from, \"from\") validateNonZeroAddress(to, \"to\") returns (uint256) {\n        address operator = msg.sender;\n\n        // Check if operator is approved - approval is required for rail creation\n        OperatorApproval storage approval = operatorApprovals[token][from][operator];\n        require(approval.isApproved, Errors.OperatorNotApproved(from, operator));\n\n        // Validate commission rate\n        require(\n            commissionRateBps <= COMMISSION_MAX_BPS, Errors.CommissionRateTooHigh(COMMISSION_MAX_BPS, commissionRateBps)\n        );\n\n        require(commissionRateBps == 0 || serviceFeeRecipient != address(0), Errors.MissingServiceFeeRecipient());\n\n        uint256 railId = _nextRailId++;\n\n        Rail storage rail = rails[railId];\n        rail.token = token;\n        rail.from = from;\n        rail.to = to;\n        rail.operator = operator;\n        rail.validator = validator;\n        rail.settledUpTo = block.number;\n        rail.endEpoch = 0;\n        rail.commissionRateBps = commissionRateBps;\n        rail.serviceFeeRecipient = serviceFeeRecipient;\n\n        // Record this rail in the payee's and payer's lists\n        payeeRails[token][to].push(railId);\n        payerRails[token][from].push(railId);\n\n        emit RailCreated(railId, from, to, token, operator, validator, serviceFeeRecipient, commissionRateBps);\n\n        return railId;\n    }\n\n    /// @notice Modifies the fixed lockup and lockup period of a rail.\n    /// - If the rail has already been terminated, the lockup period may not be altered and the fixed lockup may only be reduced.\n    /// - If the rail is active, the lockup may only be modified if the payer's account is fully funded and will remain fully funded after the operation.\n    /// @param railId The ID of the rail to modify.\n    /// @param period The new lockup period (in epochs/blocks).\n    /// @param lockupFixed The new fixed lockup amount.\n    /// @custom:constraint Caller must be the rail operator.\n    /// @custom:constraint Operator must have sufficient lockup allowance to cover any increases the lockup period or the fixed lockup.\n    function modifyRailLockup(uint256 railId, uint256 period, uint256 lockupFixed)\n        external\n        validateRailActive(railId)\n        onlyRailOperator(railId)\n        nonReentrant\n        settleAccountLockupBeforeAndAfterForRail(railId, false, 0)\n    {\n        Rail storage rail = rails[railId];\n        bool isTerminated = isRailTerminated(rail, railId);\n\n        uint256 oldLockupPeriod = rail.lockupPeriod;\n        uint256 oldLockupFixed = rail.lockupFixed;\n\n        if (isTerminated) {\n            modifyTerminatedRailLockup(rail, period, lockupFixed);\n        } else {\n            modifyNonTerminatedRailLockup(rail, period, lockupFixed);\n        }\n\n        emit RailLockupModified(railId, oldLockupPeriod, period, oldLockupFixed, lockupFixed);\n    }\n\n    function modifyTerminatedRailLockup(Rail storage rail, uint256 period, uint256 lockupFixed) internal {\n        require(\n            period == rail.lockupPeriod && lockupFixed <= rail.lockupFixed,\n            Errors.InvalidTerminatedRailModification(rail.lockupPeriod, rail.lockupFixed, period, lockupFixed)\n        );\n\n        Account storage payer = accounts[rail.token][rail.from];\n\n        // Calculate the fixed lockup reduction - this is the only change allowed for terminated rails\n        uint256 lockupReduction = rail.lockupFixed - lockupFixed;\n\n        // Update payer's lockup - subtract the exact reduction amount\n        require(\n            payer.lockupCurrent >= lockupReduction,\n            Errors.InsufficientCurrentLockup(rail.token, rail.from, payer.lockupCurrent, lockupReduction)\n        );\n        payer.lockupCurrent -= lockupReduction;\n\n        // Reduce operator rate allowance\n        OperatorApproval storage operatorApproval = operatorApprovals[rail.token][rail.from][rail.operator];\n        updateOperatorLockupUsage(operatorApproval, rail.lockupFixed, lockupFixed);\n\n        rail.lockupFixed = lockupFixed;\n    }\n\n    function modifyNonTerminatedRailLockup(Rail storage rail, uint256 period, uint256 lockupFixed) internal {\n        Account storage payer = accounts[rail.token][rail.from];\n\n        // Don't allow changing the lockup period or increasing the fixed lockup unless the payer's\n        // account is fully settled.\n        if (!isAccountLockupFullySettled(payer)) {\n            require(\n                period == rail.lockupPeriod,\n                Errors.LockupPeriodChangeNotAllowedDueToInsufficientFunds(\n                    rail.token, rail.from, rail.lockupPeriod, period\n                )\n            );\n\n            require(\n                lockupFixed <= rail.lockupFixed,\n                Errors.LockupFixedIncreaseNotAllowedDueToInsufficientFunds(\n                    rail.token, rail.from, rail.lockupFixed, lockupFixed\n                )\n            );\n        }\n\n        // Get operator approval\n        OperatorApproval storage operatorApproval = operatorApprovals[rail.token][rail.from][rail.operator];\n\n        // Check if period exceeds the max lockup period allowed for this operator\n        // Only enforce this constraint when increasing the period, not when decreasing\n        if (period > rail.lockupPeriod) {\n            require(\n                period <= operatorApproval.maxLockupPeriod,\n                Errors.LockupPeriodExceedsOperatorMaximum(\n                    rail.token, rail.operator, operatorApproval.maxLockupPeriod, period\n                )\n            );\n        }\n\n        // Calculate current (old) lockup.\n        uint256 oldLockup = rail.lockupFixed + (rail.paymentRate * rail.lockupPeriod);\n\n        // Calculate new lockup amount with new parameters\n        uint256 newLockup = lockupFixed + (rail.paymentRate * period);\n\n        require(\n            payer.lockupCurrent >= oldLockup,\n            Errors.CurrentLockupLessThanOldLockup(rail.token, rail.from, oldLockup, payer.lockupCurrent)\n        );\n\n        // We blindly update the payer's lockup. If they don't have enough funds to cover the new\n        // amount, we'll revert in the post-condition.\n        payer.lockupCurrent = payer.lockupCurrent - oldLockup + newLockup;\n\n        updateOperatorLockupUsage(operatorApproval, oldLockup, newLockup);\n\n        // Update rail lockup parameters\n        rail.lockupPeriod = period;\n        rail.lockupFixed = lockupFixed;\n    }\n\n    /// @notice Modifies the payment rate and optionally makes a one-time payment.\n    /// - If the rail has already been terminated, one-time payments can be made and the rate may always be decreased (but never increased) regardless of the status of the payer's account.\n    /// - If the payer's account isn't fully funded and the rail is active (not terminated), the rail's payment rate may not be changed at all (increased or decreased).\n    /// - Regardless of the payer's account status, one-time payments will always go through provided that the rail has sufficient fixed lockup to cover the payment.\n    /// @param railId The ID of the rail to modify.\n    /// @param newRate The new payment rate (per epoch). This new rate applies starting the next epoch after the current one.\n    /// @param oneTimePayment Optional one-time payment amount to transfer immediately, taken out of the rail's fixed lockup.\n    /// @custom:constraint Caller must be the rail operator.\n    /// @custom:constraint Operator must have sufficient rate and lockup allowances for any increases.\n    function modifyRailPayment(uint256 railId, uint256 newRate, uint256 oneTimePayment)\n        external\n        nonReentrant\n        validateRailActive(railId)\n        onlyRailOperator(railId)\n        settleAccountLockupBeforeAndAfterForRail(railId, false, oneTimePayment)\n    {\n        Rail storage rail = rails[railId];\n        Account storage payer = accounts[rail.token][rail.from];\n        Account storage payee = accounts[rail.token][rail.to];\n\n        uint256 oldRate = rail.paymentRate;\n        bool isTerminated = isRailTerminated(rail, railId);\n\n        // Validate rate changes based on rail state and account lockup\n        if (isTerminated) {\n            uint256 maxSettlementEpoch = maxSettlementEpochForTerminatedRail(rail, railId);\n            require(\n                block.number < maxSettlementEpoch,\n                Errors.CannotModifyTerminatedRailBeyondEndEpoch(railId, maxSettlementEpoch, block.number)\n            );\n\n            require(newRate <= oldRate, Errors.RateChangeNotAllowedOnTerminatedRail(railId));\n        } else {\n            bool isSettled = isAccountLockupFullySettled(payer);\n            require(\n                isSettled || newRate == oldRate,\n                Errors.LockupNotSettledRateChangeNotAllowed(railId, rail.from, isSettled, oldRate, newRate)\n            );\n        }\n\n        // enqueuing rate change\n        enqueueRateChange(rail, oldRate, newRate);\n\n        // Calculate the effective lockup period\n        uint256 effectiveLockupPeriod;\n        if (isTerminated) {\n            effectiveLockupPeriod = remainingEpochsForTerminatedRail(rail, railId);\n        } else {\n            effectiveLockupPeriod = rail.lockupPeriod;\n        }\n\n        // Verify one-time payment doesn't exceed fixed lockup\n        require(\n            rail.lockupFixed >= oneTimePayment,\n            Errors.OneTimePaymentExceedsLockup(railId, rail.lockupFixed, oneTimePayment)\n        );\n\n        // Update the rail fixed lockup and payment rate\n        rail.lockupFixed = rail.lockupFixed - oneTimePayment;\n        rail.paymentRate = newRate;\n\n        OperatorApproval storage operatorApproval = operatorApprovals[rail.token][rail.from][rail.operator];\n\n        // Update payer's lockup rate - only if the rail is not terminated\n        // for terminated rails, the payer's lockup rate is already updated during rail termination\n        if (!isTerminated) {\n            require(\n                payer.lockupRate >= oldRate,\n                Errors.LockupRateLessThanOldRate(railId, rail.from, oldRate, payer.lockupRate)\n            );\n            payer.lockupRate = payer.lockupRate - oldRate + newRate;\n            updateOperatorRateUsage(operatorApproval, oldRate, newRate);\n        }\n\n        // Update payer's current lockup with effective lockup period calculation\n        // Remove old rate lockup for the effective period, add new rate lockup for the same period\n        payer.lockupCurrent =\n            payer.lockupCurrent - (oldRate * effectiveLockupPeriod) + (newRate * effectiveLockupPeriod) - oneTimePayment;\n\n        updateOperatorLockupUsage(operatorApproval, oldRate * effectiveLockupPeriod, newRate * effectiveLockupPeriod);\n\n        // Update operator allowance for one-time payment\n        updateOperatorAllowanceForOneTimePayment(operatorApproval, oneTimePayment);\n\n        emit RailRateModified(railId, oldRate, newRate);\n\n        // --- Process the One-Time Payment ---\n        processOneTimePayment(railId, payer, payee, rail, oneTimePayment);\n    }\n\n    function enqueueRateChange(Rail storage rail, uint256 oldRate, uint256 newRate) internal {\n        // If rate hasn't changed or rail is already settled up to current block, nothing to do\n        if (newRate == oldRate || rail.settledUpTo == block.number) {\n            return;\n        }\n\n        // Skip putting a 0-rate entry on an empty queue\n        if (oldRate == 0 && rail.rateChangeQueue.isEmpty()) {\n            rail.settledUpTo = block.number;\n            return;\n        }\n\n        // Only queue the previous rate once per epoch\n        if (rail.rateChangeQueue.isEmpty() || rail.rateChangeQueue.peekTail().untilEpoch != block.number) {\n            // For validated rails, we need to enqueue the old rate.\n            // This ensures that the old rate is applied up to and including the current block.\n            // The new rate will be applicable starting from the next block.\n            rail.rateChangeQueue.enqueue(oldRate, block.number);\n        }\n    }\n\n    function calculateAndPayFees(uint256 amount, address token, address serviceFeeRecipient, uint256 commissionRateBps)\n        internal\n        returns (uint256 netPayeeAmount, uint256 operatorCommission)\n    {\n        // Calculate operator commission (if any) based on remaining amount\n        operatorCommission = 0;\n        if (commissionRateBps > 0) {\n            operatorCommission = (amount * commissionRateBps) / COMMISSION_MAX_BPS;\n        }\n\n        // Calculate net amount for payee\n        netPayeeAmount = amount - operatorCommission;\n\n        // Credit operator (if commission exists)\n        if (operatorCommission > 0) {\n            Account storage serviceFeeRecipientAccount = accounts[token][serviceFeeRecipient];\n            serviceFeeRecipientAccount.funds += operatorCommission;\n        }\n\n        return (netPayeeAmount, operatorCommission);\n    }\n\n    function processOneTimePayment(\n        uint256 railId,\n        Account storage payer,\n        Account storage payee,\n        Rail storage rail,\n        uint256 oneTimePayment\n    ) internal {\n        if (oneTimePayment > 0) {\n            require(\n                payer.funds >= oneTimePayment,\n                Errors.InsufficientFundsForOneTimePayment(rail.token, rail.from, oneTimePayment, payer.funds)\n            );\n\n            // Transfer funds from payer (full amount)\n            payer.funds -= oneTimePayment;\n\n            // Calculate fees, pay operator commission and track platform fees\n            (uint256 netPayeeAmount, uint256 operatorCommission) =\n                calculateAndPayFees(oneTimePayment, rail.token, rail.serviceFeeRecipient, rail.commissionRateBps);\n\n            // Credit payee (net amount after fees)\n            payee.funds += netPayeeAmount;\n\n            emit RailOneTimePaymentProcessed(railId, netPayeeAmount, operatorCommission);\n        }\n    }\n\n    /// @notice Settles payments for a terminated rail without validation. This may only be called by the payee and after the terminated rail's max settlement epoch has passed. It's an escape-hatch to unblock payments in an otherwise stuck rail (e.g., due to a buggy validator contract) and it always pays in full.\n    /// @param railId The ID of the rail to settle.\n    /// @return totalSettledAmount The total amount settled and transferred.\n    /// @return totalNetPayeeAmount The net amount credited to the payee after fees.\n    /// @return totalOperatorCommission The commission credited to the operator.\n    /// @return finalSettledEpoch The epoch up to which settlement was actually completed.\n    /// @return note Additional information about the settlement.\n    function settleTerminatedRailWithoutValidation(uint256 railId)\n        external\n        nonReentrant\n        validateRailActive(railId)\n        validateRailTerminated(railId)\n        onlyRailClient(railId)\n        settleAccountLockupBeforeAndAfterForRail(railId, false, 0)\n        returns (\n            uint256 totalSettledAmount,\n            uint256 totalNetPayeeAmount,\n            uint256 totalOperatorCommission,\n            uint256 finalSettledEpoch,\n            string memory note\n        )\n    {\n        // Verify the current epoch is greater than the max settlement epoch\n        uint256 maxSettleEpoch = maxSettlementEpochForTerminatedRail(rails[railId], railId);\n        require(\n            block.number > maxSettleEpoch,\n            Errors.CannotSettleTerminatedRailBeforeMaxEpoch(railId, maxSettleEpoch + 1, block.number)\n        );\n\n        return settleRailInternal(railId, maxSettleEpoch, true);\n    }\n\n    function burnAndRefundRest(uint256 _amount) internal {\n        require(msg.value >= _amount, Errors.InsufficientNativeTokenForBurn(_amount, msg.value));\n        // f099 burn address\n        (bool success,) = BURN_ADDRESS.call{value: _amount}(\"\");\n        require(success, Errors.NativeTransferFailed(BURN_ADDRESS, _amount));\n\n        if (msg.value > _amount) {\n            uint256 refund = msg.value - _amount;\n            (success,) = msg.sender.call{value: refund}(\"\");\n            require(success, Errors.NativeTransferFailed(msg.sender, refund));\n        }\n    }\n\n    /// @notice Settles payments for a rail up to the specified epoch. Settlement may fail to reach the target epoch if either the client lacks the funds to pay up to the current epoch or the validator refuses to settle the entire requested range.\n    /// @notice In the call to this function, the caller must include NETWORK_FEE amount of native token as a fee.\n    /// @param railId The ID of the rail to settle.\n    /// @param untilEpoch The epoch up to which to settle (must not exceed current block number).\n    /// @return totalSettledAmount The total amount settled and transferred.\n    /// @return totalNetPayeeAmount The net amount credited to the payee after fees.\n    /// @return totalOperatorCommission The commission credited to the operator.\n    /// @return finalSettledEpoch The epoch up to which settlement was actually completed.\n    /// @return note Additional information about the settlement (especially from validation).\n    function settleRail(uint256 railId, uint256 untilEpoch)\n        public\n        payable\n        nonReentrant\n        validateRailActive(railId)\n        onlyRailParticipant(railId)\n        settleAccountLockupBeforeAndAfterForRail(railId, false, 0)\n        returns (\n            uint256 totalSettledAmount,\n            uint256 totalNetPayeeAmount,\n            uint256 totalOperatorCommission,\n            uint256 finalSettledEpoch,\n            string memory note\n        )\n    {\n        if (NETWORK_FEE > 0) {\n            burnAndRefundRest(NETWORK_FEE);\n        }\n        return settleRailInternal(railId, untilEpoch, false);\n    }\n\n    function settleRailInternal(uint256 railId, uint256 untilEpoch, bool skipValidation)\n        internal\n        returns (\n            uint256 totalSettledAmount,\n            uint256 totalNetPayeeAmount,\n            uint256 totalOperatorCommission,\n            uint256 finalSettledEpoch,\n            string memory note\n        )\n    {\n        require(untilEpoch <= block.number, Errors.CannotSettleFutureEpochs(railId, untilEpoch, block.number));\n\n        Rail storage rail = rails[railId];\n        Account storage payer = accounts[rail.token][rail.from];\n\n        // Handle terminated and fully settled rails that are still not finalised\n        if (isRailTerminated(rail, railId) && rail.settledUpTo >= rail.endEpoch) {\n            finalizeTerminatedRail(railId, rail, payer);\n            return (0, 0, 0, rail.settledUpTo, \"rail fully settled and finalized\");\n        }\n\n        // Calculate the maximum settlement epoch based on account lockup\n        uint256 maxSettlementEpoch;\n        if (!isRailTerminated(rail, railId)) {\n            maxSettlementEpoch = min(untilEpoch, payer.lockupLastSettledAt);\n        } else {\n            maxSettlementEpoch = min(untilEpoch, rail.endEpoch);\n        }\n\n        uint256 startEpoch = rail.settledUpTo;\n        // Nothing to settle (already settled or zero-duration)\n        if (startEpoch >= maxSettlementEpoch) {\n            return (\n                0, 0, 0, startEpoch, string.concat(\"already settled up to epoch \", Strings.toString(maxSettlementEpoch))\n            );\n        }\n\n        // Declare variables for settlement results\n        uint256 amount;\n        uint256 netPayeeAmount;\n        uint256 operatorCommission;\n        string memory segmentNote;\n\n        // Process settlement depending on whether rate changes exist\n        if (rail.rateChangeQueue.isEmpty()) {\n            (amount, netPayeeAmount, operatorCommission, segmentNote) =\n                _settleSegment(railId, startEpoch, maxSettlementEpoch, rail.paymentRate, skipValidation);\n\n            require(\n                rail.settledUpTo > startEpoch, Errors.NoProgressInSettlement(railId, startEpoch + 1, rail.settledUpTo)\n            );\n        } else {\n            (amount, netPayeeAmount, operatorCommission, segmentNote) =\n                _settleWithRateChanges(railId, rail.paymentRate, startEpoch, maxSettlementEpoch, skipValidation);\n        }\n        (totalSettledAmount, totalNetPayeeAmount, totalOperatorCommission, finalSettledEpoch, note) =\n        checkAndFinalizeTerminatedRail(\n            railId,\n            rail,\n            payer,\n            amount,\n            netPayeeAmount,\n            operatorCommission,\n            rail.settledUpTo,\n            segmentNote,\n            string.concat(segmentNote, \"terminated rail fully settled and finalized.\")\n        );\n\n        emit RailSettled(railId, totalSettledAmount, totalNetPayeeAmount, totalOperatorCommission, finalSettledEpoch);\n\n        return (totalSettledAmount, totalNetPayeeAmount, totalOperatorCommission, finalSettledEpoch, note);\n    }\n\n    function checkAndFinalizeTerminatedRail(\n        uint256 railId,\n        Rail storage rail,\n        Account storage payer,\n        uint256 totalSettledAmount,\n        uint256 totalNetPayeeAmount,\n        uint256 totalOperatorCommission,\n        uint256 finalEpoch,\n        string memory regularNote,\n        string memory finalizedNote\n    ) internal returns (uint256, uint256, uint256, uint256, string memory) {\n        // Check if rail is a terminated rail that's now fully settled\n        if (isRailTerminated(rail, railId) && rail.settledUpTo >= maxSettlementEpochForTerminatedRail(rail, railId)) {\n            finalizeTerminatedRail(railId, rail, payer);\n            return (totalSettledAmount, totalNetPayeeAmount, totalOperatorCommission, finalEpoch, finalizedNote);\n        }\n\n        return (totalSettledAmount, totalNetPayeeAmount, totalOperatorCommission, finalEpoch, regularNote);\n    }\n\n    function finalizeTerminatedRail(uint256 railId, Rail storage rail, Account storage payer) internal {\n        // Reduce the lockup by the fixed amount\n        require(\n            payer.lockupCurrent >= rail.lockupFixed,\n            Errors.LockupInconsistencyDuringRailFinalization(\n                railId, rail.token, rail.from, rail.lockupFixed, payer.lockupCurrent\n            )\n        );\n        payer.lockupCurrent -= rail.lockupFixed;\n\n        // Get operator approval for finalization update\n        OperatorApproval storage operatorApproval = operatorApprovals[rail.token][rail.from][rail.operator];\n        // Calculate current (old) lockup.\n        uint256 oldLockup = rail.lockupFixed + (rail.paymentRate * rail.lockupPeriod);\n\n        updateOperatorLockupUsage(operatorApproval, oldLockup, 0);\n\n        // Zero out the rail to mark it as inactive\n        _zeroOutRail(rail);\n\n        emit RailFinalized(railId);\n    }\n\n    function _settleWithRateChanges(\n        uint256 railId,\n        uint256 currentRate,\n        uint256 startEpoch,\n        uint256 targetEpoch,\n        bool skipValidation\n    )\n        internal\n        returns (\n            uint256 totalSettledAmount,\n            uint256 totalNetPayeeAmount,\n            uint256 totalOperatorCommission,\n            string memory note\n        )\n    {\n        Rail storage rail = rails[railId];\n        RateChangeQueue.Queue storage rateQueue = rail.rateChangeQueue;\n\n        SettlementState memory state = SettlementState({\n            totalSettledAmount: 0,\n            totalNetPayeeAmount: 0,\n            totalOperatorCommission: 0,\n            processedEpoch: startEpoch,\n            note: \"\"\n        });\n\n        // Process each segment until we reach the target epoch or hit an early exit condition\n        while (state.processedEpoch < targetEpoch) {\n            (uint256 segmentEndBoundary, uint256 segmentRate) =\n                _getNextSegmentBoundary(rateQueue, currentRate, state.processedEpoch, targetEpoch);\n\n            // if current segment rate is zero, advance settlement to end of this segment and continue\n            if (segmentRate == 0) {\n                rail.settledUpTo = segmentEndBoundary;\n                state.processedEpoch = segmentEndBoundary;\n\n                // Remove the processed rate change from the queue if it exists AND we have processed it entirely\n                if (!rateQueue.isEmpty() && segmentEndBoundary >= rateQueue.peek().untilEpoch) {\n                    rateQueue.dequeue();\n                }\n\n                // Continue to next segment\n                continue;\n            }\n\n            // Settle the current segment with potentially validated outcomes\n            (\n                uint256 segmentSettledAmount,\n                uint256 segmentNetPayeeAmount,\n                uint256 segmentOperatorCommission,\n                string memory validationNote\n            ) = _settleSegment(railId, state.processedEpoch, segmentEndBoundary, segmentRate, skipValidation);\n\n            // If validator returned no progress, exit early without updating state\n            if (rail.settledUpTo <= state.processedEpoch) {\n                return\n                    (state.totalSettledAmount, state.totalNetPayeeAmount, state.totalOperatorCommission, validationNote);\n            }\n\n            // Add the settled amounts to our running totals\n            state.totalSettledAmount += segmentSettledAmount;\n            state.totalNetPayeeAmount += segmentNetPayeeAmount;\n            state.totalOperatorCommission += segmentOperatorCommission;\n\n            // If validator partially settled the segment, exit early\n            if (rail.settledUpTo < segmentEndBoundary) {\n                return\n                    (state.totalSettledAmount, state.totalNetPayeeAmount, state.totalOperatorCommission, validationNote);\n            }\n\n            // Successfully settled full segment, update tracking values\n            state.processedEpoch = rail.settledUpTo;\n            state.note = validationNote;\n\n            // Remove the processed rate change from the queue\n            if (!rateQueue.isEmpty() && segmentEndBoundary >= rateQueue.peek().untilEpoch) {\n                rateQueue.dequeue();\n            }\n        }\n\n        // We've successfully settled up to the target epoch\n        return (state.totalSettledAmount, state.totalNetPayeeAmount, state.totalOperatorCommission, state.note);\n    }\n\n    function _getNextSegmentBoundary(\n        RateChangeQueue.Queue storage rateQueue,\n        uint256 currentRate,\n        uint256 processedEpoch,\n        uint256 targetEpoch\n    ) internal view returns (uint256 segmentEndBoundary, uint256 segmentRate) {\n        // Default boundary is the target we want to reach\n        segmentEndBoundary = targetEpoch;\n        segmentRate = currentRate;\n\n        // If we have rate changes in the queue, use the rate from the next change\n        if (!rateQueue.isEmpty()) {\n            RateChangeQueue.RateChange memory nextRateChange = rateQueue.peek();\n\n            // Validate rate change queue consistency\n            require(\n                nextRateChange.untilEpoch >= processedEpoch,\n                Errors.InvalidRateChangeQueueState(nextRateChange.untilEpoch, processedEpoch)\n            );\n\n            // Boundary is the minimum of our target or the next rate change epoch\n            segmentEndBoundary = min(targetEpoch, nextRateChange.untilEpoch);\n            segmentRate = nextRateChange.rate;\n        }\n    }\n\n    function _settleSegment(uint256 railId, uint256 epochStart, uint256 epochEnd, uint256 rate, bool skipValidation)\n        internal\n        returns (uint256 totalSettledAmount, uint256 netPayeeAmount, uint256 operatorCommission, string memory note)\n    {\n        Rail storage rail = rails[railId];\n        Account storage payer = accounts[rail.token][rail.from];\n        Account storage payee = accounts[rail.token][rail.to];\n\n        if (rate == 0) {\n            rail.settledUpTo = epochEnd;\n            return (0, 0, 0, \"Zero rate payment rail\");\n        }\n\n        // Calculate the default settlement values (without validation)\n        uint256 duration = epochEnd - epochStart;\n        uint256 settledAmount = rate * duration;\n        uint256 settledUntilEpoch = epochEnd;\n        note = \"\";\n\n        // If this rail has an validator and we're not skipping validation, let it decide on the final settlement amount\n        if (rail.validator != address(0) && !skipValidation) {\n            IValidator validator = IValidator(rail.validator);\n            IValidator.ValidationResult memory result =\n                validator.validatePayment(railId, settledAmount, epochStart, epochEnd, rate);\n\n            // Ensure validator doesn't settle beyond our segment's end boundary\n            require(\n                result.settleUpto <= epochEnd,\n                Errors.ValidatorSettledBeyondSegmentEnd(railId, epochEnd, result.settleUpto)\n            );\n            require(\n                result.settleUpto >= epochStart,\n                Errors.ValidatorSettledBeforeSegmentStart(railId, epochStart, result.settleUpto)\n            );\n\n            settledUntilEpoch = result.settleUpto;\n            settledAmount = result.modifiedAmount;\n            note = result.note;\n\n            // Ensure validator doesn't allow more payment than the maximum possible\n            // for the epochs they're confirming\n            uint256 maxAllowedAmount = rate * (settledUntilEpoch - epochStart);\n\n            require(\n                result.modifiedAmount <= maxAllowedAmount,\n                Errors.ValidatorModifiedAmountExceedsMaximum(railId, maxAllowedAmount, result.modifiedAmount)\n            );\n        }\n\n        // Verify payer has sufficient funds for the settlement\n        require(\n            payer.funds >= settledAmount,\n            Errors.InsufficientFundsForSettlement(rail.token, rail.from, settledAmount, payer.funds)\n        );\n\n        // Verify payer has sufficient lockup for the settlement\n        require(\n            payer.lockupCurrent >= settledAmount,\n            Errors.InsufficientLockupForSettlement(rail.token, rail.from, payer.lockupCurrent, settledAmount)\n        );\n        uint256 actualSettledDuration = settledUntilEpoch - epochStart;\n        uint256 requiredLockup = rate * actualSettledDuration;\n\n        // Transfer funds from payer (always pays full settled amount)\n        payer.funds -= settledAmount;\n\n        // Calculate fees, pay operator commission and track platform fees\n        (netPayeeAmount, operatorCommission) =\n            calculateAndPayFees(settledAmount, rail.token, rail.serviceFeeRecipient, rail.commissionRateBps);\n\n        // Credit payee\n        payee.funds += netPayeeAmount;\n\n        // Reduce lockup based on actual settled duration, not requested duration\n        // so that if the validator only settles for a partial duration, we only reduce the client lockup by the actual locked amount\n        // for that reduced duration.\n        payer.lockupCurrent -= requiredLockup;\n\n        // Update the rail's settled epoch\n        rail.settledUpTo = settledUntilEpoch;\n\n        // Invariant check: lockup should never exceed funds\n        require(\n            payer.lockupCurrent <= payer.funds,\n            Errors.LockupExceedsFundsInvariant(rail.token, rail.from, payer.lockupCurrent, payer.funds)\n        );\n        return (settledAmount, netPayeeAmount, operatorCommission, note);\n    }\n\n    function isAccountLockupFullySettled(Account storage account) internal view returns (bool) {\n        return account.lockupLastSettledAt == block.number;\n    }\n\n    // attempts to settle account lockup up to and including the current epoch\n    // returns the actual epoch upto and including which the lockup was settled\n    function settleAccountLockup(address token, address owner, Account storage account) internal returns (uint256) {\n        uint256 currentEpoch = block.number;\n        uint256 elapsedTime = currentEpoch - account.lockupLastSettledAt;\n\n        if (elapsedTime <= 0) {\n            return account.lockupLastSettledAt;\n        }\n\n        if (account.lockupRate == 0) {\n            account.lockupLastSettledAt = currentEpoch;\n\n            // Emit event for zero rate case\n            emit AccountLockupSettled(\n                token, owner, account.lockupCurrent, account.lockupRate, account.lockupLastSettledAt\n            );\n            return currentEpoch;\n        }\n\n        uint256 additionalLockup = account.lockupRate * elapsedTime;\n\n        // we have sufficient funds to cover account lockup upto and including the current epoch\n        if (account.funds >= account.lockupCurrent + additionalLockup) {\n            account.lockupCurrent += additionalLockup;\n            account.lockupLastSettledAt = currentEpoch;\n        } else {\n            require(\n                account.funds >= account.lockupCurrent,\n                Errors.LockupExceedsFundsInvariant(token, owner, account.lockupCurrent, account.funds)\n            );\n\n            // If insufficient, calculate the fractional epoch where funds became insufficient\n            uint256 availableFunds = account.funds - account.lockupCurrent;\n\n            if (availableFunds == 0) {\n                return account.lockupLastSettledAt;\n            }\n\n            // Round down to the nearest whole epoch\n            uint256 fractionalEpochs = availableFunds / account.lockupRate;\n\n            // Apply lockup up to this point\n            account.lockupCurrent += account.lockupRate * fractionalEpochs;\n            account.lockupLastSettledAt = account.lockupLastSettledAt + fractionalEpochs;\n        }\n\n        // event emission for all other cases where state changed\n        emit AccountLockupSettled(token, owner, account.lockupCurrent, account.lockupRate, account.lockupLastSettledAt);\n        return account.lockupLastSettledAt;\n    }\n\n    function remainingEpochsForTerminatedRail(Rail storage rail, uint256 railId)\n        internal\n        view\n        validateRailTerminated(railId)\n        returns (uint256)\n    {\n        // If current block beyond end epoch, return 0\n        if (block.number > rail.endEpoch) {\n            return 0;\n        }\n\n        // Return the number of epochs (blocks) remaining until end epoch\n        return rail.endEpoch - block.number;\n    }\n\n    function isRailTerminated(Rail storage rail, uint256 railId) internal view returns (bool) {\n        require(rail.from != address(0), Errors.RailInactiveOrSettled(railId));\n        return rail.endEpoch > 0;\n    }\n\n    // Get the final settlement epoch for a terminated rail\n    function maxSettlementEpochForTerminatedRail(Rail storage rail, uint256 railId)\n        internal\n        view\n        validateRailTerminated(railId)\n        returns (uint256)\n    {\n        return rail.endEpoch;\n    }\n\n    function _zeroOutRail(Rail storage rail) internal {\n        // IMPORTANT: Do not use `require(cond, Errors.Custom(peekTail()))` here,\n        // because Solidity evaluates all arguments before checking the condition.\n        // That would call `peekTail()` even if the queue is empty, causing an unwanted revert.\n        // Use `if (!cond) revert Errors.Custom(peekTail());` to safely handle the error.\n        // Check if queue is empty before clearing\n        if (!rail.rateChangeQueue.isEmpty()) {\n            revert Errors.RateChangeQueueNotEmpty(rail.rateChangeQueue.peekTail().untilEpoch);\n        }\n\n        rail.token = address(0);\n        rail.from = address(0); // This now marks the rail as inactive\n        rail.to = address(0);\n        rail.operator = address(0);\n        rail.validator = address(0);\n        rail.paymentRate = 0;\n        rail.lockupFixed = 0;\n        rail.lockupPeriod = 0;\n        rail.settledUpTo = 0;\n        rail.endEpoch = 0;\n        rail.commissionRateBps = 0;\n    }\n\n    function updateOperatorRateUsage(OperatorApproval storage approval, uint256 oldRate, uint256 newRate) internal {\n        if (newRate > oldRate) {\n            uint256 rateIncrease = newRate - oldRate;\n            // If the increase exceeds the allowance, revert\n            require(\n                approval.rateUsage + rateIncrease <= approval.rateAllowance,\n                Errors.OperatorRateAllowanceExceeded(approval.rateAllowance, approval.rateUsage + rateIncrease)\n            );\n            approval.rateUsage += rateIncrease;\n        } else if (oldRate > newRate) {\n            uint256 rateDecrease = oldRate - newRate;\n            approval.rateUsage = approval.rateUsage > rateDecrease ? approval.rateUsage - rateDecrease : 0;\n        }\n    }\n\n    function updateOperatorLockupUsage(OperatorApproval storage approval, uint256 oldLockup, uint256 newLockup)\n        internal\n    {\n        if (newLockup > oldLockup) {\n            uint256 lockupIncrease = newLockup - oldLockup;\n            // If the increase exceeds the allowance, revert\n            require(\n                approval.lockupUsage + lockupIncrease <= approval.lockupAllowance,\n                Errors.OperatorLockupAllowanceExceeded(approval.lockupAllowance, approval.lockupUsage + lockupIncrease)\n            );\n            approval.lockupUsage += lockupIncrease;\n        } else if (oldLockup > newLockup) {\n            uint256 lockupDecrease = oldLockup - newLockup;\n            approval.lockupUsage = approval.lockupUsage > lockupDecrease ? approval.lockupUsage - lockupDecrease : 0;\n        }\n    }\n\n    function updateOperatorAllowanceForOneTimePayment(OperatorApproval storage approval, uint256 oneTimePayment)\n        internal\n    {\n        if (oneTimePayment == 0) return;\n\n        // Reduce lockup usage\n        approval.lockupUsage = approval.lockupUsage - oneTimePayment;\n\n        // Reduce lockup allowance\n        approval.lockupAllowance =\n            oneTimePayment > approval.lockupAllowance ? 0 : approval.lockupAllowance - oneTimePayment;\n    }\n\n    /**\n     * @notice Gets all rails where the given address is the payer for a specific token.\n     * @param payer The address of the payer to get rails for.\n     * @param token The token address to filter rails by.\n     * @return Array of RailInfo structs containing rail IDs and termination status.\n     */\n    function getRailsForPayerAndToken(address payer, address token) external view returns (RailInfo[] memory) {\n        return _getRailsForAddressAndToken(payer, token, true);\n    }\n\n    /**\n     * @notice Gets all rails where the given address is the payee for a specific token.\n     * @param payee The address of the payee to get rails for.\n     * @param token The token address to filter rails by.\n     * @return Array of RailInfo structs containing rail IDs and termination status.\n     */\n    function getRailsForPayeeAndToken(address payee, address token) external view returns (RailInfo[] memory) {\n        return _getRailsForAddressAndToken(payee, token, false);\n    }\n\n    /**\n     * @dev Internal function to get rails for either a payer or payee.\n     * @param addr The address to get rails for (either payer or payee).\n     * @param token The token address to filter rails by.\n     * @param isPayer If true, search for rails where addr is the payer, otherwise search for rails where addr is the payee.\n     * @return Array of RailInfo structs containing rail IDs and termination status.\n     */\n    function _getRailsForAddressAndToken(address addr, address token, bool isPayer)\n        internal\n        view\n        returns (RailInfo[] memory)\n    {\n        // Get the appropriate list of rails based on whether we're looking for payer or payee\n        uint256[] storage allRailIds = isPayer ? payerRails[token][addr] : payeeRails[token][addr];\n        uint256 railsLength = allRailIds.length;\n\n        RailInfo[] memory results = new RailInfo[](railsLength);\n        uint256 resultCount = 0;\n\n        for (uint256 i = 0; i < railsLength; i++) {\n            uint256 railId = allRailIds[i];\n            Rail storage rail = rails[railId];\n\n            // Skip non-existent rails\n            if (rail.from == address(0)) continue;\n\n            // Add rail info to results\n            results[resultCount] = RailInfo({railId: railId, isTerminated: rail.endEpoch > 0, endEpoch: rail.endEpoch});\n            resultCount++;\n        }\n\n        // Truncate\n        assembly (\"memory-safe\") {\n            mstore(results, resultCount)\n        }\n\n        return results;\n    }\n\n    /// @notice Number of pending rate-change entries for a rail\n    function getRateChangeQueueSize(uint256 railId) external view returns (uint256) {\n        return rails[railId].rateChangeQueue.size();\n    }\n\n    /**\n     * @notice Gets information about an account - when it would go into debt, total balance, available balance, and lockup rate.\n     * @param token The token address to get account info for.\n     * @param owner The address of the account owner.\n     * @return fundedUntilEpoch The epoch at which the account would go into debt given current lockup rate and balance.\n     * @return currentFunds The current funds in the account.\n     * @return availableFunds The funds available after accounting for simulated lockup.\n     * @return currentLockupRate The current lockup rate per epoch.\n     */\n    function getAccountInfoIfSettled(address token, address owner)\n        external\n        view\n        returns (uint256 fundedUntilEpoch, uint256 currentFunds, uint256 availableFunds, uint256 currentLockupRate)\n    {\n        Account storage account = accounts[token][owner];\n\n        currentFunds = account.funds;\n        currentLockupRate = account.lockupRate;\n\n        uint256 currentEpoch = block.number;\n\n        fundedUntilEpoch = account.lockupRate == 0\n            ? type(uint256).max\n            : account.lockupLastSettledAt + (account.funds - account.lockupCurrent) / account.lockupRate;\n        uint256 simulatedSettledAt = fundedUntilEpoch >= currentEpoch ? currentEpoch : fundedUntilEpoch;\n        uint256 simulatedLockupCurrent =\n            account.lockupCurrent + account.lockupRate * (simulatedSettledAt - account.lockupLastSettledAt);\n        availableFunds = account.funds - simulatedLockupCurrent;\n\n        return (fundedUntilEpoch, currentFunds, availableFunds, currentLockupRate);\n    }\n}\n\nfunction min(uint256 a, uint256 b) pure returns (uint256) {\n    return a < b ? a : b;\n}\n"
    }
}