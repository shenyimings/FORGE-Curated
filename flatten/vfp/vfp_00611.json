{
    "vfp_id": "vfp_00611",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "Minimum Debt Requirement for a Position Is Not Enforced Correctly",
            "description": "The `operate` function enforces a `MIN_DEBT` of 1e9 on `rawDebt`, but later checks the same threshold on `debtShares` after division by `debtIndex`. Since `debtShares` can be less than 1e9 even if `rawDebt` exceeds the minimum, the second check may revert valid operations. The root cause is inconsistent enforcement of the minimum debt requirement across different representations of debt. As `debtIndex` increases over time, the effective minimum debt rises, making it harder to open new positions. The impact is reduced usability and potential denial of service for users trying to open small positions, especially as the protocol ages.\n",
            "severity": "Low",
            "location": [
                "BasePool.sol::operate#83",
                "BasePool.sol::_addPositionToTick#176"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/BasePool.sol"
            ]
        }
    ],
    "affected_files": {
        "BasePool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { IPegKeeper } from \"../../interfaces/IPegKeeper.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IPoolManager } from \"../../interfaces/IPoolManager.sol\";\nimport { IPriceOracle } from \"../../price-oracle/interfaces/IPriceOracle.sol\";\n\nimport { WordCodec } from \"../../common/codec/WordCodec.sol\";\nimport { Math } from \"../../libraries/Math.sol\";\nimport { TickBitmap } from \"../../libraries/TickBitmap.sol\";\nimport { PositionLogic } from \"./PositionLogic.sol\";\nimport { TickLogic } from \"./TickLogic.sol\";\n\nabstract contract BasePool is TickLogic, PositionLogic {\n  using TickBitmap for mapping(int8 => uint256);\n  using WordCodec for bytes32;\n\n  /***********\n   * Structs *\n   ***********/\n\n  struct OperationMemoryVar {\n    int256 tick;\n    uint48 node;\n    uint256 positionColl;\n    uint256 positionDebt;\n    int256 newColl;\n    int256 newDebt;\n    uint256 collIndex;\n    uint256 debtIndex;\n    uint256 globalColl;\n    uint256 globalDebt;\n    uint256 price;\n  }\n\n  /*************\n   * Modifiers *\n   *************/\n\n  modifier onlyPoolManager() {\n    if (_msgSender() != poolManager) {\n      revert ErrorCallerNotPoolManager();\n    }\n    _;\n  }\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address _poolManager) {\n    _checkAddressNotZero(_poolManager);\n\n    poolManager = _poolManager;\n    fxUSD = IPoolManager(_poolManager).fxUSD();\n    pegKeeper = IPoolManager(_poolManager).pegKeeper();\n  }\n\n  function __BasePool_init() internal onlyInitializing {\n    _updateDebtIndex(E96);\n    _updateCollateralIndex(E96);\n    _updateDebtRatioRange(500000000000000000, 857142857142857142); // 1/2 ~ 6/7\n    _updateMaxRedeemRatioPerTick(200000000); // 20%\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc IPool\n  function operate(\n    uint256 positionId,\n    int256 newRawColl,\n    int256 newRawDebt,\n    address owner\n  ) external onlyPoolManager returns (uint256, int256, int256, uint256) {\n    if (newRawColl == 0 && newRawDebt == 0) revert ErrorNoSupplyAndNoBorrow();\n    if (newRawColl != 0 && (newRawColl > -MIN_COLLATERAL && newRawColl < MIN_COLLATERAL)) {\n      revert ErrorCollateralTooSmall();\n    }\n    if (newRawDebt != 0 && (newRawDebt > -MIN_DEBT && newRawDebt < MIN_DEBT)) {\n      revert ErrorDebtTooSmall();\n    }\n    if (newRawDebt > 0 && (_isBorrowPaused() || !IPegKeeper(pegKeeper).isBorrowAllowed())) {\n      revert ErrorBorrowPaused();\n    }\n\n    OperationMemoryVar memory op;\n    // price precision and ratio precision are both 1e18, use min price here\n    op.price = IPriceOracle(priceOracle).getExchangePrice();\n    (op.globalDebt, op.globalColl) = _getDebtAndCollateralShares();\n    (op.collIndex, op.debtIndex) = _updateCollAndDebtIndex();\n    if (positionId == 0) {\n      positionId = _mintPosition(owner);\n    } else {\n      // make sure position is owned and check owner only in case of withdraw or borrow\n      if (ownerOf(positionId) != owner && (newRawColl < 0 || newRawDebt > 0)) {\n        revert ErrorNotPositionOwner();\n      }\n      PositionInfo memory position = _getAndUpdatePosition(positionId);\n      // temporarily remove position from tick tree for simplicity\n      _removePositionFromTick(position);\n      op.tick = position.tick;\n      op.node = position.nodeId;\n      op.positionDebt = position.debts;\n      op.positionColl = position.colls;\n\n      // cannot withdraw or borrow when the position is above liquidation ratio\n      if (newRawColl < 0 || newRawDebt > 0) {\n        uint256 rawColls = _convertToRawColl(op.positionColl, op.collIndex, Math.Rounding.Down);\n        uint256 rawDebts = _convertToRawDebt(op.positionDebt, op.debtIndex, Math.Rounding.Down);\n        (uint256 debtRatio, ) = _getLiquidateRatios();\n        if (rawDebts * PRECISION * PRECISION > debtRatio * rawColls * op.price) revert ErrorPositionInLiquidationMode();\n      }\n    }\n\n    uint256 protocolFees;\n    // supply or withdraw\n    if (newRawColl > 0) {\n      protocolFees = _deductProtocolFees(newRawColl);\n      newRawColl -= int256(protocolFees);\n      op.newColl = int256(_convertToCollShares(uint256(newRawColl), op.collIndex, Math.Rounding.Down));\n      op.positionColl += uint256(op.newColl);\n      op.globalColl += uint256(op.newColl);\n    } else if (newRawColl < 0) {\n      if (newRawColl == type(int256).min) {\n        // this is max withdraw\n        newRawColl = -int256(_convertToRawColl(op.positionColl, op.collIndex, Math.Rounding.Down));\n        op.newColl = -int256(op.positionColl);\n      } else {\n        // this is partial withdraw, rounding up removing extra wei from collateral\n        op.newColl = -int256(_convertToCollShares(uint256(-newRawColl), op.collIndex, Math.Rounding.Up));\n        if (uint256(-op.newColl) > op.positionColl) revert ErrorWithdrawExceedSupply();\n      }\n      unchecked {\n        op.positionColl -= uint256(-op.newColl);\n        op.globalColl -= uint256(-op.newColl);\n      }\n      protocolFees = _deductProtocolFees(newRawColl);\n      newRawColl += int256(protocolFees);\n    }\n\n    // borrow or repay\n    if (newRawDebt > 0) {\n      // rounding up adding extra wei in debt\n      op.newDebt = int256(_convertToDebtShares(uint256(newRawDebt), op.debtIndex, Math.Rounding.Up));\n      op.positionDebt += uint256(op.newDebt);\n      op.globalDebt += uint256(op.newDebt);\n    } else if (newRawDebt < 0) {\n      if (newRawDebt == type(int256).min) {\n        // this is max repay, rounding up amount that will be transferred in to pay back full debt:\n        // subtracting -1 of negative debtAmount newDebt_ for safe rounding (increasing payback)\n        newRawDebt = -int256(_convertToRawDebt(op.positionDebt, op.debtIndex, Math.Rounding.Up));\n        op.newDebt = -int256(op.positionDebt);\n      } else {\n        // this is partial repay, safe rounding up negative amount to rounding reduce payback\n        op.newDebt = -int256(_convertToDebtShares(uint256(-newRawDebt), op.debtIndex, Math.Rounding.Up));\n      }\n      op.positionDebt -= uint256(-op.newDebt);\n      op.globalDebt -= uint256(-op.newDebt);\n    }\n\n    // final debt ratio check\n    {\n      // check position debt ratio is between `minDebtRatio` and `maxDebtRatio`.\n      uint256 rawColls = _convertToRawColl(op.positionColl, op.collIndex, Math.Rounding.Down);\n      uint256 rawDebts = _convertToRawDebt(op.positionDebt, op.debtIndex, Math.Rounding.Down);\n      (uint256 minDebtRatio, uint256 maxDebtRatio) = _getDebtRatioRange();\n      if (rawDebts * PRECISION * PRECISION > maxDebtRatio * rawColls * op.price) revert ErrorDebtRatioTooLarge();\n      if (rawDebts * PRECISION * PRECISION < minDebtRatio * rawColls * op.price) revert ErrorDebtRatioTooSmall();\n    }\n\n    // update position state to storage\n    (op.tick, op.node) = _addPositionToTick(op.positionColl, op.positionDebt, true);\n\n    if (op.positionColl > type(uint96).max) revert ErrorOverflow();\n    if (op.positionDebt > type(uint96).max) revert ErrorOverflow();\n    positionData[positionId] = PositionInfo(int16(op.tick), op.node, uint96(op.positionColl), uint96(op.positionDebt));\n\n    // update global state to storage\n    _updateDebtAndCollateralShares(op.globalDebt, op.globalColl);\n\n    emit PositionSnapshot(positionId, int16(op.tick), op.positionColl, op.positionDebt, op.price);\n\n    return (positionId, newRawColl, newRawDebt, protocolFees);\n  }\n\n  /// @inheritdoc IPool\n  function redeem(uint256 rawDebts) external onlyPoolManager returns (uint256 rawColls) {\n    if (_isRedeemPaused()) revert ErrorRedeemPaused();\n\n    (uint256 cachedCollIndex, uint256 cachedDebtIndex) = _updateCollAndDebtIndex();\n    (uint256 cachedTotalDebts, uint256 cachedTotalColls) = _getDebtAndCollateralShares();\n    uint256 price = IPriceOracle(priceOracle).getRedeemPrice();\n    // check global debt ratio, if global debt ratio >= 1, disable redeem\n    {\n      uint256 totalRawColls = _convertToRawColl(cachedTotalColls, cachedCollIndex, Math.Rounding.Down);\n      uint256 totalRawDebts = _convertToRawDebt(cachedTotalDebts, cachedDebtIndex, Math.Rounding.Down);\n      if (totalRawDebts * PRECISION >= totalRawColls * price) revert ErrorPoolUnderCollateral();\n    }\n\n    int16 tick = _getTopTick();\n    bool hasDebt = true;\n    uint256 debtShare = _convertToDebtShares(rawDebts, cachedDebtIndex, Math.Rounding.Down);\n    while (debtShare > 0) {\n      if (!hasDebt) {\n        (tick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(tick - 1);\n      } else {\n        uint256 node = tickData[tick];\n        bytes32 value = tickTreeData[node].value;\n        uint256 tickDebtShare = value.decodeUint(DEBT_SHARE_OFFSET, 128);\n        // skip bad debt\n        {\n          uint256 tickCollShare = value.decodeUint(COLL_SHARE_OFFSET, 128);\n          if (\n            _convertToRawDebt(tickDebtShare, cachedDebtIndex, Math.Rounding.Down) * PRECISION >\n            _convertToRawColl(tickCollShare, cachedCollIndex, Math.Rounding.Down) * price\n          ) {\n            hasDebt = false;\n            tick = tick;\n            continue;\n          }\n        }\n\n        // redeem at most `maxRedeemRatioPerTick`\n        uint256 debtShareToRedeem = (tickDebtShare * _getMaxRedeemRatioPerTick()) / FEE_PRECISION;\n        if (debtShareToRedeem > debtShare) debtShareToRedeem = debtShare;\n        uint256 rawCollRedeemed = (_convertToRawDebt(debtShareToRedeem, cachedDebtIndex, Math.Rounding.Down) *\n          PRECISION) / price;\n        uint256 collShareRedeemed = _convertToCollShares(rawCollRedeemed, cachedCollIndex, Math.Rounding.Down);\n        _liquidateTick(tick, collShareRedeemed, debtShareToRedeem, price);\n        debtShare -= debtShareToRedeem;\n        rawColls += rawCollRedeemed;\n\n        cachedTotalColls -= collShareRedeemed;\n        cachedTotalDebts -= debtShareToRedeem;\n\n        (tick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(tick - 1);\n      }\n      if (tick == type(int16).min) break;\n    }\n    _updateDebtAndCollateralShares(cachedTotalDebts, cachedTotalColls);\n  }\n\n  /// @inheritdoc IPool\n  function rebalance(int16 tick, uint256 maxRawDebts) external onlyPoolManager returns (RebalanceResult memory result) {\n    (uint256 cachedCollIndex, uint256 cachedDebtIndex) = _updateCollAndDebtIndex();\n    (, uint256 price, ) = IPriceOracle(priceOracle).getPrice(); // use min price\n    uint256 node = tickData[tick];\n    bytes32 value = tickTreeData[node].value;\n    uint256 tickRawColl = _convertToRawColl(\n      value.decodeUint(COLL_SHARE_OFFSET, 128),\n      cachedCollIndex,\n      Math.Rounding.Down\n    );\n    uint256 tickRawDebt = _convertToRawDebt(\n      value.decodeUint(DEBT_SHARE_OFFSET, 128),\n      cachedDebtIndex,\n      Math.Rounding.Down\n    );\n    (uint256 rebalanceDebtRatio, uint256 rebalanceBonusRatio) = _getRebalanceRatios();\n    (uint256 liquidateDebtRatio, ) = _getLiquidateRatios();\n    // rebalance only debt ratio >= `rebalanceDebtRatio` and ratio < `liquidateDebtRatio`\n    if (tickRawDebt * PRECISION * PRECISION < rebalanceDebtRatio * tickRawColl * price) {\n      revert ErrorRebalanceDebtRatioNotReached();\n    }\n    if (tickRawDebt * PRECISION * PRECISION >= liquidateDebtRatio * tickRawColl * price) {\n      revert ErrorRebalanceOnLiquidatableTick();\n    }\n\n    // compute debts to rebalance to make debt ratio to `rebalanceDebtRatio`\n    result.rawDebts = _getRawDebtToRebalance(tickRawColl, tickRawDebt, price, rebalanceDebtRatio, rebalanceBonusRatio);\n    if (maxRawDebts < result.rawDebts) result.rawDebts = maxRawDebts;\n\n    uint256 debtShareToRebalance = _convertToDebtShares(result.rawDebts, cachedDebtIndex, Math.Rounding.Down);\n    result.rawColls = (result.rawDebts * PRECISION) / price;\n    result.bonusRawColls = (result.rawColls * rebalanceBonusRatio) / FEE_PRECISION;\n    if (result.bonusRawColls > tickRawColl - result.rawColls) {\n      result.bonusRawColls = tickRawColl - result.rawColls;\n    }\n    uint256 collShareToRebalance = _convertToCollShares(\n      result.rawColls + result.bonusRawColls,\n      cachedCollIndex,\n      Math.Rounding.Down\n    );\n\n    _liquidateTick(tick, collShareToRebalance, debtShareToRebalance, price);\n    unchecked {\n      (uint256 totalDebts, uint256 totalColls) = _getDebtAndCollateralShares();\n      _updateDebtAndCollateralShares(totalDebts - debtShareToRebalance, totalColls - collShareToRebalance);\n    }\n  }\n\n  struct RebalanceVars {\n    uint256 tickCollShares;\n    uint256 tickDebtShares;\n    uint256 tickRawColls;\n    uint256 tickRawDebts;\n    uint256 maxRawDebts;\n    uint256 rebalanceDebtRatio;\n    uint256 rebalanceBonusRatio;\n    uint256 price;\n    uint256 collIndex;\n    uint256 debtIndex;\n    uint256 totalCollShares;\n    uint256 totalDebtShares;\n  }\n\n  /// @inheritdoc IPool\n  function rebalance(uint256 maxRawDebts) external onlyPoolManager returns (RebalanceResult memory result) {\n    RebalanceVars memory vars;\n    vars.maxRawDebts = maxRawDebts;\n    (vars.rebalanceDebtRatio, vars.rebalanceBonusRatio) = _getRebalanceRatios();\n    (, vars.price, ) = IPriceOracle(priceOracle).getPrice();\n    (vars.collIndex, vars.debtIndex) = _updateCollAndDebtIndex();\n    (vars.totalDebtShares, vars.totalCollShares) = _getDebtAndCollateralShares();\n    (uint256 liquidateDebtRatio, ) = _getLiquidateRatios();\n\n    int16 tick = _getTopTick();\n    bool hasDebt = true;\n    while (vars.maxRawDebts > 0) {\n      if (!hasDebt) {\n        (tick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(tick - 1);\n      } else {\n        (vars.tickCollShares, vars.tickDebtShares, vars.tickRawColls, vars.tickRawDebts) = _getTickRawCollAndDebts(\n          tick,\n          vars.collIndex,\n          vars.debtIndex\n        );\n        // skip bad debt and liquidatable positions: coll * price * liquidateDebtRatio <= debts\n        if (vars.tickRawColls * vars.price * liquidateDebtRatio <= vars.tickRawDebts * PRECISION * PRECISION) {\n          hasDebt = false;\n          tick = tick;\n          continue;\n        }\n        // skip dust\n        if (vars.tickRawDebts < uint256(MIN_DEBT)) {\n          hasDebt = false;\n          tick = tick;\n          continue;\n        }\n        // no more rebalanceable tick: coll * price * rebalanceDebtRatio > debts\n        if (vars.tickRawColls * vars.price * vars.rebalanceDebtRatio > vars.tickRawDebts * PRECISION * PRECISION) {\n          break;\n        }\n        // rebalance this tick\n        (uint256 rawDebts, uint256 rawColls, uint256 bonusRawColls) = _rebalanceTick(tick, vars);\n        result.rawDebts += rawDebts;\n        result.rawColls += rawColls;\n        result.bonusRawColls += bonusRawColls;\n\n        // goto next tick\n        (tick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(tick - 1);\n      }\n      if (tick == type(int16).min) break;\n    }\n\n    _updateDebtAndCollateralShares(vars.totalDebtShares, vars.totalCollShares);\n  }\n\n  struct LiquidateVars {\n    uint256 tickCollShares;\n    uint256 tickDebtShares;\n    uint256 tickRawColls;\n    uint256 tickRawDebts;\n    uint256 maxRawDebts;\n    uint256 reservedRawColls;\n    uint256 liquidateDebtRatio;\n    uint256 liquidateBonusRatio;\n    uint256 price;\n    uint256 collIndex;\n    uint256 debtIndex;\n    uint256 totalCollShares;\n    uint256 totalDebtShares;\n  }\n\n  /// @inheritdoc IPool\n  function liquidate(\n    uint256 maxRawDebts,\n    uint256 reservedRawColls\n  ) external onlyPoolManager returns (LiquidateResult memory result) {\n    LiquidateVars memory vars;\n    vars.maxRawDebts = maxRawDebts;\n    vars.reservedRawColls = reservedRawColls;\n    (vars.liquidateDebtRatio, vars.liquidateBonusRatio) = _getLiquidateRatios();\n    (, vars.price, ) = IPriceOracle(priceOracle).getPrice();\n    (vars.collIndex, vars.debtIndex) = _updateCollAndDebtIndex();\n    (vars.totalDebtShares, vars.totalCollShares) = _getDebtAndCollateralShares();\n\n    int16 tick = _getTopTick();\n    bool hasDebt = true;\n    while (vars.maxRawDebts > 0) {\n      if (!hasDebt) {\n        (tick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(tick - 1);\n      } else {\n        (vars.tickCollShares, vars.tickDebtShares, vars.tickRawColls, vars.tickRawDebts) = _getTickRawCollAndDebts(\n          tick,\n          vars.collIndex,\n          vars.debtIndex\n        );\n        // no more liquidatable tick: coll * price * liquidateDebtRatio > debts\n        if (vars.tickRawColls * vars.price * vars.liquidateDebtRatio > vars.tickRawDebts * PRECISION * PRECISION) {\n          // skip dust, since the results might be wrong\n          if (vars.tickRawDebts < uint256(MIN_DEBT)) {\n            hasDebt = false;\n            tick = tick;\n            continue;\n          }\n          break;\n        }\n        // rebalance this tick\n        (uint256 rawDebts, uint256 rawColls, uint256 bonusRawColls, uint256 bonusFromReserve) = _liquidateTick(\n          tick,\n          vars\n        );\n        result.rawDebts += rawDebts;\n        result.rawColls += rawColls;\n        result.bonusRawColls += bonusRawColls;\n        result.bonusFromReserve += bonusFromReserve;\n\n        // goto next tick\n        (tick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(tick - 1);\n      }\n      if (tick == type(int16).min) break;\n    }\n\n    _updateDebtAndCollateralShares(vars.totalDebtShares, vars.totalCollShares);\n    _updateDebtIndex(vars.debtIndex);\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the borrow and redeem status.\n  /// @param borrowStatus The new borrow status.\n  /// @param redeemStatus The new redeem status.\n  function updateBorrowAndRedeemStatus(bool borrowStatus, bool redeemStatus) external onlyRole(EMERGENCY_ROLE) {\n    _updateBorrowStatus(borrowStatus);\n    _updateRedeemStatus(redeemStatus);\n  }\n\n  /// @notice Update debt ratio range.\n  /// @param minRatio The minimum allowed debt ratio to update, multiplied by 1e18.\n  /// @param maxRatio The maximum allowed debt ratio to update, multiplied by 1e18.\n  function updateDebtRatioRange(uint256 minRatio, uint256 maxRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateDebtRatioRange(minRatio, maxRatio);\n  }\n\n  /// @notice Update maximum redeem ratio per tick.\n  /// @param ratio The ratio to update, multiplied by 1e9.\n  function updateMaxRedeemRatioPerTick(uint256 ratio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateMaxRedeemRatioPerTick(ratio);\n  }\n\n  /// @notice Update ratio for rebalance.\n  /// @param debtRatio The minimum debt ratio to start rebalance, multiplied by 1e18.\n  /// @param bonusRatio The bonus ratio during rebalance, multiplied by 1e9.\n  function updateRebalanceRatios(uint256 debtRatio, uint256 bonusRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateRebalanceRatios(debtRatio, bonusRatio);\n  }\n\n  /// @notice Update ratio for liquidate.\n  /// @param debtRatio The minimum debt ratio to start liquidate, multiplied by 1e18.\n  /// @param bonusRatio The bonus ratio during liquidate, multiplied by 1e9.\n  function updateLiquidateRatios(uint256 debtRatio, uint256 bonusRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateLiquidateRatios(debtRatio, bonusRatio);\n  }\n\n  /// @notice Update the address of price oracle.\n  /// @param newOracle The address of new price oracle.\n  function updatePriceOracle(address newOracle) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updatePriceOracle(newOracle);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to compute the amount of debt to rebalance to reach certain debt ratio.\n  /// @param coll The amount of collateral tokens.\n  /// @param debt The amount of debt tokens.\n  /// @param price The price of the collateral token.\n  /// @param targetDebtRatio The target debt ratio, multiplied by 1e18.\n  /// @param incentiveRatio The bonus ratio, multiplied by 1e9.\n  /// @return rawDebts The amount of debt tokens to rebalance.\n  function _getRawDebtToRebalance(\n    uint256 coll,\n    uint256 debt,\n    uint256 price,\n    uint256 targetDebtRatio,\n    uint256 incentiveRatio\n  ) internal pure returns (uint256 rawDebts) {\n    // we have\n    //   1. (debt - x) / (price * (coll - y * (1 + incentive))) <= target_ratio\n    //   2. debt / (price * coll) >= target_ratio\n    // then\n    // => debt - x <= target * price * (coll - y * (1 + incentive)) and y = x / price\n    // => debt - target_ratio * price * coll <= (1 - (1 + incentive) * target) * x\n    // => x >= (debt - target_ratio * price * coll) / (1 - (1 + incentive) * target)\n    rawDebts =\n      (debt * PRECISION * PRECISION - targetDebtRatio * price * coll) /\n      (PRECISION * PRECISION - (PRECISION * targetDebtRatio * (FEE_PRECISION + incentiveRatio)) / FEE_PRECISION);\n  }\n\n  function _getTickRawCollAndDebts(\n    int16 tick,\n    uint256 collIndex,\n    uint256 debtIndex\n  ) internal view returns (uint256 colls, uint256 debts, uint256 rawColls, uint256 rawDebts) {\n    uint256 node = tickData[tick];\n    bytes32 value = tickTreeData[node].value;\n    colls = value.decodeUint(COLL_SHARE_OFFSET, 128);\n    debts = value.decodeUint(DEBT_SHARE_OFFSET, 128);\n    rawColls = _convertToRawColl(colls, collIndex, Math.Rounding.Down);\n    rawDebts = _convertToRawDebt(debts, debtIndex, Math.Rounding.Down);\n  }\n\n  function _rebalanceTick(\n    int16 tick,\n    RebalanceVars memory vars\n  ) internal returns (uint256 rawDebts, uint256 rawColls, uint256 bonusRawColls) {\n    // compute debts to rebalance to make debt ratio to `rebalanceDebtRatio`\n    rawDebts = _getRawDebtToRebalance(\n      vars.tickRawColls,\n      vars.tickRawDebts,\n      vars.price,\n      vars.rebalanceDebtRatio,\n      vars.rebalanceBonusRatio\n    );\n    if (vars.maxRawDebts < rawDebts) rawDebts = vars.maxRawDebts;\n\n    uint256 debtShares = _convertToDebtShares(rawDebts, vars.debtIndex, Math.Rounding.Down);\n    rawColls = (rawDebts * PRECISION) / vars.price;\n    bonusRawColls = (rawColls * vars.rebalanceBonusRatio) / FEE_PRECISION;\n    if (bonusRawColls > vars.tickRawColls - rawColls) {\n      bonusRawColls = vars.tickRawColls - rawColls;\n    }\n    uint256 collShares = _convertToCollShares(rawColls + bonusRawColls, vars.collIndex, Math.Rounding.Down);\n\n    _liquidateTick(tick, collShares, debtShares, vars.price);\n    vars.totalCollShares -= collShares;\n    vars.totalDebtShares -= debtShares;\n    vars.maxRawDebts -= rawDebts;\n  }\n\n  function _liquidateTick(\n    int16 tick,\n    LiquidateVars memory vars\n  ) internal returns (uint256 rawDebts, uint256 rawColls, uint256 bonusRawColls, uint256 bonusFromReserve) {\n    uint256 virtualTickRawColls = vars.tickRawColls + vars.reservedRawColls;\n    rawDebts = vars.tickRawDebts;\n    if (rawDebts > vars.maxRawDebts) rawDebts = vars.maxRawDebts;\n    rawColls = (rawDebts * PRECISION) / vars.price;\n    uint256 debtShares;\n    uint256 collShares;\n    if (rawDebts == vars.tickRawDebts) {\n      // full liquidation\n      debtShares = vars.tickDebtShares;\n    } else {\n      // partial liquidation\n      debtShares = _convertToDebtShares(rawDebts, vars.debtIndex, Math.Rounding.Down);\n    }\n    if (virtualTickRawColls <= rawColls) {\n      // even reserve funds cannot cover bad debts, no bonus and will trigger bad debt redistribution\n      rawColls = virtualTickRawColls;\n      bonusFromReserve = vars.reservedRawColls;\n      rawDebts = (virtualTickRawColls * vars.price) / PRECISION;\n      debtShares = _convertToDebtShares(rawDebts, vars.debtIndex, Math.Rounding.Down);\n      collShares = vars.tickCollShares;\n    } else {\n      // Bonus is from colls in tick, if it is not enough will use reserve funds\n      bonusRawColls = (rawColls * vars.liquidateBonusRatio) / FEE_PRECISION;\n      uint256 rawCollWithBonus = bonusRawColls + rawColls;\n      if (rawCollWithBonus > virtualTickRawColls) {\n        rawCollWithBonus = virtualTickRawColls;\n        bonusRawColls = rawCollWithBonus - rawColls;\n      }\n      if (rawCollWithBonus >= vars.tickRawColls) {\n        bonusFromReserve = rawCollWithBonus - vars.tickRawColls;\n        collShares = vars.tickCollShares;\n      } else {\n        collShares = _convertToCollShares(rawCollWithBonus, vars.collIndex, Math.Rounding.Down);\n      }\n    }\n\n    vars.reservedRawColls -= bonusFromReserve;\n    if (collShares == vars.tickCollShares && debtShares < vars.tickDebtShares) {\n      // trigger bad debt redistribution\n      uint256 rawBadDebt = _convertToRawDebt(vars.tickDebtShares - debtShares, vars.debtIndex, Math.Rounding.Down);\n      debtShares = vars.tickDebtShares;\n      vars.totalCollShares -= collShares;\n      vars.totalDebtShares -= debtShares;\n      vars.debtIndex += (rawBadDebt * E96) / vars.totalDebtShares;\n    } else {\n      vars.totalCollShares -= collShares;\n      vars.totalDebtShares -= debtShares;\n    }\n    vars.maxRawDebts -= rawDebts;\n    _liquidateTick(tick, collShares, debtShares, vars.price);\n  }\n\n  /// @dev Internal function to update collateral and debt index.\n  /// @return newCollIndex The updated collateral index.\n  /// @return newDebtIndex The updated debt index.\n  function _updateCollAndDebtIndex() internal virtual returns (uint256 newCollIndex, uint256 newDebtIndex);\n\n  /// @dev Internal function to compute the protocol fees.\n  /// @param rawColl The amount of collateral tokens involved.\n  /// @return fees The expected protocol fees.\n  function _deductProtocolFees(int256 rawColl) internal view virtual returns (uint256 fees);\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private __gap;\n}\n"
    }
}