{
    "vfp_id": "vfp_00302",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 55,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Zapper Remove Manager Requires Increased Trust",
            "description": "In core contracts, the removeManager cannot directly profit from malicious actions because funds go to the receiver. In zappers, however, the removeManager controls swap parameters in leverage functions. A malicious removeManager can execute trades at unfavorable rates or sandwich attacks to extract value from the trove owner. Thus, the removeManager in zappers requires higher trust than in core contracts.\n",
            "severity": "Informational",
            "location": [
                "Zapper removeManager"
            ],
            "files": [
                "bold/contracts/test/zapperWETH.t.sol",
                "bold/contracts/test/zapperLeverage.t.sol",
                "bold/frontend/app/src/abi/LeverageLSTZapper.ts",
                "bold/frontend/app/src/abi/LeverageWETHZapper.ts"
            ]
        }
    ],
    "affected_files": {
        "zapperLeverage.t.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"./TestContracts/DevTestSetup.sol\";\nimport \"./TestContracts/WETH.sol\";\nimport \"src/Zappers/Modules/Exchanges/Curve/ICurvePool.sol\";\nimport \"src/Zappers/Modules/Exchanges/CurveExchange.sol\";\nimport \"src/Zappers/Modules/Exchanges/UniswapV3/IUniswapV3Pool.sol\";\nimport \"src/Zappers/Modules/Exchanges/UniV3Exchange.sol\";\nimport \"src/Zappers/Modules/Exchanges/UniswapV3/INonfungiblePositionManager.sol\";\nimport \"src/Zappers/Modules/Exchanges/UniswapV3/IUniswapV3Factory.sol\";\nimport \"src/Zappers/Modules/Exchanges/UniswapV3/IQuoterV2.sol\";\nimport \"src/Zappers/Modules/Exchanges/UniswapV3/ISwapRouter.sol\";\nimport \"src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol\";\nimport \"src/Zappers/Modules/Exchanges/HybridCurveUniV3ExchangeHelpers.sol\";\nimport \"src/Zappers/Interfaces/IFlashLoanProvider.sol\";\nimport \"src/Zappers/Modules/FlashLoans/Balancer/vault/IVault.sol\";\n\nimport \"src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGFactory.sol\";\n\ncontract ZapperLeverageMainnet is DevTestSetup {\n    using StringFormatting for uint256;\n\n    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    // Curve\n    uint128 constant BOLD_TOKEN_INDEX = 0;\n    uint256 constant COLL_TOKEN_INDEX = 1;\n    uint128 constant USDC_INDEX = 1;\n\n    // UniV3\n    INonfungiblePositionManager constant uniV3PositionManager =\n        INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n    IUniswapV3Factory constant uniswapV3Factory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    IQuoterV2 constant uniV3Quoter = IQuoterV2(0x61fFE014bA17989E743c5F6cB21bF9697530B21e);\n    ISwapRouter constant uniV3Router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    uint24 constant UNIV3_FEE = 3000; // 0.3%\n    uint24 constant UNIV3_FEE_USDC_WETH = 500; // 0.05%\n    uint24 constant UNIV3_FEE_WETH_COLL = 100; // 0.01%\n\n    uint256 constant NUM_COLLATERALS = 3;\n\n    IZapper[] baseZapperArray;\n    ILeverageZapper[] leverageZapperCurveArray;\n    ILeverageZapper[] leverageZapperUniV3Array;\n    ILeverageZapper[] leverageZapperHybridArray;\n\n    HybridCurveUniV3ExchangeHelpers hybridCurveUniV3ExchangeHelpers;\n\n    ICurveStableswapNGPool usdcCurvePool;\n\n    TestDeployer.LiquityContracts[] contractsArray;\n\n    struct OpenTroveVars {\n        uint256 price;\n        uint256 flashLoanAmount;\n        uint256 expectedBoldAmount;\n        uint256 maxNetDebt;\n        uint256 effectiveBoldAmount;\n        uint256 value;\n        uint256 troveId;\n    }\n\n    struct LeverVars {\n        uint256 price;\n        uint256 currentCR;\n        uint256 currentLR;\n        uint256 currentCollAmount;\n        uint256 flashLoanAmount;\n        uint256 expectedBoldAmount;\n        uint256 maxNetDebtIncrease;\n        uint256 effectiveBoldAmount;\n    }\n\n    struct TestVars {\n        uint256 collAmount;\n        uint256 initialLeverageRatio;\n        uint256 troveId;\n        uint256 initialDebt;\n        uint256 newLeverageRatio;\n        uint256 resultingCollateralRatio;\n        uint256 flashLoanAmount;\n        uint256 price;\n        uint256 boldBalanceBeforeA;\n        uint256 ethBalanceBeforeA;\n        uint256 collBalanceBeforeA;\n        uint256 boldBalanceBeforeZapper;\n        uint256 ethBalanceBeforeZapper;\n        uint256 collBalanceBeforeZapper;\n        uint256 boldBalanceBeforeExchange;\n        uint256 ethBalanceBeforeExchange;\n        uint256 collBalanceBeforeExchange;\n    }\n\n    enum ExchangeType {\n        Curve,\n        UniV3,\n        HybridCurveUniV3\n    }\n\n    function setUp() public override {\n        uint256 forkBlock = 21328610;\n\n        try vm.envString(\"MAINNET_RPC_URL\") returns (string memory rpcUrl) {\n            vm.createSelectFork(rpcUrl, forkBlock);\n        } catch {\n            vm.skip(true);\n        }\n\n        // Start tests at a non-zero timestamp\n        vm.warp(block.timestamp + 600);\n\n        accounts = new Accounts();\n        createAccounts();\n\n        (A, B, C, D, E, F, G) = (\n            accountsList[0],\n            accountsList[1],\n            accountsList[2],\n            accountsList[3],\n            accountsList[4],\n            accountsList[5],\n            accountsList[6]\n        );\n\n        WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n        TestDeployer.TroveManagerParams[] memory troveManagerParamsArray =\n            new TestDeployer.TroveManagerParams[](NUM_COLLATERALS);\n        troveManagerParamsArray[0] = TestDeployer.TroveManagerParams(150e16, 110e16, 10e16, 110e16, 5e16, 10e16);\n        for (uint256 c = 0; c < NUM_COLLATERALS; c++) {\n            troveManagerParamsArray[c] = TestDeployer.TroveManagerParams(160e16, 120e16, 10e16, 120e16, 5e16, 10e16);\n        }\n\n        TestDeployer deployer = new TestDeployer();\n        TestDeployer.DeploymentResultMainnet memory result =\n            deployer.deployAndConnectContractsMainnet(troveManagerParamsArray);\n        collateralRegistry = result.collateralRegistry;\n        boldToken = result.boldToken;\n        // Record contracts\n        baseZapperArray.push(result.zappersArray[0].wethZapper);\n        for (uint256 c = 1; c < NUM_COLLATERALS; c++) {\n            baseZapperArray.push(result.zappersArray[c].gasCompZapper);\n        }\n        for (uint256 c = 0; c < NUM_COLLATERALS; c++) {\n            contractsArray.push(result.contractsArray[c]);\n            leverageZapperCurveArray.push(result.zappersArray[c].leverageZapperCurve);\n            leverageZapperUniV3Array.push(result.zappersArray[c].leverageZapperUniV3);\n            leverageZapperHybridArray.push(result.zappersArray[c].leverageZapperHybrid);\n        }\n\n        // Bootstrap Curve pools\n        fundCurveV2Pools(result.contractsArray, result.zappersArray);\n\n        // Bootstrap UniV3 pools\n        fundUniV3Pools(result.contractsArray);\n\n        // Give some Collateral to test accounts\n        uint256 initialCollateralAmount = 10_000e18;\n\n        // A to F\n        for (uint256 c = 0; c < NUM_COLLATERALS; c++) {\n            for (uint256 i = 0; i < 6; i++) {\n                // Give some raw ETH to test accounts\n                deal(accountsList[i], initialCollateralAmount);\n                // Give and approve some coll token to test accounts\n                deal(address(contractsArray[c].collToken), accountsList[i], initialCollateralAmount);\n                vm.startPrank(accountsList[i]);\n                contractsArray[c].collToken.approve(address(baseZapperArray[c]), initialCollateralAmount);\n                contractsArray[c].collToken.approve(address(leverageZapperCurveArray[c]), initialCollateralAmount);\n                contractsArray[c].collToken.approve(address(leverageZapperUniV3Array[c]), initialCollateralAmount);\n                contractsArray[c].collToken.approve(address(leverageZapperHybridArray[c]), initialCollateralAmount);\n                vm.stopPrank();\n            }\n        }\n\n        // exchange helpers\n        hybridCurveUniV3ExchangeHelpers = new HybridCurveUniV3ExchangeHelpers(\n            USDC,\n            WETH,\n            usdcCurvePool,\n            USDC_INDEX, // USDC Curve pool index\n            BOLD_TOKEN_INDEX, // BOLD Curve pool index\n            UNIV3_FEE_USDC_WETH,\n            UNIV3_FEE_WETH_COLL,\n            uniV3Quoter\n        );\n    }\n\n    function fundCurveV2Pools(\n        TestDeployer.LiquityContracts[] memory _contractsArray,\n        TestDeployer.Zappers[] memory _zappersArray\n    ) internal {\n        uint256 boldAmount;\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            (uint256 price,) = _contractsArray[i].priceFeed.fetchPrice();\n            ICurvePool curvePool = CurveExchange(address(_zappersArray[i].leverageZapperCurve.exchange())).curvePool();\n\n            // Add liquidity\n            uint256 collAmount = 1000 ether;\n            boldAmount = collAmount * price / DECIMAL_PRECISION;\n            deal(address(_contractsArray[i].collToken), A, collAmount);\n            deal(address(boldToken), A, boldAmount);\n            vm.startPrank(A);\n            // approve\n            _contractsArray[i].collToken.approve(address(curvePool), collAmount);\n            boldToken.approve(address(curvePool), boldAmount);\n            uint256[2] memory amounts;\n            amounts[0] = boldAmount;\n            amounts[1] = collAmount;\n            curvePool.add_liquidity(amounts, 0);\n            vm.stopPrank();\n        }\n\n        // Add liquidity to USDC-BOLD\n        usdcCurvePool = HybridCurveUniV3Exchange(address(_zappersArray[0].leverageZapperHybrid.exchange())).curvePool();\n        uint256 usdcAmount = 1e15; // 1B with 6 decimals\n        boldAmount = usdcAmount * 1e12; // from 6 to 18 decimals\n        deal(address(USDC), A, usdcAmount);\n        deal(address(boldToken), A, boldAmount);\n        vm.startPrank(A);\n        // approve\n        USDC.approve(address(usdcCurvePool), usdcAmount);\n        boldToken.approve(address(usdcCurvePool), boldAmount);\n        uint256[] memory amountsDynamic = new uint256[](2);\n        amountsDynamic[0] = boldAmount;\n        amountsDynamic[1] = usdcAmount;\n        // add liquidity\n        usdcCurvePool.add_liquidity(amountsDynamic, 0);\n        vm.stopPrank();\n    }\n\n    function fundUniV3Pools(TestDeployer.LiquityContracts[] memory _contractsArray) internal {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            (uint256 price,) = _contractsArray[i].priceFeed.fetchPrice();\n            //console2.log(price, \"price\");\n\n            // tokens and amounts\n            uint256 collAmount = 1000 ether;\n            uint256 boldAmount = collAmount * price / DECIMAL_PRECISION;\n            address[2] memory tokens;\n            uint256[2] memory amounts;\n            if (address(boldToken) < address(_contractsArray[i].collToken)) {\n                //console2.log(\"b < c\");\n                tokens[0] = address(boldToken);\n                tokens[1] = address(_contractsArray[i].collToken);\n                amounts[0] = boldAmount;\n                amounts[1] = collAmount;\n            } else {\n                //console2.log(\"c < b\");\n                tokens[0] = address(_contractsArray[i].collToken);\n                tokens[1] = address(boldToken);\n                amounts[0] = collAmount;\n                amounts[1] = boldAmount;\n            }\n\n            // Add liquidity\n\n            vm.startPrank(A);\n\n            // deal and approve\n            deal(address(_contractsArray[i].collToken), A, collAmount);\n            deal(address(boldToken), A, boldAmount);\n            _contractsArray[i].collToken.approve(address(uniV3PositionManager), collAmount);\n            boldToken.approve(address(uniV3PositionManager), boldAmount);\n\n            // mint new position\n            address uniV3PoolAddress =\n                uniswapV3Factory.getPool(address(boldToken), address(_contractsArray[i].collToken), UNIV3_FEE);\n            //console2.log(uniV3PoolAddress, \"uniV3PoolAddress\");\n            int24 TICK_SPACING = IUniswapV3Pool(uniV3PoolAddress).tickSpacing();\n            (, int24 tick,,,,,) = IUniswapV3Pool(uniV3PoolAddress).slot0();\n            int24 tickLower = (tick - 6000) / TICK_SPACING * TICK_SPACING;\n            int24 tickUpper = (tick + 6000) / TICK_SPACING * TICK_SPACING;\n            INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n                token0: tokens[0],\n                token1: tokens[1],\n                fee: UNIV3_FEE,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amounts[0],\n                amount1Desired: amounts[1],\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: A,\n                deadline: block.timestamp\n            });\n\n            uniV3PositionManager.mint(params);\n\n            vm.stopPrank();\n        }\n    }\n\n    // Implementing `onERC721Received` so this contract can receive custody of erc721 tokens\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    struct OpenLeveragedTroveWithIndexParams {\n        ILeverageZapper leverageZapper;\n        IERC20 collToken;\n        uint256 index;\n        uint256 collAmount;\n        uint256 leverageRatio;\n        IPriceFeed priceFeed;\n        ExchangeType exchangeType;\n        uint256 branch;\n        address batchManager;\n    }\n\n    function openLeveragedTroveWithIndex(OpenLeveragedTroveWithIndexParams memory _inputParams)\n        internal\n        returns (uint256, uint256)\n    {\n        OpenTroveVars memory vars;\n        (vars.price,) = _inputParams.priceFeed.fetchPrice();\n\n        // This should be done in the frontend\n        vars.flashLoanAmount =\n            _inputParams.collAmount * (_inputParams.leverageRatio - DECIMAL_PRECISION) / DECIMAL_PRECISION;\n        vars.expectedBoldAmount = vars.flashLoanAmount * vars.price / DECIMAL_PRECISION;\n        vars.maxNetDebt = vars.expectedBoldAmount * 105 / 100; // slippage\n        vars.effectiveBoldAmount = _getBoldAmountToSwap(\n            _inputParams.exchangeType,\n            _inputParams.branch,\n            vars.expectedBoldAmount,\n            vars.maxNetDebt,\n            vars.flashLoanAmount,\n            _inputParams.collToken\n        );\n\n        ILeverageZapper.OpenLeveragedTroveParams memory params = ILeverageZapper.OpenLeveragedTroveParams({\n            owner: A,\n            ownerIndex: _inputParams.index,\n            collAmount: _inputParams.collAmount,\n            flashLoanAmount: vars.flashLoanAmount,\n            boldAmount: vars.effectiveBoldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: _inputParams.batchManager == address(0) ? 5e16 : 0,\n            batchManager: _inputParams.batchManager,\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        vars.value = _inputParams.branch > 0 ? ETH_GAS_COMPENSATION : _inputParams.collAmount + ETH_GAS_COMPENSATION;\n        _inputParams.leverageZapper.openLeveragedTroveWithRawETH{value: vars.value}(params);\n        vars.troveId = addressToTroveIdThroughZapper(address(_inputParams.leverageZapper), A, _inputParams.index);\n        vm.stopPrank();\n\n        return (vars.troveId, vars.effectiveBoldAmount);\n    }\n\n    function _setInitialBalances(ILeverageZapper _leverageZapper, uint256 _branch, TestVars memory vars)\n        internal\n        view\n    {\n        vars.boldBalanceBeforeA = boldToken.balanceOf(A);\n        vars.ethBalanceBeforeA = A.balance;\n        vars.collBalanceBeforeA = contractsArray[_branch].collToken.balanceOf(A);\n        vars.boldBalanceBeforeZapper = boldToken.balanceOf(address(_leverageZapper));\n        vars.ethBalanceBeforeZapper = address(_leverageZapper).balance;\n        vars.collBalanceBeforeZapper = contractsArray[_branch].collToken.balanceOf(address(_leverageZapper));\n        vars.boldBalanceBeforeExchange = boldToken.balanceOf(address(_leverageZapper.exchange()));\n        vars.ethBalanceBeforeExchange = address(_leverageZapper.exchange()).balance;\n        vars.collBalanceBeforeExchange =\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper.exchange()));\n    }\n\n    function testCanOpenTroveWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanOpenTrove(leverageZapperCurveArray[i], ExchangeType.Curve, i, address(0));\n        }\n    }\n\n    function testCanOpenTroveWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanOpenTrove(leverageZapperUniV3Array[i], ExchangeType.UniV3, i, address(0));\n        }\n    }\n\n    function testCanOpenTroveWithHybrid() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testCanOpenTrove(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i, address(0));\n        }\n    }\n\n    function testCanOpenTroveAndJoinBatchWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _registerBatchManager(B, i);\n            _testCanOpenTrove(leverageZapperCurveArray[i], ExchangeType.Curve, i, B);\n        }\n    }\n\n    function testCanOpenTroveAndJoinBatchWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            if (i == 2) continue; // TODO!!\n            _registerBatchManager(B, i);\n            _testCanOpenTrove(leverageZapperUniV3Array[i], ExchangeType.UniV3, i, B);\n        }\n    }\n\n    function testCanOpenTroveAndJoinBatchWithHybrid() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _registerBatchManager(B, i);\n            _testCanOpenTrove(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i, B);\n        }\n    }\n\n    function _registerBatchManager(address _account, uint256 _branch) internal {\n        vm.startPrank(_account);\n        contractsArray[_branch].borrowerOperations.registerBatchManager(\n            uint128(1e16), uint128(20e16), uint128(5e16), uint128(25e14), MIN_INTEREST_RATE_CHANGE_PERIOD\n        );\n        vm.stopPrank();\n    }\n\n    function _testCanOpenTrove(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch,\n        address _batchManager\n    ) internal {\n        TestVars memory vars;\n        vars.collAmount = 10 ether;\n        vars.newLeverageRatio = 2e18;\n        vars.resultingCollateralRatio = _leverageZapper.leverageRatioToCollateralRatio(vars.newLeverageRatio);\n\n        _setInitialBalances(_leverageZapper, _branch, vars);\n\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = vars.collAmount;\n        openTroveParams.leverageRatio = vars.newLeverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = _batchManager;\n        uint256 expectedMinNetDebt;\n        (vars.troveId, expectedMinNetDebt) = openLeveragedTroveWithIndex(openTroveParams);\n\n        // Checks\n        (vars.price,) = contractsArray[_branch].priceFeed.fetchPrice();\n        // owner\n        assertEq(contractsArray[_branch].troveNFT.ownerOf(vars.troveId), A, \"Wrong owner\");\n        // troveId\n        assertGt(vars.troveId, 0, \"Trove id should be set\");\n        // coll\n        assertEq(\n            getTroveEntireColl(contractsArray[_branch].troveManager, vars.troveId),\n            vars.collAmount * vars.newLeverageRatio / DECIMAL_PRECISION,\n            \"Coll mismatch\"\n        );\n        // debt\n        uint256 expectedMaxNetDebt = expectedMinNetDebt * 105 / 100;\n        uint256 troveEntireDebt = getTroveEntireDebt(contractsArray[_branch].troveManager, vars.troveId);\n        assertGe(troveEntireDebt, expectedMinNetDebt, \"Debt too low\");\n        assertLe(troveEntireDebt, expectedMaxNetDebt, \"Debt too high\");\n        // CR\n        uint256 ICR = contractsArray[_branch].troveManager.getCurrentICR(vars.troveId, vars.price);\n        assertTrue(ICR >= vars.resultingCollateralRatio || vars.resultingCollateralRatio - ICR < 3e16, \"Wrong CR\");\n        // token balances\n        assertEq(boldToken.balanceOf(A), vars.boldBalanceBeforeA, \"BOLD bal mismatch\");\n        assertEq(\n            boldToken.balanceOf(address(_leverageZapper)), vars.boldBalanceBeforeZapper, \"Zapper should not keep BOLD\"\n        );\n        assertEq(\n            boldToken.balanceOf(address(_leverageZapper.exchange())),\n            vars.boldBalanceBeforeExchange,\n            \"Exchange should not keep BOLD\"\n        );\n        assertEq(\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper)),\n            vars.collBalanceBeforeZapper,\n            \"Zapper should not keep Coll\"\n        );\n        assertEq(\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper.exchange())),\n            vars.collBalanceBeforeExchange,\n            \"Exchange should not keep Coll\"\n        );\n        assertEq(address(_leverageZapper).balance, vars.ethBalanceBeforeZapper, \"Zapper should not keep ETH\");\n        assertEq(\n            address(_leverageZapper.exchange()).balance, vars.ethBalanceBeforeExchange, \"Exchange should not keep ETH\"\n        );\n        if (_branch > 0) {\n            // LST\n            assertEq(A.balance, vars.ethBalanceBeforeA - ETH_GAS_COMPENSATION, \"ETH bal mismatch\");\n            assertGe(\n                contractsArray[_branch].collToken.balanceOf(A),\n                vars.collBalanceBeforeA - vars.collAmount,\n                \"Coll bal mismatch\"\n            );\n        } else {\n            assertEq(A.balance, vars.ethBalanceBeforeA - ETH_GAS_COMPENSATION - vars.collAmount, \"ETH bal mismatch\");\n            assertGe(contractsArray[_branch].collToken.balanceOf(A), vars.collBalanceBeforeA, \"Coll bal mismatch\");\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallOpenTroveCallbackWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallOpenTroveCallback(leverageZapperCurveArray[i]);\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallOpenTroveCallbackWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallOpenTroveCallback(leverageZapperUniV3Array[i]);\n        }\n    }\n\n    function _testOnlyFlashLoanProviderCanCallOpenTroveCallback(ILeverageZapper _leverageZapper) internal {\n        ILeverageZapper.OpenLeveragedTroveParams memory params = ILeverageZapper.OpenLeveragedTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 10 ether,\n            flashLoanAmount: 10 ether,\n            boldAmount: 10000e18,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 5e16,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        vm.expectRevert(\"LZ: Caller not FlashLoan provider\");\n        IFlashLoanReceiver(address(_leverageZapper)).receiveFlashLoanOnOpenLeveragedTrove(params, 10 ether);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(_leverageZapper.flashLoanProvider().receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    // Lever up\n\n    struct LeverUpParams {\n        ILeverageZapper leverageZapper;\n        IERC20 collToken;\n        uint256 troveId;\n        uint256 leverageRatio;\n        ITroveManager troveManager;\n        IPriceFeed priceFeed;\n        ExchangeType exchangeType;\n        uint256 branch;\n    }\n\n    function _getLeverUpFlashLoanAndBoldAmount(LeverUpParams memory _params) internal returns (uint256, uint256) {\n        LeverVars memory vars;\n        (vars.price,) = _params.priceFeed.fetchPrice();\n        vars.currentCR = _params.troveManager.getCurrentICR(_params.troveId, vars.price);\n        vars.currentLR = _params.leverageZapper.leverageRatioToCollateralRatio(vars.currentCR);\n        assertGt(_params.leverageRatio, vars.currentLR, \"Leverage ratio should increase\");\n        vars.currentCollAmount = getTroveEntireColl(_params.troveManager, _params.troveId);\n        vars.flashLoanAmount = vars.currentCollAmount * _params.leverageRatio / vars.currentLR - vars.currentCollAmount;\n        vars.expectedBoldAmount = vars.flashLoanAmount * vars.price / DECIMAL_PRECISION;\n        vars.maxNetDebtIncrease = vars.expectedBoldAmount * 105 / 100; // slippage\n        // The actual bold we need, capped by the slippage above, to get flash loan amount\n        vars.effectiveBoldAmount = _getBoldAmountToSwap(\n            _params.exchangeType,\n            _params.branch,\n            vars.expectedBoldAmount,\n            vars.maxNetDebtIncrease,\n            vars.flashLoanAmount,\n            _params.collToken\n        );\n\n        return (vars.flashLoanAmount, vars.effectiveBoldAmount);\n    }\n\n    function leverUpTrove(LeverUpParams memory _params) internal returns (uint256, uint256) {\n        // This should be done in the frontend\n        (uint256 flashLoanAmount, uint256 effectiveBoldAmount) = _getLeverUpFlashLoanAndBoldAmount(_params);\n\n        ILeverageZapper.LeverUpTroveParams memory params = ILeverageZapper.LeverUpTroveParams({\n            troveId: _params.troveId,\n            flashLoanAmount: flashLoanAmount,\n            boldAmount: effectiveBoldAmount,\n            maxUpfrontFee: 1000e18\n        });\n        vm.startPrank(A);\n        _params.leverageZapper.leverUpTrove(params);\n        vm.stopPrank();\n\n        return (flashLoanAmount, effectiveBoldAmount);\n    }\n\n    function testCanLeverUpTroveWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanLeverUpTrove(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testCanLeverUpTroveWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanLeverUpTrove(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testCanLeverUpTroveWithHybrid() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testCanLeverUpTrove(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i);\n        }\n    }\n\n    function _testCanLeverUpTrove(ILeverageZapper _leverageZapper, ExchangeType _exchangeType, uint256 _branch)\n        internal\n    {\n        TestVars memory vars;\n        vars.collAmount = 10 ether;\n        vars.initialLeverageRatio = 2e18;\n\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = vars.collAmount;\n        openTroveParams.leverageRatio = vars.initialLeverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (vars.troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        vars.initialDebt = getTroveEntireDebt(contractsArray[_branch].troveManager, vars.troveId);\n\n        vars.newLeverageRatio = 2.5e18;\n        vars.resultingCollateralRatio = _leverageZapper.leverageRatioToCollateralRatio(vars.newLeverageRatio);\n\n        _setInitialBalances(_leverageZapper, _branch, vars);\n\n        LeverUpParams memory params;\n        params.leverageZapper = _leverageZapper;\n        params.collToken = contractsArray[_branch].collToken;\n        params.troveId = vars.troveId;\n        params.leverageRatio = vars.newLeverageRatio;\n        params.troveManager = contractsArray[_branch].troveManager;\n        params.priceFeed = contractsArray[_branch].priceFeed;\n        params.exchangeType = _exchangeType;\n        params.branch = _branch;\n        uint256 expectedMinLeverUpNetDebt;\n        (vars.flashLoanAmount, expectedMinLeverUpNetDebt) = leverUpTrove(params);\n\n        // Checks\n        (vars.price,) = contractsArray[_branch].priceFeed.fetchPrice();\n        // coll\n        uint256 coll = getTroveEntireColl(contractsArray[_branch].troveManager, vars.troveId);\n        uint256 collExpected = vars.collAmount * vars.newLeverageRatio / DECIMAL_PRECISION;\n        assertTrue(coll >= collExpected || collExpected - coll <= 4e17, \"Coll mismatch\");\n        // debt\n        uint256 expectedMinNetDebt = vars.initialDebt + expectedMinLeverUpNetDebt;\n        uint256 expectedMaxNetDebt = expectedMinNetDebt * 105 / 100;\n        uint256 troveEntireDebt = getTroveEntireDebt(contractsArray[_branch].troveManager, vars.troveId);\n        assertGe(troveEntireDebt, expectedMinNetDebt, \"Debt too low\");\n        assertLe(troveEntireDebt, expectedMaxNetDebt, \"Debt too high\");\n        // CR\n        uint256 ICR = contractsArray[_branch].troveManager.getCurrentICR(vars.troveId, vars.price);\n        assertTrue(ICR >= vars.resultingCollateralRatio || vars.resultingCollateralRatio - ICR < 2e16, \"Wrong CR\");\n        // token balances\n        assertEq(boldToken.balanceOf(A), vars.boldBalanceBeforeA, \"BOLD bal mismatch\");\n        assertEq(A.balance, vars.ethBalanceBeforeA, \"ETH bal mismatch\");\n        assertGe(contractsArray[_branch].collToken.balanceOf(A), vars.collBalanceBeforeA, \"Coll bal mismatch\");\n        assertEq(\n            boldToken.balanceOf(address(_leverageZapper)), vars.boldBalanceBeforeZapper, \"Zapper should not keep BOLD\"\n        );\n        assertEq(\n            boldToken.balanceOf(address(_leverageZapper.exchange())),\n            vars.boldBalanceBeforeExchange,\n            \"Exchange should not keep BOLD\"\n        );\n        assertEq(\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper)),\n            vars.collBalanceBeforeZapper,\n            \"Zapper should not keep Coll\"\n        );\n        assertEq(\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper.exchange())),\n            vars.collBalanceBeforeExchange,\n            \"Exchange should not keep Coll\"\n        );\n        assertEq(address(_leverageZapper).balance, vars.ethBalanceBeforeZapper, \"Zapper should not keep ETH\");\n        assertEq(\n            address(_leverageZapper.exchange()).balance, vars.ethBalanceBeforeExchange, \"Exchange should not keep ETH\"\n        );\n\n        // Check receiver is back to zero\n        assertEq(address(_leverageZapper.flashLoanProvider().receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testCannotLeverUpTroveWithCurveIfZapperIsNotReceiver() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotLeverUpTroveIfZapperIsNotReceiver(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testCannotLeverUpTroveWithUniV3IfZapperIsNotReceiver() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotLeverUpTroveIfZapperIsNotReceiver(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testCannotLeverUpTroveWithHybridIfZapperIsNotReceiver() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testCannotLeverUpTroveIfZapperIsNotReceiver(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i);\n        }\n    }\n\n    function _testCannotLeverUpTroveIfZapperIsNotReceiver(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        TestVars memory vars;\n        vars.collAmount = 10 ether;\n        vars.initialLeverageRatio = 2e18;\n\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = vars.collAmount;\n        openTroveParams.leverageRatio = vars.initialLeverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (vars.troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        vars.initialDebt = getTroveEntireDebt(contractsArray[_branch].troveManager, vars.troveId);\n\n        vars.newLeverageRatio = 2.5e18;\n        vars.resultingCollateralRatio = _leverageZapper.leverageRatioToCollateralRatio(vars.newLeverageRatio);\n\n        LeverUpParams memory getterParams;\n        getterParams.leverageZapper = _leverageZapper;\n        getterParams.collToken = contractsArray[_branch].collToken;\n        getterParams.troveId = vars.troveId;\n        getterParams.leverageRatio = vars.newLeverageRatio;\n        getterParams.troveManager = contractsArray[_branch].troveManager;\n        getterParams.priceFeed = contractsArray[_branch].priceFeed;\n        getterParams.exchangeType = _exchangeType;\n        getterParams.branch = _branch;\n\n        // This should be done in the frontend\n        (uint256 flashLoanAmount, uint256 effectiveBoldAmount) = _getLeverUpFlashLoanAndBoldAmount(getterParams);\n\n        ILeverageZapper.LeverUpTroveParams memory params = ILeverageZapper.LeverUpTroveParams({\n            troveId: vars.troveId,\n            flashLoanAmount: flashLoanAmount,\n            boldAmount: effectiveBoldAmount,\n            maxUpfrontFee: 1000e18\n        });\n        vm.startPrank(A);\n        // Change receiver in BO\n        contractsArray[_branch].borrowerOperations.setRemoveManagerWithReceiver(\n            vars.troveId, address(_leverageZapper), C\n        );\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        _leverageZapper.leverUpTrove(params);\n        vm.stopPrank();\n    }\n\n    function testOnlyFlashLoanProviderCanCallLeverUpCallbackWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallLeverUpCallback(leverageZapperCurveArray[i]);\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallLeverUpCallbackWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallLeverUpCallback(leverageZapperUniV3Array[i]);\n        }\n    }\n\n    function _testOnlyFlashLoanProviderCanCallLeverUpCallback(ILeverageZapper _leverageZapper) internal {\n        ILeverageZapper.LeverUpTroveParams memory params = ILeverageZapper.LeverUpTroveParams({\n            troveId: addressToTroveIdThroughZapper(address(_leverageZapper), A),\n            flashLoanAmount: 10 ether,\n            boldAmount: 10000e18,\n            maxUpfrontFee: 1000e18\n        });\n        vm.startPrank(A);\n        vm.expectRevert(\"LZ: Caller not FlashLoan provider\");\n        IFlashLoanReceiver(address(_leverageZapper)).receiveFlashLoanOnLeverUpTrove(params, 10 ether);\n        vm.stopPrank();\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithCurveFromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromZapper(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithUniV3FromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromZapper(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithHybridFromZapper() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromZapper(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i);\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanLeverUpFromZapper(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        LeverUpParams memory getterParams;\n        getterParams.leverageZapper = _leverageZapper;\n        getterParams.collToken = contractsArray[_branch].collToken;\n        getterParams.troveId = troveId;\n        getterParams.leverageRatio = 2.5e18;\n        getterParams.troveManager = contractsArray[_branch].troveManager;\n        getterParams.priceFeed = contractsArray[_branch].priceFeed;\n        getterParams.exchangeType = _exchangeType;\n        getterParams.branch = _branch;\n        (uint256 flashLoanAmount, uint256 effectiveBoldAmount) = _getLeverUpFlashLoanAndBoldAmount(getterParams);\n\n        ILeverageZapper.LeverUpTroveParams memory params = ILeverageZapper.LeverUpTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            boldAmount: effectiveBoldAmount,\n            maxUpfrontFee: 1000e18\n        });\n        // B tries to lever up A’s trove\n        vm.startPrank(B);\n        vm.expectRevert(AddRemoveManagers.NotOwnerNorRemoveManager.selector);\n        _leverageZapper.leverUpTrove(params);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(_leverageZapper.flashLoanProvider().receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithCurveFromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromBalancerFLProvider(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithUniV3FromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromBalancerFLProvider(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithHybridFromBalancerFLProvider() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromBalancerFLProvider(\n                leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i\n            );\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanLeverUpFromBalancerFLProvider(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 1;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        LeverUpParams memory getterParams;\n        getterParams.leverageZapper = _leverageZapper;\n        getterParams.collToken = contractsArray[_branch].collToken;\n        getterParams.troveId = troveId;\n        getterParams.leverageRatio = 2.5e18;\n        getterParams.troveManager = contractsArray[_branch].troveManager;\n        getterParams.priceFeed = contractsArray[_branch].priceFeed;\n        getterParams.exchangeType = _exchangeType;\n        getterParams.branch = _branch;\n        (uint256 flashLoanAmount, uint256 effectiveBoldAmount) = _getLeverUpFlashLoanAndBoldAmount(getterParams);\n\n        // B tries to lever up A’s trove calling our flash loan provider module\n        ILeverageZapper.LeverUpTroveParams memory params = ILeverageZapper.LeverUpTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            boldAmount: effectiveBoldAmount,\n            maxUpfrontFee: 1000e18\n        });\n        IFlashLoanProvider flashLoanProvider = _leverageZapper.flashLoanProvider();\n        vm.startPrank(B);\n        vm.expectRevert(); // reverts without data because it calls back B\n        flashLoanProvider.makeFlashLoan(\n            contractsArray[_branch].collToken,\n            flashLoanAmount,\n            IFlashLoanProvider.Operation.LeverUpTrove,\n            abi.encode(params)\n        );\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(flashLoanProvider.receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithCurveFromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromBalancerVault(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithUniV3FromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromBalancerVault(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverUpWithHybridFromBalancerVault() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanLeverUpFromBalancerVault(\n                leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i\n            );\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanLeverUpFromBalancerVault(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 2;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        // B tries to lever up A’s trove calling Balancer Vault directly\n        LeverUpParams memory getterParams;\n        getterParams.leverageZapper = _leverageZapper;\n        getterParams.collToken = contractsArray[_branch].collToken;\n        getterParams.troveId = troveId;\n        getterParams.leverageRatio = 2.5e18;\n        getterParams.troveManager = contractsArray[_branch].troveManager;\n        getterParams.priceFeed = contractsArray[_branch].priceFeed;\n        getterParams.exchangeType = _exchangeType;\n        getterParams.branch = _branch;\n        (uint256 flashLoanAmount, uint256 effectiveBoldAmount) = _getLeverUpFlashLoanAndBoldAmount(getterParams);\n\n        ILeverageZapper.LeverUpTroveParams memory params = ILeverageZapper.LeverUpTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            boldAmount: effectiveBoldAmount,\n            maxUpfrontFee: 1000e18\n        });\n        IFlashLoanProvider flashLoanProvider = _leverageZapper.flashLoanProvider();\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = contractsArray[_branch].collToken;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = flashLoanAmount;\n        bytes memory userData = abi.encode(address(_leverageZapper), IFlashLoanProvider.Operation.LeverUpTrove, params);\n        IVault vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n        vm.startPrank(B);\n        vm.expectRevert(\"Flash loan not properly initiated\");\n        vault.flashLoan(IFlashLoanRecipient(address(flashLoanProvider)), tokens, amounts, userData);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(flashLoanProvider.receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    // Lever down\n\n    function _getLeverDownFlashLoanAndBoldAmount(\n        ILeverageZapper _leverageZapper,\n        uint256 _troveId,\n        uint256 _leverageRatio,\n        ITroveManager _troveManager,\n        IPriceFeed _priceFeed\n    ) internal returns (uint256, uint256) {\n        (uint256 price,) = _priceFeed.fetchPrice();\n\n        uint256 currentCR = _troveManager.getCurrentICR(_troveId, price);\n        uint256 currentLR = _leverageZapper.leverageRatioToCollateralRatio(currentCR);\n        assertLt(_leverageRatio, currentLR, \"Leverage ratio should decrease\");\n        uint256 currentCollAmount = getTroveEntireColl(_troveManager, _troveId);\n        uint256 flashLoanAmount = currentCollAmount - currentCollAmount * _leverageRatio / currentLR;\n        uint256 expectedBoldAmount = flashLoanAmount * price / DECIMAL_PRECISION;\n        uint256 minBoldDebt = expectedBoldAmount * 95 / 100; // slippage\n\n        return (flashLoanAmount, minBoldDebt);\n    }\n\n    function leverDownTrove(\n        ILeverageZapper _leverageZapper,\n        uint256 _troveId,\n        uint256 _leverageRatio,\n        ITroveManager _troveManager,\n        IPriceFeed _priceFeed\n    ) internal returns (uint256) {\n        // This should be done in the frontend\n        (uint256 flashLoanAmount, uint256 minBoldDebt) =\n            _getLeverDownFlashLoanAndBoldAmount(_leverageZapper, _troveId, _leverageRatio, _troveManager, _priceFeed);\n\n        ILeverageZapper.LeverDownTroveParams memory params = ILeverageZapper.LeverDownTroveParams({\n            troveId: _troveId,\n            flashLoanAmount: flashLoanAmount,\n            minBoldAmount: minBoldDebt\n        });\n        vm.startPrank(A);\n        _leverageZapper.leverDownTrove(params);\n        vm.stopPrank();\n\n        return flashLoanAmount;\n    }\n\n    function testCanLeverDownTroveWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanLeverDownTrove(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testCanLeverDownTroveWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanLeverDownTrove(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testCanLeverDownTroveWithHybrid() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testCanLeverDownTrove(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i);\n        }\n    }\n\n    function _testCanLeverDownTrove(ILeverageZapper _leverageZapper, ExchangeType _exchangeType, uint256 _branch)\n        internal\n    {\n        TestVars memory vars;\n        vars.collAmount = 10 ether;\n        vars.initialLeverageRatio = 2e18;\n\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = vars.collAmount;\n        openTroveParams.leverageRatio = vars.initialLeverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (vars.troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        vars.initialDebt = getTroveEntireDebt(contractsArray[_branch].troveManager, vars.troveId);\n\n        vars.newLeverageRatio = 1.5e18;\n        vars.resultingCollateralRatio = _leverageZapper.leverageRatioToCollateralRatio(vars.newLeverageRatio);\n\n        _setInitialBalances(_leverageZapper, _branch, vars);\n\n        vars.flashLoanAmount = leverDownTrove(\n            _leverageZapper,\n            vars.troveId,\n            vars.newLeverageRatio,\n            contractsArray[_branch].troveManager,\n            contractsArray[_branch].priceFeed\n        );\n\n        // Checks\n        (vars.price,) = contractsArray[_branch].priceFeed.fetchPrice();\n        // coll\n        uint256 coll = getTroveEntireColl(contractsArray[_branch].troveManager, vars.troveId);\n        uint256 collExpected = vars.collAmount * vars.newLeverageRatio / DECIMAL_PRECISION;\n        assertTrue(coll >= collExpected || collExpected - coll <= 22e16, \"Coll mismatch\");\n        // debt\n        uint256 expectedMinNetDebt =\n            vars.initialDebt - vars.flashLoanAmount * vars.price / DECIMAL_PRECISION * 101 / 100;\n        uint256 expectedMaxNetDebt = expectedMinNetDebt * 105 / 100;\n        uint256 troveEntireDebt = getTroveEntireDebt(contractsArray[_branch].troveManager, vars.troveId);\n        assertGe(troveEntireDebt, expectedMinNetDebt, \"Debt too low\");\n        assertLe(troveEntireDebt, expectedMaxNetDebt, \"Debt too high\");\n        // CR\n        // When getting flashloan amount, we allow the min debt to deviate up to 5%\n        // That deviation can translate into CR, specially for UniV3 exchange which is the less efficient\n        // With UniV3, the quoter gives a price “too good”, meaning we exchange less, so the deleverage is lower\n        uint256 CRTolerance = _exchangeType == ExchangeType.UniV3 ? 9e16 : 17e15;\n        uint256 ICR = contractsArray[_branch].troveManager.getCurrentICR(vars.troveId, vars.price);\n        assertTrue(\n            ICR >= vars.resultingCollateralRatio || vars.resultingCollateralRatio - ICR < CRTolerance, \"Wrong CR\"\n        );\n        // token balances\n        assertEq(boldToken.balanceOf(A), vars.boldBalanceBeforeA, \"BOLD bal mismatch\");\n        assertEq(A.balance, vars.ethBalanceBeforeA, \"ETH bal mismatch\");\n        assertGe(contractsArray[_branch].collToken.balanceOf(A), vars.collBalanceBeforeA, \"Coll bal mismatch\");\n        assertEq(\n            boldToken.balanceOf(address(_leverageZapper)), vars.boldBalanceBeforeZapper, \"Zapper should not keep BOLD\"\n        );\n        assertEq(\n            boldToken.balanceOf(address(_leverageZapper.exchange())),\n            vars.boldBalanceBeforeExchange,\n            \"Exchange should not keep BOLD\"\n        );\n        assertEq(\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper)),\n            vars.collBalanceBeforeZapper,\n            \"Zapper should not keep Coll\"\n        );\n        assertEq(\n            contractsArray[_branch].collToken.balanceOf(address(_leverageZapper.exchange())),\n            vars.collBalanceBeforeExchange,\n            \"Exchange should not keep Coll\"\n        );\n        assertEq(address(_leverageZapper).balance, vars.ethBalanceBeforeZapper, \"Zapper should not keep ETH\");\n        assertEq(\n            address(_leverageZapper.exchange()).balance, vars.ethBalanceBeforeExchange, \"Exchange should not keep ETH\"\n        );\n\n        // Check receiver is back to zero\n        assertEq(address(_leverageZapper.flashLoanProvider().receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testCannotLeverDownWithCurveFromZapperIfZapperIsNotReceiver() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotLeverDownFromZapperIfZapperIsNotReceiver(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testCannotLeverDownWithUniV3FromZapperIfZapperIsNotReceiver() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotLeverDownFromZapperIfZapperIsNotReceiver(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testCannotLeverDownWithHybridFromZapperIfZapperIsNotReceiver() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testCannotLeverDownFromZapperIfZapperIsNotReceiver(\n                leverageZapperUniV3Array[i], ExchangeType.HybridCurveUniV3, i\n            );\n        }\n    }\n\n    function _testCannotLeverDownFromZapperIfZapperIsNotReceiver(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        (uint256 flashLoanAmount, uint256 minBoldDebt) = _getLeverDownFlashLoanAndBoldAmount(\n            _leverageZapper,\n            troveId,\n            1.5e18, // _leverageRatio,\n            contractsArray[_branch].troveManager,\n            contractsArray[_branch].priceFeed\n        );\n\n        ILeverageZapper.LeverDownTroveParams memory params = ILeverageZapper.LeverDownTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            minBoldAmount: minBoldDebt\n        });\n        vm.startPrank(A);\n        // Change receiver in BO\n        contractsArray[_branch].borrowerOperations.setRemoveManagerWithReceiver(troveId, address(_leverageZapper), C);\n\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        _leverageZapper.leverDownTrove(params);\n        vm.stopPrank();\n    }\n\n    function testOnlyFlashLoanProviderCanCallLeverDownCallbackWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallLeverDownCallback(leverageZapperCurveArray[i]);\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallLeverDownCallbackWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallLeverDownCallback(leverageZapperUniV3Array[i]);\n        }\n    }\n\n    function _testOnlyFlashLoanProviderCanCallLeverDownCallback(ILeverageZapper _leverageZapper) internal {\n        ILeverageZapper.LeverDownTroveParams memory params = ILeverageZapper.LeverDownTroveParams({\n            troveId: addressToTroveIdThroughZapper(address(_leverageZapper), A),\n            flashLoanAmount: 10 ether,\n            minBoldAmount: 10000e18\n        });\n        vm.startPrank(A);\n        vm.expectRevert(\"LZ: Caller not FlashLoan provider\");\n        IFlashLoanReceiver(address(_leverageZapper)).receiveFlashLoanOnLeverDownTrove(params, 10 ether);\n        vm.stopPrank();\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithCurveFromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromZapper(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithUniV3FromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromZapper(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithHybridFromZapper() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromZapper(leverageZapperUniV3Array[i], ExchangeType.HybridCurveUniV3, i);\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanLeverDownFromZapper(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 0;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        // B tries to lever up A’s trove\n        (uint256 flashLoanAmount, uint256 minBoldDebt) = _getLeverDownFlashLoanAndBoldAmount(\n            _leverageZapper,\n            troveId,\n            1.5e18, // _leverageRatio,\n            contractsArray[_branch].troveManager,\n            contractsArray[_branch].priceFeed\n        );\n\n        ILeverageZapper.LeverDownTroveParams memory params = ILeverageZapper.LeverDownTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            minBoldAmount: minBoldDebt\n        });\n        vm.startPrank(B);\n        vm.expectRevert(AddRemoveManagers.NotOwnerNorRemoveManager.selector);\n        _leverageZapper.leverDownTrove(params);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(_leverageZapper.flashLoanProvider().receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithCurveFromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromBalancerFLProvider(\n                leverageZapperCurveArray[i], ExchangeType.Curve, i\n            );\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithUniV3FromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromBalancerFLProvider(\n                leverageZapperUniV3Array[i], ExchangeType.UniV3, i\n            );\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithHybridFromBalancerFLProvider() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromBalancerFLProvider(\n                leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i\n            );\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanLeverDownFromBalancerFLProvider(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 1;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        // B tries to lever down A’s trove calling our flash loan provider module\n        (uint256 flashLoanAmount, uint256 minBoldDebt) = _getLeverDownFlashLoanAndBoldAmount(\n            _leverageZapper,\n            troveId,\n            1.5e18, // _leverageRatio,\n            contractsArray[_branch].troveManager,\n            contractsArray[_branch].priceFeed\n        );\n\n        ILeverageZapper.LeverDownTroveParams memory params = ILeverageZapper.LeverDownTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            minBoldAmount: minBoldDebt\n        });\n        IFlashLoanProvider flashLoanProvider = _leverageZapper.flashLoanProvider();\n        vm.startPrank(B);\n        vm.expectRevert(); // reverts without data because it calls back B\n        flashLoanProvider.makeFlashLoan(\n            contractsArray[_branch].collToken,\n            flashLoanAmount,\n            IFlashLoanProvider.Operation.LeverDownTrove,\n            abi.encode(params)\n        );\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(flashLoanProvider.receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithCurveFromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromBalancerVault(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithUniV3FromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromBalancerVault(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanLeverDownWithHybridFromBalancerVault() external {\n        // Not enough liquidity for ETHx\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanLeverDownFromBalancerVault(\n                leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i\n            );\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanLeverDownFromBalancerVault(\n        ILeverageZapper _leverageZapper,\n        ExchangeType _exchangeType,\n        uint256 _branch\n    ) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 leverageRatio = 2e18;\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = 2;\n        openTroveParams.collAmount = collAmount;\n        openTroveParams.leverageRatio = leverageRatio;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        // B tries to lever down A’s trove calling Balancer Vault directly\n        (uint256 flashLoanAmount, uint256 minBoldDebt) = _getLeverDownFlashLoanAndBoldAmount(\n            _leverageZapper,\n            troveId,\n            1.5e18, // _leverageRatio,\n            contractsArray[_branch].troveManager,\n            contractsArray[_branch].priceFeed\n        );\n\n        ILeverageZapper.LeverDownTroveParams memory params = ILeverageZapper.LeverDownTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            minBoldAmount: minBoldDebt\n        });\n        IFlashLoanProvider flashLoanProvider = _leverageZapper.flashLoanProvider();\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = contractsArray[_branch].collToken;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = flashLoanAmount;\n        bytes memory userData =\n            abi.encode(address(_leverageZapper), IFlashLoanProvider.Operation.LeverDownTrove, params);\n        IVault vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n        vm.startPrank(B);\n        vm.expectRevert(\"Flash loan not properly initiated\");\n        vault.flashLoan(IFlashLoanRecipient(address(flashLoanProvider)), tokens, amounts, userData);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(flashLoanProvider.receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    // Close trove\n\n    function testCanCloseTroveWithBaseZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanCloseTrove(baseZapperArray[i], i);\n        }\n    }\n\n    function testCanCloseTroveWithLeverageCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanCloseTrove(IZapper(leverageZapperCurveArray[i]), i);\n        }\n    }\n\n    function testCanCloseTroveWithLeverageUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCanCloseTrove(IZapper(leverageZapperUniV3Array[i]), i);\n        }\n    }\n\n    function testCanCloseTroveWithLeverageHybrid() external {\n        for (uint256 i = 0; i < 3; i++) {\n            _testCanCloseTrove(IZapper(leverageZapperHybridArray[i]), i);\n        }\n    }\n\n    function _getCloseFlashLoanAmount(uint256 _troveId, ITroveManager _troveManager, IPriceFeed _priceFeed)\n        internal\n        returns (uint256, uint256)\n    {\n        (uint256 price,) = _priceFeed.fetchPrice();\n\n        uint256 currentDebt = getTroveEntireDebt(_troveManager, _troveId);\n        uint256 currentColl = getTroveEntireColl(_troveManager, _troveId);\n        uint256 flashLoanAmount = currentDebt * DECIMAL_PRECISION / price * 105 / 100; // slippage\n\n        return (flashLoanAmount, currentColl - flashLoanAmount);\n    }\n\n    function closeTrove(IZapper _zapper, uint256 _troveId, ITroveManager _troveManager, IPriceFeed _priceFeed)\n        internal\n    {\n        // This should be done in the frontend\n        (uint256 flashLoanAmount, uint256 minExpectedCollateral) =\n            _getCloseFlashLoanAmount(_troveId, _troveManager, _priceFeed);\n\n        vm.startPrank(A);\n        _zapper.closeTroveFromCollateral(_troveId, flashLoanAmount, minExpectedCollateral);\n        vm.stopPrank();\n    }\n\n    function openTrove(\n        IZapper _zapper,\n        address _account,\n        uint256 _index,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        bool _lst\n    ) internal returns (uint256) {\n        return openTrove(_zapper, _account, _index, _collAmount, _boldAmount, _lst, MIN_ANNUAL_INTEREST_RATE);\n    }\n\n    function openTrove(\n        IZapper _zapper,\n        address _account,\n        uint256 _index,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        bool _lst,\n        uint256 _interestRate\n    ) internal returns (uint256) {\n        IZapper.OpenTroveParams memory openParams = IZapper.OpenTroveParams({\n            owner: _account,\n            ownerIndex: _index,\n            collAmount: _collAmount,\n            boldAmount: _boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: _interestRate,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n\n        vm.startPrank(_account);\n        uint256 value = _lst ? ETH_GAS_COMPENSATION : _collAmount + ETH_GAS_COMPENSATION;\n        uint256 troveId = _zapper.openTroveWithRawETH{value: value}(openParams);\n        vm.stopPrank();\n\n        return troveId;\n    }\n\n    function _testCanCloseTrove(IZapper _zapper, uint256 _branch) internal {\n        uint256 collAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        bool lst = _branch > 0;\n        uint256 troveId = openTrove(_zapper, A, 0, collAmount, boldAmount, lst);\n\n        // open a 2nd trove so we can close the 1st one\n        openTrove(_zapper, B, 0, 100 ether, 10000e18, lst);\n\n        uint256 boldBalanceBefore = boldToken.balanceOf(A);\n        uint256 collBalanceBefore = contractsArray[_branch].collToken.balanceOf(A);\n        uint256 ethBalanceBefore = A.balance;\n        (uint256 price,) = contractsArray[_branch].priceFeed.fetchPrice();\n        uint256 debtInColl =\n            getTroveEntireDebt(contractsArray[_branch].troveManager, troveId) * DECIMAL_PRECISION / price;\n\n        // Close trove\n        closeTrove(_zapper, troveId, contractsArray[_branch].troveManager, contractsArray[_branch].priceFeed);\n\n        assertEq(getTroveEntireColl(contractsArray[_branch].troveManager, troveId), 0, \"Coll mismatch\");\n        assertEq(getTroveEntireDebt(contractsArray[_branch].troveManager, troveId), 0, \"Debt mismatch\");\n        assertGe(boldToken.balanceOf(A), boldBalanceBefore, \"BOLD bal should not decrease\");\n        assertLe(boldToken.balanceOf(A), boldBalanceBefore * 105 / 100, \"BOLD bal can only increase by slippage margin\");\n        if (lst) {\n            assertGe(contractsArray[_branch].collToken.balanceOf(A), collBalanceBefore, \"Coll bal should not decrease\");\n            assertApproxEqAbs(\n                contractsArray[_branch].collToken.balanceOf(A),\n                collBalanceBefore + collAmount - debtInColl,\n                3e17,\n                \"Coll bal mismatch\"\n            );\n            assertEq(A.balance, ethBalanceBefore + ETH_GAS_COMPENSATION, \"ETH bal mismatch\");\n        } else {\n            assertEq(contractsArray[_branch].collToken.balanceOf(A), collBalanceBefore, \"Coll bal mismatch\");\n            assertGe(A.balance, ethBalanceBefore, \"ETH bal should not decrease\");\n            assertApproxEqAbs(\n                A.balance, ethBalanceBefore + collAmount + ETH_GAS_COMPENSATION - debtInColl, 3e17, \"ETH bal mismatch\"\n            );\n        }\n    }\n\n    function testCannotCloseTroveWithBaseZapperIfLessCollThanExpected() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotCloseTroveIfLessCollThanExpected(baseZapperArray[i], i);\n        }\n    }\n\n    function testCannotCloseTroveWithLeverageCurveIfLessCollThanExpected() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotCloseTroveIfLessCollThanExpected(IZapper(leverageZapperCurveArray[i]), i);\n        }\n    }\n\n    function testCannotCloseTroveWithLeverageUniV3IfLessCollThanExpected() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testCannotCloseTroveIfLessCollThanExpected(IZapper(leverageZapperUniV3Array[i]), i);\n        }\n    }\n\n    function testCannotCloseTroveWithLeverageHybridIfLessCollThanExpected() external {\n        for (uint256 i = 0; i < 3; i++) {\n            _testCannotCloseTroveIfLessCollThanExpected(IZapper(leverageZapperHybridArray[i]), i);\n        }\n    }\n\n    function _testCannotCloseTroveIfLessCollThanExpected(IZapper _zapper, uint256 _branch) internal {\n        uint256 collAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        bool lst = _branch > 0;\n        uint256 troveId = openTrove(_zapper, A, 0, collAmount, boldAmount, lst);\n\n        // open a 2nd trove so we can close the 1st one\n        openTrove(_zapper, B, 0, 100 ether, 10000e18, lst);\n\n        // Try to close trove\n        // This should be done in the frontend\n        (uint256 flashLoanAmount, uint256 minExpectedCollateral) =\n            _getCloseFlashLoanAmount(troveId, contractsArray[_branch].troveManager, contractsArray[_branch].priceFeed);\n\n        string memory revertReason = lst ? \"GCZ: Not enough collateral received\" : \"WZ: Not enough collateral received\";\n        vm.startPrank(A);\n        vm.expectRevert(bytes(revertReason));\n        _zapper.closeTroveFromCollateral(troveId, flashLoanAmount, minExpectedCollateral * 2);\n        vm.stopPrank();\n    }\n\n    function testCannotCloseTroveIfFrontRunByRedemption() external {\n        // Make sure redemption rate is not 100%\n        vm.warp(block.timestamp + 18 hours);\n\n        IZapper zapper = IZapper(leverageZapperHybridArray[0]);\n\n        uint256 collAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        // open a 2nd trove so we can close the A's one, with higher interest so it doesn't get redeemed\n        openTrove(zapper, B, 0, 100 ether, 10000e18, false, 1e17);\n\n        uint256 troveId = openTrove(zapper, A, 0, collAmount, boldAmount, false);\n\n        // Try to close trove\n        // This should be done in the frontend\n        (uint256 flashLoanAmount, uint256 minExpectedCollateral) =\n            _getCloseFlashLoanAmount(troveId, contractsArray[0].troveManager, contractsArray[0].priceFeed);\n\n        // Now attacker redeems from trove and increases Bold price\n        vm.startPrank(B);\n        // Redemption\n        collateralRegistry.redeemCollateral(10000e18, 0, 1e18);\n        uint256 troveDebt = getTroveEntireDebt(contractsArray[0].troveManager, troveId);\n        uint256 troveColl = getTroveEntireColl(contractsArray[0].troveManager, troveId);\n        assertLt(troveDebt, boldAmount, \"Trove debt should have decreased\");\n        assertLt(troveColl, collAmount, \"Trove coll should have decreased\");\n\n        // Swap WETH to USDC to increase price\n        uint256 swapWETHAmount = 10000e18;\n        deal(address(WETH), B, swapWETHAmount);\n        WETH.approve(address(uniV3Router), swapWETHAmount);\n        bytes memory path = abi.encodePacked(WETH, UNIV3_FEE_USDC_WETH, USDC);\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: B,\n            deadline: block.timestamp,\n            amountIn: swapWETHAmount,\n            amountOutMinimum: 0\n        });\n\n        uniV3Router.exactInput(params);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        vm.expectRevert(\"WZ: Not enough collateral received\");\n        zapper.closeTroveFromCollateral(troveId, flashLoanAmount, minExpectedCollateral);\n        vm.stopPrank();\n    }\n\n    function testOnlyFlashLoanProviderCanCallCloseTroveCallbackWithBaseZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallCloseTroveCallback(baseZapperArray[i], i);\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallCloseTroveCallbackWithCurve() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallCloseTroveCallback(leverageZapperCurveArray[i], i);\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallCloseTroveCallbackWithUniV3() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyFlashLoanProviderCanCallCloseTroveCallback(leverageZapperUniV3Array[i], i);\n        }\n    }\n\n    function testOnlyFlashLoanProviderCanCallCloseTroveCallbackWithHybrid() external {\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyFlashLoanProviderCanCallCloseTroveCallback(leverageZapperHybridArray[i], i);\n        }\n    }\n\n    function _testOnlyFlashLoanProviderCanCallCloseTroveCallback(IZapper _zapper, uint256 _branch) internal {\n        IZapper.CloseTroveParams memory params = IZapper.CloseTroveParams({\n            troveId: addressToTroveIdThroughZapper(address(_zapper), A),\n            flashLoanAmount: 10 ether,\n            minExpectedCollateral: 0,\n            receiver: address(0) // Set later\n        });\n\n        bool lst = _branch > 0;\n        string memory revertReason = lst ? \"GCZ: Caller not FlashLoan provider\" : \"WZ: Caller not FlashLoan provider\";\n        vm.startPrank(A);\n        vm.expectRevert(bytes(revertReason));\n        IFlashLoanReceiver(address(_zapper)).receiveFlashLoanOnCloseTroveFromCollateral(params, 10 ether);\n        vm.stopPrank();\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithBaseZapperFromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromZapper(baseZapperArray[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithCurveFromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromZapper(leverageZapperCurveArray[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithUniV3FromZapper() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromZapper(leverageZapperUniV3Array[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithHybridFromZapper() external {\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromZapper(leverageZapperHybridArray[i], i);\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanCloseTroveFromZapper(IZapper _zapper, uint256 _branch) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        bool lst = _branch > 0;\n        uint256 troveId = openTrove(_zapper, A, 0, collAmount, boldAmount, lst);\n\n        // B tries to close A’s trove\n        (uint256 flashLoanAmount, uint256 minExpectedCollateral) =\n            _getCloseFlashLoanAmount(troveId, contractsArray[_branch].troveManager, contractsArray[_branch].priceFeed);\n\n        vm.startPrank(B);\n        vm.expectRevert(AddRemoveManagers.NotOwnerNorRemoveManager.selector);\n        _zapper.closeTroveFromCollateral(troveId, flashLoanAmount, minExpectedCollateral);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(_zapper.flashLoanProvider().receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithBaseZapperFromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerFLProvider(baseZapperArray[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithCurveFromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerFLProvider(leverageZapperCurveArray[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithUniV3FromBalancerFLProvider() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerFLProvider(leverageZapperUniV3Array[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithHybridFromBalancerFLProvider() external {\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerFLProvider(leverageZapperHybridArray[i], i);\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanCloseTroveFromBalancerFLProvider(IZapper _zapper, uint256 _branch) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        bool lst = _branch > 0;\n        uint256 troveId = openTrove(_zapper, A, 0, collAmount, boldAmount, lst);\n\n        // B tries to close A’s trove calling our flash loan provider module\n        (uint256 flashLoanAmount, uint256 minExpectedCollateral) =\n            _getCloseFlashLoanAmount(troveId, contractsArray[_branch].troveManager, contractsArray[_branch].priceFeed);\n\n        IZapper.CloseTroveParams memory params = IZapper.CloseTroveParams({\n            troveId: troveId,\n            flashLoanAmount: flashLoanAmount,\n            minExpectedCollateral: minExpectedCollateral,\n            receiver: address(0) // Set later\n        });\n        IFlashLoanProvider flashLoanProvider = _zapper.flashLoanProvider();\n        vm.startPrank(B);\n        vm.expectRevert(); // reverts without data because it calls back B\n        flashLoanProvider.makeFlashLoan(\n            contractsArray[_branch].collToken,\n            flashLoanAmount,\n            IFlashLoanProvider.Operation.CloseTrove,\n            abi.encode(params)\n        );\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(flashLoanProvider.receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithBaseZapperFromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerVault(baseZapperArray[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithCurveFromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerVault(leverageZapperCurveArray[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithUniV3FromBalancerVault() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerVault(leverageZapperUniV3Array[i], i);\n        }\n    }\n\n    function testOnlyOwnerOrManagerCanCloseTroveWithHybridFromBalancerVault() external {\n        for (uint256 i = 0; i < 3; i++) {\n            _testOnlyOwnerOrManagerCanCloseTroveFromBalancerVault(leverageZapperHybridArray[i], i);\n        }\n    }\n\n    function _testOnlyOwnerOrManagerCanCloseTroveFromBalancerVault(IZapper _zapper, uint256 _branch) internal {\n        // Open trove\n        uint256 collAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        bool lst = _branch > 0;\n        uint256 troveId = openTrove(_zapper, A, 0, collAmount, boldAmount, lst);\n\n        // B tries to close A’s trove calling Balancer Vault directly\n        (uint256 flashLoanAmount, uint256 minExpectedCollateral) =\n            _getCloseFlashLoanAmount(troveId, contractsArray[_branch].troveManager, contractsArray[_branch].priceFeed);\n\n        IFlashLoanProvider flashLoanProvider = _zapper.flashLoanProvider();\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = contractsArray[_branch].collToken;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = flashLoanAmount;\n        bytes memory userData = abi.encode(\n            address(_zapper), IFlashLoanProvider.Operation.CloseTrove, troveId, flashLoanAmount, minExpectedCollateral\n        );\n        IVault vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n        vm.startPrank(B);\n        vm.expectRevert(\"Flash loan not properly initiated\");\n        vault.flashLoan(IFlashLoanRecipient(address(flashLoanProvider)), tokens, amounts, userData);\n        vm.stopPrank();\n\n        // Check receiver is back to zero\n        assertEq(address(flashLoanProvider.receiver()), address(0), \"Receiver should be zero\");\n    }\n\n    function testApprovalIsNotReset() external {\n        for (uint256 i = 0; i < NUM_COLLATERALS; i++) {\n            _testApprovalIsNotReset(leverageZapperCurveArray[i], ExchangeType.Curve, i);\n            _testApprovalIsNotReset(leverageZapperUniV3Array[i], ExchangeType.UniV3, i);\n        }\n        for (uint256 i = 0; i < 3; i++) {\n            _testApprovalIsNotReset(leverageZapperHybridArray[i], ExchangeType.HybridCurveUniV3, i);\n        }\n    }\n\n    function _testApprovalIsNotReset(ILeverageZapper _leverageZapper, ExchangeType _exchangeType, uint256 _branch)\n        internal\n    {\n        // Open non leveraged trove\n        openTrove(_leverageZapper, A, uint256(_exchangeType) * 2, 10 ether, 10000e18, _branch > 0);\n\n        // Now try to open leveraged trove, it should still work\n        OpenLeveragedTroveWithIndexParams memory openTroveParams;\n        openTroveParams.leverageZapper = _leverageZapper;\n        openTroveParams.collToken = contractsArray[_branch].collToken;\n        openTroveParams.index = uint256(_exchangeType) * 2 + 1;\n        openTroveParams.collAmount = 10 ether;\n        openTroveParams.leverageRatio = 1.5 ether;\n        openTroveParams.priceFeed = contractsArray[_branch].priceFeed;\n        openTroveParams.exchangeType = _exchangeType;\n        openTroveParams.branch = _branch;\n        openTroveParams.batchManager = address(0);\n        (uint256 troveId,) = openLeveragedTroveWithIndex(openTroveParams);\n\n        assertGt(getTroveEntireColl(contractsArray[_branch].troveManager, troveId), 0);\n        assertGt(getTroveEntireDebt(contractsArray[_branch].troveManager, troveId), 0);\n    }\n\n    // helper price functions\n\n    // Helper to get the actual bold we need, capped by a max value, to get flash loan amount\n    function _getBoldAmountToSwap(\n        ExchangeType _exchangeType,\n        uint256 _branch,\n        uint256 _boldAmount,\n        uint256 _maxBoldAmount,\n        uint256 _minCollAmount,\n        IERC20 _collToken\n    ) internal returns (uint256) {\n        if (_exchangeType == ExchangeType.Curve) {\n            return _getBoldAmountToSwapCurve(_branch, _boldAmount, _maxBoldAmount, _minCollAmount);\n        }\n\n        if (_exchangeType == ExchangeType.UniV3) {\n            return _getBoldAmountToSwapUniV3(_maxBoldAmount, _minCollAmount, _collToken);\n        }\n\n        return _getBoldAmountToSwapHybrid(_maxBoldAmount, _minCollAmount, _collToken);\n    }\n\n    function _getBoldAmountToSwapCurve(\n        uint256 _branch,\n        uint256 _boldAmount,\n        uint256 _maxBoldAmount,\n        uint256 _minCollAmount\n    ) internal view returns (uint256) {\n        ICurvePool curvePool = CurveExchange(address(leverageZapperCurveArray[_branch].exchange())).curvePool();\n\n        uint256 step = (_maxBoldAmount - _boldAmount) / 5; // In max 5 iterations we should reach the target, unless price is lower\n        uint256 dy;\n        // TODO: Optimizations: binary search, change the step depending on last dy, ...\n        // Or check if there’s any helper implemented anywhere\n        uint256 lastBoldAmount = _maxBoldAmount + step;\n        do {\n            lastBoldAmount -= step;\n            dy = curvePool.get_dy(BOLD_TOKEN_INDEX, COLL_TOKEN_INDEX, lastBoldAmount);\n        } while (dy > _minCollAmount && lastBoldAmount > step);\n\n        uint256 boldAmountToSwap = dy >= _minCollAmount ? lastBoldAmount : lastBoldAmount + step;\n        require(boldAmountToSwap <= _maxBoldAmount, \"Bold amount required too high\");\n\n        return boldAmountToSwap;\n    }\n\n    // See: https://docs.uniswap.org/contracts/v3/reference/periphery/interfaces/IQuoterV2\n    // These functions are not marked view because they rely on calling non-view functions and reverting to compute the result.\n    // They are also not gas efficient and should not be called on-chain.\n    function _getBoldAmountToSwapUniV3(uint256 _maxBoldAmount, uint256 _minCollAmount, IERC20 _collToken)\n        internal /* view */\n        returns (uint256)\n    {\n        IQuoterV2.QuoteExactOutputSingleParams memory params = IQuoterV2.QuoteExactOutputSingleParams({\n            tokenIn: address(boldToken),\n            tokenOut: address(_collToken),\n            amount: _minCollAmount,\n            fee: UNIV3_FEE,\n            sqrtPriceLimitX96: 0\n        });\n        (uint256 amountIn,,,) = uniV3Quoter.quoteExactOutputSingle(params);\n        require(amountIn <= _maxBoldAmount, \"Price too high\");\n\n        return amountIn;\n    }\n\n    function _getBoldAmountToSwapHybrid(uint256 _maxBoldAmount, uint256 _minCollAmount, IERC20 _collToken)\n        internal /* view */\n        returns (uint256)\n    {\n        // Uniswap\n        uint256 wethAmount;\n        IQuoterV2.QuoteExactOutputSingleParams memory quoterParams;\n        // Coll <- WETH\n        if (address(WETH) != address(_collToken)) {\n            quoterParams = IQuoterV2.QuoteExactOutputSingleParams({\n                tokenIn: address(WETH),\n                tokenOut: address(_collToken),\n                amount: _minCollAmount,\n                fee: UNIV3_FEE_WETH_COLL,\n                sqrtPriceLimitX96: 0\n            });\n            (wethAmount,,,) = uniV3Quoter.quoteExactOutputSingle(quoterParams);\n        } else {\n            wethAmount = _minCollAmount;\n        }\n        // WETH <- USDC\n        quoterParams = IQuoterV2.QuoteExactOutputSingleParams({\n            tokenIn: address(USDC),\n            tokenOut: address(WETH),\n            amount: wethAmount,\n            fee: UNIV3_FEE_USDC_WETH,\n            sqrtPriceLimitX96: 0\n        });\n        (uint256 usdcAmount,,,) = uniV3Quoter.quoteExactOutputSingle(quoterParams);\n\n        // Curve\n        // USDC <- BOLD\n        uint256 boldAmountToSwap = usdcCurvePool.get_dx(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), usdcAmount);\n        require(boldAmountToSwap <= _maxBoldAmount, \"Bold amount required too high\");\n\n        boldAmountToSwap = Math.min(boldAmountToSwap * 101 / 100, _maxBoldAmount); // TODO\n\n        return boldAmountToSwap;\n    }\n\n    // Helpers\n    function testHybridExchangeHelpers() public {\n        for (uint256 i = 0; i < 3; i++) {\n            (uint256 price,) = contractsArray[i].priceFeed.fetchPrice();\n            //console2.log(i, \"branch\");\n            //console2.log(price, \"price\");\n            //console2.log(price, \"amount\");\n            _testHybridExchangeHelpers(price, contractsArray[i].collToken, 1 ether, 1e16); // 1% slippage\n            //console2.log(price * 1e3, \"amount\");\n            _testHybridExchangeHelpers(price * 1e3, contractsArray[i].collToken, 1 ether, 1e16); // 1% slippage\n            //console2.log(price * 1e6, \"amount\");\n            _testHybridExchangeHelpers(price * 1e6, contractsArray[i].collToken, 1 ether, 1e16); // 1% slippage\n        }\n    }\n\n    function _testHybridExchangeHelpers(\n        uint256 _boldAmount,\n        IERC20 _collToken,\n        uint256 _desiredCollAmount,\n        uint256 _acceptedSlippage\n    ) internal {\n        (uint256 collAmount, uint256 slippage) =\n            hybridCurveUniV3ExchangeHelpers.getCollFromBold(_boldAmount, _collToken, _desiredCollAmount);\n        //console2.log(collAmount, \"collAmount\");\n        //console2.log(slippage, \"slippage\");\n        assertGe(collAmount, (DECIMAL_PRECISION - slippage) * _desiredCollAmount / DECIMAL_PRECISION);\n        assertLe(slippage, _acceptedSlippage);\n    }\n\n    function testHybridExchangeHelpersNoDeviation() public {\n        (uint256 price,) = contractsArray[0].priceFeed.fetchPrice();\n        (uint256 collAmount, uint256 slippage) =\n            hybridCurveUniV3ExchangeHelpers.getCollFromBold(price, contractsArray[0].collToken, 0);\n        assertGt(collAmount, 0);\n        assertEq(slippage, 0);\n    }\n}\n",
        "zapperWETH.t.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"./TestContracts/DevTestSetup.sol\";\nimport \"./TestContracts/WETH.sol\";\nimport \"src/Zappers/WETHZapper.sol\";\n\ncontract ZapperWETHTest is DevTestSetup {\n    function setUp() public override {\n        // Start tests at a non-zero timestamp\n        vm.warp(block.timestamp + 600);\n\n        accounts = new Accounts();\n        createAccounts();\n\n        (A, B, C, D, E, F, G) = (\n            accountsList[0],\n            accountsList[1],\n            accountsList[2],\n            accountsList[3],\n            accountsList[4],\n            accountsList[5],\n            accountsList[6]\n        );\n\n        WETH = new WETH9();\n\n        TestDeployer.TroveManagerParams[] memory troveManagerParams = new TestDeployer.TroveManagerParams[](1);\n        troveManagerParams[0] = TestDeployer.TroveManagerParams(150e16, 110e16, 10e16, 110e16, 5e16, 10e16);\n\n        TestDeployer deployer = new TestDeployer();\n        TestDeployer.LiquityContractsDev[] memory contractsArray;\n        TestDeployer.Zappers[] memory zappersArray;\n        (contractsArray, collateralRegistry, boldToken,,, zappersArray) =\n            deployer.deployAndConnectContracts(troveManagerParams, WETH);\n\n        // Set price feeds\n        contractsArray[0].priceFeed.setPrice(2000e18);\n\n        // Give some Collateral to test accounts\n        uint256 initialCollateralAmount = 10_000e18;\n\n        // A to F\n        for (uint256 i = 0; i < 6; i++) {\n            // Give some raw ETH to test accounts\n            deal(accountsList[i], initialCollateralAmount);\n        }\n\n        // Set first branch as default\n        addressesRegistry = contractsArray[0].addressesRegistry;\n        borrowerOperations = contractsArray[0].borrowerOperations;\n        troveManager = contractsArray[0].troveManager;\n        troveNFT = contractsArray[0].troveNFT;\n        wethZapper = zappersArray[0].wethZapper;\n    }\n\n    function testCanOpenTrove() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        uint256 ethBalanceBefore = A.balance;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 5e16,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        assertEq(troveNFT.ownerOf(troveId), A, \"Wrong owner\");\n        assertGt(troveId, 0, \"Trove id should be set\");\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount, \"Coll mismatch\");\n        assertGt(troveManager.getTroveEntireDebt(troveId), boldAmount, \"Debt mismatch\");\n        assertEq(boldToken.balanceOf(A), boldAmount, \"BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBefore - (ethAmount + ETH_GAS_COMPENSATION), \"ETH bal mismatch\");\n    }\n\n    function testCanOpenTroveWithBatchManager() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        uint256 ethBalanceBefore = A.balance;\n\n        registerBatchManager(B);\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 0,\n            batchManager: B,\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        assertEq(troveNFT.ownerOf(troveId), A, \"Wrong owner\");\n        assertGt(troveId, 0, \"Trove id should be set\");\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount, \"Coll mismatch\");\n        assertGt(troveManager.getTroveEntireDebt(troveId), boldAmount, \"Debt mismatch\");\n        assertEq(boldToken.balanceOf(A), boldAmount, \"BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBefore - (ethAmount + ETH_GAS_COMPENSATION), \"ETH bal mismatch\");\n        assertEq(borrowerOperations.interestBatchManagerOf(troveId), B, \"Wrong batch manager\");\n        (,,,,,,,, address tmBatchManagerAddress,) = troveManager.Troves(troveId);\n        assertEq(tmBatchManagerAddress, B, \"Wrong batch manager (TM)\");\n    }\n\n    function testCanNotOpenTroveWithBatchManagerAndInterest() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        registerBatchManager(B);\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 5e16,\n            batchManager: B,\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        vm.expectRevert(\"WZ: Cannot choose interest if joining a batch\");\n        wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n    }\n\n    function testCanAddColl() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 boldAmount = 10000e18;\n        uint256 ethAmount2 = 5 ether;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 5e16,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 ethBalanceBefore = A.balance;\n        vm.startPrank(A);\n        wethZapper.addCollWithRawETH{value: ethAmount2}(troveId);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount1 + ethAmount2, \"Coll mismatch\");\n        assertGt(troveManager.getTroveEntireDebt(troveId), boldAmount, \"Debt mismatch\");\n        assertEq(boldToken.balanceOf(A), boldAmount, \"BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBefore - ethAmount2, \"ETH bal mismatch\");\n    }\n\n    function testCanWithdrawColl() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 boldAmount = 10000e18;\n        uint256 ethAmount2 = 1 ether;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 5e16,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 ethBalanceBefore = A.balance;\n        vm.startPrank(A);\n        wethZapper.withdrawCollToRawETH(troveId, ethAmount2);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount1 - ethAmount2, \"Coll mismatch\");\n        assertGt(troveManager.getTroveEntireDebt(troveId), boldAmount, \"Debt mismatch\");\n        assertEq(boldToken.balanceOf(A), boldAmount, \"BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBefore + ethAmount2, \"ETH bal mismatch\");\n    }\n\n    function testCannotWithdrawCollIfZapperIsNotReceiver() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 boldAmount = 10000e18;\n        uint256 ethAmount2 = 1 ether;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: 5e16,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        // Change receiver in BO\n        borrowerOperations.setRemoveManagerWithReceiver(troveId, address(wethZapper), B);\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        wethZapper.withdrawCollToRawETH(troveId, ethAmount2);\n        vm.stopPrank();\n    }\n\n    function testCanNotAddReceiverWithoutRemoveManager() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount1 = 10000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        // Try to add a receiver for the zapper without remove manager\n        vm.startPrank(A);\n        vm.expectRevert(AddRemoveManagers.EmptyManager.selector);\n        wethZapper.setRemoveManagerWithReceiver(troveId, address(0), B);\n        vm.stopPrank();\n    }\n\n    function testCanRepayBold() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 boldBalanceBeforeA = boldToken.balanceOf(A);\n        uint256 ethBalanceBeforeA = A.balance;\n        uint256 boldBalanceBeforeB = boldToken.balanceOf(B);\n        uint256 ethBalanceBeforeB = B.balance;\n\n        // Add a remove manager for the zapper, and send bold\n        vm.startPrank(A);\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        boldToken.transfer(B, boldAmount2);\n        vm.stopPrank();\n\n        // Approve and repay\n        vm.startPrank(B);\n        boldToken.approve(address(wethZapper), boldAmount2);\n        wethZapper.repayBold(troveId, boldAmount2);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount, \"Trove coll mismatch\");\n        assertApproxEqAbs(\n            troveManager.getTroveEntireDebt(troveId), boldAmount1 - boldAmount2, 2e18, \"Trove  debt mismatch\"\n        );\n        assertEq(boldToken.balanceOf(A), boldBalanceBeforeA - boldAmount2, \"A BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBeforeA, \"A ETH bal mismatch\");\n        assertEq(boldToken.balanceOf(B), boldBalanceBeforeB, \"B BOLD bal mismatch\");\n        assertEq(B.balance, ethBalanceBeforeB, \"B ETH bal mismatch\");\n    }\n\n    function testCanWithdrawBold() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 boldBalanceBeforeA = boldToken.balanceOf(A);\n        uint256 ethBalanceBeforeA = A.balance;\n        uint256 boldBalanceBeforeB = boldToken.balanceOf(B);\n        uint256 ethBalanceBeforeB = B.balance;\n\n        // Add a remove manager for the zapper\n        vm.startPrank(A);\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        vm.stopPrank();\n\n        // Withdraw bold\n        vm.startPrank(B);\n        wethZapper.withdrawBold(troveId, boldAmount2, boldAmount2);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount, \"Trove coll mismatch\");\n        assertApproxEqAbs(\n            troveManager.getTroveEntireDebt(troveId), boldAmount1 + boldAmount2, 2e18, \"Trove  debt mismatch\"\n        );\n        assertEq(boldToken.balanceOf(A), boldBalanceBeforeA + boldAmount2, \"A BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBeforeA, \"A ETH bal mismatch\");\n        assertEq(boldToken.balanceOf(B), boldBalanceBeforeB, \"B BOLD bal mismatch\");\n        assertEq(B.balance, ethBalanceBeforeB, \"B ETH bal mismatch\");\n    }\n\n    function testCannotWithdrawBoldIfZapperIsNotReceiver() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        // Add a remove manager for the zapper\n        vm.startPrank(A);\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        // Change receiver in BO\n        borrowerOperations.setRemoveManagerWithReceiver(troveId, address(wethZapper), C);\n        vm.stopPrank();\n\n        // Withdraw bold\n        vm.startPrank(B);\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        wethZapper.withdrawBold(troveId, boldAmount2, boldAmount2);\n        vm.stopPrank();\n    }\n\n    // TODO: more adjustment combinations\n    function testCanAdjustTroveWithdrawCollAndBold() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 boldBalanceBeforeA = boldToken.balanceOf(A);\n        uint256 ethBalanceBeforeA = A.balance;\n        uint256 boldBalanceBeforeB = boldToken.balanceOf(B);\n        uint256 ethBalanceBeforeB = B.balance;\n\n        // Add a remove manager for the zapper\n        vm.startPrank(A);\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        vm.stopPrank();\n\n        // Adjust (withdraw coll and Bold)\n        vm.startPrank(B);\n        wethZapper.adjustTroveWithRawETH(troveId, ethAmount2, false, boldAmount2, true, boldAmount2);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount1 - ethAmount2, \"Trove coll mismatch\");\n        assertApproxEqAbs(\n            troveManager.getTroveEntireDebt(troveId), boldAmount1 + boldAmount2, 2e18, \"Trove  debt mismatch\"\n        );\n        assertEq(boldToken.balanceOf(A), boldBalanceBeforeA + boldAmount2, \"A BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBeforeA + ethAmount2, \"A ETH bal mismatch\");\n        assertEq(boldToken.balanceOf(B), boldBalanceBeforeB, \"B BOLD bal mismatch\");\n        assertEq(B.balance, ethBalanceBeforeB, \"B ETH bal mismatch\");\n    }\n\n    function testCannotAdjustTroveWithdrawCollAndBoldIfZapperIsNotReceiver() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        // Add a remove manager for the zapper\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        // Change receiver in BO\n        borrowerOperations.setRemoveManagerWithReceiver(troveId, address(wethZapper), C);\n        vm.stopPrank();\n\n        // Adjust (withdraw coll and Bold)\n        vm.startPrank(B);\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        wethZapper.adjustTroveWithRawETH(troveId, ethAmount2, false, boldAmount2, true, boldAmount2);\n        vm.stopPrank();\n    }\n\n    function testCanAdjustTroveAddCollAndBold() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        // A sends Bold to B\n        boldToken.transfer(B, boldAmount2);\n        vm.stopPrank();\n\n        uint256 boldBalanceBeforeA = boldToken.balanceOf(A);\n        uint256 ethBalanceBeforeA = A.balance;\n        uint256 boldBalanceBeforeB = boldToken.balanceOf(B);\n        uint256 ethBalanceBeforeB = B.balance;\n\n        // Add an add manager for the zapper\n        vm.startPrank(A);\n        wethZapper.setAddManager(troveId, B);\n        vm.stopPrank();\n\n        // Adjust (add coll and Bold)\n        vm.startPrank(B);\n        boldToken.approve(address(wethZapper), boldAmount2);\n        wethZapper.adjustTroveWithRawETH{value: ethAmount2}(troveId, ethAmount2, true, boldAmount2, false, boldAmount2);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), ethAmount1 + ethAmount2, \"Trove coll mismatch\");\n        assertApproxEqAbs(\n            troveManager.getTroveEntireDebt(troveId), boldAmount1 - boldAmount2, 2e18, \"Trove  debt mismatch\"\n        );\n        assertEq(boldToken.balanceOf(A), boldBalanceBeforeA, \"A BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBeforeA, \"A ETH bal mismatch\");\n        assertEq(boldToken.balanceOf(B), boldBalanceBeforeB - boldAmount2, \"B BOLD bal mismatch\");\n        assertEq(B.balance, ethBalanceBeforeB - ethAmount2, \"B ETH bal mismatch\");\n    }\n\n    function testCanAdjustZombieTroveWithdrawCollAndBold() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        // Add a remove manager for the zapper\n        vm.startPrank(A);\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        vm.stopPrank();\n\n        // Redeem to make trove zombie\n        vm.startPrank(A);\n        collateralRegistry.redeemCollateral(boldAmount1 - boldAmount2, 10, 1e18);\n        vm.stopPrank();\n\n        uint256 troveCollBefore = troveManager.getTroveEntireColl(troveId);\n        uint256 boldBalanceBeforeA = boldToken.balanceOf(A);\n        uint256 ethBalanceBeforeA = A.balance;\n        uint256 ethBalanceBeforeB = B.balance;\n\n        // Adjust (withdraw coll and Bold)\n        vm.startPrank(B);\n        wethZapper.adjustZombieTroveWithRawETH(troveId, ethAmount2, false, boldAmount2, true, 0, 0, boldAmount2);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), troveCollBefore - ethAmount2, \"Trove coll mismatch\");\n        assertApproxEqAbs(troveManager.getTroveEntireDebt(troveId), 2 * boldAmount2, 2e18, \"Trove  debt mismatch\");\n        assertEq(boldToken.balanceOf(A), boldBalanceBeforeA + boldAmount2, \"A BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBeforeA + ethAmount2, \"A ETH bal mismatch\");\n        assertEq(boldToken.balanceOf(B), 0, \"B BOLD bal mismatch\");\n        assertEq(B.balance, ethBalanceBeforeB, \"B ETH bal mismatch\");\n    }\n\n    function testCannotAdjustZombieTroveWithdrawCollAndBoldIfZapperIsNotReceiver() external {\n        uint256 ethAmount1 = 10 ether;\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount1 = 10000e18;\n        uint256 boldAmount2 = 1000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount1,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount1 + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        // Add a remove manager for the zapper\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        // Change receiver in BO\n        borrowerOperations.setRemoveManagerWithReceiver(troveId, address(wethZapper), C);\n        vm.stopPrank();\n\n        // Redeem to make trove zombie\n        vm.startPrank(A);\n        collateralRegistry.redeemCollateral(boldAmount1 - boldAmount2, 10, 1e18);\n        vm.stopPrank();\n\n        // Adjust (withdraw coll and Bold)\n        vm.startPrank(B);\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        wethZapper.adjustZombieTroveWithRawETH(troveId, ethAmount2, false, boldAmount2, true, 0, 0, boldAmount2);\n        vm.stopPrank();\n    }\n\n    function testCanAdjustZombieTroveAddCollAndWithdrawBold() external {\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: 10000e18,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: 10 ether + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        // Add a remove manager for the zapper\n        vm.startPrank(A);\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        vm.stopPrank();\n\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount2 = 1000e18;\n\n        // Redeem to make trove zombie\n        vm.startPrank(A);\n        collateralRegistry.redeemCollateral(10000e18 - boldAmount2, 10, 1e18);\n        vm.stopPrank();\n\n        uint256 troveCollBefore = troveManager.getTroveEntireColl(troveId);\n        uint256 boldBalanceBeforeA = boldToken.balanceOf(A);\n        uint256 ethBalanceBeforeA = A.balance;\n        uint256 ethBalanceBeforeB = B.balance;\n\n        // Adjust (add coll and withdraw Bold)\n        vm.startPrank(B);\n        wethZapper.adjustZombieTroveWithRawETH{value: ethAmount2}(\n            troveId, ethAmount2, true, boldAmount2, true, 0, 0, boldAmount2\n        );\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), troveCollBefore + ethAmount2, \"Trove coll mismatch\");\n        assertApproxEqAbs(troveManager.getTroveEntireDebt(troveId), 2 * boldAmount2, 2e18, \"Trove  debt mismatch\");\n        assertEq(boldToken.balanceOf(A), boldBalanceBeforeA + boldAmount2, \"A BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBeforeA, \"A ETH bal mismatch\");\n        assertEq(boldToken.balanceOf(B), 0, \"B BOLD bal mismatch\");\n        assertEq(B.balance, ethBalanceBeforeB - ethAmount2, \"B ETH bal mismatch\");\n    }\n\n    function testCannotAdjustZombieTroveAddCollAndWithdrawBoldIfZapperIsNotReceiver() external {\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: 10000e18,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: 10 ether + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        // Add a remove manager for the zapper\n        wethZapper.setRemoveManagerWithReceiver(troveId, B, A);\n        // Change receiver in BO\n        borrowerOperations.setRemoveManagerWithReceiver(troveId, address(wethZapper), C);\n        vm.stopPrank();\n\n        uint256 ethAmount2 = 1 ether;\n        uint256 boldAmount2 = 1000e18;\n\n        // Redeem to make trove zombie\n        vm.startPrank(A);\n        collateralRegistry.redeemCollateral(10000e18 - boldAmount2, 10, 1e18);\n        vm.stopPrank();\n\n        // Adjust (add coll and withdraw Bold)\n        vm.startPrank(B);\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        wethZapper.adjustZombieTroveWithRawETH{value: ethAmount2}(\n            troveId, ethAmount2, true, boldAmount2, true, 0, 0, boldAmount2\n        );\n        vm.stopPrank();\n    }\n\n    function testCanCloseTrove() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        uint256 ethBalanceBefore = A.balance;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        // open a 2nd trove so we can close the 1st one, and send Bold to account for interest and fee\n        vm.startPrank(B);\n        deal(address(WETH), B, 100 ether + ETH_GAS_COMPENSATION);\n        WETH.approve(address(borrowerOperations), 100 ether + ETH_GAS_COMPENSATION);\n        borrowerOperations.openTrove(\n            B,\n            0, // index,\n            100 ether, // coll,\n            10000e18, //boldAmount,\n            0, // _upperHint\n            0, // _lowerHint\n            MIN_ANNUAL_INTEREST_RATE, // annualInterestRate,\n            10000e18, // upfrontFee\n            address(0),\n            address(0),\n            address(0)\n        );\n        boldToken.transfer(A, troveManager.getTroveEntireDebt(troveId) - boldAmount);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        boldToken.approve(address(wethZapper), type(uint256).max);\n        wethZapper.closeTroveToRawETH(troveId);\n        vm.stopPrank();\n\n        assertEq(troveManager.getTroveEntireColl(troveId), 0, \"Coll mismatch\");\n        assertEq(troveManager.getTroveEntireDebt(troveId), 0, \"Debt mismatch\");\n        assertEq(boldToken.balanceOf(A), 0, \"BOLD bal mismatch\");\n        assertEq(A.balance, ethBalanceBefore, \"ETH bal mismatch\");\n    }\n\n    function testCannotCloseTroveIfZapperIsNotReceiver() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        // open a 2nd trove so we can close the 1st one, and send Bold to account for interest and fee\n        vm.startPrank(B);\n        deal(address(WETH), B, 100 ether + ETH_GAS_COMPENSATION);\n        WETH.approve(address(borrowerOperations), 100 ether + ETH_GAS_COMPENSATION);\n        borrowerOperations.openTrove(\n            B,\n            0, // index,\n            100 ether, // coll,\n            10000e18, //boldAmount,\n            0, // _upperHint\n            0, // _lowerHint\n            MIN_ANNUAL_INTEREST_RATE, // annualInterestRate,\n            10000e18, // upfrontFee\n            address(0),\n            address(0),\n            address(0)\n        );\n        boldToken.transfer(A, troveManager.getTroveEntireDebt(troveId) - boldAmount);\n        vm.stopPrank();\n\n        vm.startPrank(A);\n        // Change receiver in BO\n        borrowerOperations.setRemoveManagerWithReceiver(troveId, address(wethZapper), C);\n\n        boldToken.approve(address(wethZapper), type(uint256).max);\n        vm.expectRevert(\"BZ: Zapper is not receiver for this trove\");\n        wethZapper.closeTroveToRawETH(troveId);\n        vm.stopPrank();\n    }\n\n    function testExcessRepaymentByAdjustGoesBackToUser() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 ethBalanceBefore = A.balance;\n        uint256 collBalanceBefore = WETH.balanceOf(A);\n        uint256 boldDebtBefore = troveManager.getTroveEntireDebt(troveId);\n\n        // Adjust trove: remove 1 ETH and try to repay 9k (only will repay ~8k, up to MIN_DEBT)\n        vm.startPrank(A);\n        boldToken.approve(address(wethZapper), type(uint256).max);\n        wethZapper.adjustTroveWithRawETH(troveId, 1 ether, false, 9000e18, false, 0);\n        vm.stopPrank();\n\n        assertEq(boldToken.balanceOf(A), boldAmount + MIN_DEBT - boldDebtBefore, \"BOLD bal mismatch\");\n        assertEq(boldToken.balanceOf(address(wethZapper)), 0, \"Zapper BOLD bal should be zero\");\n        assertEq(A.balance, ethBalanceBefore + 1 ether, \"ETH bal mismatch\");\n        assertEq(address(wethZapper).balance, 0, \"Zapper ETH bal should be zero\");\n        assertEq(WETH.balanceOf(A), collBalanceBefore, \"Coll bal mismatch\");\n        assertEq(WETH.balanceOf(address(wethZapper)), 0, \"Zapper Coll bal should be zero\");\n    }\n\n    function testExcessRepaymentByRepayGoesBackToUser() external {\n        uint256 ethAmount = 10 ether;\n        uint256 boldAmount = 10000e18;\n\n        IZapper.OpenTroveParams memory params = IZapper.OpenTroveParams({\n            owner: A,\n            ownerIndex: 0,\n            collAmount: 0, // not needed\n            boldAmount: boldAmount,\n            upperHint: 0,\n            lowerHint: 0,\n            annualInterestRate: MIN_ANNUAL_INTEREST_RATE,\n            batchManager: address(0),\n            maxUpfrontFee: 1000e18,\n            addManager: address(0),\n            removeManager: address(0),\n            receiver: address(0)\n        });\n        vm.startPrank(A);\n        uint256 troveId = wethZapper.openTroveWithRawETH{value: ethAmount + ETH_GAS_COMPENSATION}(params);\n        vm.stopPrank();\n\n        uint256 boldDebtBefore = troveManager.getTroveEntireDebt(troveId);\n        uint256 collBalanceBefore = WETH.balanceOf(A);\n\n        // Adjust trove: try to repay 9k (only will repay ~8k, up to MIN_DEBT)\n        vm.startPrank(A);\n        boldToken.approve(address(wethZapper), type(uint256).max);\n        wethZapper.repayBold(troveId, 9000e18);\n        vm.stopPrank();\n\n        assertEq(boldToken.balanceOf(A), boldAmount + MIN_DEBT - boldDebtBefore, \"BOLD bal mismatch\");\n        assertEq(boldToken.balanceOf(address(wethZapper)), 0, \"Zapper BOLD bal should be zero\");\n        assertEq(address(wethZapper).balance, 0, \"Zapper ETH bal should be zero\");\n        assertEq(WETH.balanceOf(A), collBalanceBefore, \"Coll bal mismatch\");\n        assertEq(WETH.balanceOf(address(wethZapper)), 0, \"Zapper Coll bal should be zero\");\n    }\n\n    // TODO: tests for add/remove managers of zapper contract\n}\n"
    }
}