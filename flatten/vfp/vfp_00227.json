{
    "vfp_id": "vfp_00227",
    "project_name": "cantina_managed_sky_lockstake_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing fee check in the LSE",
            "description": "The LockstakeEngine contract sets the fee used in free operations as an immutable field in the constructor without validating it against WAD (10^18, the equivalent of 100%). In previous versions, a validation check ensured that the fee was less than WAD to prevent invalid configurations. The absence of this validation in the current version could allow deployment with an incorrect fee value, although it is set immutably and not dynamically adjustable. This does not pose an immediate exploit risk but reduces safety guarantees.\n",
            "severity": "Informational",
            "location": [
                "LockstakeEngine.sol#L131"
            ],
            "files": [
                "lockstake/src/LockstakeEngine.sol"
            ]
        }
    ],
    "affected_files": {
        "LockstakeEngine.sol": "// SPDX-FileCopyrightText: Â© 2023 Dai Foundation <www.daifoundation.org>\n// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.21;\n\nimport { LockstakeUrn } from \"src/LockstakeUrn.sol\";\nimport { Multicall } from \"src/Multicall.sol\";\n\ninterface VoteDelegateFactoryLike {\n    function created(address) external returns (uint256);\n}\n\ninterface VoteDelegateLike {\n    function lock(uint256) external;\n    function free(uint256) external;\n}\n\ninterface VatLike {\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function urns(bytes32, address) external view returns (uint256, uint256);\n    function hope(address) external;\n    function slip(bytes32, address, int256) external;\n    function frob(bytes32, address, address, address, int256, int256) external;\n    function grab(bytes32, address, address, address, int256, int256) external;\n}\n\ninterface UsdsJoinLike {\n    function vat() external view returns (VatLike);\n    function usds() external view returns (GemLike);\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n\ninterface GemLike {\n    function approve(address, uint256) external;\n    function transfer(address, uint256) external;\n    function transferFrom(address, address, uint256) external;\n    function mint(address, uint256) external;\n    function burn(address, uint256) external;\n}\n\ninterface JugLike {\n    function drip(bytes32) external returns (uint256);\n}\n\ncontract LockstakeEngine is Multicall {\n    // --- storage variables ---\n\n    mapping(address usr   => uint256 allowed)                         public wards;\n    mapping(address farm  => FarmStatus)                              public farms;\n    mapping(address owner => uint256 count)                           public ownerUrnsCount;\n    mapping(address owner => mapping(uint256 index => address urn))   public ownerUrns;\n    mapping(address urn   => address owner)                           public urnOwners;\n    mapping(address urn   => mapping(address usr => uint256 allowed)) public urnCan;\n    mapping(address urn   => address voteDelegate)                    public urnVoteDelegates;\n    mapping(address urn   => address farm)                            public urnFarms;\n    mapping(address urn   => uint256 auctionsCount)                   public urnAuctions;\n    JugLike                                                           public jug;\n\n    // --- constants and enums ---\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    enum FarmStatus { UNSUPPORTED, ACTIVE, DELETED }\n\n    // --- immutables ---\n\n    VoteDelegateFactoryLike immutable public voteDelegateFactory;\n    VatLike                 immutable public vat;\n    UsdsJoinLike            immutable public usdsJoin;\n    GemLike                 immutable public usds;\n    bytes32                 immutable public ilk;\n    GemLike                 immutable public sky;\n    GemLike                 immutable public lssky;\n    address                 immutable public urnImplementation;\n    uint256                 immutable public fee;\n\n    // --- events ---   \n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event File(bytes32 indexed what, address data);\n    event AddFarm(address farm);\n    event DelFarm(address farm);\n    event Open(address indexed owner, uint256 indexed index, address urn);\n    event Hope(address indexed owner, uint256 indexed index, address indexed usr);\n    event Nope(address indexed owner, uint256 indexed index, address indexed usr);\n    event SelectVoteDelegate(address indexed owner, uint256 indexed index, address indexed voteDelegate);\n    event SelectFarm(address indexed owner, uint256 indexed index, address indexed farm, uint16 ref);\n    event Lock(address indexed owner, uint256 indexed index, uint256 wad, uint16 ref);\n    event Free(address indexed owner, uint256 indexed index, address to, uint256 wad, uint256 freed);\n    event FreeNoFee(address indexed owner, uint256 indexed index, address to, uint256 wad);\n    event Draw(address indexed owner, uint256 indexed index, address to, uint256 wad);\n    event Wipe(address indexed owner, uint256 indexed index, uint256 wad);\n    event GetReward(address indexed owner, uint256 indexed index, address indexed farm, address to, uint256 amt);\n    event OnKick(address indexed urn, uint256 wad);\n    event OnTake(address indexed urn, address indexed who, uint256 wad);\n    event OnRemove(address indexed urn, uint256 sold, uint256 burn, uint256 refund);\n\n    // --- modifiers ---\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"LockstakeEngine/not-authorized\");\n        _;\n    }\n\n    // --- constructor ---\n\n    constructor(address voteDelegateFactory_, address usdsJoin_, bytes32 ilk_, address sky_, address lssky_, uint256 fee_) {\n        voteDelegateFactory = VoteDelegateFactoryLike(voteDelegateFactory_);\n        usdsJoin = UsdsJoinLike(usdsJoin_);\n        vat = usdsJoin.vat();\n        usds = usdsJoin.usds();\n        ilk = ilk_;\n        sky = GemLike(sky_);\n        lssky = GemLike(lssky_);\n        fee = fee_;\n        urnImplementation = address(new LockstakeUrn(address(vat), lssky_));\n        vat.hope(usdsJoin_);\n        usds.approve(usdsJoin_, type(uint256).max);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- internals ---\n\n    function _min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n\n    function _divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // Note: _divup(0,0) will return 0 differing from natural solidity division\n        unchecked {\n            z = x != 0 ? ((x - 1) / y) + 1 : 0;\n        }\n    }\n\n    function _urnAuth(address owner, address urn, address usr) internal view returns (bool ok) {\n        ok = owner == usr || urnCan[urn][usr] == 1;\n    }\n\n    function _getUrn(address owner, uint256 index) internal view returns (address urn) {\n        urn = ownerUrns[owner][index];\n        require(urn != address(0), \"LockstakeEngine/invalid-urn\");\n    }\n\n    function _getAuthedUrn(address owner, uint256 index) internal view returns (address urn) {\n        urn = _getUrn(owner, index);\n        require(_urnAuth(owner, urn, msg.sender), \"LockstakeEngine/urn-not-authorized\");\n    }\n\n    // See the reference implementation in https://eips.ethereum.org/EIPS/eip-1167\n    function _initCode() internal view returns (bytes memory code) {\n        code = new bytes(0x37);\n        bytes20 impl = bytes20(urnImplementation);\n        assembly {\n            mstore(add(code,     0x20),        0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(code, add(0x20, 0x14)), impl)\n            mstore(add(code, add(0x20, 0x28)), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n        }\n    }\n\n    // --- administration ---\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    function file(bytes32 what, address data) external auth {\n        if (what == \"jug\") {\n            jug = JugLike(data);\n        } else revert(\"LockstakeEngine/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function addFarm(address farm) external auth {\n        farms[farm] = FarmStatus.ACTIVE;\n        emit AddFarm(farm);\n    }\n\n    function delFarm(address farm) external auth {\n        farms[farm] = FarmStatus.DELETED;\n        emit DelFarm(farm);\n    }\n\n    // --- getters ---\n\n    function isUrnAuth(address owner, uint256 index, address usr) external view returns (bool ok) {\n        ok = _urnAuth(owner, _getUrn(owner, index), usr);\n    }\n\n    // --- urn management functions ---\n\n    function open(uint256 index) external returns (address urn) {\n        require(index == ownerUrnsCount[msg.sender]++, \"LockstakeEngine/wrong-urn-index\");\n        bytes memory initCode = _initCode();\n        assembly { urn := create(0, add(initCode, 0x20), 0x37) }\n        LockstakeUrn(urn).init(); // would revert if create had failed\n        ownerUrns[msg.sender][index] = urn;\n        urnOwners[urn] = msg.sender;\n        emit Open(msg.sender, index, urn);\n    }\n\n    function hope(address owner, uint256 index, address usr) external {\n        address urn = _getAuthedUrn(owner, index);\n        urnCan[urn][usr] = 1;\n        emit Hope(owner, index, usr);\n    }\n\n    function nope(address owner, uint256 index, address usr) external {\n        address urn = _getAuthedUrn(owner, index);\n        urnCan[urn][usr] = 0;\n        emit Nope(owner, index, usr);\n    }\n\n    // --- delegation/staking functions ---\n\n    function selectVoteDelegate(address owner, uint256 index, address voteDelegate) external {\n        address urn = _getAuthedUrn(owner, index);\n        require(urnAuctions[urn] == 0, \"LockstakeEngine/urn-in-auction\");\n        require(voteDelegate == address(0) || voteDelegateFactory.created(voteDelegate) == 1, \"LockstakeEngine/not-valid-vote-delegate\");\n        address prevVoteDelegate = urnVoteDelegates[urn];\n        require(prevVoteDelegate != voteDelegate, \"LockstakeEngine/same-vote-delegate\");\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n        if (art > 0 && voteDelegate != address(0)) {\n            (,, uint256 spot,,) = vat.ilks(ilk);\n            require(ink * spot >= art * jug.drip(ilk), \"LockstakeEngine/urn-unsafe\");\n        }\n        _selectVoteDelegate(urn, ink, prevVoteDelegate, voteDelegate);\n        emit SelectVoteDelegate(owner, index, voteDelegate);\n    }\n\n    function _selectVoteDelegate(address urn, uint256 wad, address prevVoteDelegate, address voteDelegate) internal {\n        if (wad > 0) {\n            if (prevVoteDelegate != address(0)) {\n                VoteDelegateLike(prevVoteDelegate).free(wad);\n            }\n            if (voteDelegate != address(0)) {\n                sky.approve(voteDelegate, wad);\n                VoteDelegateLike(voteDelegate).lock(wad);\n            }\n        }\n        urnVoteDelegates[urn] = voteDelegate;\n    }\n\n    function selectFarm(address owner, uint256 index, address farm, uint16 ref) external {\n        address urn = _getAuthedUrn(owner, index);\n        require(urnAuctions[urn] == 0, \"LockstakeEngine/urn-in-auction\");\n        require(farm == address(0) || farms[farm] == FarmStatus.ACTIVE, \"LockstakeEngine/farm-unsupported-or-deleted\");\n        address prevFarm = urnFarms[urn];\n        require(prevFarm != farm, \"LockstakeEngine/same-farm\");\n        (uint256 ink,) = vat.urns(ilk, urn);\n        _selectFarm(urn, ink, prevFarm, farm, ref);\n        emit SelectFarm(owner, index, farm, ref);\n    }\n\n    function _selectFarm(address urn, uint256 wad, address prevFarm, address farm, uint16 ref) internal {\n        if (wad > 0) {\n            if (prevFarm != address(0)) {\n                LockstakeUrn(urn).withdraw(prevFarm, wad);\n            }\n            if (farm != address(0)) {\n                LockstakeUrn(urn).stake(farm, wad, ref);\n            }\n        }\n        urnFarms[urn] = farm;\n    }\n\n    function lock(address owner, uint256 index, uint256 wad, uint16 ref) external {\n        address urn = _getUrn(owner, index);\n        sky.transferFrom(msg.sender, address(this), wad);\n        require(wad <= uint256(type(int256).max), \"LockstakeEngine/overflow\");\n        address voteDelegate = urnVoteDelegates[urn];\n        if (voteDelegate != address(0)) {\n            sky.approve(voteDelegate, wad);\n            VoteDelegateLike(voteDelegate).lock(wad);\n        }\n        vat.slip(ilk, urn, int256(wad));\n        vat.frob(ilk, urn, urn, address(0), int256(wad), 0);\n        lssky.mint(urn, wad);\n        address urnFarm = urnFarms[urn];\n        if (urnFarm != address(0)) {\n            require(farms[urnFarm] == FarmStatus.ACTIVE, \"LockstakeEngine/farm-deleted\");\n            LockstakeUrn(urn).stake(urnFarm, wad, ref);\n        }\n        emit Lock(owner, index, wad, ref);\n    }\n\n    function free(address owner, uint256 index, address to, uint256 wad) external returns (uint256 freed) {\n        address urn = _getAuthedUrn(owner, index);\n        freed = _free(urn, wad, fee);\n        sky.transfer(to, freed);\n        emit Free(owner, index, to, wad, freed);\n    }\n\n    function freeNoFee(address owner, uint256 index, address to, uint256 wad) external auth {\n        address urn = _getAuthedUrn(owner, index);\n        _free(urn, wad, 0);\n        sky.transfer(to, wad);\n        emit FreeNoFee(owner, index, to, wad);\n    }\n\n    function _free(address urn, uint256 wad, uint256 fee_) internal returns (uint256 freed) {\n        require(wad <= uint256(type(int256).max), \"LockstakeEngine/overflow\");\n        address urnFarm = urnFarms[urn];\n        if (urnFarm != address(0)) {\n            LockstakeUrn(urn).withdraw(urnFarm, wad);\n        }\n        lssky.burn(urn, wad);\n        vat.frob(ilk, urn, urn, address(0), -int256(wad), 0);\n        vat.slip(ilk, urn, -int256(wad));\n        address voteDelegate = urnVoteDelegates[urn];\n        if (voteDelegate != address(0)) {\n            VoteDelegateLike(voteDelegate).free(wad);\n        }\n        uint256 burn = wad * fee_ / WAD;\n        if (burn > 0) {\n            sky.burn(address(this), burn);\n        }\n        unchecked { freed = wad - burn; } // burn <= wad always\n    }\n\n    // --- loan functions ---\n\n    function draw(address owner, uint256 index, address to, uint256 wad) external {\n        address urn = _getAuthedUrn(owner, index);\n        uint256 rate = jug.drip(ilk);\n        uint256 dart = _divup(wad * RAY, rate);\n        require(dart <= uint256(type(int256).max), \"LockstakeEngine/overflow\");\n        vat.frob(ilk, urn, address(0), address(this), 0, int256(dart));\n        usdsJoin.exit(to, wad);\n        emit Draw(owner, index, to, wad);\n    }\n\n    function wipe(address owner, uint256 index, uint256 wad) external {\n        address urn = _getUrn(owner, index);\n        usds.transferFrom(msg.sender, address(this), wad);\n        usdsJoin.join(address(this), wad);\n        (, uint256 rate,,,) = vat.ilks(ilk);\n        uint256 dart = wad * RAY / rate;\n        require(dart <= uint256(type(int256).max), \"LockstakeEngine/overflow\");\n        vat.frob(ilk, urn, address(0), address(this), 0, -int256(dart));\n        emit Wipe(owner, index, wad);\n    }\n\n    function wipeAll(address owner, uint256 index) external returns (uint256 wad) {\n        address urn = _getUrn(owner, index);\n        (, uint256 art) = vat.urns(ilk, urn);\n        require(art <= uint256(type(int256).max), \"LockstakeEngine/overflow\");\n        (, uint256 rate,,,) = vat.ilks(ilk);\n        wad = _divup(art * rate, RAY);\n        usds.transferFrom(msg.sender, address(this), wad);\n        usdsJoin.join(address(this), wad);\n        vat.frob(ilk, urn, address(0), address(this), 0, -int256(art));\n        emit Wipe(owner, index, wad);\n    }\n\n    // --- staking rewards function ---\n\n    function getReward(address owner, uint256 index, address farm, address to) external returns (uint256 amt) {\n        address urn = _getAuthedUrn(owner, index);\n        require(farms[farm] > FarmStatus.UNSUPPORTED, \"LockstakeEngine/farm-unsupported\");\n        amt = LockstakeUrn(urn).getReward(farm, to);\n        emit GetReward(owner, index, farm, to, amt);\n    }\n\n    // --- liquidation callback functions ---\n\n    function onKick(address urn, uint256 wad) external auth {\n        // Urn confiscation happens in Dog contract where ilk vat.gem is sent to the LockstakeClipper\n        (uint256 ink,) = vat.urns(ilk, urn);\n        uint256 inkBeforeKick = ink + wad;\n        _selectVoteDelegate(urn, inkBeforeKick, urnVoteDelegates[urn], address(0));\n        _selectFarm(urn, inkBeforeKick, urnFarms[urn], address(0), 0);\n        lssky.burn(urn, wad);\n        urnAuctions[urn]++;\n        emit OnKick(urn, wad);\n    }\n\n    function onTake(address urn, address who, uint256 wad) external auth {\n        sky.transfer(who, wad); // Free SKY to the auction buyer\n        emit OnTake(urn, who, wad);\n    }\n\n    function onRemove(address urn, uint256 sold, uint256 left) external auth {\n        uint256 burn;\n        uint256 refund;\n        if (left > 0) {\n            uint256 fee_ = fee;\n            burn = _min(sold * fee_ / (WAD - fee_), left);\n            sky.burn(address(this), burn);\n            unchecked { refund = left - burn; }\n            if (refund > 0) {\n                // The following is ensured by the dog and clip but we still prefer to be explicit\n                require(refund <= uint256(type(int256).max), \"LockstakeEngine/overflow\");\n                vat.slip(ilk, urn, int256(refund));\n                vat.grab(ilk, urn, urn, address(0), int256(refund), 0);\n                lssky.mint(urn, refund);\n            }\n        }\n        urnAuctions[urn]--;\n        emit OnRemove(urn, sold, burn, refund);\n    }\n}\n"
    }
}