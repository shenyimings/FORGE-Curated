{
    "vfp_id": "vfp_00417",
    "project_name": "cantina_panoptic_sep2025.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Lack of end-to-end Merkle tests before release",
            "description": "1. **Description:** The project lacks integration or fork-based end-to-end tests that validate the entire Merkle distribution process, including leaf encoding, proof verification, and token balances.\n2. **Cause:** Absence of pre-deployment testing that reconstructs the Merkle root and simulates claims for all leaves under real conditions.\n3. **Exploitation:** Discrepancies in leaf data (e.g., incorrect amounts, malformed addresses, or unsupported tokens) may only be discovered post-deployment, potentially preventing some users from claiming their tokens.\n4. **Impact:** Risk of denial-of-service for legitimate claimants if data inconsistencies exist, leading to reputational damage and user fund loss.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "multitoken-merkle-distributor/test/MerkleDistributor.t.sol",
                "multitoken-merkle-distributor/test/MerkleDistributor.test.ts",
                "multitoken-merkle-distributor/test/MerkleDistributor.spec.ts.old"
            ]
        }
    ],
    "affected_files": {
        "MerkleDistributor.t.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.22;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../contracts/MerkleDistributor.sol\";\n\ncontract MerkleDistributorTest is Test {\n    MerkleDistributor public distributor;\n    address public admin = address(0x123);\n\n    // Vault account that has funds on all chains\n    address constant VAULT_ACCOUNT = 0x82BF455e9ebd6a541EF10b683dE1edCaf05cE7A1;\n\n    // Proofs and samples generated from ~/scripts/generate-multitoken-merkle-root.ts\n    // Output files found in ~/data/{chainName}-merkle-data.json, using the ~/data/{chainName}_balances.csv files as our source of truth for\n    // what each Panoptic user should be able to reclaim\n    // ============ BASE CHAIN CONSTANTS ============\n    bytes32 constant BASE_MERKLE_ROOT = 0xb2b025a07391f5072db59ddbd44c1f08d8c45aaf6540daab2f8a5ba21bb340d0;\n    address constant BASE_WETH = 0x4200000000000000000000000000000000000006;\n    address constant BASE_USDC = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;\n    address constant BASE_TEST_ACCOUNT = 0x0235a7aE51301c3cb19493D7E37f9eFdd7c5c3bB;\n    uint256 constant BASE_TEST_INDEX = 0;\n\n    // ============ ETHEREUM MAINNET CONSTANTS ============\n    bytes32 constant MAINNET_MERKLE_ROOT = 0xfc98cc0d1bbbbddd72b72d70d01dd5fc1bcf5bdb4286da286eb14c7174ea6895;\n    address constant MAINNET_USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address constant MAINNET_WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant MAINNET_TEST_ACCOUNT = 0x00B2E0166500fe321DD72EA2CB1af23af5e30aF0;\n    uint256 constant MAINNET_TEST_INDEX = 2;\n\n    // ============ UNICHAIN CONSTANTS ============\n    bytes32 constant UNICHAIN_MERKLE_ROOT = 0xbdd0e6e4a36de4cdb9aa3ff02899863cb75ce2680f1db9d9fde6c8bfb246fdb6;\n    address constant UNICHAIN_USDC = 0x078D782b760474a361dDA0AF3839290b0EF57AD6;\n    address constant UNICHAIN_WETH = 0x4200000000000000000000000000000000000006;\n    address constant UNICHAIN_TEST_ACCOUNT = 0x045324661B1B38D32A8C5B50f1B5bdD62f5f9d86;\n    uint256 constant UNICHAIN_TEST_INDEX = 3;\n\n    uint256 withdrawableAt;\n\n    // ============ BASE CHAIN TESTS ============\n\n    function testBase_MerkleRoot() public {\n        _setupBase();\n        assertEq(distributor.merkleRoot(), BASE_MERKLE_ROOT);\n    }\n\n    function testBase_SupportedTokens() public {\n        _setupBase();\n        assertTrue(distributor.supportedTokens(BASE_WETH));\n        assertTrue(distributor.supportedTokens(BASE_USDC));\n    }\n\n    function testBase_ValidClaim() public {\n        _setupBase();\n\n        // Set up test claim data\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 2938061841488396; // WETH amount from base data\n        amounts[1] = 0; // USDC amount from base data\n\n        bytes32[] memory proof = _getBaseProof();\n        uint256 initialBalance = IERC20(BASE_WETH).balanceOf(BASE_TEST_ACCOUNT);\n\n        console2.log(\"initialWETHBalance of claimant:\", initialBalance);\n\n        // Execute the claim\n        vm.prank(BASE_TEST_ACCOUNT);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, proof);\n\n        console2.log(\"post-claim WETH Balance of claimant:\", IERC20(BASE_WETH).balanceOf(BASE_TEST_ACCOUNT));\n\n        // Verify balances updated correctly\n        assertEq(IERC20(BASE_WETH).balanceOf(BASE_TEST_ACCOUNT), initialBalance + amounts[0]);\n\n        // Verify claim is marked as claimed\n        assertTrue(distributor.isClaimed(BASE_TEST_INDEX));\n    }\n\n    function testBase_CannotClaimTwice() public {\n        _setupBase();\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 2938061841488396;\n        amounts[1] = 0;\n\n        bytes32[] memory proof = _getBaseProof();\n\n        // First claim should succeed\n        vm.prank(BASE_TEST_ACCOUNT);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, proof);\n\n        // Second claim should fail\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(AlreadyClaimed.selector);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, proof);\n    }\n\n    // ============ ETHEREUM MAINNET TESTS ============\n\n    function testMainnet_MerkleRoot() public {\n        _setupMainnet();\n        assertEq(distributor.merkleRoot(), MAINNET_MERKLE_ROOT);\n    }\n\n    function testMainnet_SupportedTokens() public {\n        _setupMainnet();\n        assertTrue(distributor.supportedTokens(MAINNET_USDC));\n        assertTrue(distributor.supportedTokens(MAINNET_WETH));\n    }\n\n    function testMainnet_ValidClaim() public {\n        _setupMainnet();\n\n        // Set up test claim data\n        address[] memory tokens = new address[](2);\n        tokens[0] = MAINNET_USDC;\n        tokens[1] = MAINNET_WETH;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 224064496; // USDC amount\n        amounts[1] = 0; // WETH amount\n\n        bytes32[] memory proof = new bytes32[](10);\n        proof[0] = 0x363cba88087d853d43d49109015f03668288abdc49d919b290e3cfa7d121a8a0;\n        proof[1] = 0x7a49e9fd41dc9688823abb51c7edb1e06ec0c300e268f1a3e9b10cbd05c5aa84;\n        proof[2] = 0x906bc7b7ce8c55addbb68e5138d24f90e67a3f115a5399efcd8b739be9d0380d;\n        proof[3] = 0x1c79464a41f0363736d95ffdd573035d95f38afad0c6048dc9779da60defe03c;\n        proof[4] = 0xcd3cceefc2f4ac8fa709937b5e56de5e837b9a273e15b575fa20f5e5a189350e;\n        proof[5] = 0x4aa10617259eab761dcee883261f2f9e35d4fe6903a1eb482c1249e484d8dce2;\n        proof[6] = 0xca0bd0bd7b26ea0c84404649b6f8ec9a7eb6de6823848b6360a6c25d01539205;\n        proof[7] = 0x15fc330cfa367ef573198d2dadc7ee8a67db1c7079cf9968325d5a339d94fed9;\n        proof[8] = 0x555b67fc2291ed58234dfb9893d7c23f7af2b75d3599f2010def29a7ef56a0d1;\n        proof[9] = 0x51365528c93bed96fffd163823a44f35017da3921ad36c481746bb654a81fa69;\n\n        uint256 initialBalance = IERC20(MAINNET_USDC).balanceOf(MAINNET_TEST_ACCOUNT);\n        console2.log(\"initialUSDCBalance of claimant:\", initialBalance);\n\n        // Execute the claim\n        vm.prank(MAINNET_TEST_ACCOUNT);\n        distributor.claim(MAINNET_TEST_INDEX, MAINNET_TEST_ACCOUNT, tokens, amounts, proof);\n        console2.log(\"post-claim USDC Balance of claimant:\", IERC20(MAINNET_USDC).balanceOf(MAINNET_TEST_ACCOUNT));\n\n        // Verify balances updated correctly\n        assertEq(IERC20(MAINNET_USDC).balanceOf(MAINNET_TEST_ACCOUNT), initialBalance + amounts[0]);\n\n        // Verify claim is marked as claimed\n        assertTrue(distributor.isClaimed(MAINNET_TEST_INDEX));\n    }\n\n    function testMainnet_InvalidProof() public {\n        _setupMainnet();\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = MAINNET_USDC;\n        tokens[1] = MAINNET_WETH;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 0;\n        amounts[1] = 0;\n\n        bytes32[] memory invalidProof = new bytes32[](1);\n        invalidProof[0] = bytes32(uint256(1));\n\n        vm.prank(MAINNET_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(MAINNET_TEST_INDEX, MAINNET_TEST_ACCOUNT, tokens, amounts, invalidProof);\n    }\n\n    // ============ UNICHAIN TESTS ============\n\n    function testUnichain_MerkleRoot() public {\n        _setupUnichain();\n        assertEq(distributor.merkleRoot(), UNICHAIN_MERKLE_ROOT);\n    }\n\n    function testUnichain_SupportedTokens() public {\n        _setupUnichain();\n        assertTrue(distributor.supportedTokens(UNICHAIN_USDC));\n        assertTrue(distributor.supportedTokens(UNICHAIN_WETH));\n    }\n\n    function testUnichain_ValidClaim() public {\n        _setupUnichain();\n\n        // Set up test claim data (note the duplicate WETH addresses in original data)\n        address[] memory tokens = new address[](2);\n        tokens[0] = UNICHAIN_USDC;\n        tokens[1] = UNICHAIN_WETH;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 0;\n        amounts[1] = 1029089761109200;\n\n        bytes32[] memory proof = new bytes32[](9);\n        proof[0] = 0x048716ff63a8b4cf963bdb616c80daca2eb60bdca275e4761e9c3435623c1fd9;\n        proof[1] = 0x69bc509a3b1de64a50df3ec92b8550e3d111812637f88dd3ddb8c0cb29c3b97f;\n        proof[2] = 0x921f81e5b53611d4242d3609d8fab79f44d3dcfe1d5489f83aaecd2fad68501f;\n        proof[3] = 0xcd99617124b3f50fe9f3d6cc77c1398ee53f84d72d69216d78145cd64d6e3cde;\n        proof[4] = 0xdd207c72b1ab17233cbd99a7d359cba6a652bc424e80962f1be5e901ef9c3e67;\n        proof[5] = 0x8ee783c12931adb244f11ca8a252b2ea58130c0d31f76442aa2f9493d81ac76e;\n        proof[6] = 0xa709a44851cb2a58259c9d49a4dfb217105a33509d67011dd1d93d17cdce5812;\n        proof[7] = 0xb3f3034336424dc075eb52778bdbf39c0002fc453f90b58f8446287a33ab0379;\n        proof[8] = 0xb467125908b2fa01fed95f324eabb81d5ec16d6e077d54f479c3208146892ac2;\n\n        uint256 initialUSDCBalance = IERC20(UNICHAIN_USDC).balanceOf(UNICHAIN_TEST_ACCOUNT);\n        uint256 initialWETHBalance = IERC20(UNICHAIN_WETH).balanceOf(UNICHAIN_TEST_ACCOUNT);\n        console2.log(\"initialUSDCBalance of claimant:\", initialUSDCBalance);\n        console2.log(\"initialWETHBalance of claimant:\", initialWETHBalance);\n\n        vm.prank(UNICHAIN_TEST_ACCOUNT);\n        distributor.claim(UNICHAIN_TEST_INDEX, UNICHAIN_TEST_ACCOUNT, tokens, amounts, proof);\n        console2.log(\"post-claim USDC Balance of claimant:\", IERC20(UNICHAIN_USDC).balanceOf(UNICHAIN_TEST_ACCOUNT));\n        console2.log(\"post-claim WETH Balance of claimant:\", IERC20(UNICHAIN_WETH).balanceOf(UNICHAIN_TEST_ACCOUNT));\n\n        // Verify balances updated correctly\n        assertEq(IERC20(UNICHAIN_USDC).balanceOf(UNICHAIN_TEST_ACCOUNT), initialUSDCBalance + amounts[0]);\n        assertEq(IERC20(UNICHAIN_WETH).balanceOf(UNICHAIN_TEST_ACCOUNT), initialWETHBalance + amounts[1]);\n\n        // Verify claim is marked as claimed\n        assertTrue(distributor.isClaimed(UNICHAIN_TEST_INDEX));\n    }\n\n    // ============ CROSS-CHAIN WITHDRAW TESTS ============\n\n    function testBase_WithdrawUnclaimed() public {\n        _setupBase();\n\n        // Fast forward past withdrawal time\n        vm.roll(withdrawableAt + 1);\n\n        uint256 initialBalance1 = IERC20(BASE_WETH).balanceOf(admin);\n        uint256 initialBalance2 = IERC20(BASE_USDC).balanceOf(admin);\n\n        address[] memory withdrawTokens = new address[](2);\n        withdrawTokens[0] = BASE_WETH;\n        withdrawTokens[1] = BASE_USDC;\n\n        vm.prank(admin);\n        distributor.withdrawUnclaimed(withdrawTokens, admin);\n\n        // Verify tokens were withdrawn\n        assertTrue(IERC20(BASE_WETH).balanceOf(admin) > initialBalance1);\n        assertTrue(IERC20(BASE_USDC).balanceOf(admin) >= initialBalance2);\n    }\n\n    function testMainnet_WithdrawTooEarly() public {\n        _setupMainnet();\n\n        address[] memory withdrawTokens = new address[](2);\n        withdrawTokens[0] = MAINNET_USDC;\n        withdrawTokens[1] = MAINNET_WETH;\n\n        vm.prank(admin);\n        vm.expectRevert(WithdrawTooEarly.selector);\n        distributor.withdrawUnclaimed(withdrawTokens, admin);\n    }\n\n    function testUnichain_WithdrawOnlyAdmin() public {\n        _setupUnichain();\n\n        vm.roll(withdrawableAt + 1);\n\n        address[] memory withdrawTokens = new address[](2);\n        withdrawTokens[0] = UNICHAIN_USDC;\n        withdrawTokens[1] = UNICHAIN_WETH;\n\n        vm.prank(address(0x456));\n        vm.expectRevert(OnlyAdmin.selector);\n        distributor.withdrawUnclaimed(withdrawTokens, admin);\n    }\n\n    // ============ HELPER FUNCTIONS ============\n\n    function _setupBase() internal {\n        vm.createSelectFork(\"base\");\n\n        withdrawableAt = block.number + 100;\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        distributor = new MerkleDistributor(BASE_MERKLE_ROOT, tokens, withdrawableAt, admin);\n        _fundDistributor(BASE_WETH, BASE_USDC);\n    }\n\n    function _setupMainnet() internal {\n        vm.createSelectFork(\"mainnet\");\n\n        withdrawableAt = block.number + 100;\n\n        // Note: We need to include all 22 unique tokens from the mainnet data\n        // For testing purposes, we'll just include the main ones\n        address[] memory tokens = new address[](2);\n        tokens[0] = MAINNET_USDC;\n        tokens[1] = MAINNET_WETH;\n\n        distributor = new MerkleDistributor(MAINNET_MERKLE_ROOT, tokens, withdrawableAt, admin);\n        _fundDistributorMainnet(MAINNET_USDC, MAINNET_WETH);\n    }\n\n    function _setupUnichain() internal {\n        vm.createSelectFork(\"unichain\");\n\n        withdrawableAt = block.number + 100;\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = UNICHAIN_USDC;\n        tokens[1] = UNICHAIN_WETH;\n\n        distributor = new MerkleDistributor(UNICHAIN_MERKLE_ROOT, tokens, withdrawableAt, admin);\n        _fundDistributorUnichain(UNICHAIN_USDC, UNICHAIN_WETH);\n    }\n\n    function _fundDistributor(address token1, address token2) internal {\n        vm.startPrank(VAULT_ACCOUNT);\n\n        uint256 vaultBalance1 = IERC20(token1).balanceOf(VAULT_ACCOUNT);\n        uint256 vaultBalance2 = IERC20(token2).balanceOf(VAULT_ACCOUNT);\n\n        console2.log(\"Base: Vault token1 balance:\", vaultBalance1);\n        console2.log(\"Base: Vault token2 balance:\", vaultBalance2);\n\n        uint256 toTransfer1 = 1 ether;\n        uint256 toTransfer2 = 1000 * 10**6; // For USDC\n\n        if (vaultBalance1 >= toTransfer1) {\n            IERC20(token1).transfer(address(distributor), toTransfer1);\n        } else if (vaultBalance1 > 0) {\n            IERC20(token1).transfer(address(distributor), vaultBalance1);\n        }\n\n        if (vaultBalance2 >= toTransfer2) {\n            IERC20(token2).transfer(address(distributor), toTransfer2);\n        } else if (vaultBalance2 > 0) {\n            IERC20(token2).transfer(address(distributor), vaultBalance2);\n        }\n\n        vm.stopPrank();\n    }\n\n    function _fundDistributorMainnet(address usdc, address weth) internal {\n        vm.startPrank(VAULT_ACCOUNT);\n\n        uint256 vaultUsdcBalance = IERC20(usdc).balanceOf(VAULT_ACCOUNT);\n        uint256 vaultWethBalance = IERC20(weth).balanceOf(VAULT_ACCOUNT);\n\n        console2.log(\"Mainnet: Vault USDC balance:\", vaultUsdcBalance);\n        console2.log(\"Mainnet: Vault WETH balance:\", vaultWethBalance);\n\n        // Transfer available balances\n        if (vaultUsdcBalance > 0) {\n            uint256 usdcToTransfer = vaultUsdcBalance > 10000 * 10**6 ? 10000 * 10**6 : vaultUsdcBalance;\n            IERC20(usdc).transfer(address(distributor), usdcToTransfer);\n        }\n\n        if (vaultWethBalance > 0) {\n            uint256 wethToTransfer = vaultWethBalance > 10 ether ? 10 ether : vaultWethBalance;\n            IERC20(weth).transfer(address(distributor), wethToTransfer);\n        }\n\n        vm.stopPrank();\n    }\n\n    function _fundDistributorUnichain(address usdc, address weth) internal {\n        vm.startPrank(VAULT_ACCOUNT);\n\n        // Check if tokens exist on Unichain\n        uint256 vaultUsdcBalance;\n        uint256 vaultWethBalance;\n\n        // Use try-catch in case tokens don't exist on Unichain\n        try IERC20(usdc).balanceOf(VAULT_ACCOUNT) returns (uint256 balance) {\n            vaultUsdcBalance = balance;\n        } catch {\n            console2.log(\"Unichain: usdc doesn't exist or has no balance\");\n        }\n\n        try IERC20(weth).balanceOf(VAULT_ACCOUNT) returns (uint256 balance) {\n            vaultWethBalance = balance;\n        } catch {\n            console2.log(\"Unichain: WETH doesn't exist or has no balance\");\n        }\n\n        console2.log(\"Unichain: Vault usdc balance:\", vaultUsdcBalance);\n        console2.log(\"Unichain: Vault WETH balance:\", vaultWethBalance);\n\n        if (vaultUsdcBalance > 0) {\n            IERC20(usdc).transfer(address(distributor), vaultUsdcBalance);\n        }\n\n        if (vaultWethBalance > 0) {\n            IERC20(weth).transfer(address(distributor), vaultWethBalance);\n        }\n\n        vm.stopPrank();\n    }\n\n    function _getBaseProof() internal pure returns (bytes32[] memory) {\n        bytes32[] memory proof = new bytes32[](9);\n        proof[0] = 0xb56596733e85fde5bca61ea621db418addce504637f05734b5db98486b278517;\n        proof[1] = 0xce1f34c5edc3ec207842184b82c022fc3dacf4aa290202b3ec90f1beb4c6fdfb;\n        proof[2] = 0xd70d2533d6340436a0e68ef7ff259a49ab016d5d6e2053475b26cb3261e7306b;\n        proof[3] = 0x95f284b81e092d0136daa75dfb6bcf735cecbea5bb6e19d11a3abc174d7aea73;\n        proof[4] = 0xcd93858d46b1a4ccd503f263fed6cc1dd51ccd715207e22410e28f9a499ed7eb;\n        proof[5] = 0x0eb97c00b8a77089f1b2a6d47f9261d8ad1f4c4eaa640a385b1738d2b0b2c360;\n        proof[6] = 0xa4862d659cf3c56690c38ff4cd853864edad28f8ef5897b5dc63941b58ec6295;\n        proof[7] = 0x986faa7573bfb93eb147edc1134cd67945e565e7833e0c7d21f3871c6c2c1db8;\n        proof[8] = 0xae87bcf032087f2a8461aa1555b3b125d0ddab75842c4a0aa5bc5c289998a6ea;\n        return proof;\n    }\n\n    // ============ INTEGRATION TESTS ============\n\n    function testFullScenario_AllChains() public {\n        console2.log(\"=== Testing Base Chain ===\");\n        testBase_ValidClaim();\n\n        console2.log(\"\\n=== Testing Ethereum Mainnet ===\");\n        testMainnet_ValidClaim();\n\n        console2.log(\"\\n=== Testing Unichain ===\");\n        testUnichain_ValidClaim();\n\n        console2.log(\"\\n=== All chain tests completed successfully ===\");\n    }\n\n    // ============ COMPREHENSIVE CLAIM TESTS ============\n\n    function testAllClaims_Base() public {\n        _setupBaseWithFullFunding();\n\n        // Read the merkle data JSON\n        string memory json = vm.readFile(\"data/base-merkle-data.json\");\n\n        // Get all claim addresses\n        string[] memory claimAddresses = vm.parseJsonKeys(json, \".claims\");\n\n        console2.log(\"Testing\", claimAddresses.length, \"claims on Base\");\n\n        uint256 successfulClaims = 0;\n        uint256 failedClaims = 0;\n\n        for (uint256 i = 0; i < claimAddresses.length; i++) {\n            address claimant = vm.parseAddress(claimAddresses[i]);\n\n            // Parse claim data\n            string memory claimPath = string.concat(\".claims.\", vm.toString(claimant));\n            uint256 index = vm.parseJsonUint(json, string.concat(claimPath, \".index\"));\n\n            address[] memory tokens = vm.parseJsonAddressArray(json, string.concat(claimPath, \".tokens\"));\n            uint256[] memory amounts = vm.parseJsonUintArray(json, string.concat(claimPath, \".amounts\"));\n            bytes32[] memory proof = vm.parseJsonBytes32Array(json, string.concat(claimPath, \".proof\"));\n\n            // Track initial balances\n            uint256[] memory initialBalances = new uint256[](tokens.length);\n            for (uint256 j = 0; j < tokens.length; j++) {\n                initialBalances[j] = IERC20(tokens[j]).balanceOf(claimant);\n            }\n\n            // Execute claim\n            vm.prank(claimant);\n            try distributor.claim(index, claimant, tokens, amounts, proof) {\n                // Verify balances updated correctly\n                bool balancesCorrect = true;\n                for (uint256 j = 0; j < tokens.length; j++) {\n                    uint256 expectedBalance = initialBalances[j] + amounts[j];\n                    uint256 actualBalance = IERC20(tokens[j]).balanceOf(claimant);\n                    if (actualBalance != expectedBalance) {\n                        console2.log(\"Balance mismatch for token\", tokens[j], \"claimant\", claimant);\n                        console2.log(\"Expected:\", expectedBalance, \"Actual:\", actualBalance);\n                        balancesCorrect = false;\n                    }\n                }\n\n                if (balancesCorrect && distributor.isClaimed(index)) {\n                    successfulClaims++;\n                } else {\n                    failedClaims++;\n                    console2.log(\"Claim verification failed for\", claimant, \"at index\", index);\n                }\n            } catch Error(string memory reason) {\n                failedClaims++;\n                console2.log(\"Claim failed for\", claimant, \":\", reason);\n            } catch {\n                failedClaims++;\n                console2.log(\"Claim failed for\", claimant, \"with unknown error\");\n            }\n        }\n\n        console2.log(\"Base claims completed - Success:\", successfulClaims, \"Failed:\", failedClaims);\n        assertEq(failedClaims, 0, \"All claims should succeed\");\n    }\n\n    function testAllClaims_Mainnet() public {\n        _setupMainnetWithFullFunding();\n\n        // Read the merkle data JSON\n        string memory json = vm.readFile(\"data/mainnet-merkle-data.json\");\n\n        // Get all claim addresses\n        string[] memory claimAddresses = vm.parseJsonKeys(json, \".claims\");\n\n        console2.log(\"Testing\", claimAddresses.length, \"claims on Mainnet\");\n\n        uint256 successfulClaims = 0;\n        uint256 failedClaims = 0;\n\n        for (uint256 i = 0; i < claimAddresses.length; i++) {\n            address claimant = vm.parseAddress(claimAddresses[i]);\n\n            // Parse claim data\n            string memory claimPath = string.concat(\".claims.\", vm.toString(claimant));\n            uint256 index = vm.parseJsonUint(json, string.concat(claimPath, \".index\"));\n\n            address[] memory tokens = vm.parseJsonAddressArray(json, string.concat(claimPath, \".tokens\"));\n            uint256[] memory amounts = vm.parseJsonUintArray(json, string.concat(claimPath, \".amounts\"));\n            bytes32[] memory proof = vm.parseJsonBytes32Array(json, string.concat(claimPath, \".proof\"));\n\n            // Track initial balances\n            uint256[] memory initialBalances = new uint256[](tokens.length);\n            for (uint256 j = 0; j < tokens.length; j++) {\n                initialBalances[j] = IERC20(tokens[j]).balanceOf(claimant);\n            }\n\n            // Execute claim\n            vm.prank(claimant);\n            try distributor.claim(index, claimant, tokens, amounts, proof) {\n                // Verify balances updated correctly\n                bool balancesCorrect = true;\n                for (uint256 j = 0; j < tokens.length; j++) {\n                    uint256 expectedBalance = initialBalances[j] + amounts[j];\n                    uint256 actualBalance = IERC20(tokens[j]).balanceOf(claimant);\n                    if (actualBalance != expectedBalance) {\n                        console2.log(\"Balance mismatch for token\", tokens[j], \"claimant\", claimant);\n                        console2.log(\"Expected:\", expectedBalance, \"Actual:\", actualBalance);\n                        balancesCorrect = false;\n                    }\n                }\n\n                if (balancesCorrect && distributor.isClaimed(index)) {\n                    successfulClaims++;\n                } else {\n                    failedClaims++;\n                    console2.log(\"Claim verification failed for\", claimant, \"at index\", index);\n                }\n            } catch Error(string memory reason) {\n                failedClaims++;\n                console2.log(\"Claim failed for\", claimant, \":\", reason);\n            } catch {\n                failedClaims++;\n                console2.log(\"Claim failed for\", claimant, \"with unknown error\");\n            }\n        }\n\n        console2.log(\"Mainnet claims completed - Success:\", successfulClaims, \"Failed:\", failedClaims);\n        assertEq(failedClaims, 0, \"All claims should succeed\");\n    }\n\n    function testAllClaims_Unichain() public {\n        _setupUnichainWithFullFunding();\n\n        // Read the merkle data JSON\n        string memory json = vm.readFile(\"data/unichain-merkle-data.json\");\n\n        // Get all claim addresses\n        string[] memory claimAddresses = vm.parseJsonKeys(json, \".claims\");\n\n        console2.log(\"Testing\", claimAddresses.length, \"claims on Unichain\");\n\n        uint256 successfulClaims = 0;\n        uint256 failedClaims = 0;\n\n        for (uint256 i = 0; i < claimAddresses.length; i++) {\n            address claimant = vm.parseAddress(claimAddresses[i]);\n\n            // Parse claim data\n            string memory claimPath = string.concat(\".claims.\", vm.toString(claimant));\n            uint256 index = vm.parseJsonUint(json, string.concat(claimPath, \".index\"));\n\n            address[] memory tokens = vm.parseJsonAddressArray(json, string.concat(claimPath, \".tokens\"));\n            uint256[] memory amounts = vm.parseJsonUintArray(json, string.concat(claimPath, \".amounts\"));\n            bytes32[] memory proof = vm.parseJsonBytes32Array(json, string.concat(claimPath, \".proof\"));\n\n            // Track initial balances\n            uint256[] memory initialBalances = new uint256[](tokens.length);\n            for (uint256 j = 0; j < tokens.length; j++) {\n                initialBalances[j] = IERC20(tokens[j]).balanceOf(claimant);\n            }\n\n            // Execute claim\n            vm.prank(claimant);\n            try distributor.claim(index, claimant, tokens, amounts, proof) {\n                // Verify balances updated correctly\n                bool balancesCorrect = true;\n                for (uint256 j = 0; j < tokens.length; j++) {\n                    uint256 expectedBalance = initialBalances[j] + amounts[j];\n                    uint256 actualBalance = IERC20(tokens[j]).balanceOf(claimant);\n                    if (actualBalance != expectedBalance) {\n                        console2.log(\"Balance mismatch for token\", tokens[j], \"claimant\", claimant);\n                        console2.log(\"Expected:\", expectedBalance, \"Actual:\", actualBalance);\n                        balancesCorrect = false;\n                    }\n                }\n\n                if (balancesCorrect && distributor.isClaimed(index)) {\n                    successfulClaims++;\n                } else {\n                    failedClaims++;\n                    console2.log(\"Claim verification failed for\", claimant, \"at index\", index);\n                }\n            } catch Error(string memory reason) {\n                failedClaims++;\n                console2.log(\"Claim failed for\", claimant, \":\", reason);\n            } catch {\n                failedClaims++;\n                console2.log(\"Claim failed for\", claimant, \"with unknown error\");\n            }\n        }\n\n        console2.log(\"Unichain claims completed - Success:\", successfulClaims, \"Failed:\", failedClaims);\n        assertEq(failedClaims, 0, \"All claims should succeed\");\n    }\n\n    // ============ SETUP FUNCTIONS WITH FULL FUNDING ============\n\n    function _setupBaseWithFullFunding() internal {\n        vm.createSelectFork(\"base\");\n\n        withdrawableAt = block.number + 100;\n\n        // Read token list from JSON\n        string memory json = vm.readFile(\"data/base-merkle-data.json\");\n        address[] memory tokens = vm.parseJsonAddressArray(json, \".tokenList\");\n\n        distributor = new MerkleDistributor(BASE_MERKLE_ROOT, tokens, withdrawableAt, admin);\n\n        // Fund distributor with exact amounts needed\n        _fundDistributorWithExactAmounts(json, tokens);\n    }\n\n    function _setupMainnetWithFullFunding() internal {\n        vm.createSelectFork(\"mainnet\");\n\n        withdrawableAt = block.number + 100;\n\n        // Read token list from JSON\n        string memory json = vm.readFile(\"data/mainnet-merkle-data.json\");\n        address[] memory tokens = vm.parseJsonAddressArray(json, \".tokenList\");\n\n        distributor = new MerkleDistributor(MAINNET_MERKLE_ROOT, tokens, withdrawableAt, admin);\n\n        // Fund distributor with exact amounts needed\n        _fundDistributorWithExactAmounts(json, tokens);\n    }\n\n    function _setupUnichainWithFullFunding() internal {\n        vm.createSelectFork(\"unichain\");\n\n        withdrawableAt = block.number + 100;\n\n        // Read token list from JSON\n        string memory json = vm.readFile(\"data/unichain-merkle-data.json\");\n        address[] memory tokens = vm.parseJsonAddressArray(json, \".tokenList\");\n\n        distributor = new MerkleDistributor(UNICHAIN_MERKLE_ROOT, tokens, withdrawableAt, admin);\n\n        // Fund distributor with exact amounts needed\n        _fundDistributorWithExactAmounts(json, tokens);\n    }\n\n    function _fundDistributorWithExactAmounts(string memory json, address[] memory tokens) internal {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address token = tokens[i];\n\n            // Get the total amount needed for this token\n            string memory amountPath = string.concat(\".tokenTotals.\", vm.toString(token));\n            uint256 totalNeeded = vm.parseJsonUint(json, amountPath);\n\n            if (totalNeeded > 0) {\n                // Give the vault account the exact amount needed\n                vm.startPrank(VAULT_ACCOUNT);\n\n                // Use deal to set balance directly\n                deal(token, VAULT_ACCOUNT, totalNeeded);\n\n                // Transfer to distributor\n                IERC20(token).transfer(address(distributor), totalNeeded);\n\n                vm.stopPrank();\n\n                console2.log(\"Funded distributor with\", totalNeeded, \"of token\", token);\n            }\n        }\n    }\n\n    // ============ SECURITY TESTS ============\n\n    function testBase_CannotClaimForOthers() public {\n        _setupBase();\n\n        address attacker = address(0xBEEF);\n\n        // Set up legitimate claim data for BASE_TEST_ACCOUNT\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 2938061841488396; // WETH amount from base data\n        amounts[1] = 0; // USDC amount from base data\n\n        bytes32[] memory proof = _getBaseProof();\n\n        // Try to claim someone else's tokens as the attacker\n        vm.prank(attacker);\n        vm.expectRevert(\"Only the claim owner may execute their claim\");\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, proof);\n\n        // Verify the legitimate account can still claim their tokens\n        vm.prank(BASE_TEST_ACCOUNT);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, proof);\n\n        // Verify claim is marked as claimed for the correct index\n        assertTrue(distributor.isClaimed(BASE_TEST_INDEX));\n    }\n\n    function testMainnet_CannotClaimForOthers() public {\n        _setupMainnet();\n\n        address attacker = address(0xDEAD);\n\n        // Set up legitimate claim data for MAINNET_TEST_ACCOUNT\n        address[] memory tokens = new address[](2);\n        tokens[0] = MAINNET_USDC;\n        tokens[1] = MAINNET_WETH;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 224064496; // USDC amount\n        amounts[1] = 0; // WETH amount\n\n        bytes32[] memory proof = new bytes32[](10);\n        proof[0] = 0x363cba88087d853d43d49109015f03668288abdc49d919b290e3cfa7d121a8a0;\n        proof[1] = 0x7a49e9fd41dc9688823abb51c7edb1e06ec0c300e268f1a3e9b10cbd05c5aa84;\n        proof[2] = 0x906bc7b7ce8c55addbb68e5138d24f90e67a3f115a5399efcd8b739be9d0380d;\n        proof[3] = 0x1c79464a41f0363736d95ffdd573035d95f38afad0c6048dc9779da60defe03c;\n        proof[4] = 0xcd3cceefc2f4ac8fa709937b5e56de5e837b9a273e15b575fa20f5e5a189350e;\n        proof[5] = 0x4aa10617259eab761dcee883261f2f9e35d4fe6903a1eb482c1249e484d8dce2;\n        proof[6] = 0xca0bd0bd7b26ea0c84404649b6f8ec9a7eb6de6823848b6360a6c25d01539205;\n        proof[7] = 0x15fc330cfa367ef573198d2dadc7ee8a67db1c7079cf9968325d5a339d94fed9;\n        proof[8] = 0x555b67fc2291ed58234dfb9893d7c23f7af2b75d3599f2010def29a7ef56a0d1;\n        proof[9] = 0x51365528c93bed96fffd163823a44f35017da3921ad36c481746bb654a81fa69;\n\n        // Attacker tries to claim\n        vm.prank(attacker);\n        vm.expectRevert(\"Only the claim owner may execute their claim\");\n        distributor.claim(MAINNET_TEST_INDEX, MAINNET_TEST_ACCOUNT, tokens, amounts, proof);\n\n        // Verify legitimate account can still claim\n        vm.prank(MAINNET_TEST_ACCOUNT);\n        distributor.claim(MAINNET_TEST_INDEX, MAINNET_TEST_ACCOUNT, tokens, amounts, proof);\n\n        assertTrue(distributor.isClaimed(MAINNET_TEST_INDEX));\n    }\n\n    function testBase_InvalidProofVariations() public {\n        _setupBase();\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 2938061841488396;\n        amounts[1] = 0;\n\n        // Test 1: Empty proof array\n        bytes32[] memory emptyProof = new bytes32[](0);\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, emptyProof);\n\n        // Test 2: Wrong length proof (too short)\n        bytes32[] memory shortProof = new bytes32[](2);\n        shortProof[0] = bytes32(uint256(1));\n        shortProof[1] = bytes32(uint256(2));\n\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, shortProof);\n\n        // Test 3: Correct length but wrong values\n        bytes32[] memory wrongProof = new bytes32[](9);\n        for (uint i = 0; i < 9; i++) {\n            wrongProof[i] = bytes32(uint256(i + 1));\n        }\n\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, wrongProof);\n\n        // Test 4: All zero proof with correct length\n        bytes32[] memory zeroProof = new bytes32[](9);\n        // Array is already initialized with zeros\n\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(BASE_TEST_INDEX, BASE_TEST_ACCOUNT, tokens, amounts, zeroProof);\n    }\n\n    function testMainnet_WrongAmountsCantClaim() public {\n        _setupMainnet();\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = MAINNET_USDC;\n        tokens[1] = MAINNET_WETH;\n\n        // Correct proof but wrong amounts\n        uint256[] memory wrongAmounts = new uint256[](2);\n        wrongAmounts[0] = 224064496 + 1; // USDC amount + 1 (wrong!)\n        wrongAmounts[1] = 0;\n\n        bytes32[] memory proof = new bytes32[](10);\n        proof[0] = 0x363cba88087d853d43d49109015f03668288abdc49d919b290e3cfa7d121a8a0;\n        proof[1] = 0x7a49e9fd41dc9688823abb51c7edb1e06ec0c300e268f1a3e9b10cbd05c5aa84;\n        proof[2] = 0x906bc7b7ce8c55addbb68e5138d24f90e67a3f115a5399efcd8b739be9d0380d;\n        proof[3] = 0x1c79464a41f0363736d95ffdd573035d95f38afad0c6048dc9779da60defe03c;\n        proof[4] = 0xcd3cceefc2f4ac8fa709937b5e56de5e837b9a273e15b575fa20f5e5a189350e;\n        proof[5] = 0x4aa10617259eab761dcee883261f2f9e35d4fe6903a1eb482c1249e484d8dce2;\n        proof[6] = 0xca0bd0bd7b26ea0c84404649b6f8ec9a7eb6de6823848b6360a6c25d01539205;\n        proof[7] = 0x15fc330cfa367ef573198d2dadc7ee8a67db1c7079cf9968325d5a339d94fed9;\n        proof[8] = 0x555b67fc2291ed58234dfb9893d7c23f7af2b75d3599f2010def29a7ef56a0d1;\n        proof[9] = 0x51365528c93bed96fffd163823a44f35017da3921ad36c481746bb654a81fa69;\n\n        // Should fail with wrong amounts\n        vm.prank(MAINNET_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(MAINNET_TEST_INDEX, MAINNET_TEST_ACCOUNT, tokens, wrongAmounts, proof);\n    }\n\n    function testBase_WrongIndexCantClaim() public {\n        _setupBase();\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 2938061841488396;\n        amounts[1] = 0;\n\n        bytes32[] memory proof = _getBaseProof();\n\n        // Try to claim with wrong index (BASE_TEST_INDEX + 1)\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(InvalidProof.selector);\n        distributor.claim(BASE_TEST_INDEX + 1, BASE_TEST_ACCOUNT, tokens, amounts, proof);\n    }\n\n    function testUnichain_CannotClaimForOthers() public {\n        _setupUnichain();\n\n        address attacker = address(0xCAFE);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = UNICHAIN_USDC;\n        tokens[1] = UNICHAIN_WETH;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 0;\n        amounts[1] = 1029089761109200;\n\n        bytes32[] memory proof = new bytes32[](9);\n        proof[0] = 0x048716ff63a8b4cf963bdb616c80daca2eb60bdca275e4761e9c3435623c1fd9;\n        proof[1] = 0x69bc509a3b1de64a50df3ec92b8550e3d111812637f88dd3ddb8c0cb29c3b97f;\n        proof[2] = 0x921f81e5b53611d4242d3609d8fab79f44d3dcfe1d5489f83aaecd2fad68501f;\n        proof[3] = 0xcd99617124b3f50fe9f3d6cc77c1398ee53f84d72d69216d78145cd64d6e3cde;\n        proof[4] = 0xdd207c72b1ab17233cbd99a7d359cba6a652bc424e80962f1be5e901ef9c3e67;\n        proof[5] = 0x8ee783c12931adb244f11ca8a252b2ea58130c0d31f76442aa2f9493d81ac76e;\n        proof[6] = 0xa709a44851cb2a58259c9d49a4dfb217105a33509d67011dd1d93d17cdce5812;\n        proof[7] = 0xb3f3034336424dc075eb52778bdbf39c0002fc453f90b58f8446287a33ab0379;\n        proof[8] = 0xb467125908b2fa01fed95f324eabb81d5ec16d6e077d54f479c3208146892ac2;\n\n        // Attacker tries to claim someone else's tokens\n        vm.prank(attacker);\n        vm.expectRevert(\"Only the claim owner may execute their claim\");\n        distributor.claim(UNICHAIN_TEST_INDEX, UNICHAIN_TEST_ACCOUNT, tokens, amounts, proof);\n\n        // Legitimate user can still claim\n        vm.prank(UNICHAIN_TEST_ACCOUNT);\n        distributor.claim(UNICHAIN_TEST_INDEX, UNICHAIN_TEST_ACCOUNT, tokens, amounts, proof);\n\n        assertTrue(distributor.isClaimed(UNICHAIN_TEST_INDEX));\n    }\n\n    function testBase_ProofIsAddressSpecific() public {\n        _setupBase();\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = BASE_WETH;\n        tokens[1] = BASE_USDC;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 2938061841488396;\n        amounts[1] = 0;\n\n        bytes32[] memory proof = _getBaseProof();\n\n        // Try to use BASE_TEST_ACCOUNT's proof but claim to a different address\n        address wrongRecipient = address(0x9999);\n\n        vm.prank(BASE_TEST_ACCOUNT);\n        vm.expectRevert(\"Only the claim owner may execute their claim\");\n        distributor.claim(BASE_TEST_INDEX, wrongRecipient, tokens, amounts, proof);\n    }\n}\n"
    }
}