{
    "vfp_id": "vfp_00417",
    "project_name": "cantina_eco_pr247_nov2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Missing documentation for the new CCIP prover in various NatSpecs",
            "description": "1. **Description:** The NatSpec comments in Inbox.sol and IProver.sol list existing prover systems but do not include documentation for the new CCIPProver, creating a gap in developer understanding.\n2. **Cause:** The addition of CCIPProver was not accompanied by updates to the inline documentation that explains domain ID mappings for different bridge providers.\n3. **Exploitation:** Developers relying on the NatSpec comments may misunderstand how CCIP handles chain identifiers, leading to incorrect integration or configuration.\n4. **Impact:** This reduces code clarity and maintainability, increasing the risk of integration errors. While not a direct security vulnerability, it affects the overall quality and safety of the system. The issue was fixed in PR 353.\n",
            "severity": "Informational",
            "location": [
                "Inbox.sol::#L100",
                "Inbox.sol::#L149",
                "IProver.sol::#L84"
            ],
            "files": [
                "eco-routes/contracts/Inbox.sol",
                "eco-routes/contracts/interfaces/IProver.sol"
            ]
        }
    ],
    "affected_files": {
        "IProver.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {ISemver} from \"./ISemver.sol\";\n\n/**\n * @title IProver\n * @notice Interface for proving intent fulfillment\n * @dev Defines required functionality for proving intent execution with different\n * proof mechanisms (storage or Hyperlane)\n */\ninterface IProver is ISemver {\n    /**\n     * @notice Proof data stored for each proven intent\n     * @param claimant Address eligible to claim the intent rewards\n     * @param destination Chain ID where the intent was proven\n     */\n    struct ProofData {\n        address claimant;\n        uint64 destination;\n    }\n\n    /**\n     * @notice Arrays of intent hashes and claimants must have the same length\n     */\n    error ArrayLengthMismatch();\n\n    /**\n     * @notice Portal address cannot be zero\n     */\n    error ZeroPortal();\n\n    /**\n     * @notice Chain ID is too large to fit in uint64\n     * @param chainId The chain ID that is too large\n     */\n    error ChainIdTooLarge(uint256 chainId);\n\n    /**\n     * @notice Emitted when an intent is successfully proven\n     * @dev Emitted by the Prover on the source chain.\n     * @param intentHash Hash of the proven intent\n     * @param claimant Address eligible to claim the intent rewards\n     * @param destination Destination chain ID where the intent was proven\n     */\n    event IntentProven(\n        bytes32 indexed intentHash,\n        address indexed claimant,\n        uint64 destination\n    );\n\n    /**\n     * @notice Emitted when an intent proof is invalidated\n     * @param intentHash Hash of the invalidated intent\n     */\n    event IntentProofInvalidated(bytes32 indexed intentHash);\n\n    /**\n     * @notice Emitted when attempting to prove an already-proven intent\n     * @dev Event instead of error to allow batch processing to continue\n     * @param intentHash Hash of the already proven intent\n     */\n    event IntentAlreadyProven(bytes32 intentHash);\n\n    /**\n     * @notice Gets the proof mechanism type used by this prover\n     * @return string indicating the prover's mechanism\n     */\n    function getProofType() external pure returns (string memory);\n\n    /**\n     * @notice Initiates the proving process for intents from the destination chain\n     * @dev Implemented by specific prover mechanisms (storage, Hyperlane, Metalayer)\n     * @param sender Address of the original transaction sender\n     * @param sourceChainDomainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data specific to the proving implementation\n     *\n     * @dev WARNING: sourceChainDomainID is NOT necessarily the same as chain ID.\n     *      Each bridge provider uses their own domain ID mapping system:\n     *      - Hyperlane: Uses custom domain IDs that may differ from chain IDs\n     *      - LayerZero: Uses endpoint IDs that map to chains differently\n     *      - Metalayer: Uses domain IDs specific to their routing system\n     *      - Polymer: Uses chainIDs\n     *      - CCIP: Uses chain selectors that are totally separate from chainIDs\n     *      You MUST consult the specific bridge provider's documentation to determine\n     *      the correct domain ID for the source chain.\n     */\n    function prove(\n        address sender,\n        uint64 sourceChainDomainID,\n        bytes calldata encodedProofs,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice Returns the proof data for a given intent hash\n     * @param intentHash Hash of the intent to query\n     * @return ProofData containing claimant and destination chain ID\n     */\n    function provenIntents(\n        bytes32 intentHash\n    ) external view returns (ProofData memory);\n\n    /**\n     * @notice Challenge an intent proof if destination chain ID doesn't match\n     * @dev Can be called by anyone to remove invalid proofs. This is a safety mechanism to ensure\n     *      intents are only claimable when executed on their intended destination chains.\n     * @param destination The intended destination chain ID\n     * @param routeHash The hash of the intent's route\n     * @param rewardHash The hash of the reward specification\n     */\n    function challengeIntentProof(\n        uint64 destination,\n        bytes32 routeHash,\n        bytes32 rewardHash\n    ) external;\n}\n",
        "Inbox.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IProver} from \"./interfaces/IProver.sol\";\nimport {IInbox} from \"./interfaces/IInbox.sol\";\nimport {IExecutor} from \"./interfaces/IExecutor.sol\";\n\nimport {Route, Call, TokenAmount} from \"./types/Intent.sol\";\nimport {Semver} from \"./libs/Semver.sol\";\nimport {Refund} from \"./libs/Refund.sol\";\n\nimport {DestinationSettler} from \"./ERC7683/DestinationSettler.sol\";\nimport {Executor} from \"./Executor.sol\";\n\n/**\n * @title Inbox\n * @notice Main entry point for fulfilling intents on the destination chain\n * @dev Validates intent hash authenticity, executes calldata, and enables provers\n * to claim rewards on the source chain by checking the claimants mapping\n */\nabstract contract Inbox is DestinationSettler, IInbox {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Mapping of intent hashes to their claimant identifiers\n     * @dev Stores the cross-VM compatible claimant identifier for each fulfilled intent\n     */\n    mapping(bytes32 => bytes32) public claimants;\n\n    IExecutor public immutable executor;\n\n    /**\n     * @notice Chain ID stored as immutable for gas efficiency\n     * @dev Used to prepend to proof messages for cross-chain identification\n     */\n    uint64 private immutable CHAIN_ID;\n\n    /**\n     * @notice Initializes the Inbox contract\n     * @dev Sets up the base contract for handling intent fulfillment on destination chains\n     */\n    constructor() {\n        executor = new Executor();\n\n        // Validate that chain ID fits in uint64 and store it\n        if (block.chainid > type(uint64).max) {\n            revert ChainIdTooLarge(block.chainid);\n        }\n        CHAIN_ID = uint64(block.chainid);\n    }\n\n    /**\n     * @notice Fulfills an intent to be proven via storage proofs\n     * @dev Validates intent hash, executes calls, and marks as fulfilled\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route of the intent\n     * @param rewardHash The hash of the reward details\n     * @param claimant Cross-VM compatible claimant identifier\n     * @return Array of execution results from each call\n     */\n    function fulfill(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant\n    ) external payable returns (bytes[] memory) {\n        bytes[] memory result = _fulfill(\n            intentHash,\n            route,\n            rewardHash,\n            claimant\n        );\n\n        // Refund any remaining balance (excess ETH)\n        Refund.excessNative();\n\n        return result;\n    }\n\n    /**\n     * @notice Fulfills an intent and initiates proving in one transaction\n     * @dev Executes intent actions and sends proof message to source chain\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route of the intent\n     * @param rewardHash The hash of the reward details\n     * @param claimant Cross-VM compatible claimant identifier\n     * @param prover Address of prover on the destination chain\n     * @param sourceChainDomainID Domain ID of the source chain where the intent was created\n     * @param data Additional data for message formatting\n     * @return Array of execution results\n     *\n     * @dev WARNING: sourceChainDomainID is NOT necessarily the same as chain ID.\n     *      Each bridge provider uses their own domain ID mapping system:\n     *      - Hyperlane: Uses custom domain IDs that may differ from chain IDs\n     *      - LayerZero: Uses endpoint IDs that map to chains differently\n     *      - Metalayer: Uses domain IDs specific to their routing system\n     *      - Polymer: Uses chain IDs\n     *      You MUST consult the specific bridge provider's documentation to determine\n     *      the correct domain ID for the source chain.\n     */\n    function fulfillAndProve(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant,\n        address prover,\n        uint64 sourceChainDomainID,\n        bytes memory data\n    )\n        public\n        payable\n        override(DestinationSettler, IInbox)\n        returns (bytes[] memory)\n    {\n        bytes[] memory result = _fulfill(\n            intentHash,\n            route,\n            rewardHash,\n            claimant\n        );\n\n        // Create array with single intent hash\n        bytes32[] memory intentHashes = new bytes32[](1);\n        intentHashes[0] = intentHash;\n\n        // Call prove with the intent hash array\n        // This will also refund any excess ETH\n        prove(prover, sourceChainDomainID, intentHashes, data);\n\n        return result;\n    }\n\n    /**\n     * @notice Initiates proving process for fulfilled intents\n     * @dev Sends message to source chain to verify intent execution\n     * @param prover Address of prover on the destination chain\n     * @param sourceChainDomainID Domain ID of the source chain\n     * @param intentHashes Array of intent hashes to prove\n     * @param data Additional data for message formatting\n     *\n     * @dev WARNING: sourceChainDomainID is NOT necessarily the same as chain ID.\n     *      Each bridge provider uses their own domain ID mapping system:\n     *      - Hyperlane: Uses custom domain IDs that may differ from chain IDs\n     *      - LayerZero: Uses endpoint IDs that map to chains differently\n     *      - Metalayer: Uses domain IDs specific to their routing system\n     *      - Polymer: Uses chainIDs\n     *      You MUST consult the specific bridge provider's documentation to determine\n     *      the correct domain ID for the source chain.\n     */\n    function prove(\n        address prover,\n        uint64 sourceChainDomainID,\n        bytes32[] memory intentHashes,\n        bytes memory data\n    ) public payable {\n        uint256 size = intentHashes.length;\n\n        // Encode chain ID followed by intent hash/claimant pairs as bytes\n        // 8 bytes for chain ID + (32 bytes for intent hash + 32 bytes for claimant) * size\n        bytes memory encodedClaimants = new bytes(8 + size * 64);\n\n        // Prepend chain ID to the encoded data\n        uint64 chainId = CHAIN_ID;\n        assembly {\n            mstore(add(encodedClaimants, 0x20), shl(192, chainId))\n        }\n\n        for (uint256 i = 0; i < size; ++i) {\n            bytes32 claimantBytes = claimants[intentHashes[i]];\n\n            if (claimantBytes == bytes32(0)) {\n                revert IntentNotFulfilled(intentHashes[i]);\n            }\n\n            // Pack intent hash and claimant into encodedData (after 8-byte chain ID)\n            assembly {\n                let offset := add(8, mul(i, 64))\n                mstore(\n                    add(add(encodedClaimants, 0x20), offset),\n                    mload(add(intentHashes, add(0x20, mul(i, 32))))\n                )\n                mstore(\n                    add(add(encodedClaimants, 0x20), add(offset, 32)),\n                    claimantBytes\n                )\n            }\n\n            // Emit IntentProven event\n            emit IntentProven(intentHashes[i], claimantBytes);\n        }\n\n        // Provide left over balance to the prover\n        IProver(prover).prove{value: address(this).balance}(\n            msg.sender,\n            sourceChainDomainID,\n            encodedClaimants,\n            data\n        );\n    }\n\n    /**\n     * @notice Internal function to fulfill intents\n     * @dev Validates intent and executes calls\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route of the intent\n     * @param rewardHash The hash of the reward\n     * @param claimant Cross-VM compatible claimant identifier\n     * @return Array of execution results\n     */\n    function _fulfill(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant\n    ) internal returns (bytes[] memory) {\n        // Check if the route has expired\n        if (block.timestamp > route.deadline) {\n            revert IntentExpired();\n        }\n\n        bytes32 routeHash = keccak256(abi.encode(route));\n        bytes32 computedIntentHash = keccak256(\n            abi.encodePacked(CHAIN_ID, routeHash, rewardHash)\n        );\n\n        if (route.portal != address(this)) {\n            revert InvalidPortal(route.portal);\n        }\n        if (computedIntentHash != intentHash) {\n            revert InvalidHash(intentHash);\n        }\n        if (claimants[intentHash] != bytes32(0)) {\n            revert IntentAlreadyFulfilled(intentHash);\n        }\n        if (claimant == bytes32(0)) {\n            revert ZeroClaimant();\n        }\n\n        claimants[intentHash] = claimant;\n\n        emit IntentFulfilled(intentHash, claimant);\n\n        // Transfer ERC20 tokens to the executor\n        uint256 tokensLength = route.tokens.length;\n\n        // Validate that msg.value is at least the route's nativeAmount\n        // Allow extra value for cross-chain message fees when using fulfillAndProve\n        if (msg.value < route.nativeAmount) {\n            revert InsufficientNativeAmount(msg.value, route.nativeAmount);\n        }\n\n        for (uint256 i = 0; i < tokensLength; ++i) {\n            TokenAmount memory token = route.tokens[i];\n\n            IERC20(token.token).safeTransferFrom(\n                msg.sender,\n                address(executor),\n                token.amount\n            );\n        }\n\n        return executor.execute{value: route.nativeAmount}(route.calls);\n    }\n}\n"
    }
}