{
    "vfp_id": "vfp_00153",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary bit masking in StageMath functions",
            "description": "The StageMath functions apply a bit mask to uint128 values that are already properly decoded, making the masking redundant. The root cause is unnecessary operation. This wastes gas and reduces code clarity. The impact is increased gas costs and maintenance burden.\n",
            "severity": "Informational",
            "location": [
                "StageMathsol"
            ],
            "files": [
                "likwid-margin/src/libraries/StageMath.sol"
            ]
        }
    ],
    "affected_files": {
        "StageMath.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Likwid Contracts\npragma solidity ^0.8.26;\n\nlibrary StageMath {\n    function add(uint256 stage, uint128 amount) internal pure returns (uint256) {\n        (uint128 _total, uint128 _liquidity) = decode(stage);\n        _total += amount;\n        _liquidity += amount;\n        return (uint256(_total) << 128) | uint256(_liquidity & ((1 << 128) - 1));\n    }\n\n    function sub(uint256 stage, uint128 amount) internal pure returns (uint256) {\n        (uint128 _total, uint128 _liquidity) = decode(stage);\n        _liquidity -= amount;\n        return (uint256(_total) << 128) | uint256(_liquidity & ((1 << 128) - 1));\n    }\n\n    function subTotal(uint256 stage, uint128 amount) internal pure returns (uint256) {\n        (uint128 _total, uint128 _liquidity) = decode(stage);\n        _total -= amount;\n        _liquidity -= amount;\n        return (uint256(_total) << 128) | uint256(_liquidity & ((1 << 128) - 1));\n    }\n\n    function isFree(uint256 stage, uint32 leavePart) internal pure returns (bool) {\n        (uint128 total, uint128 liquidity) = decode(stage);\n        if (leavePart == 0) {\n            leavePart = 2;\n        }\n        return total / leavePart >= liquidity;\n    }\n\n    function decode(uint256 stage) internal pure returns (uint128 total, uint128 liquidity) {\n        if (stage == 0) {\n            return (0, 0);\n        }\n        total = uint128(stage >> 128);\n        liquidity = uint128(stage & ((1 << 128) - 1));\n    }\n}\n"
    }
}