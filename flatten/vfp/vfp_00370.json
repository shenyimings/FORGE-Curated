{
    "vfp_id": "vfp_00370",
    "project_name": "ChainSecurity_M0_MExtensions_Audit.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Wrapped $M V1 Is Unsupported",
            "description": "The SwapFacility and UniswapV3SwapAdapter contracts assume that `wrap()` and `unwrap()` on Wrapped $M V1 mint and burn exact token amounts. However, the deployed version incurs rounding errors, violating this assumption. The cause is imprecise arithmetic in the token's wrapping logic. When these functions are called, the expected amount-in and amount-out calculations fail due to discrepancies between expected and actual balances, causing reverts in critical swap functions. This impacts the usability of the entire swapping infrastructure, potentially blocking user transactions and reducing system reliability.\n",
            "severity": "Medium",
            "location": [
                "SwapFacility::wrap/unwrap",
                "UniswapV3SwapAdapter::wrap/unwrap"
            ],
            "files": [
                "evm-m-extensions/src/swap/SwapFacility.sol",
                "evm-m-extensions/src/swap/UniswapV3SwapAdapter.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Wrong Remaining Balance in swapOut()",
            "description": "In `UniswapV3SwapAdapter.swapOut()`, the remaining wMToken balance after a partial swap is incorrectly calculated because `wrappedMBalanceBefore` is read after the swap instead of before. This causes `remainingBalance` to always be zero, even when leftover tokens exist. The root cause is incorrect ordering of balance checks. As a result, unspent funds may be left stranded in the contract, leading to loss of user assets or incorrect state assumptions in subsequent operations. This could be exploited by manipulating swap routes to leave residual funds that are not returned to the user.\n",
            "severity": "Medium",
            "location": [
                "UniswapV3SwapAdapter::swapOut"
            ],
            "files": [
                "evm-m-extensions/src/swap/UniswapV3SwapAdapter.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Discrepancy in Event Emission",
            "description": "The `_whitelistToken()` function in UniswapV3SwapAdapter emits the `TokenWhitelisted` event even when the token's whitelist status does not change, deviating from the standard pattern elsewhere in the codebase. The cause is lack of a pre-check for existing status. This inconsistency can mislead off-chain systems that rely on events for state tracking, causing false positives in monitoring tools or analytics platforms. While not security-critical, it reduces reliability of event-based indexing.\n",
            "severity": "Informational",
            "location": [
                "UniswapV3SwapAdapter::_whitelistToken"
            ],
            "files": [
                "evm-m-extensions/src/swap/UniswapV3SwapAdapter.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Potentially Redundant Balance Difference",
            "description": "The `SwapFacility.swapOutToken()` function uses a balance difference to account for rounding errors in Wrapped $M V1's `wrap()` function. This is currently necessary due to known rounding issues. However, if Wrapped $M is upgraded to a version without such errors, this balance difference becomes redundant. The cause is defensive coding for a known bug in an external contract. While not a vulnerability now, it highlights technical debt that should be revisited post-upgrade to simplify logic and reduce gas costs.\n",
            "severity": "Informational",
            "location": [
                "SwapFacility::swapOutToken"
            ],
            "files": [
                "evm-m-extensions/src/swap/SwapFacility.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant Balance Difference",
            "description": "The `_swap()` and `_swapOutM()` functions in SwapFacility recompute amounts using balance differences to handle potential rounding errors in the M token. However, since SwapFacility is not an earner, no such rounding occurs. The cause is unnecessary defensive programming. This redundancy increases gas usage and complicates code logic without benefit. Removing it would improve efficiency and readability without introducing risk.\n",
            "severity": "Informational",
            "location": [
                "SwapFacility::_swap",
                "SwapFacility::_swapOutM"
            ],
            "files": [
                "evm-m-extensions/src/swap/SwapFacility.sol"
            ]
        }
    ],
    "affected_files": {
        "UniswapV3SwapAdapter.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"../../lib/openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IUniswapV3SwapAdapter } from \"./interfaces/IUniswapV3SwapAdapter.sol\";\nimport { IV3SwapRouter } from \"./interfaces/uniswap/IV3SwapRouter.sol\";\n\n/**\n * @title  Uniswap V3 Swap Adapter\n * @author M0 Labs\n *         MetaStreet Foundation\n *         Adapted from https://github.com/metastreet-labs/metastreet-usdai-contracts/blob/main/src/swapAdapters/UniswapV3SwapAdapter.sol\n */\ncontract UniswapV3SwapAdapter is IUniswapV3SwapAdapter, AccessControl {\n    using SafeERC20 for IERC20;\n\n    /// @notice Fee for Uniswap V3 swap router (0.01%)\n    uint24 internal constant UNISWAP_V3_FEE = 100;\n\n    /// @notice Path address size\n    uint256 internal constant PATH_ADDR_SIZE = 20;\n\n    /// @notice Path fee size\n    uint256 internal constant PATH_FEE_SIZE = 3;\n\n    /// @notice Path next offset\n    uint256 internal constant PATH_NEXT_OFFSET = PATH_ADDR_SIZE + PATH_FEE_SIZE;\n\n    address public immutable swapRouter;\n\n    address public immutable baseToken;\n\n    mapping(address token => bool whitelisted) public whitelistedTokens;\n\n    /**\n     * @notice Constructs UniswapV3SwapAdapter contract\n     * @param  baseToken_ The address of base token.\n     * @param  swapRouter_ The address of the Uniswap V3 swap router.\n     * @param  admin The address of the admin.\n     * @param  tokens The list of whitelisted tokens.\n     */\n    constructor(address baseToken_, address swapRouter_, address admin, address[] memory tokens) {\n        if ((baseToken = baseToken_) == address(0)) revert ZeroBaseToken();\n        if ((swapRouter = swapRouter_) == address(0)) revert ZeroSwapRouter();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n        for (uint256 i; i < tokens.length; i++) {\n            _whitelistToken(tokens[i], true);\n        }\n    }\n\n    /// @inheritdoc IUniswapV3SwapAdapter\n    function swapIn(\n        address inputToken,\n        uint256 inputAmount,\n        uint256 minBaseAmount,\n        address recipient,\n        bytes calldata path\n    ) external returns (uint256 baseAmount) {\n        _revertIfNotWhitelistedToken(inputToken);\n        _revertIfZeroAmount(inputAmount);\n        _revertIfInvalidSwapInPath(inputToken, path);\n        _revertIfZeroRecipient(recipient);\n\n        // Transfer token input from sender to this contract\n        IERC20(inputToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n\n        address swapRouter_ = swapRouter;\n\n        // Approve the router to spend token input\n        IERC20(inputToken).forceApprove(swapRouter_, inputAmount);\n\n        // Swap token input for base token\n        if (path.length == 0) {\n            IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams({\n                tokenIn: inputToken,\n                tokenOut: baseToken,\n                fee: UNISWAP_V3_FEE,\n                recipient: recipient,\n                amountIn: inputAmount,\n                amountOutMinimum: minBaseAmount,\n                sqrtPriceLimitX96: 0\n            });\n\n            baseAmount = IV3SwapRouter(swapRouter_).exactInputSingle(params);\n        } else {\n            IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter.ExactInputParams({\n                path: path,\n                recipient: msg.sender,\n                amountIn: inputAmount,\n                amountOutMinimum: minBaseAmount\n            });\n\n            baseAmount = IV3SwapRouter(swapRouter_).exactInput(params);\n        }\n    }\n\n    /// @inheritdoc IUniswapV3SwapAdapter\n    function swapOut(\n        address outputToken,\n        uint256 baseAmount,\n        uint256 minOutputAmount,\n        address recipient,\n        bytes calldata path\n    ) external returns (uint256 outputAmount) {\n        _revertIfNotWhitelistedToken(outputToken);\n        _revertIfZeroAmount(baseAmount);\n        _revertIfInvalidSwapOutPath(outputToken, path);\n        _revertIfZeroRecipient(recipient);\n\n        // Transfer token input from sender to this contract\n        IERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseAmount);\n\n        // Approve the router to spend base token\n        IERC20(baseToken).forceApprove(swapRouter, baseAmount);\n\n        // Swap base token for token output\n        if (path.length == 0) {\n            IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams({\n                tokenIn: baseToken,\n                tokenOut: outputToken,\n                fee: UNISWAP_V3_FEE,\n                recipient: recipient,\n                amountIn: baseAmount,\n                amountOutMinimum: minOutputAmount,\n                sqrtPriceLimitX96: 0\n            });\n\n            outputAmount = IV3SwapRouter(swapRouter).exactInputSingle(params);\n        } else {\n            IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter.ExactInputParams({\n                path: path,\n                recipient: recipient,\n                amountIn: baseAmount,\n                amountOutMinimum: minOutputAmount\n            });\n\n            outputAmount = IV3SwapRouter(swapRouter).exactInput(params);\n        }\n    }\n\n    /// @inheritdoc IUniswapV3SwapAdapter\n    function whitelistToken(address token, bool isWhitelisted) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _whitelistToken(token, isWhitelisted);\n    }\n\n    function _whitelistToken(address token, bool isWhitelisted) private {\n        if (token == address(0)) revert ZeroToken();\n        whitelistedTokens[token] = isWhitelisted;\n\n        emit TokenWhitelisted(token, isWhitelisted);\n    }\n\n    /**\n     * @notice Decode input and output tokens\n     * @param  path Swap path\n     * @return tokenInput Address of the input token\n     * @return tokenOutput Address if the output token\n     */\n    function _decodeInputAndOutputTokens(\n        bytes calldata path\n    ) internal pure returns (address tokenInput, address tokenOutput) {\n        // Validate path format\n        if (\n            (path.length < PATH_ADDR_SIZE + PATH_FEE_SIZE + PATH_ADDR_SIZE) ||\n            ((path.length - PATH_ADDR_SIZE) % PATH_NEXT_OFFSET != 0)\n        ) {\n            revert InvalidPathFormat();\n        }\n\n        tokenInput = address(bytes20(path[:PATH_ADDR_SIZE]));\n\n        // Calculate position of output token\n        uint256 numHops = (path.length - PATH_ADDR_SIZE) / PATH_NEXT_OFFSET;\n        uint256 outputTokenIndex = numHops * PATH_NEXT_OFFSET;\n\n        tokenOutput = address(bytes20(path[outputTokenIndex:outputTokenIndex + PATH_ADDR_SIZE]));\n    }\n\n    /**\n     * @dev   Reverts if not whitelisted token.\n     * @param token Address of a token.\n     */\n    function _revertIfNotWhitelistedToken(address token) internal view {\n        if (!whitelistedTokens[token]) revert NotWhitelistedToken(token);\n    }\n\n    /**\n     * @dev   Reverts if `recipient` is address(0).\n     * @param recipient Address of a recipient.\n     */\n    function _revertIfZeroRecipient(address recipient) internal pure {\n        if (recipient == address(0)) revert ZeroRecipient();\n    }\n\n    /**\n     * @dev   Reverts if `amount` is equal to 0.\n     * @param amount Amount of token.\n     */\n    function _revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the swap path is invalid for swapping in.\n     * @param  tokenInput Address of the input token.\n     * @param  path Swap path.\n     */\n    function _revertIfInvalidSwapInPath(address tokenInput, bytes calldata path) internal view {\n        if (path.length != 0) {\n            (address tokenInput_, address tokenOutput) = _decodeInputAndOutputTokens(path);\n            if (tokenInput_ != tokenInput || tokenOutput != baseToken) revert InvalidPath();\n        }\n    }\n\n    /**\n     * @notice Reverts if the swap path is invalid for swapping out.\n     * @param  tokenOutput Address of the output token.\n     * @param  path Swap path.\n     */\n    function _revertIfInvalidSwapOutPath(address tokenOutput, bytes calldata path) internal view {\n        if (path.length != 0) {\n            (address tokenInput, address tokenOutput_) = _decodeInputAndOutputTokens(path);\n            if (tokenInput != baseToken || tokenOutput_ != tokenOutput) revert InvalidPath();\n        }\n    }\n}\n",
        "SwapFacility.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    AccessControlUpgradeable\n} from \"../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport { Lock } from \"../../lib/universal-router/contracts/base/Lock.sol\";\n\nimport { IMTokenLike } from \"../interfaces/IMTokenLike.sol\";\nimport { IMExtension } from \"../interfaces/IMExtension.sol\";\n\nimport { ISwapFacility } from \"./interfaces/ISwapFacility.sol\";\nimport { IRegistrarLike } from \"./interfaces/IRegistrarLike.sol\";\nimport { IUniswapV3SwapAdapter } from \"./interfaces/IUniswapV3SwapAdapter.sol\";\n\n/**\n * @title  Swap Facility\n * @notice A contract responsible for swapping between $M Extensions.\n * @author M0 Labs\n */\ncontract SwapFacility is ISwapFacility, AccessControlUpgradeable, Lock {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant EARNERS_LIST_IGNORED_KEY = \"earners_list_ignored\";\n    bytes32 public constant EARNERS_LIST_NAME = \"earners\";\n    bytes32 public constant M_SWAPPER_ROLE = keccak256(\"M_SWAPPER_ROLE\");\n\n    /// @inheritdoc ISwapFacility\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable mToken;\n\n    /// @inheritdoc ISwapFacility\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable registrar;\n\n    /// @inheritdoc ISwapFacility\n    address public immutable swapAdapter;\n\n    /**\n     * @notice Constructs SwapFacility Implementation contract\n     * @dev    Sets immutable storage.\n     * @param  mToken_      The address of $M token.\n     * @param  registrar_   The address of Registrar.\n     * @param  swapAdapter_ The address of Uniswap swap adapter.\n     */\n    constructor(address mToken_, address registrar_, address swapAdapter_) {\n        _disableInitializers();\n\n        if ((mToken = mToken_) == address(0)) revert ZeroMToken();\n        if ((registrar = registrar_) == address(0)) revert ZeroRegistrar();\n        if ((swapAdapter = swapAdapter_) == address(0)) revert ZeroSwapAdapter();\n    }\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @notice Initializes SwapFacility Proxy.\n     * @param  admin Address of the SwapFacility admin.\n     */\n    function initialize(address admin) external initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc ISwapFacility\n    function swap(address extensionIn, address extensionOut, uint256 amount, address recipient) external isNotLocked {\n        // NOTE: Amount and recipient validation is performed in Extensions.\n        _revertIfNotApprovedExtension(extensionIn);\n        _revertIfNotApprovedExtension(extensionOut);\n\n        _swap(extensionIn, extensionOut, amount, recipient);\n\n        emit Swapped(extensionIn, extensionOut, amount, recipient);\n    }\n\n    /// @inheritdoc ISwapFacility\n    function swapInM(address extensionOut, uint256 amount, address recipient) external isNotLocked {\n        // NOTE: Amount and recipient validation is performed in Extensions.\n        _revertIfNotApprovedExtension(extensionOut);\n\n        _swapInM(extensionOut, amount, recipient);\n    }\n\n    /// @inheritdoc ISwapFacility\n    function swapInMWithPermit(\n        address extensionOut,\n        uint256 amount,\n        address recipient,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external isNotLocked {\n        _revertIfNotApprovedExtension(extensionOut);\n\n        try IMTokenLike(mToken).permit(msgSender(), address(this), amount, deadline, v, r, s) {} catch {}\n\n        _swapInM(extensionOut, amount, recipient);\n    }\n\n    /// @inheritdoc ISwapFacility\n    function swapInMWithPermit(\n        address extensionOut,\n        uint256 amount,\n        address recipient,\n        uint256 deadline,\n        bytes calldata signature\n    ) external isNotLocked {\n        _revertIfNotApprovedExtension(extensionOut);\n\n        try IMTokenLike(mToken).permit(msgSender(), address(this), amount, deadline, signature) {} catch {}\n\n        _swapInM(extensionOut, amount, recipient);\n    }\n\n    /// @inheritdoc ISwapFacility\n    function swapOutM(address extensionIn, uint256 amount, address recipient) external isNotLocked {\n        // NOTE: Amount and recipient validation is performed in Extensions.\n        _revertIfNotApprovedExtension(extensionIn);\n        _revertIfNotApprovedSwapper(msgSender());\n\n        _swapOutM(extensionIn, amount, recipient);\n    }\n\n    /// @inheritdoc ISwapFacility\n    function swapInToken(\n        address tokenIn,\n        uint256 amountIn,\n        address extensionOut,\n        uint256 minAmountOut,\n        address recipient,\n        bytes calldata path\n    ) external isNotLocked {\n        _revertIfNotApprovedExtension(extensionOut);\n\n        // Transfer input token to SwapFacility for future transfer to Swap Adapter.\n        IERC20(tokenIn).safeTransferFrom(msgSender(), address(this), amountIn);\n\n        // Approve Swap Adapter to spend input token.\n        IERC20(tokenIn).forceApprove(swapAdapter, amountIn);\n\n        // Swap input token for base token in Uniswap pool\n        uint256 amountOut = IUniswapV3SwapAdapter(swapAdapter).swapIn(\n            tokenIn,\n            amountIn,\n            minAmountOut,\n            address(this),\n            path\n        );\n\n        address baseToken = IUniswapV3SwapAdapter(swapAdapter).baseToken();\n        // If extensionOut is baseToken, transfer to the recipient directly\n        if (extensionOut == baseToken) {\n            IERC20(baseToken).transfer(recipient, amountOut);\n        } else {\n            // Otherwise, swap the baseToken to extensionOut\n            _swap(baseToken, extensionOut, amountOut, recipient);\n        }\n\n        emit Swapped(tokenIn, extensionOut, amountOut, recipient);\n    }\n\n    /// @inheritdoc ISwapFacility\n    function swapOutToken(\n        address extensionIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        address recipient,\n        bytes calldata path\n    ) external isNotLocked {\n        _revertIfNotApprovedExtension(extensionIn);\n\n        address baseToken = IUniswapV3SwapAdapter(swapAdapter).baseToken();\n        if (extensionIn == baseToken) {\n            // If extensionIn is baseToken (Wrapped $M), transfer it to SwapFacility\n            IERC20(baseToken).safeTransferFrom(msgSender(), address(this), amountIn);\n        } else {\n            uint256 balanceBefore = IERC20(baseToken).balanceOf(address(this));\n\n            // Otherwise, swap the extensionIn to baseToken\n            _swap(extensionIn, baseToken, amountIn, address(this));\n\n            // Calculate amountIn as the difference in balance to account for rounding errors\n            amountIn = IERC20(baseToken).balanceOf(address(this)) - balanceBefore;\n        }\n\n        // Approve Swap Adapter to spend baseToken (Wrapped $M).\n        IERC20(baseToken).forceApprove(swapAdapter, amountIn);\n\n        // Swap baseToken in Uniswap pool for output token\n        uint256 amountOut = IUniswapV3SwapAdapter(swapAdapter).swapOut(\n            tokenOut,\n            amountIn,\n            minAmountOut,\n            recipient,\n            path\n        );\n\n        emit Swapped(extensionIn, tokenOut, amountOut, recipient);\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc ISwapFacility\n    function msgSender() public view returns (address) {\n        return _getLocker();\n    }\n\n    /* ============ Private Interactive Functions ============ */\n\n    /**\n     * @notice Swaps one $M Extension to another.\n     * @param  extensionIn  The address of the $M Extension to swap from.\n     * @param  extensionOut The address of the $M Extension to swap to.\n     * @param  amount       The amount to swap.\n     * @param  recipient    The address to receive the swapped $M Extension tokens.\n     */\n    function _swap(address extensionIn, address extensionOut, uint256 amount, address recipient) private {\n        uint256 balanceBefore = _mBalanceOf(address(this));\n\n        // Recipient parameter is ignored in the MExtension, keeping it for backward compatibility.\n        IMExtension(extensionIn).unwrap(address(this), amount);\n\n        // NOTE: Calculate amount as $M Token balance difference\n        //       to account for rounding errors.\n        amount = _mBalanceOf(address(this)) - balanceBefore;\n\n        IERC20(mToken).approve(extensionOut, amount);\n        IMExtension(extensionOut).wrap(recipient, amount);\n    }\n\n    /**\n     * @notice Swaps $M token to $M Extension.\n     * @param  extensionOut The address of the M Extension to swap to.\n     * @param  amount       The amount of $M token to swap.\n     * @param  recipient    The address to receive the swapped $M Extension tokens.\n     */\n    function _swapInM(address extensionOut, uint256 amount, address recipient) private {\n        IERC20(mToken).transferFrom(msgSender(), address(this), amount);\n        IERC20(mToken).approve(extensionOut, amount);\n        IMExtension(extensionOut).wrap(recipient, amount);\n\n        emit SwappedInM(extensionOut, amount, recipient);\n    }\n\n    /**\n     * @notice Swaps $M Extension to $M token.\n     * @param  extensionIn The address of the $M Extension to swap from.\n     * @param  amount      The amount of $M Extension tokens to swap.\n     * @param  recipient   The address to receive $M tokens.\n     */\n    function _swapOutM(address extensionIn, uint256 amount, address recipient) private {\n        uint256 balanceBefore = _mBalanceOf(address(this));\n\n        // Recipient parameter is ignored in the MExtension, keeping it for backward compatibility.\n        IMExtension(extensionIn).unwrap(address(this), amount);\n\n        // NOTE: Calculate amount as $M Token balance difference\n        //       to account for rounding errors.\n        amount = _mBalanceOf(address(this)) - balanceBefore;\n        IERC20(mToken).transfer(recipient, amount);\n\n        emit SwappedOutM(extensionIn, amount, recipient);\n    }\n\n    /**\n     * @dev    Returns the M Token balance of `account`.\n     * @param  account The account being queried.\n     * @return balance The M Token balance of the account.\n     */\n    function _mBalanceOf(address account) internal view returns (uint256) {\n        return IMTokenLike(mToken).balanceOf(account);\n    }\n\n    /* ============ Private View/Pure Functions ============ */\n\n    /**\n     * @dev   Reverts if `extension` is not an approved earner.\n     * @param extension Address of an extension.\n     */\n    function _revertIfNotApprovedExtension(address extension) private view {\n        if (!_isApprovedEarner(extension)) revert NotApprovedExtension(extension);\n    }\n\n    /**\n     * @dev   Reverts if `account` is not an approved M token swapper.\n     * @param account Address of an extension.\n     */\n    function _revertIfNotApprovedSwapper(address account) private view {\n        if (!hasRole(M_SWAPPER_ROLE, account)) revert NotApprovedSwapper(account);\n    }\n\n    /**\n     * @dev    Checks if the given extension is an approved earner.\n     * @param  extension Address of the extension to check.\n     * @return True if the extension is an approved earner, false otherwise.\n     */\n    function _isApprovedEarner(address extension) private view returns (bool) {\n        return\n            IRegistrarLike(registrar).get(EARNERS_LIST_IGNORED_KEY) != bytes32(0) ||\n            IRegistrarLike(registrar).listContains(EARNERS_LIST_NAME, extension);\n    }\n}\n"
    }
}