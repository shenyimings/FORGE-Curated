{
    "vfp_id": "vfp_00189",
    "project_name": "Forte - Zenith Audit Report (October).pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "LPToken needs to disable renounceOwnership()",
            "description": "The LPToken contract inherits from Ownable2Step, which allows the owner to renounce ownership. If ownership is renounced, critical administrative functions could become permanently disabled, potentially leading to loss of control over essential contract operations. \nThe root cause is the lack of explicit prevention of ownership renouncement in the LPToken contract, unlike other components such as FactoryBase which already disable this functionality. \nAn attacker could potentially social-engineer or manipulate the owner into renouncing ownership, or the owner might do so accidentally, leading to irreversible loss of control. \nThe impact is limited to operational disruption rather than direct fund loss, hence the low severity.\n",
            "severity": "Low",
            "location": [
                "LPToken.sol::#19-20"
            ],
            "files": [
                "e65ee2644f50649a95b74b02032025d3bf5ef54e/liquidity-base/src/common/LPToken.sol"
            ]
        }
    ],
    "affected_files": {
        "LPToken.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport {ERC721, IERC165} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {ILPTokenEvents} from \"./IEvents.sol\";\nimport \"./IErrors.sol\";\nimport {packedFloat, MathLibs} from \"../amm/mathLibs/MathLibs.sol\";\nimport {ILPToken, LPTokenS} from \"./ILPToken.sol\";\nimport {Descriptor} from \"../common/SVG/NFTSVG.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\n\n/**\n * @title Liquidity provider token\n * @dev This contract serves as the LP Token associated with a liquidity position.\n * @dev Revenue and liquidity position are stored in the LP Token metadata and updated by the pool contract.\n * @author @palmerg4 @oscarsernarosero @cirsteve\n */\ncontract LPToken is Ownable2Step, ERC721, ERC721Enumerable, ILPToken {\n    using MathLibs for packedFloat;\n\n    uint256 public currentTokenId;\n    address public factoryAddress;\n    address public factoryAddressProposed;\n\n    // id => (wj, rj)\n    mapping(uint256 tokenId => LPTokenS lpToken) lpToken;\n    // id => pool it belongs to\n    mapping(uint256 tokenId => address pool) public idToPool;\n    // pool allowlist\n    mapping(address pool => bool isAllowed) allowedPool;\n    // inactive tokens\n    mapping(uint256 tokenId => bool isInactive) public inactiveToken;\n\n    modifier onlyAllowedPools() {\n        if (!allowedPool[msg.sender]) revert PoolNotAllowed();\n        _;\n    }\n\n    modifier onlyTokensFromPool(uint256 tokenId) {\n        if (msg.sender != idToPool[tokenId]) revert TokenNotFromPool();\n        _;\n    }\n\n    modifier onlyFactory() {\n        if (msg.sender != factoryAddress) revert NotFactory();\n        _;\n    }\n\n    constructor(string memory _name, string memory _symbol) Ownable(msg.sender) ERC721(_name, _symbol) {\n        emit ILPTokenEvents.ALTBCPositionTokenDeployed();\n    }\n\n    /**\n     * @dev Get the liquidity share and last claimed amount for an lpToken\n     * @param tokenId The token id of the lpToken being updated\n     * @return wj the amount of the lpToken\n     * @return rj the last revenue claim of the lpToken\n     */\n    function getLPToken(uint256 tokenId) public view returns (packedFloat wj, packedFloat rj) {\n        LPTokenS memory token = lpToken[tokenId];\n        return (token.wj, token.rj);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable, IERC165) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Mints a new lpToken to a liquidity provider and updated the value associated with this new lpToken\n     * @notice The internal version of the mint method. Used in the constructor, in order to circumvent ownership transfers.\n     * @param lp The address of the liquidity provider owning the lpToken being updated\n     * @param wj The amount of liquidity provided by the liquidity provider\n     * @param hn The revenue parameter of the pool associated with the lpToken contract\n     */\n    function mintTokenAndUpdate(address lp, packedFloat wj, packedFloat hn) external onlyAllowedPools returns (uint256 tokenId) {\n        currentTokenId++;\n        _mint(lp, currentTokenId);\n        idToPool[currentTokenId] = msg.sender;\n        updateLPToken(currentTokenId, wj, hn);\n        tokenId = currentTokenId;\n    }\n\n    /**\n     * @dev Updates the values wj and rj of tokenId\n     * @notice The internal version of the updateLPToken method. Used in the constructor, in order to circumvent ownership transfers.\n     * @param tokenId The token id of the lpToken being updated\n     * @param _wj The amount of liquidity associated with the lpToken being updated\n     * @param _rj The amount of revenue associated with the lpToken being updated\n     */\n    function updateLPToken(uint256 tokenId, packedFloat _wj, packedFloat _rj) public onlyTokensFromPool(tokenId) {\n        lpToken[tokenId].rj = _rj;\n        lpToken[tokenId].wj = _wj;\n        emit ILPTokenEvents.LPTokenUpdated(tokenId, _wj, _rj);\n    }\n\n    /**\n     * @dev Updates the amount of liquidity associated with an LP Token. Used when withdrawing a full or partial liquidity position.\n     * @notice If an LP is withdrawing their entire position, the LP Token associated will be burned.\n     * @param _tokenId The token id of the lpToken being updated\n     * @param _wj The amount of liquidity the LP would like to withdraw\n     * @param _rj The new value of _rj\n     */\n    function updateLPTokenWithdrawal(uint256 _tokenId, packedFloat _wj, packedFloat _rj) external {\n        updateLPToken(_tokenId, _wj, _rj);\n        if (_wj.eq(packedFloat.wrap(0))) {\n            if (msg.sender != idToPool[_tokenId]) revert TokenNotFromPool();\n            _burn(_tokenId);\n            delete lpToken[_tokenId];\n        }\n    }\n\n    /**\n     * @dev See {ERC721-_update}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal override(ERC721, ERC721Enumerable) returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {\n        super._increaseBalance(account, value);\n    }\n\n    /**\n     * @dev add a pool to the allow list\n     * @param pool the address of the pool to be added\n     * @notice Only the factory should be able to add pools to the allow list\n     */\n    function addPoolToAllowList(address pool) external onlyFactory {\n        if (pool == address(0)) revert ZeroAddress();\n        if (allowedPool[pool]) revert PoolAlreadyAllowed();\n        allowedPool[pool] = true;\n        inactiveToken[currentTokenId + 1] = true;\n        emit ILPTokenEvents.PoolAddedToAllowList(pool, currentTokenId + 1);\n    }\n\n    /**\n     * @dev tells is a pool is allowed\n     * @param pool the address of the pool to be added\n     * @return true if the pool is allowed\n     */\n    function isPoolAllowed(address pool) external view returns (bool) {\n        return allowedPool[pool];\n    }\n\n    /**\n     * @dev propose the factory address\n     * @param factory the address of the proposed factory\n     * @notice Only the owner should be able to propose a factory\n     */\n    function proposeFactoryAddress(address factory) external onlyOwner {\n        if (factory == address(0)) revert ZeroAddress();\n        factoryAddressProposed = factory;\n        emit ILPTokenEvents.FactoryProposed(factory);\n    }\n\n    /**\n     * @dev confirm the factory address\n     * @notice Only the proposed factory should be able to confirm the factory address\n     */\n    function confirmFactoryAddress() external {\n        if (msg.sender != factoryAddressProposed) revert NotProposedFactory(factoryAddressProposed);\n        delete factoryAddressProposed;\n        factoryAddress = msg.sender;\n        emit ILPTokenEvents.FactoryConfirmed(msg.sender);\n    }\n\n    /**\n     * @dev Overrides the tokenURI function from ERC721 to generate an NFT with pool information\n     * @param tokenId The token ID to generate the URI for\n     * @return The token URI with SVG image and metadata\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (_ownerOf(tokenId) == address(0)) revert URIQueryForNonexistentToken();\n        return Descriptor.constructTokenURI(tokenId, idToPool[tokenId], inactiveToken[tokenId]);\n    }\n}\n"
    }
}