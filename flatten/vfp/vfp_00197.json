{
    "vfp_id": "vfp_00197",
    "project_name": "Virtuals Protocol Staking - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Stakers with autoRenew enabled have an unfair advantage",
            "description": "1. **Description:** Users who enable the autoRenew feature during staking are granted full, non-decaying voting power for the entire lock period, while still being able to withdraw after the standard maxWeeks period. In contrast, users who stake for maxWeeks without autoRenew experience vote decay over time and face the same withdrawal delay, creating an unfair advantage for autoRenew users.\n2. **Cause:** The _balanceOfLockAt() function returns the full lock value if autoRenew is enabled, bypassing vote decay logic. Additionally, the stake() function forces numWeeks to maxWeeks when autoRenew is true, allowing these users to benefit from maximum lock duration without decay.\n3. **Exploitation:** An attacker could repeatedly enable autoRenew on their locks to maintain maximum voting power indefinitely relative to non-autoRenew stakers, gaining disproportionate influence in governance decisions.\n4. **Impact:** This leads to an inequitable distribution of voting power, undermining the fairness and integrity of the protocol's governance system.\n",
            "severity": "High",
            "location": [
                "veVirtual.sol::stake#130",
                "veVirtual.sol::_balanceOfLockAt#162-181"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-706"
                ],
                "3": [
                    "CWE-386"
                ]
            },
            "title": "withdraw() switches indexes around which can lead to unintended operations when calling toggleAutoRenew(), extend() and withdraw() in a short time",
            "description": "1. **Description:** The withdraw() function reorders the locks array by moving the last element into the position of the withdrawn lock and then deleting the last entry. However, other functions like toggleAutoRenew(), extend(), and withdraw() itself rely on the index of a lock to perform operations.\n2. **Cause:** The use of array indices as identifiers without a stable lock ID means that concurrent transactions can operate on incorrect locks due to index shifts caused by prior withdrawals.\n3. **Exploitation:** If a user submits multiple transactions targeting different locks in quick succession, the reordering of indices during execution could cause a transaction to act on a different lock than intended, potentially leading to failed transactions or unintended state changes.\n4. **Impact:** This can result in user funds being locked unexpectedly or governance actions being performed on the wrong lock, leading to loss of control or reduced usability.\n",
            "severity": "Medium",
            "location": [
                "veVirtual.sol::withdraw#162",
                "veVirtual.sol::toggleAutoRenew#183",
                "veVirtual.sol::extend#199"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "stake() allows to stake for 0 weeks leading to just-in-time voting",
            "description": "1. **Description:** The stake() function allows users to specify 0 weeks as the lock duration, which immediately makes the tokens eligible for withdrawal while still granting full voting power based on the staked amount.\n2. **Cause:** There is no validation preventing numWeeks from being set to 0, enabling users to stake and vote with zero time commitment.\n3. **Exploitation:** An attacker can stake tokens for 0 weeks, vote in a governance proposal, and immediately withdraw their tokens, effectively executing a just-in-time voting attack to manipulate governance outcomes without any long-term stake.\n4. **Impact:** This undermines the economic security of the governance system by allowing temporary, non-committed stakeholders to influence decisions, potentially leading to malicious proposals passing.\n",
            "severity": "Medium",
            "location": [
                "veVirtual.sol::stake#130"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Changing the maxWeeks variable can lead to unexpected consequences",
            "description": "1. **Description:** Modifying the maxWeeks parameter via setMaxWeeks() can lead to inconsistent behavior in lock management, particularly for locks with autoRenew enabled. The toggleAutoRenew() function uses the old value of maxWeeks stored in lock.numWeeks, which may no longer reflect the current maxWeeks.\n2. **Cause:** The lock.numWeeks is not updated when maxWeeks changes, and the value calculation in _balanceOfLockAt() does not account for the current maxWeeks, leading to incorrect voting power calculations and potential multipliers exceeding 100%.\n3. **Exploitation:** An attacker with a lock created under a higher maxWeeks value could retain inflated voting power after maxWeeks is reduced, or manipulate the system by timing their autoRenew toggling around a maxWeeks change.\n4. **Impact:** This can result in incorrect voting power distribution, inconsistent lock behavior, and potential exploitation of governance mechanisms due to outdated or mismatched lock parameters.\n",
            "severity": "Medium",
            "location": [
                "veVirtual.sol::toggleAutoRenew#183",
                "veVirtual.sol::setMaxWeeks#217",
                "veVirtual.sol::_balanceOfLockAt#106",
                "veVirtual.sol::getMaturity#221"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "unbounded loops iterations on stakedAmountOf() and balanceOfAt()",
            "description": "1. **Description:** The stakedAmountOf() and balanceOfAt() functions iterate over a user's entire array of locks without any bound checks, which can lead to out-of-gas failures if the array becomes too large.\n2. **Cause:** The absence of a limit on the number of locks a user can create results in unbounded loop iterations during balance calculations.\n3. **Exploitation:** An attacker could create a large number of small locks to bloat their locks array, causing any function that iterates over it (e.g., delegation or balance queries) to fail due to gas limits.\n4. **Impact:** This can prevent legitimate users from delegating votes or checking balances, leading to denial-of-service conditions and reduced protocol usability.\n",
            "severity": "Low",
            "location": [
                "veVirtual.sol::stakedAmountOf#258",
                "veVirtual.sol::balanceOfAt#84"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1050"
                ]
            },
            "title": "Suboptimal locks array management",
            "description": "1. **Description:** The withdraw() function uses the delete keyword to clear a lock entry but does not reduce the array length, leaving behind empty slots in the locks array.\n2. **Cause:** Using delete instead of pop results in storage bloat and inefficient iteration over sparse arrays.\n3. **Exploitation:** Over time, repeated withdrawals can accumulate many empty entries, increasing gas costs for any operation that loops through the array (e.g., _getVotingUnits), and potentially leading to out-of-gas errors.\n4. **Impact:** Increased transaction costs and potential denial-of-service for users with long interaction histories, reducing the efficiency and scalability of the contract.\n",
            "severity": "Low",
            "location": [
                "veVirtual.sol::withdraw#176"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "EIP712Upgradeable contract not initialized",
            "description": "1. **Description:** The veVirtual contract inherits from EIP712Upgradeable but fails to initialize it, leaving the name and version fields unset in the domain separator.\n2. **Cause:** The __EIP712_init() function is not called during contract initialization, resulting in incorrect or unpredictable domain separators.\n3. **Exploitation:** Off-chain signature verification tools may reject valid signatures because the computed domain separator does not match expectations, breaking meta-transaction functionality.\n4. **Impact:** This disrupts off-chain delegation and voting via signatures, impairing user experience and potentially preventing legitimate governance participation.\n",
            "severity": "Low",
            "location": [
                "EIP712Upgradeable.sol::__EIP712_init_unchained#72"
            ],
            "files": [
                "protocol-contracts/contracts/token/veVirtual.sol"
            ]
        }
    ],
    "affected_files": {
        "veVirtual.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/utils/VotesUpgradeable.sol\";\n\ncontract veVirtual is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    AccessControlUpgradeable,\n    VotesUpgradeable\n{\n    using SafeERC20 for IERC20;\n    struct Lock {\n        uint256 amount;\n        uint256 start;\n        uint256 end;\n        uint8 numWeeks; // Active duration in weeks. Reset to maxWeeks if autoRenew is true.\n        uint256 value;\n        bool autoRenew;\n    }\n\n    uint16 public constant DENOM = 10000;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public baseToken;\n    mapping(address => Lock[]) public locks;\n\n    uint8 public maxWeeks;\n\n    event Stake(address indexed user, uint256 amount, uint8 numWeeks);\n    event Withdraw(address indexed user, uint256 index, uint256 amount);\n\n    bool public adminUnlocked;\n\n    event AdminUnlocked(bool adminUnlocked);\n\n    function initialize(\n        address baseToken_,\n        uint8 maxWeeks_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __AccessControl_init();\n        __Votes_init();\n\n        require(baseToken_ != address(0), \"Invalid token\");\n        baseToken = baseToken_;\n        maxWeeks = maxWeeks_;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _grantRole(ADMIN_ROLE, _msgSender());\n    }\n\n    function numPositions(address account) public view returns (uint256) {\n        return locks[account].length;\n    }\n\n    function getPositions(\n        address account,\n        uint256 start,\n        uint256 count\n    ) public view returns (Lock[] memory) {\n        Lock[] memory results = new Lock[](count);\n        uint j = 0;\n        for (\n            uint i = start;\n            i < (start + count) && i < locks[account].length;\n            i++\n        ) {\n            results[j] = locks[account][i];\n            j++;\n        }\n        return results;\n    }\n\n    // Query balance at a specific timestamp\n    // If the timestamp is before the lock was created, it will return 0\n    // This does not work on withdrawn locks\n    function balanceOfAt(\n        address account,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        uint256 balance = 0;\n        for (uint i = 0; i < locks[account].length; i++) {\n            balance += _balanceOfLockAt(locks[account][i], timestamp);\n        }\n        return balance;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balanceOfAt(account, block.timestamp);\n    }\n\n    function balanceOfLock(\n        address account,\n        uint256 index\n    ) public view returns (uint256) {\n        return _balanceOfLock(locks[account][index]);\n    }\n\n    function _balanceOfLockAt(\n        Lock memory lock,\n        uint256 timestamp\n    ) internal pure returns (uint256) {\n        uint256 value = lock.value;\n        if (lock.autoRenew) {\n            return value;\n        }\n\n        if (timestamp < lock.start || timestamp >= lock.end) {\n            return 0;\n        }\n\n        uint256 duration = lock.end - lock.start;\n        uint256 elapsed = timestamp - lock.start;\n        uint256 decayRate = (value * DENOM) / duration;\n\n        return value - (elapsed * decayRate) / DENOM;\n    }\n\n    function _balanceOfLock(Lock memory lock) internal view returns (uint256) {\n        return _balanceOfLockAt(lock, block.timestamp);\n    }\n\n    function stake(\n        uint256 amount,\n        uint8 numWeeks,\n        bool autoRenew\n    ) external nonReentrant {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(numWeeks <= maxWeeks, \"Num weeks must be less than max weeks\");\n\n        IERC20(baseToken).safeTransferFrom(_msgSender(), address(this), amount);\n\n        if (autoRenew == true) {\n            numWeeks = maxWeeks;\n        }\n\n        uint multiplier = (uint(numWeeks) * DENOM) / uint(maxWeeks);\n        uint256 value = (amount * multiplier) / DENOM;\n\n        uint256 end = block.timestamp + uint256(numWeeks) * 1 weeks;\n\n        Lock memory lock = Lock({\n            amount: amount,\n            start: block.timestamp,\n            end: end,\n            numWeeks: numWeeks,\n            value: value,\n            autoRenew: autoRenew\n        });\n        locks[_msgSender()].push(lock);\n        emit Stake(_msgSender(), amount, numWeeks);\n        _transferVotingUnits(address(0), _msgSender(), amount);\n    }\n\n    function withdraw(uint256 index) external nonReentrant {\n        require(index < locks[_msgSender()].length, \"Invalid index\");\n        Lock memory lock = locks[_msgSender()][index];\n        require(\n            block.timestamp >= lock.end || adminUnlocked,\n            \"Lock is not expired\"\n        );\n\n        uint256 amount = lock.amount;\n\n        uint256 lastIndex = locks[_msgSender()].length - 1;\n        if (index != lastIndex) {\n            locks[_msgSender()][index] = locks[_msgSender()][lastIndex];\n        }\n        delete locks[_msgSender()][lastIndex];\n\n        IERC20(baseToken).safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), index, amount);\n        _transferVotingUnits(_msgSender(), address(0), amount);\n    }\n\n    function toggleAutoRenew(uint256 index) external nonReentrant {\n        require(index < locks[_msgSender()].length, \"Invalid index\");\n        Lock storage lock = locks[_msgSender()][index];\n        require(block.timestamp < lock.end, \"Lock is expired\");\n        lock.autoRenew = !lock.autoRenew;\n\n        if (lock.autoRenew) {\n            lock.numWeeks = maxWeeks;\n        }\n\n        lock.start = block.timestamp;\n        lock.end = block.timestamp + uint(lock.numWeeks) * 1 weeks;\n        uint multiplier = (uint(lock.numWeeks) * DENOM) / uint(maxWeeks);\n        lock.value = (lock.amount * multiplier) / DENOM;\n    }\n\n    function extend(uint256 index, uint8 numWeeks) external nonReentrant {\n        require(index < locks[_msgSender()].length, \"Invalid index\");\n        Lock storage lock = locks[_msgSender()][index];\n        require(lock.autoRenew == false, \"Lock is auto-renewing\");\n        require(block.timestamp < lock.end, \"Lock is expired\");\n        require(\n            (lock.numWeeks + numWeeks) <= maxWeeks,\n            \"Num weeks must be less than max weeks\"\n        );\n        uint256 newEnd = lock.end + uint256(numWeeks) * 1 weeks;\n\n        lock.numWeeks += numWeeks;\n        lock.end = newEnd;\n        uint multiplier = ((uint(newEnd) - lock.start) * DENOM) /\n            (uint(maxWeeks) * 1 weeks);\n        lock.value = (lock.amount * multiplier) / DENOM;\n    }\n\n    function setMaxWeeks(uint8 maxWeeks_) external onlyRole(ADMIN_ROLE) {\n        maxWeeks = maxWeeks_;\n    }\n\n    function getMaturity(\n        address account,\n        uint256 index\n    ) public view returns (uint256) {\n        Lock memory lock = locks[account][index];\n        if (!lock.autoRenew) {\n            return locks[account][index].end;\n        }\n\n        return block.timestamp + maxWeeks * 1 weeks;\n    }\n\n    function name() public pure returns (string memory) {\n        return \"veVIRTUAL\";\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"veVIRTUAL\";\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function setAdminUnlocked(\n        bool adminUnlocked_\n    ) external onlyRole(ADMIN_ROLE) {\n        adminUnlocked = adminUnlocked_;\n        emit AdminUnlocked(adminUnlocked);\n    }\n\n    function _getVotingUnits(\n        address account\n    ) internal view virtual override returns (uint256) {\n        return stakedAmountOf(account);\n    }\n\n    function stakedAmountOf(address account) public view returns (uint256) {\n        uint256 amount = 0;\n        for (uint i = 0; i < locks[account].length; i++) {\n            amount += locks[account][i].amount;\n        }\n        return amount;\n    }\n}\n"
    }
}