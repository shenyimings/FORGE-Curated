{
    "vfp_id": "vfp_00514",
    "project_name": "Parallel Protocol - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "A re-org may affect SideChainFeeCollector.sol/:release()",
            "description": "The release function in SideChainFeeCollector uses mutable storage variables destinationReceiver and bridgeableToken without passing them as parameters. If a reorg occurs, the transaction order could change such that release is executed before an update to these variables, causing funds to be sent to outdated or invalid addresses. The root cause is the reliance on storage state that can be modified in the same block. An attacker could potentially exploit chain reorganizations or frontrun updates to manipulate fund destinations. The impact includes loss of funds, incorrect token distribution, and reduced security of the fee release mechanism.\n",
            "severity": "Low",
            "location": [
                "SideChainFeeCollector.sol::release",
                "SideChainFeeCollector.sol::updateDestinationReceiver",
                "SideChainFeeCollector.sol::updateBridgeableToken"
            ],
            "files": [
                "cd3992aec0847063c2b979c51f6cac7dd2ff03bd/tokenomics/contracts/fees/SideChainFeeCollector.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "The SideChainFeeCollector does not work correctly when the fee token has decimals other than 18",
            "description": "The SideChainFeeCollector contract uses a fixed constant BRIDGEABLE_CONVERSION_DECIMALS = 1e12 to convert fee token amounts for bridging. This conversion logic assumes the fee token has 18 decimals. If the fee token has more than 18 decimals, precision will be lost during division, resulting in token loss. If the token has fewer than 18 decimals, the calculated bridgeable amount may be incorrect due to integer division truncation. The root cause is the hardcoded conversion factor that does not account for variable token decimals. An attacker could potentially exploit this by using a token with non-standard decimals to manipulate the bridged amount or cause miscalculations. The impact includes incorrect token transfers, loss of user funds, and unreliable fee collection and distribution across chains.\n",
            "severity": "Medium",
            "location": [
                "SideChainFeeCollector.sol#L21",
                "SideChainFeeCollector.sol#L129",
                "SideChainFeeCollector.sol::_calcBridgeableAmount"
            ],
            "files": [
                "cd3992aec0847063c2b979c51f6cac7dd2ff03bd/tokenomics/contracts/fees/SideChainFeeCollector.sol"
            ]
        }
    ],
    "affected_files": {
        "SideChainFeeCollector.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { OptionsBuilder } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport { SendParam, IOFT } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport { MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport { OFTMsgCodec } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\nimport { FeeCollectorCore, SafeERC20, IERC20 } from \"./FeeCollectorCore.sol\";\n\n/// @title SideChainFeeCollector\n/// @author Cooper Labs\n/// @custom:contact security@cooperlabs.xyz\n/// @notice Handles the transfer of fee tokens to the MainFeeDistributor on the receiving chain.\ncontract SideChainFeeCollector is FeeCollectorCore {\n    using SafeERC20 for IERC20;\n    using OptionsBuilder for bytes;\n\n    /// @notice BridgeableToken round down amount under the BRIDGEABLE_CONVERSION_DECIMALS\n    uint256 private constant BRIDGEABLE_CONVERSION_DECIMALS = 1e12;\n\n    //-------------------------------------------\n    // Storage\n    //-------------------------------------------\n    /// @notice token bridgeableToken contract\n    IOFT public bridgeableToken;\n\n    /// @notice LayerZero Eid value of the receiving chain\n    uint32 public lzEidReceiver;\n\n    /// @notice Address of the wallet that will receive the fees on the receiving chain.\n    address public destinationReceiver;\n\n    //-------------------------------------------\n    // Events\n    //-------------------------------------------\n\n    /// @notice Emitted when the fee token is released.\n    event FeeReleased(address caller, uint256 amountSent);\n\n    /// @notice Emitted when the destination receiver address is updated.\n    event DestinationReceiverUpdated(address newDestinationReceiver);\n\n    /// @notice Emitted when the bridgeable token is updated.\n    event BridgeableTokenUpdated(address newBridgeableToken);\n\n    //-------------------------------------------\n    // Constructor\n    //-------------------------------------------\n\n    ///@notice SideChainFeeCollector constructor.\n    ///@param _accessManager address of the AccessManager contract.\n    ///@param _lzEidReceiver LayerZero Eid value of the receiving chain.\n    ///@param _destinationReceiver address of the fee receiver on the destination chain.\n    ///@param _bridgeableToken address of the bridgeable token.\n    ///@param _feeToken address of the fee token.\n    constructor(\n        address _accessManager,\n        uint32 _lzEidReceiver,\n        address _bridgeableToken,\n        address _destinationReceiver,\n        address _feeToken\n    )\n        FeeCollectorCore(_accessManager, _feeToken)\n    {\n        destinationReceiver = _destinationReceiver;\n        bridgeableToken = IOFT(_bridgeableToken);\n        lzEidReceiver = _lzEidReceiver;\n    }\n\n    //-------------------------------------------\n    // AccessManaged functions\n    //-------------------------------------------\n\n    /// @notice Release the fee token to the MainFeeDistributor on the receiving chain.\n    /// @param _options Options to be passed to the bridgeable token.\n    /// @return amountSent The amount of fee token that has been bridged.\n    function release(bytes memory _options)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        restricted\n        returns (uint256 amountSent)\n    {\n        amountSent = _calcBridgeableAmount();\n        if (amountSent == 0) {\n            revert NothingToRelease();\n        }\n        SendParam memory sendParam = SendParam(\n            lzEidReceiver,\n            OFTMsgCodec.addressToBytes32(destinationReceiver),\n            amountSent,\n            amountSent,\n            _options,\n            abi.encode(true),\n            \"\"\n        );\n\n        feeToken.approve(address(bridgeableToken), amountSent);\n        emit FeeReleased(msg.sender, amountSent);\n        bridgeableToken.send{ value: msg.value }(sendParam, MessagingFee(msg.value, 0), payable(msg.sender));\n    }\n\n    /// @notice Update the destination receiver address.\n    /// @param _newDestinationReceiver The new destination receiver address.\n    function updateDestinationReceiver(address _newDestinationReceiver) external restricted {\n        destinationReceiver = _newDestinationReceiver;\n        emit DestinationReceiverUpdated(_newDestinationReceiver);\n    }\n\n    /// @notice Update the bridgeable token.\n    /// @param _newBridgeableToken The new bridgeable token address.\n    function updateBridgeableToken(address _newBridgeableToken) external restricted {\n        bridgeableToken = IOFT(_newBridgeableToken);\n        emit BridgeableTokenUpdated(_newBridgeableToken);\n    }\n\n    //-------------------------------------------\n    // Internal/Private functions\n    //-------------------------------------------\n\n    /// @notice Calculate the amount of fee token that can be bridged\n    /// @dev BridgeableToken contract remove dust under BRIDGEABLE_CONVERSION_DECIMALS\n    /// @return The amount of fee token that will be bridged\n    function _calcBridgeableAmount() private view returns (uint256) {\n        uint256 feeTokenBalance = feeToken.balanceOf(address(this));\n        return (feeTokenBalance / BRIDGEABLE_CONVERSION_DECIMALS) * BRIDGEABLE_CONVERSION_DECIMALS;\n    }\n}\n"
    }
}