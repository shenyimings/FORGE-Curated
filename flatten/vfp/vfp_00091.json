{
    "vfp_id": "vfp_00091",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Attacker can drain the entire suppliers on Morpho market by inflating collateral price",
            "description": "The AbstractYieldStrategy contract allows users to initiate a withdrawal without burning their shares, only escrowing them. This leads to a reduction in effectiveSupply() while keeping totalSupply() unchanged. An attacker can exploit this by initiating a large withdrawal, drastically reducing effectiveSupply(), and then donating a large amount of yield tokens to inflate the price() function's output.\n\nThe root cause lies in the price() calculation, which depends on effectiveSupply() and the yield token balance. Since effectiveSupply() can be reduced arbitrarily by initiating withdrawals, and the price is calculated as (yieldTokens * convertYieldTokenToAsset()) / effectiveSupply(), a low effectiveSupply() combined with a high yield token balance results in an extremely high price.\n\nThe attacker can then borrow a massive amount of assets from the Morpho market using this inflated price as collateral value. Since Morpho allows direct borrowing without going through the LendingRouter, the transient state checks are bypassed, making the attack feasible. After borrowing, the attacker can finalize their withdrawal and reclaim their original collateral.\n\nThe impact is catastrophic: the attacker can borrow nearly the entire supply of the loan asset from the Morpho market, leading to a complete loss of funds for all suppliers in that market. The only cost to the attacker is the donated yield tokens, which is negligible compared to the borrowed amount.\n",
            "severity": "High",
            "location": [
                "src/AbstractYieldStrategy.sol::initiateWithdraw#280-307",
                "src/AbstractYieldStrategy.sol::convertToAssets",
                "src/AbstractYieldStrategy.sol::convertSharesToYieldToken",
                "src/AbstractYieldStrategy.sol::price"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/AbstractYieldStrategy.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "When users borrow directly from Morpho price of the collateral will not be accurate",
            "description": "The vulnerability arises because the Morpho price oracle prices withdrawal requests based on the requested value when going through the lending router, but when users borrow directly from Morpho, the pricing falls back to the raw share value via super.convertToAssets(shares), which does not account for active withdrawal requests. The root cause is the reliance on the t_currentAccount variable being set only by the lending router, leading to inconsistent pricing logic. An attacker can exploit this by initiating a withdrawal request and then borrowing directly from Morpho without using the lending router, causing the oracle to misprice their collateral. This results in incorrect collateral valuation, potentially allowing over-borrowing or under-collateralized positions, which threatens protocol solvency.\n",
            "severity": "High",
            "location": [
                "AbstractYieldStrategy.sol#L118-L120",
                "AbstractSingleSidedLP.sol#L300-L303"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/AbstractYieldStrategy.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Setup with asset = WETH and a Curve pool that contains Native ETH will lead to a loss for the users",
            "description": "When a yield strategy uses WETH as its asset and a Curve pool containing Native ETH (e.g., ETH/wstETH), the protocol incorrectly handles token addresses by mapping Native ETH (0xEeeee...) to address(0). This causes the _PRIMARY_INDEX to point to Native ETH, leading to incorrect trade execution during proportional exits.\n\nThe root cause is improper handling of Native ETH in token comparisons and trade routing logic, particularly in _executeRedemptionTrades, where the vault attempts to sell Native ETH it no longer holds (after wrapping to WETH).\n\nDuring withdrawal initiation, the vault wraps all ETH to WETH, leaving zero Native ETH balance. However, the trade logic still tries to sell Native ETH, causing a revert due to insufficient balance.\n\nUsers cannot initiate withdrawals, and during liquidation or position exit, they are forced into single-sided exits on Curve, which incur higher slippage and asset loss when the pool is imbalanced.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::_PRIMARY_INDEX#59",
                "AbstractSingleSidedLP.sol::_executeRedemptionTrades#223",
                "CurveConvex2Token.sol::unstakeAndExitPool#207"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unable to support Curve Pool with Native ETH",
            "description": "When a Curve pool includes Native ETH, the _rewriteAltETH() function converts its address to 0x00000000. Later, during withdrawal or liquidation, the protocol attempts to fetch a Withdraw Request Manager (WRM) for this zero address via ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i])).\n\nThe root cause is the assumption that all tokens have a corresponding WRM, without validating whether the token is a standard ERC20 or Native ETH (which has no WRM).\n\nAny operation that loops through tokens to check pending withdrawals or finalize them (e.g., getWithdrawRequestValue, hasPendingWithdrawals) will revert when encountering Native ETH.\n\nThis breaks core functionality for pools with Native ETH, potentially bricking user accounts by making withdrawals and liquidations impossible, leading to permanently stuck funds.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::_rewriteAltETH#54",
                "AbstractSingleSidedLP.sol::getWithdrawRequestValue#326",
                "AbstractSingleSidedLP.sol::hasPendingWithdrawals#338"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Convex cannot be configured for the Yield Strategy vault in Arbitrum even though Convex is available in Arbitrum",
            "description": "The constructor of CurveConvex2Token checks if block.chainid == CHAIN_ID_MAINNET before configuring the Convex booster and pool ID. This condition prevents the configuration of Convex on Arbitrum, even though Convex is deployed and functional there.\n\nThe root cause is a hardcoded chain ID check that excludes Arbitrum from Convex integration, despite it being in scope per the contest README.\n\nAs a result, yield strategies on Arbitrum cannot leverage Convex staking, limiting yield potential and rendering the Convex integration unusable on that chain.\n\nThis breaks intended cross-chain functionality and reduces capital efficiency for Arbitrum users.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol::constructor#137"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "migrateRewardPool Fails Due to Incompatible Storage Design in CurveConvexLib",
            "description": "The migrateRewardPool function in AbstractRewardManager is designed to migrate rewards from an old to a new Convex reward pool by updating internal storage and using delegatecall. However, the function fails in practice because CurveConvexLib, used by CurveConvex2Token, stores the reward pool address as immutable. As a result, even if the reward manager updates its state, newly minted LP tokens continue to deposit into the old reward pool. The root cause is the incompatibility between the mutable storage assumption in AbstractRewardManager and the immutable design of CurveConvexLib. There is no direct attack path, but if Convex deprecates a reward pool, the protocol cannot migrate, breaking expected functionality. This violates the IRewardManager interface specification, which requires support for reward pool changes.\n",
            "severity": "High",
            "location": [
                "AbstractRewardManager.sol#L44-L65",
                "IRewardManager.sol#L82-L86"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/rewards/AbstractRewardManager.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/interfaces/IRewardManager.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Hardcoded useEth = true in remove_liquidity_one_coin or remove_liquidity lead to stuck fund",
            "description": "The vulnerability arises when exiting a Curve V2 pool via the _exitPool function in single-sided strategies, where the useEth parameter is hardcoded to true during remove_liquidity_one_coin and remove_liquidity calls. This causes the Curve pool to return native ETH instead of WETH. However, the protocol expects WETH, and the subsequent logic in unstakeAndExitPool fails to wrap the received native ETH back into WETH because it only checks if TOKEN_1 or TOKEN_2 is ETH_ADDRESS (0x0), which is false when dealing with WETH. The root cause is the hardcoded useEth = true regardless of the actual token configuration. An attacker cannot directly exploit this, but any user action triggering an exit will leave native ETH in the vault. The impact is severe: the vault becomes desynchronized from its expected asset (WETH), leading to incorrect balance accounting and potential loss of user funds during withdrawals, as _burnShares measures WETH balance changes and returns zero if only native ETH is present.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::add_liquidity#236-238",
                "CurveConvex2Token.sol::remove_liquidity_one_coin#255-258",
                "CurveConvex2Token.sol::remove_liquidity#281-283",
                "CurveConvex2Token.sol::unstakeAndExitPool#205-211",
                "AbstractYieldStrategy.sol::_burnShares#416-433"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/CurveConvex2Token.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/AbstractYieldStrategy.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Minting yield tokens single sided can be impossible if CURVE_V2 dexId is used on redemptions",
            "description": "In single-sided yield strategies, the strategy contract grants infinite allowance to the Curve pool for both underlying tokens upon deployment. However, when a user withdraws and chooses CURVE_V2 as the dexId to swap one of the underlying tokens back to the asset token, the TRADING_MODULE revokes the allowance of the sellToken (which is the asset token) after the swap.\n\nThe root cause is that the trading module revokes token allowances for security after swaps, but does not account for the fact that the strategy itself depends on those allowances to continue depositing into the yield pool. If the swap uses the same pool the strategy is LP'ing into, the allowance revocation breaks future deposits.\n\nAn attacker can exploit this by withdrawing double-sided and selecting the same Curve pool via CURVE_V2 to swap one token to the other, triggering the allowance revocation. This can be done repeatedly to permanently block deposits.\n\nThe impact is that the strategy becomes permanently unusable for new deposits, as it loses the required token allowance to mint LP tokens, effectively bricking the strategy.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol::constructor#169-178",
                "AbstractSingleSidedLP.sol::withdrawDoubleSided#163-178",
                "TradingUtils.sol::executeTrade#54-57",
                "CurveV2Adapter.sol::swap#42-63"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Emission rewards accrue when yield strategy is empty due to virtual shares",
            "description": "The vulnerability occurs in the AbstractRewardManager and AbstractYieldStrategy contracts, where emission rewards continue to accrue even when there are no real depositors in a yield strategy. The root cause is the assumption that effectiveSupply can reach zero to halt reward accrual, but due to the use of VIRTUAL_SHARES (a non-zero minimum), effectiveSupply never reaches zero. This leads to the rewardPerToken accumulator continuing to increase unnecessarily. The issue is triggered naturally whenever a strategy has no real deposits but still holds virtual shares. The impact is that reward distribution logic remains active when it should be paused, leading to incorrect state accumulation and potential future miscalculations or unfair reward distribution when users eventually join. This breaks the intended economic model and wastes protocol resources.\n",
            "severity": "Medium",
            "location": [
                "AbstractRewardManager.sol#L298",
                "AbstractYieldStrategy.sol#L149-L151"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/AbstractYieldStrategy.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/rewards/AbstractRewardManager.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Incorrect ETH/WETH comparison causes DoS in CurveConvexStrategy exit",
            "description": "The vulnerability exists in the CurveConvexStrategy's _executeRedemptionTrades function, where a strict address comparison fails to recognize that ETH and WETH are economically equivalent. The root cause is the use of direct address equality (tokens[i] == asset) without considering that ETH is automatically wrapped into WETH during the exit process. When the strategy asset is WETH and one of the pool tokens is ETH, the function incorrectly attempts to trade ETH to WETH, using invalid trade parameters. This leads to a revert during redemption, preventing users from exiting their positions. The impact is a denial of service that can lock user funds in the vault, especially affecting users redeeming shares when the pool contains ETH. This breaks a fundamental user expectation of liquidity and exitability.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol#L205",
                "AbstractSingleSidedLP.sol#L176",
                "AbstractSingleSidedLP.sol#L229"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Users cannot claim rewards when LP tokens are staked directly to Curve Gauge",
            "description": "The vulnerability is in the AbstractRewardManager's _claimVaultRewards function, which fails to handle the case where LP tokens are staked directly to a Curve Gauge without using Convex Booster. The root cause is a conditional check that returns early if rewardPool is address(0), which is the case when staking directly to Gauge. This short-circuits the reward claim process, preventing any rewards from being distributed. The impact is that users who have their LP tokens staked in Curve Gauges are unable to claim their earned rewards, leading to loss of expected yield and reduced protocol trust. This affects all users in strategies that bypass Convex and stake directly to Gauges, effectively locking their rewards indefinitely unless the contract is upgraded.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol#L291-L298",
                "AbstractRewardManager.sol#L190"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/rewards/AbstractRewardManager.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Loss of reward tokens during initiating withdrawal due to cooldown",
            "description": "When a user initiates a withdrawal, the protocol skips claiming rewards from external protocols if the reward pool is in cooldown. However, the accumulatedRewardPerVaultShare is updated based only on claimed rewards, leading to an outdated state when calculating user rewards.\n\nThe root cause is that _claimVaultRewards in AbstractRewardManager.sol skips external reward claims during cooldown periods, even though this is the last chance for the withdrawing user to claim their entitled rewards. Since effectiveSupply changes after withdrawal initiation, future reward accruals will be based on a different total supply, but the user's final reward is calculated before the supply change using incomplete data.\n\nFor example, if 10 WETH has accrued but only 5 were claimed before withdrawal due to cooldown, the user receives rewards based on 5 WETH instead of 10. The remaining unclaimed rewards are distributed to remaining stakers, effectively redistributing the withdrawing user's share.\n\nThe impact is high, as users initiating withdrawals lose a portion of their earned reward tokens, resulting in direct financial loss.\n",
            "severity": "High",
            "location": [
                "AbstractRewardManager.sol::updateAccountRewards#159",
                "AbstractRewardManager.sol::claimVaultRewards#159",
                "RewardManagerMixin.sol::_initiateWithdraw#131"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/rewards/AbstractRewardManager.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Users will be unfairly liquidated if collateral value drops after initiating withdraw request",
            "description": "After a user initiates a withdrawal request, they are blocked from minting new shares, which also prevents them from depositing additional collateral to avoid liquidation. This occurs because _isWithdrawRequestPending reverts minting if a withdrawal is pending.\n\nThe root cause is the design decision to lock the account from further minting once a withdrawal is initiated, without allowing separate collateral top-ups. While the position remains active and subject to market fluctuations, the user cannot adjust their collateralization ratio during the cooldown period (e.g., 7 days for sUSDe).\n\nIf the value of the collateral drops during this period, the user’s position may become undercollateralized and subject to liquidation. Unlike standard leveraged systems, the user cannot “top up” their margin to avoid this, leading to forced liquidation and loss of funds.\n\nThe impact is high, as users risk losing a portion of their assets to liquidators despite being willing and able to maintain their position, resulting in unfair economic loss.\n",
            "severity": "High",
            "location": [
                "AbstractYieldStrategy.sol::mintShares#197",
                "AbstractYieldStrategy.sol::_isWithdrawRequestPending#197"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/notional-v4/src/AbstractYieldStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "CurveConvex2Token.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {IWithdrawRequestManager} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {AbstractSingleSidedLP, BaseLPLib} from \"./AbstractSingleSidedLP.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {ETH_ADDRESS, ALT_ETH_ADDRESS, WETH, CHAIN_ID_MAINNET} from \"../utils/Constants.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/Curve/ICurve.sol\";\nimport \"../interfaces/Curve/IConvex.sol\";\n\nstruct DeploymentParams {\n    address pool;\n    address poolToken;\n    address gauge;\n    address convexRewardPool;\n    CurveInterface curveInterface;\n}\n\ncontract CurveConvex2Token is AbstractSingleSidedLP {\n\n    uint256 internal constant _NUM_TOKENS = 2;\n\n    ERC20 internal immutable CURVE_POOL_TOKEN;\n    uint8 internal immutable _PRIMARY_INDEX;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n\n    function NUM_TOKENS() internal pure override returns (uint256) { return _NUM_TOKENS; }\n    function PRIMARY_INDEX() internal view override returns (uint256) { return _PRIMARY_INDEX; }\n    function TOKENS() internal view override returns (ERC20[] memory) {\n        ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n        tokens[0] = ERC20(TOKEN_1);\n        tokens[1] = ERC20(TOKEN_2);\n        return tokens;\n    }\n\n    constructor(\n        uint256 _maxPoolShare,\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        DeploymentParams memory params,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) AbstractSingleSidedLP(_maxPoolShare, _asset, _yieldToken, _feeRate, _rewardManager, 18, _withdrawRequestManager) {\n        CURVE_POOL_TOKEN = ERC20(params.poolToken);\n\n        // We interact with curve pools directly so we never pass the token addresses back\n        // to the curve pools. The amounts are passed back based on indexes instead. Therefore\n        // we can rewrite the token addresses from ALT Eth (0xeeee...) back to (0x0000...) which\n        // is used by the vault internally to represent ETH.\n        TOKEN_1 = _rewriteAltETH(ICurvePool(params.pool).coins(0));\n        TOKEN_2 = _rewriteAltETH(ICurvePool(params.pool).coins(1));\n\n        // Assets may be WETH, so we need to unwrap it in this case.\n        _PRIMARY_INDEX =\n            (TOKEN_1 == _asset || (TOKEN_1 == ETH_ADDRESS && _asset == address(WETH))) ? 0 :\n            (TOKEN_2 == _asset || (TOKEN_2 == ETH_ADDRESS && _asset == address(WETH))) ? 1 :\n            // Otherwise the primary index is not set and we will not be able to enter or exit\n            // single sided.\n            type(uint8).max;\n\n        LP_LIB = address(new CurveConvexLib(TOKEN_1, TOKEN_2, _asset, _PRIMARY_INDEX, params));\n    }\n\n    function _rewriteAltETH(address token) private pure returns (address) {\n        return token == address(ALT_ETH_ADDRESS) ? ETH_ADDRESS : address(token);\n    }\n\n    function _transferYieldTokenToOwner(address owner, uint256 yieldTokens) internal override {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(\n            CurveConvexLib.transferYieldTokenToOwner.selector, owner, yieldTokens)\n        );\n    }\n\n    function _totalPoolSupply() internal view override returns (uint256) {\n        return CURVE_POOL_TOKEN.totalSupply();\n    }\n\n    function _checkReentrancyContext() internal override {\n        CurveConvexLib(payable(LP_LIB)).checkReentrancyContext();\n    }\n}\n\ncontract CurveConvexLib is BaseLPLib {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    uint256 internal constant _NUM_TOKENS = 2;\n\n    address internal immutable CURVE_POOL;\n    ERC20 internal immutable CURVE_POOL_TOKEN;\n\n    /// @dev Curve gauge contract used when there is no convex reward pool\n    address internal immutable CURVE_GAUGE;\n    /// @dev Convex booster contract used for staking BPT\n    address internal immutable CONVEX_BOOSTER;\n    /// @dev Convex reward pool contract used for unstaking and claiming reward tokens\n    address internal immutable CONVEX_REWARD_POOL;\n    uint256 internal immutable CONVEX_POOL_ID;\n\n    uint8 internal immutable _PRIMARY_INDEX;\n    address internal immutable ASSET;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n    CurveInterface internal immutable CURVE_INTERFACE;\n\n    // Payable is required for the CurveV1 interface which will execute a transfer\n    // when the remove_liquidity function is called, it only will be done to this contract\n    // during the checkReentrancyContext function.\n    receive() external payable {}\n\n    constructor(\n        address _token1,\n        address _token2,\n        address _asset,\n        uint8 _primaryIndex,\n        DeploymentParams memory params\n    ) {\n        TOKEN_1 = _token1;\n        TOKEN_2 = _token2;\n        ASSET = _asset;\n        _PRIMARY_INDEX = _primaryIndex;\n\n        CURVE_POOL = params.pool;\n        CURVE_GAUGE = params.gauge;\n        CURVE_POOL_TOKEN = ERC20(params.poolToken);\n        CURVE_INTERFACE = params.curveInterface;\n\n        // If the convex reward pool is set then get the booster and pool id, if not then\n        // we will stake on the curve gauge directly.\n        CONVEX_REWARD_POOL = params.convexRewardPool;\n        address convexBooster;\n        uint256 poolId;\n        if (block.chainid == CHAIN_ID_MAINNET && CONVEX_REWARD_POOL != address(0)) {\n            convexBooster = IConvexRewardPool(CONVEX_REWARD_POOL).operator();\n            poolId = IConvexRewardPool(CONVEX_REWARD_POOL).pid();\n        }\n\n        CONVEX_POOL_ID = poolId;\n        CONVEX_BOOSTER = convexBooster;\n    }\n\n    function checkReentrancyContext() external {\n        uint256[2] memory minAmounts;\n        if (CURVE_INTERFACE == CurveInterface.V1) {\n            ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity(0, minAmounts);\n        } else if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n            // Total supply on stable swap has a non-reentrant lock\n            ICurveStableSwapNG(CURVE_POOL).totalSupply();\n        } else if (CURVE_INTERFACE == CurveInterface.V2) {\n            // Curve V2 does a `-1` on the liquidity amount so set the amount removed to 1 to\n            // avoid an underflow.\n            ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(1, minAmounts, true, address(this));\n        } else {\n            revert();\n        }\n    }\n\n    function TOKENS() internal view override returns (ERC20[] memory) {\n        ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n        tokens[0] = ERC20(TOKEN_1);\n        tokens[1] = ERC20(TOKEN_2);\n        return tokens;\n    }\n\n    function initialApproveTokens() external {\n        // If either token is ETH_ADDRESS the check approve will short circuit\n        ERC20(TOKEN_1).checkApprove(address(CURVE_POOL), type(uint256).max);\n        ERC20(TOKEN_2).checkApprove(address(CURVE_POOL), type(uint256).max);\n        if (CONVEX_BOOSTER != address(0)) {\n            CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n        } else {\n            CURVE_POOL_TOKEN.checkApprove(address(CURVE_GAUGE), type(uint256).max);\n        }\n    }\n\n    function joinPoolAndStake(\n        uint256[] memory _amounts, uint256 minPoolClaim\n    ) external {\n        // Although Curve uses ALT_ETH to represent native ETH, it is rewritten in the Curve2TokenPoolMixin\n        // to the Deployments.ETH_ADDRESS which we use internally.\n        uint256 msgValue;\n        if (TOKEN_1 == ETH_ADDRESS) {\n            msgValue = _amounts[0];\n        } else if (TOKEN_2 == ETH_ADDRESS) {\n            msgValue = _amounts[1];\n        }\n        if (msgValue > 0) WETH.withdraw(msgValue);\n\n        uint256 lpTokens = _enterPool(_amounts, minPoolClaim, msgValue);\n\n        _stakeLpTokens(lpTokens);\n    }\n\n    function unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) external returns (uint256[] memory exitBalances) {\n        _unstakeLpTokens(poolClaim);\n\n        exitBalances = _exitPool(poolClaim, _minAmounts, isSingleSided);\n\n        if (ASSET == address(WETH)) {\n            if (TOKEN_1 == ETH_ADDRESS) {\n                WETH.deposit{value: exitBalances[0]}();\n            } else if (TOKEN_2 == ETH_ADDRESS) {\n                WETH.deposit{value: exitBalances[1]}();\n            }\n        }\n    }\n\n    function transferYieldTokenToOwner(address owner, uint256 yieldTokens) external {\n        _unstakeLpTokens(yieldTokens);\n        CURVE_POOL_TOKEN.safeTransfer(owner, yieldTokens);\n    }\n\n    function _enterPool(\n        uint256[] memory _amounts, uint256 minPoolClaim, uint256 msgValue\n    ) internal returns (uint256) {\n        if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n            return ICurveStableSwapNG(CURVE_POOL).add_liquidity{value: msgValue}(\n                _amounts, minPoolClaim\n            );\n        } \n\n        uint256[2] memory amounts;\n        amounts[0] = _amounts[0];\n        amounts[1] = _amounts[1];\n        if (CURVE_INTERFACE == CurveInterface.V1) {\n            return ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim\n            );\n        } else if (CURVE_INTERFACE == CurveInterface.V2) {\n            return ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n            );\n        }\n\n        revert();\n    }\n\n    function _exitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) internal returns (uint256[] memory exitBalances) {\n        if (isSingleSided) {\n            exitBalances = new uint256[](_NUM_TOKENS);\n            if (CURVE_INTERFACE == CurveInterface.V1 || CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n                // Method signature is the same for v1 and stable swap ng\n                exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity_one_coin(\n                    poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n                );\n            } else {\n                exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity_one_coin(\n                    // Last two parameters are useEth = true and receiver = this contract\n                    poolClaim, _PRIMARY_INDEX, _minAmounts[_PRIMARY_INDEX], true, address(this)\n                );\n            }\n        } else {\n            // Two sided exit\n            if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n                return ICurveStableSwapNG(CURVE_POOL).remove_liquidity(poolClaim, _minAmounts);\n            }\n            \n            // Redeem proportionally, min amounts are rewritten to a fixed length array\n            uint256[2] memory minAmounts;\n            minAmounts[0] = _minAmounts[0];\n            minAmounts[1] = _minAmounts[1];\n\n            exitBalances = new uint256[](_NUM_TOKENS);\n            if (CURVE_INTERFACE == CurveInterface.V1) {\n                uint256[2] memory _exitBalances = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity(poolClaim, minAmounts);\n                exitBalances[0] = _exitBalances[0];\n                exitBalances[1] = _exitBalances[1];\n            } else {\n                exitBalances[0] = TokenUtils.tokenBalance(TOKEN_1);\n                exitBalances[1] = TokenUtils.tokenBalance(TOKEN_2);\n                // Remove liquidity on CurveV2 does not return the exit amounts so we have to measure\n                // them before and after.\n                ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(\n                    // Last two parameters are useEth = true and receiver = this contract\n                    poolClaim, minAmounts, true, address(this)\n                );\n                exitBalances[0] = TokenUtils.tokenBalance(TOKEN_1) - exitBalances[0];\n                exitBalances[1] = TokenUtils.tokenBalance(TOKEN_2) - exitBalances[1];\n            }\n        }\n    }\n\n    function _stakeLpTokens(uint256 lpTokens) internal {\n        if (CONVEX_BOOSTER != address(0)) {\n            bool success = IConvexBooster(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens, true);\n            require(success);\n        } else {\n            ICurveGauge(CURVE_GAUGE).deposit(lpTokens);\n        }\n    }\n\n\n    function _unstakeLpTokens(uint256 poolClaim) internal {\n        if (CONVEX_REWARD_POOL != address(0)) {\n            bool success = IConvexRewardPool(CONVEX_REWARD_POOL).withdrawAndUnwrap(poolClaim, false);\n            require(success);\n        } else {\n            ICurveGauge(CURVE_GAUGE).withdraw(poolClaim);\n        }\n    }\n\n}",
        "AbstractRewardManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ReentrancyGuardTransient} from \"@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IRewardManager.sol\";\nimport {IYieldStrategy} from \"../interfaces/IYieldStrategy.sol\";\nimport {Unauthorized} from \"../interfaces/Errors.sol\";\nimport {DEFAULT_PRECISION, ADDRESS_REGISTRY, YEAR} from \"../utils/Constants.sol\";\nimport {TypeConvert} from \"../utils/TypeConvert.sol\";\nimport {IEIP20NonStandard} from \"../interfaces/IEIP20NonStandard.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\n\nabstract contract AbstractRewardManager is IRewardManager, ReentrancyGuardTransient {\n    using TypeConvert for uint256;\n    using TokenUtils for ERC20;\n\n    modifier onlyUpgradeAdmin() {\n        if (msg.sender != ADDRESS_REGISTRY.upgradeAdmin()) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    // Uses custom storage slots to avoid collisions with other contracts\n    uint256 private constant REWARD_POOL_SLOT = 1000001;\n    uint256 private constant VAULT_REWARD_STATE_SLOT = 1000002;\n    uint256 private constant ACCOUNT_REWARD_DEBT_SLOT = 1000003;\n    uint256 private constant ACCOUNT_ESCROW_STATE_SLOT = 1000004;\n\n    function _getRewardPoolSlot() internal pure returns (RewardPoolStorage storage store) {\n        assembly { store.slot := REWARD_POOL_SLOT }\n    }\n\n    function _getVaultRewardStateSlot() internal pure returns (VaultRewardState[] storage store) {\n        assembly { store.slot := VAULT_REWARD_STATE_SLOT }\n    }\n\n    function _getAccountRewardDebtSlot() internal pure returns (\n        mapping(address account => mapping(address rewardToken => uint256 rewardDebt)) storage store\n    ) {\n        assembly { store.slot := ACCOUNT_REWARD_DEBT_SLOT }\n    }\n\n    /// @inheritdoc IRewardManager\n    function migrateRewardPool(address poolToken, RewardPoolStorage memory newRewardPool) external override onlyUpgradeAdmin nonReentrant {\n        // Claim all rewards from the previous reward pool before withdrawing\n        uint256 effectiveSupplyBefore = IYieldStrategy(address(this)).effectiveSupply();\n        _claimVaultRewards(effectiveSupplyBefore, _getVaultRewardStateSlot());\n        RewardPoolStorage memory oldRewardPool = _getRewardPoolSlot();\n\n        if (oldRewardPool.rewardPool != address(0)) {\n            _withdrawFromPreviousRewardPool(oldRewardPool);\n\n            // Clear approvals on the old pool.\n            ERC20(poolToken).checkRevoke(address(oldRewardPool.rewardPool));\n        }\n\n        uint256 poolTokens = ERC20(poolToken).balanceOf(address(this));\n        _depositIntoNewRewardPool(poolToken, poolTokens, newRewardPool);\n\n        // Set the last claim timestamp to the current block timestamp since we re claiming all the rewards\n        // earlier in this method.\n        _getRewardPoolSlot().lastClaimTimestamp = uint32(block.timestamp);\n        _getRewardPoolSlot().rewardPool = newRewardPool.rewardPool;\n        _getRewardPoolSlot().forceClaimAfter = newRewardPool.forceClaimAfter;\n    }\n\n\n    /// @inheritdoc IRewardManager\n    function getRewardSettings() external view override returns (\n        VaultRewardState[] memory rewardStates,\n        RewardPoolStorage memory rewardPool\n    ) {\n        rewardStates = _getVaultRewardStateSlot();\n        rewardPool = _getRewardPoolSlot();\n    }\n\n    /// @inheritdoc IRewardManager\n    function getRewardDebt(address rewardToken, address account) external view override returns (uint256) {\n        return _getAccountRewardDebtSlot()[rewardToken][account];\n    }\n\n    /// @inheritdoc IRewardManager\n    function updateRewardToken(\n        uint256 index,\n        address rewardToken,\n        uint128 emissionRatePerYear,\n        uint32 endTime\n    ) external override onlyUpgradeAdmin {\n        uint256 effectiveSupplyBefore = IYieldStrategy(address(this)).effectiveSupply();\n        uint256 numRewardStates = _getVaultRewardStateSlot().length;\n\n        if (index < numRewardStates) {\n            VaultRewardState memory state = _getVaultRewardStateSlot()[index];\n            // Safety check to ensure that the correct token is specified, we can never change the\n            // token address once set.\n            require(state.rewardToken == rewardToken);\n            // Modifies the emission rate on an existing token, direct claims of the token will\n            // not be affected by the emission rate.\n            // First accumulate under the old regime up to the current time. Even if the previous\n            // emissionRatePerYear is zero this will still set the lastAccumulatedTime to the current\n            // blockTime.\n            _accumulateSecondaryRewardViaEmissionRate(index, state, effectiveSupplyBefore);\n\n            // Save the new emission rates\n            state.emissionRatePerYear = emissionRatePerYear;\n            if (state.emissionRatePerYear == 0) {\n                state.endTime = 0;\n            } else {\n                require(block.timestamp < endTime);\n                state.endTime = endTime;\n            }\n            _getVaultRewardStateSlot()[index] = state;\n        } else if (index == numRewardStates) {\n            // This sets a new reward token, ensure that the current slot is empty\n            VaultRewardState[] storage states = _getVaultRewardStateSlot();\n            // If no emission rate is set then governance is just adding a token that can be claimed\n            // via the LP tokens without an emission rate. These settings will be left empty and the\n            // subsequent _claimVaultRewards method will set the initial accumulatedRewardPerVaultShare.\n            if (0 < emissionRatePerYear) require(block.timestamp < endTime);\n\n            states.push(VaultRewardState({\n                rewardToken: rewardToken,\n                lastAccumulatedTime: uint32(block.timestamp),\n                endTime: endTime,\n                emissionRatePerYear: emissionRatePerYear,\n                accumulatedRewardPerVaultShare: 0\n            }));\n        } else {\n            // Can only append or modify existing tokens\n            revert();\n        }\n\n        // Claim all vault rewards up to the current time\n        _claimVaultRewards(effectiveSupplyBefore, _getVaultRewardStateSlot());\n        emit VaultRewardUpdate(rewardToken, emissionRatePerYear, endTime);\n    }\n\n    /// @notice Claims all the rewards for the entire vault and updates the accumulators. Does not\n    /// update emission rewarders since those are automatically updated on every account claim.\n    function claimRewardTokens() external nonReentrant {\n        // This method is not executed from inside enter or exit vault positions, so this total\n        // vault shares value is valid.\n        uint256 effectiveSupplyBefore = IYieldStrategy(address(this)).effectiveSupply();\n        _claimVaultRewards(effectiveSupplyBefore, _getVaultRewardStateSlot());\n    }\n\n    /// @inheritdoc IRewardManager\n    function updateAccountRewards(\n        address account,\n        uint256 effectiveSupplyBefore,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        bool sharesInEscrow\n    ) external returns (uint256[] memory rewards) {\n        // Short circuit in this case, no rewards to claim\n        if (sharesInEscrow && accountSharesAfter > 0) return rewards;\n\n        VaultRewardState[] memory state = _getVaultRewardStateSlot();\n        _claimVaultRewards(effectiveSupplyBefore, state);\n        rewards = new uint256[](state.length);\n\n        for (uint256 i; i < state.length; i++) {\n            if (sharesInEscrow && accountSharesAfter == 0) {\n                delete _getAccountRewardDebtSlot()[state[i].rewardToken][account];\n                continue;\n            }\n\n            if (0 < state[i].emissionRatePerYear) {\n                // Accumulate any rewards with an emission rate here\n                _accumulateSecondaryRewardViaEmissionRate(i, state[i], effectiveSupplyBefore);\n            }\n\n            rewards[i] = _claimRewardToken(\n                state[i].rewardToken,\n                account,\n                accountSharesBefore,\n                accountSharesAfter,\n                state[i].accumulatedRewardPerVaultShare\n            );\n        }\n    }\n\n    /// @notice Executes a claim against the given reward pool type and updates internal\n    /// rewarder accumulators.\n    function _claimVaultRewards(\n        uint256 effectiveSupplyBefore,\n        VaultRewardState[] memory state\n    ) internal {\n        RewardPoolStorage memory rewardPool = _getRewardPoolSlot();\n        if (rewardPool.rewardPool == address(0)) return;\n        if (block.timestamp < rewardPool.lastClaimTimestamp + rewardPool.forceClaimAfter) return;\n\n        uint256[] memory balancesBefore = new uint256[](state.length);\n        // Run a generic call against the reward pool and then do a balance\n        // before and after check.\n        for (uint256 i; i < state.length; i++) {\n            // Presumes that ETH will never be given out as a reward token.\n            balancesBefore[i] = ERC20(state[i].rewardToken).balanceOf(address(this));\n        }\n\n        _executeClaim();\n\n        _getRewardPoolSlot().lastClaimTimestamp = uint32(block.timestamp);\n\n        // This only accumulates rewards claimed, it does not accumulate any secondary emissions\n        // that are streamed to vault users.\n        for (uint256 i; i < state.length; i++) {\n            uint256 balanceAfter = ERC20(state[i].rewardToken).balanceOf(address(this));\n            _accumulateSecondaryRewardViaClaim(\n                i,\n                state[i],\n                // balanceAfter should never be less than balanceBefore\n                balanceAfter - balancesBefore[i],\n                effectiveSupplyBefore\n            );\n        }\n    }\n\n\n    /** Reward Claim Methods **/\n\n    function _claimRewardToken(\n        address rewardToken,\n        address account,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        uint256 rewardsPerVaultShare\n    ) internal returns (uint256 rewardToClaim) {\n        // Vault shares are always in DEFAULT_PRECISION\n        uint256 rewardDebt = _getAccountRewardDebtSlot()[rewardToken][account];\n        rewardToClaim = ((accountSharesBefore * rewardsPerVaultShare) / DEFAULT_PRECISION) - rewardDebt;\n        _getAccountRewardDebtSlot()[rewardToken][account] = (\n            (accountSharesAfter * rewardsPerVaultShare) / DEFAULT_PRECISION\n        );\n\n        if (0 < rewardToClaim) {\n            // Ignore transfer errors here so that any strange failures here do not\n            // prevent normal vault operations from working. Failures may include a\n            // lack of balances or some sort of blacklist that prevents an account\n            // from receiving tokens.\n            if (rewardToken.code.length > 0) {\n                try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n                    bool success = TokenUtils.checkReturnCode();\n                    if (success) {\n                        emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n                    } else {\n                        emit VaultRewardTransfer(rewardToken, account, 0);\n                    }\n                // Emits zero tokens transferred if the transfer fails.\n                } catch {\n                    emit VaultRewardTransfer(rewardToken, account, 0);\n                }\n            }\n        }\n    }\n\n    /*** ACCUMULATORS  ***/\n\n    function _accumulateSecondaryRewardViaClaim(\n        uint256 index,\n        VaultRewardState memory state,\n        uint256 tokensClaimed,\n        uint256 effectiveSupplyBefore\n    ) private {\n        if (tokensClaimed == 0) return;\n\n        state.accumulatedRewardPerVaultShare += (\n            (tokensClaimed * DEFAULT_PRECISION) / effectiveSupplyBefore\n        ).toUint128();\n\n        _getVaultRewardStateSlot()[index] = state;\n    }\n\n    function _accumulateSecondaryRewardViaEmissionRate(\n        uint256 index,\n        VaultRewardState memory state,\n        uint256 effectiveSupplyBefore\n    ) private {\n        state.accumulatedRewardPerVaultShare = _getAccumulatedRewardViaEmissionRate(\n            state, effectiveSupplyBefore, block.timestamp\n        ).toUint128();\n        state.lastAccumulatedTime = uint32(block.timestamp);\n\n        _getVaultRewardStateSlot()[index] = state;\n    }\n\n    function _getAccumulatedRewardViaEmissionRate(\n        VaultRewardState memory state,\n        uint256 effectiveSupplyBefore,\n        uint256 blockTime\n    ) private pure returns (uint256) {\n        // Short circuit the method with no emission rate\n        if (state.emissionRatePerYear == 0) return state.accumulatedRewardPerVaultShare;\n        require(0 < state.endTime);\n        uint256 time = blockTime < state.endTime ? blockTime : state.endTime;\n\n        uint256 additionalIncentiveAccumulatedPerVaultShare;\n        if (state.lastAccumulatedTime < time && 0 < effectiveSupplyBefore) {\n            // NOTE: no underflow, checked in if statement\n            uint256 timeSinceLastAccumulation = time - state.lastAccumulatedTime;\n            // Precision here is:\n            //  timeSinceLastAccumulation (SECONDS)\n            //  emissionRatePerYear (REWARD_TOKEN_PRECISION)\n            //  DEFAULT_PRECISION (1e18)\n            // DIVIDE BY\n            //  YEAR (SECONDS)\n            //  DEFAULT_PRECISION (1e18)\n            // => Precision = REWARD_TOKEN_PRECISION\n            additionalIncentiveAccumulatedPerVaultShare = (timeSinceLastAccumulation * DEFAULT_PRECISION * state.emissionRatePerYear)\n                / (YEAR * effectiveSupplyBefore);\n        }\n\n        return state.accumulatedRewardPerVaultShare + additionalIncentiveAccumulatedPerVaultShare;\n    }\n\n    /// @notice Executes the proper call for various rewarder types.\n    function _executeClaim() internal virtual;\n    function _withdrawFromPreviousRewardPool(RewardPoolStorage memory oldRewardPool) internal virtual;\n    function _depositIntoNewRewardPool(address poolToken, uint256 poolTokens, RewardPoolStorage memory newRewardPool) internal virtual;\n}",
        "IRewardManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nstruct VaultRewardState {\n    address rewardToken;\n    uint32 lastAccumulatedTime;\n    uint32 endTime;\n    // Slot #2\n    // If secondary rewards are enabled, they will be streamed to the accounts via\n    // an annual emission rate. If the same reward token is also issued by the LP pool,\n    // those tokens will be added on top of the annual emission rate. If the vault is under\n    // automatic reinvestment mode, the secondary reward token cannot be sold.\n    uint128 emissionRatePerYear; // in internal token precision\n    uint128 accumulatedRewardPerVaultShare;\n}\n\nenum RewardPoolType {\n    _UNUSED,\n    AURA,\n    CONVEX_MAINNET,\n    CONVEX_ARBITRUM\n}\n\nstruct RewardPoolStorage {\n    address rewardPool;\n    uint32 lastClaimTimestamp;\n    uint32 forceClaimAfter;\n}\n\n/// Each reward manager is responsible for claiming rewards for a given protocol.\n/// it will be called through a delegatecall from the vault to avoid token transfers\n/// of staked tokens.\ninterface IRewardManager {\n\n    event VaultRewardTransfer(address token, address account, uint256 amount);\n    event VaultRewardUpdate(address rewardToken, uint128 emissionRatePerYear, uint32 endTime);\n\n    /// @notice Returns the current reward claim method and reward state\n    /// @return rewardStates Array of vault reward states\n    /// @return rewardPool Reward pool storage\n    function getRewardSettings() external view returns (\n        VaultRewardState[] memory rewardStates,\n        RewardPoolStorage memory rewardPool\n    );\n\n    /// @notice Returns the reward debt for the given reward token and account\n    /// @param rewardToken Address of the reward token\n    /// @param account Address of the account\n    /// @return rewardDebt The reward debt for the account\n    function getRewardDebt(address rewardToken, address account) external view returns (\n        uint256 rewardDebt\n    );\n\n\n    /// @notice Updates account rewards during enter and exit vault operations, only\n    /// callable via delegatecall from inside the vault\n    /// @param account Address of the account\n    /// @param effectiveSupplyBefore Total vault shares before the operation\n    /// @param accountSharesBefore Number of shares before the operation\n    /// @param accountSharesAfter Number of shares after the operation\n    /// @param sharesInEscrow Whether the shares are in escrow\n    function updateAccountRewards(\n        address account,\n        uint256 effectiveSupplyBefore,\n        uint256 accountSharesBefore,\n        uint256 accountSharesAfter,\n        bool sharesInEscrow\n    ) external returns (uint256[] memory rewards);\n\n    /// @notice Sets a secondary reward rate for a given token, only callable via the owner\n    /// @param index Index of the reward token\n    /// @param rewardToken Address of the reward token\n    /// @param emissionRatePerYear Emission rate per year for the token\n    /// @param endTime End time for the emission rate\n    function updateRewardToken(\n        uint256 index,\n        address rewardToken,\n        uint128 emissionRatePerYear,\n        uint32 endTime\n    ) external;\n\n    /// @notice Migrates the reward pool to a new reward pool, needs to be called initially\n    /// to set the reward pool storage and when the reward pool is updated.\n    /// @param poolToken The pool token to migrate\n    /// @param newRewardPool The new reward pool storage configuration\n    function migrateRewardPool(address poolToken, RewardPoolStorage memory newRewardPool) external;\n\n    /// @notice Claims all the rewards for the entire vault and updates the accumulators\n    function claimRewardTokens() external;\n}",
        "AbstractYieldStrategy.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ReentrancyGuardTransient} from \"@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol\";\nimport {DEFAULT_DECIMALS, DEFAULT_PRECISION, YEAR, ADDRESS_REGISTRY} from \"./utils/Constants.sol\";\n\nimport {\n    Unauthorized,\n    UnauthorizedLendingMarketTransfer,\n    InsufficientSharesHeld,\n    CannotLiquidate,\n    CannotEnterPosition,\n    CurrentAccountAlreadySet\n} from \"./interfaces/Errors.sol\";\nimport {IYieldStrategy} from \"./interfaces/IYieldStrategy.sol\";\nimport {IOracle} from \"./interfaces/Morpho/IOracle.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Trade, TradeType, TRADING_MODULE, nProxy, TradeFailed} from \"./interfaces/ITradingModule.sol\";\nimport {IWithdrawRequestManager} from \"./interfaces/IWithdrawRequestManager.sol\";\nimport {Initializable} from \"./proxy/Initializable.sol\";\nimport {ADDRESS_REGISTRY} from \"./utils/Constants.sol\";\nimport {ILendingRouter} from \"./interfaces/ILendingRouter.sol\";\n\n/// @title AbstractYieldStrategy\n/// @notice This is the base contract for all yield strategies, it implements the core logic for\n/// minting, burning and the valuation of tokens.\nabstract contract AbstractYieldStrategy is Initializable, ERC20, ReentrancyGuardTransient, IYieldStrategy {\n    using TokenUtils for ERC20;\n    using SafeERC20 for ERC20;\n\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\n    uint256 internal constant VIRTUAL_YIELD_TOKENS = 1;\n    uint256 internal constant SHARE_PRECISION = DEFAULT_PRECISION * VIRTUAL_SHARES;\n\n    /// @inheritdoc IYieldStrategy\n    address public immutable override asset;\n    /// @inheritdoc IYieldStrategy\n    address public immutable override yieldToken;\n    /// @inheritdoc IYieldStrategy\n    uint256 public immutable override feeRate;\n\n    IWithdrawRequestManager internal immutable withdrawRequestManager;\n\n    uint8 internal immutable _yieldTokenDecimals;\n    uint8 internal immutable _assetDecimals;\n\n    /********* Storage Variables *********/\n    string private s_name;\n    string private s_symbol;\n\n    uint32 private s_lastFeeAccrualTime;\n    uint256 private s_accruedFeesInYieldToken;\n    uint256 private s_escrowedShares;\n    /****** End Storage Variables ******/\n\n    /********* Transient Variables *********/\n    // Used to adjust the valuation call of price(), is set on some methods and\n    // cleared by the lending router using clearCurrentAccount(). This is required to\n    // ensure that the variable is set throughout the entire context of the lending router\n    // call.\n    address internal transient t_CurrentAccount;\n    // Set and cleared on every call to a lending router authorized method\n    address internal transient t_CurrentLendingRouter;\n    // Used to authorize transfers off of the lending market\n    address internal transient t_AllowTransfer_To;\n    uint256 internal transient t_AllowTransfer_Amount;\n    /****** End Transient Variables ******/\n\n    constructor(\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        uint8 __yieldTokenDecimals\n    ) ERC20(\"\", \"\") {\n        feeRate = _feeRate;\n        asset = address(_asset);\n        yieldToken = address(_yieldToken);\n        // Not all yield tokens have a decimals() function (i.e. Convex staked tokens), so we\n        // do have to pass in the decimals as a parameter.\n        _yieldTokenDecimals = __yieldTokenDecimals;\n        _assetDecimals = TokenUtils.getDecimals(_asset);\n    }\n\n    function name() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        return s_name;\n    }\n\n    function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        return s_symbol;\n    }\n\n    /*** Valuation and Conversion Functions ***/\n\n    /// @inheritdoc IYieldStrategy\n    function convertSharesToYieldToken(uint256 shares) public view override returns (uint256) {\n        // NOTE: rounds down on division\n        return (shares * (_yieldTokenBalance() - feesAccrued() + VIRTUAL_YIELD_TOKENS)) / (effectiveSupply());\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function convertYieldTokenToShares(uint256 yieldTokens) public view returns (uint256) {\n        // NOTE: rounds down on division\n        return (yieldTokens * effectiveSupply()) / (_yieldTokenBalance() - feesAccrued() + VIRTUAL_YIELD_TOKENS);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function convertToShares(uint256 assets) public view override returns (uint256) {\n        // NOTE: rounds down on division\n        uint256 yieldTokens = assets * (10 ** (_yieldTokenDecimals + DEFAULT_DECIMALS)) / \n            (convertYieldTokenToAsset() * (10 ** _assetDecimals));\n        return convertYieldTokenToShares(yieldTokens);\n    }\n\n    /// @inheritdoc IOracle\n    function price() public view override returns (uint256) {\n        return convertToAssets(SHARE_PRECISION) * (10 ** (36 - 24));\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function price(address borrower) external override returns (uint256) {\n        // Do not change the current account in this method since this method is not\n        // authenticated and we do not want to have any unexpected side effects.\n        address prevCurrentAccount = t_CurrentAccount;\n\n        t_CurrentAccount = borrower;\n        uint256 p = convertToAssets(SHARE_PRECISION) * (10 ** (36 - 24));\n\n        t_CurrentAccount = prevCurrentAccount;\n        return p;\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function totalAssets() public view override returns (uint256) {\n        return convertToAssets(totalSupply());\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function convertYieldTokenToAsset() public view returns (uint256) {\n        // The trading module always returns a positive rate in 18 decimals so we can safely\n        // cast to uint256\n        (int256 rate , /* */) = TRADING_MODULE.getOraclePrice(yieldToken, asset);\n        return uint256(rate);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function effectiveSupply() public view returns (uint256) {\n        return (totalSupply() - s_escrowedShares + VIRTUAL_SHARES);\n    }\n\n    /*** Fee Methods ***/\n\n    /// @inheritdoc IYieldStrategy\n    function feesAccrued() public view override returns (uint256 feesAccruedInYieldToken) {\n        return s_accruedFeesInYieldToken + _calculateAdditionalFeesInYieldToken();\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function collectFees() external override {\n        _accrueFees();\n        _transferYieldTokenToOwner(ADDRESS_REGISTRY.feeReceiver(), s_accruedFeesInYieldToken);\n\n        delete s_accruedFeesInYieldToken;\n    }\n\n    /*** Core Functions ***/\n    modifier onlyLendingRouter() {\n        if (ADDRESS_REGISTRY.isLendingRouter(msg.sender) == false) revert Unauthorized(msg.sender);\n        t_CurrentLendingRouter = msg.sender;\n        _;\n        delete t_CurrentLendingRouter;\n    }\n\n    modifier setCurrentAccount(address onBehalf) {\n        if (t_CurrentAccount == address(0)) {\n            t_CurrentAccount = onBehalf;\n        } else if (t_CurrentAccount != onBehalf) {\n            revert CurrentAccountAlreadySet();\n        }\n\n        _;\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function clearCurrentAccount() external override onlyLendingRouter {\n        delete t_CurrentAccount;\n    }\n\n    function mintShares(\n        uint256 assetAmount,\n        address receiver,\n        bytes calldata depositData\n    ) external override onlyLendingRouter setCurrentAccount(receiver) nonReentrant returns (uint256 sharesMinted) {\n        // Cannot mint shares if the receiver has an active withdraw request\n        if (_isWithdrawRequestPending(receiver)) revert CannotEnterPosition();\n        ERC20(asset).safeTransferFrom(t_CurrentLendingRouter, address(this), assetAmount);\n        sharesMinted = _mintSharesGivenAssets(assetAmount, depositData, receiver);\n\n        t_AllowTransfer_To = t_CurrentLendingRouter;\n        t_AllowTransfer_Amount = sharesMinted;\n        // Transfer the shares to the lending router so it can supply collateral\n        _transfer(receiver, t_CurrentLendingRouter, sharesMinted);\n    }\n\n    function burnShares(\n        address sharesOwner,\n        uint256 sharesToBurn,\n        uint256 sharesHeld,\n        bytes calldata redeemData\n    ) external override onlyLendingRouter setCurrentAccount(sharesOwner) nonReentrant returns (uint256 assetsWithdrawn) {\n        assetsWithdrawn = _burnShares(sharesToBurn, sharesHeld, redeemData, sharesOwner);\n\n        // Send all the assets back to the lending router\n        ERC20(asset).safeTransfer(t_CurrentLendingRouter, assetsWithdrawn);\n    }\n\n    function allowTransfer(\n        address to, uint256 amount, address currentAccount\n    ) external setCurrentAccount(currentAccount) onlyLendingRouter {\n        // Sets the transient variables to allow the lending market to transfer shares on exit position\n        // or liquidation.\n        t_AllowTransfer_To = to;\n        t_AllowTransfer_Amount = amount;\n    }\n\n    function preLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidate,\n        uint256 accountSharesHeld\n    ) external onlyLendingRouter {\n        t_CurrentAccount = liquidateAccount;\n        // Liquidator cannot liquidate if they have an active withdraw request, including a tokenized\n        // withdraw request.\n        if (_isWithdrawRequestPending(liquidator)) revert CannotEnterPosition();\n        // Cannot receive a pending withdraw request if the liquidator has a balanceOf\n        if (_isWithdrawRequestPending(liquidateAccount) && balanceOf(liquidator) > 0) {\n            revert CannotEnterPosition();\n        }\n        _preLiquidation(liquidateAccount, liquidator, sharesToLiquidate, accountSharesHeld);\n\n        // Allow transfers to the lending router which will proxy the call to liquidate.\n        t_AllowTransfer_To = msg.sender;\n        t_AllowTransfer_Amount = sharesToLiquidate;\n    }\n\n    function postLiquidation(\n        address liquidator,\n        address liquidateAccount,\n        uint256 sharesToLiquidator\n    ) external onlyLendingRouter {\n        t_AllowTransfer_To = liquidator;\n        t_AllowTransfer_Amount = sharesToLiquidator;\n        // Transfer the shares to the liquidator from the lending router\n        _transfer(t_CurrentLendingRouter, liquidator, sharesToLiquidator);\n\n        _postLiquidation(liquidator, liquidateAccount, sharesToLiquidator);\n\n        // Clear the transient variables to prevent re-use in a future call.\n        delete t_CurrentAccount;\n    }\n\n    /// @inheritdoc IYieldStrategy\n    /// @dev We do not set the current account here because valuation is not done in this method.\n    /// A native balance does not require a collateral check.\n    function redeemNative(\n        uint256 sharesToRedeem,\n        bytes memory redeemData\n    ) external override nonReentrant returns (uint256 assetsWithdrawn) {\n        uint256 sharesHeld = balanceOf(msg.sender);\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n\n        assetsWithdrawn = _burnShares(sharesToRedeem, sharesHeld, redeemData, msg.sender);\n        ERC20(asset).safeTransfer(msg.sender, assetsWithdrawn);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    function initiateWithdraw(\n        address account,\n        uint256 sharesHeld,\n        bytes calldata data\n    ) external onlyLendingRouter setCurrentAccount(account) override returns (uint256 requestId) {\n        requestId = _withdraw(account, sharesHeld, data);\n    }\n\n    /// @inheritdoc IYieldStrategy\n    /// @dev We do not set the current account here because valuation is not done in this method. A\n    /// native balance does not require a collateral check.\n    function initiateWithdrawNative(\n        bytes memory data\n    ) external override returns (uint256 requestId) {\n        requestId = _withdraw(msg.sender, balanceOf(msg.sender), data);\n    }\n\n    function _withdraw(address account, uint256 sharesHeld, bytes memory data) internal returns (uint256 requestId) {\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n\n        // Accrue fees before initiating a withdraw since it will change the effective supply\n        _accrueFees();\n        uint256 yieldTokenAmount = convertSharesToYieldToken(sharesHeld);\n        requestId = _initiateWithdraw(account, yieldTokenAmount, sharesHeld, data);\n        // Escrow the shares after the withdraw since it will change the effective supply\n        // during reward claims when using the RewardManagerMixin.\n        s_escrowedShares += sharesHeld;\n    }\n\n    /*** Private Functions ***/\n\n    function _calculateAdditionalFeesInYieldToken() private view returns (uint256 additionalFeesInYieldToken) {\n        uint256 timeSinceLastFeeAccrual = block.timestamp - s_lastFeeAccrualTime;\n        // e ^ (feeRate * timeSinceLastFeeAccrual / YEAR)\n        uint256 x = (feeRate * timeSinceLastFeeAccrual) / YEAR;\n        if (x == 0) return 0;\n\n        uint256 preFeeUserHeldYieldTokens = _yieldTokenBalance() - s_accruedFeesInYieldToken;\n        // Taylor approximation of e ^ x = 1 + x + x^2 / 2! + x^3 / 3! + ...\n        uint256 eToTheX = DEFAULT_PRECISION + x + (x * x) / (2 * DEFAULT_PRECISION) + (x * x * x) / (6 * DEFAULT_PRECISION * DEFAULT_PRECISION);\n        // Decay the user's yield tokens by e ^ (feeRate * timeSinceLastFeeAccrual / YEAR)\n        uint256 postFeeUserHeldYieldTokens = preFeeUserHeldYieldTokens * DEFAULT_PRECISION / eToTheX;\n\n        additionalFeesInYieldToken = preFeeUserHeldYieldTokens - postFeeUserHeldYieldTokens;\n    }\n\n    function _accrueFees() private {\n        if (s_lastFeeAccrualTime == block.timestamp) return;\n        // NOTE: this has to be called before any mints or burns.\n        s_accruedFeesInYieldToken += _calculateAdditionalFeesInYieldToken();\n        s_lastFeeAccrualTime = uint32(block.timestamp);\n    }\n\n    function _update(address from, address to, uint256 value) internal override {\n        if (from != address(0) && to != address(0)) {\n            // Any transfers off of the lending market must be authorized here, this means that native balances\n            // held cannot be transferred.\n            if (t_AllowTransfer_To != to) revert UnauthorizedLendingMarketTransfer(from, to, value);\n            if (t_AllowTransfer_Amount < value) revert UnauthorizedLendingMarketTransfer(from, to, value);\n\n            delete t_AllowTransfer_To;\n            delete t_AllowTransfer_Amount;\n        }\n\n        super._update(from, to, value);\n    }\n\n    /*** Internal Helper Functions ***/\n\n    function _isWithdrawRequestPending(address account) virtual internal view returns (bool) {\n        return address(withdrawRequestManager) != address(0)\n            && withdrawRequestManager.isPendingWithdrawRequest(address(this), account);\n    }\n\n    function _yieldTokenBalance() internal view returns (uint256) {\n        return ERC20(yieldToken).balanceOf(address(this));\n    }\n\n    /// @dev Can be used to delegate call to the TradingModule's implementation in order to execute a trade\n    function _executeTrade(\n        Trade memory trade,\n        uint16 dexId\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        if (trade.tradeType == TradeType.STAKE_TOKEN) {\n            IWithdrawRequestManager wrm = ADDRESS_REGISTRY.getWithdrawRequestManager(trade.buyToken);\n            ERC20(trade.sellToken).checkApprove(address(wrm), trade.amount);\n            amountBought = wrm.stakeTokens(trade.sellToken, trade.amount, trade.exchangeData);\n            return (trade.amount, amountBought);\n        } else {\n            address implementation = nProxy(payable(address(TRADING_MODULE))).getImplementation();\n            bytes memory result = _delegateCall(\n                implementation, abi.encodeWithSelector(TRADING_MODULE.executeTrade.selector, dexId, trade)\n            );\n            (amountSold, amountBought) = abi.decode(result, (uint256, uint256));\n        }\n    }\n\n    function _delegateCall(address target, bytes memory data) internal returns (bytes memory result) {\n        bool success;\n        (success, result) = target.delegatecall(data);\n        if (!success) {\n            assembly {\n                // Copy the return data to memory\n                returndatacopy(0, 0, returndatasize())\n                // Revert with the return data\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /*** Virtual Functions ***/\n\n    function _initialize(bytes calldata data) internal override virtual {\n        (string memory _name, string memory _symbol) = abi.decode(data, (string, string));\n        s_name = _name;\n        s_symbol = _symbol;\n\n        s_lastFeeAccrualTime = uint32(block.timestamp);\n        emit VaultCreated(address(this));\n    }\n\n    /// @dev Marked as virtual to allow for RewardManagerMixin to override\n    function _mintSharesGivenAssets(uint256 assets, bytes memory depositData, address receiver) internal virtual returns (uint256 sharesMinted) {\n        if (assets == 0) return 0;\n\n        // First accrue fees on the yield token\n        _accrueFees();\n        uint256 initialYieldTokenBalance = _yieldTokenBalance();\n        _mintYieldTokens(assets, receiver, depositData);\n        uint256 yieldTokensMinted = _yieldTokenBalance() - initialYieldTokenBalance;\n\n        sharesMinted = (yieldTokensMinted * effectiveSupply()) / (initialYieldTokenBalance - feesAccrued() + VIRTUAL_YIELD_TOKENS);\n        _mint(receiver, sharesMinted);\n    }\n\n    /// @dev Marked as virtual to allow for RewardManagerMixin to override\n    function _burnShares(\n        uint256 sharesToBurn,\n        uint256 /* sharesHeld */,\n        bytes memory redeemData,\n        address sharesOwner\n    ) internal virtual returns (uint256 assetsWithdrawn) {\n        if (sharesToBurn == 0) return 0;\n        bool isEscrowed = _isWithdrawRequestPending(sharesOwner);\n\n        uint256 initialAssetBalance = TokenUtils.tokenBalance(asset);\n\n        // First accrue fees on the yield token\n        _accrueFees();\n        _redeemShares(sharesToBurn, sharesOwner, isEscrowed, redeemData);\n        if (isEscrowed) s_escrowedShares -= sharesToBurn;\n\n        uint256 finalAssetBalance = TokenUtils.tokenBalance(asset);\n        assetsWithdrawn = finalAssetBalance - initialAssetBalance;\n\n        // This burns the shares from the sharesOwner's balance\n        _burn(sharesOwner, sharesToBurn);\n    }\n\n    /// @dev Some yield tokens (such as Convex staked tokens) cannot be transferred, so we may need\n    /// to override this function.\n    function _transferYieldTokenToOwner(address owner, uint256 yieldTokens) internal virtual {\n        ERC20(yieldToken).safeTransfer(owner, yieldTokens);\n    }\n\n    /// @dev Returns the maximum number of shares that can be liquidated. Allows the strategy to override the\n    /// underlying lending market's liquidation logic.\n    function _preLiquidation(address liquidateAccount, address liquidator, uint256 sharesToLiquidate, uint256 accountSharesHeld) internal virtual;\n\n    /// @dev Called after liquidation\n    function _postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal virtual returns (bool didTokenize);\n\n    /// @dev Mints yield tokens given a number of assets.\n    function _mintYieldTokens(uint256 assets, address receiver, bytes memory depositData) internal virtual;\n\n    /// @dev Redeems shares\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal virtual;\n\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal virtual returns (uint256 requestId);\n\n    /// @inheritdoc IYieldStrategy\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        uint256 yieldTokens = convertSharesToYieldToken(shares);\n        // NOTE: rounds down on division\n        return (yieldTokens * convertYieldTokenToAsset() * (10 ** _assetDecimals)) /\n            (10 ** (_yieldTokenDecimals + DEFAULT_DECIMALS));\n    }\n\n}\n\n"
    }
}