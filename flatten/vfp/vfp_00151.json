{
    "vfp_id": "vfp_00151",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Protocol fees are lost when LP fees are zero",
            "description": "In the swap() function of LikwidVault.sol, the update to protocol fees is skipped if feeAmount is zero, even if amountToProtocol is greater than zero. This means that protocol fees are not collected in cases where LP fees are zero, resulting in lost revenue. The root cause is a flawed conditional check that ties protocol fee updates to LP fee amounts rather than protocol fee amounts. An attacker cannot directly exploit this, but it leads to economic inefficiency. The impact is loss of potential protocol revenue when LP fees are set to zero.\n",
            "severity": "Low",
            "location": [
                "LikwidVault.sol#L151-157"
            ],
            "files": [
                "likwid-margin/src/LikwidVault.sol"
            ]
        },
        {
            "id": 57,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Check pool is initialized before checkpointing state",
            "description": "The _getAndUpdatePool() function updates pool state before validating initialization. The root cause is incorrect order of operations. While likely a no-op, it violates defensive programming principles. The impact is potential edge-case issues if uninitialized pools are accessed.\n",
            "severity": "Informational",
            "location": [
                "LikwidVault.sol#L82-83"
            ],
            "files": [
                "likwid-margin/src/LikwidVault.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Protocol fees are not collected for swaps in margin operations",
            "description": "During margin operations such as margin(), close(), and liquidateBurn(), swap fees are logged but protocol fees are not collected from swapFeeAmount. The feeAmount and amountToProtocol variables only reflect margin fees, while swapFeeAmount is only used for event emission. The root cause is missing protocol fee accounting logic for swap fees in margin contexts. An attacker cannot exploit this directly, but it results in lost revenue. The impact is missed protocol income from swap activities within margin operations.\n",
            "severity": "Low",
            "location": [
                "LikwidVault.sol#L200-216"
            ],
            "files": [
                "likwid-margin/src/LikwidVault.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing fee validation during pool initialization",
            "description": "The initialize() function in LikwidVault.sol does not validate whether the LP fee is within the valid range (i.e., not exceeding 1,000,000, which represents 100%). This allows potentially invalid or malicious fee values to be set during pool creation. The root cause is the absence of input validation for a critical parameter. An attacker could exploit this by initializing a pool with an excessively high fee, leading to unexpected economic behavior or denial of service. The impact includes potential protocol instability or loss of user trust due to unreasonable fee settings.\n",
            "severity": "Low",
            "location": [
                "LikwidVault.sol"
            ],
            "files": [
                "likwid-margin/src/LikwidVault.sol"
            ]
        }
    ],
    "affected_files": {
        "LikwidVault.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Likwid Contracts\npragma solidity 0.8.28;\n\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {MarginBalanceDelta} from \"./types/MarginBalanceDelta.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"./types/BalanceDelta.sol\";\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {FeeTypes} from \"./types/FeeTypes.sol\";\nimport {MarginActions} from \"./types/MarginActions.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IUnlockCallback} from \"./interfaces/callback/IUnlockCallback.sol\";\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\nimport {CurrencyGuard} from \"./libraries/CurrencyGuard.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {ERC6909Claims} from \"./base/ERC6909Claims.sol\";\nimport {NoDelegateCall} from \"./base/NoDelegateCall.sol\";\nimport {ProtocolFees} from \"./base/ProtocolFees.sol\";\nimport {Extsload} from \"./base/Extsload.sol\";\nimport {Exttload} from \"./base/Exttload.sol\";\nimport {CustomRevert} from \"./libraries/CustomRevert.sol\";\n\n/// @title Likwid vault\n/// @notice Holds the property for all likwid pools\ncontract LikwidVault is IVault, ProtocolFees, NoDelegateCall, ERC6909Claims, Extsload, Exttload {\n    using CustomRevert for bytes4;\n    using SafeCast for *;\n    using CurrencyGuard for Currency;\n    using BalanceDeltaLibrary for BalanceDelta;\n    using Pool for Pool.State;\n\n    mapping(PoolId id => Pool.State) private _pools;\n\n    /// transient storage\n    bool transient unlocked;\n    uint256 transient nonzeroDeltaCount;\n\n    /// @notice This will revert if the contract is locked\n    modifier onlyWhenUnlocked() {\n        if (!unlocked) VaultLocked.selector.revertWith();\n        _;\n    }\n\n    constructor(address initialOwner) ProtocolFees(initialOwner) {\n        protocolFeeController = initialOwner;\n    }\n\n    /// @inheritdoc IVault\n    function unlock(bytes calldata data) external override returns (bytes memory result) {\n        if (unlocked) revert AlreadyUnlocked();\n\n        unlocked = true;\n\n        // the caller does everything in this callback, including paying what they owe via calls to settle\n        result = IUnlockCallback(msg.sender).unlockCallback(data);\n\n        if (nonzeroDeltaCount != 0) revert CurrencyNotSettled();\n        unlocked = false;\n    }\n\n    /// @inheritdoc IVault\n    function initialize(PoolKey memory key) external noDelegateCall {\n        if (key.currency0 >= key.currency1) {\n            CurrenciesOutOfOrderOrEqual.selector.revertWith(\n                Currency.unwrap(key.currency0), Currency.unwrap(key.currency1)\n            );\n        }\n\n        PoolId id = key.toId();\n        _pools[id].initialize(key.fee);\n        emit Initialize(id, key.currency0, key.currency1, key.fee);\n    }\n\n    /// @inheritdoc IVault\n    function modifyLiquidity(PoolKey memory key, IVault.ModifyLiquidityParams memory params)\n        external\n        onlyWhenUnlocked\n        noDelegateCall\n        returns (BalanceDelta callerDelta, int128 finalLiquidityDelta)\n    {\n        Pool.State storage pool = _getAndUpdatePool(key);\n        pool.checkPoolInitialized();\n        PoolId id = key.toId();\n\n        uint256 liquidityBefore = pool.slot0.totalSupply();\n\n        (callerDelta, finalLiquidityDelta) = pool.modifyLiquidity(\n            Pool.ModifyLiquidityParams({\n                owner: msg.sender,\n                amount0: params.amount0,\n                amount1: params.amount1,\n                liquidityDelta: params.liquidityDelta.toInt128(),\n                salt: params.salt\n            })\n        );\n\n        uint256 liquidityAfter = pool.slot0.totalSupply();\n\n        if (liquidityAfter > liquidityBefore) {\n            _handleAddLiquidity(id, liquidityAfter - liquidityBefore);\n        } else if (liquidityAfter < liquidityBefore) {\n            _handleRemoveLiquidity(id, liquidityBefore - liquidityAfter);\n        }\n        int256 liquidityDelta = liquidityAfter.toInt256() - liquidityBefore.toInt256();\n        emit ModifyLiquidity(id, msg.sender, BalanceDelta.unwrap(callerDelta), liquidityDelta, params.salt);\n        _appendPoolBalanceDelta(key, msg.sender, callerDelta);\n    }\n\n    /// @inheritdoc IVault\n    function swap(PoolKey memory key, IVault.SwapParams memory params)\n        external\n        onlyWhenUnlocked\n        noDelegateCall\n        returns (BalanceDelta swapDelta, uint24 swapFee, uint256 feeAmount)\n    {\n        if (params.amountSpecified == 0) AmountCannotBeZero.selector.revertWith();\n\n        PoolId id = key.toId();\n        Pool.State storage pool = _getAndUpdatePool(key);\n        pool.checkPoolInitialized();\n        uint256 amountToProtocol;\n        (swapDelta, amountToProtocol, swapFee, feeAmount) = pool.swap(\n            Pool.SwapParams({\n                sender: msg.sender,\n                zeroForOne: params.zeroForOne,\n                amountSpecified: params.amountSpecified,\n                useMirror: params.useMirror,\n                salt: params.salt\n            }),\n            defaultProtocolFee\n        );\n        if (params.useMirror) {\n            BalanceDelta realDelta;\n            int128 lendAmount;\n            if (params.zeroForOne) {\n                realDelta = toBalanceDelta(swapDelta.amount0(), 0);\n                lendAmount = -swapDelta.amount1();\n            } else {\n                realDelta = toBalanceDelta(0, swapDelta.amount1());\n                lendAmount = -swapDelta.amount0();\n            }\n            _appendPoolBalanceDelta(key, msg.sender, realDelta);\n            uint256 depositCumulativeLast =\n                params.zeroForOne ? pool.deposit1CumulativeLast : pool.deposit0CumulativeLast;\n            emit Lend(id, msg.sender, params.zeroForOne, lendAmount, depositCumulativeLast, params.salt);\n        } else {\n            _appendPoolBalanceDelta(key, msg.sender, swapDelta);\n        }\n\n        if (feeAmount > 0) {\n            Currency feeCurrency = params.zeroForOne ? key.currency0 : key.currency1;\n            if (amountToProtocol > 0) {\n                _updateProtocolFees(feeCurrency, amountToProtocol);\n            }\n            emit Fees(id, feeCurrency, msg.sender, uint8(FeeTypes.SWAP), feeAmount);\n        }\n\n        emit Swap(id, msg.sender, swapDelta.amount0(), swapDelta.amount1(), swapFee);\n    }\n\n    /// @inheritdoc IVault\n    function lend(PoolKey memory key, IVault.LendParams memory params)\n        external\n        onlyWhenUnlocked\n        noDelegateCall\n        returns (BalanceDelta lendDelta)\n    {\n        if (params.lendAmount == 0) AmountCannotBeZero.selector.revertWith();\n\n        PoolId id = key.toId();\n        Pool.State storage pool = _getAndUpdatePool(key);\n        pool.checkPoolInitialized();\n        uint256 depositCumulativeLast;\n        (lendDelta, depositCumulativeLast) = pool.lend(\n            Pool.LendParams({\n                sender: msg.sender,\n                lendForOne: params.lendForOne,\n                lendAmount: params.lendAmount,\n                salt: params.salt\n            })\n        );\n\n        _appendPoolBalanceDelta(key, msg.sender, lendDelta);\n        emit Lend(id, msg.sender, params.lendForOne, params.lendAmount, depositCumulativeLast, params.salt);\n    }\n\n    /// @inheritdoc IVault\n    function marginBalance(PoolKey memory key, MarginBalanceDelta memory params)\n        external\n        onlyWhenUnlocked\n        onlyManager\n        noDelegateCall\n        returns (BalanceDelta marginDelta, uint256 feeAmount)\n    {\n        PoolId id = key.toId();\n        Pool.State storage pool = _getAndUpdatePool(key);\n        pool.checkPoolInitialized();\n        uint256 amountToProtocol;\n        (marginDelta, amountToProtocol, feeAmount) = pool.margin(params, defaultProtocolFee);\n\n        (Currency marginCurrency, Currency borrowCurrency) =\n            params.marginForOne ? (key.currency1, key.currency0) : (key.currency0, key.currency1);\n        if (feeAmount > 0) {\n            if (amountToProtocol > 0) {\n                _updateProtocolFees(marginCurrency, amountToProtocol);\n            }\n            emit Fees(id, marginCurrency, msg.sender, uint8(FeeTypes.MARGIN), feeAmount);\n        }\n        if (params.swapFeeAmount > 0) {\n            if (params.action == MarginActions.MARGIN) {\n                emit Fees(id, borrowCurrency, msg.sender, uint8(FeeTypes.MARGIN_SWAP), params.swapFeeAmount);\n            } else {\n                emit Fees(id, marginCurrency, msg.sender, uint8(FeeTypes.MARGIN_CLOSE_SWAP), params.swapFeeAmount);\n            }\n        }\n\n        _appendPoolBalanceDelta(key, msg.sender, marginDelta);\n    }\n\n    /// @inheritdoc IVault\n    function sync(Currency currency) external {\n        // address(0) is used for the native currency\n        if (currency.isAddressZero()) {\n            syncedCurrency = CurrencyLibrary.ADDRESS_ZERO;\n        } else {\n            uint256 balance = currency.balanceOfSelf();\n            syncedCurrency = currency;\n            syncedReserves = balance;\n        }\n    }\n\n    /// @inheritdoc IVault\n    function take(Currency currency, address to, uint256 amount) external onlyWhenUnlocked {\n        unchecked {\n            // negation must be safe as amount is not negative\n            _appendDelta(currency, msg.sender, -amount.toInt256());\n            currency.transfer(to, amount);\n        }\n    }\n\n    /// @inheritdoc IVault\n    function settle() external payable onlyWhenUnlocked returns (uint256) {\n        return _settle(msg.sender);\n    }\n\n    /// @inheritdoc IVault\n    function settleFor(address recipient) external payable onlyWhenUnlocked returns (uint256) {\n        return _settle(recipient);\n    }\n\n    /// @inheritdoc IVault\n    function clear(Currency currency, uint256 amount) external onlyWhenUnlocked {\n        int256 current = currency.currentDelta(msg.sender);\n        int256 amountDelta = amount.toInt256();\n        if (amountDelta != current) revert MustClearExactPositiveDelta();\n        // negation must be safe as amountDelta is positive\n        unchecked {\n            _appendDelta(currency, msg.sender, -(amountDelta));\n        }\n    }\n\n    /// @inheritdoc IVault\n    function mint(address to, uint256 id, uint256 amount) external onlyWhenUnlocked {\n        unchecked {\n            Currency currency = CurrencyLibrary.fromId(id);\n            // negation must be safe as amount is not negative\n            _appendDelta(currency, msg.sender, -amount.toInt256());\n            _mint(to, currency.toId(), amount);\n        }\n    }\n\n    /// @inheritdoc IVault\n    function burn(address from, uint256 id, uint256 amount) external onlyWhenUnlocked {\n        Currency currency = CurrencyLibrary.fromId(id);\n        _appendDelta(currency, msg.sender, amount.toInt256());\n        _burnFrom(from, currency.toId(), amount);\n    }\n\n    /// @notice Settles a user's balance for a specific currency.\n    /// @dev Internal function to handle the logic of settling a user's balance.\n    /// @param recipient The address of the user to settle the balance for.\n    /// @return paid The amount paid to the user.\n    function _settle(address recipient) internal returns (uint256 paid) {\n        Currency currency = syncedCurrency;\n\n        if (currency.isAddressZero()) {\n            paid = msg.value;\n        } else {\n            if (msg.value > 0) revert NonzeroNativeValue();\n            uint256 reservesBefore = syncedReserves;\n            uint256 reservesNow = currency.balanceOfSelf();\n            paid = reservesNow - reservesBefore;\n            syncedCurrency = CurrencyLibrary.ADDRESS_ZERO; // reset synced currency\n        }\n\n        _appendDelta(currency, recipient, paid.toInt256());\n    }\n\n    /// @notice Appends a balance delta in a currency for a target address\n    /// @param currency The currency to update the balance for.\n    /// @param target The address whose balance is to be updated.\n    /// @param delta The change in balance.\n    function _appendDelta(Currency currency, address target, int256 delta) internal {\n        if (delta == 0) return;\n\n        (int256 previous, int256 current) = currency.appendDelta(target, delta.toInt128());\n\n        if (current == 0) {\n            nonzeroDeltaCount -= 1;\n        } else if (previous == 0) {\n            nonzeroDeltaCount += 1;\n        }\n    }\n\n    /// @notice Appends the deltas of 2 currencies to a target address\n    /// @param key The key of the pool.\n    /// @param target The address whose balance is to be updated.\n    /// @param delta The change in balance for both currencies.\n    function _appendPoolBalanceDelta(PoolKey memory key, address target, BalanceDelta delta) internal {\n        _appendDelta(key.currency0, target, delta.amount0());\n        _appendDelta(key.currency1, target, delta.amount1());\n    }\n\n    /// @notice Implementation of the _getAndUpdatePool function defined in ProtocolFees\n    /// @param key The key of the pool to retrieve.\n    /// @return _pool The state of the pool.\n    function _getAndUpdatePool(PoolKey memory key) internal override returns (Pool.State storage _pool) {\n        PoolId id = key.toId();\n        _pool = _pools[id];\n        (uint256 pairInterest0, uint256 pairInterest1) = _pool.updateInterests(marginState, defaultProtocolFee);\n        if (pairInterest0 > 0) {\n            emit Fees(id, key.currency0, address(this), uint8(FeeTypes.INTERESTS), pairInterest0);\n        }\n        if (pairInterest1 > 0) {\n            emit Fees(id, key.currency1, address(this), uint8(FeeTypes.INTERESTS), pairInterest1);\n        }\n    }\n\n    /// @notice Implementation of the _isUnlocked function defined in ProtocolFees\n    /// @return A boolean indicating whether the contract is unlocked.\n    function _isUnlocked() internal view override returns (bool) {\n        return unlocked;\n    }\n}\n"
    }
}