{
    "vfp_id": "vfp_00381",
    "project_name": "cantina_eco_pr28_pr38_aug2025.pdf",
    "findings": [
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ]
            },
            "title": "Ambiguous Transfer name in PermitType enum",
            "description": "The PermitType enum contains a member named Transfer, which is ambiguous in a multi-token standard context. The name \"Transfer\" suggests it could apply to any token type, but it is only used for ERC20 transfers via _transferFrom(), creating a mismatch between name and function. Developers may incorrectly assume the Transfer type supports NFTs, leading to failed transactions when attempting to use it for ERC721 or ERC1155. The impact is increased risk of integration errors and user confusion, reducing the safety and usability of the API.\n",
            "severity": "Informational",
            "location": [
                "IPermit3.sol::PermitType#L20"
            ],
            "files": [
                "70649332/permit3/src/interfaces/IPermit3.sol",
                "70649332/permit3/src/Permit3.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant zero address check for owner",
            "description": "Several functions in the Permit3 contract (e.g., permit(), permitTransferFrom()) include explicit checks to ensure the owner is not the zero address. However, these checks are redundant because the _verifySignature() function, which is called later, relies on ECDSA.recover(), which inherently rejects signatures from address(0) and reverts. Therefore, the prior checks do not add security but only consume additional gas. The root cause is duplicated validation logic. The impact is unnecessary gas costs for all users calling these functions, reducing efficiency without any security benefit.\n",
            "severity": "Informational",
            "location": [
                "Permit3.sol#L109-L111",
                "Permit3.sol#L160-L162",
                "Permit3.sol#L218-L220",
                "Permit3.sol#L280-L282"
            ],
            "files": [
                "70649332/permit3/src/Permit3.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Non-valid addresses allowed for Transfers",
            "description": "The Permit3 contract allows any bytes32 value to be used as a tokenKey for Transfer operations, which are then truncated to 20 bytes to form an address. The implementation does not validate that the upper 12 bytes of the bytes32 value are zero, allowing non-address values to be interpreted as addresses. Malformed or invalid tokenKeys could lead to transfers being directed to unintended or invalid addresses, increasing the risk of fund loss. The impact is reduced safety and clarity in transfer operations, potentially leading to irreversible errors due to incorrect address interpretation.\n",
            "severity": "Informational",
            "location": [
                "Permit3.sol::token#L338"
            ],
            "files": [
                "70649332/permit3/src/Permit3.sol"
            ]
        }
    ],
    "affected_files": {
        "Permit3.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IPermit3 } from \"./interfaces/IPermit3.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport { MultiTokenPermit } from \"./MultiTokenPermit.sol\";\nimport { NonceManager } from \"./NonceManager.sol\";\n\n/**\n * @title Permit3\n * @notice A cross-chain token approval and transfer system using EIP-712 signatures with merkle proofs\n * @dev Key features and components:\n * 1. Cross-chain Compatibility: Single signature can authorize operations across multiple chains\n * 2. Batched Operations: Process multiple token approvals and transfers in one transaction\n * 3. Flexible Nonce System: Non-sequential nonces for concurrent operations and gas optimization\n * 4. Time-bound Approvals: Permissions can be set to expire automatically\n * 5. EIP-712 Typed Signatures: Enhanced security through structured data signing\n * 6. Merkle Proofs: Optimized proof structure for cross-chain verification\n */\ncontract Permit3 is IPermit3, MultiTokenPermit, NonceManager {\n    /**\n     * @dev EIP-712 typehash for bundled chain permits\n     * Includes nested SpendTransferPermit struct for structured token permissions\n     * Used in cross-chain signature verification\n     */\n    bytes32 public constant CHAIN_PERMITS_TYPEHASH = keccak256(\n        \"ChainPermits(uint64 chainId,AllowanceOrTransfer[] permits)AllowanceOrTransfer(uint48 modeOrExpiration,bytes32 tokenKey,address account,uint160 amountDelta)\"\n    );\n\n    /**\n     * @dev EIP-712 typehash for the primary permit signature\n     * Binds owner, deadline, and permit data hash for signature verification\n     */\n    bytes32 public constant SIGNED_PERMIT3_TYPEHASH =\n        keccak256(\"Permit3(address owner,bytes32 salt,uint48 deadline,uint48 timestamp,bytes32 merkleRoot)\");\n\n    // Constants for witness type hash strings\n    string public constant PERMIT_WITNESS_TYPEHASH_STUB =\n        \"PermitWitness(address owner,bytes32 salt,uint48 deadline,uint48 timestamp,bytes32 merkleRoot,\";\n\n    /**\n     * @dev Sets up EIP-712 domain separator with protocol identifiers\n     * @notice Establishes the contract's domain for typed data signing\n     */\n    constructor() NonceManager(\"Permit3\", \"1\") { }\n\n    /**\n     * @dev Generate EIP-712 compatible hash for chain permits\n     * @param chainPermits Chain-specific permit data\n     * @return bytes32 Combined hash of all permit parameters\n     */\n    function hashChainPermits(\n        ChainPermits memory chainPermits\n    ) public pure returns (bytes32) {\n        uint256 permitsLength = chainPermits.permits.length;\n        bytes32[] memory permitHashes = new bytes32[](permitsLength);\n\n        for (uint256 i = 0; i < permitsLength; i++) {\n            permitHashes[i] = keccak256(\n                abi.encode(\n                    chainPermits.permits[i].modeOrExpiration,\n                    chainPermits.permits[i].tokenKey,\n                    chainPermits.permits[i].account,\n                    chainPermits.permits[i].amountDelta\n                )\n            );\n        }\n\n        return keccak256(\n            abi.encode(CHAIN_PERMITS_TYPEHASH, chainPermits.chainId, keccak256(abi.encodePacked(permitHashes)))\n        );\n    }\n\n    /**\n     * @notice Direct permit execution for ERC-7702 integration\n     * @dev No signature verification - caller must be the token owner\n     * @param permits Array of permit operations to execute on current chain\n     */\n    function permit(\n        AllowanceOrTransfer[] memory permits\n    ) external {\n        if (permits.length == 0) {\n            revert EmptyArray();\n        }\n\n        ChainPermits memory chainPermits = ChainPermits({ chainId: uint64(block.chainid), permits: permits });\n        _processChainPermits(msg.sender, uint48(block.timestamp), chainPermits);\n    }\n\n    /**\n     * @notice Process token approvals for a single chain\n     * @dev Core permit processing function for single-chain operations\n     * @param owner The token owner authorizing the permits\n     * @param salt Unique value for replay protection and nonce management\n     * @param deadline Timestamp limiting signature validity for security\n     * @param timestamp Timestamp of the permit\n     * @param permits Array of permit operations to execute\n     * @param signature EIP-712 signature authorizing all permits in the batch\n     */\n    function permit(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        AllowanceOrTransfer[] calldata permits,\n        bytes calldata signature\n    ) external {\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n\n        if (permits.length == 0) {\n            revert EmptyArray();\n        }\n\n        ChainPermits memory chainPermits = ChainPermits({ chainId: uint64(block.chainid), permits: permits });\n\n        bytes32 signedHash = keccak256(\n            abi.encode(SIGNED_PERMIT3_TYPEHASH, owner, salt, deadline, timestamp, hashChainPermits(chainPermits))\n        );\n\n        _useNonce(owner, salt);\n        _verifySignature(owner, signedHash, signature);\n        _processChainPermits(owner, timestamp, chainPermits);\n    }\n\n    // Helper struct to avoid stack-too-deep errors\n    struct PermitParams {\n        address owner;\n        bytes32 salt;\n        uint48 deadline;\n        uint48 timestamp;\n        bytes32 currentChainHash;\n        bytes32 merkleRoot;\n    }\n\n    /**\n     * @notice Process token approvals across multiple chains using Merkle Tree verification\n     * @dev Verifies the current chain's permits are part of a larger cross-chain batch\n     * @param owner Token owner authorizing the operations\n     * @param salt Unique salt for replay protection and nonce management\n     * @param deadline Signature expiration timestamp for security\n     * @param timestamp Block timestamp when the permit was created\n     * @param permits Chain-specific permit operations to execute on current chain\n     * @param proof Merkle proof array proving permits belong to the signed batch\n     * @param signature EIP-712 signature covering the entire cross-chain batch via merkle root\n     */\n    function permit(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        ChainPermits calldata permits,\n        bytes32[] calldata proof,\n        bytes calldata signature\n    ) external {\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (permits.chainId != uint64(block.chainid)) {\n            revert WrongChainId(uint64(block.chainid), permits.chainId);\n        }\n\n        // Use a struct to avoid stack-too-deep errors\n        PermitParams memory params;\n        params.owner = owner;\n        params.salt = salt;\n        params.deadline = deadline;\n        params.timestamp = timestamp;\n\n        // Hash current chain's permits\n        params.currentChainHash = hashChainPermits(permits);\n\n        // Calculate the merkle root from the proof components\n        // processProof performs validation internally and provides granular error messages\n        params.merkleRoot = MerkleProof.processProof(proof, params.currentChainHash);\n\n        // Verify signature with merkle root\n        bytes32 signedHash = keccak256(\n            abi.encode(\n                SIGNED_PERMIT3_TYPEHASH, params.owner, params.salt, params.deadline, params.timestamp, params.merkleRoot\n            )\n        );\n\n        _useNonce(owner, salt);\n        _verifySignature(params.owner, signedHash, signature);\n        _processChainPermits(params.owner, params.timestamp, permits);\n    }\n\n    /**\n     * @notice Process token approvals with witness data for single chain operations\n     * @dev Handles permitWitnessTransferFrom operations with dynamic witness data\n     * @param owner The token owner authorizing the permits\n     * @param salt Unique salt for replay protection\n     * @param deadline Timestamp limiting signature validity for security\n     * @param timestamp Timestamp of the permit\n     * @param permits Array of permit operations to execute\n     * @param witness Additional data to include in signature verification\n     * @param witnessTypeString EIP-712 type definition for witness data\n     * @param signature EIP-712 signature authorizing all permits with witness\n     */\n    function permitWitness(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        AllowanceOrTransfer[] calldata permits,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external {\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n\n        if (permits.length == 0) {\n            revert EmptyArray();\n        }\n\n        ChainPermits memory chainPermits = ChainPermits({ chainId: uint64(block.chainid), permits: permits });\n\n        // Validate witness type string format\n        _validateWitnessTypeString(witnessTypeString);\n\n        // Get hash of permits data\n        bytes32 permitDataHash = hashChainPermits(chainPermits);\n\n        // Compute witness-specific typehash and signed hash\n        bytes32 typeHash = _getWitnessTypeHash(witnessTypeString);\n        bytes32 signedHash = keccak256(abi.encode(typeHash, owner, salt, deadline, timestamp, permitDataHash, witness));\n\n        _useNonce(owner, salt);\n        _verifySignature(owner, signedHash, signature);\n        _processChainPermits(owner, timestamp, chainPermits);\n    }\n\n    // Helper struct to avoid stack-too-deep errors\n    struct WitnessParams {\n        address owner;\n        bytes32 salt;\n        uint48 deadline;\n        uint48 timestamp;\n        bytes32 witness;\n        bytes32 currentChainHash;\n        bytes32 merkleRoot;\n    }\n\n    /**\n     * @notice Process permit with additional witness data for cross-chain operations\n     * @dev Combines cross-chain merkle verification with custom witness data in signature\n     * @param owner Token owner address authorizing the operations\n     * @param salt Unique salt for replay protection and nonce management\n     * @param deadline Signature expiration timestamp for security\n     * @param timestamp Block timestamp when the permit was created\n     * @param permits Chain-specific permit operations to execute on current chain\n     * @param proof Merkle proof array proving permits belong to the signed batch\n     * @param witness Additional 32-byte data to include in signature verification\n     * @param witnessTypeString EIP-712 type definition string for the witness data structure\n     * @param signature EIP-712 signature authorizing the batch including witness data\n     */\n    function permitWitness(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        ChainPermits calldata permits,\n        bytes32[] calldata proof,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external {\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (permits.chainId != uint64(block.chainid)) {\n            revert WrongChainId(uint64(block.chainid), permits.chainId);\n        }\n\n        // Validate witness type string format\n        _validateWitnessTypeString(witnessTypeString);\n\n        // Use a struct to avoid stack-too-deep errors\n        WitnessParams memory params;\n        params.owner = owner;\n        params.salt = salt;\n        params.deadline = deadline;\n        params.timestamp = timestamp;\n        params.witness = witness;\n\n        // Hash current chain's permits\n        params.currentChainHash = hashChainPermits(permits);\n\n        // Calculate the merkle root\n        // processProof performs validation internally and provides granular error messages\n        params.merkleRoot = MerkleProof.processProof(proof, params.currentChainHash);\n\n        // Compute witness-specific typehash and signed hash\n        bytes32 typeHash = _getWitnessTypeHash(witnessTypeString);\n        bytes32 signedHash = keccak256(\n            abi.encode(\n                typeHash,\n                params.owner,\n                params.salt,\n                params.deadline,\n                params.timestamp,\n                params.merkleRoot,\n                params.witness\n            )\n        );\n\n        _useNonce(owner, salt);\n        _verifySignature(params.owner, signedHash, signature);\n        _processChainPermits(params.owner, params.timestamp, permits);\n    }\n\n    /**\n     * @dev Core permit processing logic that executes multiple permit operations in a single transaction\n     * @dev Internal function that handles both direct permits and signature-verified permits\n     * @param owner Token owner authorizing the operations\n     * @param timestamp Block timestamp for validation and allowance updates\n     * @param chainPermits Bundle of permit operations to process on the current chain\n     * @notice Handles multiple types of operations based on modeOrExpiration value:\n     *         - 0: Immediate transfer mode - transfers tokens directly without approval\n     *         - 1: Decrease allowance mode - reduces existing allowance by specified amount\n     *         - 2: Lock allowance mode - sets allowance to locked state preventing usage\n     *         - 3: Unlock allowance mode - removes lock from previously locked allowance\n     *         - >3: Increase allowance mode - adds to allowance with expiration timestamp\n     * @notice Enforces timestamp-based locking and handles MAX_ALLOWANCE for infinite approvals\n     */\n    function _processChainPermits(address owner, uint48 timestamp, ChainPermits memory chainPermits) internal {\n        uint256 permitsLength = chainPermits.permits.length;\n        for (uint256 i = 0; i < permitsLength; i++) {\n            AllowanceOrTransfer memory p = chainPermits.permits[i];\n\n            if (p.modeOrExpiration == uint48(PermitType.Transfer)) {\n                // Extract address from tokenKey for transfer\n                address token = address(uint160(uint256(p.tokenKey)));\n                _transferFrom(owner, p.account, p.amountDelta, token);\n            } else {\n                _processAllowanceOperation(owner, timestamp, p);\n            }\n        }\n    }\n\n    /**\n     * @dev Processes allowance-related operations for a single permit\n     * @param owner Token owner authorizing the operation\n     * @param timestamp Current timestamp for validation\n     * @param p The permit operation to process\n     */\n    function _processAllowanceOperation(address owner, uint48 timestamp, AllowanceOrTransfer memory p) private {\n        // Validate tokenKey is not zero\n        if (p.tokenKey == bytes32(0)) {\n            revert ZeroToken();\n        }\n\n        if (p.account == address(0)) {\n            revert ZeroAccount();\n        }\n\n        Allowance memory allowed = allowances[owner][p.tokenKey][p.account];\n\n        // Validate lock status before processing\n        _validateLockStatus(owner, p, allowed, p.modeOrExpiration, timestamp);\n\n        // Process the operation based on its type\n        if (p.modeOrExpiration == uint48(PermitType.Decrease)) {\n            _decreaseAllowance(allowed, p.amountDelta);\n        } else if (p.modeOrExpiration == uint48(PermitType.Lock)) {\n            _lockAllowance(allowed, timestamp);\n        } else if (p.modeOrExpiration == uint48(PermitType.Unlock)) {\n            _unlockAllowance(allowed);\n        } else {\n            _processIncreaseOrUpdate(allowed, p, timestamp);\n        }\n\n        // Check if tokenKey represents a clean address (upper 96 bits are zero)\n        // If yes, emit the regular Permit event from IPermit, otherwise emit the multi-token PermitMultiToken event\n        if (uint256(p.tokenKey) >> 160 == 0) {\n            // It's a clean address, emit regular Permit event for ERC20/collection-wide\n            emit Permit(\n                owner, address(uint160(uint256(p.tokenKey))), p.account, allowed.amount, allowed.expiration, timestamp\n            );\n        } else {\n            // It's a hash (NFT with tokenId), emit multi-token PermitMultiToken event with tokenKey\n            emit PermitMultiToken(owner, p.tokenKey, p.account, allowed.amount, allowed.expiration, timestamp);\n        }\n\n        allowances[owner][p.tokenKey][p.account] = allowed;\n    }\n\n    /**\n     * @dev Validates if an operation can proceed based on lock status\n     * @param owner Token owner\n     * @param p Permit operation being processed\n     * @param allowed Current allowance state\n     * @param operationType Type of operation being performed\n     * @param timestamp Current timestamp\n     */\n    function _validateLockStatus(\n        address owner,\n        AllowanceOrTransfer memory p,\n        Allowance memory allowed,\n        uint48 operationType,\n        uint48 timestamp\n    ) private pure {\n        if (allowed.expiration == LOCKED_ALLOWANCE) {\n            if (operationType == uint48(PermitType.Unlock)) {\n                // Only allow unlock if timestamp is newer than lock timestamp\n                if (timestamp <= allowed.timestamp) {\n                    // Decode address from tokenKey for error message\n                    revert AllowanceLocked(owner, p.tokenKey, p.account);\n                }\n            } else {\n                // For all other operations, reject if allowance is locked\n                revert AllowanceLocked(owner, p.tokenKey, p.account);\n            }\n        }\n    }\n\n    /**\n     * @dev Decreases an allowance, handling MAX_ALLOWANCE cases\n     * @param allowed Current allowance to modify\n     * @param amountDelta Amount to decrease by\n     */\n    function _decreaseAllowance(Allowance memory allowed, uint160 amountDelta) private pure {\n        if (allowed.amount != MAX_ALLOWANCE || amountDelta == MAX_ALLOWANCE) {\n            allowed.amount = amountDelta > allowed.amount ? 0 : allowed.amount - amountDelta;\n        }\n    }\n\n    /**\n     * @dev Locks an allowance to prevent further usage\n     * @param allowed Allowance to lock\n     * @param timestamp Current timestamp for lock tracking\n     */\n    function _lockAllowance(Allowance memory allowed, uint48 timestamp) private pure {\n        allowed.amount = 0;\n        allowed.expiration = LOCKED_ALLOWANCE;\n        allowed.timestamp = timestamp;\n    }\n\n    /**\n     * @dev Unlocks a previously locked allowance\n     * @param allowed Allowance to unlock\n     */\n    function _unlockAllowance(\n        Allowance memory allowed\n    ) private pure {\n        if (allowed.expiration == LOCKED_ALLOWANCE) {\n            allowed.expiration = 0;\n        }\n    }\n\n    /**\n     * @dev Processes increase operations and updates expiration/timestamp\n     * @param allowed Current allowance to modify\n     * @param p Permit operation containing new values\n     * @param timestamp Current timestamp\n     */\n    function _processIncreaseOrUpdate(\n        Allowance memory allowed,\n        AllowanceOrTransfer memory p,\n        uint48 timestamp\n    ) private view {\n        // Handle amount increase if specified\n        if (p.amountDelta > 0) {\n            _increaseAllowanceAmount(allowed, p.amountDelta);\n        }\n\n        // Update expiration and timestamp based on precedence rules\n        _updateExpirationAndTimestamp(allowed, p.modeOrExpiration, timestamp);\n    }\n\n    /**\n     * @dev Increases allowance amount, handling MAX_ALLOWANCE cases\n     * @param allowed Allowance to modify\n     * @param amountDelta Amount to increase by\n     */\n    function _increaseAllowanceAmount(Allowance memory allowed, uint160 amountDelta) private pure {\n        if (allowed.amount != MAX_ALLOWANCE) {\n            if (amountDelta == MAX_ALLOWANCE) {\n                allowed.amount = MAX_ALLOWANCE;\n            } else {\n                allowed.amount += amountDelta;\n            }\n        }\n    }\n\n    /**\n     * @dev Updates expiration and timestamp based on precedence rules\n     * @param allowed Allowance to modify\n     * @param newExpiration New expiration value\n     * @param timestamp Current timestamp\n     */\n    function _updateExpirationAndTimestamp(\n        Allowance memory allowed,\n        uint48 newExpiration,\n        uint48 timestamp\n    ) private view {\n        // Prevent setting timestamps in the future\n        if (block.timestamp < timestamp) {\n            revert InvalidTimestamp(timestamp, uint48(block.timestamp));\n        }\n\n        if (timestamp > allowed.timestamp) {\n            allowed.expiration = newExpiration;\n            allowed.timestamp = timestamp;\n        } else if (timestamp == allowed.timestamp && newExpiration > allowed.expiration) {\n            allowed.expiration = newExpiration;\n        }\n    }\n\n    /**\n     * @dev Validates that a witness type string is properly formatted for EIP-712 compliance\n     * @dev Internal function used by both permitWitness variants\n     * @param witnessTypeString The EIP-712 type string to validate (e.g., \"CustomData(uint256 value)\")\n     * @notice This function ensures proper EIP-712 formatting by checking:\n     *         - The string is not empty (length > 0)\n     *         - The string ends with a closing parenthesis ')' for valid type definition\n     * @notice Reverts with InvalidWitnessTypeString() if any validation fails\n     */\n    function _validateWitnessTypeString(\n        string calldata witnessTypeString\n    ) internal pure {\n        // Validate minimum length\n        if (bytes(witnessTypeString).length == 0) {\n            revert InvalidWitnessTypeString(witnessTypeString);\n        }\n\n        // Validate proper ending with closing parenthesis\n        uint256 witnessTypeStringLength = bytes(witnessTypeString).length;\n        if (bytes(witnessTypeString)[witnessTypeStringLength - 1] != \")\") {\n            revert InvalidWitnessTypeString(witnessTypeString);\n        }\n    }\n\n    /**\n     * @dev Constructs a complete witness type hash from type string and stub for EIP-712\n     * @dev Internal function that builds the full EIP-712 type string before hashing\n     * @param witnessTypeString The EIP-712 witness type string suffix to append (e.g., \"CustomData(uint256 value)\")\n     * @return typeHash The keccak256 hash of the complete EIP-712 type string\n     * @notice Combines PERMIT_WITNESS_TYPEHASH_STUB with witnessTypeString to create the full type definition\n     * @notice Example: stub + \"CustomData(uint256 value)\" becomes complete EIP-712 type string\n     */\n    function _getWitnessTypeHash(\n        string calldata witnessTypeString\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PERMIT_WITNESS_TYPEHASH_STUB, witnessTypeString));\n    }\n}\n",
        "IPermit3.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { INonceManager } from \"./INonceManager.sol\";\nimport { IPermit } from \"./IPermit.sol\";\n\n/**\n * @title IPermit3\n * @notice Interface for the Permit3 cross-chain token approval and transfer system using UnbalancedProofs\n */\ninterface IPermit3 is IPermit, INonceManager {\n    /**\n     * @notice Enum representing the type of permit operation\n     * @param Transfer Execute immediate transfer\n     * @param Decrease Decrease allowance\n     * @param Lock Lock allowance\n     * @param Unlock Unlock previously locked allowance\n     */\n    enum PermitType {\n        Transfer,\n        Decrease,\n        Lock,\n        Unlock\n    }\n\n    /**\n     * @notice Represents a token allowance modification or transfer operation\n     * @param modeOrExpiration Mode indicators:\n     *        = 0: Immediate transfer mode\n     *        = 1: Decrease allowance mode\n     *        = 2: Lock allowance mode\n     *        = 3: UnLock allowance mode\n     *        > 3: Increase allowance mode, new expiration for the allowance if the timestamp is recent\n     * @param tokenKey Encoded token identifier (bytes32):\n     *        - For ERC20: bytes32(uint256(uint160(address)))\n     *        - For ERC721/ERC1155: keccak256(abi.encodePacked(token, tokenId))\n     * @param account Transfer recipient (for mode 0) or approved spender (for allowance)\n     * @param amountDelta Allowance change or transfer amount:\n     *        - For transfer mode: Amount to transfer\n     *        - For allowance mode: Increases or decreases allowance\n     *           - 0: Only updates expiration\n     *           - type(uint160).max: Unlimited approval or decrease to 0.\n     */\n    struct AllowanceOrTransfer {\n        uint48 modeOrExpiration;\n        bytes32 tokenKey;\n        address account;\n        uint160 amountDelta;\n    }\n\n    /**\n     * @notice Struct grouping permits for a specific chain\n     * @param chainId Target chain identifier\n     * @param permits Array of permit operations for this chain\n     */\n    struct ChainPermits {\n        uint64 chainId;\n        AllowanceOrTransfer[] permits;\n    }\n\n    /**\n     * @notice Returns the witness typehash stub for EIP-712 signature verification\n     * @return The stub string for witness permit typehash\n     */\n    function PERMIT_WITNESS_TYPEHASH_STUB() external pure returns (string memory);\n\n    /**\n     * @notice Hashes chain permits data for cross-chain operations\n     * @param chainPermits Chain-specific permit data\n     * @return bytes32 Combined hash of all permit parameters\n     */\n    function hashChainPermits(\n        ChainPermits memory chainPermits\n    ) external pure returns (bytes32);\n\n    /**\n     * @notice Direct permit execution for ERC-7702 integration\n     * @dev No signature verification - caller must be the token owner\n     * @param permits Array of permit operations to execute on current chain\n     */\n    function permit(\n        AllowanceOrTransfer[] memory permits\n    ) external;\n\n    /**\n     * @notice Process permit for single chain token approvals\n     * @param owner Token owner address\n     * @param salt Unique salt for replay protection\n     * @param deadline Signature expiration timestamp\n     * @param timestamp Timestamp of the permit\n     * @param permits Array of permit operations to execute\n     * @param signature EIP-712 signature authorizing the permits\n     */\n    function permit(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        AllowanceOrTransfer[] calldata permits,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Process permit for multi-chain token approvals using Merkle Tree\n     * @param owner Token owner address\n     * @param salt Unique salt for replay protection\n     * @param deadline Signature expiration timestamp\n     * @param timestamp Timestamp of the permit\n     * @param permits Permit operations for the current chain\n     * @param proof Merkle proof array for verification\n     * @param signature EIP-712 signature authorizing the batch\n     */\n    function permit(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        ChainPermits calldata permits,\n        bytes32[] calldata proof,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Process permit with additional witness data for single chain operations\n     * @param owner Token owner address\n     * @param salt Unique salt for replay protection\n     * @param deadline Signature expiration timestamp\n     * @param timestamp Timestamp of the permit\n     * @param permits Array of permit operations to execute\n     * @param witness Additional data to include in signature verification\n     * @param witnessTypeString EIP-712 type definition for witness data\n     * @param signature EIP-712 signature authorizing the permits\n     */\n    function permitWitness(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        AllowanceOrTransfer[] calldata permits,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Process permit with additional witness data for cross-chain operations\n     * @param owner Token owner address\n     * @param salt Unique salt for replay protection\n     * @param deadline Signature expiration timestamp\n     * @param timestamp Timestamp of the permit\n     * @param permits Permit operations for the current chain\n     * @param proof Merkle proof array for verification\n     * @param witness Additional data to include in signature verification\n     * @param witnessTypeString EIP-712 type definition for witness data\n     * @param signature EIP-712 signature authorizing the batch\n     */\n    function permitWitness(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        ChainPermits calldata permits,\n        bytes32[] calldata proof,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n}\n"
    }
}