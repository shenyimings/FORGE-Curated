{
    "vfp_id": "vfp_00038",
    "project_name": "cantina_uniswap_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Execute calls can be front-run",
            "description": "1. **Description:** The `execute` function in the MinimalDelegation contract is publicly callable, allowing any external address to invoke it if a valid signature is provided. This enables front-running of execute calls by malicious actors.\n2. **Cause:** The lack of an intended executor address in the signature's domain separator allows any relayer to submit the transaction, removing execution exclusivity.\n3. **Exploitation:** An attacker can front-run a legitimate execute call with a zero-value transaction, potentially causing batched calls to revert, especially when `shouldRevert` is false, thereby disrupting the intended execution flow.\n4. **Impact:** This can lead to denial of service or manipulation of transaction outcomes, undermining the reliability of batched operations.\n",
            "severity": "High",
            "location": [
                "MinimalDelegation.sol::execute#66"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Execute calls can be forced to fail with an out of gas error",
            "description": "1. **Description:** The `execute` function allows a malicious user to specify a gas limit that is sufficient for the high-level validation but insufficient for the low-level `_dispatch` and `_execute` calls, causing them to fail with an out-of-gas error.\n2. **Cause:** The contract does not enforce a minimum gas limit for the execution phase, relying solely on the caller's gas allocation.\n3. **Exploitation:** An attacker can submit a transaction with a gas limit just above the threshold required for signature validation but below what is needed for the actual call execution, forcing the subcalls to revert.\n4. **Impact:** This can result in partial execution failure of batched calls, especially when `shouldRevert` is false, leading to inconsistent state changes and potential fund loss.\n",
            "severity": "High",
            "location": [
                "MinimalDelegation.sol::execute#66"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Potential double-counting allowance risk",
            "description": "1. **Description:** The MinimalDelegation wallet supports both persistent and transient native allowances. This dual mechanism could lead to confusion or unintended double-spending if both allowances are active for the same spender.\n2. **Cause:** The contract does not prevent setting a transient allowance when a persistent one already exists, creating overlapping permissions.\n3. **Exploitation:** A user or hook might unintentionally use both allowances in sequence, leading to higher-than-intended spending limits.\n4. **Impact:** While not directly exploitable by external attackers, this could lead to user error or misuse in complex delegation scenarios, potentially resulting in loss of funds.\n",
            "severity": "Low",
            "location": [
                "ERC7914.sol::approveNativeTransient#14-25"
            ],
            "files": [
                "minimal-delegation/src/ERC7914.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Potential privilege escalation in nonce management",
            "description": "1. **Description:** In the NonceManager, all keyHashes share the same nonce mapping. While only admin keys can invalidate entire nonce spaces, non-admin keys can invalidate specific nonces, enabling front-running of other keyHashes' execute calls.\n2. **Cause:** Centralized nonce management without segregation per keyHash.\n3. **Exploitation:** A non-admin key can sign a nonce invalidation to block another key's transaction, acting as a denial-of-service vector.\n4. **Impact:** This allows lower-privileged keys to interfere with higher-privileged ones, undermining the access control model.\n",
            "severity": "Low",
            "location": [
                "MinimalDelegation.sol::invalidateNonce#156-159"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-393"
                ]
            },
            "title": "_checkExpiry will revert if the signature is expired in validateUserOp",
            "description": "1. **Description:** When a signature is expired, `_checkExpiry(settings)` reverts with a `KeyExpired` error instead of returning `SIG_VALIDATION_FAILED` as required by EIP-4337.\n2. **Cause:** The function uses `revert` instead of returning a validation failure code.\n3. **Exploitation:** This deviation from the standard causes the entire UserOperation to revert rather than being marked as invalid, affecting bundler behavior.\n4. **Impact:** Non-compliance with EIP-4337 may lead to rejection by compliant bundlers and reduced interoperability.\n",
            "severity": "Low",
            "location": [
                "MinimalDelegation.sol::validateUserOp#142"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "HookData is not included in the signature digest",
            "description": "1. **Description:** The `hookData` parameter passed to `handleAfterVerifySignature` and `handleAfterIsValidSignature` is not included in the EIP-712 signature digest, allowing it to be arbitrarily modified by external callers.\n2. **Cause:** The signature covers only the core operation, not the hook data, making it untrusted input.\n3. **Exploitation:** An attacker can alter `hookData` in the `wrappedSignature`, causing the hook to execute with unintended parameters, potentially leading to unexpected behavior.\n4. **Impact:** The security of the hook logic depends on `hookData` integrity, which is compromised, leading to potential privilege escalation or state corruption depending on hook implementation.\n",
            "severity": "Informational",
            "location": [
                "MinimalDelegation.sol::handleAfterVerifySignature#127",
                "MinimalDelegation.sol::handleAfterIsValidSignature#127"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "MinimalDelegation EntryPoint compatibility",
            "description": "1. **Description:** The MinimalDelegation wallet is incompatible with EntryPoint v0.6.0 and earlier due to lack of `executeUserOp` support. It is compatible with later versions but lacks support for certain features like EIP-7702 in some versions.\n2. **Cause:** The contract was built against a different EntryPoint interface and does not implement the full `UserOperation` struct or required functions.\n3. **Exploitation:** Attempting to use the wallet with an incompatible EntryPoint version will result in transaction failure.\n4. **Impact:** Limits deployment flexibility and requires careful version matching, increasing operational complexity.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Use of unlicensed smart contracts",
            "description": "1. **Description:** All smart contracts in the codebase are currently unlicensed, which may create legal ambiguity for users and contributors.\n2. **Cause:** No open-source license was explicitly declared in the repository.\n3. **Exploitation:** Lack of a license may deter adoption or contribution due to uncertainty about usage rights.\n4. **Impact:** Potential legal risks and reduced community engagement due to unclear licensing terms.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "minimal-delegation/src/ERC7914.sol",
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-393"
                ]
            },
            "title": "When transferring 0 amount, ERC7914 is better to return true",
            "description": "1. **Description:** The ERC7914 contract returns `false` when transferring a zero amount, which is interpreted as a failed transfer, though no value is moved.\n2. **Cause:** The transfer logic does not treat zero-value transfers as successful by default.\n3. **Exploitation:** External systems relying on the return value may incorrectly flag zero transfers as failures.\n4. **Impact:** Can lead to incorrect state assumptions in integrations, affecting accounting or event handling logic.\n",
            "severity": "Informational",
            "location": [
                "ERC7914.sol::transfer#28-37"
            ],
            "files": [
                "minimal-delegation/src/ERC7914.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "_execute() may call handleAfterExecute() on stale hook",
            "description": "1. **Description:** In `_execute()`, the `handleAfterExecute()` function is called on a hook that was cached before the `to.call()` execution. If the call updates the hook via `KeyManagement.update()`, the after-hook may execute on an outdated hook address.\n2. **Cause:** The hook address is not reloaded after the main call execution.\n3. **Exploitation:** An attacker could manipulate the hook update flow to force execution of an old, potentially vulnerable or unintended hook.\n4. **Impact:** May lead to unexpected behavior or security issues if the stale hook has different logic than the current one.\n",
            "severity": "Informational",
            "location": [
                "MinimalDelegation.sol::_execute#109-117"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "validateUserOp() should not return early when the signature is invalid",
            "description": "1. **Description:** According to EIP-4337, `validateUserOp()` should not return early on invalid signatures but should continue validation. However, the current implementation returns early, deviating from the standard.\n2. **Cause:** The function uses early returns instead of proceeding to return a validation failure code.\n3. **Exploitation:** This can cause bundlers to misinterpret the validation result, potentially leading to incorrect inclusion or rejection of UserOperations.\n4. **Impact:** Non-compliance with EIP-4337 may result in interoperability issues with standard-compliant infrastructure.\n",
            "severity": "Informational",
            "location": [
                "MinimalDelegation.sol::validateUserOp#137-153"
            ],
            "files": [
                "minimal-delegation/src/MinimalDelegation.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC7914.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {IERC7914} from \"./interfaces/IERC7914.sol\";\nimport {TransientAllowance} from \"./libraries/TransientAllowance.sol\";\nimport {BaseAuthorization} from \"./BaseAuthorization.sol\";\n\n/// @title ERC-7914\n/// @notice Abstract ERC-7914 implementation\nabstract contract ERC7914 is IERC7914, BaseAuthorization {\n    mapping(address spender => uint256 allowance) public allowance;\n\n    /// @inheritdoc IERC7914\n    function approveNative(address spender, uint256 amount) external onlyThis returns (bool) {\n        allowance[spender] = amount;\n        emit ApproveNative(address(this), spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC7914\n    function approveNativeTransient(address spender, uint256 amount) external onlyThis returns (bool) {\n        TransientAllowance.set(spender, amount);\n        emit ApproveNativeTransient(address(this), spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC7914\n    function transferFromNative(address from, address recipient, uint256 amount) external returns (bool) {\n        if (amount == 0) return false;\n        _transferFrom(from, recipient, amount, false);\n        emit TransferFromNative(address(this), recipient, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC7914\n    function transferFromNativeTransient(address from, address recipient, uint256 amount) external returns (bool) {\n        if (amount == 0) return false;\n        _transferFrom(from, recipient, amount, true);\n        emit TransferFromNativeTransient(address(this), recipient, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC7914\n    function transientAllowance(address spender) public view returns (uint256) {\n        return TransientAllowance.get(spender);\n    }\n\n    /// @dev Internal function to validate and execute transfers\n    /// @param from The address to transfer from\n    /// @param recipient The address to receive the funds\n    /// @param amount The amount to transfer\n    /// @param isTransient Whether this is transient allowance or not\n    function _transferFrom(address from, address recipient, uint256 amount, bool isTransient) internal {\n        // Validate inputs\n        if (from != address(this)) revert IncorrectSender();\n\n        // Check allowance\n        uint256 currentAllowance = isTransient ? transientAllowance(msg.sender) : allowance[msg.sender];\n        if (currentAllowance < amount) revert AllowanceExceeded();\n\n        // Update allowance\n        if (currentAllowance < type(uint256).max) {\n            uint256 newAllowance;\n            unchecked {\n                newAllowance = currentAllowance - amount;\n            }\n            if (isTransient) {\n                TransientAllowance.set(msg.sender, newAllowance);\n            } else {\n                allowance[msg.sender] = newAllowance;\n            }\n        }\n\n        // Execute transfer\n        (bool success,) = payable(recipient).call{value: amount}(\"\");\n        if (!success) {\n            revert TransferNativeFailed();\n        }\n    }\n}\n",
        "MinimalDelegation.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.29;\n\nimport {EnumerableSetLib} from \"solady/utils/EnumerableSetLib.sol\";\nimport {Receiver} from \"solady/accounts/Receiver.sol\";\nimport {IMinimalDelegation} from \"./interfaces/IMinimalDelegation.sol\";\nimport {Call, CallLib} from \"./libraries/CallLib.sol\";\nimport {IKeyManagement} from \"./interfaces/IKeyManagement.sol\";\nimport {Key, KeyLib, KeyType} from \"./libraries/KeyLib.sol\";\nimport {ModeDecoder} from \"./libraries/ModeDecoder.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {IERC1271} from \"./interfaces/IERC1271.sol\";\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC7201} from \"./ERC7201.sol\";\nimport {CalldataDecoder} from \"./libraries/CalldataDecoder.sol\";\nimport {P256} from \"@openzeppelin/contracts/utils/cryptography/P256.sol\";\nimport {PackedUserOperation} from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport {NonceManager} from \"./NonceManager.sol\";\nimport {IAccount} from \"account-abstraction/interfaces/IAccount.sol\";\nimport {ERC4337Account} from \"./ERC4337Account.sol\";\nimport {IERC4337Account} from \"./interfaces/IERC4337Account.sol\";\nimport {WrappedDataHash} from \"./libraries/WrappedDataHash.sol\";\nimport {ERC7914} from \"./ERC7914.sol\";\nimport {SignedBatchedCallLib, SignedBatchedCall} from \"./libraries/SignedBatchedCallLib.sol\";\nimport {BatchedCallLib, BatchedCall} from \"./libraries/BatchedCallLib.sol\";\nimport {KeyManagement} from \"./KeyManagement.sol\";\nimport {IHook} from \"./interfaces/IHook.sol\";\nimport {HooksLib} from \"./libraries/HooksLib.sol\";\nimport {ModeDecoder} from \"./libraries/ModeDecoder.sol\";\nimport {Settings, SettingsLib} from \"./libraries/SettingsLib.sol\";\nimport {Static} from \"./libraries/Static.sol\";\nimport {ERC7821} from \"./ERC7821.sol\";\nimport {IERC7821} from \"./interfaces/IERC7821.sol\";\nimport {Multicall} from \"./Multicall.sol\";\n\ncontract MinimalDelegation is\n    IMinimalDelegation,\n    ERC7821,\n    ERC1271,\n    EIP712,\n    ERC4337Account,\n    Receiver,\n    KeyManagement,\n    NonceManager,\n    ERC7914,\n    ERC7201,\n    Multicall\n{\n    using ModeDecoder for bytes32;\n    using KeyLib for *;\n    using EnumerableSetLib for EnumerableSetLib.Bytes32Set;\n    using CalldataDecoder for bytes;\n    using WrappedDataHash for bytes32;\n    using CallLib for Call[];\n    using BatchedCallLib for BatchedCall;\n    using SignedBatchedCallLib for SignedBatchedCall;\n    using HooksLib for IHook;\n    using SettingsLib for Settings;\n\n    function execute(BatchedCall memory batchedCall) public payable {\n        bytes32 keyHash = msg.sender.toKeyHash();\n        if (!_isOwnerOrAdmin(keyHash)) revert Unauthorized();\n        _dispatch(batchedCall, keyHash);\n    }\n\n    function execute(SignedBatchedCall memory signedBatchedCall, bytes memory wrappedSignature) public payable {\n        _handleVerifySignature(signedBatchedCall, wrappedSignature);\n        _dispatch(signedBatchedCall.batchedCall, signedBatchedCall.keyHash);\n    }\n\n    function execute(bytes32 mode, bytes memory executionData) external payable override {\n        if (!mode.isBatchedCall()) revert IERC7821.UnsupportedExecutionMode();\n        Call[] memory calls = abi.decode(executionData, (Call[]));\n        BatchedCall memory batchedCall = BatchedCall({calls: calls, shouldRevert: mode.shouldRevert()});\n        execute(batchedCall);\n    }\n\n    /// @dev This function is executeable only by the EntryPoint contract, and is the main pathway for UserOperations to be executed.\n    /// UserOperations can be executed through the execute function, but another method of authorization (ie through a passed in signature) is required.\n    /// userOp.callData is abi.encodeCall(IAccountExecute.executeUserOp.selector, (abi.encode(Call[]), bool))\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32) external onlyEntryPoint {\n        // Parse the keyHash from the signature. This is the keyHash that has been pre-validated as the correct signer over the UserOp data\n        // and must be used to check further on-chain permissions over the call execution.\n        (bytes32 keyHash,,) = abi.decode(userOp.signature, (bytes32, bytes, bytes));\n\n        // The mode is only passed in to signify the EXEC_TYPE of the calls.\n        bytes calldata executionData = userOp.callData.removeSelector();\n        (BatchedCall memory batchedCall) = abi.decode(executionData, (BatchedCall));\n\n        _dispatch(batchedCall, keyHash);\n    }\n\n    function _dispatch(BatchedCall memory batchedCall, bytes32 keyHash) private {\n        for (uint256 i = 0; i < batchedCall.calls.length; i++) {\n            (bool success, bytes memory output) = _execute(batchedCall.calls[i], keyHash);\n            // Reverts with the first call that is unsuccessful if the EXEC_TYPE is set to force a revert.\n            if (!success && batchedCall.shouldRevert) revert IMinimalDelegation.CallFailed(output);\n        }\n    }\n\n    /// @dev Executes a low level call using execution hooks if set\n    function _execute(Call memory _call, bytes32 keyHash) internal returns (bool success, bytes memory output) {\n        // Per ERC7821, replace address(0) with address(this)\n        address to = _call.to == address(0) ? address(this) : _call.to;\n\n        Settings settings = getKeySettings(keyHash);\n        if (!settings.isAdmin() && to == address(this)) revert IKeyManagement.OnlyAdminCanSelfCall();\n\n        IHook hook = settings.hook();\n        bytes memory beforeExecuteData;\n        if (hook.hasPermission(HooksLib.BEFORE_EXECUTE_FLAG)) {\n            beforeExecuteData = hook.handleBeforeExecute(keyHash, to, _call.value, _call.data);\n        }\n\n        (success, output) = to.call{value: _call.value}(_call.data);\n\n        if (hook.hasPermission(HooksLib.AFTER_EXECUTE_FLAG)) hook.handleAfterExecute(keyHash, beforeExecuteData);\n    }\n\n    /// @inheritdoc IAccount\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n        external\n        onlyEntryPoint\n        returns (uint256 validationData)\n    {\n        _payEntryPoint(missingAccountFunds);\n        (bytes32 keyHash, bytes memory signature, bytes memory hookData) =\n            abi.decode(userOp.signature, (bytes32, bytes, bytes));\n\n        /// The userOpHash does not need to be safe hashed with _hashTypedData, as the EntryPoint will always call the sender contract of the UserOperation for validation.\n        /// It is possible that the signature is a wrapped signature, so any supported key can be used to validate the signature.\n        /// This is because the signature field is not defined by the protocol, but by the account implementation. See https://eips.ethereum.org/EIPS/eip-4337#definitions\n        Key memory key = getKey(keyHash);\n        bool isValid = key.verify(userOpHash, signature);\n\n        // If signature verification failed, return failure immediately WITHOUT expiry as it cannot be trusted\n        if (!isValid) {\n            return SIG_VALIDATION_FAILED;\n        }\n\n        Settings settings = getKeySettings(keyHash);\n        _checkExpiry(settings);\n\n        /// validationData is (uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)\n        /// `validAfter` is always 0.\n        validationData = uint256(settings.expiration()) << 160 | SIG_VALIDATION_SUCCEEDED;\n\n        IHook hook = settings.hook();\n        if (hook.hasPermission(HooksLib.AFTER_VALIDATE_USER_OP_FLAG)) {\n            // The hook can override the validation data\n            validationData = hook.handleAfterValidateUserOp(keyHash, userOp, userOpHash, hookData);\n        }\n    }\n\n    /// @dev This function is used to handle the verification of signatures sent through execute()\n    function _handleVerifySignature(SignedBatchedCall memory signedBatchedCall, bytes memory wrappedSignature)\n        private\n    {\n        _useNonce(signedBatchedCall.nonce);\n\n        (bytes memory signature, bytes memory hookData) = abi.decode(wrappedSignature, (bytes, bytes));\n\n        bytes32 digest = _hashTypedData(signedBatchedCall.hash());\n\n        Key memory key = getKey(signedBatchedCall.keyHash);\n        bool isValid = key.verify(digest, signature);\n        if (!isValid) revert IMinimalDelegation.InvalidSignature();\n\n        Settings settings = getKeySettings(signedBatchedCall.keyHash);\n        _checkExpiry(settings);\n\n        IHook hook = settings.hook();\n        if (hook.hasPermission(HooksLib.AFTER_VERIFY_SIGNATURE_FLAG)) {\n            // Hook must revert to signal that signature verification\n            hook.handleAfterVerifySignature(signedBatchedCall.keyHash, digest, hookData);\n        }\n    }\n\n    /// @notice Reverts if the key settings are expired\n    function _checkExpiry(Settings settings) private view {\n        (bool isExpired, uint40 expiry) = settings.isExpired();\n        if (isExpired) revert IKeyManagement.KeyExpired(expiry);\n    }\n\n    /// @inheritdoc ERC1271\n    function isValidSignature(bytes32 data, bytes calldata wrappedSignature)\n        public\n        view\n        override(ERC1271, IERC1271)\n        returns (bytes4 result)\n    {\n        (bytes32 keyHash, bytes memory signature, bytes memory hookData) =\n            abi.decode(wrappedSignature, (bytes32, bytes, bytes));\n        bytes32 digest = _hashTypedData(data.hashWithWrappedType());\n\n        Key memory key = getKey(keyHash);\n        bool isValid = key.verify(digest, signature);\n        if (!isValid) return _1271_INVALID_VALUE;\n        result = _1271_MAGIC_VALUE;\n\n        Settings settings = getKeySettings(keyHash);\n        _checkExpiry(settings);\n\n        IHook hook = settings.hook();\n        if (hook.hasPermission(HooksLib.AFTER_IS_VALID_SIGNATURE_FLAG)) {\n            // Hook can override the result\n            result = hook.handleAfterIsValidSignature(keyHash, digest, hookData);\n        }\n    }\n}\n"
    }
}