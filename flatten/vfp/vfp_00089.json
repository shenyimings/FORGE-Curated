{
    "vfp_id": "vfp_00089",
    "project_name": "cantina_sky_jul2025.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Consistent IRateLimits rateLimits parameter order",
            "description": "The PSMLib library functions _rateLimited and _cancelRateLimit take the IRateLimits parameter as the last argument, while other similar helper functions in the codebase take controller state variables as the first parameter. This inconsistency breaks established patterns and reduces code readability and maintainability. The root cause is a deviation from internal coding conventions. There is no direct security impact or exploit path. The impact is purely on code quality, making the codebase harder to navigate and increasing the risk of developer errors during future modifications.\n",
            "severity": "Informational",
            "location": [
                "PSMLib.sol#L156-L162"
            ],
            "files": [
                "spark-alm-controller/src/libraries/PSMLib.sol"
            ]
        }
    ],
    "affected_files": {
        "PSMLib.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IERC20 } from \"forge-std/interfaces/IERC20.sol\";\n\nimport { IRateLimits }  from \"../interfaces/IRateLimits.sol\";\nimport { IALMProxy }    from \"../interfaces/IALMProxy.sol\";\n\nimport { RateLimitHelpers } from \"../RateLimitHelpers.sol\";\n\ninterface IDaiUsdsLike {\n    function dai() external view returns (address);\n    function daiToUsds(address usr, uint256 wad) external;\n    function usdsToDai(address usr, uint256 wad) external;\n}\n\ninterface IPSMLike {\n    function buyGemNoFee(address usr, uint256 usdcAmount) external returns (uint256 usdsAmount);\n    function fill() external returns (uint256 wad);\n    function gem() external view returns (address);\n    function sellGemNoFee(address usr, uint256 usdcAmount) external returns (uint256 usdsAmount);\n    function to18ConversionFactor() external view returns (uint256);\n}\n\nlibrary PSMLib {\n\n    /**********************************************************************************************/\n    /*** Structs                                                                                ***/\n    /**********************************************************************************************/\n\n    struct SwapUSDSToUSDCParams {\n        IALMProxy    proxy;\n        IRateLimits  rateLimits;\n        IDaiUsdsLike daiUsds;\n        IPSMLike     psm;\n        IERC20       usds;\n        IERC20       dai;\n        bytes32      rateLimitId;\n        uint256      usdcAmount;\n        uint256      psmTo18ConversionFactor;\n    }\n\n    struct SwapUSDCToUSDSParams {\n        IALMProxy    proxy;\n        IRateLimits  rateLimits;\n        IDaiUsdsLike daiUsds;\n        IPSMLike     psm;\n        IERC20       dai;\n        IERC20       usdc;\n        bytes32      rateLimitId;\n        uint256      usdcAmount;\n        uint256      psmTo18ConversionFactor;\n    }\n\n    /**********************************************************************************************/\n    /*** External functions                                                                     ***/\n    /**********************************************************************************************/\n\n    function swapUSDSToUSDC(SwapUSDSToUSDCParams calldata params) external {\n        _rateLimited(params.rateLimitId, params.usdcAmount, params.rateLimits);\n\n        uint256 usdsAmount = params.usdcAmount * params.psmTo18ConversionFactor;\n\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(params.proxy, address(params.usds), address(params.daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        params.proxy.doCall(\n            address(params.daiUsds),\n            abi.encodeCall(params.daiUsds.usdsToDai, (address(params.proxy), usdsAmount))\n        );\n\n        // Approve DAI to PSM from the proxy because conversion from USDS to DAI was 1:1\n        _approve(params.proxy, address(params.dai), address(params.psm), usdsAmount);\n\n        // Swap DAI to USDC through the PSM\n        params.proxy.doCall(\n            address(params.psm),\n            abi.encodeCall(params.psm.buyGemNoFee, (address(params.proxy), params.usdcAmount))\n        );\n    }\n\n    function swapUSDCToUSDS(SwapUSDCToUSDSParams calldata params) external {\n        _cancelRateLimit(params.rateLimitId, params.usdcAmount, params.rateLimits);\n\n        // Approve USDC to PSM from the proxy (assumes the proxy has enough USDC)\n        _approve(params.proxy, address(params.usdc), address(params.psm), params.usdcAmount);\n\n        // Max USDC that can be swapped to DAI in one call\n        uint256 limit = params.dai.balanceOf(address(params.psm)) / params.psmTo18ConversionFactor;\n\n        if (params.usdcAmount <= limit) {\n            _swapUSDCToDAI(params.proxy, params.psm, params.usdcAmount);\n        } else {\n            uint256 remainingUsdcToSwap = params.usdcAmount;\n\n            // Refill the PSM with DAI as many times as needed to get to the full `usdcAmount`.\n            // If the PSM cannot be filled with the full amount, psm.fill() will revert\n            // with `DssLitePsm/nothing-to-fill` since rush() will return 0.\n            // This is desired behavior because this function should only succeed if the full\n            // `usdcAmount` can be swapped.\n            while (remainingUsdcToSwap > 0) {\n                params.psm.fill();\n\n                limit = params.dai.balanceOf(address(params.psm)) / params.psmTo18ConversionFactor;\n\n                uint256 swapAmount = remainingUsdcToSwap < limit ? remainingUsdcToSwap : limit;\n\n                _swapUSDCToDAI(params.proxy, params.psm, swapAmount);\n\n                remainingUsdcToSwap -= swapAmount;\n            }\n        }\n\n        uint256 daiAmount = params.usdcAmount * params.psmTo18ConversionFactor;\n\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(params.proxy, address(params.dai), address(params.daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        params.proxy.doCall(\n            address(params.daiUsds),\n            abi.encodeCall(params.daiUsds.daiToUsds, (address(params.proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Helper functions                                                                       ***/\n    /**********************************************************************************************/\n\n    // NOTE: As swaps are only done between USDC and USDS and vice versa, using `_forceApprove` \n    //       is unnecessary.\n    function _approve(\n        IALMProxy proxy,\n        address   token,\n        address   spender,\n        uint256   amount\n    )\n        internal\n    {\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, amount)));\n    }\n\n    function _swapUSDCToDAI(IALMProxy proxy, IPSMLike psm, uint256 usdcAmount) internal {\n        // Swap USDC to DAI through the PSM (1:1 since sellGemNoFee is used)\n        proxy.doCall(\n            address(psm),\n            abi.encodeCall(psm.sellGemNoFee, (address(proxy), usdcAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Rate Limit helper functions                                                            ***/\n    /**********************************************************************************************/\n\n    function _rateLimited(bytes32 key, uint256 amount, IRateLimits rateLimits) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n    function _cancelRateLimit(bytes32 key, uint256 amount, IRateLimits rateLimits) internal {\n        rateLimits.triggerRateLimitIncrease(key, amount);\n    }\n\n}\n"
    }
}