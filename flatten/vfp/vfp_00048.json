{
    "vfp_id": "vfp_00048",
    "project_name": "ChainSecurity_MellowFinance_Multivault_Audit.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Gas Optimizations",
            "description": "The `EigenLayerWithdrawalQueue.transferPendingAssets` loop continues iterating even after `amount` reaches zero, missing an opportunity to exit early and save gas. The loop condition does not check for `amount == 0` and the comparison uses `<=` instead of `<`, delaying the exit. Unnecessary iterations increase gas consumption, especially in scenarios with many small withdrawals. Higher transaction costs for users and reduced efficiency in withdrawal processing.\n",
            "severity": "Informational",
            "location": [
                "EigenLayerWithdrawalQueue.transferPendingAssets"
            ],
            "files": [
                "simple-lrt/src/queues/EigenLayerWithdrawalQueue.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Incomplete Deletion of Shares",
            "description": "When a user withdraws all shares in `EigenLayerWithdrawalQueue._handleWithdrawal`, the `sharesOf` mapping is not deleted, causing the sum of shares to potentially exceed total shares. The function deletes `_withdrawals[withdrawalIndex]` but omits `delete sharesOf[account]`. This can amplify DoS risks in withdrawal processing due to incorrect share tracking. Inaccurate accounting may lead to inconsistencies in share balances and increased vulnerability to denial-of-service attacks.\n",
            "severity": "Informational",
            "location": [
                "EigenLayerWithdrawalQueue._handleWithdrawal"
            ],
            "files": [
                "simple-lrt/src/queues/EigenLayerWithdrawalQueue.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Return Value Not Used",
            "description": "The return value of `EigenLayerWithdrawalQueue._pull` is never used, indicating either dead code or a missed validation check. The function returns a value (likely success or amount), but callers ignore it. If the return value indicates failure, ignoring it could lead to incorrect state transitions. Reduced code clarity and potential for silent failures if the return value was meant to be checked.\n",
            "severity": "Informational",
            "location": [
                "EigenLayerWithdrawalQueue._pull"
            ],
            "files": [
                "simple-lrt/src/queues/EigenLayerWithdrawalQueue.sol"
            ]
        }
    ],
    "affected_files": {
        "EigenLayerWithdrawalQueue.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.25;\n\nimport \"../interfaces/queues/IEigenLayerWithdrawalQueue.sol\";\n\ncontract EigenLayerWithdrawalQueue is IEigenLayerWithdrawalQueue, Initializable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    uint256 public constant MAX_WITHDRAWALS = 14;\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    address public immutable claimer;\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    address public immutable delegation;\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    address public isolatedVault;\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    address public strategy;\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    address public operator;\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    bool public isShutdown;\n\n    WithdrawalData[] internal _withdrawals;\n    mapping(address account => AccountData) internal _accountData;\n\n    constructor(address claimer_, address delegation_) {\n        claimer = claimer_;\n        delegation = delegation_;\n        _disableInitializers();\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function initialize(address isolatedVault_, address strategy_, address operator_)\n        public\n        virtual\n        initializer\n    {\n        __init_EigenLayerWithdrawalQueue(isolatedVault_, strategy_, operator_);\n    }\n\n    /// --------------- EXTERNAL VIEW FUNCTIONS ---------------\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function latestWithdrawableBlock() public view returns (uint256) {\n        IStrategy[] memory strategies = new IStrategy[](1);\n        strategies[0] = IStrategy(strategy);\n        return block.number - IDelegationManager(delegation).getWithdrawalDelay(strategies);\n    }\n\n    /// @inheritdoc IWithdrawalQueue\n    function pendingAssetsOf(address account) public view returns (uint256 assets) {\n        AccountData storage accountData_ = _accountData[account];\n        uint256[] memory indices = accountData_.withdrawals.values();\n        uint256 block_ = latestWithdrawableBlock();\n        uint256 shares = 0;\n        for (uint256 i = 0; i < indices.length; i++) {\n            WithdrawalData storage withdrawal = _withdrawals[indices[i]];\n            if (block_ < withdrawal.data.startBlock) {\n                shares += withdrawal.sharesOf[account];\n            }\n        }\n        assets = shares == 0\n            ? 0\n            : IIsolatedEigenLayerVault(isolatedVault).sharesToUnderlyingView(strategy, shares);\n    }\n\n    /// @inheritdoc IWithdrawalQueue\n    function claimableAssetsOf(address account) public view returns (uint256 assets) {\n        AccountData storage accountData_ = _accountData[account];\n        uint256[] memory indices = accountData_.withdrawals.values();\n        uint256 block_ = latestWithdrawableBlock();\n        uint256 shares = 0;\n        for (uint256 i = 0; i < indices.length; i++) {\n            WithdrawalData storage withdrawal = _withdrawals[indices[i]];\n            if (withdrawal.isClaimed) {\n                uint256 totalShares = withdrawal.shares;\n                uint256 accountShares = withdrawal.sharesOf[account];\n                assets += totalShares == accountShares\n                    ? withdrawal.assets\n                    : withdrawal.assets.mulDiv(accountShares, totalShares);\n            } else if (block_ >= withdrawal.data.startBlock) {\n                shares += withdrawal.sharesOf[account];\n            }\n        }\n        assets += accountData_.claimableAssets;\n        assets += shares == 0\n            ? 0\n            : IIsolatedEigenLayerVault(isolatedVault).sharesToUnderlyingView(strategy, shares);\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function getAccountData(\n        address account,\n        uint256 withdrawalsLimit,\n        uint256 withdrawalsOffset,\n        uint256 transferredWithdrawalsLimit,\n        uint256 transferredWithdrawalsOffset\n    )\n        external\n        view\n        returns (\n            uint256 claimableAssets,\n            uint256[] memory withdrawals,\n            uint256[] memory transferredWithdrawals\n        )\n    {\n        AccountData storage accountData_ = _accountData[account];\n        claimableAssets = accountData_.claimableAssets;\n        {\n            EnumerableSet.UintSet storage withdrawals_ = accountData_.withdrawals;\n            uint256 length = withdrawals_.length();\n            if (withdrawalsOffset < length) {\n                uint256 count = (length - withdrawalsOffset).min(withdrawalsLimit);\n                withdrawals = new uint256[](count);\n                for (uint256 i = 0; i < count; i++) {\n                    withdrawals[i] = withdrawals_.at(i + withdrawalsOffset);\n                }\n            }\n        }\n        {\n            EnumerableSet.UintSet storage withdrawals_ = accountData_.transferredWithdrawals;\n            uint256 length = withdrawals_.length();\n            if (transferredWithdrawalsOffset < length) {\n                uint256 count =\n                    (length - transferredWithdrawalsOffset).min(transferredWithdrawalsLimit);\n                transferredWithdrawals = new uint256[](count);\n                for (uint256 i = 0; i < count; i++) {\n                    transferredWithdrawals[i] = withdrawals_.at(i + transferredWithdrawalsOffset);\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function getWithdrawalRequest(uint256 index, address account)\n        external\n        view\n        returns (IDelegationManager.Withdrawal memory, bool, uint256, uint256, uint256)\n    {\n        WithdrawalData storage withdrawal = _withdrawals[index];\n        return (\n            withdrawal.data,\n            withdrawal.isClaimed,\n            withdrawal.assets,\n            withdrawal.shares,\n            withdrawal.sharesOf[account]\n        );\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function withdrawalRequests() external view returns (uint256) {\n        return _withdrawals.length;\n    }\n\n    /// --------------- EXTERNAL MUTABLE FUNCTIONS ---------------\n\n    function request(address account, uint256 assets, bool isSelfRequested) public {\n        address isolatedVault_ = isolatedVault;\n        require(msg.sender == isolatedVault_, \"EigenLayerWithdrawalQueue: forbidden\");\n        handleWithdrawals(account);\n        IStrategy[] memory strategies = new IStrategy[](1);\n        uint256[] memory shares = new uint256[](1);\n        strategies[0] = IStrategy(strategy);\n        shares[0] = IIsolatedEigenLayerVault(isolatedVault_).underlyingToSharesView(\n            address(strategies[0]), assets\n        );\n        if (shares[0] == 0) {\n            // nothing to withdraw\n            return;\n        }\n        IDelegationManager delegationManager = IDelegationManager(delegation);\n\n        IDelegationManager.Withdrawal memory data = IDelegationManager.Withdrawal({\n            staker: isolatedVault_,\n            delegatedTo: operator,\n            withdrawer: isolatedVault_,\n            nonce: delegationManager.cumulativeWithdrawalsQueued(isolatedVault_),\n            startBlock: uint32(block.number),\n            strategies: strategies,\n            shares: shares\n        });\n\n        IDelegationManager.QueuedWithdrawalParams[] memory requests =\n            new IDelegationManager.QueuedWithdrawalParams[](1);\n        requests[0] = IDelegationManager.QueuedWithdrawalParams(strategies, shares, isolatedVault_);\n        IIsolatedEigenLayerVault(isolatedVault_).queueWithdrawals(delegationManager, requests);\n\n        uint256 withdrawalIndex = _pushRequest(data, account, isSelfRequested, false);\n        emit Request(account, withdrawalIndex, assets, isSelfRequested);\n    }\n\n    /// @inheritdoc IWithdrawalQueue\n    function transferPendingAssets(address to, uint256 amount) public {\n        address from = msg.sender;\n        if (amount == 0 || from == to) {\n            return;\n        }\n        handleWithdrawals(from);\n        AccountData storage accountDataFrom = _accountData[from];\n        AccountData storage accountDataTo = _accountData[to];\n        uint256 pendingWithdrawals = accountDataFrom.withdrawals.length();\n        IIsolatedEigenLayerVault isolatedVault_ = IIsolatedEigenLayerVault(isolatedVault);\n        for (uint256 i = 0; i < pendingWithdrawals;) {\n            uint256 withdrawalIndex = accountDataFrom.withdrawals.at(i);\n            mapping(address => uint256) storage balances = _withdrawals[withdrawalIndex].sharesOf;\n            uint256 accountShares;\n            uint256 accountAssets;\n            {\n                WithdrawalData storage withdrawal = _withdrawals[withdrawalIndex];\n                accountShares = balances[from];\n                accountAssets = withdrawal.isClaimed\n                    ? withdrawal.assets.mulDiv(accountShares, withdrawal.shares)\n                    : isolatedVault_.sharesToUnderlyingView(strategy, accountShares);\n            }\n            if (accountAssets == 0) {\n                i++;\n            } else if (accountAssets <= amount) {\n                delete balances[from];\n                balances[to] += accountShares;\n                emit Transfer(from, to, withdrawalIndex, accountShares);\n                accountDataFrom.withdrawals.remove(withdrawalIndex);\n                amount -= accountAssets;\n                pendingWithdrawals--;\n                if (!accountDataTo.withdrawals.contains(withdrawalIndex)) {\n                    accountDataTo.transferredWithdrawals.add(withdrawalIndex);\n                }\n                if (amount == 0) {\n                    return;\n                }\n            } else {\n                uint256 shares_ = accountShares.mulDiv(amount, accountAssets);\n                if (shares_ == 0) {\n                    return;\n                }\n                balances[from] -= shares_;\n                balances[to] += shares_;\n                emit Transfer(from, to, withdrawalIndex, shares_);\n                if (!accountDataTo.withdrawals.contains(withdrawalIndex)) {\n                    accountDataTo.transferredWithdrawals.add(withdrawalIndex);\n                }\n                return;\n            }\n        }\n        if (amount != 0) {\n            revert(\"EigenLayerWithdrawalQueue: insufficient pending assets\");\n        }\n    }\n\n    /// @inheritdoc IWithdrawalQueue\n    function pull(uint256 withdrawalIndex) public {\n        if (withdrawalIndex >= _withdrawals.length) {\n            revert(\"EigenLayerWithdrawalQueue: invalid withdrawal index\");\n        }\n        WithdrawalData storage withdrawal = _withdrawals[withdrawalIndex];\n        if (withdrawal.isClaimed) {\n            return;\n        }\n        IDelegationManager.Withdrawal memory data = withdrawal.data;\n        if (\n            data.startBlock + IDelegationManager(delegation).getWithdrawalDelay(data.strategies)\n                <= block.number\n        ) {\n            _pull(withdrawal, withdrawalIndex);\n        }\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function handleWithdrawals(address account) public {\n        AccountData storage accountData_ = _accountData[account];\n        EnumerableSet.UintSet storage withdrawals_ = accountData_.withdrawals;\n        uint256 block_ = latestWithdrawableBlock();\n        uint256[] memory indices = withdrawals_.values();\n        uint256 index;\n        for (uint256 i = 0; i < indices.length; i++) {\n            index = indices[i];\n            WithdrawalData storage withdrawal = _withdrawals[index];\n            bool isClaimed = withdrawal.isClaimed;\n            if (!isClaimed && block_ >= withdrawal.data.startBlock) {\n                _pull(withdrawal, index);\n                isClaimed = true;\n            }\n            if (isClaimed) {\n                withdrawals_.remove(index);\n                _handleWithdrawal(index, withdrawal, account, accountData_);\n            }\n        }\n    }\n\n    /// @inheritdoc IWithdrawalQueue\n    function claim(address account, address to, uint256 maxAmount)\n        external\n        returns (uint256 assets)\n    {\n        address sender = msg.sender;\n        require(sender == account || sender == claimer, \"EigenLayerWithdrawalQueue: forbidden\");\n        handleWithdrawals(account);\n        AccountData storage accountData_ = _accountData[account];\n        assets = maxAmount.min(accountData_.claimableAssets);\n        if (assets != 0) {\n            accountData_.claimableAssets -= assets;\n            IERC20(IIsolatedEigenLayerVault(isolatedVault).asset()).safeTransfer(to, assets);\n            emit Claimed(account, to, assets);\n        }\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function acceptPendingAssets(address account, uint256[] calldata withdrawals_) external {\n        address sender = msg.sender;\n        require(sender == account || sender == claimer, \"EigenLayerWithdrawalQueue: forbidden\");\n        AccountData storage accountData_ = _accountData[account];\n        EnumerableSet.UintSet storage transferredWithdrawals = accountData_.transferredWithdrawals;\n        EnumerableSet.UintSet storage withdrawals = accountData_.withdrawals;\n        for (uint256 i = 0; i < withdrawals_.length; i++) {\n            if (transferredWithdrawals.remove(withdrawals_[i])) {\n                if (withdrawals.add(withdrawals_[i])) {\n                    emit Accepted(account, withdrawals_[i]);\n                }\n            }\n        }\n        handleWithdrawals(account);\n        require(\n            withdrawals.length() <= MAX_WITHDRAWALS,\n            \"EigenLayerWithdrawalQueue: max withdrawal requests reached\"\n        );\n    }\n\n    /// @inheritdoc IEigenLayerWithdrawalQueue\n    function shutdown(uint32 blockNumber, uint256 shares) external {\n        address isolatedVault_ = isolatedVault;\n        IDelegationManager delegationManager = IDelegationManager(delegation);\n        require(\n            !isShutdown && !delegationManager.isDelegated(isolatedVault_),\n            \"EigenLayerWithdrawalQueue: not yet forcibly unstaked\"\n        );\n\n        IDelegationManager.Withdrawal memory withdrawal = IDelegationManager.Withdrawal({\n            staker: isolatedVault_,\n            delegatedTo: operator,\n            withdrawer: isolatedVault_,\n            nonce: delegationManager.cumulativeWithdrawalsQueued(isolatedVault_) - 1,\n            startBlock: blockNumber,\n            strategies: new IStrategy[](1),\n            shares: new uint256[](1)\n        });\n        withdrawal.strategies[0] = IStrategy(strategy);\n        withdrawal.shares[0] = shares;\n\n        bytes32 withdrawalRoot = delegationManager.calculateWithdrawalRoot(withdrawal);\n        require(\n            IDelegationManagerExtended(delegation).pendingWithdrawals(withdrawalRoot),\n            \"EigenLayerWithdrawalQueue: invalid withdrawal root\"\n        );\n\n        _pushRequest(withdrawal, IIsolatedEigenLayerVault(isolatedVault_).vault(), true, true);\n        isShutdown = true;\n        emit Shutdown(msg.sender, blockNumber, shares);\n    }\n\n    /// --------------- INTERNAL MUTABLE FUNCTIONS ---------------\n\n    function __init_EigenLayerWithdrawalQueue(\n        address isolatedVault_,\n        address strategy_,\n        address operator_\n    ) internal onlyInitializing {\n        isolatedVault = isolatedVault_;\n        strategy = strategy_;\n        operator = operator_;\n    }\n\n    function _pushRequest(\n        IDelegationManager.Withdrawal memory data,\n        address account,\n        bool isSelfRequested,\n        bool isShutdown_\n    ) internal returns (uint256 withdrawalIndex) {\n        withdrawalIndex = _withdrawals.length;\n        WithdrawalData storage withdrawal = _withdrawals.push();\n        withdrawal.data = data;\n        withdrawal.shares = data.shares[0];\n        withdrawal.sharesOf[account] = data.shares[0];\n        AccountData storage accountData = _accountData[account];\n        if (isSelfRequested) {\n            if (!isShutdown_ && accountData.withdrawals.length() + 1 > MAX_WITHDRAWALS) {\n                revert(\"EigenLayerWithdrawalQueue: max withdrawal requests reached\");\n            }\n            accountData.withdrawals.add(withdrawalIndex);\n        } else {\n            accountData.transferredWithdrawals.add(withdrawalIndex);\n        }\n    }\n\n    function _pull(WithdrawalData storage withdrawal, uint256 index) internal virtual {\n        uint256 assets = IIsolatedEigenLayerVault(isolatedVault).claimWithdrawal(\n            IDelegationManager(delegation), withdrawal.data\n        );\n        withdrawal.assets = assets;\n        withdrawal.isClaimed = true;\n        emit Pull(index, assets);\n    }\n\n    function _handleWithdrawal(\n        uint256 withdrawalIndex,\n        WithdrawalData storage withdrawal,\n        address account,\n        AccountData storage accountData_\n    ) private {\n        uint256 accountShares = withdrawal.sharesOf[account];\n        if (accountShares == 0) {\n            return;\n        }\n        uint256 assets = withdrawal.assets;\n        uint256 shares = withdrawal.shares;\n        delete withdrawal.sharesOf[account];\n        if (accountShares == shares) {\n            delete _withdrawals[withdrawalIndex];\n            accountData_.claimableAssets += assets;\n            emit Handled(account, withdrawalIndex, assets);\n        } else {\n            uint256 assets_ = assets.mulDiv(accountShares, shares);\n            accountData_.claimableAssets += assets_;\n            withdrawal.assets = assets - assets_;\n            withdrawal.shares = shares - accountShares;\n            emit Handled(account, withdrawalIndex, assets_);\n        }\n    }\n}\n"
    }
}