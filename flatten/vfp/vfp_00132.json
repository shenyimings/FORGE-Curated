{
    "vfp_id": "vfp_00132",
    "project_name": "2025-07-scroll-feynmanupgradesmartcontractchanges-securityreview.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Malicious submissions to commitAndFinalizeBatch can break off-chain indexers",
            "description": "The commitAndFinalizeBatch function uses the OnlyTopLevelCall modifier to ensure that calls originate from externally owned accounts (EOAs) and not from smart contracts, in order to preserve correct parsing by off-chain indexers. However, the modifier is ineffective because it only checks for non-zero contract code length, which is absent during a constructor execution. As a result, a malicious actor can call the function from a contract constructor, where msg.sender has no code, bypassing the check. This allows malformed or unexpected call data to be submitted as top-level transactions, which can cause off-chain indexers to crash or misinterpret the data. The impact is a degradation or corruption of data used by external services relying on accurate batch commitment and finalization tracking, especially during enforced liveness mode when users can manually submit batches.\n",
            "severity": "Low",
            "location": [
                "src/L1/rollup/ScrollChain.sol::commitAndFinalizeBatch#396-400",
                "src/L1/rollup/ScrollChain.sol::OnlyTopLevelCall#199-203"
            ],
            "files": [
                "scroll-contracts/src/L1/rollup/ScrollChain.sol"
            ]
        }
    ],
    "affected_files": {
        "ScrollChain.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL1MessageQueueV1} from \"./IL1MessageQueueV1.sol\";\nimport {IL1MessageQueueV2} from \"./IL1MessageQueueV2.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {BatchHeaderV1Codec} from \"../../libraries/codec/BatchHeaderV1Codec.sol\";\nimport {BatchHeaderV3Codec} from \"../../libraries/codec/BatchHeaderV3Codec.sol\";\nimport {BatchHeaderV7Codec} from \"../../libraries/codec/BatchHeaderV7Codec.sol\";\nimport {ChunkCodecV0} from \"../../libraries/codec/ChunkCodecV0.sol\";\nimport {ChunkCodecV1} from \"../../libraries/codec/ChunkCodecV1.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\nimport {SystemConfig} from \"../system-contract/SystemConfig.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, PausableUpgradeable, IScrollChain {\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given account is not EOA account.\n    error ErrorAccountIsNotEOA();\n\n    /// @dev Thrown when committing a committed batch.\n    error ErrorBatchIsAlreadyCommitted();\n\n    /// @dev Thrown when finalizing a verified batch.\n    error ErrorBatchIsAlreadyVerified();\n\n    /// @dev Thrown when committing empty batch (batch without chunks)\n    error ErrorBatchIsEmpty();\n\n    /// @dev Thrown when call precompile failed.\n    error ErrorCallPointEvaluationPrecompileFailed();\n\n    /// @dev Thrown when the caller is not prover.\n    error ErrorCallerIsNotProver();\n\n    /// @dev Thrown when the caller is not sequencer.\n    error ErrorCallerIsNotSequencer();\n\n    /// @dev Thrown when the transaction has multiple blobs.\n    error ErrorFoundMultipleBlobs();\n\n    /// @dev Thrown when some fields are not zero in genesis batch.\n    error ErrorGenesisBatchHasNonZeroField();\n\n    /// @dev Thrown when importing genesis batch twice.\n    error ErrorGenesisBatchImported();\n\n    /// @dev Thrown when data hash in genesis batch is zero.\n    error ErrorGenesisDataHashIsZero();\n\n    /// @dev Thrown when the parent batch hash in genesis batch is zero.\n    error ErrorGenesisParentBatchHashIsNonZero();\n\n    /// @dev Thrown when the batch hash is incorrect.\n    error ErrorIncorrectBatchHash();\n\n    /// @dev Thrown when the batch version is incorrect.\n    error ErrorIncorrectBatchVersion();\n\n    /// @dev Thrown when the bitmap length is incorrect.\n    error ErrorIncorrectBitmapLength();\n\n    /// @dev Thrown when the last message is skipped.\n    error ErrorLastL1MessageSkipped();\n\n    /// @dev Thrown when no blob found in the transaction.\n    error ErrorNoBlobFound();\n\n    /// @dev Thrown when the number of transactions is less than number of L1 message in one block.\n    error ErrorNumTxsLessThanNumL1Msgs();\n\n    /// @dev Thrown when reverting a finalized batch.\n    error ErrorRevertFinalizedBatch();\n\n    /// @dev Thrown when the given state root is zero.\n    error ErrorStateRootIsZero();\n\n    /// @dev Thrown when a chunk contains too many transactions.\n    error ErrorTooManyTxsInOneChunk();\n\n    /// @dev Thrown when the precompile output is incorrect.\n    error ErrorUnexpectedPointEvaluationPrecompileOutput();\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /// @dev Thrown when commit batch with lower version.\n    error ErrorCannotDowngradeVersion();\n\n    /// @dev Thrown when we try to commit or finalize normal batch in enforced batch mode.\n    error ErrorInEnforcedBatchMode();\n\n    /// @dev Thrown when we try to commit enforced batch while not in enforced batch mode.\n    error ErrorNotInEnforcedBatchMode();\n\n    /// @dev Thrown when commit old batch after Euclid fork is enabled.\n    error ErrorEuclidForkEnabled();\n\n    /// @dev Thrown when the committed v5 batch doesn't contain only one chunk.\n    error ErrorV5BatchNotContainsOnlyOneChunk();\n\n    /// @dev Thrown when the committed v5 batch doesn't contain only one block.\n    error ErrorV5BatchNotContainsOnlyOneBlock();\n\n    /// @dev Thrown when the committed v5 batch contains some transactions (L1 or L2).\n    error ErrorV5BatchContainsTransactions();\n\n    /// @dev Thrown when finalize v4/v5, v5/v6, v4/v5/v6 batches in the same bundle.\n    error ErrorFinalizePreAndPostEuclidBatchInOneBundle();\n\n    /// @dev Thrown when finalize v7 batches while some v1 messages still unfinalized.\n    error ErrorNotAllV1MessagesAreFinalized();\n\n    /// @dev Thrown when the committed batch hash doesn't match off-chain computed one.\n    error InconsistentBatchHash(uint256 batchIndex, bytes32 expected, bytes32 actual);\n\n    /// @dev Thrown when given batch is not committed before.\n    error ErrorBatchNotCommitted();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @dev Address of the point evaluation precompile used for EIP-4844 blob verification.\n    address internal constant POINT_EVALUATION_PRECOMPILE_ADDR = address(0x0A);\n\n    /// @dev BLS Modulus value defined in EIP-4844 and the magic value returned from a successful call to the\n    /// point evaluation precompile\n    uint256 internal constant BLS_MODULUS =\n        52435875175126190479447740508185965837690552500527637822603658699938581184513;\n\n    /// @dev offsets in miscData.flags\n    uint256 private constant V1_MESSAGES_FINALIZED_OFFSET = 0;\n    uint256 private constant ENFORCED_MODE_OFFSET = 1;\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public immutable layer2ChainId;\n\n    /// @notice The address of `L1MessageQueueV1`.\n    address public immutable messageQueueV1;\n\n    /// @notice The address of `L1MessageQueueV2`.\n    address public immutable messageQueueV2;\n\n    /// @notice The address of `MultipleVersionRollupVerifier`.\n    address public immutable verifier;\n\n    /// @notice The address of `SystemConfig`.\n    address public immutable systemConfig;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @param lastCommittedBatchIndex The index of the last committed batch.\n    /// @param lastFinalizedBatchIndex The index of the last finalized batch.\n    /// @param lastFinalizeTimestamp The timestamp of the last finalize transaction.\n    /// @param flags Various flags for saving gas. It has 8 bits.\n    ///        + bit 0 indicates whether all v1 messages are finalized, 1 means finalized and 0 means not.\n    ///        + bit 1 indicates whether the enforced batch mode is enabled, 1 means enabled and 0 means disabled.\n    /// @dev We use `32` bits for the timestamp, which works until `Feb 07 2106 06:28:15 GMT+0000`.\n    struct ScrollChainMiscData {\n        uint64 lastCommittedBatchIndex;\n        uint64 lastFinalizedBatchIndex;\n        uint32 lastFinalizeTimestamp;\n        uint8 flags;\n        uint88 reserved;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumTxInChunk;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @dev The storage slot used as RollupVerifier contract, which is deprecated now.\n    address private __verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice Whether an account is a prover.\n    mapping(address => bool) public isProver;\n\n    /// @dev The storage slot used as `lastFinalizedBatchIndex`, which is deprecated now.\n    uint256 private __lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    /// @dev Starting from EuclidV2, this array is sparse: it only contains\n    /// the last batch hash per commit transaction, and not intermediate ones.\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    /// @dev Starting from Darwin, this array is sparse: it only contains\n    /// the last state root per finalized bundle, and not intermediate ones.\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    /// @dev Starting from Darwin, this array is sparse: it only contains\n    /// the last withdraw root per finalized bundle, and not intermediate ones.\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /// @notice The index of first Euclid batch.\n    uint256 public initialEuclidBatchIndex;\n\n    ScrollChainMiscData public miscData;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        if (!isSequencer[_msgSender()]) revert ErrorCallerIsNotSequencer();\n        _;\n    }\n\n    modifier OnlyProver() {\n        if (!isProver[_msgSender()]) revert ErrorCallerIsNotProver();\n        _;\n    }\n\n    modifier whenEnforcedBatchNotEnabled() {\n        if (isEnforcedModeEnabled()) revert ErrorInEnforcedBatchMode();\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Constructor for `ScrollChain` implementation contract.\n    ///\n    /// @param _chainId The chain id of L2.\n    /// @param _messageQueueV1 The address of `L1MessageQueueV1`.\n    /// @param _messageQueueV2 The address of `L1MessageQueueV2`.\n    /// @param _verifier The address of `MultipleVersionRollupVerifier`.\n    /// @param _systemConfig The address of `SystemConfig`.\n    constructor(\n        uint64 _chainId,\n        address _messageQueueV1,\n        address _messageQueueV2,\n        address _verifier,\n        address _systemConfig\n    ) {\n        if (\n            _messageQueueV1 == address(0) ||\n            _messageQueueV2 == address(0) ||\n            _verifier == address(0) ||\n            _systemConfig == address(0)\n        ) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        layer2ChainId = _chainId;\n        messageQueueV1 = _messageQueueV1;\n        messageQueueV2 = _messageQueueV2;\n        verifier = _verifier;\n        systemConfig = _systemConfig;\n    }\n\n    /// @notice Initialize the storage of ScrollChain.\n    ///\n    /// @dev The parameters `_messageQueue` and `_verifier` are no longer used.\n    ///\n    /// @param _messageQueue The address of `L1MessageQueue` contract.\n    /// @param _verifier The address of zkevm verifier contract.\n    /// @param _maxNumTxInChunk The maximum number of transactions allowed in each chunk.\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumTxInChunk\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        maxNumTxInChunk = _maxNumTxInChunk;\n        __verifier = _verifier;\n        __messageQueue = _messageQueue;\n\n        emit UpdateMaxNumTxInChunk(0, _maxNumTxInChunk);\n    }\n\n    function initializeV2() external reinitializer(2) {\n        // binary search on lastCommittedBatchIndex\n        uint256 index = __lastFinalizedBatchIndex;\n        uint256 step = 1;\n        unchecked {\n            while (committedBatches[index + step] != bytes32(0)) {\n                step <<= 1;\n            }\n            step >>= 1;\n            while (step > 0) {\n                if (committedBatches[index + step] != bytes32(0)) {\n                    index += step;\n                }\n                step >>= 1;\n            }\n        }\n\n        miscData = ScrollChainMiscData({\n            lastCommittedBatchIndex: uint64(index),\n            lastFinalizedBatchIndex: uint64(__lastFinalizedBatchIndex),\n            lastFinalizeTimestamp: uint32(block.timestamp),\n            flags: 0,\n            reserved: 0\n        });\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= miscData.lastFinalizedBatchIndex;\n    }\n\n    /// @inheritdoc IScrollChain\n    function lastFinalizedBatchIndex() external view returns (uint256) {\n        return miscData.lastFinalizedBatchIndex;\n    }\n\n    /// @notice Return whether we are in enforced batch mode.\n    function isEnforcedModeEnabled() public view returns (bool) {\n        return _decodeBoolFromFlag(miscData.flags, ENFORCED_MODE_OFFSET);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @param _batchHeader The header of the genesis batch.\n    /// @param _stateRoot The state root of the genesis block.\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external {\n        // check genesis batch header length\n        if (_stateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        // check whether the genesis batch is imported\n        if (finalizedStateRoots[0] != bytes32(0)) revert ErrorGenesisBatchImported();\n\n        (uint256 memPtr, bytes32 _batchHash, , ) = _loadBatchHeader(_batchHeader, 0);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.getVersion(memPtr) +\n                BatchHeaderV0Codec.getBatchIndex(memPtr) +\n                BatchHeaderV0Codec.getL1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.getTotalL1MessagePopped(memPtr);\n            if (sum != 0) revert ErrorGenesisBatchHasNonZeroField();\n        }\n        if (BatchHeaderV0Codec.getDataHash(memPtr) == bytes32(0)) revert ErrorGenesisDataHashIsZero();\n        if (BatchHeaderV0Codec.getParentBatchHash(memPtr) != bytes32(0)) revert ErrorGenesisParentBatchHashIsNonZero();\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n\n        emit CommitBatch(0, _batchHash);\n        emit FinalizeBatch(0, _batchHash, _stateRoot, bytes32(0));\n    }\n\n    /// @inheritdoc IScrollChain\n    ///\n    /// @dev This function will revert unless all V0/V1/V2 batches are finalized. This is because we start to\n    /// pop L1 messages in `commitBatchWithBlobProof` but not in `commitBatch`. We also introduce `finalizedQueueIndex`\n    /// in `L1MessageQueue`. If one of V0/V1/V2 batches not finalized, `L1MessageQueue.pendingQueueIndex` will not\n    /// match `parentBatchHeader.totalL1MessagePopped` and thus revert.\n    ///\n    /// @dev This function now only accept batches with 4 <= version <= 6. And for `_version=5`, we should make sure this\n    /// batch contains only one empty block, since it is the Euclid initial batch for zkt/mpt transition.\n    function commitBatchWithBlobProof(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap,\n        bytes calldata _blobDataProof\n    ) external override OnlySequencer whenNotPaused whenEnforcedBatchNotEnabled {\n        // only accept 4 <= version <= 6\n        if (_version < 4) {\n            revert ErrorIncorrectBatchVersion();\n        } else if (_version == 5) {\n            // only commit once for Euclid initial batch\n            if (initialEuclidBatchIndex != 0) revert ErrorBatchIsAlreadyCommitted();\n        } else if (_version > 6) {\n            revert ErrorIncorrectBatchVersion();\n        }\n        // @note We suppose to check v6 batches cannot be committed without initial Euclid Batch.\n        // However it will introduce extra sload (2000 gas), we let the sequencer to do this check offchain.\n        // Even if the sequencer commits v6 batches without v5 batch, the security council can still revert it.\n\n        uint256 batchIndex = _commitBatchFromV2ToV6(\n            _version,\n            _parentBatchHeader,\n            _chunks,\n            _skippedL1MessageBitmap,\n            _blobDataProof\n        );\n        // Don't allow to commit version 4 after Euclid upgrade.\n        // This check is to avoid sequencer committing wrong batch due to human error.\n        // And This check won't introduce much gas overhead (likely less than 100).\n        if (_version == 4) {\n            uint256 euclidForkBatchIndex = initialEuclidBatchIndex;\n            if (euclidForkBatchIndex > 0 && batchIndex > euclidForkBatchIndex) revert ErrorEuclidForkEnabled();\n        } else if (_version == 5) {\n            initialEuclidBatchIndex = batchIndex;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatches(\n        uint8 version,\n        bytes32 parentBatchHash,\n        bytes32 lastBatchHash\n    ) external override OnlySequencer whenNotPaused whenEnforcedBatchNotEnabled {\n        _commitBatchesFromV7(version, parentBatchHash, lastBatchHash, false);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev This function cannot revert V6 and V7 batches at the same time, so we will assume all batches are V7.\n    /// If we need to revert V6 batches, we can downgrade the contract to the previous version and call this function.\n    /// @dev During commit batch we only store the last batch hash into storage. As a result, we cannot revert intermediate batches.\n    function revertBatch(bytes calldata batchHeader) external onlyOwner {\n        uint256 lastBatchIndex = miscData.lastCommittedBatchIndex;\n        (uint256 batchPtr, , uint256 startBatchIndex, ) = _loadBatchHeader(batchHeader, lastBatchIndex);\n        // only revert v7 batches\n        if (BatchHeaderV0Codec.getVersion(batchPtr) < 7) revert ErrorIncorrectBatchVersion();\n        // check finalization\n        if (startBatchIndex < miscData.lastFinalizedBatchIndex) revert ErrorRevertFinalizedBatch();\n\n        // actual revert\n        for (uint256 i = lastBatchIndex; i > startBatchIndex; --i) {\n            bytes32 hash = committedBatches[i];\n            if (hash != bytes32(0)) delete committedBatches[i];\n        }\n        emit RevertBatch(startBatchIndex + 1, lastBatchIndex);\n\n        // update `lastCommittedBatchIndex`\n        miscData.lastCommittedBatchIndex = uint64(startBatchIndex);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev All batches in the given bundle should have the same version and version <= 4 or version >= 6.\n    function finalizeBundleWithProof(\n        bytes calldata batchHeader,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external override OnlyProver whenNotPaused whenEnforcedBatchNotEnabled {\n        // actions before verification\n        (\n            uint256 version,\n            bytes32 batchHash,\n            uint256 batchIndex,\n            uint256 totalL1MessagesPoppedOverall,\n            uint256 prevBatchIndex\n        ) = _beforeFinalizeBatch(batchHeader, postStateRoot);\n\n        uint256 euclidForkBatchIndex = initialEuclidBatchIndex;\n        // Make sure we don't finalize v4, v5 and v6 batches in the same bundle, that\n        // means `batchIndex < euclidForkBatchIndex` or `prevBatchIndex >= euclidForkBatchIndex`.\n        if (prevBatchIndex < euclidForkBatchIndex && euclidForkBatchIndex <= batchIndex) {\n            revert ErrorFinalizePreAndPostEuclidBatchInOneBundle();\n        }\n\n        bytes memory publicInputs = abi.encodePacked(\n            layer2ChainId,\n            uint32(batchIndex - prevBatchIndex), // numBatches\n            finalizedStateRoots[prevBatchIndex], // _prevStateRoot\n            committedBatches[prevBatchIndex], // _prevBatchHash\n            postStateRoot,\n            batchHash,\n            withdrawRoot\n        );\n\n        // verify bundle, choose the correct verifier based on the last batch\n        // our off-chain service will make sure all unfinalized batches have the same batch version.\n        IRollupVerifier(verifier).verifyBundleProof(version, batchIndex, aggrProof, publicInputs);\n\n        // actions after verification\n        _afterFinalizeBatch(batchIndex, batchHash, totalL1MessagesPoppedOverall, postStateRoot, withdrawRoot, true);\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBundlePostEuclidV2(\n        bytes calldata batchHeader,\n        uint256 totalL1MessagesPoppedOverall,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external override OnlyProver whenNotPaused whenEnforcedBatchNotEnabled {\n        uint256 flags = miscData.flags;\n        bool isV1MessageFinalized = _decodeBoolFromFlag(flags, V1_MESSAGES_FINALIZED_OFFSET);\n        if (!isV1MessageFinalized) {\n            if (\n                IL1MessageQueueV1(messageQueueV1).nextUnfinalizedQueueIndex() !=\n                IL1MessageQueueV2(messageQueueV2).firstCrossDomainMessageIndex()\n            ) {\n                revert ErrorNotAllV1MessagesAreFinalized();\n            }\n            miscData.flags = uint8(_insertBoolToFlag(flags, V1_MESSAGES_FINALIZED_OFFSET, true));\n        }\n\n        _finalizeBundlePostEuclidV2(batchHeader, totalL1MessagesPoppedOverall, postStateRoot, withdrawRoot, aggrProof);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev We only consider batch version >= 7 here.\n    function commitAndFinalizeBatch(\n        uint8 version,\n        bytes32 parentBatchHash,\n        FinalizeStruct calldata finalizeStruct\n    ) external {\n        ScrollChainMiscData memory cachedMiscData = miscData;\n        if (!isEnforcedModeEnabled()) {\n            (uint256 maxDelayEnterEnforcedMode, uint256 maxDelayMessageQueue) = SystemConfig(systemConfig)\n                .enforcedBatchParameters();\n            uint256 firstUnfinalizedMessageTime = IL1MessageQueueV2(messageQueueV2)\n                .getFirstUnfinalizedMessageEnqueueTime();\n            if (\n                firstUnfinalizedMessageTime + maxDelayMessageQueue < block.timestamp ||\n                cachedMiscData.lastFinalizeTimestamp + maxDelayEnterEnforcedMode < block.timestamp\n            ) {\n                if (cachedMiscData.lastFinalizedBatchIndex < cachedMiscData.lastCommittedBatchIndex) {\n                    // be careful with the gas costs, maybe should call revertBatch first.\n                    for (\n                        uint256 i = cachedMiscData.lastCommittedBatchIndex;\n                        i > cachedMiscData.lastFinalizedBatchIndex;\n                        --i\n                    ) {\n                        bytes32 hash = committedBatches[i];\n                        if (hash != bytes32(0)) delete committedBatches[i];\n                    }\n                    emit RevertBatch(\n                        cachedMiscData.lastFinalizedBatchIndex + 1,\n                        cachedMiscData.lastCommittedBatchIndex\n                    );\n                }\n                // explicitly enable enforced batch mode\n                cachedMiscData.flags = uint8(_insertBoolToFlag(cachedMiscData.flags, ENFORCED_MODE_OFFSET, true));\n                // reset `lastCommittedBatchIndex`\n                cachedMiscData.lastCommittedBatchIndex = uint64(cachedMiscData.lastFinalizedBatchIndex);\n                miscData = cachedMiscData;\n                emit UpdateEnforcedBatchMode(true, cachedMiscData.lastCommittedBatchIndex);\n            } else {\n                revert ErrorNotInEnforcedBatchMode();\n            }\n        }\n\n        bytes32 batchHash = keccak256(finalizeStruct.batchHeader);\n        _commitBatchesFromV7(version, parentBatchHash, batchHash, true);\n\n        // finalize with zk proof\n        _finalizeBundlePostEuclidV2(\n            finalizeStruct.batchHeader,\n            finalizeStruct.totalL1MessagesPoppedOverall,\n            finalizeStruct.postStateRoot,\n            finalizeStruct.withdrawRoot,\n            finalizeStruct.zkProof\n        );\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add an account to the sequencer list.\n    /// @param _account The address of account to add.\n    function addSequencer(address _account) external onlyOwner {\n        // @note Currently many external services rely on EOA sequencer to decode metadata directly from tx.calldata.\n        // So we explicitly make sure the account is EOA.\n        if (_account.code.length > 0) revert ErrorAccountIsNotEOA();\n\n        isSequencer[_account] = true;\n\n        emit UpdateSequencer(_account, true);\n    }\n\n    /// @notice Remove an account from the sequencer list.\n    /// @param _account The address of account to remove.\n    function removeSequencer(address _account) external onlyOwner {\n        isSequencer[_account] = false;\n\n        emit UpdateSequencer(_account, false);\n    }\n\n    /// @notice Add an account to the prover list.\n    /// @param _account The address of account to add.\n    function addProver(address _account) external onlyOwner {\n        // @note Currently many external services rely on EOA prover to decode metadata directly from tx.calldata.\n        // So we explicitly make sure the account is EOA.\n        if (_account.code.length > 0) revert ErrorAccountIsNotEOA();\n        isProver[_account] = true;\n\n        emit UpdateProver(_account, true);\n    }\n\n    /// @notice Add an account from the prover list.\n    /// @param _account The address of account to remove.\n    function removeProver(address _account) external onlyOwner {\n        isProver[_account] = false;\n\n        emit UpdateProver(_account, false);\n    }\n\n    /// @notice Update the value of `maxNumTxInChunk`.\n    /// @param _maxNumTxInChunk The new value of `maxNumTxInChunk`.\n    function updateMaxNumTxInChunk(uint256 _maxNumTxInChunk) external onlyOwner {\n        uint256 _oldMaxNumTxInChunk = maxNumTxInChunk;\n        maxNumTxInChunk = _maxNumTxInChunk;\n\n        emit UpdateMaxNumTxInChunk(_oldMaxNumTxInChunk, _maxNumTxInChunk);\n    }\n\n    /// @notice Pause the contract\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Exit from enforced batch mode.\n    function disableEnforcedBatchMode() external onlyOwner {\n        miscData.flags = uint8(_insertBoolToFlag(miscData.flags, ENFORCED_MODE_OFFSET, false));\n        emit UpdateEnforcedBatchMode(false, miscData.lastCommittedBatchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Caller should make sure bit is smaller than 256.\n    function _decodeBoolFromFlag(uint256 flag, uint256 bit) internal pure returns (bool) {\n        return (flag >> bit) & 1 == 1;\n    }\n\n    /// @dev Caller should make sure bit is smaller than 256.\n    function _insertBoolToFlag(\n        uint256 flag,\n        uint256 bit,\n        bool value\n    ) internal pure returns (uint256) {\n        flag = flag ^ (flag & (1 << bit)); // reset value at bit\n        if (value) {\n            flag |= (1 << bit);\n        }\n        return flag;\n    }\n\n    /// @dev Internal function to do common checks before actual batch committing.\n    /// @param _version The version of the batch to commit.\n    /// @param _parentBatchHeader The parent batch header in calldata.\n    /// @param _chunks The list of chunks in memory.\n    /// @param _lastCommittedBatchIndex The index of the last committed batch.\n    /// @return _parentBatchHash The batch hash of parent batch header.\n    /// @return _batchIndex The index of current batch.\n    /// @return _totalL1MessagesPoppedOverall The total number of L1 messages popped before current batch.\n    function _beforeCommitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        uint256 _lastCommittedBatchIndex\n    )\n        private\n        view\n        returns (\n            bytes32 _parentBatchHash,\n            uint256 _batchIndex,\n            uint256 _totalL1MessagesPoppedOverall\n        )\n    {\n        // check whether the batch is empty\n        if (_chunks.length == 0) revert ErrorBatchIsEmpty();\n        uint256 batchPtr;\n        (batchPtr, _parentBatchHash, _batchIndex, _totalL1MessagesPoppedOverall) = _loadBatchHeader(\n            _parentBatchHeader,\n            _lastCommittedBatchIndex\n        );\n        // version should non-decreasing\n        if (BatchHeaderV0Codec.getVersion(batchPtr) > _version) revert ErrorCannotDowngradeVersion();\n\n        if (_batchIndex != _lastCommittedBatchIndex) revert ErrorBatchIsAlreadyCommitted();\n        unchecked {\n            _batchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to do common actions after actual batch committing.\n    /// @param _batchIndex The index of current batch.\n    /// @param _batchHash The hash of current batch.\n    function _afterCommitBatch(uint256 _batchIndex, bytes32 _batchHash) private {\n        miscData.lastCommittedBatchIndex = uint64(_batchIndex);\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchIndex, _batchHash);\n    }\n\n    /// @dev Internal function to do common actions before actual batch finalization.\n    function _beforeFinalizeBatch(bytes calldata batchHeader, bytes32 postStateRoot)\n        internal\n        view\n        returns (\n            uint256 version,\n            bytes32 batchHash,\n            uint256 batchIndex,\n            uint256 totalL1MessagesPoppedOverall,\n            uint256 prevBatchIndex\n        )\n    {\n        if (postStateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        ScrollChainMiscData memory cachedMiscData = miscData;\n        uint256 batchPtr;\n        // compute pending batch hash and verify\n        (batchPtr, batchHash, batchIndex, totalL1MessagesPoppedOverall) = _loadBatchHeader(\n            batchHeader,\n            cachedMiscData.lastCommittedBatchIndex\n        );\n\n        // make sure don't finalize batch multiple times\n        prevBatchIndex = cachedMiscData.lastFinalizedBatchIndex;\n        if (batchIndex <= prevBatchIndex) revert ErrorBatchIsAlreadyVerified();\n\n        version = BatchHeaderV0Codec.getVersion(batchPtr);\n    }\n\n    /// @dev Internal function to do common actions after actual batch finalization.\n    function _afterFinalizeBatch(\n        uint256 batchIndex,\n        bytes32 batchHash,\n        uint256 totalL1MessagesPoppedOverall,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bool isV1\n    ) internal {\n        ScrollChainMiscData memory cachedMiscData = miscData;\n        cachedMiscData.lastFinalizedBatchIndex = uint64(batchIndex);\n        cachedMiscData.lastFinalizeTimestamp = uint32(block.timestamp);\n        miscData = cachedMiscData;\n        // @note we do not store intermediate finalized roots\n        finalizedStateRoots[batchIndex] = postStateRoot;\n        withdrawRoots[batchIndex] = withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        _finalizePoppedL1Messages(totalL1MessagesPoppedOverall, isV1);\n\n        emit FinalizeBatch(batchIndex, batchHash, postStateRoot, withdrawRoot);\n    }\n\n    /// @dev Internal function to check the `SkippedL1MessageBitmap`.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped after current batch.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _skippedL1MessageBitmap The skipped L1 message bitmap in calldata.\n    /// @param _doPopMessage Whether we actually pop the messages from message queue.\n    function _checkSkippedL1MessageBitmap(\n        uint256 _totalL1MessagesPoppedOverall,\n        uint256 _totalL1MessagesPoppedInBatch,\n        bytes calldata _skippedL1MessageBitmap,\n        bool _doPopMessage\n    ) private {\n        // check the length of bitmap\n        unchecked {\n            if (((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 != _skippedL1MessageBitmap.length) {\n                revert ErrorIncorrectBitmapLength();\n            }\n        }\n        if (_doPopMessage) {\n            _popL1MessagesCalldata(\n                _skippedL1MessageBitmap,\n                _totalL1MessagesPoppedOverall,\n                _totalL1MessagesPoppedInBatch\n            );\n        }\n    }\n\n    /// @dev Internal function to get and check the blob versioned hash.\n    /// @param _blobDataProof The blob data proof passing to point evaluation precompile.\n    /// @return _blobVersionedHash The retrieved blob versioned hash.\n    function _getAndCheckBlobVersionedHash(bytes calldata _blobDataProof)\n        internal\n        returns (bytes32 _blobVersionedHash)\n    {\n        _blobVersionedHash = _getBlobVersionedHash();\n\n        // Calls the point evaluation precompile and verifies the output\n        (bool success, bytes memory data) = POINT_EVALUATION_PRECOMPILE_ADDR.staticcall(\n            abi.encodePacked(_blobVersionedHash, _blobDataProof)\n        );\n        // We verify that the point evaluation precompile call was successful by testing the latter 32 bytes of the\n        // response is equal to BLS_MODULUS as defined in https://eips.ethereum.org/EIPS/eip-4844#point-evaluation-precompile\n        if (!success) revert ErrorCallPointEvaluationPrecompileFailed();\n        (, uint256 result) = abi.decode(data, (uint256, uint256));\n        if (result != BLS_MODULUS) revert ErrorUnexpectedPointEvaluationPrecompileOutput();\n    }\n\n    /// @dev Internal function to get the blob versioned hash.\n    /// @return _blobVersionedHash The retrieved blob versioned hash.\n    function _getBlobVersionedHash() internal virtual returns (bytes32 _blobVersionedHash) {\n        bytes32 _secondBlob;\n        // Get blob's versioned hash\n        assembly {\n            _blobVersionedHash := blobhash(0)\n            _secondBlob := blobhash(1)\n        }\n        if (_blobVersionedHash == bytes32(0)) revert ErrorNoBlobFound();\n        if (_secondBlob != bytes32(0)) revert ErrorFoundMultipleBlobs();\n    }\n\n    /// @dev Internal function to get the blob versioned hash.\n    /// @return _blobVersionedHash The retrieved blob versioned hash.\n    function _getBlobVersionedHash(uint256 index) internal virtual returns (bytes32 _blobVersionedHash) {\n        // Get blob's versioned hash\n        assembly {\n            _blobVersionedHash := blobhash(index)\n        }\n    }\n\n    /// @dev We make sure v5 batch only contains one empty block here.\n    function _validateV5Batch(bytes[] memory chunks) internal pure {\n        if (chunks.length != 1) revert ErrorV5BatchNotContainsOnlyOneChunk();\n        bytes memory chunk = chunks[0];\n        uint256 chunkPtr;\n        uint256 blockPtr;\n        assembly {\n            chunkPtr := add(chunk, 0x20) // skip chunkLength\n            blockPtr := add(chunkPtr, 1)\n        }\n\n        uint256 numBlocks = ChunkCodecV1.validateChunkLength(chunkPtr, chunk.length);\n        if (numBlocks != 1) revert ErrorV5BatchNotContainsOnlyOneBlock();\n        uint256 numTransactions = ChunkCodecV1.getNumTransactions(blockPtr);\n        if (numTransactions != 0) revert ErrorV5BatchContainsTransactions();\n    }\n\n    /// @dev Internal function to commit one ore more batches after the EuclidV2 upgrade.\n    /// @param version The version of the batches (version >= 7).\n    /// @param parentBatchHash The hash of parent batch.\n    /// @param lastBatchHash The hash of the last committed batch after this call.\n    /// @param onlyOne If true, we will only process the first blob.\n    function _commitBatchesFromV7(\n        uint8 version,\n        bytes32 parentBatchHash,\n        bytes32 lastBatchHash,\n        bool onlyOne\n    ) internal {\n        if (version < 7) {\n            // only accept version >= 7\n            revert ErrorIncorrectBatchVersion();\n        }\n\n        uint256 lastCommittedBatchIndex = miscData.lastCommittedBatchIndex;\n        if (parentBatchHash != committedBatches[lastCommittedBatchIndex]) revert ErrorIncorrectBatchHash();\n        for (uint256 i = 0; ; i++) {\n            bytes32 blobVersionedHash = _getBlobVersionedHash(i);\n            if (blobVersionedHash == bytes32(0)) {\n                if (i == 0) revert ErrorBatchIsEmpty();\n                break;\n            }\n\n            lastCommittedBatchIndex += 1;\n            // see comments in `src/libraries/codec/BatchHeaderV7Codec.sol` for encodings\n            uint256 batchPtr = BatchHeaderV7Codec.allocate();\n            BatchHeaderV0Codec.storeVersion(batchPtr, version);\n            BatchHeaderV0Codec.storeBatchIndex(batchPtr, lastCommittedBatchIndex);\n            BatchHeaderV7Codec.storeParentBatchHash(batchPtr, parentBatchHash);\n            BatchHeaderV7Codec.storeBlobVersionedHash(batchPtr, blobVersionedHash);\n            bytes32 batchHash = BatchHeaderV0Codec.computeBatchHash(\n                batchPtr,\n                BatchHeaderV7Codec.BATCH_HEADER_FIXED_LENGTH\n            );\n            emit CommitBatch(lastCommittedBatchIndex, batchHash);\n            parentBatchHash = batchHash;\n            if (onlyOne) break;\n        }\n\n        // Make sure that the batch hash matches the one computed by the batch committer off-chain.\n        // This check can fail if:\n        // 1. faulty batch producers commit a wrong batch or the local computation is wrong.\n        // 2. unexpected `parentBatch` in case commit transactions get reordered\n        // 3. two batch producers commit at the same time with the same `parentBatch`.\n        if (parentBatchHash != lastBatchHash) {\n            revert InconsistentBatchHash(lastCommittedBatchIndex, lastBatchHash, parentBatchHash);\n        }\n        // only store last batch hash in storage\n        committedBatches[lastCommittedBatchIndex] = parentBatchHash;\n        miscData.lastCommittedBatchIndex = uint64(lastCommittedBatchIndex);\n    }\n\n    /// @dev Internal function to finalize a bundle after the EuclidV2 upgrade.\n    /// @param batchHeader The header of the last batch in this bundle.\n    /// @param totalL1MessagesPoppedOverall The number of messages processed after this bundle.\n    /// @param postStateRoot The state root after this bundle.\n    /// @param withdrawRoot The withdraw trie root after this bundle.\n    /// @param aggrProof The bundle proof for this bundle.\n    function _finalizeBundlePostEuclidV2(\n        bytes calldata batchHeader,\n        uint256 totalL1MessagesPoppedOverall,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) internal {\n        // actions before verification\n        (uint256 version, bytes32 batchHash, uint256 batchIndex, , uint256 prevBatchIndex) = _beforeFinalizeBatch(\n            batchHeader,\n            postStateRoot\n        );\n\n        // L1 message hashes are chained,\n        // this hash commits to the whole queue up to and including `totalL1MessagesPoppedOverall-1`\n        bytes32 messageQueueHash = totalL1MessagesPoppedOverall == 0\n            ? bytes32(0)\n            : IL1MessageQueueV2(messageQueueV2).getMessageRollingHash(totalL1MessagesPoppedOverall - 1);\n\n        bytes memory publicInputs = abi.encodePacked(\n            layer2ChainId,\n            messageQueueHash,\n            uint32(batchIndex - prevBatchIndex), // numBatches\n            finalizedStateRoots[prevBatchIndex], // _prevStateRoot\n            committedBatches[prevBatchIndex], // _prevBatchHash\n            postStateRoot,\n            batchHash,\n            withdrawRoot\n        );\n\n        // verify bundle, choose the correct verifier based on the last batch\n        // our off-chain service will make sure all unfinalized batches have the same batch version.\n        IRollupVerifier(verifier).verifyBundleProof(version, batchIndex, aggrProof, publicInputs);\n\n        // actions after verification\n        _afterFinalizeBatch(batchIndex, batchHash, totalL1MessagesPoppedOverall, postStateRoot, withdrawRoot, false);\n    }\n\n    /// @dev Internal function to commit batches from V2 to V6 (except V5, since it is Euclid initial batch)\n    function _commitBatchFromV2ToV6(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap,\n        bytes calldata _blobDataProof\n    ) internal returns (uint256) {\n        // do extra checks for batch v5.\n        if (_version == 5) {\n            _validateV5Batch(_chunks);\n        }\n\n        // allocate memory of batch header and store entries if necessary, the order matters\n        // @note why store entries if necessary, to avoid stack overflow problem.\n        // The codes for `version`, `batchIndex`, `l1MessagePopped`, `totalL1MessagePopped` and `dataHash`\n        // are the same as `BatchHeaderV0Codec`.\n        // The codes for `blobVersionedHash`, and `parentBatchHash` are the same as `BatchHeaderV1Codec`.\n        uint256 batchPtr = BatchHeaderV3Codec.allocate();\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n\n        (bytes32 _parentBatchHash, uint256 _batchIndex, uint256 _totalL1MessagesPoppedOverall) = _beforeCommitBatch(\n            _version,\n            _parentBatchHeader,\n            _chunks,\n            miscData.lastCommittedBatchIndex\n        );\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n\n        // versions 2 to 6 both use ChunkCodecV1\n        (bytes32 _dataHash, uint256 _totalL1MessagesPoppedInBatch) = _commitChunksV1(\n            _totalL1MessagesPoppedOverall,\n            _chunks,\n            _skippedL1MessageBitmap\n        );\n        unchecked {\n            _totalL1MessagesPoppedOverall += _totalL1MessagesPoppedInBatch;\n        }\n\n        // verify skippedL1MessageBitmap\n        _checkSkippedL1MessageBitmap(\n            _totalL1MessagesPoppedOverall,\n            _totalL1MessagesPoppedInBatch,\n            _skippedL1MessageBitmap,\n            true\n        );\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n\n        // verify blob versioned hash\n        BatchHeaderV1Codec.storeBlobVersionedHash(batchPtr, _getAndCheckBlobVersionedHash(_blobDataProof));\n        BatchHeaderV1Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n\n        uint256 lastBlockTimestamp;\n        {\n            bytes memory lastChunk = _chunks[_chunks.length - 1];\n            lastBlockTimestamp = ChunkCodecV1.getLastBlockTimestamp(lastChunk);\n        }\n        BatchHeaderV3Codec.storeLastBlockTimestamp(batchPtr, lastBlockTimestamp);\n        BatchHeaderV3Codec.storeBlobDataProof(batchPtr, _blobDataProof);\n\n        // compute batch hash, V2~V6 has same code as V0\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(\n            batchPtr,\n            BatchHeaderV3Codec.BATCH_HEADER_FIXED_LENGTH\n        );\n\n        _afterCommitBatch(_batchIndex, _batchHash);\n\n        return _batchIndex;\n    }\n\n    /// @dev Internal function to commit chunks with version 1\n    /// @param _totalL1MessagesPoppedOverall The number of L1 messages popped before the list of chunks.\n    /// @param _chunks The list of chunks to commit.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _batchDataHash The computed data hash for the list of chunks.\n    /// @return _totalL1MessagesPoppedInBatch The total number of L1 messages popped in this batch, including skipped one.\n    function _commitChunksV1(\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (bytes32 _batchDataHash, uint256 _totalL1MessagesPoppedInBatch) {\n        uint256 _chunksLength = _chunks.length;\n\n        // load `batchDataHashPtr` and reserve the memory region for chunk data hashes\n        uint256 batchDataHashPtr;\n        assembly {\n            batchDataHashPtr := mload(0x40)\n            mstore(0x40, add(batchDataHashPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk;\n            bytes32 _chunkDataHash;\n            (_chunkDataHash, _totalNumL1MessagesInChunk) = _commitChunkV1(\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n            }\n            assembly {\n                mstore(batchDataHashPtr, _chunkDataHash)\n                batchDataHashPtr := add(batchDataHashPtr, 0x20)\n            }\n        }\n\n        // compute the data hash for current batch\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _batchDataHash := keccak256(sub(batchDataHashPtr, dataLen), dataLen)\n        }\n    }\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @param _lastCommittedBatchIndex The index of the last committed batch.\n    /// @return batchPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    /// @return _batchIndex The index of this batch.\n    /// @return _totalL1MessagesPoppedOverall The number of L1 messages popped after this batch.\n    /// @dev This function only works with batches whose hashes are stored in `committedBatches`.\n    function _loadBatchHeader(bytes calldata _batchHeader, uint256 _lastCommittedBatchIndex)\n        internal\n        view\n        virtual\n        returns (\n            uint256 batchPtr,\n            bytes32 _batchHash,\n            uint256 _batchIndex,\n            uint256 _totalL1MessagesPoppedOverall\n        )\n    {\n        // load version from batch header, it is always the first byte.\n        uint256 version;\n        assembly {\n            version := shr(248, calldataload(_batchHeader.offset))\n        }\n\n        uint256 _length;\n        if (version == 0) {\n            (batchPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n        } else if (version <= 2) {\n            (batchPtr, _length) = BatchHeaderV1Codec.loadAndValidate(_batchHeader);\n        } else if (version <= 6) {\n            (batchPtr, _length) = BatchHeaderV3Codec.loadAndValidate(_batchHeader);\n        } else {\n            (batchPtr, _length) = BatchHeaderV7Codec.loadAndValidate(_batchHeader);\n        }\n\n        // the code for compute batch hash is the same for V0~V6\n        // also the `_batchIndex` and `_totalL1MessagesPoppedOverall`.\n        _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, _length);\n        _batchIndex = BatchHeaderV0Codec.getBatchIndex(batchPtr);\n        // we don't have totalL1MessagesPoppedOverall in V7~\n        if (version <= 6) {\n            _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.getTotalL1MessagePopped(batchPtr);\n        }\n\n        if (_batchIndex > _lastCommittedBatchIndex) revert ErrorBatchNotCommitted();\n\n        // only check when genesis is imported\n        if (committedBatches[_batchIndex] != _batchHash && finalizedStateRoots[0] != bytes32(0)) {\n            revert ErrorIncorrectBatchHash();\n        }\n    }\n\n    /// @dev Internal function to commit a chunk with version 1.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _dataHash The computed data hash for this chunk.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunkV1(\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (bytes32 _dataHash, uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 startDataPtr;\n        uint256 dataPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            startDataPtr := dataPtr\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n        }\n\n        uint256 _numBlocks = ChunkCodecV1.validateChunkLength(chunkPtr, _chunk.length);\n        // concatenate block contexts, use scope to avoid stack too deep\n        for (uint256 i = 0; i < _numBlocks; i++) {\n            dataPtr = ChunkCodecV1.copyBlockContext(chunkPtr, dataPtr, i);\n            uint256 blockPtr = chunkPtr + 1 + i * ChunkCodecV1.BLOCK_CONTEXT_LENGTH;\n            uint256 _numL1MessagesInBlock = ChunkCodecV1.getNumL1Messages(blockPtr);\n            unchecked {\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n            }\n        }\n        assembly {\n            mstore(0x40, add(dataPtr, mul(_totalNumL1MessagesInChunk, 0x20))) // reserve memory for l1 message hashes\n            chunkPtr := add(chunkPtr, 1)\n        }\n\n        // the number of actual transactions in one chunk: non-skipped l1 messages + l2 txs\n        uint256 _totalTransactionsInChunk;\n        // concatenate tx hashes\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodecV1.getNumL1Messages(chunkPtr);\n            uint256 startPtr = dataPtr;\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n            uint256 _numTransactionsInBlock = ChunkCodecV1.getNumTransactions(chunkPtr);\n            if (_numTransactionsInBlock < _numL1MessagesInBlock) revert ErrorNumTxsLessThanNumL1Msgs();\n            unchecked {\n                _totalTransactionsInChunk += (dataPtr - startPtr) / 32; // number of non-skipped l1 messages\n                _totalTransactionsInChunk += _numTransactionsInBlock - _numL1MessagesInBlock; // number of l2 txs\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                chunkPtr += ChunkCodecV1.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the actual number of transactions in the chunk\n        if (_totalTransactionsInChunk > maxNumTxInChunk) {\n            revert ErrorTooManyTxsInOneChunk();\n        }\n\n        // compute data hash and store to memory\n        assembly {\n            _dataHash := keccak256(startDataPtr, sub(dataPtr, startDataPtr))\n        }\n    }\n\n    /// @dev Internal function to load L1 message hashes from the message queue.\n    /// @param _ptr The memory offset to store the transaction hash.\n    /// @param _numL1Messages The number of L1 messages to load.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return uint256 The new memory offset after loading.\n    function _loadL1MessageHashes(\n        uint256 _ptr,\n        uint256 _numL1Messages,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256) {\n        if (_numL1Messages == 0) return _ptr;\n        IL1MessageQueueV1 _messageQueue = IL1MessageQueueV1(messageQueueV1);\n\n        unchecked {\n            uint256 _bitmap;\n            uint256 rem;\n            for (uint256 i = 0; i < _numL1Messages; i++) {\n                uint256 quo = _totalL1MessagesPoppedInBatch >> 8;\n                rem = _totalL1MessagesPoppedInBatch & 0xff;\n\n                // load bitmap every 256 bits\n                if (i == 0 || rem == 0) {\n                    assembly {\n                        _bitmap := calldataload(add(_skippedL1MessageBitmap.offset, mul(0x20, quo)))\n                    }\n                }\n                if (((_bitmap >> rem) & 1) == 0) {\n                    // message not skipped\n                    bytes32 _hash = _messageQueue.getCrossDomainMessage(_totalL1MessagesPoppedOverall);\n                    assembly {\n                        mstore(_ptr, _hash)\n                        _ptr := add(_ptr, 0x20)\n                    }\n                }\n\n                _totalL1MessagesPoppedInBatch += 1;\n                _totalL1MessagesPoppedOverall += 1;\n            }\n\n            // check last L1 message is not skipped, _totalL1MessagesPoppedInBatch must > 0\n            rem = (_totalL1MessagesPoppedInBatch - 1) & 0xff;\n            if (((_bitmap >> rem) & 1) > 0) revert ErrorLastL1MessageSkipped();\n        }\n\n        return _ptr;\n    }\n\n    /// @param totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    function _finalizePoppedL1Messages(uint256 totalL1MessagesPoppedOverall, bool isV1) internal {\n        if (totalL1MessagesPoppedOverall > 0) {\n            if (isV1) {\n                IL1MessageQueueV1(messageQueueV1).finalizePoppedCrossDomainMessage(totalL1MessagesPoppedOverall);\n            } else {\n                IL1MessageQueueV2(messageQueueV2).finalizePoppedCrossDomainMessage(totalL1MessagesPoppedOverall);\n            }\n        }\n    }\n\n    /// @dev Internal function to pop l1 messages from `skippedL1MessageBitmap` in calldata.\n    /// @param skippedL1MessageBitmap The `skippedL1MessageBitmap` in calldata.\n    /// @param totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param totalL1MessagesPoppedInBatch The number of L1 messages popped in current batch.\n    function _popL1MessagesCalldata(\n        bytes calldata skippedL1MessageBitmap,\n        uint256 totalL1MessagesPoppedOverall,\n        uint256 totalL1MessagesPoppedInBatch\n    ) internal {\n        if (totalL1MessagesPoppedInBatch == 0) return;\n        uint256 bitmapPtr;\n        assembly {\n            bitmapPtr := skippedL1MessageBitmap.offset\n        }\n        _popL1Messages(true, bitmapPtr, totalL1MessagesPoppedOverall, totalL1MessagesPoppedInBatch);\n    }\n\n    /// @dev Internal function to pop l1 messages from `skippedL1MessageBitmap` in calldata or memory.\n    /// @param isCalldata Whether the `skippedL1MessageBitmap` is in calldata or memory.\n    /// @param bitmapPtr The offset of `skippedL1MessageBitmap` in calldata or memory.\n    /// @param totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param totalL1MessagesPoppedInBatch The number of L1 messages popped in current batch.\n    function _popL1Messages(\n        bool isCalldata,\n        uint256 bitmapPtr,\n        uint256 totalL1MessagesPoppedOverall,\n        uint256 totalL1MessagesPoppedInBatch\n    ) internal {\n        if (totalL1MessagesPoppedInBatch == 0) return;\n\n        unchecked {\n            uint256 startIndex = totalL1MessagesPoppedOverall - totalL1MessagesPoppedInBatch;\n            uint256 bitmap;\n\n            for (uint256 i = 0; i < totalL1MessagesPoppedInBatch; i += 256) {\n                uint256 _count = 256;\n                if (totalL1MessagesPoppedInBatch - i < _count) {\n                    _count = totalL1MessagesPoppedInBatch - i;\n                }\n                assembly {\n                    switch isCalldata\n                    case 1 {\n                        bitmap := calldataload(bitmapPtr)\n                    }\n                    default {\n                        bitmap := mload(bitmapPtr)\n                    }\n                    bitmapPtr := add(bitmapPtr, 0x20)\n                }\n                IL1MessageQueueV1(messageQueueV1).popCrossDomainMessage(startIndex, _count, bitmap);\n                startIndex += 256;\n            }\n        }\n    }\n}\n"
    }
}