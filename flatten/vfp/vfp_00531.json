{
    "vfp_id": "vfp_00531",
    "project_name": "cantina_centrifuge_aug2025.pdf",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Extra safeguard for rely() and endorse()",
            "description": "The deployment scripts perform multiple rely() and endorse() calls without checking that the target address is not zero. The root cause is missing input validation in deployment logic. If a zero address is accidentally passed, it could lead to loss of control or inability to revoke permissions. While the functions themselves may have checks, adding a safeguard in the scripts would prevent human error during deployment. The same issue applies to root::endorse().\n",
            "severity": null,
            "location": [
                "rely",
                "endorse"
            ],
            "files": [
                "protocol-v3/script/CommonDeployer.s.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Missing TokenRecoverer contract registration",
            "description": "The TokenRecoverer contract is deployed in _preDeployCommon() but is not registered in the system registry. The cause is an omission in the deployment script. This leads to inconsistency in the contract registry, making it harder to discover or interact with the TokenRecoverer programmatically. While the contract functions correctly, the lack of registration could lead to operational issues or confusion during upgrades or integrations. It may also prevent automated tooling from recognizing the contract.\n",
            "severity": null,
            "location": [
                "_preDeployCommon"
            ],
            "files": [
                "protocol-v3/script/CommonDeployer.s.sol",
                "protocol-v3/src/common/TokenRecoverer.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "adminSafe not registered",
            "description": "The CommonDeployer script contains a comment stating that registering \"adminSafe\" is unnecessary, but due to refactoring (load_vars.sh â†’ load_config.py), the registration is no longer handled elsewhere. The adminSafe is present in the JSON config but not registered in the system. The cause is outdated assumptions in deployment logic. This could lead to the adminSafe not being accessible via the registry, breaking tooling or governance workflows that depend on it. Registration should be explicitly added to ensure consistency.\n",
            "severity": null,
            "location": [
                "CommonDeployer",
                "load_config.py"
            ],
            "files": [
                "protocol-v3/script/CommonDeployer.s.sol"
            ]
        }
    ],
    "affected_files": {
        "CommonDeployer.s.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {JsonRegistry} from \"./utils/JsonRegistry.s.sol\";\n\nimport {Root} from \"../src/common/Root.sol\";\nimport {Gateway} from \"../src/common/Gateway.sol\";\nimport {GasService} from \"../src/common/GasService.sol\";\nimport {Guardian, ISafe} from \"../src/common/Guardian.sol\";\nimport {MultiAdapter} from \"../src/common/MultiAdapter.sol\";\nimport {TokenRecoverer} from \"../src/common/TokenRecoverer.sol\";\nimport {MessageProcessor} from \"../src/common/MessageProcessor.sol\";\nimport {MessageDispatcher} from \"../src/common/MessageDispatcher.sol\";\nimport {PoolEscrowFactory} from \"../src/common/factories/PoolEscrowFactory.sol\";\n\nimport {CreateXScript} from \"createx-forge/script/CreateXScript.sol\";\n\nimport \"forge-std/Script.sol\";\n\nstruct CommonInput {\n    uint16 centrifugeId;\n    ISafe adminSafe;\n    uint128 maxBatchGasLimit;\n    bytes32 version;\n}\n\nstruct CommonReport {\n    ISafe adminSafe;\n    Root root;\n    TokenRecoverer tokenRecoverer;\n    Guardian guardian;\n    GasService gasService;\n    Gateway gateway;\n    MultiAdapter multiAdapter;\n    MessageProcessor messageProcessor;\n    MessageDispatcher messageDispatcher;\n    PoolEscrowFactory poolEscrowFactory;\n}\n\ncontract CommonActionBatcher {\n    error NotDeployer();\n\n    address deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    modifier onlyDeployer() {\n        require(msg.sender == deployer, NotDeployer());\n        _;\n    }\n\n    function setDeployer(address newDeployer) public onlyDeployer {\n        deployer = newDeployer;\n    }\n\n    function lock() public onlyDeployer {\n        deployer = address(0);\n    }\n\n    function engageCommon(CommonReport memory report) public onlyDeployer {\n        report.root.rely(address(report.guardian));\n        report.root.rely(address(report.tokenRecoverer));\n        report.root.rely(address(report.messageProcessor));\n        report.root.rely(address(report.messageDispatcher));\n        report.gateway.rely(address(report.root));\n        report.gateway.rely(address(report.messageDispatcher));\n        report.gateway.rely(address(report.multiAdapter));\n        report.multiAdapter.rely(address(report.root));\n        report.multiAdapter.rely(address(report.guardian));\n        report.multiAdapter.rely(address(report.gateway));\n        report.messageDispatcher.rely(address(report.root));\n        report.messageDispatcher.rely(address(report.guardian));\n        report.messageProcessor.rely(address(report.root));\n        report.messageProcessor.rely(address(report.gateway));\n        report.tokenRecoverer.rely(address(report.root));\n        report.tokenRecoverer.rely(address(report.messageDispatcher));\n        report.tokenRecoverer.rely(address(report.messageProcessor));\n        report.poolEscrowFactory.rely(address(report.root));\n\n        report.gateway.file(\"processor\", address(report.messageProcessor));\n        report.gateway.file(\"adapter\", address(report.multiAdapter));\n        report.poolEscrowFactory.file(\"gateway\", address(report.gateway));\n    }\n\n    function postEngageCommon(CommonReport memory report) public onlyDeployer {\n        // We override the deployer with the correct admin once everything is deployed\n        report.guardian.file(\"safe\", address(report.adminSafe));\n    }\n\n    function revokeCommon(CommonReport memory report) public onlyDeployer {\n        report.root.deny(address(this));\n        report.gateway.deny(address(this));\n        report.multiAdapter.deny(address(this));\n        report.tokenRecoverer.deny(address(this));\n        report.messageProcessor.deny(address(this));\n        report.messageDispatcher.deny(address(this));\n        report.poolEscrowFactory.deny(address(this));\n    }\n}\n\nabstract contract CommonDeployer is Script, JsonRegistry, CreateXScript {\n    uint256 public constant DELAY = 48 hours;\n\n    bytes32 version;\n    ISafe public adminSafe;\n\n    Root public root;\n    TokenRecoverer public tokenRecoverer;\n    Guardian public guardian;\n    GasService public gasService;\n    Gateway public gateway;\n    MultiAdapter public multiAdapter;\n    MessageProcessor public messageProcessor;\n    MessageDispatcher public messageDispatcher;\n    PoolEscrowFactory public poolEscrowFactory;\n\n    /**\n     * @dev Generates a salt for contract deployment\n     * @param contractName The name of the contract\n     * @return salt A deterministic salt based on contract name and optional VERSION\n     */\n    function generateSalt(string memory contractName) internal view returns (bytes32) {\n        if (version != bytes32(0)) {\n            bytes32 contractNameHash = keccak256(bytes(contractName));\n            // Special handling for v3.0.1 contracts that were deployed with version \"3\" instead of keccak256(\"3\")\n            if (\n                version == keccak256(abi.encodePacked(\"3\"))\n                    && (\n                        contractNameHash == keccak256(bytes(\"asyncRequestManager-2\"))\n                            || contractNameHash == keccak256(bytes(\"syncDepositVaultFactory-2\"))\n                            || contractNameHash == keccak256(bytes(\"asyncVaultFactory-2\"))\n                    )\n            ) {\n                return keccak256(abi.encodePacked(contractName, bytes32(bytes(\"3\"))));\n            }\n            return keccak256(abi.encodePacked(contractName, version));\n        }\n        return keccak256(abi.encodePacked(contractName));\n    }\n\n    function deployCommon(CommonInput memory input, CommonActionBatcher batcher) public {\n        _preDeployCommon(input, batcher);\n        _postDeployCommon(batcher);\n    }\n\n    function _preDeployCommon(CommonInput memory input, CommonActionBatcher batcher) internal {\n        if (address(gateway) != address(0)) {\n            return; // Already deployed. Make this method idempotent.\n        }\n\n        setUpCreateXFactory();\n\n        adminSafe = input.adminSafe;\n        version = input.version;\n\n        root =\n            Root(create3(generateSalt(\"root\"), abi.encodePacked(type(Root).creationCode, abi.encode(DELAY, batcher))));\n\n        tokenRecoverer = TokenRecoverer(\n            create3(\n                generateSalt(\"tokenRecoverer\"),\n                abi.encodePacked(type(TokenRecoverer).creationCode, abi.encode(root, batcher))\n            )\n        );\n\n        messageProcessor = MessageProcessor(\n            create3(\n                generateSalt(\"messageProcessor\"),\n                abi.encodePacked(type(MessageProcessor).creationCode, abi.encode(root, tokenRecoverer, batcher))\n            )\n        );\n\n        gasService = GasService(\n            create3(\n                generateSalt(\"gasService-2\"),\n                abi.encodePacked(type(GasService).creationCode, abi.encode(input.maxBatchGasLimit))\n            )\n        );\n\n        gateway = Gateway(\n            payable(\n                create3(\n                    generateSalt(\"gateway\"),\n                    abi.encodePacked(type(Gateway).creationCode, abi.encode(root, gasService, batcher))\n                )\n            )\n        );\n\n        multiAdapter = MultiAdapter(\n            create3(\n                generateSalt(\"multiAdapter\"),\n                abi.encodePacked(type(MultiAdapter).creationCode, abi.encode(input.centrifugeId, gateway, batcher))\n            )\n        );\n\n        messageDispatcher = MessageDispatcher(\n            create3(\n                generateSalt(\"messageDispatcher\"),\n                abi.encodePacked(\n                    type(MessageDispatcher).creationCode,\n                    abi.encode(input.centrifugeId, root, gateway, tokenRecoverer, batcher)\n                )\n            )\n        );\n\n        guardian = Guardian(\n            create3(\n                generateSalt(\"guardian\"),\n                abi.encodePacked(\n                    type(Guardian).creationCode,\n                    abi.encode(ISafe(address(batcher)), multiAdapter, root, messageDispatcher)\n                )\n            )\n        );\n\n        poolEscrowFactory = PoolEscrowFactory(\n            create3(\n                generateSalt(\"poolEscrowFactory\"),\n                abi.encodePacked(type(PoolEscrowFactory).creationCode, abi.encode(address(root), batcher))\n            )\n        );\n\n        batcher.engageCommon(_commonReport());\n\n        register(\"root\", address(root));\n        register(\"guardian\", address(guardian));\n        register(\"gasService\", address(gasService));\n        register(\"gateway\", address(gateway));\n        register(\"multiAdapter\", address(multiAdapter));\n        register(\"messageProcessor\", address(messageProcessor));\n        register(\"messageDispatcher\", address(messageDispatcher));\n        register(\"poolEscrowFactory\", address(poolEscrowFactory));\n        register(\"tokenRecoverer\", address(tokenRecoverer));\n    }\n\n    function _postDeployCommon(CommonActionBatcher batcher) internal {\n        if (guardian.safe() == _commonReport().adminSafe) {\n            return; // Already configured. Make this method idempotent.\n        }\n\n        batcher.postEngageCommon(_commonReport());\n    }\n\n    function removeCommonDeployerAccess(CommonActionBatcher batcher) public {\n        if (gateway.wards(address(batcher)) == 0) {\n            return; // Already removed. Make this method idempotent.\n        }\n\n        batcher.revokeCommon(_commonReport());\n    }\n\n    function _commonReport() internal view returns (CommonReport memory) {\n        return CommonReport(\n            adminSafe,\n            root,\n            tokenRecoverer,\n            guardian,\n            gasService,\n            gateway,\n            multiAdapter,\n            messageProcessor,\n            messageDispatcher,\n            poolEscrowFactory\n        );\n    }\n}\n",
        "TokenRecoverer.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IRoot} from \"./interfaces/IRoot.sol\";\nimport {ITokenRecoverer} from \"./interfaces/ITokenRecoverer.sol\";\n\nimport {Auth} from \"../misc/Auth.sol\";\nimport {IRecoverable} from \"../misc/interfaces/IRecoverable.sol\";\n\ncontract TokenRecoverer is Auth, ITokenRecoverer {\n    IRoot public immutable root;\n\n    constructor(IRoot root_, address deployer) Auth(deployer) {\n        root = root_;\n    }\n\n    /// @notice inheritdoc ITokenRecoverer\n    function recoverTokens(IRecoverable target, address token, uint256 tokenId, address to, uint256 amount)\n        external\n        auth\n    {\n        root.relyContract(address(target), address(this));\n\n        if (tokenId == 0) {\n            target.recoverTokens(token, to, amount);\n        } else {\n            target.recoverTokens(token, tokenId, to, amount);\n        }\n\n        root.denyContract(address(target), address(this));\n\n        emit RecoverTokens(target, token, tokenId, to, amount);\n    }\n}\n"
    }
}