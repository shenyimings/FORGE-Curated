{
    "vfp_id": "vfp_00086",
    "project_name": "cantina_sky_jul2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "ForeignController.transferTokenLayerZero is missing approval to the Sky OFT adapter",
            "description": "The ForeignController.transferTokenLayerZero function is intended to support LayerZero OFT token transfers, but it fails to approve the Sky OFT adapter before attempting to burn or transfer tokens. Unlike the USDT0 adapter, the Sky OFT adapter does not have special burn privileges and requires explicit approval from the caller. The root cause is the absence of an approval call before invoking the burn function on the Sky OFT token. An attacker or malicious relayer could exploit this by triggering a transfer that fails due to lack of approval, potentially disrupting legitimate operations or causing unexpected reverts. The impact includes failed transactions and potential denial of service for valid users relying on the bridging functionality.\n",
            "severity": "Medium",
            "location": [
                "ForeignController.sol#L239"
            ],
            "files": [
                "spark-alm-controller/src/ForeignController.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Compromised relayer can use transferTokenLayerZero to burn ETH in ALM Proxy",
            "description": "The transferTokenLayerZero function in MainnetController can be exploited by a compromised relayer to bridge minimal amounts of ETH (e.g., 1 wei) repeatedly, potentially draining native token balances held in the ALM Proxy over time. The cause is the lack of rate limiting or call frequency restrictions on this function, allowing repeated invocations. An attacker with control over the relayer could exploit this by initiating numerous small transfers, gradually depleting the proxy's ETH balance. The impact is a potential loss of native tokens from the ALM Proxy, especially if significant ETH is held there, although the risk is mitigated by the small per-call amount.\n",
            "severity": "Low",
            "location": [
                "MainnetController.sol#L813"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-228"
                ],
                "3": [
                    "CWE-237"
                ]
            },
            "title": "_approve ignores the success bool return value",
            "description": "The _approve function in MainnetController incorrectly interprets the return data from a low-level call to the ALM Proxy when checking the success of an ERC20 approve call. Due to double encoding of the return data, the function reads the offset (0x20) as a success flag instead of decoding the actual boolean return value. This leads to false positives where failed approvals (returning false) are treated as successful, preventing the fallback logic (resetting to 0 then re-approving) from executing. The root cause is improper handling of nested ABI encoding in the low-level call. An attacker could exploit this with a token like USDT that returns false on approval failure instead of reverting, causing the system to believe an approval succeeded when it did not. The impact includes failed subsequent operations that depend on valid approvals, potentially leading to transaction failures or incorrect state assumptions.\n",
            "severity": "Low",
            "location": [
                "MainnetController.sol#L846-L857"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "_approve can re-use approveData in third call",
            "description": "The _approve function performs three potential approve calls: the initial attempt, a reset to zero, and a retry of the original amount. In the third call, the function re-encodes the approve calldata instead of reusing the previously constructed approveData variable. This is inefficient and results in unnecessary gas consumption during execution. The root cause is redundant calldata encoding in the third approve call. While not a security vulnerability, this issue increases transaction costs for users. An attacker cannot directly exploit this, but all users bear higher gas fees than necessary. The impact is increased operational costs without any functional benefit.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L861"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Quirks in OFT implementations",
            "description": "Different LayerZero OFT token implementations exhibit inconsistent behaviors, particularly in how they handle zero-address destinations. For example, USDT0 does not redirect transfers to address(0) or the token itself, while Sky's OFT implementation redirects such transfers to 0xdead. This inconsistency means that integrating new OFTs requires careful, case-by-case review rather than assuming uniform behavior. The root cause is the lack of standardized handling for edge cases across OFT implementations. If not properly reviewed, this could lead to unexpected token burns or misdirected funds during bridging operations. The impact is potential loss of funds or incorrect state if assumptions about OFT behavior are made without verification during integration.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L810-L814",
                "ForeignController.sol#L270-L274"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Minor issues",
            "description": "This finding aggregates several minor code quality issues: unused imports (IMetaMorpho, AccessControl, RateLimitHelpers), duplicated interface definitions (IATokenWithPool), a typo (\"multipled\" instead of \"multiplied\"), and the use of custom interfaces instead of standard ones like OpenZeppelin's. These issues do not pose direct security risks but indicate suboptimal code hygiene. The root causes include oversight during development and lack of strict linting or code review practices. While no direct exploitation is possible, these issues can increase maintenance burden, create confusion, and potentially introduce bugs during future modifications. The impact is reduced code readability, maintainability, and increased risk of human error in future development.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "spark-alm-controller/src/MainnetController.sol",
                "spark-alm-controller/src/ForeignController.sol",
                "spark-alm-controller/test/base-fork/Morpho.t.sol",
                "spark-alm-controller/test/base-fork/MorphoAllocations.t.sol",
                "spark-alm-controller/script/staging/test/StagingDeployment.t.sol"
            ]
        }
    ],
    "affected_files": {
        "ForeignController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { IERC20 }   from \"forge-std/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IPSM3 } from \"spark-psm/src/interfaces/IPSM3.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport  \"./interfaces/ILayerZero.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ncontract ForeignController is AccessControl {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    // NOTE: This is used to track individual transfers for offchain processing of CCTP transactions\n    event CCTPTransferInitiated(\n        uint64  indexed nonce,\n        uint32  indexed destinationDomain,\n        bytes32 indexed mintRecipient,\n        uint256 usdcAmount\n    );\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT       = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW      = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT       = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW      = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_LAYERZERO_TRANSFER = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public constant LIMIT_PSM_DEPOSIT        = keccak256(\"LIMIT_PSM_DEPOSIT\");\n    bytes32 public constant LIMIT_PSM_WITHDRAW       = keccak256(\"LIMIT_PSM_WITHDRAW\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP       = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN     = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n\n    IALMProxy   public immutable proxy;\n    ICCTPLike   public immutable cctp;\n    IPSM3       public immutable psm;\n    IRateLimits public immutable rateLimits;\n\n    IERC20 public immutable usdc;\n\n    mapping(uint32 destinationDomain     => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId => bytes32 layerZeroRecipient) public layerZeroRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address psm_,\n        address usdc_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        psm        = IPSM3(psm_);\n        usdc       = IERC20(usdc_);\n        cctp       = ICCTPLike(cctp_);\n    }\n\n    /**********************************************************************************************/\n    /*** Modifiers                                                                              ***/\n    /**********************************************************************************************/\n\n    modifier rateLimited(bytes32 key, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n        _;\n    }\n\n    modifier rateLimitedAsset(bytes32 key, address asset, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n        _;\n    }\n\n    modifier rateLimitExists(bytes32 key) {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"ForeignController/invalid-action\"\n        );\n        _;\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(uint32 destinationEndpointId, bytes32 layerZeroRecipient) \n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external onlyRole(FREEZER) {\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    function depositPSM(address asset, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_PSM_DEPOSIT, asset, amount)\n        returns (uint256 shares)\n    {\n        // Approve `asset` to PSM from the proxy (assumes the proxy has enough `asset`).\n        _approve(asset, address(psm), amount);\n\n        // Deposit `amount` of `asset` in the PSM, decode the result to get `shares`.\n        shares = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.deposit,\n                    (asset, address(proxy), amount)\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawPSM(address asset, uint256 maxAmount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assetsWithdrawn)\n    {\n        // Withdraw up to `maxAmount` of `asset` in the PSM, decode the result\n        // to get `assetsWithdrawn` (assumes the proxy has enough PSM shares).\n        assetsWithdrawn = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.withdraw,\n                    (asset, address(proxy), maxAmount)\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_PSM_WITHDRAW, asset),\n            assetsWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain)\n        external\n        onlyRole(RELAYER)\n        rateLimited(LIMIT_USDC_TO_CCTP, usdcAmount)\n        rateLimited(\n            RateLimitHelpers.makeDomainKey(LIMIT_USDC_TO_DOMAIN, destinationDomain),\n            usdcAmount\n        )\n    {\n        bytes32 mintRecipient = mintRecipients[destinationDomain];\n\n        require(mintRecipient != 0, \"ForeignController/domain-not-configured\");\n\n        // Approve USDC to CCTP from the proxy (assumes the proxy has enough USDC).\n        _approve(address(usdc), address(cctp), usdcAmount);\n\n        // If amount is larger than limit it must be split into multiple calls.\n        uint256 burnLimit = cctp.localMinter().burnLimitsPerMessage(address(usdc));\n\n        while (usdcAmount > burnLimit) {\n            _initiateCCTPTransfer(burnLimit, destinationDomain, mintRecipient);\n            usdcAmount -= burnLimit;\n        }\n\n        // Send remaining amount (if any)\n        if (usdcAmount > 0) {\n            _initiateCCTPTransfer(usdcAmount, destinationDomain, mintRecipient);\n        }\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount)\n        returns (uint256 shares)\n    {\n        // Note that whitelist is done by rate limits.\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount)\n        returns (uint256 shares)\n    {\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assets)\n    {\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount)\n    {\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens.\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 amountWithdrawn)\n    {\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Morpho functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setSupplyQueueMorpho(address morphoVault, Id[] memory newSupplyQueue)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).setSupplyQueue, (newSupplyQueue))\n        );\n    }\n\n    function updateWithdrawQueueMorpho(address morphoVault, uint256[] calldata indexes)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).updateWithdrawQueue, (indexes))\n        );\n    }\n\n    function reallocateMorpho(address morphoVault, MarketAllocation[] calldata allocations)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).reallocate, (allocations))\n        );\n    }\n\n\n    /**********************************************************************************************/\n    /*** Internal helper functions                                                              ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        // Decode the first 32 bytes of the data, ALMProxy returns 96 bytes\n        bytes32 result;\n        assembly { result := mload(add(data, 32)) }\n\n        // Decode the result to check if the approval was successful\n        bool decodedSuccess = (data.length == 0) || result != bytes32(0);\n\n        // If call succeeded with expected calldata, return\n        if (success && decodedSuccess) return;\n\n        // If call reverted, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, amount)));\n    }\n\n    function _initiateCCTPTransfer(\n        uint256 usdcAmount,\n        uint32  destinationDomain,\n        bytes32 mintRecipient\n    )\n        internal\n    {\n        uint64 nonce = abi.decode(\n            proxy.doCall(\n                address(cctp),\n                abi.encodeCall(\n                    cctp.depositForBurn,\n                    (\n                        usdcAmount,\n                        destinationDomain,\n                        mintRecipient,\n                        address(usdc)\n                    )\n                )\n            ),\n            (uint64)\n        );\n\n        emit CCTPTransferInitiated(nonce, destinationDomain, mintRecipient, usdcAmount);\n    }\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n}\n",
        "MorphoAllocations.t.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { MarketParamsLib }       from \"morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport { IMorpho, MarketParams } from \"morpho-blue/src/interfaces/IMorpho.sol\";\n\nimport { RateLimitHelpers } from \"../../src/RateLimitHelpers.sol\";\n\nimport \"./ForkTestBase.t.sol\";\n\ncontract MorphoTestBase is ForkTestBase {\n\n    address constant CBBTC              = 0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf;\n    address constant CBBTC_USDC_ORACLE  = 0x663BECd10daE6C4A3Dcd89F1d76c1174199639B9;\n    address constant MORPHO_DEFAULT_IRM = 0x46415998764C29aB2a25CbeA6254146D50D22687;\n\n    IMetaMorpho morphoVault = IMetaMorpho(Base.MORPHO_VAULT_SUSDC);\n    IMorpho     morpho      = IMorpho(Base.MORPHO);\n\n    MarketParams usdcIdle = MarketParams({\n        loanToken       : Base.USDC,\n        collateralToken : address(0),\n        oracle          : address(0),\n        irm             : address(0),\n        lltv            : 0\n    });\n    MarketParams usdcCBBTC = MarketParams({\n        loanToken       : Base.USDC,\n        collateralToken : CBBTC,\n        oracle          : CBBTC_USDC_ORACLE,\n        irm             : MORPHO_DEFAULT_IRM,\n        lltv            : 0.86e18\n    });\n\n    function setUp() public override {\n        super.setUp();\n\n        // Spell onboarding\n        vm.startPrank(Base.SPARK_EXECUTOR);\n        morphoVault.setIsAllocator(address(almProxy), true);\n        morphoVault.setIsAllocator(address(relayer),  false);\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_DEPOSIT(),\n                address(morphoVault)\n            ),\n            1_000_000e6,\n            uint256(1_000_000e6) / 1 days\n        );\n        vm.stopPrank();\n    }\n\n    function _getBlock() internal pure override returns (uint256) {\n        return 25340000;  // Jan 21, 2024\n    }\n\n    function positionShares(MarketParams memory marketParams) internal view returns (uint256) {\n        return morpho.position(MarketParamsLib.id(marketParams), address(morphoVault)).supplyShares;\n    }\n\n    function positionAssets(MarketParams memory marketParams) internal view returns (uint256) {\n        return positionShares(marketParams)\n            * marketAssets(marketParams)\n            / morpho.market(MarketParamsLib.id(marketParams)).totalSupplyShares;\n    }\n\n    function marketAssets(MarketParams memory marketParams) internal view returns (uint256) {\n        return morpho.market(MarketParamsLib.id(marketParams)).totalSupplyAssets;\n    }\n\n}\n\ncontract MorphoSetSupplyQueueMorphoFailureTests is MorphoTestBase {\n\n    function test_setSupplyQueueMorpho_notRelayer() external {\n        vm.expectRevert(abi.encodeWithSignature(\n            \"AccessControlUnauthorizedAccount(address,bytes32)\",\n            address(this),\n            RELAYER\n        ));\n        foreignController.setSupplyQueueMorpho(address(morphoVault), new Id[](0));\n    }\n\n    function test_setSupplyQueueMorpho_invalidVault() external {\n        vm.prank(relayer);\n        vm.expectRevert(\"ForeignController/invalid-action\");\n        foreignController.setSupplyQueueMorpho(makeAddr(\"fake-vault\"), new Id[](0));\n    }\n\n}\n\ncontract MorphoSetSupplyQueueMorphoSuccessTests is MorphoTestBase {\n\n    function test_setSupplyQueueMorpho() external {\n        // Switch order of existing markets\n        Id[] memory supplyQueueUSDC = new Id[](2);\n        supplyQueueUSDC[0] = MarketParamsLib.id(usdcIdle);\n        supplyQueueUSDC[1] = MarketParamsLib.id(usdcCBBTC);\n\n        assertEq(morphoVault.supplyQueueLength(), 2);\n\n        assertEq(Id.unwrap(morphoVault.supplyQueue(0)), Id.unwrap(MarketParamsLib.id(usdcCBBTC)));\n        assertEq(Id.unwrap(morphoVault.supplyQueue(1)), Id.unwrap(MarketParamsLib.id(usdcIdle)));\n\n        vm.prank(relayer);\n        foreignController.setSupplyQueueMorpho(address(morphoVault), supplyQueueUSDC);\n\n        assertEq(morphoVault.supplyQueueLength(), 2);\n\n        assertEq(Id.unwrap(morphoVault.supplyQueue(0)), Id.unwrap(MarketParamsLib.id(usdcIdle)));\n        assertEq(Id.unwrap(morphoVault.supplyQueue(1)), Id.unwrap(MarketParamsLib.id(usdcCBBTC)));\n    }\n\n}\n\ncontract MorphoUpdateWithdrawQueueMorphoFailureTests is MorphoTestBase {\n\n    function test_updateWithdrawQueueMorpho_notRelayer() external {\n        vm.expectRevert(abi.encodeWithSignature(\n            \"AccessControlUnauthorizedAccount(address,bytes32)\",\n            address(this),\n            RELAYER\n        ));\n        foreignController.updateWithdrawQueueMorpho(address(morphoVault), new uint256[](0));\n    }\n\n    function test_updateWithdrawQueueMorpho_invalidVault() external {\n        vm.prank(relayer);\n        vm.expectRevert(\"ForeignController/invalid-action\");\n        foreignController.updateWithdrawQueueMorpho(makeAddr(\"fake-vault\"), new uint256[](0));\n    }\n\n}\n\ncontract MorphoUpdateWithdrawQueueMorphoSuccessTests is MorphoTestBase {\n\n    function test_updateWithdrawQueueMorpho() external {\n        // Switch order of existing markets\n        uint256[] memory withdrawQueueUsdc = new uint256[](2);\n        withdrawQueueUsdc[0] = 1;\n        withdrawQueueUsdc[1] = 0;\n\n        assertEq(morphoVault.withdrawQueueLength(), 2);\n\n        assertEq(Id.unwrap(morphoVault.withdrawQueue(0)), Id.unwrap(MarketParamsLib.id(usdcIdle)));\n        assertEq(Id.unwrap(morphoVault.withdrawQueue(1)), Id.unwrap(MarketParamsLib.id(usdcCBBTC)));\n\n        vm.prank(relayer);\n        foreignController.updateWithdrawQueueMorpho(address(morphoVault), withdrawQueueUsdc);\n\n        assertEq(morphoVault.withdrawQueueLength(), 2);\n\n        assertEq(Id.unwrap(morphoVault.withdrawQueue(0)), Id.unwrap(MarketParamsLib.id(usdcCBBTC)));\n        assertEq(Id.unwrap(morphoVault.withdrawQueue(1)), Id.unwrap(MarketParamsLib.id(usdcIdle)));\n    }\n\n}\n\ncontract MorphoReallocateMorphoFailureTests is MorphoTestBase {\n\n    function test_reallocateMorpho_notRelayer() external {\n        vm.expectRevert(abi.encodeWithSignature(\n            \"AccessControlUnauthorizedAccount(address,bytes32)\",\n            address(this),\n            RELAYER\n        ));\n        foreignController.reallocateMorpho(address(morphoVault), new MarketAllocation[](0));\n    }\n\n    function test_reallocateMorpho_invalidVault() external {\n        vm.prank(relayer);\n        vm.expectRevert(\"ForeignController/invalid-action\");\n        foreignController.reallocateMorpho(makeAddr(\"fake-vault\"), new MarketAllocation[](0));\n    }\n\n}\n\ncontract MorphoReallocateMorphoSuccessTests is MorphoTestBase {\n\n    function test_reallocateMorpho() external {\n        vm.startPrank(Base.SPARK_EXECUTOR);\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_DEPOSIT(),\n                address(morphoVault)\n            ),\n            25_000_000e6,\n            uint256(5_000_000e6) / 1 days\n        );\n        vm.stopPrank();\n\n        // Refresh markets so calculations don't include interest\n        vm.prank(relayer);\n        foreignController.depositERC4626(address(morphoVault), 0);\n\n        uint256 positionCBBTC = positionAssets(usdcCBBTC);\n        uint256 positionIdle  = positionAssets(usdcIdle);\n\n        uint256 marketAssetsCBBTC = marketAssets(usdcCBBTC);\n        uint256 marketAssetsIdle  = marketAssets(usdcIdle);\n\n        assertEq(positionCBBTC, 12_128_319.737383e6);\n        assertEq(positionIdle,  0);\n\n        assertEq(marketAssetsCBBTC, 56_494_357.047568e6);\n        assertEq(marketAssetsIdle,  5.205521e6);\n\n        deal(Base.USDC, address(almProxy), 1_000_000e6);\n        vm.prank(relayer);\n        foreignController.depositERC4626(address(morphoVault), 1_000_000e6);\n\n        assertEq(positionAssets(usdcCBBTC), positionCBBTC + 1_000_000e6);\n        assertEq(positionAssets(usdcIdle),  0);\n\n        assertEq(marketAssets(usdcCBBTC), marketAssetsCBBTC + 1_000_000e6);\n        assertEq(marketAssets(usdcIdle),  marketAssetsIdle);\n\n        // Move new allocation into idle market\n        MarketAllocation[] memory reallocations = new MarketAllocation[](2);\n        reallocations[0] = MarketAllocation({\n            marketParams : usdcCBBTC,\n            assets       : positionCBBTC\n        });\n        reallocations[1] = MarketAllocation({\n            marketParams : usdcIdle,\n            assets       : 1_000_000e6\n        });\n\n        vm.prank(relayer);\n        foreignController.reallocateMorpho(address(morphoVault), reallocations);\n\n        // NOTE: No interest is accrued because deposit coverered all markets and is atomic\n        assertEq(positionAssets(usdcCBBTC), positionCBBTC);\n        assertEq(positionAssets(usdcIdle),  1_000_000e6);\n\n        assertEq(marketAssets(usdcCBBTC), marketAssetsCBBTC);\n        assertEq(marketAssets(usdcIdle),  marketAssetsIdle + 1_000_000e6);\n\n        // Move 400k back into CBBTC, note order has changed because of pulling from idle market\n        reallocations = new MarketAllocation[](2);\n        reallocations[0] = MarketAllocation({\n            marketParams : usdcIdle,\n            assets       : 600_000e6\n        });\n        reallocations[1] = MarketAllocation({\n            marketParams : usdcCBBTC,\n            assets       : positionCBBTC + 400_000e6\n        });\n\n        vm.prank(relayer);\n        foreignController.reallocateMorpho(address(morphoVault), reallocations);\n\n        assertEq(positionAssets(usdcCBBTC), positionCBBTC + 400_000e6);\n        assertEq(positionAssets(usdcIdle),  600_000e6);\n\n        assertEq(marketAssets(usdcCBBTC), marketAssetsCBBTC + 400_000e6);\n        assertEq(marketAssets(usdcIdle),  marketAssetsIdle + 600_000e6);\n    }\n\n}\n",
        "StagingDeployment.t.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ScriptTools } from \"dss-test/ScriptTools.sol\";\n\nimport \"forge-std/Test.sol\";\n\nimport { IERC20 }   from \"forge-std/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\n\nimport { IMetaMorpho, Id } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { MarketParamsLib }       from \"morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport { IMorpho, MarketParams } from \"morpho-blue/src/interfaces/IMorpho.sol\";\n\nimport { Usds } from \"usds/src/Usds.sol\";\n\nimport { SUsds } from \"sdai/src/SUsds.sol\";\n\nimport { Base }     from \"spark-address-registry/Base.sol\";\nimport { Ethereum } from \"spark-address-registry/Ethereum.sol\";\n\nimport { PSM3 } from \"spark-psm/src/PSM3.sol\";\n\nimport { Bridge }                from \"xchain-helpers/testing/Bridge.sol\";\nimport { Domain, DomainHelpers } from \"xchain-helpers/testing/Domain.sol\";\nimport { CCTPBridgeTesting }     from \"xchain-helpers/testing/bridges/CCTPBridgeTesting.sol\";\nimport { CCTPForwarder }         from \"xchain-helpers/forwarders/CCTPForwarder.sol\";\n\nimport { MainnetControllerDeploy } from \"../../../deploy/ControllerDeploy.sol\";\nimport { MainnetControllerInit }   from \"../../../deploy/MainnetControllerInit.sol\";\n\nimport { IRateLimits } from \"../../../src/interfaces/IRateLimits.sol\";\n\nimport { ALMProxy }          from \"../../../src/ALMProxy.sol\";\nimport { ForeignController } from \"../../../src/ForeignController.sol\";\nimport { MainnetController } from \"../../../src/MainnetController.sol\";\nimport { RateLimits }        from \"../../../src/RateLimits.sol\";\n\nimport { RateLimitHelpers }  from \"../../../src/RateLimitHelpers.sol\";\n\ninterface IVatLike {\n    function can(address, address) external view returns (uint256);\n}\n\ninterface IMapleTokenExtended is IERC4626 {\n    function manager() external view returns (address);\n}\n\ninterface IWithdrawalManagerLike {\n    function processRedemptions(uint256 maxSharesToProcess) external;\n}\n\ninterface IPoolManagerLike {\n    function withdrawalManager() external view returns (IWithdrawalManagerLike);\n    function poolDelegate() external view returns (address);\n}\n\ncontract StagingDeploymentTestBase is Test {\n\n    using stdJson           for *;\n    using DomainHelpers     for *;\n    using CCTPBridgeTesting for *;\n    using ScriptTools       for *;\n\n    // AAVE aTokens for testing\n    address constant AUSDS = 0x32a6268f9Ba3642Dda7892aDd74f1D34469A4259;\n    address constant AUSDC = 0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c;\n\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    uint256 constant RELEASE_DATE = 20241227;\n\n    // Common variables\n    address admin;\n\n    // Configuration data\n    string inputArbitrum;\n    string inputBase;\n    string inputMainnet;\n\n    // Bridging\n    Domain mainnet;\n    Domain arbitrum;\n    Domain base;\n\n    Bridge cctpBridgeArbitrum;\n    Bridge cctpBridgeBase;\n\n    // Mainnet contracts\n\n    Usds   usds;\n    SUsds  susds;\n    IERC20 usdc;\n    IERC20 dai;\n\n    address vault;\n    address relayerSafe;\n    address usdsJoin;\n\n    ALMProxy          almProxy;\n    MainnetController mainnetController;\n    RateLimits        rateLimits;\n\n    // Arbitrum contracts\n\n    address relayerSafeArbitrum;\n\n    PSM3 psmArbitrum;\n\n    IERC20 usdsArbitrum;\n    IERC20 susdsArbitrum;\n    IERC20 usdcArbitrum;\n\n    ALMProxy          arbitrumAlmProxy;\n    ForeignController arbitrumController;\n    RateLimits        arbitrumRateLimits;\n\n    // Base contracts\n\n    address relayerSafeBase;\n\n    PSM3 psmBase;\n\n    IERC20 usdsBase;\n    IERC20 susdsBase;\n    IERC20 usdcBase;\n\n    ALMProxy          baseAlmProxy;\n    ForeignController baseController;\n    RateLimits        baseRateLimits;\n\n    /**********************************************************************************************/\n    /**** Setup                                                                                 ***/\n    /**********************************************************************************************/\n\n    function setUp() public virtual {\n        vm.setEnv(\"FOUNDRY_ROOT_CHAINID\", \"1\");\n\n        // Domains and bridge\n        mainnet    = getChain(\"mainnet\").createSelectFork(22233941);  // April 9, 2025\n        base       = getChain(\"base\").createFork(28721799);           // April 9, 2025\n        arbitrum   = getChain(\"arbitrum_one\").createFork(324683441);  // April 9, 2025\n\n        cctpBridgeArbitrum = CCTPBridgeTesting.createCircleBridge(mainnet, arbitrum);\n        cctpBridgeBase     = CCTPBridgeTesting.createCircleBridge(mainnet, base);\n\n        // JSON data\n        inputArbitrum = ScriptTools.readInput(\"arbitrum_one-staging\");\n        inputBase     = ScriptTools.readInput(\"base-staging\");\n        inputMainnet  = ScriptTools.readInput(\"mainnet-staging\");\n\n        // --- Mainnet ---\n\n        // Roles\n        admin       = inputMainnet.readAddress(\".admin\");\n        relayerSafe = inputMainnet.readAddress(\".relayer\");\n\n        // Tokens\n        usds  = Usds(inputMainnet.readAddress(\".usds\"));\n        susds = SUsds(inputMainnet.readAddress(\".susds\"));\n        usdc  = IERC20(inputMainnet.readAddress(\".usdc\"));\n        dai   = IERC20(inputMainnet.readAddress(\".dai\"));\n\n        // Dependencies\n        vault    = inputMainnet.readAddress(\".allocatorVault\");\n        usdsJoin = inputMainnet.readAddress(\".usdsJoin\");\n\n        // ALM system\n        almProxy          = ALMProxy(payable(inputMainnet.readAddress(\".almProxy\")));\n        rateLimits        = RateLimits(inputMainnet.readAddress(\".rateLimits\"));\n        mainnetController = MainnetController(inputMainnet.readAddress(\".controller\"));\n\n        // --- Arbitrum ---\n\n        // Roles\n        relayerSafeArbitrum = inputArbitrum.readAddress(\".relayer\");\n\n        // Tokens\n        usdsArbitrum  = IERC20(inputArbitrum.readAddress(\".usds\"));\n        susdsArbitrum = IERC20(inputArbitrum.readAddress(\".susds\"));\n        usdcArbitrum  = IERC20(inputArbitrum.readAddress(\".usdc\"));\n\n        // ALM system\n        arbitrumAlmProxy   = ALMProxy(payable(inputArbitrum.readAddress(\".almProxy\")));\n        arbitrumController = ForeignController(inputArbitrum.readAddress(\".controller\"));\n        arbitrumRateLimits = RateLimits(inputArbitrum.readAddress(\".rateLimits\"));\n\n        // PSM3\n        psmArbitrum = PSM3(inputArbitrum.readAddress(\".psm\"));\n\n        // --- Base ---\n\n        // Roles\n        relayerSafeBase = inputBase.readAddress(\".relayer\");\n\n        // Tokens\n        usdsBase  = IERC20(inputBase.readAddress(\".usds\"));\n        susdsBase = IERC20(inputBase.readAddress(\".susds\"));\n        usdcBase  = IERC20(inputBase.readAddress(\".usdc\"));\n\n        // ALM system\n        baseAlmProxy   = ALMProxy(payable(inputBase.readAddress(\".almProxy\")));\n        baseController = ForeignController(inputBase.readAddress(\".controller\"));\n        baseRateLimits = RateLimits(inputBase.readAddress(\".rateLimits\"));\n\n        // PSM3\n        psmBase = PSM3(inputBase.readAddress(\".psm\"));\n\n        mainnet.selectFork();\n\n        deal(address(usds), address(usdsJoin), 1000e18);  // Ensure there is enough balance\n    }\n}\n\ncontract MainnetStagingDeploymentTests is StagingDeploymentTestBase {\n\n    function test_mintUSDS() public {\n        uint256 startingBalance = usds.balanceOf(address(almProxy));\n\n        vm.prank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n\n        assertEq(usds.balanceOf(address(almProxy)), startingBalance + 10e18);\n    }\n\n    function test_mintAndSwapToUSDC() public {\n        uint256 startingBalance = usdc.balanceOf(address(almProxy));\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        vm.stopPrank();\n\n        assertEq(usdc.balanceOf(address(almProxy)), startingBalance + 10e6);\n    }\n\n    function test_depositAndWithdrawUsdsFromSUsds() public {\n        uint256 startingBalance = usds.balanceOf(address(almProxy));\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.depositERC4626(Ethereum.SUSDS, 10e18);\n        skip(1 days);\n        mainnetController.withdrawERC4626(Ethereum.SUSDS, 10e18);\n        vm.stopPrank();\n\n        assertEq(usds.balanceOf(address(almProxy)), startingBalance + 10e18);\n\n        assertGe(IERC4626(Ethereum.SUSDS).balanceOf(address(almProxy)), 0);  // Interest earned\n    }\n\n    function test_depositAndRedeemUsdsFromSUsds() public {\n        uint256 startingBalance = usds.balanceOf(address(almProxy));\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.depositERC4626(Ethereum.SUSDS, 10e18);\n        skip(1 days);\n        mainnetController.redeemERC4626(Ethereum.SUSDS, IERC4626(Ethereum.SUSDS).balanceOf(address(almProxy)));\n        vm.stopPrank();\n\n        assertGe(usds.balanceOf(address(almProxy)), startingBalance + 10e18);  // Interest earned\n\n        assertEq(IERC4626(Ethereum.SUSDS).balanceOf(address(almProxy)), 0);\n    }\n\n    function test_depositAndWithdrawUsdsFromAave() public {\n        uint256 startingBalance = usds.balanceOf(address(almProxy));\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.depositAave(AUSDS, 10e6);\n        skip(1 days);\n        mainnetController.withdrawAave(AUSDS, type(uint256).max);\n        vm.stopPrank();\n\n        assertGe(usds.balanceOf(address(almProxy)), startingBalance + 10e6);  // Interest earned\n    }\n\n    function test_depositAndWithdrawUsdcFromAave() public {\n        uint256 startingBalance = usdc.balanceOf(address(almProxy));\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.depositAave(AUSDC, 10e6);\n        skip(1 days);\n        mainnetController.withdrawAave(AUSDC, type(uint256).max);\n        vm.stopPrank();\n\n        assertGe(usdc.balanceOf(address(almProxy)), startingBalance + 10e6);  // Interest earned\n    }\n\n    function test_mintDepositCooldownAssetsBurnUsde() public {\n        uint256 startingBalance = usdc.balanceOf(address(almProxy));\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.prepareUSDeMint(10e6);\n        vm.stopPrank();\n\n        _simulateUsdeMint(10e6);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.depositERC4626(Ethereum.SUSDE, 10e18);\n        skip(1 days);\n        mainnetController.cooldownAssetsSUSDe(10e18 - 1);  // Rounding\n        skip(7 days);\n        mainnetController.unstakeSUSDe();\n        mainnetController.prepareUSDeBurn(10e18 - 1);\n        vm.stopPrank();\n\n        _simulateUsdeBurn(10e18 - 1);\n\n        assertEq(usdc.balanceOf(address(almProxy)), startingBalance + 10e6 - 1);  // Rounding not captured\n\n        assertGe(IERC4626(Ethereum.SUSDE).balanceOf(address(almProxy)), 0);  // Interest earned\n    }\n\n    function test_mintDepositCooldownSharesBurnUsde() public {\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.prepareUSDeMint(10e6);\n        vm.stopPrank();\n\n        uint256 startingBalance = usdc.balanceOf(address(almProxy));\n\n        _simulateUsdeMint(10e6);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.depositERC4626(Ethereum.SUSDE, 10e18);\n        skip(1 days);\n        uint256 usdeAmount = mainnetController.cooldownSharesSUSDe(IERC4626(Ethereum.SUSDE).balanceOf(address(almProxy)));\n        skip(7 days);\n        mainnetController.unstakeSUSDe();\n\n        // Handle situation where usde balance of ALM Proxy is higher than max rate limit\n        uint256 maxBurnAmount = rateLimits.getCurrentRateLimit(mainnetController.LIMIT_USDE_BURN());\n        uint256 burnAmount    = usdeAmount > maxBurnAmount ? maxBurnAmount : usdeAmount;\n        mainnetController.prepareUSDeBurn(burnAmount);\n\n        vm.stopPrank();\n\n        _simulateUsdeBurn(burnAmount);\n\n        assertGe(usdc.balanceOf(address(almProxy)), startingBalance - 1);  // Interest earned (rounding)\n\n        assertEq(IERC4626(Ethereum.SUSDE).balanceOf(address(almProxy)), 0);\n    }\n\n    // TODO: Get Maple team to whitelist staging almProxy for testing when needed\n    // function test_mintDepositWithdrawSyrupUsdc() public {\n    //     vm.startPrank(relayerSafe);\n    //     mainnetController.mintUSDS(10e18);\n    //     mainnetController.swapUSDSToUSDC(10e6);\n    //     vm.stopPrank();\n\n    //     uint256 startingBalance = usdc.balanceOf(address(almProxy));\n\n    //     vm.startPrank(relayerSafe);\n    //     uint256 shares = mainnetController.depositERC4626(Ethereum.SYRUP_USDC, 10e6);\n\n    //     skip(1 days);\n\n    //     mainnetController.requestMapleRedemption(Ethereum.SYRUP_USDC, shares);\n\n    //     IMapleTokenExtended syrup = IMapleTokenExtended(Ethereum.SYRUP_USDC);\n\n    //     IWithdrawalManagerLike withdrawManager = IPoolManagerLike(syrup.manager()).withdrawalManager();\n    //     vm.startPrank(IPoolManagerLike(syrup.manager()).poolDelegate());\n    //     withdrawManager.processRedemptions(shares);\n    //     vm.stopPrank();\n\n    //     assertGe(usdc.balanceOf(address(almProxy)), startingBalance - 1);  // Interest earned (rounding)\n    // }\n\n\n    /**********************************************************************************************/\n    /**** Helper functions                                                                      ***/\n    /**********************************************************************************************/\n\n    // NOTE: In reality these actions are performed by the signer submitting an order with an\n    //       EIP712 signature which is verified by the ethenaMinter contract,\n    //       minting/burning USDe into the ALMProxy. Also, for the purposes of this test,\n    //       minting/burning is done 1:1 with USDC.\n\n    // TODO: Try doing ethena minting with EIP-712 signatures (vm.sign)\n\n    function _simulateUsdeMint(uint256 amount) internal {\n        vm.prank(Ethereum.ETHENA_MINTER);\n        usdc.transferFrom(address(almProxy), Ethereum.ETHENA_MINTER, amount);\n        deal(\n            Ethereum.USDE,\n            address(almProxy),\n            IERC20(Ethereum.USDE).balanceOf(address(almProxy)) + amount * 1e12\n        );\n    }\n\n    function _simulateUsdeBurn(uint256 amount) internal {\n        vm.prank(Ethereum.ETHENA_MINTER);\n        IERC20(Ethereum.USDE).transferFrom(address(almProxy), Ethereum.ETHENA_MINTER, amount);\n        deal(address(usdc), address(almProxy), usdc.balanceOf(address(almProxy)) + amount / 1e12);\n    }\n\n}\n\ncontract BaseStagingDeploymentTests is StagingDeploymentTestBase {\n\n    using DomainHelpers     for *;\n    using CCTPBridgeTesting for *;\n\n    address constant AUSDC_BASE = 0x4e65fE4DbA92790696d040ac24Aa414708F5c0AB;\n    address constant MORPHO     = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\n\n    function setUp() public override {\n        super.setUp();\n\n        base.selectFork();\n    }\n\n    function test_transferCCTP() public {\n        base.selectFork();\n\n        uint256 startingBalance = usdcBase.balanceOf(address(baseAlmProxy));\n\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_BASE);\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToDestination(true);\n\n        assertEq(usdcBase.balanceOf(address(baseAlmProxy)), startingBalance + 10e6);\n    }\n\n    function test_transferToPSM() public {\n        base.selectFork();\n\n        uint256 startingBalance = usdcBase.balanceOf(address(psmBase));\n\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_BASE);\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToDestination(true);\n\n        uint256 startingShares = psmBase.shares(address(baseAlmProxy));\n\n        vm.startPrank(relayerSafeBase);\n        baseController.depositPSM(address(usdcBase), 10e6);\n        vm.stopPrank();\n\n        assertEq(usdcBase.balanceOf(address(psmBase)), startingBalance + 10e6);\n\n        assertEq(psmBase.shares(address(baseAlmProxy)), startingShares + psmBase.convertToShares(10e18));\n    }\n\n    function test_addAndRemoveFundsFromBasePSM() public {\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_BASE);\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToDestination(true);\n\n        vm.startPrank(relayerSafeBase);\n        baseController.depositPSM(address(usdcBase), 10e6);\n        skip(1 days);\n        baseController.withdrawPSM(address(usdcBase), 10e6);\n        baseController.transferUSDCToCCTP(10e6 - 1, CCTPForwarder.DOMAIN_ID_CIRCLE_ETHEREUM);  // Account for potential rounding\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToSource(true);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.swapUSDCToUSDS(10e6 - 1);\n        mainnetController.burnUSDS((10e6 - 1) * 1e12);\n        vm.stopPrank();\n    }\n\n    function test_addAndRemoveFundsFromBaseAAVE() public {\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_BASE);\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToDestination(true);\n\n        vm.startPrank(relayerSafeBase);\n        baseController.depositAave(AUSDC_BASE, 10e6);\n        skip(1 days);\n        baseController.withdrawAave(AUSDC_BASE, 10e6);\n\n        assertEq(usdcBase.balanceOf(address(baseAlmProxy)), 10e6);\n\n        assertGe(IERC20(AUSDC_BASE).balanceOf(address(baseAlmProxy)), 0);  // Interest earned\n\n        baseController.transferUSDCToCCTP(10e6 - 1, CCTPForwarder.DOMAIN_ID_CIRCLE_ETHEREUM);  // Account for potential rounding\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToSource(true);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.swapUSDCToUSDS(10e6 - 1);\n        mainnetController.burnUSDS((10e6 - 1) * 1e12);\n        vm.stopPrank();\n    }\n\n    function test_depositWithdrawFundsFromBaseMorphoUsdc() public {\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_BASE);\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToDestination(true);\n\n        vm.startPrank(relayerSafeBase);\n        baseController.depositERC4626(Base.MORPHO_VAULT_SUSDC, 10e6);\n        skip(1 days);\n        baseController.withdrawERC4626(Base.MORPHO_VAULT_SUSDC, 10e6);\n\n        assertEq(usdcBase.balanceOf(address(baseAlmProxy)), 10e6);\n\n        assertGe(IERC20(Base.MORPHO_VAULT_SUSDC).balanceOf(address(baseAlmProxy)), 0);  // Interest earned\n\n        baseController.transferUSDCToCCTP(1e6 - 1, CCTPForwarder.DOMAIN_ID_CIRCLE_ETHEREUM);  // Account for potential rounding\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToSource(true);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.swapUSDCToUSDS(1e6 - 1);\n        mainnetController.burnUSDS((1e6 - 1) * 1e12);\n        vm.stopPrank();\n    }\n\n    function test_depositRedeemFundsFromBaseMorphoUsdc() public {\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_BASE);\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToDestination(true);\n\n        vm.startPrank(relayerSafeBase);\n        baseController.depositERC4626(Base.MORPHO_VAULT_SUSDC, 10e6);\n        skip(1 days);\n        baseController.redeemERC4626(Base.MORPHO_VAULT_SUSDC, IERC20(Base.MORPHO_VAULT_SUSDC).balanceOf(address(baseAlmProxy)));\n\n        assertGe(usdcBase.balanceOf(address(baseAlmProxy)), 10e6);  // Interest earned\n\n        assertEq(IERC20(Base.MORPHO_VAULT_SUSDC).balanceOf(address(baseAlmProxy)), 0);\n\n        baseController.transferUSDCToCCTP(1e6 - 1, CCTPForwarder.DOMAIN_ID_CIRCLE_ETHEREUM);  // Account for potential rounding\n        vm.stopPrank();\n\n        cctpBridgeBase.relayMessagesToSource(true);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.swapUSDCToUSDS(1e6 - 1);\n        mainnetController.burnUSDS((1e6 - 1) * 1e12);\n        vm.stopPrank();\n    }\n\n}\n\ncontract ArbitrumStagingDeploymentTests is StagingDeploymentTestBase {\n\n    using DomainHelpers     for *;\n    using CCTPBridgeTesting for *;\n\n    function setUp() public override {\n        super.setUp();\n\n        arbitrum.selectFork();\n    }\n\n    function test_transferCCTP() public {\n        arbitrum.selectFork();\n\n        uint256 startingBalance = usdcArbitrum.balanceOf(address(arbitrumAlmProxy));\n\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_ARBITRUM_ONE);\n        vm.stopPrank();\n\n        cctpBridgeArbitrum.relayMessagesToDestination(true);\n\n        assertEq(usdcArbitrum.balanceOf(address(arbitrumAlmProxy)), startingBalance + 10e6);\n    }\n\n    function test_transferToPSM() public {\n        arbitrum.selectFork();\n\n        uint256 startingBalance = usdcArbitrum.balanceOf(address(psmArbitrum));\n\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_ARBITRUM_ONE);\n        vm.stopPrank();\n\n        cctpBridgeArbitrum.relayMessagesToDestination(true);\n\n        uint256 startingShares = psmArbitrum.shares(address(arbitrumAlmProxy));\n\n        vm.startPrank(relayerSafeArbitrum);\n        arbitrumController.depositPSM(address(usdcArbitrum), 10e6);\n        vm.stopPrank();\n\n        assertEq(usdcArbitrum.balanceOf(address(psmArbitrum)), startingBalance + 10e6);\n\n        assertEq(psmArbitrum.shares(address(arbitrumAlmProxy)), startingShares + psmArbitrum.convertToShares(10e18));\n    }\n\n    function test_addAndRemoveFundsFromArbitrumPSM() public {\n        mainnet.selectFork();\n\n        vm.startPrank(relayerSafe);\n        mainnetController.mintUSDS(10e18);\n        mainnetController.swapUSDSToUSDC(10e6);\n        mainnetController.transferUSDCToCCTP(10e6, CCTPForwarder.DOMAIN_ID_CIRCLE_ARBITRUM_ONE);\n        vm.stopPrank();\n\n        cctpBridgeArbitrum.relayMessagesToDestination(true);\n\n        vm.startPrank(relayerSafeArbitrum);\n        arbitrumController.depositPSM(address(usdcArbitrum), 10e6);\n        skip(1 days);\n        arbitrumController.withdrawPSM(address(usdcArbitrum), 10e6);\n        arbitrumController.transferUSDCToCCTP(10e6 - 1, CCTPForwarder.DOMAIN_ID_CIRCLE_ETHEREUM);  // Account for potential rounding\n        vm.stopPrank();\n\n        cctpBridgeArbitrum.relayMessagesToSource(true);\n\n        vm.startPrank(relayerSafe);\n        mainnetController.swapUSDCToUSDS(10e6 - 1);\n        mainnetController.burnUSDS((10e6 - 1) * 1e12);\n        vm.stopPrank();\n    }\n\n}\n",
        "Morpho.t.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\n\nimport { IMetaMorpho, Id }       from \"metamorpho/interfaces/IMetaMorpho.sol\";\nimport { MarketParamsLib }       from \"morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport { IMorpho, MarketParams } from \"morpho-blue/src/interfaces/IMorpho.sol\";\n\nimport { RateLimitHelpers } from \"../../src/RateLimitHelpers.sol\";\n\nimport \"./ForkTestBase.t.sol\";\n\ncontract MorphoBaseTest is ForkTestBase {\n\n    address constant MORPHO = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\n\n    address constant MORPHO_VAULT_USDS = 0x0fFDeCe791C5a2cb947F8ddBab489E5C02c6d4F7;\n    address constant MORPHO_VAULT_USDC = 0x305E03Ed9ADaAB22F4A58c24515D79f2B1E2FD5D;\n\n    IERC4626 usdsVault = IERC4626(MORPHO_VAULT_USDS);\n    IERC4626 usdcVault = IERC4626(MORPHO_VAULT_USDC);\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.startPrank(Base.SPARK_EXECUTOR);\n\n        // Add in the idle markets so deposits can be made\n        MarketParams memory usdsParams = MarketParams({\n            loanToken:       Base.USDS,\n            collateralToken: address(0),\n            oracle:          address(0),\n            irm:             address(0),\n            lltv:            0\n        });\n        MarketParams memory usdcParams = MarketParams({\n            loanToken:       Base.USDC,\n            collateralToken: address(0),\n            oracle:          address(0),\n            irm:             address(0),\n            lltv:            0\n        });\n        IMorpho(MORPHO).createMarket(\n            usdsParams\n        );\n        // USDC idle market already exists\n        IMetaMorpho(MORPHO_VAULT_USDS).submitCap(\n            usdsParams,\n            type(uint184).max\n        );\n        IMetaMorpho(MORPHO_VAULT_USDC).submitCap(\n            usdcParams,\n            type(uint184).max\n        );\n\n        skip(1 days);\n\n        IMetaMorpho(MORPHO_VAULT_USDS).acceptCap(usdsParams);\n        IMetaMorpho(MORPHO_VAULT_USDC).acceptCap(usdcParams);\n\n        Id[] memory supplyQueueUSDS = new Id[](1);\n        supplyQueueUSDS[0] = MarketParamsLib.id(usdsParams);\n        IMetaMorpho(MORPHO_VAULT_USDS).setSupplyQueue(supplyQueueUSDS);\n\n        Id[] memory supplyQueueUSDC = new Id[](1);\n        supplyQueueUSDC[0] = MarketParamsLib.id(usdcParams);\n        IMetaMorpho(MORPHO_VAULT_USDC).setSupplyQueue(supplyQueueUSDC);\n\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_DEPOSIT(),\n                MORPHO_VAULT_USDS\n            ),\n            25_000_000e18,\n            uint256(5_000_000e18) / 1 days\n        );\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_DEPOSIT(),\n                MORPHO_VAULT_USDC\n            ),\n            25_000_000e6,\n            uint256(5_000_000e6) / 1 days\n        );\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_WITHDRAW(),\n                MORPHO_VAULT_USDS\n            ),\n            10_000_000e18,\n            uint256(5_000_000e18) / 1 days\n        );\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_WITHDRAW(),\n                MORPHO_VAULT_USDC\n            ),\n            10_000_000e6,\n            uint256(5_000_000e6) / 1 days\n        );\n\n        vm.stopPrank();\n    }\n\n    function _getBlock() internal pure override returns (uint256) {\n        return 22841965;  // November 24, 2024\n    }\n\n}\n\n// NOTE: Only testing USDS for non-rate limit failures as it doesn't matter which asset is used\n// TODO: Refactor tests here to be generic 4626, testing morpho as a subset, rename file and functions\n\ncontract MorphoDepositFailureTests is MorphoBaseTest {\n\n    function test_morpho_deposit_notRelayer() external {\n        vm.expectRevert(abi.encodeWithSignature(\n            \"AccessControlUnauthorizedAccount(address,bytes32)\",\n            address(this),\n            RELAYER\n        ));\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n    }\n\n    function test_morpho_deposit_zeroMaxAmount() external {\n        vm.prank(relayer);\n        vm.expectRevert(\"RateLimits/zero-maxAmount\");\n        foreignController.depositERC4626(makeAddr(\"fake-token\"), 1e18);\n    }\n\n    function test_morpho_usds_deposit_rateLimitedBoundary() external {\n        deal(Base.USDS, address(almProxy), 25_000_000e18 + 1);\n\n        vm.expectRevert(\"RateLimits/rate-limit-exceeded\");\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 25_000_000e18 + 1);\n\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 25_000_000e18);\n    }\n\n    function test_morpho_usdc_deposit_rateLimitedBoundary() external {\n        deal(Base.USDC, address(almProxy), 25_000_000e6 + 1);\n\n        vm.expectRevert(\"RateLimits/rate-limit-exceeded\");\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDC, 25_000_000e6 + 1);\n\n        foreignController.depositERC4626(MORPHO_VAULT_USDC, 25_000_000e6);\n    }\n\n}\n\ncontract MorphoDepositSuccessTests is MorphoBaseTest {\n\n    function test_morpho_usds_deposit() public {\n        deal(Base.USDS, address(almProxy), 1_000_000e18);\n\n        assertEq(usdsVault.convertToAssets(usdsVault.balanceOf(address(almProxy))),          0);\n        assertEq(IERC20(Base.USDS).balanceOf(address(almProxy)),                             1_000_000e18);\n        assertEq(IERC20(Base.USDS).allowance(address(almProxy), address(MORPHO_VAULT_USDS)), 0);\n\n        vm.prank(relayer);\n        assertEq(foreignController.depositERC4626(MORPHO_VAULT_USDS, 1_000_000e18), 1_000_000e18);\n\n        assertEq(usdsVault.convertToAssets(usdsVault.balanceOf(address(almProxy))),          1_000_000e18);\n        assertEq(IERC20(Base.USDS).balanceOf(address(almProxy)),                             0);\n        assertEq(IERC20(Base.USDS).allowance(address(almProxy), address(MORPHO_VAULT_USDS)), 0);\n    }\n\n    function test_morpho_usdc_deposit() public {\n        deal(Base.USDC, address(almProxy), 1_000_000e6);\n\n        assertEq(usdcVault.convertToAssets(usdcVault.balanceOf(address(almProxy))),          0);\n        assertEq(IERC20(Base.USDC).balanceOf(address(almProxy)),                             1_000_000e6);\n        assertEq(IERC20(Base.USDC).allowance(address(almProxy), address(MORPHO_VAULT_USDC)), 0);\n\n        vm.prank(relayer);\n        assertEq(foreignController.depositERC4626(MORPHO_VAULT_USDC, 1_000_000e6), 1_000_000e18);\n\n        assertEq(usdcVault.convertToAssets(usdcVault.balanceOf(address(almProxy))),          1_000_000e6);\n        assertEq(IERC20(Base.USDC).balanceOf(address(almProxy)),                             0);\n        assertEq(IERC20(Base.USDC).allowance(address(almProxy), address(MORPHO_VAULT_USDC)), 0);\n    }\n\n}\n\ncontract MorphoWithdrawFailureTests is MorphoBaseTest {\n\n    function test_morpho_withdraw_notRelayer() external {\n        vm.expectRevert(abi.encodeWithSignature(\n            \"AccessControlUnauthorizedAccount(address,bytes32)\",\n            address(this),\n            RELAYER\n        ));\n        foreignController.withdrawERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n    }\n\n    function test_morpho_withdraw_zeroMaxAmount() external {\n        vm.prank(relayer);\n        vm.expectRevert(\"RateLimits/zero-maxAmount\");\n        foreignController.withdrawERC4626(makeAddr(\"fake-token\"), 1_000_000e18);\n    }\n\n    function test_morpho_usds_withdraw_rateLimitBoundary() external {\n        deal(Base.USDS, address(almProxy), 10_000_000e18 + 1);\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 10_000_000e18 + 1);\n\n        vm.expectRevert(\"RateLimits/rate-limit-exceeded\");\n        foreignController.withdrawERC4626(MORPHO_VAULT_USDS, 10_000_000e18 + 1);\n\n        foreignController.withdrawERC4626(MORPHO_VAULT_USDS, 10_000_000e18);\n    }\n\n    function test_morpho_usdc_withdraw_rateLimitBoundary() external {\n        deal(Base.USDC, address(almProxy), 10_000_000e18 + 1);\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDC, 10_000_000e6 + 1);\n\n        vm.expectRevert(\"RateLimits/rate-limit-exceeded\");\n        foreignController.withdrawERC4626(MORPHO_VAULT_USDC, 10_000_000e6 + 1);\n\n        foreignController.withdrawERC4626(MORPHO_VAULT_USDC, 10_000_000e6);\n    }\n\n}\n\ncontract MorphoWithdrawSuccessTests is MorphoBaseTest {\n\n    function test_morpho_usds_withdraw() public {\n        deal(Base.USDS, address(almProxy), 1_000_000e18);\n        vm.prank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n\n        assertEq(usdsVault.convertToAssets(usdsVault.balanceOf(address(almProxy))), 1_000_000e18);\n        assertEq(IERC20(Base.USDS).balanceOf(address(almProxy)),                    0);\n\n        vm.prank(relayer);\n        assertEq(foreignController.withdrawERC4626(MORPHO_VAULT_USDS, 1_000_000e18), 1_000_000e18);\n\n        assertEq(usdsVault.convertToAssets(usdsVault.balanceOf(address(almProxy))), 0);\n        assertEq(IERC20(Base.USDS).balanceOf(address(almProxy)),                    1_000_000e18);\n    }\n\n    function test_morpho_usdc_withdraw() public {\n        deal(Base.USDC, address(almProxy), 1_000_000e6);\n        vm.prank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDC, 1_000_000e6);\n\n        assertEq(usdcVault.convertToAssets(usdcVault.balanceOf(address(almProxy))), 1_000_000e6);\n        assertEq(IERC20(Base.USDC).balanceOf(address(almProxy)),                    0);\n\n        vm.prank(relayer);\n        assertEq(foreignController.withdrawERC4626(MORPHO_VAULT_USDC, 1_000_000e6), 1_000_000e18);\n\n        assertEq(usdcVault.convertToAssets(usdcVault.balanceOf(address(almProxy))), 0);\n        assertEq(IERC20(Base.USDC).balanceOf(address(almProxy)),                    1_000_000e6);\n    }\n\n}\n\ncontract MorphoRedeemFailureTests is MorphoBaseTest {\n\n    function test_morpho_redeem_notRelayer() external {\n        vm.expectRevert(abi.encodeWithSignature(\n            \"AccessControlUnauthorizedAccount(address,bytes32)\",\n            address(this),\n            RELAYER\n        ));\n        foreignController.redeemERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n    }\n\n    function test_morpho_redeem_zeroMaxAmount() external {\n        // Longer setup because rate limit revert is at the end of the function\n        vm.startPrank(Base.SPARK_EXECUTOR);\n        rateLimits.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                foreignController.LIMIT_4626_WITHDRAW(),\n                MORPHO_VAULT_USDS\n            ),\n            0,\n            0\n        );\n        vm.stopPrank();\n\n        deal(Base.USDS, address(almProxy), 1_000_000e18);\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n\n        vm.expectRevert(\"RateLimits/zero-maxAmount\");\n        foreignController.redeemERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n    }\n\n    function test_morpho_usds_redeem_rateLimitBoundary() external {\n        deal(Base.USDS, address(almProxy), 20_000_000e18);\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 20_000_000e18);\n\n        IERC4626 vault = IERC4626(MORPHO_VAULT_USDS);\n\n        uint256 overBoundaryShares = vault.convertToShares(10_000_000e18 + 1);\n        uint256 atBoundaryShares   = vault.convertToShares(10_000_000e18);\n\n        assertEq(vault.previewRedeem(overBoundaryShares), 10_000_000e18 + 1);\n        assertEq(vault.previewRedeem(atBoundaryShares),   10_000_000e18);\n\n        vm.expectRevert(\"RateLimits/rate-limit-exceeded\");\n        foreignController.redeemERC4626(MORPHO_VAULT_USDS, overBoundaryShares);\n\n        foreignController.redeemERC4626(MORPHO_VAULT_USDS, atBoundaryShares);\n    }\n\n    function test_morpho_usdc_redeem_rateLimitBoundary() external {\n        deal(Base.USDC, address(almProxy), 20_000_000e18);\n        vm.startPrank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDC, 20_000_000e6);\n\n        IERC4626 vault = IERC4626(MORPHO_VAULT_USDC);\n\n        uint256 overBoundaryShares = vault.convertToShares(10_000_000e6 + 1);\n        uint256 atBoundaryShares   = vault.convertToShares(10_000_000e6);\n\n        assertEq(vault.previewRedeem(overBoundaryShares), 10_000_000e6 + 1);\n        assertEq(vault.previewRedeem(atBoundaryShares),   10_000_000e6);\n\n        vm.expectRevert(\"RateLimits/rate-limit-exceeded\");\n        foreignController.redeemERC4626(MORPHO_VAULT_USDC, overBoundaryShares);\n\n        foreignController.redeemERC4626(MORPHO_VAULT_USDC, atBoundaryShares);\n    }\n\n}\n\ncontract MorphoRedeemSuccessTests is MorphoBaseTest {\n\n    function test_morpho_usds_redeem() public {\n        deal(Base.USDS, address(almProxy), 1_000_000e18);\n        vm.prank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDS, 1_000_000e18);\n\n        assertEq(usdsVault.convertToAssets(usdsVault.balanceOf(address(almProxy))), 1_000_000e18);\n        assertEq(IERC20(Base.USDS).balanceOf(address(almProxy)),                    0);\n\n        uint256 shares = usdsVault.balanceOf(address(almProxy));\n        vm.prank(relayer);\n        assertEq(foreignController.redeemERC4626(MORPHO_VAULT_USDS, shares), 1_000_000e18);\n\n        assertEq(usdsVault.convertToAssets(usdsVault.balanceOf(address(almProxy))), 0);\n        assertEq(IERC20(Base.USDS).balanceOf(address(almProxy)),                    1_000_000e18);\n    }\n\n    function test_morpho_usdc_redeem() public {\n        deal(Base.USDC, address(almProxy), 1_000_000e6);\n        vm.prank(relayer);\n        foreignController.depositERC4626(MORPHO_VAULT_USDC, 1_000_000e6);\n\n        assertEq(usdcVault.convertToAssets(usdcVault.balanceOf(address(almProxy))), 1_000_000e6);\n        assertEq(IERC20(Base.USDC).balanceOf(address(almProxy)),                    0);\n\n        uint256 shares = usdcVault.balanceOf(address(almProxy));\n        vm.prank(relayer);\n        assertEq(foreignController.redeemERC4626(MORPHO_VAULT_USDC, shares), 1_000_000e6);\n\n        assertEq(usdcVault.convertToAssets(usdcVault.balanceOf(address(almProxy))), 0);\n        assertEq(IERC20(Base.USDC).balanceOf(address(almProxy)),                    1_000_000e6);\n    }\n\n}\n",
        "MainnetController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { IERC20 }   from \"forge-std/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\nimport { IERC7540 } from \"forge-std/interfaces/IERC7540.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { Ethereum } from \"spark-address-registry/Ethereum.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport  \"./interfaces/ILayerZero.sol\";\n\nimport { CCTPLib }                        from \"./libraries/CCTPLib.sol\";\nimport { CurveLib }                       from \"./libraries/CurveLib.sol\";\nimport { IDaiUsdsLike, IPSMLike, PSMLib } from \"./libraries/PSMLib.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ninterface IEthenaMinterLike {\n    function setDelegatedSigner(address delegateSigner) external;\n    function removeDelegatedSigner(address delegateSigner) external;\n}\n\ninterface ICentrifugeToken is IERC7540 {\n    function cancelDepositRequest(uint256 requestId, address controller) external;\n    function cancelRedeemRequest(uint256 requestId, address controller) external;\n    function claimCancelDepositRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 assets);\n    function claimCancelRedeemRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 shares);\n}\n\ninterface IMapleTokenLike is IERC4626 {\n    function requestRedeem(uint256 shares, address receiver) external;\n    function removeShares(uint256 shares, address receiver) external;\n}\n\ninterface ISSRedemptionLike is IERC20 {\n    function calculateUsdcOut(uint256 ustbAmount)\n        external view returns (uint256 usdcOutAmount, uint256 usdPerUstbChainlinkRaw);\n    function redeem(uint256 ustbAmout) external;\n}\n\ninterface ISUSDELike is IERC4626 {\n    function cooldownAssets(uint256 usdeAmount) external;\n    function cooldownShares(uint256 susdeAmount) external;\n    function unstake(address receiver) external;\n}\n\ninterface IUSTBLike is IERC20 {\n    function subscribe(uint256 inAmount, address stablecoin) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function draw(uint256 usdsAmount) external;\n    function wipe(uint256 usdsAmount) external;\n}\n\ncontract MainnetController is AccessControl {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n    event MaxSlippageSet(address indexed pool, uint256 maxSlippage);\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT         = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW        = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_7540_DEPOSIT         = keccak256(\"LIMIT_7540_DEPOSIT\");\n    bytes32 public constant LIMIT_7540_REDEEM          = keccak256(\"LIMIT_7540_REDEEM\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT         = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW        = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_ASSET_TRANSFER       = keccak256(\"LIMIT_ASSET_TRANSFER\");\n    bytes32 public constant LIMIT_CURVE_DEPOSIT        = keccak256(\"LIMIT_CURVE_DEPOSIT\");\n    bytes32 public constant LIMIT_CURVE_SWAP           = keccak256(\"LIMIT_CURVE_SWAP\");\n    bytes32 public constant LIMIT_CURVE_WITHDRAW       = keccak256(\"LIMIT_CURVE_WITHDRAW\");\n    bytes32 public constant LIMIT_LAYERZERO_TRANSFER   = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public constant LIMIT_MAPLE_REDEEM         = keccak256(\"LIMIT_MAPLE_REDEEM\");\n    bytes32 public constant LIMIT_SUPERSTATE_REDEEM    = keccak256(\"LIMIT_SUPERSTATE_REDEEM\");\n    bytes32 public constant LIMIT_SUPERSTATE_SUBSCRIBE = keccak256(\"LIMIT_SUPERSTATE_SUBSCRIBE\");\n    bytes32 public constant LIMIT_SUSDE_COOLDOWN       = keccak256(\"LIMIT_SUSDE_COOLDOWN\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP         = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN       = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n    bytes32 public constant LIMIT_USDE_BURN            = keccak256(\"LIMIT_USDE_BURN\");\n    bytes32 public constant LIMIT_USDE_MINT            = keccak256(\"LIMIT_USDE_MINT\");\n    bytes32 public constant LIMIT_USDS_MINT            = keccak256(\"LIMIT_USDS_MINT\");\n    bytes32 public constant LIMIT_USDS_TO_USDC         = keccak256(\"LIMIT_USDS_TO_USDC\");\n\n    uint256 internal constant CENTRIFUGE_REQUEST_ID = 0;\n\n    address public immutable buffer;\n\n    IALMProxy         public immutable proxy;\n    ICCTPLike         public immutable cctp;\n    IDaiUsdsLike      public immutable daiUsds;\n    IEthenaMinterLike public immutable ethenaMinter;\n    IPSMLike          public immutable psm;\n    IRateLimits       public immutable rateLimits;\n    ISSRedemptionLike public immutable superstateRedemption;\n    IVaultLike        public immutable vault;\n\n    IERC20     public immutable dai;\n    IERC20     public immutable usds;\n    IERC20     public immutable usde;\n    IERC20     public immutable usdc;\n    IUSTBLike  public immutable ustb;\n    ISUSDELike public immutable susde;\n\n    uint256 public immutable psmTo18ConversionFactor;\n\n    mapping(address pool => uint256 maxSlippage) public maxSlippages;  // 1e18 precision\n\n    mapping(uint32 destinationDomain     => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId => bytes32 layerZeroRecipient) public layerZeroRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address vault_,\n        address psm_,\n        address daiUsds_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        vault      = IVaultLike(vault_);\n        buffer     = IVaultLike(vault_).buffer();\n        psm        = IPSMLike(psm_);\n        daiUsds    = IDaiUsdsLike(daiUsds_);\n        cctp       = ICCTPLike(cctp_);\n\n        ethenaMinter         = IEthenaMinterLike(Ethereum.ETHENA_MINTER);\n        superstateRedemption = ISSRedemptionLike(Ethereum.SUPERSTATE_REDEMPTION);\n\n        susde = ISUSDELike(Ethereum.SUSDE);\n        ustb  = IUSTBLike(Ethereum.USTB);\n        dai   = IERC20(daiUsds.dai());\n        usdc  = IERC20(psm.gem());\n        usds  = IERC20(Ethereum.USDS);\n        usde  = IERC20(Ethereum.USDE);\n\n        psmTo18ConversionFactor = psm.to18ConversionFactor();\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(\n        uint32  destinationEndpointId,\n        bytes32 layerZeroRecipient\n    ) \n        external\n    {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    function setMaxSlippage(address pool, uint256 maxSlippage) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        maxSlippages[pool] = maxSlippage;\n        emit MaxSlippageSet(pool, maxSlippage);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external {\n        _checkRole(FREEZER);\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer vault functions                                                                ***/\n    /**********************************************************************************************/\n\n    function mintUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDS_MINT, usdsAmount);\n\n        // Mint USDS into the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.draw, (usdsAmount))\n        );\n\n        // Transfer USDS from the buffer to the proxy\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transferFrom, (buffer, address(proxy), usdsAmount))\n        );\n    }\n\n    function burnUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _cancelRateLimit(LIMIT_USDS_MINT, usdsAmount);\n\n        // Transfer USDS from the proxy to the buffer\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transfer, (buffer, usdsAmount))\n        );\n\n        // Burn USDS from the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.wipe, (usdsAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC20 functions                                                                ***/\n    /**********************************************************************************************/\n\n    function transferAsset(address asset, address destination, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            RateLimitHelpers.makeAssetDestinationKey(LIMIT_ASSET_TRANSFER, asset, destination),\n            amount\n        );\n\n        proxy.doCall(\n            asset,\n            abi.encodeCall(IERC20(asset).transfer, (destination, amount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount);\n\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares) external returns (uint256 assets) {\n        _checkRole(RELAYER);\n\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC7540 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function requestDepositERC7540(address token, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_7540_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC7540(token).asset());\n\n        // Approve asset to vault from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Submit deposit request by transferring assets\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestDeposit, (amount, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimDepositERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        uint256 shares = IERC7540(token).maxMint(address(proxy));\n\n        // Claim shares from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC4626(token).mint, (shares, address(proxy)))\n        );\n    }\n\n    function requestRedeemERC7540(address token, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_7540_REDEEM,\n            token,\n            IERC7540(token).convertToAssets(shares)\n        );\n\n        // Submit redeem request by transferring shares\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestRedeem, (shares, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimRedeemERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        uint256 assets = IERC7540(token).maxWithdraw(address(proxy));\n\n        // Claim assets from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).withdraw, (assets, address(proxy), address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Centrifuge functions                                                           ***/\n    /**********************************************************************************************/\n\n    // NOTE: These cancelation methods are compatible with ERC-7887\n\n    function cancelCentrifugeDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        // NOTE: While the cancelation is pending, no new deposit request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    function cancelCentrifugeRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        // NOTE: While the cancelation is pending, no new redeem request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount);\n\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        _checkRole(RELAYER);\n\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Curve StableSwap functions                                                     ***/\n    /**********************************************************************************************/\n\n    function swapCurve(\n        address pool,\n        uint256 inputIndex,\n        uint256 outputIndex,\n        uint256 amountIn,\n        uint256 minAmountOut\n    )\n        external returns (uint256 amountOut)\n    {\n        _checkRole(RELAYER);\n\n        amountOut = CurveLib.swap(CurveLib.SwapCurveParams({\n            proxy        : proxy,\n            rateLimits   : rateLimits,\n            pool         : pool,\n            rateLimitId  : LIMIT_CURVE_SWAP,\n            inputIndex   : inputIndex,\n            outputIndex  : outputIndex,\n            amountIn     : amountIn,\n            minAmountOut : minAmountOut,\n            maxSlippage  : maxSlippages[pool]\n        }));\n    }\n\n    function addLiquidityCurve(\n        address pool,\n        uint256[] memory depositAmounts,\n        uint256 minLpAmount\n    )\n        external returns (uint256 shares)\n    {\n        _checkRole(RELAYER);\n\n        shares = CurveLib.addLiquidity(CurveLib.AddLiquidityParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            pool                    : pool,\n            addLiquidityRateLimitId : LIMIT_CURVE_DEPOSIT,\n            swapRateLimitId         : LIMIT_CURVE_SWAP,\n            minLpAmount             : minLpAmount,\n            maxSlippage             : maxSlippages[pool],\n            depositAmounts          : depositAmounts\n        }));\n    }\n\n    function removeLiquidityCurve(\n        address pool,\n        uint256 lpBurnAmount,\n        uint256[] memory minWithdrawAmounts\n    )\n        external returns (uint256[] memory withdrawnTokens)\n    {\n        _checkRole(RELAYER);\n\n        withdrawnTokens = CurveLib.removeLiquidity(CurveLib.RemoveLiquidityParams({\n            proxy              : proxy,\n            rateLimits         : rateLimits,\n            pool               : pool,\n            rateLimitId        : LIMIT_CURVE_WITHDRAW,\n            lpBurnAmount       : lpBurnAmount,\n            minWithdrawAmounts : minWithdrawAmounts,\n            maxSlippage        : maxSlippages[pool]\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Ethena functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.setDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    function removeDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.removeDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    // Note that Ethena's mint/redeem per-block limits include other users\n    function prepareUSDeMint(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_MINT, usdcAmount);\n        _approve(address(usdc), address(ethenaMinter), usdcAmount);\n    }\n\n    function prepareUSDeBurn(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_BURN, usdeAmount);\n        _approve(address(usde), address(ethenaMinter), usdeAmount);\n    }\n\n    function cooldownAssetsSUSDe(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUSDE_COOLDOWN, usdeAmount);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.cooldownAssets, (usdeAmount))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function cooldownSharesSUSDe(uint256 susdeAmount)\n        external\n        returns (uint256 cooldownAmount)\n    {\n        _checkRole(RELAYER);\n\n        cooldownAmount = abi.decode(\n            proxy.doCall(\n                address(susde),\n                abi.encodeCall(susde.cooldownShares, (susdeAmount))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUSDE_COOLDOWN, cooldownAmount);\n    }\n\n    function unstakeSUSDe() external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.unstake, (address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Maple functions                                                                ***/\n    /**********************************************************************************************/\n\n    function requestMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_MAPLE_REDEEM,\n            mapleToken,\n            IMapleTokenLike(mapleToken).convertToAssets(shares)\n        );\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).requestRedeem, (shares, address(proxy)))\n        );\n    }\n\n    function cancelMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_MAPLE_REDEEM, mapleToken));\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).removeShares, (shares, address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Superstate functions                                                           ***/\n    /**********************************************************************************************/\n\n    function subscribeSuperstate(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUPERSTATE_SUBSCRIBE, usdcAmount);\n\n        _approve(address(usdc), address(ustb), usdcAmount);\n\n        proxy.doCall(\n            address(ustb),\n            abi.encodeCall(ustb.subscribe, (usdcAmount, address(usdc)))\n        );\n    }\n\n    // NOTE: Rate limited outside of modifier because of tuple return\n    function redeemSuperstate(uint256 ustbAmount) external {\n        _checkRole(RELAYER);\n\n        ( uint256 usdcAmount, ) = superstateRedemption.calculateUsdcOut(ustbAmount);\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUPERSTATE_REDEEM, usdcAmount);\n\n        _approve(address(ustb), address(superstateRedemption), ustbAmount);\n\n        proxy.doCall(\n            address(superstateRedemption),\n            abi.encodeCall(superstateRedemption.redeem, (ustbAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer DaiUsds functions                                                              ***/\n    /**********************************************************************************************/\n\n    function swapUSDSToDAI(uint256 usdsAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(address(usds), address(daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.usdsToDai, (address(proxy), usdsAmount))\n        );\n    }\n\n    function swapDAIToUSDS(uint256 daiAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(address(dai), address(daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.daiToUsds, (address(proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    // NOTE: The param `usdcAmount` is denominated in 1e6 precision to match how PSM uses\n    //       USDC precision for both `buyGemNoFee` and `sellGemNoFee`\n    function swapUSDSToUSDC(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDSToUSDC(PSMLib.SwapUSDSToUSDCParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            usds                    : usds,\n            dai                     : dai,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    function swapUSDCToUSDS(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDCToUSDS(PSMLib.SwapUSDCToUSDSParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            dai                     : dai,\n            usdc                    : usdc,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        _approve(ILayerZero(oftAddress).token(), oftAddress, amount);\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain) external {\n        _checkRole(RELAYER);\n\n        CCTPLib.transferUSDCToCCTP(CCTPLib.TransferUSDCToCCTPParams({\n            proxy             : proxy,\n            rateLimits        : rateLimits,\n            cctp              : cctp,\n            usdc              : usdc,\n            domainRateLimitId : LIMIT_USDC_TO_DOMAIN,\n            cctpRateLimitId   : LIMIT_USDC_TO_CCTP,\n            mintRecipient     : mintRecipients[destinationDomain],\n            destinationDomain : destinationDomain,\n            usdcAmount        : usdcAmount\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        // Decode the first 32 bytes of the data, ALMProxy returns 96 bytes\n        bytes32 result;\n        assembly { result := mload(add(data, 32)) }\n\n        // Decode the result to check if the approval was successful\n        bool decodedSuccess = (data.length == 0) || result != bytes32(0);\n\n        // If call succeeded with expected calldata, return\n        if (success && decodedSuccess) return;\n\n        // If call reverted, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, amount)));\n    }\n\n    /**********************************************************************************************/\n    /*** Rate Limit helper functions                                                            ***/\n    /**********************************************************************************************/\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n    function _rateLimitedAsset(bytes32 key, address asset, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n    }\n\n    function _cancelRateLimit(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitIncrease(key, amount);\n    }\n\n    function _rateLimitExists(bytes32 key) internal view {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"MainnetController/invalid-action\"\n        );\n    }\n\n}\n\n"
    }
}