{
    "vfp_id": "vfp_00124",
    "project_name": "cantina_euler_swap_april2025.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Missing Internal Function Naming Convention",
            "description": "Internal functions in contracts like EulerSwapFactory (e.g., uninstall, swapAndPop) do not use the underscore prefix convention, making it unclear which functions are internal. The root cause is inconsistent coding style. While this does not introduce a direct security vulnerability, it reduces code readability and increases the risk of accidental misuse or incorrect assumptions by developers and auditors. The impact is informational, as it pertains to code quality and maintainability rather than security.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "euler-swap/src/EulerSwapFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "EulerSwapFactory.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport {IEulerSwapFactory, IEulerSwap} from \"./interfaces/IEulerSwapFactory.sol\";\nimport {EVCUtil} from \"ethereum-vault-connector/utils/EVCUtil.sol\";\nimport {GenericFactory} from \"evk/GenericFactory/GenericFactory.sol\";\n\nimport {EulerSwap} from \"./EulerSwap.sol\";\nimport {ProtocolFee} from \"./utils/ProtocolFee.sol\";\nimport {MetaProxyDeployer} from \"./utils/MetaProxyDeployer.sol\";\n\n/// @title EulerSwapFactory contract\n/// @custom:security-contact security@euler.xyz\n/// @author Euler Labs (https://www.eulerlabs.com/)\ncontract EulerSwapFactory is IEulerSwapFactory, EVCUtil, ProtocolFee {\n    /// @dev An array to store all pools addresses.\n    address[] private allPools;\n    /// @dev Vaults must be deployed by this factory\n    address public immutable evkFactory;\n    /// @dev The EulerSwap code instance that will be proxied to\n    address public immutable eulerSwapImpl;\n    /// @dev Mapping between euler account and EulerAccountState\n    mapping(address eulerAccount => EulerAccountState state) private eulerAccountState;\n    mapping(address asset0 => mapping(address asset1 => address[])) private poolMap;\n\n    event PoolDeployed(address indexed asset0, address indexed asset1, address indexed eulerAccount, address pool);\n    event PoolConfig(address indexed pool, IEulerSwap.Params params, IEulerSwap.InitialState initialState);\n    event PoolUninstalled(address indexed asset0, address indexed asset1, address indexed eulerAccount, address pool);\n\n    error InvalidQuery();\n    error Unauthorized();\n    error OldOperatorStillInstalled();\n    error OperatorNotInstalled();\n    error InvalidVaultImplementation();\n    error SliceOutOfBounds();\n    error InvalidProtocolFee();\n\n    constructor(address evc, address evkFactory_, address eulerSwapImpl_, address feeOwner_)\n        EVCUtil(evc)\n        ProtocolFee(feeOwner_)\n    {\n        evkFactory = evkFactory_;\n        eulerSwapImpl = eulerSwapImpl_;\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function deployPool(IEulerSwap.Params memory params, IEulerSwap.InitialState memory initialState, bytes32 salt)\n        external\n        returns (address)\n    {\n        require(_msgSender() == params.eulerAccount, Unauthorized());\n        require(\n            GenericFactory(evkFactory).isProxy(params.vault0) && GenericFactory(evkFactory).isProxy(params.vault1),\n            InvalidVaultImplementation()\n        );\n        require(\n            params.protocolFee == protocolFee && params.protocolFeeRecipient == protocolFeeRecipient,\n            InvalidProtocolFee()\n        );\n\n        uninstall(params.eulerAccount);\n\n        EulerSwap pool = EulerSwap(\n            MetaProxyDeployer.deployMetaProxy(\n                eulerSwapImpl, abi.encode(params), keccak256(abi.encode(params.eulerAccount, salt))\n            )\n        );\n\n        updateEulerAccountState(params.eulerAccount, address(pool));\n\n        pool.activate(initialState);\n\n        (address asset0, address asset1) = pool.getAssets();\n        emit PoolDeployed(asset0, asset1, params.eulerAccount, address(pool));\n        emit PoolConfig(address(pool), params, initialState);\n\n        return address(pool);\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function uninstallPool() external {\n        uninstall(_msgSender());\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function computePoolAddress(IEulerSwap.Params memory poolParams, bytes32 salt) external view returns (address) {\n        return address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            keccak256(abi.encode(address(poolParams.eulerAccount), salt)),\n                            keccak256(MetaProxyDeployer.creationCodeMetaProxy(eulerSwapImpl, abi.encode(poolParams)))\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function poolByEulerAccount(address eulerAccount) external view returns (address) {\n        return eulerAccountState[eulerAccount].pool;\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function poolsLength() external view returns (uint256) {\n        return allPools.length;\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function poolsSlice(uint256 start, uint256 end) external view returns (address[] memory) {\n        return _getSlice(allPools, start, end);\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function pools() external view returns (address[] memory) {\n        return _getSlice(allPools, 0, type(uint256).max);\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function poolsByPairLength(address asset0, address asset1) external view returns (uint256) {\n        return poolMap[asset0][asset1].length;\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function poolsByPairSlice(address asset0, address asset1, uint256 start, uint256 end)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _getSlice(poolMap[asset0][asset1], start, end);\n    }\n\n    /// @inheritdoc IEulerSwapFactory\n    function poolsByPair(address asset0, address asset1) external view returns (address[] memory) {\n        return _getSlice(poolMap[asset0][asset1], 0, type(uint256).max);\n    }\n\n    /// @notice Validates operator authorization for euler account and update the relevant EulerAccountState.\n    /// @param eulerAccount The address of the euler account.\n    /// @param newOperator The address of the new pool.\n    function updateEulerAccountState(address eulerAccount, address newOperator) internal {\n        require(evc.isAccountOperatorAuthorized(eulerAccount, newOperator), OperatorNotInstalled());\n\n        (address asset0, address asset1) = _getAssets(newOperator);\n\n        address[] storage poolMapArray = poolMap[asset0][asset1];\n\n        eulerAccountState[eulerAccount] = EulerAccountState({\n            pool: newOperator,\n            allPoolsIndex: uint48(allPools.length),\n            poolMapIndex: uint48(poolMapArray.length)\n        });\n\n        allPools.push(newOperator);\n        poolMapArray.push(newOperator);\n    }\n\n    /// @notice Uninstalls the pool associated with the given Euler account\n    /// @dev This function removes the pool from the factory's tracking and emits a PoolUninstalled event\n    /// @dev The function checks if the operator is still installed and reverts if it is\n    /// @dev If no pool exists for the account, the function returns without any action\n    /// @param eulerAccount The address of the Euler account whose pool should be uninstalled\n    function uninstall(address eulerAccount) internal {\n        address pool = eulerAccountState[eulerAccount].pool;\n\n        if (pool == address(0)) return;\n\n        require(!evc.isAccountOperatorAuthorized(eulerAccount, pool), OldOperatorStillInstalled());\n\n        (address asset0, address asset1) = _getAssets(pool);\n\n        address[] storage poolMapArr = poolMap[asset0][asset1];\n\n        swapAndPop(allPools, eulerAccountState[eulerAccount].allPoolsIndex);\n        swapAndPop(poolMapArr, eulerAccountState[eulerAccount].poolMapIndex);\n\n        delete eulerAccountState[eulerAccount];\n\n        emit PoolUninstalled(asset0, asset1, eulerAccount, pool);\n    }\n\n    /// @notice Swaps the element at the given index with the last element and removes the last element\n    /// @param arr The storage array to modify\n    /// @param index The index of the element to remove\n    function swapAndPop(address[] storage arr, uint256 index) internal {\n        arr[index] = arr[arr.length - 1];\n        arr.pop();\n    }\n\n    /// @notice Retrieves the asset addresses for a given pool\n    /// @dev Calls the pool contract to get its asset0 and asset1 addresses\n    /// @param pool The address of the pool to query\n    /// @return The addresses of asset0 and asset1 in the pool\n    function _getAssets(address pool) internal view returns (address, address) {\n        return IEulerSwap(pool).getAssets();\n    }\n\n    /// @notice Returns a slice of an array of addresses\n    /// @dev Creates a new memory array containing elements from start to end index\n    ///      If end is type(uint256).max, it will return all elements from start to the end of the array\n    /// @param arr The storage array to slice\n    /// @param start The starting index of the slice (inclusive)\n    /// @param end The ending index of the slice (exclusive)\n    /// @return A new memory array containing the requested slice of addresses\n    function _getSlice(address[] storage arr, uint256 start, uint256 end) internal view returns (address[] memory) {\n        uint256 length = arr.length;\n        if (end == type(uint256).max) end = length;\n        if (end < start || end > length) revert SliceOutOfBounds();\n\n        address[] memory slice = new address[](end - start);\n        for (uint256 i; i < end - start; ++i) {\n            slice[i] = arr[start + i];\n        }\n\n        return slice;\n    }\n}\n"
    }
}