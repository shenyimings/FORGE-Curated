{
    "vfp_id": "vfp_00187",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Single token liquidity provision and removal will not work on tokens that revert on zero value transfers",
            "description": "The Router contractâ€™s addLiquidityHook and removeLiquidityHook functions iterate over all pool tokens and attempt transfers even when the amount is zero. For tokens like BNB that revert on zero-value transfers, this causes the entire transaction to fail, even if the zero transfer is irrelevant. As a result, single-sided liquidity operations (e.g., adding only WETH to a BNB/WETH pool) become impossible on chains where such tokens are used, breaking compatibility and limiting usability for common token types.\n",
            "severity": "Low",
            "location": [
                "Router.sol::addLiquidityHook#266-311",
                "Router.sol::removeLiquidityHook",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1014"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/Router.sol"
            ]
        }
    ],
    "affected_files": {
        "Router.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IPermit2 } from \"permit2/src/interfaces/IPermit2.sol\";\n\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IRouter } from \"@balancer-labs/v3-interfaces/contracts/vault/IRouter.sol\";\nimport { IWETH } from \"@balancer-labs/v3-interfaces/contracts/solidity-utils/misc/IWETH.sol\";\nimport \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport {\n    ReentrancyGuardTransient\n} from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/ReentrancyGuardTransient.sol\";\n\nimport { RouterCommon } from \"./RouterCommon.sol\";\n\n/**\n * @notice Entrypoint for swaps, liquidity operations, and corresponding queries.\n * @dev The external API functions unlock the Vault, which calls back into the corresponding hook functions.\n * These interact with the Vault, transfer tokens, settle accounting, and handle wrapping and unwrapping ETH.\n */\ncontract Router is IRouter, RouterCommon, ReentrancyGuardTransient {\n    using Address for address payable;\n\n    constructor(IVault vault, IWETH weth, IPermit2 permit2) RouterCommon(vault, weth, permit2) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /*******************************************************************************\n                                Pool Initialization\n    *******************************************************************************/\n\n    /// @inheritdoc IRouter\n    function initialize(\n        address pool,\n        IERC20[] memory tokens,\n        uint256[] memory exactAmountsIn,\n        uint256 minBptAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable returns (uint256 bptAmountOut) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.initializeHook.selector,\n                        InitializeHookParams({\n                            sender: msg.sender,\n                            pool: pool,\n                            tokens: tokens,\n                            exactAmountsIn: exactAmountsIn,\n                            minBptAmountOut: minBptAmountOut,\n                            wethIsEth: wethIsEth,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256)\n            );\n    }\n\n    /**\n     * @notice Hook for initialization.\n     * @dev Can only be called by the Vault.\n     * @param params Initialization parameters (see IRouter for struct definition)\n     * @return bptAmountOut BPT amount minted in exchange for the input tokens\n     */\n    function initializeHook(\n        InitializeHookParams calldata params\n    ) external nonReentrant onlyVault returns (uint256 bptAmountOut) {\n        bptAmountOut = _vault.initialize(\n            params.pool,\n            params.sender,\n            params.tokens,\n            params.exactAmountsIn,\n            params.minBptAmountOut,\n            params.userData\n        );\n\n        uint256 ethAmountIn;\n        for (uint256 i = 0; i < params.tokens.length; ++i) {\n            IERC20 token = params.tokens[i];\n            uint256 amountIn = params.exactAmountsIn[i];\n\n            // There can be only one WETH token in the pool.\n            if (params.wethIsEth && address(token) == address(_weth)) {\n                if (address(this).balance < amountIn) {\n                    revert InsufficientEth();\n                }\n\n                _weth.deposit{ value: amountIn }();\n                ethAmountIn = amountIn;\n                // Transfer WETH from the router to the Vault.\n                _weth.transfer(address(_vault), amountIn);\n                _vault.settle(_weth, amountIn);\n            } else {\n                // Rransfer tokens from the user to the Vault.\n                _permit2.transferFrom(params.sender, address(_vault), uint160(amountIn), address(token));\n                _vault.settle(token, amountIn);\n            }\n        }\n\n        // Return ETH dust.\n        _returnEth(params.sender);\n    }\n\n    /***************************************************************************\n                                   Add Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IRouter\n    function addLiquidityProportional(\n        address pool,\n        uint256[] memory maxAmountsIn,\n        uint256 exactBptAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256[] memory amountsIn) {\n        (amountsIn, , ) = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(\n                    Router.addLiquidityHook.selector,\n                    AddLiquidityHookParams({\n                        sender: msg.sender,\n                        pool: pool,\n                        maxAmountsIn: maxAmountsIn,\n                        minBptAmountOut: exactBptAmountOut,\n                        kind: AddLiquidityKind.PROPORTIONAL,\n                        wethIsEth: wethIsEth,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256[], uint256, bytes)\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function addLiquidityUnbalanced(\n        address pool,\n        uint256[] memory exactAmountsIn,\n        uint256 minBptAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256 bptAmountOut) {\n        (, bptAmountOut, ) = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(\n                    Router.addLiquidityHook.selector,\n                    AddLiquidityHookParams({\n                        sender: msg.sender,\n                        pool: pool,\n                        maxAmountsIn: exactAmountsIn,\n                        minBptAmountOut: minBptAmountOut,\n                        kind: AddLiquidityKind.UNBALANCED,\n                        wethIsEth: wethIsEth,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256[], uint256, bytes)\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function addLiquiditySingleTokenExactOut(\n        address pool,\n        IERC20 tokenIn,\n        uint256 maxAmountIn,\n        uint256 exactBptAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256 amountIn) {\n        (uint256[] memory maxAmountsIn, uint256 tokenIndex) = _getSingleInputArrayAndTokenIndex(\n            pool,\n            tokenIn,\n            maxAmountIn\n        );\n\n        (uint256[] memory amountsIn, , ) = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(\n                    Router.addLiquidityHook.selector,\n                    AddLiquidityHookParams({\n                        sender: msg.sender,\n                        pool: pool,\n                        maxAmountsIn: maxAmountsIn,\n                        minBptAmountOut: exactBptAmountOut,\n                        kind: AddLiquidityKind.SINGLE_TOKEN_EXACT_OUT,\n                        wethIsEth: wethIsEth,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256[], uint256, bytes)\n        );\n\n        return amountsIn[tokenIndex];\n    }\n\n    /// @inheritdoc IRouter\n    function donate(\n        address pool,\n        uint256[] memory amountsIn,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender {\n        _vault.unlock(\n            abi.encodeWithSelector(\n                Router.addLiquidityHook.selector,\n                AddLiquidityHookParams({\n                    sender: msg.sender,\n                    pool: pool,\n                    maxAmountsIn: amountsIn,\n                    minBptAmountOut: 0,\n                    kind: AddLiquidityKind.DONATION,\n                    wethIsEth: wethIsEth,\n                    userData: userData\n                })\n            )\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function addLiquidityCustom(\n        address pool,\n        uint256[] memory maxAmountsIn,\n        uint256 minBptAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.addLiquidityHook.selector,\n                        AddLiquidityHookParams({\n                            sender: msg.sender,\n                            pool: pool,\n                            maxAmountsIn: maxAmountsIn,\n                            minBptAmountOut: minBptAmountOut,\n                            kind: AddLiquidityKind.CUSTOM,\n                            wethIsEth: wethIsEth,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256[], uint256, bytes)\n            );\n    }\n\n    /**\n     * @notice Hook for adding liquidity.\n     * @dev Can only be called by the Vault.\n     * @param params Add liquidity parameters (see IRouter for struct definition)\n     * @return amountsIn Actual amounts in required for the join\n     * @return bptAmountOut BPT amount minted in exchange for the input tokens\n     * @return returnData Arbitrary data with encoded response from the pool\n     */\n    function addLiquidityHook(\n        AddLiquidityHookParams calldata params\n    )\n        external\n        nonReentrant\n        onlyVault\n        returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData)\n    {\n        (amountsIn, bptAmountOut, returnData) = _vault.addLiquidity(\n            AddLiquidityParams({\n                pool: params.pool,\n                to: params.sender,\n                maxAmountsIn: params.maxAmountsIn,\n                minBptAmountOut: params.minBptAmountOut,\n                kind: params.kind,\n                userData: params.userData\n            })\n        );\n\n        // maxAmountsIn length is checked against tokens length at the vault.\n        IERC20[] memory tokens = _vault.getPoolTokens(params.pool);\n\n        uint256 ethAmountIn;\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amountIn = amountsIn[i];\n\n            // There can be only one WETH token in the pool.\n            if (params.wethIsEth && address(token) == address(_weth)) {\n                if (address(this).balance < amountIn) {\n                    revert InsufficientEth();\n                }\n\n                _weth.deposit{ value: amountIn }();\n                ethAmountIn = amountIn;\n                _weth.transfer(address(_vault), amountIn);\n                _vault.settle(_weth, amountIn);\n            } else {\n                _permit2.transferFrom(params.sender, address(_vault), uint160(amountIn), address(token));\n                _vault.settle(token, amountIn);\n            }\n        }\n\n        // Send remaining ETH to the user.\n        _returnEth(params.sender);\n    }\n\n    /***************************************************************************\n                                 Remove Liquidity\n    ***************************************************************************/\n\n    /// @inheritdoc IRouter\n    function removeLiquidityProportional(\n        address pool,\n        uint256 exactBptAmountIn,\n        uint256[] memory minAmountsOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256[] memory amountsOut) {\n        (, amountsOut, ) = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(\n                    Router.removeLiquidityHook.selector,\n                    RemoveLiquidityHookParams({\n                        sender: msg.sender,\n                        pool: pool,\n                        minAmountsOut: minAmountsOut,\n                        maxBptAmountIn: exactBptAmountIn,\n                        kind: RemoveLiquidityKind.PROPORTIONAL,\n                        wethIsEth: wethIsEth,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256, uint256[], bytes)\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function removeLiquiditySingleTokenExactIn(\n        address pool,\n        uint256 exactBptAmountIn,\n        IERC20 tokenOut,\n        uint256 minAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256 amountOut) {\n        (uint256[] memory minAmountsOut, uint256 tokenIndex) = _getSingleInputArrayAndTokenIndex(\n            pool,\n            tokenOut,\n            minAmountOut\n        );\n\n        (, uint256[] memory amountsOut, ) = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(\n                    Router.removeLiquidityHook.selector,\n                    RemoveLiquidityHookParams({\n                        sender: msg.sender,\n                        pool: pool,\n                        minAmountsOut: minAmountsOut,\n                        maxBptAmountIn: exactBptAmountIn,\n                        kind: RemoveLiquidityKind.SINGLE_TOKEN_EXACT_IN,\n                        wethIsEth: wethIsEth,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256, uint256[], bytes)\n        );\n\n        return amountsOut[tokenIndex];\n    }\n\n    /// @inheritdoc IRouter\n    function removeLiquiditySingleTokenExactOut(\n        address pool,\n        uint256 maxBptAmountIn,\n        IERC20 tokenOut,\n        uint256 exactAmountOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external payable saveSender returns (uint256 bptAmountIn) {\n        (uint256[] memory minAmountsOut, ) = _getSingleInputArrayAndTokenIndex(pool, tokenOut, exactAmountOut);\n\n        (bptAmountIn, , ) = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(\n                    Router.removeLiquidityHook.selector,\n                    RemoveLiquidityHookParams({\n                        sender: msg.sender,\n                        pool: pool,\n                        minAmountsOut: minAmountsOut,\n                        maxBptAmountIn: maxBptAmountIn,\n                        kind: RemoveLiquidityKind.SINGLE_TOKEN_EXACT_OUT,\n                        wethIsEth: wethIsEth,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256, uint256[], bytes)\n        );\n\n        return bptAmountIn;\n    }\n\n    /// @inheritdoc IRouter\n    function removeLiquidityCustom(\n        address pool,\n        uint256 maxBptAmountIn,\n        uint256[] memory minAmountsOut,\n        bool wethIsEth,\n        bytes memory userData\n    ) external saveSender returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.removeLiquidityHook.selector,\n                        RemoveLiquidityHookParams({\n                            sender: msg.sender,\n                            pool: pool,\n                            minAmountsOut: minAmountsOut,\n                            maxBptAmountIn: maxBptAmountIn,\n                            kind: RemoveLiquidityKind.CUSTOM,\n                            wethIsEth: wethIsEth,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256, uint256[], bytes)\n            );\n    }\n\n    /// @inheritdoc IRouter\n    function removeLiquidityRecovery(\n        address pool,\n        uint256 exactBptAmountIn\n    ) external returns (uint256[] memory amountsOut) {\n        amountsOut = abi.decode(\n            _vault.unlock(\n                abi.encodeWithSelector(Router.removeLiquidityRecoveryHook.selector, pool, msg.sender, exactBptAmountIn)\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @notice Hook for removing liquidity.\n     * @dev Can only be called by the Vault.\n     * @param params Remove liquidity parameters (see IRouter for struct definition)\n     * @return bptAmountIn BPT amount burned for the output tokens\n     * @return amountsOut Actual token amounts transferred in exchange for the BPT\n     * @return returnData Arbitrary (optional) data with an encoded response from the pool\n     */\n    function removeLiquidityHook(\n        RemoveLiquidityHookParams calldata params\n    )\n        external\n        nonReentrant\n        onlyVault\n        returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData)\n    {\n        (bptAmountIn, amountsOut, returnData) = _vault.removeLiquidity(\n            RemoveLiquidityParams({\n                pool: params.pool,\n                from: params.sender,\n                maxBptAmountIn: params.maxBptAmountIn,\n                minAmountsOut: params.minAmountsOut,\n                kind: params.kind,\n                userData: params.userData\n            })\n        );\n\n        // minAmountsOut length is checked against tokens length at the vault.\n        IERC20[] memory tokens = _vault.getPoolTokens(params.pool);\n\n        uint256 ethAmountOut;\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            uint256 amountOut = amountsOut[i];\n            IERC20 token = tokens[i];\n\n            // There can be only one WETH token in the pool.\n            if (params.wethIsEth && address(token) == address(_weth)) {\n                // Send WETH here and unwrap to native ETH.\n                _vault.sendTo(_weth, address(this), amountOut);\n                _weth.withdraw(amountOut);\n                ethAmountOut = amountOut;\n            } else {\n                // Transfer the token to the sender (amountOut).\n                _vault.sendTo(token, params.sender, amountOut);\n            }\n        }\n\n        // Send ETH to sender.\n        payable(params.sender).sendValue(ethAmountOut);\n    }\n\n    /**\n     * @notice Hook for removing liquidity in Recovery Mode.\n     * @dev Can only be called by the Vault, when the pool is in Recovery Mode.\n     * @param pool Address of the liquidity pool\n     * @param sender Account originating the remove liquidity operation\n     * @param exactBptAmountIn BPT amount burned for the output tokens\n     * @return amountsOut Actual token amounts transferred in exchange for the BPT\n     */\n    function removeLiquidityRecoveryHook(\n        address pool,\n        address sender,\n        uint256 exactBptAmountIn\n    ) external nonReentrant onlyVault returns (uint256[] memory amountsOut) {\n        amountsOut = _vault.removeLiquidityRecovery(pool, sender, exactBptAmountIn);\n\n        IERC20[] memory tokens = _vault.getPoolTokens(pool);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Transfer the token to the sender (amountOut)\n            _vault.sendTo(tokens[i], sender, amountsOut[i]);\n        }\n    }\n\n    /***************************************************************************\n                                       Swaps\n    ***************************************************************************/\n\n    /// @inheritdoc IRouter\n    function swapSingleTokenExactIn(\n        address pool,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 exactAmountIn,\n        uint256 minAmountOut,\n        uint256 deadline,\n        bool wethIsEth,\n        bytes calldata userData\n    ) external payable saveSender returns (uint256) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.swapSingleTokenHook.selector,\n                        SwapSingleTokenHookParams({\n                            sender: msg.sender,\n                            kind: SwapKind.EXACT_IN,\n                            pool: pool,\n                            tokenIn: tokenIn,\n                            tokenOut: tokenOut,\n                            amountGiven: exactAmountIn,\n                            limit: minAmountOut,\n                            deadline: deadline,\n                            wethIsEth: wethIsEth,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256)\n            );\n    }\n\n    /// @inheritdoc IRouter\n    function swapSingleTokenExactOut(\n        address pool,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 exactAmountOut,\n        uint256 maxAmountIn,\n        uint256 deadline,\n        bool wethIsEth,\n        bytes calldata userData\n    ) external payable saveSender returns (uint256) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.swapSingleTokenHook.selector,\n                        SwapSingleTokenHookParams({\n                            sender: msg.sender,\n                            kind: SwapKind.EXACT_OUT,\n                            pool: pool,\n                            tokenIn: tokenIn,\n                            tokenOut: tokenOut,\n                            amountGiven: exactAmountOut,\n                            limit: maxAmountIn,\n                            deadline: deadline,\n                            wethIsEth: wethIsEth,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256)\n            );\n    }\n\n    /**\n     * @notice Hook for swaps.\n     * @dev Can only be called by the Vault. Also handles native ETH.\n     * @param params Swap parameters (see IRouter for struct definition)\n     * @return amountCalculated Token amount calculated by the pool math (e.g., amountOut for a exact in swap)\n     */\n    function swapSingleTokenHook(\n        SwapSingleTokenHookParams calldata params\n    ) external nonReentrant onlyVault returns (uint256) {\n        (uint256 amountCalculated, uint256 amountIn, uint256 amountOut) = _swapHook(params);\n\n        IERC20 tokenIn = params.tokenIn;\n\n        _takeTokenIn(params.sender, tokenIn, amountIn, params.wethIsEth);\n        _sendTokenOut(params.sender, params.tokenOut, amountOut, params.wethIsEth);\n\n        if (tokenIn == _weth) {\n            // Return the rest of ETH to sender\n            _returnEth(params.sender);\n        }\n\n        return amountCalculated;\n    }\n\n    function _swapHook(\n        SwapSingleTokenHookParams calldata params\n    ) internal returns (uint256 amountCalculated, uint256 amountIn, uint256 amountOut) {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp > params.deadline) {\n            revert SwapDeadline();\n        }\n\n        (amountCalculated, amountIn, amountOut) = _vault.swap(\n            SwapParams({\n                kind: params.kind,\n                pool: params.pool,\n                tokenIn: params.tokenIn,\n                tokenOut: params.tokenOut,\n                amountGivenRaw: params.amountGiven,\n                limitRaw: params.limit,\n                userData: params.userData\n            })\n        );\n    }\n\n    /*******************************************************************************\n                            Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IRouter\n    function addLiquidityToBuffer(\n        IERC4626 wrappedToken,\n        uint256 amountUnderlyingRaw,\n        uint256 amountWrappedRaw,\n        address sharesOwner\n    ) external returns (uint256 issuedShares) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.addLiquidityToBufferHook.selector,\n                        wrappedToken,\n                        amountUnderlyingRaw,\n                        amountWrappedRaw,\n                        sharesOwner\n                    )\n                ),\n                (uint256)\n            );\n    }\n\n    /**\n     * @notice Hook for adding liquidity to vault buffers.\n     * @dev Can only be called by the Vault.\n     * @param wrappedToken Address of the wrapped token that implements IERC4626\n     * @param amountUnderlyingRaw Amount of underlying tokens that will be deposited into the buffer\n     * @param amountWrappedRaw Amount of wrapped tokens that will be deposited into the buffer\n     * @param sharesOwner Address that will own the deposited liquidity. Only this address will be able to\n     * remove liquidity from the buffer\n     * @return issuedShares the amount of tokens sharesOwner has in the buffer, expressed in underlying token amounts.\n     * (This is the BPT of an internal ERC4626 buffer)\n     */\n    function addLiquidityToBufferHook(\n        IERC4626 wrappedToken,\n        uint256 amountUnderlyingRaw,\n        uint256 amountWrappedRaw,\n        address sharesOwner\n    ) external nonReentrant onlyVault returns (uint256 issuedShares) {\n        issuedShares = _vault.addLiquidityToBuffer(wrappedToken, amountUnderlyingRaw, amountWrappedRaw, sharesOwner);\n        _takeTokenIn(sharesOwner, IERC20(wrappedToken.asset()), amountUnderlyingRaw, false);\n        _takeTokenIn(sharesOwner, IERC20(address(wrappedToken)), amountWrappedRaw, false);\n    }\n\n    /// @inheritdoc IRouter\n    function removeLiquidityFromBuffer(\n        IERC4626 wrappedToken,\n        uint256 sharesToRemove\n    ) external returns (uint256, uint256) {\n        return\n            abi.decode(\n                _vault.unlock(\n                    abi.encodeWithSelector(\n                        Router.removeLiquidityFromBufferHook.selector,\n                        wrappedToken,\n                        sharesToRemove,\n                        msg.sender\n                    )\n                ),\n                (uint256, uint256)\n            );\n    }\n\n    /**\n     * @notice Hook for removing liquidity from vault buffers.\n     * @dev Can only be called by the Vault.\n     * @param wrappedToken Address of the wrapped token that implements IERC4626\n     * @param sharesToRemove Amount of shares to remove from the buffer. Cannot be greater than sharesOwner\n     * total shares\n     * @param sharesOwner Address of contract that owns the deposited liquidity.\n     * @return removedUnderlyingBalanceRaw Amount of underlying tokens returned to the user\n     * @return removedWrappedBalanceRaw Amount of wrapped tokens returned to the user\n     */\n    function removeLiquidityFromBufferHook(\n        IERC4626 wrappedToken,\n        uint256 sharesToRemove,\n        address sharesOwner\n    ) external nonReentrant onlyVault returns (uint256 removedUnderlyingBalanceRaw, uint256 removedWrappedBalanceRaw) {\n        (removedUnderlyingBalanceRaw, removedWrappedBalanceRaw) = _vault.removeLiquidityFromBuffer(\n            wrappedToken,\n            sharesToRemove,\n            sharesOwner\n        );\n        _sendTokenOut(sharesOwner, IERC20(wrappedToken.asset()), removedUnderlyingBalanceRaw, false);\n        _sendTokenOut(sharesOwner, IERC20(address(wrappedToken)), removedWrappedBalanceRaw, false);\n    }\n\n    /*******************************************************************************\n                                      Queries\n    *******************************************************************************/\n\n    /// @inheritdoc IRouter\n    function queryAddLiquidityProportional(\n        address pool,\n        uint256 exactBptAmountOut,\n        bytes memory userData\n    ) external saveSender returns (uint256[] memory amountsIn) {\n        (amountsIn, , ) = abi.decode(\n            _vault.quote(\n                abi.encodeWithSelector(\n                    Router.queryAddLiquidityHook.selector,\n                    AddLiquidityHookParams({\n                        // We use the Router as a sender to simplify basic query functions,\n                        // but it is possible to add liquidity to any recipient.\n                        sender: address(this),\n                        pool: pool,\n                        maxAmountsIn: _maxTokenLimits(pool),\n                        minBptAmountOut: exactBptAmountOut,\n                        kind: AddLiquidityKind.PROPORTIONAL,\n                        wethIsEth: false,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256[], uint256, bytes)\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function queryAddLiquidityUnbalanced(\n        address pool,\n        uint256[] memory exactAmountsIn,\n        bytes memory userData\n    ) external saveSender returns (uint256 bptAmountOut) {\n        (, bptAmountOut, ) = abi.decode(\n            _vault.quote(\n                abi.encodeWithSelector(\n                    Router.queryAddLiquidityHook.selector,\n                    AddLiquidityHookParams({\n                        // We use the Router as a sender to simplify basic query functions,\n                        // but it is possible to add liquidity to any recipient.\n                        sender: address(this),\n                        pool: pool,\n                        maxAmountsIn: exactAmountsIn,\n                        minBptAmountOut: 0,\n                        kind: AddLiquidityKind.UNBALANCED,\n                        wethIsEth: false,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256[], uint256, bytes)\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function queryAddLiquiditySingleTokenExactOut(\n        address pool,\n        IERC20 tokenIn,\n        uint256 exactBptAmountOut,\n        bytes memory userData\n    ) external saveSender returns (uint256 amountIn) {\n        (uint256[] memory maxAmountsIn, uint256 tokenIndex) = _getSingleInputArrayAndTokenIndex(\n            pool,\n            tokenIn,\n            _MAX_AMOUNT\n        );\n\n        (uint256[] memory amountsIn, , ) = abi.decode(\n            _vault.quote(\n                abi.encodeWithSelector(\n                    Router.queryAddLiquidityHook.selector,\n                    AddLiquidityHookParams({\n                        // We use the Router as a sender to simplify basic query functions,\n                        // but it is possible to add liquidity to any recipient.\n                        sender: address(this),\n                        pool: pool,\n                        maxAmountsIn: maxAmountsIn,\n                        minBptAmountOut: exactBptAmountOut,\n                        kind: AddLiquidityKind.SINGLE_TOKEN_EXACT_OUT,\n                        wethIsEth: false,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256[], uint256, bytes)\n        );\n\n        return amountsIn[tokenIndex];\n    }\n\n    /// @inheritdoc IRouter\n    function queryAddLiquidityCustom(\n        address pool,\n        uint256[] memory maxAmountsIn,\n        uint256 minBptAmountOut,\n        bytes memory userData\n    ) external saveSender returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData) {\n        return\n            abi.decode(\n                _vault.quote(\n                    abi.encodeWithSelector(\n                        Router.queryAddLiquidityHook.selector,\n                        AddLiquidityHookParams({\n                            // We use the Router as a sender to simplify basic query functions,\n                            // but it is possible to add liquidity to any recipient.\n                            sender: address(this),\n                            pool: pool,\n                            maxAmountsIn: maxAmountsIn,\n                            minBptAmountOut: minBptAmountOut,\n                            kind: AddLiquidityKind.CUSTOM,\n                            wethIsEth: false,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256[], uint256, bytes)\n            );\n    }\n\n    /**\n     * @notice Hook for add liquidity queries.\n     * @dev Can only be called by the Vault.\n     * @param params Add liquidity parameters (see IRouter for struct definition)\n     * @return amountsIn Actual token amounts in required as inputs\n     * @return bptAmountOut Expected pool tokens to be minted\n     * @return returnData Arbitrary (optional) data with an encoded response from the pool\n     */\n    function queryAddLiquidityHook(\n        AddLiquidityHookParams calldata params\n    ) external payable onlyVault returns (uint256[] memory amountsIn, uint256 bptAmountOut, bytes memory returnData) {\n        (amountsIn, bptAmountOut, returnData) = _vault.addLiquidity(\n            AddLiquidityParams({\n                pool: params.pool,\n                to: params.sender,\n                maxAmountsIn: params.maxAmountsIn,\n                minBptAmountOut: params.minBptAmountOut,\n                kind: params.kind,\n                userData: params.userData\n            })\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function queryRemoveLiquidityProportional(\n        address pool,\n        uint256 exactBptAmountIn,\n        bytes memory userData\n    ) external saveSender returns (uint256[] memory amountsOut) {\n        uint256[] memory minAmountsOut = new uint256[](_vault.getPoolTokens(pool).length);\n        (, amountsOut, ) = abi.decode(\n            _vault.quote(\n                abi.encodeWithSelector(\n                    Router.queryRemoveLiquidityHook.selector,\n                    RemoveLiquidityHookParams({\n                        // We use the Router as a sender to simplify basic query functions,\n                        // but it is possible to remove liquidity from any sender.\n                        sender: address(this),\n                        pool: pool,\n                        minAmountsOut: minAmountsOut,\n                        maxBptAmountIn: exactBptAmountIn,\n                        kind: RemoveLiquidityKind.PROPORTIONAL,\n                        wethIsEth: false,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256, uint256[], bytes)\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function queryRemoveLiquiditySingleTokenExactIn(\n        address pool,\n        uint256 exactBptAmountIn,\n        IERC20 tokenOut,\n        bytes memory userData\n    ) external saveSender returns (uint256 amountOut) {\n        // We cannot use 0 as min amount out, as this value is used to figure out the token index.\n        (uint256[] memory minAmountsOut, uint256 tokenIndex) = _getSingleInputArrayAndTokenIndex(pool, tokenOut, 1);\n\n        (, uint256[] memory amountsOut, ) = abi.decode(\n            _vault.quote(\n                abi.encodeWithSelector(\n                    Router.queryRemoveLiquidityHook.selector,\n                    RemoveLiquidityHookParams({\n                        // We use the Router as a sender to simplify basic query functions,\n                        // but it is possible to remove liquidity from any sender.\n                        sender: address(this),\n                        pool: pool,\n                        minAmountsOut: minAmountsOut,\n                        maxBptAmountIn: exactBptAmountIn,\n                        kind: RemoveLiquidityKind.SINGLE_TOKEN_EXACT_IN,\n                        wethIsEth: false,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256, uint256[], bytes)\n        );\n\n        return amountsOut[tokenIndex];\n    }\n\n    /// @inheritdoc IRouter\n    function queryRemoveLiquiditySingleTokenExactOut(\n        address pool,\n        IERC20 tokenOut,\n        uint256 exactAmountOut,\n        bytes memory userData\n    ) external saveSender returns (uint256 bptAmountIn) {\n        (uint256[] memory minAmountsOut, ) = _getSingleInputArrayAndTokenIndex(pool, tokenOut, exactAmountOut);\n\n        (bptAmountIn, , ) = abi.decode(\n            _vault.quote(\n                abi.encodeWithSelector(\n                    Router.queryRemoveLiquidityHook.selector,\n                    RemoveLiquidityHookParams({\n                        // We use the Router as a sender to simplify basic query functions,\n                        // but it is possible to remove liquidity from any sender.\n                        sender: address(this),\n                        pool: pool,\n                        minAmountsOut: minAmountsOut,\n                        maxBptAmountIn: _MAX_AMOUNT,\n                        kind: RemoveLiquidityKind.SINGLE_TOKEN_EXACT_OUT,\n                        wethIsEth: false,\n                        userData: userData\n                    })\n                )\n            ),\n            (uint256, uint256[], bytes)\n        );\n\n        return bptAmountIn;\n    }\n\n    /// @inheritdoc IRouter\n    function queryRemoveLiquidityCustom(\n        address pool,\n        uint256 maxBptAmountIn,\n        uint256[] memory minAmountsOut,\n        bytes memory userData\n    ) external saveSender returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData) {\n        return\n            abi.decode(\n                _vault.quote(\n                    abi.encodeWithSelector(\n                        Router.queryRemoveLiquidityHook.selector,\n                        RemoveLiquidityHookParams({\n                            // We use the Router as a sender to simplify basic query functions,\n                            // but it is possible to remove liquidity from any sender.\n                            sender: address(this),\n                            pool: pool,\n                            minAmountsOut: minAmountsOut,\n                            maxBptAmountIn: maxBptAmountIn,\n                            kind: RemoveLiquidityKind.CUSTOM,\n                            wethIsEth: false,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256, uint256[], bytes)\n            );\n    }\n\n    /// @inheritdoc IRouter\n    function queryRemoveLiquidityRecovery(\n        address pool,\n        uint256 exactBptAmountIn\n    ) external returns (uint256[] memory amountsOut) {\n        return\n            abi.decode(\n                _vault.quote(\n                    abi.encodeWithSelector(\n                        Router.queryRemoveLiquidityRecoveryHook.selector,\n                        pool,\n                        address(this),\n                        exactBptAmountIn\n                    )\n                ),\n                (uint256[])\n            );\n    }\n\n    /**\n     * @notice Hook for remove liquidity queries.\n     * @dev Can only be called by the Vault.\n     * @param params Remove liquidity parameters (see IRouter for struct definition)\n     * @return bptAmountIn Pool token amount to be burned for the output tokens\n     * @return amountsOut Expected token amounts to be transferred to the sender\n     * @return returnData Arbitrary (optional) data with an encoded response from the pool\n     */\n    function queryRemoveLiquidityHook(\n        RemoveLiquidityHookParams calldata params\n    ) external onlyVault returns (uint256 bptAmountIn, uint256[] memory amountsOut, bytes memory returnData) {\n        // If router is the sender, it has to approve itself.\n        IERC20(params.pool).approve(address(this), type(uint256).max);\n        return\n            _vault.removeLiquidity(\n                RemoveLiquidityParams({\n                    pool: params.pool,\n                    from: params.sender,\n                    maxBptAmountIn: params.maxBptAmountIn,\n                    minAmountsOut: params.minAmountsOut,\n                    kind: params.kind,\n                    userData: params.userData\n                })\n            );\n    }\n\n    /**\n     * @notice Hook for remove liquidity queries.\n     * @dev Can only be called by the Vault.\n     * @param pool The liquidity pool\n     * @param sender Account originating the remove liquidity operation\n     * @param exactBptAmountIn Pool token amount to be burned for the output tokens\n     * @return amountsOut Expected token amounts to be transferred to the sender\n     */\n    function queryRemoveLiquidityRecoveryHook(\n        address pool,\n        address sender,\n        uint256 exactBptAmountIn\n    ) external onlyVault returns (uint256[] memory amountsOut) {\n        return _vault.removeLiquidityRecovery(pool, sender, exactBptAmountIn);\n    }\n\n    /// @inheritdoc IRouter\n    function querySwapSingleTokenExactIn(\n        address pool,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 exactAmountIn,\n        bytes calldata userData\n    ) external saveSender returns (uint256 amountCalculated) {\n        return\n            abi.decode(\n                _vault.quote(\n                    abi.encodeWithSelector(\n                        Router.querySwapHook.selector,\n                        SwapSingleTokenHookParams({\n                            sender: msg.sender,\n                            kind: SwapKind.EXACT_IN,\n                            pool: pool,\n                            tokenIn: tokenIn,\n                            tokenOut: tokenOut,\n                            amountGiven: exactAmountIn,\n                            limit: 0,\n                            deadline: _MAX_AMOUNT,\n                            wethIsEth: false,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256)\n            );\n    }\n\n    /// @inheritdoc IRouter\n    function querySwapSingleTokenExactOut(\n        address pool,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 exactAmountOut,\n        bytes calldata userData\n    ) external saveSender returns (uint256 amountCalculated) {\n        return\n            abi.decode(\n                _vault.quote(\n                    abi.encodeWithSelector(\n                        Router.querySwapHook.selector,\n                        SwapSingleTokenHookParams({\n                            sender: msg.sender,\n                            kind: SwapKind.EXACT_OUT,\n                            pool: pool,\n                            tokenIn: tokenIn,\n                            tokenOut: tokenOut,\n                            amountGiven: exactAmountOut,\n                            limit: _MAX_AMOUNT,\n                            deadline: type(uint256).max,\n                            wethIsEth: false,\n                            userData: userData\n                        })\n                    )\n                ),\n                (uint256)\n            );\n    }\n\n    /**\n     * @notice Hook for swap queries.\n     * @dev Can only be called by the Vault. Also handles native ETH.\n     * @param params Swap parameters (see IRouter for struct definition)\n     * @return amountCalculated Token amount calculated by the pool math (e.g., amountOut for a exact in swap)\n     */\n    function querySwapHook(\n        SwapSingleTokenHookParams calldata params\n    ) external payable nonReentrant onlyVault returns (uint256) {\n        (uint256 amountCalculated, , ) = _swapHook(params);\n\n        return amountCalculated;\n    }\n}\n"
    }
}