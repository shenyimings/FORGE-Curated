{
    "vfp_id": "vfp_00536",
    "project_name": "cantina_honeyjar_february2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Admin can lock funds",
            "description": "1. **Description:** The admin (or reward notifier) can set reward parameters in a way that effectively locks user funds by misconfiguring the reward system, particularly in the notifyRewardAmount function.\n2. **Cause:** The function lacks validation checks to ensure the reward token is not the zero address or the contract itself, which could lead to incorrect reward distribution or locking of funds.\n3. **Exploitation:** An attacker with admin privileges could set a malicious reward token address, preventing proper reward distribution and effectively locking user funds by disrupting the expected functionality.\n4. **Impact:** Users may be unable to claim their rightful rewards, leading to loss of trust and potential financial loss if the system becomes unusable.\n",
            "severity": "Medium",
            "location": [
                "fatBERA.sol#L206",
                "fatBERA.sol#L252"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Deposits and Mints to Whitelisted Vaults Result in Lost Rewards",
            "description": "1. **Description:** Depositing or minting directly to a whitelisted vault results in lost rewards because such vaults are treated as having zero effective balance.\n2. **Cause:** The contract does not prevent deposits or mints to whitelisted vaults, which bypass the reward tracking mechanism since these vaults do not accumulate shares in the expected way.\n3. **Exploitation:** A user could deposit funds into a whitelisted vault, causing their shares to be recorded without proper reward synchronization, leading to permanent loss of accrued rewards.\n4. **Impact:** Users lose out on expected rewards, undermining the incentive model of the protocol and potentially leading to financial loss.\n",
            "severity": "Medium",
            "location": [
                "fatBERA.sol#L323-L343",
                "fatBERA.sol#L352-L359",
                "fatBERA.sol#L368-L376"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Whitelisted Vaults Not Receiving Accumulated Rewards",
            "description": "1. **Description:** When a vault is added to the whitelist after having been active, it does not receive rewards that accrued while it was not whitelisted.\n2. **Cause:** The setWhitelistedVault function does not update rewards before changing the vault's status, so any potential rewards during the non-whitelisted period are lost.\n3. **Exploitation:** An attacker could delay whitelisting a vault they control to manipulate reward accrual timing, or users may simply lose out due to the missing update.\n4. **Impact:** Loss of expected rewards for vault operators, reducing fairness and economic integrity of the system.\n",
            "severity": "Medium",
            "location": [
                "fatBERA.sol#L262-L264"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Misleading Values on Preview Functions When Withdrawals Are Disabled",
            "description": "1. **Description:** The previewWithdraw and previewRedeem functions return non-zero values even though withdrawals are disabled by maxWithdraw and maxRedeem returning 0.\n2. **Cause:** The preview functions are not overridden to reflect the disabled state, leading to inconsistent behavior.\n3. **Exploitation:** A user or frontend interface may rely on preview functions to determine if withdrawals are possible, leading to failed transactions and poor user experience.\n4. **Impact:** User confusion, failed transactions, and potential loss of trust in the system due to misleading interface behavior.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "setMaxDeposits Can Be Front-Run and Prevent Proper Deposit Management",
            "description": "1. **Description:** The setMaxDeposits function can be front-run by users who deposit just before the admin's transaction, causing the new maxDeposits value to be less than the current depositPrincipal and reverting the admin's transaction.\n2. **Cause:** The function allows newMax to be set equal to depositPrincipal without accounting for potential frontrunning, making it vulnerable to race conditions.\n3. **Exploitation:** An attacker can monitor mempool for admin transactions and submit a deposit to push depositPrincipal above the intended newMax, causing the admin's transaction to fail.\n4. **Impact:** The admin may be unable to adjust deposit caps effectively, disrupting deposit management and potentially leaving the system exposed to uncontrolled deposits.\n",
            "severity": "Low",
            "location": [
                "fatBERA.sol#L179-L182"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Principal Withdrawal Can Cause Underflow and Withdrawal Failures",
            "description": "1. **Description:** The withdrawPrincipal function allows the admin to withdraw principal assets, which can reduce depositPrincipal to a level where future withdrawals fail due to insufficient balance.\n2. **Cause:** The function does not ensure that the contract retains enough balance to cover future user withdrawals after principal is withdrawn.\n3. **Exploitation:** An admin could withdraw too much principal, causing subsequent user withdrawal attempts to fail when the contract lacks sufficient funds to transfer.\n4. **Impact:** Users may be unable to withdraw their funds, leading to loss of funds and trust in the protocol.\n",
            "severity": "Low",
            "location": [
                "fatBERA.sol#L190-L196"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "_updateReward calculation could lead to reward inflation allowing a user to steal rewards",
            "description": "1. **Description:** The _updateReward function calculates additional rewards using totalSupply, but if totalSupply is less than 1e18, the reward per share becomes inflated due to division by a very small number.\n2. **Cause:** The calculation assumes a minimum totalSupply of 1e18, but no such guarantee is enforced, leading to arithmetic inflation when supply is low.\n3. **Exploitation:** A user controlling a large portion of a very small total supply could trigger reward distribution and receive disproportionately high rewards.\n4. **Impact:** Reward inflation could allow a malicious actor to steal a significant portion of the reward pool, diluting other users' rewards and compromising economic fairness.\n",
            "severity": "Low",
            "location": [
                "fatBERA.sol#L562-L566",
                "fatBERA.sol#L545-L548"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "claimRewards(address) contains duplicate code and could be simplified",
            "description": "1. **Description:** The claimRewards(address) function duplicates logic already present in claimRewards(address,address), increasing code size and gas costs.\n2. **Cause:** Redundant implementation instead of reusing the more specific public function.\n3. **Exploitation:** While not directly exploitable, this increases deployment and execution costs unnecessarily.\n4. **Impact:** Higher gas consumption for users, reduced code maintainability, and increased risk of bugs due to duplicated logic.\n",
            "severity": "Informational",
            "location": [
                "fatBERA.sol#L384-L409"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Inconsistent errors",
            "description": "1. **Description:** The contract uses string-based revert messages in some places (require(..., \"error\")) instead of custom errors, leading to inconsistent error handling.\n2. **Cause:** Mixed use of Solidity error patterns without standardization across the codebase.\n3. **Exploitation:** Not directly exploitable, but increases bytecode size and reduces readability and gas efficiency.\n4. **Impact:** Higher gas costs and reduced code clarity, making integration and debugging harder for external developers.\n",
            "severity": "Informational",
            "location": [
                "fatBERA.sol#L223",
                "fatBERA.sol#L251-L252"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Unnecessary storage reads in _lastTimeRewardApplicable",
            "description": "1. **Description:** The _lastTimeRewardApplicable function reads rewardData[token] from storage even though it is already read in the calling function _updateReward.\n2. **Cause:** Redundant storage access due to poor function design and lack of parameter passing.\n3. **Exploitation:** Not exploitable, but increases gas cost unnecessarily.\n4. **Impact:** Increased gas consumption for reward calculations, affecting all users interacting with reward functions.\n",
            "severity": "Informational",
            "location": [
                "fatBERA.sol#L558-L575"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-571"
                ]
            },
            "title": "Unnecessary amount checks",
            "description": "1. **Description:** The contract includes checks for amount > 0 on uint256 parameters, which is redundant since unsigned integers cannot be negative.\n2. **Cause:** Over-cautious validation that does not account for Solidity type semantics.\n3. **Exploitation:** No security risk, but wastes gas on unnecessary checks.\n4. **Impact:** Increased gas costs for transactions involving these functions, reducing efficiency.\n",
            "severity": "Informational",
            "location": [
                "fatBERA.sol#L191",
                "fatBERA.sol#L205"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "Separation of Pause and Unpause Permissions",
            "description": "1. **Description:** Both pause and unpause functions require DEFAULT_ADMIN_ROLE, which does not follow the principle of least privilege for emergency response.\n2. **Cause:** Lack of role separation between pausing (emergency action) and unpausing (recovery action).\n3. **Exploitation:** In an emergency, if the admin key is not immediately available, the system cannot be paused quickly, increasing risk.\n4. **Impact:** Slower response to security incidents, reduced operational security, and potential for greater damage during attacks.\n",
            "severity": "Informational",
            "location": [
                "fatBERA.sol#L134-L144"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-703"
                ]
            },
            "title": "Implemented, but not ready functions",
            "description": "1. **Description:** Functions like withdraw and redeem are implemented but disabled by setting maxWithdraw to 0, indicating they are not yet ready for use.\n2. **Cause:** Incomplete feature rollout without proper function disabling (e.g., using revert or noop).\n3. **Exploitation:** Users may attempt to call these functions, expecting them to work, only to have transactions fail unexpectedly.\n4. **Impact:** Poor user experience, potential confusion, and possible integration issues with frontends or other contracts.\n",
            "severity": "Informational",
            "location": [
                "fatBERA.sol#L411-L452"
            ],
            "files": [
                "LST/src/fatBERA.sol"
            ]
        }
    ],
    "affected_files": {
        "fatBERA.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC4626Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                          INTERFACES                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\ncontract fatBERA is\n    ERC4626Upgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          ERRORS                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error ZeroPrincipal();\n    error ExceedsPrincipal();\n    error ZeroRewards();\n    error ExceedsMaxDeposits();\n    error ExceedsAvailableRewards();\n    error InvalidToken();\n    error ZeroShares();\n    error ExceedsMaxRewardsTokens();\n    error RewardsDurationNotSet();\n    error RewardPeriodStillActive();\n    error ZeroRewardDuration();\n    error CannotDepositToVault();\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    struct RewardData {\n        uint256 rewardPerShareStored;\n        uint256 totalRewards;\n        uint256 rewardsDuration;\n        uint256 periodFinish;\n        uint256 rewardRate;\n        uint256 lastUpdateTime;\n        uint256 remainingRewards;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          Events                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event RewardAdded(address indexed token, uint256 rewardAmount);\n    event RewardsDurationUpdated(address indexed token, uint256 newDuration);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    uint256 public depositPrincipal;\n    uint256 public maxDeposits;\n\n    mapping(address => RewardData) public rewardData;\n    mapping(address => mapping(address => uint256)) public userRewardPerSharePaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    address[] public rewardTokens;\n    mapping(address => bool) public isRewardToken;\n    uint256 public MAX_REWARDS_TOKENS;\n\n    bytes32 public constant REWARD_NOTIFIER_ROLE = keccak256(\"REWARD_NOTIFIER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    mapping(address => uint256) public vaultedShares;\n    mapping(address => bool) public isWhitelistedVault;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          CONSTRUCTOR                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Contract constructor.\n     * @dev Disables initializers to prevent misuse.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          Events                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Initializes the contract variables and parent contracts.\n     * @param _asset The address of the underlying asset.\n     * @param _owner The admin owner address.\n     * @param _maxDeposits The maximum deposit limit.\n     * @dev Calls initializer functions from parent contracts and sets up admin roles.\n     */\n    function initialize(address _asset, address _owner, uint256 _maxDeposits) external initializer {\n        __ERC4626_init(IERC20(_asset));\n        __ERC20_init(\"fatBERA\", \"fatBERA\");\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n\n        // Set up roles\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n        _grantRole(REWARD_NOTIFIER_ROLE, _owner);\n        _grantRole(PAUSER_ROLE, _owner);\n\n        MAX_REWARDS_TOKENS = 10;\n\n        maxDeposits = _maxDeposits;\n        _pause();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          OWNER LOGIC                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Pauses contract operations.\n     * @dev Can be called by accounts with PAUSER_ROLE for quick emergency response.\n     */\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses contract operations.\n     * @dev Only callable by admin after thorough review of the emergency situation.\n     */\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Sets the maximum number of allowed reward tokens.\n     * @param newMax The new maximum reward tokens.\n     * @dev Only callable by admin.\n     */\n    function setMaxRewardsTokens(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        MAX_REWARDS_TOKENS = newMax;\n    }\n\n    /**\n     * @notice Withdraws the accumulated rounding losses for a specific reward token.\n     * @param token The address of the reward token.\n     * @param receiver The address receiving the rounded lost rewards.\n     * @dev Only callable by admin.\n     */\n    function withdrawRemainingRewards(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = rewardData[token].remainingRewards;\n        rewardData[token].remainingRewards = 0;\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n    /**\n     * @notice Authorizes an upgrade of the contract implementation.\n     * @param newImplementation The address of the new implementation.\n     * @dev Only callable by admin.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    /**\n     * @notice Updates the maximum deposit limit.\n     * @param newMax The new maximum deposit limit.\n     * @dev If newMax is less than depositPrincipal, maxDeposits is set to depositPrincipal to halt deposits.\n     */\n    function setMaxDeposits(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        maxDeposits = newMax < depositPrincipal ? depositPrincipal : newMax;\n    }\n\n    /**\n     * @notice Allows admin to withdraw principal deposits.\n     * @param assets The amount of principal tokens to withdraw.\n     * @param receiver The address receiving the withdrawn tokens.\n     * @dev Reverts if assets is zero or exceeds the deposit principal.\n     */\n    function withdrawPrincipal(uint256 assets, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (assets == 0) revert ZeroPrincipal();\n        if (assets > depositPrincipal) revert ExceedsPrincipal();\n\n        depositPrincipal -= assets;\n        IERC20(asset()).safeTransfer(receiver, assets);\n    }\n\n    /**\n     * @notice Notifies the contract of new reward tokens.\n     * @param token The address of the reward token.\n     * @param rewardAmount The amount of reward tokens to distribute.\n     * @dev Updates reward rate and accumulates any rounding losses, ensuring exact division when reward period has ended.\n     */\n    function notifyRewardAmount(address token, uint256 rewardAmount) external onlyRole(REWARD_NOTIFIER_ROLE) {\n        if (rewardAmount == 0) revert ZeroRewards();\n        if (token == address(0) || token == address(this)) revert InvalidToken();\n\n        uint256 totalSharesCurrent = totalSupply();\n        if (totalSharesCurrent == 0) revert ZeroShares();\n\n        IERC20 rewardToken = IERC20(token);\n        rewardToken.safeTransferFrom(msg.sender, address(this), rewardAmount);\n\n        // Add to reward tokens list if new\n        if (!isRewardToken[token]) {\n            rewardTokens.push(token);\n            if (rewardTokens.length > MAX_REWARDS_TOKENS) revert ExceedsMaxRewardsTokens();\n            isRewardToken[token] = true;\n        }\n\n        RewardData storage data = rewardData[token];\n        // Ensure rewards duration is set\n        if (data.rewardsDuration == 0) revert RewardsDurationNotSet();\n\n        _updateReward(token);\n\n        if (block.timestamp >= data.periodFinish) {\n            data.rewardRate = rewardAmount / data.rewardsDuration;\n            data.remainingRewards += rewardAmount - data.rewardRate * data.rewardsDuration;\n        } else {\n            uint256 remaining = data.periodFinish - block.timestamp;\n            uint256 leftover = remaining * data.rewardRate;\n            data.rewardRate = (rewardAmount + leftover) / data.rewardsDuration;\n            data.remainingRewards += (rewardAmount + leftover) - data.rewardRate * data.rewardsDuration;\n        }\n\n        data.lastUpdateTime = block.timestamp;\n        data.periodFinish = block.timestamp + data.rewardsDuration;\n        data.totalRewards += rewardAmount;\n        emit RewardAdded(token, rewardAmount);\n    }\n\n    /**\n     * @notice Sets the rewards duration for a given reward token.\n     * @param token The address of the reward token.\n     * @param duration The new rewards duration.\n     * @dev Only callable by admin after the current reward period has ended.\n     */\n    function setRewardsDuration(address token, uint256 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        RewardData storage data = rewardData[token];\n        if (block.timestamp <= data.periodFinish) revert RewardPeriodStillActive();\n        if (duration == 0) revert ZeroRewardDuration();\n        data.rewardsDuration = duration;\n        emit RewardsDurationUpdated(token, duration);\n    }\n\n    /**\n     * @dev Admin function to set a whitelisted vault address.\n     * Vaults are considered external contracts that hold fatBERA and\n     * should not accrue rewards.\n     */\n    function setWhitelistedVault(address vaultAddress, bool status) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (!isWhitelistedVault[vaultAddress]) {\n            _updateRewards(vaultAddress);\n        }\n        isWhitelistedVault[vaultAddress] = status;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        EXTERNAL LOGIC                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Returns the total assets in the vault.\n     * @return The total assets, equal to the total supply.\n     * @dev Overrides default behavior to ignore yield-related tokens.\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        return totalSupply();\n    }\n\n    /**\n     * @notice Returns the maximum amount of assets that can be deposited.\n     * @return The available deposit amount.\n     * @dev The input parameter is unused; functionality is based solely on maxDeposits.\n     */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        if (totalSupply() >= maxDeposits) return 0;\n        return maxDeposits - totalSupply();\n    }\n\n    /**\n     * @notice Returns the maximum number of shares that can be minted.\n     * @param receiver The address for which to query.\n     * @return The maximum shares that can be minted.\n     * @dev Since shares map 1:1 to assets, this is equal to maxDeposit.\n     */\n    function maxMint(address receiver) public view virtual override returns (uint256) {\n        return maxDeposit(receiver);\n    }\n\n    /**\n     * @notice Returns the maximum amount of assets that can be withdrawn.\n     * @return Always returns 0.\n     * @dev The input parameter is unused; withdrawals are currently disabled.\n     */\n    function maxWithdraw(address) public view virtual override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Returns the maximum number of shares that can be redeemed.\n     * @return Always returns 0.\n     * @dev The input parameter is unused; withdrawals are currently disabled.\n     */\n    function maxRedeem(address) public view virtual override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Deposits native ETH, wraps it, and mints vault shares.\n     * @param receiver The address receiving the minted shares.\n     * @return The number of shares minted.\n     * @dev Wraps ETH to WBERA and bypasses ERC4626 deposit since assets are already provided.\n     */\n    function depositNative(address receiver) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroPrincipal();\n        if (msg.value > maxDeposit(receiver)) revert ExceedsMaxDeposits();\n        if (isWhitelistedVault[receiver]) revert CannotDepositToVault();\n        _updateRewards(receiver);\n\n        // Wrap native token\n        IWETH weth = IWETH(asset());\n        weth.deposit{value: msg.value}();\n\n        // Calculate shares using previewDeposit\n        uint256 shares = previewDeposit(msg.value);\n\n        // Bypass ERC4626 deposit and mint directly (assets already held)\n        _mint(receiver, shares);\n        depositPrincipal += msg.value;\n\n        // Emit Deposit event to match ERC4626 spec\n        emit Deposit(msg.sender, receiver, msg.value, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Deposits assets into the vault and updates rewards.\n     * @param assets The amount of assets to deposit.\n     * @param receiver The address receiving the shares.\n     * @return The number of shares minted.\n     * @dev Overrides the parent deposit function and increments depositPrincipal.\n     */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        if (isWhitelistedVault[receiver]) revert CannotDepositToVault();\n        _updateRewards(receiver);\n\n        uint256 sharesMinted = super.deposit(assets, receiver);\n        depositPrincipal += assets;\n\n        return sharesMinted;\n    }\n\n    /**\n     * @notice Mints shares by depositing assets.\n     * @param shares The number of shares to mint.\n     * @param receiver The address receiving the minted shares.\n     * @return The amount of assets required.\n     * @dev Overrides the parent mint function and increments depositPrincipal.\n     */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        if (isWhitelistedVault[receiver]) revert CannotDepositToVault();\n        _updateRewards(receiver);\n\n        uint256 assetsRequired = super.previewMint(shares);\n        assetsRequired = super.mint(shares, receiver);\n        depositPrincipal += assetsRequired;\n\n        return assetsRequired;\n    }\n    /**\n     * @notice Claims accrued rewards for a specific reward token.\n     * @param token The address of the reward token.\n     * @param receiver The address receiving the claimed rewards.\n     * @dev Updates rewards prior to claiming and resets the user's reward balance.\n     */\n\n    function claimRewards(address token, address receiver) public nonReentrant {\n        _updateRewards(msg.sender, token);\n\n        uint256 reward = rewards[token][msg.sender];\n        if (reward > 0) {\n            rewards[token][msg.sender] = 0;\n            IERC20(token).safeTransfer(receiver, reward);\n        }\n    }\n\n    /**\n     * @notice Claims accrued rewards for all reward tokens.\n     * @param receiver The address receiving the claimed rewards.\n     * @dev Iterates through all reward tokens and claims each one.\n     */\n    function claimRewards(address receiver) public {\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            claimRewards(rewardTokens[i], receiver);\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                WITHDRAWALS ARENT ENABLED YET               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Withdraws assets from the vault.\n     * @param assets The amount of assets to withdraw.\n     * @param receiver The address receiving the assets.\n     * @param owner The owner of the shares to be withdrawn.\n     * @return The number of burned shares.\n     * @dev Updates rewards and decrements depositPrincipal. Withdrawals are subject to pause conditions.\n     */\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        _updateRewards(owner);\n\n        uint256 burnedShares = super.withdraw(assets, receiver, owner);\n        depositPrincipal -= assets;\n\n        return burnedShares;\n    }\n\n    /**\n     * @notice Redeems shares for the underlying assets.\n     * @param shares The number of shares to redeem.\n     * @param receiver The address receiving the assets.\n     * @param owner The owner of the shares.\n     * @return The amount of redeemed assets.\n     * @dev Updates rewards and decrements depositPrincipal. Withdrawals are subject to pause conditions.\n     */\n    function redeem(uint256 shares, address receiver, address owner) public override whenNotPaused returns (uint256) {\n        _updateRewards(owner);\n\n        uint256 redeemedAssets = super.redeem(shares, receiver, owner);\n        depositPrincipal -= redeemedAssets;\n\n        return redeemedAssets;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          VIEW LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Simulates the effects of withdrawing assets at the current block.\n     * @return Returns 0 if paused, otherwise returns the standard ERC4626 preview calculation.\n     * @dev Overridden to maintain consistency with maxWithdraw when paused.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        if (paused()) return 0;\n        return super.previewWithdraw(assets);\n    }\n\n    /**\n     * @notice Simulates the effects of redeeming shares at the current block.\n     * @return Returns 0 if paused, otherwise returns the standard ERC4626 preview calculation.\n     * @dev Overridden to maintain consistency with maxRedeem when paused.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        if (paused()) return 0;\n        return super.previewRedeem(shares);\n    }\n\n    /**\n     * @dev Returns the effective balance of an account for reward calculations.\n     * For a regular (non-vault) user, effective balance = wallet balance + vaultedShares.\n     * For a whitelisted vault, effective balance is 0.\n     */\n    function effectiveBalance(address account) public view returns (uint256) {\n        if (isWhitelistedVault[account]) return 0;\n        return balanceOf(account) + vaultedShares[account];\n    }\n\n    function previewRewards(address account, address token) external view returns (uint256) {\n        RewardData storage data = rewardData[token];\n        uint256 currentRewardPerShare = data.rewardPerShareStored;\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            uint256 lastApplicable = block.timestamp < data.periodFinish ? block.timestamp : data.periodFinish;\n            uint256 elapsed = lastApplicable - data.lastUpdateTime;\n            uint256 additional = FixedPointMathLib.fullMulDiv(elapsed * data.rewardRate, 1e36, supply);\n            currentRewardPerShare += additional;\n        }\n        return rewards[token][account]\n            + FixedPointMathLib.fullMulDiv(\n                effectiveBalance(account), currentRewardPerShare - userRewardPerSharePaid[token][account], 1e36\n            );\n    }\n\n    /**\n     * @notice Retrieves the list of reward tokens.\n     * @return An array containing the addresses of all reward tokens.\n     * @dev Helper function for frontend and external integrations.\n     */\n    function getRewardTokens() external view returns (address[] memory) {\n        return rewardTokens;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       INTERNAL LOGIC                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @notice Hook to update rewards during token transfers.\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @dev Only updates rewards if both addresses are non-zero.\n     */\n    function _update(address from, address to, uint256 amount) internal override {\n        if (from != address(0) && to != address(0)) {\n            if (!isWhitelistedVault[from] && isWhitelistedVault[to]) {\n                // Depositing to a whitelisted vault.\n                _updateRewards(from);\n                vaultedShares[from] += amount;\n            } else if (isWhitelistedVault[from] && !isWhitelistedVault[to]) {\n                // Withdrawing from a whitelisted vault.\n                _updateRewards(to);\n                if (vaultedShares[to] < amount) revert(\"Insufficient vaulted shares\");\n                vaultedShares[to] -= amount;\n            } else {\n                // Normal transfer between non‑vault addresses (or vault <-> vault, though vaults have no effective balance).\n                _updateRewards(from);\n                _updateRewards(to);\n            }\n        }\n        super._update(from, to, amount);\n    }\n\n    /**\n     * @notice Updates rewards for all reward tokens for a given account.\n     * @param account The address for which rewards are updated.\n     * @dev Iterates over each reward token and calls _updateRewards for individual tokens.\n     */\n    function _updateRewards(address account) internal {\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            _updateRewards(account, rewardTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Updates rewards for a specific reward token for an account.\n     * @param account The address for which rewards are updated.\n     * @param token The reward token address.\n     * @dev Updates global reward data before calculating and storing user-specific rewards.\n     */\n    function _updateRewards(address account, address token) internal {\n        _updateReward(token);\n        RewardData storage data = rewardData[token];\n        uint256 effectiveBal = effectiveBalance(account);\n        if (effectiveBal > 0) {\n            uint256 earned = data.rewardPerShareStored - userRewardPerSharePaid[token][account];\n            rewards[token][account] += FixedPointMathLib.fullMulDiv(effectiveBal, earned, 1e36);\n        }\n        userRewardPerSharePaid[token][account] = data.rewardPerShareStored;\n    }\n\n    /**\n     * @notice Updates the global reward data for a specific token.\n     * @param token The reward token address.\n     * @dev Computes additional reward per share based on elapsed time and updates last update time.\n     */\n    function _updateReward(address token) internal {\n        RewardData storage data = rewardData[token];\n        uint256 lastApplicable = block.timestamp < data.periodFinish ? block.timestamp : data.periodFinish;\n        if (totalSupply() > 0) {\n            uint256 elapsed = lastApplicable - data.lastUpdateTime;\n            if (elapsed > 0) {\n                uint256 additional = FixedPointMathLib.fullMulDiv(elapsed * data.rewardRate, 1e36, totalSupply());\n                data.rewardPerShareStored += additional;\n            }\n        }\n        data.lastUpdateTime = lastApplicable;\n    }\n}\n"
    }
}