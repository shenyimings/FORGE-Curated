{
    "vfp_id": "vfp_00360",
    "project_name": "cantina_eco_pr28_pr38_aug2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Transfer permits bypass lockdown functionality",
            "description": "The lockdown() function is designed to prevent transfers in case of account or contract compromise, but it is not enforced for transfer permits. This means that even if an account is locked down, an attacker with a valid transfer permit can still execute transfers, completely bypassing the intended security mechanism. The cause is the absence of a call to _validateLockStatus() before executing permit-based transfers. An attacker who obtains a valid signature or permit can exploit this to drain funds despite the lockdown being active. The impact is a significant reduction in the effectiveness of the lockdown feature, potentially allowing theft of assets even after a user has attempted to secure their account.\n",
            "severity": "High",
            "location": [
                "Permit3.sol#L347"
            ],
            "files": [
                "833b84f8/permit3/src/Permit3.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Allowance timestamp can not be decreased",
            "description": "The allowance timestamp in the Permit3 contract cannot be decreased once set. If a timestamp is mistakenly set to a very high value (e.g., type(uint48).max), it cannot be corrected, effectively freezing the allowance until that distant time. This occurs because there is no validation or mechanism to lower the timestamp, treating it like a monotonic nonce rather than a time-bound parameter. An attacker or user error could set an excessively high timestamp, rendering the allowance unusable for practical purposes. The impact is loss of functionality for legitimate users who cannot update or correct their allowance settings, leading to potential fund lockup or usability issues.\n",
            "severity": "Medium",
            "location": [
                "Permit3.sol#L496-L501"
            ],
            "files": [
                "833b84f8/permit3/src/Permit3.sol"
            ]
        }
    ],
    "affected_files": {
        "Permit3.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IPermit3 } from \"./interfaces/IPermit3.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport { NonceManager } from \"./NonceManager.sol\";\nimport { PermitBase } from \"./PermitBase.sol\";\n\n/**\n * @title Permit3\n * @notice A cross-chain token approval and transfer system using EIP-712 signatures with merkle proofs\n * @dev Key features and components:\n * 1. Cross-chain Compatibility: Single signature can authorize operations across multiple chains\n * 2. Batched Operations: Process multiple token approvals and transfers in one transaction\n * 3. Flexible Nonce System: Non-sequential nonces for concurrent operations and gas optimization\n * 4. Time-bound Approvals: Permissions can be set to expire automatically\n * 5. EIP-712 Typed Signatures: Enhanced security through structured data signing\n * 6. Merkle Proofs: Optimized proof structure for cross-chain verification\n */\ncontract Permit3 is IPermit3, PermitBase, NonceManager {\n    /**\n     * @dev EIP-712 typehash for bundled chain permits\n     * Includes nested SpendTransferPermit struct for structured token permissions\n     * Used in cross-chain signature verification\n     */\n    bytes32 public constant CHAIN_PERMITS_TYPEHASH = keccak256(\n        \"ChainPermits(uint64 chainId,AllowanceOrTransfer[] permits)AllowanceOrTransfer(uint48 modeOrExpiration,address token,address account,uint160 amountDelta)\"\n    );\n\n    /**\n     * @dev EIP-712 typehash for the primary permit signature\n     * Binds owner, deadline, and permit data hash for signature verification\n     */\n    bytes32 public constant SIGNED_PERMIT3_TYPEHASH =\n        keccak256(\"Permit3(address owner,bytes32 salt,uint48 deadline,uint48 timestamp,bytes32 merkleRoot)\");\n\n    // Constants for witness type hash strings\n    string public constant PERMIT_WITNESS_TYPEHASH_STUB =\n        \"PermitWitness(address owner,bytes32 salt,uint48 deadline,uint48 timestamp,bytes32 merkleRoot,\";\n\n    /**\n     * @dev Sets up EIP-712 domain separator with protocol identifiers\n     * @notice Establishes the contract's domain for typed data signing\n     */\n    constructor() NonceManager(\"Permit3\", \"1\") { }\n\n    /**\n     * @dev Generate EIP-712 compatible hash for chain permits\n     * @param chainPermits Chain-specific permit data\n     * @return bytes32 Combined hash of all permit parameters\n     */\n    function hashChainPermits(\n        ChainPermits memory chainPermits\n    ) public pure returns (bytes32) {\n        uint256 permitsLength = chainPermits.permits.length;\n        bytes32[] memory permitHashes = new bytes32[](permitsLength);\n\n        for (uint256 i = 0; i < permitsLength; i++) {\n            permitHashes[i] = keccak256(\n                abi.encode(\n                    chainPermits.permits[i].modeOrExpiration,\n                    chainPermits.permits[i].token,\n                    chainPermits.permits[i].account,\n                    chainPermits.permits[i].amountDelta\n                )\n            );\n        }\n\n        return keccak256(\n            abi.encode(CHAIN_PERMITS_TYPEHASH, chainPermits.chainId, keccak256(abi.encodePacked(permitHashes)))\n        );\n    }\n\n    /**\n     * @notice Direct permit execution for ERC-7702 integration\n     * @dev No signature verification - caller must be the token owner\n     * @param permits Array of permit operations to execute on current chain\n     */\n    function permit(\n        AllowanceOrTransfer[] memory permits\n    ) external {\n        if (permits.length == 0) {\n            revert EmptyArray();\n        }\n\n        ChainPermits memory chainPermits = ChainPermits({ chainId: uint64(block.chainid), permits: permits });\n        _processChainPermits(msg.sender, uint48(block.timestamp), chainPermits);\n    }\n\n    /**\n     * @notice Process token approvals for a single chain\n     * @dev Core permit processing function for single-chain operations\n     * @param owner The token owner authorizing the permits\n     * @param salt Unique value for replay protection and nonce management\n     * @param deadline Timestamp limiting signature validity for security\n     * @param timestamp Timestamp of the permit\n     * @param permits Array of permit operations to execute\n     * @param signature EIP-712 signature authorizing all permits in the batch\n     */\n    function permit(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        AllowanceOrTransfer[] calldata permits,\n        bytes calldata signature\n    ) external {\n        if (owner == address(0)) {\n            revert ZeroOwner();\n        }\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n\n        if (permits.length == 0) {\n            revert EmptyArray();\n        }\n\n        ChainPermits memory chainPermits = ChainPermits({ chainId: uint64(block.chainid), permits: permits });\n\n        bytes32 signedHash = keccak256(\n            abi.encode(SIGNED_PERMIT3_TYPEHASH, owner, salt, deadline, timestamp, hashChainPermits(chainPermits))\n        );\n\n        _useNonce(owner, salt);\n        _verifySignature(owner, signedHash, signature);\n        _processChainPermits(owner, timestamp, chainPermits);\n    }\n\n    // Helper struct to avoid stack-too-deep errors\n    struct PermitParams {\n        address owner;\n        bytes32 salt;\n        uint48 deadline;\n        uint48 timestamp;\n        bytes32 currentChainHash;\n        bytes32 merkleRoot;\n    }\n\n    /**\n     * @notice Process token approvals across multiple chains using Merkle Tree\n     * @param owner Token owner authorizing the operations\n     * @param salt Unique salt for replay protection\n     * @param deadline Signature expiration timestamp\n     * @param timestamp Timestamp of the permit\n     * @param permits Permit operations for the current chain\n     * @param proof Merkle proof array for verification\n     * @param signature EIP-712 signature covering the entire cross-chain batch\n     */\n    function permit(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        ChainPermits calldata permits,\n        bytes32[] calldata proof,\n        bytes calldata signature\n    ) external {\n        if (owner == address(0)) {\n            revert ZeroOwner();\n        }\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (permits.chainId != uint64(block.chainid)) {\n            revert WrongChainId(uint64(block.chainid), permits.chainId);\n        }\n\n        // Use a struct to avoid stack-too-deep errors\n        PermitParams memory params;\n        params.owner = owner;\n        params.salt = salt;\n        params.deadline = deadline;\n        params.timestamp = timestamp;\n\n        // Hash current chain's permits\n        params.currentChainHash = hashChainPermits(permits);\n\n        // Calculate the merkle root from the proof components\n        // processProof performs validation internally and provides granular error messages\n        params.merkleRoot = MerkleProof.processProof(proof, params.currentChainHash);\n\n        // Verify signature with merkle root\n        bytes32 signedHash = keccak256(\n            abi.encode(\n                SIGNED_PERMIT3_TYPEHASH, params.owner, params.salt, params.deadline, params.timestamp, params.merkleRoot\n            )\n        );\n\n        _useNonce(owner, salt);\n        _verifySignature(params.owner, signedHash, signature);\n        _processChainPermits(params.owner, params.timestamp, permits);\n    }\n\n    /**\n     * @notice Process token approvals with witness data for single chain operations\n     * @dev Handles permitWitnessTransferFrom operations with dynamic witness data\n     * @param owner The token owner authorizing the permits\n     * @param salt Unique salt for replay protection\n     * @param deadline Timestamp limiting signature validity for security\n     * @param timestamp Timestamp of the permit\n     * @param permits Array of permit operations to execute\n     * @param witness Additional data to include in signature verification\n     * @param witnessTypeString EIP-712 type definition for witness data\n     * @param signature EIP-712 signature authorizing all permits with witness\n     */\n    function permitWitness(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        AllowanceOrTransfer[] calldata permits,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external {\n        if (owner == address(0)) {\n            revert ZeroOwner();\n        }\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n\n        if (permits.length == 0) {\n            revert EmptyArray();\n        }\n\n        ChainPermits memory chainPermits = ChainPermits({ chainId: uint64(block.chainid), permits: permits });\n\n        // Validate witness type string format\n        _validateWitnessTypeString(witnessTypeString);\n\n        // Get hash of permits data\n        bytes32 permitDataHash = hashChainPermits(chainPermits);\n\n        // Compute witness-specific typehash and signed hash\n        bytes32 typeHash = _getWitnessTypeHash(witnessTypeString);\n        bytes32 signedHash = keccak256(abi.encode(typeHash, owner, salt, deadline, timestamp, permitDataHash, witness));\n\n        _useNonce(owner, salt);\n        _verifySignature(owner, signedHash, signature);\n        _processChainPermits(owner, timestamp, chainPermits);\n    }\n\n    // Helper struct to avoid stack-too-deep errors\n    struct WitnessParams {\n        address owner;\n        bytes32 salt;\n        uint48 deadline;\n        uint48 timestamp;\n        bytes32 witness;\n        bytes32 currentChainHash;\n        bytes32 merkleRoot;\n    }\n\n    /**\n     * @notice Process permit with additional witness data for cross-chain operations\n     * @param owner Token owner address\n     * @param salt Unique salt for replay protection\n     * @param deadline Signature expiration timestamp\n     * @param timestamp Timestamp of the permit\n     * @param permits Permit operations for the current chain\n     * @param proof Merkle proof array for verification\n     * @param witness Additional data to include in signature verification\n     * @param witnessTypeString EIP-712 type definition for witness data\n     * @param signature EIP-712 signature authorizing the batch\n     */\n    function permitWitness(\n        address owner,\n        bytes32 salt,\n        uint48 deadline,\n        uint48 timestamp,\n        ChainPermits calldata permits,\n        bytes32[] calldata proof,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external {\n        if (owner == address(0)) {\n            revert ZeroOwner();\n        }\n        if (block.timestamp > deadline) {\n            revert SignatureExpired(deadline, uint48(block.timestamp));\n        }\n        if (permits.chainId != uint64(block.chainid)) {\n            revert WrongChainId(uint64(block.chainid), permits.chainId);\n        }\n\n        // Validate witness type string format\n        _validateWitnessTypeString(witnessTypeString);\n\n        // Use a struct to avoid stack-too-deep errors\n        WitnessParams memory params;\n        params.owner = owner;\n        params.salt = salt;\n        params.deadline = deadline;\n        params.timestamp = timestamp;\n        params.witness = witness;\n\n        // Hash current chain's permits\n        params.currentChainHash = hashChainPermits(permits);\n\n        // Calculate the merkle root\n        // processProof performs validation internally and provides granular error messages\n        params.merkleRoot = MerkleProof.processProof(proof, params.currentChainHash);\n\n        // Compute witness-specific typehash and signed hash\n        bytes32 typeHash = _getWitnessTypeHash(witnessTypeString);\n        bytes32 signedHash = keccak256(\n            abi.encode(\n                typeHash,\n                params.owner,\n                params.salt,\n                params.deadline,\n                params.timestamp,\n                params.merkleRoot,\n                params.witness\n            )\n        );\n\n        _useNonce(owner, salt);\n        _verifySignature(params.owner, signedHash, signature);\n        _processChainPermits(params.owner, params.timestamp, permits);\n    }\n\n    /**\n     * @dev Core permit processing logic that executes multiple permit operations in a single transaction\n     * @param owner Token owner authorizing the operations\n     * @param timestamp Block timestamp for validation and allowance updates\n     * @param chainPermits Bundle of permit operations to process on the current chain\n     * @notice Handles multiple types of operations based on modeOrExpiration:\n     *        = 0: Immediate transfer mode - transfers tokens directly\n     *        = 1: Decrease allowance mode - reduces existing allowance\n     *        = 2: Lock allowance mode - locks allowance to prevent usage\n     *        = 3: Unlock allowance mode - unlocks previously locked allowance\n     *        > 3: Increase allowance mode with expiration timestamp\n     * @notice The function enforces timestamp-based locking mechanisms and handles\n     *         special MAX_ALLOWANCE values for infinite approvals\n     */\n    function _processChainPermits(address owner, uint48 timestamp, ChainPermits memory chainPermits) internal {\n        uint256 permitsLength = chainPermits.permits.length;\n        for (uint256 i = 0; i < permitsLength; i++) {\n            AllowanceOrTransfer memory p = chainPermits.permits[i];\n\n            if (p.modeOrExpiration == uint48(PermitType.Transfer)) {\n                _transferFrom(owner, p.account, p.amountDelta, p.token);\n            } else {\n                _processAllowanceOperation(owner, timestamp, p);\n            }\n        }\n    }\n\n    /**\n     * @dev Processes allowance-related operations for a single permit\n     * @param owner Token owner authorizing the operation\n     * @param timestamp Current timestamp for validation\n     * @param p The permit operation to process\n     */\n    function _processAllowanceOperation(address owner, uint48 timestamp, AllowanceOrTransfer memory p) private {\n        if (p.token == address(0)) {\n            revert ZeroToken();\n        }\n        if (p.account == address(0)) {\n            revert ZeroAccount();\n        }\n\n        Allowance memory allowed = allowances[owner][p.token][p.account];\n\n        // Validate lock status before processing\n        _validateLockStatus(owner, p, allowed, p.modeOrExpiration, timestamp);\n\n        // Process the operation based on its type\n        if (p.modeOrExpiration == uint48(PermitType.Decrease)) {\n            _decreaseAllowance(allowed, p.amountDelta);\n        } else if (p.modeOrExpiration == uint48(PermitType.Lock)) {\n            _lockAllowance(allowed, timestamp);\n        } else if (p.modeOrExpiration == uint48(PermitType.Unlock)) {\n            _unlockAllowance(allowed);\n        } else {\n            _processIncreaseOrUpdate(allowed, p, timestamp);\n        }\n\n        emit Permit(owner, p.token, p.account, allowed.amount, allowed.expiration, timestamp);\n        allowances[owner][p.token][p.account] = allowed;\n    }\n\n    /**\n     * @dev Validates if an operation can proceed based on lock status\n     * @param owner Token owner\n     * @param p Permit operation being processed\n     * @param allowed Current allowance state\n     * @param operationType Type of operation being performed\n     * @param timestamp Current timestamp\n     */\n    function _validateLockStatus(\n        address owner,\n        AllowanceOrTransfer memory p,\n        Allowance memory allowed,\n        uint48 operationType,\n        uint48 timestamp\n    ) private pure {\n        if (allowed.expiration == LOCKED_ALLOWANCE) {\n            if (operationType == uint48(PermitType.Unlock)) {\n                // Only allow unlock if timestamp is newer than lock timestamp\n                if (timestamp <= allowed.timestamp) {\n                    revert AllowanceLocked(owner, p.token, p.account);\n                }\n            } else {\n                // For all other operations, reject if allowance is locked\n                revert AllowanceLocked(owner, p.token, p.account);\n            }\n        }\n    }\n\n    /**\n     * @dev Decreases an allowance, handling MAX_ALLOWANCE cases\n     * @param allowed Current allowance to modify\n     * @param amountDelta Amount to decrease by\n     */\n    function _decreaseAllowance(Allowance memory allowed, uint160 amountDelta) private pure {\n        if (allowed.amount != MAX_ALLOWANCE || amountDelta == MAX_ALLOWANCE) {\n            allowed.amount = amountDelta > allowed.amount ? 0 : allowed.amount - amountDelta;\n        }\n    }\n\n    /**\n     * @dev Locks an allowance to prevent further usage\n     * @param allowed Allowance to lock\n     * @param timestamp Current timestamp for lock tracking\n     */\n    function _lockAllowance(Allowance memory allowed, uint48 timestamp) private pure {\n        allowed.amount = 0;\n        allowed.expiration = LOCKED_ALLOWANCE;\n        allowed.timestamp = timestamp;\n    }\n\n    /**\n     * @dev Unlocks a previously locked allowance\n     * @param allowed Allowance to unlock\n     */\n    function _unlockAllowance(\n        Allowance memory allowed\n    ) private pure {\n        if (allowed.expiration == LOCKED_ALLOWANCE) {\n            allowed.expiration = 0;\n        }\n    }\n\n    /**\n     * @dev Processes increase operations and updates expiration/timestamp\n     * @param allowed Current allowance to modify\n     * @param p Permit operation containing new values\n     * @param timestamp Current timestamp\n     */\n    function _processIncreaseOrUpdate(\n        Allowance memory allowed,\n        AllowanceOrTransfer memory p,\n        uint48 timestamp\n    ) private pure {\n        // Handle amount increase if specified\n        if (p.amountDelta > 0) {\n            _increaseAllowanceAmount(allowed, p.amountDelta);\n        }\n\n        // Update expiration and timestamp based on precedence rules\n        _updateExpirationAndTimestamp(allowed, p.modeOrExpiration, timestamp);\n    }\n\n    /**\n     * @dev Increases allowance amount, handling MAX_ALLOWANCE cases\n     * @param allowed Allowance to modify\n     * @param amountDelta Amount to increase by\n     */\n    function _increaseAllowanceAmount(Allowance memory allowed, uint160 amountDelta) private pure {\n        if (allowed.amount != MAX_ALLOWANCE) {\n            if (amountDelta == MAX_ALLOWANCE) {\n                allowed.amount = MAX_ALLOWANCE;\n            } else {\n                allowed.amount += amountDelta;\n            }\n        }\n    }\n\n    /**\n     * @dev Updates expiration and timestamp based on precedence rules\n     * @param allowed Allowance to modify\n     * @param newExpiration New expiration value\n     * @param timestamp Current timestamp\n     */\n    function _updateExpirationAndTimestamp(\n        Allowance memory allowed,\n        uint48 newExpiration,\n        uint48 timestamp\n    ) private pure {\n        if (timestamp > allowed.timestamp) {\n            allowed.expiration = newExpiration;\n            allowed.timestamp = timestamp;\n        } else if (timestamp == allowed.timestamp && newExpiration > allowed.expiration) {\n            allowed.expiration = newExpiration;\n        }\n    }\n\n    /**\n     * @dev Validates that a witness type string is properly formatted for EIP-712 compliance\n     * @param witnessTypeString The EIP-712 type string to validate\n     * @notice This function ensures:\n     *         - The string is not empty\n     *         - The string ends with a closing parenthesis ')'\n     * @notice Reverts with InvalidWitnessTypeString() if validation fails\n     */\n    function _validateWitnessTypeString(\n        string calldata witnessTypeString\n    ) internal pure {\n        // Validate minimum length\n        if (bytes(witnessTypeString).length == 0) {\n            revert InvalidWitnessTypeString(witnessTypeString);\n        }\n\n        // Validate proper ending with closing parenthesis\n        uint256 witnessTypeStringLength = bytes(witnessTypeString).length;\n        if (bytes(witnessTypeString)[witnessTypeStringLength - 1] != \")\") {\n            revert InvalidWitnessTypeString(witnessTypeString);\n        }\n    }\n\n    /**\n     * @dev Constructs a complete witness type hash from type string and stub for EIP-712\n     * @param witnessTypeString The EIP-712 witness type string suffix to append\n     * @return The keccak256 hash of the complete type string\n     * @notice Combines PERMIT_WITNESS_TYPEHASH_STUB with the provided witnessTypeString\n     *         to form a complete EIP-712 type definition, then returns its hash\n     */\n    function _getWitnessTypeHash(\n        string calldata witnessTypeString\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PERMIT_WITNESS_TYPEHASH_STUB, witnessTypeString));\n    }\n}\n"
    }
}