{
    "vfp_id": "vfp_00340",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Unchecked state transition may lead to unexpected behavior in setUseLatestDelegate()",
            "description": "The setUseLatestDelegate() function in RocketMegapoolProxy does not validate the state transition, potentially leading to unexpected behavior if called in an invalid context. The root cause is missing preconditions or state checks. An attacker could exploit this by triggering the function at an inappropriate time, possibly disrupting megapool operations. The impact is potential instability in megapool delegation logic.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolProxy.sol#L102-L112"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolProxy.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketMegapoolProxy.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketMegapoolDelegateBaseInterface} from \"../../interface/megapool/RocketMegapoolDelegateBaseInterface.sol\";\nimport {RocketMegapoolProxyInterface} from \"../../interface/megapool/RocketMegapoolProxyInterface.sol\";\nimport {RocketMegapoolStorageLayout} from \"./RocketMegapoolStorageLayout.sol\";\n\n/// @notice Contains the initialisation and delegate upgrade logic for megapools.\n///         All other calls are delegated to the node operator's current delegate or optionally the latest.\ncontract RocketMegapoolProxy is RocketMegapoolProxyInterface, RocketMegapoolStorageLayout {\n    // Events\n    event EtherReceived(address indexed from, uint256 amount, uint256 time);\n    event DelegateUpgraded(address oldDelegate, address newDelegate, uint256 time);\n    event UseLatestUpdated(bool state, uint256 time);\n\n    // Immutables\n    address immutable private self;\n    RocketStorageInterface immutable private rocketStorage;\n\n    // Construct\n    constructor (RocketStorageInterface _rocketStorage) {\n        self = address(this);\n        rocketStorage = _rocketStorage;\n    }\n\n    /// @dev Prevent direct calls to this contract\n    modifier notSelf() {\n        require(address(this) != self);\n        _;\n    }\n\n    /// @dev Only allow access from the owning node address\n    modifier onlyMegapoolOwner() {\n        // Only the node operator can upgrade\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n        require(msg.sender == nodeAddress || msg.sender == withdrawalAddress, \"Only the node operator can access this method\");\n        _;\n    }\n\n    /// @notice Sets up the initial delegate\n    /// @param _nodeAddress The owner of this megapool\n    function initialise(address _nodeAddress) external override notSelf {\n        // Check input\n        require(_nodeAddress != address(0), \"Invalid node address\");\n        require(!storageState, \"Already initialised\");\n        // Flag storage state as initialised and record node address\n        storageState = true;\n        nodeAddress = _nodeAddress;\n        // Set the current delegate (checking it exists)\n        address delegateAddress = getContractAddress(\"rocketMegapoolDelegate\");\n        require(contractExists(delegateAddress), \"Delegate contract does not exist\");\n        rocketMegapoolDelegate = delegateAddress;\n    }\n\n    /// @notice Receive an ETH deposit\n    receive() external payable notSelf {\n        // Emit ether received event\n        emit EtherReceived(msg.sender, msg.value, block.timestamp);\n    }\n\n    /// @notice Delegates all other calls to megapool delegate contract (or latest if flag is set)\n    /// @param _input Transaction calldata that is passed directly to the delegate\n    fallback(bytes calldata _input) external payable notSelf returns (bytes memory) {\n        address delegateContract;\n        // If useLatestDelegate is set, use the latest delegate contract otherwise use stored and check expiry\n        if (useLatestDelegate) {\n            delegateContract = getContractAddress(\"rocketMegapoolDelegate\");\n        } else {\n            require(!getDelegateExpired(), \"Delegate has expired\");\n            delegateContract = rocketMegapoolDelegate;\n        }\n        // Check for contract existence\n        require(contractExists(delegateContract), \"Delegate contract does not exist\");\n        // Execute delegatecall on the delegate contract\n        (bool success, bytes memory data) = delegateContract.delegatecall(_input);\n        if (!success) {\n            revert(getRevertMessage(data));\n        }\n        return data;\n    }\n\n    /// @notice Upgrade this megapool to the latest network delegate contract\n    function delegateUpgrade() public override notSelf {\n        // Only owner can upgrade if delegate hasn't expired\n        if (!getDelegateExpired()) {\n            address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n            require(msg.sender == nodeAddress || msg.sender == withdrawalAddress, \"Only the node operator can access this method\");\n        }\n        // Only succeed if there is a new delegate to upgrade to\n        address oldDelegate = rocketMegapoolDelegate;\n        address newDelegate = getContractAddress(\"rocketMegapoolDelegate\");\n        require(oldDelegate != newDelegate, \"Already using latest\");\n        // Set new delegate\n        rocketMegapoolDelegate = newDelegate;\n        // Log event\n        emit DelegateUpgraded(oldDelegate, newDelegate, block.timestamp);\n    }\n\n    /// @notice Sets the flag to automatically use the latest delegate contract or not\n    /// @param _state If true, will always use the latest delegate contract\n    function setUseLatestDelegate(bool _state) external override onlyMegapoolOwner notSelf {\n        useLatestDelegate = _state;\n        emit UseLatestUpdated(_state, block.timestamp);\n        if (!_state) {\n            // Upon disabling use latest, set their current delegate to the latest\n            address newDelegate = getContractAddress(\"rocketMegapoolDelegate\");\n            if (newDelegate != rocketMegapoolDelegate) {\n                delegateUpgrade();\n            }\n        }\n    }\n\n    /// @notice Returns true if this megapool always uses the latest delegate contract\n    function getUseLatestDelegate() external override view returns (bool) {\n        return useLatestDelegate;\n    }\n\n    /// @notice Returns the address of the megapool's stored delegate\n    function getDelegate() external override view returns (address) {\n        return rocketMegapoolDelegate;\n    }\n\n    /// @notice Returns the delegate which will be used when calling this megapool taking into account useLatestDelegate setting\n    function getEffectiveDelegate() external override view returns (address) {\n        return useLatestDelegate ? getContractAddress(\"rocketMegapoolDelegate\") : rocketMegapoolDelegate;\n    }\n\n    /// @notice Returns true if the megapools current delegate has expired\n    function getDelegateExpired() public view returns (bool) {\n        RocketMegapoolDelegateBaseInterface megapoolDelegate = RocketMegapoolDelegateBaseInterface(rocketMegapoolDelegate);\n        uint256 expiry = megapoolDelegate.getExpirationBlock();\n        return expiry != 0 && block.number >= expiry;\n    }\n\n    /// @dev Get the address of a Rocket Pool network contract\n    function getContractAddress(string memory _contractName) private view returns (address) {\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        require(contractAddress != address(0x0), \"Contract not found\");\n        return contractAddress;\n    }\n\n    /// @dev Get a revert message from delegatecall return data\n    function getRevertMessage(bytes memory _returnData) private pure returns (string memory) {\n        if (_returnData.length < 68) {\n            return \"Transaction reverted silently\";\n        }\n        assembly {\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string));\n    }\n\n    /// @dev Returns true if contract exists at _contractAddress (if called during that contract's construction it will return a false negative)\n    function contractExists(address _contractAddress) private view returns (bool) {\n        uint32 codeSize;\n        assembly {\n            codeSize := extcodesize(_contractAddress)\n        }\n        return codeSize > 0;\n    }\n\n}\n"
    }
}