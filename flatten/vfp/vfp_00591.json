{
    "vfp_id": "vfp_00591",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused Imports",
            "description": "Some imported symbols are never used in the contract, which adds unnecessary clutter and can confuse developers. The cause is leftover imports from prior development stages. While not a security risk, this reduces code clarity and may lead to confusion about dependencies. The impact is reduced maintainability and readability.\n",
            "severity": null,
            "location": [
                "ETHPriceOracle.sol::ITwapOracle#10",
                "LSDPriceOracleBase.sol::ITwapOracle#10"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/ETHPriceOracle.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Pools Can Be Subject to Price Manipulation Leading to Early Liquidations or Arbitrage",
            "description": "The protocol's price oracle uses a combination of Chainlink's `anchorPrice` and spot prices from multiple on-chain DEX pools to derive `minPrice` and `maxPrice`. These are used in critical operations such as liquidation and redemption. However, the system allows manipulation if any single pool's spot price deviates by exactly 1% from the `anchorPrice`, at which point it bypasses the deviation check and is accepted. An attacker can manipulate a low-TLV pool (e.g., WETH/USDC Uniswap V2) to force `minPrice` down, triggering premature liquidations for profit, or manipulate `maxPrice` to create arbitrage during redemption. The root cause is the aggregation logic that collapses multiple spot prices into a single `minPrice` and `maxPrice`, making the system vulnerable to a single point of failure. This negates the intended resilience from diversification. The impact includes potential loss of user funds due to forced liquidations and unfair arbitrage, undermining the protocol's economic security.\n",
            "severity": "Medium",
            "location": [
                "LSDPriceOracleBase.sol::getPrice#85-99",
                "StETHPriceOracle.sol::getPrice#36-43",
                "BasePool.sol::operate#92",
                "BasePool.sol::rebalance#250",
                "BasePool.sol::liquidate#388",
                "BasePool.sol::redeem#196"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/LSDPriceOracleBase.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Minimum Price Deviation Is Calculated Incorrectly in Price Oracles",
            "description": "The `getPrice` functions in multiple oracle contracts (ETHPriceOracle, LSDPriceOracleBase, BTCDerivativeOracleBase) incorrectly calculate the minimum price deviation using `(anchorPrice - minPrice) / minPrice > maxDeviation`, which compares the deviation relative to `minPrice` instead of `anchorPrice`. The correct formula should be `(anchorPrice - minPrice) / anchorPrice > maxDeviation` to ensure consistent deviation thresholds. The root cause is a mathematical error in the comparison logic. This leads to overly restrictive checks that may incorrectly reset valid prices, reducing price accuracy. The impact is reduced responsiveness to real market movements and potential missed liquidations or incorrect pricing, affecting protocol stability.\n",
            "severity": "Low",
            "location": [
                "ETHPriceOracle.sol::getPrice#61-74",
                "LSDPriceOracleBase.sol::getPrice#85-99",
                "BTCDerivativeOracleBase.sol::getPrice#58-72",
                "BTCDerivativeOracleBase.sol::getExchangePrice#58-72"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/ETHPriceOracle.sol",
                "fx-protocol-contracts/contracts/price-oracle/LSDPriceOracleBase.sol",
                "fx-protocol-contracts/contracts/price-oracle/BTCDerivativeOracleBase.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1286"
                ]
            },
            "title": "Inconsistent Sanity Checks for On-Chain Spot Encodings in Oracle Contracts",
            "description": "The `updateOnchainSpotEncodings` function lacks consistent input validation across different oracle implementations. While `BTCDerivativeOracleBase` checks for non-empty prices, `ETHPriceOracle` does not, and `LSDPriceOracleBase` applies the check only conditionally. This inconsistency allows potentially empty or malformed data to be set in critical price oracle contracts. The root cause is the absence of a uniform validation standard across inherited or similarly structured contracts. An attacker could exploit this by submitting empty data arrays, causing downstream read functions to revert or return invalid prices. This could disrupt protocol operations, lead to incorrect pricing, or trigger unintended behavior in dependent systems.\n",
            "severity": null,
            "location": [
                "BTCDerivativeOracleBase.sol::updateOnchainSpotEncodings#111",
                "ETHPriceOracle.sol::updateOnchainSpotEncodings#108-110",
                "LSDPriceOracleBase.sol::updateOnchainSpotEncodings#131"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/BTCDerivativeOracleBase.sol",
                "fx-protocol-contracts/contracts/price-oracle/ETHPriceOracle.sol",
                "fx-protocol-contracts/contracts/price-oracle/LSDPriceOracleBase.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Incomplete Docstrings",
            "description": "Several functions have partial NatSpec documentation where parameters or return values are not fully described. For example, the `isRedeem` parameter in `getBTCDerivativeUSDAnchorPrice`, and `collateralCapacity`/`debtCapacity` in `registerPool` are undocumented. The cause is incomplete documentation efforts. This reduces the usefulness of the existing docstrings and can mislead developers about the function's behavior or required inputs. The impact is increased risk of incorrect function usage, integration bugs, and longer onboarding time for new developers, potentially leading to operational errors or security issues due to misunderstood parameters.\n",
            "severity": null,
            "location": [
                "BTCDerivativeOracleBase.sol::getBTCDerivativeUSDAnchorPrice#52-54",
                "PoolManager.sol::registerPool#515-529",
                "ReservePool.sol::withdrawFund#94-96"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/BTCDerivativeOracleBase.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect or Inaccurate Comments",
            "description": "Several code comments do not match the actual implementation. For example, the comment stating the price validity condition uses `< maxPriceDeviation` while the code uses `< 2 * maxPriceDeviation`. Additionally, a comment in `LSDPriceOracleBase` incorrectly refers to LSD/ETH instead of LSD/USD. The cause is outdated or incorrect documentation. These inaccuracies can mislead developers and auditors into believing the logic is different from what it actually is. The impact includes potential logic errors during maintenance, incorrect security assumptions, and increased risk of introducing bugs when modifying the code based on false premises.\n",
            "severity": null,
            "location": [
                "BTCDerivativeOracleBase.sol#57",
                "ETHPriceOracle.sol#60",
                "LSDPriceOracleBase.sol#71"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/BTCDerivativeOracleBase.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Prefix Increment Operator (`++i`) Can Save Gas in Loops",
            "description": "The use of postfix increment (`i++`) in loops results in storing the original value before incrementing, which is unnecessary when the return value is unused. The cause is suboptimal loop iteration practices. This leads to higher gas consumption during loop execution. The impact is increased transaction costs, especially in loops with many iterations, though there is no direct security vulnerability.\n",
            "severity": null,
            "location": [
                "BTCDerivativeOracleBase.sol#150",
                "ETHPriceOracle.sol#137",
                "FxUSDRegeneracy.sol#193",
                "LSDPriceOracleBase.sol#170",
                "SpotPriceOracleBase.sol#88"
            ],
            "files": [
                "fx-protocol-contracts/contracts/price-oracle/BTCDerivativeOracleBase.sol"
            ]
        }
    ],
    "affected_files": {
        "BTCDerivativeOracleBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Math } from \"@openzeppelin/contracts-v4/utils/math/Math.sol\";\n\nimport { SpotPriceOracleBase } from \"./SpotPriceOracleBase.sol\";\n\nimport { IPriceOracle } from \"./interfaces/IPriceOracle.sol\";\n\nabstract contract BTCDerivativeOracleBase is SpotPriceOracleBase, IPriceOracle {\n  /*************\n   * Constants *\n   *************/\n\n  /// @notice The Chainlink BTC/USD price feed.\n  /// @dev See comments of `_readSpotPriceByChainlink` for more details.\n  bytes32 public immutable Chainlink_BTC_USD_Spot;\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @dev The encodings for BTCDerivative/USD spot sources.\n  bytes private onchainSpotEncodings_BTCDerivativeUSD;\n\n  /// @notice The value of maximum price deviation, multiplied by 1e18.\n  uint256 public maxPriceDeviation;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(bytes32 _Chainlink_BTC_USD_Spot) {\n    Chainlink_BTC_USD_Spot = _Chainlink_BTC_USD_Spot;\n\n    _updateMaxPriceDeviation(1e16); // 1%\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Return the BTCDerivative/USD spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getBTCDerivativeUSDSpotPrices() public view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_BTCDerivativeUSD);\n  }\n\n  /// @notice Return the BTCDerivative/USD anchor price, the price that is hard to manipulate in single tx.\n  /// @return price The anchor price, multiplied by 1e18.\n  function getBTCDerivativeUSDAnchorPrice(bool isRedeem) external view returns (uint256 price) {\n    price = _getBTCDerivativeUSDAnchorPrice(isRedeem);\n  }\n\n  /// @inheritdoc IPriceOracle\n  /// @dev The price is valid iff |maxPrice-minPrice|/minPrice < maxPriceDeviation\n  function getPrice() external view override returns (uint256 anchorPrice, uint256 minPrice, uint256 maxPrice) {\n    anchorPrice = _getBTCDerivativeUSDAnchorPrice(false);\n    (minPrice, maxPrice) = _getBTCDerivativeMinMaxPrice(anchorPrice);\n\n    uint256 cachedMaxPriceDeviation = maxPriceDeviation; // gas saving\n    // use anchor price when the price deviation between anchor price and min price exceed threshold\n    if ((anchorPrice - minPrice) * PRECISION > cachedMaxPriceDeviation * minPrice) {\n      minPrice = anchorPrice;\n    }\n\n    // use anchor price when the price deviation between anchor price and max price exceed threshold\n    if ((maxPrice - anchorPrice) * PRECISION > cachedMaxPriceDeviation * anchorPrice) {\n      maxPrice = anchorPrice;\n    }\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getExchangePrice() public view returns (uint256) {\n    uint256 anchorPrice = _getBTCDerivativeUSDAnchorPrice(false);\n    (uint256 minPrice, ) = _getBTCDerivativeMinMaxPrice(anchorPrice);\n    // use anchor price when the price deviation between anchor price and min price exceed threshold\n    if ((anchorPrice - minPrice) * PRECISION > maxPriceDeviation * minPrice) {\n      minPrice = anchorPrice;\n    }\n    return minPrice;\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getLiquidatePrice() external view returns (uint256) {\n    return getExchangePrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getRedeemPrice() external view returns (uint256) {\n    uint256 anchorPrice = _getBTCDerivativeUSDAnchorPrice(true);\n    (, uint256 maxPrice) = _getBTCDerivativeMinMaxPrice(anchorPrice);\n\n    // use anchor price when the price deviation between anchor price and max price exceed threshold\n    if ((maxPrice - anchorPrice) * PRECISION > maxPriceDeviation * anchorPrice) {\n      maxPrice = anchorPrice;\n    }\n    return maxPrice;\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the on-chain spot encodings.\n  /// @param encodings The encodings to update. See `_getSpotPriceByEncoding` for more details.\n  function updateOnchainSpotEncodings(bytes memory encodings) external onlyOwner {\n    // validate encoding\n    uint256[] memory prices = _getSpotPriceByEncoding(encodings);\n    if (prices.length == 0) revert();\n\n    onchainSpotEncodings_BTCDerivativeUSD = encodings;\n  }\n\n  /// @notice Update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function updateMaxPriceDeviation(uint256 newMaxPriceDeviation) external onlyOwner {\n    _updateMaxPriceDeviation(newMaxPriceDeviation);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function _updateMaxPriceDeviation(uint256 newMaxPriceDeviation) private {\n    uint256 oldMaxPriceDeviation = maxPriceDeviation;\n    if (oldMaxPriceDeviation == newMaxPriceDeviation) {\n      revert ErrorParameterUnchanged();\n    }\n\n    maxPriceDeviation = newMaxPriceDeviation;\n\n    emit UpdateMaxPriceDeviation(oldMaxPriceDeviation, newMaxPriceDeviation);\n  }\n\n  /// @dev Internal function to return the min/max BTCDerivative/USD prices.\n  /// @param anchorPrice The BTCDerivative/USD anchor price, multiplied by 1e18.\n  /// @return minPrice The minimum price among all available sources (including anchor price), multiplied by 1e18.\n  /// @return maxPrice The maximum price among all available sources (including anchor price), multiplied by 1e18.\n  function _getBTCDerivativeMinMaxPrice(\n    uint256 anchorPrice\n  ) internal view returns (uint256 minPrice, uint256 maxPrice) {\n    minPrice = maxPrice = anchorPrice;\n    uint256[] memory BTCDerivative_USD_prices = getBTCDerivativeUSDSpotPrices();\n\n    uint256 length = BTCDerivative_USD_prices.length;\n    for (uint256 i = 0; i < length; i++) {\n      uint256 price = BTCDerivative_USD_prices[i];\n      if (price > maxPrice) maxPrice = price;\n      if (price < minPrice) minPrice = price;\n    }\n  }\n\n  /// @dev Internal function to return the BTCDerivative/USD anchor price.\n  /// @return price The anchor price of BTCDerivative/USD, multiplied by 1e18.\n  function _getBTCDerivativeUSDAnchorPrice(bool isRedeem) internal view virtual returns (uint256 price);\n}\n",
        "ETHPriceOracle.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { SpotPriceOracleBase } from \"./SpotPriceOracleBase.sol\";\n\nimport { IPriceOracle } from \"./interfaces/IPriceOracle.sol\";\nimport { ITwapOracle } from \"./interfaces/ITwapOracle.sol\";\n\ncontract ETHPriceOracle is SpotPriceOracleBase, IPriceOracle {\n  /*************\n   * Constants *\n   *************/\n\n  /// @notice The Chainlink ETH/USD price feed.\n  /// @dev See comments of `_readSpotPriceByChainlink` for more details.\n  bytes32 public immutable Chainlink_ETH_USD_Spot;\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @dev The encodings for ETH/USD spot sources.\n  bytes private onchainSpotEncodings_ETHUSD;\n\n  /// @notice The value of maximum price deviation, multiplied by 1e18.\n  uint256 public maxPriceDeviation;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address _spotPriceOracle, bytes32 _Chainlink_ETH_USD_Spot) SpotPriceOracleBase(_spotPriceOracle) {\n    Chainlink_ETH_USD_Spot = _Chainlink_ETH_USD_Spot;\n\n    _updateMaxPriceDeviation(1e16); // 1%\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Return the ETH/USD spot price.\n  /// @return chainlinkPrice The spot price from Chainlink price feed.\n  /// @return minPrice The minimum spot price among all available sources.\n  /// @return maxPrice The maximum spot price among all available sources.\n  function getETHUSDSpotPrice() external view returns (uint256 chainlinkPrice, uint256 minPrice, uint256 maxPrice) {\n    (chainlinkPrice, minPrice, maxPrice) = _getETHUSDSpotPrice();\n  }\n\n  /// @notice Return the ETH/USD spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getETHUSDSpotPrices() external view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_ETHUSD);\n  }\n\n  /// @inheritdoc IPriceOracle\n  /// @dev The price is valid iff |maxPrice-minPrice|/minPrice < maxPriceDeviation\n  function getPrice() public view override returns (uint256 anchorPrice, uint256 minPrice, uint256 maxPrice) {\n    (anchorPrice, minPrice, maxPrice) = _getETHUSDSpotPrice();\n\n    uint256 cachedMaxPriceDeviation = maxPriceDeviation; // gas saving\n    // use anchor price when the price deviation between anchor price and min price exceed threshold\n    if ((anchorPrice - minPrice) * PRECISION > cachedMaxPriceDeviation * minPrice) {\n      minPrice = anchorPrice;\n    }\n\n    // use anchor price when the price deviation between anchor price and max price exceed threshold\n    if ((maxPrice - anchorPrice) * PRECISION > cachedMaxPriceDeviation * anchorPrice) {\n      maxPrice = anchorPrice;\n    }\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getExchangePrice() public view returns (uint256) {\n    (, uint256 price, ) = getPrice();\n    return price;\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getLiquidatePrice() external view returns (uint256) {\n    return getExchangePrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getRedeemPrice() external view returns (uint256) {\n    (, , uint256 price) = getPrice();\n    return price;\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the on-chain spot encodings.\n  /// @param encodings The encodings to update. See `_getSpotPriceByEncoding` for more details.\n  function updateOnchainSpotEncodings(bytes memory encodings) external onlyOwner {\n    // validate encoding\n    _getSpotPriceByEncoding(encodings);\n\n    onchainSpotEncodings_ETHUSD = encodings;\n  }\n\n  /// @notice Update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function updateMaxPriceDeviation(uint256 newMaxPriceDeviation) external onlyOwner {\n    _updateMaxPriceDeviation(newMaxPriceDeviation);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function _updateMaxPriceDeviation(uint256 newMaxPriceDeviation) private {\n    uint256 oldMaxPriceDeviation = maxPriceDeviation;\n    if (oldMaxPriceDeviation == newMaxPriceDeviation) {\n      revert ErrorParameterUnchanged();\n    }\n\n    maxPriceDeviation = newMaxPriceDeviation;\n\n    emit UpdateMaxPriceDeviation(oldMaxPriceDeviation, newMaxPriceDeviation);\n  }\n\n  /// @dev Internal function to calculate the ETH/USD spot price.\n  /// @return chainlinkPrice The spot price from Chainlink price feed, multiplied by 1e18.\n  /// @return minPrice The minimum spot price among all available sources, multiplied by 1e18.\n  /// @return maxPrice The maximum spot price among all available sources, multiplied by 1e18.\n  function _getETHUSDSpotPrice() internal view returns (uint256 chainlinkPrice, uint256 minPrice, uint256 maxPrice) {\n    chainlinkPrice = _readSpotPriceByChainlink(Chainlink_ETH_USD_Spot);\n    uint256[] memory prices = _getSpotPriceByEncoding(onchainSpotEncodings_ETHUSD);\n    minPrice = maxPrice = chainlinkPrice;\n    for (uint256 i = 0; i < prices.length; i++) {\n      if (prices[i] > maxPrice) maxPrice = prices[i];\n      if (prices[i] < minPrice) minPrice = prices[i];\n    }\n  }\n}\n",
        "LSDPriceOracleBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { SpotPriceOracleBase } from \"./SpotPriceOracleBase.sol\";\n\nimport { IPriceOracle } from \"./interfaces/IPriceOracle.sol\";\nimport { ITwapOracle } from \"./interfaces/ITwapOracle.sol\";\n\nabstract contract LSDPriceOracleBase is SpotPriceOracleBase, IPriceOracle {\n  /*************\n   * Constants *\n   *************/\n\n  /// @notice The Chainlink ETH/USD price feed.\n  /// @dev See comments of `_readSpotPriceByChainlink` for more details.\n  bytes32 public immutable Chainlink_ETH_USD_Spot;\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @dev The encodings for ETH/USD spot sources.\n  bytes private onchainSpotEncodings_ETHUSD;\n\n  /// @dev The encodings for LSD/ETH spot sources.\n  bytes private onchainSpotEncodings_LSDETH;\n\n  /// @dev The encodings for LSD/USD spot sources.\n  bytes private onchainSpotEncodings_LSDUSD;\n\n  /// @notice The value of maximum price deviation, multiplied by 1e18.\n  uint256 public maxPriceDeviation;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(bytes32 _Chainlink_ETH_USD_Spot) {\n    Chainlink_ETH_USD_Spot = _Chainlink_ETH_USD_Spot;\n\n    _updateMaxPriceDeviation(1e16); // 1%\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Return the ETH/USD spot price.\n  /// @return chainlinkPrice The spot price from Chainlink price feed.\n  /// @return minPrice The minimum spot price among all available sources.\n  /// @return maxPrice The maximum spot price among all available sources.\n  function getETHUSDSpotPrice() external view returns (uint256 chainlinkPrice, uint256 minPrice, uint256 maxPrice) {\n    (chainlinkPrice, minPrice, maxPrice) = _getETHUSDSpotPrice();\n  }\n\n  /// @notice Return the ETH/USD spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getETHUSDSpotPrices() external view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_ETHUSD);\n  }\n\n  /// @notice Return the LSD/ETH spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getLSDETHSpotPrices() public view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_LSDETH);\n  }\n\n  /// @notice Return the LSD/ETH spot prices.\n  /// @return prices The list of spot price among all available sources, multiplied by 1e18.\n  function getLSDUSDSpotPrices() public view returns (uint256[] memory prices) {\n    prices = _getSpotPriceByEncoding(onchainSpotEncodings_LSDUSD);\n  }\n\n  /// @notice Return the LSD/USD anchor price, the price that is hard to manipulate in single tx.\n  /// @return price The anchor price, multiplied by 1e18.\n  function getLSDUSDAnchorPrice() external view returns (uint256 price) {\n    price = _getLSDUSDAnchorPrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  /// @dev The price is valid iff |maxPrice-minPrice|/minPrice < maxPriceDeviation\n  function getPrice() public view override returns (uint256 anchorPrice, uint256 minPrice, uint256 maxPrice) {\n    anchorPrice = _getLSDUSDAnchorPrice();\n    (minPrice, maxPrice) = _getLSDMinMaxPrice(anchorPrice);\n\n    uint256 cachedMaxPriceDeviation = maxPriceDeviation; // gas saving\n    // use anchor price when the price deviation between anchor price and min price exceed threshold\n    if ((anchorPrice - minPrice) * PRECISION > cachedMaxPriceDeviation * minPrice) {\n      minPrice = anchorPrice;\n    }\n\n    // use anchor price when the price deviation between anchor price and max price exceed threshold\n    if ((maxPrice - anchorPrice) * PRECISION > cachedMaxPriceDeviation * anchorPrice) {\n      maxPrice = anchorPrice;\n    }\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getExchangePrice() public view returns (uint256) {\n    (, uint256 price, ) = getPrice();\n    return price;\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getLiquidatePrice() external view returns (uint256) {\n    return getExchangePrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getRedeemPrice() external view returns (uint256) {\n    (, , uint256 price) = getPrice();\n    return price;\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the on-chain spot encodings.\n  /// @param encodings The encodings to update. See `_getSpotPriceByEncoding` for more details.\n  /// @param spotType The type of the encodings.\n  function updateOnchainSpotEncodings(bytes memory encodings, uint256 spotType) external onlyOwner {\n    // validate encoding\n    uint256[] memory prices = _getSpotPriceByEncoding(encodings);\n\n    if (spotType == 0) {\n      onchainSpotEncodings_ETHUSD = encodings;\n      if (prices.length == 0) revert ErrorInvalidEncodings();\n    } else if (spotType == 1) {\n      onchainSpotEncodings_LSDETH = encodings;\n    } else if (spotType == 2) {\n      onchainSpotEncodings_LSDUSD = encodings;\n    }\n  }\n\n  /// @notice Update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function updateMaxPriceDeviation(uint256 newMaxPriceDeviation) external onlyOwner {\n    _updateMaxPriceDeviation(newMaxPriceDeviation);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update the value of maximum price deviation.\n  /// @param newMaxPriceDeviation The new value of maximum price deviation, multiplied by 1e18.\n  function _updateMaxPriceDeviation(uint256 newMaxPriceDeviation) private {\n    uint256 oldMaxPriceDeviation = maxPriceDeviation;\n    if (oldMaxPriceDeviation == newMaxPriceDeviation) {\n      revert ErrorParameterUnchanged();\n    }\n\n    maxPriceDeviation = newMaxPriceDeviation;\n\n    emit UpdateMaxPriceDeviation(oldMaxPriceDeviation, newMaxPriceDeviation);\n  }\n\n  /// @dev Internal function to calculate the ETH/USD spot price.\n  /// @return chainlinkPrice The spot price from Chainlink price feed, multiplied by 1e18.\n  /// @return minPrice The minimum spot price among all available sources, multiplied by 1e18.\n  /// @return maxPrice The maximum spot price among all available sources, multiplied by 1e18.\n  function _getETHUSDSpotPrice() internal view returns (uint256 chainlinkPrice, uint256 minPrice, uint256 maxPrice) {\n    chainlinkPrice = _readSpotPriceByChainlink(Chainlink_ETH_USD_Spot);\n    uint256[] memory prices = _getSpotPriceByEncoding(onchainSpotEncodings_ETHUSD);\n    minPrice = maxPrice = chainlinkPrice;\n    for (uint256 i = 0; i < prices.length; i++) {\n      if (prices[i] > maxPrice) maxPrice = prices[i];\n      if (prices[i] < minPrice) minPrice = prices[i];\n    }\n  }\n\n  /// @dev Internal function to return the min/max LSD/USD prices.\n  /// @param anchorPrice The LSD/USD anchor price, multiplied by 1e18.\n  /// @return minPrice The minimum price among all available sources (including twap), multiplied by 1e18.\n  /// @return maxPrice The maximum price among all available sources (including twap), multiplied by 1e18.\n  function _getLSDMinMaxPrice(uint256 anchorPrice) internal view returns (uint256 minPrice, uint256 maxPrice) {\n    minPrice = maxPrice = anchorPrice;\n    (, uint256 minETHUSDPrice, uint256 maxETHUSDPrice) = _getETHUSDSpotPrice();\n    uint256[] memory LSD_ETH_prices = getLSDETHSpotPrices();\n    uint256[] memory LSD_USD_prices = getLSDUSDSpotPrices();\n\n    uint256 length = LSD_ETH_prices.length;\n    uint256 LSD_ETH_minPrice = type(uint256).max;\n    uint256 LSD_ETH_maxPrice;\n    unchecked {\n      for (uint256 i = 0; i < length; i++) {\n        uint256 price = LSD_ETH_prices[i];\n        if (price > LSD_ETH_maxPrice) LSD_ETH_maxPrice = price;\n        if (price < LSD_ETH_minPrice) LSD_ETH_minPrice = price;\n      }\n      if (LSD_ETH_maxPrice != 0) {\n        minPrice = Math.min(minPrice, (LSD_ETH_minPrice * minETHUSDPrice) / PRECISION);\n        maxPrice = Math.max(maxPrice, (LSD_ETH_maxPrice * maxETHUSDPrice) / PRECISION);\n      }\n\n      length = LSD_USD_prices.length;\n      for (uint256 i = 0; i < length; i++) {\n        uint256 price = LSD_USD_prices[i];\n        if (price > maxPrice) maxPrice = price;\n        if (price < minPrice) minPrice = price;\n      }\n    }\n  }\n\n  /// @dev Internal function to return the LSD/USD anchor price.\n  /// @return price The anchor price of LSD/USD, multiplied by 1e18.\n  function _getLSDUSDAnchorPrice() internal view virtual returns (uint256 price);\n}\n"
    }
}