{
    "vfp_id": "vfp_00276",
    "project_name": "Ozean Finance Security Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "USDC Depeg Risk in USDX Bridge",
            "description": "The bridge function in the USDXBridge contract does not have a pause mechanism, exposing it to instant arbitrage risks if USDC or other bridged assets lose their peg. The cause is the absence of emergency controls to halt operations during market instability. An attacker could exploit price discrepancies during a depeg event to drain value from the system or destabilize USDX's market price. The impact is potential loss of user confidence, market depreciation of USDX, and financial losses for liquidity providers or users relying on stable 1:1 conversions.\n",
            "severity": "Medium",
            "location": [
                "USDXBridge.sol::bridge"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/USDXBridge.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Absence of a USDX to Stablecoin Exchange Mechanism",
            "description": "The USDXBridge contract does not provide a direct mechanism for users to exchange USDX back to deposited stablecoins. This is due to the design choice of relying on off-chain KYC processes for redemptions. Users who do not wish to complete KYC are unable to redeem their tokens, limiting usability. The impact is reduced user autonomy and potential liquidity issues if USDX lacks market trading pairs. While not a security risk, it affects user experience and accessibility.\n",
            "severity": "Low",
            "location": [
                "USDXBridge.sol"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/USDXBridge.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Lack of Fee-on-Transfer Tokens Check",
            "description": "The bridge function in USDXBridge.sol does not account for fee-on-transfer tokens like USDT, which may deduct fees upon transfer. The cause is the assumption of exact token amounts received without post-transfer balance checks. If a fee-on-transfer token activates its fee mechanism, the bridge would mint USDX at a 1:1 ratio based on the pre-fee amount, leading to over-minting. The impact is potential imbalance in backing reserves and inflationary pressure on USDX supply, though currently low risk as major tokens have fees disabled.\n",
            "severity": "Low",
            "location": [
                "USDXBridge.sol::bridge#109-134"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/USDXBridge.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Inefficient Implementation of the stETH Integration",
            "description": "The depositETH() function in LGEStaking.sol stakes ETH to stETH and then wraps it to wstETH, which is inefficient. The root cause is using two steps when the wstETH contract supports direct ETH deposits. While functional, this approach increases complexity and gas usage unnecessarily. There is no direct exploit, but it represents a suboptimal design. The impact is higher gas costs and reduced efficiency, though security is unaffected.\n",
            "severity": "Low",
            "location": [
                "LGEStaking.sol::depositETH"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEStaking.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "_l2Destination in the migrate Function",
            "description": "The migrate function in LGEStaking contract does not validate the _l2Destination parameter, allowing potentially dangerous addresses like ozUSD or wozUSD on L2 to be set as recipients. Although not currently exploitable, this could lead to fund loss if tokens are sent to non-recoverable contract addresses in the future. The cause is missing input validation for destination addresses. The impact is a future risk to system integrity and asset safety if the destination is a contract that cannot return tokens.\n",
            "severity": "Low",
            "location": [
                "LGEStaking.sol::migrate",
                "LGEMigrationV1.sol#80"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEStaking.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused Import",
            "description": "The ISemver interface is imported in LGEStaking.sol but never used. This is a code hygiene issue caused by leftover imports from development. It has no security impact but reduces code clarity and increases bytecode size slightly. The impact is purely maintenance-related, making the codebase harder to audit and understand.\n",
            "severity": "Low",
            "location": [
                "LGEStaking.sol#9"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEStaking.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typographical Errors in Comments",
            "description": "There are typographical errors in comments, such as \"deposted\" instead of \"deposited\" in LGEStaking.sol and \"Statked\" instead of \"Staked\" in LGEMigrationV1.sol. These are documentation issues that do not affect code execution but reduce readability and professionalism. The impact is minimal, limited to confusion during code review or onboarding of new developers.\n",
            "severity": "Low",
            "location": [
                "LGEStaking.sol#37",
                "LGEMigrationV1.sol#31"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEStaking.sol",
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEMigrationV1.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Zero Address Checks in Constructor",
            "description": "The constructor of LGEMigrationV1.sol does not validate that critical parameters (_owner, _l1StandardBridge, etc.) are non-zero addresses. This could lead to misconfiguration and contract lockups if deployed with invalid inputs. The cause is missing require checks in the constructor. The impact is operational risk and potential redeployment costs, though mitigated by deploy script validations.\n",
            "severity": "Low",
            "location": [
                "LGEMigrationV1.sol::constructor"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEMigrationV1.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Inefficient Inequality Operator in Deposit Check",
            "description": "The deposit check in LGEStaking.sol uses a strict < comparison instead of <= when enforcing deposit caps. This prevents users from depositing up to the exact cap amount. The cause is incorrect operator usage in require statements. The impact is minor, limiting full utilization of allowed deposits, but does not break core functionality.\n",
            "severity": "Low",
            "location": [
                "LGEStaking.sol#106",
                "LGEStaking.sol#128",
                "USDXBridge.sol#115"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEStaking.sol",
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/USDXBridge.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing Zero Address and Duplicate Checks in LGEStaking Constructor",
            "description": "The constructor of LGEStaking.sol lacks validation for _owner and _wstETH being non-zero, and does not check for duplicate tokens in the _tokens array. This could lead to misconfiguration or logical errors if duplicates are present. The cause is insufficient input validation. The impact is low, as deployment scripts include checks, but introduces risk if bypassed.\n",
            "severity": "Low",
            "location": [
                "LGEStaking.sol#72-93"
            ],
            "files": [
                "dacd9ed9c895c9b6be422531eea15fecc3c2b1d8/Ozean-Contracts/src/L1/LGEStaking.sol"
            ]
        }
    ],
    "affected_files": {
        "LGEMigrationV1.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Ownable} from \"openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ILGEMigration} from \"./interface/ILGEMigration.sol\";\n\n/// @title  LGE Migration V1\n/// @notice This contract facilitates the migration of staked tokens from the LGE Staking pool\n///         on Layer 1 to the Ozean Layer 2.\ncontract LGEMigrationV1 is Ownable, ILGEMigration, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice The standard bridge contract for Layer 1 to Layer 2 transfers.\n    IL1StandardBridge public immutable l1StandardBridge;\n\n    /// @notice The L1 lido bridge contract.\n    IL1LidoTokensBridge public immutable l1LidoTokensBridge;\n\n    /// @notice The L1 USDX bridge that converts USDC into USDX.\n    IUSDXBridge public immutable usdxBridge;\n\n    /// @notice The address of the LGE Staking contract.\n    address public immutable lgeStaking;\n\n    /// @notice The address of Circle's USDC.\n    address public immutable usdc;\n\n    /// @notice The address of Wrapped Statked Ether.\n    address public immutable wstETH;\n\n    /// @notice A mapping from Layer 1 token addresses to their corresponding Layer 2 addresses.\n    mapping(address => address) public l1ToL2Addresses;\n\n    /// @notice A mapping from Layer 1 token address to the gas limits passed to the bridge contracts.\n    mapping(address => uint32) public gasLimits;\n\n    constructor(\n        address _owner,\n        address _l1StandardBridge,\n        address _l1LidoTokensBridge,\n        address _usdxBridge,\n        address _lgeStaking,\n        address _usdc,\n        address _wstETH,\n        address[] memory _l1Addresses,\n        address[] memory _l2Addresses\n    ) {\n        _transferOwnership(_owner);\n        l1StandardBridge = IL1StandardBridge(_l1StandardBridge);\n        l1LidoTokensBridge = IL1LidoTokensBridge(_l1LidoTokensBridge);\n        usdxBridge = IUSDXBridge(_usdxBridge);\n        lgeStaking = _lgeStaking;\n        usdc = _usdc;\n        wstETH = _wstETH;\n        uint256 length = _l1Addresses.length;\n        require(\n            length == _l2Addresses.length,\n            \"LGE Migration: L1 addresses array length must equal the L2 addresses array length.\"\n        );\n        for (uint256 i; i < length; ++i) {\n            l1ToL2Addresses[_l1Addresses[i]] = _l2Addresses[i];\n            gasLimits[_l1Addresses[i]] = 21000;\n        }\n    }\n\n    /// @notice This function is called by the LGE Staking contract to facilitate migration of staked tokens from\n    ///         the LGE Staking pool to the Ozean L2.\n    /// @param _l2Destination The address which will be credited the tokens on Ozean.\n    /// @param _tokens The tokens being migrated to Ozean from the LGE Staking contract.\n    /// @param _amounts The amounts of each token to be migrated to Ozean for the _user\n    function migrate(address _l2Destination, address[] calldata _tokens, uint256[] calldata _amounts)\n        external\n        nonReentrant\n    {\n        require(msg.sender == lgeStaking, \"LGE Migration: Only the staking contract can call this function.\");\n        uint256 length = _tokens.length;\n        for (uint256 i; i < length; i++) {\n            require(\n                l1ToL2Addresses[_tokens[i]] != address(0), \"LGE Migration: L2 contract address not set for migration.\"\n            );\n            if (_tokens[i] == usdc) {\n                /// Handle USDC\n                IERC20(_tokens[i]).safeApprove(address(usdxBridge), _amounts[i]);\n                usdxBridge.bridge(_tokens[i], _amounts[i], _l2Destination);\n            } else if (_tokens[i] == wstETH) {\n                /// Handle wstETH\n                IERC20(_tokens[i]).safeApprove(address(l1LidoTokensBridge), _amounts[i]);\n                l1LidoTokensBridge.depositERC20To(\n                    _tokens[i], l1ToL2Addresses[_tokens[i]], _l2Destination, _amounts[i], gasLimits[_tokens[i]], \"\"\n                );\n            } else {\n                /// Handle other tokens\n                IERC20(_tokens[i]).safeApprove(address(l1StandardBridge), _amounts[i]);\n                l1StandardBridge.depositERC20To(\n                    _tokens[i], l1ToL2Addresses[_tokens[i]], _l2Destination, _amounts[i], gasLimits[_tokens[i]], \"\"\n                );\n            }\n        }\n    }\n\n    /// @notice This function allows the contract owner to recover ERC20 tokens from the contract.\n    /// @param  _token The address of the ERC20 token to recover.\n    /// @param  _amount The amount of tokens to transfer to the recipient.\n    /// @param  _recipient The address that will receive the recovered tokens.\n    function recoverTokens(address _token, uint256 _amount, address _recipient) external onlyOwner nonReentrant {\n        IERC20(_token).transfer(_recipient, _amount);\n    }\n\n    /// @notice This function allows the contract owner to change the gas limit passed to the bridging contracts.\n    /// @param  _token The address of the ERC20 token.\n    /// @param  _limit The new gas limit for bridging the token.\n    function setGasLimit(address _token, uint32 _limit) external onlyOwner {\n        gasLimits[_token] = _limit;\n    }\n}\n\n/// Interfaces ///\n\ninterface IL1StandardBridge {\n    /// @custom:legacy\n    /// @notice Deposits some amount of ERC20 tokens into a target account on L2.\n    /// @param _l1Token     Address of the L1 token being deposited.\n    /// @param _l2Token     Address of the corresponding token on L2.\n    /// @param _to          Address of the recipient on L2.\n    /// @param _amount      Amount of the ERC20 to deposit.\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\n    /// @param _extraData   Optional data to forward to L2.\n    ///                     Data supplied here will not be used to execute any code on L2 and is\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\ninterface IL1LidoTokensBridge {\n    function depositERC20To(\n        address l1Token_,\n        address l2Token_,\n        address to_,\n        uint256 amount_,\n        uint32 l2Gas_,\n        bytes calldata data_\n    ) external;\n}\n\ninterface IUSDXBridge {\n    function bridge(address _stablecoin, uint256 _amount, address _to) external;\n}\n",
        "USDXBridge.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Ownable} from \"openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {OptimismPortal} from \"optimism/src/L1/OptimismPortal.sol\";\nimport {SystemConfig} from \"optimism/src/L1/SystemConfig.sol\";\nimport {ISemver} from \"optimism/src/universal/interfaces/ISemver.sol\";\n\n/// @title  USDX Bridge\n/// @notice This contract provides bridging functionality for allow-listed stablecoins to the Ozean Layer L2.\n///         Users can deposit any allow-listed stablecoin and recieve USDX, the native gas token for Ozean, on\n///         the L2 via the Optimism Portal contract. The owner of this contract can modify the set of\n///         allow-listed stablecoins accepted, along with the deposit caps, and can also withdraw any deposited\n///         ERC20 tokens.\ncontract USDXBridge is Ownable, ReentrancyGuard, ISemver {\n    using SafeERC20 for IERC20Decimals;\n\n    /// @notice Semantic version.\n    /// @custom:semver 1.0.0\n    string public constant version = \"1.0.0\";\n\n    /// @notice Contract of the Optimism Portal.\n    /// @custom:network-specific\n    OptimismPortal public immutable portal;\n\n    /// @notice Address of the System Config contract.\n    SystemConfig public immutable config;\n\n    /// @notice Addresses of allow-listed stablecoins.\n    /// @dev    stablecoin => allowlisted\n    mapping(address => bool) public allowlisted;\n\n    /// @notice The limit to the total USDX supply that can be minted and bridged per deposted stablecoin.\n    /// @dev    stablecoin => amount\n    mapping(address => uint256) public depositCap;\n\n    /// @notice The total amount of USDX bridged via this contract per deposted stablecoin.\n    /// @dev    stablecoin => amount\n    mapping(address => uint256) public totalBridged;\n\n    /// @notice The gas limit passed to the Optimism portal when depositing USDX.\n    uint64 public gasLimit;\n\n    /// EVENTS ///\n\n    /// @notice An event emitted when a bridge deposit is made by a user.\n    event BridgeDeposit(address indexed _stablecoin, uint256 _amount, address indexed _to);\n\n    /// @notice An event emitted when an ERC20 token is withdrawn from this contract.\n    event WithdrawCoins(address indexed _coin, uint256 _amount, address indexed _to);\n\n    /// @notice An event emitted when en ERC20 stablecoin is set as allowlisted or not (true if allowlisted, false if\n    /// removed).\n    event AllowlistSet(address indexed _coin, bool _set);\n\n    /// @notice An event emitted when the deposit cap for an ERC20 stablecoin is modified.\n    event DepositCapSet(address indexed _coin, uint256 _newDepositCap);\n\n    /// @notice An event emitted when the gas limit is updated.\n    event GasLimitSet(uint64 _newGasLimit);\n\n    /// SETUP ///\n\n    /// @notice The constructor contract set up.\n    /// @param  _owner The address granted ownership rights to this contract.\n    /// @param  _portal The Optimism Portal contract, which is directly responsible for bridging USDX.\n    /// @param  _config The Optimism System Config contract, which ensures alignment on the gas token.\n    /// @param  _stablecoins An array of allow-listed stablecoins that can be used to mint and bridge USDX.\n    /// @param  _depositCaps The deposit caps per stablecoin for this contract, which limits the total amount bridged.\n    /// @dev    Ensure that the index for each deposit cap aligns with the index of the stablecoin that is allowlisted.\n    /// @dev    This function includes an unbounded for-loop. Ensure that the array of allow-listed\n    ///         stablecoins is reasonable in length.\n    constructor(\n        address _owner,\n        OptimismPortal _portal,\n        SystemConfig _config,\n        address[] memory _stablecoins,\n        uint256[] memory _depositCaps\n    ) {\n        _transferOwnership(_owner);\n        portal = _portal;\n        config = _config;\n        gasLimit = 21000;\n        /// Add allow-listed stablecoins and deposit caps\n        if (address(config) != address(0)) {\n            uint256 length = _stablecoins.length;\n            require(\n                length == _depositCaps.length,\n                \"USDXBridge: Stablecoins array length must equal the Deposit Caps array length.\"\n            );\n            for (uint256 i; i < length; ++i) {\n                allowlisted[_stablecoins[i]] = true;\n                emit AllowlistSet(_stablecoins[i], true);\n                depositCap[_stablecoins[i]] = _depositCaps[i];\n                emit DepositCapSet(_stablecoins[i], _depositCaps[i]);\n            }\n        }\n    }\n\n    /// BRIDGE ///\n\n    /// @notice This function allows users to deposit any allow-listed stablecoin to the Ozean Layer L2.\n    /// @param  _stablecoin Depositing stablecoin address.\n    /// @param  _amount The amount of deposit stablecoin to be swapped for USDX.\n    /// @param  _to Recieving address on L2.\n    function bridge(address _stablecoin, uint256 _amount, address _to) external nonReentrant {\n        /// Checks\n        require(allowlisted[_stablecoin], \"USDXBridge: Stablecoin not accepted.\");\n        require(_amount > 0, \"USDXBridge: May not bridge nothing.\");\n        uint256 bridgeAmount = _getBridgeAmount(_stablecoin, _amount);\n        require(\n            totalBridged[_stablecoin] + bridgeAmount < depositCap[_stablecoin],\n            \"USDXBridge: Bridge amount exceeds deposit cap.\"\n        );\n        /// Update state\n        totalBridged[_stablecoin] += bridgeAmount;\n        IERC20Decimals(_stablecoin).safeTransferFrom(msg.sender, address(this), _amount);\n        /// Mint USDX\n        usdx().mint(address(this), bridgeAmount);\n        /// Bridge USDX\n        usdx().approve(address(portal), bridgeAmount);\n        portal.depositERC20Transaction({\n            _to: _to,\n            _mint: bridgeAmount,\n            _value: bridgeAmount,\n            _gasLimit: gasLimit,\n            _isCreation: false,\n            _data: \"\"\n        });\n        emit BridgeDeposit(_stablecoin, _amount, _to);\n    }\n\n    /// OWNER ///\n\n    /// @notice This function allows the owner to either add or remove an allow-listed stablecoin for bridging.\n    /// @param  _stablecoin The stablecoin address to add or remove.\n    /// @param  _set A boolean for whether the stablecoin is allow-listed or not. True for allow-listed, false\n    ///         otherwise.\n    function setAllowlist(address _stablecoin, bool _set) external onlyOwner {\n        allowlisted[_stablecoin] = _set;\n        emit AllowlistSet(_stablecoin, _set);\n    }\n\n    /// @notice This function allows the owner to modify the deposit cap for deposited stablecoins.\n    /// @param  _stablecoin The stablecoin address to modify the deposit cap.\n    /// @param  _newDepositCap The new deposit cap.\n    function setDepositCap(address _stablecoin, uint256 _newDepositCap) external onlyOwner {\n        depositCap[_stablecoin] = _newDepositCap;\n        emit DepositCapSet(_stablecoin, _newDepositCap);\n    }\n\n    /// @notice This function allows the owner to modify the gas limit for USDX deposits.\n    /// @param  _newGasLimit The new gas limit to be set for transactions.\n    function setGasLimit(uint64 _newGasLimit) external onlyOwner {\n        gasLimit = _newGasLimit;\n        emit GasLimitSet(_newGasLimit);\n    }\n\n    /// @notice This function allows the owner to withdraw any ERC20 token held by this contract.\n    /// @param  _coin The address of the ERC20 token to withdraw.\n    /// @param  _amount The amount of tokens to withdraw.\n    function withdrawERC20(address _coin, uint256 _amount) external onlyOwner {\n        IERC20Decimals(_coin).safeTransfer(msg.sender, _amount);\n        emit WithdrawCoins(_coin, _amount, msg.sender);\n    }\n\n    /// VIEW ///\n\n    /// @notice This view function returns the address, as the USDX interface, for minting and bridging.\n    /// @return IUSDX Interface and address.\n    function usdx() public view returns (IUSDX) {\n        (address addr,) = config.gasPayingToken();\n        return IUSDX(addr);\n    }\n\n    /// @notice This view function normalises deposited amounts given diverging decimals for tokens and USDX.\n    /// @param  _stablecoin The address of the deposited stablecoin.\n    /// @param  _amount The amount of the stablecoin deposited.\n    /// @return uint256 The amount of USDX to mint given the deposited stablecoin amount.\n    /// @dev    Assumes 1:1 conversion between the deposited stablecoin and USDX.\n    function _getBridgeAmount(address _stablecoin, uint256 _amount) internal view returns (uint256) {\n        uint8 depositDecimals = IERC20Decimals(_stablecoin).decimals();\n        uint8 usdxDecimals = usdx().decimals();\n        return (_amount * 10 ** usdxDecimals) / (10 ** depositDecimals);\n    }\n}\n\n/// @notice An interface whihc extends the IERC20 to include a decimals view function.\n/// @dev    Any allow-listed stablecoin added to the bridge must conform to this interface.\ninterface IERC20Decimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\n/// @notice An interface whihc extends the IERC20Decimals to include a mint function to allow for minting\n///         of new USDX tokens by this bridge.\ninterface IUSDX is IERC20Decimals {\n    function mint(address to, uint256 amount) external;\n}\n",
        "LGEStaking.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Ownable} from \"openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"openzeppelin/contracts/security/Pausable.sol\";\nimport {ISemver} from \"optimism/src/universal/interfaces/ISemver.sol\";\nimport {ILGEMigration} from \"src/L1/interface/ILGEMigration.sol\";\n\n/// @title  LGE Staking\n/// @notice This contract facilitates staking of ERC20 tokens and ETH for users and allows migration of staked assets to\n///         the Ozean L2.\n/// @dev    Inspired by https://vscode.blockscan.com/ethereum/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6\ncontract LGEStaking is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Semantic version.\n    /// @custom:semver 1.0.0\n    string public constant version = \"1.0.0\";\n\n    /// @notice The contract address for Lido's staked ether.\n    address public immutable stETH;\n\n    /// @notice The contract address for Lido's wrapped staked ether.\n    /// @dev    All ETH deposits are converted to wstETH on deposit.\n    address public immutable wstETH;\n\n    /// @notice The migration contract that facilitates unstaking and deposits to the Ozean L2.\n    ILGEMigration public lgeMigration;\n\n    /// @notice Addresses of allow-listed ERC20 tokens.\n    /// @dev    token => allowlisted\n    mapping(address => bool) public allowlisted;\n\n    /// @notice The total amount of tokens deposted via this contract per allowlisted token address.\n    /// @dev    token => amount\n    mapping(address => uint256) public totalDeposited;\n\n    /// @notice The limit to the amount that can be minted and bridged per token address.\n    /// @dev    token => amount\n    mapping(address => uint256) public depositCap;\n\n    /// @notice The amount of tokens each user deposited for each allowlisted token.\n    /// @dev    token => user => amount\n    mapping(address => mapping(address => uint256)) public balance;\n\n    /// EVENTS ///\n\n    /// @notice An event emitted when a deposit is made by a user.\n    event Deposit(address indexed _token, uint256 _amount, address indexed _to);\n\n    /// @notice An event emitted when is withdrawal is made by a user.\n    event Withdraw(address indexed _token, uint256 _amount, address indexed _to);\n\n    /// @notice An event emitted when en ERC20 token is set as allowlisted or not (true if allowlisted, false if\n    ///         removed).\n    event AllowlistSet(address indexed _coin, bool _set);\n\n    /// @notice An event emitted when the deposit cap for an ERC20 token is modified.\n    event DepositCapSet(address indexed _coin, uint256 _newDepositCap);\n\n    /// @notice An event emitted when a user migrates deposited assets to Ozean.\n    event TokensMigrated(address indexed _user, address indexed _l2Destination, address[] _tokens, uint256[] _amounts);\n\n    /// @notice An event emitted when the migration contract is modified.\n    event MigrationContractSet(address _newContract);\n\n    /// SETUP ///\n\n    constructor(\n        address _owner,\n        address _stETH,\n        address _wstETH,\n        address[] memory _tokens,\n        uint256[] memory _depositCaps\n    ) {\n        _transferOwnership(_owner);\n        stETH = _stETH;\n        wstETH = _wstETH;\n        IstETH(stETH).approve(wstETH, ~uint256(0));\n        uint256 length = _tokens.length;\n        require(\n            length == _depositCaps.length, \"LGE Staking: Tokens array length must equal the Deposit Caps array length.\"\n        );\n        for (uint256 i; i < length; ++i) {\n            allowlisted[_tokens[i]] = true;\n            emit AllowlistSet(_tokens[i], true);\n            depositCap[_tokens[i]] = _depositCaps[i];\n            emit DepositCapSet(_tokens[i], _depositCaps[i]);\n        }\n    }\n\n    /// DEPOSIT ///\n\n    /// @notice Deposits ERC20 tokens into the staking contract.\n    /// @param  _token The address of the ERC20 token to deposit.\n    /// @param  _amount The amount of tokens to deposit.\n    /// @dev    Users must grant approval for the contract to move their tokens.\n    function depositERC20(address _token, uint256 _amount) external nonReentrant whenNotPaused {\n        require(!migrationActivated(), \"LGE Staking: May not deposit once migration has been activated.\");\n        require(_amount > 0, \"LGE Staking: May not deposit nothing.\");\n        require(allowlisted[_token], \"LGE Staking: Token must be allowlisted.\");\n        require(\n            totalDeposited[_token] + _amount < depositCap[_token], \"LGE Staking: deposit amount exceeds deposit cap.\"\n        );\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        require(\n            IERC20(_token).balanceOf(address(this)) - balanceBefore == _amount,\n            \"LGE Staking: Fee-on-transfer tokens not supported.\"\n        );\n        balance[_token][msg.sender] += _amount;\n        totalDeposited[_token] += _amount;\n        emit Deposit(_token, _amount, msg.sender);\n    }\n\n    /// @notice Deposits ETH into the staking contract, converting it to wstETH.\n    /// @dev    All ETH is converted to wstETH on deposit.\n    function depositETH() external payable nonReentrant whenNotPaused {\n        require(!migrationActivated(), \"LGE Staking: May not deposit once migration has been activated.\");\n        require(msg.value > 0, \"LGE Staking: May not deposit nothing.\");\n        require(allowlisted[wstETH], \"LGE Staking: Token must be allowlisted.\");\n        IstETH(stETH).submit{value: msg.value}(address(0));\n        uint256 wstETHAmount = IwstETH(wstETH).wrap(IstETH(stETH).balanceOf(address(this)));\n        require(\n            totalDeposited[wstETH] + wstETHAmount < depositCap[wstETH],\n            \"LGE Staking: deposit amount exceeds deposit cap.\"\n        );\n        balance[wstETH][msg.sender] += wstETHAmount;\n        totalDeposited[wstETH] += wstETHAmount;\n        emit Deposit(wstETH, wstETHAmount, msg.sender);\n    }\n\n    /// WITHDRAW ///\n\n    /// @notice Withdraws ERC20 tokens from the staking contract.\n    /// @param  _token The address of the ERC20 token to withdraw.\n    /// @param  _amount The amount of tokens to withdraw.\n    function withdraw(address _token, uint256 _amount) external nonReentrant whenNotPaused {\n        require(_amount > 0, \"LGE Staking: may not withdraw nothing.\");\n        require(balance[_token][msg.sender] >= _amount, \"LGE Staking: insufficient deposited balance.\");\n        balance[_token][msg.sender] -= _amount;\n        totalDeposited[_token] -= _amount;\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        emit Withdraw(_token, _amount, msg.sender);\n    }\n\n    /// MIGRATE ///\n\n    /// @notice Migrates assets to the specified L2 destination.\n    /// @param  _l2Destination The address of the L2 destination to migrate tokens to.\n    /// @param  _tokens An array of token addresses to migrate.\n    /// @dev    Sends assets to the migration contract, and then calls `migrate` to move the assets.\n    function migrate(address _l2Destination, address[] calldata _tokens) external nonReentrant whenNotPaused {\n        require(migrationActivated(), \"LGE Staking: Migration not active.\");\n        require(_l2Destination != address(0), \"LGE Staking: May not send tokens to the zero address.\");\n        uint256 length = _tokens.length;\n        require(length > 0, \"LGE Staking: Must migrate some tokens.\");\n        uint256[] memory amounts = new uint256[](length);\n        uint256 amount;\n        for (uint256 i; i < length; i++) {\n            amount = balance[_tokens[i]][msg.sender];\n            require(amount > 0, \"LGE Staking: No tokens to migrate.\");\n            balance[_tokens[i]][msg.sender] -= amount;\n            totalDeposited[_tokens[i]] -= amount;\n            amounts[i] = amount;\n            IERC20(_tokens[i]).safeTransfer(address(lgeMigration), amount);\n        }\n        lgeMigration.migrate(_l2Destination, _tokens, amounts);\n        emit TokensMigrated(msg.sender, _l2Destination, _tokens, amounts);\n    }\n\n    /// OWNER ///\n\n    /// @notice This function allows the owner to either add or remove an allow-listed token for deposit.\n    /// @param  _token The token address to add or remove.\n    /// @param  _set A boolean for whether the token is allow-listed or not. True for allow-listed, false otherwise.\n    function setAllowlist(address _token, bool _set) external onlyOwner {\n        allowlisted[_token] = _set;\n        emit AllowlistSet(_token, _set);\n    }\n\n    /// @notice This function allows the owner to modify the deposit cap for deposited tokens.\n    /// @param  _token The token address to modify the deposit cap.\n    /// @param  _newDepositCap The new deposit cap.\n    function setDepositCap(address _token, uint256 _newDepositCap) external onlyOwner {\n        depositCap[_token] = _newDepositCap;\n        emit DepositCapSet(_token, _newDepositCap);\n    }\n\n    /// @notice This function allows the owner to set the migration contract used to move deposited assets to the\n    ///         Ozean L2.\n    /// @param  _contract The new contract address for the LGE Migration logic.\n    /// @dev    The new migration contract must conform to the ILGEMigration interface.\n    /// @dev    If this contract is set to address(0) migration is deactivated\n    function setMigrationContract(address _contract) external onlyOwner {\n        lgeMigration = ILGEMigration(_contract);\n        emit MigrationContractSet(_contract);\n    }\n\n    /// @notice This function allows the owner to pause or unpause this contract.\n    /// @param  _set The boolean for whether the contract is to be paused or unpaused. True for paused, false otherwise.\n    function setPaused(bool _set) external onlyOwner {\n        _set ? _pause() : _unpause();\n    }\n\n    /// VIEW ///\n\n    /// @notice Checks if migration has been activated.\n    /// @return activated A boolean indicating whether migration is active.\n    function migrationActivated() public view returns (bool activated) {\n        activated = (address(lgeMigration) != address(0));\n    }\n}\n\ninterface IstETH is IERC20 {\n    function submit(address _referral) external payable returns (uint256);\n}\n\ninterface IwstETH is IERC20 {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n}\n"
    }
}