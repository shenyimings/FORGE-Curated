{
    "vfp_id": "vfp_00261",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The NetworkMiddleware.registerVault function does not check if a vault has already been registered for a given agent, allowing duplicate entries. This leads to the same vault's delegation being counted multiple times when calculating coverage. The root cause is the lack of deduplication or uniqueness checks during vault registration. An attacker or user could exploit this by re-registering the same vault multiple times, especially after a transaction failure and replacement. The impact is an inflated delegation value, which can cause incorrect risk assessment and lead to under-collateralized liquidations, resulting in potential loss of funds for the senior tranche.\n",
            "severity": "Medium",
            "location": [
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::registerVault#58-69",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::coverage#195-206",
                "Delegation.sol::addVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "StakedCap yield distribution DoS through timer manipulation",
            "description": "The StakedCap contract's notify function is permissionless and resets the lastNotify timestamp upon any token deposit, which affects the lockedProfit calculation. An attacker can repeatedly call notify with minimal token transfers to reset the timer, keeping the elapsed time small and preventing yield from unlocking. The root cause is the lack of rate-limiting or time-based protection on the notify function. This allows an attacker to indefinitely delay the vesting of rewards. The impact is a denial of service for legitimate stakers who cannot withdraw their earned yield, effectively locking their rewards permanently.\n",
            "severity": "Medium",
            "location": [
                "contracts/token/StakedCap.sol::notify#58-69",
                "contracts/token/StakedCap.sol::lockedProfit#73-85",
                "contracts/token/StakedCap.sol::totalAssets#L73-85",
                "StakedCap.sol"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "Inconsistent balance tracking in vault creates DoS for asset borrowing",
            "description": "The Vault contract uses inconsistent accounting methods: some functions rely on totalSupplies while others use direct balanceOf checks. The burn function reduces totalSupplies without validating against actual token balances, allowing totalSupplies to drop below totalBorrows. This violates the invariant that total supply must be >= total borrows. The root cause is the lack of synchronization between accounting variables and real token balances. An attacker can exploit this by transferring tokens directly to the vault and then burning more than the accounted supply, creating a negative available balance. The impact is a system-wide denial of service for borrowing that specific asset, even if physical tokens are available.\n",
            "severity": "High",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::burn#111-124",
                "contracts/vault/Vault.sol::availableBalance#206-209",
                "contracts/lendingPool/libraries/ViewLogic.sol::maxBorrowable#83-91",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/lendingPool/libraries/ViewLogic.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ]
            },
            "title": "Unsafe asset removal without borrow validation",
            "description": "The removeAsset function in VaultLogic allows removing an asset from the vault's list without checking if there are outstanding borrows. This can lead to a state where borrowers cannot repay loans because the asset is no longer recognized by the system. The root cause is the absence of a pre-removal validation check for totalBorrows. An admin or attacker with access could remove an asset with active loans, rendering repayment functions ineffective. The impact is that borrowers' funds become locked, they cannot clear their debt, and the system enters an inconsistent state.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::removeAsset#192-208",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Immediate liquidation possible when reducing an agent’s liquidation threshold",
            "description": "The modifyAgent function allows reducing an agent’s liquidation threshold without checking if the agent is already below the new threshold. This could immediately trigger liquidation of the agent’s position. The root cause is the lack of a safety check before updating the threshold. An admin could unknowingly or maliciously set a threshold that puts an agent into a liquidatable state. The impact is unfair liquidation of agents’ positions, leading to loss of collateral and potential disputes or loss of trust in the system.\n",
            "severity": "Informational",
            "location": [
                "contracts/delegation/Delegation.sol::modifyAgent#227-244",
                "Lender.sol::setLiquidationThreshold"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emissions for critical parameter changes in VaultAdapter",
            "description": "The setSlopes and setLimits functions in VaultAdapter do not emit events when critical parameters are changed. This makes it difficult to monitor or detect changes to interest rate models, which are essential for protocol transparency and security. The root cause is the omission of event emissions in admin-controlled functions. An attacker or compromised admin could change parameters without leaving an on-chain trace. The impact is reduced auditability and increased risk of undetected malicious or erroneous configuration changes.\n",
            "severity": "Informational",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::setSlopes#51-56",
                "contracts/oracle/libraries/VaultAdapter.sol::setLimits#60-70",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "VaultAdapter’s setSlopes function permits zero or maximum kink values that cause division by zero",
            "description": "The setSlopes function allows setting the kink parameter to 0 or 1e27, which leads to division by zero in interest rate calculations. This would cause the rate calculation to revert, breaking core protocol functionality. The root cause is the lack of input validation on the kink value. An attacker with admin access or a misconfigured input could set these values, causing the system to fail on rate queries. The impact is a denial of service for any function relying on interest rate calculations, disrupting borrowing and lending.\n",
            "severity": "Informational",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::setSlopes#51-56",
                "contracts/oracle/libraries/VaultAdapter.sol::rate#104-105",
                "contracts/oracle/libraries/VaultAdapter.sol::utilizationMultiplier#87-88",
                "VaultAdapter.sol::setSlopes"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Unvalidated _vault address in VaultAdapter allows interest rate manipulation",
            "description": "The rate function in VaultAdapter accepts any _vault address without validation and makes external calls to it. An attacker can pass a malicious contract that returns manipulated utilization values, which are then stored and used in interest rate calculations. The root cause is the lack of access control or allowlist validation on the _vault parameter. This allows an attacker to inflate or deflate interest rates across the protocol. The impact is financial loss for borrowers or lenders due to incorrect interest accrual, and potential manipulation of the entire lending market.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::rate#26-49",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "The protocol exhibits a critical discrepancy between how an agent's health factor is calculated and how slashable collateral is determined. This inconsistency arises because the health factor evaluation uses all current collateral, including recent deposits, while the slashing mechanism only considers deposits made before the most recent epoch or the agent's last borrow time. The root cause is the misalignment in time bases used by the coverage and slashTimestamp functions. An attacker can exploit this by adding fresh collateral just before a liquidation event to improve their health factor, knowing that these new deposits will not be subject to slashing. As a result, during liquidation, the protocol cannot recover sufficient collateral from these recent deposits, leading to a shortfall that the protocol must absorb. This undermines the financial stability and security model of the system, potentially resulting in significant protocol losses, especially if all existing delegations are from the current epoch.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/Delegation.sol#L73-L76",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L195-L206",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Reward distribution enables front-running attacks and reward siphoning",
            "description": "The reward distribution mechanism allocates rewards to all vaults backing an agent at the time of loan repayment without considering the duration of their delegation. This creates a timing vulnerability where opportunistic actors can monitor pending repayment transactions in the mempool and front-run them by adding their own collateral just before repayment. The root cause is the lack of time-based eligibility criteria for reward distribution. By doing so, these actors can capture a disproportionate share of the accrued interest rewards despite having provided capital for only a minimal period. This allows them to systematically siphon rewards from long-term backers who actually bore the lending risk over time. The impact is an unfair redistribution of rewards that disincentivizes long-term participation and undermines the economic fairness of the protocol.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/NetworkMiddleware.sol",
                "contracts/delegation/Delegation.sol",
                "StakedCap.sol::distributeRewards"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Unaccounted external vault investment losses can create withdrawal shortfalls",
            "description": "The protocol invests idle assets in external vaults such as Yearn but fails to account for losses incurred during divestment. When the protocol changes the address of an external vault, it divests from the current vault regardless of any losses, and these losses are not tracked or reflected in the system's accounting. The root cause is the absence of loss tracking during divestment operations. This creates a \"first out\" advantage where early withdrawers can redeem their full amounts while later withdrawers may face shortfalls because the physical assets no longer exist to back their balances. The protocol continues to report the original total supply despite having fewer physical tokens, leading to an inability to fulfill withdrawal requests. This threatens the solvency of the system and creates an unfair distribution of losses among users.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol",
                "contracts/vault/FractionalReserve.sol",
                "FractionalReserve.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Liquidation mechanism can be permanently disabled by misconfigured grace and expiry periods",
            "description": "The Lender contract does not validate that the grace period is less than the expiry period during initialization. If grace >= expiry, the liquidation mechanism becomes impossible to trigger because the validateLiquidation function requires block.timestamp to be both greater than start+grace and less than start+expiry, which cannot be satisfied simultaneously. The root cause is the lack of input validation for critical configuration parameters. Since these parameters cannot be reset after deployment, a misconfiguration would permanently disable liquidations. An attacker or negligent admin could deploy the contract with such invalid parameters, preventing any liquidation from occurring even when agents are severely undercollateralized. This leads to the accumulation of bad debt and potentially results in protocol insolvency as unhealthy positions remain outstanding indefinitely.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol#L98-L102",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Oracle update front-running allows extraction of value from vaults",
            "description": "The protocol's minting and burning functions are vulnerable to oracle sandwiching attacks due to the use of current oracle prices without protection against timing manipulation. The root cause is the lack of safeguards such as fees, TWAPs, or circuit breakers around oracle updates. An attacker can monitor pending Chainlink oracle updates and front-run them by depositing assets before the price update and withdrawing after, profiting from the price difference. For example, when the USDC price drops, the attacker deposits at the old price and withdraws at the new, higher effective rate, extracting value from the protocol. The impact is a direct loss of funds from the protocol treasury proportional to the size of the oracle update, exploiting natural market movements rather than oracle manipulation, which undermines the economic integrity of the system.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/Vault.sol",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/oracle/Oracle.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Asset removal does not reset isBorrowing flag for agents",
            "description": "When an asset is removed from the system, the validation logic only checks if the principal debt is repaid but does not clear the agent's isBorrowing flag for that asset. The root cause is incomplete state cleanup during asset removal. If the same reserve ID is later reused for a different asset, agents who previously borrowed the old asset will have their isBorrowing flag incorrectly set to true for the new asset, even though they never borrowed it. This leads to accounting inconsistencies that can affect health factor calculations, borrowing limits, and liquidation eligibility. The impact includes incorrect risk assessments for agents and potential denial of service for legitimate operations due to false borrowing status, undermining the reliability of the protocol's financial tracking mechanisms.\n",
            "severity": "Informational",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Invalid network registration in Delegation.registerNetwork can cause DoS",
            "description": "The registerNetwork function in the Delegation contract lacks validation for network addresses and provides no way to remove registered networks. The root cause is insufficient input validation and missing administrative functions for error correction. If an invalid address (e.g., address(0)) or a non-compliant contract is registered, key functions like coverage and slashableCollateral will permanently revert when attempting external calls to the invalid network. This results in a denial of service for the affected agent, locking them out of protocol functionality indefinitely. Since there is no mechanism to unregister networks or remove the agent, the issue cannot be resolved post-deployment, making it a permanent operational failure for the affected user.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L249-L258",
                "Delegation.sol::registerNetwork"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Lack of verification on ERC4626 vault withdrawal amounts",
            "description": "The divest function reduces the recorded loaned amount before the actual withdrawal occurs and does not verify the return value from the ERC4626 vault's withdraw call. The root cause is the failure to validate the actual amount received versus the expected divestAmount. If the vault returns fewer assets than requested (due to losses or other factors), the accounting system still assumes the full amount was withdrawn, creating a discrepancy between recorded and actual assets. While current integrations with Yearn vaults prevent losses by reverting, future integration with other ERC4626 vaults that allow losses could lead to systematic asset shortfalls. The impact is a gradual erosion of protocol solvency as unaccounted losses accumulate over time.\n",
            "severity": "Informational",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol#L63-L66",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Agent LTV can be configured equal to or higher than liquidation threshold",
            "description": "The addAgent and modifyAgent functions allow setting an agent's loan-to-value (LTV) ratio equal to or higher than its liquidation threshold. The root cause is missing validation that ensures LTV is strictly less than the liquidation threshold. This configuration leads to contradictory economic states: if LTV >= liquidation threshold, an agent could either be immediately liquidatable upon borrowing or never reach liquidation even when undercollateralized. The impact is a breakdown of the risk management system, exposing the protocol to uncontrolled borrowing and potential insolvency. Even if unintended, a simple administrative error could create such a dangerous configuration, undermining the core collateralization safeguards of the protocol.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L202-L209",
                "Lender.sol::setLTV"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Small borrows can create economically unviable liquidatable positions leading to bad debt accumulation",
            "description": "The borrow function allows positions as small as 1 wei without a minimum borrow amount check. The root cause is the absence of economic viability safeguards in the borrowing logic. When such tiny positions become undercollateralized, the gas costs of liquidation exceed the liquidation value plus bonus, making it unprofitable for liquidators to act. This leads to the accumulation of bad debt in the system, as these positions remain outstanding indefinitely. While the impact is limited by the number of borrowable assets per agent, it still introduces a persistent solvency risk. The protocol effectively subsidizes spammy or malicious small borrowing behavior, weakening the overall health of the lending market.\n",
            "severity": "Low",
            "location": [
                "contracts/lendingPool/Lender.sol#L65-L69",
                "Lender.sol::borrow"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Interest rate manipulation through frequent mints and burns",
            "description": "The interest rate calculation depends on the elapsed time since the last update, but this timestamp is reset on every mint, burn, or borrow operation. The root cause is the vulnerability to timestamp manipulation via frequent zero-value or low-value transactions. An attacker can artificially reduce the elapsed time used in utilization multiplier calculations by performing repeated operations, thereby dampening interest rate increases during high utilization periods. This is especially severe when zero-value mints or burns are allowed, as they enable manipulation with minimal capital. The impact is distorted interest rates that fail to reflect true market conditions, allowing borrowers to avoid paying appropriate risk premiums and undermining the protocol's risk management and capital allocation mechanisms.\n",
            "severity": "Low",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol#L289-L293",
                "contracts/oracle/libraries/VaultAdapter.sol#L87-L88",
                "Minter.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol",
                "cap-contracts/contracts/vault/Minter.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Protocol lacks bad debt management mechanisms, risking permanent insolvency",
            "description": "The protocol has no mechanism to handle accumulated bad debt from failed or uneconomical liquidations. The root cause is the absence of insurance or loss-socialization mechanisms. When bad debt accumulates—especially in conjunction with small, unviable borrowing positions—the loss is not distributed fairly. Instead, it creates a \"last withdrawer\" problem where early withdrawers redeem their full amounts while later users face shortfalls as the protocol runs out of physical tokens. This leads to permanent insolvency and unfair loss distribution. The impact is a systemic risk to user funds, where the timing of withdrawal determines whether a user loses money, undermining trust in the protocol's solvency guarantees.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/Lender.sol",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Reward distribution can be tricked by front-running notify calls",
            "description": "The notify function in StakedCap updates the reward distribution state based on current balances without protecting against front-running. The root cause is the lack of time-based or anti-sybil mechanisms in reward allocation. An attacker can monitor mempool transactions and deposit a large amount of CAP tokens immediately before a notify call, thereby capturing a disproportionate share of the newly distributed rewards. After receiving the rewards, the attacker can withdraw, having gained value without long-term commitment. This undermines the incentive structure for genuine long-term stakers and enables sophisticated actors to exploit timing advantages for unfair profit extraction, reducing the fairness and effectiveness of the reward system.\n",
            "severity": "Informational",
            "location": [
                "contracts/token/StakedCap.sol#L58-L69",
                "StakedCap.sol::notifyReward"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        }
    ],
    "affected_files": {
        "ViewLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IDebtToken } from \"../../interfaces/IDebtToken.sol\";\nimport { IDelegation } from \"../../interfaces/IDelegation.sol\";\n\nimport { ILender } from \"../../interfaces/ILender.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { AgentConfiguration } from \"./configuration/AgentConfiguration.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title View Logic\n/// @author kexley, @capLabs\n/// @notice View functions to see the state of an agent's health\nlibrary ViewLogic {\n    using AgentConfiguration for ILender.AgentConfigurationMap;\n\n    /// @notice Calculate the agent data\n    /// @param $ Lender storage\n    /// @param _agent Agent address\n    /// @return totalDelegation Total delegation of an agent in USD, encoded with 8 decimals\n    /// @return totalDebt Total debt of an agent in USD, encoded with 8 decimals\n    /// @return ltv Loan to value ratio, encoded in ray (1e27)\n    /// @return liquidationThreshold Liquidation ratio of an agent, encoded in ray (1e27)\n    /// @return health Health status of an agent, encoded in ray (1e27)\n    function agent(ILender.LenderStorage storage $, address _agent)\n        public\n        view\n        returns (uint256 totalDelegation, uint256 totalDebt, uint256 ltv, uint256 liquidationThreshold, uint256 health)\n    {\n        totalDelegation = IDelegation($.delegation).coverage(_agent);\n        liquidationThreshold = IDelegation($.delegation).liquidationThreshold(_agent);\n\n        for (uint256 i; i < $.reservesCount; ++i) {\n            if (!$.agentConfig[_agent].isBorrowing(i)) {\n                continue;\n            }\n\n            address asset = $.reservesList[i];\n            (uint256 assetPrice,) = IOracle($.oracle).getPrice(asset);\n            if (assetPrice == 0) continue;\n\n            totalDebt += (\n                IERC20($.reservesData[asset].principalDebtToken).balanceOf(_agent)\n                    + IERC20($.reservesData[asset].interestDebtToken).balanceOf(_agent)\n                    + IERC20($.reservesData[asset].restakerDebtToken).balanceOf(_agent)\n            ) * assetPrice / (10 ** $.reservesData[asset].decimals);\n        }\n\n        ltv = totalDelegation == 0 ? 0 : (totalDebt * 1e27) / totalDelegation;\n        health = totalDebt == 0 ? type(uint256).max : (totalDelegation * liquidationThreshold) / totalDebt;\n    }\n\n    /// @notice Calculate the maximum amount that can be borrowed for a given asset\n    /// @param $ Lender storage\n    /// @param _agent Agent address\n    /// @param _asset Asset to borrow\n    /// @return maxBorrowableAmount Maximum amount that can be borrowed in asset decimals\n    function maxBorrowable(ILender.LenderStorage storage $, address _agent, address _asset)\n        external\n        view\n        returns (uint256 maxBorrowableAmount)\n    {\n        (uint256 totalDelegation, uint256 totalDebt,,, uint256 health) = agent($, _agent);\n\n        // health is below liquidation threshold, no borrowing allowed\n        if (health < 1e27) return 0;\n\n        uint256 ltv = IDelegation($.delegation).ltv(_agent);\n        uint256 borrowCapacity = totalDelegation * ltv / 1e27;\n\n        //  already at or above borrow capacity\n        if (totalDebt >= borrowCapacity) return 0;\n\n        // Calculate remaining borrow capacity in USD (8 decimals)\n        uint256 remainingCapacity = borrowCapacity - totalDebt;\n\n        // Convert to asset amount using price and decimals\n        (uint256 assetPrice,) = IOracle($.oracle).getPrice(_asset);\n        if (assetPrice == 0) return 0;\n\n        uint256 assetDecimals = $.reservesData[_asset].decimals;\n        maxBorrowableAmount = remainingCapacity * (10 ** assetDecimals) / assetPrice;\n\n        // Get total available assets using the vault's availableBalance function\n        uint256 totalAvailable = IVault($.reservesData[_asset].vault).availableBalance(_asset);\n\n        // Limit maxBorrowableAmount by total available assets\n        if (totalAvailable < maxBorrowableAmount) {\n            maxBorrowableAmount = totalAvailable;\n        }\n    }\n\n    /// @notice Calculate the maximum amount that can be liquidated for a given asset\n    /// @param $ Lender storage\n    /// @param _agent Agent address\n    /// @param _asset Asset to liquidate\n    /// @return maxLiquidatableAmount Maximum amount that can be liquidated in asset decimals\n    function maxLiquidatable(ILender.LenderStorage storage $, address _agent, address _asset)\n        external\n        view\n        returns (uint256 maxLiquidatableAmount)\n    {\n        (uint256 totalDelegation, uint256 totalDebt,, uint256 liquidationThreshold, uint256 health) = agent($, _agent);\n        if (health >= 1e27) return 0;\n\n        (uint256 assetPrice,) = IOracle($.oracle).getPrice(_asset);\n        if (assetPrice == 0) return 0;\n\n        uint256 decPow = 10 ** $.reservesData[_asset].decimals;\n        uint256 a = ($.targetHealth * totalDebt);\n        uint256 b = (totalDelegation * liquidationThreshold);\n        uint256 c = ($.targetHealth - liquidationThreshold);\n        uint256 d = assetPrice;\n        uint256 e = b > a ? 0 : (a - b);\n        uint256 f = (c * d);\n        uint256 g = e * decPow;\n\n        maxLiquidatableAmount = g / f;\n    }\n\n    /// @notice Get the current debt balances for an agent for a specific asset\n    /// @param $ Lender storage\n    /// @param _agent Agent address to check debt for\n    /// @param _asset Asset to check debt for\n    /// @return principalDebt Principal debt amount in asset decimals\n    /// @return interestDebt Interest debt amount in asset decimals\n    /// @return restakerDebt Restaker debt amount in asset decimals\n    function debt(ILender.LenderStorage storage $, address _agent, address _asset)\n        external\n        view\n        returns (uint256 principalDebt, uint256 interestDebt, uint256 restakerDebt)\n    {\n        ILender.ReserveData memory reserve = $.reservesData[_asset];\n        principalDebt = IERC20(reserve.principalDebtToken).balanceOf(_agent);\n        restakerDebt = IERC20(reserve.restakerDebtToken).balanceOf(_agent);\n        interestDebt = IERC20(reserve.interestDebtToken).balanceOf(_agent);\n    }\n}\n",
        "ValidationLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IDelegation } from \"../../interfaces/IDelegation.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ILender } from \"../../interfaces/ILender.sol\";\nimport { ViewLogic } from \"./ViewLogic.sol\";\n\n/// @title Validation Logic\n/// @author kexley, @capLabs\n/// @notice Validate actions before state is altered\nlibrary ValidationLogic {\n    /// @dev Collateral cannot cover new borrow\n    error CollateralCannotCoverNewBorrow();\n\n    /// @dev Health factor not below threshold\n    error HealthFactorNotBelowThreshold();\n\n    /// @dev Health factor lower than liquidation threshold\n    error HealthFactorLowerThanLiquidationThreshold(uint256 health);\n\n    /// @dev Already initiated\n    error AlreadyInitiated();\n\n    /// @dev Grace period not over\n    error GracePeriodNotOver();\n\n    /// @dev Liquidation expired\n    error LiquidationExpired();\n\n    /// @dev Reserve paused\n    error ReservePaused();\n\n    /// @dev Asset not listed\n    error AssetNotListed();\n\n    /// @dev Variable debt supply not zero\n    error VariableDebtSupplyNotZero();\n\n    /// @dev Zero address not valid\n    error ZeroAddressNotValid();\n\n    /// @dev Reserve already initialized\n    error ReserveAlreadyInitialized();\n\n    /// @dev Interest receiver not set\n    error InterestReceiverNotSet();\n\n    /// @dev Restaker interest receiver not set\n    error RestakerInterestReceiverNotSet();\n\n    /// @notice Validate the borrow of an agent\n    /// @dev Check the pause state of the reserve and the health of the agent before and after the\n    /// borrow.\n    /// @param $ Lender storage\n    /// @param params Validation parameters\n    function validateBorrow(ILender.LenderStorage storage $, ILender.BorrowParams memory params) external {\n        if (params.receiver == address(0) || params.asset == address(0)) revert ZeroAddressNotValid();\n        if ($.reservesData[params.asset].paused) revert ReservePaused();\n\n        uint256 borrowCapacity = ViewLogic.maxBorrowable($, params.agent, params.asset);\n\n        if (params.amount > borrowCapacity) revert CollateralCannotCoverNewBorrow();\n\n        IDelegation($.delegation).setLastBorrow(params.agent);\n    }\n\n    /// @notice Validate the initialization of the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    /// @param start Last liquidation start time\n    /// @param expiry Liquidation duration after which it expires\n    function validateInitiateLiquidation(uint256 health, uint256 start, uint256 expiry) external view {\n        if (health >= 1e27) revert HealthFactorNotBelowThreshold();\n        if (block.timestamp <= start + expiry) revert AlreadyInitiated();\n    }\n\n    /// @notice Validate the cancellation of the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    function validateCancelLiquidation(uint256 health) external pure {\n        if (health < 1e27) revert HealthFactorLowerThanLiquidationThreshold(health);\n    }\n\n    /// @notice Validate the liquidation of an agent\n    /// @dev Health of above 1e27 is healthy, below is liquidatable\n    /// @param health Health of an agent's position\n    /// @param emergencyHealth Emergency health below which the grace period is voided\n    /// @param start Last liquidation start time\n    /// @param grace Grace period duration\n    /// @param expiry Liquidation duration after which it expires\n    function validateLiquidation(uint256 health, uint256 emergencyHealth, uint256 start, uint256 grace, uint256 expiry)\n        external\n        view\n    {\n        if (health >= 1e27) revert HealthFactorNotBelowThreshold();\n        if (emergencyHealth >= 1e27) {\n            if (block.timestamp <= start + grace) revert GracePeriodNotOver();\n            if (block.timestamp >= start + expiry) revert LiquidationExpired();\n        }\n    }\n\n    /// TODO Check that the asset is borrowable from the vault\n    /// @notice Validate adding an asset as a reserve\n    /// @param $ Lender storage\n    /// @param params Parameters for adding an asset\n    function validateAddAsset(ILender.LenderStorage storage $, ILender.AddAssetParams memory params) external view {\n        if (params.asset == address(0) || params.vault == address(0)) revert ZeroAddressNotValid();\n        if (params.interestReceiver == address(0)) revert InterestReceiverNotSet();\n        if (params.restakerInterestReceiver == address(0)) revert RestakerInterestReceiverNotSet();\n        if ($.reservesData[params.asset].vault != address(0)) revert ReserveAlreadyInitialized();\n    }\n\n    /// @notice Validate dropping an asset as a reserve\n    /// @dev All principal borrows must be repaid, interest is ignored\n    /// @param $ Lender storage\n    /// @param _asset Asset to remove\n    function validateRemoveAsset(ILender.LenderStorage storage $, address _asset) external view {\n        if (IERC20($.reservesData[_asset].principalDebtToken).totalSupply() != 0) revert VariableDebtSupplyNotZero();\n    }\n\n    /// @notice Validate pausing a reserve\n    /// @param $ Lender storage\n    /// @param _asset Asset to pause\n    function validatePauseAsset(ILender.LenderStorage storage $, address _asset) external view {\n        if ($.reservesData[_asset].vault == address(0)) revert AssetNotListed();\n    }\n}\n",
        "Vault.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { VaultStorageUtils } from \"../storage/VaultStorageUtils.sol\";\nimport { FractionalReserve } from \"./FractionalReserve.sol\";\nimport { Minter } from \"./Minter.sol\";\nimport { VaultLogic } from \"./libraries/VaultLogic.sol\";\nimport { ERC20PermitUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\n\n/// @title Vault for storing the backing for cTokens\n/// @author kexley, @capLabs\n/// @notice Tokens are supplied by cToken minters and borrowed by covered agents\n/// @dev Supplies, borrows and utilization rates are tracked. Interest rates should be computed and\n/// charged on the external contracts, only the principle amount is counted on this contract.\ncontract Vault is IVault, ERC20PermitUpgradeable, Access, Minter, FractionalReserve, VaultStorageUtils {\n    /// @dev Initialize the assets\n    /// @param _name Name of the cap token\n    /// @param _symbol Symbol of the cap token\n    /// @param _accessControl Access control address\n    /// @param _feeAuction Fee auction address\n    /// @param _oracle Oracle address\n    /// @param _assets Asset addresses\n    function __Vault_init(\n        string memory _name,\n        string memory _symbol,\n        address _accessControl,\n        address _feeAuction,\n        address _oracle,\n        address[] calldata _assets\n    ) internal onlyInitializing {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        __Access_init(_accessControl);\n        __FractionalReserve_init_unchained(_feeAuction);\n        __Minter_init_unchained(_oracle);\n        __Vault_init_unchained(_assets);\n    }\n\n    /// @dev Initialize unchained\n    /// @param _assets Asset addresses\n    function __Vault_init_unchained(address[] calldata _assets) internal onlyInitializing {\n        getVaultStorage().assets = _assets;\n    }\n\n    /// @notice Mint the cap token using an asset\n    /// @dev This contract must have approval to move asset from msg.sender\n    /// @param _asset Whitelisted asset to deposit\n    /// @param _amountIn Amount of asset to use in the minting\n    /// @param _minAmountOut Minimum amount to mint\n    /// @param _receiver Receiver of the minting\n    /// @param _deadline Deadline of the tx\n    function mint(address _asset, uint256 _amountIn, uint256 _minAmountOut, address _receiver, uint256 _deadline)\n        external\n        returns (uint256 amountOut)\n    {\n        amountOut = getMintAmount(_asset, _amountIn);\n        VaultLogic.mint(\n            getVaultStorage(),\n            MintBurnParams({\n                asset: _asset,\n                amountIn: _amountIn,\n                amountOut: amountOut,\n                minAmountOut: _minAmountOut,\n                receiver: _receiver,\n                deadline: _deadline\n            })\n        );\n        _mint(_receiver, amountOut);\n    }\n\n    /// @notice Burn the cap token for an asset\n    /// @dev Asset is withdrawn from the reserve or divested from the underlying vault\n    /// @param _asset Asset to withdraw\n    /// @param _amountIn Amount of cap token to burn\n    /// @param _minAmountOut Minimum amount out to receive\n    /// @param _receiver Receiver of the withdrawal\n    /// @param _deadline Deadline of the tx\n    function burn(address _asset, uint256 _amountIn, uint256 _minAmountOut, address _receiver, uint256 _deadline)\n        external\n        returns (uint256 amountOut)\n    {\n        amountOut = getBurnAmount(_asset, _amountIn);\n        divest(_asset, amountOut);\n        VaultLogic.burn(\n            getVaultStorage(),\n            MintBurnParams({\n                asset: _asset,\n                amountIn: _amountIn,\n                amountOut: amountOut,\n                minAmountOut: _minAmountOut,\n                receiver: _receiver,\n                deadline: _deadline\n            })\n        );\n        _burn(msg.sender, _amountIn);\n    }\n\n    /// @notice Redeem the Cap token for a bundle of assets\n    /// @dev Assets are withdrawn from the reserve or divested from the underlying vault\n    /// @param _amountIn Amount of Cap token to burn\n    /// @param _minAmountsOut Minimum amounts of assets to withdraw\n    /// @param _receiver Receiver of the withdrawal\n    /// @param _deadline Deadline of the tx\n    /// @return amountsOut Amount of assets withdrawn\n    function redeem(uint256 _amountIn, uint256[] calldata _minAmountsOut, address _receiver, uint256 _deadline)\n        external\n        returns (uint256[] memory amountsOut)\n    {\n        amountsOut = getRedeemAmount(_amountIn);\n        divestMany(assets(), amountsOut);\n        VaultLogic.redeem(\n            getVaultStorage(),\n            RedeemParams({\n                amountIn: _amountIn,\n                amountsOut: amountsOut,\n                minAmountsOut: _minAmountsOut,\n                receiver: _receiver,\n                deadline: _deadline\n            })\n        );\n        _burn(msg.sender, _amountIn);\n    }\n\n    /// @notice Borrow an asset\n    /// @dev Whitelisted agents can borrow any amount, LTV is handled by Agent contracts\n    /// @param _asset Asset to borrow\n    /// @param _amount Amount of asset to borrow\n    /// @param _receiver Receiver of the borrow\n    function borrow(address _asset, uint256 _amount, address _receiver) external checkAccess(this.borrow.selector) {\n        divest(_asset, _amount);\n        VaultLogic.borrow(getVaultStorage(), BorrowParams({ asset: _asset, amount: _amount, receiver: _receiver }));\n    }\n\n    /// @notice Repay an asset\n    /// @param _asset Asset to repay\n    /// @param _amount Amount of asset to repay\n    function repay(address _asset, uint256 _amount) external checkAccess(this.repay.selector) {\n        VaultLogic.repay(getVaultStorage(), RepayParams({ asset: _asset, amount: _amount }));\n    }\n\n    /// @notice Add an asset to the vault list\n    /// @param _asset Asset address\n    function addAsset(address _asset) external checkAccess(this.addAsset.selector) {\n        VaultLogic.addAsset(getVaultStorage(), _asset);\n    }\n\n    /// @notice Remove an asset from the vault list\n    /// @param _asset Asset address\n    function removeAsset(address _asset) external checkAccess(this.removeAsset.selector) {\n        VaultLogic.removeAsset(getVaultStorage(), _asset);\n    }\n\n    /// @notice Pause an asset\n    /// @param _asset Asset address\n    function pause(address _asset) external checkAccess(this.pause.selector) {\n        VaultLogic.pause(getVaultStorage(), _asset);\n    }\n\n    /// @notice Unpause an asset\n    /// @param _asset Asset address\n    function unpause(address _asset) external checkAccess(this.unpause.selector) {\n        VaultLogic.unpause(getVaultStorage(), _asset);\n    }\n\n    /// @notice Rescue an unsupported asset\n    /// @param _asset Asset to rescue\n    /// @param _receiver Receiver of the rescue\n    function rescueERC20(address _asset, address _receiver) external checkAccess(this.rescueERC20.selector) {\n        VaultLogic.rescueERC20(getVaultStorage(), _asset, _receiver);\n    }\n\n    /// @notice Get the list of assets supported by the vault\n    /// @return assetList List of assets\n    function assets() public view returns (address[] memory assetList) {\n        assetList = getVaultStorage().assets;\n    }\n\n    /// @notice Get the total supplies of an asset\n    /// @param _asset Asset address\n    /// @return totalSupply Total supply\n    function totalSupplies(address _asset) external view returns (uint256 totalSupply) {\n        totalSupply = getVaultStorage().totalSupplies[_asset];\n    }\n\n    /// @notice Get the total borrows of an asset\n    /// @param _asset Asset address\n    /// @return totalBorrow Total borrow\n    function totalBorrows(address _asset) external view returns (uint256 totalBorrow) {\n        totalBorrow = getVaultStorage().totalBorrows[_asset];\n    }\n\n    /// @notice Get the pause state of an asset\n    /// @param _asset Asset address\n    /// @return isPaused Pause state\n    function paused(address _asset) external view returns (bool isPaused) {\n        isPaused = getVaultStorage().paused[_asset];\n    }\n\n    /// @notice Available balance to borrow\n    /// @param _asset Asset to borrow\n    /// @return amount Amount available\n    function availableBalance(address _asset) external view returns (uint256 amount) {\n        VaultStorage storage $ = getVaultStorage();\n        amount = $.totalSupplies[_asset] - $.totalBorrows[_asset];\n    }\n\n    /// @notice Utilization rate of an asset\n    /// @dev Utilization scaled by 1e27\n    /// @param _asset Utilized asset\n    /// @return ratio Utilization ratio\n    function utilization(address _asset) external view returns (uint256 ratio) {\n        ratio = VaultLogic.utilization(getVaultStorage(), _asset);\n    }\n\n    /// @notice Up to date cumulative utilization index of an asset\n    /// @dev Utilization scaled by 1e27\n    /// @param _asset Utilized asset\n    /// @return index Utilization ratio index\n    function currentUtilizationIndex(address _asset) external view returns (uint256 index) {\n        index = VaultLogic.currentUtilizationIndex(getVaultStorage(), _asset);\n    }\n}\n",
        "NetworkMiddleware.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../../../access/Access.sol\";\nimport { IOracle } from \"../../../interfaces/IOracle.sol\";\nimport { IStakerRewards } from \"../../../interfaces/IStakerRewards.sol\";\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IBurnerRouter } from \"@symbioticfi/burners/src/interfaces/router/IBurnerRouter.sol\";\n\nimport { IMiddleware } from \"../../../interfaces/IMiddleware.sol\";\n\nimport { INetworkMiddleware } from \"../../../interfaces/INetworkMiddleware.sol\";\nimport { NetworkMiddlewareStorageUtils } from \"../../../storage/NetworkMiddlewareStorageUtils.sol\";\nimport { Subnetwork } from \"@symbioticfi/core/src/contracts/libraries/Subnetwork.sol\";\nimport { IEntity } from \"@symbioticfi/core/src/interfaces/common/IEntity.sol\";\nimport { IRegistry } from \"@symbioticfi/core/src/interfaces/common/IRegistry.sol\";\nimport { IBaseDelegator } from \"@symbioticfi/core/src/interfaces/delegator/IBaseDelegator.sol\";\nimport { ISlasher } from \"@symbioticfi/core/src/interfaces/slasher/ISlasher.sol\";\nimport { IVault } from \"@symbioticfi/core/src/interfaces/vault/IVault.sol\";\n\n/// @title Cap Symbiotic Network Middleware Contract\n/// @author Cap Labs\n/// @notice This contract manages the symbiotic collateral and slashing.\ncontract NetworkMiddleware is INetworkMiddleware, UUPSUpgradeable, Access, NetworkMiddlewareStorageUtils {\n    using SafeERC20 for IERC20;\n\n    /// @notice Initialize\n    /// @param _accessControl Access control address\n    /// @param _network Network address\n    /// @param _vaultRegistry Vault registry address\n    /// @param _oracle Oracle address\n    /// @param _requiredEpochDuration Required epoch duration in seconds\n    /// @param _feeAllowed Fee allowed to be charged on rewards by restakers\n    function initialize(\n        address _accessControl,\n        address _network,\n        address _vaultRegistry,\n        address _oracle,\n        uint48 _requiredEpochDuration,\n        uint256 _feeAllowed\n    ) external initializer {\n        __Access_init(_accessControl);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        $.network = _network;\n        $.vaultRegistry = _vaultRegistry;\n        $.oracle = _oracle;\n        $.requiredEpochDuration = _requiredEpochDuration;\n        $.feeAllowed = _feeAllowed;\n    }\n\n    /// @notice Register vault to be used as collateral within the CAP system\n    /// @param _vault Vault address\n    /// @param _agents Agents supported by the vault\n    function registerVault(address _vault, address _stakerRewarder, address[] calldata _agents)\n        external\n        checkAccess(this.registerVault.selector)\n    {\n        _verifyVault(_vault);\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        $.stakerRewarders[_vault] = _stakerRewarder;\n        for (uint256 i; i < _agents.length; ++i) {\n            $.vaults[_agents[i]].push(_vault);\n        }\n        emit VaultRegistered(_vault);\n    }\n\n    /// @notice Set fee allowed\n    /// @param _feeAllowed Fee allowed to be charged on rewards by restakers\n    function setFeeAllowed(uint256 _feeAllowed) external checkAccess(this.setFeeAllowed.selector) {\n        getNetworkMiddlewareStorage().feeAllowed = _feeAllowed;\n    }\n\n    /// @notice Slash delegation and send to recipient\n    /// @param _agent Agent address\n    /// @param _recipient Recipient of the slashed assets\n    /// @param _slashShare Percentage of delegation to slash encoded with 18 decimals\n    /// @param _timestamp Timestamp to slash at\n    function slash(address _agent, address _recipient, uint256 _slashShare, uint48 _timestamp)\n        external\n        checkAccess(this.slash.selector)\n    {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n\n        for (uint256 i; i < $.vaults[_agent].length; ++i) {\n            IVault vault = IVault($.vaults[_agent][i]);\n\n            (, uint256 totalSlashableCollateral) =\n                slashableCollateralByVault($.network, _agent, address(vault), $.oracle, _timestamp);\n            if (totalSlashableCollateral == 0) continue;\n\n            // Round up in favor of the liquidator\n            uint256 slashShareOfCollateral = (totalSlashableCollateral * _slashShare / 1e18) + 1;\n\n            // If the slash share is greater than the total slashable collateral, set it to the total slashable collateral\n            if (slashShareOfCollateral > totalSlashableCollateral) {\n                slashShareOfCollateral = totalSlashableCollateral;\n            }\n\n            ISlasher(vault.slasher()).slash(\n                subnetwork(_agent), _agent, slashShareOfCollateral, _timestamp, new bytes(0)\n            );\n\n            // TODO: the burner could be a non routing burner, could add hooks?\n            IBurnerRouter(vault.burner()).triggerTransfer(address(this));\n            IERC20(vault.collateral()).safeTransfer(_recipient, slashShareOfCollateral);\n\n            emit Slash(_agent, _recipient, slashShareOfCollateral);\n        }\n    }\n\n    /// @dev Get vault info\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @return burnerRouter The burner router contract\n    /// @return decimals The collateral token decimals\n    /// @return collateralPrice The collateral token price\n    function _getVaultInfo(address _network, address _agent, address _vault, address _oracle)\n        private\n        view\n        returns (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice)\n    {\n        burnerRouter = IBurnerRouter(IVault(_vault).burner());\n\n        // Check pending receivers\n        (address pendingReceiver,) = burnerRouter.pendingNetworkReceiver(_network);\n        if (pendingReceiver != address(0) && pendingReceiver != address(this)) {\n            return (IBurnerRouter(address(0)), 0, 0);\n        }\n\n        (pendingReceiver,) = burnerRouter.pendingOperatorNetworkReceiver(_network, _agent);\n        if (pendingReceiver != address(0) && pendingReceiver != address(this)) {\n            return (IBurnerRouter(address(0)), 0, 0);\n        }\n\n        address collateralAddress = IVault(_vault).collateral();\n        decimals = IERC20Metadata(collateralAddress).decimals();\n        (collateralPrice,) = IOracle(_oracle).getPrice(collateralAddress);\n    }\n\n    /// @notice Coverage of an agent by a specific vault at a given timestamp\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @param _timestamp Timestamp to check coverage at\n    /// @return collateralValue Coverage value in USD (8 decimals)\n    /// @return collateral Coverage amount in the vault's collateral token decimals\n    function coverageByVault(address _network, address _agent, address _vault, address _oracle, uint48 _timestamp)\n        public\n        view\n        returns (uint256 collateralValue, uint256 collateral)\n    {\n        (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice) =\n            _getVaultInfo(_network, _agent, _vault, _oracle);\n\n        if (address(burnerRouter) == address(0)) return (0, 0);\n\n        collateral = IBaseDelegator(IVault(_vault).delegator()).stakeAt(subnetwork(_agent), _agent, _timestamp, \"\");\n        collateralValue = collateral * collateralPrice / (10 ** decimals);\n    }\n\n    /// @notice Slashable collateral of an agent by a specific vault at a given timestamp\n    /// @param _network Network address\n    /// @param _agent Agent address\n    /// @param _vault Vault address\n    /// @param _oracle Oracle address\n    /// @param _timestamp Timestamp to check slashable collateral at\n    /// @return collateralValue Slashable collateral value in USD (8 decimals)\n    function slashableCollateralByVault(\n        address _network,\n        address _agent,\n        address _vault,\n        address _oracle,\n        uint48 _timestamp\n    ) public view returns (uint256 collateralValue, uint256 collateral) {\n        (IBurnerRouter burnerRouter, uint8 decimals, uint256 collateralPrice) =\n            _getVaultInfo(_network, _agent, _vault, _oracle);\n\n        if (address(burnerRouter) == address(0)) return (0, 0);\n\n        ISlasher slasher = ISlasher(IVault(_vault).slasher());\n        collateral = slasher.slashableStake(subnetwork(_agent), _agent, _timestamp, \"\");\n        collateralValue = collateral * collateralPrice / (10 ** decimals);\n    }\n\n    /// @notice Coverage of an agent by Symbiotic vaults\n    /// @param _agent Agent address\n    /// @return delegation Delegation amount in USD (8 decimals)\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        address[] memory _vaults = $.vaults[_agent];\n        address _network = $.network;\n        address _oracle = $.oracle;\n        uint48 _timestamp = uint48(block.timestamp);\n\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            (uint256 value,) = coverageByVault(_network, _agent, _vaults[i], _oracle, _timestamp);\n            delegation += value;\n        }\n    }\n\n    /// @notice Slashable collateral of an agent by Symbiotic vaults\n    /// @param _agent Agent address\n    /// @param _timestamp Timestamp to check slashable collateral at\n    /// @return _slashableCollateral Slashable collateral amount in USD (8 decimals)\n    function slashableCollateral(address _agent, uint48 _timestamp)\n        external\n        view\n        returns (uint256 _slashableCollateral)\n    {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        address[] memory _vaults = $.vaults[_agent];\n        address _network = $.network;\n        address _oracle = $.oracle;\n\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            (uint256 value,) = slashableCollateralByVault(_network, _agent, _vaults[i], _oracle, _timestamp);\n            _slashableCollateral += value;\n        }\n    }\n\n    /// @notice Subnetwork id\n    /// @dev Creates a collision resistant uint96 identifier by taking keccak256 hash of agent address\n    /// and using the first 96 bits of the hash\n    /// @param _agent Agent address\n    /// @return id Subnetwork identifier (first 96 bits of keccak256 hash of agent address)\n    function subnetworkIdentifier(address _agent) public pure returns (uint96 id) {\n        bytes32 hash = keccak256(abi.encodePacked(_agent));\n        id = uint96(uint256(hash)); // Takes first 96 bits of hash\n    }\n\n    /// @notice Subnetwork id concatenated with network address\n    /// @return id Subnetwork id\n    function subnetwork(address _agent) public view returns (bytes32 id) {\n        id = Subnetwork.subnetwork(getNetworkMiddlewareStorage().network, subnetworkIdentifier(_agent));\n    }\n\n    /// @notice Registered vaults for an agent\n    /// @param _agent Agent address\n    /// @return vaultAddresses Vault addresses\n    function vaults(address _agent) external view returns (address[] memory vaultAddresses) {\n        vaultAddresses = getNetworkMiddlewareStorage().vaults[_agent];\n    }\n\n    /// @dev Verify a vault has the required specifications\n    /// @param _vault Vault address\n    function _verifyVault(address _vault) internal view {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n\n        if (!IRegistry($.vaultRegistry).isEntity(_vault)) {\n            revert NotVault();\n        }\n\n        if (!IVault(_vault).isInitialized()) revert VaultNotInitialized();\n\n        uint48 vaultEpoch = IVault(_vault).epochDuration();\n        if (vaultEpoch < $.requiredEpochDuration) revert InvalidEpochDuration($.requiredEpochDuration, vaultEpoch);\n\n        address slasher = IVault(_vault).slasher();\n        uint64 slasherType = IEntity(slasher).TYPE();\n        if (slasher == address(0)) revert NoSlasher();\n        if (slasherType != uint64(INetworkMiddleware.SlasherType.INSTANT)) revert InvalidSlasher();\n\n        address burner = IVault(_vault).burner();\n        if (burner == address(0)) revert NoBurner();\n        address receiver = IBurnerRouter(burner).networkReceiver($.network);\n        if (receiver != address(this)) revert InvalidBurnerRouter();\n\n        address delegator = IVault(_vault).delegator();\n        uint64 delegatorType = IEntity(delegator).TYPE();\n        if (delegatorType != uint64(INetworkMiddleware.DelegatorType.NETWORK_RESTAKE)) revert InvalidDelegator();\n    }\n\n    /// @notice Distribute rewards accumulated by the agent borrowing\n    /// @param _agent Agent address\n    /// @param _token Token address\n    function distributeRewards(address _agent, address _token) external checkAccess(this.distributeRewards.selector) {\n        NetworkMiddlewareStorage storage $ = getNetworkMiddlewareStorage();\n        uint256 totalCollateralValue = coverage(_agent);\n        uint256 _amount = IERC20(_token).balanceOf(address(this));\n\n        // here, distribute proportionally to the collateral value of the vaults\n        address[] memory _vaults = $.vaults[_agent];\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            address vault = _vaults[i];\n            (uint256 collateralValue,) = coverageByVault($.network, _agent, vault, $.oracle, uint48(block.timestamp));\n            uint256 reward = _amount * collateralValue / totalCollateralValue;\n            address stakerRewarder = $.stakerRewarders[vault];\n            if (stakerRewarder == address(0)) revert NoStakerRewarder();\n\n            IERC20(_token).forceApprove(address(IStakerRewards(stakerRewarder)), reward);\n            IStakerRewards(stakerRewarder).distributeRewards(\n                $.network, _token, reward, abi.encode(uint48(block.timestamp - 1), $.feeAllowed, \"\", \"\")\n            );\n        }\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n",
        "VaultLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Vault for storing the backing for cTokens\n/// @author kexley, @capLabs\n/// @notice Tokens are supplied by cToken minters and borrowed by covered agents\n/// @dev Supplies, borrows and utilization rates are tracked. Interest rates should be computed and\n/// charged on the external contracts, only the principle amount is counted on this contract.\nlibrary VaultLogic {\n    using SafeERC20 for IERC20;\n\n    /// @dev Timestamp is past the deadline\n    error PastDeadline();\n\n    /// @dev Amount out is less than required\n    error Slippage(address asset, uint256 amountOut, uint256 minAmountOut);\n\n    /// @dev Paused assets cannot be supplied or borrowed\n    error AssetPaused(address asset);\n\n    /// @dev Only whitelisted assets can be supplied or borrowed\n    error AssetNotSupported(address asset);\n\n    /// @dev Asset is already listed\n    error AssetAlreadySupported(address asset);\n\n    /// @dev Only non-supported assets can be rescued\n    error AssetNotRescuable(address asset);\n\n    /// @dev Invalid min amounts out as they dont match the number of assets\n    error InvalidMinAmountsOut();\n\n    /// @dev Insufficient reserves\n    error InsufficientReserves(address asset, uint256 balanceBefore, uint256 amount);\n\n    /// @dev Cap token minted\n    event Mint(address indexed minter, address receiver, address indexed asset, uint256 amountIn, uint256 amountOut);\n\n    /// @dev Cap token burned\n    event Burn(address indexed burner, address receiver, address indexed asset, uint256 amountIn, uint256 amountOut);\n\n    /// @dev Cap token redeemed\n    event Redeem(address indexed redeemer, address receiver, uint256 amountIn, uint256[] amountsOut);\n\n    /// @dev Borrow made\n    event Borrow(address indexed borrower, address indexed asset, uint256 amount);\n\n    /// @dev Repayment made\n    event Repay(address indexed repayer, address indexed asset, uint256 amount);\n\n    /// @dev Add asset\n    event AddAsset(address asset);\n\n    /// @dev Remove asset\n    event RemoveAsset(address asset);\n\n    /// @dev Asset paused\n    event PauseAsset(address asset);\n\n    /// @dev Asset unpaused\n    event UnpauseAsset(address asset);\n\n    /// @dev Rescue unsupported ERC20 tokens\n    event RescueERC20(address asset, address receiver);\n\n    /// @dev Modifier to only allow supplies and borrows when not paused\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    modifier whenNotPaused(IVault.VaultStorage storage $, address _asset) {\n        _whenNotPaused($, _asset);\n        _;\n    }\n\n    /// @dev Modifier to update the utilization index\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    modifier updateIndex(IVault.VaultStorage storage $, address _asset) {\n        _updateIndex($, _asset);\n        _;\n    }\n\n    /// @notice Mint the cap token using an asset\n    /// @dev This contract must have approval to move asset from msg.sender\n    /// @param $ Vault storage pointer\n    /// @param params Mint parameters\n    function mint(IVault.VaultStorage storage $, IVault.MintBurnParams memory params)\n        external\n        whenNotPaused($, params.asset)\n        updateIndex($, params.asset)\n    {\n        if (params.deadline < block.timestamp) revert PastDeadline();\n        if (params.amountOut < params.minAmountOut) {\n            revert Slippage(address(this), params.amountOut, params.minAmountOut);\n        }\n\n        $.totalSupplies[params.asset] += params.amountIn;\n\n        IERC20(params.asset).safeTransferFrom(msg.sender, address(this), params.amountIn);\n\n        emit Mint(msg.sender, params.receiver, params.asset, params.amountIn, params.amountOut);\n    }\n\n    /// @notice Burn the cap token for an asset\n    /// @dev Can only withdraw up to the amount remaining on this contract\n    /// @param $ Vault storage pointer\n    /// @param params Burn parameters\n    function burn(IVault.VaultStorage storage $, IVault.MintBurnParams memory params)\n        external\n        updateIndex($, params.asset)\n    {\n        if (params.deadline < block.timestamp) revert PastDeadline();\n        if (params.amountOut < params.minAmountOut) {\n            revert Slippage(params.asset, params.amountOut, params.minAmountOut);\n        }\n\n        $.totalSupplies[params.asset] -= params.amountOut;\n\n        IERC20(params.asset).safeTransfer(params.receiver, params.amountOut);\n\n        emit Burn(msg.sender, params.receiver, params.asset, params.amountIn, params.amountOut);\n    }\n\n    /// @notice Redeem the Cap token for a bundle of assets\n    /// @dev Can only withdraw up to the amount remaining on this contract\n    /// @param $ Vault storage pointer\n    /// @param params Redeem parameters\n    function redeem(IVault.VaultStorage storage $, IVault.RedeemParams memory params) external {\n        if (params.amountsOut.length != $.assets.length) revert InvalidMinAmountsOut();\n        if (params.deadline < block.timestamp) revert PastDeadline();\n\n        address[] memory cachedAssets = $.assets;\n        for (uint256 i; i < cachedAssets.length; ++i) {\n            if (params.amountsOut[i] < params.minAmountsOut[i]) {\n                revert Slippage(cachedAssets[i], params.amountsOut[i], params.minAmountsOut[i]);\n            }\n            _updateIndex($, cachedAssets[i]);\n            $.totalSupplies[cachedAssets[i]] -= params.amountsOut[i];\n            IERC20(cachedAssets[i]).safeTransfer(params.receiver, params.amountsOut[i]);\n        }\n\n        emit Redeem(msg.sender, params.receiver, params.amountIn, params.amountsOut);\n    }\n\n    /// @notice Borrow an asset\n    /// @dev Whitelisted agents can borrow any amount, LTV is handled by Agent contracts\n    /// @param $ Vault storage pointer\n    /// @param params Borrow parameters\n    function borrow(IVault.VaultStorage storage $, IVault.BorrowParams memory params)\n        external\n        whenNotPaused($, params.asset)\n        updateIndex($, params.asset)\n    {\n        uint256 balanceBefore = IERC20(params.asset).balanceOf(address(this));\n        if (balanceBefore < params.amount) revert InsufficientReserves(params.asset, balanceBefore, params.amount);\n\n        $.totalBorrows[params.asset] += params.amount;\n        IERC20(params.asset).safeTransfer(params.receiver, params.amount);\n\n        emit Borrow(msg.sender, params.asset, params.amount);\n    }\n\n    /// @notice Repay an asset\n    /// @param $ Vault storage pointer\n    /// @param params Repay parameters\n    function repay(IVault.VaultStorage storage $, IVault.RepayParams memory params)\n        external\n        updateIndex($, params.asset)\n    {\n        $.totalBorrows[params.asset] -= params.amount;\n        IERC20(params.asset).safeTransferFrom(msg.sender, address(this), params.amount);\n\n        emit Repay(msg.sender, params.asset, params.amount);\n    }\n\n    /// @notice Add an asset to the vault list\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function addAsset(IVault.VaultStorage storage $, address _asset) external {\n        if (_listed($, _asset)) revert AssetAlreadySupported(_asset);\n\n        $.assets.push(_asset);\n        emit AddAsset(_asset);\n    }\n\n    /// @notice Remove an asset from the vault list\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function removeAsset(IVault.VaultStorage storage $, address _asset) external {\n        address[] memory cachedAssets = $.assets;\n        uint256 length = cachedAssets.length;\n        bool removed;\n        for (uint256 i; i < length; ++i) {\n            if (_asset == cachedAssets[i]) {\n                $.assets[i] = cachedAssets[length - 1];\n                $.assets.pop();\n                removed = true;\n                break;\n            }\n        }\n\n        if (!removed) revert AssetNotSupported(_asset);\n\n        emit RemoveAsset(_asset);\n    }\n\n    /// @notice Pause an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function pause(IVault.VaultStorage storage $, address _asset) external {\n        $.paused[_asset] = true;\n        emit PauseAsset(_asset);\n    }\n\n    /// @notice Unpause an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function unpause(IVault.VaultStorage storage $, address _asset) external {\n        $.paused[_asset] = false;\n        emit UnpauseAsset(_asset);\n    }\n\n    /// @notice Rescue an unsupported asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset to rescue\n    /// @param _receiver Receiver of the rescue\n    function rescueERC20(IVault.VaultStorage storage $, address _asset, address _receiver) external {\n        if (_listed($, _asset)) revert AssetNotRescuable(_asset);\n        IERC20(_asset).safeTransfer(_receiver, IERC20(_asset).balanceOf(address(this)));\n        emit RescueERC20(_asset, _receiver);\n    }\n\n    /// @notice Calculate the utilization ratio of an asset\n    /// @dev Returns the ratio of borrowed assets to total supply, scaled to ray (1e27)\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    /// @return ratio Utilization ratio in ray (1e27)\n    function utilization(IVault.VaultStorage storage $, address _asset) public view returns (uint256 ratio) {\n        ratio = $.totalSupplies[_asset] != 0 ? $.totalBorrows[_asset] * 1e27 / $.totalSupplies[_asset] : 0;\n    }\n\n    /// @notice Up to date cumulative utilization index of an asset\n    /// @dev Utilization and index are both scaled in ray (1e27)\n    /// @param $ Vault storage pointer\n    /// @param _asset Utilized asset\n    /// @return index Utilization ratio index in ray (1e27)\n    function currentUtilizationIndex(IVault.VaultStorage storage $, address _asset)\n        external\n        view\n        returns (uint256 index)\n    {\n        index = $.utilizationIndex[_asset] + (utilization($, _asset) * (block.timestamp - $.lastUpdate[_asset]));\n    }\n\n    /// @notice Validate that an asset is listed\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset to check\n    /// @return isListed Asset is listed or not\n    function _listed(IVault.VaultStorage storage $, address _asset) internal view returns (bool isListed) {\n        address[] memory cachedAssets = $.assets;\n        uint256 length = cachedAssets.length;\n        for (uint256 i; i < length; ++i) {\n            if (_asset == cachedAssets[i]) {\n                isListed = true;\n                break;\n            }\n        }\n    }\n\n    /// @dev Only allow supplies and borrows when not paused\n    /// @param $ Vault storage pointer\n    /// @param _asset Asset address\n    function _whenNotPaused(IVault.VaultStorage storage $, address _asset) private view {\n        if ($.paused[_asset]) revert AssetPaused(_asset);\n    }\n\n    /// @dev Update the cumulative utilization index of an asset\n    /// @param $ Vault storage pointer\n    /// @param _asset Utilized asset\n    function _updateIndex(IVault.VaultStorage storage $, address _asset) internal {\n        if (!_listed($, _asset)) revert AssetNotSupported(_asset);\n        $.utilizationIndex[_asset] += utilization($, _asset) * (block.timestamp - $.lastUpdate[_asset]);\n        $.lastUpdate[_asset] = block.timestamp;\n    }\n}\n",
        "VaultAdapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../../access/Access.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\nimport { IVaultAdapter } from \"../../interfaces/IVaultAdapter.sol\";\nimport { VaultAdapterStorageUtils } from \"../../storage/VaultAdapterStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Vault Adapter\n/// @author kexley, @capLabs\n/// @notice Market rates are sourced from the Vault\ncontract VaultAdapter is IVaultAdapter, UUPSUpgradeable, Access, VaultAdapterStorageUtils {\n    /// @notice Initialize the vault adapter with the access control\n    /// @param _accessControl Access control\n    function initialize(address _accessControl) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Fetch borrow rate for an asset from the Vault\n    /// @param _vault Vault address\n    /// @param _asset Asset to fetch rate for\n    /// @return latestAnswer Borrow rate\n    function rate(address _vault, address _asset) external returns (uint256 latestAnswer) {\n        VaultAdapterStorage storage $ = getVaultAdapterStorage();\n\n        uint256 elapsed;\n        uint256 utilization;\n        if (block.timestamp > $.utilizationData[_asset].lastUpdate) {\n            uint256 index = IVault(_vault).currentUtilizationIndex(_asset);\n            elapsed = block.timestamp - $.utilizationData[_asset].lastUpdate;\n\n            /// Use average utilization except on the first rate update\n            if (elapsed != block.timestamp) {\n                utilization = (index - $.utilizationData[_asset].index) / elapsed;\n            } else {\n                utilization = IVault(_vault).utilization(_asset);\n            }\n\n            $.utilizationData[_asset].index = index;\n            $.utilizationData[_asset].lastUpdate = block.timestamp;\n        } else {\n            utilization = IVault(_vault).utilization(_asset);\n        }\n\n        latestAnswer = _applySlopes(_asset, utilization, elapsed);\n    }\n\n    /// @notice Set utilization slopes for an asset\n    /// @param _asset Asset address\n    /// @param _slopes Slope data\n    function setSlopes(address _asset, SlopeData memory _slopes) external checkAccess(this.setSlopes.selector) {\n        getVaultAdapterStorage().slopeData[_asset] = _slopes;\n    }\n\n    /// @notice Set limits for the utilization multiplier\n    /// @param _maxMultiplier Maximum slope multiplier\n    /// @param _minMultiplier Minimum slope multiplier\n    /// @param _rate Rate at which the multiplier shifts\n    function setLimits(uint256 _maxMultiplier, uint256 _minMultiplier, uint256 _rate)\n        external\n        checkAccess(this.setLimits.selector)\n    {\n        VaultAdapterStorage storage $ = getVaultAdapterStorage();\n        $.maxMultiplier = _maxMultiplier;\n        $.minMultiplier = _minMultiplier;\n        $.rate = _rate;\n    }\n\n    /// @dev Interest is applied according to where on the slope the current utilization is and the\n    /// multiplier depends on the duration and distance the utilization is from the kink point.\n    /// All utilization values, kinks, and multipliers are in ray (1e27)\n    /// @param _asset Asset address\n    /// @param _utilization Utilization ratio in ray (1e27)\n    /// @param _elapsed Length of time at the utilization\n    /// @return interestRate Interest rate in ray (1e27)\n    function _applySlopes(address _asset, uint256 _utilization, uint256 _elapsed)\n        internal\n        returns (uint256 interestRate)\n    {\n        VaultAdapterStorage storage $ = getVaultAdapterStorage();\n        SlopeData memory slopes = $.slopeData[_asset];\n        if (_utilization > slopes.kink) {\n            uint256 excess = _utilization - slopes.kink;\n            $.utilizationData[_asset].utilizationMultiplier *=\n                (1e27 + (1e27 * excess / (1e27 - slopes.kink)) * (_elapsed * $.rate / 1e27));\n\n            if ($.utilizationData[_asset].utilizationMultiplier > $.maxMultiplier) {\n                $.utilizationData[_asset].utilizationMultiplier = $.maxMultiplier;\n            }\n\n            interestRate = (slopes.slope0 + (slopes.slope1 * excess / 1e27))\n                * $.utilizationData[_asset].utilizationMultiplier / 1e27;\n        } else {\n            $.utilizationData[_asset].utilizationMultiplier /=\n                (1e27 + (1e27 * (slopes.kink - _utilization) / slopes.kink) * (_elapsed * $.rate / 1e27));\n\n            if ($.utilizationData[_asset].utilizationMultiplier < $.minMultiplier) {\n                $.utilizationData[_asset].utilizationMultiplier = $.minMultiplier;\n            }\n\n            interestRate =\n                (slopes.slope0 * _utilization / slopes.kink) * $.utilizationData[_asset].utilizationMultiplier / 1e27;\n        }\n    }\n\n    /// @dev Only admin is allowed to upgrade implementation\n    function _authorizeUpgrade(address) internal view override checkAccess(bytes4(0)) { }\n}\n",
        "Minter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IMinter } from \"../interfaces/IMinter.sol\";\nimport { MinterStorageUtils } from \"../storage/MinterStorageUtils.sol\";\nimport { MinterLogic } from \"./libraries/MinterLogic.sol\";\n\n/// @title Minter/burner for cap tokens\n/// @author kexley, @capLabs\n/// @notice Cap tokens are minted or burned in exchange for collateral ratio of the backing tokens\n/// @dev Dynamic fees are applied according to the allocation of assets in the basket. Increasing\n/// the supply of a excessive asset or burning for an scarce asset will charge fees on a kinked\n/// slope. Redeem can be used to avoid these fees by burning for the current ratio of assets.\ncontract Minter is IMinter, Access, MinterStorageUtils {\n    /// @dev Initialize the minter\n    /// @param _accessControl Access control address\n    /// @param _oracle Oracle address\n    function __Minter_init(address _accessControl, address _oracle) internal onlyInitializing {\n        __Access_init(_accessControl);\n        __Minter_init_unchained(_oracle);\n    }\n\n    /// @dev Initialize unchained\n    /// @param _oracle Oracle address\n    function __Minter_init_unchained(address _oracle) internal onlyInitializing {\n        getMinterStorage().oracle = _oracle;\n    }\n\n    /// @notice Get the mint amount for a given asset\n    /// @param _asset Asset address\n    /// @param _amountIn Amount of asset to use\n    /// @return amountOut Amount minted\n    function getMintAmount(address _asset, uint256 _amountIn) public view returns (uint256 amountOut) {\n        amountOut =\n            MinterLogic.amountOut(getMinterStorage(), AmountOutParams({ mint: true, asset: _asset, amount: _amountIn }));\n    }\n\n    /// @notice Get the burn amount for a given asset\n    /// @param _asset Asset address to withdraw\n    /// @param _amountIn Amount of cap token to burn\n    /// @return amountOut Amount of the asset withdrawn\n    function getBurnAmount(address _asset, uint256 _amountIn) public view returns (uint256 amountOut) {\n        amountOut = MinterLogic.amountOut(\n            getMinterStorage(), AmountOutParams({ mint: false, asset: _asset, amount: _amountIn })\n        );\n    }\n\n    /// @notice Get the redeem amount\n    /// @param _amountIn Amount of cap token to burn\n    /// @return amountsOut Amounts of assets to be withdrawn\n    function getRedeemAmount(uint256 _amountIn) public view returns (uint256[] memory amountsOut) {\n        amountsOut = MinterLogic.redeemAmountOut(getMinterStorage(), RedeemAmountOutParams({ amount: _amountIn }));\n    }\n\n    /// @notice Set the allocation slopes and ratios for an asset\n    /// @param _asset Asset address\n    /// @param _feeData Fee slopes and ratios for the asset in the vault\n    function setFeeData(address _asset, FeeData calldata _feeData) external checkAccess(this.setFeeData.selector) {\n        getMinterStorage().fees[_asset] = _feeData;\n        emit SetFeeData(_asset, _feeData);\n    }\n\n    /// @notice Set the redeem fee\n    /// @param _redeemFee Redeem fee amount\n    function setRedeemFee(uint256 _redeemFee) external checkAccess(this.setRedeemFee.selector) {\n        getMinterStorage().redeemFee = _redeemFee;\n        emit SetRedeemFee(_redeemFee);\n    }\n}\n",
        "Lender.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { ILender } from \"../interfaces/ILender.sol\";\nimport { LenderStorageUtils } from \"../storage/LenderStorageUtils.sol\";\nimport { BorrowLogic } from \"./libraries/BorrowLogic.sol\";\nimport { LiquidationLogic } from \"./libraries/LiquidationLogic.sol\";\nimport { ReserveLogic } from \"./libraries/ReserveLogic.sol\";\nimport { ViewLogic } from \"./libraries/ViewLogic.sol\";\n\n/// @title Lender for covered agents\n/// @author kexley, @capLabs\n/// @notice Whitelisted tokens are borrowed and repaid from this contract by covered agents.\n/// @dev Borrow interest rates are calculated from the underlying utilization rates of the assets\n/// in the vaults.\ncontract Lender is ILender, UUPSUpgradeable, Access, LenderStorageUtils {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the lender\n    /// @param _accessControl Access control address\n    /// @param _delegation Delegation address\n    /// @param _oracle Oracle address\n    /// @param _targetHealth Target health after liquidations (scaled by 1e27)\n    /// @param _grace Grace period in seconds before an agent becomes liquidatable\n    /// @param _expiry Expiry period in seconds after which an agent cannot be liquidated until called again\n    /// @param _bonusCap Bonus cap for liquidations (scaled by 1e27)\n    /// @param _emergencyLiquidationThreshold Liquidation threshold below which grace periods are voided (scaled by 1e27)\n    function initialize(\n        address _accessControl,\n        address _delegation,\n        address _oracle,\n        uint256 _targetHealth,\n        uint256 _grace,\n        uint256 _expiry,\n        uint256 _bonusCap,\n        uint256 _emergencyLiquidationThreshold\n    ) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n\n        if (_delegation == address(0) || _oracle == address(0)) revert ZeroAddressNotValid();\n\n        // TODO: remove this\n        LenderStorage storage $ = getLenderStorage();\n        $.delegation = _delegation;\n        $.oracle = _oracle;\n        $.targetHealth = _targetHealth;\n        $.grace = _grace;\n        $.expiry = _expiry;\n        $.bonusCap = _bonusCap;\n        $.emergencyLiquidationThreshold = _emergencyLiquidationThreshold;\n    }\n\n    /// @notice Borrow an asset\n    /// @param _asset Asset to borrow\n    /// @param _amount Amount to borrow\n    /// @param _receiver Receiver of the borrowed asset\n    function borrow(address _asset, uint256 _amount, address _receiver) external {\n        BorrowLogic.borrow(\n            getLenderStorage(), BorrowParams({ agent: msg.sender, asset: _asset, amount: _amount, receiver: _receiver })\n        );\n    }\n\n    /// @notice Repay an asset\n    /// @param _asset Asset to repay\n    /// @param _amount Amount to repay\n    /// @param _agent Repay on behalf of another borrower\n    /// @return repaid Actual amount repaid\n    function repay(address _asset, uint256 _amount, address _agent) external returns (uint256 repaid) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        repaid = BorrowLogic.repay(\n            getLenderStorage(), RepayParams({ agent: _agent, asset: _asset, amount: _amount, caller: msg.sender })\n        );\n    }\n\n    /// @notice Realize interest for an asset\n    /// @param _asset Asset to realize interest for\n    /// @param _amount Amount of interest to realize (type(uint).max for all available interest)\n    /// @return actualRealized Actual amount realized\n    function realizeInterest(address _asset, uint256 _amount) external returns (uint256 actualRealized) {\n        actualRealized =\n            BorrowLogic.realizeInterest(getLenderStorage(), RealizeInterestParams({ asset: _asset, amount: _amount }));\n    }\n\n    /// @notice Calculate the maximum interest that can be realized\n    /// @param _asset Asset to calculate max realization for\n    /// @return _maxRealization Maximum interest that can be realized\n    function maxRealization(address _asset) external view returns (uint256 _maxRealization) {\n        _maxRealization = BorrowLogic.maxRealization(getLenderStorage(), _asset);\n    }\n\n    /// @notice Initiate liquidation of an agent when the health is below 1\n    /// @param _agent Agent address\n    function initiateLiquidation(address _agent) external {\n        LiquidationLogic.initiateLiquidation(getLenderStorage(), _agent);\n    }\n\n    /// @notice Cancel liquidation of an agent when the health is above 1\n    /// @param _agent Agent address\n    function cancelLiquidation(address _agent) external {\n        LiquidationLogic.cancelLiquidation(getLenderStorage(), _agent);\n    }\n\n    /// @notice Liquidate an agent when the health is below 1\n    /// @param _agent Agent address\n    /// @param _asset Asset to repay\n    /// @param _amount Amount of asset to repay on behalf of the agent\n    /// @param liquidatedValue Value of the liquidation returned to the liquidator\n    function liquidate(address _agent, address _asset, uint256 _amount) external returns (uint256 liquidatedValue) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        liquidatedValue = LiquidationLogic.liquidate(\n            getLenderStorage(), RepayParams({ agent: _agent, asset: _asset, amount: _amount, caller: msg.sender })\n        );\n    }\n\n    /// @notice Calculate the agent data\n    /// @param _agent Address of agent\n    /// @return totalDelegation Total delegation of an agent in USD, encoded with 8 decimals\n    /// @return totalDebt Total debt of an agent in USD, encoded with 8 decimals\n    /// @return ltv Loan to value ratio, encoded in ray (1e27)\n    /// @return liquidationThreshold Liquidation ratio of an agent, encoded in ray (1e27)\n    /// @return health Health status of an agent, encoded in ray (1e27)\n    function agent(address _agent)\n        external\n        view\n        returns (uint256 totalDelegation, uint256 totalDebt, uint256 ltv, uint256 liquidationThreshold, uint256 health)\n    {\n        (totalDelegation, totalDebt, ltv, liquidationThreshold, health) = ViewLogic.agent(getLenderStorage(), _agent);\n    }\n\n    /// @notice Calculate the maximum amount that can be borrowed for a given asset\n    /// @param _agent Agent address\n    /// @param _asset Asset to borrow\n    /// @return maxBorrowableAmount Maximum amount that can be borrowed in asset decimals\n    function maxBorrowable(address _agent, address _asset) external view returns (uint256 maxBorrowableAmount) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        maxBorrowableAmount = ViewLogic.maxBorrowable(getLenderStorage(), _agent, _asset);\n    }\n\n    /// @notice Calculate the maximum amount that can be liquidated for a given asset\n    /// @param _agent Agent address\n    /// @param _asset Asset to liquidate\n    /// @return maxLiquidatableAmount Maximum amount that can be liquidated in asset decimals\n    function maxLiquidatable(address _agent, address _asset) external view returns (uint256 maxLiquidatableAmount) {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        maxLiquidatableAmount = ViewLogic.maxLiquidatable(getLenderStorage(), _agent, _asset);\n    }\n\n    /// @notice Get the current debt balances for an agent for a specific asset\n    /// @param _agent Agent address to check debt for\n    /// @param _asset Asset to check debt for\n    /// @return principalDebt Principal debt amount in asset decimals\n    /// @return interestDebt Interest debt amount in asset decimals\n    /// @return restakerDebt Restaker debt amount in asset decimals\n    function debt(address _agent, address _asset)\n        external\n        view\n        returns (uint256 principalDebt, uint256 interestDebt, uint256 restakerDebt)\n    {\n        if (_agent == address(0) || _asset == address(0)) revert ZeroAddressNotValid();\n        (principalDebt, interestDebt, restakerDebt) = ViewLogic.debt(getLenderStorage(), _agent, _asset);\n    }\n\n    /// @notice Add an asset to the Lender\n    /// @param _params Parameters to add an asset\n    function addAsset(AddAssetParams calldata _params) external checkAccess(this.addAsset.selector) {\n        LenderStorage storage $ = getLenderStorage();\n        if (!ReserveLogic.addAsset($, _params)) ++$.reservesCount;\n    }\n\n    /// @notice Remove asset from lending when there is no borrows\n    /// @param _asset Asset address\n    function removeAsset(address _asset) external checkAccess(this.removeAsset.selector) {\n        if (_asset == address(0)) revert ZeroAddressNotValid();\n        ReserveLogic.removeAsset(getLenderStorage(), _asset);\n    }\n\n    /// @notice Pause an asset from being borrowed\n    /// @param _asset Asset address\n    /// @param _pause True if pausing or false if unpausing\n    function pauseAsset(address _asset, bool _pause) external checkAccess(this.pauseAsset.selector) {\n        if (_asset == address(0)) revert ZeroAddressNotValid();\n        ReserveLogic.pauseAsset(getLenderStorage(), _asset, _pause);\n    }\n\n    /// @notice The total number of reserves\n    /// @return count Number of reserves\n    function reservesCount() external view returns (uint256 count) {\n        count = getLenderStorage().reservesCount;\n    }\n\n    /// @notice The grace period duration\n    /// @return gracePeriod Grace period in seconds\n    function grace() external view returns (uint256 gracePeriod) {\n        gracePeriod = getLenderStorage().grace;\n    }\n\n    /// @notice The expiry period duration\n    /// @return expiryPeriod Expiry period in seconds\n    function expiry() external view returns (uint256 expiryPeriod) {\n        expiryPeriod = getLenderStorage().expiry;\n    }\n\n    /// @notice The target health factor\n    /// @return target Target health factor scaled to 1e27\n    function targetHealth() external view returns (uint256 target) {\n        target = getLenderStorage().targetHealth;\n    }\n\n    /// @notice The liquidation bonus cap\n    /// @return cap Bonus cap scaled to 1e27\n    function bonusCap() external view returns (uint256 cap) {\n        cap = getLenderStorage().bonusCap;\n    }\n\n    /// @notice The emergency liquidation threshold\n    /// @return threshold Threshold scaled to 1e27\n    function emergencyLiquidationThreshold() external view returns (uint256 threshold) {\n        threshold = getLenderStorage().emergencyLiquidationThreshold;\n    }\n\n    /// @notice The liquidation start time for an agent\n    /// @param _agent Address of the agent\n    /// @return startTime Timestamp when liquidation was initiated\n    function liquidationStart(address _agent) external view returns (uint256 startTime) {\n        startTime = getLenderStorage().liquidationStart[_agent];\n    }\n\n    /// @notice The reserve data for an asset\n    /// @param _asset Address of the asset\n    /// @return id Id of the reserve\n    /// @return vault Address of the vault\n    /// @return principalDebtToken Address of the principal debt token\n    /// @return restakerDebtToken Address of the restaker debt token\n    /// @return interestDebtToken Address of the interest debt token\n    /// @return interestReceiver Address of the interest receiver\n    /// @return decimals Decimals of the asset\n    /// @return paused True if the asset is paused, false otherwise\n    /// @return realizedInterest Realized interest of the asset\n    function reservesData(address _asset)\n        external\n        view\n        returns (\n            uint256 id,\n            address vault,\n            address principalDebtToken,\n            address restakerDebtToken,\n            address interestDebtToken,\n            address interestReceiver,\n            uint8 decimals,\n            bool paused,\n            uint256 realizedInterest\n        )\n    {\n        ReserveData storage reserve = getLenderStorage().reservesData[_asset];\n        id = reserve.id;\n        vault = reserve.vault;\n        principalDebtToken = reserve.principalDebtToken;\n        restakerDebtToken = reserve.restakerDebtToken;\n        interestDebtToken = reserve.interestDebtToken;\n        interestReceiver = reserve.interestReceiver;\n        decimals = reserve.decimals;\n        paused = reserve.paused;\n        realizedInterest = reserve.realizedInterest;\n    }\n\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n",
        "Delegation.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IDelegation } from \"../interfaces/IDelegation.sol\";\nimport { INetworkMiddleware } from \"../interfaces/INetworkMiddleware.sol\";\n\nimport { IRestakerRewardReceiver } from \"../interfaces/IRestakerRewardReceiver.sol\";\n\nimport { DelegationStorageUtils } from \"../storage/DelegationStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Cap Delegation Contract\n/// @author Cap Labs\n/// @notice This contract manages delegation and slashing.\ncontract Delegation is IDelegation, UUPSUpgradeable, Access, DelegationStorageUtils {\n    using SafeERC20 for IERC20;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract\n    /// @param _accessControl Access control address\n    /// @param _oracle Oracle address\n    /// @param _epochDuration Epoch duration in seconds\n    function initialize(address _accessControl, address _oracle, uint256 _epochDuration) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        DelegationStorage storage $ = getDelegationStorage();\n        $.oracle = _oracle;\n        $.epochDuration = _epochDuration;\n    }\n\n    /// @notice How much global delegation we have in the system\n    /// @return delegation Delegation in USD\n    function globalDelegation() external view returns (uint256 delegation) {\n        DelegationStorage storage $ = getDelegationStorage();\n        for (uint i; i < $.agents.length; ++i) {\n            delegation += coverage($.agents[i]);\n        }\n    }\n\n    /// @notice Get the epoch duration\n    /// @return duration Epoch duration in seconds\n    function epochDuration() external view returns (uint256 duration) {\n        DelegationStorage storage $ = getDelegationStorage();\n        duration = $.epochDuration;\n    }\n\n    /// @notice Get the current epoch\n    /// @return currentEpoch Current epoch\n    function epoch() public view returns (uint256 currentEpoch) {\n        DelegationStorage storage $ = getDelegationStorage();\n        currentEpoch = block.timestamp / $.epochDuration;\n    }\n\n    /// @notice Get the timestamp that is most recent between the last borrow and the epoch -1\n    /// @param _agent The agent address\n    /// @return _slashTimestamp Timestamp that is most recent between the last borrow and the epoch -1\n    function slashTimestamp(address _agent) public view returns (uint48 _slashTimestamp) {\n        DelegationStorage storage $ = getDelegationStorage();\n        _slashTimestamp = uint48(Math.max((epoch() - 1) * $.epochDuration, $.agentData[_agent].lastBorrow));\n    }\n\n    /// @notice How much delegation and agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return delegation Amount in USD (8 decimals) that a agent has provided as delegation from the delegators\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        DelegationStorage storage $ = getDelegationStorage();\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            delegation += coverageByNetwork(_agent, $.networks[_agent][i]);\n        }\n    }\n\n    /// @notice How much slashable coverage an agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return _slashableCollateral Amount in USD (8 decimals) that a agent has provided as slashable collateral from the delegators\n    function slashableCollateral(address _agent) public view returns (uint256 _slashableCollateral) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            _slashableCollateral +=\n                INetworkMiddleware($.networks[_agent][i]).slashableCollateral(_agent, _slashTimestamp);\n        }\n    }\n\n    /// @notice How much delegation and agent has available to back their borrows\n    /// @param _agent The agent addres\n    /// @param _network The network covering the agent\n    /// @return delegation Amount in USD that a agent has as delegation from the networks, encoded with 8 decimals\n    function coverageByNetwork(address _agent, address _network) public view returns (uint256 delegation) {\n        delegation = INetworkMiddleware(_network).coverage(_agent);\n    }\n\n    /// @notice Slashable collateral of an agent by a specific network\n    /// @param _agent Agent address\n    /// @param _network Network address\n    /// @return _slashableCollateral Slashable collateral amount in USD (8 decimals)\n    function slashableCollateralByNetwork(address _agent, address _network)\n        public\n        view\n        returns (uint256 _slashableCollateral)\n    {\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n        _slashableCollateral = INetworkMiddleware(_network).slashableCollateral(_agent, _slashTimestamp);\n    }\n\n    /// @notice Fetch active network addresses\n    /// @param _agent Agent address\n    /// @return networkAddresses network addresses\n    function networks(address _agent) external view returns (address[] memory networkAddresses) {\n        networkAddresses = getDelegationStorage().networks[_agent];\n    }\n\n    /// @notice Fetch active agent addresses\n    /// @return agentAddresses Agent addresses\n    function agents() external view returns (address[] memory agentAddresses) {\n        agentAddresses = getDelegationStorage().agents;\n    }\n\n    /// @notice The LTV of a specific agent\n    /// @param _agent Agent who we are querying\n    /// @return currentLtv Loan to value ratio of the agent\n    function ltv(address _agent) external view returns (uint256 currentLtv) {\n        currentLtv = getDelegationStorage().agentData[_agent].ltv;\n    }\n\n    /// @notice Liquidation threshold of the agent\n    /// @param _agent Agent who we are querying\n    /// @return lt Liquidation threshold of the agent\n    function liquidationThreshold(address _agent) external view returns (uint256 lt) {\n        lt = getDelegationStorage().agentData[_agent].liquidationThreshold;\n    }\n\n    /// @notice The slash function. Calls the underlying networks to slash the delegated capital\n    /// @dev Called only by the lender during liquidation\n    /// @param _agent The agent who is unhealthy\n    /// @param _liquidator The liquidator who receives the funds\n    /// @param _amount The USD value of the delegation needed to cover the debt\n    function slash(address _agent, address _liquidator, uint256 _amount) external checkAccess(this.slash.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n\n        // Calculate each network's proportion of total delegation\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            address network = $.networks[_agent][i];\n            uint256 networkSlashableCollateral =\n                INetworkMiddleware(network).slashableCollateral(_agent, _slashTimestamp);\n            if (networkSlashableCollateral == 0) continue;\n\n            // Calculate this network's share of the total amount to slash\n            uint256 networkSlash = _amount * 1e18 / networkSlashableCollateral;\n            INetworkMiddleware(network).slash(_agent, _liquidator, networkSlash, _slashTimestamp);\n            emit SlashNetwork(network, networkSlash);\n        }\n    }\n\n    /// @notice Distribute rewards to networks covering an agent proportionally to their coverage\n    /// @param _agent The agent address\n    /// @param _asset The reward token address\n    function distributeRewards(address _agent, address _asset) external {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint256 _amount = IERC20(_asset).balanceOf(address(this));\n\n        uint256 totalCoverage = coverage(_agent);\n        // here we cannot revert because the agent might not have any coverage\n        // in case we are liquidating the current agent due to 0 coverage\n        if (totalCoverage == 0) return;\n\n        // Distribute to each network based on their coverage proportion\n        for (uint i; i < $.networks[_agent].length; ++i) {\n            address network = $.networks[_agent][i];\n            uint256 networkCoverage = coverageByNetwork(_agent, network);\n            if (networkCoverage == 0) continue;\n\n            uint256 networkReward = _amount * networkCoverage / totalCoverage;\n            IERC20(_asset).safeTransfer(network, networkReward);\n            INetworkMiddleware(network).distributeRewards(_agent, _asset);\n            emit NetworkReward(network, _asset, networkReward);\n        }\n\n        emit DistributeReward(_agent, _asset, _amount);\n    }\n\n    /// @notice Set the last borrow timestamp for an agent\n    /// @param _agent Agent address\n    function setLastBorrow(address _agent) external checkAccess(this.setLastBorrow.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        $.agentData[_agent].lastBorrow = block.timestamp;\n    }\n\n    /// @notice Add agent to be delegated to\n    /// @param _agent Agent address\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function addAgent(address _agent, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.addAgent.selector)\n    {\n        // if liquidation threshold or ltv is greater than 100%, agent\n        // could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv > 1e27) revert InvalidLtv();\n\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // If the agent already exists, we revert\n        if ($.agentData[_agent].exists) revert DuplicateAgent();\n\n        $.agents.push(_agent);\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        $.agentData[_agent].exists = true;\n        emit AddAgent(_agent, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Modify an agents config only callable by the operator\n    /// @param _agent the agent to modify\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function modifyAgent(address _agent, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.modifyAgent.selector)\n    {\n        // if liquidation threshold or ltv is greater than 100%, agent\n        // could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv > 1e27) revert InvalidLtv();\n\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // Check that the agent exists\n        if (!$.agentData[_agent].exists) revert AgentDoesNotExist();\n\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        emit ModifyAgent(_agent, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Register a new network\n    /// @param _agent Agent address\n    /// @param _network Network address\n    function registerNetwork(address _agent, address _network) external checkAccess(this.registerNetwork.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // Check for duplicates\n        if ($.networkExistsForAgent[_agent][_network]) revert DuplicateNetwork();\n\n        $.networks[_agent].push(_network);\n        $.networkExistsForAgent[_agent][_network] = true;\n        emit RegisterNetwork(_agent, _network);\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n",
        "StakedCap.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IStakedCap } from \"../interfaces/IStakedCap.sol\";\nimport { StakedCapStorageUtils } from \"../storage/StakedCapStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ERC20PermitUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {\n    ERC20Upgradeable,\n    ERC4626Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Staked Cap Token\n/// @author kexley, @capLabs\n/// @notice Slow releasing yield-bearing token that distributes the yield accrued from agents\n/// borrowing from the underlying assets.\n/// @dev Calling notify permissionlessly will start the linear unlock\ncontract StakedCap is\n    IStakedCap,\n    UUPSUpgradeable,\n    ERC4626Upgradeable,\n    ERC20PermitUpgradeable,\n    Access,\n    StakedCapStorageUtils\n{\n    /// @dev Disable initializers on the implementation\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the staked cap token by matching the name and symbol of the underlying\n    /// @param _accessControl Address of the access control\n    /// @param _asset Address of the cap token\n    /// @param _lockDuration Duration in seconds for profit locking\n    function initialize(address _accessControl, address _asset, uint256 _lockDuration) external initializer {\n        string memory _name = string.concat(\"s\", IERC20Metadata(_asset).name());\n        string memory _symbol = string.concat(\"s\", IERC20Metadata(_asset).symbol());\n\n        __ERC4626_init(IERC20(_asset));\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        getStakedCapStorage().lockDuration = _lockDuration;\n    }\n\n    /// @notice Override the decimals function to match underlying decimals\n    /// @return _decimals Decimals of the staked cap token\n    function decimals() public view override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8 _decimals) {\n        _decimals = ERC4626Upgradeable.decimals();\n    }\n\n    /// @notice Notify the yield to start vesting\n    function notify() external {\n        uint256 total = IERC20(asset()).balanceOf(address(this));\n        StakedCapStorage storage $ = getStakedCapStorage();\n        if (total > $.storedTotal) {\n            uint256 diff = total - $.storedTotal;\n            $.totalLocked = lockedProfit() + diff;\n            $.storedTotal = total;\n            $.lastNotify = block.timestamp;\n\n            emit Notify(msg.sender, diff);\n        }\n    }\n\n    /// @notice Remaining locked profit after a notification\n    /// @return locked Amount remaining to be vested\n    function lockedProfit() public view returns (uint256 locked) {\n        StakedCapStorage storage $ = getStakedCapStorage();\n        if ($.lockDuration == 0) return 0;\n        uint256 elapsed = block.timestamp - $.lastNotify;\n        uint256 remaining = elapsed < $.lockDuration ? $.lockDuration - elapsed : 0;\n        locked = $.totalLocked * remaining / $.lockDuration;\n    }\n\n    /// @notice Total vested cap tokens on this contract\n    /// @return total Total amount of vested cap tokens\n    function totalAssets() public view override returns (uint256 total) {\n        total = getStakedCapStorage().storedTotal - lockedProfit();\n    }\n\n    /// @dev Overridden to update the total assets including unvested tokens\n    /// @param _caller Caller of the deposit\n    /// @param _receiver Receiver of the staked cap tokens\n    /// @param _assets Amount of cap tokens to pull from the caller\n    /// @param _shares Amount of staked cap tokens to send to receiver\n    function _deposit(address _caller, address _receiver, uint256 _assets, uint256 _shares) internal override {\n        super._deposit(_caller, _receiver, _assets, _shares);\n        getStakedCapStorage().storedTotal += _assets;\n    }\n\n    /// @dev Overridden to reduce the total assets including unvested tokens\n    /// @param _caller Caller of the withdrawal\n    /// @param _receiver Receiver of the cap tokens\n    /// @param _owner Owner of the staked cap tokens being burnt\n    /// @param _assets Amount of cap tokens to send to the receiver\n    /// @param _shares Amount of staked cap tokens to burn from the owner\n    function _withdraw(address _caller, address _receiver, address _owner, uint256 _assets, uint256 _shares)\n        internal\n        override\n    {\n        super._withdraw(_caller, _receiver, _owner, _assets, _shares);\n        getStakedCapStorage().storedTotal -= _assets;\n    }\n\n    /// @dev Only admin can upgrade implementation\n    function _authorizeUpgrade(address) internal view override checkAccess(bytes4(0)) { }\n}\n",
        "Oracle.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { PriceOracle } from \"./PriceOracle.sol\";\nimport { RateOracle } from \"./RateOracle.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Oracle\n/// @author kexley, @capLabs\n/// @notice Price and Rate oracles are unified\ncontract Oracle is IOracle, UUPSUpgradeable, Access, PriceOracle, RateOracle {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the oracle with the access control\n    /// @param _accessControl Access control\n    /// @param _staleness Staleness period in seconds for asset prices\n    function initialize(address _accessControl, uint256 _staleness) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        __PriceOracle_init_unchained(_staleness);\n        __RateOracle_init_unchained();\n    }\n\n    /// @dev Only admin is allowed to upgrade implementation\n    function _authorizeUpgrade(address) internal view override checkAccess(bytes4(0)) { }\n}\n",
        "FractionalReserveLogic.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { IFractionalReserve } from \"../../interfaces/IFractionalReserve.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Fractional Reserve Logic\n/// @author kexley, @capLabs\n/// @notice Idle capital is put to work in fractional reserve vaults and can be recalled when\n/// withdrawing, redeeming or borrowing.\nlibrary FractionalReserveLogic {\n    using SafeERC20 for IERC20;\n\n    /// @notice Invest unborrowed capital in a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    function invest(IFractionalReserve.FractionalReserveStorage storage $, address _asset) external {\n        uint256 assetBalance = IERC20(_asset).balanceOf(address(this));\n        uint256 reserveBalance = $.reserve[_asset];\n\n        if (assetBalance > reserveBalance) {\n            uint256 investAmount = assetBalance - reserveBalance;\n            $.loaned[_asset] += investAmount;\n            IERC20(_asset).forceApprove($.vault[_asset], investAmount);\n            IERC4626($.vault[_asset]).deposit(investAmount, address(this));\n        }\n    }\n\n    /// @notice Divest all from a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    function divest(IFractionalReserve.FractionalReserveStorage storage $, address _asset) external {\n        if ($.vault[_asset] != address(0)) {\n            uint256 loanedAssets = $.loaned[_asset];\n            $.loaned[_asset] = 0;\n\n            uint256 vaultBalance = IERC20($.vault[_asset]).balanceOf(address(this));\n            if (vaultBalance > 0) {\n                uint256 redeemedAssets = IERC4626($.vault[_asset]).redeem(vaultBalance, address(this), address(this));\n                if (redeemedAssets > loanedAssets) {\n                    IERC20(_asset).safeTransfer($.feeAuction, redeemedAssets - loanedAssets);\n                }\n            }\n        }\n    }\n\n    /// @notice Divest capital from a fractional reserve vault when not enough funds are held in reserve\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @param _withdrawAmount Amount to withdraw to fulfil\n    function divest(IFractionalReserve.FractionalReserveStorage storage $, address _asset, uint256 _withdrawAmount)\n        external\n    {\n        if ($.vault[_asset] != address(0)) {\n            uint256 assetBalance = IERC20(_asset).balanceOf(address(this));\n\n            if (_withdrawAmount > assetBalance) {\n                /// Divest both the withdrawal amount and the buffer reserve for later withdrawals\n                uint256 divestAmount = _withdrawAmount + $.reserve[_asset] - assetBalance;\n                if (divestAmount > $.loaned[_asset]) divestAmount = $.loaned[_asset];\n                if (divestAmount > 0) {\n                    $.loaned[_asset] -= divestAmount;\n                    IERC4626($.vault[_asset]).withdraw(divestAmount, address(this), address(this));\n                }\n            }\n        }\n    }\n\n    /// @notice Set the fractional reserve vault for an asset\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @param _vault Fractional reserve vault\n    function setFractionalReserveVault(\n        IFractionalReserve.FractionalReserveStorage storage $,\n        address _asset,\n        address _vault\n    ) external {\n        $.vault[_asset] = _vault;\n    }\n\n    /// @notice Set the reserve level for an asset\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @param _reserve Reserve level in asset decimals\n    function setReserve(IFractionalReserve.FractionalReserveStorage storage $, address _asset, uint256 _reserve)\n        external\n    {\n        $.reserve[_asset] = _reserve;\n    }\n\n    /// @notice Realize interest from a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    function realizeInterest(IFractionalReserve.FractionalReserveStorage storage $, address _asset) external {\n        IERC4626($.vault[_asset]).withdraw(claimableInterest($, _asset), $.feeAuction, address(this));\n    }\n\n    /// @notice Interest from a fractional reserve vault\n    /// @param $ Storage pointer\n    /// @param _asset Asset address\n    /// @return interest Claimable amount of asset\n    function claimableInterest(IFractionalReserve.FractionalReserveStorage storage $, address _asset)\n        public\n        view\n        returns (uint256 interest)\n    {\n        uint256 vaultShares = IERC4626($.vault[_asset]).balanceOf(address(this));\n        uint256 vaultAssets = IERC4626($.vault[_asset]).convertToAssets(vaultShares);\n        interest = vaultAssets > $.loaned[_asset] ? vaultAssets - $.loaned[_asset] : 0;\n    }\n}\n"
    }
}