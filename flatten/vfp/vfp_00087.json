{
    "vfp_id": "vfp_00087",
    "project_name": "cantina_sky_jul2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ]
            },
            "title": "Deployment scripts set mintRecipients (for CCTP bridging) but no LayerZero recipients",
            "description": "The deployment initialization scripts configure mintRecipients for CCTP bridging but fail to set corresponding LayerZero recipients using setLayerZeroRecipient. This creates an inconsistency in bridge configuration, potentially leaving the system unable to receive tokens via LayerZero even though CCTP is properly configured. The root cause is an omission in the deployment logic. An attacker cannot directly exploit this, but it could lead to operational issues where LayerZero deposits fail or are blocked, resulting in a partial denial of service for users relying on that bridge. The impact is reduced functionality and potential user fund lockups if LayerZero is a primary bridge method.\n",
            "severity": "Informational",
            "location": [
                "MainnetControllerInit.sol#L155-L157"
            ],
            "files": [
                "spark-alm-controller/deploy/MainnetControllerInit.sol"
            ]
        }
    ],
    "affected_files": {
        "MainnetControllerInit.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { MainnetController } from \"../src/MainnetController.sol\";\n\nimport { IALMProxy }   from \"../src/interfaces/IALMProxy.sol\";\nimport { IRateLimits } from \"../src/interfaces/IRateLimits.sol\";\n\nimport { ControllerInstance } from \"./ControllerInstance.sol\";\n\ninterface IBufferLike {\n    function approve(address, address, uint256) external;\n}\n\ninterface IPSMLike {\n    function kiss(address) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function rely(address) external;\n}\n\nlibrary MainnetControllerInit {\n\n    /**********************************************************************************************/\n    /*** Structs and constants                                                                  ***/\n    /**********************************************************************************************/\n\n    struct CheckAddressParams {\n        address admin;\n        address proxy;\n        address rateLimits;\n        address vault;\n        address psm;\n        address daiUsds;\n        address cctp;\n    }\n\n    struct ConfigAddressParams {\n        address   freezer;\n        address[] relayers;\n        address   oldController;\n    }\n\n    struct MintRecipient {\n        uint32  domain;\n        bytes32 mintRecipient;\n    }\n\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**********************************************************************************************/\n    /*** Internal library functions                                                             ***/\n    /**********************************************************************************************/\n\n    function initAlmSystem(\n        address vault,\n        address usds,\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        internal\n    {\n        // Step 1: Do sanity checks outside of the controller\n\n        require(IALMProxy(controllerInst.almProxy).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin),     \"MainnetControllerInit/incorrect-admin-almProxy\");\n        require(IRateLimits(controllerInst.rateLimits).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"MainnetControllerInit/incorrect-admin-rateLimits\");\n\n        // Step 2: Initialize the controller\n\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients);\n\n        // Step 3: Configure almProxy within the allocation system\n\n        require(vault == checkAddresses.vault, \"MainnetControllerInit/incorrect-vault\");\n\n        IVaultLike(vault).rely(controllerInst.almProxy);\n        IBufferLike(IVaultLike(vault).buffer()).approve(usds, controllerInst.almProxy, type(uint256).max);\n    }\n\n    function upgradeController(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        internal\n    {\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients);\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        require(configAddresses.oldController != address(0), \"MainnetControllerInit/old-controller-zero-address\");\n\n        require(almProxy.hasRole(almProxy.CONTROLLER(), configAddresses.oldController),     \"MainnetControllerInit/old-controller-not-almProxy-controller\");\n        require(rateLimits.hasRole(rateLimits.CONTROLLER(), configAddresses.oldController), \"MainnetControllerInit/old-controller-not-rateLimits-controller\");\n\n        almProxy.revokeRole(almProxy.CONTROLLER(), configAddresses.oldController);\n        rateLimits.revokeRole(rateLimits.CONTROLLER(), configAddresses.oldController);\n    }\n\n    function pauseProxyInitAlmSystem(address psm, address almProxy) internal {\n        IPSMLike(psm).kiss(almProxy);  // To allow using no fee functionality\n    }\n\n    /**********************************************************************************************/\n    /*** Private helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    function _initController(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        private\n    {\n        // Step 1: Perform controller sanity checks\n\n        MainnetController newController = MainnetController(controllerInst.controller);\n\n        require(newController.hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"MainnetControllerInit/incorrect-admin-controller\");\n\n        require(address(newController.proxy())      == controllerInst.almProxy,   \"MainnetControllerInit/incorrect-almProxy\");\n        require(address(newController.rateLimits()) == controllerInst.rateLimits, \"MainnetControllerInit/incorrect-rateLimits\");\n\n        require(address(newController.vault())   == checkAddresses.vault,   \"MainnetControllerInit/incorrect-vault\");\n        require(address(newController.psm())     == checkAddresses.psm,     \"MainnetControllerInit/incorrect-psm\");\n        require(address(newController.daiUsds()) == checkAddresses.daiUsds, \"MainnetControllerInit/incorrect-daiUsds\");\n        require(address(newController.cctp())    == checkAddresses.cctp,    \"MainnetControllerInit/incorrect-cctp\");\n\n        require(newController.psmTo18ConversionFactor() == 1e12, \"MainnetControllerInit/incorrect-psmTo18ConversionFactor\");\n\n        require(configAddresses.oldController != address(newController), \"MainnetControllerInit/old-controller-is-new-controller\");\n\n        // Step 2: Configure ACL permissions controller, almProxy, and rateLimits\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        almProxy.grantRole(almProxy.CONTROLLER(),        address(newController));\n        newController.grantRole(newController.FREEZER(), configAddresses.freezer);\n        rateLimits.grantRole(rateLimits.CONTROLLER(),    address(newController));\n\n        for (uint256 i; i < configAddresses.relayers.length; ++i) {\n            newController.grantRole(newController.RELAYER(), configAddresses.relayers[i]);\n        }\n\n        // Step 3: Configure the mint recipients on other domains\n\n        for (uint256 i; i < mintRecipients.length; ++i) {\n            newController.setMintRecipient(mintRecipients[i].domain, mintRecipients[i].mintRecipient);\n        }\n    }\n\n}\n"
    }
}