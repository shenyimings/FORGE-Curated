{
    "vfp_id": "vfp_00160",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Single Emissary Configuration Allows Users to Set Emissaries for Others",
            "description": "The Emissary role allows a designated individual to authorize claims on behalf of a sponsor. However, due to incorrect memory management in the `_getEmissaryConfig` function, the storage slot computation omits the sponsor's address and relies only on `_EMISSARY_SCOPE` and `lockTag`. This causes all users sharing the same `lockTag` to share the same emissary configuration.\nThe root cause is a memory overwrite during slot calculation, which fails to isolate per-user configurations. An attacker can exploit this by setting a malicious emissary for a shared `lockTag`, which will apply to all users under that tag.\nThis allows the attacker to bypass proper sponsor authorization and approve fraudulent claims on behalf of other users. The impact includes unauthorized control over claim processing, potentially leading to loss of funds or unauthorized transfers for affected sponsors.\n",
            "severity": "High",
            "location": [
                "EmissaryLib.sol::_getEmissaryConfig#65"
            ],
            "files": [
                "the-compact/src/lib/EmissaryLib.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "State Variable Visibility Not Explicitly Declared",
            "description": "The `NOT_SCHEDULED` constant in `EmissaryLib.sol` does not explicitly declare its visibility, relying on Solidity's default `internal` visibility. While functionally correct, this practice reduces code clarity and may lead to confusion for auditors or developers unfamiliar with Solidity defaults. Explicitly declaring visibility (e.g., `internal constant`) improves readability and ensures consistency across the codebase. This is a minor issue but aligns with best practices for secure and maintainable smart contract development.\n",
            "severity": "Informational",
            "location": [
                "EmissaryLib.sol::NOT_SCHEDULED#49"
            ],
            "files": [
                "the-compact/src/lib/EmissaryLib.sol"
            ]
        }
    ],
    "affected_files": {
        "EmissaryLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IdLib } from \"./IdLib.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { EmissaryConfig, EmissaryStatus } from \"../types/EmissaryStatus.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IEmissary } from \"../interfaces/IEmissary.sol\";\n\n/**\n * @title EmissaryLib\n * @notice This library manages the assignment and verification of emissaries for sponsors\n * within the system. An emissary is an address that can verify claims on behalf of a sponsor.\n * The library enforces security constraints and scheduling rules to ensure proper delegation.\n *\n * @dev The library uses a storage-efficient design with a single storage slot for all emissary\n * configurations, using mappings to organize data by sponsor and allocator ID. This allows for\n * efficient storage and access while maintaining data isolation between different sponsors.\n *\n * Key Components:\n * - EmissarySlot: Storage structure that maps sponsors to their allocator ID configurations\n * - EmissaryConfig: Configuration data for each emissary assignment, including reset periods\n * - Assignment scheduling: Enforces cooldown periods between assignments to prevent abuse\n * - Verification: Delegates claim verification to the assigned emissary contract\n *\n * Security Features:\n * - Timelock mechanism for reassignment to prevent rapid succession of emissaries\n * - Clear state management with Disabled/Enabled/Scheduled statuses\n * - Storage cleanup when emissaries are removed\n */\nlibrary EmissaryLib {\n    using IdLib for bytes12;\n    using IdLib for address;\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using IdLib for uint96;\n    using EfficiencyLib for bytes12;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n\n    error EmissaryAssignmentUnavailable(uint256 assignAt);\n    error InvalidLockTag();\n    error InvalidEmissaryStatus();\n\n    event EmissaryAssigned(address indexed sponsor, bytes12 indexed lockTag, address indexed emissary);\n    event EmissaryAssignmentScheduled(address indexed sponsor, bytes12 indexed lockTag, uint256 indexed assignableAt);\n\n    uint96 constant NOT_SCHEDULED = type(uint96).max;\n\n    // Storage slot for emissary configurations\n    // Maps: keccak256(_EMISSARY_SCOPE) => EmissarySlot\n    uint256 private constant _EMISSARY_SCOPE = 0x2d5c707;\n\n    // bytes4(keccak256(\"verifyClaim(address,bytes32,bytes,bytes12)\")).\n    uint32 private constant _VERIFY_CLAIM_SELECTOR = 0xcd4d6588;\n\n    /**\n     * @dev Retrieves the configuration for a given emissary.\n     * This ensures that emissary-specific settings (like reset period and assignment time)\n     * are stored and retrieved in a consistent and isolated manner to prevent conflicts.\n     * The function uses a combination of sponsor address, lockTag, and a scope constant\n     * to compute a unique storage slot for the configuration.\n     */\n    function _getEmissaryConfig(address sponsor, bytes12 lockTag)\n        private\n        pure\n        returns (EmissaryConfig storage config)\n    {\n        assembly (\"memory-safe\") {\n            // Pack data for computing storage slot.\n            mstore(0x14, sponsor) // Offset 0x14 (20 bytes): Store 20-byte sponsor address\n            mstore(0, _EMISSARY_SCOPE) // Offset 0 (0 bytes): Store 4-byte scope value\n            mstore(0x20, lockTag) // Offset 0x20 (12 bytes): Store 12-byte lock tag\n\n            // Compute storage slot from packed data.\n            // Start at offset 0x1c (28 bytes), which includes:\n            // - The 4 bytes of _EMISSARY_SCOPE (which is stored at position 0x00)\n            // - The entire 20-byte sponsor address (which starts at position 0x14)\n            // - The entire 12-byte lock tag (which starts at position 0x34)\n            // Hash 0x24 (36 bytes) of data in total\n            config.slot := keccak256(0x1c, 0x24)\n        }\n    }\n\n    /**\n     * @dev Assigns or removes an emissary for a specific sponsor and allocator ID.\n     * The function ensures that the assignment process adheres to the scheduling rules\n     * and prevents invalid or premature assignments. It also clears the configuration\n     * when removing an emissary to keep storage clean and avoid stale data.\n     * @param lockTag The lockTag of the emissary\n     * @param newEmissary The address of the new emissary (use address(0) to remove)\n     */\n    function assignEmissary(bytes12 lockTag, address newEmissary) internal {\n        EmissaryConfig storage config = _getEmissaryConfig(msg.sender, lockTag);\n        uint256 _assignableAt = config.assignableAt;\n        address _emissary = config.emissary;\n\n        // Ensures that the assignment has been scheduled properly.\n        // Without this check, an emissary could be assigned without proper scheduling,\n        // leading to uncontrolled state transitions.\n        require(_assignableAt != NOT_SCHEDULED, EmissaryAssignmentUnavailable(NOT_SCHEDULED));\n\n        // The second check ensures that either there is no current emissary,\n        // or the reset period has elapsed before allowing a new assignment.\n        // This enforces the cooldown period between assignments to prevent abuse.\n        require(\n            _emissary == address(0) || config.assignableAt <= block.timestamp,\n            EmissaryAssignmentUnavailable(config.assignableAt)\n        );\n\n        // If new Emissary is address(0), that means that the sponsor wants to remove the emissary feature.\n        // In that event, wipe all storage.\n        if (newEmissary == address(0)) {\n            // If the new emissary is address(0), this means the emissary should be removed.\n            // Clear all related storage fields to maintain a clean state and avoid stale data.\n            delete config.emissary;\n            delete config.assignableAt;\n        }\n        // Otherwise, set the provided resetPeriod.\n        else {\n            config.emissary = newEmissary;\n            config.assignableAt = NOT_SCHEDULED;\n        }\n\n        emit EmissaryAssigned(msg.sender, lockTag, newEmissary);\n    }\n\n    /**\n     * @dev Schedules a future assignment for an emissary.\n     * The scheduling mechanism ensures that emissaries cannot be reassigned arbitrarily,\n     * enforcing a reset period that must elapse before a new assignment is possible.\n     * This prevents abuse of the system by requiring a cooldown period between assignments.\n     * @param lockTag The lock tag for the assignment\n     * @return assignableAt The timestamp when the assignment becomes available\n     */\n    function scheduleEmissaryAssignment(bytes12 lockTag) internal returns (uint256 assignableAt) {\n        // Get the current emissary config from storage.\n        EmissaryConfig storage emissaryConfig = _getEmissaryConfig(msg.sender, lockTag);\n\n        unchecked {\n            // Extract five bit resetPeriod from lockTag, convert to seconds, & add to current time.\n            assignableAt = block.timestamp + lockTag.toResetPeriod().toSeconds();\n\n            // Ensure that assignableAt is in the future and is not greater than type(uint96.max).\n            if ((assignableAt < block.timestamp).or(assignableAt > type(uint96).max)) {\n                revert InvalidLockTag();\n            }\n        }\n\n        // Write the resultant value to storage.\n        emissaryConfig.assignableAt = uint96(assignableAt);\n\n        // Emit an EmissaryAssignmentScheduled event.\n        emit EmissaryAssignmentScheduled(msg.sender, lockTag, assignableAt);\n    }\n\n    /**\n     * @dev Extracts and verifies that all IDs in the array have the same lock tag.\n     * @param idsAndAmounts Array of [id, amount] pairs\n     * @return lockTag The common lock tag across all IDs\n     */\n    function extractSameLockTag(uint256[2][] memory idsAndAmounts) internal pure returns (bytes12 lockTag) {\n        // Retrieve the length of the array.\n        uint256 idsAndAmountsLength = idsAndAmounts.length;\n\n        // Ensure length is at least 1.\n        if (idsAndAmountsLength == 0) {\n            revert InvalidLockTag();\n        }\n\n        // Store the first lockTag for the first id.\n        lockTag = idsAndAmounts[0][0].toLockTag();\n\n        // Initialize an error buffer.\n        uint256 errorBuffer;\n\n        // Iterate over remaining array elements.\n        unchecked {\n            for (uint256 i = 1; i < idsAndAmountsLength; ++i) {\n                // Set the error buffer if lockTag does not match initial lockTag.\n                errorBuffer |= (idsAndAmounts[i][0].toLockTag() != lockTag).asUint256();\n            }\n        }\n\n        // Ensure that no lockTag values differ.\n        if (errorBuffer.asBool()) {\n            revert InvalidLockTag();\n        }\n    }\n\n    /**\n     * @dev Verifies a claim using the assigned emissary.\n     * This function delegates the verification logic to the emissary contract,\n     * ensuring that the verification process is modular and can be updated independently.\n     * If no emissary is assigned, the verification fails, enforcing the requirement\n     * for an active emissary to validate claims.\n     * @param claimHash The hash of the claim to verify.\n     * @param sponsor   The address of the sponsor.\n     * @param lockTag   The lock tag for the claim.\n     * @param signature The signature to verify.\n     */\n    function verifyWithEmissary(bytes32 claimHash, address sponsor, bytes12 lockTag, bytes calldata signature)\n        internal\n        view\n    {\n        // Retrieve the emissary for the sponsor and lock tag from storage.\n        EmissaryConfig storage emissaryConfig = _getEmissaryConfig(sponsor, lockTag);\n\n        // Delegate the verification process to the assigned emissary contract.\n        _callVerifyClaim(emissaryConfig.emissary, sponsor, claimHash, signature, lockTag);\n    }\n\n    /**\n     * @dev Perform a low-level verifyClaim staticcall to an emissary, ensuring that\n     * the expected magic value (verifyClaim function selector) is returned. Reverts\n     * if the magic value is not returned successfully.\n     * @param emissary  The emissary to perform the call to.\n     * @param sponsor   The address of the sponsor.\n     * @param claimHash The hash of the claim to verify.\n     * @param signature The signature to verify.\n     * @param lockTag   The lock tag for the claim.\n     */\n    function _callVerifyClaim(\n        address emissary,\n        address sponsor,\n        bytes32 claimHash,\n        bytes calldata signature,\n        bytes12 lockTag\n    ) private view {\n        assembly (\"memory-safe\") {\n            // Sanitize sponsor and lock tag.\n            sponsor := shr(0x60, shl(0x60, sponsor))\n            lockTag := shl(0xa0, shr(0xa0, lockTag))\n\n            // Retrieve the free memory pointer; memory will be left dirtieed.\n            let m := mload(0x40)\n\n            // Derive offset to start of data for the call from memory pointer.\n            let dataStart := add(m, 0x1c)\n\n            // Prepare fixed-location components of calldata.\n            mstore(m, _VERIFY_CLAIM_SELECTOR)\n            mstore(add(m, 0x20), sponsor)\n            mstore(add(m, 0x40), claimHash)\n            mstore(add(m, 0x60), 0x80)\n            mstore(add(m, 0x80), lockTag)\n            mstore(add(m, 0xa0), signature.length)\n            calldatacopy(add(m, 0xc0), signature.offset, signature.length)\n\n            // Ensure sure initial scratch space is cleared as an added precaution.\n            mstore(0, 0)\n\n            // Perform a staticcall to emissary and write response to scratch space.\n            let success := staticcall(gas(), emissary, dataStart, add(0xa4, signature.length), 0, 0x20)\n\n            // Revert if the required magic value was not received back.\n            if iszero(eq(mload(0), shl(224, _VERIFY_CLAIM_SELECTOR))) {\n                // Bubble up revert if the call failed and there's data.\n                // NOTE: consider evaluating remaining gas to protect against revert bombing.\n                if iszero(or(success, iszero(returndatasize()))) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert InvalidSignature();\n                mstore(0, 0x8baa579f)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @dev Retrieves the current status of an emissary for a given sponsor and lock tag.\n     * The status provides insight into whether the emissary is active, disabled, or scheduled for reassignment.\n     * This helps external contracts and users understand the state of the emissary system\n     * without needing to interpret raw configuration data.\n     * @param sponsor The address of the sponsor\n     * @param lockTag The lock tag for the emissary\n     * @return status The current status of the emissary\n     * @return assignableAt The timestamp when the emissary can be reassigned\n     * @return currentEmissary The address of the currently assigned emissary\n     */\n    function getEmissaryStatus(address sponsor, bytes12 lockTag)\n        internal\n        view\n        returns (EmissaryStatus status, uint256 assignableAt, address currentEmissary)\n    {\n        EmissaryConfig storage emissaryConfig = _getEmissaryConfig(sponsor, lockTag);\n        assignableAt = emissaryConfig.assignableAt;\n        currentEmissary = emissaryConfig.emissary;\n\n        // Determine the emissary's status based on its current state:\n        // - If there is no current emissary, the status is Disabled.\n        // - If assignableAt is NOT_SCHEDULED, the emissary is Enabled and active.\n        // - If assignableAt is set to a future timestamp, the emissary is Scheduled for reassignment.\n        if (currentEmissary == address(0)) {\n            status = EmissaryStatus.Disabled;\n        } else if (assignableAt == NOT_SCHEDULED) {\n            status = EmissaryStatus.Enabled;\n        } else if (assignableAt != 0) {\n            status = EmissaryStatus.Scheduled;\n        } else {\n            revert InvalidEmissaryStatus();\n        }\n    }\n}\n"
    }
}