{
    "vfp_id": "vfp_00160",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 59,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing validation for callerProfit and protocolProfit in setMarginLevel()",
            "description": "The setMarginLevel() function does not validate that callerProfit and protocolProfit are â‰¤ 1e6, allowing potentially invalid values above 100%. The root cause is incomplete input validation. This could lead to DoS if profits exceed 100%. The impact is potential protocol instability due to invalid configuration.\n",
            "severity": "Informational",
            "location": [
                "MarginLevels.sol#L18"
            ],
            "files": [
                "likwid-margin/src/types/MarginLevels.sol"
            ]
        }
    ],
    "affected_files": {
        "MarginLevels.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ntype MarginLevels is bytes32;\n\nusing MarginLevelsLibrary for MarginLevels global;\n\n/// @notice Library for getting and setting values in the MarginLevels type\nlibrary MarginLevelsLibrary {\n    uint24 internal constant MASK_24_BITS = 0xFFFFFF;\n\n    uint8 internal constant MIN_BORROW_LEVEL_OFFSET = 24;\n    uint8 internal constant LIQUIDATE_LEVEL_OFFSET = 48;\n    uint8 internal constant LIQUIDATION_RATIO_OFFSET = 72;\n    uint8 internal constant CALLER_PROFIT_OFFSET = 96;\n    uint8 internal constant PROTOCOL_PROFIT_OFFSET = 120;\n\n    function isValidMarginLevels(MarginLevels _packed) internal pure returns (bool valid) {\n        uint24 _liquidateLevel = liquidateLevel(_packed);\n        uint24 one = 10 ** 6;\n        valid = _liquidateLevel >= one && minMarginLevel(_packed) > _liquidateLevel\n            && minBorrowLevel(_packed) > _liquidateLevel && liquidationRatio(_packed) <= one;\n    }\n\n    // #### GETTERS ####\n    function minMarginLevel(MarginLevels _packed) internal pure returns (uint24 _minMarginLevel) {\n        assembly (\"memory-safe\") {\n            _minMarginLevel := and(MASK_24_BITS, _packed)\n        }\n    }\n\n    function minBorrowLevel(MarginLevels _packed) internal pure returns (uint24 _minBorrowLevel) {\n        assembly (\"memory-safe\") {\n            _minBorrowLevel := and(MASK_24_BITS, shr(MIN_BORROW_LEVEL_OFFSET, _packed))\n        }\n    }\n\n    function liquidateLevel(MarginLevels _packed) internal pure returns (uint24 _liquidateLevel) {\n        assembly (\"memory-safe\") {\n            _liquidateLevel := and(MASK_24_BITS, shr(LIQUIDATE_LEVEL_OFFSET, _packed))\n        }\n    }\n\n    function liquidationRatio(MarginLevels _packed) internal pure returns (uint24 _liquidationRatio) {\n        assembly (\"memory-safe\") {\n            _liquidationRatio := and(MASK_24_BITS, shr(LIQUIDATION_RATIO_OFFSET, _packed))\n        }\n    }\n\n    function callerProfit(MarginLevels _packed) internal pure returns (uint24 _callerProfit) {\n        assembly (\"memory-safe\") {\n            _callerProfit := and(MASK_24_BITS, shr(CALLER_PROFIT_OFFSET, _packed))\n        }\n    }\n\n    function protocolProfit(MarginLevels _packed) internal pure returns (uint24 _protocolProfit) {\n        assembly (\"memory-safe\") {\n            _protocolProfit := and(MASK_24_BITS, shr(PROTOCOL_PROFIT_OFFSET, _packed))\n        }\n    }\n\n    // #### SETTERS ####\n    function setMinMarginLevel(MarginLevels _packed, uint24 _minMarginLevel)\n        internal\n        pure\n        returns (MarginLevels _result)\n    {\n        assembly (\"memory-safe\") {\n            _result := or(and(not(MASK_24_BITS), _packed), and(MASK_24_BITS, _minMarginLevel))\n        }\n    }\n\n    function setMinBorrowLevel(MarginLevels _packed, uint24 _minBorrowLevel)\n        internal\n        pure\n        returns (MarginLevels _result)\n    {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(MIN_BORROW_LEVEL_OFFSET, MASK_24_BITS)), _packed),\n                    shl(MIN_BORROW_LEVEL_OFFSET, and(MASK_24_BITS, _minBorrowLevel))\n                )\n        }\n    }\n\n    function setLiquidateLevel(MarginLevels _packed, uint24 _liquidateLevel)\n        internal\n        pure\n        returns (MarginLevels _result)\n    {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(LIQUIDATE_LEVEL_OFFSET, MASK_24_BITS)), _packed),\n                    shl(LIQUIDATE_LEVEL_OFFSET, and(MASK_24_BITS, _liquidateLevel))\n                )\n        }\n    }\n\n    function setLiquidationRatio(MarginLevels _packed, uint24 _liquidationRatio)\n        internal\n        pure\n        returns (MarginLevels _result)\n    {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(LIQUIDATION_RATIO_OFFSET, MASK_24_BITS)), _packed),\n                    shl(LIQUIDATION_RATIO_OFFSET, and(MASK_24_BITS, _liquidationRatio))\n                )\n        }\n    }\n\n    function setCallerProfit(MarginLevels _packed, uint24 _callerProfit) internal pure returns (MarginLevels _result) {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(CALLER_PROFIT_OFFSET, MASK_24_BITS)), _packed),\n                    shl(CALLER_PROFIT_OFFSET, and(MASK_24_BITS, _callerProfit))\n                )\n        }\n    }\n\n    function setProtocolProfit(MarginLevels _packed, uint24 _protocolProfit)\n        internal\n        pure\n        returns (MarginLevels _result)\n    {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(PROTOCOL_PROFIT_OFFSET, MASK_24_BITS)), _packed),\n                    shl(PROTOCOL_PROFIT_OFFSET, and(MASK_24_BITS, _protocolProfit))\n                )\n        }\n    }\n}\n"
    }
}