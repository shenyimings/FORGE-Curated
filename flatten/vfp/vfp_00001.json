{
    "vfp_id": "vfp_00001",
    "project_name": "Spectral Image Vaults - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Refunded agent tokens should be sent back to the requester",
            "description": "The vulnerability occurs in the `issueRefund` function of the AgentImageService contract, where refunded tokens are incorrectly sent to the caller (`msg.sender`) instead of the original requester. The root cause is the misuse of `msg.sender` in the `safeTransfer` call, which fails to reference the stored `request.user` from the `ImageRequest` struct. An attacker who is an admin or agent owner could exploit this by calling `approveRefund` and receiving the refund themselves, stealing funds from the rightful requester. This leads to loss of user funds and undermines trust in the refund mechanism.\n",
            "severity": "High",
            "location": [
                "AgentImageService.sol::requestImage#L203",
                "AgentImageService.sol::requestRefund#L263",
                "AgentImageService.sol::approveRefund#L284",
                "AgentImageService.sol::issueRefund#L299"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "The tax in agent tokens is causing incorrect accounting in the AgentImageService",
            "description": "When users transfer agent tokens with a tax mechanism (e.g., via `transfer` in AgentToken.sol), a portion of the tokens is deducted as tax before reaching the recipient. However, the `requestImage` function in AgentImageService assumes the full `finalImagePrice` is received, without accounting for potential tax deductions. This causes `pendingFees` to be inflated, leading to incorrect fee tracking and potential discrepancies during fee withdrawal or distribution. The root cause is the lack of balance checks before updating state. An attacker could exploit this by using taxed tokens to underpay fees while the system records a higher amount, resulting in financial loss to the protocol.\n",
            "severity": "High",
            "location": [
                "AgentToken.sol::transfer#L100",
                "AgentImageService.sol::requestImage#L216"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentToken.sol",
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Wrong approval in fullfillImage",
            "description": "In the `fulfillImage` function, the contract attempts to approve `spectralTreasury` to spend agent tokens, but the subsequent `swapExactTokensForSPEC` call is made through the `deployer` contract, which is the actual `msg.sender` during the transfer. Since the allowance was granted to `spectralTreasury` and not `deployer`, the transfer will fail, causing the transaction to revert. The root cause is incorrect allowance targeting. This can be exploited by an attacker (or simply occur naturally) when fulfilling images, leading to denial of service for image fulfillment, disrupting core functionality.\n",
            "severity": "High",
            "location": [
                "AgentImageService.sol::fulfillImage"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Duplicate requestId values can occur",
            "description": "The `requestId` is generated using `keccak256(abi.encodePacked(prompt, block.timestamp, msg.sender))`. If a user sends two identical requests (same prompt and sender) within the same block, they will generate the same `requestId`, overwriting the first request in the `imageRequests` mapping. Although both transactions transfer tokens, only the second request is recorded, causing the first request's funds to be effectively lost. The root cause is the lack of a uniqueness check or nonce mechanism. This can be exploited by front-running or automated bots, leading to loss of user funds.\n",
            "severity": "Medium",
            "location": [
                "AgentImageService.sol::requestImage#L191"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The requestRefund function contains an incorrect check",
            "description": "The `requestRefund` function includes a check `block.timestamp >= request.timestamp + config.refundTimeLimit` before allowing a refund request. However, this check prevents users from requesting a refund until the time limit has passed, which contradicts the intended workflow where users can *request* a refund at any time, but only *receive* it after the time limit. The root cause is a misplaced time check. This leads to reduced user flexibility and potential confusion, as legitimate refund requests are blocked prematurely.\n",
            "severity": "Medium",
            "location": [
                "AgentImageService.sol::requestRefund#L260"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Swap deadline in fullfillImage might stall the TX",
            "description": "The `fulfillImage` function sets a swap deadline of `block.timestamp + 20 minutes`, which is excessively long. While this reduces the chance of slippage-related failure, it increases the risk of transaction mempool congestion or delayed execution, especially during high network activity. The root cause is poor deadline configuration. This can be exploited by MEV bots or lead to operational inefficiencies, potentially stalling image fulfillment and degrading user experience.\n",
            "severity": "Medium",
            "location": [
                "AgentImageService.sol::fulfillImage"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "The configuration cannot be changed once it has been set",
            "description": "The `configureAgent` function enforces that configuration can only be set once via the `isConfigured` flag. Once set, critical parameters like `pricePerImage` and `refundTimeLimit` cannot be updated, even by the agent owner. The root cause is the immutable design of the configuration. This reduces operational flexibility and prevents adaptation to changing market conditions or user needs, limiting the long-term usability of deployed agents.\n",
            "severity": "Medium",
            "location": [
                "AgentImageService.sol::deployImageAgent#L137",
                "AgentImageService.sol::configureAgent#L171"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "The owner cannot set a new creator for the agent tokens",
            "description": "The `updateAgentCreator` function in `AgentImageService` attempts to delegate to the `deployer` contract, but the `deployer`'s `updateAgentCreator` function is restricted to the current agent creator via the `onlyAgentCreator` modifier. Since `AgentImageService` is not the creator, the call reverts. The root cause is a permission mismatch between the service and deployer contracts. This prevents administrative updates to agent ownership, reducing governance flexibility and potentially locking in incorrect configurations.\n",
            "severity": "Medium",
            "location": [
                "AgentImageService.sol::updateAgentCreator#L354",
                "AutonomousAgentDeployer.sol::updateAgentCreator#L255-L259"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol",
                "autonomous-agent-contracts/contracts/AutonomousAgentDeployer.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "setDistributor and setSpectralStaking functions might be needed",
            "description": "The V2 version of `AutonomousAgentDeployer` removed the `setDistributor` and `setSpectralStaking` functions, making it impossible to correct a mistakenly initialized address. The root cause is the removal of critical administrative functions for bytecode size optimization. If a wrong address is set during initialization, it cannot be fixed without a contract upgrade, leading to potential permanent misconfiguration and loss of functionality.\n",
            "severity": "Low",
            "location": [
                "AutonomousAgentDeployer.sol"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AutonomousAgentDeployer.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "The fees can be transferred to the admin",
            "description": "The `withdrawFees` function allows the admin (or agent owner) to withdraw accumulated fees to `msg.sender`. Since the admin can call this for any agent token they control, they can siphon fees that should belong to the actual agent owner. The root cause is insufficient access control and lack of fee destination validation. This can lead to unauthorized withdrawal of funds by the admin, resulting in financial loss for agent creators.\n",
            "severity": "Low",
            "location": [
                "AgentImageService.sol::withdrawFees#L311"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused mapping, variable and events in V2",
            "description": "The `AutonomousAgentDeployer` contract contains unused elements: the `agentWallets` mapping, `accumulatedTaxToSwap` variable, and the `DistributorSet` and `SpectralStakingSet` events. These increase contract size and reduce code clarity. The root cause is leftover code from previous versions. While not directly exploitable, they contribute to higher gas costs and maintenance burden, reducing code quality and auditability.\n",
            "severity": "Informational",
            "location": [
                "AutonomousAgentDeployer.sol"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AutonomousAgentDeployer.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-331"
                ]
            },
            "title": "Recommendation for public mempool chain deployments",
            "description": "The `deployImageAgent` function is vulnerable to MEV (Miner Extractable Value) attacks on chains with public mempools. An attacker can monitor pending transactions and frontrun the deployment to manipulate approvals or extract value. The root cause is the lack of entropy (e.g., salt using `msg.sender`) in the deployment process. This can lead to loss of funds or compromised agent tokens due to adversarial deployment interference.\n",
            "severity": "Informational",
            "location": [
                "AgentImageService.sol::deployImageAgent"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused variables",
            "description": "The `agentRequestIds` and `requestProcessed` mappings in `AgentImageService` are declared but never used. No function writes to them, making them redundant. The root cause is incomplete implementation or leftover code. These unused variables increase storage overhead and reduce code readability, making audits and maintenance more difficult.\n",
            "severity": "Informational",
            "location": [
                "AgentImageService.sol"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "The AgentImageService should inherit from IAgentImageService",
            "description": "The `IAgentImageService` interface contains duplicated and incorrect struct definitions (`ImageRequest` and `AgentConfig`) that are not aligned with the implementation. The `AgentImageService` contract does not inherit from this interface, leading to potential interface mismatches. The root cause is poor interface design and lack of inheritance. This reduces code consistency and increases the risk of integration errors with external systems.\n",
            "severity": "Informational",
            "location": [
                "AgentImageService.sol",
                "IAgentImageService.sol#L5-L12"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol",
                "autonomous-agent-contracts/contracts/interfaces/IAgentImageService.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "The previously calculated value can be reused",
            "description": "In the `fulfillImage` function, the `treasuryCut` value is calculated but not reused in the subsequent `safeTransfer` call, which recalculates the same value. This is inefficient and wastes gas. The root cause is redundant computation. While not a security risk, it represents a missed optimization opportunity, increasing transaction costs unnecessarily.\n",
            "severity": "Informational",
            "location": [
                "AgentImageService.sol::fulfillImage#L245"
            ],
            "files": [
                "autonomous-agent-contracts/contracts/AgentImageService.sol"
            ]
        }
    ],
    "affected_files": {
        "IAgentImageService.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IAgentImageService {\n    struct ImageRequest {\n        address user;\n        uint256 amount;\n        uint256 timestamp;\n        bool fulfilled;\n        bool refunded;\n        string prompt;\n    }\n\n    struct AgentConfig {\n        uint256 pricePerImage;\n        string imageDescription;\n        uint256 refundTimeLimit;\n        bool isConfigured;\n    }\n\n    event AgentConfigured(address indexed agentToken, uint256 price, string description, uint256 refundTimeLimit);\n    event ImageRequested(address indexed agentToken, address indexed user, bytes32 indexed requestId, uint256 amount);\n    event ImageFulfilled(address indexed agentToken, bytes32 indexed requestId);\n    event FeesWithdrawn(address indexed agentToken, uint256 amount);\n    event RefundIssued(address indexed agentToken, bytes32 indexed requestId, uint256 amount);\n\n    function configureAgent(\n        address agentToken,\n        uint256 pricePerImage,\n        string memory imageDescription,\n        uint256 refundTimeLimit\n    ) external;\n\n    function requestImage(address agentToken, string calldata prompt) external;\n\n    function fulfillImage(address agentToken, bytes32 requestId) external;\n\n    function requestRefund(address agentToken, bytes32 requestId) external;\n\n    function withdrawFees(address agentToken) external;\n\n    function getRequestDetails(\n        address agentToken,\n        bytes32 requestId\n    ) external view returns (\n        address user,\n        uint256 amount,\n        uint256 timestamp,\n        bool fulfilled,\n        bool refunded,\n        string memory prompt\n    );\n\n    function agentConfigs(address agentToken) external view returns (AgentConfig memory);\n    \n    function accumulatedFees(address agentToken) external view returns (uint256);\n} ",
        "AgentToken.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./interfaces/IAgentBalances.sol\";\nimport \"./interfaces/IAutonomousAgentDeployer.sol\";\n\ncontract AgentToken is Initializable, ERC20Upgradeable, UUPSUpgradeable {\n    using AddressUpgradeable for address;\n\n    uint256 public taxPercentage;\n    address public taxWallet;\n    address public owner;\n    IAgentBalances public agentBalances;\n\n    uint8 version;\n    // Some agents are already deployed and need upgrading using diamond pattern\n    // IAutonomousAgentDeployer constant public deployer = IAutonomousAgentDeployer(address(0xD84B6CAccFCc9FA5F48c6277C40FaC0620f1d0c2));\n    // use this if testing or deploying new deployer\n    IAutonomousAgentDeployer public deployer;\n\n    uint256[49] private __gap;\n\n    event TaxChanged(uint256 taxPercentage);\n    event TaxWalletchanged(address taxWallet);\n\n    modifier onlyUpgrader() {\n        require(owner == msg.sender, \"CALLER_NOT_UPGRADER\");\n        _;\n    }\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address _owner,\n        address _agentBalances\n    ) public initializer {\n        require(_owner != address(0), \"Invalid owner\");\n        __ERC20_init(name, symbol);\n        __UUPSUpgradeable_init(); //initialize the UUPSUpgradeable\n        owner = _owner;\n        taxWallet = _owner; // default tax wallet\n        taxPercentage = 100;\n        agentBalances = IAgentBalances(_agentBalances);\n        deployer = IAutonomousAgentDeployer(msg.sender);\n        _mint(msg.sender, initialSupply);\n        version = 1;\n    }\n\n\n    // Override the transfer function to apply tax only if the recipient is a contract\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        // Check if the recipient is agentBalances to prevent recursion\n        if (recipient == address(agentBalances)) {\n            return super.transfer(recipient, amount);\n        }\n        address distributor = address(deployer.distributor());\n        if (address(deployer) != address(0) &&                               // deployer exists\n        (recipient.isContract() || msg.sender.isContract()) &&                   // XOR: exactly one must be a contract\n        !(recipient == address(deployer) || msg.sender == address(deployer)) &&  // neither sender nor recipient is deployer\n        (distributor == address(0) || recipient != distributor))\n        {\n            uint256 taxAmount = (amount * taxPercentage) / 10000;\n            uint256 amountAfterTax = amount - taxAmount;\n\n            //send the tax to deployer to distribute\n            super.transfer(address(deployer), taxAmount);\n            deployer.accumulateSwapFees(taxAmount);\n\n            // Transfer the remaining amount to the recipient\n            return super.transfer(recipient, amountAfterTax);\n        } else {\n            // No tax if recipient is not a contract\n            return super.transfer(recipient, amount);\n        }\n    }\n\n    // Override the transferFrom function to apply tax only if the recipient is a contract\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        // Check if the recipient is agentBalances to prevent recursion\n        if (recipient == address(agentBalances)) {\n            return super.transferFrom(sender, recipient, amount);\n        }\n\n        address distributor = address(deployer.distributor());\n\n        if (address(deployer) != address(0) &&                               // deployer exists\n        (recipient.isContract() || sender.isContract()) &&                   // XOR: exactly one must be a contract\n        !(recipient == address(deployer) || sender == address(deployer)) &&  // neither sender nor recipient is deployer\n        (distributor == address(0) || recipient != distributor))\n        {\n            uint256 taxAmount = (amount * taxPercentage) / 10000;\n            uint256 amountAfterTax = amount - taxAmount;\n\n            //send the tax to deployer to distribute\n            super.transferFrom(sender, address(deployer), taxAmount);\n            deployer.accumulateSwapFees(taxAmount);\n\n            // Transfer the remaining amount to the recipient\n            return super.transferFrom(sender, recipient, amountAfterTax);\n        } else {\n            // No tax if recipient is not a contract\n            return super.transferFrom(sender, recipient, amount);\n        }\n    }\n\n    function setTaxWallet(address _taxWallet) external {\n        require(msg.sender == owner, \"Only the owner can set the tax wallet\");\n        require(_taxWallet != address(0), \"Invalid tax wallet address\");\n        taxWallet = _taxWallet;\n\n        emit TaxWalletchanged(_taxWallet);\n    }\n\n    // Times the percentage by 100 to allow for more decimal places\n    function setTaxPercentage(uint256 _taxPercentage) external {\n        require(_taxPercentage >= 100, \"Tax percentage too small\");\n        require(_taxPercentage <= 10000, \"Tax percentage cannot exceed 100%\");\n        require(msg.sender == owner, \"Only the owner can set the tax percentage\");\n        taxPercentage = _taxPercentage;\n        emit TaxChanged(_taxPercentage);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyUpgrader {\n        require(newImplementation != address(0), \"ADDRESS_IS_ZERO\");\n        ++version;\n    }\n\n    function removeAllowance(address approver, address spender) public onlyUpgrader {\n        _approve(approver, spender, 0);\n    }\n}",
        "AutonomousAgentDeployer.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"node_modules/diamond-proxy-pattern/contracts/BeaconProxyManager.sol\";\nimport \"./AgentToken.sol\";\nimport \"./interfaces/IOctoDistributor.sol\";\nimport \"./interfaces/ISpectralStaking.sol\";\n\ncontract AutonomousAgentDeployer is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable, BeaconProxyManager, IAutonomousAgentDeployer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    mapping(Parameter => uint256) public parameters;\n\n    address payable public feeWallet;\n\n    IUniswapV2Router02 public uniswapRouter;\n    ISwapRouter public uniswapV3Router;\n\n    address public uniswapFactory;\n    address public agentTokenImplementation; \n    uint256 public UNISWAP_POOL_CREATION_VALUE; // Threshold for pool creation in SPEC\n\n    address public spectralToken;\n    address public WETH;\n    IAgentBalances public override agentBalances;\n\n    mapping (address => bool) public agentTokens;\n    mapping (address => uint256) public agentTokensSold;\n    mapping (address => address) public agentWallets;\n    mapping (address => uint256) public totalSPECDeposited;\n    mapping (address => address) public agentTokenUniswapPool;\n\n    address public admin;\n\n    uint8 public version;\n    uint8 public agentsVersion;\n\n    bool public paused;\n    address public pauser;\n    \n    uint256 constant INITIAL_VIRTUAL_LIQUIDITY = 500 ether;\n\n    IOctoDistributor public distributor;\n    ISpectralStaking public spectralStaking;\n    uint256 accumulatedTaxToSwap;\n    mapping(address => uint256) public accumulatedTaxToSwapByAgent;\n    //gap for future variable additions\n    uint256[44] private __gap;\n\n    event TokensSold(address indexed agentToken, address indexed buyer, uint256 amount, uint256 specAmount);\n    event TokensRedeemedForSPEC(address indexed agentToken, address indexed redeemer, uint256 amount, uint256 specAmount);\n    event ParameterSet(Parameter indexed param, uint256 value);\n    event DistributorSet(address distributor);\n    event SpectralStakingSet(address spectralStaking);\n    event TaxDistributed(uint256 amount);\n    event TaxAccumulated(uint256 amount,uint256 total);\n    event UniswapV2PoolCreationFailed(address token, address pool);\n    event ProfitDistributed(address token, uint256 amount);\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Pausable: paused\");\n        _;\n    }\n\n    modifier OnlyPauserOrOwner() {\n        require(msg.sender == owner() || msg.sender == pauser, \"AgentDeployer: caller is not the owner or admin\");\n        _;\n    }\n\n    modifier onlyAgentToken() {\n        require(agentTokens[msg.sender], \"Invalid agent token\");\n        _;\n    }\n\n    modifier onlyDistributor() {\n        require(msg.sender == address(distributor), \"Only distributor\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    modifier onlyAdminOrOwner() {\n        require(msg.sender == owner() || msg.sender == admin, \"AgentDeployer: caller is not the owner or admin\");\n        _;\n    }\n\n    function initialize(\n        address payable _fee,\n        address _admin,\n        address _uniswapRouter,\n        address _uniswapFactory,\n        address _spectralToken,\n        address _agentBalances,\n        uint256 _uniswap_pool_creation_value,\n        address _agentTokenImplementation,\n        address _uniswapV3Router,\n        address _WETH\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        \n        parameters[Parameter.INITIAL_TOKEN_SUPPLY] = 1_000_000_000 ether;\n        parameters[Parameter.AGENT_TOKEN_DEPLOYMENT_FEE] = 6_500_000 ether;\n        parameters[Parameter.AGENT_TOKEN_OWNERSHIP] = 500_000 ether;\n        parameters[Parameter.DEPLOYMENT_COST_ETH] = 0.01 ether;\n        parameters[Parameter.INITIAL_TRADING_BALANCE] = 0.007 ether;\n        parameters[Parameter.DEPLOYMENT_TREASURY_FEE] = 0.003 ether;\n        \n        feeWallet = _fee;\n        admin = _admin;\n        agentsVersion = 1;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        uniswapFactory = _uniswapFactory;\n        agentBalances = IAgentBalances(_agentBalances);\n        spectralToken = _spectralToken;\n        UNISWAP_POOL_CREATION_VALUE = _uniswap_pool_creation_value;\n        agentTokenImplementation = _agentTokenImplementation;\n        uniswapV3Router = ISwapRouter(_uniswapV3Router);\n        WETH = _WETH;\n    }\n\n    function deployAgent(\n        string memory _agentName,\n        string memory _agentTicker,\n        uint256 specAmount\n    ) public payable whenNotPaused {\n        require(msg.value >=\n        parameters[Parameter.DEPLOYMENT_COST_ETH]\n        , \"Incorrect ETH amount\");\n\n        // Transfer SPEC from the deployer to this contract\n        IERC20Upgradeable(spectralToken).transferFrom(msg.sender, address(this), specAmount);\n\n        // Deploy the agent and perform common operations\n        (address _agentToken, uint256 creatorTokensReceived) = initializeAgent(\n            _agentName,\n            _agentTicker,\n            specAmount\n        );\n\n        //allocate tokens to the creator\n        IERC20Upgradeable(_agentToken).transfer(msg.sender, creatorTokensReceived);\n\n        // Emit tokens sold event for initial token sale\n        emit TokensSold(_agentToken, msg.sender, creatorTokensReceived, specAmount);        \n    }\n\n    function deployAgentWithETH(\n        string memory _agentName,\n        string memory _agentTicker,\n        uint256 minSpecAmount\n    ) public payable whenNotPaused returns (address agentToken) {\n        require(msg.value >= \n        parameters[Parameter.DEPLOYMENT_COST_ETH]\n        , \"Incorrect ETH amount\");\n\n        // Calculate ETH required for fees and deduct from the total ETH received\n        uint256 treasuryFee = parameters[Parameter.DEPLOYMENT_TREASURY_FEE];\n        uint256 initialTradingBalance = parameters[Parameter.INITIAL_TRADING_BALANCE];\n        uint256 totalFees = initialTradingBalance + treasuryFee;\n\n        require(msg.value >= totalFees, \"Insufficient ETH for fees\");\n\n        uint256 swapAmountETH = msg.value - totalFees;\n\n        // Perform the swap using the externally calculated minSpecAmount as the minimum output\n        uint256 specAmount = swapETHForSPEC(swapAmountETH, minSpecAmount);\n        // Deploy the agent and perform common operations\n        (address _agentToken, uint256 creatorTokensReceived) = initializeAgent(\n            _agentName,\n            _agentTicker,\n            specAmount\n        );\n        agentToken = _agentToken;\n\n        if (specAmount > 0) {\n            IERC20Upgradeable(_agentToken).transfer(msg.sender, creatorTokensReceived);\n            emit TokensSold(_agentToken, msg.sender, creatorTokensReceived, specAmount);\n        }\n    }\n\n    function initializeAgent(\n        string memory _agentName,\n        string memory _agentTicker,\n        uint256 specAmount\n    ) internal returns (address, uint256) {\n        require(address(agentBalances) != address(0), \"Invalid balances address\");\n\n        // Deploy the proxy with the AgentToken implementation address with diamond pattern\n        address _agentToken = createBeaconProxy(agentTokenImplementation, abi.encodeWithSelector(\n            AgentToken(address(0)).initialize.selector,\n            _agentName,\n            _agentTicker,\n            parameters[Parameter.INITIAL_TOKEN_SUPPLY],\n            feeWallet,\n            address(agentBalances)\n        ));\n\n        agentTokens[_agentToken] = true;\n        distributor.setAgentCreator(_agentToken, msg.sender);\n        // Transfer deployment fee and treasury fee to feeWallet\n        IERC20Upgradeable(_agentToken).transfer(feeWallet, parameters[Parameter.AGENT_TOKEN_DEPLOYMENT_FEE]);\n\n        IERC20Upgradeable(_agentToken).approve(address(spectralStaking), 2_000_000 ether);\n        spectralStaking.addDistribution(_agentToken, address(0), 2_000_000 ether, 0);\n\n        IERC20Upgradeable(_agentToken).approve(address(agentBalances), parameters[Parameter.AGENT_TOKEN_OWNERSHIP]);\n        agentBalances.deposit(address(this), _agentToken, _agentToken, parameters[Parameter.AGENT_TOKEN_OWNERSHIP]);\n        // Calculate tokens received based on `specAmount`\n        uint256 creatorTokensReceived = getTokensReceived(specAmount, _agentToken);\n        require(creatorTokensReceived <= parameters[Parameter.INITIAL_TOKEN_SUPPLY] / 100, \"Exceeds 1%\");\n\n        (bool success, ) = feeWallet.call{value: parameters[Parameter.DEPLOYMENT_TREASURY_FEE]}(\"\");\n        require(success, \"Transfer failed.\");\n\n        // Deposit the initial trading balance to agent balance contract\n        agentBalances.depositETH{value: parameters[Parameter.INITIAL_TRADING_BALANCE]}(_agentToken);\n\n        // Update total SPEC deposited and tokens sold\n        totalSPECDeposited[_agentToken] += specAmount;\n        agentTokensSold[_agentToken] += creatorTokensReceived;\n\n        // Account for deployment fee and ownership tokens in the tracking\n        agentTokensSold[_agentToken] += parameters[Parameter.AGENT_TOKEN_DEPLOYMENT_FEE];\n        agentTokensSold[_agentToken] += parameters[Parameter.AGENT_TOKEN_OWNERSHIP];\n        // Emit agent deployment event\n        emit AgentDeployed(_agentToken);\n\n        return (_agentToken, creatorTokensReceived);\n    }\n\n    function swapETHForSPEC(uint256 ethAmount, uint256 minSpecAmount) internal returns (uint256 specAmount) {\n        if(ethAmount == 0){\n            return 0;\n        }\n        \n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH,\n            tokenOut: spectralToken,\n            fee: 3000,\n            recipient: address(this),\n            amountIn: ethAmount,\n            amountOutMinimum: minSpecAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        specAmount = uniswapV3Router.exactInputSingle{value: ethAmount}(params);\n\n        require(specAmount >= minSpecAmount, \"received less than expected\");\n        return specAmount;\n    }\n\n    function getTokensReceived(uint _amountSPECIn, address _agentToken) public view returns (uint256) {\n        require(agentTokens[_agentToken], \"Invalid agent token\");\n\n        if (agentTokenUniswapPool[_agentToken] != address(0)) {\n            return _getTokensFromUniswap(_amountSPECIn, spectralToken, _agentToken);\n        }\n        return _getTokensFromBondingCurve(_amountSPECIn, _agentToken, true);\n    }\n\n    function getSPECReceived(uint _amountAgentTokenIn, address _agentToken) public view returns (uint256) {\n        require(agentTokens[_agentToken], \"Invalid agent token\");\n\n        if (agentTokenUniswapPool[_agentToken] != address(0)) {\n            return _getTokensFromUniswap(_amountAgentTokenIn, _agentToken, spectralToken);\n        }\n        return _getTokensFromBondingCurve(_amountAgentTokenIn, _agentToken, false);\n    }\n\n    function _getTokensFromUniswap(uint _amountIn, address _tokenIn, address _tokenOut) internal view returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = _tokenIn;\n        path[1] = _tokenOut;\n\n        uint256[] memory amounts = uniswapRouter.getAmountsOut(_amountIn, path);\n        return amounts[amounts.length - 1];\n    }\n\n    function _getTokensFromBondingCurve(uint _amountIn, address _agentToken, bool isSpecToAgentToken) internal view returns (uint256) {\n        uint256 currentSPECReserve = totalSPECDeposited[_agentToken] + INITIAL_VIRTUAL_LIQUIDITY;\n        uint256 currentTokenReserve = IERC20Upgradeable(_agentToken).balanceOf(address(this));\n\n        // Determine reserves based on input direction\n        uint256 newReserve;\n        uint256 k = currentSPECReserve * currentTokenReserve;\n\n        if (isSpecToAgentToken) {\n            // Calculate new SPEC reserve and agent token received\n            newReserve = currentSPECReserve + _amountIn;\n            uint256 newTokenReserve = k / newReserve;\n            return currentTokenReserve - newTokenReserve;\n        } else {\n            // Calculate new agent token reserve and SPEC received\n            newReserve = currentTokenReserve + _amountIn;\n            uint256 newSPECReserve = k / newReserve;\n            return currentSPECReserve - newSPECReserve;\n        }\n    }\n\n\n    function getSPECAmountForTokens(uint tokenAmount, address token) public view returns (uint256) {\n        require(agentTokens[token], \"Invalid agent token\");\n        return getSPECReceived(tokenAmount, token);\n    }\n\n    function _createUniswapPool(address _agentToken, uint _deadline) internal {\n        require(totalSPECDeposited[_agentToken] > UNISWAP_POOL_CREATION_VALUE && agentTokenUniswapPool[_agentToken] == address(0), \"Invalid pool creation conditions\");\n        address poolAddress = deployUniswapPool(_agentToken);\n        if(agentTokenUniswapPool[_agentToken] != address(0))\n        {\n            agentTokenUniswapPool[_agentToken] = poolAddress;\n            uint256 agentTokenBalance = IERC20Upgradeable(_agentToken).balanceOf(address(this));\n            // Approve tokens and add liquidity\n            IERC20Upgradeable(spectralToken).approve(address(uniswapRouter), totalSPECDeposited[_agentToken]);\n            IERC20Upgradeable(_agentToken).approve(address(uniswapRouter), agentTokenBalance);\n            uniswapRouter.addLiquidity(\n                spectralToken,\n                _agentToken,\n                totalSPECDeposited[_agentToken],\n                agentTokenBalance,\n                0, \n                0,\n                address(agentBalances), //agentBalances will burn the LPs by the Agent Wallet\n                _deadline\n            );\n        }\n    }\n\n    function swapExactSPECForTokens(uint _amountIn, uint amountOutMin, address _agentToken, uint _deadline) public ensure(_deadline) whenNotPaused nonReentrant {   \n        require(agentTokens[_agentToken], \"Invalid agent token\");\n        require(_amountIn > 0, \"Invalid amount\");\n        uint256 taxSpecAmount = (_amountIn * AgentToken(_agentToken).taxPercentage() / 10000);\n        uint256 userSpecAmount = _amountIn - taxSpecAmount;\n        IERC20Upgradeable(spectralToken).transferFrom(msg.sender, address(this), _amountIn);\n        if(agentTokenUniswapPool[_agentToken] != address(0)) {\n            address[] memory path = new address[](2);\n            path[0] = spectralToken;\n            path[1] = _agentToken;\n\n            IERC20Upgradeable(spectralToken).approve(address(uniswapRouter), userSpecAmount);\n\n            //We won't emit an event here because Uniswap's event has all the info we need\n            //Uniswap checks if amount received > amountOutMin\n            uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(userSpecAmount, amountOutMin, path, msg.sender, _deadline);\n        } else {\n            uint256 tokensReceived = getTokensReceived(userSpecAmount, _agentToken);\n            require(tokensReceived >= amountOutMin, \"Insufficient tokens output\");\n            agentTokensSold[_agentToken] += tokensReceived;\n            totalSPECDeposited[_agentToken] += userSpecAmount;\n            IERC20Upgradeable(_agentToken).safeTransfer(msg.sender, tokensReceived);\n            emit TokensSold(_agentToken, msg.sender, tokensReceived, _amountIn);\n        }\n        _distributeSwapFees(taxSpecAmount);\n        //Create liquidity pool if we meet liquidity conditions\n        if(totalSPECDeposited[_agentToken] > UNISWAP_POOL_CREATION_VALUE && agentTokenUniswapPool[_agentToken] == address(0)) {\n            _createUniswapPool(_agentToken, _deadline);\n        }\n    }\n\n    function swapExactTokensForSPEC(uint amountIn, uint amountOutMin, address fromToken, uint deadline) public ensure(deadline) whenNotPaused nonReentrant {\n        require(agentTokens[fromToken], \"Invalid agent token\");\n        require(amountIn > 0, \"Invalid amount\");\n        uint256 taxAmount = (amountIn * AgentToken(fromToken).taxPercentage() / 10000);\n        uint256 protocolSwapAmount = taxAmount + accumulatedTaxToSwapByAgent[fromToken];\n        accumulatedTaxToSwapByAgent[fromToken] = 0;\n        uint256 userSwapAfterTax = amountIn - taxAmount;\n        uint256 actualSpecTax;\n        IERC20Upgradeable(fromToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        if(agentTokenUniswapPool[fromToken] != address(0)) {\n            address[] memory path = new address[](2);\n            path[0] = fromToken;\n            path[1] = spectralToken;\n            IERC20Upgradeable(fromToken).approve(address(uniswapRouter), userSwapAfterTax);\n            \n\n            //Uniswap checks if amount received > amountOutMin\n            uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(userSwapAfterTax, amountOutMin, path, msg.sender, deadline);\n\n            //Swap the current tax and accumulated tax that was from outside our protocol operations (since this contract is ignored in the conditions of the agentToken tax taking)\n            uint256 protocolSpecAmount = getSPECReceived(protocolSwapAmount, fromToken);\n            uint256 initialSpecBalance = IERC20(spectralToken).balanceOf(address(this));\n            IERC20Upgradeable(fromToken).approve(address(uniswapRouter), protocolSwapAmount);\n            uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(protocolSwapAmount, (protocolSpecAmount * 95) / 100, path, address(this), deadline);\n            uint256 specBalance = IERC20(spectralToken).balanceOf(address(this)) - initialSpecBalance;\n            actualSpecTax = specBalance;\n        } else {\n            uint256 userSpecAmount = getSPECReceived(userSwapAfterTax, fromToken);\n            require(userSpecAmount >= amountOutMin, \"Insufficient SPEC output\");\n            agentTokensSold[fromToken] -= userSwapAfterTax;\n            totalSPECDeposited[fromToken] -= userSpecAmount;\n            IERC20Upgradeable(spectralToken).safeTransfer(msg.sender, userSpecAmount);\n            uint256 protocolSpecAmount = getSPECReceived(protocolSwapAmount, fromToken);\n            agentTokensSold[fromToken] -= protocolSwapAmount;\n            totalSPECDeposited[fromToken] -= protocolSpecAmount;\n            actualSpecTax = protocolSpecAmount;\n            emit TokensRedeemedForSPEC(fromToken, msg.sender, userSwapAfterTax, userSpecAmount);\n        }\n        if(actualSpecTax == 0) {\n            return;\n        }\n        _distributeSwapFees(actualSpecTax);\n    }\n\n    function accumulateSwapFees(uint256 amount) external onlyAgentToken() {\n        accumulatedTaxToSwapByAgent[msg.sender] += amount;\n        emit TaxAccumulated(amount,accumulatedTaxToSwapByAgent[msg.sender]);\n    }\n\n    function _distributeSwapFees(uint256 specAmount) internal {\n        uint256 splitAmount = specAmount / 2;\n        IERC20(spectralToken).transfer(feeWallet, splitAmount);\n        IERC20(spectralToken).approve(address(spectralStaking), splitAmount);\n        spectralStaking.addDistributionToBuffer(spectralToken, address(0), splitAmount, 0);\n        emit TaxDistributed(specAmount);\n    }\n\n    function distributeTradingProfitsToStakers(uint256 _amount, address _token) external onlyDistributor {\n        require(_token != address(0), \"ZERO_ADDRESS\");\n        require(_amount > 0, \"AMOUNT_ZERO\");\n        require(address(spectralStaking) != address(0), \"STAKING_ADDRESS_ZERO\");\n        IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20Upgradeable(_token).approve(address(spectralStaking),_amount);\n        spectralStaking.addDistribution(_token, address(0), _amount, 0);\n        emit ProfitDistributed(_token, _amount);\n    }\n\n    function deployUniswapPool(address token) internal whenNotPaused returns(address) {\n        address pair;\n        try IUniswapV2Factory(uniswapFactory).createPair(token, spectralToken) returns (address createdPair) {\n            pair = createdPair;\n            agentTokenUniswapPool[token] = pair;\n            emit UniswapV2PoolCreated(token, pair);\n            return pair;\n        } catch {\n            pair = IUniswapV2Factory(uniswapFactory).getPair(token, spectralToken);\n            emit UniswapV2PoolCreationFailed(token, pair);\n            return address(0);\n        }\n    }\n\n    function withdrawTokens(address token, uint amount) public onlyOwner whenNotPaused {\n        require(IERC20Upgradeable(token).balanceOf(address(this)) >= amount, \"Insufficient balance\");\n        IERC20Upgradeable(token).safeTransfer(owner(), amount);\n    }\n\n    function withdrawEther(uint amount) public onlyOwner whenNotPaused {\n        require(address(this).balance >= amount, \"Insufficient balance\");\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function setParameter(Parameter param, uint256 value) external onlyOwner whenNotPaused {\n        parameters[param] = value;\n        emit ParameterSet(param, value);\n    }\n\n    /* Someone could buy AGENT tokens and set up a pool before liquidity conditions are met in this contract,\n    so we need to account for this and potentially set it up in here retrospectively */\n    function addAlreadyExistingUniswapPool(address token, address pool) external onlyAdminOrOwner whenNotPaused {\n        require(pool != address(0), \"ZERO_ADDRESS\");\n        require(agentTokens[token], \"Invalid agent token\");\n        agentTokenUniswapPool[token] = pool;\n        emit UniswapV2PoolCreated(token, pool);\n    }\n\n    function setAdmin(address _admin) external onlyOwner whenNotPaused {\n        require(_admin != address(0), \"ZERO_ADDRESS\");\n        admin = _admin;\n    }\n\n    function upgradeAllAgents(address newImplementation) external onlyOwner {\n        require(newImplementation != address(0), \"ZERO_ADDRESS\");\n        agentTokenImplementation = newImplementation;\n        updateBeaconLogic(newImplementation);\n        ++agentsVersion;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {\n        require(newImplementation != address(0), \"ZERO_ADDRESS\");\n        ++version;\n    }\n\n    function pause() external OnlyPauserOrOwner {\n        paused = true;\n    }\n\n    function unpause() external onlyOwner {\n        paused = false;\n    }\n\n    function isAgentToken(address token) public view returns (bool) {\n        return agentTokens[token];\n    }\n\n    function setPauser(address _pauser) external onlyOwner() {\n        require(_pauser != address(0), \"ZERO_ADDRESS\");\n        pauser = _pauser;\n    }\n\n    function setDistributor(address _distributor) external onlyOwner() {\n        require(_distributor != address(0), \"ZERO_ADDRESS\");\n        distributor = IOctoDistributor(_distributor);\n        emit DistributorSet(_distributor);\n    }\n\n    function setSpectralStaking(address _spectralStaking) external onlyOwner() {\n        require(_spectralStaking != address(0), \"ZERO_ADDRESS\");\n        spectralStaking = ISpectralStaking(_spectralStaking);\n        emit SpectralStakingSet(_spectralStaking);\n    }\n}",
        "AgentImageService.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IAutonomousAgentDeployer.sol\";\nimport \"./interfaces/IOctoDistributor.sol\";\n\ncontract AgentImageService is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct ImageRequest {\n        address user;\n        uint256 amount;\n        uint256 width;\n        uint256 height;\n        uint256 timestamp;\n        uint256 fulfilled;\n        uint256 refunded;\n        string prompt;\n    }\n    struct Agent {\n        string agentName;\n        string agentTicker;\n        string agentDescription;\n    }\n\n    struct AgentConfig {\n        uint256 pricePerImage;\n        string imageDescription;\n        uint256 refundTimeLimit; // Time in seconds after which refund is possible\n        bool isConfigured;\n    }\n\n    enum Parameter {\n        TREASURY_CUT\n    }\n\n    mapping(address => Agent) public agents;\n    // Agent token address => Agent configuration\n    mapping(address => AgentConfig) public agentConfigs;\n    \n    // Agent token address => accumulated fees ready for withdrawal\n    mapping(address => uint256) public accumulatedFees;\n    \n    // Agent token address => amount locked in pending requests\n    mapping(address => uint256) public pendingFees;\n    \n    // Agent token address => request hash => ImageRequest\n    mapping(address => mapping(bytes32 => ImageRequest)) public imageRequests;\n    \n    // Agent token address => all request IDs for that agent\n    mapping(address => bytes32[]) private agentRequestIds;\n    \n    // Agent token address => index => whether request has been processed (fulfilled or refunded)\n    mapping(address => mapping(bytes32 => bool)) private requestProcessed;\n\n    mapping(Parameter => uint256) public parameters;\n    \n    IAutonomousAgentDeployer public deployer;\n    address public spectralTreasury;\n\n    uint16 public version;\n\n    uint256[50] __gap; // Reserved space\n\n    event AgentConfigured(address indexed agentToken, uint256 price, string description, uint256 refundTimeLimit);\n    event ImageRequested(address indexed agentToken, address indexed user, bytes32 indexed requestId, uint256 amount, uint256 width, uint256 height, string prompt);\n    event ImageFulfilled(address indexed agentToken, bytes32 indexed requestId);\n    event FeesWithdrawn(address indexed agentToken, uint256 amount);\n    event RefundIssued(address indexed agentToken, bytes32 indexed requestId, uint256 amount);\n    event ImageAgentDeployed(string agentName, string agentTicker, string agentDescription, address indexed owner, address indexed agentToken, uint256 minSpecAmount, uint256 tokenAmountOut);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _deployer, address _spectralTreasury, uint16 _treasuryCut) public initializer {\n        require(_deployer != address(0), \"AgentImageService: deployer cannot be zero address\");\n        require(_spectralTreasury != address(0), \"AgentImageService: spectral treasury cannot be zero address\");\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        parameters[Parameter.TREASURY_CUT] = _treasuryCut;\n        spectralTreasury = _spectralTreasury;\n        deployer = IAutonomousAgentDeployer(_deployer);\n        version = 1;\n    }\n\n    modifier onlyAgentOwner(address agentToken) {\n        require(IOctoDistributor(address(deployer.distributor())).agentCreators(agentToken) == msg.sender, \"AgentImageService: : Not agent owner\");\n        _;\n    }\n\n    modifier onlyValidAgent(address agentToken) {\n        require(deployer.isAgentToken(agentToken), \"AgentImageService: : Invalid agent token\");\n        _;\n    }\n\n    function getAgentCreator(address agentToken) external view returns (address) {\n        return IOctoDistributor(address(deployer.distributor())).agentCreators(agentToken);\n    }\n\n    function deployImageAgent(\n        string memory agentName,\n        string memory agentTicker,\n        string memory agentDescription,\n        address owner,\n        uint256 minSpecAmount) external payable returns (address agentToken) {\n        require(owner != address(0), \"AgentImageService: Owner cannot be zero address\");\n        require(msg.value >= deployer.parameters(IAutonomousAgentDeployer.Parameter.DEPLOYMENT_COST_ETH), \"AgentImageService: Incorrect ETH amount sent for deployment\");\n        // only transfer ETH to the this contract from the user in the next lines\n        (agentToken) = deployer.deployAgentWithETH{value: msg.value}(agentName, agentTicker, minSpecAmount);\n        agents[agentToken] = Agent({\n            agentName: agentName,\n            agentTicker: agentTicker,\n            agentDescription: agentDescription\n        });\n        agentConfigs[agentToken] = AgentConfig({\n            pricePerImage: 1 ether, // Default to 0 until configured\n            imageDescription: \"\",\n            refundTimeLimit: 1 days, // Default to 0 until configured\n            isConfigured: true\n        });\n        uint256 tokenAmountOut = IERC20Upgradeable(agentToken).balanceOf(address(this));\n        IERC20Upgradeable(agentToken).safeTransfer(owner, tokenAmountOut);\n        emit ImageAgentDeployed(agentName, agentTicker, agentDescription, owner, agentToken, minSpecAmount, tokenAmountOut);\n\n    }\n\n    function _configureAgent(\n        address agentToken,\n        uint256 pricePerImage,\n        string memory imageDescription,\n        uint256 refundTimeLimit\n    ) internal {\n        require(pricePerImage > 0, \"Price must be greater than 0\");\n        require(refundTimeLimit > 0, \"Refund time limit must be greater than 0\");\n        \n        agentConfigs[agentToken] = AgentConfig({\n            pricePerImage: pricePerImage,\n            imageDescription: imageDescription,\n            refundTimeLimit: refundTimeLimit,\n            isConfigured: true\n        });\n    }\n\n    function configureAgent(\n        address agentToken,\n        uint256 pricePerImage,\n        string memory imageDescription,\n        uint256 refundTimeLimit\n    ) external onlyAgentOwner(agentToken) onlyValidAgent(agentToken) {\n        require(!agentConfigs[agentToken].isConfigured, \"Agent already configured\");\n        _configureAgent(agentToken, pricePerImage, imageDescription, refundTimeLimit);\n\n        emit AgentConfigured(agentToken, pricePerImage, imageDescription, refundTimeLimit);\n    }\n\n    function requestImage(\n        address agentToken,\n        string calldata prompt,\n        uint256 width,\n        uint256 height\n    ) external nonReentrant onlyValidAgent(agentToken) {\n        AgentConfig memory config = agentConfigs[agentToken];\n        require(config.isConfigured, \"Agent not configured\");\n        require(bytes(prompt).length > 0, \"Prompt cannot be empty\");\n        require(width >= 64 && height >= 64, \"Width and height must be greater or equal than 64\");\n        IERC20Upgradeable token = IERC20Upgradeable(agentToken);\n        \n        // Generate request ID from prompt and timestamp\n        bytes32 requestId = keccak256(abi.encodePacked(prompt, block.timestamp, msg.sender));\n        \n        // Transfer tokens from user to this contract\n        token.safeTransferFrom(msg.sender, address(this), config.pricePerImage);\n        \n        // Record the request\n        imageRequests[agentToken][requestId] = ImageRequest({\n            user: msg.sender,\n            amount: config.pricePerImage,\n            width: width,\n            height: height,\n            timestamp: block.timestamp,\n            fulfilled: 0,\n            refunded: 0,\n            prompt: prompt\n        });\n\n        // Add to pending fees instead of accumulated\n        pendingFees[agentToken] += config.pricePerImage;\n        \n        emit ImageRequested(agentToken, msg.sender, requestId, config.pricePerImage, width, height, prompt);\n    }\n\n    function fulfillImage(\n        address agentToken,\n        bytes32 requestId\n    ) external onlyAgentOwner(agentToken) onlyValidAgent(agentToken) nonReentrant {\n        ImageRequest storage request = imageRequests[agentToken][requestId];\n        require(request.fulfilled == 0 && request.refunded == 0, \"Request already processed\");\n        require(request.user != address(0), \"Request does not exist\");\n        \n        request.fulfilled = block.timestamp;\n        \n        // Move fee from pending to accumulated\n        pendingFees[agentToken] -= request.amount;\n        uint256 treasuryCut = (request.amount * parameters[Parameter.TREASURY_CUT]) / 10000;\n        accumulatedFees[agentToken] += (request.amount - treasuryCut);\n        IERC20Upgradeable(agentToken).safeTransfer(spectralTreasury, (request.amount * parameters[Parameter.TREASURY_CUT]) / 10000);\n        \n        emit ImageFulfilled(agentToken, requestId);\n    }\n\n    function requestRefund(\n        address agentToken,\n        bytes32 requestId\n    ) external nonReentrant {\n        ImageRequest storage request = imageRequests[agentToken][requestId];\n        AgentConfig memory config = agentConfigs[agentToken];\n        \n        require(request.user == msg.sender, \"Not request owner\");\n        require(request.fulfilled == 0 && request.refunded == 0, \"Request already processed\");\n        require(\n            block.timestamp >= request.timestamp + config.refundTimeLimit,\n            \"Refund time limit not reached\"\n        );\n\n        request.refunded = block.timestamp;\n        \n        // Remove from pending fees\n        pendingFees[agentToken] -= request.amount;\n        \n        // Transfer tokens back to user\n        IERC20Upgradeable(agentToken).safeTransfer(msg.sender, request.amount);\n        \n        emit RefundIssued(agentToken, requestId, request.amount);\n    }\n\n    function withdrawFees(address agentToken) external onlyAgentOwner(agentToken) nonReentrant {\n        uint256 amount = accumulatedFees[agentToken];\n        require(amount > 0, \"No fees to withdraw\");\n        \n        accumulatedFees[agentToken] = 0;\n        IERC20Upgradeable(agentToken).safeTransfer(msg.sender, amount);\n        \n        emit FeesWithdrawn(agentToken, amount);\n    }\n\n    function getRequestDetails(\n        address agentToken,\n        bytes32 requestId\n    ) external view returns (\n        address user,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 fulfilled,\n        uint256 refunded,\n        string memory prompt\n    ) {\n        ImageRequest memory request = imageRequests[agentToken][requestId];\n        return (\n            request.user,\n            request.amount,\n            request.timestamp,\n            request.fulfilled,\n            request.refunded,\n            request.prompt\n        );\n    }\n\n    // Helper function to check if an agent has any pending fees\n    function getPendingFees(address agentToken) public view returns (uint256) {\n        return pendingFees[agentToken];\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {\n        require(newImplementation != address(0), \"ZERO_ADDRESS\");\n        ++version;\n    }\n} "
    }
}