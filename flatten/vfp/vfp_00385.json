{
    "vfp_id": "vfp_00385",
    "project_name": "cantina_coinbase_flywheel_sep2025.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "owner_ is not used in the Adconversion constructor",
            "description": "The AdConversion constructor accepts an owner_ parameter that is never used, and the contract lacks any ownership-based access control. The cause is redundant code or incomplete implementation. This does not pose a security risk but may confuse developers. The impact is purely code clarity and maintenance, with no effect on functionality or security.\n",
            "severity": "Informational",
            "location": [
                "AdConversion.sol#L190"
            ],
            "files": [
                "flywheel/src/hooks/AdConversion.sol"
            ]
        }
    ],
    "affected_files": {
        "AdConversion.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {CampaignHooks} from \"../CampaignHooks.sol\";\nimport {Flywheel} from \"../Flywheel.sol\";\nimport {BuilderCodes} from \"../BuilderCodes.sol\";\n\n/// @title AdConversion\n///\n/// @notice Attribution hook for processing ad conversions\n///\n/// @dev Handles both onchain and offchain conversion events\n///\n/// @author Coinbase\ncontract AdConversion is CampaignHooks {\n    // Conversion configuration structure\n    struct ConversionConfig {\n        /// @dev Whether the conversion config is active\n        bool isActive;\n        /// @dev Whether the conversion event is onchain\n        bool isEventOnchain;\n        /// @dev URI to extra metadata for offchain events\n        string metadataURI;\n    }\n\n    // Input structure for creating conversion configs (without isActive)\n    struct ConversionConfigInput {\n        /// @dev Whether the conversion event is onchain\n        bool isEventOnchain;\n        /// @dev URI to extra metadata for offchain events\n        string metadataURI;\n    }\n\n    /// @notice Attribution structure containing payout and conversion data\n    struct Attribution {\n        /// @dev The conversion data\n        Conversion conversion;\n        /// @dev Empty bytes if offchain conversion, encoded log data if onchain\n        bytes logBytes;\n    }\n\n    /// @notice Conversion data structure\n    struct Conversion {\n        /// @dev Unique identifier for the conversion event\n        bytes16 eventId;\n        /// @dev Click identifier\n        string clickId;\n        /// @dev Configuration ID for the conversion (0 = no config/unregistered)\n        uint16 configId;\n        /// @dev Referral code\n        string publisherRefCode;\n        /// @dev Timestamp of the conversion\n        uint32 timestamp;\n        /// @dev Recipient address for the conversion, zero address implies using the referral code registry to get the payout address\n        address payoutRecipient;\n        /// @dev Amount of the payout for this conversion\n        uint256 payoutAmount;\n    }\n\n    /// @notice Structure for recording onchain attribution events\n    struct Log {\n        /// @dev Chain ID where the transaction occurred\n        uint256 chainId;\n        /// @dev Transaction hash where the conversion occurred\n        bytes32 transactionHash;\n        /// @dev Index of the event log in the transaction\n        uint256 index;\n    }\n\n    /// @notice Structure for recording finalization information\n    struct CampaignState {\n        /// @dev Address of the advertiser\n        address advertiser;\n        /// @dev Whether this campaign has a publisher allowlist\n        bool hasAllowlist;\n        /// @dev Attribution provider fee in basis points, cached at campaign creation\n        uint16 attributionProviderFeeBps;\n        /// @dev Address of the attribution provider\n        address attributionProvider;\n        /// @dev Duration for attribution deadline specific to this campaign\n        uint48 attributionWindow;\n        /// @dev Timestamp when finalization can occur\n        uint48 attributionDeadline;\n    }\n\n    /// @notice Maximum basis points\n    uint16 public constant MAX_BPS = 10_000;\n\n    /// @notice Maximum number of conversion configs per campaign (65535 since we use uint16, IDs are 1-indexed)\n    uint16 public constant MAX_CONVERSION_CONFIGS = type(uint16).max;\n\n    /// @notice Address of the publisher registry contract\n    BuilderCodes public immutable publisherCodesRegistry;\n\n    /// @notice Mapping of campaign addresses to their URI\n    mapping(address campaign => string uri) public override campaignURI;\n\n    /// @notice Mapping of campaign addresses to finalization information\n    mapping(address campaign => CampaignState) public state;\n\n    /// @notice Mapping from campaign to allowed publisher ref codes\n    mapping(address campaign => mapping(string publisherRefCode => bool allowed)) public allowedPublishers;\n\n    /// @notice Mapping from campaign to conversion configs by config ID\n    mapping(address campaign => mapping(uint16 configId => ConversionConfig)) public conversionConfigs;\n\n    /// @notice Mapping from campaign to number of conversion configs\n    mapping(address campaign => uint16) public conversionConfigCount;\n\n    /// @notice Emitted when an offchain attribution event occurred\n    ///\n    /// @param campaign Address of the campaign\n    /// @param isPublisherPayout True if original payout address was zero (publisher payout via registry)\n    /// @param conversion The conversion data\n    event OffchainConversionProcessed(address indexed campaign, bool isPublisherPayout, Conversion conversion);\n\n    /// @notice Emitted when an onchain attribution event occurred\n    ///\n    /// @param campaign Address of the campaign\n    /// @param isPublisherPayout True if original payout address was zero (publisher payout via registry)\n    /// @param conversion The conversion data\n    /// @param log The onchain log data\n    event OnchainConversionProcessed(address indexed campaign, bool isPublisherPayout, Conversion conversion, Log log);\n\n    /// @notice Emitted when attribution deadline is updated\n    ///\n    /// @param campaign Address of the campaign\n    /// @param deadline The new deadline\n    event AttributionDeadlineUpdated(address indexed campaign, uint48 deadline);\n\n    /// @notice Emitted when a new conversion config is added to a campaign\n    event ConversionConfigAdded(address indexed campaign, uint16 indexed configId, ConversionConfig config);\n\n    /// @notice Emitted when a conversion config is disabled\n    event ConversionConfigStatusChanged(address indexed campaign, uint16 indexed configId, bool isActive);\n\n    /// @notice Emitted when a publisher is added to campaign allowlist\n    event PublisherAddedToAllowlist(address indexed campaign, string publisherRefCode);\n\n    /// @notice Emitted when an ad campaign is created\n    ///\n    /// @param campaign Address of the campaign\n    /// @param attributionProvider Address of the attribution provider\n    /// @param advertiser Address of the advertiser\n    /// @param uri Campaign URI\n    /// @param attributionWindow Duration for attribution deadline in seconds\n    event AdCampaignCreated(\n        address indexed campaign, address attributionProvider, address advertiser, string uri, uint48 attributionWindow\n    );\n\n    /// @notice Error thrown when an unauthorized action is attempted\n    error Unauthorized();\n\n    /// @notice Emitted when an invalid fee BPS is provided\n    ///\n    /// @param feeBps The invalid fee BPS\n    error InvalidFeeBps(uint16 feeBps);\n\n    /// @notice Error thrown when referral code is invalid\n    error InvalidPublisherRefCode();\n\n    /// @notice Error thrown when referral code is not in allowlist\n    error PublisherNotAllowed();\n\n    /// @notice Error thrown when conversion config ID is invalid\n    error InvalidConversionConfigId();\n\n    /// @notice Error thrown when conversion config is disabled\n    error ConversionConfigDisabled();\n\n    /// @notice Error thrown when conversion type doesn't match config\n    error InvalidConversionType();\n\n    /// @notice Error thrown when trying to add too many conversion configs\n    error TooManyConversionConfigs();\n\n    /// @notice Error thrown when attribution deadline duration is invalid (if non-zero, must be in days precision)\n    ///\n    /// @param duration The invalid duration\n    error InvalidAttributionWindow(uint48 duration);\n\n    /// @notice Error thrown when an invalid address is provided\n    error ZeroAddress();\n\n    /// @notice Constructor for ConversionAttestation\n    ///\n    /// @param protocol_ Address of the protocol contract\n    /// @param owner_ Address of the contract owner\n    /// @param publisherCodesRegistry_ Address of the referral code registry contract\n    constructor(address protocol_, address owner_, address publisherCodesRegistry_) CampaignHooks(protocol_) {\n        if (publisherCodesRegistry_ == address(0)) revert ZeroAddress();\n\n        publisherCodesRegistry = BuilderCodes(publisherCodesRegistry_);\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onCreateCampaign(address campaign, uint256 nonce, bytes calldata hookData) internal override {\n        (\n            address attributionProvider,\n            address advertiser,\n            string memory uri,\n            string[] memory allowedPublisherRefCodes,\n            ConversionConfigInput[] memory configs,\n            uint48 campaignAttributionWindow,\n            uint16 attributionProviderFeeBps\n        ) = abi.decode(hookData, (address, address, string, string[], ConversionConfigInput[], uint48, uint16));\n\n        // Validate attribution deadline duration (if non-zero, must be in days precision)\n        if (campaignAttributionWindow % 1 days != 0) revert InvalidAttributionWindow(campaignAttributionWindow);\n\n        // Validate attribution window is between 0 and 6 months (180 days)\n        if (campaignAttributionWindow > 180 days) revert InvalidAttributionWindow(campaignAttributionWindow);\n\n        // Validate attribution provider fee\n        if (attributionProviderFeeBps > MAX_BPS) revert InvalidFeeBps(attributionProviderFeeBps);\n\n        bool hasAllowlist = allowedPublisherRefCodes.length > 0;\n\n        // Store campaign state\n        state[campaign] = CampaignState({\n            attributionProvider: attributionProvider,\n            advertiser: advertiser,\n            attributionDeadline: 0,\n            attributionWindow: campaignAttributionWindow,\n            hasAllowlist: hasAllowlist,\n            attributionProviderFeeBps: attributionProviderFeeBps\n        });\n        campaignURI[campaign] = uri;\n\n        // Set up allowed publishers mapping if allowlist exists\n        if (hasAllowlist) {\n            uint256 publisherCount = allowedPublisherRefCodes.length;\n            for (uint256 i = 0; i < publisherCount; i++) {\n                allowedPublishers[campaign][allowedPublisherRefCodes[i]] = true;\n                emit PublisherAddedToAllowlist(campaign, allowedPublisherRefCodes[i]);\n            }\n        }\n\n        // Store conversion configs\n        conversionConfigCount[campaign] = uint16(configs.length);\n        uint256 count = configs.length;\n        for (uint16 i = 0; i < count; i++) {\n            uint16 configId = i + 1;\n            // Always set isActive to true for new configs\n            ConversionConfig memory activeConfig = ConversionConfig({\n                isActive: true,\n                isEventOnchain: configs[i].isEventOnchain,\n                metadataURI: configs[i].metadataURI\n            });\n            conversionConfigs[campaign][configId] = activeConfig;\n            emit ConversionConfigAdded(campaign, configId, activeConfig);\n        }\n\n        // Emit campaign creation event with all decoded data\n        emit AdCampaignCreated(campaign, attributionProvider, advertiser, uri, campaignAttributionWindow);\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onSend(address attributionProvider, address campaign, address payoutToken, bytes calldata hookData)\n        internal\n        override\n        returns (\n            Flywheel.Payout[] memory payouts,\n            Flywheel.Payout[] memory, /*immediateFees*/\n            Flywheel.Allocation[] memory delayedFees\n        )\n    {\n        // Validate that the caller is the authorized attribution provider for this campaign\n        if (attributionProvider != state[campaign].attributionProvider) revert Unauthorized();\n\n        // Get the fee from the cached campaign state\n        uint16 feeBps = state[campaign].attributionProviderFeeBps;\n\n        // Decode only the attributions from hookData\n        Attribution[] memory attributions = abi.decode(hookData, (Attribution[]));\n\n        // Arrays to track unique recipients and their accumulated amounts\n        address[] memory recipients = new address[](attributions.length);\n        uint256[] memory amounts = new uint256[](attributions.length);\n        uint256 uniqueCount = 0;\n        uint256 feeAmount = 0;\n\n        // Loop over attributions, deducting attribution fee from payout amount and emitting appropriate events\n        uint256 count = attributions.length;\n        for (uint256 i = 0; i < count; i++) {\n            // Validate referral code exists in the registry\n            string memory publisherRefCode = attributions[i].conversion.publisherRefCode;\n            if (bytes(publisherRefCode).length != 0 && !publisherCodesRegistry.isRegistered(publisherRefCode)) {\n                revert InvalidPublisherRefCode();\n            }\n\n            // Check if referral code is in allowlist (if allowlist exists)\n            if (state[campaign].hasAllowlist) {\n                if (bytes(publisherRefCode).length != 0 && !allowedPublishers[campaign][publisherRefCode]) {\n                    revert PublisherNotAllowed();\n                }\n            }\n\n            // Validate conversion config (if configId is not 0)\n            uint16 configId = attributions[i].conversion.configId;\n            bytes memory logBytes = attributions[i].logBytes;\n\n            // Validating that the config exists\n            if (configId != 0) {\n                if (configId > conversionConfigCount[campaign]) {\n                    revert InvalidConversionConfigId();\n                }\n\n                ConversionConfig memory config = conversionConfigs[campaign][configId];\n\n                // Validate that the conversion type matches the config\n                if (config.isEventOnchain && logBytes.length == 0) revert InvalidConversionType();\n                if (!config.isEventOnchain && logBytes.length > 0) revert InvalidConversionType();\n            }\n\n            address payoutAddress = attributions[i].conversion.payoutRecipient;\n\n            // Determine if attribution was for a publisher (original payout address was zero)\n            bool isPublisherPayout = (payoutAddress == address(0));\n\n            // If the recipient is the zero address, we use the referral code registry to get the payout address\n            if (isPublisherPayout) {\n                payoutAddress = publisherCodesRegistry.payoutAddress(publisherRefCode);\n                attributions[i].conversion.payoutRecipient = payoutAddress;\n            }\n\n            // Deduct attribution fee from payout amount\n            uint256 netAmount = attributions[i].conversion.payoutAmount;\n            if (feeBps > 0) {\n                uint256 attributionFee = (attributions[i].conversion.payoutAmount * feeBps) / MAX_BPS;\n                feeAmount += attributionFee;\n                netAmount -= attributionFee;\n            }\n\n            // Find if this payoutAddress already exists in our tracking arrays\n            bool found = false;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (recipients[j] == payoutAddress) {\n                    amounts[j] += netAmount;\n                    found = true;\n                    break;\n                }\n            }\n\n            // If not found, add as new recipient\n            if (!found && netAmount > 0) {\n                recipients[uniqueCount] = payoutAddress;\n                amounts[uniqueCount] = netAmount;\n                uniqueCount++;\n            }\n\n            // Emit onchain conversion if logBytes is present, else emit offchain conversion\n            Conversion memory conversion = attributions[i].conversion;\n\n            if (logBytes.length > 0) {\n                emit OnchainConversionProcessed(campaign, isPublisherPayout, conversion, abi.decode(logBytes, (Log)));\n            } else {\n                emit OffchainConversionProcessed(campaign, isPublisherPayout, conversion);\n            }\n        }\n\n        // Create the final payouts array with only unique recipients\n        payouts = new Flywheel.Payout[](uniqueCount);\n        for (uint256 i = 0; i < uniqueCount; i++) {\n            payouts[i] = Flywheel.Payout({recipient: recipients[i], amount: amounts[i], extraData: \"\"});\n        }\n\n        // Add delayed fee for attribution provider to claim later\n        if (feeAmount > 0) {\n            delayedFees = new Flywheel.Allocation[](1);\n            delayedFees[0] =\n                Flywheel.Allocation({key: bytes32(bytes20(attributionProvider)), amount: feeAmount, extraData: \"\"});\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    /// @dev Only advertiser allowed to withdraw funds on finalized campaigns\n    function _onWithdrawFunds(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        returns (Flywheel.Payout memory payout)\n    {\n        if (sender != state[campaign].advertiser) revert Unauthorized();\n        if (flywheel.campaignStatus(campaign) != Flywheel.CampaignStatus.FINALIZED) revert Unauthorized();\n\n        (address recipient, uint256 amount) = abi.decode(hookData, (address, uint256));\n        return (Flywheel.Payout({recipient: recipient, amount: amount, extraData: \"\"}));\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onDistributeFees(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        returns (Flywheel.Distribution[] memory distributions)\n    {\n        if (sender != state[campaign].attributionProvider) revert Unauthorized();\n        bytes32 key = bytes32(bytes20(sender));\n        uint256 amount = flywheel.allocatedFee(campaign, token, key);\n        address recipient = abi.decode(hookData, (address));\n\n        distributions = new Flywheel.Distribution[](1);\n        distributions[0] = Flywheel.Distribution({recipient: recipient, key: key, amount: amount, extraData: \"\"});\n        return distributions;\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onUpdateStatus(\n        address sender,\n        address campaign,\n        Flywheel.CampaignStatus oldStatus,\n        Flywheel.CampaignStatus newStatus,\n        bytes calldata hookData\n    ) internal override {\n        address attributionProvider = state[campaign].attributionProvider;\n        address advertiser = state[campaign].advertiser;\n\n        // Only attribution provider and advertiser can update status\n        if (sender != attributionProvider && sender != advertiser) {\n            revert Unauthorized();\n        }\n\n        // Advertiser constraints from INACTIVE: only INACTIVE → FINALIZED allowed\n        if (oldStatus == Flywheel.CampaignStatus.INACTIVE) {\n            if (sender == advertiser && newStatus != Flywheel.CampaignStatus.FINALIZED) {\n                revert Unauthorized();\n            }\n            // Attribution provider constraint: cannot do INACTIVE → FINALIZING/FINALIZED (fund recovery is advertiser-only)\n            if (sender == attributionProvider && (newStatus != Flywheel.CampaignStatus.ACTIVE)) {\n                revert Unauthorized();\n            }\n        }\n\n        // Security restriction: No one can pause active campaigns (ACTIVE → INACTIVE)\n        if (oldStatus == Flywheel.CampaignStatus.ACTIVE && newStatus == Flywheel.CampaignStatus.INACTIVE) {\n            revert Unauthorized();\n        }\n\n        // Attribution window protection: Advertiser cannot bypass FINALIZING (ACTIVE → FINALIZED) but Attribution Provider can\n        if (oldStatus == Flywheel.CampaignStatus.ACTIVE && newStatus == Flywheel.CampaignStatus.FINALIZED) {\n            if (sender == advertiser) {\n                revert Unauthorized();\n            }\n        }\n\n        // Set attribution deadline when entering FINALIZING\n        if (newStatus == Flywheel.CampaignStatus.FINALIZING) {\n            state[campaign].attributionDeadline = uint48(block.timestamp) + state[campaign].attributionWindow;\n            emit AttributionDeadlineUpdated(campaign, state[campaign].attributionDeadline);\n        }\n\n        // Attribution deadline enforcement for FINALIZING → FINALIZED for Advertiser\n        if (oldStatus == Flywheel.CampaignStatus.FINALIZING && newStatus == Flywheel.CampaignStatus.FINALIZED) {\n            if (sender == advertiser && state[campaign].attributionDeadline > block.timestamp) {\n                revert Unauthorized();\n            }\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onUpdateMetadata(address sender, address campaign, bytes calldata hookData) internal override {\n        if (sender != state[campaign].attributionProvider && sender != state[campaign].advertiser) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @notice Adds a referral code to the campaign allowlist\n    /// @param campaign Address of the campaign\n    /// @param publisherRefCode Referral code to add\n    /// @dev Only advertiser can add referral codes to allowlist\n    function addAllowedPublisherRefCode(address campaign, string memory publisherRefCode) external {\n        if (msg.sender != state[campaign].advertiser) revert Unauthorized();\n\n        // Validate referral code exists in registry\n        if (!publisherCodesRegistry.isRegistered(publisherRefCode)) {\n            revert InvalidPublisherRefCode();\n        }\n\n        // @notice: if the allowlist is not enabled during campaign creation, we revert\n        if (!state[campaign].hasAllowlist) {\n            revert Unauthorized();\n        }\n\n        // Check if already allowed to avoid redundant operations\n        if (allowedPublishers[campaign][publisherRefCode]) {\n            return; // Already allowed, no-op\n        }\n\n        // Add to mapping\n        allowedPublishers[campaign][publisherRefCode] = true;\n        emit PublisherAddedToAllowlist(campaign, publisherRefCode);\n    }\n\n    /// @notice Adds a new conversion config to an existing campaign\n    /// @param campaign Address of the campaign\n    /// @param config The conversion config input (without isActive)\n    /// @dev Only advertiser can add conversion configs\n    function addConversionConfig(address campaign, ConversionConfigInput memory config) external {\n        if (msg.sender != state[campaign].advertiser) revert Unauthorized();\n\n        uint16 currentCount = conversionConfigCount[campaign];\n        if (currentCount >= type(uint16).max) revert TooManyConversionConfigs();\n\n        // Add the new config - always set isActive to true\n        uint16 newConfigId = currentCount + 1;\n        ConversionConfig memory activeConfig =\n            ConversionConfig({isActive: true, isEventOnchain: config.isEventOnchain, metadataURI: config.metadataURI});\n        conversionConfigs[campaign][newConfigId] = activeConfig;\n        conversionConfigCount[campaign] = newConfigId;\n\n        emit ConversionConfigAdded(campaign, newConfigId, activeConfig);\n    }\n\n    /// @notice Disables a conversion config for a campaign\n    /// @param campaign Address of the campaign\n    /// @param configId The ID of the conversion config to disable\n    /// @dev Only advertiser can disable conversion configs\n    function disableConversionConfig(address campaign, uint16 configId) external {\n        if (msg.sender != state[campaign].advertiser) revert Unauthorized();\n\n        if (configId == 0 || configId > conversionConfigCount[campaign]) {\n            revert InvalidConversionConfigId();\n        }\n\n        // Check if config is already disabled\n        if (!conversionConfigs[campaign][configId].isActive) revert ConversionConfigDisabled();\n\n        // Disable the config\n        conversionConfigs[campaign][configId].isActive = false;\n\n        emit ConversionConfigStatusChanged(campaign, configId, false);\n    }\n\n    /// @notice Checks if a campaign has a publisher allowlist\n    /// @param campaign Address of the campaign\n    /// @return True if the campaign has an allowlist\n    function hasPublisherAllowlist(address campaign) external view returns (bool) {\n        return state[campaign].hasAllowlist;\n    }\n\n    /// @notice Checks if a referral code is allowed for a campaign\n    /// @param campaign Address of the campaign\n    /// @param publisherRefCode Referral code to check\n    /// @return True if the referral code is allowed (or if no allowlist exists)\n    function isPublisherRefCodeAllowed(address campaign, string memory publisherRefCode) external view returns (bool) {\n        // If no allowlist exists, all referral codes are allowed\n        if (!state[campaign].hasAllowlist) {\n            return true;\n        }\n        return allowedPublishers[campaign][publisherRefCode];\n    }\n\n    /// @notice Gets a conversion config for a campaign\n    /// @param campaign Address of the campaign\n    /// @param configId The ID of the conversion config\n    /// @return The conversion config\n    function getConversionConfig(address campaign, uint16 configId) external view returns (ConversionConfig memory) {\n        if (configId == 0 || configId > conversionConfigCount[campaign]) {\n            revert InvalidConversionConfigId();\n        }\n        return conversionConfigs[campaign][configId];\n    }\n}\n"
    }
}