{
    "vfp_id": "vfp_00345",
    "project_name": "ChainSecurity_Plusplus_AG_Plusplus_Custody_audit_1.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Duplicate Inputs Can Overwrite Storage",
            "description": "This vulnerability exists in the ZCHFSavingsManager contract's createDeposits function, which failed to prevent duplicate identifiers within the same input array. Although the function checked that identifiers were not already in use, it did not validate uniqueness within the batch itself. As a result, if an operator provided the same identifier multiple times, the last occurrence would overwrite prior entries, leading to untracked deposits. The root cause is the lack of intra-batch duplicate checking during deposit creation. A malicious or erroneous operator could exploit this by submitting duplicate IDs, causing the contract state to lose track of intermediate deposits. This leads to inconsistent accounting, as multiple DepositCreated events would be emitted without corresponding DepositRedeemed events upon redemption. The impact includes potential misuse of untracked deposits via moveZCHF() and discrepancies between event logs and actual state, undermining auditability and trust in the system. This issue was resolved in Version 2 by adding a check that reverts if a deposit's createdAt is already non-zero during batch processing.\n",
            "severity": "Low",
            "location": [
                "ZCHFSavingsManager.sol::createDeposits"
            ],
            "files": [
                "plusplus-custody/src/ZCHFSavingsManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Tick-accrual Mismatch on New Deposit",
            "description": "The ZCHFSavingsManager contract experiences a temporary accounting mismatch due to the way the Frankencoin Savings module handles tick accrual after new deposits. When new funds are deposited, the module applies a weighted delay to the account's tick baseline, causing a pause in interest accrual until currentTicks() catches up. However, the manager's getDepositDetails function does not account for this pause and continues to report increasing interest based on currentTicks(), even though no actual interest is being accrued during the delay period. The root cause is the discrepancy between the module's account-based tick advancement and the manager's assumption of continuous accrual. An operator could exploit this by redeeming deposits during the delay window, potentially withdrawing more than what has actually accrued. The impact is a temporary overstatement of redeemable value, which could lead to a shortfall if all deposits were redeemed simultaneously during the delay. However, this risk is mitigated by maintaining a buffer of unwithdrawn fees that generate sufficient interest to cover any over-withdrawals. The issue is acknowledged by the team and considered acceptable under operational processes.\n",
            "severity": "Informational",
            "location": [
                "ZCHFSavingsManager.sol::getDepositDetails",
                "ZCHFSavingsManager.sol::createDeposits"
            ],
            "files": [
                "plusplus-custody/src/ZCHFSavingsManager.sol"
            ]
        }
    ],
    "affected_files": {
        "ZCHFSavingsManager.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {RedemptionLimiter} from \"./RedemptionLimiter.sol\";\n\n/// @notice Minimal ERC-20 interface used for basic token operations\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address who) external view returns (uint256);\n}\n\n/// @notice Minimal interface for interacting with the Frankencoin savings module\ninterface IFrankencoinSavings {\n    function save(uint192 amount) external;\n    function currentTicks() external view returns (uint64);\n    function currentRatePPM() external view returns (uint24);\n    function INTEREST_DELAY() external view returns (uint64);\n    function withdraw(address target, uint192 amount) external returns (uint256);\n}\n\n/// @title ZCHFSavingsManager\n/// @notice Manages batch deposits into the Frankencoin Savings Module with delayed interest and fee deduction.\n/// @dev Tracks each deposit independently using an identifier, computes accrued interest using the external tick-based system,\n/// and deducts a fixed annual fee on interest. Only entities with OPERATOR_ROLE can create/redeem deposits.\n/// Funds can only be received by addresses with RECEIVER_ROLE.\n/// @author Plusplus AG (dev@plusplus.swiss)\n/// @custom:security-contact security@plusplus.swiss\ncontract ZCHFSavingsManager is AccessControl, ReentrancyGuard, RedemptionLimiter {\n    /// @notice Role required to create or redeem deposits\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    /// @notice Role required to receive withdrawn or rescued funds\n    bytes32 public constant RECEIVER_ROLE = keccak256(\"RECEIVER_ROLE\");\n\n    /// @notice Annual fee in parts per million (ppm). For example, 12,500 ppm = 1.25% yearly.\n    /// @dev Uint24 is used by the savings module for all ppm values.\n    uint24 public constant FEE_ANNUAL_PPM = 12_500;\n\n    /// @notice Struct representing a single tracked customer deposit\n    /// @dev `ticksAtDeposit` includes a delay to skip initial non-interest-bearing period.\n    struct Deposit {\n        /// @dev Amount originally deposited into the savings module (principal). Uint192 is used by the savings module for all amount variables.\n        uint192 initialAmount;\n        /// @dev Block timestamp when the deposit was created. Uint40 is used by the savings module for all timestamps.\n        uint40 createdAt;\n        /// @dev Tick count (ppm-seconds) at which interest accrual starts for this deposit. Uint64 is used by the savings module for all tick variables.\n        uint64 ticksAtDeposit;\n    }\n\n    /// @notice Mapping of unique deposit identifiers to deposit metadata\n    /// @dev The identifier is a hashed customer ID, to retain pseudonimity on-chain.\n    ///      No way to enumerate deposits as it is not needed by the contract logic. Use events or identifier lists.\n    mapping(bytes32 => Deposit) public deposits;\n\n    IERC20 public immutable ZCHF;\n    IFrankencoinSavings public immutable savingsModule;\n\n    /// @notice Emitted when a new deposit is created\n    /// @param identifier Hashed customer ID\n    /// @param amount The amount deposited in ZCHF\n    event DepositCreated(bytes32 indexed identifier, uint192 amount);\n\n    /// @notice Emitted when a deposit is redeemed\n    /// @param identifier Hashed customer ID\n    /// @param totalAmount Amount withdrawn (principal + net interest)\n    event DepositRedeemed(bytes32 indexed identifier, uint192 totalAmount);\n\n    // ===========================\n    // Custom Errors\n    // ===========================\n\n    /// @notice Thrown when a deposit with the given identifier already exists\n    error DepositAlreadyExists(bytes32 identifier);\n\n    /// @notice Thrown when a deposit with the given identifier is not found\n    error DepositNotFound(bytes32 identifier);\n\n    /// @notice Thrown when expected positive amount is given as zero\n    error ZeroAmount();\n\n    /// @notice Thrown when transferFrom fails\n    error TransferFromFailed(address from, address to, uint256 amount);\n\n    /// @notice Thrown when an address lacks the RECEIVER_ROLE\n    error InvalidReceiver(address receiver);\n\n    /// @notice Thrown when input arrays do not match in length or other argument errors occur\n    error InvalidArgument();\n\n    /// @notice Thrown when withdrawal from the savings module is not the expected amount\n    error UnexpectedWithdrawalAmount();\n\n    /// @notice Initializes the manager and grants initial roles\n    /// @dev This contract grants itself RECEIVER_ROLE for internal redemptions.\n    /// @param admin Address to receive DEFAULT_ADMIN_ROLE\n    /// @param zchfToken Address of the deployed ZCHF token contract\n    /// @param savingsModule_ Address of the deployed Frankencoin savings module\n    constructor(address admin, address zchfToken, address savingsModule_) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(RECEIVER_ROLE, address(this));\n        ZCHF = IERC20(zchfToken);\n        savingsModule = IFrankencoinSavings(savingsModule_);\n\n        // Not needed as the savings module is a registered minter with max allowance to move funds\n        // ZCHF.approve(address(savingsModule), type(uint256).max);\n    }\n\n    /// @notice Sets the daily redemption limit for a user (in ZCHF).\n    /// @dev Only callable by DEFAULT_ADMIN_ROLE. See {RedemptionLimiter-_setDailyRedemptionLimit}.\n    /// @param user The operator whose limit is being set.\n    /// @param dailyLimit The daily quota (in ZCHF) for the rolling window.\n    function setDailyLimit(address user, uint192 dailyLimit) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setDailyRedemptionLimit(user, dailyLimit);\n    }\n\n    /// @notice Creates one or more deposits and forwards the total amount to the savings module.\n    /// @dev Each deposit is assigned a unique identifier and accrues interest starting after a fixed delay.\n    ///      Reverts if any identifier already exists or any amount is zero. Saves once for all.\n    /// @param identifiers Unique identifiers for each deposit. Is a hash of the customer ID (must not be reused).\n    /// @param amounts Corresponding deposit amounts (must match identifiers length, non-zero)\n    /// @param source The address providing the ZCHF. If `address(this)`, will skip pulling funds.\n    function createDeposits(bytes32[] calldata identifiers, uint192[] calldata amounts, address source)\n        external\n        onlyRole(OPERATOR_ROLE)\n        nonReentrant\n    {\n        uint256 len = identifiers.length;\n        if (len != amounts.length) revert InvalidArgument();\n\n        uint256 totalAmount;\n\n        // Pre-validate and sum amounts\n        for (uint256 i = 0; i < len; ++i) {\n            uint192 amt = amounts[i];\n\n            if (amt == 0) revert ZeroAmount();\n\n            totalAmount += amt;\n        }\n\n        // Pull funds from source, if applicable\n        if (source != address(this)) {\n            bool success = ZCHF.transferFrom(source, address(this), totalAmount);\n            if (!success) revert TransferFromFailed(source, address(this), totalAmount);\n        }\n\n        // In theory, totalAmount can overflow when cast down. This must be an Input error.\n        if (totalAmount > type(uint192).max) revert InvalidArgument();\n\n        // Forward to savings module in a single save() call\n        savingsModule.save(uint192(totalAmount));\n\n        // Interest starts accruing only after a fixed delay (defined in savings module).\n        // Precompute common tick baseline and post-delay snapshot\n        uint64 baseTicks = savingsModule.currentTicks();\n        uint24 rate = savingsModule.currentRatePPM();\n        uint64 delay = savingsModule.INTEREST_DELAY();\n        uint64 tickDelay = uint64(uint256(rate) * delay);\n        uint64 ticksAtDeposit = baseTicks + tickDelay;\n        uint40 ts = uint40(block.timestamp);\n\n        // Record each individual deposit\n        for (uint256 i = 0; i < len; ++i) {\n            bytes32 id = identifiers[i];\n            uint192 amt = amounts[i];\n\n            if (deposits[id].createdAt != 0) revert DepositAlreadyExists(id);\n            deposits[id] = Deposit({initialAmount: amt, createdAt: ts, ticksAtDeposit: ticksAtDeposit});\n\n            emit DepositCreated(id, amt);\n        }\n    }\n\n    /// @notice Redeems a batch of deposits and forwards the total redeemed funds (principal + net interest) to a receiver.\n    /// @dev Each deposit is deleted after redemption. The total amount is withdrawn in a single call to the savings module.\n    ///      Operators must respect their daily redemption limit.\n    /// @param identifiers Unique identifiers (hashed customer IDs) of the deposits to redeem\n    /// @param receiver Address that will receive the ZCHF; must have RECEIVER_ROLE\n    function redeemDeposits(bytes32[] calldata identifiers, address receiver)\n        external\n        onlyRole(OPERATOR_ROLE)\n        nonReentrant\n    {\n        if (!hasRole(RECEIVER_ROLE, receiver)) revert InvalidReceiver(receiver);\n\n        uint192 totalAmount;\n\n        // Process each identifier and sum withdrawal amounts\n        for (uint256 i = 0; i < identifiers.length; ++i) {\n            bytes32 id = identifiers[i];\n            Deposit storage deposit = deposits[id];\n            uint192 initialAmount = deposit.initialAmount;\n\n            if (initialAmount == 0) revert DepositNotFound(id);\n\n            (, uint192 netInterest) = getDepositDetails(id);\n            uint192 totalForDeposit = initialAmount + netInterest;\n\n            emit DepositRedeemed(id, totalForDeposit);\n\n            totalAmount += totalForDeposit;\n            delete deposits[id];\n        }\n\n        _useMyRedemptionQuota(totalAmount);\n\n        // Withdraw the full amount from savings to receiver and confirm the amount\n        // (Savings module will silently return less if not enough available)\n        uint256 withdrawn = savingsModule.withdraw(receiver, totalAmount);\n        if (withdrawn != totalAmount) revert UnexpectedWithdrawalAmount();\n    }\n\n    /// @notice Returns the current principal and net interest for a given deposit\n    /// @dev Accrual is calculated from `ticksAtDeposit` to current tick count.\n    /// @param identifier The unique identifier of the deposit\n    /// @return initialAmount The originally deposited amount (principal)\n    /// @return netInterest The interest accrued after fee deduction\n    function getDepositDetails(bytes32 identifier) public view returns (uint192 initialAmount, uint192 netInterest) {\n        Deposit storage deposit = deposits[identifier];\n\n        initialAmount = deposit.initialAmount;\n        if (initialAmount == 0) return (0, 0);\n\n        uint40 createdAt = deposit.createdAt;\n        uint64 currentTicks = savingsModule.currentTicks();\n\n        uint64 ticksAtDeposit = deposit.ticksAtDeposit;\n        uint64 deltaTicks = currentTicks > ticksAtDeposit ? currentTicks - ticksAtDeposit : 0;\n\n        // Total interest accrued over deposit lifetime (accounts for initial delay via `ticksAtDeposit`)\n        uint256 totalInterest = (uint256(deltaTicks) * initialAmount) / 1_000_000 / 365 days;\n\n        // Fee is time-based, not tick-based. Converts elapsed time to tick-equivalent.\n        uint256 duration = block.timestamp - createdAt;\n        uint256 feeableTicks = duration * FEE_ANNUAL_PPM;\n\n        // Cap the fee to ensure it's never higher than the actual earned ticks\n        uint256 feeTicks = feeableTicks < deltaTicks ? feeableTicks : deltaTicks;\n\n        uint256 fee = feeTicks * initialAmount / 1_000_000 / 365 days;\n\n        // Net interest must not be negative\n        // The following clamp is not strictly required, since we clamp the feeTicks above.\n        // It is still included to be explicit and futureproof.\n        netInterest = totalInterest > fee ? uint192(totalInterest - fee) : 0;\n\n        return (initialAmount, netInterest);\n    }\n\n    /// @notice Forwards ZCHF to the savings module without creating a tracked deposit.\n    /// @dev Useful for correcting underfunding or over-withdrawal. Funds are added on behalf of this contract.\n    /// @param source The address from which ZCHF should be pulled. Use `address(this)` if funds are already held.\n    /// @param amount The amount of ZCHF to forward. Caller must have OPERATOR_ROLE.\n    function addZCHF(address source, uint192 amount) public onlyRole(OPERATOR_ROLE) nonReentrant {\n        if (amount == 0) revert ZeroAmount();\n\n        // Pull ZCHF from external source if needed\n        if (source != address(this)) {\n            bool success = ZCHF.transferFrom(source, address(this), amount);\n            if (!success) revert TransferFromFailed(source, address(this), amount);\n        }\n\n        // Save on behalf of the contract (untracked)\n        savingsModule.save(amount);\n    }\n\n    /// @notice Moves funds from the savings module to a receiver, either to collect fees or migrate balances.\n    /// @dev Reverts if not enough funds are available in the savings module.\n    /// @param receiver Must have RECEIVER_ROLE\n    /// @param amount The maximum amount of ZCHF to move\n    function moveZCHF(address receiver, uint192 amount) public onlyRole(OPERATOR_ROLE) nonReentrant {\n        if (amount == 0) revert ZeroAmount();\n        if (!hasRole(RECEIVER_ROLE, receiver)) revert InvalidReceiver(receiver);\n\n        uint256 movedAmount = savingsModule.withdraw(receiver, amount);\n        if (movedAmount != amount) revert UnexpectedWithdrawalAmount();\n    }\n\n    /// @notice Recovers arbitrary ERC-20 tokens or ETH accidentally sent to this contract\n    /// @dev If a token doesn't follow the ERC-20 specs, rescue can not be guaranteed\n    /// @param token Address of the token to recover (use zero address for ETH)\n    /// @param receiver Must have RECEIVER_ROLE\n    /// @param amount The amount to recover\n    function rescueTokens(address token, address receiver, uint256 amount)\n        public\n        onlyRole(OPERATOR_ROLE)\n        nonReentrant\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (!hasRole(RECEIVER_ROLE, receiver)) revert InvalidReceiver(receiver);\n        if (token == address(0)) {\n            payable(receiver).transfer(amount);\n        } else {\n            IERC20(token).transfer(receiver, amount);\n        }\n    }\n}\n"
    }
}