{
    "vfp_id": "vfp_00345",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 59,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing sanity checks could cause unexpected behavior",
            "description": "Several functions lack basic sanity checks, such as validating member existence, non-zero addresses, or sufficient balances. Examples include proposeVeto(), proposalReplace(), setDelegate(), and payOutContract().\nThe root cause is missing require() guards that would prevent invalid state transitions.\nAn attacker could trigger reverts, cause incorrect state updates, or drain funds if balance checks are missing (e.g., in payOutContract).\nThe impact is inconsistent state or operational failures, though most issues are low risk due to trusted caller assumptions.\n",
            "severity": "Informational",
            "location": [
                "RocketDAOSecurityProposals.sol#L157-L162",
                "RocketDAOSecurityProposals.sol#L166-L171",
                "RocketDAOSecurityProposals.sol#L177-L180",
                "RocketDAOSecurityUpgrade.sol#L44-L53",
                "RocketNetworkVoting.sol#L100-L105",
                "RocketNodeManager.sol#L250-L261",
                "RocketNodeStaking.sol#L332-L340",
                "RocketClaimDAO.sol#L182-L221"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/security/RocketDAOSecurityProposals.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAOSecurityProposals.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketBase} from \"../../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../../interface/RocketStorageInterface.sol\";\nimport {RocketVaultInterface} from \"../../../interface/RocketVaultInterface.sol\";\nimport {RocketDAOProposalInterface} from \"../../../interface/dao/RocketDAOProposalInterface.sol\";\nimport {RocketDAOProtocolInterface} from \"../../../interface/dao/protocol/RocketDAOProtocolInterface.sol\";\nimport {RocketDAOProtocolSettingsSecurityInterface} from \"../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsSecurityInterface.sol\";\nimport {RocketDAOProtocolSettingsNetworkInterface} from \"../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport {RocketDAOSecurityActionsInterface} from \"../../../interface/dao/security/RocketDAOSecurityActionsInterface.sol\";\nimport {RocketDAOSecurityInterface} from \"../../../interface/dao/security/RocketDAOSecurityInterface.sol\";\nimport {RocketDAOSecurityProposalsInterface} from \"../../../interface/dao/security/RocketDAOSecurityProposalsInterface.sol\";\nimport {RocketNetworkRevenuesInterface} from \"../../../interface/network/RocketNetworkRevenuesInterface.sol\";\nimport {IERC20Burnable} from \"../../../interface/util/IERC20Burnable.sol\";\n\n/// @notice Proposal contract for the security council\ncontract RocketDAOSecurityProposals is RocketBase, RocketDAOSecurityProposalsInterface {\n\n    // The namespace for any data stored in the trusted node DAO (do not change)\n    string constant internal daoNameSpace = \"dao.security.\";\n\n    // The namespace of the DAO that setting changes get applied to (protocol DAO)\n    string constant internal protocolDaoSettingNamespace = \"dao.protocol.setting.\";\n\n    /// @dev Only allow certain contracts to execute methods\n    modifier onlyExecutingContracts() {\n        // Methods are either executed by bootstrapping methods in rocketDAONodeTrusted or by people executing passed proposals in rocketDAOProposal\n        require(msg.sender == getContractAddress(\"rocketDAOProtocol\") || msg.sender == getContractAddress(\"rocketDAOProposal\"), \"Sender is not permitted to access executing methods\");\n        _;\n    }\n\n    /// @dev Only allow security councils to vote\n    modifier onlySecurityMember() {\n        require(getBool(keccak256(abi.encodePacked(daoNameSpace, \"member\", msg.sender))), \"Sender is not a security council member\");\n        _;\n    }\n\n    /// @dev Reverts if the provided setting is not within the accepted set of settings\n    modifier onlyValidSetting(string memory _settingNameSpace, string memory _settingPath) {\n        if (!getBool(keccak256(abi.encodePacked(\"dao.security.allowed.setting\", _settingNameSpace, _settingPath)))) {\n            revert(\"Setting is not modifiable by security council\");\n        }\n        _;\n    }\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 2;\n    }\n\n    /// @notice Creates a new proposal for this DAO\n    /// @param _proposalMessage A short message explaining what this proposal does\n    /// @param _payload An ABI encoded payload which is executed on the proposal contract upon execution of this proposal\n    function propose(string memory _proposalMessage, bytes memory _payload) override external onlySecurityMember() onlyLatestContract(\"rocketDAOSecurityProposals\", address(this)) returns (uint256) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        RocketDAOSecurityInterface daoSecurity = RocketDAOSecurityInterface(getContractAddress(\"rocketDAOSecurity\"));\n        RocketDAOProtocolSettingsSecurityInterface rocketDAOProtocolSettingsSecurity = RocketDAOProtocolSettingsSecurityInterface(getContractAddress(\"rocketDAOProtocolSettingsSecurity\"));\n        // Create the proposal\n        return daoProposal.add(msg.sender, \"rocketDAOSecurityProposals\", _proposalMessage, block.timestamp + 1, rocketDAOProtocolSettingsSecurity.getVoteTime(), rocketDAOProtocolSettingsSecurity.getExecuteTime(), daoSecurity.getMemberQuorumVotesRequired(), _payload);\n    }\n\n    /// @notice Vote on a proposal\n    /// @param _proposalID The ID of the proposal to vote on\n    /// @param _support Whether the caller votes in favour or against the proposal\n    function vote(uint256 _proposalID, bool _support) override external onlySecurityMember() onlyLatestContract(\"rocketDAOSecurityProposals\", address(this)) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        RocketDAOSecurityInterface daoSecurity = RocketDAOSecurityInterface(getContractAddress(\"rocketDAOSecurity\"));\n        // Did they join after this proposal was created? If so, they can't vote or it'll throw off the set proposalVotesRequired\n        require(daoSecurity.getMemberJoinedTime(msg.sender) < daoProposal.getCreated(_proposalID), \"Member cannot vote on proposal created before they became a member\");\n        // Vote now, one vote per trusted node member\n        daoProposal.vote(msg.sender, 1 ether, _proposalID, _support);\n    }\n\n    /// @notice Cancel a proposal\n    /// @param _proposalID The ID of the proposal to cancel\n    function cancel(uint256 _proposalID) override external onlySecurityMember() onlyLatestContract(\"rocketDAOSecurityProposals\", address(this)) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        // Cancel now, will succeed if it is the original proposer\n        daoProposal.cancel(msg.sender, _proposalID);\n    }\n\n    /// @notice Execute a successful proposal\n    /// @param _proposalID The ID of the proposal to execute\n    function execute(uint256 _proposalID) override external onlyLatestContract(\"rocketDAOSecurityProposals\", address(this)) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        // Execute now\n        daoProposal.execute(_proposalID);\n    }\n\n    /*** Proposal - Settings **********************/\n\n    /// @notice Change one of the current uint256 settings of the protocol DAO\n    /// @param _settingNameSpace The namespace of the setting to change\n    /// @param _settingPath The setting path to change\n    /// @param _value The new value for the setting\n    function proposalSettingUint(string memory _settingNameSpace, string memory _settingPath, uint256 _value) override public onlyExecutingContracts() onlyValidSetting(_settingNameSpace, _settingPath) {\n        bytes32 namespace = keccak256(abi.encodePacked(protocolDaoSettingNamespace, _settingNameSpace));\n        setUint(keccak256(abi.encodePacked(namespace, _settingPath)), _value);\n\n        // Security council adder requires additional processing\n        if (keccak256(bytes(_settingNameSpace)) == keccak256(bytes(\"network\"))) {\n            if (keccak256(bytes(_settingPath)) == keccak256(bytes(\"network.node.commission.share.security.council.adder\"))) {\n                RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n\n                // Check guardrails\n                uint256 maxAdderValue = rocketDAOProtocolSettingsNetwork.getMaxNodeShareSecurityCouncilAdder();\n                require(_value <= maxAdderValue, \"Value must be <= max value\");\n                uint256 maxVoterValue = rocketDAOProtocolSettingsNetwork.getVoterShare();\n                require(_value <= maxVoterValue, \"Value must be <= voter share\");\n\n                // Notify RocketNetworkRevenue of the changes to voter and node share\n                RocketNetworkRevenuesInterface rocketNetworkRevenues = RocketNetworkRevenuesInterface(getContractAddress(\"rocketNetworkRevenues\"));\n                rocketNetworkRevenues.setVoterShare(rocketDAOProtocolSettingsNetwork.getEffectiveVoterShare());\n                rocketNetworkRevenues.setNodeShare(rocketDAOProtocolSettingsNetwork.getEffectiveNodeShare());\n            }\n        }\n    }\n\n    /// @notice Change one of the current bool settings of the protocol DAO\n    /// @param _settingNameSpace The namespace of the setting to change\n    /// @param _settingPath The setting path to change\n    /// @param _value The new value for the setting\n    function proposalSettingBool(string memory _settingNameSpace, string memory _settingPath, bool _value) override public onlyExecutingContracts() onlyValidSetting(_settingNameSpace, _settingPath) {\n        bytes32 namespace = keccak256(abi.encodePacked(protocolDaoSettingNamespace, _settingNameSpace));\n        setBool(keccak256(abi.encodePacked(namespace, _settingPath)), _value);\n    }\n\n    /// @notice Change one of the current address settings of the protocol DAO\n    /// @param _settingNameSpace The namespace of the setting to change\n    /// @param _settingPath The setting path to change\n    /// @param _value The new value for the setting\n    function proposalSettingAddress(string memory _settingNameSpace, string memory _settingPath, address _value) override public onlyExecutingContracts() onlyValidSetting(_settingNameSpace, _settingPath) {\n        bytes32 namespace = keccak256(abi.encodePacked(protocolDaoSettingNamespace, _settingNameSpace));\n        setAddress(keccak256(abi.encodePacked(namespace, _settingPath)), _value);\n    }\n\n    /*** Proposal - Members **********************/\n\n    /// @dev Called by rocketDAOProtocolProposals to execute an invite in this namespace\n    /// @param _id A unique identifier for the new member\n    /// @param _memberAddress The address of the new member\n    function proposalInvite(string calldata _id, address _memberAddress) override public onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) {\n        // Their proposal executed, record the block\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.executed.time\", \"invited\", _memberAddress)), block.timestamp);\n        // Ok all good, lets get their invitation and member data setup\n        // They are initially only invited to join, so their membership isn't set as true until they accept it in RocketDAONodeTrustedActions\n        _memberInit(_id, _memberAddress);\n    }\n\n    /// @dev Called by rocketDAOProtocolProposals to execute a kick in this namespace\n    /// @param _memberAddress The address of the member to kick\n    function proposalKick(address _memberAddress) override public onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) {\n        // Load contracts\n        RocketDAOSecurityActionsInterface daoActionsContract = RocketDAOSecurityActionsInterface(getContractAddress(\"rocketDAOSecurityActions\"));\n        // Kick them now\n        daoActionsContract.actionKick(_memberAddress);\n    }\n\n    /// @dev Called by rocketDAOProtocolProposals to execute a kick of multiple members in this namespace\n    /// @param _memberAddresses An array of addresses of the members to kick\n    function proposalKickMulti(address[] calldata _memberAddresses) override public onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) {\n        // Load contracts\n        RocketDAOSecurityActionsInterface daoActionsContract = RocketDAOSecurityActionsInterface(getContractAddress(\"rocketDAOSecurityActions\"));\n        // Kick them now\n        daoActionsContract.actionKickMulti(_memberAddresses);\n    }\n\n    /// @dev Called by rocketDAOProtocolProposals to execute an member replacement in this namespace\n    /// @param _existingMemberAddress The address of the member to kick\n    /// @param _newMemberId A unique identifier for the new member\n    /// @param _newMemberAddress The address of the member to invite\n    function proposalReplace(address _existingMemberAddress, string calldata _newMemberId, address _newMemberAddress) override external onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) {\n        proposalKick(_existingMemberAddress);\n        proposalInvite(_newMemberId, _newMemberAddress);\n    }\n\n    /*** Methods - Internal ***************/\n\n    /// @dev Add a new potential members data, they must accept the invite to become an actual member\n    /// @param _id A unique ID for the new member\n    /// @param _memberAddress The address of the new member\n    function _memberInit(string memory _id, address _memberAddress) private {\n        // Load contracts\n        RocketDAOSecurityInterface daoSecurity = RocketDAOSecurityInterface(getContractAddress(\"rocketDAOSecurity\"));\n        // Check current node status\n        require(!daoSecurity.getMemberIsValid(_memberAddress), \"This node is already part of the security council\");\n        // Verify the ID is min 3 chars\n        require(bytes(_id).length >= 3, \"The ID for this new member must be at least 3 characters\");\n        // Member initial data, not official until the bool is flagged as true\n        setBool(keccak256(abi.encodePacked(daoNameSpace, \"member\", _memberAddress)), false);\n        setAddress(keccak256(abi.encodePacked(daoNameSpace, \"member.address\", _memberAddress)), _memberAddress);\n        setString(keccak256(abi.encodePacked(daoNameSpace, \"member.id\", _memberAddress)), _id);\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.joined.time\", _memberAddress)), 0);\n    }\n}\n"
    }
}