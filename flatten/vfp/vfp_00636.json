{
    "vfp_id": "vfp_00636",
    "project_name": "ackee-blockchain-vfat-sickle-report.pdf",
    "findings": [
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Misleading error name",
            "description": "The TransactionNotReadyToExecute error in SickleMultisig.sol is used when a transaction fails due to an insufficient number of signatures, but the name does not clearly reflect this condition. The cause is that the error name is ambiguous and does not accurately describe the specific failure condition, leading to potential confusion during debugging or integration. This cannot be exploited maliciously, but it may mislead developers interpreting error logs or handling exceptions. The impact is limited to code clarity and developer experience, with no direct security or financial consequences.\n",
            "severity": "Informational",
            "location": [
                "SickleMultisig.sol::TransactionNotReadyToExecute#333"
            ],
            "files": [
                "sickle-public/contracts/governance/SickleMultisig.sol"
            ]
        },
        {
            "id": 21,
            "category": {},
            "title": "Unconsolidated storage variable definitions",
            "description": "In SickleMultisig.sol, the _signers variable is defined far from other storage variables (at line 253), while others are at the top. The root cause is inconsistent code organization. This can mislead developers about the storage layout, potentially causing incorrect assumptions during upgrades or audits. The impact is primarily on code maintainability and safety in upgradeable contexts, where storage layout must be preserved. Misplaced variables increase the risk of storage collisions in proxy patterns.\n",
            "severity": "Informational",
            "location": [
                "SickleMultisig.sol::_signers"
            ],
            "files": [
                "sickle-public/contracts/governance/SickleMultisig.sol"
            ]
        }
    ],
    "affected_files": {
        "SickleMultisig.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract SickleMultisig {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Data structures\n\n    struct Proposal {\n        address[] targets;\n        bytes[] calldatas;\n        string description;\n    }\n\n    struct Transaction {\n        // Calls to be executed in the transaction\n        Proposal proposal;\n        // Transaction state\n        bool exists;\n        bool executed;\n        bool cancelled;\n        // Settings nonce that the transaction was created with\n        uint256 settingsNonce;\n        // Signing state\n        uint256 signatures;\n        mapping(address => bool) signed;\n    }\n\n    // Errors\n\n    error NotASigner();\n    error NotMultisig();\n\n    error InvalidProposal();\n    error InvalidThreshold();\n\n    error TransactionDoesNotExist();\n    error TransactionNotReadyToExecute();\n    error TransactionNoLongerValid();\n    error TransactionAlreadyExists();\n    error TransactionAlreadySigned();\n    error TransactionAlreadyExecuted();\n    error TransactionAlreadyCancelled();\n\n    error SignerAlreadyAdded();\n    error SignerAlreadyRemoved();\n    error SignerCannotBeRemoved();\n\n    // Events\n\n    event SignerAdded(address signer);\n    event SignerRemoved(address signer);\n\n    event ThresholdChanged(uint256 newThreshold);\n\n    event TransactionProposed(uint256 proposalId, address signer);\n    event TransactionSigned(uint256 proposalId, address signer);\n    event TransactionExecuted(uint256 proposalId, address signer);\n    event TransactionCancelled(uint256 proposalId, address signer);\n\n    // Public storage\n\n    uint256 public threshold;\n    uint256 public settingsNonce;\n    mapping(uint256 => Transaction) public transactions;\n\n    // Initialization\n\n    constructor(address initialSigner) {\n        // Initialize with only a single signer and a threshold of 1. The signer\n        // can add more signers and update the threshold using a proposal.\n        _addSigner(initialSigner);\n        _setThreshold(1);\n    }\n\n    // Signer-only actions\n\n    /// @notice Propose a new transaction to be executed from the multisig\n    /// @custom:access Restricted to multisig signers.\n    function propose(Proposal memory proposal)\n        public\n        onlySigner\n        returns (uint256)\n    {\n        return _propose(proposal);\n    }\n\n    /// @notice Sign a transaction\n    /// @custom:access Restricted to multisig signers.\n    function sign(uint256 proposalId) public onlySigner {\n        _sign(proposalId);\n    }\n\n    /// @notice Cancel a transaction that hasn't been executed or invalidated\n    /// @custom:access Restricted to multisig signers.\n    function cancel(uint256 proposalId) public onlySigner {\n        _cancel(proposalId);\n    }\n\n    /// @notice Execute a transaction that has passed the signatures threshold\n    /// @custom:access Restricted to multisig signers.\n    function execute(uint256 proposalId) public onlySigner {\n        _execute(proposalId);\n    }\n\n    // Multisig-only actions\n\n    /// @notice Add a signer to the multisig\n    /// @custom:access Restricted to multisig transactions.\n    function addSigner(address signer) public onlyMultisig {\n        _addSigner(signer);\n    }\n\n    /// @notice Remove a signer from the multisig\n    /// @custom:access Restricted to multisig transactions.\n    function removeSigner(address signer) public onlyMultisig {\n        _removeSigner(signer);\n    }\n\n    /// @notice Remove a signer from the multisig\n    /// @custom:access Restricted to multisig transactions.\n    function replaceSigner(\n        address oldSigner,\n        address newSigner\n    ) public onlyMultisig {\n        _addSigner(newSigner);\n        _removeSigner(oldSigner);\n    }\n\n    /// @notice Set a new signatures threshold for the multisig\n    /// @custom:access Restricted to multisig transactions.\n    function setThreshold(uint256 newThreshold) public onlyMultisig {\n        _setThreshold(newThreshold);\n    }\n\n    // Public functions\n\n    function signerCount() public view returns (uint256) {\n        return _signers.length();\n    }\n\n    function signerAddresses() public view returns (address[] memory) {\n        return _signers.values();\n    }\n\n    function isSigner(address signer) public view returns (bool) {\n        return _signers.contains(signer);\n    }\n\n    function hashProposal(Proposal memory proposal)\n        public\n        view\n        returns (uint256)\n    {\n        return uint256(\n            keccak256(\n                abi.encode(\n                    block.chainid,\n                    proposal.targets,\n                    proposal.calldatas,\n                    proposal.description\n                )\n            )\n        );\n    }\n\n    function getProposal(uint256 proposalId)\n        public\n        view\n        returns (Proposal memory)\n    {\n        return transactions[proposalId].proposal;\n    }\n\n    function exists(uint256 proposalId) public view returns (bool) {\n        return transactions[proposalId].exists;\n    }\n\n    function executed(uint256 proposalId) public view returns (bool) {\n        return transactions[proposalId].executed;\n    }\n\n    function cancelled(uint256 proposalId) public view returns (bool) {\n        return transactions[proposalId].cancelled;\n    }\n\n    function signatures(uint256 proposalId) public view returns (uint256) {\n        return transactions[proposalId].signatures;\n    }\n\n    function signed(\n        uint256 proposalId,\n        address signer\n    ) public view returns (bool) {\n        return transactions[proposalId].signed[signer];\n    }\n\n    // Modifiers\n\n    modifier onlySigner() {\n        if (!isSigner(msg.sender)) {\n            revert NotASigner();\n        }\n\n        _;\n    }\n\n    modifier onlyMultisig() {\n        if (msg.sender != address(this)) {\n            revert NotMultisig();\n        }\n\n        _;\n    }\n\n    modifier changesSettings() {\n        _;\n        settingsNonce += 1;\n    }\n\n    // Internals\n\n    EnumerableSet.AddressSet private _signers;\n\n    function _propose(Proposal memory proposal) internal returns (uint256) {\n        // Check that the proposal is valid\n        if (proposal.targets.length != proposal.calldatas.length) {\n            revert InvalidProposal();\n        }\n\n        // Retrieve transaction details\n        uint256 proposalId = hashProposal(proposal);\n        Transaction storage transaction = transactions[proposalId];\n\n        // Validate transaction state\n        if (transaction.exists) revert TransactionAlreadyExists();\n\n        // Initialize transaction statue\n        transaction.exists = true;\n        transaction.proposal = proposal;\n        transaction.settingsNonce = settingsNonce;\n\n        // Emit event\n        emit TransactionProposed(proposalId, msg.sender);\n\n        // Add a signature from the current signer\n        _sign(proposalId);\n\n        return proposalId;\n    }\n\n    function _validateTransaction(Transaction storage transaction)\n        internal\n        view\n    {\n        if (!transaction.exists) revert TransactionDoesNotExist();\n        if (transaction.executed) revert TransactionAlreadyExecuted();\n        if (transaction.cancelled) revert TransactionAlreadyCancelled();\n        if (transaction.settingsNonce != settingsNonce) {\n            revert TransactionNoLongerValid();\n        }\n    }\n\n    function _sign(uint256 proposalId) internal {\n        // Retrieve transaction details\n        Transaction storage transaction = transactions[proposalId];\n\n        // Validate transaction state\n        _validateTransaction(transaction);\n        if (transaction.signed[msg.sender]) revert TransactionAlreadySigned();\n\n        // Update transaction state\n        transaction.signatures += 1;\n        transaction.signed[msg.sender] = true;\n\n        // Emit event\n        emit TransactionSigned(proposalId, msg.sender);\n    }\n\n    function _cancel(uint256 proposalId) internal {\n        // Retrieve transaction details\n        Transaction storage transaction = transactions[proposalId];\n\n        // Validate transaction state\n        _validateTransaction(transaction);\n\n        // Update transaction state\n        transaction.cancelled = true;\n\n        // Emit event\n        emit TransactionCancelled(proposalId, msg.sender);\n    }\n\n    function _execute(uint256 proposalId) internal {\n        // Retrieve transaction details\n        Transaction storage transaction = transactions[proposalId];\n\n        // Validate transaction state\n        _validateTransaction(transaction);\n\n        // Check if the transaction has enough signatures\n        if (transaction.signatures < threshold) {\n            revert TransactionNotReadyToExecute();\n        }\n\n        // Update transaction state\n        transaction.executed = true;\n\n        // Execute calls\n        uint256 length = transaction.proposal.targets.length;\n        for (uint256 i; i < length;) {\n            _call(\n                transaction.proposal.targets[i],\n                transaction.proposal.calldatas[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // And finally emit event\n        emit TransactionExecuted(proposalId, msg.sender);\n    }\n\n    function _call(address target, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call(data);\n\n        if (!success) {\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        }\n    }\n\n    function _addSigner(address signer) internal changesSettings {\n        if (isSigner(signer)) revert SignerAlreadyAdded();\n\n        _signers.add(signer);\n\n        emit SignerAdded(signer);\n    }\n\n    function _removeSigner(address signer) internal changesSettings {\n        if (!isSigner(signer)) revert SignerAlreadyRemoved();\n        if (signerCount() == 1) revert SignerCannotBeRemoved();\n\n        _signers.remove(signer);\n\n        emit SignerRemoved(signer);\n\n        if (threshold > signerCount()) {\n            _setThreshold(signerCount());\n        }\n    }\n\n    function _setThreshold(uint256 newThreshold) internal changesSettings {\n        if (newThreshold > signerCount() || newThreshold == 0) {\n            revert InvalidThreshold();\n        }\n\n        threshold = newThreshold;\n\n        emit ThresholdChanged(newThreshold);\n    }\n}\n"
    }
}