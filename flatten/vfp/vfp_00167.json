{
    "vfp_id": "vfp_00167",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Incorrect Boolean Casting in `_isConsumedBy` Nonce Check",
            "description": "In the `_isConsumedBy` function, the result of a bitwise `and` operation is used as a boolean without explicit casting. Although the Solidity compiler currently handles this implicitly, this behavior is not guaranteed across all compiler versions and may lead to inconsistent evaluation. This could result in incorrect nonce validation, potentially allowing replay attacks or other logic flaws. Explicitly casting the result using `iszero(iszero(...))` ensures deterministic behavior and makes the intent clear, improving both security and portability of the code.\n",
            "severity": "Medium",
            "location": [
                "ConsumerLib.sol::_isConsumedBy#87"
            ],
            "files": [
                "the-compact/src/lib/ConsumerLib.sol"
            ]
        }
    ],
    "affected_files": {
        "ConsumerLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/**\n * @title ConsumerLib\n * @notice Library contract implementing logic for consuming bitpacked nonces scoped to\n * specific accounts and for querying for the state of those nonces. Note that only the\n * allocator nonce scope is currently in use in The Compact.\n */\nlibrary ConsumerLib {\n    // Storage scope identifiers for nonce buckets.\n    uint256 private constant _ALLOCATOR_NONCE_SCOPE = 0x03f37b1a;\n\n    // Error thrown when attempting to consume an already-consumed nonce.\n    error InvalidNonce(address account, uint256 nonce);\n\n    /**\n     * @notice Internal function for consuming a nonce in the allocator's scope.\n     * @param nonce     The nonce to consume.\n     * @param allocator The address of the allocator whose scope to consume the nonce in.\n     */\n    function consumeNonceAsAllocator(uint256 nonce, address allocator) internal {\n        _consumeNonce(nonce, allocator, _ALLOCATOR_NONCE_SCOPE);\n    }\n\n    /**\n     * @notice Internal view function for checking if a nonce has been consumed in the\n     * allocator's scope.\n     * @param nonceToCheck The nonce to check.\n     * @param allocator    The address of the allocator whose scope to check.\n     * @return consumed    Whether the nonce has been consumed.\n     */\n    function isConsumedByAllocator(uint256 nonceToCheck, address allocator) internal view returns (bool consumed) {\n        return _isConsumedBy(nonceToCheck, allocator, _ALLOCATOR_NONCE_SCOPE);\n    }\n\n    /**\n     * @notice Private function implementing nonce consumption logic. Uses the last byte\n     * of the nonce to determine which bit to set in a 256-bit storage bucket unique to\n     * the account and scope. Reverts if the nonce has already been consumed.\n     * @param nonce   The nonce to consume.\n     * @param account The address of the account whose scope to consume the nonce in.\n     * @param scope   The scope identifier to consume the nonce in.\n     */\n    function _consumeNonce(uint256 nonce, address account, uint256 scope) private {\n        // The last byte of the nonce is used to assign a bit in a 256-bit bucket;\n        // specific nonces are consumed for each account and can only be used once.\n        // NOTE: this function temporarily overwrites the free memory pointer, but\n        // restores it before returning.\n        assembly (\"memory-safe\") {\n            // Store free memory pointer; its memory location will be overwritten.\n            let freeMemoryPointer := mload(0x40)\n\n            // derive the nonce bucket slot:\n            // keccak256(_CONSUMER_NONCE_SCOPE ++ account ++ nonce[0:31])\n            mstore(0x20, account)\n            mstore(0x0c, scope)\n            mstore(0x40, nonce)\n            let bucketSlot := keccak256(0x28, 0x37)\n\n            // Retrieve nonce bucket and check if nonce has been consumed.\n            let bucketValue := sload(bucketSlot)\n            let bit := shl(and(0xff, nonce), 1)\n            if and(bit, bucketValue) {\n                // `InvalidNonce(address,uint256)` with padding for `account`.\n                mstore(0x0c, 0xdbc205b1000000000000000000000000)\n                revert(0x1c, 0x44)\n            }\n\n            // Invalidate the nonce by setting its bit.\n            sstore(bucketSlot, or(bucketValue, bit))\n\n            // Restore the free memory pointer.\n            mstore(0x40, freeMemoryPointer)\n        }\n    }\n\n    /**\n     * @notice Private view function implementing nonce consumption checking logic.\n     * Uses the last byte of the nonce to determine which bit to check in a 256-bit\n     * storage bucket unique to the account and scope.\n     * @param nonceToCheck The nonce to check.\n     * @param account      The address of the account whose scope to check.\n     * @param scope        The scope identifier to check.\n     * @return consumed    Whether the nonce has been consumed.\n     */\n    function _isConsumedBy(uint256 nonceToCheck, address account, uint256 scope) private view returns (bool consumed) {\n        assembly (\"memory-safe\") {\n            // Store free memory pointer; its memory location will be overwritten.\n            let freeMemoryPointer := mload(0x40)\n\n            // derive the nonce bucket slot:\n            // keccak256(_CONSUMER_NONCE_SCOPE ++ account ++ nonce[0:31])\n            mstore(0x20, account)\n            mstore(0x0c, scope)\n            mstore(0x40, nonceToCheck)\n\n            // Retrieve nonce bucket value and determine whether the nonce is set.\n            consumed := and(shl(and(0xff, nonceToCheck), 1), sload(keccak256(0x28, 0x37)))\n\n            // Restore the free memory pointer.\n            mstore(0x40, freeMemoryPointer)\n        }\n    }\n}\n"
    }
}