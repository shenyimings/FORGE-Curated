{
    "vfp_id": "vfp_00011",
    "project_name": "2025-06-reserveprotocol-solidity400-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Insufficient test coverage of new features",
            "description": "The code added to support trusted fillers and rebalancing in the reserve-index-dtf and trusted-fillers repositories lacks sufficient test coverage. Several new functions in the Folio and TrustedFillerRegistry contracts are not tested at all, and some functions in the CowSwapFiller contract are only partially tested. The root cause is inadequate testing methodology and insufficient test cases for critical functionality, such as nonce handling and rebalance lifecycle management. An attacker could exploit undetected bugs in untested code paths, potentially leading to incorrect state transitions or failed operations during rebalancing. The impact includes potential operational failures, loss of trust, and financial losses due to unhandled edge cases in production.\n",
            "severity": "Informational",
            "location": [
                "Folio.sol::stateChangeActive#213",
                "Folio.sol::setTrustedFillerRegistry#282",
                "Folio.sol::getRebalance#454",
                "Folio.sol::endRebalance#794",
                "TrustedFillerRegistry.sol::deprecateTrustedFiller#36",
                "TrustedFillerRegistry.sol::isAllowed#59",
                "CowSwapFiller.sol::swapActive#89",
                "CowSwapFiller.sol::rescueToken",
                "Folio.t.sol::isValidSignature#1359"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol",
                "20ec35af10212eefaa3963cefce7318231c20567/trusted-fillers/contracts/TrustedFillerRegistry.sol",
                "20ec35af10212eefaa3963cefce7318231c20567/trusted-fillers/contracts/fillers/cowswap/CowSwapFiller.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Functions can be called repeatedly, causing misleading events",
            "description": "Several event-emitting functions in the Folio contract—startRebalance, endRebalance, and closeAuction—can be called repeatedly without requiring intervening calls to their corresponding counterpart functions. This behavior can lead to off-chain systems receiving misleading or inconsistent event sequences, such as multiple RebalanceStarted events without a RebalanceEnded in between. The root cause is the lack of state checks to prevent redundant calls. An attacker or malicious actor could exploit this by spamming these functions, causing bots or monitoring systems that rely on predictable event patterns to malfunction. The impact includes incorrect behavior of off-chain automation tools, potentially leading to financial losses for users relying on such systems.\n",
            "severity": "Low",
            "location": [
                "Folio.sol::startRebalance#485",
                "Folio.sol::endRebalance#794",
                "Folio.sol::closeAuction#773",
                "AuctionLib.sol::openAuction#114"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol",
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/utils/AuctionLib.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Order surplus extraction",
            "description": "The CowSwapFiller contract's isValidSignature function fails to validate the appData field in CoW Swap orders, which can contain partner fee information. This allows an attacker to manipulate the appData field to include arbitrarily high partner fees while keeping the signature valid. The root cause is improper data validation of a critical order parameter. During settlement, the CoW Protocol processes these inflated fees, redirecting surplus funds to the attacker’s address. The impact is the potential loss of order surplus, which would otherwise go to the user, resulting in financial loss for users whose orders are exploited.\n",
            "severity": "Low",
            "location": [
                "GPv2OrderLib.sol::appData#19"
            ],
            "files": [
                "20ec35af10212eefaa3963cefce7318231c20567/trusted-fillers/contracts/fillers/cowswap/CowSwapFiller.sol",
                "20ec35af10212eefaa3963cefce7318231c20567/trusted-fillers/contracts/fillers/cowswap/GPv2OrderLib.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "DAO can receive slightly lower fees than expected",
            "description": "The contract calculates the per-second fee floor from an annual percentage using a fixed-point approximation of 1/31536000 (ONE_OVER_YEAR), which introduces precision loss due to rounding down. Additionally, the calculation does not account for leap years, making the inaccuracy worse in those years. The root cause is the use of imprecise fixed-point arithmetic and the omission of leap year adjustments. While the deviation is small (e.g., 0.15% becomes ~0.14999990833183%), it results in the DAO receiving slightly lower fees than intended. The impact is a minor but systematic under-collection of fees, affecting revenue predictability and transparency.\n",
            "severity": "Informational",
            "location": [
                "Folio.sol::feeFloor#937"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Denial of service allows blocking operations during Dutch auctions",
            "description": "A malicious actor can trigger a denial of service by creating a CowSwap filler at the beginning of a block and performing a minimal swap (e.g., 1 wei), causing the swapActive function to return true. This causes the sync modifier to revert, blocking all dependent functions. The root cause is the lack of a minimum threshold for swaps to be considered valid in the swapActive check. During Dutch auctions, where prices decrease over time, an attacker can exploit this to block other users' transactions and then bid at a lower price after the price drops. The impact is a temporary disruption of service and potential financial gain for the attacker at the expense of other users, undermining fair access to auctions.\n",
            "severity": "Medium",
            "location": [
                "CowSwapFiller.sol::swapActive#88-104"
            ],
            "files": [
                "20ec35af10212eefaa3963cefce7318231c20567/trusted-fillers/contracts/fillers/cowswap/CowSwapFiller.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Redundant Auction End Time Storage",
            "description": "The system maintains auction end times in two separate data structures: the `endTime` field within the Auction struct and the `auctionEnds` mapping in the Folio contract. This redundancy increases the risk of state inconsistency because both must be updated in sync across multiple functions, such as in `bid` and `closeAuction`. The root cause is poor data model design, leading to duplicated state. An attacker could potentially exploit a scenario where these values fall out of sync due to a logic error or incomplete update, leading to incorrect auction state transitions. The impact includes potential manipulation of auction timing, which could affect bid validity and fairness.\n",
            "severity": "Medium",
            "location": [
                "Folio.sol::closeAuction#773-789",
                "AuctionLib.sol::bid#179-235",
                "AuctionLib.sol#48-57"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol",
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/utils/AuctionLib.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Unbounded Iteration in Folio Functions",
            "description": "Several externally callable functions in the Folio contract iterate over variable-sized data structures such as `basket.values` and `feeRecipients`, including `startRebalance`, `getRebalance`, `totalAssets`, `toAssets`, `mint`, `redeem`, and `distributeFees`. The cause is the use of loops over dynamic arrays without checks on their size. If the number of tokens or fee recipients grows sufficiently large, the gas cost of these functions could exceed the block gas limit, rendering them uncallable. An attacker could exploit this by inflating the size of these collections, leading to a denial of service for critical rebalancing and fee distribution operations. While the report estimates this would require an impractically large number of tokens (~2.75 million), the risk remains as the system scales.\n",
            "severity": "Medium",
            "location": [
                "Folio.sol::startRebalance",
                "Folio.sol::getRebalance",
                "Folio.sol::totalAssets",
                "Folio.sol::toAssets",
                "Folio.sol::mint",
                "Folio.sol::redeem",
                "Folio.sol::distributeFees",
                "Folio.sol::setFeeRecipients"
            ],
            "files": [
                "e82bfd60b391832640800f32bb41f735a0e1e56f/reserve-index-dtf/contracts/Folio.sol"
            ]
        }
    ],
    "affected_files": {
        "TrustedFillerRegistry.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport { IRoleRegistry } from \"./interfaces/IRoleRegistry.sol\";\n\nimport { ITrustedFillerRegistry } from \"./interfaces/ITrustedFillerRegistry.sol\";\nimport { IBaseTrustedFiller } from \"./interfaces/IBaseTrustedFiller.sol\";\n\n/**\n * @title TrustedFillerRegistry\n * @author akshatmittal, julianmrodri, pmckelvy1, tbrent\n * @notice Registry for Trusted Fillers\n */\ncontract TrustedFillerRegistry is ITrustedFillerRegistry {\n    IRoleRegistry public immutable roleRegistry;\n\n    mapping(address filler => bool allowed) private trustedFillers;\n\n    constructor(address _roleRegistry) {\n        require(_roleRegistry != address(0), TrustedFillerRegistry__InvalidRoleRegistry());\n\n        roleRegistry = IRoleRegistry(_roleRegistry);\n    }\n\n    function addTrustedFiller(IBaseTrustedFiller _filler) external {\n        require(roleRegistry.isOwner(msg.sender), TrustedFillerRegistry__InvalidCaller());\n        require(address(_filler) != address(0), TrustedFillerRegistry__InvalidFiller());\n\n        trustedFillers[address(_filler)] = true;\n\n        emit TrustedFillerAdded(_filler);\n    }\n\n    function deprecateTrustedFiller(IBaseTrustedFiller _filler) external {\n        require(roleRegistry.isOwnerOrEmergencyCouncil(msg.sender), TrustedFillerRegistry__InvalidCaller());\n        require(address(_filler) != address(0), TrustedFillerRegistry__InvalidFiller());\n\n        trustedFillers[address(_filler)] = false;\n\n        emit TrustedFillerDeprecated(_filler);\n    }\n\n    function createTrustedFiller(\n        address senderSource,\n        address trustedFiller,\n        bytes32 deploymentSalt\n    ) external returns (IBaseTrustedFiller trustedFillerInstance) {\n        require(trustedFillers[trustedFiller], TrustedFillerRegistry__InvalidFiller());\n\n        bytes32 protectedSalt = keccak256(abi.encodePacked(msg.sender, senderSource, deploymentSalt));\n\n        trustedFillerInstance = IBaseTrustedFiller(Clones.cloneDeterministic(trustedFiller, protectedSalt));\n\n        emit TrustedFillerCreated(msg.sender, trustedFillerInstance);\n    }\n\n    function isAllowed(address _filler) external view returns (bool) {\n        return trustedFillers[_filler];\n    }\n}\n",
        "GPv2OrderLib.sol": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\n/// @dev From https://github.com/cowprotocol/contracts\nlibrary GPv2OrderLib {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     \"Order(\" +\n    ///         \"address sellToken,\" +\n    ///         \"address buyToken,\" +\n    ///         \"address receiver,\" +\n    ///         \"uint256 sellAmount,\" +\n    ///         \"uint256 buyAmount,\" +\n    ///         \"uint32 validTo,\" +\n    ///         \"bytes32 appData,\" +\n    ///         \"uint256 feeAmount,\" +\n    ///         \"string kind,\" +\n    ///         \"bool partiallyFillable,\" +\n    ///         \"string sellTokenBalance,\" +\n    ///         \"string buyTokenBalance\" +\n    ///     \")\"\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH = hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"sell\")\n    /// ```\n    bytes32 internal constant KIND_SELL = hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"buy\")\n    /// ```\n    bytes32 internal constant KIND_BUY = hex\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"erc20\")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 = hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"external\")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL = hex\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"internal\")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL = hex\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(Data memory order, address owner) internal pure returns (address receiver) {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(Data memory order, bytes32 domainSeparator) internal pure returns (bytes32 orderDigest) {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 12 fields, and\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(\n        bytes calldata orderUid\n    ) internal pure returns (bytes32 orderDigest, address owner, uint32 validTo) {\n        require(orderUid.length == UID_LENGTH, \"GPv2: invalid uid\");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n",
        "Folio.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ITrustedFillerRegistry, IBaseTrustedFiller } from \"@reserve-protocol/trusted-fillers/contracts/interfaces/ITrustedFillerRegistry.sol\";\n\nimport { AuctionLib } from \"@utils/AuctionLib.sol\";\nimport { D18, D27, MAX_TVL_FEE, MAX_MINT_FEE, MIN_MINT_FEE, MIN_AUCTION_LENGTH, MAX_AUCTION_LENGTH, MAX_FEE_RECIPIENTS, MAX_LIMIT, MAX_TOKEN_PRICE, MAX_TOKEN_PRICE_RANGE, MAX_TTL, RESTRICTED_AUCTION_BUFFER, ONE_OVER_YEAR, ONE_DAY } from \"@utils/Constants.sol\";\nimport { MathLib } from \"@utils/MathLib.sol\";\nimport { Versioned } from \"@utils/Versioned.sol\";\n\nimport { IFolioDAOFeeRegistry } from \"@interfaces/IFolioDAOFeeRegistry.sol\";\nimport { IFolio } from \"@interfaces/IFolio.sol\";\n\n/**\n * @title Folio\n * @author akshatmittal, julianmrodri, pmckelvy1, tbrent\n * @notice Folio is a backed ERC20 token with permissionless minting/redemption and a rebalancing mechanism.\n *\n * A Folio is backed by a flexible number of ERC20 tokens of any denomination/price (within assumed ranges, see README)\n * All tokens tracked by the Folio are required to mint/redeem. This forms the basket.\n *\n * There are 3 main roles:\n *   1. DEFAULT_ADMIN_ROLE: can set erc20 assets, fees, auction length, close auctions/rebalances, and deprecateFolio\n *   2. REBALANCE_MANAGER: can start/end rebalances\n *   3. AUCTION_LAUNCHER: can open auctions during an ongoing rebalance, and close auctions\n *\n * There is also an additional BRAND_MANAGER role that does not have any permissions. It is used off-chain.\n *\n * Rebalance lifecycle:\n *   startRebalance() -> openAuction() -> bid() -> [optional] closeAuction()\n *\n * After a new rebalance is started by the REBALANCE_MANAGER, there is a period of time where only the AUCTION_LAUNCHER\n * can open auctions. They can choose to act within the range of the REBALANCE_MANAGER's initial estimates. After this\n * period is over, anyone can open auctions until the rebalance expires.\n *\n * An auction for a given token pair can run any number of times. However it requires the sell token to be in surplus\n * and the buy token in deficit.\n *\n * Targets for the rebalance are called \"limits\" and defined in basket ratios: ratios of token to Folio shares, D27{tok/share}\n *\n * Fees:\n *   - TVL fee: fee per unit time. Max 10% annually. Causes supply inflation over time, discretely once a day.\n *   - Mint fee: fee on mint. Max 5%. Does not cause supply inflation.\n *\n * After fees have been applied, the DAO takes a cut based on the configuration of the FolioDAOFeeRegistry including\n * a minimum fee floor of 15bps. The remaining portion above 15bps is distributed to the Folio's fee recipients.\n * Note that this means it is possible for the fee recipients to receive nothing despite configuring a nonzero fee.\n */\ncontract Folio is\n    IFolio,\n    Initializable,\n    ERC20Upgradeable,\n    AccessControlEnumerableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Versioned\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IFolioDAOFeeRegistry public daoFeeRegistry;\n\n    /**\n     * Roles\n     */\n    bytes32 public constant REBALANCE_MANAGER = keccak256(\"REBALANCE_MANAGER\"); // expected to be trading governance's timelock\n    bytes32 public constant AUCTION_LAUNCHER = keccak256(\"AUCTION_LAUNCHER\"); // optional: EOA or multisig\n    bytes32 public constant BRAND_MANAGER = keccak256(\"BRAND_MANAGER\"); // optional: no permissions\n\n    /**\n     * Mandate\n     */\n    string public mandate; // mutable field that describes mission/brand of the Folio\n\n    /**\n     * Basket\n     */\n    EnumerableSet.AddressSet private basket;\n\n    /**\n     * Fees\n     */\n    FeeRecipient[] public feeRecipients;\n    uint256 public tvlFee; // D18{1/s} demurrage fee on AUM\n    uint256 public mintFee; // D18{1} fee on mint\n\n    /**\n     * System\n     */\n    uint256 public lastPoke; // {s}\n    uint256 public daoPendingFeeShares; // {share} shares pending to be distributed ONLY to the DAO\n    uint256 public feeRecipientsPendingFeeShares; // {share} shares pending to be distributed ONLY to fee recipients\n    bool public isDeprecated; // {bool} if true, Folio goes into redemption-only mode\n\n    modifier notDeprecated() {\n        require(!isDeprecated, Folio__FolioDeprecated());\n        _;\n    }\n\n    DeprecatedStruct[] private auctions_DEPRECATED;\n    mapping(address token => uint256 timepoint) private sellEnds_DEPRECATED; // {s} timestamp of last possible second we could sell the token\n    mapping(address token => uint256 timepoint) private buyEnds_DEPRECATED; // {s} timestamp of last possible second we could buy the token\n    uint256 private auctionDelay_DEPRECATED; // {s} delay in the APPROVED state before an auction can be opened by anyone\n\n    uint256 public auctionLength; // {s} length of an auction\n\n    // === 2.0.0 ===\n    mapping(uint256 auctionId => DeprecatedStruct details) private auctionDetails_DEPRECATED;\n    mapping(address token => uint256 amount) private dustAmount_DEPRECATED;\n\n    // === 3.0.0 ===\n    ITrustedFillerRegistry public trustedFillerRegistry;\n    bool public trustedFillerEnabled;\n    IBaseTrustedFiller private activeTrustedFill;\n\n    /**\n     * Rebalancing\n     *   REBALANCE_MANAGER\n     *   - There can only be 1 rebalance live at a time\n     *   - There can be an auction for each unique token pair in the basket\n     *   - A token can be ONLY sold or ONLY bought depending on whether it is in surplus or deficit\n     *   - Auctions are restricted to the AUCTION_LAUNCHER until rebalance.restrictedUntil\n     *   - Auctions cannot be launched after availableUntil, though their end time may extend past it\n     *   - The AUCTION_LAUNCHER acts within the bounds set by the REBALANCE_MANAGER, adding precision to limits/prices\n     *   - If the AUCTION_LAUNCHER is not active, the original spot estimates from the REBALANCE_MANAGER are used\n     *   - At anytime the rebalance can be stopped or a new one can be started (closing live auctions)\n     *   - The AUCTION_LAUNCHER is limited in the damage they can do and can always be removed if griefing\n     */\n    Rebalance public rebalance;\n\n    /**\n     * Auctions\n     *   Openable by AUCTION_LAUNCHER -> Openable by anyone (optional) -> Running -> Closed\n     *   - There can only be one live auction per token pair\n     *   - Multiple bids can be executed against the same auction\n     *   - All auctions are dutch auctions with an exponential decay curve, but startPrice can equal endPrice\n     */\n    mapping(uint256 id => Auction auction) public auctions;\n    mapping(uint256 rebalanceNonce => mapping(bytes32 pair => uint256 endTime)) public auctionEnds;\n    uint256 public nextAuctionId;\n\n    /// Any external call to the Folio that relies on accurate share accounting must pre-hook poke\n    modifier sync() {\n        _poke();\n        _;\n    }\n\n    // ====\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        FolioBasicDetails calldata _basicDetails,\n        FolioAdditionalDetails calldata _additionalDetails,\n        address _creator,\n        address _daoFeeRegistry,\n        address _trustedFillerRegistry,\n        bool _trustedFillerEnabled\n    ) external initializer {\n        __ERC20_init(_basicDetails.name, _basicDetails.symbol);\n        __AccessControlEnumerable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setFeeRecipients(_additionalDetails.feeRecipients);\n        _setTVLFee(_additionalDetails.tvlFee);\n        _setMintFee(_additionalDetails.mintFee);\n        _setAuctionLength(_additionalDetails.auctionLength);\n        _setMandate(_additionalDetails.mandate);\n        _setTrustedFillerRegistry(_trustedFillerRegistry, _trustedFillerEnabled);\n\n        daoFeeRegistry = IFolioDAOFeeRegistry(_daoFeeRegistry);\n\n        require(_basicDetails.initialShares != 0, Folio__ZeroInitialShares());\n\n        uint256 assetLength = _basicDetails.assets.length;\n        require(assetLength != 0, Folio__EmptyAssets());\n\n        for (uint256 i; i < assetLength; i++) {\n            require(_basicDetails.assets[i] != address(0), Folio__InvalidAsset());\n\n            uint256 assetBalance = IERC20(_basicDetails.assets[i]).balanceOf(address(this));\n            require(assetBalance != 0, Folio__InvalidAssetAmount(_basicDetails.assets[i]));\n\n            _addToBasket(_basicDetails.assets[i]);\n        }\n\n        lastPoke = block.timestamp;\n\n        _mint(_creator, _basicDetails.initialShares);\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev Testing function, no production use\n    function poke() external nonReentrant {\n        _poke();\n    }\n\n    /// Check if the Folio state can be relied upon to be complete\n    /// @dev Safety check for consuming protocols to check for synchronous and asynchronous state changes\n    /// @dev Consuming protocols SHOULD call this function and ensure it returns (false, false) before\n    ///      strongly relying on the Folio state.\n    function stateChangeActive() external view returns (bool syncStateChangeActive, bool asyncStateChangeActive) {\n        syncStateChangeActive = _reentrancyGuardEntered();\n        asyncStateChangeActive = address(activeTrustedFill) != address(0) && activeTrustedFill.swapActive();\n    }\n\n    // ==== Governance ====\n\n    /// Escape hatch function to be used when tokens get acquired not through an auction but\n    /// through any other means and should become part of the Folio without being sold.\n    /// @dev Does not require a token balance\n    /// @param token The token to add to the basket\n    function addToBasket(IERC20 token) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_addToBasket(address(token)), Folio__BasketModificationFailed());\n    }\n\n    /// @dev Enables permissionless removal of tokens for 0 balance tokens\n    function removeFromBasket(IERC20 token) external nonReentrant {\n        _closeTrustedFill();\n\n        // always allow admin to remove from basket\n        // allow permissionless removal if 0 weight AND 0 balance\n        // known: can be griefed by token donation\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                (rebalance.details[address(token)].limits.spot == 0 && IERC20(token).balanceOf(address(this)) == 0),\n            Folio__BalanceNotRemovable()\n        );\n        require(_removeFromBasket(address(token)), Folio__BasketModificationFailed());\n    }\n\n    /// An annual tvl fee below the DAO fee floor will result in the entirety of the fee being sent to the DAO\n    /// @dev Non-reentrant via distributeFees()\n    /// @param _newFee D18{1/s} Fee per second on AUM\n    function setTVLFee(uint256 _newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setTVLFee(_newFee);\n    }\n\n    /// A minting fee below the DAO fee floor will result in the entirety of the fee being sent to the DAO\n    /// @dev Non-reentrant via distributeFees()\n    /// @param _newFee D18{1} Fee on mint\n    function setMintFee(uint256 _newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setMintFee(_newFee);\n    }\n\n    /// @dev Non-reentrant via distributeFees()\n    /// @dev Fee recipients must be unique and sorted by address, and sum to 1e18\n    /// @dev Warning: An empty fee recipients table will result in all fees being sent to DAO\n    function setFeeRecipients(FeeRecipient[] memory _newRecipients) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setFeeRecipients(_newRecipients);\n    }\n\n    /// @param _newLength {s} Length of an auction\n    function setAuctionLength(uint256 _newLength) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setAuctionLength(_newLength);\n    }\n\n    /// @param _newMandate New mandate, a schelling point to guide governance\n    function setMandate(string calldata _newMandate) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setMandate(_newMandate);\n    }\n\n    /// @dev _newFillerRegistry must be the already set registry if already set. This is to ensure\n    ///      correctness and in order to be explicit what registry is being enabled/disabled.\n    function setTrustedFillerRegistry(address _newFillerRegistry, bool _enabled) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setTrustedFillerRegistry(_newFillerRegistry, _enabled);\n    }\n\n    /// Deprecate the Folio, callable only by the admin\n    /// @dev Folio cannot be minted and auctions cannot be approved, opened, or bid on\n    function deprecateFolio() external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        isDeprecated = true;\n\n        emit FolioDeprecated();\n    }\n\n    // ==== Share + Asset Accounting ====\n\n    /// @dev Contains all pending fee shares\n    function totalSupply() public view override returns (uint256) {\n        (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares, ) = _getPendingFeeShares();\n\n        return super.totalSupply() + _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n    }\n\n    /// @return _assets\n    /// @return _amounts {tok}\n    function totalAssets() external view returns (address[] memory _assets, uint256[] memory _amounts) {\n        return _totalAssets();\n    }\n\n    /// @param shares {share}\n    /// @return _assets\n    /// @return _amounts {tok}\n    function toAssets(\n        uint256 shares,\n        Math.Rounding rounding\n    ) external view returns (address[] memory _assets, uint256[] memory _amounts) {\n        return _toAssets(shares, rounding);\n    }\n\n    /// @dev Use allowances to set slippage limits for provided assets\n    /// @dev Minting has 3 share-portions: (i) receiver shares, (ii) DAO fee shares, (iii) fee recipients shares\n    /// @param shares {share} Amount of shares to mint\n    /// @param minSharesOut {share} Minimum amount of shares the caller must receive after fees\n    /// @return _assets\n    /// @return _amounts {tok}\n    function mint(\n        uint256 shares,\n        address receiver,\n        uint256 minSharesOut\n    ) external nonReentrant notDeprecated sync returns (address[] memory _assets, uint256[] memory _amounts) {\n        // === Calculate fee shares ===\n\n        (, uint256 daoFeeNumerator, uint256 daoFeeDenominator, uint256 daoFeeFloor) = daoFeeRegistry.getFeeDetails(\n            address(this)\n        );\n\n        // ensure DAO fee floor is at least 3 bps (set just above daily MAX_TVL_FEE)\n        daoFeeFloor = Math.max(daoFeeFloor, MIN_MINT_FEE);\n\n        // {share} = {share} * D18{1} / D18\n        uint256 totalFeeShares = (shares * mintFee + D18 - 1) / D18;\n        uint256 daoFeeShares = (totalFeeShares * daoFeeNumerator + daoFeeDenominator - 1) / daoFeeDenominator;\n\n        // ensure DAO's portion of fees is at least the DAO feeFloor\n        uint256 minDaoShares = (shares * daoFeeFloor + D18 - 1) / D18;\n        daoFeeShares = daoFeeShares < minDaoShares ? minDaoShares : daoFeeShares;\n\n        // 100% to DAO, if necessary\n        totalFeeShares = totalFeeShares < daoFeeShares ? daoFeeShares : totalFeeShares;\n\n        // {share}\n        uint256 sharesOut = shares - totalFeeShares;\n        require(sharesOut != 0 && sharesOut >= minSharesOut, Folio__InsufficientSharesOut());\n\n        // === Transfer assets in ===\n\n        (_assets, _amounts) = _toAssets(shares, Math.Rounding.Ceil);\n\n        uint256 assetLength = _assets.length;\n        for (uint256 i; i < assetLength; i++) {\n            if (_amounts[i] != 0) {\n                SafeERC20.safeTransferFrom(IERC20(_assets[i]), msg.sender, address(this), _amounts[i]);\n            }\n        }\n\n        // === Mint shares ===\n\n        _mint(receiver, sharesOut);\n\n        // defer fee handouts until distributeFees()\n        daoPendingFeeShares += daoFeeShares;\n        feeRecipientsPendingFeeShares += totalFeeShares - daoFeeShares;\n    }\n\n    /// @param shares {share} Amount of shares to redeem\n    /// @param assets Assets to receive, must match basket exactly\n    /// @param minAmountsOut {tok} Minimum amounts of each asset to receive\n    /// @return _amounts {tok} Actual amounts transferred of each asset\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address[] calldata assets,\n        uint256[] calldata minAmountsOut\n    ) external nonReentrant sync returns (uint256[] memory _amounts) {\n        address[] memory _assets;\n        (_assets, _amounts) = _toAssets(shares, Math.Rounding.Floor);\n\n        // === Burn shares ===\n\n        _burn(msg.sender, shares);\n\n        // === Transfer assets out ===\n\n        uint256 len = _assets.length;\n        require(len == assets.length && len == minAmountsOut.length, Folio__InvalidArrayLengths());\n\n        for (uint256 i; i < len; i++) {\n            require(_assets[i] == assets[i], Folio__InvalidAsset());\n            require(_amounts[i] >= minAmountsOut[i], Folio__InvalidAssetAmount(_assets[i]));\n\n            if (_amounts[i] != 0) {\n                SafeERC20.safeTransfer(IERC20(_assets[i]), receiver, _amounts[i]);\n            }\n        }\n    }\n\n    // ==== Fee Shares ====\n\n    /// @return {share} Up-to-date sum of DAO and fee recipients pending fee shares\n    function getPendingFeeShares() public view returns (uint256) {\n        (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares, ) = _getPendingFeeShares();\n        return _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n    }\n\n    /// Distribute all pending fee shares\n    /// @dev Recipients: DAO and fee recipients; if feeRecipients are empty, the DAO gets all the fees\n    /// @dev Pending fee shares are already reflected in the total supply, this function only concretizes balances\n    function distributeFees() public nonReentrant sync {\n        // daoPendingFeeShares and feeRecipientsPendingFeeShares are up-to-date\n\n        // === Fee recipients ===\n\n        uint256 _feeRecipientsPendingFeeShares = feeRecipientsPendingFeeShares;\n        feeRecipientsPendingFeeShares = 0;\n        uint256 feeRecipientsTotal;\n\n        uint256 len = feeRecipients.length;\n        for (uint256 i; i < len; i++) {\n            // {share} = {share} * D18{1} / D18\n            uint256 shares = (_feeRecipientsPendingFeeShares * feeRecipients[i].portion) / D18;\n            feeRecipientsTotal += shares;\n\n            _mint(feeRecipients[i].recipient, shares);\n\n            emit FolioFeePaid(feeRecipients[i].recipient, shares);\n        }\n\n        // === DAO ===\n\n        // {share}\n        uint256 daoShares = daoPendingFeeShares + _feeRecipientsPendingFeeShares - feeRecipientsTotal;\n\n        (address daoRecipient, , , ) = daoFeeRegistry.getFeeDetails(address(this));\n        _mint(daoRecipient, daoShares);\n        emit ProtocolFeePaid(daoRecipient, daoShares);\n\n        daoPendingFeeShares = 0;\n    }\n\n    // ==== Auctions ====\n\n    /// Get the currently ongoing rebalance\n    /// @dev The other rebalance variables are part of the autogenerated `rebalance()` getter\n    /// @dev Nonzero return values do not imply a rebalance is ongoing; check `rebalance.availableUntil`\n    function getRebalance()\n        external\n        view\n        returns (\n            address[] memory tokens,\n            BasketRange[] memory limits,\n            Prices[] memory prices,\n            bool[] memory inRebalance\n        )\n    {\n        tokens = basket.values();\n        uint256 len = tokens.length;\n        limits = new BasketRange[](len);\n        prices = new Prices[](len);\n        inRebalance = new bool[](len);\n\n        for (uint256 i; i < len; i++) {\n            RebalanceDetails storage details = rebalance.details[tokens[i]];\n            limits[i] = details.limits;\n            prices[i] = details.prices;\n            inRebalance[i] = details.inRebalance;\n        }\n    }\n\n    /// Set basket and start rebalancing towards it, ending currently running auctions\n    /// @dev If caller omits old tokens they will be kept in the basket for mint/redeem but skipped in the rebalance\n    /// @dev Note that limits will be _slightly_ stale after the fee supply inflation on a 24h boundary\n    /// @param newTokens Tokens to add to the basket, MUST be unique\n    /// @param newLimits D27{tok/share} New rebalance limits\n    /// @param newPrices D27{UoA/tok} New prices for each asset in terms of the Folio\n    ///                  Can pass 0 for ALL token prices to defer to AUCTION_LAUNCHER (cannot pick and choose)\n    function startRebalance(\n        address[] calldata newTokens,\n        BasketRange[] calldata newLimits,\n        Prices[] calldata newPrices,\n        uint256 auctionLauncherWindow,\n        uint256 ttl\n    ) external onlyRole(REBALANCE_MANAGER) nonReentrant notDeprecated sync {\n        require(ttl >= auctionLauncherWindow && ttl <= MAX_TTL, Folio__InvalidTTL());\n\n        // keep old tokens in the basket for mint/redeem, but remove from rebalance\n        address[] memory oldTokens = basket.values();\n        uint256 len = oldTokens.length;\n        for (uint256 i; i < len; i++) {\n            delete rebalance.details[oldTokens[i]];\n        }\n\n        len = newTokens.length;\n        require(len != 0 && len == newLimits.length && len == newPrices.length, Folio__InvalidArrayLengths());\n\n        // enforce that if one price is 0, all prices are 0\n        bool deferPrices = newPrices[0].low == 0;\n\n        // set new basket\n        for (uint256 i; i < len; i++) {\n            address token = newTokens[i];\n\n            require(!rebalance.details[token].inRebalance, Folio__DuplicateAsset());\n\n            require(\n                newLimits[i].low <= newLimits[i].spot &&\n                    newLimits[i].spot <= newLimits[i].high &&\n                    newLimits[i].high <= MAX_LIMIT,\n                Folio__InvalidLimits()\n            );\n\n            require(newLimits[i].spot != 0 || newLimits[i].high == 0, Folio__InvalidLimits());\n\n            require(\n                deferPrices == (newPrices[i].low == 0) && deferPrices == (newPrices[i].high == 0),\n                Folio__InvalidPrices()\n            );\n\n            if (!deferPrices) {\n                require(\n                    newPrices[i].low <= newPrices[i].high &&\n                        newPrices[i].high <= MAX_TOKEN_PRICE &&\n                        newPrices[i].high / newPrices[i].low <= MAX_TOKEN_PRICE_RANGE,\n                    Folio__InvalidPrices()\n                );\n            }\n\n            _addToBasket(token);\n            rebalance.details[token] = RebalanceDetails({\n                inRebalance: true,\n                limits: newLimits[i],\n                prices: newPrices[i]\n            });\n        }\n\n        rebalance.nonce++;\n        rebalance.startedAt = block.timestamp;\n        rebalance.restrictedUntil = block.timestamp + auctionLauncherWindow;\n        rebalance.availableUntil = block.timestamp + ttl;\n\n        emit RebalanceStarted(\n            rebalance.nonce,\n            newTokens,\n            newLimits,\n            newPrices,\n            block.timestamp + auctionLauncherWindow,\n            block.timestamp + ttl\n        );\n    }\n\n    /// Open an auction between two tokens as the AUCTION_LAUNCHER, with specific limits and prices\n    /// @param sellLimit D27{sellTok/share} min ratio of sell token to shares allowed, inclusive, 1e54 max\n    /// @param buyLimit D27{buyTok/share} max balance-ratio to shares allowed, exclusive, 1e54 max\n    /// @param startPrice D27{buyTok/sellTok} (0, 1e54]\n    /// @param endPrice D27{buyTok/sellTok} (0, 1e54]\n    /// @return auctionId The newly created auctionId\n    function openAuction(\n        IERC20 sellToken,\n        IERC20 buyToken,\n        uint256 sellLimit,\n        uint256 buyLimit,\n        uint256 startPrice,\n        uint256 endPrice\n    ) external onlyRole(AUCTION_LAUNCHER) nonReentrant notDeprecated sync returns (uint256 auctionId) {\n        // auction launcher can:\n        //   - select a sell limit within the approved basket weight range\n        //   - select a buy limit within the approved basket weight range\n        //   - raise starting price by up to 100x\n        //   - raise ending price arbitrarily (can cause auction not to clear, same end result as closing auction)\n\n        RebalanceDetails storage sellDetails = rebalance.details[address(sellToken)];\n        RebalanceDetails storage buyDetails = rebalance.details[address(buyToken)];\n\n        // startRebalance invariant: if any of the tokens have a 0 price, they must all have a 0 price\n        if (sellDetails.prices.high != 0) {\n            // D27{buyTok/sellTok} = D27 * D27{UoA/sellTok} / D27{UoA/buyTok}\n            uint256 oldStartPrice = (D27 * sellDetails.prices.high + buyDetails.prices.low - 1) / buyDetails.prices.low;\n            uint256 oldEndPrice = (D27 * sellDetails.prices.low + buyDetails.prices.high - 1) / buyDetails.prices.high;\n\n            // allow up to 100x price increase\n            require(\n                startPrice >= oldStartPrice && startPrice <= 100 * oldStartPrice && endPrice >= oldEndPrice,\n                Folio__InvalidPrices()\n            );\n        }\n\n        // for upgraded Folios, pick up on the next auction index from the old array\n        nextAuctionId = nextAuctionId != 0 ? nextAuctionId : auctions_DEPRECATED.length;\n        auctionId = nextAuctionId++;\n\n        AuctionLib.AuctionArgs memory args = AuctionLib.AuctionArgs({\n            auctionId: auctionId,\n            sellToken: sellToken,\n            buyToken: buyToken,\n            sellLimit: sellLimit,\n            buyLimit: buyLimit,\n            startPrice: startPrice,\n            endPrice: endPrice,\n            auctionBuffer: 0\n        });\n\n        // many more checks, including confirming sellToken is in surplus and buyToken is in deficit\n        AuctionLib.openAuction(rebalance, auctions, auctionEnds, totalSupply(), auctionLength, args);\n    }\n\n    /// Open an auction without restrictions\n    /// @dev Callable only after the auction launcher window passes\n    /// @return auctionId The newly created auctionId\n    function openAuctionUnrestricted(\n        IERC20 sellToken,\n        IERC20 buyToken\n    ) external nonReentrant notDeprecated sync returns (uint256 auctionId) {\n        require(block.timestamp >= rebalance.restrictedUntil, Folio__AuctionCannotBeOpenedWithoutRestriction());\n\n        // open an auction on spot limits + full price range\n\n        RebalanceDetails storage sellDetails = rebalance.details[address(sellToken)];\n        RebalanceDetails storage buyDetails = rebalance.details[address(buyToken)];\n\n        // startRebalance invariant: if any of the tokens have a 0 price, they must all have a 0 price\n        require(buyDetails.prices.low != 0, Folio__AuctionCannotBeOpenedWithoutRestriction());\n\n        // D27{buyTok/sellTok} = D27 * D27{UoA/sellTok} / D27{UoA/buyTok}\n        uint256 startPrice = (D27 * sellDetails.prices.high + buyDetails.prices.low - 1) / buyDetails.prices.low;\n        uint256 endPrice = (D27 * sellDetails.prices.low + buyDetails.prices.high - 1) / buyDetails.prices.high;\n\n        // for upgraded Folios, pick up on the next auction index from the old array\n        nextAuctionId = nextAuctionId != 0 ? nextAuctionId : auctions_DEPRECATED.length;\n        auctionId = nextAuctionId++;\n\n        AuctionLib.AuctionArgs memory args = AuctionLib.AuctionArgs({\n            auctionId: auctionId,\n            sellToken: sellToken,\n            buyToken: buyToken,\n            sellLimit: sellDetails.limits.spot,\n            buyLimit: buyDetails.limits.spot,\n            startPrice: startPrice,\n            endPrice: endPrice,\n            auctionBuffer: RESTRICTED_AUCTION_BUFFER\n        });\n\n        // many more checks, including confirming sellToken is in surplus and buyToken is in deficit\n        AuctionLib.openAuction(rebalance, auctions, auctionEnds, totalSupply(), auctionLength, args);\n    }\n\n    /// Get auction bid parameters at the current timestamp, up to a maximum sell amount\n    /// @param timestamp {s} The timestamp to get the bid parameters for, or 0 to use the current timestamp\n    /// @param maxSellAmount {sellTok} The max amount of sell tokens the bidder can offer the protocol\n    /// @return sellAmount {sellTok} The amount of sell token on sale in the auction at a given timestamp\n    /// @return bidAmount {buyTok} The amount of buy tokens required to bid for the full sell amount\n    /// @return price D27{buyTok/sellTok} The price at the given timestamp as an 27-decimal fixed point\n    function getBid(\n        uint256 auctionId,\n        uint256 timestamp,\n        uint256 maxSellAmount\n    ) external view returns (uint256 sellAmount, uint256 bidAmount, uint256 price) {\n        Auction storage auction = auctions[auctionId];\n\n        require(auction.rebalanceNonce == rebalance.nonce, Folio__AuctionNotOngoing());\n\n        // checks auction is ongoing and that sellAmount is below maxSellAmount\n        (sellAmount, bidAmount, price) = AuctionLib.getBid(\n            auction,\n            totalSupply(),\n            timestamp == 0 ? block.timestamp : timestamp,\n            _balanceOfToken(auction.sellToken),\n            _balanceOfToken(auction.buyToken),\n            0,\n            maxSellAmount,\n            type(uint256).max\n        );\n    }\n\n    /// Bid in an ongoing auction\n    ///   If withCallback is true, caller must adhere to IBidderCallee interface and receives a callback\n    ///   If withCallback is false, caller must have provided an allowance in advance\n    /// @dev Callable by anyone\n    /// @param sellAmount {sellTok} Sell token, the token the bidder receives\n    /// @param maxBuyAmount {buyTok} Max buy token, the token the bidder provides\n    /// @param withCallback If true, caller must adhere to IBidderCallee interface and transfers tokens via callback\n    /// @param data Arbitrary data to pass to the callback\n    /// @return boughtAmt {buyTok} The amount bidder receives\n    function bid(\n        uint256 auctionId,\n        uint256 sellAmount,\n        uint256 maxBuyAmount,\n        bool withCallback,\n        bytes calldata data\n    ) external nonReentrant notDeprecated sync returns (uint256 boughtAmt) {\n        Auction storage auction = auctions[auctionId];\n\n        require(auction.rebalanceNonce == rebalance.nonce, Folio__AuctionNotOngoing());\n\n        uint256 _totalSupply = totalSupply();\n\n        // checks auction is ongoing and that sellAmount is below maxSellAmount\n        (, boughtAmt, ) = AuctionLib.getBid(\n            auction,\n            _totalSupply,\n            block.timestamp,\n            auction.sellToken.balanceOf(address(this)),\n            auction.buyToken.balanceOf(address(this)),\n            sellAmount,\n            sellAmount,\n            maxBuyAmount\n        );\n\n        // bid via approval or callback\n        if (\n            AuctionLib.bid(\n                auction,\n                auctionEnds[auction.rebalanceNonce],\n                _totalSupply,\n                sellAmount,\n                boughtAmt,\n                withCallback,\n                data\n            )\n        ) {\n            _removeFromBasket(address(auction.sellToken));\n        }\n\n        emit AuctionBid(auctionId, sellAmount, boughtAmt);\n    }\n\n    /// As an alternative to bidding directly, an in-block async swap can be opened without removing Folio's access\n    function createTrustedFill(\n        uint256 auctionId,\n        address targetFiller,\n        bytes32 deploymentSalt\n    ) external nonReentrant notDeprecated sync returns (IBaseTrustedFiller filler) {\n        Auction storage auction = auctions[auctionId];\n\n        require(auction.rebalanceNonce == rebalance.nonce, Folio__AuctionNotOngoing());\n        require(\n            address(trustedFillerRegistry) != address(0) && trustedFillerEnabled,\n            Folio__TrustedFillerRegistryNotEnabled()\n        );\n\n        // checks auction is ongoing and that sellAmount is below maxSellAmount\n        (uint256 sellAmount, uint256 buyAmount, ) = AuctionLib.getBid(\n            auction,\n            totalSupply(),\n            block.timestamp,\n            auction.sellToken.balanceOf(address(this)),\n            auction.buyToken.balanceOf(address(this)),\n            0,\n            type(uint256).max,\n            type(uint256).max\n        );\n\n        // Create Trusted Filler\n        filler = trustedFillerRegistry.createTrustedFiller(msg.sender, targetFiller, deploymentSalt);\n        SafeERC20.forceApprove(auction.sellToken, address(filler), sellAmount);\n\n        filler.initialize(address(this), auction.sellToken, auction.buyToken, sellAmount, buyAmount);\n        activeTrustedFill = filler;\n\n        emit AuctionTrustedFillCreated(auctionId, address(filler));\n    }\n\n    /// Close an auction\n    /// A auction can be closed from anywhere in its lifecycle\n    /// @dev Callable by ADMIN or REBALANCE_MANAGER or AUCTION_LAUNCHER\n    function closeAuction(uint256 auctionId) external nonReentrant {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(REBALANCE_MANAGER, msg.sender) ||\n                hasRole(AUCTION_LAUNCHER, msg.sender),\n            Folio__Unauthorized()\n        );\n        Auction storage auction = auctions[auctionId];\n\n        // do not revert, to prevent griefing\n        auction.endTime = block.timestamp - 1;\n        auctionEnds[auction.rebalanceNonce][AuctionLib.pairHash(auction.sellToken, auction.buyToken)] =\n            block.timestamp -\n            1;\n\n        emit AuctionClosed(auctionId);\n    }\n\n    /// End the current rebalance, including all ongoing auctions\n    /// @dev Callable by ADMIN or REBALANCE_MANAGER or AUCTION_LAUNCHER\n    /// @dev Still have to wait out auctionEnds after\n    function endRebalance() external nonReentrant {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(REBALANCE_MANAGER, msg.sender) ||\n                hasRole(AUCTION_LAUNCHER, msg.sender),\n            Folio__Unauthorized()\n        );\n\n        emit RebalanceEnded(rebalance.nonce);\n\n        // do not revert, to prevent griefing\n        rebalance.nonce++; // advancing nonce clears auctionEnds\n        rebalance.availableUntil = block.timestamp;\n    }\n\n    // ==== Internal ====\n\n    /// @param shares {share}\n    /// @return _assets\n    /// @return _amounts {tok}\n    function _toAssets(\n        uint256 shares,\n        Math.Rounding rounding\n    ) internal view returns (address[] memory _assets, uint256[] memory _amounts) {\n        uint256 _totalSupply = totalSupply();\n\n        (_assets, _amounts) = _totalAssets();\n\n        uint256 assetLen = _assets.length;\n        for (uint256 i; i < assetLen; i++) {\n            // {tok} = {share} * {tok} / {share}\n            _amounts[i] = Math.mulDiv(shares, _amounts[i], _totalSupply, rounding);\n        }\n    }\n\n    /// @return _assets\n    /// @return _amounts {tok}\n    function _totalAssets() internal view returns (address[] memory _assets, uint256[] memory _amounts) {\n        _assets = basket.values();\n\n        uint256 assetLength = _assets.length;\n        _amounts = new uint256[](assetLength);\n        for (uint256 i; i < assetLength; i++) {\n            _amounts[i] = _balanceOfToken(IERC20(_assets[i]));\n        }\n    }\n\n    /// @return amount The known balances of a token, including trusted fills\n    function _balanceOfToken(IERC20 token) internal view returns (uint256 amount) {\n        amount = token.balanceOf(address(this));\n\n        if (\n            address(activeTrustedFill) != address(0) &&\n            (activeTrustedFill.sellToken() == token || activeTrustedFill.buyToken() == token)\n        ) {\n            amount += token.balanceOf(address(activeTrustedFill));\n        }\n    }\n\n    /// @return _daoPendingFeeShares {share}\n    /// @return _feeRecipientsPendingFeeShares {share}\n    function _getPendingFeeShares()\n        internal\n        view\n        returns (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares, uint256 _accountedUntil)\n    {\n        // {s} Always in full days\n        _accountedUntil = (block.timestamp / ONE_DAY) * ONE_DAY;\n        uint256 elapsed = _accountedUntil > lastPoke ? _accountedUntil - lastPoke : 0;\n\n        if (elapsed == 0) {\n            return (daoPendingFeeShares, feeRecipientsPendingFeeShares, lastPoke);\n        }\n\n        _daoPendingFeeShares = daoPendingFeeShares;\n        _feeRecipientsPendingFeeShares = feeRecipientsPendingFeeShares;\n\n        // {share}\n        uint256 supply = super.totalSupply() + _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n\n        (, uint256 daoFeeNumerator, uint256 daoFeeDenominator, uint256 daoFeeFloor) = daoFeeRegistry.getFeeDetails(\n            address(this)\n        );\n\n        // convert annual percentage to per-second for comparison with stored tvlFee\n        // = 1 - (1 - feeFloor) ^ (1 / 31536000)\n        // D18{1/s} = D18{1} - D18{1} * D18{1} ^ D18{1/s}\n        uint256 feeFloor = D18 - MathLib.pow(D18 - daoFeeFloor, ONE_OVER_YEAR);\n\n        // D18{1/s}\n        uint256 _tvlFee = feeFloor > tvlFee ? feeFloor : tvlFee;\n\n        // {share} += {share} * D18 / D18{1/s} ^ {s} - {share}\n        uint256 feeShares = (supply * D18) / MathLib.powu(D18 - _tvlFee, elapsed) - supply;\n\n        // D18{1} = D18{1/s} * D18 / D18{1/s}\n        uint256 correction = (feeFloor * D18 + _tvlFee - 1) / _tvlFee;\n\n        // {share} = {share} * D18{1} / D18\n        uint256 daoShares = (correction > (daoFeeNumerator * D18 + daoFeeDenominator - 1) / daoFeeDenominator)\n            ? (feeShares * correction + D18 - 1) / D18\n            : (feeShares * daoFeeNumerator + daoFeeDenominator - 1) / daoFeeDenominator;\n\n        _daoPendingFeeShares += daoShares;\n        _feeRecipientsPendingFeeShares += feeShares - daoShares;\n    }\n\n    /// Set TVL fee by annual percentage. Different from how it is stored!\n    /// @param _newFeeAnnually D18{1}\n    function _setTVLFee(uint256 _newFeeAnnually) internal {\n        require(_newFeeAnnually <= MAX_TVL_FEE, Folio__TVLFeeTooHigh());\n\n        // convert annual percentage to per-second\n        // = 1 - (1 - _newFeeAnnually) ^ (1 / 31536000)\n        // D18{1/s} = D18{1} - D18{1} ^ {s}\n        tvlFee = D18 - MathLib.pow(D18 - _newFeeAnnually, ONE_OVER_YEAR);\n\n        require(_newFeeAnnually == 0 || tvlFee != 0, Folio__TVLFeeTooLow());\n\n        emit TVLFeeSet(tvlFee, _newFeeAnnually);\n    }\n\n    /// Set mint fee\n    /// @param _newFee D18{1}\n    function _setMintFee(uint256 _newFee) internal {\n        require(_newFee <= MAX_MINT_FEE, Folio__MintFeeTooHigh());\n\n        mintFee = _newFee;\n        emit MintFeeSet(_newFee);\n    }\n\n    /// @dev Warning: An empty fee recipients table will result in all fees being sent to DAO\n    function _setFeeRecipients(FeeRecipient[] memory _feeRecipients) internal {\n        emit FeeRecipientsSet(_feeRecipients);\n\n        // Clear existing fee table\n        uint256 len = feeRecipients.length;\n        for (uint256 i; i < len; i++) {\n            feeRecipients.pop();\n        }\n\n        // Add new items to the fee table\n        len = _feeRecipients.length;\n\n        if (len == 0) {\n            return;\n        }\n\n        require(len <= MAX_FEE_RECIPIENTS, Folio__TooManyFeeRecipients());\n\n        address previousRecipient;\n        uint256 total;\n\n        for (uint256 i; i < len; i++) {\n            require(_feeRecipients[i].recipient > previousRecipient, Folio__FeeRecipientInvalidAddress());\n            require(_feeRecipients[i].portion != 0, Folio__FeeRecipientInvalidFeeShare());\n\n            total += _feeRecipients[i].portion;\n            previousRecipient = _feeRecipients[i].recipient;\n            feeRecipients.push(_feeRecipients[i]);\n        }\n\n        // ensure table adds up to 100%\n        require(total == D18, Folio__BadFeeTotal());\n    }\n\n    /// @param _newLength {s}\n    function _setAuctionLength(uint256 _newLength) internal {\n        require(_newLength >= MIN_AUCTION_LENGTH && _newLength <= MAX_AUCTION_LENGTH, Folio__InvalidAuctionLength());\n\n        auctionLength = _newLength;\n        emit AuctionLengthSet(auctionLength);\n    }\n\n    function _setMandate(string memory _newMandate) internal {\n        mandate = _newMandate;\n        emit MandateSet(_newMandate);\n    }\n\n    /// @dev After: daoPendingFeeShares and feeRecipientsPendingFeeShares are up-to-date\n    function _poke() internal {\n        _closeTrustedFill();\n\n        (\n            uint256 _daoPendingFeeShares,\n            uint256 _feeRecipientsPendingFeeShares,\n            uint256 _accountedUntil\n        ) = _getPendingFeeShares();\n\n        if (_accountedUntil > lastPoke) {\n            daoPendingFeeShares = _daoPendingFeeShares;\n            feeRecipientsPendingFeeShares = _feeRecipientsPendingFeeShares;\n            lastPoke = _accountedUntil;\n        }\n    }\n\n    function _addToBasket(address token) internal returns (bool) {\n        require(token != address(0) && token != address(this), Folio__InvalidAsset());\n        emit BasketTokenAdded(token);\n\n        return basket.add(token);\n    }\n\n    function _removeFromBasket(address token) internal returns (bool) {\n        emit BasketTokenRemoved(token);\n\n        delete rebalance.details[token];\n\n        return basket.remove(token);\n    }\n\n    function _setTrustedFillerRegistry(address _newFillerRegistry, bool _enabled) internal {\n        if (address(trustedFillerRegistry) != _newFillerRegistry) {\n            require(address(trustedFillerRegistry) == address(0), Folio__TrustedFillerRegistryAlreadySet());\n\n            trustedFillerRegistry = ITrustedFillerRegistry(_newFillerRegistry);\n        }\n\n        if (trustedFillerEnabled != _enabled) {\n            trustedFillerEnabled = _enabled;\n        }\n\n        emit TrustedFillerRegistrySet(address(trustedFillerRegistry), trustedFillerEnabled);\n    }\n\n    /// Claim all token balances from outstanding trusted fill\n    function _closeTrustedFill() internal {\n        if (address(activeTrustedFill) != address(0)) {\n            activeTrustedFill.closeFiller();\n\n            delete activeTrustedFill;\n        }\n    }\n\n    function _update(address from, address to, uint256 value) internal override {\n        // prevent accidental donations\n        require(to != address(this), Folio__InvalidTransferToSelf());\n\n        super._update(from, to, value);\n    }\n}\n",
        "CowSwapFiller.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IBaseTrustedFiller } from \"../../interfaces/IBaseTrustedFiller.sol\";\n\nimport { GPv2OrderLib } from \"./GPv2OrderLib.sol\";\nimport { GPV2_SETTLEMENT, GPV2_VAULT_RELAYER, D27 } from \"./Constants.sol\";\n\n/// Swap MUST occur in the same block as initialization\n/// Expected to be newly deployed in the pre-hook of a CowSwap order\n/// Ideally `closeFiller()` is called in the end as a post-hook, but this is not relied upon\ncontract CowSwapFiller is Initializable, IBaseTrustedFiller {\n    using GPv2OrderLib for GPv2OrderLib.Data;\n    using SafeERC20 for IERC20;\n\n    error CowSwapFiller__Unauthorized();\n    error CowSwapFiller__OrderCheckFailed(uint256 errorCode);\n\n    address public fillCreator;\n\n    IERC20 public sellToken;\n    IERC20 public buyToken;\n\n    uint256 public sellAmount; // {sellTok}\n    uint256 public blockInitialized; // {block}\n\n    uint256 public price; // D27{buyTok/sellTok}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// Initialize the swap, transferring in `_sellAmount` of the `_sell` token\n    /// @dev Built for the pre-hook of a CowSwap order, must be called via using entity\n    function initialize(\n        address _creator,\n        IERC20 _sellToken,\n        IERC20 _buyToken,\n        uint256 _sellAmount,\n        uint256 _minBuyAmount\n    ) external initializer {\n        fillCreator = _creator;\n        sellToken = _sellToken;\n        buyToken = _buyToken;\n        sellAmount = _sellAmount;\n\n        blockInitialized = block.number;\n\n        // D27{buyTok/sellTok} = {buyTok} * D27 / {sellTok}\n        price = Math.mulDiv(_minBuyAmount, D27, _sellAmount, Math.Rounding.Ceil);\n\n        sellToken.forceApprove(GPV2_VAULT_RELAYER, _sellAmount);\n        sellToken.safeTransferFrom(_creator, address(this), _sellAmount);\n    }\n\n    /// @dev Validates CowSwap order for a fill via EIP-1271\n    function isValidSignature(bytes32 orderHash, bytes calldata signature) external view returns (bytes4) {\n        require(block.number == blockInitialized, CowSwapFiller__Unauthorized());\n\n        // Decode signature to get the CowSwap order\n        GPv2OrderLib.Data memory order = abi.decode(signature, (GPv2OrderLib.Data));\n\n        // Verify Order Hash\n        require(orderHash == order.hash(GPV2_SETTLEMENT.domainSeparator()), CowSwapFiller__OrderCheckFailed(0)); // Invalid Order Hash\n\n        require(order.sellToken == sellToken, CowSwapFiller__OrderCheckFailed(1)); // Invalid Sell Token\n        require(order.buyToken == buyToken, CowSwapFiller__OrderCheckFailed(2)); // Invalid Buy Token\n        require(order.feeAmount == 0, CowSwapFiller__OrderCheckFailed(3)); // Must be a Limit Order\n        require(order.receiver == address(this), CowSwapFiller__OrderCheckFailed(4)); // Receiver must be self\n        require(order.sellTokenBalance == GPv2OrderLib.BALANCE_ERC20, CowSwapFiller__OrderCheckFailed(5)); // Must use ERC20 Balance\n        require(order.buyTokenBalance == GPv2OrderLib.BALANCE_ERC20, CowSwapFiller__OrderCheckFailed(6)); // Must use ERC20 Balance\n        require(order.sellAmount != 0, CowSwapFiller__OrderCheckFailed(7)); // catch div-by-zero below\n\n        // Price check, just in case\n        // D27{buyTok/sellTok} = {buyTok} * D27 / {sellTok}\n        uint256 orderPrice = Math.mulDiv(order.buyAmount, D27, order.sellAmount, Math.Rounding.Floor);\n        require(order.sellAmount <= sellAmount && orderPrice >= price, CowSwapFiller__OrderCheckFailed(100));\n\n        // If all checks pass, return the magic value\n        return this.isValidSignature.selector;\n    }\n\n    /// @return true if the contract is mid-swap and funds have not yet settled\n    function swapActive() public view returns (bool) {\n        if (block.number != blockInitialized) {\n            return false;\n        }\n\n        uint256 sellTokenBalance = sellToken.balanceOf(address(this));\n\n        if (sellTokenBalance >= sellAmount) {\n            return false;\n        }\n\n        // {buyTok} = {sellTok} * D27{buyTok/sellTok} / D27\n        uint256 minimumExpectedIn = Math.mulDiv(sellAmount - sellTokenBalance, price, D27, Math.Rounding.Ceil);\n        \n        return minimumExpectedIn > buyToken.balanceOf(address(this));\n    }\n\n    /// Collect all balances back to the beneficiary\n    function closeFiller() external {\n        require(!swapActive(), IBaseTrustedFiller__SwapActive());\n\n        rescueToken(sellToken);\n        rescueToken(buyToken);\n    }\n\n    /// Rescue tokens in case any are left in the contract\n    function rescueToken(IERC20 token) public {\n        uint256 tokenBalance = token.balanceOf(address(this));\n\n        if (tokenBalance != 0) {\n            token.safeTransfer(fillCreator, tokenBalance);\n        }\n    }\n}\n",
        "AuctionLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IBidderCallee } from \"@interfaces/IBidderCallee.sol\";\nimport { IFolio } from \"@interfaces/IFolio.sol\";\n\nimport { D18, D27, MAX_AUCTION_PRICE, MAX_AUCTION_PRICE_RANGE, MAX_TOKEN_BALANCE } from \"@utils/Constants.sol\";\nimport { MathLib } from \"@utils/MathLib.sol\";\n\nlibrary AuctionLib {\n    // stack-too-deep\n    struct AuctionArgs {\n        uint256 auctionId;\n        IERC20 sellToken;\n        IERC20 buyToken;\n        uint256 sellLimit;\n        uint256 buyLimit;\n        uint256 startPrice;\n        uint256 endPrice;\n        uint256 auctionBuffer;\n    }\n\n    /// Open a new auction\n    function openAuction(\n        IFolio.Rebalance storage rebalance,\n        mapping(uint256 auctionId => IFolio.Auction auction) storage auctions,\n        mapping(uint256 rebalanceNonce => mapping(bytes32 pair => uint256 endTime)) storage auctionEnds,\n        uint256 totalSupply,\n        uint256 auctionLength,\n        AuctionArgs memory args\n    ) external {\n        IFolio.RebalanceDetails storage sellDetails = rebalance.details[address(args.sellToken)];\n        IFolio.RebalanceDetails storage buyDetails = rebalance.details[address(args.buyToken)];\n\n        // confirm rebalance ongoing\n        require(\n            block.timestamp >= rebalance.startedAt + args.auctionBuffer && block.timestamp < rebalance.availableUntil,\n            IFolio.Folio__NotRebalancing()\n        );\n\n        // confirm tokens are in rebalance\n        require(sellDetails.inRebalance && buyDetails.inRebalance, IFolio.Folio__NotRebalancing());\n\n        // confirm no auction collision on token pair\n        {\n            bytes32 pair = AuctionLib.pairHash(args.sellToken, args.buyToken);\n            require(\n                block.timestamp > auctionEnds[rebalance.nonce][pair] + args.auctionBuffer,\n                IFolio.Folio__AuctionCollision()\n            );\n\n            auctionEnds[rebalance.nonce][pair] = block.timestamp + auctionLength;\n        }\n\n        // preserve limits relative ordering\n        require(\n            args.sellLimit >= sellDetails.limits.low && args.sellLimit <= sellDetails.limits.high,\n            IFolio.Folio__InvalidSellLimit()\n        );\n        require(\n            args.buyLimit >= buyDetails.limits.low && args.buyLimit <= buyDetails.limits.high,\n            IFolio.Folio__InvalidBuyLimit()\n        );\n\n        // confirm sellToken is in surplus and buyToken is in deficit\n        {\n            // {sellTok} = D27{sellTok/share} * {share} / D27\n            uint256 sellBalLimit = Math.mulDiv(args.sellLimit, totalSupply, D27, Math.Rounding.Ceil);\n            require(args.sellToken.balanceOf(address(this)) > sellBalLimit, IFolio.Folio__InvalidSellLimit());\n\n            // {buyTok} = D27{buyTok/share} * {share} / D27\n            uint256 buyBalLimit = Math.mulDiv(args.buyLimit, totalSupply, D27, Math.Rounding.Floor);\n            require(args.buyToken.balanceOf(address(this)) < buyBalLimit, IFolio.Folio__InvalidBuyLimit());\n        }\n\n        // ensure valid price range (startPrice == endPrice is valid)\n        require(\n            args.startPrice >= args.endPrice &&\n                args.endPrice != 0 &&\n                args.startPrice <= MAX_AUCTION_PRICE &&\n                args.startPrice / args.endPrice <= MAX_AUCTION_PRICE_RANGE,\n            IFolio.Folio__InvalidPrices()\n        );\n\n        // update spot limits to prevent double trading in the future by openAuctionUnrestricted()\n        sellDetails.limits.spot = args.sellLimit;\n        buyDetails.limits.spot = args.buyLimit;\n\n        // update low/high limits to prevent double trading in the future by openAuction()\n        sellDetails.limits.high = args.sellLimit;\n        buyDetails.limits.low = args.buyLimit;\n        // by lowering the high sell limit the AUCTION_LAUNCHER cannot backtrack and later buy the sellToken\n        // by raising the low buy limit the AUCTION_LAUNCHER cannot backtrack and later sell the buyToken\n        // intentional: by leaving the other 2 limits unchanged (sell.low and buy.high) there can be future\n        //              auctions to trade FURTHER, incase current auctions go better than expected\n\n        IFolio.Auction memory auction = IFolio.Auction({\n            rebalanceNonce: rebalance.nonce,\n            sellToken: args.sellToken,\n            buyToken: args.buyToken,\n            sellLimit: args.sellLimit,\n            buyLimit: args.buyLimit,\n            startPrice: args.startPrice,\n            endPrice: args.endPrice,\n            startTime: block.timestamp,\n            endTime: block.timestamp + auctionLength\n        });\n        auctions[args.auctionId] = auction;\n\n        emit IFolio.AuctionOpened(args.auctionId, auction);\n    }\n\n    /// Get bid parameters for an ongoing auction\n    /// @param totalSupply {share} Current total supply of the Folio\n    /// @param timestamp {s} Timestamp to fetch bid for\n    /// @param sellBal {sellTok} Folio's available balance of sell token, including any active fills\n    /// @param buyBal {buyTok} Folio's available balance of buy token, including any active fills\n    /// @param minSellAmount {sellTok} The minimum sell amount the bidder should receive\n    /// @param maxSellAmount {sellTok} The maximum sell amount the bidder should receive\n    /// @param maxBuyAmount {buyTok} The maximum buy amount the bidder is willing to offer\n    /// @return sellAmount {sellTok} The actual sell amount in the bid\n    /// @return bidAmount {buyTok} The corresponding buy amount\n    /// @return price D27{buyTok/sellTok} The price at the given timestamp as an 27-decimal fixed point\n    function getBid(\n        IFolio.Auction storage auction,\n        uint256 totalSupply,\n        uint256 timestamp,\n        uint256 sellBal,\n        uint256 buyBal,\n        uint256 minSellAmount,\n        uint256 maxSellAmount,\n        uint256 maxBuyAmount\n    ) external view returns (uint256 sellAmount, uint256 bidAmount, uint256 price) {\n        assert(minSellAmount <= maxSellAmount);\n\n        // checks auction is ongoing\n        // D27{buyTok/sellTok}\n        price = _price(auction, timestamp);\n\n        // {sellTok} = D27{sellTok/share} * {share} / D27\n        uint256 sellLimitBal = Math.mulDiv(auction.sellLimit, totalSupply, D27, Math.Rounding.Ceil);\n        uint256 sellAvailable = sellBal > sellLimitBal ? sellBal - sellLimitBal : 0;\n\n        // {buyTok} = D27{buyTok/share} * {share} / D27\n        uint256 buyLimitBal = Math.mulDiv(auction.buyLimit, totalSupply, D27, Math.Rounding.Floor);\n        uint256 buyAvailable = buyBal < buyLimitBal ? buyLimitBal - buyBal : 0;\n\n        // maximum valid token balance is 1e36; do not try to buy more than this\n        buyAvailable = Math.min(buyAvailable, MAX_TOKEN_BALANCE);\n\n        // {sellTok} = {buyTok} * D27 / D27{buyTok/sellTok}\n        uint256 sellAvailableFromBuy = Math.mulDiv(buyAvailable, D27, price, Math.Rounding.Floor);\n        sellAvailable = Math.min(sellAvailable, sellAvailableFromBuy);\n\n        // ensure auction is large enough to cover bid\n        require(sellAvailable >= minSellAmount, IFolio.Folio__InsufficientSellAvailable());\n\n        // {sellTok}\n        sellAmount = Math.min(sellAvailable, maxSellAmount);\n\n        // {buyTok} = {sellTok} * D27{buyTok/sellTok} / D27\n        bidAmount = Math.mulDiv(sellAmount, price, D27, Math.Rounding.Ceil);\n        require(bidAmount != 0 && bidAmount <= maxBuyAmount, IFolio.Folio__SlippageExceeded());\n    }\n\n    /// Bid in an ongoing auction\n    ///   If withCallback is true, caller must adhere to IBidderCallee interface and receives a callback\n    ///   If withCallback is false, caller must have provided an allowance in advance\n    /// @dev Callable by anyone\n    /// @param sellAmount {sellTok} Sell amount as returned by getBid\n    /// @param bidAmount {buyTok} Bid amount as returned by getBid\n    /// @param withCallback If true, caller must adhere to IBidderCallee interface and transfers tokens via callback\n    /// @param data Arbitrary data to pass to the callback\n    /// @return shouldRemoveFromBasket If true, the auction's sell token should be removed from the basket after\n    function bid(\n        IFolio.Auction storage auction,\n        mapping(bytes32 pair => uint256 endTime) storage auctionEnds,\n        uint256 totalSupply,\n        uint256 sellAmount,\n        uint256 bidAmount,\n        bool withCallback,\n        bytes calldata data\n    ) external returns (bool shouldRemoveFromBasket) {\n        // pay bidder\n        SafeERC20.safeTransfer(auction.sellToken, msg.sender, sellAmount);\n\n        // D27{sellTok/share}\n        uint256 sellBasketPresence;\n        {\n            // {sellTok}\n            uint256 sellBal = auction.sellToken.balanceOf(address(this));\n\n            // remove sell token from basket at 0 balance\n            if (sellBal == 0) {\n                shouldRemoveFromBasket = true;\n            }\n\n            // D27{sellTok/share} = {sellTok} * D27 / {share}\n            sellBasketPresence = Math.mulDiv(sellBal, D27, totalSupply, Math.Rounding.Ceil);\n            assert(sellBasketPresence >= auction.sellLimit); // function-use invariant\n        }\n\n        // D27{buyTok/share}\n        uint256 buyBasketPresence;\n        {\n            // {buyTok}\n            uint256 buyBalBefore = auction.buyToken.balanceOf(address(this));\n\n            // collect payment from bidder\n            if (withCallback) {\n                IBidderCallee(msg.sender).bidCallback(address(auction.buyToken), bidAmount, data);\n            } else {\n                SafeERC20.safeTransferFrom(auction.buyToken, msg.sender, address(this), bidAmount);\n            }\n\n            uint256 buyBalAfter = auction.buyToken.balanceOf(address(this));\n\n            require(buyBalAfter - buyBalBefore >= bidAmount, IFolio.Folio__InsufficientBid());\n\n            // D27{buyTok/share} = {buyTok} * D27 / {share}\n            buyBasketPresence = Math.mulDiv(buyBalAfter, D27, totalSupply, Math.Rounding.Floor);\n        }\n\n        // end auction at limits\n        // can still be griefed\n        // limits may not be reacheable due to limited precision + defensive roundings\n        if (sellBasketPresence == auction.sellLimit || buyBasketPresence >= auction.buyLimit) {\n            auction.endTime = block.timestamp - 1;\n            auctionEnds[pairHash(auction.sellToken, auction.buyToken)] = block.timestamp - 1;\n        }\n    }\n\n    // ==== Internal ====\n\n    /// @return p D27{buyTok/sellTok}\n    function _price(IFolio.Auction storage auction, uint256 timestamp) internal view returns (uint256 p) {\n        // ensure auction is ongoing\n        require(timestamp >= auction.startTime && timestamp <= auction.endTime, IFolio.Folio__AuctionNotOngoing());\n\n        if (timestamp == auction.startTime) {\n            return auction.startPrice;\n        }\n        if (timestamp == auction.endTime) {\n            return auction.endPrice;\n        }\n\n        uint256 elapsed = timestamp - auction.startTime;\n        uint256 auctionLength = auction.endTime - auction.startTime;\n\n        // D18{1}\n        // k = ln(P_0 / P_t) / t\n        uint256 k = MathLib.ln(Math.mulDiv(auction.startPrice, D18, auction.endPrice)) / auctionLength;\n\n        // P_t = P_0 * e ^ -kt\n        // D27{buyTok/sellTok} = D27{buyTok/sellTok} * D18{1} / D18\n        p = Math.mulDiv(auction.startPrice, MathLib.exp(-1 * int256(k * elapsed)), D18);\n        if (p < auction.endPrice) {\n            p = auction.endPrice;\n        }\n    }\n\n    /// @return pair The hash of the pair\n    function pairHash(IERC20 sellToken, IERC20 buyToken) internal pure returns (bytes32) {\n        return\n            sellToken > buyToken\n                ? keccak256(abi.encode(sellToken, buyToken))\n                : keccak256(abi.encode(buyToken, sellToken));\n    }\n}\n"
    }
}