{
    "vfp_id": "vfp_00005",
    "project_name": "Zenith - SSI Protocol Audit Report.pdf",
    "findings": [
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "lock() It is recommended to use safeTransferFrom",
            "description": "1. **Description:** The lock() function uses raw transfer calls instead of safeTransferFrom, which may lead to issues with non-compliant ERC20 tokens.\n2. **Cause:** Direct use of transfer without safety checks for token compliance.\n3. **Exploitation:** Interaction with non-standard tokens could revert or behave unexpectedly.\n4. **Impact:** Potential transaction failures when handling certain ERC20 tokens.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetLocking.sol"
            ]
        }
    ],
    "affected_files": {
        "AssetLocking.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport './Interface.sol';\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"forge-std/console.sol\";\n\ncontract AssetLocking is Initializable, OwnableUpgradeable, UUPSUpgradeable, PausableUpgradeable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    event SetEpoch(address token, uint8 oldEpoch, uint8 newEpoch);\n    event UpdateLockConfig(address token, uint8 epoch, uint256 lockLimit, uint48 cooldown);\n    event Lock(address locker, address token, uint256 amount);\n    event UnLock(address locker, address token, uint256 amount);\n    event Withdraw(address locker, address token, uint256 amount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address owner) public initializer {\n        __Ownable_init(owner);\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    uint48 public constant MAX_COOLDOWN = 90 days;\n\n    struct LockConfig {\n        uint8 epoch;\n        uint256 lockLimit;\n        uint48 cooldown;\n        uint256 totalLock;\n        uint256 totalCooldown;\n    }\n\n    struct LockData {\n        uint256 amount;\n        uint256 cooldownAmount;\n        uint256 cooldownEndTimestamp;\n    }\n\n    EnumerableSet.AddressSet tokens_;\n    mapping(address => uint8) public activeEpochs;\n    mapping(address => LockConfig) public lockConfigs;\n    mapping(address => mapping (address => LockData)) public lockDatas;\n\n    function setEpoch(address token, uint8 newEpoch) external onlyOwner {\n        uint8 oldEpoch = activeEpochs[token];\n        require(newEpoch != activeEpochs[token], \"epoch not change\");\n        activeEpochs[token] = newEpoch;\n        emit SetEpoch(token, oldEpoch, newEpoch);\n    }\n\n    function updateLockConfig(address token, uint8 epoch, uint256 lockLimit, uint48 cooldown) external onlyOwner {\n        if (!tokens_.contains(token)) {\n            tokens_.add(token);\n        }\n        require(cooldown <= MAX_COOLDOWN, \"cooldown exceeds MAX_COOLDOWN\");\n        LockConfig storage lockConfig = lockConfigs[token];\n        lockConfig.epoch = epoch;\n        lockConfig.lockLimit = lockLimit;\n        lockConfig.cooldown = cooldown;\n        emit UpdateLockConfig(token, epoch, lockLimit, cooldown);\n    }\n\n    function getActiveTokens() external view returns (address[] memory tokens)  {\n        address[] memory tmp = new address[](tokens_.length());\n        uint j = 0;\n        for (uint i = 0; i < tokens_.length(); i++) {\n            address token = tokens_.at(i);\n            if (lockConfigs[token].epoch == activeEpochs[token]) {\n                tmp[j] = token;\n                j += 1;\n            }\n        }\n        tokens = new address[](j);\n        for (uint i = 0; i < j; i++) {\n            tokens[i] = tmp[i];\n        }\n    }\n\n    function lock(address token, uint256 amount) external whenNotPaused {\n        require(tokens_.contains(token), \"token not supported\");\n        require(lockConfigs[token].epoch == activeEpochs[token], \"token cannot stake now\");\n        LockData storage lockData = lockDatas[token][msg.sender];\n        LockConfig storage lockConfig = lockConfigs[token];\n        require(lockConfig.totalLock + amount <= lockConfig.lockLimit, \"total lock amount exceeds lock limit\");\n        require(IERC20(token).allowance(msg.sender, address(this)) >= amount, \"not enough allowance\");\n        lockData.amount += amount;\n        lockConfig.totalLock += amount;\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        emit Lock(msg.sender, token, amount);\n    }\n\n    function unlock(address token, uint256 amount) external whenNotPaused {\n        LockData storage lockData = lockDatas[token][msg.sender];\n        LockConfig storage lockConfig = lockConfigs[token];\n        require(lockData.amount >= amount, \"not enough balance to unlock\");\n        lockData.amount -= amount;\n        lockData.cooldownAmount += amount;\n        lockData.cooldownEndTimestamp = block.timestamp + lockConfig.cooldown;\n        lockConfig.totalLock -= amount;\n        lockConfig.totalCooldown += amount;\n        emit UnLock(msg.sender, token, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external whenNotPaused {\n        LockData storage lockData = lockDatas[token][msg.sender];\n        require(lockData.cooldownAmount > 0, \"nothing to withdraw\");\n        require(lockData.cooldownEndTimestamp <= block.timestamp, \"coolingdown\");\n        require(amount <= lockData.cooldownAmount, \"no enough balance to withdraw\");\n        lockData.cooldownAmount -= amount;\n        LockConfig storage lockConfig = lockConfigs[token];\n        lockConfig.totalCooldown -= amount;\n        IERC20(token).safeTransfer(msg.sender, amount);\n        emit Withdraw(msg.sender, token, amount);\n    }\n}"
    }
}