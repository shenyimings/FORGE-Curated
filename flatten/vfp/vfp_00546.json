{
    "vfp_id": "vfp_00546",
    "project_name": "Uniswap Calibur Audit.md",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "`revertOnFailure` Does Not Consider Hooks Revert",
            "description": "The `beforeExecutionHook` function reverts when execution fails, even if `revertOnFailure` is set to `false`, which contradicts the expected behavior where failed calls should not revert. The cause is a logic inconsistency between the hook behavior and the batch execution mode. An attacker could exploit this by crafting a transaction with `revertOnFailure=false` but triggering a hook revert, causing the entire transaction to fail unexpectedly. The impact is incorrect error handling and potential denial of service, reducing the reliability of batched transaction execution.\n",
            "severity": "Low",
            "location": [
                "HooksLib.sol::beforeExecutionHook#74",
                "MinimalDelegation.sol#191"
            ],
            "files": [
                "732a20a8d82f034573c6c7e44160f1860233a946/minimal-delegation/src/libraries/HooksLib.sol"
            ]
        }
    ],
    "affected_files": {
        "HooksLib.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {IHook} from \"../interfaces/IHook.sol\";\nimport {IExecutionHook} from \"../interfaces/IExecutionHook.sol\";\nimport {IValidationHook} from \"../interfaces/IValidationHook.sol\";\nimport {PackedUserOperation} from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title HooksLib\n/// @notice Hooks are invoked by inspecting the least significant bits of the address it is deployed to\n/// For example, a hook deployed to address: 0x000000000000000000000000000000000000000a\n/// has the lowest bits '0001 1010' which would cause the 'VALIDATE_USER_OP', 'BEFORE_EXECUTE', and 'AFTER_EXECUTE' hooks to be used.\n/// @author Inspired by https://github.com/Uniswap/v4-core/blob/main/src/libraries/Hooks.sol\nlibrary HooksLib {\n    using HooksLib for IHook;\n\n    /// @notice Internal constant hook flags\n    uint160 internal constant AFTER_VERIFY_SIGNATURE_FLAG = 1 << 0;\n    uint160 internal constant AFTER_VALIDATE_USER_OP_FLAG = 1 << 1;\n    uint160 internal constant AFTER_IS_VALID_SIGNATURE_FLAG = 1 << 2;\n    uint160 internal constant BEFORE_EXECUTE_FLAG = 1 << 3;\n    uint160 internal constant AFTER_EXECUTE_FLAG = 1 << 4;\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Returns whether the flag is configured for the hook\n    function hasPermission(IHook self, uint160 flag) internal pure returns (bool) {\n        return uint160(address(self)) & flag != 0;\n    }\n\n    /// @notice Handles the afterValidateUserOp hook\n    /// @notice MAY revert if desired according to ERC-4337 spec\n    /// @dev Expected to validate the userOp and return a validationData which will override the internally computed validationData\n    function handleAfterValidateUserOp(\n        IHook self,\n        bytes32 keyHash,\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        bytes memory hookData\n    ) internal view {\n        if (self.hasPermission(HooksLib.AFTER_VALIDATE_USER_OP_FLAG)) {\n            (bytes4 hookSelector) = self.afterValidateUserOp(keyHash, userOp, userOpHash, hookData);\n            if (hookSelector != IValidationHook.afterValidateUserOp.selector) revert InvalidHookResponse();\n        }\n    }\n\n    /// @notice Handles the afterIsValidSignature hook\n    /// @notice MUST revert if validation fails\n    /// @dev Expected to validate the signature and return a value which will override the internally computed ERC-1271 magic value\n    function handleAfterIsValidSignature(IHook self, bytes32 keyHash, bytes32 digest, bytes memory hookData)\n        internal\n        view\n    {\n        if (self.hasPermission(HooksLib.AFTER_IS_VALID_SIGNATURE_FLAG)) {\n            bytes4 hookSelector = self.afterIsValidSignature(keyHash, digest, hookData);\n            if (hookSelector != IValidationHook.afterIsValidSignature.selector) revert InvalidHookResponse();\n        }\n    }\n\n    /// @notice Handles the afterVerifySignature hook\n    /// @notice MUST revert if validation fails\n    function handleAfterVerifySignature(IHook self, bytes32 keyHash, bytes32 digest, bytes memory hookData)\n        internal\n        view\n    {\n        if (self.hasPermission(HooksLib.AFTER_VERIFY_SIGNATURE_FLAG)) {\n            bytes4 hookSelector = self.afterVerifySignature(keyHash, digest, hookData);\n            if (hookSelector != IValidationHook.afterVerifySignature.selector) revert InvalidHookResponse();\n        }\n    }\n\n    /// @notice Handles the beforeExecute hook\n    /// @dev Expected to revert if the execution should be reverted\n    /// @return beforeExecuteData any data which the hook wishes to be passed into the afterExecute hook\n    function handleBeforeExecute(IHook self, bytes32 keyHash, address to, uint256 value, bytes memory data)\n        internal\n        returns (bytes memory beforeExecuteData)\n    {\n        if (self.hasPermission(HooksLib.BEFORE_EXECUTE_FLAG)) {\n            bytes4 hookSelector;\n            (hookSelector, beforeExecuteData) = self.beforeExecute(keyHash, to, value, data);\n            if (hookSelector != IExecutionHook.beforeExecute.selector) revert InvalidHookResponse();\n        }\n    }\n\n    /// @notice Handles the afterExecute hook\n    /// @param beforeExecuteData data returned from the beforeExecute hook\n    /// @dev Expected to revert if the execution should be reverted\n    function handleAfterExecute(IHook self, bytes32 keyHash, bytes memory beforeExecuteData) internal {\n        if (self.hasPermission(HooksLib.AFTER_EXECUTE_FLAG)) {\n            bytes4 hookSelector = self.afterExecute(keyHash, beforeExecuteData);\n            if (hookSelector != IExecutionHook.afterExecute.selector) revert InvalidHookResponse();\n        }\n    }\n}\n"
    }
}