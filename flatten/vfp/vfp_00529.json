{
    "vfp_id": "vfp_00529",
    "project_name": "cantina_seamless_sep2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-74"
                ]
            },
            "title": "Unauthorized Transfer of User-Approved ERC20 Tokens via LeverageRouter",
            "description": "1. **Description:** The _depositAndRepayMorphoFlashLoan and _redeemAndRepayMorphoFlashLoan internal functions allow arbitrary external calls to any address passed via the swapCalls parameter in deposit or redeem functions. This enables a malicious actor to include a transferFrom call in the calldata, thereby draining user-approved ERC20 tokens.\n2. **Cause:** The vulnerability arises from the lack of validation or whitelisting of external calls made through the swapCalls array. The LeverageRouter holds temporary ERC20 allowances during mint and redeem operations, making it a target for abuse.\n3. **Exploitation:** An attacker can craft a malicious swapCall that includes a transferFrom call to transfer tokens from a user who has approved the router, to an attacker-controlled address. This can also be extended to stealing future allowances via permit2 or triggering untrusted callbacks through flash loans.\n4. **Impact:** Successful exploitation allows theft of user funds that have been approved to the router, especially on chains with public mempools where transaction details can be front-run.\n",
            "severity": "High",
            "location": [
                "LeverageRouter::deposit",
                "LeverageRouter::redeem",
                "_depositAndRepayMorphoFlashLoan",
                "_redeemAndRepayMorphoFlashLoan"
            ],
            "files": [
                "leverage-tokens/src/periphery/LeverageRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "LeverageRouter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Dependency imports\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IMorpho} from \"@morpho-blue/interfaces/IMorpho.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Internal imports\nimport {ILendingAdapter} from \"../interfaces/ILendingAdapter.sol\";\nimport {ILeverageManager} from \"../interfaces/ILeverageManager.sol\";\nimport {ILeverageToken} from \"../interfaces/ILeverageToken.sol\";\nimport {ILeverageRouter} from \"../interfaces/periphery/ILeverageRouter.sol\";\nimport {IVeloraAdapter} from \"../interfaces/periphery/IVeloraAdapter.sol\";\nimport {ActionData} from \"../types/DataTypes.sol\";\n\n/**\n * @dev The LeverageRouter contract is an immutable periphery contract that facilitates the use of flash loans and a swaps\n * to deposit and redeem equity from LeverageTokens.\n *\n * The high-level deposit flow is as follows:\n *   1. The sender calls `deposit` with the amount of collateral from the sender to deposit, the amount of debt to flash loan\n *      (which will be swapped to collateral), the minimum amount of shares to receive, and the calldata to execute for\n *      the swap of the flash loaned debt to collateral\n *   2. The LeverageRouter will flash loan the debt asset amount and execute the calldata to swap it to collateral\n *   3. The LeverageRouter will use the collateral from the swapped debt and the collateral from the sender for the deposit\n *      into the LeverageToken, receiving LeverageToken shares and debt in return\n *   4. The LeverageRouter will use the debt received from the deposit to repay the flash loan\n *   6. The LeverageRouter will transfer the LeverageToken shares and any surplus debt assets to the sender\n *\n * The high-level redeem flow is the same as the deposit flow, but in reverse.\n *\n * @custom:contact security@seamlessprotocol.com\n */\ncontract LeverageRouter is ILeverageRouter {\n    /// @inheritdoc ILeverageRouter\n    ILeverageManager public immutable leverageManager;\n\n    /// @inheritdoc ILeverageRouter\n    IMorpho public immutable morpho;\n\n    /// @notice Creates a new LeverageRouter\n    /// @param _leverageManager The LeverageManager contract\n    /// @param _morpho The Morpho core protocol contract\n    constructor(ILeverageManager _leverageManager, IMorpho _morpho) {\n        leverageManager = _leverageManager;\n        morpho = _morpho;\n    }\n\n    /// @inheritdoc ILeverageRouter\n    function convertEquityToCollateral(ILeverageToken token, uint256 equityInCollateralAsset)\n        public\n        view\n        returns (uint256 collateral)\n    {\n        uint256 collateralRatio = leverageManager.getLeverageTokenState(token).collateralRatio;\n        ILendingAdapter lendingAdapter = leverageManager.getLeverageTokenLendingAdapter(token);\n        uint256 baseRatio = leverageManager.BASE_RATIO();\n\n        if (lendingAdapter.getCollateral() == 0 && lendingAdapter.getDebt() == 0) {\n            uint256 initialCollateralRatio = leverageManager.getLeverageTokenInitialCollateralRatio(token);\n            collateral = Math.mulDiv(\n                equityInCollateralAsset, initialCollateralRatio, initialCollateralRatio - baseRatio, Math.Rounding.Ceil\n            );\n        } else if (collateralRatio == type(uint256).max) {\n            collateral = equityInCollateralAsset;\n        } else {\n            collateral =\n                Math.mulDiv(equityInCollateralAsset, collateralRatio, collateralRatio - baseRatio, Math.Rounding.Ceil);\n        }\n\n        return collateral;\n    }\n\n    /// @inheritdoc ILeverageRouter\n    function previewDeposit(ILeverageToken token, uint256 collateralFromSender)\n        external\n        view\n        returns (ActionData memory previewData)\n    {\n        uint256 collateral = convertEquityToCollateral(token, collateralFromSender);\n        return leverageManager.previewDeposit(token, collateral);\n    }\n\n    /// @inheritdoc ILeverageRouter\n    function deposit(\n        ILeverageToken leverageToken,\n        uint256 collateralFromSender,\n        uint256 flashLoanAmount,\n        uint256 minShares,\n        Call[] calldata swapCalls\n    ) external {\n        bytes memory depositData = abi.encode(\n            DepositParams({\n                sender: msg.sender,\n                leverageToken: leverageToken,\n                collateralFromSender: collateralFromSender,\n                minShares: minShares,\n                swapCalls: swapCalls\n            })\n        );\n\n        morpho.flashLoan(\n            address(leverageManager.getLeverageTokenDebtAsset(leverageToken)),\n            flashLoanAmount,\n            abi.encode(MorphoCallbackData({action: LeverageRouterAction.Deposit, data: depositData}))\n        );\n    }\n\n    /// @inheritdoc ILeverageRouter\n    function redeem(ILeverageToken token, uint256 shares, uint256 minCollateralForSender, Call[] calldata swapCalls)\n        external\n    {\n        uint256 debtRequired = leverageManager.previewRedeem(token, shares).debt;\n\n        bytes memory redeemData = abi.encode(\n            RedeemParams({\n                sender: msg.sender,\n                leverageToken: token,\n                shares: shares,\n                minCollateralForSender: minCollateralForSender,\n                swapCalls: swapCalls\n            })\n        );\n\n        morpho.flashLoan(\n            address(leverageManager.getLeverageTokenDebtAsset(token)),\n            debtRequired,\n            abi.encode(MorphoCallbackData({action: LeverageRouterAction.Redeem, data: redeemData}))\n        );\n    }\n\n    /// @inheritdoc ILeverageRouter\n    function redeemWithVelora(\n        ILeverageToken token,\n        uint256 shares,\n        uint256 minCollateralForSender,\n        IVeloraAdapter veloraAdapter,\n        address augustus,\n        IVeloraAdapter.Offsets calldata offsets,\n        bytes calldata swapData\n    ) external {\n        uint256 debtRequired = leverageManager.previewRedeem(token, shares).debt;\n\n        bytes memory redeemData = abi.encode(\n            RedeemWithVeloraParams({\n                sender: msg.sender,\n                leverageToken: token,\n                shares: shares,\n                minCollateralForSender: minCollateralForSender,\n                veloraAdapter: veloraAdapter,\n                augustus: augustus,\n                offsets: offsets,\n                swapData: swapData\n            })\n        );\n\n        morpho.flashLoan(\n            address(leverageManager.getLeverageTokenDebtAsset(token)),\n            debtRequired,\n            abi.encode(MorphoCallbackData({action: LeverageRouterAction.RedeemWithVelora, data: redeemData}))\n        );\n    }\n\n    /// @notice Morpho flash loan callback function\n    /// @param loanAmount Amount of asset flash loaned\n    /// @param data Encoded data passed to `morpho.flashLoan`\n    function onMorphoFlashLoan(uint256 loanAmount, bytes calldata data) external {\n        if (msg.sender != address(morpho)) revert Unauthorized();\n\n        MorphoCallbackData memory callbackData = abi.decode(data, (MorphoCallbackData));\n\n        if (callbackData.action == LeverageRouterAction.Deposit) {\n            DepositParams memory params = abi.decode(callbackData.data, (DepositParams));\n            _depositAndRepayMorphoFlashLoan(params, loanAmount);\n        } else if (callbackData.action == LeverageRouterAction.Redeem) {\n            RedeemParams memory params = abi.decode(callbackData.data, (RedeemParams));\n            _redeemAndRepayMorphoFlashLoan(params, loanAmount);\n        } else if (callbackData.action == LeverageRouterAction.RedeemWithVelora) {\n            RedeemWithVeloraParams memory params = abi.decode(callbackData.data, (RedeemWithVeloraParams));\n            _redeemWithVeloraAndRepayMorphoFlashLoan(params, loanAmount);\n        }\n    }\n\n    /// @notice Executes the deposit into a LeverageToken by flash loaning the debt asset, swapping it to collateral,\n    /// depositing into the LeverageToken with the sender's collateral, and using the resulting debt to repay the flash loan.\n    /// Any surplus debt assets after repaying the flash loan are given to the sender.\n    /// @param params Params for the deposit into a LeverageToken\n    /// @param debtLoan Amount of debt asset flash loaned\n    function _depositAndRepayMorphoFlashLoan(DepositParams memory params, uint256 debtLoan) internal {\n        IERC20 collateralAsset = leverageManager.getLeverageTokenCollateralAsset(params.leverageToken);\n        IERC20 debtAsset = leverageManager.getLeverageTokenDebtAsset(params.leverageToken);\n\n        // Transfer the collateral from the sender for the deposit\n        // slither-disable-next-line arbitrary-send-erc20\n        SafeERC20.safeTransferFrom(collateralAsset, params.sender, address(this), params.collateralFromSender);\n\n        // Swap the debt asset received from the flash loan to the collateral asset, used to deposit into the LeverageToken\n        for (uint256 i = 0; i < params.swapCalls.length; i++) {\n            // slither-disable-next-line unused-return\n            Address.functionCallWithValue(\n                params.swapCalls[i].target, params.swapCalls[i].data, params.swapCalls[i].value\n            );\n        }\n\n        // The sum of the collateral from the swap and the collateral from the sender\n        uint256 totalCollateral = IERC20(collateralAsset).balanceOf(address(this));\n\n        // Use the collateral from the swap and the collateral from the sender for the deposit into the LeverageToken\n        SafeERC20.forceApprove(collateralAsset, address(leverageManager), totalCollateral);\n\n        uint256 shares = leverageManager.deposit(params.leverageToken, totalCollateral, params.minShares).shares;\n\n        // Transfer any surplus debt assets to the sender\n        uint256 debtBalance = debtAsset.balanceOf(address(this));\n        if (debtLoan < debtBalance) {\n            SafeERC20.safeTransfer(debtAsset, params.sender, debtBalance - debtLoan);\n        }\n\n        // Transfer shares received from the deposit to the deposit sender\n        SafeERC20.safeTransfer(params.leverageToken, params.sender, shares);\n\n        // Approve morpho to transfer debt assets to repay the flash loan\n        // Note: if insufficient debt is available to repay the flash loan, the transaction will revert when Morpho\n        // attempts to transfer the debt assets to repay the flash loan\n        SafeERC20.forceApprove(debtAsset, address(morpho), debtLoan);\n    }\n\n    /// @notice Executes the redeem from a LeverageToken by flash loaning the debt asset, swapping the collateral asset\n    /// to the debt asset using arbitrary calldata, using the resulting debt to repay the flash loan, and transferring\n    /// the remaining collateral asset and debt assets to the sender\n    /// @param params Params for the redeem from a LeverageToken, using arbitrary calldata for the swap\n    /// @param debtLoanAmount Amount of debt asset flash loaned\n    function _redeemAndRepayMorphoFlashLoan(RedeemParams memory params, uint256 debtLoanAmount) internal {\n        IERC20 collateralAsset = leverageManager.getLeverageTokenCollateralAsset(params.leverageToken);\n        IERC20 debtAsset = leverageManager.getLeverageTokenDebtAsset(params.leverageToken);\n\n        // Transfer the shares from the sender\n        // slither-disable-next-line arbitrary-send-erc20\n        SafeERC20.safeTransferFrom(params.leverageToken, params.sender, address(this), params.shares);\n\n        // Use the debt from the flash loan to redeem the shares from the sender\n        SafeERC20.forceApprove(debtAsset, address(leverageManager), debtLoanAmount);\n        // slither-disable-next-line unused-return\n        leverageManager.redeem(params.leverageToken, params.shares, params.minCollateralForSender);\n\n        // Swap the collateral asset received from the redeem to the debt asset, used to repay the flash loan.\n        for (uint256 i = 0; i < params.swapCalls.length; i++) {\n            // slither-disable-next-line unused-return\n            Address.functionCallWithValue(\n                params.swapCalls[i].target, params.swapCalls[i].data, params.swapCalls[i].value\n            );\n        }\n\n        // The remaining collateral after the arbitrary swap calls is available for the sender\n        uint256 collateralForSender = collateralAsset.balanceOf(address(this));\n\n        // The remaining debt after the arbitrary swap calls is available for the sender, minus\n        // the amount of debt for repaying the flash loan\n        uint256 debtBalance = debtAsset.balanceOf(address(this));\n        uint256 debtForSender = debtBalance > debtLoanAmount ? debtBalance - debtLoanAmount : 0;\n\n        // Check slippage on collateral the sender receives\n        if (collateralForSender < params.minCollateralForSender) {\n            revert CollateralSlippageTooHigh(collateralForSender, params.minCollateralForSender);\n        }\n\n        // Transfer remaining collateral to the sender\n        if (collateralForSender > 0) {\n            SafeERC20.safeTransfer(collateralAsset, params.sender, collateralForSender);\n        }\n\n        // Transfer any remaining debt assets to the sender\n        if (debtForSender > 0) {\n            SafeERC20.safeTransfer(debtAsset, params.sender, debtForSender);\n        }\n\n        // Approve Morpho to spend the debt asset to repay the flash loan\n        SafeERC20.forceApprove(debtAsset, address(morpho), debtLoanAmount);\n    }\n\n    /// @notice Executes the redeem from a LeverageToken by flash loaning the debt asset, swapping the collateral asset\n    /// to the debt asset using Velora, using the resulting debt to repay the flash loan, and transferring the remaining\n    /// collateral asset to the sender\n    /// @param params Params for the redeem from a LeverageToken using Velora\n    /// @param debtLoanAmount Amount of debt asset flash loaned\n    function _redeemWithVeloraAndRepayMorphoFlashLoan(RedeemWithVeloraParams memory params, uint256 debtLoanAmount)\n        internal\n    {\n        IERC20 collateralAsset = leverageManager.getLeverageTokenCollateralAsset(params.leverageToken);\n        IERC20 debtAsset = leverageManager.getLeverageTokenDebtAsset(params.leverageToken);\n\n        // Transfer the shares from the sender\n        // slither-disable-next-line arbitrary-send-erc20\n        SafeERC20.safeTransferFrom(params.leverageToken, params.sender, address(this), params.shares);\n\n        // Use the debt from the flash loan to redeem the shares from the sender\n        SafeERC20.forceApprove(debtAsset, address(leverageManager), debtLoanAmount);\n        uint256 collateralWithdrawn =\n            leverageManager.redeem(params.leverageToken, params.shares, params.minCollateralForSender).collateral;\n\n        // Use the VeloraAdapter to swap the collateral asset received from the redeem to the debt asset, used to repay the flash loan.\n        // The excess collateral asset sent back to this LeverageRouter is for the sender of the redeem\n        // slither-disable-next-line arbitrary-send-erc20\n        SafeERC20.safeTransfer(collateralAsset, address(params.veloraAdapter), collateralWithdrawn);\n        uint256 collateralForSender = params.veloraAdapter.buy(\n            params.augustus,\n            params.swapData,\n            address(collateralAsset),\n            address(debtAsset),\n            debtLoanAmount,\n            params.offsets,\n            address(this)\n        );\n\n        // Check slippage\n        if (collateralForSender < params.minCollateralForSender) {\n            revert CollateralSlippageTooHigh(collateralForSender, params.minCollateralForSender);\n        }\n\n        // Transfer remaining collateral to the sender\n        if (collateralForSender > 0) {\n            SafeERC20.safeTransfer(collateralAsset, params.sender, collateralForSender);\n        }\n\n        // Approve Morpho to spend the debt asset to repay the flash loan\n        SafeERC20.forceApprove(debtAsset, address(morpho), debtLoanAmount);\n    }\n\n    receive() external payable {}\n}\n"
    }
}