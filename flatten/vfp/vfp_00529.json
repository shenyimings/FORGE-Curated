{
    "vfp_id": "vfp_00529",
    "project_name": "cantina_centrifuge_aug2025.pdf",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "_requestPoolFunding() is suboptimal for shared refund addresses",
            "description": "If a refund address is shared among multiple pools, _requestPoolFunding() retrieves all funds from the refund address and applies them to a single poolId, which is inefficient. The cause is the lack of granular fund retrieval logic. This could lead to over-subsidization of one pool while starving others, especially in scenarios where refund addresses are reused. The recommendation is to either document that refund addresses should not be shared or modify the function to only retrieve the required amount, improving fund distribution efficiency.\n",
            "severity": null,
            "location": [
                "Gateway::_requestPoolFunding",
                "Gateway::setRefundAddress"
            ],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "uint96(...) truncates",
            "description": "The use of uint96() silently truncates values without validation or error checking. The root cause is unsafe type casting. While the likelihood of overflow is low due to expected input ranges, a malicious or erroneous high-value input could be truncated, leading to incorrect calculations or loss of precision. This could affect financial calculations if large values are ever passed, potentially resulting in incorrect subsidies or accounting. The impact is likely low but non-zero.\n",
            "severity": null,
            "location": [
                "uint96"
            ],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "underpaid_[] entries stay forever",
            "description": "After a successful repay() call, the underpaid_[centrifugeId][batchHash] entry remains in storage and is never deleted. The root cause is the absence of a cleanup step post-repayment. This leads to permanent storage bloat, increasing gas costs for future operations that iterate or access this mapping. An attacker could potentially exploit this by triggering many small underpaid entries, leading to denial of service via excessive gas usage. While not a direct fund loss, it degrades system performance and increases operational costs.\n",
            "severity": null,
            "location": [
                "underpaid_",
                "repay"
            ],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        }
    ],
    "affected_files": {
        "Gateway.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {PoolId} from \"./types/PoolId.sol\";\nimport {IRoot} from \"./interfaces/IRoot.sol\";\nimport {IAdapter} from \"./interfaces/IAdapter.sol\";\nimport {IGateway} from \"./interfaces/IGateway.sol\";\nimport {IGasService} from \"./interfaces/IGasService.sol\";\nimport {IMessageSender} from \"./interfaces/IMessageSender.sol\";\nimport {IMessageHandler} from \"./interfaces/IMessageHandler.sol\";\nimport {IMessageProcessor} from \"./interfaces/IMessageProcessor.sol\";\n\nimport {Auth} from \"../misc/Auth.sol\";\nimport {BytesLib} from \"../misc/libraries/BytesLib.sol\";\nimport {TransientArrayLib} from \"../misc/libraries/TransientArrayLib.sol\";\nimport {TransientBytesLib} from \"../misc/libraries/TransientBytesLib.sol\";\nimport {TransientStorageLib} from \"../misc/libraries/TransientStorageLib.sol\";\nimport {Recoverable, IRecoverable, ETH_ADDRESS} from \"../misc/Recoverable.sol\";\n\n/// @title  Gateway\n/// @notice Routing contract that forwards outgoing messages to multiple adapters (1 full message, n-1 proofs)\n///         and validates that multiple adapters have confirmed a message.\n///\n///         Supports batching multiple messages, as well as paying for methods manually or through pool-level subsidies.\n///\n///         Supports processing multiple duplicate messages in parallel by storing counts of messages\n///         and proofs that have been received. Also implements a retry method for failed messages.\ncontract Gateway is Auth, Recoverable, IGateway {\n    using BytesLib for bytes;\n    using TransientStorageLib for bytes32;\n\n    PoolId public constant GLOBAL_POT = PoolId.wrap(0);\n    bytes32 public constant BATCH_LOCATORS_SLOT = bytes32(uint256(keccak256(\"Centrifuge/batch-locators\")) - 1);\n\n    // Dependencies\n    IRoot public immutable root;\n    IGasService public gasService;\n    IMessageProcessor public processor;\n    IAdapter public adapter;\n\n    // Outbound & payments\n    bool public transient isBatching;\n    uint256 public transient fuel;\n    address public transient transactionRefund;\n    uint128 public transient extraGasLimit;\n    mapping(PoolId => Funds) public subsidy;\n    mapping(uint16 centrifugeId => mapping(bytes32 batchHash => Underpaid)) public underpaid;\n\n    // Inbound\n    mapping(uint16 centrifugeId => mapping(bytes32 messageHash => uint256)) public failedMessages;\n\n    constructor(IRoot root_, IGasService gasService_, address deployer) Auth(deployer) {\n        root = root_;\n        gasService = gasService_;\n\n        subsidy[GLOBAL_POT].refund = IRecoverable(address(this));\n        emit SetRefundAddress(GLOBAL_POT, IRecoverable(address(this)));\n    }\n\n    modifier pauseable() {\n        require(!root.paused(), Paused());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGateway\n    function file(bytes32 what, address instance) external auth {\n        if (what == \"gasService\") gasService = IGasService(instance);\n        else if (what == \"processor\") processor = IMessageProcessor(instance);\n        else if (what == \"adapter\") adapter = IAdapter(instance);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, instance);\n    }\n\n    receive() external payable {\n        _subsidizePool(GLOBAL_POT, msg.sender, msg.value);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageHandler\n    function handle(uint16 centrifugeId, bytes memory batch) public pauseable auth {\n        IMessageProcessor processor_ = processor;\n        bytes memory remaining = batch;\n\n        while (remaining.length > 0) {\n            uint256 length = processor_.messageLength(remaining);\n            bytes memory message = remaining.slice(0, length);\n            remaining = remaining.slice(length, remaining.length - length);\n\n            try processor_.handle(centrifugeId, message) {\n                emit ExecuteMessage(centrifugeId, message);\n            } catch (bytes memory err) {\n                bytes32 messageHash = keccak256(message);\n                failedMessages[centrifugeId][messageHash]++;\n                emit FailMessage(centrifugeId, message, err);\n            }\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function retry(uint16 centrifugeId, bytes memory message) external pauseable {\n        bytes32 messageHash = keccak256(message);\n        require(failedMessages[centrifugeId][messageHash] > 0, NotFailedMessage());\n\n        failedMessages[centrifugeId][messageHash]--;\n        processor.handle(centrifugeId, message);\n\n        emit ExecuteMessage(centrifugeId, message);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageSender\n    function send(uint16 centrifugeId, bytes calldata message) external pauseable auth {\n        require(message.length > 0, EmptyMessage());\n\n        PoolId poolId = processor.messagePoolId(message);\n\n        emit PrepareMessage(centrifugeId, poolId, message);\n\n        uint128 gasLimit = gasService.messageGasLimit(centrifugeId, message) + extraGasLimit;\n        extraGasLimit = 0;\n\n        if (isBatching) {\n            bytes32 batchSlot = _outboundBatchSlot(centrifugeId, poolId);\n            bytes memory previousMessage = TransientBytesLib.get(batchSlot);\n\n            bytes32 gasLimitSlot = _gasLimitSlot(centrifugeId, poolId);\n            uint128 newGasLimit = gasLimitSlot.tloadUint128() + gasLimit;\n            require(newGasLimit <= gasService.maxBatchGasLimit(centrifugeId), ExceedsMaxGasLimit());\n            gasLimitSlot.tstore(uint256(newGasLimit));\n\n            if (previousMessage.length == 0) {\n                TransientArrayLib.push(BATCH_LOCATORS_SLOT, _encodeLocator(centrifugeId, poolId));\n            }\n\n            TransientBytesLib.append(batchSlot, message);\n        } else {\n            _send(centrifugeId, poolId, message, gasLimit);\n        }\n    }\n\n    function _send(uint16 centrifugeId, PoolId poolId, bytes memory batch, uint128 batchGasLimit)\n        internal\n        returns (bool succeeded)\n    {\n        uint256 cost = adapter.estimate(centrifugeId, batch, batchGasLimit);\n\n        // Ensure sufficient funds are available\n        if (transactionRefund != address(0)) {\n            require(cost <= fuel, NotEnoughTransactionGas());\n            fuel -= cost;\n        } else {\n            // Subsidized pool payment\n            if (cost > subsidy[poolId].value) {\n                _requestPoolFunding(poolId);\n            }\n\n            if (cost <= subsidy[poolId].value) {\n                subsidy[poolId].value -= uint96(cost);\n            } else {\n                _addUnpaidBatch(centrifugeId, batch, batchGasLimit);\n                return false;\n            }\n        }\n\n        adapter.send{value: cost}(\n            centrifugeId,\n            batch,\n            batchGasLimit,\n            transactionRefund != address(0) ? transactionRefund : address(subsidy[poolId].refund)\n        );\n\n        return true;\n    }\n\n    /// @inheritdoc IGateway\n    function addUnpaidMessage(uint16 centrifugeId, bytes memory message) external auth {\n        _addUnpaidBatch(centrifugeId, message, gasService.messageGasLimit(centrifugeId, message));\n    }\n\n    function _addUnpaidBatch(uint16 centrifugeId, bytes memory message, uint128 gasLimit) internal {\n        bytes32 batchHash = keccak256(message);\n\n        Underpaid storage underpaid_ = underpaid[centrifugeId][batchHash];\n        underpaid_.counter++;\n        underpaid_.gasLimit = gasLimit;\n\n        emit UnderpaidBatch(centrifugeId, message);\n    }\n\n    /// @inheritdoc IGateway\n    function repay(uint16 centrifugeId, bytes memory batch) external payable pauseable {\n        bytes32 batchHash = keccak256(batch);\n        Underpaid storage underpaid_ = underpaid[centrifugeId][batchHash];\n        require(underpaid_.counter > 0, NotUnderpaidBatch());\n\n        PoolId poolId = processor.messagePoolId(batch);\n        if (msg.value > 0) subsidizePool(poolId);\n\n        underpaid_.counter--;\n        require(_send(centrifugeId, poolId, batch, underpaid_.gasLimit), InsufficientFundsForRepayment());\n\n        emit RepayBatch(centrifugeId, batch);\n    }\n\n    function _requestPoolFunding(PoolId poolId) internal {\n        IRecoverable refund = subsidy[poolId].refund;\n        if (!poolId.isNull() && address(refund) != address(0)) {\n            uint256 refundBalance = address(refund).balance;\n            if (refundBalance == 0) return;\n\n            // Send to the gateway GLOBAL_POT\n            refund.recoverTokens(ETH_ADDRESS, address(this), refundBalance);\n\n            // Extract from the GLOBAL_POT\n            subsidy[GLOBAL_POT].value -= uint96(refundBalance);\n            _subsidizePool(poolId, address(refund), refundBalance);\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function setExtraGasLimit(uint128 gas) public auth {\n        extraGasLimit = gas;\n    }\n\n    /// @inheritdoc IGateway\n    function setRefundAddress(PoolId poolId, IRecoverable refund) public auth {\n        subsidy[poolId].refund = refund;\n        emit SetRefundAddress(poolId, refund);\n    }\n\n    /// @inheritdoc IGateway\n    function subsidizePool(PoolId poolId) public payable {\n        require(address(subsidy[poolId].refund) != address(0), RefundAddressNotSet());\n        _subsidizePool(poolId, msg.sender, msg.value);\n    }\n\n    function _subsidizePool(PoolId poolId, address who, uint256 value) internal {\n        subsidy[poolId].value += uint96(value);\n        emit SubsidizePool(poolId, who, value);\n    }\n\n    /// @inheritdoc IGateway\n    function startTransactionPayment(address payer) external payable auth {\n        transactionRefund = payer;\n        fuel += msg.value;\n    }\n\n    /// @inheritdoc IGateway\n    function endTransactionPayment() external auth {\n        if (transactionRefund == address(0)) return;\n\n        // Reset before external call\n        uint256 fuel_ = fuel;\n        address transactionRefund_ = transactionRefund;\n        fuel = 0;\n        transactionRefund = address(0);\n\n        if (fuel_ > 0) {\n            (bool success,) = payable(transactionRefund_).call{value: fuel_}(new bytes(0));\n\n            if (!success) {\n                // If refund fails, move remaining fuel to global pot\n                _subsidizePool(GLOBAL_POT, transactionRefund_, fuel_);\n            }\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function startBatching() external auth {\n        isBatching = true;\n    }\n\n    /// @inheritdoc IGateway\n    function endBatching() external auth {\n        require(isBatching, NoBatched());\n        bytes32[] memory locators = TransientArrayLib.getBytes32(BATCH_LOCATORS_SLOT);\n\n        isBatching = false;\n        TransientArrayLib.clear(BATCH_LOCATORS_SLOT);\n\n        for (uint256 i; i < locators.length; i++) {\n            (uint16 centrifugeId, PoolId poolId) = _parseLocator(locators[i]);\n            bytes32 outboundBatchSlot = _outboundBatchSlot(centrifugeId, poolId);\n            uint128 gasLimit = _gasLimitSlot(centrifugeId, poolId).tloadUint128();\n\n            _send(centrifugeId, poolId, TransientBytesLib.get(outboundBatchSlot), gasLimit);\n\n            TransientBytesLib.clear(outboundBatchSlot);\n            _gasLimitSlot(centrifugeId, poolId).tstore(uint256(0));\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------------------------------\n\n    function _encodeLocator(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return bytes32(abi.encodePacked(bytes2(centrifugeId), bytes8(poolId.raw())));\n    }\n\n    function _parseLocator(bytes32 locator) internal pure returns (uint16 centrifugeId, PoolId poolId) {\n        centrifugeId = uint16(bytes2(locator));\n        poolId = PoolId.wrap(uint64(bytes8(locator << 16)));\n    }\n\n    function _gasLimitSlot(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"batchGasLimit\", centrifugeId, poolId));\n    }\n\n    function _outboundBatchSlot(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"outboundBatch\", centrifugeId, poolId));\n    }\n}\n"
    }
}