{
    "vfp_id": "vfp_00040",
    "project_name": "cantina_uniswap_april2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "ModeDecoder implements a subset of EIP-7821",
            "description": "1. **Description:** The ModeDecoder and MinimalDelegation contract only support a limited subset of EIP-7821 execution modes (single-batch and multi-batch), without parsing optional opData or supporting recursive \"batch of batches\".\n2. **Cause:** The implementation is intentionally minimal and does not fully adopt the EIP-7821 specification.\n3. **Exploitation:** Users expecting full EIP-7821 functionality may encounter unexpected behavior or limitations.\n4. **Impact:** Reduced interoperability with tools or wallets expecting full EIP-7821 support, potentially leading to integration issues.\n",
            "severity": "Informational",
            "location": [
                "ERC7821.sol::ModeDecoder#9-16"
            ],
            "files": [
                "minimal-delegation/src/ERC7821.sol",
                "minimal-delegation/src/libraries/ModeDecoder.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC7821.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.29;\n\nimport {IERC7821} from \"./interfaces/IERC7821.sol\";\nimport {ModeDecoder} from \"./libraries/ModeDecoder.sol\";\n\n/// @title ERC7821\n/// @notice A base contract that implements the ERC7821 interface\nabstract contract ERC7821 is IERC7821 {\n    using ModeDecoder for bytes32;\n\n    /// @inheritdoc IERC7821\n    function supportsExecutionMode(bytes32 mode) external pure override returns (bool result) {\n        return mode.isBatchedCall();\n    }\n}\n",
        "ModeDecoder.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nusing ModeDecoder for bytes32;\n\nlibrary ModeDecoder {\n    // Mode layout adhering to ERC-7579\n    // 1 byte           | 1 byte    | 4 bytes       | 4 bytes       | 22 bytes\n    // CALL_TYPE        | EXEC_TYPE | UNUSED        | MODE_SELECTOR | MODE_PAYLOAD\n    bytes32 constant BATCHED_CALL = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    bytes32 constant BATCHED_CAN_REVERT_CALL = 0x0101000000000000000000000000000000000000000000000000000000000000;\n\n    // Mode Masks\n    bytes32 constant EXTRACT_EXEC_TYPE = 0x00ff000000000000000000000000000000000000000000000000000000000000;\n\n    // Supported modes:\n    // 0x01           | 0x00      | unused        | 0x00000000   | unused\n    // 0x01           | 0x01      | unused        | 0x00000000   | unused\n    // - A batched call that reverts on failure, specifying mode selector 0x00000000 means no other data is present\n    // - A batched call that does not revert on failure, specifying mode selector 0x00000000 means no other data is present\n    function isBatchedCall(bytes32 mode) internal pure returns (bool) {\n        return mode == BATCHED_CALL || mode == BATCHED_CAN_REVERT_CALL;\n    }\n\n    // Revert if the EXEC_TYPE is 0.\n    // The EXEC_TYPE is guaranteed to be ONLY 1 or 0 since the mode is checked with strict equality in isBatchedCall().\n    function shouldRevert(bytes32 mode) internal pure returns (bool) {\n        return mode & EXTRACT_EXEC_TYPE == 0;\n    }\n}\n"
    }
}