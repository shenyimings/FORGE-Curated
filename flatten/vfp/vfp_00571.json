{
    "vfp_id": "vfp_00571",
    "project_name": "Lido V3 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-1188"
                ],
                "5": [
                    "CWE-453"
                ]
            },
            "title": "Incorrect Default Node Operator Fee Recipient May Lock Certain Functions When Creating a Vault Without Connecting It to VaultHub",
            "description": "The `createVaultWithDashboardWithoutConnectingToVaultHub` function in the `VaultFactory` contract sets the factory itself as the `nodeOperatorFeeRecipient` during initialization, which can cause key operations like `setOperatorFeeRate` or `voluntaryDisconnect` to revert if fees are pending and not manually updated. This occurs because the factory address, which is not intended to be a long-term fee recipient, cannot disburse fees, leading to functional lockups. The root cause is the use of `address(this)` instead of the provided `_nodeOperatorManager` parameter when initializing the Dashboard. An attacker could exploit this by creating a vault without connecting to VaultHub and triggering operations that require fee disbursement, resulting in failed transactions and operational disruption. The impact is limited to denial of service for certain management functions, not loss of funds.\n",
            "severity": "Low",
            "location": [
                "contracts/0.8.25/vaults/VaultFactory.sol:L118"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultFactory.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Zero-Address Validation for _nodeOperatorManager in Vault Creation Without Hub Connection",
            "description": "The `createVaultWithDashboardWithoutConnectingToVaultHub` function does not validate that `_nodeOperatorManager` is non-zero, allowing it to be set to `address(0)`. This could lock management functions that require a valid manager. The root cause is missing input validation compared to the connected variant of the function. An attacker could exploit this by creating a vault with a zero address manager, rendering the dashboard's management functions unusable. The impact is denial of service for critical administrative operations.\n",
            "severity": null,
            "location": [
                "contracts/0.8.25/vaults/VaultFactory.sol:L87-L127"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/VaultFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultFactory.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {Clones} from \"@openzeppelin/contracts-v5.2/proxy/Clones.sol\";\nimport {PinnedBeaconProxy} from \"./PinnedBeaconProxy.sol\";\n\nimport {ILidoLocator} from \"contracts/common/interfaces/ILidoLocator.sol\";\n\nimport {VaultHub} from \"./VaultHub.sol\";\nimport {Permissions} from \"./dashboard/Permissions.sol\";\nimport {Dashboard} from \"./dashboard/Dashboard.sol\";\nimport {IStakingVault} from \"./interfaces/IStakingVault.sol\";\n\n/**\n * @title VaultFactory\n * @author Lido\n * @notice The factory contract for StakingVaults\n */\ncontract VaultFactory {\n    address public immutable LIDO_LOCATOR;\n    address public immutable BEACON;\n    address public immutable DASHBOARD_IMPL;\n\n    /**\n     * @param _lidoLocator The address of the LidoLocator contract\n     * @param _beacon The address of the Beacon contract for StakingVaults\n     * @param _dashboardImpl The address of the Dashboard implementation contract\n     */\n    constructor(address _lidoLocator, address _beacon, address _dashboardImpl) {\n        if (_lidoLocator == address(0)) revert ZeroArgument(\"_lidoLocator\");\n        if (_beacon == address(0)) revert ZeroArgument(\"_beacon\");\n        if (_dashboardImpl == address(0)) revert ZeroArgument(\"_dashboardImpl\");\n\n        LIDO_LOCATOR = _lidoLocator;\n        BEACON = _beacon;\n        DASHBOARD_IMPL = _dashboardImpl;\n    }\n\n    /**\n     * @notice Creates a new StakingVault and Dashboard contracts\n     * @param _defaultAdmin The address of the default admin of the Dashboard\n     * @param _nodeOperator The address of the node operator of the StakingVault\n     * @param _nodeOperatorManager The address of the node operator manager in the Dashboard\n     * @param _nodeOperatorFeeBP The node operator fee in basis points\n     * @param _confirmExpiry The confirmation expiry in seconds\n     * @param _roleAssignments The optional role assignments to be made\n     */\n    function createVaultWithDashboard(\n        address _defaultAdmin,\n        address _nodeOperator,\n        address _nodeOperatorManager,\n        uint256 _nodeOperatorFeeBP,\n        uint256 _confirmExpiry,\n        Permissions.RoleAssignment[] calldata _roleAssignments\n    ) external payable returns (IStakingVault vault, Dashboard dashboard) {\n        // check if the msg.value is enough to cover the connect deposit\n        ILidoLocator locator = ILidoLocator(LIDO_LOCATOR);\n        if (msg.value < VaultHub(payable(locator.vaultHub())).CONNECT_DEPOSIT()) revert InsufficientFunds();\n\n        // create the vault proxy\n        vault = IStakingVault(address(new PinnedBeaconProxy(BEACON, \"\")));\n\n        // create the dashboard proxy\n        bytes memory immutableArgs = abi.encode(address(vault));\n        dashboard = Dashboard(payable(Clones.cloneWithImmutableArgs(DASHBOARD_IMPL, immutableArgs)));\n\n        // initialize StakingVault with the dashboard address as the owner\n        vault.initialize(address(dashboard), _nodeOperator, locator.predepositGuarantee());\n\n        // initialize Dashboard with the factory address as the default admin, grant optional roles and connect to VaultHub\n        dashboard.initialize(address(this), _nodeOperatorManager, _nodeOperatorFeeBP, _confirmExpiry);\n\n        if (_roleAssignments.length > 0) dashboard.grantRoles(_roleAssignments);\n\n        dashboard.connectToVaultHub{value: msg.value}();\n\n        dashboard.grantRole(dashboard.DEFAULT_ADMIN_ROLE(), _defaultAdmin);\n        dashboard.revokeRole(dashboard.DEFAULT_ADMIN_ROLE(), address(this));\n\n        emit VaultCreated(address(vault));\n        emit DashboardCreated(address(dashboard), address(vault), _defaultAdmin);\n    }\n\n    /**\n     * @notice Creates a new StakingVault and Dashboard contracts without connecting to VaultHub\n     * @param _defaultAdmin The address of the default admin of the Dashboard\n     * @param _nodeOperator The address of the node operator of the StakingVault\n     * @param _nodeOperatorManager The address of the node operator manager in the Dashboard\n     * @param _nodeOperatorFeeBP The node operator fee in basis points\n     * @param _confirmExpiry The confirmation expiry in seconds\n     * @param _roleAssignments The optional role assignments to be made\n     * @notice Only Node Operator managed roles can be assigned\n     */\n    function createVaultWithDashboardWithoutConnectingToVaultHub(\n        address _defaultAdmin,\n        address _nodeOperator,\n        address _nodeOperatorManager,\n        uint256 _nodeOperatorFeeBP,\n        uint256 _confirmExpiry,\n        Permissions.RoleAssignment[] calldata _roleAssignments\n    ) external payable returns (IStakingVault vault, Dashboard dashboard) {\n        ILidoLocator locator = ILidoLocator(LIDO_LOCATOR);\n\n        // create the vault proxy\n        vault = IStakingVault(address(new PinnedBeaconProxy(BEACON, \"\")));\n\n        // create the dashboard proxy\n        bytes memory immutableArgs = abi.encode(address(vault));\n        dashboard = Dashboard(payable(Clones.cloneWithImmutableArgs(DASHBOARD_IMPL, immutableArgs)));\n\n        // initialize StakingVault with the dashboard address as the owner\n        vault.initialize(address(dashboard), _nodeOperator, locator.predepositGuarantee());\n\n        // initialize Dashboard with the _defaultAdmin as the default admin, grant optional node operator managed roles\n        dashboard.initialize(_defaultAdmin, address(this), _nodeOperatorFeeBP, _confirmExpiry);\n\n        if (_roleAssignments.length > 0) dashboard.grantRoles(_roleAssignments);\n\n        dashboard.grantRole(dashboard.NODE_OPERATOR_MANAGER_ROLE(), _nodeOperatorManager);\n        dashboard.revokeRole(dashboard.NODE_OPERATOR_MANAGER_ROLE(), address(this));\n\n        emit VaultCreated(address(vault));\n        emit DashboardCreated(address(dashboard), address(vault), _defaultAdmin);\n    }\n\n    /**\n     * @notice Event emitted on a Vault creation\n     * @param vault The address of the created Vault\n     */\n    event VaultCreated(address indexed vault);\n\n    /**\n     * @notice Event emitted on a Dashboard creation\n     * @param dashboard The address of the created Dashboard\n     * @param vault The address of the created Vault\n     * @param admin The address of the Dashboard admin\n     */\n    event DashboardCreated(address indexed dashboard, address indexed vault, address indexed admin);\n\n    /**\n     * @notice Error thrown for when a given value cannot be zero\n     * @param argument Name of the argument\n     */\n    error ZeroArgument(string argument);\n\n    /**\n     * @notice Error thrown for when insufficient funds are provided\n     */\n    error InsufficientFunds();\n}\n"
    }
}