{
    "vfp_id": "vfp_00262",
    "project_name": "Jovay Rollup Contracts Audit.md",
    "findings": [
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "‘TRANSFER_ROLE’ Role Declared but Never Used",
            "description": "The `TRANSFER_ROLE` constant is defined in `ERC20Token.sol` but is never assigned or checked in any function within the contract. This creates unnecessary code bloat and confusion about the intended access control model. The root cause is incomplete or outdated role management logic. An attacker cannot exploit this directly, but it may indicate a design inconsistency or a missing feature. Future developers might assume the role is functional and attempt to use it, leading to unexpected behavior. The impact is low, primarily affecting code clarity and maintainability.\n",
            "severity": "Low",
            "location": [
                "ERC20Token.sol#20"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/common/ERC20Token.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Redundant `ADMIN_ROLE` Definition Instead of Using `DEFAULT_ADMIN_ROLE`",
            "description": "The `ERC20Token` contract defines a custom `ADMIN_ROLE` and assigns it as the admin of all other roles, instead of using OpenZeppelin's built-in `DEFAULT_ADMIN_ROLE`. This creates redundancy and potential confusion in access control management.\n\nThe root cause is unnecessary customization of a standard pattern. OpenZeppelin's `AccessControl` defaults to `DEFAULT_ADMIN_ROLE` as the admin of new roles, so failing to assign it can result in roles being unmanageable.\n\nWhile not directly exploitable, this design increases the risk of privilege escalation or loss of control if new roles are added and `DEFAULT_ADMIN_ROLE` remains unassigned. It also consumes more gas due to extra role definitions.\n\nThe impact is increased maintenance complexity, higher risk of administrative errors, and suboptimal gas usage. It does not pose an immediate security threat but reduces code clarity and safety.\n",
            "severity": "Low",
            "location": [
                "ERC20Token.sol::ADMIN_ROLE#34-38"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/common/ERC20Token.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC20Token.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20CappedUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport \"./interfaces/IERC20Token.sol\";\n\n/**\n* @title Asset Token Contract\n* @notice Asset token contract, used to manage assets\n* @dev inherit ERC20BurnableUpgradeable, ERC20CappedUpgradeable, AccessControlEnumerableUpgradeable\n */\ncontract ERC20Token is AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20CappedUpgradeable, IERC20Token {\n    //roles\n    bytes32 public constant ADMIN_ROLE = keccak256(abi.encodePacked(\"ADMIN_ROLE\"));\n    bytes32 public constant MINTER_ROLE = keccak256(abi.encodePacked(\"MINTER_ROLE\"));\n    bytes32 public constant BURNER_ROLE = keccak256(abi.encodePacked(\"BURNER_ROLE\"));\n    bytes32 public constant TRANSFER_ROLE = keccak256(abi.encodePacked(\"TRANSFER_ROLE\"));\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(string calldata name_, string calldata symbol_, uint256 cap_, address admin_) external initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n        __AccessControlEnumerable_init_unchained();\n        __ERC20Burnable_init_unchained();\n        __ERC20Capped_init_unchained(cap_);\n\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(TRANSFER_ROLE, ADMIN_ROLE);\n        _grantRole(ADMIN_ROLE, admin_);\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) returns (bool) {\n        return super.hasRole(role, account) || super.hasRole(getRoleAdmin(role), account);\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     */\n    function _mint(address account, uint256 amount) internal override (ERC20Upgradeable, ERC20CappedUpgradeable) {\n        super._mint(account, amount);\n    }\n\n    /**\n     * @dev require MINTER_ROLE=keccak256(abi.encodePacked(\"MINTER_ROLE\"))\n     */\n    function mint(address account, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev require BURNER_ROLE=keccak256(abi.encodePacked(\"BURNER_ROLE\"))\n     */\n    function burn(uint256 amount) public override onlyRole(BURNER_ROLE) {\n        super.burn(amount);\n    }\n\n    /**\n     * @dev require BURNER_ROLE=keccak256(abi.encodePacked(\"BURNER_ROLE\"))\n     */\n    function burn(address account, uint256 amount) public override onlyRole(BURNER_ROLE) {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev require BURNER_ROLE=keccak256(abi.encodePacked(\"BURNER_ROLE\"))\n     */\n    function burnFrom(address account, uint256 amount) public override onlyRole(BURNER_ROLE) {\n        super.burnFrom(account, amount);\n    }\n}"
    }
}