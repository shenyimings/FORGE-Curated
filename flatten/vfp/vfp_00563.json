{
    "vfp_id": "vfp_00563",
    "project_name": "blocksec_astherus_202502-signed.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect comment in function _smartMint()",
            "description": "The _smartMint() function in the Minter contract contains a comment stating “swap to asCAKE by pancakeSwap”, which is inaccurate as the function does not perform a swap but mints tokens. The root cause is outdated or incorrect documentation. This does not introduce a security vulnerability but can mislead developers and auditors. The impact is confusion during maintenance or auditing, potentially leading to logic errors.\n",
            "severity": "Informational",
            "location": [
                "Minter.sol::_smartMint"
            ],
            "files": [
                "5eb634c4ca7e1597e943c8c46e91683d76ac3ba9/ass-cake-earn-contract/src/Minter.sol"
            ]
        }
    ],
    "affected_files": {
        "Minter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"./interfaces/IMinter.sol\";\nimport \"./interfaces/IAssToken.sol\";\nimport \"./interfaces/pancakeswap/IPancakeStableSwapPool.sol\";\nimport \"./interfaces/pancakeswap/IPancakeStableSwapRouter.sol\";\nimport \"./interfaces/IUniversalProxy.sol\";\n\ncontract Minter is\n  IMinter,\n  Initializable,\n  AccessControlUpgradeable,\n  PausableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  UUPSUpgradeable\n{\n  using SafeERC20 for IERC20;\n  // compounder role\n  bytes32 public constant COMPOUNDER = keccak256(\"COMPOUNDER\");\n  // pause role\n  bytes32 public constant PAUSER = keccak256(\"PAUSER\");\n  // manager role\n  bytes32 public constant MANAGER = keccak256(\"MANAGER\");\n  // denominator\n  uint256 public constant DENOMINATOR = 10000;\n  // rewards compounded are vesting every day\n  uint256 private constant VESTING_PERIOD = 1 days;\n\n  /* ============ State Variables ============ */\n  // token address\n  IERC20 public token;\n  // assToken address\n  IAssToken public assToken;\n  // total tokens\n  uint256 private _totalTokens;\n  // total veToken rewards\n  uint256 public totalVeTokenRewards;\n  // total vote rewards\n  uint256 public totalVoteRewards;\n  // total donate rewards\n  uint256 public totalDonateRewards;\n  // total rewards per type\n  mapping(IMinter.RewardsType => uint256) public totalRewards;\n  // veToken rewards fee rate in percentage (10_000 = 100%)\n  uint256 public veTokenRewardsFeeRate;\n  // vote rewards fee rate in percentage (10_000 = 100%)\n  uint256 public voteRewardsFeeRate;\n  // donate rewards fee rate in percentage (10_000 = 100%)\n  uint256 public donateRewardsFeeRate;\n  // total totalFee\n  uint256 public totalFee;\n  // pancake swap router\n  address public pancakeSwapRouter;\n  // pancake swap pool\n  address public pancakeSwapPool;\n  // max swap ratio\n  uint256 public maxSwapRatio;\n  //universal Proxy\n  address public universalProxy;\n  // The amount of the last asset distribution from the controller contract into this\n  // contract + any unvested remainder at that time\n  uint256 public vestingAmount;\n  // The timestamp of the last asset distribution from the controller contract into this contract\n  uint256 public lastDistributionTimestamp;\n\n  /* ============ Events ============ */\n  event SmartMinted(address indexed user, uint256 cakeInput, uint256 obtainedAssCake);\n  event RewardsCompounded(address indexed sender, uint256 compoundAmount, uint256 fee);\n  event FeeRateUpdated(address indexed sender, RewardsType rewardsType, uint256 oldFeeRate, uint256 newFeeRate);\n  event FeeWithdrawn(address indexed sender, address receipt, uint256 amount);\n  event PancakeSwapRouterChanged(address indexed sender, address indexed pancakeSwapRouter);\n  event PancakeSwapPoolChanged(address indexed sender, address indexed pancakeSwapPool);\n  event MaxSwapRatioChanged(address indexed sender, uint256 maxSwapRatio);\n  event AddToken(address indexed assToken, address indexed token);\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev initialize the contract\n   * @param _admin - Address of the admin\n   * @param _manager - Address of the manager\n   * @param _pauser - Address of the pauser\n   * @param _token - Address of the token\n   * @param _assToken - Address of the assToken\n   * @param _universalProxy - Address of the universalProxy\n   * @param _pancakeSwapRouter - Address of swap router\n   * @param _pancakeSwapPool - Address of swap pool\n   * @param _maxSwapRatio - Max swap ratio\n   */\n  function initialize(\n    address _admin,\n    address _manager,\n    address _pauser,\n    address _token,\n    address _assToken,\n    address _universalProxy,\n    address _pancakeSwapRouter,\n    address _pancakeSwapPool,\n    uint256 _maxSwapRatio\n  ) external override initializer {\n    require(_admin != address(0), \"Invalid admin address\");\n    require(_manager != address(0), \"Invalid manager address\");\n    require(_pauser != address(0), \"Invalid pauser address\");\n    require(_token != address(0), \"Invalid token address\");\n    require(_assToken != address(0), \"Invalid AssToken address\");\n    require(_universalProxy != address(0), \"Invalid universalProxy address\");\n    require(_pancakeSwapRouter != address(0), \"Invalid pancake swap router address\");\n    require(_pancakeSwapPool != address(0), \"Invalid pancake swap pool address\");\n    require(_maxSwapRatio <= DENOMINATOR, \"Invalid max swap ratio\");\n\n    __AccessControl_init();\n    __Pausable_init();\n    __ReentrancyGuard_init();\n    __UUPSUpgradeable_init();\n    _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    _grantRole(MANAGER, _manager);\n    _grantRole(PAUSER, _pauser);\n\n    // CAKE\n    token = IERC20(_token);\n    // asCAKE\n    assToken = IAssToken(_assToken);\n    universalProxy = _universalProxy;\n    pancakeSwapRouter = _pancakeSwapRouter;\n    pancakeSwapPool = _pancakeSwapPool;\n    maxSwapRatio = _maxSwapRatio;\n\n    emit AddToken(_assToken, _token);\n  }\n\n  /* ============ External Getters ============ */\n\n  /**\n   * @dev estimateTotalOut  get asCAKE amount\n   * @param _amountIn - amount of CAKE\n   * @param _mintRatio - mint ratio\n   */\n  function estimateTotalOut(uint256 _amountIn, uint256 _mintRatio) public view returns (uint256 minimumEstimatedTotal) {\n    // valid mintRatio\n    require(_mintRatio <= DENOMINATOR, \"Incorrect Ratio\");\n\n    // convert CAKE amount by this contract\n    uint256 mintAmount = ((_amountIn * _mintRatio) / DENOMINATOR);\n    // swap CAKE amount by pancakeSwap\n    uint256 buybackAmount = _amountIn - mintAmount;\n\n    // asCAKE amount\n    uint256 amountOut = 0;\n\n    if (buybackAmount > 0) {\n      // swap to asCAKE by pancakeSwap\n      amountOut += swapToAssTokens(buybackAmount);\n    }\n\n    if (mintAmount > 0) {\n      // convert to asCAKE by this contract\n      amountOut += convertToAssTokens(mintAmount);\n    }\n\n    // asCAKE amount\n    return amountOut;\n  }\n\n  /**\n   * @dev swapToAssTokens  get assToken amount\n   * @param tokens - amount of token\n   */\n  function swapToAssTokens(uint256 tokens) public view returns (uint256) {\n    // swap by pancakeSwap\n    return IPancakeStableSwapPool(pancakeSwapPool).get_dy(0, 1, tokens);\n  }\n\n  /**\n   * @dev convertToTokens  get token amount\n   * @param assTokens - amount of assTokens\n   */\n  function convertToTokens(uint256 assTokens) public view returns (uint256) {\n    uint256 totalSupply = assToken.totalSupply();\n    //why +1？\n    //When using the contract for the first time, totalTokens and totalSupply are both 0.\n    //After calling smartMint and mint assToken, totalTokens and totalSupply are not 0.\n    return (assTokens * (totalTokens() + 1)) / (totalSupply + 1);\n  }\n\n  /**\n   * @dev convertToAssTokens  get assToken amount\n   * @param tokens - amount of token\n   */\n  function convertToAssTokens(uint256 tokens) public view returns (uint256) {\n    uint256 totalSupply = assToken.totalSupply();\n    //why +1？\n    //When using the contract for the first time, totalTokens and totalSupply are both 0.\n    //After calling smartMint and mint assToken, totalTokens and totalSupply are not 0.\n    return (tokens * (totalSupply + 1)) / (totalTokens() + 1);\n  }\n\n  // /* ============ External Functions ============ */\n\n  /**\n   * @dev smart mint assToken\n   * @param _amountIn - amount of token\n   * @param _mintRatio - mint ratio\n   * @param _minOut - minimum output\n   */\n  function smartMint(\n    uint256 _amountIn,\n    uint256 _mintRatio,\n    uint256 _minOut\n  ) external override whenNotPaused nonReentrant returns (uint256) {\n    // smart mint assToken\n    return _smartMint(_amountIn, _mintRatio, _minOut);\n  }\n\n  /**\n   * @dev totalTokens\n   * @notice returns the total amount of tokens in the contract\n   */\n  function totalTokens() public view returns (uint256) {\n    return _totalTokens - getUnvestedAmount();\n  }\n\n  /**\n   * @dev compoundRewards\n   * @param _rewards - rewards type and amount in\n   */\n  function compoundRewards(\n    IMinter.RewardsType[] memory _rewardsTypes,\n    uint256[] memory _rewards\n  ) external override onlyRole(COMPOUNDER) whenNotPaused nonReentrant {\n    require(_rewardsTypes.length > 0 && _rewardsTypes.length == _rewards.length, \"Invalid rewards length\");\n\n    // separate compoundAmount and fee\n    uint256 compoundAmount = 0;\n    uint256 fee = 0;\n    // compound the rewards\n    for (uint i; i < _rewardsTypes.length; ++i) {\n      IMinter.RewardsType rewardsType = _rewardsTypes[i];\n      uint256 amountInPerType = _rewards[i];\n      // process only if amount is not 0\n      if (amountInPerType != 0) {\n        uint256 feePerType = 0;\n        // collect fee per type\n        if (rewardsType == RewardsType.VeTokenRewards) {\n          feePerType = (amountInPerType * veTokenRewardsFeeRate) / DENOMINATOR;\n        } else if (rewardsType == RewardsType.VoteRewards) {\n          feePerType = (amountInPerType * voteRewardsFeeRate) / DENOMINATOR;\n        } else if (rewardsType == RewardsType.Donate) {\n          feePerType = (amountInPerType * donateRewardsFeeRate) / DENOMINATOR;\n        } else {\n          revert(\"Invalid rewardsType\");\n        }\n        // add up fee\n        fee += feePerType;\n        // add up amt. of compound after fee is deducted\n        compoundAmount += amountInPerType - feePerType;\n        // accumulate rewards per type\n        totalRewards[rewardsType] += amountInPerType - feePerType;\n      }\n    }\n    // transfer token from compounder\n    require(compoundAmount + fee > 0, \"Invalid compound amount\");\n    IERC20(token).safeTransferFrom(msg.sender, address(this), compoundAmount + fee);\n\n    // reset vesting amount\n    _updateVestingAmount(compoundAmount);\n\n    // update total fee and actual total tokens\n    totalFee += fee;\n    _totalTokens += compoundAmount;\n\n    // compound rewards\n    IERC20(token).safeIncreaseAllowance(universalProxy, compoundAmount);\n    IUniversalProxy(universalProxy).lock(compoundAmount);\n\n    emit RewardsCompounded(msg.sender, compoundAmount, fee);\n  }\n\n  /**\n   * @dev reset lastDistributionTimestamp and reward vesting amount\n   * @param newVestingAmount - new vesting amount\n   */\n  function _updateVestingAmount(uint256 newVestingAmount) internal {\n    if (getUnvestedAmount() > 0) revert(\"reward still vesting\");\n\n    vestingAmount = newVestingAmount;\n    lastDistributionTimestamp = block.timestamp;\n  }\n\n  /**\n   * @notice Returns the amount of tokens that are unvested in the contract.\n   */\n  function getUnvestedAmount() public view returns (uint256) {\n    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;\n    // vesting period is over\n    if (timeSinceLastDistribution >= VESTING_PERIOD) {\n      return 0;\n    }\n\n    uint256 deltaT;\n    unchecked {\n      deltaT = (VESTING_PERIOD - timeSinceLastDistribution);\n    }\n    return (deltaT * vestingAmount) / VESTING_PERIOD;\n  }\n\n  /**\n   * @dev mint assToken\n   * @param _amountIn - amount of token\n   */\n  function _mint(uint256 _amountIn) private returns (uint256) {\n    // increase allowance for universalProxy\n    IERC20(token).safeIncreaseAllowance(universalProxy, _amountIn);\n    // increase lock amount of the veToken\n    IUniversalProxy(universalProxy).lock(_amountIn);\n\n    // calculate how much asCAKE can get\n    uint256 assTokens = convertToAssTokens(_amountIn);\n\n    // mint asCAKE\n    assToken.mint(address(this), assTokens);\n\n    return assTokens;\n  }\n\n  /**\n   * @dev buyback assToken\n   * @param _amountIn - amount of token\n   * @param _minOut - minimum output\n   */\n  function _buyback(uint256 _amountIn, uint256 _minOut) private returns (uint256) {\n    address[] memory tokenPath = new address[](2);\n    // token address\n    tokenPath[0] = address(token);\n    // assToken address\n    tokenPath[1] = address(assToken);\n    uint256[] memory flag = new uint256[](1);\n    flag[0] = 2;\n    // increase allowance for pancakeSwapRouter\n    token.safeIncreaseAllowance(pancakeSwapRouter, _amountIn);\n    // balance before swap\n    uint256 oldBalance = assToken.balanceOf(address(this));\n    uint256 amountOut = IPancakeStableSwapRouter(pancakeSwapRouter).exactInputStableSwap(\n      tokenPath,\n      flag,\n      _amountIn,\n      _minOut,\n      address(this)\n    );\n    //balance after swap\n    uint256 newBalance = assToken.balanceOf(address(this));\n    // amountOut must equals to the net diff.\n    require(amountOut == newBalance - oldBalance, \"Invalid amountOut\");\n\n    //after swap, the difference amount\n    return (newBalance - oldBalance);\n  }\n\n  /**\n   * @dev unpause the contract\n   */\n  function unpause() external onlyRole(MANAGER) {\n    _unpause();\n  }\n\n  /**\n   * @dev pause the contract\n   */\n  function pause() external onlyRole(PAUSER) {\n    _pause();\n  }\n\n  /* ============ Admin Functions ============ */\n\n  /**\n   * @dev updateFeeRate\n   * @param _rewardsType - rewards type\n   * @param _feeRate - fee rate\n   */\n  function updateFeeRate(RewardsType _rewardsType, uint256 _feeRate) external nonReentrant onlyRole(MANAGER) {\n    // valid feeRate\n    require(_feeRate < DENOMINATOR, \"Incorrect Fee Ratio\");\n\n    uint256 oldFeeRate = 0;\n    if (_rewardsType == RewardsType.VeTokenRewards) {\n      require(veTokenRewardsFeeRate != _feeRate, \"newFeeRate can not be equal oldFeeRate\");\n\n      oldFeeRate = veTokenRewardsFeeRate;\n      // set veTokenRewardsFeeRate\n      veTokenRewardsFeeRate = _feeRate;\n    } else if (_rewardsType == RewardsType.VoteRewards) {\n      require(voteRewardsFeeRate != _feeRate, \"newFeeRate can not be equal oldFeeRate\");\n\n      oldFeeRate = voteRewardsFeeRate;\n      // set voteRewardsFeeRate\n      voteRewardsFeeRate = _feeRate;\n    } else if (_rewardsType == RewardsType.Donate) {\n      require(donateRewardsFeeRate != _feeRate, \"newFeeRate can not be equal oldFeeRate\");\n\n      oldFeeRate = donateRewardsFeeRate;\n      // set donateRewardsFeeRate\n      donateRewardsFeeRate = _feeRate;\n    } else {\n      revert(\"Invalid rewardsType\");\n    }\n    // emit event\n    emit FeeRateUpdated(msg.sender, _rewardsType, oldFeeRate, _feeRate);\n  }\n\n  /**\n   * @dev withdrawFee withdraw the reward commission amount collected by the platform to an address\n   * @param receipt - Address of the receipt\n   * @param amount - amount of token\n   */\n  function withdrawFee(address receipt, uint256 amount) external nonReentrant onlyRole(MANAGER) {\n    // valid receipt\n    require(receipt != address(0), \"Invalid address\");\n    // valid amount\n    require(amount > 0, \"Invalid amount\");\n    // The totalFee must be sufficient\n    require(amount <= totalFee, \"Invalid amount\");\n\n    // reduce totalFee\n    totalFee -= amount;\n    // transfer CAKE to receipt\n    IERC20(token).safeTransfer(receipt, amount);\n    // emit event\n    emit FeeWithdrawn(msg.sender, receipt, amount);\n  }\n\n  /**\n   * @dev changePancakeSwapRouter\n   * @param _pancakeSwapRouter - Address of the pancakeSwapRouter\n   */\n  function changePancakeSwapRouter(address _pancakeSwapRouter) external onlyRole(MANAGER) {\n    require(_pancakeSwapRouter != address(0), \"_pancakeSwapRouter is the zero address\");\n    require(_pancakeSwapRouter != pancakeSwapRouter, \"_pancakeSwapRouter is the same\");\n    // set pancakeSwapRouter\n    pancakeSwapRouter = _pancakeSwapRouter;\n    emit PancakeSwapRouterChanged(msg.sender, _pancakeSwapRouter);\n  }\n\n  /**\n   * @dev changePancakeSwapPool\n   * @param _pancakeSwapPool - Address of the pancakeSwapPool\n   */\n  function changePancakeSwapPool(address _pancakeSwapPool) external onlyRole(MANAGER) {\n    require(_pancakeSwapPool != address(0), \"_pancakeSwapPool is the zero address\");\n    require(_pancakeSwapPool != pancakeSwapPool, \"_pancakeSwapPool is the same\");\n    // set pancakeSwapPool\n    pancakeSwapPool = _pancakeSwapPool;\n    emit PancakeSwapPoolChanged(msg.sender, _pancakeSwapPool);\n  }\n\n  /**\n   * @dev changeMaxSwapRatio\n   * @param _maxSwapRatio - Address of the maxSwapRatio\n   */\n  function changeMaxSwapRatio(uint256 _maxSwapRatio) external onlyRole(MANAGER) {\n    require(_maxSwapRatio <= DENOMINATOR, \"Invalid max swap ratio\");\n    require(_maxSwapRatio != maxSwapRatio, \"_maxSwapRatio is the same\");\n    // set maxSwapRatio\n    maxSwapRatio = _maxSwapRatio;\n    emit MaxSwapRatioChanged(msg.sender, _maxSwapRatio);\n  }\n\n  // /* ============ Internal Functions ============ */\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n  function _smartMint(uint256 _amountIn, uint256 _mintRatio, uint256 _minOut) private returns (uint256) {\n    // valid amount\n    require(_amountIn > 0, \"Invalid amount\");\n    // valid mintRatio\n    require(_mintRatio <= DENOMINATOR, \"Incorrect Ratio\");\n    // transfer funds to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amountIn);\n    //convert CAKE amount by this contract\n    uint256 mintAmount = (_amountIn * _mintRatio) / DENOMINATOR;\n    // swap CAKE amount by pancakeSwap\n    uint256 buybackAmount = _amountIn - mintAmount;\n    // asCAKE amount\n    uint256 amountRec = 0;\n\n    if (mintAmount > 0) {\n      // swap to asCAKE by pancakeSwap\n      amountRec += _mint(mintAmount);\n      // increase total CAKE\n      _totalTokens += mintAmount;\n    }\n\n    if (buybackAmount > 0) {\n      // make sure minOut is not 0\n      require(_minOut > amountRec, \"MinOut not match\");\n      //swap CAKE by pancakeSwap\n      amountRec += _buyback(buybackAmount, _minOut - amountRec);\n    }\n    // the received amount is greater than equal to the estimated amount\n    require(amountRec >= _minOut, \"MinOut not match\");\n\n    // transfer asCAKE to sender\n    IERC20(assToken).safeTransfer(msg.sender, amountRec);\n\n    // emit event\n    emit SmartMinted(msg.sender, _amountIn, amountRec);\n\n    return amountRec;\n  }\n}\n"
    }
}