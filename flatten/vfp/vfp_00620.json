{
    "vfp_id": "vfp_00620",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Storage Description",
            "description": "Storage slot layouts in comments are depicted with index 0 on the left, contradicting the standard convention where index 0 is on the right (least significant bit). This is seen in `miscData`, `rebalanceRatioData`, and others in `PoolStorage`, `ProtocolFees`, and `AaveFundingPool`. The cause is incorrect bit layout documentation. This can lead developers to misunderstand how data is packed and unpacked, potentially causing errors in bitwise operations or storage manipulation. The impact is high risk of logic bugs during development or upgrades, especially when dealing with packed variables, which could result in incorrect state interpretation or corruption.\n",
            "severity": null,
            "location": [
                "PoolStorage.sol::miscData#105-109",
                "PoolStorage.sol::rebalanceRatioData#117-121",
                "PoolStorage.sol::indexData#127-131",
                "PoolStorage.sol::shareData#139-143",
                "PoolStorage.sol::positionMetadata#148-152",
                "ProtocolFees.sol::_miscData#92-96",
                "AaveFundingPool.sol::fundingMiscData#81-85"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/PoolStorage.sol"
            ]
        }
    ],
    "affected_files": {
        "PoolStorage.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC721Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\nimport { IPool } from \"../../interfaces/IPool.sol\";\n\nimport { WordCodec } from \"../../common/codec/WordCodec.sol\";\nimport { PoolConstant } from \"./PoolConstant.sol\";\nimport { PoolErrors } from \"./PoolErrors.sol\";\n\nabstract contract PoolStorage is ERC721Upgradeable, AccessControlUpgradeable, PoolConstant, PoolErrors {\n  using WordCodec for bytes32;\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev Below are offsets of each variables in `miscData`.\n  uint256 private constant BORROW_FLAG_OFFSET = 0;\n  uint256 private constant REDEEM_FLAG_OFFSET = 1;\n  uint256 private constant TOP_TICK_OFFSET = 2;\n  uint256 private constant NEXT_POSITION_OFFSET = 18;\n  uint256 private constant NEXT_NODE_OFFSET = 50;\n  uint256 private constant MIN_DEBT_RATIO_OFFSET = 98;\n  uint256 private constant MAX_DEBT_RATIO_OFFSET = 158;\n  uint256 private constant MAX_REDEEM_RATIO_OFFSET = 218;\n\n  /// @dev Below are offsets of each variables in `rebalanceRatioData`.\n  uint256 private constant REBALANCE_DEBT_RATIO_OFFSET = 0;\n  uint256 private constant REBALANCE_BONUS_RATIO_OFFSET = 60;\n  uint256 private constant LIQUIDATE_DEBT_RATIO_OFFSET = 90;\n  uint256 private constant LIQUIDATE_BONUS_RATIO_OFFSET = 150;\n\n  /// @dev Below are offsets of each variables in `indexData`.\n  uint256 private constant DEBT_INDEX_OFFSET = 0;\n  uint256 private constant COLLATERAL_INDEX_OFFSET = 128;\n\n  /// @dev Below are offsets of each variables in `sharesData`.\n  uint256 private constant DEBT_SHARES_OFFSET = 0;\n  uint256 private constant COLLATERAL_SHARES_OFFSET = 128;\n\n  /***********\n   * Structs *\n   ***********/\n\n  /// @dev if nodeId = 0, tick is not used and this position only has collateral\n  ///\n  /// @param tick The tick this position belongs to at the beginning.\n  /// @param nodeId The tree node id this position belongs to at the beginning.\n  /// @param colls The collateral shares this position has.\n  /// @param debts The debt shares this position has.\n  struct PositionInfo {\n    int16 tick;\n    uint48 nodeId;\n    // `uint96` is enough, since we use `86` bits in `PoolManager`.\n    uint96 colls;\n    // `uint96` is enough, since we use `96` bits in `PoolManager`.\n    uint96 debts;\n  }\n\n  /// @dev The compiler will pack it into two `uint256`.\n  /// @param metadata The metadata for tree node.\n  ///   ```text\n  ///   * Field           Bits    Index       Comments\n  ///   * parent          48      0           The index for parent tree node.\n  ///   * tick            16      48          The original tick for this tree node.\n  ///   * coll ratio      64      64          The remained coll share ratio base on parent node, the value is real ratio * 2^60.\n  ///   * debt ratio      64      128         The remained debt share ratio base on parent node, the value is real ratio * 2^60.\n  ///   ```\n  /// @param value The value for tree node\n  ///   ```text\n  ///   * Field           Bits    Index       Comments\n  ///   * coll share      128     0           The original total coll share before rebalance or redeem.\n  ///   * debt share      128     128         The original total debt share before rebalance or redeem.\n  ///   ```\n  struct TickTreeNode {\n    bytes32 metadata;\n    bytes32 value;\n  }\n\n  /*********************\n   * Storage Variables *\n   *********************/\n\n  /// @inheritdoc IPool\n  address public collateralToken;\n\n  /// @inheritdoc IPool\n  address public priceOracle;\n\n  /// @dev `miscData` is a storage slot that can be used to store unrelated pieces of information.\n  ///\n  /// - The *borrow flag* indicates whether borrow fxUSD is allowed, 1 means paused.\n  /// - The *redeem flag* indicates whether redeem fxUSD is allowed, 1 means paused.\n  /// - The *top tick* is the largest tick with debts.\n  /// - The *next position* is the next unassigned position id.\n  /// - The *next node* is the next unassigned tree node id.\n  /// - The *min debt ratio* is the minimum allowed debt ratio, multiplied by 1e18.\n  /// - The *max debt ratio* is the maximum allowed debt ratio, multiplied by 1e18.\n  /// - The *max redeem ratio* is the maximum allowed redeem ratio per tick, multiplied by 1e9.\n  ///\n  /// [ borrow flag | redeem flag | top tick | next position | next node | min debt ratio | max debt ratio | max redeem ratio | reserved ]\n  /// [    1 bit    |    1 bit    | 16  bits |    32 bits    |  48 bits  |    60  bits    |    60  bits    |      30 bits     |  8 bits  ]\n  /// [ MSB                                                                                                                          LSB ]\n  bytes32 private miscData;\n\n  /// @dev `rebalanceRatioData` is a storage slot used to store rebalance and liquidate information.\n  ///\n  /// - The *rebalance debt ratio* is the min debt ratio to start rebalance, multiplied by 1e18.\n  /// - The *rebalance bonus ratio* is the bonus ratio during rebalance, multiplied by 1e9.\n  /// - The *liquidate debt ratio* is the min debt ratio to start liquidate, multiplied by 1e18.\n  /// - The *liquidate bonus ratio* is the bonus ratio during liquidate, multiplied by 1e9.\n  ///\n  /// [ rebalance debt ratio | rebalance bonus ratio | liquidate debt ratio | liquidate bonus ratio | reserved ]\n  /// [       60  bits       |        30 bits        |       60  bits       |        30 bits        | 76  bits ]\n  /// [ MSB                                                                                                LSB ]\n  bytes32 private rebalanceRatioData;\n\n  /// @dev `indexData` is a storage slot used to store debt/collateral index.\n  ///\n  /// - The *debt index* is the index for each debt shares, only increasing, starting from 2^96, max 2^128-1.\n  /// - The *collateral index* is the index for each collateral shares, only increasing, starting from 2^96, max 2^128-1\n  ///\n  /// [ debt index | collateral index ]\n  /// [  128 bits  |     128 bits     ]\n  /// [ MSB                       LSB ]\n  bytes32 private indexData;\n\n  /// @dev `sharesData` is a storage slot used to store debt/collateral shares.\n  ///\n  /// - The *debt shares* is the total debt shares. The actual number of total debts\n  ///   is `<debt shares> * <debt index>`.\n  /// - The *collateral shares* is the total collateral shares. The actual number of\n  ///   total collateral is `<collateral shares> / <collateral index>`.\n  ///\n  /// [ debt shares | collateral shares ]\n  /// [  128  bits  |     128  bits     ]\n  /// [ MSB                         LSB ]\n  bytes32 private sharesData;\n\n  /// @dev Mapping from position id to position information.\n  mapping(uint256 => PositionInfo) public positionData;\n\n  /// @dev Mapping from position id to position metadata.\n  /// [ open timestamp | reserved ]\n  /// [    40  bits    | 216 bits ]\n  /// [ MSB                   LSB ]\n  mapping(uint256 => bytes32) public positionMetadata;\n\n  /// @dev The bitmap for ticks with debts.\n  mapping(int8 => uint256) public tickBitmap;\n\n  /// @dev Mapping from tick to tree node id.\n  mapping(int256 => uint48) public tickData;\n\n  /// @dev Mapping from tree node id to tree node data.\n  mapping(uint256 => TickTreeNode) public tickTreeData;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  function __PoolStorage_init(address _collateralToken, address _priceOracle) internal onlyInitializing {\n    _checkAddressNotZero(_collateralToken);\n\n    collateralToken = _collateralToken;\n    _updatePriceOracle(_priceOracle);\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc AccessControlUpgradeable\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(AccessControlUpgradeable, ERC721Upgradeable) returns (bool) {\n    return super.supportsInterface(interfaceId);\n  }\n\n  /// @inheritdoc IPool\n  function isBorrowPaused() external view returns (bool) {\n    return _isBorrowPaused();\n  }\n\n  /// @inheritdoc IPool\n  function isRedeemPaused() external view returns (bool) {\n    return _isRedeemPaused();\n  }\n\n  /// @inheritdoc IPool\n  function getTopTick() external view returns (int16) {\n    return _getTopTick();\n  }\n\n  /// @inheritdoc IPool\n  function getNextPositionId() external view returns (uint32) {\n    return _getNextPositionId();\n  }\n\n  /// @inheritdoc IPool\n  function getNextTreeNodeId() external view returns (uint48) {\n    return _getNextTreeNodeId();\n  }\n\n  /// @inheritdoc IPool\n  function getDebtRatioRange() external view returns (uint256, uint256) {\n    return _getDebtRatioRange();\n  }\n\n  /// @inheritdoc IPool\n  function getMaxRedeemRatioPerTick() external view returns (uint256) {\n    return _getMaxRedeemRatioPerTick();\n  }\n\n  /// @inheritdoc IPool\n  function getRebalanceRatios() external view returns (uint256, uint256) {\n    return _getRebalanceRatios();\n  }\n\n  /// @inheritdoc IPool\n  function getLiquidateRatios() external view returns (uint256, uint256) {\n    return _getLiquidateRatios();\n  }\n\n  /// @inheritdoc IPool\n  function getDebtAndCollateralIndex() external view returns (uint256, uint256) {\n    return _getDebtAndCollateralIndex();\n  }\n\n  /// @inheritdoc IPool\n  function getDebtAndCollateralShares() external view returns (uint256, uint256) {\n    return _getDebtAndCollateralShares();\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update price oracle.\n  /// @param newOracle The address of new price oracle;\n  function _updatePriceOracle(address newOracle) internal {\n    _checkAddressNotZero(newOracle);\n\n    address oldOracle = priceOracle;\n    priceOracle = newOracle;\n\n    emit UpdatePriceOracle(oldOracle, newOracle);\n  }\n\n  /*************************************\n   * Internal Functions For `miscData` *\n   *************************************/\n\n  /// @dev Internal function to get the borrow pause status.\n  function _isBorrowPaused() internal view returns (bool) {\n    return miscData.decodeBool(BORROW_FLAG_OFFSET);\n  }\n\n  /// @dev Internal function to update borrow pause status.\n  /// @param status The status to update.\n  function _updateBorrowStatus(bool status) internal {\n    miscData = miscData.insertBool(status, BORROW_FLAG_OFFSET);\n\n    emit UpdateBorrowStatus(status);\n  }\n\n  /// @dev Internal function to get the redeem pause status.\n  function _isRedeemPaused() internal view returns (bool) {\n    return miscData.decodeBool(REDEEM_FLAG_OFFSET);\n  }\n\n  /// @dev Internal function to update redeem pause status.\n  /// @param status The status to update.\n  function _updateRedeemStatus(bool status) internal {\n    miscData = miscData.insertBool(status, REDEEM_FLAG_OFFSET);\n\n    emit UpdateRedeemStatus(status);\n  }\n\n  /// @dev Internal function to get the value of top tick.\n  function _getTopTick() internal view returns (int16) {\n    return int16(miscData.decodeInt(TOP_TICK_OFFSET, 16));\n  }\n\n  /// @dev Internal function to update the top tick.\n  /// @param tick The new top tick.\n  function _updateTopTick(int16 tick) internal {\n    miscData = miscData.insertInt(tick, TOP_TICK_OFFSET, 16);\n  }\n\n  /// @dev Internal function to get next available position id.\n  function _getNextPositionId() internal view returns (uint32) {\n    return uint32(miscData.decodeUint(NEXT_POSITION_OFFSET, 32));\n  }\n\n  /// @dev Internal function to update next available position id.\n  /// @param id The position id to update.\n  function _updateNextPositionId(uint32 id) internal {\n    miscData = miscData.insertUint(id, NEXT_POSITION_OFFSET, 32);\n  }\n\n  /// @dev Internal function to get next available tree node id.\n  function _getNextTreeNodeId() internal view returns (uint48) {\n    return uint48(miscData.decodeUint(NEXT_NODE_OFFSET, 48));\n  }\n\n  /// @dev Internal function to update next available tree node id.\n  /// @param id The tree node id to update.\n  function _updateNextTreeNodeId(uint48 id) internal {\n    miscData = miscData.insertUint(id, NEXT_NODE_OFFSET, 48);\n  }\n\n  /// @dev Internal function to get `minDebtRatio` and `maxDebtRatio`, both multiplied by 1e18.\n  function _getDebtRatioRange() internal view returns (uint256 minDebtRatio, uint256 maxDebtRatio) {\n    bytes32 data = miscData;\n    minDebtRatio = data.decodeUint(MIN_DEBT_RATIO_OFFSET, 60);\n    maxDebtRatio = data.decodeUint(MAX_DEBT_RATIO_OFFSET, 60);\n  }\n\n  /// @dev Internal function to update debt ratio range.\n  /// @param minDebtRatio The minimum allowed debt ratio to update, multiplied by 1e18.\n  /// @param maxDebtRatio The maximum allowed debt ratio to update, multiplied by 1e18.\n  function _updateDebtRatioRange(uint256 minDebtRatio, uint256 maxDebtRatio) internal {\n    _checkValueTooLarge(minDebtRatio, maxDebtRatio);\n    _checkValueTooLarge(maxDebtRatio, PRECISION);\n\n    bytes32 data = miscData;\n    data = data.insertUint(minDebtRatio, MIN_DEBT_RATIO_OFFSET, 60);\n    miscData = data.insertUint(maxDebtRatio, MAX_DEBT_RATIO_OFFSET, 60);\n\n    emit UpdateDebtRatioRange(minDebtRatio, maxDebtRatio);\n  }\n\n  /// @dev Internal function to get the `maxRedeemRatioPerTick`.\n  function _getMaxRedeemRatioPerTick() internal view returns (uint256) {\n    return miscData.decodeUint(MAX_REDEEM_RATIO_OFFSET, 30);\n  }\n\n  /// @dev Internal function to update maximum redeem ratio per tick.\n  /// @param ratio The ratio to update, multiplied by 1e9.\n  function _updateMaxRedeemRatioPerTick(uint256 ratio) internal {\n    _checkValueTooLarge(ratio, FEE_PRECISION);\n\n    miscData = miscData.insertUint(ratio, MAX_REDEEM_RATIO_OFFSET, 30);\n\n    emit UpdateMaxRedeemRatioPerTick(ratio);\n  }\n\n  /***********************************************\n   * Internal Functions For `rebalanceRatioData` *\n   ***********************************************/\n\n  /// @dev Internal function to get `debtRatio` and `bonusRatio` for rebalance.\n  /// @return debtRatio The minimum debt ratio to start rebalance, multiplied by 1e18.\n  /// @return bonusRatio The bonus ratio during rebalance, multiplied by 1e9.\n  function _getRebalanceRatios() internal view returns (uint256 debtRatio, uint256 bonusRatio) {\n    bytes32 data = rebalanceRatioData;\n    debtRatio = data.decodeUint(REBALANCE_DEBT_RATIO_OFFSET, 60);\n    bonusRatio = data.decodeUint(REBALANCE_BONUS_RATIO_OFFSET, 30);\n  }\n\n  /// @dev Internal function to update ratio for rebalance.\n  /// @param debtRatio The minimum debt ratio to start rebalance, multiplied by 1e18.\n  /// @param bonusRatio The bonus ratio during rebalance, multiplied by 1e9.\n  function _updateRebalanceRatios(uint256 debtRatio, uint256 bonusRatio) internal {\n    _checkValueTooLarge(debtRatio, PRECISION);\n    _checkValueTooLarge(bonusRatio, FEE_PRECISION);\n\n    bytes32 data = rebalanceRatioData;\n    data = data.insertUint(debtRatio, REBALANCE_DEBT_RATIO_OFFSET, 60);\n    rebalanceRatioData = data.insertUint(bonusRatio, REBALANCE_BONUS_RATIO_OFFSET, 30);\n\n    emit UpdateRebalanceRatios(debtRatio, bonusRatio);\n  }\n\n  /// @dev Internal function to get `debtRatio` and `bonusRatio` for liquidate.\n  /// @return debtRatio The minimum debt ratio to start liquidate, multiplied by 1e18.\n  /// @return bonusRatio The bonus ratio during liquidate, multiplied by 1e9.\n  function _getLiquidateRatios() internal view returns (uint256 debtRatio, uint256 bonusRatio) {\n    bytes32 data = rebalanceRatioData;\n    debtRatio = data.decodeUint(LIQUIDATE_DEBT_RATIO_OFFSET, 60);\n    bonusRatio = data.decodeUint(LIQUIDATE_BONUS_RATIO_OFFSET, 30);\n  }\n\n  /// @dev Internal function to update ratio for liquidate.\n  /// @param debtRatio The minimum debt ratio to start liquidate, multiplied by 1e18.\n  /// @param bonusRatio The bonus ratio during liquidate, multiplied by 1e9.\n  function _updateLiquidateRatios(uint256 debtRatio, uint256 bonusRatio) internal {\n    _checkValueTooLarge(debtRatio, PRECISION);\n    _checkValueTooLarge(bonusRatio, FEE_PRECISION);\n\n    bytes32 data = rebalanceRatioData;\n    data = data.insertUint(debtRatio, LIQUIDATE_DEBT_RATIO_OFFSET, 60);\n    rebalanceRatioData = data.insertUint(bonusRatio, LIQUIDATE_BONUS_RATIO_OFFSET, 30);\n\n    emit UpdateLiquidateRatios(debtRatio, bonusRatio);\n  }\n\n  /**************************************\n   * Internal Functions For `indexData` *\n   **************************************/\n\n  /// @dev Internal function to get debt and collateral index.\n  /// @return debtIndex The index for debt shares.\n  /// @return collIndex The index for collateral shares.\n  function _getDebtAndCollateralIndex() internal view returns (uint256 debtIndex, uint256 collIndex) {\n    bytes32 data = indexData;\n    debtIndex = data.decodeUint(DEBT_INDEX_OFFSET, 128);\n    collIndex = data.decodeUint(COLLATERAL_INDEX_OFFSET, 128);\n  }\n\n  /// @dev Internal function to update debt index.\n  /// @param index The debt index to update.\n  function _updateDebtIndex(uint256 index) internal {\n    indexData = indexData.insertUint(index, DEBT_INDEX_OFFSET, 128);\n\n    emit DebtIndexSnapshot(index);\n  }\n\n  /// @dev Internal function to update collateral index.\n  /// @param index The collateral index to update.\n  function _updateCollateralIndex(uint256 index) internal {\n    indexData = indexData.insertUint(index, COLLATERAL_INDEX_OFFSET, 128);\n\n    emit CollateralIndexSnapshot(index);\n  }\n\n  /**************************************\n   * Internal Functions For `sharesData` *\n   **************************************/\n\n  /// @dev Internal function to get debt and collateral shares.\n  /// @return debtShares The total number of debt shares.\n  /// @return collShares The total number of collateral shares.\n  function _getDebtAndCollateralShares() internal view returns (uint256 debtShares, uint256 collShares) {\n    bytes32 data = sharesData;\n    debtShares = data.decodeUint(DEBT_SHARES_OFFSET, 128);\n    collShares = data.decodeUint(COLLATERAL_SHARES_OFFSET, 128);\n  }\n\n  /// @dev Internal function to update debt and collateral shares.\n  /// @param debtShares The debt shares to update.\n  /// @param collShares The collateral shares to update.\n  function _updateDebtAndCollateralShares(uint256 debtShares, uint256 collShares) internal {\n    bytes32 data = sharesData;\n    data = data.insertUint(debtShares, DEBT_SHARES_OFFSET, 128);\n    sharesData = data.insertUint(collShares, COLLATERAL_SHARES_OFFSET, 128);\n  }\n\n  /// @dev Internal function to update debt shares.\n  /// @param shares The debt shares to update.\n  function _updateDebtShares(uint256 shares) internal {\n    sharesData = sharesData.insertUint(shares, DEBT_SHARES_OFFSET, 128);\n  }\n\n  /// @dev Internal function to update collateral shares.\n  /// @param shares The collateral shares to update.\n  function _updateCollateralShares(uint256 shares) internal {\n    sharesData = sharesData.insertUint(shares, COLLATERAL_SHARES_OFFSET, 128);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[40] private __gap;\n}\n"
    }
}