{
    "vfp_id": "vfp_00488",
    "project_name": "IBC Eureka - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Unchecked slippage may lead to sandwich attacks",
            "description": "The swapAndTransfer function in EurekaHandler performs a token swap using arbitrary calldata (swapCalldata) passed directly from the user without validating slippage parameters. Since the function does not enforce a minimum output amount or verify that slippage is bounded in the provided calldata, an attacker can craft a swap with zero or minimal slippage protection. This exposes users to sandwich attacks, where malicious actors front-run and back-run the swap to extract value. The lack of enforced slippage checks means users may receive significantly less output than expected, resulting in direct financial loss. While the impact is limited to individual user transactions, it represents a significant risk in a trustless environment where MEV (Miner Extractable Value) is prevalent.\n",
            "severity": "Informational",
            "location": [
                "EurekaHandler::swapAndTransfer"
            ],
            "files": [
                "64c5ba2db3155fee10d5fb5331dd371499c9548f/skip-go-evm-contracts/EurekaHandler/src/EurekaHandler.sol"
            ]
        }
    ],
    "affected_files": {
        "EurekaHandler.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {IICS20TransferMsgs, IICS20Transfer} from \"./interfaces/eureka/ICS20Transfer.sol\";\nimport {IIBCVoucher} from \"./interfaces/lombard/IIBCVoucher.sol\";\nimport {IEurekaHandler} from \"./interfaces/IEurekaHandler.sol\";\n\ncontract EurekaHandler is IEurekaHandler, Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    address public ics20Transfer;\n    address public swapRouter;\n    address public lbtcVoucher;\n    address public lbtc;\n    address public relayFeeRecipient;\n\n    event Transfer(address indexed token, uint256 amount, uint256 relayFee);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _ics20Transfer,\n        address _swapRouter,\n        address _lbtcVoucher,\n        address _lbtc,\n        address _relayFeeRecipient\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init(_owner);\n\n        ics20Transfer = _ics20Transfer;\n        swapRouter = _swapRouter;\n        lbtcVoucher = _lbtcVoucher;\n        lbtc = _lbtc;\n        relayFeeRecipient = _relayFeeRecipient;\n    }\n\n    function transfer(uint256 amount, TransferParams memory transferParams, Fees memory fees) external {\n        require(block.timestamp < fees.quoteExpiry, \"Fee quote expired\");\n\n        // Collect fees\n        IERC20(transferParams.token).transferFrom(msg.sender, relayFeeRecipient, fees.relayFee);\n\n        IERC20(transferParams.token).transferFrom(msg.sender, address(this), amount);\n\n        _sendTransfer(\n            IICS20TransferMsgs.SendTransferMsg({\n                denom: transferParams.token,\n                amount: amount,\n                receiver: transferParams.recipient,\n                sourceClient: transferParams.sourceClient,\n                destPort: transferParams.destPort,\n                timeoutTimestamp: transferParams.timeoutTimestamp,\n                memo: transferParams.memo\n            })\n        );\n\n        emit Transfer(transferParams.token, amount, fees.relayFee);\n    }\n\n    function swapAndTransfer(\n        address swapInputToken,\n        uint256 swapInputAmount,\n        bytes memory swapCalldata,\n        TransferParams memory transferParams,\n        Fees memory fees\n    ) external {\n        require(block.timestamp < fees.quoteExpiry, \"Fee quote expired\");\n\n        IERC20(swapInputToken).transferFrom(msg.sender, address(this), swapInputAmount);\n\n        uint256 amountOut = _swap(swapInputToken, transferParams.token, swapInputAmount, swapCalldata);\n\n        if (amountOut <= _totalFees(fees)) {\n            revert(\"Insufficient amount out to cover fees\");\n        }\n\n        // Collect fees\n        IERC20(transferParams.token).transferFrom(address(this), relayFeeRecipient, fees.relayFee);\n\n        uint256 amountOutAfterFees = amountOut - _totalFees(fees);\n\n        _sendTransfer(\n            IICS20TransferMsgs.SendTransferMsg({\n                denom: transferParams.token,\n                amount: amountOutAfterFees,\n                receiver: transferParams.recipient,\n                sourceClient: transferParams.sourceClient,\n                destPort: transferParams.destPort,\n                timeoutTimestamp: transferParams.timeoutTimestamp,\n                memo: transferParams.memo\n            })\n        );\n\n        emit Transfer(transferParams.token, amountOutAfterFees, fees.relayFee);\n    }\n\n    function lombardTransfer(uint256 amount, TransferParams memory transferParams, Fees memory fees) external {\n        require(block.timestamp < fees.quoteExpiry, \"Fee quote expired\");\n\n        // Collect fees\n        IERC20(lbtc).transferFrom(msg.sender, relayFeeRecipient, fees.relayFee);\n\n        IERC20(lbtc).transferFrom(msg.sender, address(this), amount);\n\n        IERC20(lbtc).approve(lbtcVoucher, amount);\n\n        uint256 voucherAmount = IIBCVoucher(lbtcVoucher).get(amount);\n\n        _sendTransfer(\n            IICS20TransferMsgs.SendTransferMsg({\n                denom: lbtcVoucher,\n                amount: voucherAmount,\n                receiver: transferParams.recipient,\n                sourceClient: transferParams.sourceClient,\n                destPort: transferParams.destPort,\n                timeoutTimestamp: transferParams.timeoutTimestamp,\n                memo: transferParams.memo\n            })\n        );\n\n        emit Transfer(lbtc, voucherAmount, fees.relayFee);\n    }\n\n    function _sendTransfer(IICS20TransferMsgs.SendTransferMsg memory transferMsg) internal {\n        IERC20(transferMsg.denom).approve(ics20Transfer, transferMsg.amount);\n\n        IICS20Transfer(ics20Transfer).sendTransferWithSender(transferMsg, msg.sender);\n    }\n\n    function _swap(address tokenIn, address tokenOut, uint256 amountIn, bytes memory swapCalldata)\n        internal\n        returns (uint256 amountOut)\n    {\n        uint256 tokenOutBalanceBefore = IERC20(tokenOut).balanceOf(address(this));\n\n        IERC20(tokenIn).approve(swapRouter, amountIn);\n\n        (bool success,) = swapRouter.call(swapCalldata);\n        if (!success) {\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        amountOut = IERC20(tokenOut).balanceOf(address(this)) - tokenOutBalanceBefore;\n\n        return amountOut;\n    }\n\n    function _totalFees(Fees memory fees) internal pure returns (uint256) {\n        return fees.relayFee;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function setRelayFeeRecipient(address newRelayFeeRecipient) external onlyOwner {\n        relayFeeRecipient = newRelayFeeRecipient;\n    }\n}\n"
    }
}