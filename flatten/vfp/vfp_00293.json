{
    "vfp_id": "vfp_00293",
    "project_name": "cantina_euler_rescue_strategy_nov2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "Missing enough flashloan avenues can make the rescue impossible",
            "description": "The rescue operation for affected vaults relies on only three flashloan avenues: direct Euler vault loan, batched Euler loan, and Morpho loan. This limited set of flashloan sources may not be sufficient on chains where Euler has low liquidity or where Morpho is not deployed, rendering the rescue operation impossible in those environments.\nThe root cause is the lack of diversification in flashloan providers integrated into the rescue strategy. An attacker or adverse market condition that disables access to all three current avenues on a given chain would prevent any rescue.\nAn attacker could exploit this by manipulating liquidity on the supported platforms or by targeting chains where alternative flashloan providers are not available, thereby preventing the rescue of funds.\nThe impact is that users' funds in affected vaults may become permanently stranded if a rescue is needed but cannot be executed due to lack of flashloan liquidity, leading to potential loss of user funds.\n",
            "severity": "Low",
            "location": [
                "RescueStrategy.sol"
            ],
            "files": [
                "euler-earn/src/RescueStrategy.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ],
                "4": [
                    "CWE-638"
                ]
            },
            "title": "Relaying on EOA as a rescuer is dangerous",
            "description": "The rescue mechanism relies on a single Externally Owned Account (EOA) as the rescuer, which poses significant operational risks. Once a vault opts into the rescue strategy and the cap is set, the fundsReceiver (EOA) can withdraw the vault's liquidity without further on-chain authorization checks.\nThe vulnerability stems from the fact that the isStrategyAllowed check is only performed during _setCap, and after that, no additional protections exist. Since the rescuer must be an EOA to satisfy tx.origin checks, it becomes a single point of failure.\nAn attacker who compromises the private key of the EOA or a malicious operator could trigger unauthorized rescues, execute arbitrary calls via the call() function, or exfiltrate assets. Additionally, permit approvals set in the constructor increase the attack surface.\nThe impact includes potential loss of all funds in vaults that have enabled the rescue strategy, as well as a complete compromise of the rescue mechanism's integrity.\n",
            "severity": "Low",
            "location": [
                "RescueStrategy.sol#L26"
            ],
            "files": [
                "euler-earn/src/RescueStrategy.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Invariant not enforced in a pool that is in Rescue mode",
            "description": "When a vault is in Rescue mode, certain invariants should be enforced: the supplyQueue[0] and withdrawalQueue[0] should both be the RescueStrategy, and the supplyQueue length should be 1. However, these invariants are not checked during the rescue flow (flashloan and callback), allowing a vault to be in rescue mode while having a different strategy as the primary supplier.\nThe cause is the absence of validation logic in the rescue functions to verify the expected queue configuration before proceeding.\nAn attacker or misconfigured vault could exploit this by manipulating the strategy queue to include another strategy, leading to unexpected behavior during the rescue process, such as funds being routed incorrectly or the rescue failing silently.\nThe impact includes potential loss of rescued funds or failure of the rescue operation due to unexpected interactions with other strategies, undermining the reliability of the rescue mechanism.\n",
            "severity": "Low",
            "location": [
                "RescueStrategy.sol#L188-L203"
            ],
            "files": [
                "euler-earn/src/RescueStrategy.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Performance fee should be set to 0 during rescue state",
            "description": "Vaults in rescue mode currently still incur a performance fee, which reduces the amount of assets that can be rescued and sent to the fundsReceiver.\nThe issue arises because the performance fee is not automatically set to zero when a vault enters rescue mode, despite the fact that the rescue operation is not a performance-generating event.\nWhile not directly exploitable by an attacker, this design choice results in suboptimal fund recovery, as a portion of the rescued assets is unnecessarily deducted as fees.\nThe impact is a reduction in the total amount of user funds recovered during a rescue, which could affect user trust and the effectiveness of the rescue operation.\n",
            "severity": "Informational",
            "location": [
                "RescueStrategy.sol#L199"
            ],
            "files": [
                "euler-earn/src/RescueStrategy.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "The deposit returns the amount of assets deposited",
            "description": "The deposit function in the RescueStrategy returns the amount of assets deposited instead of the amount of shares, which deviates from the standard ERC4626 deposit behavior.\nThis is caused by the function's implementation not adhering to the ERC4626 specification, which expects deposit to return shares = assets * exchangeRate.\nWhile this does not pose a direct security risk in the current rescue context—where the goal is to extract liquidity—it could lead to confusion or incorrect integration if the strategy is reused in other contexts.\nThe impact is primarily on code clarity and future maintainability, as developers might expect standard ERC4626 behavior, potentially leading to integration errors if the strategy is repurposed.\n",
            "severity": "Informational",
            "location": [
                "RescueStrategy.sol#L100"
            ],
            "files": [
                "euler-earn/src/RescueStrategy.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Emit event with rescued amount for easier offchain accounting",
            "description": "The rescue process does not emit an event containing the amount of assets rescued, making it difficult to track and account for rescued funds off-chain.\nThis is due to the absence of an explicit event emission in the _processFlashLoan function or related rescue steps.\nWhile not a security vulnerability, this omission complicates monitoring, auditing, and reporting of rescue operations by external tools and stakeholders.\nThe impact is reduced transparency and operational visibility, which could hinder post-incident analysis and accountability.\n",
            "severity": "Informational",
            "location": [
                "RescueStrategy.sol#L189-L202"
            ],
            "files": [
                "euler-earn/src/RescueStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "RescueStrategy.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.26;\n\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {EVCUtil} from \"ethereum-vault-connector/utils/EVCUtil.sol\";\nimport {IEVC} from \"ethereum-vault-connector/interfaces/IEthereumVaultConnector.sol\";\nimport {IEulerEarn} from \"./interfaces/IEulerEarn.sol\";\nimport {SafeERC20Permit2Lib} from \"./libraries/SafeERC20Permit2Lib.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IBorrowing, IRiskManager} from \"../lib/euler-vault-kit/src/EVault/IEVault.sol\";\n\n/* \n    Rescue procedure:\n    - Euler installs a perspective in the earn factory which allows adding custom strategies\n    - RescueStrategy contracts are deployed for each earn vault to rescue. \n      Immutable params:\n        o Rescue EOA: is only allowed to call the rescue function directly or through a multisig (tx.origin is checked).\n          It should be a throw-away EOA just for the purpose of rescue, because of tx.origin use.\n        o funds receiver: will receive rescued assets and left over shares (see below)\n        o earn vault: the strategy can only work with the specified vault. If another vault tries to enable it, it will revert on `submitCap`\n    - Euler registers the strategies in the perspective\n    - Curator installs the strategy with unlimited cap (submit/acceptCap)\n    - Curator sets the new strategy as the only one in supply queue and moves it to the front of withdraw queue\n        o at this stage the regular users can't deposit or withdraw from earn\n    - Rescue EOA calls one of the `rescueX` funcitons (for Euler or Morpho flash loan sources), specifying the asset amount to flashloan\n        o flash loan is used to create earn vault shares, it just passes through earn vault back to the rescue strategy where it is repaid\n        o the shares are used to withdraw as much as possible from the underlying strategies to the funds receiver\n        o remaining shares are returned to the funds receiver\n        o the rescue function can be called multiple times\n        o the rescue EOA can also withdraw shares at any time, as long as it is tx.origin \n          (so can also initiate withdrawal if funds receiver is a multisig)\n*/\n\ninterface IFlashLoan {\n    function flashLoan(uint256, bytes memory) external;\n    function flashLoan(address, uint256, bytes memory) external;\n}\n\ncontract RescueStrategy {\n\taddress immutable public rescueAccount;\n\taddress immutable public earnVault;\n\tIERC20 immutable internal _asset;\n\taddress immutable public fundsReceiver;\n\n\tmodifier onlyRescueAccount() {\n\t\trequire(tx.origin == rescueAccount, \"vault operations are paused\");\n\t\t_;\n\t}\n\n    modifier onlyAllowedEarnVault() {\n        require(msg.sender == earnVault, \"wrong vault\");\n        _;\n    }\n\n\tconstructor(address _rescueAccount, address _earnVault, address _fundsReceiver) {\n\t\trescueAccount = _rescueAccount;\n\t\tearnVault = _earnVault;\n        fundsReceiver = _fundsReceiver;\n\t\t_asset = IERC20(IEulerEarn(earnVault).asset());\n\t\tSafeERC20Permit2Lib.forceApproveMaxWithPermit2(\n\t\t\t_asset,\n\t\t\trescueAccount,\n\t\t\taddress(0)\n\t\t);\n\t}\n\n    function asset() external view returns(address) {\n        return address(_asset);\n    }\n\n    // will revert user deposits\n\tfunction maxDeposit(address) onlyAllowedEarnVault onlyRescueAccount external view returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n    // will revert user withdrawals\n\tfunction maxWithdraw(address) onlyAllowedEarnVault onlyRescueAccount external view returns (uint256) {\n\t\treturn 0;\n\t}\n\n\tfunction previewRedeem(uint256) onlyAllowedEarnVault external view returns (uint256) {\n\t\treturn 0;\n\t}\n\n    // this reverts acceptCaps to prevent reusing the whitelisted strategy on other vaults\n\tfunction balanceOf(address) onlyAllowedEarnVault external view returns (uint256) {\n\t\treturn 0;\n\t}\n\n\tfunction deposit(uint256 amount, address) onlyAllowedEarnVault onlyRescueAccount external returns (uint256) {\n\t\tSafeERC20Permit2Lib.safeTransferFromWithPermit2(\n\t\t\t_asset,\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\tamount, \n\t\t\tIEulerEarn(earnVault).permit2Address()\n\t\t);\n\n        return amount;\n\t}\n\n    // alternative sources of flashloan\n    function rescueEuler(uint256 loanAmount, address flashLoanVault) onlyRescueAccount external {\n        bytes memory data = abi.encode(loanAmount, flashLoanVault);\n\t\tIFlashLoan(flashLoanVault).flashLoan(loanAmount, data);\n\t}\n\n    // alternative sources of flashloan\n    function rescueEulerBatch(uint256 loanAmount, address flashLoanVault) onlyRescueAccount external {\n        address evc = EVCUtil(earnVault).EVC();\n\n        SafeERC20.forceApprove(_asset, flashLoanVault, loanAmount);\n\n        IEVC.BatchItem[] memory batchItems = new IEVC.BatchItem[](5);\n        batchItems[0] = IEVC.BatchItem({\n            targetContract: evc,\n            onBehalfOfAccount: address(0),\n            value: 0,\n            data: abi.encodeCall(IEVC.enableController, (address(this), flashLoanVault))\n        });\n        batchItems[1] = IEVC.BatchItem({\n            targetContract: flashLoanVault,\n            onBehalfOfAccount: address(this),\n            value: 0,\n            data: abi.encodeCall(IBorrowing.borrow, (loanAmount, address(this)))\n        });\n        batchItems[2] = IEVC.BatchItem({\n            targetContract: address(this),\n            onBehalfOfAccount: address(this),\n            value: 0,\n            data: abi.encodeCall(this.onBatchLoan, (loanAmount))\n        });\n        batchItems[3] = IEVC.BatchItem({\n            targetContract: flashLoanVault,\n            onBehalfOfAccount: address(this),\n            value: 0,\n            data: abi.encodeCall(IBorrowing.repay, (loanAmount, address(this)))\n        });\n        batchItems[4] = IEVC.BatchItem({\n            targetContract: flashLoanVault,\n            onBehalfOfAccount: address(this),\n            value: 0,\n            data: abi.encodeCall(IRiskManager.disableController, ())\n        });\n\n        IEVC(evc).batch(batchItems);\n\t}\n\n    // alternative sources of flashloan\n    function rescueMorpho(uint256 loanAmount, address morpho) onlyRescueAccount external {\n\t\tIFlashLoan(morpho).flashLoan(address(_asset), loanAmount, \"\");\n\t}\n\n\tfunction onBatchLoan(uint256 loanAmount) external {\n\t\t_processFlashLoan(loanAmount);\n\t}\n\n\tfunction onFlashLoan(bytes memory data) external {\n        (uint256 loanAmount, address flashLoanSource) = abi.decode(data, (uint256, address));\n\n\t\t_processFlashLoan(loanAmount);\n\n        // repay the flashloan\n\t\tSafeERC20.safeTransfer(\n\t\t\t_asset,\n\t\t\tflashLoanSource,\n\t\t\tloanAmount\n\t\t);\n\t}\n\n\tfunction onMorphoFlashLoan(uint256 amount, bytes memory) external {\n\t\t_processFlashLoan(amount);\n\n        SafeERC20.forceApprove(_asset, msg.sender, amount);\n\t}\n\n    // The contract is not supposed to hold any value, but in case of any issues rescue account can exec arbitrary call\n\tfunction call(address target, bytes memory payload) onlyRescueAccount external {\n\t\t(bool success,) = target.call(payload);\n\t\trequire(success, \"call failed\");\n\t}\n\n\tfallback() external {\n\t\trevert(\"vault operations are paused\");\n\t}\n\n    function _processFlashLoan(uint256 loanAmount) internal {\n\t\tSafeERC20Permit2Lib.forceApproveMaxWithPermit2(\n\t\t\t_asset,\n\t\t\tearnVault,\n\t\t\taddress(0)\n\t\t);\n\n\t\t// deposit to earn, create shares. Assets will come back here if the strategy is first in supply queue\n\t\tIERC4626(earnVault).deposit(loanAmount, address(this));\n\n        // withdraw as much as possible to the receiver\n        IERC4626(earnVault).withdraw(IERC4626(earnVault).maxWithdraw(address(this)), fundsReceiver, address(this));\n\n        // send the remaining shares to the receiver\n        IERC4626(earnVault).transfer(fundsReceiver, IERC4626(earnVault).balanceOf(address(this)));\n    }\n}\n"
    }
}