{
    "vfp_id": "vfp_00341",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 47,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Allowing pDAO to control voter share of revenue is risky",
            "description": "The pDAO has the ability to modify the voter share of protocol revenue via setVoterShare(), or indirectly by adjusting node or protocol DAO shares. This creates a conflict of interest, especially in the Saturn-1 phase, where short-term pDAO members might vote to increase their own share at the expense of long-term protocol health.\nThe root cause is the governance design that allows pDAO to control a parameter (voter share) that directly affects their own rewards, despite RPIP-46 specifying that this should no longer be a modifiable parameter post-Saturn-2.\nA malicious or self-interested pDAO member could propose and pass a vote to increase their share, leveraging their voting power.\nThe impact includes potential misalignment of incentives, reduced attractiveness of rETH yields compared to other LSTs, and erosion of trust in the protocol's fairness, though economic disincentives may limit exploitation.\n",
            "severity": "Low",
            "location": [
                "RocketNetworkRevenues.sol#L80-L96"
            ],
            "files": [
                "rocketpool/contracts/contract/network/RocketNetworkRevenues.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketNetworkRevenues.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketNetworkSnapshotsInterface} from \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\nimport {RocketNetworkRevenuesInterface} from \"../../interface/network/RocketNetworkRevenuesInterface.sol\";\n\n/// @notice Handles the calculations of revenue splits for the protocol's Universal Adjustable Revenue Split\ncontract RocketNetworkRevenues is RocketBase, RocketNetworkRevenuesInterface {\n    // Constants\n    uint256 private constant shareMagnitude = 100_000;\n    uint256 private constant shareScale = 1 ether / shareMagnitude;\n    bytes32 private constant nodeShareKey = keccak256(abi.encodePacked(\"network.revenue.node.share\"));\n    bytes32 private constant voterShareKey = keccak256(abi.encodePacked(\"network.revenue.voter.share\"));\n    bytes32 private constant protocolDAOShareKey = keccak256(abi.encodePacked(\"network.revenue.pdao.share\"));\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 1;\n    }\n\n    /// @dev Only allows calls from the pDAO setting contract or the security DAO contract\n    modifier onlyProtocolOrSecurityDAO() {\n        if(msg.sender != getAddress(keccak256(abi.encodePacked(\"contract.address\", \"rocketDAOProtocolSettingsNetwork\")))) {\n            if(msg.sender != getAddress(keccak256(abi.encodePacked(\"contract.address\", \"rocketDAOSecurityProposals\")))) {\n                revert(\"Invalid or outdated network contract\");\n            }\n        }\n        _;\n    }\n\n    /// @notice Used following an upgrade or new deployment to initialise the revenue split system\n    /// @param _initialNodeShare The initial value to for the node share\n    /// @param _initialVoterShare The initial value to for the voter share\n    /// @param _initialProtocolDAOShare The initial value to for the pdao share\n    function initialise(uint256 _initialNodeShare, uint256 _initialVoterShare, uint256 _initialProtocolDAOShare) override public {\n        // On new deploy, allow guardian to initialise, otherwise, only a network contract\n        if (rocketStorage.getDeployedStatus()) {\n            require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            require(msg.sender == rocketStorage.getGuardian(), \"Not guardian\");\n        }\n        // Initialise the shares\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        (bool exists,,) = rocketNetworkSnapshots.latest(nodeShareKey);\n        require(!exists, \"Already initialised\");\n        // Initialise node share\n        bytes32 valueKey = bytes32(uint256(nodeShareKey) + block.number);\n        setUint(valueKey, _initialNodeShare / shareScale);\n        rocketNetworkSnapshots.push(nodeShareKey, 0);\n        // Initialise voter share\n        valueKey = bytes32(uint256(voterShareKey) + block.number);\n        setUint(valueKey, _initialVoterShare / shareScale);\n        rocketNetworkSnapshots.push(voterShareKey, 0);\n        // Initialise pdao share\n        valueKey = bytes32(uint256(protocolDAOShareKey) + block.number);\n        setUint(valueKey, _initialProtocolDAOShare / shareScale);\n        rocketNetworkSnapshots.push(protocolDAOShareKey, 0);\n    }\n\n    /// @notice Returns the current node share value\n    function getCurrentNodeShare() external override view returns (uint256) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        return _getCurrentShare(rocketNetworkSnapshots, nodeShareKey);\n    }\n\n    /// @notice Returns the current voter share value\n    function getCurrentVoterShare() external override view returns (uint256) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        return _getCurrentShare(rocketNetworkSnapshots, voterShareKey);\n    }\n\n    /// @notice Returns the current pDAO share value\n    function getCurrentProtocolDAOShare() external override view returns (uint256) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        return _getCurrentShare(rocketNetworkSnapshots, protocolDAOShareKey);\n    }\n\n    /// @notice Called by a pDAO governance contract or security council to update the `node_operator_commission_share` parameter\n    /// @param _newShare The value to set `node_operator_commission_share` to\n    function setNodeShare(uint256 _newShare) external override onlyProtocolOrSecurityDAO {\n        _setShare(nodeShareKey, _newShare);\n    }\n\n    /// @notice Called by a pDAO governance contract or security council to update the `voter_share` parameter\n    /// @param _newShare The value to set the `voter_share` to\n    function setVoterShare(uint256 _newShare) external override onlyProtocolOrSecurityDAO {\n        _setShare(voterShareKey, _newShare);\n    }\n\n    /// @notice Called by a pDAO governance contract or security council to update the `pdao_share` parameter\n    /// @param _newShare The value to set the `pdao_share` to\n    function setProtocolDAOShare(uint256 _newShare) external override onlyProtocolOrSecurityDAO {\n        _setShare(protocolDAOShareKey, _newShare);\n    }\n\n    /// @notice Calculates the time-weighted average revenue split values between the supplied block number and now\n    /// @param _sinceBlock The starting block number for the calculation\n    function calculateSplit(uint256 _sinceBlock) external override view returns (uint256 nodeShare, uint256 voterShare, uint256 protocolDAOShare, uint256 rethShare) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        if (_sinceBlock == block.number) {\n            nodeShare = _getCurrentShare(rocketNetworkSnapshots, nodeShareKey);\n            voterShare = _getCurrentShare(rocketNetworkSnapshots, voterShareKey);\n            protocolDAOShare = _getCurrentShare(rocketNetworkSnapshots, protocolDAOShareKey);\n        } else {\n            require(_sinceBlock < block.number, \"Block must be in the past\");\n            nodeShare = getAverageSince(rocketNetworkSnapshots, _sinceBlock, nodeShareKey);\n            voterShare = getAverageSince(rocketNetworkSnapshots, _sinceBlock, voterShareKey);\n            protocolDAOShare = getAverageSince(rocketNetworkSnapshots, _sinceBlock, protocolDAOShareKey);\n        }\n        uint256 rethCommission = nodeShare + voterShare + protocolDAOShare;\n        rethShare = 1 ether - rethCommission;\n        return (nodeShare, voterShare, protocolDAOShare, rethShare);\n    }\n\n    /// @notice Calculates the time-weighted average since a given block\n    function getAverageSince(RocketNetworkSnapshotsInterface _rocketNetworkSnapshots, uint256 _sinceBlock, bytes32 _key) internal view returns (uint256) {\n        (bool checkpointExists, uint32 checkpointBlock, uint224 checkpointValue) = _rocketNetworkSnapshots.latest(_key);\n        require(checkpointExists, \"RocketNetworkRevenues is not initialised\");\n        if (checkpointBlock <= _sinceBlock) {\n            // Value hasn't changed since _sinceBlock, so return current\n            bytes32 valueKey = bytes32(uint256(_key) + checkpointBlock);\n            return getUint(valueKey) * shareScale;\n        }\n        // Calculate the current accumulator value\n        bytes32 valueKey = bytes32(uint256(_key) + checkpointBlock);\n        uint256 valueAtBlock = getUint(valueKey);\n        uint256 blockDuration = (block.number - checkpointBlock);\n        uint256 currentAccum = uint256(checkpointValue) + (valueAtBlock * blockDuration);\n        // Calculate the accumulator at _sinceBlock\n        (checkpointExists, checkpointBlock, checkpointValue) = _rocketNetworkSnapshots.lookupCheckpoint(_key, uint32(_sinceBlock));\n        valueKey = bytes32(uint256(_key) + checkpointBlock);\n        valueAtBlock = getUint(valueKey);\n        blockDuration = (_sinceBlock - checkpointBlock);\n        uint256 pastAccum = uint256(checkpointValue) + (valueAtBlock * blockDuration);\n        // Calculate time-weighted average\n        uint256 duration = (block.number - _sinceBlock);\n        uint256 average = (currentAccum - pastAccum) / duration;\n        return average * shareScale;\n    }\n\n    /// @dev Calculates the cumulative value of the accumulator at a given block\n    function getAccumulatorAt(RocketNetworkSnapshotsInterface _rocketNetworkSnapshots, bytes32 _key, uint256 _block) internal view returns (uint256) {\n        (bool checkpointExists, uint32 checkpointBlock, uint224 checkpointValue) = _rocketNetworkSnapshots.lookupCheckpoint(_key, uint32(_block));\n        require(checkpointExists, \"RocketNetworkRevenues is not initialised\");\n        bytes32 valueKey = bytes32(uint256(_key) + checkpointBlock);\n        uint256 valueAtBlock = getUint(valueKey);\n        uint256 blockDuration = (_block - checkpointBlock);\n        return uint256(checkpointValue) + (valueAtBlock * blockDuration);\n    }\n\n    /// @dev Convenience method to return the current value given a key\n    function _getCurrentShare(RocketNetworkSnapshotsInterface _rocketNetworkSnapshots, bytes32 _key) internal view returns (uint256) {\n        (bool exists, uint32 blockNumber, ) = _rocketNetworkSnapshots.latest(_key);\n        require(exists, \"RocketNetworkRevenues is not initialised\");\n        bytes32 valueKey = bytes32(uint256(_key) + blockNumber);\n        return getUint(valueKey) * shareScale;\n    }\n\n    /// @dev Sets the share value of the given key\n    /// @param _key Key of the share value to set\n    /// @param _newShare Value to set it to\n    function _setShare(bytes32 _key, uint256 _newShare) internal {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        uint256 currentAccum = getAccumulatorAt(rocketNetworkSnapshots, _key, block.number);\n        rocketNetworkSnapshots.push(_key, uint224(currentAccum));\n        uint256 newShareScaled = _newShare / shareScale;\n        bytes32 valueKey = bytes32(uint256(_key) + block.number);\n        setUint(valueKey, newShareScaled);\n    }\n}\n"
    }
}