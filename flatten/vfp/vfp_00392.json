{
    "vfp_id": "vfp_00392",
    "project_name": "USDKG _ Consensys Diligence.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-184"
                ]
            },
            "title": "transferFrom() Lacks notBlackListed Modifier on the Spender msg.sender",
            "description": "The USDKG token implements a blacklist mechanism to restrict certain users from interacting with the token, enforced via the `notBlackListed` modifier on functions like `transfer()` and `transferFrom()`. However, in the `transferFrom()` function, the modifier only checks the `_from` address (the token owner) but not the `msg.sender` (the spender). This omission allows a malicious or compromised contract, once approved by a user, to execute `transferFrom()` even if it has been blacklisted. For example, an exploited lending protocol with USDKG approval could be used to drain user funds. By not checking the spender, the system cannot proactively block such contracts from acting as intermediaries in token transfers. This reduces the effectiveness of the blacklist mechanism and allows attackers to bypass restrictions by using vulnerable or malicious smart contracts as conduits.\n",
            "severity": "Medium",
            "location": [
                "contracts/USDKG.sol::transferFrom#122",
                "contracts/USDKG.sol::notBlackListed#86-92"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation for Parameters in the Constructor",
            "description": "The constructor of the `USDKG` contract accepts `_owner` and `_compliance` address parameters but does not validate that these addresses are non-zero. If either parameter is set to the zero address during deployment, critical administrative functions tied to these roles (such as pausing, issuing, redeeming, or blacklisting) will become permanently inoperable, as no account can assume those roles. This creates a single point of failure during deployment. A mistaken or malicious deployment with zero addresses would render the contract partially or fully unusable, leading to a permanent loss of control and governance functionality. This issue stems from the lack of input validation, a common best practice in smart contract development.\n",
            "severity": "Medium",
            "location": [
                "contracts/USDKG.sol::constructor#45-52"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small Amount Can Ignore Fee on Transfer",
            "description": "The USDKG token implements a fee-on-transfer mechanism using a `basisPointsRate` divided by a `FEE_PRECISION` constant of 10,000. However, because the fee is calculated as `(_value * basisPointsRate) / FEE_PRECISION`, small transfer amounts can result in a fee that rounds down to zero due to integer division truncation. For instance, if the product `_value * basisPointsRate` is less than 10,000, the fee becomes zero. This allows users to bypass the fee mechanism entirely by splitting large transfers into multiple small ones. While the client has acknowledged and accepted this risk, it remains a design flaw that undermines the intended economic model if fees are ever enabled. The impact is limited to revenue loss from fee evasion rather than direct fund loss.\n",
            "severity": "Low",
            "location": [
                "contracts/USDKG.sol::transfer#103-104",
                "contracts/USDKG.sol::transferFrom#122-128",
                "contracts/USDKG.sol::FEE_PRECISION#22"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Fee Basis Points Canâ€™t Reach the Maximum Unlike What Is Described in the Documentation",
            "description": "The project documentation states that the transfer fee can reach a maximum of 0.2%, but the on-chain implementation prevents this. The `MAX_BASIS_POINTS` constant is set to 20, and the `setParams` function enforces `newBasisPoints < MAX_BASIS_POINTS`, meaning the maximum allowed fee is strictly less than 20 basis points (i.e., less than 0.2%). This discrepancy between documentation and code can mislead users and administrators into believing a higher fee cap is possible. The inconsistency may stem from a misunderstanding during implementation or a failure to update documentation. While not a direct security vulnerability, it affects transparency and trust in the system's specifications.\n",
            "severity": "Low",
            "location": [
                "contracts/USDKG.sol::MAX_BASIS_POINTS#21",
                "contracts/USDKG.sol::setParams#216-223",
                "docs/USDKG.md?plain=1#L11"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Inaccurate Comments and Messages",
            "description": "The codebase contains several instances of incorrect or misleading comments and error messages. Examples include misspelling `keccak256` as `keccack`, using \"Now owner\" instead of \"Not owner\" in a require statement, and using a generic `onlyOwner` comment on a modifier named `onlyCompliance`. Additionally, references to \"Tether\" in comments are irrelevant since USDKG is not affiliated with Tether. These inaccuracies do not introduce direct security risks but reduce code readability, increase the risk of developer errors during maintenance, and may mislead auditors or contributors. They indicate a lack of code hygiene and attention to detail, which can indirectly affect long-term security and maintainability.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::transferToken#276-277",
                "contracts/Multisig.sol::owners#457",
                "contracts/USDKG.sol::onlyCompliance#62-65",
                "contracts/USDKG.sol::getBlackListStatus#248-249"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Use .call to Transfer Native Token Refund",
            "description": "The `handlePayment` function in the `Multisig.sol` contract uses `receiver.send(payment)` to refund ETH, which forwards only 2300 gas and may fail for contracts that require more gas to receive funds. The recommendation is to use `.call` instead, which forwards all available gas and is more compatible with modern smart contract wallets. This issue was previously addressed in the Gnosis Safe codebase (PRs 601 and 602), which this contract is based on. While `.send` is safe from reentrancy due to limited gas, it limits interoperability with contract receivers. Using `.call` improves compatibility without introducing reentrancy risks in this context, as the payment is made after the main logic and state changes.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::handlePayment#257-260"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Settle Solidity Version",
            "description": "The contracts `Multisig.sol` and `USDKG.sol` specify their Solidity version as `^0.8.0`, which allows compilation with any minor version in the 0.8.x series. This introduces unpredictability, as different compilers may produce different bytecode due to bug fixes or optimizations in newer versions. It also increases the risk of deploying with an untested compiler version. Best practice is to lock the version (e.g., `0.8.20`) to ensure deterministic builds and avoid potential issues from compiler regressions. This is especially important for audited contracts where the audit is based on a specific compilation output.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol#2",
                "contracts/USDKG.sol#2"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol",
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Inconsistent Transaction Execution Logic in Multisig Contract Deviates From Gnosis Safe and Documentation",
            "description": "The `execTransaction` function in `Multisig.sol` allows any external party to execute a transaction once it has sufficient approvals, unlike the original Gnosis Safe implementation, which restricts execution to the last approver. This deviation increases the attack surface by enabling front-running or censorship by third parties. It also contradicts the project's own documentation, which states \"The last signer initiates the transaction.\" This inconsistency could lead to unexpected behavior, reduced accountability, and potential denial-of-service if malicious actors block executions. The current design reduces trustworthiness and deviates from a well-audited standard, introducing unnecessary risk.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::execTransaction#382-437",
                "contracts/Multisig.sol::checkApprovals#146-171"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Variable and Functions",
            "description": "The `Multisig` contract contains several unused elements: the `data` parameter in `checkApprovals` and `checkNApprovals`, the `signedMessages` mapping, and the `signatureSplit` function. These elements contribute to code bloat, increase deployment cost, and add unnecessary complexity, making audits and maintenance harder. While they do not pose direct security risks, they violate code hygiene principles and may confuse developers. Removing dead code reduces the attack surface and improves clarity. The `signatureSplit` function, for example, is defined but not used anywhere in the contract.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::checkApprovals#146-171",
                "contracts/Multisig.sol::signedMessages#47",
                "contracts/Multisig.sol::signatureSplit#309-323"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        }
    ],
    "affected_files": {
        "Multisig.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract Multisig {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event ApproveHash(\n        bytes32 indexed approvedHash,\n        address indexed owner,\n        address to,\n        uint256 value,\n        bytes data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 nonce\n    );\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\n    event SafeReceived(address indexed sender, uint256 value);\n\n    uint256 public nonce;\n\n    mapping(address => address) internal owners;\n    uint256 internal immutable ownerCount;\n    uint256 internal immutable threshold;\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    // mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    constructor(address[] memory _owners, uint256 _threshold) {\n        // validate that threshold is smaller than number of added owners\n        require(_threshold <= _owners.length, \"Too big threshold\");\n        // there has to be at least one Safe owner\n        require(_threshold >= 1, \"Threshold can't be equal to zero\");\n        // initializing Safe owners\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // owner address cannot be null\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"Incorrect owner address\");\n            // no duplicate owners allowed\n            require(owners[owner] == address(0), \"Owners' addresses must not be repeated\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    ///////////////////////////////\n    /// VIEW FUNCTIONS\n    ///////////////////////////////\n\n    /**\n     * @notice returns the ID of the chain the contract is currently deployed on\n     * @return the ID of the current chain as a uint256\n     */\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * @dev returns the domain separator for this contract, as defined in the EIP-712 standard\n     * @return bytes32 the domain separator hash\n     */\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /**\n     * @notice returns the pre-image of the transaction hash (see getTransactionHash)\n     * @param to destination address\n     * @param value ether value\n     * @param data data payload\n     * @param operation operation type\n     * @param safeTxGas gas that should be used for the safe transaction\n     * @param baseGas gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice maximum gas price that should be used for this transaction\n     * @param gasToken token address (or 0 if ETH) that is used for the payment\n     * @param refundReceiver address of receiver of gas payment (or 0 if tx.origin)\n     * @param _nonce transaction nonce\n     * @return transaction hash bytes\n     */\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /**\n     * @notice checks whether the signature provided is valid for the provided data and hash. Reverts otherwise\n     * @param dataHash hash of the data (could be either a message hash or transaction hash)\n     * @param data that should be signed (this is passed to an external validator contract)\n     */\n    function checkApprovals(bytes32 dataHash, bytes memory data) public view {\n        // load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // check that a threshold is set\n        require(_threshold > 0, \"Threshold is not set\");\n        checkNApprovals(dataHash, data, _threshold);\n    }\n\n    /**\n     * @notice checks whether the signature provided is valid for the provided data and hash. Reverts otherwise\n     * @dev since the EIP-1271 does an external call, be mindful of reentrancy attacks\n     * @param dataHash hash of the data (could be either a message hash or transaction hash)\n     * @param data that should be signed (this is passed to an external validator contract)\n     * @param requiredSignatures amount of required valid signatures\n     */\n    function checkNApprovals(bytes32 dataHash, bytes memory data, uint256 requiredSignatures) public view {\n        uint256 count = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            if (approvedHashes[currentOwner][dataHash] != 0) {\n                count++;\n            }\n            currentOwner = owners[currentOwner];\n        }\n        require(count >= requiredSignatures, \"Not enough approvals\");\n    }\n\n    /**\n     * @notice returns transaction hash to be signed by owners\n     * @param to destination address\n     * @param value ether value\n     * @param data data payload\n     * @param operation operation type\n     * @param safeTxGas fas that should be used for the safe transaction\n     * @param baseGas gas costs for data used to trigger the safe transaction\n     * @param gasPrice maximum gas price that should be used for this transaction\n     * @param gasToken token address (or 0 if ETH) that is used for the payment\n     * @param refundReceiver address of receiver of gas payment (or 0 if tx.origin)\n     * @param _nonce transaction nonce\n     * @return transaction hash\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n\n    /**\n     * @notice returns the number of required confirmations for a Safe transaction aka the threshold\n     * @return threshold number\n     */\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    /**\n     * @notice returns if `owner` is an owner of the Safe\n     * @return boolean if owner is an owner of the Safe\n     */\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /**\n     * @notice returns a list of Safe owners\n     * @return array of Safe owners\n     */\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n\n    ///////////////////////////////\n    /// INTERNAL FUNCTIONS\n    ///////////////////////////////\n\n    /**\n     * @notice handles the payment for a Safe transaction\n     * @param gasUsed gas used by the Safe transaction\n     * @param baseGas gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice gas price that should be used for the payment calculation\n     * @param gasToken token address (or 0 if ETH) that is used for the payment\n     * @return payment The amount of payment made in the specified token\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // for ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"Error when paying a transaction in native currency\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Error when paying a transaction in token\");\n        }\n    }\n\n    /**\n     * @notice transfers a token and returns a boolean if it was a success\n     * @dev it checks the return data of the transfer call and returns true if the transfer was successful\n     *      it doesn't check if the `token` address is a contract or not\n     * @param token token that should be transferred\n     * @param receiver receiver to whom the token should be transferred\n     * @param amount the amount of tokens that should be transferred\n     * @return transferred Returns true if the transfer was successful\n     */\n    function transferToken(address token, address receiver, uint256 amount) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n            case 0 {\n                transferred := success\n            }\n            case 0x20 {\n                transferred := iszero(or(iszero(success), iszero(mload(0))))\n            }\n            default {\n                transferred := 0\n            }\n        }\n    }\n\n    /**\n     * @notice splits signature bytes into `uint8 v, bytes32 r, bytes32 s`\n     * @dev make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n     *      the signature format is a compact form of {bytes32 r}{bytes32 s}{uint8 v}\n     *      compact means uint8 is not padded to 32 bytes\n     * @param pos which signature to read\n     *            a prior bounds check of this parameter should be performed, to avoid out of bounds access\n     * @param signatures concatenated {r, s, v} signatures\n     * @return v Recovery ID or Safe signature type\n     * @return r Output value r of the signature\n     * @return s Output value s of the signature\n     */\n    function signatureSplit(bytes memory signatures, uint256 pos) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            /**\n             * here we are loading the last 32 bytes, including 31 bytes\n             * of 's'. There is no 'mload8' to do this\n             * 'byte' is not working due to the Solidity parser, so lets\n             * use the second best option, 'and'\n             */\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n\n    /**\n     * @notice executes either a delegatecall or a call with provided parameters\n     * @dev this method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      it is the responsibility of the caller to perform such checks\n     * @param to destination address\n     * @param value ether value\n     * @param data data payload\n     * @param operation operation type\n     * @return success boolean flag indicating if the call succeeded\n     */\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    ///////////////////////////////\n    /// PUBLIC FUNCTIONS\n    ///////////////////////////////\n\n    /** @notice executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`\n     * @dev the fees are always transferred, even if the user transaction fails\n     *      this method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      - if the `gasToken` is a contract or not\n     *      it is the responsibility of the caller to perform such checks\n     * @param to destination address of Safe transaction\n     * @param value ether value of Safe transaction\n     * @param data data payload of Safe transaction\n     * @param operation operation type of Safe transaction\n     * @param safeTxGas gas that should be used for the Safe transaction\n     * @param baseGas gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice gas price that should be used for the payment calculation\n     * @param gasToken token address (or 0 if ETH) that is used for the payment\n     * @param refundReceiver address of receiver of gas payment (or 0 if tx.origin)\n     * @return success Boolean indicating transaction's success\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // signature info\n                nonce\n            );\n            // increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkApprovals(txHash, txHashData);\n        }\n        // we require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // we also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((safeTxGas * 64) / 63, safeTxGas + 2500) + 500, \"Insufficient gas\");\n        // use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // if the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // we only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed - gasleft();\n            // if no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // this makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"Error during call\");\n            // we transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }\n\n    /**\n     * @notice marks hash `hashToApprove` as approved\n     * @dev this can be used with a pre-approved hash transaction signature\n     *      IMPORTANT: the approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\n     * @param hashToApprove the hash to mark as approved for signatures that are verified by this contract\n     */\n    function approveHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes32 hashToApprove\n    ) external {\n        require(owners[msg.sender] != address(0), \"Now owner\");\n\n        bytes32 txHash = getTransactionHash(\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            nonce\n        );\n        require(txHash == hashToApprove, \"Incorrect data to approve\");\n\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(\n            hashToApprove,\n            msg.sender,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            nonce\n        );\n    }\n\n    /**\n     * @dev performs a delegatecall on a targetContract in the context of self\n     * internally reverts execution to avoid side effects (making it static)\n     *\n     * this method reverts with data equal to `abi.encode(bool(success), bytes(response))`\n     * specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`\n     *\n     * @param targetContract address of the contract containing the code to execute\n     * @param calldataPayload calldata that should be sent to the target contract (encoded method name and arguments)\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n\n    /**\n     * @notice Receive function accepts native currency transactions.\n     * @dev Emits an event with sender and received value.\n     */\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}",
        "USDKG.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract USDKG is IERC20 {\n\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n\n    // ownable\n    address public owner;\n    address public compliance;\n\n    // ERC20 Basic\n    uint256 public _totalSupply;\n    mapping(address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    uint256 public constant MAX_BASIS_POINTS = 20;\n    uint256 public constant FEE_PRECISION = 10000;\n\n    // variables to manage optional transaction fees, if such functionality is enabled in the future\n    uint256 public basisPointsRate = 0;\n\n    // pausable\n    bool public paused = false;\n\n    // blacklist\n    mapping (address => bool) public isBlackListed;\n\n    event Pause();\n    event Unpause();\n    event DestroyedBlackFunds(address _blackListedUser, uint256 _balance);\n    event AddedBlackList(address _user);\n    event RemovedBlackList(address _user);\n    // called when new token are issued\n    event Issue(uint256 amount);\n    // called when tokens are redeemed\n    event Redeem(uint256 amount);\n    // called if contract ever adds fees\n    event Params(uint256 feeBasisPoints);\n\n    constructor (address _owner, address _compliance) {\n        owner = _owner;\n        compliance = _compliance;\n        _totalSupply = 0;\n        name = \"USDKG\";\n        symbol = \"USDKG\";\n        decimals = 6;\n    }\n\n    /**\n      * @dev Throws if called by any account other than the owner.\n      */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    /**\n      * @dev Throws if called by any account other than the owner.\n      */\n    modifier onlyCompliance() {\n        require(msg.sender == compliance, \"not compliance\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused, \"not paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when sender is not blacklisted.\n     */\n    modifier notBlackListed(address sender) {\n        require(!isBlackListed[sender], \"user blacklisted\");\n        _;\n    }\n\n    ////////////////////////\n    // PUBLIC FUNCTIONS\n    ////////////////////////\n\n    /**\n    * @dev transfer token for a specified address\n    * @param _to The address to transfer to\n    * @param _value The amount to be transferred\n    */\n    function transfer(address _to, uint256 _value) public whenNotPaused notBlackListed(msg.sender) returns (bool) {\n        uint256 fee = _value * basisPointsRate / FEE_PRECISION;\n        uint256 sendAmount = _value - fee;\n        balances[msg.sender] = balances[msg.sender] - _value;\n        balances[_to] = balances[_to] + sendAmount;\n        if (fee > 0) {\n            balances[owner] = balances[owner] + fee;\n            emit Transfer(msg.sender, owner, fee);\n        }\n        emit Transfer(msg.sender, _to, sendAmount);\n        return true;\n    }\n\n    /**\n    * @dev transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notBlackListed(_from) returns (bool) {\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        // check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n        // if (_value > _allowance) throw;\n\n        uint256 fee = _value * basisPointsRate / FEE_PRECISION;\n        if (_allowance < type(uint256).max) {\n            allowed[_from][msg.sender] = _allowance - _value;\n        }\n        uint256 sendAmount = _value - fee;\n        balances[_from] = balances[_from] - _value;\n        balances[_to] = balances[_to] + sendAmount;\n        if (fee > 0) {\n            balances[owner] = balances[owner] + fee;\n            emit Transfer(_from, owner, fee);\n        }\n        emit Transfer(_from, _to, sendAmount);\n        return true;\n    }\n\n    /**\n    * @dev approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n    * @param _spender the address which will spend the funds\n    * @param _value the amount of tokens to be spent\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(msg.sender != address(0), \"caller can't be zero address\");\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    ////////////////////////\n    // SERVICE FUNCTIONS\n    ////////////////////////\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n    function addBlackList (address _evilUser) public onlyCompliance {\n        isBlackListed[_evilUser] = true;\n        emit AddedBlackList(_evilUser);\n    }\n\n    function removeBlackList (address _clearedUser) public onlyCompliance {\n        isBlackListed[_clearedUser] = false;\n        emit RemovedBlackList(_clearedUser);\n    }\n\n    function destroyBlackFunds (address _blackListedUser) public onlyCompliance {\n        require(isBlackListed[_blackListedUser], \"user should be blacklisted\");\n        uint256 dirtyFunds = balanceOf(_blackListedUser);\n        balances[_blackListedUser] = 0;\n        _totalSupply -= dirtyFunds;\n        emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);\n    }\n\n    // issue a new amount of tokens\n    // @param _amount number of tokens to be issued\n    // @param _to address of tokens receiver\n    function issue(address _to, uint256 amount) public onlyOwner {\n        balances[_to] += amount;\n        _totalSupply += amount;\n        emit Issue(amount);\n    }\n\n    // redeem tokens\n    // these tokens are withdrawn from the owner address\n    // if the balance must be enough to cover the redeem\n    // or the call will fail\n    // @param _amount number of tokens to be burnt\n    function redeem(uint256 amount) public onlyOwner {\n        require(_totalSupply >= amount, \"not enough tokens to redeem\");\n        require(balances[owner] >= amount, \"not enough tokens to redeem\");\n\n        _totalSupply -= amount;\n        balances[owner] -= amount;\n        emit Redeem(amount);\n    }\n\n    function setParams(uint256 newBasisPoints) public onlyOwner {\n        // ensure transparency by hardcoding limit beyond which fees can never be added\n        require(newBasisPoints < MAX_BASIS_POINTS, \"basis points should be less then MAX_BASIS_POINTS\");\n\n        basisPointsRate = newBasisPoints;\n\n        emit Params(basisPointsRate);\n    }\n\n    ////////////////////////\n    // VIEW FUNCTIONS\n    ////////////////////////\n\n    /**\n    * @dev gets the balance of the specified address\n    * @param _owner the address to query the the balance of\n    * @return balance An uint256 representing the amount owned by the passed address\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n    * @dev function to check the amount of tokens than an owner allowed to a spender\n    * @param _owner address the address which owns the funds\n    * @param _spender address the address which will spend the funds\n    * @return remaining a uint256 specifying the amount of tokens still available for the spender\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    // getters to allow the same blacklist to be used also by other contracts (including upgraded Tether)\n    function getBlackListStatus(address _maker) external view returns (bool) {\n        return isBlackListed[_maker];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n}"
    }
}