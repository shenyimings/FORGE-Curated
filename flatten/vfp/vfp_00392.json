{
    "vfp_id": "vfp_00392",
    "project_name": "cantina_horizen_april2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Faulty batchInsert calls in EONBackupVault and ZendBackupVault could lead to irrecoverable state",
            "description": "The batchInsert() function in both EONBackupVault.sol and ZendBackupVault.sol lacks safeguards against invalid data insertion. Although only callable by the owner, the function does not check for duplicate address entries, which could overwrite existing balances or cause inconsistent state. Additionally, there is no validation to ensure that the total amount of tokens to be minted stays within the ZenToken's hard cap of 21,000,000 tokens, risking supply cap violations. The root cause is the absence of input validation and preconditions in the batchInsert function. If exploited through operator error or malicious intent, this could lead to an irrecoverable contract state, incorrect token distribution, or inflation beyond the intended supply.\n",
            "severity": "Low",
            "location": [
                "EONBackupVault.sol#L63",
                "ZendBackupVault.sol#L94"
            ],
            "files": [
                "horizen-migration/erc20-migration/contracts/EONBackupVault.sol",
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Possible replay attack risk in ZendBackupVault",
            "description": "The createMessageHash() function in ZendBackupVault does not include chain-specific context such as chain ID or contract address in the signed message, making signatures susceptible to replay attacks across different chains. Specifically, a signature valid on the original chain could be replayed on a forked chain, and testnet transactions could be replayed on mainnet if not properly isolated. The root cause is the lack of domain separation in the message hash construction. This could allow an attacker to claim tokens on the wrong network using a valid signature from another, potentially leading to loss of funds if the destAddress differs between chains.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ]
            },
            "title": "Optimization in ZendBackupVault claims functions",
            "description": "The _verifyPubKeysFromScript function in ZendBackupVault performs inefficient memory operations during public key verification. It loads a 32-byte word starting 31 bytes before the actual signature, relying on the current script layout where the compressed key prefix (0x02/0x03) happens to align with the end of that word. This is fragile and suboptimal. The root cause is poor low-level memory access design. While not a direct security vulnerability, it increases gas costs and introduces fragility—if the script layout changes, the function could break. The impact is higher transaction costs and potential future bugs.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "The distribute of ZEN in the EON vault should not be capped to 500",
            "description": "The distribute function in EONBackupVault enforces a hardcoded limit of 500 addresses per call, which may be insufficient for large-scale distributions. The root cause is the use of a magic number instead of a configurable parameter. This could force multiple transactions to complete a distribution, increasing gas costs and operational complexity. Allowing the owner to specify a maxCount parameter would provide flexibility and efficiency.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/EONBackupVault.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Add zenToken check to moreToDistribute() function",
            "description": "The moreToDistribute() function in EONBackupVault does not check whether the zenToken address has been set (i.e., != address(0)), unlike the distribute() function, which reverts if it is not. This inconsistency means moreToDistribute() could return true indicating funds are available to distribute, but a subsequent call to distribute() would revert. The root cause is a missing validation check. This could lead to incorrect state assumptions in off-chain systems or user interfaces, causing confusion and failed transactions.\n",
            "severity": "Informational",
            "location": [
                "EONBackupVault.sol#L115"
            ],
            "files": [
                "horizen-migration/erc20-migration/contracts/EONBackupVault.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Merkle Trees could be used instead of batch insert in the ZendBackupVault",
            "description": "The ZendBackupVault currently uses on-chain batchInsert to register all user balances, which is gas-intensive. A more efficient approach would be to use a Merkle tree, where only the root is stored on-chain, and users provide Merkle proofs to claim their tokens. The root cause is the use of a naive data commitment strategy. While not a vulnerability, this represents a scalability limitation. Adopting Merkle trees would reduce deployment costs and improve efficiency, especially for large user bases.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "S-malleability in the claiming process",
            "description": "The claimP2PKH and claimP2SH functions in ZendBackupVault accept ECDSA signatures without enforcing low-S normalization. While this does not currently enable fund theft—because balances are set to zero after the first claim and the message commits to destAddress—it violates best practices. The root cause is incomplete signature validation. In other contexts, high-S signatures could lead to replay or malleability issues. For future-proofing and consistency with security standards, signatures should be validated to ensure S ≤ N/2.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        }
    ],
    "affected_files": {
        "EONBackupVault.sol": "// SPDX-License-Identifier: MIT \npragma solidity ^0.8.0;\n\nimport \"./interfaces/IZenToken.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title EONBackupVault\n/// @notice This contract is used to store balances from old EON chain, and, once all are loaded, distribute corresponding ZEN in the new chain.\n///         In the constructor will receive an admin address (owner), the only entity authorized to perform operations. Before loading all the accounts,\n//          the cumulative hash calculated with all the accounts dump data must be set.\n///         \ncontract EONBackupVault is Ownable {\n\n    struct AddressValue {\n        address addr;\n        uint256 value;\n    }\n    \n    // Map of the balances\n    mapping(address => uint256) public balances;\n    \n    // Array to track inserted addresses\n    address[] private addressList;\n    \n    // Cumulative Hash calculated\n    bytes32 public _cumulativeHash;\n\n    // Final expected Cumulative Hash, used for checkpoint, to unlock distribution\n    bytes32 public cumulativeHashCheckpoint;      \n  \n    // Tracks rewarded addresses (index to next address to reward)\n    uint256 private nextRewardIndex;\n\n    IZenToken public zenToken;\n\n    error AddressNotValid();\n    error CumulativeHashNotValid();\n    error CumulativeHashCheckpointReached();\n    error CumulativeHashCheckpointNotSet();\n    error UnauthorizedOperation();\n    error ERC20NotSet();\n    error NothingToDistribute();\n\n\n    /// @notice Smart contract constructor\n    /// @param _admin  the only entity authorized to perform restore and distribution operations\n    constructor(address _admin) Ownable(_admin) {   \n    }\n\n    /// @notice Set expected cumulative hash after all the data has been loaded\n    /// @param _cumulativeHashCheckpoint  a cumulative recursive hash calculated with all the dump data.\n    ///                                   Will be used to verify the consistency of the restored data, and as\n    ///                                   a checkpoint to understand when all the data has been loaded and the distribution \n    ///                                   can start\n    function setCumulativeHashCheckpoint(bytes32 _cumulativeHashCheckpoint) public onlyOwner {\n        if(_cumulativeHashCheckpoint == bytes32(0)) revert CumulativeHashNotValid();  \n        if (cumulativeHashCheckpoint != bytes32(0)) revert UnauthorizedOperation();  //already set\n        cumulativeHashCheckpoint = _cumulativeHashCheckpoint;\n    }\n\n    /// @notice Insert a new batch of tuples (address, value) and updates the cumulative hash.\n    ///         To guarantee the same algorithm is applied, the expected cumulativeHash after the batch processing must be provided explicitly\n    function batchInsert(bytes32 expectedCumulativeHash, AddressValue[] memory addressValues) public onlyOwner {\n        if (cumulativeHashCheckpoint == bytes32(0)) revert CumulativeHashCheckpointNotSet();  \n        if(_cumulativeHash == cumulativeHashCheckpoint) revert CumulativeHashCheckpointReached();\n        uint256 i;\n        bytes32 auxHash = _cumulativeHash;\n        while (i != addressValues.length) {\n            balances[addressValues[i].addr] = addressValues[i].value;\n            addressList.push(addressValues[i].addr);\n            auxHash = keccak256(abi.encode(auxHash, addressValues[i].addr, addressValues[i].value));\n            unchecked { ++i; }\n        }\n        _cumulativeHash = auxHash;\n        if (expectedCumulativeHash != _cumulativeHash) revert CumulativeHashNotValid();   \n    }\n\n    /// @notice Set official ZEN ERC-20 smart contract that will be used for minting\n    function setERC20(address addr) public onlyOwner {  \n        if (address(zenToken) != address(0)) revert UnauthorizedOperation();  //ERC-20 address already set\n        if(addr == address(0)) revert AddressNotValid();\n        zenToken = IZenToken(addr);\n    }\n    \n    /// @notice Distribute ZEN for the next (max) \"maxCount\" addresses, until we have reached the end of the list\n    ///         Can be executed only when we have reached the planned cumulativeHashCheckpoint (meaning all data has been loaded)\n    function distribute(uint256 maxCount) public onlyOwner {\n        if (cumulativeHashCheckpoint == bytes32(0)) revert CumulativeHashCheckpointNotSet();  \n        if (address(zenToken) == address(0)) revert ERC20NotSet();\n        if (_cumulativeHash != cumulativeHashCheckpoint) revert CumulativeHashNotValid(); //Loaded data not matching - distribution locked\n        if (nextRewardIndex == addressList.length) revert NothingToDistribute();        \n\n        uint256 count = 0;\n        uint256 _nextRewardIndex = nextRewardIndex;\n        while (_nextRewardIndex != addressList.length && count != maxCount) {\n            address addr = addressList[_nextRewardIndex];      \n            uint256 amount = balances[addr];\n            if (amount > 0) {                \n                balances[addr] = 0;\n                zenToken.mint(addr, amount);\n            }\n            unchecked { \n                ++_nextRewardIndex;\n                ++count;\n            }\n        }\n        nextRewardIndex = _nextRewardIndex;\n        if (nextRewardIndex == addressList.length){\n            zenToken.notifyMintingDone();\n        }\n    }\n\n    /// @notice Return true if admin is able to distribute more\n    function moreToDistribute() public view  returns (bool) { \n        return (address(zenToken) != address(0)) && \n               (_cumulativeHash != bytes32(0)) &&\n               _cumulativeHash == cumulativeHashCheckpoint && \n               nextRewardIndex <  addressList.length;\n    }\n}",
        "ZendBackupVault.sol": "// SPDX-License-Identifier: MIT \npragma solidity ^0.8.0;\n\nimport {VerificationLibrary} from  './VerificationLibrary.sol';\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./VerificationLibrary.sol\";\nimport \"./interfaces/IZenToken.sol\";\n\n/// @title ZendBackupVault\n/// @notice This contract is used to store balances from old ZEND Mainchain, and, once all are loaded, it allows manual claiming in the new chain.\n///         In the constructor will receive an admin address (owner), the only entity authorized to perform load operations. Before loading all the accounts,\n//          the cumulative hash calculated with all the accounts dump data must be set.\ncontract ZendBackupVault is Ownable {\n    uint256 constant HORIZEN_UNCOMPRESSED_PUBLIC_KEY_LENGTH = 65;\n    uint256 constant HORIZEN_COMPRESSED_PUBLIC_KEY_LENGTH = 33;\n\n    struct AddressValue {\n        bytes20 addr;\n        uint256 value;\n    }\n\n    struct PubKey {\n        bytes32 x;\n        bytes32 y;\n    }\n    \n    // Map of the claimable balances.\n    // The key is the zendAddress in bs58 decoded format\n    mapping(bytes20 => uint256) public balances;\n       \n    // Cumulative Hash calculated\n    bytes32 public _cumulativeHash;\n\n    // Final expected Cumulative Hash, used for checkpoint, to unlock claim\n    bytes32 public cumulativeHashCheckpoint;\n\n    IZenToken public zenToken;\n\n    string private MESSAGE_CONSTANT;\n    /// First part of the message to sign, needed for zen claim operation. It is composed by the token symbol + MESSAGE_CONSTANT\n    string public message_prefix;\n\n    error AddressNotValid();\n    error CumulativeHashNotValid();\n    error CumulativeHashCheckpointReached();\n    error CumulativeHashCheckpointNotSet();\n    error UnauthorizedOperation();\n    error ERC20NotSet();\n    error NothingToClaim(bytes20 zenAddress);\n    error InsufficientSignatures(uint256 number, uint256 required);\n    error InvalidSignatureArrayLength();\n    error InvalidPublicKeysArraysLength();\n    error TooManySignatures();\n    error InvalidScriptLength();\n    error InvalidPublicKeySize(uint256 size);\n    error UnexpectedZeroPublicKey(PubKey);\n    error InvalidPublicKey(uint256 index, uint256 xOrY, bytes32 expected, bytes32 received);\n    error InvalidDirectMultisigScript(uint256 requiredSignaturesInScript, uint256 totalSignaturesInScript);\n\n    event Claimed(address indexed claimer, address indexed destAddress, bytes20 zenAddress, uint256 amount);\n\n    /// @notice verify if we are in the state in which users can already claim\n    modifier canClaim(address destAddress) {\n        if (_cumulativeHash != cumulativeHashCheckpoint) revert CumulativeHashNotValid(); //Loaded data not matching - distribution locked \n        if (address(zenToken) == address(0)) revert ERC20NotSet();\n        if (address(destAddress) == address(0)) revert AddressNotValid();\n        if (cumulativeHashCheckpoint == bytes32(0)) revert CumulativeHashCheckpointNotSet();\n        _;\n    }\n\n    /// @notice Smart contract constructor\n    /// @param _admin the only entity authorized to perform restore operations\n    /// @param base_message one of the parts of the message to sign for zen claim\n    constructor(address _admin, string memory base_message) Ownable(_admin) {\n        MESSAGE_CONSTANT = base_message;\n    }\n\n    /// @notice Set expected cumulative hash after all the data has been loaded\n    /// @param _cumulativeHashCheckpoint  a cumulative recursive hash calculated with all the dump data.\n    ///                                   Will be used to verify the consistency of the restored data, and as\n    ///                                   a checkpoint to understand when all the data has been loaded and the claim \n    ///                                   can start\n    function setCumulativeHashCheckpoint(bytes32 _cumulativeHashCheckpoint) public onlyOwner{\n        if(_cumulativeHashCheckpoint == bytes32(0)) revert CumulativeHashNotValid();  \n        if (cumulativeHashCheckpoint != bytes32(0)) revert UnauthorizedOperation();  //already set\n        cumulativeHashCheckpoint = _cumulativeHashCheckpoint;\n    }\n\n    /// @notice Insert a new batch of account tuples (bytes20, value) and updates the cumulative hash. The total balance of all accounts is minted and assigned to Zend Vault contract.\n    ///         The zend addresses are in bs58 decoded format, without prefix and checksum.\n    ///         To guarantee the same algorithm is applied, the expected cumulativeHash after the batch processing must be provided explicitly\n    /// @param expectedCumulativeHash  the cumulative recursive hash calculated with all the data already inserted plus the current batch.\n    /// @param addressValues new accounts batch to insert \n    function batchInsert(bytes32 expectedCumulativeHash, AddressValue[] calldata addressValues) public onlyOwner {\n        if (cumulativeHashCheckpoint == bytes32(0)) revert CumulativeHashCheckpointNotSet();  \n        if (address(zenToken) == address(0)) revert ERC20NotSet();\n        if (_cumulativeHash == cumulativeHashCheckpoint) revert CumulativeHashCheckpointReached();\n\n        uint256 i;\n        bytes32 auxHash = _cumulativeHash;\n        uint256 cumulativeBalance;\n        while (i != addressValues.length) {\n            balances[addressValues[i].addr] = addressValues[i].value;\n            auxHash = keccak256(abi.encode(auxHash, addressValues[i].addr, addressValues[i].value));\n            unchecked {cumulativeBalance = cumulativeBalance + addressValues[i].value; }\n            unchecked { ++i; }\n        }\n        _cumulativeHash = auxHash;\n        if (expectedCumulativeHash != _cumulativeHash) revert CumulativeHashNotValid();   \n        zenToken.mint(address(this), cumulativeBalance);\n\n        if (cumulativeHashCheckpoint == _cumulativeHash){\n            zenToken.notifyMintingDone();\n        }\n    }\n\n    /// @notice Set official ZEN ERC-20 smart contract that will be used for minting\n    function setERC20(address addr) public onlyOwner {\n        if (address(zenToken) != address(0)) revert UnauthorizedOperation();  //ERC-20 address already set\n        if(addr == address(0)) revert AddressNotValid();\n        zenToken = IZenToken(addr);\n        message_prefix = string(abi.encodePacked(zenToken.symbol(), MESSAGE_CONSTANT));\n\n    }\n\n    /// @notice Internal claim function, to reuse the code between P2PKH and P2PSH\n    function _claim(address destAddress, bytes20 zenAddress) internal {\n        uint256 amount = balances[zenAddress];\n        \n        balances[zenAddress] = 0;\n        zenToken.transfer(destAddress, amount);\n        emit Claimed(msg.sender, destAddress, zenAddress, amount);\n    }\n\n    /// @notice Claim a P2PKH balance.\n    /// @param  destAddress is the receiver of the funds\n    /// @param  hexSignature is the signature of the claiming message. Must be generated in a compressed format to claim a zend address\n    ///         generated with the public key in compressed format, or uncompressed otherwise.\n    ///         (Claiming message is predefined and composed by the concatenation of the message_prefix (token symbol + MESSAGE_CONSTANT) and the destination address in EIP-55 format (https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md) string)\n    /// @param  pubKey are the first 32 bytes and second 32 bytes of the signing key (we use always the uncompressed format here)\n    ///         Note: we pass the pubkey explicitly because the extraction from the signature would be GAS expensive.\n    function claimP2PKH(address destAddress, bytes memory hexSignature, PubKey calldata pubKey) public canClaim(destAddress) {\n        VerificationLibrary.Signature memory signature = VerificationLibrary.parseZendSignature(hexSignature);\n        bytes20 zenAddress;\n        if (signature.v == 31 || signature.v == 32){\n            //signature was compressed, also the zen address will be from the compressed format\n             zenAddress = VerificationLibrary.pubKeyCompressedToZenAddress(pubKey.x, VerificationLibrary.signByte(pubKey.y));\n        } else {\n             zenAddress = VerificationLibrary.pubKeyUncompressedToZenAddress(pubKey.x, pubKey.y);\n        }\n        //check amount to claim\n        uint256 amount = balances[zenAddress];\n        if (amount == 0) revert NothingToClaim(zenAddress);\n\n        //address in signed message should respect EIP-55 format (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md)\n        string memory asString = Strings.toChecksumHexString(destAddress);\n        string memory strMessageToSign = string(abi.encodePacked(message_prefix, asString));\n        bytes32 messageHash = VerificationLibrary.createMessageHash(strMessageToSign);\n        VerificationLibrary.verifyZendSignature(messageHash, signature, pubKey.x, pubKey.y);\n\n        _claim(destAddress, zenAddress);\n    }\n\n    /// @notice Direct claim of special UTXOs generated deterministically from a BaseAddress. \n    ///         This is a special usecase for users that can't sign a message, and requires they create this special UTXO in the old mainchain before the migration.\n    ///          Check documentation for details.\n    /// @param  baseDestAddress is the receiver of the funds. The zend address will be calculated from this one.\n    function claimDirect(address baseDestAddress) public canClaim(baseDestAddress) {\n        bytes memory addressToBytes = abi.encodePacked(baseDestAddress);\n        bytes20 zenAddress = _extractZenAddressFromScriptOrDestAddress(addressToBytes);\n\n        //check amount to claim\n        uint256 amount = balances[zenAddress];\n        if (amount == 0) revert NothingToClaim(zenAddress);\n\n        _claim(baseDestAddress, zenAddress);\n    }\n    \n    /// @notice Claim a P2SH balance.\n    ///         destAddress is the receiver of the funds\n    ///         hexSignatures is the array of the signatures of the claiming message. If a signature is not present, signature MUST be 0\n\n    ///         IMPORTANT: the array should have as length the number of public keys in the script. The signature in the \"i\" position should be the signature for the \"i\"\n    ///         pub key in the order it appears in the script. If the signature is not present for that key, it should be empty.\n    ///         This is to avoid duplicated signatures without expensive checks.\n    ///         \n    ///         script is the script to claim, from which pubKeys will be extracted\n    ///         pubKeysX and pubKeysY are the first 32 bytes and second 32 bytes of the signing keys for each one in the script (we use always the uncompressed format here)\n    ///         If a public key is not needed (because signature is zero) its value can be zero; even if not needed, if it is present, it should be the same used for the script\n    ///         (Claiming message is predefined and composed by the string in the message_prefix variable concatenated with the zenAddress and destAddress in lowercase string hex format)\n    ///         (zenAddress is the string representation with 0x prefix )\n    function claimP2SH(address destAddress, bytes[] calldata hexSignatures, bytes memory script, PubKey[] calldata pubKeys) public canClaim(destAddress) {\n        if(hexSignatures.length != pubKeys.length) revert InvalidSignatureArrayLength(); //check method doc\n        if(hexSignatures.length > 16) revert TooManySignatures(); //ZEND multisig scripts support up to 16 signatures\n\n        bytes20 zenAddress = _extractZenAddressFromScriptOrDestAddress(script);\n        //check amount to claim\n        if (balances[zenAddress] == 0) revert NothingToClaim(zenAddress);\n        uint256 minSignatures = uint256(uint8(script[0])) - 80;\n\n        _verifyPubKeysFromScript(script, pubKeys);\n\n        //address in signed message should respect EIP-55 format (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md)\n        string memory destAddressAsString = Strings.toChecksumHexString(destAddress);\n        string memory zenAddressAsString = Strings.toHexString(address(zenAddress));\n        string memory strMessageToSign = string(abi.encodePacked(message_prefix, zenAddressAsString, destAddressAsString));\n        bytes32 messageHash = VerificationLibrary.createMessageHash(strMessageToSign);\n\n        //check signatures\n        uint256 validSignatures;\n        uint256 i;\n        while(i != hexSignatures.length && validSignatures < minSignatures) {\n            if(hexSignatures[i].length != 0) { // skip otherwise\n                if(pubKeys[i].x == bytes32(0) || pubKeys[i].y == bytes32(0)) revert UnexpectedZeroPublicKey(pubKeys[i]);\n                else {\n                    VerificationLibrary.Signature memory signature = VerificationLibrary.parseZendSignature(hexSignatures[i]);\n                    //check doc: we suppose the signature in i position belonging to the pub key in i position in the script\n                    if(VerificationLibrary.verifyZendSignatureBool(messageHash, signature, pubKeys[i].x, pubKeys[i].y)) {\n                        unchecked { ++validSignatures; }\n                    }\n                }\n            }\n            unchecked { ++i; }\n        }\n\n        if(validSignatures < minSignatures) revert InsufficientSignatures(validSignatures, minSignatures); //insufficient signatures\n\n        _claim(destAddress, zenAddress);\n    }\n\n    /// @notice Direct claim of special UTXOs to a multisignature partially generated deterministically from a BaseAddress. \n    ///         This is a special usecase for users that can't sign a message, and requires they create this special UTXO in the old mainchain before the migration.\n    ///          Check documentation for details.\n    /// @param  script is the redeem script for the multisig wallet.\n    /// @param  baseDestAddress is the receiver of the funds. The zend address will be calculated from this one.\n    function claimDirectMultisig(bytes memory script, address baseDestAddress) public canClaim(baseDestAddress) {\n        //check amount to claim\n        bytes20 zenAddress = _extractZenAddressFromScriptOrDestAddress(script);\n        uint256 amount = balances[zenAddress];\n        if (amount == 0) revert NothingToClaim(zenAddress);\n\n        //generate derivative pub key from base address\n        bytes memory baseAddressToBytes = abi.encodePacked(baseDestAddress);\n        bytes32 pubKeyXFromBaseAddress = sha256(baseAddressToBytes);\n\n        //check is multisig 1 of 2\n        uint256 minSignatures = uint256(uint8(script[0])) - 80;\n        uint256 total = uint256(uint8(script[script.length - 2])) - 80;\n        if(minSignatures != 1 || total != 2) revert InvalidDirectMultisigScript(minSignatures, total);\n\n        //extract second key \"x\" from script\n        uint256 firstPubKeySize = uint256(uint8(script[1]));\n        uint256 start = firstPubKeySize + 4; //skip first OP (+1), skip size of first key (+1), first key (firstPubKeySize), size of second key (+1) and prefix of second key (+1)\n        bytes32 key = _extractBytes32FromBytes(script, start);\n\n        if(pubKeyXFromBaseAddress != key) revert InvalidPublicKey(1, 0, key, pubKeyXFromBaseAddress);\n\n        _claim(baseDestAddress, zenAddress);\n    }\n\n    /// @notice verify public keys from multisignature script\n    function _verifyPubKeysFromScript(bytes memory script, PubKey[] calldata pubKeys) internal pure {\n        if(script.length < 2) revert InvalidScriptLength();\n        uint256 total = uint256(uint8(script[script.length - 2])) - 80;\n\n        if(pubKeys.length != total) revert InvalidPublicKeysArraysLength();\n        uint256 pos = 1;\n\n        uint256 i;\n        while(i < total) {\n            uint256 nextPubKeySize = uint256(uint8(script[pos]));\n            unchecked { ++pos; }\n\n            if(nextPubKeySize != HORIZEN_COMPRESSED_PUBLIC_KEY_LENGTH && nextPubKeySize != HORIZEN_UNCOMPRESSED_PUBLIC_KEY_LENGTH) revert InvalidPublicKeySize(nextPubKeySize);\n            \n            if(pubKeys[i].x != 0 && pubKeys[i].y != 0) { //we check pub keys only if both x and y are != 0 \n                //extract key\n                //first 32 bytes\n                uint256 firstPartStart = pos+1;\n                bytes32 firstPart = _extractBytes32FromBytes(script, firstPartStart);\n\n                if(pubKeys[i].x != firstPart) revert InvalidPublicKey(i, 0, firstPart, pubKeys[i].x);\n\n                //second part\n                if(nextPubKeySize == HORIZEN_UNCOMPRESSED_PUBLIC_KEY_LENGTH) { //uncompressed case\n                    uint256 secondPartStart = pos + 33;\n                    bytes32 secondPart = _extractBytes32FromBytes(script, secondPartStart);\n                    \n                    if(pubKeys[i].y != secondPart) revert InvalidPublicKey(i, 1, secondPart, pubKeys[i].y);\n                }\n                else { //in compressed case, we just check sign\n                    uint8 sign;\n                    assembly {\n                        let offset := add(add(script, 0x20), pos) // data start + pos\n                        sign := byte(0, mload(offset))            // take the LS byte\n                    }\n                    uint8 ySign = VerificationLibrary.signByte(pubKeys[i].y);\n                    if(sign != ySign) revert InvalidPublicKey(i, 1, bytes32(uint256(sign)), bytes32(uint256(ySign)));\n                }\n            }\n\n            pos += nextPubKeySize;\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice extract zen address from multisignature script or address (direct claim)\n    function _extractZenAddressFromScriptOrDestAddress(bytes memory script) internal pure returns(bytes20) {\n        bytes32 scriptHash = sha256(script);\n        scriptHash = ripemd160(abi.encode(scriptHash));\n        return bytes20(scriptHash); \n    }\n\n    /// @notice extract a bytes32 object from a bytes object starting from the given position\n    function _extractBytes32FromBytes(bytes memory script, uint256 start) internal pure returns(bytes32) {\n        bytes32 ret;\n        assembly {\n            let sourcePtr := add(script, 0x20)\n            let offset := add(sourcePtr, start)\n            ret := mload(offset)\n        }\n        return ret;\n    }\n}\n"
    }
}