{
    "vfp_id": "vfp_00139",
    "project_name": "2025-01-beethovenx-sonicstaking-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Global pause method will fail if a subcomponent is already paused",
            "description": "The internal pause methods in the SonicStaking contract, such as _setUndelegatePaused, revert when attempting to set a pause flag to its current value due to a require statement that checks for a change in the pause state. This design causes the global pause function to fail if any of its targeted subcomponents (e.g., undelegate, withdraw) are already paused. The root cause is the placement of the require check inside internal functions that are called by the global pause method, which prevents idempotent behavior. An attacker or operational error could trigger a scenario where a partial pause is already in place, and a subsequent attempt to fully pause the system during an emergency fails. This could delay or prevent a proper incident response, leaving the system exposed during a critical period, thus undermining the reliability of the emergency pause mechanism.\n",
            "severity": "Low",
            "location": [
                "src/SonicStaking.sol::setUndelegatePaused",
                "src/SonicStaking.sol::pause"
            ],
            "files": [
                "sonic-staking/src/SonicStaking.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Risk of read-only reentrancy via Balancer pools",
            "description": "The internal _withdraw function transfers native tokens to a user-controlled address before emitting the Withdrawn event, and during the external call, the recipient can invoke a Balancer pool that reads the current rate via the getRate method. Although the contract has reentrancy guards for state-modifying functions, the getRate method is unprotected and can be called during the withdrawal, leading to out-of-order event emissions. The root cause is the lack of reentrancy protection on a read-only function that is indirectly exposed during a sensitive state transition. An attacker could exploit this by deploying a contract that withdraws funds and then calls a Balancer pool, causing the getRate call to emit events before the Withdrawn event. Off-chain monitoring tools that rely on event ordering may misinterpret the sequence, leading to incorrect state tracking or failed automated responses, potentially disrupting operational integrity and incident detection.\n",
            "severity": "Informational",
            "location": [
                "src/SonicStaking.sol::withdraw",
                "src/SonicStaking.sol::getRate"
            ],
            "files": [
                "sonic-staking/src/SonicStaking.sol"
            ]
        }
    ],
    "affected_files": {
        "SonicStaking.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {ISFC} from \"./interfaces/ISFC.sol\";\nimport {IRateProvider} from \"./interfaces/IRateProvider.sol\";\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"openzeppelin-contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20BurnableUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport {ERC20PermitUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title Beets Staked Sonic\n * @author Beets\n * @notice The contract for Beets Staked Sonic (stS)\n */\ncontract SonicStaking is\n    IRateProvider,\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    OwnableUpgradeable,\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    bytes32 public constant CLAIM_ROLE = keccak256(\"CLAIM_ROLE\");\n\n    uint256 public constant MAX_PROTOCOL_FEE_BIPS = 10_000;\n    uint256 public constant MIN_DEPOSIT = 1e16;\n    uint256 public constant MIN_UNDELEGATE_AMOUNT_SHARES = 1e12;\n    uint256 public constant MIN_DONATION_AMOUNT = 1e12;\n    uint256 public constant MIN_CLAIM_REWARDS_AMOUNT = 1e12;\n\n    enum WithdrawKind {\n        POOL,\n        VALIDATOR,\n        CLAW_BACK\n    }\n\n    struct WithdrawRequest {\n        WithdrawKind kind;\n        uint256 validatorId;\n        uint256 assetAmount;\n        bool isWithdrawn;\n        uint256 requestTimestamp;\n        address user;\n    }\n\n    /**\n     * @dev Each undelegate request is given a unique withdraw id. Once the withdraw delay has passed, the request can be\n     * processed, returning the underlying $S tokens to the user.\n     */\n    mapping(uint256 withdrawId => WithdrawRequest request) private _allWithdrawRequests;\n\n    /**\n     * @dev We track all withdraw ids for each user in order to allow for an easier off-chain UX.\n     */\n    mapping(address user => mapping(uint256 index => uint256 withdrawId)) public userWithdraws;\n    mapping(address user => uint256 numWithdraws) public userNumWithdraws;\n\n    /**\n     * @dev A reference to the SFC contract\n     */\n    ISFC public SFC;\n\n    /**\n     * @dev A reference to the treasury address\n     */\n    address public treasury;\n\n    /**\n     * @dev The protocol fee in basis points (BIPS)\n     */\n    uint256 public protocolFeeBIPS;\n\n    /**\n     * The delay between undelegation & withdraw\n     */\n    uint256 public withdrawDelay;\n\n    /**\n     * @dev When true, no new deposits are allowed\n     */\n    bool public depositPaused;\n\n    /**\n     * @dev When true, user undelegations are paused.\n     */\n    bool public undelegatePaused;\n\n    /**\n     * @dev When true, user undelegations from pool are paused.\n     */\n    bool public undelegateFromPoolPaused;\n\n    /**\n     * @dev When true, no withdraws are allowed\n     */\n    bool public withdrawPaused;\n\n    /**\n     * @dev The total assets delegated to validators\n     */\n    uint256 public totalDelegated;\n\n    /**\n     * @dev The total assets that is in the pool (undelegated)\n     */\n    uint256 public totalPool;\n\n    /**\n     * @dev Pending operator clawbacked asset amounts are stored here to preserve the invariant. Once the withdraw\n     * delay has passed, the assets are returned to the pool.\n     */\n    uint256 public pendingClawBackAmount;\n\n    /**\n     * @dev A counter to track the number of withdraws. Used to generate unique withdraw ids.\n     * The current value of the counter is the last withdraw id used.\n     */\n    uint256 public withdrawCounter;\n\n    event WithdrawDelaySet(address indexed owner, uint256 delay);\n    event UndelegatePausedUpdated(address indexed owner, bool newValue);\n    event UndelegateFromPoolPausedUpdated(address indexed owner, bool newValue);\n    event WithdrawPausedUpdated(address indexed owner, bool newValue);\n    event DepositPausedUpdated(address indexed owner, bool newValue);\n    event Deposited(address indexed user, uint256 amountAssets, uint256 amountShares);\n    event Delegated(uint256 indexed validatorId, uint256 amountAssets);\n    event Undelegated(\n        address indexed user, uint256 withdrawId, uint256 validatorId, uint256 amountAssets, WithdrawKind kind\n    );\n    event Withdrawn(address indexed user, uint256 withdrawId, uint256 amountAssets, WithdrawKind kind, bool emergency);\n    event Donated(address indexed user, uint256 amountAssets);\n    event RewardsClaimed(uint256 amountClaimed, uint256 protocolFee);\n    event OperatorClawBackInitiated(uint256 indexed withdrawId, uint256 indexed validatorId, uint256 amountAssets);\n    event OperatorClawBackExecuted(uint256 indexed withdrawId, uint256 amountAssetsWithdrawn, bool indexed emergency);\n    event ProtocolFeeUpdated(address indexed owner, uint256 indexed newFeeBIPS);\n    event TreasuryUpdated(address indexed owner, address indexed newTreasury);\n\n    error DelegateAmountCannotBeZero();\n    error UndelegateAmountCannotBeZero();\n    error NoDelegationForValidator(uint256 validatorId);\n    error UndelegateAmountExceedsDelegated(uint256 validatorId);\n    error WithdrawIdDoesNotExist(uint256 withdrawId);\n    error WithdrawDelayNotElapsed(uint256 withdrawId);\n    error WithdrawAlreadyProcessed(uint256 withdrawId);\n    error UnauthorizedWithdraw(uint256 withdrawId);\n    error TreasuryAddressCannotBeZero();\n    error SFCAddressCannotBeZero();\n    error ProtocolFeeTooHigh();\n    error DepositTooSmall();\n    error DepositPaused();\n    error UndelegatePaused();\n    error UndelegateFromPoolPaused();\n    error WithdrawsPaused();\n    error NativeTransferFailed();\n    error ProtocolFeeTransferFailed();\n    error PausedValueDidNotChange();\n    error UndelegateAmountExceedsPool();\n    error UserWithdrawsSkipTooLarge();\n    error UserWithdrawsMaxSizeCannotBeZero();\n    error ArrayLengthMismatch();\n    error UndelegateAmountTooSmall();\n    error DonationAmountCannotBeZero();\n    error DonationAmountTooSmall();\n    error UnsupportedWithdrawKind();\n    error RewardsClaimedTooSmall();\n    error SfcSlashMustBeAccepted(uint256 refundRatio);\n    error SenderNotSFC();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer\n     * @param _sfc the address of the SFC contract (is NOT modifiable)\n     * @param _treasury The address of the treasury where fees are sent to (is modifiable)\n     */\n    function initialize(ISFC _sfc, address _treasury) public initializer {\n        __ERC20_init(\"Beets Staked Sonic\", \"stS\");\n        __ERC20Burnable_init();\n        __ERC20Permit_init(\"Beets Staked Sonic\");\n\n        __Ownable_init(msg.sender);\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        require(address(_sfc) != address(0), SFCAddressCannotBeZero());\n        require(_treasury != address(0), TreasuryAddressCannotBeZero());\n\n        SFC = _sfc;\n        treasury = _treasury;\n        withdrawDelay = 604800 * 2; // 14 days\n        undelegatePaused = false;\n        undelegateFromPoolPaused = false;\n        withdrawPaused = false;\n        depositPaused = false;\n        protocolFeeBIPS = 1000; // 10%\n        withdrawCounter = 100;\n    }\n\n    /**\n     * @dev This modifier is used to validate a given withdrawId when performing a withdraw. A valid withdraw Id:\n     *      - exists\n     *      - has not been processed\n     *      - has passed the withdraw delay\n     */\n    modifier withValidWithdrawId(uint256 withdrawId) {\n        WithdrawRequest storage request = _allWithdrawRequests[withdrawId];\n        uint256 earliestWithdrawTime = request.requestTimestamp + withdrawDelay;\n\n        require(request.requestTimestamp > 0, WithdrawIdDoesNotExist(withdrawId));\n        require(_now() >= earliestWithdrawTime, WithdrawDelayNotElapsed(withdrawId));\n        require(!request.isWithdrawn, WithdrawAlreadyProcessed(withdrawId));\n\n        _;\n    }\n\n    /**\n     *\n     * Getter & helper functions\n     *\n     */\n\n    /**\n     * @notice Returns the current asset worth of the protocol\n     *\n     * Considers:\n     *  - current staked assets\n     *  - current delegated assets\n     *  - pending operator withdraws\n     */\n    function totalAssets() public view returns (uint256) {\n        return totalPool + totalDelegated + pendingClawBackAmount;\n    }\n\n    /**\n     * @notice Returns the amount of asset equivalent to 1 share (with 18 decimals)\n     * @dev This function is provided for native compatability with balancer pools\n     */\n    function getRate() public view returns (uint256) {\n        return convertToAssets(1 ether);\n    }\n\n    /**\n     * @notice Returns the amount of share equivalent to the provided number of assets\n     * @param assetAmount the amount of assets to convert\n     */\n    function convertToShares(uint256 assetAmount) public view returns (uint256) {\n        uint256 assetsTotal = totalAssets();\n        uint256 totalShares = totalSupply();\n\n        if (assetsTotal == 0 || totalShares == 0) {\n            return assetAmount;\n        }\n\n        return (assetAmount * totalShares) / assetsTotal;\n    }\n\n    /**\n     * @notice Returns the amount of asset equivalent to the provided number of shares\n     * @param sharesAmount the amount of shares to convert\n     */\n    function convertToAssets(uint256 sharesAmount) public view returns (uint256) {\n        uint256 assetsTotal = totalAssets();\n        uint256 totalShares = totalSupply();\n\n        if (assetsTotal == 0 || totalShares == 0) {\n            return sharesAmount;\n        }\n\n        return (sharesAmount * assetsTotal) / totalShares;\n    }\n\n    /**\n     * @notice Returns the user's withdraws\n     * @param user the user to get the withdraws for\n     * @param skip the number of withdraws to skip, used for pagination\n     * @param maxSize the maximum number of withdraws to return. It's possible to return less than maxSize. Used for pagination.\n     * @param reverseOrder whether to return the withdraws in reverse order (newest first)\n     */\n    function getUserWithdraws(address user, uint256 skip, uint256 maxSize, bool reverseOrder)\n        public\n        view\n        returns (WithdrawRequest[] memory)\n    {\n        require(skip < userNumWithdraws[user], UserWithdrawsSkipTooLarge());\n        require(maxSize > 0, UserWithdrawsMaxSizeCannotBeZero());\n\n        uint256 remaining = userNumWithdraws[user] - skip;\n        uint256 size = remaining < maxSize ? remaining : maxSize;\n        WithdrawRequest[] memory items = new WithdrawRequest[](size);\n\n        for (uint256 i = 0; i < size; i++) {\n            if (!reverseOrder) {\n                // In chronological order we simply skip the first (older) entries\n                items[i] = _allWithdrawRequests[userWithdraws[user][skip + i]];\n            } else {\n                // In reverse order we go back to front, skipping the last (newer) entries. Note that `remaining` will\n                // equal the total count if `skip` is 0, meaning we'd start with the newest entry.\n                items[i] = _allWithdrawRequests[userWithdraws[user][remaining - 1 - i]];\n            }\n        }\n\n        return items;\n    }\n\n    function getWithdrawRequest(uint256 withdrawId) external view returns (WithdrawRequest memory) {\n        return _allWithdrawRequests[withdrawId];\n    }\n\n    /**\n     *\n     * End User Functions\n     *\n     */\n\n    /**\n     * @notice Deposit native assets and mint shares of stS.\n     */\n    function deposit() external payable nonReentrant returns (uint256) {\n        uint256 amount = msg.value;\n        require(amount >= MIN_DEPOSIT, DepositTooSmall());\n        require(!depositPaused, DepositPaused());\n\n        address user = msg.sender;\n\n        uint256 sharesAmount = convertToShares(amount);\n\n        // Deposits are added to the pool initially. The assets are delegated to validators by the operator\n        totalPool += amount;\n\n        _mint(user, sharesAmount);\n\n        emit Deposited(user, amount, sharesAmount);\n\n        return sharesAmount;\n    }\n\n    /**\n     * @notice Undelegate staked assets. The shares are burnt from the msg.sender and a withdraw request is created.\n     * The assets are withdrawable after the `withdrawDelay` has passed.\n     * @param validatorId the validator to undelegate from\n     * @param amountShares the amount of shares to undelegate\n     */\n    function undelegate(uint256 validatorId, uint256 amountShares) external nonReentrant returns (uint256) {\n        return _undelegate(validatorId, amountShares);\n    }\n\n    /**\n     * @notice Undelegate staked assets from multiple validators.\n     * @dev This function is provided as a convenience for bulking large undelegation requests across several\n     * validators. This function is not gas optimized as we operate in an environment where gas is less of a concern.\n     * We instead optimize for simpler code that is easier to reason about.\n     * @param validatorIds an array of validator ids to undelegate from\n     * @param amountShares an array of amounts of shares to undelegate\n     */\n    function undelegateMany(uint256[] calldata validatorIds, uint256[] calldata amountShares)\n        external\n        nonReentrant\n        returns (uint256[] memory withdrawIds)\n    {\n        require(validatorIds.length == amountShares.length, ArrayLengthMismatch());\n\n        withdrawIds = new uint256[](validatorIds.length);\n\n        for (uint256 i = 0; i < validatorIds.length; i++) {\n            withdrawIds[i] = _undelegate(validatorIds[i], amountShares[i]);\n        }\n    }\n\n    /**\n     * @notice Undelegate from the pool.\n     * @dev While always possible to undelegate from the pool, the standard flow is to undelegate from a validator.\n     * @param amountShares the amount of shares to undelegate\n     */\n    function undelegateFromPool(uint256 amountShares) external nonReentrant returns (uint256 withdrawId) {\n        require(!undelegateFromPoolPaused, UndelegateFromPoolPaused());\n        require(amountShares >= MIN_UNDELEGATE_AMOUNT_SHARES, UndelegateAmountTooSmall());\n\n        uint256 amountToUndelegate = convertToAssets(amountShares);\n\n        require(amountToUndelegate <= totalPool, UndelegateAmountExceedsPool());\n\n        _burn(msg.sender, amountShares);\n\n        // The validatorId is ignored for pool withdrawals\n        withdrawId = _createAndPersistWithdrawRequest(WithdrawKind.POOL, 0, amountToUndelegate);\n\n        // The amount is subtracted from the pool, but the assets stay in this contract.\n        // The user is able to `withdraw` their assets after the `withdrawDelay` has passed.\n        totalPool -= amountToUndelegate;\n\n        emit Undelegated(msg.sender, withdrawId, 0, amountToUndelegate, WithdrawKind.POOL);\n    }\n\n    /**\n     * @notice Withdraw undelegated assets\n     * @param withdrawId the unique withdraw id for the undelegation request\n     * @param emergency flag to withdraw without checking the amount, risk to get less assets than what is owed\n     */\n    function withdraw(uint256 withdrawId, bool emergency) external nonReentrant returns (uint256) {\n        return _withdraw(withdrawId, emergency);\n    }\n\n    /**\n     * @notice Withdraw undelegated assets for a list of withdrawIds\n     * @dev This function is provided as a convenience for bulking multiple withdraws into a single tx.\n     * @param withdrawIds the unique withdraw ids for the undelegation requests\n     * @param emergency flag to withdraw without checking the amount, risk to get less assets than what is owed\n     */\n    function withdrawMany(uint256[] calldata withdrawIds, bool emergency)\n        external\n        nonReentrant\n        returns (uint256[] memory amountsWithdrawn)\n    {\n        amountsWithdrawn = new uint256[](withdrawIds.length);\n\n        for (uint256 i = 0; i < withdrawIds.length; i++) {\n            amountsWithdrawn[i] = _withdraw(withdrawIds[i], emergency);\n        }\n    }\n\n    /**\n     *\n     * OPERATOR functions\n     *\n     */\n\n    /**\n     * @notice Delegate from the pool to a specific validator\n     * @param validatorId the ID of the validator to delegate to\n     * @param amount the amount of assets to delegate. If an amount greater than the pool is provided, the entire pool\n     * is delegated.\n     */\n    function delegate(uint256 validatorId, uint256 amount)\n        external\n        nonReentrant\n        onlyRole(OPERATOR_ROLE)\n        returns (uint256)\n    {\n        // To prevent DoS vectors and improve operator UX, if an amount larger than the pool is provided,\n        // we default to the entire pool.\n        if (amount > totalPool) {\n            amount = totalPool;\n        }\n\n        require(amount > 0, DelegateAmountCannotBeZero());\n\n        totalPool -= amount;\n        totalDelegated += amount;\n\n        SFC.delegate{value: amount}(validatorId);\n\n        emit Delegated(validatorId, amount);\n\n        // Return the actual amount delegated since it could be less than the amount provided\n        return amount;\n    }\n\n    /**\n     * @notice Initiate a claw back of delegated assets to a specific validator, the claw back can be executed after `withdrawDelay`\n     * @param validatorId the validator to claw back from\n     * @param amountAssets the amount of assets to claw back from given validator\n     */\n    function operatorInitiateClawBack(uint256 validatorId, uint256 amountAssets)\n        external\n        nonReentrant\n        onlyRole(OPERATOR_ROLE)\n        returns (uint256 withdrawId, uint256 actualAmountUndelegated)\n    {\n        require(amountAssets > 0, UndelegateAmountCannotBeZero());\n\n        uint256 amountDelegated = SFC.getStake(address(this), validatorId);\n\n        if (amountAssets > amountDelegated) {\n            amountAssets = amountDelegated;\n        }\n\n        require(amountDelegated > 0, NoDelegationForValidator(validatorId));\n\n        withdrawId = _createAndPersistWithdrawRequest(WithdrawKind.CLAW_BACK, validatorId, amountAssets);\n\n        totalDelegated -= amountAssets;\n\n        // The amount clawed back is still considered part of the total assets.\n        // As such, we need to track the pending amount to ensure the invariant is maintained.\n        pendingClawBackAmount += amountAssets;\n\n        SFC.undelegate(validatorId, withdrawId, amountAssets);\n\n        emit OperatorClawBackInitiated(withdrawId, validatorId, amountAssets);\n\n        actualAmountUndelegated = amountAssets;\n    }\n\n    /**\n     * @notice Execute a claw back, withdrawing assets to the pool\n     * @dev This is the only operation that allows for the rate to decrease.\n     * @param withdrawId the unique withdrawId for the claw back request\n     * @param emergency when true, the operator acknowledges that the amount withdrawn may be less than what is owed,\n     * potentially decreasing the rate.\n     */\n    function operatorExecuteClawBack(uint256 withdrawId, bool emergency)\n        external\n        nonReentrant\n        onlyRole(OPERATOR_ROLE)\n        withValidWithdrawId(withdrawId)\n        returns (uint256)\n    {\n        WithdrawRequest storage request = _allWithdrawRequests[withdrawId];\n\n        require(request.kind == WithdrawKind.CLAW_BACK, UnsupportedWithdrawKind());\n\n        // We allow any address with the operator role to execute a pending clawback.\n        // It does not need to be the same operator that initiated the call.\n\n        request.isWithdrawn = true;\n\n        // Potential slashing events are handled by _withdrawFromSFC\n        uint256 actualWithdrawnAmount = _withdrawFromSFC(request.validatorId, withdrawId, emergency);\n\n        // we need to subtract the request amount from the pending amount since that is the value that was added during\n        // the initiate claw back operation.\n        pendingClawBackAmount -= request.assetAmount;\n\n        // We then account for the actual amount we were able to withdraw\n        // In the instance of a realized slashing event, this will result in a drop in the rate.\n        totalPool += actualWithdrawnAmount;\n\n        emit OperatorClawBackExecuted(withdrawId, actualWithdrawnAmount, emergency);\n\n        return actualWithdrawnAmount;\n    }\n\n    /**\n     * @notice Donate assets to the pool\n     * @dev Donations are added to the pool, causing the rate to increase. Only the operator can donate.\n     */\n    function donate() external payable onlyRole(OPERATOR_ROLE) {\n        uint256 donationAmount = msg.value;\n\n        require(donationAmount > 0, DonationAmountCannotBeZero());\n        // Since convertToAssets is a round down operation, very small donations can cause the rate to not grow.\n        // So, we enforce a minimum donation amount.\n        require(donationAmount >= MIN_DONATION_AMOUNT, DonationAmountTooSmall());\n\n        totalPool += donationAmount;\n\n        emit Donated(msg.sender, donationAmount);\n    }\n\n    /**\n     * @notice Pause all protocol functions\n     * @dev The operator is given the power to pause the protocol, giving them the power to take action in the case of\n     *      an emergency. Enabling the protocol is reserved for the admin.\n     */\n    function pause() external onlyRole(OPERATOR_ROLE) {\n        _setDepositPaused(true);\n        _setUndelegatePaused(true);\n        _setUndelegateFromPoolPaused(true);\n        _setWithdrawPaused(true);\n    }\n\n    /**\n     *\n     * DEFAULT_ADMIN_ROLE functions\n     *\n     */\n\n    /**\n     * @notice Set withdraw delay\n     * @param delay the new delay\n     */\n    function setWithdrawDelay(uint256 delay) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        withdrawDelay = delay;\n        emit WithdrawDelaySet(msg.sender, delay);\n    }\n\n    /**\n     * @notice Pause/unpause user undelegations\n     * @param newValue the desired value of the switch\n     */\n    function setUndelegatePaused(bool newValue) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setUndelegatePaused(newValue);\n    }\n\n    /**\n     * @notice Pause/unpause user undelegations from pool\n     * @param newValue the desired value of the switch\n     */\n    function setUndelegateFromPoolPaused(bool newValue) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setUndelegateFromPoolPaused(newValue);\n    }\n\n    /**\n     * @notice Pause/unpause user withdraws\n     * @param newValue the desired value of the switch\n     */\n    function setWithdrawPaused(bool newValue) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setWithdrawPaused(newValue);\n    }\n\n    /**\n     * @notice Pause/unpause deposit function\n     * @param newValue the desired value of the switch\n     */\n    function setDepositPaused(bool newValue) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setDepositPaused(newValue);\n    }\n\n    /**\n     * @notice Update the treasury address\n     * @param newTreasury the new treasury address\n     */\n    function setTreasury(address newTreasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(newTreasury != address(0), TreasuryAddressCannotBeZero());\n\n        treasury = newTreasury;\n\n        emit TreasuryUpdated(msg.sender, newTreasury);\n    }\n\n    /**\n     * @notice Update the protocol fee\n     * @param newFeeBIPS the value of the fee (in BIPS)\n     */\n    function setProtocolFeeBIPS(uint256 newFeeBIPS) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(newFeeBIPS <= MAX_PROTOCOL_FEE_BIPS, ProtocolFeeTooHigh());\n\n        protocolFeeBIPS = newFeeBIPS;\n\n        emit ProtocolFeeUpdated(msg.sender, newFeeBIPS);\n    }\n\n    /**\n     * @notice Claim rewards from all contracts and add them to the pool\n     * @param validatorIds an array of validator IDs to claim rewards from\n     */\n    function claimRewards(uint256[] calldata validatorIds) external nonReentrant onlyRole(CLAIM_ROLE) {\n        uint256 balanceBefore = address(this).balance;\n\n        for (uint256 i = 0; i < validatorIds.length; i++) {\n            uint256 rewards = SFC.pendingRewards(address(this), validatorIds[i]);\n\n            if (rewards > 0) {\n                SFC.claimRewards(validatorIds[i]);\n            }\n        }\n\n        uint256 totalRewardsClaimed = address(this).balance - balanceBefore;\n\n        // We enforce a minimum amount to ensure the math stays well behaved\n        require(totalRewardsClaimed > MIN_CLAIM_REWARDS_AMOUNT, RewardsClaimedTooSmall());\n\n        uint256 protocolFee = 0;\n\n        if (protocolFeeBIPS > 0) {\n            protocolFee = (totalRewardsClaimed * protocolFeeBIPS) / MAX_PROTOCOL_FEE_BIPS;\n            totalPool += totalRewardsClaimed - protocolFee;\n\n            (bool protocolFeesClaimed,) = treasury.call{value: protocolFee}(\"\");\n            require(protocolFeesClaimed, ProtocolFeeTransferFailed());\n        } else {\n            totalPool += totalRewardsClaimed;\n        }\n\n        emit RewardsClaimed(totalRewardsClaimed, protocolFee);\n    }\n\n    /**\n     *\n     * Internal functions\n     *\n     */\n    function _undelegate(uint256 validatorId, uint256 amountShares) internal returns (uint256 withdrawId) {\n        require(!undelegatePaused, UndelegatePaused());\n        require(amountShares >= MIN_UNDELEGATE_AMOUNT_SHARES, UndelegateAmountTooSmall());\n\n        uint256 amountAssets = convertToAssets(amountShares);\n        uint256 amountDelegated = SFC.getStake(address(this), validatorId);\n\n        require(amountAssets <= amountDelegated, UndelegateAmountExceedsDelegated(validatorId));\n\n        _burn(msg.sender, amountShares);\n\n        withdrawId = _createAndPersistWithdrawRequest(WithdrawKind.VALIDATOR, validatorId, amountAssets);\n\n        totalDelegated -= amountAssets;\n\n        SFC.undelegate(validatorId, withdrawId, amountAssets);\n\n        emit Undelegated(msg.sender, withdrawId, validatorId, amountAssets, WithdrawKind.VALIDATOR);\n    }\n\n    function _withdraw(uint256 withdrawId, bool emergency) internal withValidWithdrawId(withdrawId) returns (uint256) {\n        require(!withdrawPaused, WithdrawsPaused());\n\n        // We've already checked that the withdrawId exists and is valid, so we can safely access the request\n        WithdrawRequest storage request = _allWithdrawRequests[withdrawId];\n\n        require(msg.sender == request.user, UnauthorizedWithdraw(withdrawId));\n\n        // Claw backs can only be executed by the operator via the operatorExecuteClawBack function\n        require(request.kind != WithdrawKind.CLAW_BACK, UnsupportedWithdrawKind());\n\n        request.isWithdrawn = true;\n\n        uint256 amountWithdrawn = 0;\n\n        if (request.kind == WithdrawKind.POOL) {\n            // An undelegate from the pool only effects the internal accounting of this contract.\n            // The amount has already been subtracted from the pool and the assets were already owned by this contract.\n            // The amount withdrawn is always the same as the request amount.\n            amountWithdrawn = request.assetAmount;\n        } else {\n            //The only WithdrawKind left is VALIDATOR\n\n            // Potential slashing events are handled by _withdrawFromSFC\n            amountWithdrawn = _withdrawFromSFC(request.validatorId, withdrawId, emergency);\n        }\n\n        address user = msg.sender;\n        (bool withdrawnToUser,) = user.call{value: amountWithdrawn}(\"\");\n        require(withdrawnToUser, NativeTransferFailed());\n\n        emit Withdrawn(user, withdrawId, amountWithdrawn, request.kind, emergency);\n\n        // Return the actual amount withdrawn\n        return amountWithdrawn;\n    }\n\n    function _withdrawFromSFC(uint256 validatorId, uint256 withdrawId, bool emergency)\n        internal\n        returns (uint256 actualAmountWithdrawn)\n    {\n        uint256 balanceBefore = address(this).balance;\n        bool isSlashed = SFC.isSlashed(validatorId);\n\n        if (isSlashed) {\n            uint256 refundRatio = SFC.slashingRefundRatio(validatorId);\n\n            // The caller is required to acknowledge they understand their stake has been slashed\n            // by setting emergency to true.\n            require(emergency, SfcSlashMustBeAccepted(refundRatio));\n\n            // When a validator isSlashed, a refundRatio of 0 can have two different meanings:\n            // 1. The validator has been slashed but the percentage has not yet been set\n            // 2. The validator has been fully slashed\n\n            // In either case, a call to SFC.withdraw when isSlashed && refundRatio == 0 will revert with\n            // StakeIsFullySlashed. So, we cannot make the call to SFC.withdraw.\n\n            // In the instance that isSlashed == true && refundRatio == 0 && emergency == true, the caller is\n            // acknowledging that their delegation has been fully slashed.\n\n            // In the instance that refundRatio != 0, a slashing refund ratio has been set and can now be realized\n            // by calling SFC.withdraw\n            if (refundRatio != 0) {\n                SFC.withdraw(validatorId, withdrawId);\n            }\n        } else {\n            SFC.withdraw(validatorId, withdrawId);\n        }\n\n        // The SFC sends native assets to this contract, increasing it's balance. We measure the change\n        // in balance before and after the call to get the actual amount withdrawn.\n        actualAmountWithdrawn = address(this).balance - balanceBefore;\n    }\n\n    function _createAndPersistWithdrawRequest(WithdrawKind kind, uint256 validatorId, uint256 amount)\n        internal\n        returns (uint256 withdrawId)\n    {\n        address user = msg.sender;\n        withdrawId = _incrementWithdrawCounter();\n        WithdrawRequest storage request = _allWithdrawRequests[withdrawId];\n\n        request.kind = kind;\n        request.requestTimestamp = _now();\n        request.user = user;\n        request.assetAmount = amount;\n        request.validatorId = validatorId;\n        request.isWithdrawn = false;\n\n        // We store the user's withdraw ids to allow for easier off-chain processing.\n        userWithdraws[user][userNumWithdraws[user]] = withdrawId;\n        userNumWithdraws[user]++;\n    }\n\n    function _now() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Given the size of uint256 and the maximum supply of $S, we can safely assume that this will never overflow\n     * with a 1e18 minimum undelegate amount.\n     */\n    function _incrementWithdrawCounter() internal returns (uint256) {\n        withdrawCounter++;\n\n        return withdrawCounter;\n    }\n\n    function _setUndelegatePaused(bool newValue) internal {\n        require(undelegatePaused != newValue, PausedValueDidNotChange());\n\n        undelegatePaused = newValue;\n        emit UndelegatePausedUpdated(msg.sender, newValue);\n    }\n\n    function _setUndelegateFromPoolPaused(bool newValue) internal {\n        require(undelegateFromPoolPaused != newValue, PausedValueDidNotChange());\n\n        undelegateFromPoolPaused = newValue;\n        emit UndelegateFromPoolPausedUpdated(msg.sender, newValue);\n    }\n\n    function _setWithdrawPaused(bool newValue) internal {\n        require(withdrawPaused != newValue, PausedValueDidNotChange());\n\n        withdrawPaused = newValue;\n        emit WithdrawPausedUpdated(msg.sender, newValue);\n    }\n\n    function _setDepositPaused(bool newValue) internal {\n        require(depositPaused != newValue, PausedValueDidNotChange());\n\n        depositPaused = newValue;\n\n        emit DepositPausedUpdated(msg.sender, newValue);\n    }\n\n    /**\n     *\n     * OWNER functions\n     *\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @notice To receive native asset rewards from SFC\n     */\n    receive() external payable {\n        require(msg.sender == address(SFC), SenderNotSFC());\n    }\n}\n"
    }
}