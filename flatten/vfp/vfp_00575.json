{
    "vfp_id": "vfp_00575",
    "project_name": "report_cantinacode_eco_may2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Incorrect equivalence assumption on chain IDs and prover domain IDs may lead to loss of solver funds",
            "description": "The protocol incorrectly assumes that chain IDs are equivalent to prover domain IDs in HyperProver.sol and MetaProver.sol, using them interchangeably when formatting prover calls. This is a flawed assumption because cross-chain frameworks like Hyperlane and Metalayer use distinct domain ID systems that do not always align with EVM chain IDs. An attacker could exploit this by crafting a malicious fulfillment request on a chain where the domain ID and chain ID differ, causing incorrect routing or execution. This leads to the loss of solver funds used to fulfill intents, as the system may reject valid proofs or route them incorrectly.\n",
            "severity": "High",
            "location": [
                "HyperProver.sol#L297",
                "MetaProver.sol#L251"
            ],
            "files": [
                "eco-routes/contracts/prover/HyperProver.sol",
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Assumed instant finality may lead to loss of intent creator funds in reorg scenarios",
            "description": "The MetaProver contract assumes instant finality by using FinalityState.INSTANT when verifying proofs, without accounting for blockchain reorganizations. The root cause is the lack of delay or confirmation checks before accepting a proof as valid. In the event of a chain reorg, a previously accepted proof could become invalid, but the system has already processed the fulfillment on the destination chain. This allows a solver to receive rewards on the source chain while the corresponding fulfillment is rolled back, resulting in a loss of funds for the intent creator. While deep reorgs are rare on chains like Ethereum, the impact is high when they occur.\n",
            "severity": "Medium",
            "location": [
                "MetaProver.sol#L143-L150"
            ],
            "files": [
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Prover address mismatch between source and destination chains can lead to DoS",
            "description": "The Eco7683DestinationSettler contract uses `intent.reward.prover` as the prover address during the `fill()` function, which is set on the source chain. However, the prover address may differ on the destination chain due to deployment differences or chain-specific configurations. The root cause is the lack of a mapping mechanism to translate prover addresses across chains. This mismatch can cause the fulfillment to fail when validating proofs, leading to a denial of service for valid intents. The issue is mitigated by using a local prover address mapping, which ensures correct address resolution on the destination chain.\n",
            "severity": "Low",
            "location": [
                "Eco7683DestinationSettler.sol#L42"
            ],
            "files": [
                "eco-routes/contracts/ERC7683/DestinationSettler.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-346"
                ],
                "4": [
                    "CWE-940"
                ]
            },
            "title": "Missing chain-specific prover authorizations may allow spoofed proofs from unsupported chains to compromise all protocol intents",
            "description": "The protocol does not enforce chain-specific authorization for prover contracts, allowing any prover that can be deployed at a predictable address (e.g., via CREATE3) to submit proofs. The root cause is the absence of a whitelist or domain-specific validation for provers. If an attacker compromises the prover deployer's credentials or predicts the deployment address on an unsupported chain, they could spoof proofs and claim rewards for all intents. While the likelihood is very low due to the required compromise, the impact is high because it undermines the trust model of the entire protocol.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "eco-routes/contracts/prover/HyperProver.sol",
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant code constructs reduce readability",
            "description": "Several contracts contain unused imports, unused variables, and redundant error definitions that do not contribute to functionality. The cause is poor code hygiene during development, likely due to iterative changes without cleanup. While this does not introduce direct security risks, it reduces code readability and maintainability, increasing the likelihood of future bugs during upgrades or audits. The presence of dead code can also confuse auditors and developers, potentially leading to incorrect assumptions about contract behavior.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "eco-routes/contracts/ERC7683/DestinationSettler.sol",
                "eco-routes/contracts/prover/HyperProver.sol",
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing source chain prover validation may lead to lost messages",
            "description": "Both HyperProver.sol and MetaProver.sol do not validate that the source chain prover address is legitimate or authorized before accepting proofs. The root cause is the lack of explicit checks against a known set of valid provers per domain. This could allow a misconfigured or malicious solver to provide an invalid prover address, resulting in lost messages or failed fulfillments. While the solver is expected to ensure correctness, the protocol should enforce basic validation to prevent accidental errors or integration issues.\n",
            "severity": "Informational",
            "location": [
                "HyperProver.sol#L300",
                "MetaProver.sol#L95"
            ],
            "files": [
                "eco-routes/contracts/prover/HyperProver.sol",
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-74"
                ],
                "3": [
                    "CWE-94"
                ]
            },
            "title": "Allowing arbitrary custom hooks to be specified by the solver/prover may be risky",
            "description": "The HyperProver contract allows solvers or provers to specify custom post-dispatch hooks in Hyperlane, which are executed during message relaying. The root cause is the lack of validation or sandboxing of these hooks. If a malicious or compromised solver specifies a harmful hook, it could interfere with the relayer's operation or perform unauthorized actions. While the risk is mitigated by trust in solvers and ongoing work on a custom relayer, the open-ended hook mechanism introduces potential attack surface that should be carefully reviewed before production use.\n",
            "severity": "Informational",
            "location": [
                "HyperProver.sol#L144-L155",
                "HyperProver.sol#L160-L166",
                "HyperProver.sol#L308-L311"
            ],
            "files": [
                "eco-routes/contracts/prover/HyperProver.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Incorrect enforcement of minimum gas limit override in MetaProver may lead to message delays/failures",
            "description": "The MetaProver.sol contract allows a custom gas limit to be set via the `_data` parameter, but does not enforce a minimum value. The root cause is the lack of validation to ensure that the provided gas limit is sufficient for successful message processing. If a solver sets a gas limit that is too low, the message may fail to be relayed or processed, leading to delays or dropped messages. This can be exploited to cause denial of service or force repeated attempts, increasing operational costs for solvers and users.\n",
            "severity": "Informational",
            "location": [
                "MetaProver.sol#L125"
            ],
            "files": [
                "eco-routes/contracts/prover/MetaProver.sol"
            ]
        }
    ],
    "affected_files": {
        "HyperProver.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IMessageRecipient} from \"@hyperlane-xyz/core/contracts/interfaces/IMessageRecipient.sol\";\nimport {TypeCasts} from \"@hyperlane-xyz/core/contracts/libs/TypeCasts.sol\";\nimport {MessageBridgeProver} from \"./MessageBridgeProver.sol\";\nimport {Semver} from \"../libs/Semver.sol\";\nimport {IMailbox, IPostDispatchHook} from \"@hyperlane-xyz/core/contracts/interfaces/IMailbox.sol\";\n\n/**\n * @title HyperProver\n * @notice Prover implementation using Hyperlane's cross-chain messaging system\n * @dev Processes proof messages from Hyperlane mailbox and records proven intents\n */\ncontract HyperProver is IMessageRecipient, MessageBridgeProver, Semver {\n    using TypeCasts for bytes32;\n\n    /**\n     * @notice Struct for unpacked data from _data parameter\n     * @dev Only contains fields decoded from the _data parameter\n     */\n    struct UnpackedData {\n        bytes32 sourceChainProver; // Address of prover on source chain\n        bytes metadata; // Metadata for Hyperlane message\n        address hookAddr; // Address of post-dispatch hook\n    }\n\n    /**\n     * @notice Struct for Hyperlane dispatch parameters\n     * @dev Consolidates message dispatch parameters to reduce stack usage\n     */\n    struct DispatchParams {\n        uint32 destinationDomain; // Hyperlane domain ID\n        bytes32 recipientAddress; // Recipient address encoded as bytes32\n        bytes messageBody; // Encoded message body with intent hashes and claimants\n        bytes metadata; // Additional metadata for the message\n        IPostDispatchHook hook; // Post-dispatch hook contract\n    }\n\n    /**\n     * @notice Constant indicating this contract uses Hyperlane for proving\n     */\n    string public constant PROOF_TYPE = \"Hyperlane\";\n\n    /**\n     * @notice Address of local Hyperlane mailbox\n     */\n    address public immutable MAILBOX;\n\n    /**\n     * @param mailbox Address of local Hyperlane mailbox\n     * @param portal Address of Portal contract\n     * @param provers Array of trusted prover addresses (as bytes32 for cross-VM compatibility)\n     */\n    constructor(\n        address mailbox,\n        address portal,\n        bytes32[] memory provers\n    ) MessageBridgeProver(portal, provers, 0) {\n        if (mailbox == address(0)) revert MessengerContractCannotBeZeroAddress();\n        MAILBOX = mailbox;\n    }\n\n    /**\n     * @notice Handles incoming Hyperlane messages containing proof data\n     * @dev Processes batch updates to proven intents from valid sources\n     * @param origin Origin chain ID from the source chain\n     * @param sender Address that dispatched the message on source chain\n     * @param messageBody Encoded array of intent hashes and claimants\n     */\n    function handle(\n        uint32 origin,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) public payable only(MAILBOX) {\n        // Verify origin and sender are valid\n        if (origin == 0) revert MessageOriginChainDomainIDCannotBeZero();\n\n        // Validate sender is not zero\n        if (sender == bytes32(0)) revert MessageSenderCannotBeZeroAddress();\n\n        _handleCrossChainMessage(sender, messageBody);\n    }\n\n    /**\n     * @notice Implementation of message dispatch for Hyperlane\n     * @dev Called by base prove() function after common validations\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data for message formatting\n     * @param fee Fee amount for message dispatch\n     */\n    function _dispatchMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data,\n        uint256 fee\n    ) internal override {\n        // Parse incoming data into a structured format for processing\n        UnpackedData memory unpacked = _unpackData(data);\n\n        // Prepare parameters for cross-chain message dispatch using a struct\n        // to reduce stack usage and improve code maintainability\n        DispatchParams memory params = _formatHyperlaneMessage(\n            domainID,\n            encodedProofs,\n            unpacked\n        );\n\n        // Send the message through Hyperlane mailbox using params from the struct\n        // Note: Some Hyperlane versions have different dispatch signatures.\n        // This matches the expected signature for testing.\n        IMailbox(MAILBOX).dispatch{value: fee}(\n            params.destinationDomain,\n            params.recipientAddress,\n            params.messageBody,\n            params.metadata,\n            params.hook\n        );\n    }\n\n    /**\n     * @notice Calculates the fee required for Hyperlane message dispatch\n     * @dev Queries the Mailbox contract for accurate fee estimation\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data for message formatting\n     * @return Fee amount required for message dispatch\n     */\n    function fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data\n    ) public view override returns (uint256) {\n        // Decode structured data from the raw input\n        UnpackedData memory unpacked = _unpackData(data);\n\n        // Process fee calculation using the decoded struct\n        // This architecture separates decoding from core business logic\n        return _fetchFee(domainID, encodedProofs, unpacked);\n    }\n\n    /**\n     * @notice Decodes the raw cross-chain message data into a structured format\n     * @dev Parses ABI-encoded parameters into the UnpackedData struct\n     * @param data Raw message data containing source chain information\n     * @return unpacked Structured representation of the decoded parameters\n     */\n    function _unpackData(\n        bytes calldata data\n    ) internal pure returns (UnpackedData memory unpacked) {\n        unpacked = abi.decode(data, (UnpackedData));\n    }\n\n    /**\n     * @notice Internal function to calculate the fee with pre-decoded data\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param unpacked Struct containing decoded data from data parameter\n     * @return Fee amount required for message dispatch\n     */\n    function _fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        UnpackedData memory unpacked\n    ) internal view returns (uint256) {\n        // Format and prepare message parameters for dispatch\n        DispatchParams memory params = _formatHyperlaneMessage(\n            domainID,\n            encodedProofs,\n            unpacked\n        );\n\n        // Query Hyperlane mailbox for accurate fee estimate\n        return\n            IMailbox(MAILBOX).quoteDispatch(\n                params.destinationDomain,\n                params.recipientAddress,\n                params.messageBody,\n                params.metadata,\n                params.hook\n            );\n    }\n\n    /**\n     * @notice Returns the proof type used by this prover\n     * @return ProofType indicating Hyperlane proving mechanism\n     */\n    function getProofType() external pure override returns (string memory) {\n        return PROOF_TYPE;\n    }\n\n    /**\n     * @notice Formats data for Hyperlane message dispatch with encoded proofs\n     * @dev Prepares all parameters needed for the Mailbox dispatch call\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param unpacked Struct containing decoded data from data parameter\n     * @return params Structured dispatch parameters for Hyperlane message\n     */\n    function _formatHyperlaneMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        UnpackedData memory unpacked\n    ) internal view returns (DispatchParams memory params) {\n        // Convert domain ID to Hyperlane domain ID format with overflow check\n        if (domainID > type(uint32).max) {\n            revert DomainIdTooLarge(domainID);\n        }\n        params.destinationDomain = uint32(domainID);\n\n        // Use the source chain prover address as the message recipient\n        params.recipientAddress = unpacked.sourceChainProver;\n\n        params.messageBody = encodedProofs;\n\n        // Pass through metadata as provided\n        params.metadata = unpacked.metadata;\n\n        // Default to mailbox's hook if none provided, following Hyperlane best practices\n        params.hook = (unpacked.hookAddr == address(0))\n            ? IMailbox(MAILBOX).defaultHook()\n            : IPostDispatchHook(unpacked.hookAddr);\n    }\n}\n",
        "DestinationSettler.sol": "/* -*- c-basic-offset: 4 -*- */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IDestinationSettler} from \"../interfaces/ERC7683/IDestinationSettler.sol\";\nimport {Route} from \"../types/Intent.sol\";\n\n/**\n * @title DestinationSettler\n * @notice Abstract contract implementing ERC-7683 destination chain settlement for Eco Protocol\n * @dev Handles intent fulfillment on destination chains through the ERC-7683 standard interface\n */\nabstract contract DestinationSettler is IDestinationSettler {\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev originData is of type OnchainCrossChainOrder\n     * @dev fillerData is encoded bytes consisting of the claimant address and any additional data required for the chosen prover\n     * @param orderId Unique identifier for the order being filled\n     * @param originData Data emitted on the origin chain to parameterize the fill, equivalent to the originData field from the fillInstruction of the ResolvedCrossChainOrder. An encoded Intent struct.\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external payable {\n        (bytes memory encodedRoute, bytes32 rewardHash) = abi.decode(\n            originData,\n            (bytes, bytes32)\n        );\n\n        emit OrderFilled(orderId, msg.sender);\n\n        (\n            address prover,\n            uint64 source,\n            bytes32 claimant,\n            bytes memory proverData\n        ) = abi.decode(fillerData, (address, uint64, bytes32, bytes));\n\n        fulfillAndProve(\n            orderId,\n            abi.decode(encodedRoute, (Route)),\n            rewardHash,\n            claimant,\n            prover,\n            source,\n            proverData\n        );\n    }\n\n    /**\n     * @notice Fulfills an intent and initiates proving in one transaction\n     * @dev Abstract function to be implemented by concrete settlement contracts\n     * @param intentHash The hash of the intent to fulfill\n     * @param route The route information for the intent\n     * @param rewardHash The hash of the reward details\n     * @param claimant Cross-VM compatible claimant identifier\n     * @param prover Address of prover on the destination chain\n     * @param source The source chain ID where the intent was created\n     * @param data Additional data for message formatting\n     * @return Array of execution results from intent calls\n     */\n    function fulfillAndProve(\n        bytes32 intentHash,\n        Route memory route,\n        bytes32 rewardHash,\n        bytes32 claimant,\n        address prover,\n        uint64 source,\n        bytes memory data\n    ) public payable virtual returns (bytes[] memory);\n}\n",
        "MetaProver.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IMetalayerRecipient, ReadOperation} from \"@metalayer/contracts/src/interfaces/IMetalayerRecipient.sol\";\nimport {FinalityState} from \"@metalayer/contracts/src/lib/MetalayerMessage.sol\";\nimport {TypeCasts} from \"@hyperlane-xyz/core/contracts/libs/TypeCasts.sol\";\nimport {MessageBridgeProver} from \"./MessageBridgeProver.sol\";\n// Import Semver for versioning support\nimport {Semver} from \"../libs/Semver.sol\";\nimport {StandardHookMetadata} from \"@hyperlane-xyz/core/contracts/hooks/libs/StandardHookMetadata.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IMetalayerRouterExt} from \"../interfaces/IMetalayerRouterExt.sol\";\n\n/**\n * @title MetaProver\n * @notice Prover implementation using Caldera Metalayer's cross-chain messaging system\n * @notice the terms \"source\" and \"destination\" are used in reference to a given intent: created on source chain, fulfilled on destination chain\n * @dev Processes proof messages from Metalayer router and records proven intents\n */\ncontract MetaProver is IMetalayerRecipient, MessageBridgeProver, Semver {\n    using TypeCasts for bytes32;\n    using TypeCasts for address;\n    using SafeCast for uint256;\n\n    /**\n     * @notice Struct for unpacked data from _data parameter\n     * @dev Contains fields decoded from the _data parameter\n     */\n    struct UnpackedData {\n        bytes32 sourceChainProver; // Address of prover on source chain\n        uint256 gasLimit; // Gas limit for execution\n    }\n\n    /**\n     * @notice Constant indicating this contract uses Metalayer for proving\n     */\n    string public constant PROOF_TYPE = \"Meta\";\n\n    /**\n     * @notice ETH message value used in fee calculation metadata\n     * @dev Set to very high value (1e36) to avoid fee calculation failures\n     *      in the Metalayer router's quote dispatch function\n     */\n    uint256 private immutable ETH_QUOTE_VALUE = 1e36;\n\n    /**\n     * @notice Address of local Metalayer router\n     */\n    IMetalayerRouterExt public immutable ROUTER;\n\n    /**\n     * @notice Initializes the MetaProver contract\n     * @param router Address of local Metalayer router\n     * @param portal Address of Portal contract\n     * @param provers Array of trusted prover addresses (as bytes32 for cross-VM compatibility)\n     * @param minGasLimit Minimum gas limit for cross-chain messages (200k if zero)\n     */\n    constructor(\n        address router,\n        address portal,\n        bytes32[] memory provers,\n        uint256 minGasLimit\n    ) MessageBridgeProver(portal, provers, minGasLimit) {\n        if (router == address(0)) revert MessengerContractCannotBeZeroAddress();\n\n        ROUTER = IMetalayerRouterExt(router);\n    }\n\n    /**\n     * @notice Handles incoming Metalayer messages containing proof data\n     * @dev Processes batch updates to proven intents from valid sources\n     * @dev called by the Metalayer Router on the source chain\n     * @param origin Origin chain ID from the destination chain\n     * @param sender Address that dispatched the message on destination chain\n     * @param message Encoded array of intent hashes and claimants\n     */\n    function handle(\n        uint32 origin,\n        bytes32 sender,\n        bytes calldata message,\n        ReadOperation[] calldata /* operations */,\n        bytes[] calldata /* operationsData */\n    ) external payable only(address(ROUTER)) {\n        // Verify origin and sender are valid\n        if (origin == 0) revert MessageOriginChainDomainIDCannotBeZero();\n\n        // Validate sender is not zero\n        if (sender == bytes32(0)) revert MessageSenderCannotBeZeroAddress();\n\n        _handleCrossChainMessage(sender, message);\n    }\n\n    /**\n     * @notice Decodes the raw cross-chain message data into a structured format\n     * @dev Parses ABI-encoded parameters into the UnpackedData struct and enforces minimum gas limit\n     * @param data Raw message data containing source chain information\n     * @return unpacked Structured representation of the decoded parameters with validated gas limit\n     */\n    function _unpackData(\n        bytes calldata data\n    ) internal view returns (UnpackedData memory unpacked) {\n        unpacked = abi.decode(data, (UnpackedData));\n\n        // Enforce minimum gas limit to prevent underfunded transactions\n        if (unpacked.gasLimit < MIN_GAS_LIMIT) {\n            unpacked.gasLimit = MIN_GAS_LIMIT;\n        }\n    }\n\n    /**\n     * @notice Implementation of message dispatch for Metalayer\n     * @dev Called by base prove() function after common validations\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data for message formatting\n     * @param fee Fee amount for message dispatch\n     */\n    function _dispatchMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data,\n        uint256 fee\n    ) internal override {\n        // Parse incoming data into a structured format\n        UnpackedData memory unpacked = _unpackData(data);\n\n        // Format message for dispatch using pre-decoded value\n        (\n            uint32 sourceChainDomain,\n            bytes32 recipient,\n            bytes memory message\n        ) = _formatMetalayerMessage(\n                domainID,\n                encodedProofs,\n                unpacked.sourceChainProver\n            );\n\n        // Call Metalayer router's send message function\n        ROUTER.dispatch{value: fee}(\n            sourceChainDomain,\n            recipient,\n            new ReadOperation[](0),\n            message,\n            FinalityState.INSTANT,\n            unpacked.gasLimit\n        );\n    }\n\n    /**\n     * @notice Fetches fee required for message dispatch\n     * @dev Uses custom hook metadata with actual gas limit to ensure accurate fee estimation.\n     *      Fixes issue where 3-parameter quoteDispatch used hardcoded 100k gas limit.\n     * @param domainID Domain ID of source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param data Additional data containing gas limit that will be used in dispatch\n     * @return Fee amount required for message dispatch\n     */\n    function fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes calldata data\n    ) public view override returns (uint256) {\n        // Delegate to internal function with pre-decoded value\n        return _fetchFee(domainID, encodedProofs, _unpackData(data));\n    }\n\n    /**\n     * @notice Internal function to calculate fee with pre-decoded data\n     * @dev Uses actual gas limit from unpacked data to ensure accurate fee estimation\n     * @param domainID Domain ID of source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param unpacked Pre-decoded data including actual gas limit that will be used\n     * @return Fee amount required for message dispatch\n     */\n    function _fetchFee(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        UnpackedData memory unpacked\n    ) internal view returns (uint256) {\n        (\n            uint32 sourceChainDomain,\n            bytes32 recipient,\n            bytes memory message\n        ) = _formatMetalayerMessage(\n                domainID,\n                encodedProofs,\n                unpacked.sourceChainProver\n            );\n\n        // Create custom hook metadata with the actual gas limit that will be used in dispatch\n        bytes memory feeHookMetadata = StandardHookMetadata.formatMetadata(\n            ETH_QUOTE_VALUE,\n            unpacked.gasLimit, // Use actual gas limit (min 200k)\n            msg.sender, // Refund address\n            bytes(\"\") // Optional custom metadata\n        );\n\n        return\n            ROUTER.quoteDispatch(\n                sourceChainDomain,\n                recipient,\n                message,\n                feeHookMetadata\n            );\n    }\n\n    /**\n     * @notice Returns the proof type used by this prover\n     * @return ProofType indicating Metalayer proving mechanism\n     */\n    function getProofType() external pure override returns (string memory) {\n        return PROOF_TYPE;\n    }\n\n    /**\n     * @notice Formats data for Metalayer message dispatch with encoded proofs\n     * @param domainID Domain ID of the source chain\n     * @param encodedProofs Encoded (intentHash, claimant) pairs as bytes\n     * @param sourceChainProver Pre-decoded prover address on source chain\n     * @return domain Metalayer domain ID\n     * @return recipient Recipient address encoded as bytes32\n     * @return message Encoded message body with intent hashes and claimants\n     */\n    function _formatMetalayerMessage(\n        uint64 domainID,\n        bytes calldata encodedProofs,\n        bytes32 sourceChainProver\n    )\n        internal\n        pure\n        returns (uint32 domain, bytes32 recipient, bytes memory message)\n    {\n        // Convert domain ID to domain with overflow check\n        if (domainID > type(uint32).max) {\n            revert DomainIdTooLarge(domainID);\n        }\n        domain = uint32(domainID);\n\n        // Use pre-decoded source chain prover address as recipient\n        recipient = sourceChainProver;\n\n        message = encodedProofs;\n    }\n}\n"
    }
}