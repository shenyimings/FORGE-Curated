{
    "vfp_id": "vfp_00203",
    "project_name": "EVM Emulator and Semi-abstracted Nonces Update Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing Docstrings",
            "description": "Multiple contracts and interfaces lack proper NatSpec documentation, including function arguments, return values, and state variables. For example, `ContractDeployer`, `INonceHolder`, and `IContractDeployer` are missing detailed docstrings.\n\nThe root cause is insufficient code documentation practices, which reduce code readability and maintainability. This omission makes it harder for developers and auditors to understand the intended behavior of functions and interfaces.\n\nWhile not directly exploitable, the absence of documentation increases the risk of misinterpretation during development or auditing, potentially leading to incorrect integrations or missed vulnerabilities.\n\nThe impact is reduced code transparency and increased long-term maintenance burden, especially for complex systems like L2 protocols where precise understanding is critical.\n",
            "severity": "Low",
            "location": [
                "ContractDeployer.sol",
                "INonceHolder.sol",
                "IContractDeployer.sol"
            ],
            "files": [
                "era-contracts/system-contracts/contracts/ContractDeployer.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant Return Statements",
            "description": "Several functions in the codebase use explicit return statements even though they use named return variables, which is redundant and harms readability.\nThis is caused by inconsistent coding patterns, where developers return values explicitly instead of relying on named returns, defeating the purpose of that Solidity feature.\nAn attacker cannot exploit this directly, but it increases the risk of logic errors during future modifications due to unclear control flow.\nThe impact is on code maintainability and readability, making audits and reviews more difficult and error-prone.\n",
            "severity": "Low",
            "location": [
                "ContractDeployer.sol::getAccountInfo#41",
                "ContractDeployer.sol::precreateEvmAccountFromEmulator#217",
                "ContractDeployer.sol::_evmDeployOnAddress#417",
                "ContractDeployer.sol::_performDeployOnAddressEVM#473-480",
                "NonceHolder.sol::getDeploymentNonce#180"
            ],
            "files": [
                "era-contracts/system-contracts/contracts/ContractDeployer.sol"
            ]
        }
    ],
    "affected_files": {
        "ContractDeployer.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IContractDeployer, ForceDeployment} from \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, BASE_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT, COMPLEX_UPGRADER_CONTRACT, SERVICE_CALL_PSEUDO_CALLER, EVM_PREDEPLOYS_MANAGER, EVM_HASHES_STORAGE} from \"./Constants.sol\";\n\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {SystemContractBase} from \"./abstract/SystemContractBase.sol\";\nimport {Unauthorized, InvalidNonceOrderingChange, ValueMismatch, EmptyBytes32, EVMBytecodeHash, EVMBytecodeHashUnknown, EVMEmulationNotSupported, NotAllowedToDeployInKernelSpace, HashIsNonZero, NonEmptyAccount, UnknownCodeHash, NonEmptyMsgValue} from \"./SystemContractErrors.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice System smart contract that is responsible for deploying other smart contracts on ZKsync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, SystemContractBase {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal accountInfo;\n\n    /// @notice What types of bytecode are allowed to be deployed on this chain.\n    AllowedBytecodeTypes public allowedBytecodeTypesToDeploy;\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (\n            _address > address(MAX_SYSTEM_CONTRACT_ADDRESS) &&\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0\n        ) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Since only `KeyedSequential`\n    /// is supported, currently this method always reverts.\n    function updateNonceOrdering(AccountNonceOrdering) external onlySystemCall {\n        revert InvalidNonceOrderingChange();\n        // NOTE: If this method is ever implemented, the `AccountNonceOrderingUpdated` event should be emitted.\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys an EVM contract using address derivation of EVM's `CREATE` opcode.\n    /// @dev Note: this method may be callable only in system mode.\n    /// @param _initCode The init code for the contract.\n    /// @return The amount of EVM gas used.\n    /// @return The address of created contract.\n    function createEVM(bytes calldata _initCode) external payable override onlySystemCall returns (uint256, address) {\n        uint256 senderNonce;\n        // If the account is an EOA, use the min nonce. If it's a contract, use deployment nonce\n        if (msg.sender == tx.origin) {\n            // Subtract 1 for EOA since the nonce has already been incremented for this transaction\n            senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.getMinNonce(msg.sender) - 1;\n        } else {\n            // Deploy from EraVM context\n            senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        }\n\n        address newAddress = Utils.getNewAddressCreateEVM(msg.sender, senderNonce);\n\n        uint256 evmGasUsed = _evmDeployOnAddress(msg.sender, newAddress, _initCode);\n\n        return (evmGasUsed, newAddress);\n    }\n\n    /// @notice Deploys an EVM contract using address derivation of EVM's `CREATE2` opcode.\n    /// @dev Note: this method may be callable only in system mode.\n    /// @param _salt The CREATE2 salt.\n    /// @param _initCode The init code for the contract.\n    /// @return The amount of EVM gas used.\n    /// @return The address of created contract.\n    function create2EVM(\n        bytes32 _salt,\n        bytes calldata _initCode\n    ) external payable override onlySystemCall returns (uint256, address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        // No collision is possible with the zksync's non-EVM CREATE2, since the prefixes are different\n        bytes32 bytecodeHash = EfficientCall.keccak(_initCode);\n        address newAddress = Utils.getNewAddressCreate2EVM(msg.sender, _salt, bytecodeHash);\n\n        uint256 evmGasUsed = _evmDeployOnAddress(msg.sender, newAddress, _initCode);\n\n        return (evmGasUsed, newAddress);\n    }\n\n    /// @notice Method used by EVM emulator to check if contract can be deployed and calculate the corresponding address.\n    /// @dev Note: this method may be callable only by the EVM emulator.\n    /// @param _salt The CREATE2 salt.\n    /// @param _evmBytecodeHash The keccak of EVM code to be deployed (initCode).\n    /// @return newAddress The address of the contract to be deployed.\n    function precreateEvmAccountFromEmulator(\n        bytes32 _salt,\n        bytes32 _evmBytecodeHash\n    ) public onlySystemCallFromEvmEmulator returns (address newAddress) {\n        if (allowedBytecodeTypesToDeploy != AllowedBytecodeTypes.EraVmAndEVM) {\n            revert EVMEmulationNotSupported();\n        }\n\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n\n        if (_evmBytecodeHash != bytes32(0)) {\n            // Create2 case\n            newAddress = Utils.getNewAddressCreate2EVM(msg.sender, _salt, _evmBytecodeHash);\n        } else {\n            // Create case\n            newAddress = Utils.getNewAddressCreateEVM(msg.sender, senderNonce);\n        }\n\n        return newAddress;\n    }\n\n    /// @notice Method used by EVM emulator to deploy contracts.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _initCode The EVM code to be deployed (initCode).\n    /// Note: only possible revert case should be due to revert in the called constructor.\n    /// Note: this method may be callable only by the EVM emulator.\n    function createEvmFromEmulator(\n        address _newAddress,\n        bytes calldata _initCode\n    ) external payable onlySystemCallFromEvmEmulator returns (uint256, address) {\n        uint256 constructorReturnEvmGas = _performDeployOnAddressEVM(\n            msg.sender,\n            _newAddress,\n            AccountAbstractionVersion.None,\n            _initCode\n        );\n        return (constructorReturnEvmGas, _newAddress);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        // Since the `forceDeployOnAddress` function is called only during upgrades, the Governance is trusted to correctly select\n        // the addresses to deploy the new bytecodes to and to assess whether overriding the AccountInfo for the \"force-deployed\"\n        // contract is acceptable.\n\n        if (Utils.isCodeHashEVM(_deployment.bytecodeHash)) {\n            // Note, that for contracts the \"nonce\" is set as deployment nonce.\n            uint256 deploymentNonce = NONCE_HOLDER_SYSTEM_CONTRACT.getDeploymentNonce(_deployment.newAddress);\n            if (deploymentNonce == 0) {\n                NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(_deployment.newAddress);\n            }\n\n            if (!_deployment.callConstructor) {\n                _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n            }\n\n            // It is not possible to change the AccountInfo for EVM contracts.\n            // _versionedBytecodeHash will be ignored if _callConstructor is true\n            _constructEVMContract({\n                _sender: _sender,\n                _newAddress: _deployment.newAddress,\n                _versionedBytecodeHash: _deployment.bytecodeHash,\n                _input: _deployment.input,\n                _callConstructor: _deployment.callConstructor\n            });\n        } else {\n            _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n\n            AccountInfo memory newAccountInfo;\n            newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n            // Accounts have sequential nonces by default.\n            newAccountInfo.nonceOrdering = AccountNonceOrdering.KeyedSequential;\n            _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n            _constructContract({\n                _sender: _sender,\n                _newAddress: _deployment.newAddress,\n                _bytecodeHash: _deployment.bytecodeHash,\n                _input: _deployment.input,\n                _isSystem: false,\n                _callConstructor: _deployment.callConstructor\n            });\n        }\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable override {\n        if (\n            msg.sender != FORCE_DEPLOYER &&\n            msg.sender != address(COMPLEX_UPGRADER_CONTRACT) &&\n            msg.sender != EVM_PREDEPLOYS_MANAGER\n        ) {\n            revert Unauthorized(msg.sender);\n        }\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        if (msg.value != sumOfValues) {\n            revert ValueMismatch(sumOfValues, msg.value);\n        }\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    /// @notice Changes what types of bytecodes are allowed to be deployed on the chain. Can be used only during upgrades.\n    /// @param newAllowedBytecodeTypes The new allowed bytecode types mode.\n    function setAllowedBytecodeTypesToDeploy(AllowedBytecodeTypes newAllowedBytecodeTypes) external {\n        if (\n            msg.sender != FORCE_DEPLOYER &&\n            msg.sender != address(COMPLEX_UPGRADER_CONTRACT) &&\n            msg.sender != SERVICE_CALL_PSEUDO_CALLER\n        ) {\n            revert Unauthorized(msg.sender);\n        }\n\n        if (allowedBytecodeTypesToDeploy != newAllowedBytecodeTypes) {\n            allowedBytecodeTypesToDeploy = newAllowedBytecodeTypes;\n\n            emit AllowedBytecodeTypesModeUpdated(newAllowedBytecodeTypes);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        if (_bytecodeHash == bytes32(0x0)) {\n            revert EmptyBytes32();\n        }\n        if (Utils.isCodeHashEVM(_bytecodeHash)) {\n            revert EVMBytecodeHash();\n        }\n        if (uint160(_newAddress) <= MAX_SYSTEM_CONTRACT_ADDRESS) {\n            revert NotAllowedToDeployInKernelSpace();\n        }\n\n        // We do not allow deploying twice on the same address.\n        bytes32 codeHash = ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress)));\n        if (codeHash != 0x0) {\n            revert HashIsNonZero(codeHash);\n        }\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        if (NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) != 0x00) {\n            revert NonEmptyAccount();\n        }\n\n        // solhint-disable-next-line func-named-parameters\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input, true);\n    }\n\n    function _evmDeployOnAddress(\n        address _sender,\n        address _newAddress,\n        bytes calldata _initCode\n    ) internal returns (uint256 constructorReturnEvmGas) {\n        if (allowedBytecodeTypesToDeploy != AllowedBytecodeTypes.EraVmAndEVM) {\n            revert EVMEmulationNotSupported();\n        }\n\n        // Unfortunately we can not provide revert reason as it would break EVM compatibility\n        // solhint-disable-next-line reason-string, gas-custom-errors\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x0);\n        // solhint-disable-next-line reason-string, gas-custom-errors\n        require(ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_newAddress) == 0x0);\n        return _performDeployOnAddressEVM(_sender, _newAddress, AccountAbstractionVersion.None, _initCode);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    /// @param _callConstructor Whether to run the constructor or not.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input,\n        bool _callConstructor\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.KeyedSequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract({\n            _sender: msg.sender,\n            _newAddress: _newAddress,\n            _bytecodeHash: _bytecodeHash,\n            _input: _input,\n            _isSystem: false,\n            _callConstructor: _callConstructor\n        });\n    }\n\n    /// @notice Deploy a certain EVM bytecode on the address.\n    /// @param _sender The deployer address.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    /// @return constructorReturnEvmGas The EVM gas left after constructor execution.\n    function _performDeployOnAddressEVM(\n        address _sender,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal returns (uint256 constructorReturnEvmGas) {\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.KeyedSequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        // Note, that for contracts the \"nonce\" is set as deployment nonce.\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(_newAddress);\n\n        // We will store dummy constructing bytecode hash to trigger EVM emulator in constructor call\n        return\n            _constructEVMContract({\n                _sender: _sender,\n                _newAddress: _newAddress,\n                _versionedBytecodeHash: bytes32(0), // Ignored since we will call constructor\n                _input: _input,\n                _callConstructor: true\n            });\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        if (knownCodeMarker == 0) {\n            revert UnknownCodeHash(_bytecodeHash);\n        }\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted versioned hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    /// @param _callConstructor Whether to run the constructor or not.\n    function _constructContract(\n        address _sender,\n        address _newAddress,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        bool _isSystem,\n        bool _callConstructor\n    ) internal {\n        uint256 value = msg.value;\n        if (_callConstructor) {\n            // 1. Transfer the balance to the new address on the constructor call.\n            if (value > 0) {\n                BASE_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            }\n            // 2. Set the constructed code hash on the account\n            _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n            // 3. Call the constructor on behalf of the account\n            if (value > 0) {\n                // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n                SystemContractHelper.setValueForNextFarCall(uint128(value));\n            }\n            bytes memory returnData = EfficientCall.mimicCall({\n                _gas: gasleft(),\n                _address: _newAddress,\n                _data: _input,\n                _whoToMimic: _sender,\n                _isConstructor: true,\n                _isSystem: _isSystem\n            });\n            // 4. Mark bytecode hash as constructed\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n            // 5. Set the contract immutables\n            ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n            IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        } else {\n            if (value != 0) {\n                revert NonEmptyMsgValue();\n            }\n            // If we do not call the constructor, we need to set the constructed code hash.\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructedCodeHash(_newAddress, _bytecodeHash);\n        }\n\n        emit ContractDeployed(_sender, _bytecodeHash, _newAddress);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor.\n    /// @param _newAddress The address of the deployed contract.\n    /// @param _versionedBytecodeHash The correctly formatted versioned hash of the bytecode (ignored if `_callConstructor` is true).\n    /// @param _input The constructor calldata.\n    /// @param _callConstructor Whether to run the constructor or not.\n    /// @return constructorReturnEvmGas The EVM gas left after constructor execution.\n    function _constructEVMContract(\n        address _sender,\n        address _newAddress,\n        bytes32 _versionedBytecodeHash,\n        bytes calldata _input,\n        bool _callConstructor\n    ) internal returns (uint256 constructorReturnEvmGas) {\n        uint256 value = msg.value;\n        if (_callConstructor) {\n            // 1. Transfer the balance to the new address on the constructor call.\n            if (value > 0) {\n                BASE_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            }\n\n            // 2. Set the constructing code hash on the account\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(\n                _newAddress,\n                // Dummy EVM bytecode hash just to call emulator.\n                // The second byte is `0x01` to indicate that it is being constructed.\n                bytes32(0x0201000000000000000000000000000000000000000000000000000000000000)\n            );\n\n            // 3. Call the constructor on behalf of the account\n            if (value > 0) {\n                // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n                SystemContractHelper.setValueForNextFarCall(uint128(value));\n            }\n\n            bytes memory paddedBytecode = EfficientCall.mimicCall({\n                _gas: gasleft(), // note: native gas, not EVM gas\n                _address: _newAddress,\n                _data: _input,\n                _whoToMimic: _sender,\n                _isConstructor: true,\n                _isSystem: false\n            });\n\n            uint256 evmBytecodeLen;\n            // Returned data bytes have structure: paddedBytecode.evmBytecodeLen.constructorReturnEvmGas\n            assembly {\n                let dataLen := mload(paddedBytecode)\n                evmBytecodeLen := mload(add(paddedBytecode, sub(dataLen, 0x20)))\n                constructorReturnEvmGas := mload(add(paddedBytecode, dataLen))\n                mstore(paddedBytecode, sub(dataLen, 0x40)) // shrink paddedBytecode\n            }\n\n            _versionedBytecodeHash = KNOWN_CODE_STORAGE_CONTRACT.publishEVMBytecode(evmBytecodeLen, paddedBytecode);\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructedCodeHash(_newAddress, _versionedBytecodeHash);\n\n            // Calculate keccak256 of the EVM bytecode if it hasn't been done before\n            if (EVM_HASHES_STORAGE.getEvmCodeHash(_versionedBytecodeHash) == bytes32(0)) {\n                bytes32 evmBytecodeHash;\n                assembly {\n                    evmBytecodeHash := keccak256(add(paddedBytecode, 0x20), evmBytecodeLen)\n                }\n\n                EVM_HASHES_STORAGE.storeEvmCodeHash(_versionedBytecodeHash, evmBytecodeHash);\n            }\n        } else {\n            if (value != 0) {\n                revert NonEmptyMsgValue();\n            }\n\n            // Sanity check, EVM code hash should be present if versioned bytecode hash is known\n            if (EVM_HASHES_STORAGE.getEvmCodeHash(_versionedBytecodeHash) == bytes32(0)) {\n                revert EVMBytecodeHashUnknown();\n            }\n\n            // If we do not call the constructor, we need to set the constructed code hash.\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructedCodeHash(_newAddress, _versionedBytecodeHash);\n        }\n\n        emit ContractDeployed(_sender, _versionedBytecodeHash, _newAddress);\n    }\n}\n"
    }
}