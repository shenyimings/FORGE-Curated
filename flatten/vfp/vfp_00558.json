{
    "vfp_id": "vfp_00558",
    "project_name": "blocksec_astherus_202502-signed.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Lack of invoking function reDelegateTokens() after mpcWallet update",
            "description": "The YieldProxy contract delegates minted clisBNB tokens to an mpcWallet to earn rewards. However, when the MANAGER role updates the mpcWallet via setMPCWallet(), it does not automatically invoke reDelegateTokens(). The SlisBNBProvider only allows delegation to one target at a time, so failure to redelegate after the update causes the delegation to remain with the old mpcWallet. This results in a denial of service where users cannot mint asBNB. The root cause is the separation of wallet update and redelegation into two independent functions without an automated linkage. An attacker or malicious actor with the MANAGER role could exploit this by updating the wallet and not triggering redelegation, disrupting service. The impact is a temporary DoS affecting user deposits and minting functionality.\n",
            "severity": "Low",
            "location": [
                "YieldProxy.sol::setMPCWallet#338",
                "YieldProxy.sol::reDelegateTokens#304"
            ],
            "files": [
                "61fc9f5610914cf94dddc3ab83e21ca22d388e92/ass-bnb-earn-contract/src/YieldProxy.sol"
            ]
        }
    ],
    "affected_files": {
        "YieldProxy.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"./interfaces/IAsBnbMinter.sol\";\nimport \"./interfaces/IYieldProxy.sol\";\nimport \"./interfaces/IAsBNB.sol\";\nimport \"./interfaces/ISlisBNBProvider.sol\";\nimport \"./interfaces/IListaStakeManager.sol\";\n\ncontract YieldProxy is\n  IYieldProxy,\n  AccessControlUpgradeable,\n  PausableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  UUPSUpgradeable\n{\n  using SafeERC20 for IERC20;\n  // pause role\n  bytes32 public constant PAUSER = keccak256(\"PAUSER\");\n  // minter role\n  bytes32 public constant MINTER = keccak256(\"MINTER\");\n  // bot role\n  bytes32 public constant BOT = keccak256(\"BOT\");\n  // manager role\n  bytes32 public constant MANAGER = keccak256(\"MANAGER\");\n\n  /* ======================\n        State Variables\n   ====================== */\n  // token address\n  IERC20 public token;\n  // asBnb address\n  IAsBNB public asBnb;\n\n  // launchpool activities\n  Activity[] public activities;\n  uint256 public lastUpdatedActivityIdx;\n\n  // minter\n  IAsBnbMinter public minter;\n\n  // @dev clisBNB related\n  // the accumulated amount of token rewarded from the activity\n  uint256 public rewardedAmount;\n  // the address(from Lista) sends the rewards\n  address public rewardsSender;\n\n  // Lista Stake Manager - deposit BNB and get slisBNB\n  address public stakeManager;\n  // Lista slisBNB Provider - collateralize slisBNB and get clisBNB\n  address public slisBNBProvider;\n  // Lista MPC wallet - delegate to this wallet to participate in LaunchPools\n  address public mpcWallet;\n\n  /* ======================\n            Events\n   ====================== */\n  event ActivityAdded(uint256 startTime, uint256 endTime, uint256 rewardedTime, string tokenName);\n  event ActivitySettled(uint256 rewardedTime, uint256 compoundedAmount, string tokenName);\n  event Received(address indexed sender, uint256 value);\n  event MinterSet(address indexed oldMinter, address indexed newMinter);\n  event SlisBNBProviderSet(address indexed oldSlisBNBProvider, address indexed newSlisBNBProvider);\n  event MPCWalletSet(address indexed oldMpcWallet, address indexed newMpcWallet);\n  event RewardsSenderSet(address indexed oldRewardsSender, address indexed newRewardsSender);\n  event TokenDelegated(address indexed sender, uint256 amount, uint256 lpAmount);\n  event NativeTokensWithdrawn(address indexed sender, uint256 amount);\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev initialize the contract\n   * @param _admin - Address of the admin\n   * @param _manager - Address of the manager\n   * @param _pauser - Address of the pauser\n   * @param _bot - Address of the bot\n   * @param _token - Address of token\n   * @param _asBnb - Address of asBnb\n   * @param _stakeManager - Address of Lista Stake Manager\n   */\n  function initialize(\n    address _admin,\n    address _manager,\n    address _pauser,\n    address _bot,\n    address _token,\n    address _asBnb,\n    address _stakeManager,\n    address _mpcWallet\n  ) external initializer {\n    require(_admin != address(0), \"Invalid admin address\");\n    require(_manager != address(0), \"Invalid manager address\");\n    require(_pauser != address(0), \"Invalid pauser address\");\n    require(_bot != address(0), \"Invalid bot address\");\n    require(_token != address(0), \"Invalid token address\");\n    require(_asBnb != address(0), \"Invalid asBnb address\");\n    require(_stakeManager != address(0), \"Invalid stakeManager address\");\n    require(_mpcWallet != address(0), \"Invalid MPC wallet address\");\n\n    __Pausable_init();\n    __ReentrancyGuard_init();\n    __AccessControl_init();\n    __UUPSUpgradeable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    _grantRole(MANAGER, _manager);\n    _grantRole(PAUSER, _pauser);\n    _grantRole(BOT, _bot);\n\n    token = IERC20(_token);\n    asBnb = IAsBNB(_asBnb);\n    stakeManager = _stakeManager;\n    slisBNBProvider = address(0);\n    mpcWallet = _mpcWallet;\n  }\n\n  /* ============================\n          External Getters\n  ============================ */\n  /**\n   * @dev check if there is any activity ongoing\n   *      to save gas, searching from `lastUpdatedActivityIdx`\n   *      as activities before that are already settled\n   */\n  function activitiesOnGoing() external view override returns (bool) {\n    for (uint256 i = lastUpdatedActivityIdx; i < activities.length; ++i) {\n      Activity memory activity = activities[i];\n      // if it's started and not rewarded yet\n      if (activity.startTime <= block.timestamp && activity.rewardedTime == 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /* ============================\n        External Functions\n  ============================ */\n  /**\n   * @dev deposit slisBNB into this contract\n   * @notice after transition period, clisBNBProvider will be set\n   *         and the deposit will be converted to clisBNB\n   * @param amount - amount of BNB\n   */\n  function deposit(uint256 amount) external override onlyRole(MINTER) whenNotPaused {\n    require(amount > 0, \"Invalid amount\");\n    token.safeTransferFrom(msg.sender, address(this), amount);\n\n    // transition period\n    if (slisBNBProvider != address(0)) {\n      // convert to clisBNB and delegate to Lista's MPC\n      token.safeIncreaseAllowance(slisBNBProvider, amount);\n      uint256 lpAmount = ISlisBNBProvider(slisBNBProvider).provide(amount, mpcWallet);\n      emit TokenDelegated(msg.sender, amount, lpAmount);\n    }\n  }\n\n  /**\n   * @dev allows user withdraw token with their asBnb\n   * @param amount - amount of asBnb\n   */\n  function withdraw(uint256 amount) external override onlyRole(MINTER) nonReentrant whenNotPaused {\n    require(slisBNBProvider != address(0), \"slisBNBProvider not set\");\n    require(amount > 0, \"Invalid amount\");\n    // pre balance of slisBNB\n    uint256 preBalance = token.balanceOf(address(this));\n    // withdraw tokens to minter\n    ISlisBNBProvider(slisBNBProvider).release(address(this), amount);\n    // post balance of slisBNB\n    uint256 postBalance = token.balanceOf(address(this));\n    if (postBalance - preBalance != amount) {\n      // if there is a difference, revert\n      revert(\"Invalid amount\");\n    }\n    // send to minter\n    token.safeTransfer(msg.sender, amount);\n  }\n\n  /**\n   * @dev settle the activity\n   * @notice only the bot can settle the activity\n   *         also rewards from activity will be compounded\n   */\n  function settleActivity() external onlyRole(BOT) whenNotPaused {\n    // only if there is active activity\n    // and the rewarded amount is not 0\n    require(address(minter) != address(0), \"Minter not set\");\n    require(this.activitiesOnGoing(), \"No active activity\");\n    require(rewardedAmount > 0, \"No rewards to compound\");\n\n    // save rewarded time\n    activities[lastUpdatedActivityIdx].rewardedTime = block.timestamp;\n    // update last updated activity index\n    ++lastUpdatedActivityIdx;\n\n    // get pre-balance of slisBNB\n    uint256 preBalance = token.balanceOf(address(this));\n    // convert BNB to slisBNB\n    IListaStakeManager(stakeManager).deposit{ value: rewardedAmount }();\n    // get post-balance of slisBNB\n    uint256 postBalance = token.balanceOf(address(this));\n    uint256 netBalance = postBalance - preBalance;\n    // compound rewards\n    token.safeIncreaseAllowance(address(minter), netBalance);\n    minter.compoundRewards(netBalance);\n    // emit event\n    emit ActivitySettled(block.timestamp, rewardedAmount, activities[lastUpdatedActivityIdx - 1].tokenName);\n    // reset the rewarded amount\n    rewardedAmount = 0;\n  }\n\n  /**\n   * @dev admin withdraw native token (BNB)\n   *      not including the rewarded amount\n   * @param amount - amount of BNB\n   */\n  function withdrawNativeToken(uint256 amount) external onlyRole(MANAGER) {\n    require(amount > 0, \"Invalid amount\");\n    require(address(this).balance - rewardedAmount >= amount, \"Insufficient balance\");\n    payable(msg.sender).transfer(amount);\n    emit NativeTokensWithdrawn(msg.sender, amount);\n  }\n\n  // @dev records how much BNB was sent by the sender\n  receive() external payable {\n    // add up amounts determined by the sender\n    if (msg.sender == rewardsSender) {\n      rewardedAmount += msg.value;\n    }\n    emit Received(msg.sender, msg.value);\n  }\n\n  /* ============================\n          Admin Functions\n  ============================ */\n  /**\n   * @dev Flips the pause state\n   */\n  function unpause() external onlyRole(MANAGER) {\n    _unpause();\n  }\n\n  /**\n   * @dev pause the contract\n   */\n  function pause() external onlyRole(PAUSER) {\n    _pause();\n  }\n\n  /**\n   * @dev add an activity\n   * @param _startTime - start time of the activity\n   * @param _endTime - end time of the activity\n   * @param _tokenName - name of the token\n   */\n  function addActivity(\n    uint256 _startTime,\n    uint256 _endTime,\n    string memory _tokenName\n  ) external onlyRole(MANAGER) whenNotPaused {\n    require(_startTime > block.timestamp, \"Invalid start time\");\n    require(_startTime < _endTime, \"Invalid time range\");\n    require(bytes(_tokenName).length > 0, \"Invalid token name\");\n    activities.push(Activity(_startTime, _endTime, 0, _tokenName));\n    emit ActivityAdded(_startTime, _endTime, 0, _tokenName);\n  }\n\n  /**\n   * @dev end one or more activities from the last updated activity idx\n   * @param numberOfActivity - number of the activity to end\n   */\n  function endActivity(uint256 numberOfActivity) external onlyRole(MANAGER) whenNotPaused {\n    require(numberOfActivity > 0, \"Invalid number of activities\");\n    // cache the last updated activity index\n    uint256 max = lastUpdatedActivityIdx + numberOfActivity;\n    // starting from lastUpdatedActivityIdx\n    for (uint256 i = lastUpdatedActivityIdx; i < max; ++i) {\n      // break if reach to the end\n      if (i >= activities.length) {\n        break;\n      }\n      activities[i].rewardedTime = block.timestamp;\n      // emit event, note that no reward is compounded\n      emit ActivitySettled(block.timestamp, 0, activities[lastUpdatedActivityIdx].tokenName);\n      // update last updated activity index\n      ++lastUpdatedActivityIdx;\n    }\n  }\n\n  /**\n   * @dev Delegate all tokens to a new MPC Wallet\n   * @notice When Lista has announced in advance that the MPC wallet will be changed,\n   *         manager(multi-sig) can call this function to delegate all tokens to the new MPC wallet\n   */\n  function reDelegateTokens() external onlyRole(MANAGER) whenNotPaused {\n    require(slisBNBProvider != address(0), \"slisBNBProvider not set\");\n    require(mpcWallet != address(0), \"mpcWallet not set\");\n    ISlisBNBProvider(slisBNBProvider).delegateAllTo(mpcWallet);\n  }\n\n  /**\n   * @dev convert all slisBNB to clisBNB\n   */\n  function convertAllSlisBNBToClisBNB() external onlyRole(MANAGER) whenNotPaused {\n    require(slisBNBProvider != address(0), \"slisBNBProvider not set\");\n    require(mpcWallet != address(0), \"mpcWallet not set\");\n    uint256 balance = token.balanceOf(address(this));\n    if (balance > 0) {\n      token.safeIncreaseAllowance(slisBNBProvider, balance);\n      ISlisBNBProvider(slisBNBProvider).provide(balance, mpcWallet);\n    }\n  }\n\n  /**\n   * @dev set slisBNBProvider address\n   * @param _slisBNBProvider - address of the slisBNBProvider\n   */\n  function setSlisBNBProvider(address _slisBNBProvider) external onlyRole(MANAGER) {\n    require(_slisBNBProvider != address(0) && _slisBNBProvider != slisBNBProvider, \"Invalid slisBNBProvider address\");\n    address oldSlisBNBProvider = slisBNBProvider;\n    slisBNBProvider = _slisBNBProvider;\n    emit SlisBNBProviderSet(oldSlisBNBProvider, _slisBNBProvider);\n  }\n\n  /**\n   * @dev set MPC wallet\n   * @param _mpcWallet - address of the MPC wallet\n   */\n  function setMPCWallet(address _mpcWallet) external onlyRole(MANAGER) {\n    require(_mpcWallet != address(0) && _mpcWallet != mpcWallet, \"Invalid MPC wallet address\");\n    address oldMpcWallet = mpcWallet;\n    mpcWallet = _mpcWallet;\n    emit MPCWalletSet(oldMpcWallet, _mpcWallet);\n  }\n\n  /**\n   * @dev set rewards sender\n   * @param _rewardsSender - address of the rewards sender\n   */\n  function setRewardsSender(address _rewardsSender) external onlyRole(MANAGER) {\n    require(_rewardsSender != address(0) && _rewardsSender != rewardsSender, \"Invalid rewards sender address\");\n    address oldRewardsSender = rewardsSender;\n    rewardsSender = _rewardsSender;\n    emit RewardsSenderSet(oldRewardsSender, _rewardsSender);\n  }\n\n  /**\n   * @dev set minter\n   * @param _minter - address of the minter\n   */\n  function setMinter(address _minter) external onlyRole(MANAGER) {\n    require(_minter != address(0) && _minter != address(minter), \"Invalid minter address\");\n\n    address oldMinter = address(minter);\n    // revoke previous minter's MINTER ROLE\n    _revokeRole(MINTER, oldMinter);\n    // set new minter\n    minter = IAsBnbMinter(_minter);\n    // grant role and revoke previous minter's MINTER ROLE\n    _grantRole(MINTER, _minter);\n\n    emit MinterSet(oldMinter, _minter);\n  }\n\n  /* ============================\n        Internal Functions\n  ============================ */\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n}\n"
    }
}