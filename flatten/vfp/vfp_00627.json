{
    "vfp_id": "vfp_00627",
    "project_name": "cantina_tadle_oct2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Permanent block of withdrawal requests",
            "description": "The ETH withdrawal logic in main.sol compares the contract's current balance against the sum of claimed ETH and the requested withdrawal amount. However, if the airdrop contract records the exact ETH amount claimed, the balance becomes equal to the claimed amount immediately after the first claim. This makes any subsequent withdrawal request fail because claimedAmount + amt exceeds the current balance, even if sufficient funds are present. The root cause is the flawed accounting logic that does not track spendable vs. claimed funds. An attacker or malicious airdrop design could trigger this condition, causing the smart account to be unable to withdraw ETH despite holding it. The impact is permanent locking of ETH within the account, rendering it unusable.\n",
            "severity": "High",
            "location": [
                "main.sol::withdraw#117-125"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/airdrop/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/account-manager-v1/main.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "Use constant for connector name",
            "description": "The name variable in main.sol is stored in storage when it could be a compile-time constant. This wastes gas on deployment and runtime reads. The root cause is suboptimal use of storage for immutable data. While the behavior is correct, using a constant would reduce gas costs and eliminate storage collision risks under delegatecall. The impact is slightly higher gas usage and reduced efficiency, with no security implications.\n",
            "severity": "Low",
            "location": [
                "main.sol::name#94"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/account-manager-v1/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/airdrop/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/nad-fun/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/aprioi/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-v3/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-swap/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/magma/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/weth/main.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Slippage input mis-scaled, causing reverts or loose fills",
            "description": "The mint and deposit functions accept slippage in basis points but pass it directly to internal functions expecting WAD-scale (1e18 = 100%). This causes a 1% slippage input (100) to be interpreted as 0.00000000000000001%, making trades extremely sensitive to price changes and likely to revert. Conversely, large inputs create excessive slippage, leading to poor execution prices. The root cause is a unit mismatch between the public interface and internal logic. Users or bots may incorrectly adjust slippage values trying to fix reverts, worsening the issue. The impact includes failed transactions, suboptimal trade execution, and potential financial loss due to unfavorable fills.\n",
            "severity": "Medium",
            "location": [
                "main.sol::mint#84",
                "main.sol::_mint#",
                "main.sol::getMinAmount#"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-swap/main.sol",
                "v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-v3/main.sol"
            ]
        }
    ],
    "affected_files": {
        "main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {TokenHelper, TokenInterface} from \"../../../libraries/TokenHelper.sol\";\nimport {Stores} from \"../implementation/Stores.sol\";\n\n/**\n * @title WETHResolver\n * @dev Contract for handling WETH (Wrapped Ether) operations\n * @notice Provides functionality for wrapping and unwrapping ETH\n */\ncontract WETHResolver is Stores {\n    /// @dev Reference to the WETH token contract\n    TokenInterface public immutable weth;\n\n    /**\n     * @dev Initializes the contract with WETH address\n     * @param _weth Address of WETH token contract\n     * @param _tadleMemory Address of storage contract\n     */\n    constructor(address _weth, address _tadleMemory) Stores(_tadleMemory) {\n        weth = TokenInterface(_weth);\n    }\n\n    /**\n     * @dev Deposits ETH to receive WETH\n     * @param _amt Amount of ETH to wrap (in wei)\n     * @param getId Storage ID to retrieve amount, 0 for direct input\n     * @param setId Storage ID to store wrapped amount, 0 to skip storage\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     */\n    function deposit(uint256 _amt, uint256 getId, uint256 setId)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Get amount from storage if ID provided\n        uint256 amount = getUint(getId, _amt);\n        require(amount > 0, \"Invalid deposit amount\");\n\n        // Convert ETH to WETH\n        TokenHelper.convertEthToWeth(true, weth, amount);\n\n        // Store result if setId provided\n        if (setId != 0) {\n            setUint(setId, amount);\n        }\n\n        // Return event data\n        _eventName = \"LogDeposit(address,uint256)\";\n        _eventParam = abi.encode(address(this), amount);\n    }\n\n    /**\n     * @dev Withdraws ETH by unwrapping WETH\n     * @param _amt Amount of WETH to unwrap (in wei)\n     * @param getId Storage ID to retrieve amount, 0 for direct input\n     * @param setId Storage ID to store unwrapped amount, 0 to skip storage\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     */\n    function withdraw(uint256 _amt, uint256 getId, uint256 setId)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Get amount from storage if ID provided\n        uint256 amount = getUint(getId, _amt);\n        require(amount > 0, \"Invalid withdrawal amount\");\n\n        // Check WETH balance\n        require(weth.balanceOf(address(this)) >= amount, \"Insufficient WETH balance\");\n\n        // Convert WETH to ETH\n        TokenHelper.convertWethToEth(true, weth, amount);\n\n        // Store result if setId provided\n        if (setId != 0) {\n            setUint(setId, amount);\n        }\n\n        // Return event data\n        _eventName = \"LogWithdraw(address,uint256)\";\n        _eventParam = abi.encode(address(this), amount);\n    }\n}\n\n/**\n * @title ConnectV1WETH\n * @dev Connector implementation for WETH operations\n * @notice Entry point for WETH wrapping and unwrapping\n */\ncontract ConnectV1WETH is WETHResolver {\n    /// @dev Version identifier for the connector\n    string public name = \"WETH-v1.0.0\";\n\n    /**\n     * @dev Initializes the connector with required dependencies\n     * @param _weth Address of WETH token contract\n     * @param _tadleMemory Address of storage contract\n     */\n    constructor(address _weth, address _tadleMemory) WETHResolver(_weth, _tadleMemory) {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/magma/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title IMagmaStakeManager Interface\n * @dev Interface for interacting with Magma protocol's staking functions\n * @notice Defines core staking operations for MON tokens\n */\ninterface IMagmaStakeManager {\n    /**\n     * @dev Deposits MON tokens into the staking contract\n     * @param _referralId Referral ID for the deposit (0 for no referral)\n     */\n    function depositMon(uint256 _referralId) external payable;\n\n    /**\n     * @dev Withdraws staked MON tokens\n     * @param amount Amount of MON tokens to withdraw\n     */\n    function withdrawMon(uint256 amount) external;\n}\n\n/**\n * @title MagmaResolver\n * @dev Contract for handling Magma protocol staking operations\n * @notice Provides functionality for MON staking and unstaking with gMON tokens\n */\ncontract MagmaResolver {\n    using SafeERC20 for IERC20;\n\n    // ============ Storage ============\n    /// @dev Reference to the Magma staking manager contract\n    IMagmaStakeManager public immutable MAGMA_STAKE_MANAGER;\n    /// @dev Address of the gMON token contract\n    address public immutable gMON;\n\n    // ============ Events ============\n    /// @dev Emitted when token approval is granted\n    event TokenApproval(address indexed token, uint256 amount);\n\n    /**\n     * @dev Initializes the contract with required addresses\n     * @param _magmaStakeManager Address of the Magma staking manager contract\n     * @param _gMON Address of the gMON token contract\n     */\n    constructor(address _magmaStakeManager, address _gMON) {\n        require(_magmaStakeManager != address(0), \"Invalid Magma address\");\n        require(_gMON != address(0), \"Invalid gMON address\");\n\n        MAGMA_STAKE_MANAGER = IMagmaStakeManager(_magmaStakeManager);\n        gMON = _gMON;\n    }\n\n    /**\n     * @dev Deposits MON tokens and receives gMON in return\n     * @notice Stakes MON tokens in the Magma protocol with no referral\n     * @param assets Amount of MON to deposit\n     * @return _eventName Name of the event to be logged\n     * @return _eventParam Encoded event parameters\n     */\n    function depositMon(uint256 assets) external returns (string memory _eventName, bytes memory _eventParam) {\n        require(address(this).balance >= assets, \"Insufficient MON balance\");\n\n        uint256 balanceBefore = IERC20(gMON).balanceOf(address(this));\n        MAGMA_STAKE_MANAGER.depositMon{value: assets}(0);\n        uint256 balanceAfter = IERC20(gMON).balanceOf(address(this));\n        uint256 amountOut = balanceAfter - balanceBefore;\n\n        _eventName = \"LogDepositMon(address,uint256,uint256)\";\n        _eventParam = abi.encode(address(this), assets, amountOut);\n    }\n\n    /**\n     * @dev Withdraws MON tokens by unstaking gMON\n     * @notice Unstakes MON tokens from the Magma protocol\n     * @param amount Amount of MON to withdraw\n     * @return _eventName Name of the event to be logged\n     * @return _eventParam Encoded event parameters\n     */\n    function withdrawMon(uint256 amount) external returns (string memory _eventName, bytes memory _eventParam) {\n        uint256 balanceBefore = address(this).balance;\n        MAGMA_STAKE_MANAGER.withdrawMon(amount);\n        uint256 balanceAfter = address(this).balance;\n        uint256 amountOut = balanceAfter - balanceBefore;\n\n        _eventName = \"LogWithdrawMon(address,uint256)\";\n        _eventParam = abi.encode(address(this), amountOut);\n    }\n\n    /// @dev Required to receive MON tokens\n    receive() external payable {}\n}\n\n/**\n * @title ConnectV1Magma\n * @dev Connector implementation for Magma protocol v1\n * @notice Entry point for Magma protocol interactions\n */\ncontract ConnectV1Magma is MagmaResolver {\n    /// @dev Version identifier for the connector\n    string public constant name = \"Magma-v1.0.0\";\n\n    constructor(address _magmaStakeManager, address _gMON) MagmaResolver(_magmaStakeManager, _gMON) {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-swap/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {UniswapRouter02Helper} from \"./helpers.sol\";\n\n/**\n * @title UniswapSwapRouter\n * @dev Contract for executing token swaps through Uniswap\n * @notice Provides high-level swap functionality with storage integration\n */\ncontract UniswapSwapRouter02Resolver is UniswapRouter02Helper {\n    /**\n     * @dev Initializes the contract with required addresses\n     * @param _uniswapRouter Address of Uniswap Router contract\n     * @param _wethAddr Address of WETH token\n     * @param _tadleMemory Address of storage contract\n     */\n    constructor(address _uniswapRouter, address _wethAddr, address _tadleMemory)\n        UniswapRouter02Helper(_uniswapRouter, _wethAddr, _tadleMemory)\n    {}\n\n    /**\n     * @dev Executes a token swap with storage integration\n     * @param amountIn Amount of input tokens\n     * @param amountOutMin Minimum amount of output tokens expected\n     * @param path Encoded swap path data\n     * @param getIds Storage ID for retrieving input amount\n     * @param setIds Storage ID for storing output amount\n     * @return _eventName Name of the event to be logged\n     * @return _eventParam Encoded event parameters\n     */\n    function buy(bool isEth, uint256 amountIn, uint256 amountOutMin, bytes memory path, uint256 getIds, uint256 setIds)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Get input amount from storage\n        amountIn = getUint(getIds, amountIn);\n\n        // Execute swap\n        uint256 amountOut = _buy(amountIn, amountOutMin, address(this), isEth, path);\n\n        // Store output amount\n        setUint(setIds, amountOut);\n\n        // Return event data\n        _eventName = \"Buy(address,bytes,uint256,uint256)\";\n        _eventParam = abi.encode(address(this), path, amountIn, amountOut);\n    }\n}\n\n/**\n * @title ConnectV1UniswapSwapRouter02\n * @dev Connector implementation for Uniswap Router V2\n * @notice Entry point for Uniswap V2/V3 swap operations\n */\ncontract ConnectV1UniswapSwapRouter02 is UniswapSwapRouter02Resolver {\n    /// @dev Version identifier for the connector\n    string public constant name = \"UniswapSwapRouter02-v1.0.0\";\n\n    /**\n     * @dev Initializes the connector with required dependencies\n     * @param _uniswapRouter Address of Uniswap Router contract\n     * @param _wethAddr Address of WETH token\n     * @param _tadleMemory Address of storage contract\n     */\n    constructor(address _uniswapRouter, address _wethAddr, address _tadleMemory)\n        UniswapSwapRouter02Resolver(_uniswapRouter, _wethAddr, _tadleMemory)\n    {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/aprioi/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title IAprioi Interface\n * @author Tadle Team\n * @notice Interface for interacting with Aprioi protocol's core functions\n * @dev Extends IERC20 with deposit and redemption functionality\n */\ninterface IAprioi is IERC20 {\n    /// @notice Deposit ETH to receive aprMON tokens\n    /// @param assets Amount of ETH to deposit\n    /// @param receiver Address to receive aprMON tokens\n    function deposit(uint256 assets, address receiver) external payable;\n\n    /// @notice Request to redeem aprMON tokens for ETH\n    /// @param shares Amount of aprMON tokens to redeem\n    /// @param controller Address to control the redemption\n    /// @param owner Address that owns the aprMON tokens\n    /// @return requestId Unique identifier for the redemption request\n    function requestRedeem(\n        uint256 shares,\n        address controller,\n        address owner\n    ) external returns (uint256 requestId);\n\n    /// @notice Complete redemption and receive ETH\n    /// @param requestId ID of the redemption request\n    /// @param receiver Address to receive ETH\n    function redeem(uint256 requestId, address receiver) external;\n}\n\n/**\n * @title AprioiResolver\n * @author Tadle Team\n * @notice Contract for handling Aprioi protocol interactions\n * @dev Manages deposits, redemption requests, and withdrawals for aprMON tokens\n * @custom:security Implements balance tracking and validation\n */\ncontract AprioiResolver {\n    using SafeERC20 for IERC20;\n\n    // ============ Storage ============\n    /// @dev Address of the Aprioi protocol contract\n    /// @notice Immutable reference to the main protocol contract\n    address public immutable APRIOI;\n\n    // ============ Events ============\n    /// @dev Emitted when tokens are approved for spending\n    /// @notice Tracks token approval operations\n    event TokenApproval(address indexed token, uint256 amount);\n\n    /**\n     * @dev Initialize contract with Aprioi protocol address\n     * @param _aprioi Address of Aprioi protocol\n     * @notice Sets up the resolver with the Aprioi protocol contract\n     * @custom:validation Ensures protocol address is not zero\n     */\n    constructor(address _aprioi) {\n        require(\n            _aprioi != address(0),\n            \"AprioiResolver: protocol address cannot be zero\"\n        );\n        APRIOI = _aprioi;\n    }\n\n    /**\n     * @dev Deposit ETH to receive aprMON tokens\n     * @param assets Amount of ETH to deposit\n     * @param receiver Address to receive aprMON tokens (must be this contract)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     * @notice Converts ETH to aprMON tokens through the protocol\n     * @custom:validation Validates receiver and balance before deposit\n     * @custom:security Tracks balance changes to calculate exact output\n     */\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        // Validate inputs\n        require(\n            receiver == address(this),\n            \"AprioiResolver: receiver must be this contract\"\n        );\n        require(\n            address(this).balance >= assets,\n            \"AprioiResolver: insufficient ETH balance for deposit\"\n        );\n\n        // Track token balance changes\n        uint256 balanceBefore = IAprioi(APRIOI).balanceOf(receiver);\n\n        // Execute deposit\n        IAprioi(APRIOI).deposit{value: assets}(assets, receiver);\n\n        // Calculate received tokens\n        uint256 balanceAfter = IAprioi(APRIOI).balanceOf(receiver);\n        uint256 amountOut = balanceAfter - balanceBefore;\n\n        _eventName = \"LogDeposit(address,uint256,uint256)\";\n        _eventParam = abi.encode(receiver, assets, amountOut);\n    }\n\n    /**\n     * @dev Request to redeem aprMON tokens for ETH\n     * @param shares Amount of aprMON tokens to redeem\n     * @param controller Address to control the redemption (must be this contract)\n     * @param owner Address that owns the aprMON tokens (must be this contract)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     * @notice Initiates the redemption process for aprMON tokens\n     * @custom:validation Ensures controller and owner are this contract\n     */\n    function requestRedeem(\n        uint256 shares,\n        address controller,\n        address owner\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        // Validate inputs\n        require(\n            controller == address(this),\n            \"AprioiResolver: controller must be this contract\"\n        );\n        require(\n            owner == address(this),\n            \"AprioiResolver: owner must be this contract\"\n        );\n\n        // Submit redemption request\n        uint256 requestId = IAprioi(APRIOI).requestRedeem(\n            shares,\n            controller,\n            owner\n        );\n\n        _eventName = \"LogRequestRedeem(uint256,address,address,uint256)\";\n        _eventParam = abi.encode(shares, controller, owner, requestId);\n    }\n\n    /**\n     * @dev Complete redemption and receive ETH\n     * @param requestId ID of the redemption request\n     * @param receiver Address to receive ETH (must be this contract)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     * @notice Completes the redemption process and receives ETH\n     * @custom:validation Validates receiver address\n     * @custom:security Tracks balance changes to calculate exact output\n     */\n    function redeem(\n        uint256 requestId,\n        address receiver\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        // Validate inputs\n        require(\n            receiver == address(this),\n            \"AprioiResolver: receiver must be this contract\"\n        );\n\n        // Track ETH balance changes\n        uint256 balanceBefore = address(receiver).balance;\n\n        // Execute redemption\n        IAprioi(APRIOI).redeem(requestId, receiver);\n\n        // Calculate received ETH\n        uint256 balanceAfter = address(receiver).balance;\n        uint256 amountOut = balanceAfter - balanceBefore;\n\n        _eventName = \"LogRedeem(uint256,address,uint256)\";\n        _eventParam = abi.encode(requestId, receiver, amountOut);\n    }\n\n    /**\n     * @dev Required to receive ETH\n     * @notice Allows the contract to receive ETH from deposits and redemptions\n     * @custom:payable Essential for protocol interactions\n     */\n    receive() external payable {}\n}\n\n/**\n * @title ConnectV1Aprioi\n * @author Tadle Team\n * @notice Version 1.0.0 of the Aprioi connector\n * @dev Extends AprioiResolver with version identification\n * @custom:version 1.0.0\n */\ncontract ConnectV1Aprioi is AprioiResolver {\n    /// @dev Version identifier for the connector\n    /// @notice Human-readable version string\n    string public constant name = \"Aprioi-v1.0.0\";\n\n    /**\n     * @dev Constructor to initialize the Aprioi connector\n     * @param _aprioi Address of the Aprioi protocol\n     * @notice Sets up the connector with the required protocol contract\n     * @custom:initialization Inherits validation from AprioiResolver\n     */\n    constructor(address _aprioi) AprioiResolver(_aprioi) {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/account-manager-v1/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {TokenHelper, TokenInterface} from \"../../../libraries/TokenHelper.sol\";\n\n/**\n * @title IAirdrop\n * @author Tadle Team\n * @notice Interface for interacting with the Airdrop contract\n * @dev Provides functionality to query user claimed amounts\n */\ninterface IAirdrop {\n    /// @notice Get the amount of tokens claimed by a user\n    /// @param user Address of the user\n    /// @param token Address of the token\n    /// @return Amount of tokens claimed by the user\n    function getUserClaimedAmount(\n        address user,\n        address token\n    ) external view returns (uint256);\n}\n\n/**\n * @title IValidator\n * @notice Interface for validator contract\n * @dev Provides token whitelist verification functionality\n */\ninterface IValidator {\n    /// @notice Verify if a validator is authorized for a specific key\n    /// @param _key The validation key\n    /// @param _validator The validator address to check\n    /// @return True if validator is authorized, false otherwise\n    function verify(\n        bytes32 _key,\n        address _validator\n    ) external view returns (bool);\n}\n\n/**\n * @title AccountManagerResolver\n * @author Tadle Team\n * @notice Contract for managing account operations and asset withdrawals\n * @dev Handles secure token withdrawals with airdrop claim validation and whitelist checks\n * @custom:security Implements balance validation and whitelist verification\n */\ncontract AccountManagerResolver {\n    /// @dev Address of the airdrop contract for claim validation\n    /// @notice Immutable reference to airdrop contract\n    address public immutable airdropAddress;\n\n    /// @dev Address of the validator contract for whitelist checks\n    /// @notice Immutable reference to validator contract\n    address public immutable validatorAddress;\n\n    /// @dev Ethereum token address representation\n    /// @notice Standard ETH address used across the protocol\n    address internal constant ethAddr =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Key for token whitelist validation\n    /// @notice Used to verify if tokens are approved for withdrawal\n    bytes32 internal constant VALIDATOR_TOKEN_WHITELIST_KEY =\n        keccak256(\"account-manager-token-whitelist\");\n\n    /**\n     * @dev Constructor to initialize contract addresses\n     * @param _airdropAddress Address of the airdrop contract\n     * @param _validatorAddress Address of the validator contract\n     * @notice Sets up the resolver with required system contracts\n     * @custom:validation Addresses can be zero for optional functionality\n     */\n    constructor(address _airdropAddress, address _validatorAddress) {\n        airdropAddress = _airdropAddress;\n        validatorAddress = _validatorAddress;\n    }\n\n    /**\n     * @dev Withdraw assets from the smart account\n     * @param token Address of the token to withdraw (ethAddr for ETH)\n     * @param amt Amount of tokens to withdraw\n     * @param to Recipient address\n     * @return _eventName Name of the event emitted\n     * @return _eventParam Encoded event parameters\n     * @notice Securely withdraws tokens with validation checks\n     * @custom:validation Validates recipient, amount, and token whitelist\n     * @custom:security Checks airdrop claims for ETH withdrawals\n     * @custom:access-control Requires token to be whitelisted\n     */\n    function withdraw(\n        address token,\n        uint256 amt,\n        address payable to\n    )\n        external\n        payable\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Validate input parameters\n        require(\n            to != address(0),\n            \"AccountManagerResolver: recipient address cannot be zero\"\n        );\n        require(\n            amt > 0,\n            \"AccountManagerResolver: withdrawal amount must be greater than zero\"\n        );\n\n        // Verify token is whitelisted\n        require(\n            IValidator(validatorAddress).verify(\n                VALIDATOR_TOKEN_WHITELIST_KEY,\n                token\n            ),\n            \"AccountManagerResolver: token not whitelisted for withdrawal\"\n        );\n\n        // Check ETH balance considering airdrop claims\n        if (token == ethAddr && airdropAddress != address(0)) {\n            uint256 claimedAmount = IAirdrop(airdropAddress)\n                .getUserClaimedAmount(address(this), ethAddr);\n            require(\n                address(this).balance >= claimedAmount + amt,\n                \"AccountManagerResolver: insufficient balance after airdrop claims\"\n            );\n        }\n\n        // Transfer tokens based on type\n        if (token == ethAddr) {\n            _safeTransferETH(to, amt);\n        } else {\n            _safeTransferERC20(token, to, amt);\n        }\n\n        // Return event data\n        _eventName = \"LogWithdraw(address,uint256,address)\";\n        _eventParam = abi.encode(token, amt, to);\n    }\n\n    /**\n     * @dev Safely transfers ETH to a recipient\n     * @param to Recipient address\n     * @param amount Amount of ETH to transfer\n     * @notice Uses low-level call for ETH transfer with failure handling\n     * @custom:security Validates transfer success and reverts on failure\n     */\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"AccountManagerResolver: ETH transfer failed\");\n    }\n\n    /**\n     * @dev Safely transfers ERC20 tokens to a recipient\n     * @param token Address of the ERC20 token\n     * @param to Recipient address\n     * @param amount Amount of tokens to transfer\n     * @notice Uses TokenHelper for safe ERC20 transfers\n     * @custom:security Leverages battle-tested transfer helper\n     */\n    function _safeTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        TokenHelper.safeTransfer(TokenInterface(token), to, amount);\n    }\n}\n\n/**\n * @title ConnectV1AccountManager\n * @author Tadle Team\n * @notice Version 1.0.0 of the Account Manager connector\n * @dev Extends AccountManagerResolver with version identification\n * @custom:version 1.0.0\n */\ncontract ConnectV1AccountManager is AccountManagerResolver {\n    string public constant name = \"AccountManager-v1.0.0\";\n\n    /**\n     * @dev Constructor to initialize contract addresses\n     * @param _airdropAddress Address of the airdrop contract\n     * @param _validatorAddress Address of the validator contract\n     * @notice Sets up the connector with required system contracts\n     * @custom:initialization Inherits validation from AccountManagerResolver\n     */\n    constructor(\n        address _airdropAddress,\n        address _validatorAddress\n    ) AccountManagerResolver(_airdropAddress, _validatorAddress) {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/nad-fun/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Stores} from \"../implementation/Stores.sol\";\n\n/**\n * @title INadFun Interface\n * @dev Interface for interacting with NadFun protocol's core functions\n * @notice Provides methods for creating bonding curves and executing protected trades\n */\ninterface INadFun {\n    /**\n     * @dev Creates a new bonding curve\n     * @param creator Address of the curve creator\n     * @param name Name of the curve token\n     * @param symbol Symbol of the curve token\n     * @param tokenURI URI for token metadata\n     * @param amountIn Initial ETH amount for liquidity\n     * @param fee Fee percentage (in basis points, 0 for default)\n     * @return curve Address of the created curve\n     * @return token Address of the curve token\n     * @return virtualNative Virtual ETH amount in the curve\n     * @return virtualToken Virtual token amount inthe curve\n     * @return amountOut Amount of tokens received\n     */\n    function createCurve(\n        address creator,\n        string memory name,\n        string memory symbol,\n        string memory tokenURI,\n        uint256 amountIn,\n        uint256 fee\n    )\n        external\n        payable\n        returns (address curve, address token, uint256 virtualNative, uint256 virtualToken, uint256 amountOut);\n\n    /**\n     * @dev Executes a protected ETH to token swap\n     * @param amountIn Amount of ETH to swap\n     * @param amountOutMin Minimum tokens to receive\n     * @param fee Protocol fee amount\n     * @param token Token address to receive\n     * @param to Recipient address\n     * @param deadline Transaction timeout timestamp\n     */\n    function protectBuy(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256 fee,\n        address token,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    /**\n     * @dev Executes a protected token to ETH swap\n     * @param amountIn Amount of tokens to swap\n     * @param amountOutMin Minimum ETH to receive\n     * @param token Token address to swap\n     * @param to Recipient address\n     * @param deadline Transaction timeout timestamp\n     */\n    function protectSell(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        external;\n}\n\n/**\n * @title NadFunResolver\n * @dev Base contract for interacting with NadFun protocol\n * @notice Provides functionality for creating bonding curves and executing protected trades\n */\ncontract NadFunResolver is Stores {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Creates a new bonding curve with initial liquidity\n     * @notice Creates a new bonding curve and corresponding token with initial ETH liquidity\n     * @param params Parameters for curve creation including name, symbol, URI, initial amount and fee\n     * @return _eventName Name of the event to be logged\n     * @return _eventParam Encoded event parameters\n     */\n    struct CreateCurveParams {\n        string name;\n        string symbol;\n        string tokenURI;\n        uint256 amountIn;\n        uint256 fee;\n    }\n\n    /**\n     * @dev Parameters for protected trading operations\n     * @param amountIn Amount of tokens to trade (ETH for buy, tokens for sell)\n     * @param amountOutMin Minimum amount of tokens to receive after trade\n     * @param fee Custom fee rate in basis points (0 for default 1%)\n     * @param token Token contract address for the trade\n     * @param to Recipient address for the traded tokens\n     * @param deadline Transaction expiration timestamp\n     * @param getIds Storage ID to retrieve input amount\n     * @param setIds Storage ID to store output amount\n     */\n    struct ProtectParams {\n        uint256 amountIn;\n        uint256 amountOutMin;\n        uint256 fee;\n        address token;\n        address to;\n        uint256 deadline;\n        uint256 getIds;\n        uint256 setIds;\n    }\n\n    // ============ Constants ============\n    address public immutable NAD_FUN;\n    uint256 public constant EXTRA_VALUE = 0.02 ether;\n    uint256 public constant DEFAULT_FEE = 1000; // 1% fee in basis points\n    uint256 private constant BASIS_POINTS = 100000;\n\n    // ============ Events ============\n    event TokenApproval(address indexed token, uint256 amount);\n    event ProtectedSwap(address indexed token, uint256 amountIn, uint256 amountOut, bool isBuy);\n\n    constructor(address _nadFun, address _tadleMemory) Stores(_tadleMemory) {\n        require(_nadFun != address(0), \"Invalid NadFun address\");\n        NAD_FUN = _nadFun;\n    }\n\n    function createCurve(CreateCurveParams calldata params)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        (address curve, address token, uint256 amountOut, uint256 feeAmount) = _createCurveWithFee(params);\n        (_eventName, _eventParam) = _encodeCreateCurveEvent(params, curve, token, amountOut, feeAmount);\n    }\n\n    /**\n     * @dev Executes a protected ETH to token buy transaction\n     * @notice Swaps ETH for tokens with slippage protection and custom fee handling\n     * @param params Trading parameters including amounts, token, deadline and storage IDs\n     * @return _eventName Name of the event to be logged\n     * @return _eventParam Encoded event parameters\n     */\n    function protectBuy(ProtectParams calldata params)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        require(params.token != address(0), \"Invalid token\");\n        require(params.to == address(this), \"Invalid recipient\");\n        require(params.deadline >= block.timestamp, \"Expired deadline\");\n\n        uint256 amountIn = getUint(params.getIds, params.amountIn);\n        uint256 actualFee = params.fee == 0 ? DEFAULT_FEE : params.fee;\n        uint256 feeAmount = (amountIn * actualFee) / BASIS_POINTS;\n        uint256 totalAmount = amountIn + feeAmount;\n\n        require(address(this).balance >= totalAmount, \"Insufficient ETH balance\");\n\n        uint256 balanceBefore = IERC20(params.token).balanceOf(params.to);\n\n        INadFun(NAD_FUN).protectBuy{value: totalAmount}(\n            amountIn, params.amountOutMin, feeAmount, params.token, params.to, params.deadline\n        );\n\n        uint256 balanceAfter = IERC20(params.token).balanceOf(params.to);\n        uint256 amountOut = balanceAfter - balanceBefore;\n        require(amountOut >= params.amountOutMin, \"Insufficient output amount\");\n\n        setUint(params.setIds, amountOut);\n        emit ProtectedSwap(params.token, amountIn, amountOut, true);\n\n        _eventName = \"LogProtectBuy(address,uint256,uint256)\";\n        _eventParam = abi.encode(params.token, amountIn, amountOut);\n    }\n\n    /**\n     * @dev Execute a protected token to ETH sell transaction\n     * @notice Swaps tokens for ETH with slippage protection\n     * @param params Trading parameters struct\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded parameters for the event\n     */\n    function protectSell(ProtectParams calldata params)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        require(params.token != address(0), \"Invalid token\");\n        require(params.to == address(this), \"Invalid recipient\");\n        require(params.deadline >= block.timestamp, \"Expired deadline\");\n\n        uint256 amountIn = getUint(params.getIds, params.amountIn);\n        require(IERC20(params.token).balanceOf(address(this)) >= amountIn, \"Insufficient token balance\");\n\n        uint256 ethBalanceBefore = address(this).balance;\n\n        _safeApprove(params.token, NAD_FUN, amountIn);\n        INadFun(NAD_FUN).protectSell(amountIn, params.amountOutMin, params.token, params.to, params.deadline);\n\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 amountOut = ethBalanceAfter - ethBalanceBefore;\n        require(amountOut >= params.amountOutMin, \"Insufficient output amount\");\n\n        setUint(params.setIds, amountOut);\n        emit ProtectedSwap(params.token, amountIn, amountOut, false);\n\n        _eventName = \"LogProtectSell(address,uint256,uint256)\";\n        _eventParam = abi.encode(params.token, amountIn, amountOut);\n    }\n\n    /**\n     * @dev Internal function to create bonding curve and calculate fees\n     * @notice Handles core logic for curve creation including fee calculation and contract calls\n     * @param params Parameters for curve creation\n     * @return curve Address of the created curve contract\n     * @return token Address of the created token contract\n     * @return amountOut Amount of tokens minted\n     * @return feeAmount Calculated fee amount\n     */\n    function _createCurveWithFee(CreateCurveParams calldata params)\n        internal\n        returns (address curve, address token, uint256 amountOut, uint256 feeAmount)\n    {\n        feeAmount = _calculateFeeAmount(params.amountIn, params.fee);\n        uint256 totalAmount = params.amountIn + feeAmount + EXTRA_VALUE;\n\n        require(address(this).balance >= totalAmount, \"Insufficient ETH balance\");\n\n        (curve, token,,, amountOut) = INadFun(NAD_FUN).createCurve{value: totalAmount}(\n            address(this), params.name, params.symbol, params.tokenURI, params.amountIn, feeAmount\n        );\n    }\n\n    /**\n     * @dev Internal function to encode curve creation event\n     * @notice Encodes curve creation results into event parameters\n     * @param params Original curve creation parameters\n     * @param curve Curve contract address\n     * @param token Token contract address\n     * @param amountOut Amount of tokens minted\n     * @param feeAmount Fee amount\n     * @return _eventName Name of the event\n     * @return _eventParam Encoded event parameters\n     */\n    function _encodeCreateCurveEvent(\n        CreateCurveParams calldata params,\n        address curve,\n        address token,\n        uint256 amountOut,\n        uint256 feeAmount\n    ) internal view returns (string memory _eventName, bytes memory _eventParam) {\n        _eventName = \"LogCreateCurve(address,address,address,string,string,string,uint256,uint256,uint256)\";\n        _eventParam = abi.encode(\n            address(this),\n            curve,\n            token,\n            params.name,\n            params.symbol,\n            params.tokenURI,\n            params.amountIn,\n            feeAmount,\n            amountOut\n        );\n    }\n\n    /**\n     * @dev Internal function to calculate fee amount\n     * @notice Calculates fee amount based on input amount and fee rate\n     * @param amountIn Input amount for fee calculation\n     * @param fee Fee rate in basis points (0 for default)\n     * @return Calculated fee amount\n     */\n    function _calculateFeeAmount(uint256 amountIn, uint256 fee) internal pure returns (uint256) {\n        uint256 actualFee = fee == 0 ? DEFAULT_FEE : fee;\n        return (amountIn * actualFee) / BASIS_POINTS;\n    }\n\n    /**\n     * @dev Internal helper for safe token approvals\n     * @notice Handles token approvals with retry mechanism for non-standard tokens\n     * @param token Token contract address\n     * @param spender Address to approve for spending\n     * @param amount Amount of tokens to approve\n     */\n    function _safeApprove(address token, address spender, uint256 amount) internal {\n        try IERC20(token).approve(spender, amount) {\n            emit TokenApproval(token, amount);\n        } catch {\n            IERC20(token).approve(spender, 0);\n            IERC20(token).approve(spender, amount);\n            emit TokenApproval(token, amount);\n        }\n    }\n\n    receive() external payable {}\n}\n\n/**\n * @title ConnectV1NadFun\n * @dev Connector implementation for NadFun protocol\n * @notice Entry point for NadFun protocol interactions with version tracking\n */\ncontract ConnectV1NadFun is NadFunResolver {\n    string public constant name = \"NadFun-v1.0.0\";\n\n    constructor(address _nadFun, address _tadleMemory) NadFunResolver(_nadFun, _tadleMemory) {}\n}\n",
        "dataset-curated/contracts/cantina_tadle_oct2025.pdf-source/v3-sandbox-audit_1/src/relayers/monad_testnet/uniswap-v3/main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {INonfungiblePositionManager, Helpers} from \"./helpers.sol\";\n\n/**\n * @title Uniswap V3 Position Resolver\n * @dev Contract for managing Uniswap V3 NFT liquidity positions\n * @notice Provides functionality for minting, depositing, withdrawing, collecting fees, and burning positions\n */\ncontract UniswapV3PositionResolver is Helpers {\n    constructor(address _nftManager, address _wethAddr, address _tadleMemory, address _uniswapV3Factory)\n        Helpers(_nftManager, _wethAddr, _tadleMemory, _uniswapV3Factory)\n    {}\n\n    /**\n     * @dev Creates a new Uniswap V3 liquidity pool\n     * @param tokenA Address of the first token in the pair\n     * @param tokenB Address of the second token in the pair\n     * @param fee Trading fee tier (500 = 0.05%, 3000 = 0.3%, 10000 = 1%)\n     * @param sqrtPriceX96 Initial sqrt price of the pool (Q64.96 format)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters containing pool details\n     */\n    function createPool(address tokenA, address tokenB, uint24 fee, uint160 sqrtPriceX96)\n        external\n        returns (string memory _eventName, bytes memory _eventParam)\n    {\n        // Create pool and get pool address\n        address pool = _createPool(tokenA, tokenB, fee, sqrtPriceX96);\n\n        // Return event data for logging\n        _eventName = \"LogCreatePool(address,address,uint24,uint160,address)\";\n        _eventParam = abi.encode(tokenA, tokenB, fee, sqrtPriceX96, pool);\n    }\n\n    /**\n     * @dev Creates a new Uniswap V3 NFT liquidity position\n     * @param tokenA Address of the first token in the pair\n     * @param tokenB Address of the second token in the pair\n     * @param fee Trading fee tier (500 = 0.05%, 3000 = 0.3%, 10000 = 1%)\n     * @param tickLower Lower price bound of the position\n     * @param tickUpper Upper price bound of the position\n     * @param amtA Amount of tokenA to deposit (use type(uint256).max for entire balance)\n     * @param amtB Amount of tokenB to deposit (use type(uint256).max for entire balance)\n     * @param slippage Maximum allowed slippage in basis points\n     * @param getIds Array of IDs to retrieve token amounts [amtAId, amtBId]\n     * @param setId ID to store the liquidity amount\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function mint(\n        address tokenA,\n        address tokenB,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amtA,\n        uint256 amtB,\n        uint256 slippage,\n        uint256[] calldata getIds,\n        uint256 setId\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        MintParams memory params;\n        {\n            params = MintParams(tokenA, tokenB, fee, tickLower, tickUpper, amtA, amtB, slippage);\n        }\n        params.amtA = getUint(getIds[0], params.amtA);\n        params.amtB = getUint(getIds[1], params.amtB);\n\n        (uint256 _tokenId, uint256 liquidity, uint256 amountA, uint256 amountB) = _mint(params);\n\n        setUint(setId, liquidity);\n\n        _eventName = \"LogMint(uint256,uint256,uint256,uint256,int24,int24)\";\n        _eventParam = abi.encode(_tokenId, liquidity, amountA, amountB, params.tickLower, params.tickUpper);\n    }\n\n    /**\n     * @dev Increases liquidity in an existing position\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @param amountA Amount of tokenA to add\n     * @param amountB Amount of tokenB to add\n     * @param slippage Maximum allowed slippage in basis points\n     * @param getIds Array of IDs to retrieve token amounts [amtAId, amtBId]\n     * @param setId ID to store the new liquidity amount\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function deposit(\n        uint256 tokenId,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 slippage,\n        uint256[] calldata getIds,\n        uint256 setId\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        amountA = getUint(getIds[0], amountA);\n        amountB = getUint(getIds[1], amountB);\n        (uint256 _liquidity, uint256 _amtA, uint256 _amtB) = _addLiquidityWrapper(tokenId, amountA, amountB, slippage);\n        setUint(setId, _liquidity);\n\n        _eventName = \"LogDeposit(uint256,uint256,uint256,uint256)\";\n        _eventParam = abi.encode(tokenId, _liquidity, _amtA, _amtB);\n    }\n\n    /**\n     * @dev Decreases liquidity from a position\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @param liquidity Amount of liquidity to remove\n     * @param amountAMin Minimum amount of tokenA to receive\n     * @param amountBMin Minimum amount of tokenB to receive\n     * @param getId ID to retrieve liquidity amount\n     * @param setIds Array of IDs to store withdrawn amounts [amtAId, amtBId]\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function withdraw(\n        uint256 tokenId,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 getId,\n        uint256[] calldata setIds\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        uint128 _liquidity = uint128(getUint(getId, liquidity));\n\n        (uint256 _amtA, uint256 _amtB) = _decreaseLiquidity(tokenId, _liquidity, amountAMin, amountBMin);\n\n        setUint(setIds[0], _amtA);\n        setUint(setIds[1], _amtB);\n\n        _eventName = \"LogWithdraw(uint256,uint256,uint256,uint256)\";\n        _eventParam = abi.encode(tokenId, _liquidity, _amtA, _amtB);\n    }\n\n    /**\n     * @dev Collects accumulated fees from a position\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @param amount0Max Maximum amount of token0 to collect\n     * @param amount1Max Maximum amount of token1 to collect\n     * @param getIds Array of IDs to retrieve max amounts [amount0MaxId, amount1MaxId]\n     * @param setIds Array of IDs to store collected amounts [amount0Id, amount1Id]\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function collect(\n        uint256 tokenId,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256[] calldata getIds,\n        uint256[] calldata setIds\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        uint128 _amount0Max = uint128(getUint(getIds[0], amount0Max));\n        uint128 _amount1Max = uint128(getUint(getIds[1], amount1Max));\n        (uint256 amount0, uint256 amount1) = _collect(tokenId, _amount0Max, _amount1Max);\n\n        setUint(setIds[0], amount0);\n        setUint(setIds[1], amount1);\n        _eventName = \"LogCollect(uint256,uint256,uint256)\";\n        _eventParam = abi.encode(tokenId, amount0, amount1);\n    }\n\n    /**\n     * @dev Burns an NFT position after all liquidity has been withdrawn\n     * @param tokenId NFT position ID (0 for most recent position)\n     * @return _eventName Name of the event to emit\n     * @return _eventParam Encoded event parameters\n     */\n    function burn(uint256 tokenId) external payable returns (string memory _eventName, bytes memory _eventParam) {\n        if (tokenId == 0) tokenId = _getLastNftId(address(this));\n        _burn(tokenId);\n        _eventName = \"LogBurnPosition(uint256)\";\n        _eventParam = abi.encode(tokenId);\n    }\n}\n\n/**\n * @title Uniswap V3 Position Connector\n * @dev Connector contract for integrating Uniswap V3 position management\n */\ncontract ConnectV1UniswapV3Position is UniswapV3PositionResolver {\n    /// @dev Connector name for identification\n    string public constant name = \"UniswapV3-position-v1.0.0\";\n\n    constructor(address _nftManager, address _wethAddr, address _tadleMemory, address _uniswapV3Factory)\n        UniswapV3PositionResolver(_nftManager, _wethAddr, _tadleMemory, _uniswapV3Factory)\n    {}\n}\n"
    }
}