{
    "vfp_id": "vfp_00336",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Outdated rationale for minipool.maximum.penalty.count may allow oDAO to disproportionately penalize untransitioned minipools",
            "description": "The minipool.maximum.penalty.count is set to 2,500 based on an older network size estimate. With the current number of minipools and the upcoming shift to Megapools, this cap may allow disproportionate penalties on the remaining minipools.\n\nThe root cause is outdated assumptions in the parameter's rationale that no longer reflect the current or future state of the network.\n\nAfter the Saturn 1 upgrade, the reduced number of minipools means that the same penalty cap could represent a much larger relative impact per minipool.\n\nThe impact is potential over-penalization of remaining minipools, leading to unfair financial consequences.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMinipool.sol#L24",
                "RocketDAOProtocolSettingsMinipool.sol#L42-L44"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMinipool.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail on minipool.maximum.penalty.count allows validators to be arbitrarily penalized for MEV theft",
            "description": "The minipool.maximum.penalty.count parameter currently lacks an upper guardrail, allowing the pDAO to increase it to an arbitrarily high value. This would permit an unlimited number of penalties to be applied within a week, even though the original rationale assumed a maximum of 2,500 based on network size and proposal probability.\n\nThe root cause is the absence of an upper bound in the parameter validation logic, which creates a governance risk. Without a cap, the pDAO could set the value so high that it enables disproportionate or punitive penalties against minipools, especially as their numbers decrease post-upgrade.\n\nA malicious or compromised pDAO could exploit this to set an extremely high penalty count, leading to potential over-penalization of a shrinking minipool population. This undermines the fairness and predictability of the penalty system.\n\nThe impact is the potential for arbitrary and excessive penalties on minipools, leading to unjust financial loss and reduced trust in governance.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMinipool.sol#L42-L44"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMinipool.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for minipool.maximum.penalty.count allows arbitrary MEV theft penalties",
            "description": "The parameter minipool.maximum.penalty.count, which limits how many times MEV theft penalties can be applied over a rolling 50400 block window (~1 week), lacks an upper guardrail. While RPIP-58 specifies a lower bound of >=2500, it fails to define an upper limit. This allows the pDAO to set the value to an unbounded large number, enabling oDAO members to arbitrarily penalize validators for MEV theft without constraints. The root cause is the absence of an upper bound enforcement in the specification and implementation. An attacker (or malicious majority in pDAO) could exploit this by voting to increase the penalty count limit, leading to excessive penalties against validators. The impact includes potential unfair slashing of validator rewards and reputational damage due to perceived governance abuse.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMinipool.sol::setMaximumPenaltyCount#(implied)"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMinipool.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAOProtocolSettingsMinipool.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport \"./RocketDAOProtocolSettings.sol\";\nimport \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol\";\nimport \"../../../../types/MinipoolDeposit.sol\";\n\n/// @notice Network minipool settings\ncontract RocketDAOProtocolSettingsMinipool is RocketDAOProtocolSettings, RocketDAOProtocolSettingsMinipoolInterface {\n\n    uint256 constant internal minipoolUserDistributeWindowStart = 90 days;\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, \"minipool\") {\n        version = 4;\n        // Initialize settings on deployment\n        if(!getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            // Apply settings\n            setSettingBool(\"minipool.submit.withdrawable.enabled\", false);\n            setSettingBool(\"minipool.bond.reduction.enabled\", false);\n            setSettingUint(\"minipool.launch.timeout\", 72 hours);\n            setSettingUint(\"minipool.maximum.count\", 14);\n            setSettingUint(\"minipool.user.distribute.window.length\", 2 days);\n            setSettingUint(\"minipool.maximum.penalty.count\", 2500);                 // Max number of penalties oDAO can apply in rolling 1 week window (RPIP-52)\n            // Settings initialised\n            setBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")), true);\n        }\n    }\n\n    /// @notice Update a setting, overrides inherited setting method with extra checks for this contract\n    /// @param _settingPath The path of the setting within this contract's namespace\n    /// @param _value The value to set it to\n    function setSettingUint(string memory _settingPath, uint256 _value) override public onlyDAOProtocolProposal {\n        // Some safety guards for certain settings\n        if(getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            bytes32 settingKey = keccak256(abi.encodePacked(_settingPath));\n            if(settingKey == keccak256(abi.encodePacked(\"minipool.launch.timeout\"))) {\n                RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMinipool\"));\n                require(_value >= (rocketDAONodeTrustedSettingsMinipool.getScrubPeriod() + 1 hours), \"Launch timeout must be greater than scrub period\");\n                // >= 12 hours (RPIP-33)\n                require(_value >= 12 hours, \"Launch timeout must be greater than 12 hours\");\n            } else if(settingKey == keccak256(abi.encodePacked(\"minipool.maximum.penalty.count\"))) {\n                // >= 2500 (RPIP-52)\n                require(_value >= 2500, \"Maximum penalty count must be equal or greater than 2500\");\n            }\n        }\n        // Update setting now\n        setUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    /// @notice Returns the balance required to launch minipool\n    function getLaunchBalance() override public pure returns (uint256) {\n        return 32 ether;\n    }\n\n    /// @notice Returns the value required to pre-launch a minipool\n    function getPreLaunchValue() override public pure returns (uint256) {\n        return 1 ether;\n    }\n\n    /// @notice Returns the deposit amount for a given deposit type (only used for legacy minipool types)\n    function getDepositUserAmount(MinipoolDeposit _depositType) override public pure returns (uint256) {\n        if (_depositType == MinipoolDeposit.Full) { return getFullDepositUserAmount(); }\n        if (_depositType == MinipoolDeposit.Half) { return getHalfDepositUserAmount(); }\n        return 0;\n    }\n\n    /// @notice Returns the user amount for a \"Full\" deposit minipool\n    function getFullDepositUserAmount() override public pure returns (uint256) {\n        return getLaunchBalance() / 2;\n    }\n\n    /// @notice Returns the user amount for a \"Half\" deposit minipool\n    function getHalfDepositUserAmount() override public pure returns (uint256) {\n        return getLaunchBalance() / 2;\n    }\n\n    /// @notice Returns the amount a \"Variable\" minipool requires to move to staking status\n    function getVariableDepositAmount() override external pure returns (uint256) {\n        return getLaunchBalance() - getPreLaunchValue();\n    }\n\n    /// @notice Submit minipool withdrawable events currently enabled (trusted nodes only)\n    function getSubmitWithdrawableEnabled() override external view returns (bool) {\n        return getSettingBool(\"minipool.submit.withdrawable.enabled\");\n    }\n\n    /// @notice Returns true if bond reductions are currentl enabled\n    function getBondReductionEnabled() override external view returns (bool) {\n        return getSettingBool(\"minipool.bond.reduction.enabled\");\n    }\n\n    /// @notice Returns the timeout period in seconds for prelaunch minipools to launch\n    function getLaunchTimeout() override external view returns (uint256) {\n        return getSettingUint(\"minipool.launch.timeout\");\n    }\n\n    /// @notice Returns the maximum number of minipools allowed at one time\n    function getMaximumCount() override external view returns (uint256) {\n      return getSettingUint(\"minipool.maximum.count\");\n    }\n\n    /// @notice Returns true if the given time is within the user distribute window\n    function isWithinUserDistributeWindow(uint256 _time) override external view returns (bool) {\n        uint256 start = getUserDistributeWindowStart();\n        uint256 length = getUserDistributeWindowLength();\n        return (_time >= start && _time < (start + length));\n    }\n\n    /// @notice Returns true if the given time has passed the distribute window\n    function hasUserDistributeWindowPassed(uint256 _time) override external view returns (bool) {\n        uint256 start = getUserDistributeWindowStart();\n        uint256 length = getUserDistributeWindowLength();\n        return _time >= start + length;\n    }\n\n    /// @notice Returns the start of the user distribute window\n    function getUserDistributeWindowStart() override public pure returns (uint256) {\n        return minipoolUserDistributeWindowStart;\n    }\n\n    /// @notice Returns the length of the user distribute window\n    function getUserDistributeWindowLength() override public view returns (uint256) {\n        return getSettingUint(\"minipool.user.distribute.window.length\");\n    }\n\n    /// @notice Returns the maximum number of penalties the oDAO can apply in a rolling 1 week window\n    function getMaximumPenaltyCount() override external view returns (uint256) {\n        return getSettingUint(\"minipool.maximum.penalty.count\");\n    }\n\n}\n"
    }
}