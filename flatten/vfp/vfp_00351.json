{
    "vfp_id": "vfp_00351",
    "project_name": "Polygon Staking - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Lack of maximum-fee check in the constructor",
            "description": "The `LSTRewardsSplitter` contract lacks a validation check in its constructor to ensure that the total fees passed during initialization do not exceed the 10,000 basis points limit (100%). While the `addFee` and `updateFee` functions include this check, the constructor does not, allowing deployment with an invalid fee configuration.\n\nThe root cause is an omission in input validation during contract initialization. If the total fees exceed 10,000 basis points at deployment, the contract becomes permanently bricked for fee updates, as no single `addFee` or `updateFee` call can reduce the total below the threshold without first exceeding it in intermediate steps.\n\nAn attacker or malicious deployer could exploit this by deploying the contract with excessive fees, rendering the fee management functionality unusable. This would prevent legitimate fee adjustments and could lead to incorrect fee distribution or require contract replacement.\n\nThe impact is a denial of service to the fee update mechanism, potentially leading to incorrect fee collection and distribution, and necessitating contract migration if the issue is not caught early.\n",
            "severity": "Low",
            "location": [
                "LSTRewardsSplitter.sol::constructor"
            ],
            "files": [
                "contracts/contracts/core/lstRewardsSplitter/LSTRewardsSplitter.sol"
            ]
        }
    ],
    "affected_files": {
        "LSTRewardsSplitter.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IERC677.sol\";\nimport \"../interfaces/IStakingPool.sol\";\nimport \"../interfaces/ILSTRewardsSplitterController.sol\";\n\n/**\n * @title LST Rewards Splitter\n * @notice Allows an account to send LST rewards to other addresses\n */\ncontract LSTRewardsSplitter is Ownable {\n    using SafeERC20 for IERC677;\n\n    struct Fee {\n        // address to receive fee\n        address receiver;\n        // value of fee in basis points\n        uint256 basisPoints;\n    }\n\n    // address of contract that conrols this splitter\n    ILSTRewardsSplitterController public controller;\n    // address of liquid staking token\n    IERC677 public lst;\n\n    // list of fees that are paid on rewards\n    Fee[] private fees;\n\n    // total number of tokens deposited without rewards\n    uint256 public principalDeposits;\n\n    event Deposit(uint256 amount);\n    event Withdraw(uint256 amount);\n    event RewardsSplit(uint256 rewardsAmount);\n\n    error SenderNotAuthorized();\n    error FeesExceedLimit();\n    error InsufficientRewards();\n\n    /**\n     * @notice Inititalizes contract\n     * @param _lst address of liquid staking token\n     * @param _fees list of fees to be applied to new rewards\n     * @param _owner address of owner\n     */\n    constructor(address _lst, Fee[] memory _fees, address _owner) {\n        controller = ILSTRewardsSplitterController(msg.sender);\n        lst = IERC677(_lst);\n        for (uint256 i = 0; i < _fees.length; ++i) {\n            fees.push(_fees[i]);\n        }\n        _transferOwnership(_owner);\n    }\n\n    modifier onlyController() {\n        if (msg.sender != address(controller)) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Deposits tokens\n     * @param _amount amount to deposit\n     */\n    function deposit(uint256 _amount) external onlyController {\n        lst.safeTransferFrom(msg.sender, address(this), _amount);\n        principalDeposits += _amount;\n        emit Deposit(_amount);\n    }\n\n    /**\n     * @notice Withdraws tokens\n     * @param _amount amount to withdraw\n     * @param _receiver address to receive tokens\n     */\n    function withdraw(uint256 _amount, address _receiver) external onlyController {\n        principalDeposits -= _amount;\n        lst.safeTransfer(_receiver, _amount);\n        emit Withdraw(_amount);\n    }\n\n    /**\n     * @notice Returns whether a call should be made to performUpkeep to split new rewards\n     * @return upkeepNeeded true if performUpkeep should be called, false otherwise\n     */\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        int256 newRewards = int256(lst.balanceOf(address(this))) - int256(principalDeposits);\n\n        if (newRewards < 0 || uint256(newRewards) >= controller.rewardThreshold())\n            return (true, bytes(\"\"));\n\n        return (false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Splits new rewards between fee receivers\n     */\n    function performUpkeep(bytes calldata) external {\n        int256 newRewards = int256(lst.balanceOf(address(this))) - int256(principalDeposits);\n        if (newRewards < 0) {\n            principalDeposits -= uint256(-1 * newRewards);\n        } else if (uint256(newRewards) < controller.rewardThreshold()) {\n            revert InsufficientRewards();\n        } else {\n            _splitRewards(uint256(newRewards));\n        }\n    }\n\n    /**\n     * @notice Splits new rewards between fee receivers\n     * @dev bypasses rewardThreshold\n     */\n    function splitRewards() external {\n        int256 newRewards = int256(lst.balanceOf(address(this))) - int256(principalDeposits);\n        if (newRewards < 0) {\n            principalDeposits -= uint256(-1 * newRewards);\n        } else if (newRewards == 0) {\n            revert InsufficientRewards();\n        } else {\n            _splitRewards(uint256(newRewards));\n        }\n    }\n\n    /**\n     * @notice Returns a list of all fees\n     * @return list of fees\n     */\n    function getFees() external view returns (Fee[] memory) {\n        return fees;\n    }\n\n    /**\n     * @notice Sdds a new fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function addFee(address _receiver, uint256 _feeBasisPoints) external onlyOwner {\n        fees.push(Fee(_receiver, _feeBasisPoints));\n        if (_totalFeesBasisPoints() > 10000) revert FeesExceedLimit();\n    }\n\n    /**\n     * @notice Updates an existing fee\n     * @param _index index of fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function updateFee(\n        uint256 _index,\n        address _receiver,\n        uint256 _feeBasisPoints\n    ) external onlyOwner {\n        require(_index < fees.length, \"Fee does not exist\");\n\n        if (_feeBasisPoints == 0) {\n            fees[_index] = fees[fees.length - 1];\n            fees.pop();\n        } else {\n            fees[_index].receiver = _receiver;\n            fees[_index].basisPoints = _feeBasisPoints;\n        }\n\n        if (_totalFeesBasisPoints() > 10000) revert FeesExceedLimit();\n    }\n\n    /**\n     * @notice Splits new rewards\n     * @param _rewardsAmount amount of new rewards\n     */\n    function _splitRewards(uint256 _rewardsAmount) private {\n        for (uint256 i = 0; i < fees.length; ++i) {\n            Fee memory fee = fees[i];\n            uint256 amount = (_rewardsAmount * fee.basisPoints) / 10000;\n\n            if (fee.receiver == address(lst)) {\n                IStakingPool(address(lst)).burn(amount);\n            } else {\n                lst.safeTransfer(fee.receiver, amount);\n            }\n        }\n\n        principalDeposits = lst.balanceOf(address(this));\n        emit RewardsSplit(_rewardsAmount);\n    }\n\n    /**\n     * @notice Returns the sum of all fees\n     * @return sum of fees in basis points\n     **/\n    function _totalFeesBasisPoints() private view returns (uint256) {\n        uint256 totalFees;\n        for (uint i = 0; i < fees.length; i++) {\n            totalFees += fees[i].basisPoints;\n        }\n        return totalFees;\n    }\n}\n"
    }
}