{
    "vfp_id": "vfp_00351",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "Users can bypass votes threshold requirement necessary to create a proposal on AgentDAO",
            "description": "Users can stake LP tokens into AgentVeToken to receive voting power, create a proposal immediately, and then unstake their tokens within the same block or shortly after, effectively bypassing any intended lock-up period for governance participation. The root cause is the absence of a time-based lock on voting power after staking. An attacker can exploit this by temporarily staking to meet the proposal threshold, submitting a proposal, and then unstaking, allowing reuse of the same liquidity across multiple proposals. This weakens the governance model by enabling spam or low-commitment proposals, reducing the skin-in-the-game requirement for governance actions.\n",
            "severity": "Medium",
            "location": [
                "AgentVeToken.sol"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentVeToken.sol"
            ]
        }
    ],
    "affected_files": {
        "AgentVeToken.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport \"./IAgentVeToken.sol\";\nimport \"./IAgentNft.sol\";\nimport \"./ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ncontract AgentVeToken is IAgentVeToken, ERC20Upgradeable, ERC20Votes {\n    using SafeERC20 for IERC20;\n    using Checkpoints for Checkpoints.Trace208;\n\n    address public founder;\n    address public assetToken; // This is the token that is staked\n    address public agentNft;\n    uint256 public matureAt; // The timestamp when the founder can withdraw the tokens\n    bool public canStake; // To control private/public agent mode\n    uint256 public initialLock; // Initial locked amount\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    mapping(address => Checkpoints.Trace208) private _balanceCheckpoints;\n\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"cannot reenter\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _founder,\n        address _assetToken,\n        uint256 _matureAt,\n        address _agentNft,\n        bool _canStake\n    ) external initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC20Votes_init();\n\n        founder = _founder;\n        matureAt = _matureAt;\n        assetToken = _assetToken;\n        agentNft = _agentNft;\n        canStake = _canStake;\n    }\n\n    // Stakers have to stake their tokens and delegate to a validator\n    function stake(uint256 amount, address receiver, address delegatee) public {\n        require(\n            canStake || totalSupply() == 0,\n            \"Staking is disabled for private agent\"\n        ); // Either public or first staker\n\n        address sender = _msgSender();\n        require(amount > 0, \"Cannot stake 0\");\n        require(\n            IERC20(assetToken).balanceOf(sender) >= amount,\n            \"Insufficient asset token balance\"\n        );\n        require(\n            IERC20(assetToken).allowance(sender, address(this)) >= amount,\n            \"Insufficient asset token allowance\"\n        );\n\n        IAgentNft registry = IAgentNft(agentNft);\n        uint256 virtualId = registry.stakingTokenToVirtualId(address(this));\n\n        require(!registry.isBlacklisted(virtualId), \"Agent Blacklisted\");\n\n        if (totalSupply() == 0) {\n            initialLock = amount;\n        }\n        \n        registry.addValidator(virtualId, delegatee);\n\n        IERC20(assetToken).safeTransferFrom(sender, address(this), amount);\n        _mint(receiver, amount);\n        _delegate(receiver, delegatee);\n        _balanceCheckpoints[receiver].push(\n            clock(),\n            SafeCast.toUint208(balanceOf(receiver))\n        );\n    }\n\n    function setCanStake(bool _canStake) public {\n        require(_msgSender() == founder, \"Not founder\");\n        canStake = _canStake;\n    }\n\n    function setMatureAt(uint256 _matureAt) public {\n        bytes32 ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n        require(\n            IAccessControl(agentNft).hasRole(ADMIN_ROLE, _msgSender()),\n            \"Not admin\"\n        );\n        matureAt = _matureAt;\n    }\n\n    function withdraw(uint256 amount) public noReentrant {\n        address sender = _msgSender();\n        require(balanceOf(sender) >= amount, \"Insufficient balance\");\n\n        if (\n            (sender == founder) && ((balanceOf(sender) - amount) < initialLock)\n        ) {\n            require(block.timestamp >= matureAt, \"Not mature yet\");\n        }\n\n        _burn(sender, amount);\n        _balanceCheckpoints[sender].push(\n            clock(),\n            SafeCast.toUint208(balanceOf(sender))\n        );\n\n        IERC20(assetToken).safeTransfer(sender, amount);\n    }\n\n    function getPastBalanceOf(\n        address account,\n        uint256 timepoint\n    ) public view returns (uint256) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return\n            _balanceCheckpoints[account].upperLookupRecent(\n                SafeCast.toUint48(timepoint)\n            );\n    }\n\n    // This is non-transferable token\n    function transfer(\n        address /*to*/,\n        uint256 /*value*/\n    ) public override returns (bool) {\n        revert(\"Transfer not supported\");\n    }\n\n    function transferFrom(\n        address /*from*/,\n        address /*to*/,\n        uint256 /*value*/\n    ) public override returns (bool) {\n        revert(\"Transfer not supported\");\n    }\n\n    function approve(\n        address /*spender*/,\n        uint256 /*value*/\n    ) public override returns (bool) {\n        revert(\"Approve not supported\");\n    }\n\n    // The following functions are overrides required by Solidity.\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._update(from, to, value);\n    }\n\n    function getPastDelegates(\n        address account,\n        uint256 timepoint\n    ) public view returns (address) {\n        return super._getPastDelegates(account, timepoint);\n    }\n}\n"
    }
}