{
    "vfp_id": "vfp_00185",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Lack of reserve updates when collecting fees allows anyone to drain the Vault",
            "description": "The Vault fails to update its internal reserves after collecting fees, leading to a discrepancy between the recorded reserves and actual token balance. When fees are collected via collectAggregateFees, the tokens are transferred out but the Vault's reserve accounting remains unchanged. This causes the Vault to believe it holds more tokens than it actually does. The root cause is the omission of a reserve update step after fee collection. An attacker can exploit this by using the erc4626BufferWrapOrUnwrap function, which relies on reserve accounting to determine how many tokens to credit. By manipulating this discrepancy with a malicious wrapper contract, the attacker can withdraw tokens corresponding to the difference. The impact is high, as this can be repeated to drain the entire Vault of all its assets.\n",
            "severity": "High",
            "location": [
                "VaultAdmin.sol::collectAggregateFees#273-295",
                "Vault.sol::_updateReservesAfterWrapping#1367-1390",
                "https://github.com/balancer/balancer-v3-monorepo/pull/857"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Buffer total supply can be reset",
            "description": "The addLiquidityToBuffer function can be called multiple times to reset the buffer's total supply if the wrapped token's asset function returns address(0). This occurs because the function checks if _bufferAssets[wrappedToken] is zero to determine initialization, but does not validate that the underlying token is non-zero. The cause is missing input validation for the wrapped token's asset. An attacker can exploit this by deploying a malicious token that returns address(0) as its asset, allowing repeated initialization and incorrect accounting of _bufferTotalShares. This leads to inconsistent state and potential manipulation of share calculations. The impact is informational, as it affects internal accounting but does not directly enable fund theft.\n",
            "severity": "Informational",
            "location": [
                "VaultAdmin.sol::addLiquidityToBuffer#415-443",
                "https://github.com/balancer/balancer-v3-monorepo/pull/865"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Yield fees collected when exiting recovery mode will be lost",
            "description": "When a pool exits recovery mode, yield fees that are accrued during the disableRecoveryMode call are removed from the pool balance but not credited to the aggregate fee balance, resulting in permanent loss. The issue arises because _setPoolRecoveryMode sets the recovery mode flag to false before updating balances, causing _loadPoolData to accrue yield fees. However, there is no mechanism to transfer these fees to the ProtocolFeeController. The root cause is incorrect ordering of state updates. An attacker cannot directly exploit this for profit, but can trigger the condition by forcing a pool into recovery mode and waiting for yield accumulation. The impact is medium, as it leads to loss of fees that should have been distributed to stakeholders, affecting economic fairness.\n",
            "severity": "Medium",
            "location": [
                "VaultAdmin.sol::disableRecoveryMode#352-355",
                "VaultAdmin.sol::_setPoolRecoveryMode#374-383",
                "PoolDataLib.sol::load#31-64",
                "PoolDataLib.sol::load#49-91",
                "https://github.com/balancer/balancer-v3-monorepo/pull/880"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Lack of slippage protection on liquidity buffer increase",
            "description": "The addLiquidityToBuffer function lacks slippage protection, exposing users to front-running and price manipulation during liquidity provision. Since the function does not include minimum amount expectations or price checks, an attacker can manipulate the price between the time of transaction submission and execution, causing the user to receive fewer shares than expected. The root cause is the absence of slippage controls in the buffer liquidity functions. An attacker can exploit this by sandwiching the transaction with large trades to alter the price. The impact is low, as it affects economic fairness rather than leading to direct fund loss, but can erode user trust. The addLiquidityToBuffer function does not allow users to specify a minimum amount of shares they expect to receive, making them vulnerable to unfavorable changes in the asset-to-share ratio between transaction submission and inclusion. This occurs because the number of shares issued is calculated dynamically via a call to the wrapped token’s convertToAssets function without any slippage guardrails. If the ratio changes due to prior transactions (e.g., front-running), the user may receive fewer shares than anticipated. An attacker can exploit this by manipulating the underlying token state before the victim’s transaction is processed, leading to economic loss for the liquidity provider.\n",
            "severity": "Low",
            "location": [
                "VaultAdmin.sol::addLiquidityToBuffer",
                "VaultAdmin.sol::addLiquidityToBuffer#430-432",
                "https://github.com/balancer/balancer-v3-monorepo/pull/1108"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Insufficient event generation",
            "description": "Several critical functions in VaultAdmin.sol and ProtocolFeeController.sol do not emit events upon state changes, hindering off-chain monitoring and auditing. Operations such as withdrawing protocol fees, disabling queries, pausing buffers, and collecting aggregate fees lack corresponding events, making it difficult for users and monitoring systems to detect abnormal or malicious behavior. Events are essential for transparency, debugging, and security tooling; their absence increases the risk of undetected exploits or malfunctions. This reduces the system's observability and violates best practices for smart contract design.\n",
            "severity": "Informational",
            "location": [
                "ProtocolFeeController.sol::withdrawProtocolFees#449-461",
                "ProtocolFeeController.sol::_withdrawPoolCreatorFees#473-485",
                "VaultAdmin.sol::disableQuery#390-394",
                "VaultAdmin.sol::pauseVaultBuffers#401-405",
                "VaultAdmin.sol::unpauseVaultBuffers#408-412",
                "VaultAdmin.sol::collectAggregateFees#273-295",
                "https://github.com/balancer/balancer-v3-monorepo/pull/916"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/ProtocolFeeController.sol",
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Providing unbalanced liquidity to a buffer can mint more shares due to rounding",
            "description": "When users provide only the underlying token to addLiquidityToBuffer, the invariant calculation uses convertToAssets, which rounds down. This results in a lower currentInvariant value, increasing the number of shares issued due to division by a smaller denominator. Consequently, depositing only underlying tokens yields more shares than depositing a balanced mix of underlying and wrapped tokens of equal value. This rounding advantage creates an arbitrage opportunity and unfair distribution of shares, favoring users who exploit the rounding behavior, which could erode trust in fair issuance mechanics.\n",
            "severity": "Informational",
            "location": [
                "VaultAdmin.sol::addLiquidityToBuffer#512-520",
                "https://github.com/balancer/balancer-v3-monorepo/pull/982"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultAdmin.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultAdmin.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuthorizer } from \"@balancer-labs/v3-interfaces/contracts/vault/IAuthorizer.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { PoolFunctionPermission, Rounding } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { Authentication } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/Authentication.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { VaultStateBits, VaultStateLib } from \"./lib/VaultStateLib.sol\";\nimport { VaultExtensionsLib } from \"./lib/VaultExtensionsLib.sol\";\nimport { PoolConfigLib, PoolConfigBits } from \"./lib/PoolConfigLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\n\n/**\n * @dev Bytecode extension for the Vault containing permissioned functions. Complementary to `VaultExtension`,\n * it has access to the same storage layout as the main vault.\n *\n * The functions in this contract are not meant to be called directly. They must only be called by the Vault\n * via delegate calls, so that any state modifications produced by this contract's code will actually target\n * the main Vault's state.\n *\n * The storage of this contract is in practice unused.\n */\ncontract VaultAdmin is IVaultAdmin, VaultCommon, Authentication {\n    using PackedTokenBalance for bytes32;\n    using PoolConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using VaultExtensionsLib for IVault;\n    using SafeERC20 for IERC20;\n\n    IVault private immutable _vault;\n\n    /// @dev Functions with this modifier can only be delegate-called by the vault.\n    modifier onlyVaultDelegateCall() {\n        _vault.ensureVaultDelegateCall();\n        _;\n    }\n\n    /// @dev Functions with this modifier can only be called by the pool creator.\n    modifier onlyProtocolFeeController() {\n        if (msg.sender != address(_protocolFeeController)) {\n            revert SenderNotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Validate aggregate percentage values.\n    modifier withValidPercentage(uint256 aggregatePercentage) {\n        if (aggregatePercentage > FixedPoint.ONE) {\n            revert ProtocolFeesExceedTotalCollected();\n        }\n        _;\n    }\n\n    /// @dev Use with permissioned functions that use `PoolRoleAccounts`.\n    modifier authenticateByRole(address pool) {\n        _ensureAuthenticatedByRole(pool);\n        _;\n    }\n\n    function _ensureAuthenticatedByRole(address pool) private view {\n        bytes32 actionId = getActionId(msg.sig);\n\n        PoolFunctionPermission memory roleAssignment = _poolFunctionPermissions[pool][actionId];\n\n        // If there is no role assignment, fall through and delegate to governance.\n        if (roleAssignment.account != address(0)) {\n            // If the sender matches the permissioned account, all good; just return.\n            if (msg.sender == roleAssignment.account) {\n                return;\n            }\n\n            // If it doesn't, check whether it's onlyOwner. onlyOwner means *only* the permissioned account\n            // may call the function, so revert if this is the case. Otherwise, fall through and check\n            // governance.\n            if (roleAssignment.onlyOwner) {\n                revert SenderNotAllowed();\n            }\n        }\n\n        // Delegate to governance.\n        if (_canPerform(actionId, msg.sender, pool) == false) {\n            revert SenderNotAllowed();\n        }\n    }\n\n    constructor(\n        IVault mainVault,\n        uint32 pauseWindowDuration,\n        uint32 bufferPeriodDuration\n    ) Authentication(bytes32(uint256(uint160(address(mainVault))))) {\n        if (pauseWindowDuration > _MAX_PAUSE_WINDOW_DURATION) {\n            revert VaultPauseWindowDurationTooLarge();\n        }\n        if (bufferPeriodDuration > _MAX_BUFFER_PERIOD_DURATION) {\n            revert PauseBufferPeriodDurationTooLarge();\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint32 pauseWindowEndTime = uint32(block.timestamp) + pauseWindowDuration;\n\n        _vaultPauseWindowEndTime = pauseWindowEndTime;\n        _vaultBufferPeriodDuration = bufferPeriodDuration;\n        _vaultBufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n\n        _vault = mainVault;\n    }\n\n    /*******************************************************************************\n                               Constants and immutables\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function vault() external view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getPauseWindowEndTime() external view returns (uint32) {\n        return _vaultPauseWindowEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodDuration() external view returns (uint32) {\n        return _vaultBufferPeriodDuration;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferPeriodEndTime() external view returns (uint32) {\n        return _vaultBufferPeriodEndTime;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMinimumPoolTokens() external pure returns (uint256) {\n        return _MIN_TOKENS;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getMaximumPoolTokens() external pure returns (uint256) {\n        return _MAX_TOKENS;\n    }\n\n    /*******************************************************************************\n                                    Vault Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function isVaultPaused() external view onlyVaultDelegateCall returns (bool) {\n        return _isVaultPaused();\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getVaultPausedState() external view onlyVaultDelegateCall returns (bool, uint32, uint32) {\n        return (_isVaultPaused(), _vaultPauseWindowEndTime, _vaultBufferPeriodEndTime);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVault() external onlyVaultDelegateCall authenticate {\n        _setVaultPaused(false);\n    }\n\n    /**\n     * @dev The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     */\n    function _setVaultPaused(bool pausing) internal {\n        if (_isVaultPaused()) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert VaultPaused();\n            }\n\n            // The Vault can always be unpaused while it's paused.\n            // When the buffer period expires, `_isVaultPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= _vaultPauseWindowEndTime) {\n                    revert VaultPauseWindowExpired();\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert VaultNotPaused();\n            }\n        }\n\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setVaultPaused(pausing);\n        _vaultStateBits = vaultState;\n\n        emit VaultPausedStateChanged(pausing);\n    }\n\n    /*******************************************************************************\n                                     Pool Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pausePool(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpausePool(\n        address pool\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        _setPoolPaused(pool, false);\n    }\n\n    function _setPoolPaused(address pool, bool pausing) internal {\n        PoolConfigBits config = _poolConfigBits[pool];\n\n        if (_isPoolPaused(pool)) {\n            if (pausing) {\n                // Already paused, and we're trying to pause it again.\n                revert PoolPaused(pool);\n            }\n\n            // The pool can always be unpaused while it's paused.\n            // When the buffer period expires, `_isPoolPaused` will return false, so we would be in the outside\n            // else clause, where trying to unpause will revert unconditionally.\n        } else {\n            if (pausing) {\n                // Not already paused; we can pause within the window.\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp >= config.getPauseWindowEndTime()) {\n                    revert PoolPauseWindowExpired(pool);\n                }\n            } else {\n                // Not paused, and we're trying to unpause it.\n                revert PoolNotPaused(pool);\n            }\n        }\n\n        // Update poolConfigBits.\n        _poolConfigBits[pool] = config.setPoolPaused(pausing);\n\n        emit PoolPausedStateChanged(pool, pausing);\n    }\n\n    /*******************************************************************************\n                                        Fees\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setStaticSwapFeePercentage(\n        address pool,\n        uint256 swapFeePercentage\n    ) external onlyVaultDelegateCall withRegisteredPool(pool) authenticateByRole(pool) {\n        // Saving bits by not implementing a new modifier.\n        _ensureUnpaused(pool);\n        _setStaticSwapFeePercentage(pool, swapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function collectAggregateFees(address pool) public onlyVaultDelegateCall nonReentrant withRegisteredPool(pool) {\n        IERC20[] memory poolTokens = _vault.getPoolTokens(pool);\n        address feeController = address(_protocolFeeController);\n        uint256 numTokens = poolTokens.length;\n\n        uint256[] memory totalSwapFees = new uint256[](numTokens);\n        uint256[] memory totalYieldFees = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < poolTokens.length; ++i) {\n            IERC20 token = poolTokens[i];\n\n            (totalSwapFees[i], totalYieldFees[i]) = _aggregateFeeAmounts[pool][token].fromPackedBalance();\n\n            if (totalSwapFees[i] > 0 || totalYieldFees[i] > 0) {\n                // The ProtocolFeeController will pull tokens from the Vault.\n                token.forceApprove(feeController, totalSwapFees[i] + totalYieldFees[i]);\n\n                _aggregateFeeAmounts[pool][token] = 0;\n            }\n        }\n\n        _protocolFeeController.receiveAggregateFees(pool, totalSwapFees, totalYieldFees);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateSwapFeePercentage(\n        address pool,\n        uint256 newAggregateSwapFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateSwapFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateSwapFeePercentage(newAggregateSwapFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function updateAggregateYieldFeePercentage(\n        address pool,\n        uint256 newAggregateYieldFeePercentage\n    )\n        external\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        withValidPercentage(newAggregateYieldFeePercentage)\n        onlyProtocolFeeController\n    {\n        _poolConfigBits[pool] = _poolConfigBits[pool].setAggregateYieldFeePercentage(newAggregateYieldFeePercentage);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function setProtocolFeeController(\n        IProtocolFeeController newProtocolFeeController\n    ) external onlyVaultDelegateCall authenticate nonReentrant {\n        _protocolFeeController = newProtocolFeeController;\n\n        emit ProtocolFeeControllerChanged(newProtocolFeeController);\n    }\n\n    /*******************************************************************************\n                                    Recovery Mode\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function enableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) {\n        _ensurePoolNotInRecoveryMode(pool);\n\n        // If the Vault or pool is pausable (and currently paused), this call is permissionless.\n        if (_isPoolPaused(pool) == false && _isVaultPaused() == false) {\n            // If not permissionless, authenticate with governance.\n            _authenticateCaller();\n        }\n\n        _setPoolRecoveryMode(pool, true);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function disableRecoveryMode(address pool) external onlyVaultDelegateCall withRegisteredPool(pool) authenticate {\n        _ensurePoolInRecoveryMode(pool);\n        _setPoolRecoveryMode(pool, false);\n    }\n\n    /**\n     * @dev Reverts if the pool is in recovery mode.\n     * @param pool The pool\n     */\n    function _ensurePoolNotInRecoveryMode(address pool) internal view {\n        if (_isPoolInRecoveryMode(pool)) {\n            revert PoolInRecoveryMode(pool);\n        }\n    }\n\n    /**\n     * @dev Change the recovery mode state of a pool, and emit an event. Assumes any validation (e.g., whether\n     * the proposed state change is consistent) has already been done.\n     *\n     * @param pool The pool\n     * @param recoveryMode The desired recovery mode state\n     */\n    function _setPoolRecoveryMode(address pool, bool recoveryMode) internal {\n        // Update poolConfigBits\n        _poolConfigBits[pool] = _poolConfigBits[pool].setPoolInRecoveryMode(recoveryMode);\n\n        if (recoveryMode == false) {\n            _writePoolBalancesToStorage(pool, _loadPoolData(pool, Rounding.ROUND_DOWN));\n        }\n\n        emit PoolRecoveryModeStateChanged(pool, recoveryMode);\n    }\n\n    /*******************************************************************************\n                                        Queries\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function disableQuery() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setQueryDisabled(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /*******************************************************************************\n                                Yield-bearing token buffers\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function pauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(true);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function unpauseVaultBuffers() external onlyVaultDelegateCall authenticate {\n        VaultStateBits vaultState = _vaultStateBits;\n        vaultState = vaultState.setBuffersPaused(false);\n        _vaultStateBits = vaultState;\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function addLiquidityToBuffer(\n        IERC4626 wrappedToken,\n        uint256 amountUnderlying,\n        uint256 amountWrapped,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        whenVaultBuffersAreNotPaused\n        nonReentrant\n        returns (uint256 issuedShares)\n    {\n        address underlyingToken = wrappedToken.asset();\n\n        // Amount of shares to issue is the total underlying token that the user is depositing.\n        issuedShares = wrappedToken.convertToAssets(amountWrapped) + amountUnderlying;\n\n        if (_bufferAssets[wrappedToken] == address(0)) {\n            // Buffer is not initialized yet, so we initialize it.\n\n            // Register asset of wrapper, so it cannot change.\n            _bufferAssets[wrappedToken] = underlyingToken;\n\n            // Burn MINIMUM_TOTAL_SUPPLY shares, so the buffer can never go back to zero liquidity\n            // (avoids rounding issues with low liquidity).\n            _bufferTotalShares[wrappedToken] = _MINIMUM_TOTAL_SUPPLY;\n            issuedShares -= _MINIMUM_TOTAL_SUPPLY;\n        } else if (_bufferAssets[wrappedToken] != underlyingToken) {\n            // Asset was changed since the first bufferAddLiquidity call.\n            revert WrongWrappedTokenAsset(address(wrappedToken));\n        }\n\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        // Adds the issued shares to the total shares of the liquidity pool.\n        _bufferLpShares[wrappedToken][sharesOwner] += issuedShares;\n        _bufferTotalShares[wrappedToken] += issuedShares;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() + amountUnderlying,\n            bufferBalances.getBalanceDerived() + amountWrapped\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _takeDebt(IERC20(underlyingToken), amountUnderlying);\n        _takeDebt(wrappedToken, amountWrapped);\n\n        emit LiquidityAddedToBuffer(wrappedToken, sharesOwner, amountWrapped, amountUnderlying, issuedShares);\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function removeLiquidityFromBuffer(\n        IERC4626 wrappedToken,\n        uint256 sharesToRemove,\n        address sharesOwner\n    )\n        public\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        authenticate\n        nonReentrant\n        returns (uint256 removedUnderlyingBalance, uint256 removedWrappedBalance)\n    {\n        bytes32 bufferBalances = _bufferTokenBalances[wrappedToken];\n\n        if (sharesToRemove > _bufferLpShares[wrappedToken][sharesOwner]) {\n            revert NotEnoughBufferShares();\n        }\n        uint256 totalShares = _bufferTotalShares[wrappedToken];\n\n        removedUnderlyingBalance = (bufferBalances.getBalanceRaw() * sharesToRemove) / totalShares;\n        removedWrappedBalance = (bufferBalances.getBalanceDerived() * sharesToRemove) / totalShares;\n\n        _bufferLpShares[wrappedToken][sharesOwner] -= sharesToRemove;\n        _bufferTotalShares[wrappedToken] -= sharesToRemove;\n\n        bufferBalances = PackedTokenBalance.toPackedBalance(\n            bufferBalances.getBalanceRaw() - removedUnderlyingBalance,\n            bufferBalances.getBalanceDerived() - removedWrappedBalance\n        );\n\n        _bufferTokenBalances[wrappedToken] = bufferBalances;\n\n        _supplyCredit(IERC20(_bufferAssets[wrappedToken]), removedUnderlyingBalance);\n        _supplyCredit(wrappedToken, removedWrappedBalance);\n\n        emit LiquidityRemovedFromBuffer(\n            wrappedToken,\n            sharesOwner,\n            removedWrappedBalance,\n            removedUnderlyingBalance,\n            sharesToRemove\n        );\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferOwnerShares(\n        IERC4626 token,\n        address user\n    ) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferLpShares[token][user];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferTotalShares(IERC4626 token) external view onlyVaultDelegateCall returns (uint256 shares) {\n        return _bufferTotalShares[token];\n    }\n\n    /// @inheritdoc IVaultAdmin\n    function getBufferBalance(IERC4626 token) external view onlyVaultDelegateCall returns (uint256, uint256) {\n        // The first balance is underlying, and the last is wrapped balance.\n        return (_bufferTokenBalances[token].getBalanceRaw(), _bufferTokenBalances[token].getBalanceDerived());\n    }\n\n    /*******************************************************************************\n                                Authentication\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultAdmin\n    function setAuthorizer(IAuthorizer newAuthorizer) external onlyVaultDelegateCall authenticate {\n        _authorizer = newAuthorizer;\n\n        emit AuthorizerChanged(newAuthorizer);\n    }\n\n    /// @dev Access control is delegated to the Authorizer.\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\n        return _authorizer.canPerform(actionId, user, address(this));\n    }\n\n    /// @dev Access control is delegated to the Authorizer. `where` refers to the target contract.\n    function _canPerform(bytes32 actionId, address user, address where) internal view returns (bool) {\n        return _authorizer.canPerform(actionId, user, where);\n    }\n}\n",
        "ProtocolFeeController.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { IVaultErrors } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultErrors.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { FEE_SCALING_FACTOR } from \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport {\n    SingletonAuthentication\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/SingletonAuthentication.sol\";\nimport {\n    ReentrancyGuardTransient\n} from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/ReentrancyGuardTransient.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\n\nimport { VaultGuard } from \"./VaultGuard.sol\";\n\n/**\n * @notice Helper contract to manage protocol and creator fees outside the Vault.\n * @dev This contract stores global default protocol swap and yield fees, and also tracks the values of those fees\n * for each pool (the `PoolFeeConfig` described below). Protocol fees can always be overwritten by governance, but\n * pool creator fees are controlled by the registered poolCreator (see `PoolRoleAccounts`).\n *\n * The Vault stores a single aggregate percentage for swap and yield fees; only this `ProtocolFeeController` knows\n * the component fee percentages, and how to compute the aggregate from the components. This is done for performance\n * reasons, to minimize gas on the critical path, as this way the Vault simply applies a single \"cut\", and stores the\n * fee amounts separately from the pool balances.\n *\n * The pool creator fees are \"net\" protocol fees, meaning the protocol fee is taken first, and the pool creator fee\n * percentage is applied to the remainder. Essentially, the protocol is paid first, then the remainder is divided\n * between the pool creator and the LPs.\n *\n * There is a permissionless function (`collectAggregateFees`) that transfers these tokens from the Vault to this\n * contract, and distributes them between the protocol and pool creator, after which they can be withdrawn at any\n * time by governance and the pool creator, respectively.\n *\n * Protocol fees can be zero in some cases (e.g., the token is registered as exempt), and pool creator fees are zero\n * if there is no creator role address defined. Protocol fees are capped at a maximum percentage (50%); pool creator\n * fees are computed \"net\" protocol fees, so they can be any value from 0 to 100%. Any combination is possible.\n * A protocol-fee-exempt pool with a 100% pool creator fee would send all fees to the creator. If there is no pool\n * creator, a pool with a 50% protocol fee would divide the fees evenly between the protocol and LPs.\n *\n * This contract is deployed with the Vault, but can be changed by governance.\n */\ncontract ProtocolFeeController is\n    IProtocolFeeController,\n    SingletonAuthentication,\n    ReentrancyGuardTransient,\n    VaultGuard\n{\n    using FixedPoint for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Fee configuration stored in the swap and yield fee mappings.\n     * @dev Instead of storing only the fee in the mapping, also store a flag to indicate whether the fee has been\n     * set by governance through a permissioned call. (The fee is stored in 64-bits, so that the struct fits\n     * within a single slot.)\n     *\n     * We know the percentage is an 18-decimal FP value, which only takes 60 bits, so it's guaranteed to fit,\n     * and we can do simple casts to truncate the high bits without needed SafeCast.\n     *\n     * We want to enable permissionless updates for pools, so that it is less onerous to update potentially\n     * hundreds of pools if the global protocol fees change. However, we don't want to overwrite pools that\n     * have had their fee percentages manually set by the DAO (i.e., after off-chain negotiation and agreement).\n     *\n     * @param feePercentage The raw swap or yield fee percentage\n     * @param isOverride When set, this fee is controlled by governance, and cannot be changed permissionlessly\n     */\n    struct PoolFeeConfig {\n        uint64 feePercentage;\n        bool isOverride;\n    }\n\n    // Maximum protocol swap fee percentage. FixedPoint.ONE corresponds to a 100% fee.\n    uint256 internal constant _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE = 50e16; // 50%\n\n    // Maximum protocol yield fee percentage.\n    uint256 internal constant _MAX_PROTOCOL_YIELD_FEE_PERCENTAGE = 50e16; // 50%\n\n    // Global protocol swap fee.\n    uint256 private _globalProtocolSwapFeePercentage;\n\n    // Global protocol yield fee.\n    uint256 private _globalProtocolYieldFeePercentage;\n\n    // Store the pool-specific swap fee percentages (the Vault's poolConfigBits stores the aggregate percentage).\n    mapping(address => PoolFeeConfig) internal _poolProtocolSwapFeePercentages;\n\n    // Store the pool-specific yield fee percentages (the Vault's poolConfigBits stores the aggregate percentage).\n    mapping(address => PoolFeeConfig) internal _poolProtocolYieldFeePercentages;\n\n    // Pool -> address of pool creator (empowered to set pool creator fee percentages, and withdraw creator fees).\n    mapping(address => address) internal _poolCreators;\n\n    // Pool -> creator swap fee percentage.\n    mapping(address => uint256) internal _poolCreatorSwapFeePercentages;\n\n    // Pool -> creator yield fee percentage.\n    mapping(address => uint256) internal _poolCreatorYieldFeePercentages;\n\n    // Pool -> (Token -> fee): Disaggregated protocol fees (from swap and yield), available for withdrawal\n    // by governance.\n    mapping(address => mapping(IERC20 => uint256)) internal _protocolFeeAmounts;\n\n    // Pool -> (Token -> fee): Disaggregated pool creator fees (from swap and yield), available for withdrawal by\n    // the pool creator.\n    mapping(address => mapping(IERC20 => uint256)) internal _poolCreatorFeeAmounts;\n\n    // Ensure that the caller is the pool creator.\n    modifier onlyPoolCreator(address pool) {\n        _ensureCallerIsPoolCreator(pool);\n        _;\n    }\n\n    // Validate the swap fee percentage against the maximum.\n    modifier withValidSwapFee(uint256 newSwapFeePercentage) {\n        if (newSwapFeePercentage > _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE) {\n            revert ProtocolSwapFeePercentageTooHigh();\n        }\n        _;\n    }\n\n    // Validate the yield fee percentage against the maximum.\n    modifier withValidYieldFee(uint256 newYieldFeePercentage) {\n        if (newYieldFeePercentage > _MAX_PROTOCOL_YIELD_FEE_PERCENTAGE) {\n            revert ProtocolYieldFeePercentageTooHigh();\n        }\n        _;\n    }\n\n    // Force collection and disaggregation (e.g., before changing protocol fee percentages).\n    modifier withLatestFees(address pool) {\n        getVault().collectAggregateFees(pool);\n        _;\n    }\n\n    constructor(IVault vault_) SingletonAuthentication(vault_) VaultGuard(vault_) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function vault() external view returns (IVault) {\n        return getVault();\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getGlobalProtocolSwapFeePercentage() external view returns (uint256) {\n        return _globalProtocolSwapFeePercentage;\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getGlobalProtocolYieldFeePercentage() external view returns (uint256) {\n        return _globalProtocolYieldFeePercentage;\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getPoolProtocolSwapFeeInfo(address pool) external view returns (uint256, bool) {\n        PoolFeeConfig memory config = _poolProtocolSwapFeePercentages[pool];\n\n        return (config.feePercentage, config.isOverride);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getPoolProtocolYieldFeeInfo(address pool) external view returns (uint256, bool) {\n        PoolFeeConfig memory config = _poolProtocolYieldFeePercentages[pool];\n\n        return (config.feePercentage, config.isOverride);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getProtocolFeeAmounts(address pool) public view returns (uint256[] memory feeAmounts) {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        feeAmounts = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            feeAmounts[i] = _protocolFeeAmounts[pool][poolTokens[i]];\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function getPoolCreatorFeeAmounts(address pool) public view returns (uint256[] memory feeAmounts) {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        feeAmounts = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            feeAmounts[i] = _poolCreatorFeeAmounts[pool][poolTokens[i]];\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function computeAggregateFeePercentage(\n        uint256 protocolFeePercentage,\n        uint256 poolCreatorFeePercentage\n    ) external pure returns (uint256) {\n        return _computeAggregateFeePercentage(protocolFeePercentage, poolCreatorFeePercentage);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function updateProtocolSwapFeePercentage(address pool) external withLatestFees(pool) {\n        PoolFeeConfig memory feeConfig = _poolProtocolSwapFeePercentages[pool];\n        uint256 globalProtocolSwapFee = _globalProtocolSwapFeePercentage;\n\n        if (feeConfig.isOverride == false && globalProtocolSwapFee != feeConfig.feePercentage) {\n            _updatePoolSwapFeePercentage(pool, globalProtocolSwapFee, false);\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function updateProtocolYieldFeePercentage(address pool) external withLatestFees(pool) {\n        PoolFeeConfig memory feeConfig = _poolProtocolYieldFeePercentages[pool];\n        uint256 globalProtocolYieldFee = _globalProtocolYieldFeePercentage;\n\n        if (feeConfig.isOverride == false && globalProtocolYieldFee != feeConfig.feePercentage) {\n            _updatePoolYieldFeePercentage(pool, globalProtocolYieldFee, false);\n        }\n    }\n\n    function _getAggregateFeePercentage(address pool, ProtocolFeeType feeType) internal view returns (uint256) {\n        uint256 protocolFeePercentage;\n        uint256 poolCreatorFeePercentage;\n\n        if (feeType == ProtocolFeeType.SWAP) {\n            protocolFeePercentage = _poolProtocolSwapFeePercentages[pool].feePercentage;\n            poolCreatorFeePercentage = _poolCreatorSwapFeePercentages[pool];\n        } else {\n            protocolFeePercentage = _poolProtocolYieldFeePercentages[pool].feePercentage;\n            poolCreatorFeePercentage = _poolCreatorYieldFeePercentages[pool];\n        }\n\n        return _computeAggregateFeePercentage(protocolFeePercentage, poolCreatorFeePercentage);\n    }\n\n    function _computeAggregateFeePercentage(\n        uint256 protocolFeePercentage,\n        uint256 poolCreatorFeePercentage\n    ) internal pure returns (uint256 aggregateFeePercentage) {\n        aggregateFeePercentage =\n            protocolFeePercentage +\n            protocolFeePercentage.complement().mulDown(poolCreatorFeePercentage);\n\n        // Primary fee percentages are 18-decimal values, stored here in 64 bits, and calculated with full 256-bit\n        // precision. However, the resulting aggregate fees are stored in the Vault with 24-bit precision, which\n        // corresponds to 0.00001% resolution (i.e., a fee can be 1%, 1.00001%, 1.00002%, but not 1.000005%).\n        // Ensure there will be no precision loss in the Vault - which would lead to a discrepancy between the\n        // aggregate fee calculated here and that stored in the Vault.\n        if ((aggregateFeePercentage / FEE_SCALING_FACTOR) * FEE_SCALING_FACTOR != aggregateFeePercentage) {\n            revert IVaultErrors.FeePrecisionTooHigh();\n        }\n    }\n\n    function _ensureCallerIsPoolCreator(address pool) internal view {\n        address poolCreator = _poolCreators[pool];\n\n        if (poolCreator == address(0)) {\n            revert PoolCreatorNotRegistered(pool);\n        }\n\n        if (poolCreator != msg.sender) {\n            revert CallerIsNotPoolCreator(msg.sender);\n        }\n    }\n\n    function _getPoolTokensAndCount(address pool) internal view returns (IERC20[] memory tokens, uint256 numTokens) {\n        tokens = getVault().getPoolTokens(pool);\n        numTokens = tokens.length;\n    }\n\n    /***************************************************************************\n                                Permissioned Functions\n    ***************************************************************************/\n\n    /// @inheritdoc IProtocolFeeController\n    function registerPool(\n        address pool,\n        address poolCreator,\n        bool protocolFeeExempt\n    ) external onlyVault returns (uint256 aggregateSwapFeePercentage, uint256 aggregateYieldFeePercentage) {\n        _poolCreators[pool] = poolCreator;\n\n        // Set local storage of the actual percentages for the pool (default to global).\n        aggregateSwapFeePercentage = protocolFeeExempt ? 0 : _globalProtocolSwapFeePercentage;\n        aggregateYieldFeePercentage = protocolFeeExempt ? 0 : _globalProtocolYieldFeePercentage;\n\n        // `isOverride` is true if the pool is protocol fee exempt; otherwise, default to false.\n        // If exempt, this pool cannot be updated to the current global percentage permissionlessly.\n        _poolProtocolSwapFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(aggregateSwapFeePercentage),\n            isOverride: protocolFeeExempt\n        });\n        _poolProtocolYieldFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(aggregateYieldFeePercentage),\n            isOverride: protocolFeeExempt\n        });\n    }\n\n    enum ProtocolFeeType {\n        SWAP,\n        YIELD\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function receiveAggregateFees(\n        address pool,\n        uint256[] memory swapFeeAmounts,\n        uint256[] memory yieldFeeAmounts\n    ) external onlyVault {\n        _receiveAggregateFees(pool, ProtocolFeeType.SWAP, swapFeeAmounts);\n        _receiveAggregateFees(pool, ProtocolFeeType.YIELD, yieldFeeAmounts);\n    }\n\n    function _receiveAggregateFees(address pool, ProtocolFeeType feeType, uint256[] memory feeAmounts) private {\n        // There are two cases when we don't need to split fees (in which case we can save gas and avoid rounding\n        // errors by skipping calculations) if either the protocol or pool creator fee percentage is zero.\n\n        uint256 protocolFeePercentage = feeType == ProtocolFeeType.SWAP\n            ? _poolProtocolSwapFeePercentages[pool].feePercentage\n            : _poolProtocolYieldFeePercentages[pool].feePercentage;\n\n        uint256 poolCreatorFeePercentage = feeType == ProtocolFeeType.SWAP\n            ? _poolCreatorSwapFeePercentages[pool]\n            : _poolCreatorYieldFeePercentages[pool];\n\n        uint256 aggregateFeePercentage;\n\n        bool needToSplitFees = poolCreatorFeePercentage > 0 && protocolFeePercentage > 0;\n        if (needToSplitFees) {\n            // Calculate once, outside the loop.\n            aggregateFeePercentage = _computeAggregateFeePercentage(protocolFeePercentage, poolCreatorFeePercentage);\n        }\n\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            if (feeAmounts[i] > 0) {\n                IERC20 token = poolTokens[i];\n\n                token.safeTransferFrom(address(getVault()), address(this), feeAmounts[i]);\n\n                // It should be easier for off-chain processes to handle two events, rather than parsing the type\n                // out of a single event.\n                if (feeType == ProtocolFeeType.SWAP) {\n                    emit ProtocolSwapFeeCollected(pool, token, feeAmounts[i]);\n                } else {\n                    emit ProtocolYieldFeeCollected(pool, token, feeAmounts[i]);\n                }\n\n                if (needToSplitFees) {\n                    uint256 totalVolume = feeAmounts[i].divUp(aggregateFeePercentage);\n                    uint256 protocolPortion = totalVolume.mulUp(protocolFeePercentage);\n\n                    _protocolFeeAmounts[pool][token] += protocolPortion;\n                    _poolCreatorFeeAmounts[pool][token] += feeAmounts[i] - protocolPortion;\n                } else {\n                    // If we don't need to split, one of them must be zero.\n                    if (poolCreatorFeePercentage == 0) {\n                        _protocolFeeAmounts[pool][token] += feeAmounts[i];\n                    } else {\n                        _poolCreatorFeeAmounts[pool][token] += feeAmounts[i];\n                    }\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setGlobalProtocolSwapFeePercentage(\n        uint256 newProtocolSwapFeePercentage\n    ) external withValidSwapFee(newProtocolSwapFeePercentage) authenticate {\n        _globalProtocolSwapFeePercentage = newProtocolSwapFeePercentage;\n\n        emit GlobalProtocolSwapFeePercentageChanged(newProtocolSwapFeePercentage);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setGlobalProtocolYieldFeePercentage(\n        uint256 newProtocolYieldFeePercentage\n    ) external withValidYieldFee(newProtocolYieldFeePercentage) authenticate {\n        _globalProtocolYieldFeePercentage = newProtocolYieldFeePercentage;\n\n        emit GlobalProtocolYieldFeePercentageChanged(newProtocolYieldFeePercentage);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setProtocolSwapFeePercentage(\n        address pool,\n        uint256 newProtocolSwapFeePercentage\n    ) external withValidSwapFee(newProtocolSwapFeePercentage) withLatestFees(pool) authenticate {\n        _updatePoolSwapFeePercentage(pool, newProtocolSwapFeePercentage, true);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setProtocolYieldFeePercentage(\n        address pool,\n        uint256 newProtocolYieldFeePercentage\n    ) external withValidYieldFee(newProtocolYieldFeePercentage) withLatestFees(pool) authenticate {\n        _updatePoolYieldFeePercentage(pool, newProtocolYieldFeePercentage, true);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setPoolCreatorSwapFeePercentage(\n        address pool,\n        uint256 poolCreatorSwapFeePercentage\n    ) external onlyPoolCreator(pool) {\n        _setPoolCreatorFeePercentage(pool, poolCreatorSwapFeePercentage, ProtocolFeeType.SWAP);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function setPoolCreatorYieldFeePercentage(\n        address pool,\n        uint256 poolCreatorYieldFeePercentage\n    ) external onlyPoolCreator(pool) {\n        _setPoolCreatorFeePercentage(pool, poolCreatorYieldFeePercentage, ProtocolFeeType.YIELD);\n    }\n\n    function _setPoolCreatorFeePercentage(\n        address pool,\n        uint256 poolCreatorFeePercentage,\n        ProtocolFeeType feeType\n    ) private {\n        if (poolCreatorFeePercentage > FixedPoint.ONE) {\n            revert PoolCreatorFeePercentageTooHigh();\n        }\n\n        // Force collection of fees at the existing rate.\n        getVault().collectAggregateFees(pool);\n\n        // Need to set locally, and update the aggregate percentage in the vault.\n        if (feeType == ProtocolFeeType.SWAP) {\n            _poolCreatorSwapFeePercentages[pool] = poolCreatorFeePercentage;\n\n            getVault().updateAggregateSwapFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.SWAP));\n\n            emit PoolCreatorSwapFeePercentageChanged(pool, poolCreatorFeePercentage);\n        } else {\n            _poolCreatorYieldFeePercentages[pool] = poolCreatorFeePercentage;\n\n            getVault().updateAggregateYieldFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.YIELD));\n\n            emit PoolCreatorYieldFeePercentageChanged(pool, poolCreatorFeePercentage);\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function withdrawProtocolFees(address pool, address recipient) external authenticate {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            IERC20 token = poolTokens[i];\n\n            uint256 amountToWithdraw = _protocolFeeAmounts[pool][token];\n            if (amountToWithdraw > 0) {\n                _protocolFeeAmounts[pool][token] = 0;\n                token.safeTransfer(recipient, amountToWithdraw);\n            }\n        }\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function withdrawPoolCreatorFees(address pool, address recipient) external onlyPoolCreator(pool) {\n        _withdrawPoolCreatorFees(pool, recipient);\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    function withdrawPoolCreatorFees(address pool) external {\n        _withdrawPoolCreatorFees(pool, _poolCreators[pool]);\n    }\n\n    function _withdrawPoolCreatorFees(address pool, address recipient) private {\n        (IERC20[] memory poolTokens, uint256 numTokens) = _getPoolTokensAndCount(pool);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            IERC20 token = poolTokens[i];\n\n            uint256 amountToWithdraw = _poolCreatorFeeAmounts[pool][token];\n            if (amountToWithdraw > 0) {\n                _poolCreatorFeeAmounts[pool][token] = 0;\n                token.safeTransfer(recipient, amountToWithdraw);\n            }\n        }\n    }\n\n    /// @dev Common code shared between set/update. `isOverride` will be true if governance is setting the percentage.\n    function _updatePoolSwapFeePercentage(address pool, uint256 newProtocolSwapFeePercentage, bool isOverride) private {\n        // Update local storage of the raw percentage\n        _poolProtocolSwapFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(newProtocolSwapFeePercentage),\n            isOverride: isOverride\n        });\n\n        // Update the resulting aggregate swap fee value in the Vault (PoolConfig).\n        getVault().updateAggregateSwapFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.SWAP));\n\n        emit ProtocolSwapFeePercentageChanged(pool, newProtocolSwapFeePercentage);\n    }\n\n    /// @dev Common code shared between set/update. `isOverride` will be true if governance is setting the percentage.\n    function _updatePoolYieldFeePercentage(\n        address pool,\n        uint256 newProtocolYieldFeePercentage,\n        bool isOverride\n    ) private {\n        // Update local storage of the raw percentage.\n        _poolProtocolYieldFeePercentages[pool] = PoolFeeConfig({\n            feePercentage: uint64(newProtocolYieldFeePercentage),\n            isOverride: isOverride\n        });\n\n        // Update the resulting aggregate yield fee value in the Vault (PoolConfig).\n        getVault().updateAggregateYieldFeePercentage(pool, _getAggregateFeePercentage(pool, ProtocolFeeType.YIELD));\n\n        emit ProtocolYieldFeePercentageChanged(pool, newProtocolYieldFeePercentage);\n    }\n}\n"
    }
}