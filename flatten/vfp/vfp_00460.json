{
    "vfp_id": "vfp_00460",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "onlyNonceZero check can be bypassed",
            "description": "The onlyNonceZero modifier in SafeToL2Migration.sol checks that the nonce equals 1, assuming this indicates no transactions have been executed (since nonce starts at 0 and increments before execution). However, this check can be bypassed if a transaction is executed via a module, as module calls do not increment the nonce. This allows a Safe with prior transaction history to appear as if it has a zero transaction count, potentially violating backend assumptions for L2 migration. The root cause is a flawed logic assumption that nonce == 1 always implies no prior execution, without accounting for module-based transactions. An attacker could exploit this by executing a transaction through a module and then migrating the Safe to L2, circumventing the intended restriction. The impact is a warning due to potential state inconsistency in migration logic, though the backend may have mitigations.\n",
            "severity": "Informational",
            "location": [
                "SafeToL2Migration.sol::onlyNonceZero#64-68"
            ],
            "files": [
                "safe-smart-account/contracts/libraries/SafeToL2Migration.sol"
            ]
        }
    ],
    "affected_files": {
        "SafeToL2Migration.sol": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ISafe} from \"./../interfaces/ISafe.sol\";\nimport {Enum} from \"./../libraries/Enum.sol\";\nimport {SafeStorage} from \"./../libraries/SafeStorage.sol\";\n\n/**\n * @title Migration Contract for updating a Safe from 1.1.1/1.3.0/1.4.1 versions to a L2 version. Useful when replaying a Safe from a non L2 network in a L2 network.\n * @notice This contract facilitates the migration of a Safe contract from version 1.1.1 to 1.3.0/1.4.1 L2, 1.3.0 to 1.3.0L2 or from 1.4.1 to 1.4.1L2\n *         Other versions are not supported\n * @dev IMPORTANT: The migration will only work with proxies that store the implementation address in the storage slot 0.\n */\ncontract SafeToL2Migration is SafeStorage {\n    // Address of this contract\n    address public immutable MIGRATION_SINGLETON;\n\n    /**\n     * @notice Constructor\n     * @dev Initializes the migrationSingleton with the contract's own address.\n     */\n    constructor() {\n        MIGRATION_SINGLETON = address(this);\n    }\n\n    /**\n     * @notice Event indicating a change of master copy address.\n     * @param singleton New master copy address\n     */\n    event ChangedMasterCopy(address singleton);\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n\n    event SafeMultiSigTransaction(\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes signatures,\n        // We combine nonce, sender and threshold into one to avoid stack too deep\n        // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding\n        bytes additionalInfo\n    );\n\n    /**\n     * @notice Modifier to make a function callable via delegatecall only.\n     * If the function is called via a regular call, it will revert.\n     */\n    modifier onlyDelegateCall() {\n        require(address(this) != MIGRATION_SINGLETON, \"Migration should only be called via delegatecall\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to prevent using initialized Safes.\n     * If Safe has a nonce higher than 0, it will revert\n     */\n    modifier onlyNonceZero() {\n        // Nonce is increased before executing a tx, so first executed tx will have nonce=1\n        require(nonce == 1, \"Safe must have not executed any tx\");\n        _;\n    }\n\n    /**\n     * @dev Internal function with common migration steps, changes the singleton and emits SafeMultiSigTransaction event\n     */\n    function migrate(address l2Singleton, bytes memory functionData) private {\n        singleton = l2Singleton;\n\n        // Encode nonce, sender, threshold\n        bytes memory additionalInfo = abi.encode(0, msg.sender, threshold);\n\n        // Simulate a L2 transaction so Safe Tx Service indexer picks up the Safe\n        emit SafeMultiSigTransaction(\n            MIGRATION_SINGLETON,\n            0,\n            functionData,\n            Enum.Operation.DelegateCall,\n            0,\n            0,\n            0,\n            address(0),\n            payable(address(0)),\n            \"\", // We cannot detect signatures\n            additionalInfo\n        );\n        emit ChangedMasterCopy(l2Singleton);\n    }\n\n    /**\n     * @notice Migrate from Safe 1.3.0/1.4.1 Singleton (L1) to the same version provided L2 singleton\n     * Safe is required to have nonce 0 so backend can support it after the migration\n     * @dev This function should only be called via a delegatecall to perform the upgrade.\n     * Singletons versions will be compared, so it implies that contracts exist\n     */\n    function migrateToL2(address l2Singleton) external onlyDelegateCall onlyNonceZero {\n        address _singleton = singleton;\n        require(_singleton != l2Singleton, \"Safe is already using the singleton\");\n        bytes32 oldSingletonVersion = keccak256(abi.encodePacked(ISafe(_singleton).VERSION()));\n        bytes32 newSingletonVersion = keccak256(abi.encodePacked(ISafe(l2Singleton).VERSION()));\n\n        require(oldSingletonVersion == newSingletonVersion, \"L2 singleton must match current version singleton\");\n        // There's no way to make sure if address is a valid singleton, unless we configure the contract for every chain\n        require(\n            newSingletonVersion == keccak256(abi.encodePacked(\"1.3.0\")) || newSingletonVersion == keccak256(abi.encodePacked(\"1.4.1\")),\n            \"Provided singleton version is not supported\"\n        );\n\n        // 0xef2624ae - bytes4(keccak256(\"migrateToL2(address)\"))\n        bytes memory functionData = abi.encodeWithSelector(0xef2624ae, l2Singleton);\n        migrate(l2Singleton, functionData);\n    }\n\n    /**\n     * @notice Migrate from Safe 1.1.1 Singleton to 1.3.0 or 1.4.1 L2\n     * Safe is required to have nonce 0 so backend can support it after the migration\n     * @dev This function should only be called via a delegatecall to perform the upgrade.\n     * Singletons version will be checked, so it implies that contracts exist.\n     * A valid and compatible fallbackHandler needs to be provided, only existence will be checked.\n     */\n    function migrateFromV111(address l2Singleton, address fallbackHandler) external onlyDelegateCall onlyNonceZero {\n        require(isContract(fallbackHandler), \"fallbackHandler is not a contract\");\n\n        bytes32 oldSingletonVersion = keccak256(abi.encodePacked(ISafe(singleton).VERSION()));\n        require(oldSingletonVersion == keccak256(abi.encodePacked(\"1.1.1\")), \"Provided singleton version is not supported\");\n\n        bytes32 newSingletonVersion = keccak256(abi.encodePacked(ISafe(l2Singleton).VERSION()));\n        require(\n            newSingletonVersion == keccak256(abi.encodePacked(\"1.3.0\")) || newSingletonVersion == keccak256(abi.encodePacked(\"1.4.1\")),\n            \"Provided singleton version is not supported\"\n        );\n\n        ISafe safe = ISafe(address(this));\n        safe.setFallbackHandler(fallbackHandler);\n\n        // Safes < 1.3.0 did not emit SafeSetup, so Safe Tx Service backend needs the event to index the Safe\n        emit SafeSetup(MIGRATION_SINGLETON, getOwners(), threshold, address(0), fallbackHandler);\n\n        // 0xd9a20812 - bytes4(keccak256(\"migrateFromV111(address,address)\"))\n        bytes memory functionData = abi.encodeWithSelector(0xd9a20812, l2Singleton, fallbackHandler);\n        migrate(l2Singleton, functionData);\n    }\n\n    /**\n     * @notice Checks whether an Ethereum address corresponds to a contract or an externally owned account (EOA).\n     * @param account The Ethereum address to be checked.\n     * @return A boolean value indicating whether the address is associated with a contract (true) or an EOA (false).\n     * @dev This function relies on the `extcodesize` assembly opcode to determine whether an address is a contract.\n     * It may return incorrect results in some edge cases (see documentation for details).\n     * Developers should use caution when relying on the results of this function for critical decision-making.\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        /* solhint-enable no-inline-assembly */\n\n        // If the code size is greater than 0, it is a contract; otherwise, it is an EOA.\n        return size > 0;\n    }\n\n    /**\n     * @notice Returns a list of Safe owners.\n     * @dev This function is copied from `OwnerManager.sol` and takes advantage of the fact that\n     * migration happens with a `DELEGATECALL` in the context of the migrating account, which allows\n     * us to read the owners directly from storage and avoid the additional overhead of a `CALL`\n     * into the account implementation. Note that we can rely on the memory layout of the {owners}\n     * @return Array of Safe owners.\n     */\n    function getOwners() internal view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n        address sentinelOwners = address(0x1);\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[sentinelOwners];\n        while (currentOwner != sentinelOwners) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            ++index;\n        }\n        return array;\n    }\n}\n"
    }
}