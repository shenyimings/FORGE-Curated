{
    "vfp_id": "vfp_00460",
    "project_name": "Across Protocol SVM Solidity Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "_destinationSettler Can Return Zero Address",
            "description": "In the `_resolveFor` function of the `ERC7683OrderDepositor` contract, the return value from the internal `_destinationSettler` function is used without validating that it is non-zero. The `_destinationSettler` function retrieves the settler contract address for the destination chain, and if it has not been properly set, it returns the default zero address. This unchecked value is then assigned to the `fillInstructions` field of the `resolvedOrder` struct. The root cause is missing input validation for critical system parameters. An attacker could potentially craft a transaction that results in funds being sent to the zero address or cause a revert in downstream operations, leading to a loss of user funds or denial of service. The impact is medium to low depending on the execution path, but it introduces unnecessary risk due to improper validation.\n",
            "severity": "Low",
            "location": [
                "ERC7683OrderDepositor.sol::_resolveFor#245"
            ],
            "files": [
                "contracts/contracts/erc7683/ERC7683OrderDepositor.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Repeated Function",
            "description": "The `_toBytes32` internal function in the `ERC7683OrderDepositor` contract duplicates the functionality of the `toBytes32` function from the `AddressConverters` library. Both functions perform the same conversion logic and are used interchangeably within the contract. The root cause is code redundancy due to lack of reuse of existing library functions. While this does not introduce a direct security vulnerability, it reduces code clarity, increases maintenance burden, and raises the risk of inconsistent behavior if one function is updated and the other is not. The impact is primarily on code quality and long-term maintainability, making audits and future development more error-prone. It also slightly increases deployment gas costs due to duplicated bytecode.\n",
            "severity": "Low",
            "location": [
                "ERC7683OrderDepositor.sol::_toBytes32#355",
                "AddressConverters.sol::toBytes32#23"
            ],
            "files": [
                "contracts/contracts/erc7683/ERC7683OrderDepositor.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Lack of Unit Tests for ERC-7683",
            "description": "The codebase currently lacks unit tests for the `ERC7683OrderDepositor` and `ERC7683OrderDepositorExternal` contracts, which are critical components of the new ERC-7683 implementation. The root cause is insufficient test coverage for newly introduced features. Without proper unit tests, it is difficult to verify the correctness of the implementation, detect regressions, or ensure robustness under edge cases. An attacker could potentially identify and exploit untested code paths that were not considered during manual review. The impact is an increased risk of undiscovered vulnerabilities in a core part of the system, reducing overall confidence in the security and reliability of the ERC-7683 integration.\n",
            "severity": "Low",
            "location": [
                "ERC7683OrderDepositor.sol",
                "ERC7683OrderDepositorExternal.sol"
            ],
            "files": [
                "contracts/contracts/erc7683/ERC7683OrderDepositor.sol",
                "contracts/contracts/erc7683/ERC7683OrderDepositorExternal.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC7683OrderDepositor.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport { V3SpokePoolInterface } from \"../interfaces/V3SpokePoolInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Output, GaslessCrossChainOrder, OnchainCrossChainOrder, ResolvedCrossChainOrder, IOriginSettler, FillInstruction } from \"./ERC7683.sol\";\nimport { AcrossOrderData, AcrossOriginFillerData, ERC7683Permit2Lib, ACROSS_ORDER_DATA_TYPE_HASH } from \"./ERC7683Permit2Lib.sol\";\n\n/**\n * @notice ERC7683OrderDepositor processes an external order type and translates it into an AcrossV3 deposit.\n * @dev This contract is abstract because it is intended to be usable by a contract that can accept the deposit\n * as well as one that sends the deposit to another contract.\n * @custom:security-contact bugs@across.to\n */\nabstract contract ERC7683OrderDepositor is IOriginSettler {\n    using SafeERC20 for IERC20;\n\n    error WrongSettlementContract();\n    error WrongChainId();\n    error WrongOrderDataType();\n    error WrongExclusiveRelayer();\n\n    // Permit2 contract for this network.\n    IPermit2 public immutable PERMIT2;\n\n    // QUOTE_BEFORE_DEADLINE is subtracted from the deadline to get the quote timestamp.\n    // This is a somewhat arbitrary conversion, but order creators need some way to precompute the quote timestamp.\n    uint256 public immutable QUOTE_BEFORE_DEADLINE;\n\n    /**\n     * @notice Construct the Permit2Depositor.\n     * @param _permit2 Permit2 contract\n     * @param _quoteBeforeDeadline quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n     */\n    constructor(IPermit2 _permit2, uint256 _quoteBeforeDeadline) {\n        PERMIT2 = _permit2;\n        QUOTE_BEFORE_DEADLINE = _quoteBeforeDeadline;\n    }\n\n    /**\n     * @notice Open the order on behalf of the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     * @param signature signature for the EIP-712 compliant order type.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata originFillerData\n    ) external {\n        (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        ) = _resolveFor(order, originFillerData);\n\n        // Verify Permit2 signature and pull user funds into this contract\n        _processPermit2Order(order, acrossOrderData, signature);\n\n        _callDeposit(\n            order.user,\n            _toAddress(acrossOrderData.recipient),\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOriginFillerData.exclusiveRelayer,\n            // Note: simplifying assumption to avoid quote timestamps that cause orders to expire before the deadline.\n            SafeCast.toUint32(order.openDeadline - QUOTE_BEFORE_DEADLINE),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Opens the order.\n     * @dev Unlike openFor, this method is callable by the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     */\n    function open(OnchainCrossChainOrder calldata order) external {\n        (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData) = _resolve(order);\n\n        IERC20(acrossOrderData.inputToken).safeTransferFrom(msg.sender, address(this), acrossOrderData.inputAmount);\n\n        _callDeposit(\n            msg.sender,\n            _toAddress(acrossOrderData.recipient),\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOrderData.exclusiveRelayer,\n            // Note: simplifying assumption to avoid the order type having to bake in the quote timestamp.\n            SafeCast.toUint32(block.timestamp),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a GaslessCrossChainOrder and originFillerData.\n     * @param order the ERC-7683 compliant order.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, , ) = _resolveFor(order, originFillerData);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a CrossChainOrder.\n     * @param order the ERC7683 compliant order.\n     */\n    function resolve(OnchainCrossChainOrder calldata order)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, ) = _resolve(order);\n    }\n\n    /**\n     * @notice Decodes the Across specific orderData and fillerData into descriptive types.\n     * @param orderData the orderData field of the ERC7683 compliant order.\n     * @param fillerData Across-specific fillerData.\n     * @return acrossOrderData decoded AcrossOrderData.\n     * @return acrossOriginFillerData decoded AcrossOriginFillerData.\n     */\n    function decode(bytes memory orderData, bytes memory fillerData)\n        public\n        pure\n        returns (AcrossOrderData memory, AcrossOriginFillerData memory)\n    {\n        return (abi.decode(orderData, (AcrossOrderData)), abi.decode(fillerData, (AcrossOriginFillerData)));\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint32) {\n        return SafeCast.toUint32(block.timestamp); // solhint-disable-line not-rely-on-time\n    }\n\n    function _resolveFor(GaslessCrossChainOrder calldata order, bytes calldata fillerData)\n        internal\n        view\n        returns (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        )\n    {\n        // Ensure that order was intended to be settled by Across.\n        if (order.originSettler != address(this)) {\n            revert WrongSettlementContract();\n        }\n\n        if (order.originChainId != block.chainid) {\n            revert WrongChainId();\n        }\n\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        (acrossOrderData, acrossOriginFillerData) = decode(order.orderData, fillerData);\n\n        if (\n            acrossOrderData.exclusiveRelayer != address(0) &&\n            acrossOrderData.exclusiveRelayer != acrossOriginFillerData.exclusiveRelayer\n        ) {\n            revert WrongExclusiveRelayer();\n        }\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: _toBytes32(acrossOrderData.outputToken),\n            amount: acrossOrderData.outputAmount,\n            recipient: acrossOrderData.recipient,\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: _toBytes32(acrossOrderData.inputToken),\n            amount: acrossOrderData.inputAmount,\n            recipient: _toBytes32(acrossOriginFillerData.exclusiveRelayer),\n            chainId: block.chainid\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        V3SpokePoolInterface.V3RelayData memory relayData;\n        relayData.depositor = order.user;\n        relayData.recipient = _toAddress(acrossOrderData.recipient);\n        relayData.exclusiveRelayer = acrossOriginFillerData.exclusiveRelayer;\n        relayData.inputToken = acrossOrderData.inputToken;\n        relayData.outputToken = acrossOrderData.outputToken;\n        relayData.inputAmount = acrossOrderData.inputAmount;\n        relayData.outputAmount = acrossOrderData.outputAmount;\n        relayData.originChainId = block.chainid;\n        relayData.depositId = _currentDepositId();\n        relayData.fillDeadline = order.fillDeadline;\n        relayData.exclusivityDeadline = acrossOrderData.exclusivityPeriod;\n        relayData.message = acrossOrderData.message;\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: SafeCast.toUint64(acrossOrderData.destinationChainId),\n            destinationSettler: _toBytes32(_destinationSettler(acrossOrderData.destinationChainId)),\n            originData: abi.encode(relayData)\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: order.user,\n            originChainId: order.originChainId,\n            openDeadline: order.openDeadline,\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions,\n            orderId: keccak256(abi.encode(relayData, acrossOrderData.destinationChainId))\n        });\n    }\n\n    function _resolve(OnchainCrossChainOrder calldata order)\n        internal\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData)\n    {\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        acrossOrderData = abi.decode(order.orderData, (AcrossOrderData));\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: _toBytes32(acrossOrderData.outputToken),\n            amount: acrossOrderData.outputAmount,\n            recipient: acrossOrderData.recipient,\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: _toBytes32(acrossOrderData.inputToken),\n            amount: acrossOrderData.inputAmount,\n            recipient: _toBytes32(acrossOrderData.exclusiveRelayer),\n            chainId: block.chainid\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        V3SpokePoolInterface.V3RelayData memory relayData;\n        relayData.depositor = msg.sender;\n        relayData.recipient = _toAddress(acrossOrderData.recipient);\n        relayData.exclusiveRelayer = acrossOrderData.exclusiveRelayer;\n        relayData.inputToken = acrossOrderData.inputToken;\n        relayData.outputToken = acrossOrderData.outputToken;\n        relayData.inputAmount = acrossOrderData.inputAmount;\n        relayData.outputAmount = acrossOrderData.outputAmount;\n        relayData.originChainId = block.chainid;\n        relayData.depositId = _currentDepositId();\n        relayData.fillDeadline = order.fillDeadline;\n        relayData.exclusivityDeadline = acrossOrderData.exclusivityPeriod;\n        relayData.message = acrossOrderData.message;\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: SafeCast.toUint64(acrossOrderData.destinationChainId),\n            destinationSettler: _toBytes32(_destinationSettler(acrossOrderData.destinationChainId)),\n            originData: abi.encode(relayData)\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: msg.sender,\n            originChainId: block.chainid,\n            openDeadline: type(uint32).max, // no deadline since the user is sending it\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions,\n            orderId: keccak256(abi.encode(relayData, acrossOrderData.destinationChainId))\n        });\n    }\n\n    function _processPermit2Order(\n        GaslessCrossChainOrder memory order,\n        AcrossOrderData memory acrossOrderData,\n        bytes memory signature\n    ) internal {\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({\n                token: acrossOrderData.inputToken,\n                amount: acrossOrderData.inputAmount\n            }),\n            nonce: order.nonce,\n            deadline: order.openDeadline\n        });\n\n        IPermit2.SignatureTransferDetails memory signatureTransferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: acrossOrderData.inputAmount\n        });\n\n        // Pull user funds.\n        PERMIT2.permitWitnessTransferFrom(\n            permit,\n            signatureTransferDetails,\n            order.user,\n            ERC7683Permit2Lib.hashOrder(order, ERC7683Permit2Lib.hashOrderData(acrossOrderData)), // witness data hash\n            ERC7683Permit2Lib.PERMIT2_ORDER_TYPE, // witness data type string\n            signature\n        );\n    }\n\n    function _toBytes32(address input) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(input)));\n    }\n\n    function _toAddress(bytes32 _bytes32) internal pure returns (address) {\n        require(uint256(_bytes32) >> 160 == 0, \"Invalid bytes32: highest 12 bytes must be 0\");\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityPeriod,\n        bytes memory message\n    ) internal virtual;\n\n    function _currentDepositId() internal view virtual returns (uint32);\n\n    function _destinationSettler(uint256 chainId) internal view virtual returns (address);\n}\n",
        "ERC7683OrderDepositorExternal.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC7683OrderDepositor } from \"./ERC7683OrderDepositor.sol\";\nimport \"../SpokePool.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\n\n/**\n * @notice ERC7683OrderDepositorExternal processes an external order type and translates it into an AcrossV3Deposit\n * that it sends to the SpokePool contract.\n * @custom:security-contact bugs@across.to\n */\ncontract ERC7683OrderDepositorExternal is ERC7683OrderDepositor, Ownable, MultiCaller {\n    using SafeERC20 for IERC20;\n\n    event SetDestinationSettler(\n        uint256 indexed chainId,\n        address indexed prevDestinationSettler,\n        address indexed destinationSettler\n    );\n\n    SpokePool public immutable SPOKE_POOL;\n\n    // Mapping of chainIds to destination settler addresses.\n    mapping(uint256 => address) public destinationSettlers;\n\n    constructor(\n        SpokePool _spokePool,\n        IPermit2 _permit2,\n        uint256 _quoteBeforeDeadline\n    ) ERC7683OrderDepositor(_permit2, _quoteBeforeDeadline) {\n        SPOKE_POOL = _spokePool;\n    }\n\n    function setDestinationSettler(uint256 chainId, address destinationSettler) external onlyOwner {\n        address prevDestinationSettler = destinationSettlers[chainId];\n        destinationSettlers[chainId] = destinationSettler;\n        emit SetDestinationSettler(chainId, prevDestinationSettler, destinationSettler);\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes memory message\n    ) internal override {\n        IERC20(inputToken).forceApprove(address(SPOKE_POOL), inputAmount);\n\n        SPOKE_POOL.depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityDeadline,\n            message\n        );\n    }\n\n    function _currentDepositId() internal view override returns (uint32) {\n        return SPOKE_POOL.numberOfDeposits();\n    }\n\n    function _destinationSettler(uint256 chainId) internal view override returns (address) {\n        return destinationSettlers[chainId];\n    }\n}\n"
    }
}