{
    "vfp_id": "vfp_00470",
    "project_name": "SSO Account Abstraction Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Lack of Output Validation Can Lock the SsoAccount",
            "description": "The SsoAccount contract and its managers use OpenZeppelin's EnumerableSet library to manage sets of hooks, owners, and validators. However, the code does not check the boolean return values of the `add` and `remove` functions, incorrectly assuming that these operations will revert on failure. This leads to silent failures where operations appear to succeed but do not modify the set.\n\nThe root cause is the lack of validation of return values from `add` and `remove` calls in the `HookManager`, `OwnerManager`, and `ValidatorManager` contracts. As a result, when a user attempts to remove a hook with an incorrect `isValidation` flag, the removal fails silently, but the `onUninstall` function is still called. This can lead to inconsistent state in the hook, potentially causing future transaction validations to fail.\n\nAn attacker or user error could exploit this by calling `removeHook` or `unlinkHook` with the wrong flag, leading to a situation where the hook believes it is uninstalled but remains in the list, or vice versa. Similarly, attempting to add a duplicate owner or validator does not change the set but still emits events, misleading off-chain indexers.\n\nThe impact includes potential permanent lockup of the account if a critical hook enters an inconsistent state, or incorrect state tracking by external services relying on emitted events. This could prevent the account from executing any further transactions, resulting in a denial of service.\n",
            "severity": "High",
            "location": [
                "HookManager.sol::removeHook#35-44",
                "OwnerManager.sol::addOwner#40-50",
                "ValidatorManager.sol::addValidator#28-43",
                "HookManager.sol::unlinkHook#35-44",
                "OwnerManager.sol::removeOwner#40-50",
                "ValidatorManager.sol::removeValidator#28-43"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol",
                "zksync-sso-clave-contracts/src/managers/OwnerManager.sol",
                "zksync-sso-clave-contracts/src/managers/ValidatorManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-924"
                ]
            },
            "title": "Transaction Can Be Executed in Unintended Period",
            "description": "The SessionKeyValidator allows granular spending controls through time-based periods. However, the `periodIds` used to determine which spending period to charge are passed within the `transaction.signature` field, which is not included in the transaction hash. This means that the `periodIds` are not cryptographically bound to the transaction.\n\nThe root cause is that the ZKsync transaction encoding process does not include the auxiliary data in the signature field when computing the transaction hash. As a result, anyone can modify the `periodIds` without invalidating the signature, allowing replay of the same transaction under different time periods.\n\nAn attacker can observe a transaction in the mempool that fails validation due to insufficient allowance in the intended period. They can then resubmit the same transaction with different `periodIds`, potentially draining allowances from other periods. This is especially dangerous if the session has high allowances in other periods.\n\nThe impact is unauthorized spending from unintended time periods, undermining the security model of time-limited sessions. Users may lose funds or have their spending controls bypassed, leading to financial loss or unexpected behavior.\n",
            "severity": "Medium",
            "location": [
                "SessionKeyValidator.sol::validateTransaction#149",
                "SessionLib.sol::checkPeriodAllowance#69",
                "SsoAccount.sol::validateTransaction#199"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Adding or Removing Execution Hooks Causes Unexpected Behaviour",
            "description": "The HookManager uses a modifier `runExecutionHooks` that iterates over a list of execution hooks before and after transaction execution. However, if the transaction itself adds or removes an execution hook, the loop that runs the `postExecutionHook` functions can go out of bounds or execute hooks in an incorrect order.\n\nThe cause lies in the use of a cached `totalHooks` variable at the start of the loop, while the underlying set is modified during execution. Since the OpenZeppelin EnumerableSet does not guarantee ordering, removing a hook during execution can cause the loop to access an index that no longer exists, causing a revert. Similarly, adding a hook may result in it being executed in the post-hook phase while others are skipped.\n\nAn attacker or user attempting to remove an execution hook would find the transaction reverting due to the out-of-bounds access. This effectively prevents the removal of execution hooks, creating a denial of service. Additionally, inconsistent hook execution order can lead to state corruption in hooks that depend on execution sequence.\n\nThe impact is an inability to manage execution hooks safely, potentially locking the account into unwanted hook behavior. This undermines the flexibility of the account abstraction model and could prevent necessary upgrades or security fixes.\n",
            "severity": "Medium",
            "location": [
                "HookManager.sol::runExecutionHooks#77",
                "HookManager.sol::postExecutionHook#87-89"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "error Keyword Used For Variable Naming",
            "description": "The `ERC1271Handler.sol` and `SsoAccount.sol` contracts use the name `error` for a local variable that stores the result of an `ECDSA.tryRecover` call. This is problematic because `error` is a reserved keyword in Solidity for defining custom errors, introduced in version 0.8.4.\n\nThe root cause is poor variable naming choice, which can lead to confusion during code review and maintenance. While it does not currently cause compilation issues (as `error` is not a full keyword like `function`), it increases the risk of future syntax conflicts or misinterpretation by developers.\n\nA developer reading or modifying the code might mistakenly believe that `error` refers to a custom error type or built-in exception, leading to incorrect assumptions about control flow. This could result in bugs during refactoring or integration with other components.\n\nThe impact is reduced code clarity and maintainability, increasing the likelihood of human error during development. While not directly exploitable, it contributes to technical debt and potential security risks in future changes.\n",
            "severity": "Low",
            "location": [
                "ERC1271Handler.sol::isValidSignature#35-37",
                "SsoAccount.sol::validateTransaction#191-193"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/handlers/ERC1271Handler.sol",
                "zksync-sso-clave-contracts/src/SsoAccount.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Storage Slot Collision with Clave Protocol",
            "description": "The `SsoStorage` library uses a storage slot that is identical to one used by the Clave protocol, which could lead to storage collisions if both protocols are deployed in the same environment or if future upgrades are not carefully managed. This occurs because the storage slot was derived from a hash that coincides with Clave's implementation, likely due to insufficient uniqueness in the hashing input. An attacker or conflicting protocol could overwrite critical state variables in the SsoAccount contract by writing to the same storage slot, potentially leading to corruption of account state or unauthorized behavior. The impact includes loss of state integrity and potential compromise of account functionality.\n",
            "severity": "High",
            "location": [
                "SsoStorage.sol#7",
                "https://github.com/getclave/clave-contracts/blob/0719581143537dde145291a6ea45ac308c2d0f6c/contracts/libraries/ClaveStorage.sol#L7"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/libraries/SsoStorage.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unsafe ABI Encoding with abi.encodeWithSelector",
            "description": "The codebase uses `abi.encodeWithSelector` in multiple locations (HookManager, SessionLib, ValidatorManager), which is not type-safe and can lead to silent failures if the function signature does not match the actual function being called. This is caused by bypassing Solidity's type checking, allowing incorrect argument types or counts to be encoded without compiler errors. An attacker could exploit this if a function call is made to a malformed selector, potentially leading to incorrect state changes or reverted transactions that disrupt protocol flow. The impact includes reduced reliability, potential for silent bugs, and increased risk of integration errors.\n",
            "severity": "Low",
            "location": [
                "HookManager.sol#43",
                "SessionLib.sol#289",
                "ValidatorManager.sol#42"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol",
                "zksync-sso-clave-contracts/src/libraries/SessionLib.sol",
                "zksync-sso-clave-contracts/src/managers/ValidatorManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "SsoAccount Can Call updateAccountVersion and updateNonceOrdering",
            "description": "The `SsoAccount` contract does not validate function selectors when making system calls via `batchCall`, allowing it to invoke sensitive system functions like `updateAccountVersion` and `updateNonceOrdering` on the `DEPLOYER_SYSTEM_CONTRACT`. This lack of validation stems from missing checks that exist in similar implementations like `DefaultAccount`. An attacker could craft a transaction batch that modifies the account version or nonce ordering, leading to unexpected behavior in transaction processing or nonce management. The impact includes potential disruption of account security invariants and possible denial-of-service or nonce manipulation attacks.\n",
            "severity": "Medium",
            "location": [
                "BatchCaller.sol#38-46",
                "SsoAccount.sol#119-122"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/batch/BatchCaller.sol",
                "zksync-sso-clave-contracts/src/SsoAccount.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "SsoAccount Contract Deployment Can Be Frontrun",
            "description": "The `AAFactory` allows any user to deploy an `SsoAccount` using a salt and unique account ID, but does not prevent other users from observing and frontrunning this transaction. This occurs because the deployment relies on predictable inputs (`_salt` and `_uniqueAccountId`) without incorporating `msg.sender` or a sequential nonce. An attacker can monitor the mempool, compute the CREATE2 address, and deploy the contract first, potentially receiving funds sent to that address by the original user. The impact includes loss of funds and denial-of-service, where users lose control over their intended account address.\n",
            "severity": "High",
            "location": [
                "AAFactory.sol#45"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/AAFactory.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-392"
                ]
            },
            "title": "Reverted Output From Batch Execution Is Dismissed",
            "description": "When a batch call fails and `allowFailure` is true, the reverted call's data is discarded and no event is emitted to log the failure. This is caused by the `BatchCaller` contract not capturing or emitting the index and return data of failed subcalls. While execution continues as intended, this lack of visibility makes debugging and monitoring extremely difficult. An attacker could exploit this by triggering silent failures in batched operations, hiding malicious behavior or errors from off-chain services. The impact includes reduced observability, hindered debugging, and potential for undetected malicious activity.\n",
            "severity": "Low",
            "location": [
                "BatchCaller.sol#50-52"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/batch/BatchCaller.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant Association of Access Control",
            "description": "The `Auth` contract aggregates multiple authentication modifiers (`BootloaderAuth`, `SelfAuth`, `HookAuth`), but most inheriting contracts only use one of them. For example, `ValidatorManager` only uses `onlySelf`, while `SsoAccount` only uses `onlyBootloader`. This leads to unnecessary code bloat and increased deployment cost due to inclusion of unused logic. The root cause is poor modularization of access control components. While not directly exploitable, this increases maintenance burden and attack surface. The impact is reduced code clarity, higher gas costs, and increased risk of future vulnerabilities due to complex inheritance.\n",
            "severity": "Low",
            "location": [
                "Auth.sol",
                "HookManager.sol",
                "ValidatorManager.sol",
                "OwnerManager.sol"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/auth/Auth.sol",
                "zksync-sso-clave-contracts/src/managers/ValidatorManager.sol",
                "zksync-sso-clave-contracts/src/SsoAccount.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Gas Optimization Opportunities",
            "description": "Multiple gas inefficiencies were identified: (1) `signature` parameters in `isValidSignature` and `validateSignature` use `memory` instead of cheaper `calldata`; (2) redundant `__gap` variables in `SsoStorage` could be consolidated; (3) session state is not deleted upon closure, wasting storage; (4) unnecessary zero checks on `rs[0]` and `rs[1]` in `webAuthVerify`. These stem from suboptimal coding practices and missed optimization opportunities. While individually minor, collectively they increase transaction costs. An attacker could exploit high gas usage to amplify denial-of-service effects. The impact includes higher operational costs and reduced scalability.\n",
            "severity": "Informational",
            "location": [
                "ERC1271Handler.sol#33",
                "WebAuthValidator.sol#76",
                "SsoStorage.sol#13-26",
                "SessionKeyValidator.sol#117",
                "SessionLib.sol#33",
                "WebAuthValidator.sol#101",
                "WebAuthValidator.sol#106"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/handlers/ERC1271Handler.sol",
                "zksync-sso-clave-contracts/src/libraries/SsoStorage.sol",
                "zksync-sso-clave-contracts/src/libraries/SessionLib.sol",
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Missing Named Parameters in Mappings",
            "description": "Solidity 0.8.18 introduced support for named parameters in mappings to improve code clarity. The audited codebase uses mappings without named parameters in several locations, such as `accountMappings` in `AAFactory.sol` and `sessionCounter`, `sessions` in `SessionKeyValidator.sol`. The absence of named parameters reduces code readability and makes it harder to understand the purpose of each key and value in the mapping. This is a maintainability issue caused by not adopting modern Solidity syntax. While it does not directly enable exploitation, it increases the risk of developer error during future modifications. The impact is reduced code clarity and potential for misinterpretation during audits or upgrades.\n",
            "severity": "Low",
            "location": [
                "AAFactory.sol::accountMappings#24",
                "SessionKeyValidator.sol::sessionCounter#27",
                "SessionKeyValidator.sol::sessions#29"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/AAFactory.sol",
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Documentation",
            "description": "Multiple instances of documentation inaccuracies were found in the codebase. The docstrings for `k1AddOwner` and `k1RemoveOwner` in `IOwnerManager.sol` incorrectly state that whitelisted modules can call these functions, which is not true. The documentation for `HookManager` and `OwnerManager` claims addresses are stored in linked lists, but they are actually stored in enumerable sets. Additionally, a comment in `AAFactory.sol` mentions initializing `hooks`, but only `moduleValidators` and `k1Owners` are set. These discrepancies stem from outdated or incorrect comments and create confusion for developers and auditors. Misleading documentation can lead to incorrect assumptions about access control or data structures, potentially resulting in integration errors or security flaws. The impact is reduced trust in documentation and increased risk of incorrect usage.\n",
            "severity": "Low",
            "location": [
                "IOwnerManager.sol::k1AddOwner#23",
                "IOwnerManager.sol::k1RemoveOwner#31",
                "HookManager.sol#19",
                "OwnerManager.sol#14",
                "AAFactory.sol#65"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/interfaces/IOwnerManager.sol",
                "zksync-sso-clave-contracts/src/managers/HookManager.sol",
                "zksync-sso-clave-contracts/src/managers/OwnerManager.sol",
                "zksync-sso-clave-contracts/src/AAFactory.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Inconsistent Use of Custom Errors",
            "description": "The codebase inconsistently uses `require` statements with string messages instead of custom errors, despite using Solidity >=0.8.4 where custom errors are available and more gas-efficient. Files such as `AAFactory.sol`, `SessionKeyValidator.sol`, `SessionLib.sol`, `TimestampAsserterLocator.sol`, and `WebAuthValidator.sol` rely on `require` messages. This inconsistency increases gas costs on revert and reduces clarity in error signaling. The root cause is a lack of standardized error handling practices across the codebase. While not directly exploitable, this leads to higher transaction costs and less informative error messages for users and frontends. The impact is suboptimal gas usage and reduced user experience during error conditions.\n",
            "severity": "Low",
            "location": [
                "AAFactory.sol",
                "SessionKeyValidator.sol",
                "SessionLib.sol",
                "TimestampAsserterLocator.sol",
                "WebAuthValidator.sol"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/AAFactory.sol",
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol",
                "zksync-sso-clave-contracts/src/libraries/SessionLib.sol",
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "TODO Comments in Production Code",
            "description": "The codebase contains unresolved TODO comments, such as in `SessionLib.sol` line 247 and `SsoAccount.sol` line 75, as well as open questions in the `CallSpec` struct. These indicate incomplete or uncertain implementation decisions that were not resolved before audit. The presence of such comments in production code risks important security or design considerations being overlooked. The root cause is inadequate tracking of development tasks. If critical issues are only noted in code comments and not managed in a formal backlog, they may be forgotten. The impact is potential technical debt and unaddressed security risks if TODOs reference unresolved vulnerabilities or design flaws.\n",
            "severity": "Low",
            "location": [
                "SessionLib.sol#247",
                "SsoAccount.sol#75",
                "SessionLib.sol::CallSpec"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/libraries/SessionLib.sol",
                "zksync-sso-clave-contracts/src/SsoAccount.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Modified Contracts Still Point to Clave as the Author",
            "description": "The `HookManager` contract and `IValidationHook`, `IExecutionHook` interfaces have been modified from the original Clave codebase but still attribute Clave as the author. This is misleading because it does not reflect the extent of changes made by Matter Labs. The root cause is failure to update authorship metadata after significant modifications. This can create confusion about code ownership, responsibility, and trust assumptions. The impact is reduced transparency and potential misattribution of security guarantees, especially if users assume Clave's security model still fully applies.\n",
            "severity": "Low",
            "location": [
                "HookManager.sol#22",
                "IHook.sol#12",
                "IHook.sol#23"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol",
                "zksync-sso-clave-contracts/src/interfaces/IHook.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Implicit Casting",
            "description": "In `WebAuthValidator.sol`, an implicit cast is used when comparing `bytes32` values `r` and `s` to `uint256(0)`. This reduces code clarity and can lead to confusion about type handling. The root cause is not following best practices for explicit type conversion. While Solidity allows this, explicit casting improves readability and reduces the risk of type-related bugs. The impact is reduced code maintainability and potential for subtle bugs if similar patterns are used in security-critical contexts.\n",
            "severity": "Low",
            "location": [
                "WebAuthValidator.sol#106"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Using the `rawVerify` Function Could Be Facilitated",
            "description": "The `rawVerify` function in `WebAuthValidator` expects a precomputed message, while `validateTransaction` expects individual signature components. This inconsistency complicates off-chain message creation, as users must replicate the internal `_createMessage` logic. The root cause is poor API design and lack of function symmetry. This increases the likelihood of user error when constructing signatures off-chain. The impact is reduced usability and potential for failed transactions due to incorrect message formatting, although it does not directly enable exploitation.\n",
            "severity": "Low",
            "location": [
                "WebAuthValidator.sol::rawVerify#180"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "`SessionKeyValidator`'s `validateTransaction` Function Disregards Signature Parameter",
            "description": "The `validateTransaction` function in `SessionKeyValidator` decodes the signature from `transaction.signature` instead of using the provided `signature` parameter, unlike the consistent behavior in `WebAuthValidator`. While this does not introduce a security vulnerability, it creates inconsistency in the codebase. The root cause is divergent implementation patterns across validators. This can confuse developers integrating or auditing the code. The impact is reduced code uniformity and potential for bugs if developers expect consistent parameter usage across validators.\n",
            "severity": "Low",
            "location": [
                "SessionKeyValidator.sol::validateTransaction#142"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Inconsistent Order Within Contracts",
            "description": "Several contracts (`SessionKeyValidator`, `SsoAccount`, `WebAuthValidator`) mix functions of different visibilities, while `SessionLib` interlaces `enums` and `structs`, and `WebAuthValidator` mixes storage variables with events. This violates the Solidity Style Guide's recommended layout order. The root cause is lack of code formatting standards. This reduces code readability and maintainability, making it harder to navigate and audit. The impact is increased cognitive load for developers and auditors, potentially leading to missed issues during review.\n",
            "severity": "Low",
            "location": [
                "SessionKeyValidator.sol",
                "SsoAccount.sol",
                "WebAuthValidator.sol",
                "SessionLib.sol"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol",
                "zksync-sso-clave-contracts/src/SsoAccount.sol",
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Inconsistency Between Specifications and Implementation",
            "description": "The `IModule` interface specifies that `onInstall` must revert if the module is already enabled, but `WebAuthValidator` and `SessionKeyValidator` allow multiple calls with different `data` inputs even after being enabled. This creates a discrepancy between documented behavior and actual implementation. The root cause is incomplete enforcement of interface requirements. This can mislead developers integrating modules, who may rely on the specified revert behavior for safety checks. The impact is potential logic errors in client applications or higher-level protocols that assume the specification is strictly followed.\n",
            "severity": "Low",
            "location": [
                "IModule.sol::onInstall#10",
                "WebAuthValidator.sol#35-39",
                "SessionKeyValidator.sol#52-56"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/interfaces/IModule.sol",
                "zksync-sso-clave-contracts/src/validators/WebAuthValidator.sol",
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Validation Not Failing Early",
            "description": "In `SessionKeyValidator`, during session creation, if `expiresAt` is less than 60 seconds, the transaction reverts inside `assertTimestampInRange`. However, this revert occurs late in the process. The recommendation is to revert earlier by explicitly checking `sessionSpec.expiresAt < 60`. The root cause is suboptimal error handling flow. While the final outcome is correct (revert), the lack of early validation wastes gas and provides less clear error context. The impact is inefficient gas usage and less informative error traces for users.\n",
            "severity": "Low",
            "location": [
                "SessionKeyValidator.sol#88-89"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/SessionKeyValidator.sol"
            ]
        }
    ],
    "affected_files": {
        "WebAuthValidator.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\nimport { VerifierCaller } from \"../helpers/VerifierCaller.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { Base64 } from \"solady/src/utils/Base64.sol\";\nimport { JSONParserLib } from \"solady/src/utils/JSONParserLib.sol\";\n\n/// @title WebAuthValidator\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract allows secure user authentication using WebAuthn public keys.\ncontract WebAuthValidator is VerifierCaller, IModuleValidator {\n  using JSONParserLib for JSONParserLib.Item;\n  using JSONParserLib for string;\n\n  address private constant P256_VERIFIER = address(0x100);\n  bytes1 private constant AUTH_DATA_MASK = 0x05;\n  bytes32 private constant LOW_S_MAX = 0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8;\n  bytes32 private constant HIGH_R_MAX = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551;\n\n  event PasskeyCreated(address indexed keyOwner, string originDomain);\n\n  // The layout is unusual due to EIP-7562 storage read restrictions for validation phase.\n  mapping(string originDomain => mapping(address accountAddress => bytes32)) public lowerKeyHalf;\n  mapping(string originDomain => mapping(address accountAddress => bytes32)) public upperKeyHalf;\n\n  /// @notice Runs on module install\n  /// @param data ABI-encoded WebAuthn passkey to add immediately, or empty if not needed\n  function onInstall(bytes calldata data) external override {\n    if (data.length > 0) {\n      require(addValidationKey(data), \"WebAuthValidator: key already exists\");\n    }\n  }\n\n  /// @notice Runs on module uninstall\n  /// @param data ABI-encoded array of origin domains to remove keys for\n  function onUninstall(bytes calldata data) external override {\n    string[] memory domains = abi.decode(data, (string[]));\n    for (uint256 i = 0; i < domains.length; i++) {\n      string memory domain = domains[i];\n      lowerKeyHalf[domain][msg.sender] = 0x0;\n      upperKeyHalf[domain][msg.sender] = 0x0;\n    }\n  }\n\n  /// @notice Adds a WebAuthn passkey for the caller\n  /// @param key ABI-encoded WebAuthn public key to add\n  /// @return true if the key was added, false if it was updated\n  function addValidationKey(bytes calldata key) public returns (bool) {\n    (bytes32[2] memory key32, string memory originDomain) = abi.decode(key, (bytes32[2], string));\n    bytes32 initialLowerHalf = lowerKeyHalf[originDomain][msg.sender];\n    bytes32 initialUpperHalf = upperKeyHalf[originDomain][msg.sender];\n\n    // we might want to support multiple passkeys per domain\n    lowerKeyHalf[originDomain][msg.sender] = key32[0];\n    upperKeyHalf[originDomain][msg.sender] = key32[1];\n\n    // we're returning true if this was a new key, false for update\n    bool keyExists = initialLowerHalf == 0 && initialUpperHalf == 0;\n\n    emit PasskeyCreated(msg.sender, originDomain);\n\n    return keyExists;\n  }\n\n  /// @notice Validates a WebAuthn signature\n  /// @param signedHash The hash of the signed message\n  /// @param signature The signature to validate\n  /// @return true if the signature is valid\n  function validateSignature(bytes32 signedHash, bytes memory signature) external view returns (bool) {\n    return webAuthVerify(signedHash, signature);\n  }\n\n  /// @notice Validates a transaction signed with a passkey\n  /// @dev Does not validate the transaction signature field, which is expected to be different due to the modular format\n  /// @param signedHash The hash of the signed transaction\n  /// @param signature The signature to validate\n  /// @return true if the signature is valid\n  function validateTransaction(\n    bytes32 signedHash,\n    bytes calldata signature,\n    Transaction calldata\n  ) external view returns (bool) {\n    return webAuthVerify(signedHash, signature);\n  }\n\n  /// @notice Validates a WebAuthn signature\n  /// @dev Performs r & s range validation to prevent signature malleability\n  /// @dev Checks passkey authenticator data flags (valid number of credentials)\n  /// @dev Requires that the transaction signature hash was the signed challenge\n  /// @dev Verifies that the signature was performed by a 'get' request\n  /// @param transactionHash The hash of the signed message\n  /// @param fatSignature The signature to validate (authenticator data, client data, [r, s])\n  /// @return true if the signature is valid\n  function webAuthVerify(bytes32 transactionHash, bytes memory fatSignature) internal view returns (bool) {\n    (bytes memory authenticatorData, string memory clientDataJSON, bytes32[2] memory rs) = _decodeFatSignature(\n      fatSignature\n    );\n\n    if (rs[0] <= 0 || rs[0] > HIGH_R_MAX || rs[1] <= 0 || rs[1] > LOW_S_MAX) {\n      return false;\n    }\n\n    // check if the flags are set\n    if (authenticatorData[32] & AUTH_DATA_MASK != AUTH_DATA_MASK) {\n      return false;\n    }\n\n    // parse out the important fields (type, challenge, origin, crossOrigin): https://goo.gl/yabPex\n    JSONParserLib.Item memory root = JSONParserLib.parse(clientDataJSON);\n    string memory challenge = root.at('\"challenge\"').value().decodeString();\n    bytes memory challengeData = Base64.decode(challenge);\n    if (challengeData.length != 32) {\n      return false; // wrong hash size\n    }\n    if (bytes32(challengeData) != transactionHash) {\n      return false;\n    }\n\n    string memory type_ = root.at('\"type\"').value().decodeString();\n    if (!Strings.equal(\"webauthn.get\", type_)) {\n      return false;\n    }\n\n    string memory origin = root.at('\"origin\"').value().decodeString();\n    bytes32[2] memory pubkey;\n    pubkey[0] = lowerKeyHalf[origin][msg.sender];\n    pubkey[1] = upperKeyHalf[origin][msg.sender];\n    // This really only validates the origin is set\n    if (pubkey[0] == 0 || pubkey[1] == 0) {\n      return false;\n    }\n\n    JSONParserLib.Item memory crossOriginItem = root.at('\"crossOrigin\"');\n    if (!crossOriginItem.isUndefined()) {\n      string memory crossOrigin = crossOriginItem.value();\n      if (!Strings.equal(\"false\", crossOrigin)) {\n        return false;\n      }\n    }\n\n    bytes32 message = _createMessage(authenticatorData, bytes(clientDataJSON));\n    return callVerifier(P256_VERIFIER, message, rs, pubkey);\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n    return\n      interfaceId == type(IERC165).interfaceId ||\n      interfaceId == type(IModuleValidator).interfaceId ||\n      interfaceId == type(IModule).interfaceId;\n  }\n\n  function _createMessage(\n    bytes memory authenticatorData,\n    bytes memory clientData\n  ) private pure returns (bytes32 message) {\n    bytes32 clientDataHash = sha256(clientData);\n    message = sha256(bytes.concat(authenticatorData, clientDataHash));\n  }\n\n  function _decodeFatSignature(\n    bytes memory fatSignature\n  ) private pure returns (bytes memory authenticatorData, string memory clientDataSuffix, bytes32[2] memory rs) {\n    (authenticatorData, clientDataSuffix, rs) = abi.decode(fatSignature, (bytes, string, bytes32[2]));\n  }\n\n  /// @notice Verifies a message using the P256 curve.\n  /// @dev Useful for testing the P256 precompile\n  /// @param message The sha256 hash of the authenticator hash and hashed client data\n  /// @param rs The signature to validate (r, s) from the signed message\n  /// @param pubKey The public key to validate the signature against (x, y)\n  /// @return valid true if the signature is valid\n  function rawVerify(\n    bytes32 message,\n    bytes32[2] calldata rs,\n    bytes32[2] calldata pubKey\n  ) external view returns (bool valid) {\n    valid = callVerifier(P256_VERIFIER, message, rs, pubKey);\n  }\n}\n",
        "ERC1271Handler.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { IERC1271Upgradeable } from \"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport { SignatureDecoder } from \"../libraries/SignatureDecoder.sol\";\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { OwnerManager } from \"../managers/OwnerManager.sol\";\nimport { ValidatorManager } from \"../managers/ValidatorManager.sol\";\n\n/// @title ERC1271Handler\n/// @author Matter Labs\n/// @notice Contract which provides ERC1271 signature validation\n/// @notice The implementation is inspired by Clave wallet.\nabstract contract ERC1271Handler is IERC1271Upgradeable, EIP712(\"Sso1271\", \"1.0.0\"), OwnerManager, ValidatorManager {\n  struct SsoMessage {\n    bytes32 signedHash;\n  }\n\n  bytes32 private constant _SSO_MESSAGE_TYPEHASH = keccak256(\"SsoMessage(bytes32 signedHash)\");\n\n  bytes4 private constant _ERC1271_MAGIC = 0x1626ba7e;\n\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data. Does not run validation hooks.\n   * @param hash bytes32 - Hash of the data that is signed\n   * @param signature bytes calldata - K1 owner signature OR validator address concatenated to signature\n   * @return magicValue bytes4 - Magic value if the signature is valid, 0 otherwise\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view override returns (bytes4 magicValue) {\n    if (signature.length == 65) {\n      (address signer, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n      return\n        signer == address(0) || error != ECDSA.RecoverError.NoError || !_k1IsOwner(signer) ? bytes4(0) : _ERC1271_MAGIC;\n    }\n\n    (bytes memory decodedSignature, address validator) = SignatureDecoder.decodeSignatureNoHookData(signature);\n\n    bytes32 eip712Hash = _hashTypedDataV4(_ssoMessageHash(SsoMessage(hash)));\n\n    bool isValid = _isModuleValidator(validator) &&\n      IModuleValidator(validator).validateSignature(eip712Hash, decodedSignature);\n\n    magicValue = isValid ? _ERC1271_MAGIC : bytes4(0);\n  }\n\n  /**\n   * @notice Returns the EIP-712 hash of the Sso message\n   * @param ssoMessage SsoMessage calldata - The message containing signedHash\n   * @return bytes32 - EIP712 hash of the message\n   */\n  function getEip712Hash(SsoMessage calldata ssoMessage) external view returns (bytes32) {\n    return _hashTypedDataV4(_ssoMessageHash(ssoMessage));\n  }\n\n  /**\n   * @notice Returns the typehash for the sso message struct\n   * @return bytes32 - Sso message typehash\n   */\n  function ssoMessageTypeHash() external pure returns (bytes32) {\n    return _SSO_MESSAGE_TYPEHASH;\n  }\n\n  function _ssoMessageHash(SsoMessage memory ssoMessage) private pure returns (bytes32) {\n    return keccak256(abi.encode(_SSO_MESSAGE_TYPEHASH, ssoMessage.signedHash));\n  }\n}\n",
        "IHook.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Validation hook interface for native AA\n/// @author getclave.io\n/// @notice Validation hooks trigger before each transaction,\n/// can be used to enforce additional restrictions on the account and/or transaction during the validation phase.\ninterface IValidationHook is IModule, IERC165 {\n  /// @notice Hook that triggers before each transaction during the validation phase.\n  /// @param signedHash Hash of the transaction that is being validated.\n  /// @param transaction Transaction that is being validated.\n  /// @dev If reverts, the transaction is rejected from the mempool and not included in the block.\n  function validationHook(bytes32 signedHash, Transaction calldata transaction) external;\n}\n\n/// @title Execution hook interface for native AA\n/// @author getclave.io\n/// @notice Execution hooks trigger before and after each transaction, during the execution phase.\ninterface IExecutionHook is IModule, IERC165 {\n  /// @notice Hook that triggers before each transaction during the execution phase.\n  /// @param transaction Transaction that is being executed.\n  function preExecutionHook(Transaction calldata transaction) external;\n\n  /// @notice Hook that triggers after each transaction during the execution phase.\n  function postExecutionHook() external;\n}\n",
        "HookManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { ExcessivelySafeCall } from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\nimport { Auth } from \"../auth/Auth.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { IExecutionHook, IValidationHook } from \"../interfaces/IHook.sol\";\nimport { IHookManager } from \"../interfaces/IHookManager.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\n\n/**\n * @title Manager contract for hooks\n * @notice Abstract contract for managing the enabled hooks of the account\n * @dev Hook addresses are stored in a linked list\n * @author https://getclave.io\n */\nabstract contract HookManager is IHookManager, Auth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  // Interface helper library\n  using ERC165Checker for address;\n  // Low level calls helper library\n  using ExcessivelySafeCall for address;\n\n  /// @inheritdoc IHookManager\n  function addHook(address hook, bool isValidation, bytes calldata initData) external override onlySelf {\n    _addHook(hook, isValidation, initData);\n  }\n\n  /// @inheritdoc IHookManager\n  function removeHook(address hook, bool isValidation, bytes calldata deinitData) external override onlySelf {\n    _removeHook(hook, isValidation);\n    IModule(hook).onUninstall(deinitData);\n  }\n\n  /// @inheritdoc IHookManager\n  function unlinkHook(address hook, bool isValidation, bytes calldata deinitData) external onlySelf {\n    _removeHook(hook, isValidation);\n    hook.excessivelySafeCall(gasleft(), 0, abi.encodeWithSelector(IModule.onUninstall.selector, deinitData));\n  }\n\n  /// @inheritdoc IHookManager\n  function isHook(address addr) external view override returns (bool) {\n    return _isHook(addr);\n  }\n\n  /// @inheritdoc IHookManager\n  function listHooks(bool isValidation) external view override returns (address[] memory hookList) {\n    if (isValidation) {\n      hookList = _validationHooks().values();\n    } else {\n      hookList = _executionHooks().values();\n    }\n  }\n\n  // Runs the validation hooks that are enabled by the account and returns true if none reverts\n  function runValidationHooks(bytes32 signedHash, Transaction calldata transaction) internal returns (bool) {\n    EnumerableSet.AddressSet storage hookList = _validationHooks();\n    uint256 totalHooks = hookList.length();\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      bool success = _call(hookList.at(i), abi.encodeCall(IValidationHook.validationHook, (signedHash, transaction)));\n\n      if (!success) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Runs the execution hooks that are enabled by the account before and after _executeTransaction\n  modifier runExecutionHooks(Transaction calldata transaction) {\n    EnumerableSet.AddressSet storage hookList = _executionHooks();\n    uint256 totalHooks = hookList.length();\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      IExecutionHook(hookList.at(i)).preExecutionHook(transaction);\n    }\n\n    _;\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      IExecutionHook(hookList.at(i)).postExecutionHook();\n    }\n  }\n\n  function _addHook(address hook, bool isValidation, bytes calldata initData) internal {\n    if (!_supportsHook(hook, isValidation)) {\n      revert Errors.HOOK_ERC165_FAIL(hook, isValidation);\n    }\n\n    if (isValidation) {\n      _validationHooks().add(hook);\n    } else {\n      _executionHooks().add(hook);\n    }\n\n    IModule(hook).onInstall(initData);\n\n    emit HookAdded(hook);\n  }\n\n  function _removeHook(address hook, bool isValidation) internal {\n    if (isValidation) {\n      _validationHooks().remove(hook);\n    } else {\n      _executionHooks().remove(hook);\n    }\n\n    emit HookRemoved(hook);\n  }\n\n  function _isHook(address addr) internal view override returns (bool) {\n    return _validationHooks().contains(addr) || _executionHooks().contains(addr);\n  }\n\n  function _call(address target, bytes memory data) private returns (bool success) {\n    assembly (\"memory-safe\") {\n      success := call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  function _validationHooks() private view returns (EnumerableSet.AddressSet storage validationHooks) {\n    validationHooks = SsoStorage.layout().validationHooks;\n  }\n\n  function _executionHooks() private view returns (EnumerableSet.AddressSet storage executionHooks) {\n    executionHooks = SsoStorage.layout().executionHooks;\n  }\n\n  function _supportsHook(address hook, bool isValidation) private view returns (bool) {\n    return\n      hook.supportsInterface(type(IModule).interfaceId) &&\n      (\n        isValidation\n          ? hook.supportsInterface(type(IValidationHook).interfaceId)\n          : hook.supportsInterface(type(IExecutionHook).interfaceId)\n      );\n  }\n}\n",
        "SsoAccount.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { ACCOUNT_VALIDATION_SUCCESS_MAGIC } from \"@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IAccount.sol\";\nimport { Transaction, TransactionHelper } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { EfficientCall } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/EfficientCall.sol\";\nimport { NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder } from \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\nimport { SystemContractsCaller } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/SystemContractsCaller.sol\";\nimport { Utils } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/Utils.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { HookManager } from \"./managers/HookManager.sol\";\n\nimport { TokenCallbackHandler, IERC165 } from \"./helpers/TokenCallbackHandler.sol\";\n\nimport { Errors } from \"./libraries/Errors.sol\";\nimport { SignatureDecoder } from \"./libraries/SignatureDecoder.sol\";\n\nimport { ERC1271Handler } from \"./handlers/ERC1271Handler.sol\";\nimport { BatchCaller } from \"./batch/BatchCaller.sol\";\n\nimport { ISsoAccount } from \"./interfaces/ISsoAccount.sol\";\nimport { IModuleValidator } from \"./interfaces/IModuleValidator.sol\";\n\n/// @title SSO Account\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The implementation is inspired by Clave wallet.\n/// @notice This contract is a modular and extensible account implementation with support of\n/// multi-ownership, custom modules, validation/execution hooks and different signature validation formats.\n/// @dev Contract is expected to be used as Beacon proxy implementation.\ncontract SsoAccount is Initializable, HookManager, ERC1271Handler, TokenCallbackHandler, BatchCaller, ISsoAccount {\n  // Helper library for the Transaction struct\n  using TransactionHelper for Transaction;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializer function that sets account initial configuration. Expected to be used in the proxy.\n  /// @dev Sets passkey and passkey validator within account storage\n  /// @param initialValidators An array of module validator addresses and initial validation keys\n  /// in an ABI encoded format of `abi.encode(validatorAddr,validationKey))`.\n  /// @param initialK1Owners An array of addresses with full control over the account.\n  function initialize(bytes[] calldata initialValidators, address[] calldata initialK1Owners) external initializer {\n    address validatorAddr;\n    bytes memory initData;\n    for (uint256 i = 0; i < initialValidators.length; ++i) {\n      (validatorAddr, initData) = abi.decode(initialValidators[i], (address, bytes));\n      _addModuleValidator(validatorAddr, initData);\n    }\n    for (uint256 i = 0; i < initialK1Owners.length; ++i) {\n      _k1AddOwner(initialK1Owners[i]);\n    }\n  }\n\n  /// @dev Account might receive/hold base tokens.\n  receive() external payable {}\n\n  /// @notice Called by the bootloader to validate that an account agrees to process the transaction\n  /// (and potentially pay for it).\n  /// @dev The developer should strive to preserve as many steps as possible both for valid\n  /// and invalid transactions as this very method is also used during the gas fee estimation\n  /// (without some of the necessary data, e.g. signature).\n  /// @param _suggestedSignedHash The suggested hash of the transaction that is signed by the signer.\n  /// @param _transaction The transaction data.\n  /// @return magic The magic value that should be equal to the signature of this function.\n  /// if the user agrees to proceed with the transaction.\n  function validateTransaction(\n    bytes32,\n    bytes32 _suggestedSignedHash,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader returns (bytes4 magic) {\n    // TODO: session txs have their own nonce managers, so they have to not alter this nonce\n    _incrementNonce(_transaction.nonce);\n\n    // If there is not enough balance for the transaction, the account should reject it\n    // on the validation step to prevent paying fees for revertable transactions.\n    if (_transaction.totalRequiredBalance() > address(this).balance) {\n      revert Errors.INSUFFICIENT_FUNDS(_transaction.totalRequiredBalance(), address(this).balance);\n    }\n\n    // While the suggested signed hash is usually provided, it is generally\n    // not recommended to rely on it to be present, since in the future\n    // there may be tx types with no suggested signed hash.\n    bytes32 signedHash = _suggestedSignedHash == bytes32(0) ? _transaction.encodeHash() : _suggestedSignedHash;\n\n    magic = _validateTransaction(signedHash, _transaction);\n  }\n\n  /// @notice Called by the bootloader to make the account execute the transaction.\n  /// @dev The transaction is considered successful if this function does not revert\n  /// @param _transaction The transaction data.\n  function executeTransaction(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader runExecutionHooks(_transaction) {\n    address to = _safeCastToAddress(_transaction.to);\n    uint128 value = Utils.safeCastToU128(_transaction.value);\n\n    _executeCall(to, value, _transaction.data);\n  }\n\n  /// @notice Executes a call to a given address with a specified value and calldata.\n  /// @param _to The address to which the call is made.\n  /// @param _value The value to send along with the call.\n  /// @param _data The calldata to pass along with the call.\n  function _executeCall(address _to, uint128 _value, bytes calldata _data) internal {\n    uint32 gas = Utils.safeCastToU32(gasleft());\n    bool success;\n\n    if (_to == address(DEPLOYER_SYSTEM_CONTRACT)) {\n      bytes4 selector = bytes4(_data[:4]);\n      // Check that called function is the deployment method,\n      // the other deployer methods are not supposed to be called from the account.\n      // NOTE: DefaultAccount has the same behavior.\n      bool isSystemCall = selector == DEPLOYER_SYSTEM_CONTRACT.create.selector ||\n        selector == DEPLOYER_SYSTEM_CONTRACT.create2.selector ||\n        selector == DEPLOYER_SYSTEM_CONTRACT.createAccount.selector ||\n        selector == DEPLOYER_SYSTEM_CONTRACT.create2Account.selector;\n      // Note, that the deployer contract can only be called with a \"isSystemCall\" flag.\n      success = EfficientCall.rawCall({\n        _gas: gas,\n        _address: _to,\n        _value: _value,\n        _data: _data,\n        _isSystem: isSystemCall\n      });\n    } else {\n      success = EfficientCall.rawCall(gas, _to, _value, _data, false);\n    }\n\n    if (!success) {\n      EfficientCall.propagateRevert();\n    }\n  }\n\n  /// @notice This function allows an EOA to start a transaction for the account. The main purpose of which is\n  /// to have and entry point for escaping funds when L2 transactions are censored by the chain, and only\n  /// forced transactions are accepted by the network.\n  /// @dev It is not implemented yet.\n  function executeTransactionFromOutside(Transaction calldata) external payable override {\n    revert Errors.METHOD_NOT_IMPLEMENTED();\n  }\n\n  /// @notice This function allows the account to pay for its own gas and used when there is no paymaster.\n  /// @param _transaction The transaction data.\n  /// @dev This method must send at least `tx.gasprice * tx.gasLimit` ETH to the bootloader address.\n  function payForTransaction(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader {\n    bool success = _transaction.payToTheBootloader();\n\n    if (!success) {\n      revert Errors.FEE_PAYMENT_FAILED();\n    }\n  }\n  /// @notice This function is called by the system if the transaction has a paymaster\n  /// and prepares the interaction with the paymaster.\n  /// @param _transaction The transaction data.\n  function prepareForPaymaster(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n  ) external payable override onlyBootloader {\n    _transaction.processPaymasterInput();\n  }\n\n  /// @dev type(ISsoAccount).interfaceId indicates SSO accounts\n  function supportsInterface(bytes4 interfaceId) public view override(IERC165, TokenCallbackHandler) returns (bool) {\n    return interfaceId == type(ISsoAccount).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /// @notice Validates the provided transaction by validating signature of ECDSA k1 owner.\n  /// or running validation hooks and signature validation in the provided validator address.\n  /// @param _signedHash The signed hash of the transaction.\n  /// @param _transaction The transaction data.\n  /// @return The magic value if the validation was successful and bytes4(0) otherwise.\n  function _validateTransaction(bytes32 _signedHash, Transaction calldata _transaction) internal returns (bytes4) {\n    // Run validation hooks\n    bool hookSuccess = runValidationHooks(_signedHash, _transaction);\n    if (!hookSuccess) {\n      return bytes4(0);\n    }\n\n    if (_transaction.signature.length == 65) {\n      (address signer, ECDSA.RecoverError error) = ECDSA.tryRecover(_signedHash, _transaction.signature);\n      return\n        signer == address(0) || error != ECDSA.RecoverError.NoError || !_k1IsOwner(signer)\n          ? bytes4(0)\n          : ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n    }\n\n    // Extract the signature, validator address and hook data from the _transaction.signature\n    (bytes memory signature, address validator, ) = SignatureDecoder.decodeSignature(_transaction.signature);\n\n    bool validationSuccess = _isModuleValidator(validator) &&\n      IModuleValidator(validator).validateTransaction(_signedHash, signature, _transaction);\n    if (!validationSuccess) {\n      return bytes4(0);\n    }\n\n    return ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n  }\n\n  /// @dev Increments the nonce value in Nonce Holder system contract to ensure replay attack protection.\n  /// @dev Reverts if the Nonce Holder stores different `_nonce` value from the expected one.\n  /// @param _expectedNonce The nonce value expected for the account to be stored in the Nonce Holder.\n  function _incrementNonce(uint256 _expectedNonce) internal {\n    SystemContractsCaller.systemCallWithPropagatedRevert(\n      uint32(gasleft()),\n      address(NONCE_HOLDER_SYSTEM_CONTRACT),\n      0,\n      abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_expectedNonce))\n    );\n  }\n\n  /// @dev Safely casts a uint256 to an address.\n  /// @dev Revert if the value exceeds the maximum size for an address (160 bits).\n  function _safeCastToAddress(uint256 _value) internal pure returns (address) {\n    require(_value <= type(uint160).max, \"Overflow\");\n    return address(uint160(_value));\n  }\n}\n",
        "SsoStorage.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary SsoStorage {\n  bytes32 private constant SSO_STORAGE_SLOT = 0x3248da1aeae8bd923cbf26901dc4bfc6bb48bb0fbc5b6102f1151fe7012884f4;\n\n  struct Layout {\n    // \n    //    Ownership Data  \n    EnumerableSet.AddressSet k1Owners;\n    uint256[50] __gap_0;\n    // \n\n    // \n    //      Validation    \n    EnumerableSet.AddressSet moduleValidators;\n    uint256[50] __gap_2;\n    // \n\n    // \n    //        Hooks       \n    EnumerableSet.AddressSet validationHooks;\n    EnumerableSet.AddressSet executionHooks;\n    uint256[50] __gap_4;\n    // \n  }\n\n  function layout() internal pure returns (Layout storage l) {\n    bytes32 slot = SSO_STORAGE_SLOT;\n    assembly {\n      l.slot := slot\n    }\n  }\n}\n",
        "AAFactory.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { DEPLOYER_SYSTEM_CONTRACT, IContractDeployer } from \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\nimport { SystemContractsCaller } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/SystemContractsCaller.sol\";\n\nimport { ISsoAccount } from \"./interfaces/ISsoAccount.sol\";\n\n/// @title AAFactory\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract is used to deploy SSO accounts as beacon proxies.\ncontract AAFactory {\n  /// @notice Emitted when a new account is successfully created.\n  /// @param accountAddress The address of the newly created account.\n  /// @param uniqueAccountId A unique identifier for the account.\n  event AccountCreated(address indexed accountAddress, string uniqueAccountId);\n\n  /// @dev The bytecode hash of the beacon proxy, used for deploying proxy accounts.\n  bytes32 public immutable beaconProxyBytecodeHash;\n  address public immutable beacon;\n\n  /// @notice A mapping from unique account IDs to their corresponding deployed account addresses.\n  mapping(string => address) public accountMappings;\n\n  /// @notice Constructor that initializes the factory with a beacon proxy bytecode hash and implementation contract address.\n  /// @param _beaconProxyBytecodeHash The bytecode hash of the beacon proxy.\n  /// @param _beacon The address of the UpgradeableBeacon contract used for the SSO accounts' beacon proxies.\n  constructor(bytes32 _beaconProxyBytecodeHash, address _beacon) {\n    beaconProxyBytecodeHash = _beaconProxyBytecodeHash;\n    beacon = _beacon;\n  }\n\n  function getEncodedBeacon() external view returns (bytes memory) {\n    return abi.encode(beacon);\n  }\n\n  /// @notice Deploys a new SSO account as a beacon proxy with the specified parameters.\n  /// @dev Uses `create2` to deploy a proxy account, allowing for deterministic addresses based on the provided salt.\n  /// @param _salt The salt used for the `create2` deployment to make the address deterministic.\n  /// @param _uniqueAccountId A unique identifier for the new account.\n  /// @param _initialValidators An array of initial validators for the new account.\n  /// @param _initialK1Owners An array of initial owners of the K1 key for the new account.\n  /// @return accountAddress The address of the newly deployed SSO account.\n  function deployProxySsoAccount(\n    bytes32 _salt,\n    string calldata _uniqueAccountId,\n    bytes[] calldata _initialValidators,\n    address[] calldata _initialK1Owners\n  ) external returns (address accountAddress) {\n    require(accountMappings[_uniqueAccountId] == address(0), \"Account already exists\");\n\n    (bool success, bytes memory returnData) = SystemContractsCaller.systemCallWithReturndata(\n      uint32(gasleft()),\n      address(DEPLOYER_SYSTEM_CONTRACT),\n      uint128(0),\n      abi.encodeCall(\n        DEPLOYER_SYSTEM_CONTRACT.create2Account,\n        (_salt, beaconProxyBytecodeHash, abi.encode(beacon), IContractDeployer.AccountAbstractionVersion.Version1)\n      )\n    );\n    require(success, \"Deployment failed\");\n    (accountAddress) = abi.decode(returnData, (address));\n\n    // Initialize the newly deployed account with validators, hooks and K1 owners.\n    ISsoAccount(accountAddress).initialize(_initialValidators, _initialK1Owners);\n\n    accountMappings[_uniqueAccountId] = accountAddress;\n\n    emit AccountCreated(accountAddress, _uniqueAccountId);\n  }\n}\n",
        "IModule.sol": "/**\n * @title Module interface\n * @dev Interface for a module that can be added to SSO account (e.g. hook or validator).\n */\ninterface IModule {\n  /**\n   * @dev This function is called by the smart account during installation of the module\n   * @param data arbitrary data that may be required on the module during `onInstall` initialization\n   *\n   * MUST revert on error (e.g. if module is already enabled)\n   */\n  function onInstall(bytes calldata data) external;\n\n  /**\n   * @dev This function is called by the smart account during uninstallation of the module\n   * @param data arbitrary data that may be required on the module during `onUninstall` de-initialization\n   *\n   * MUST revert on error\n   */\n  function onUninstall(bytes calldata data) external;\n}\n",
        "SessionLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { IPaymasterFlow } from \"@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IPaymasterFlow.sol\";\nimport { TimestampAsserterLocator } from \"../helpers/TimestampAsserterLocator.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { LibBytes } from \"solady/src/utils/LibBytes.sol\";\n\n/// @title Session Library\n/// @author Matter Labs\n/// @notice Library for session management, used by SessionKeyValidator\n/// @custom:security-contact security@matterlabs.dev\nlibrary SessionLib {\n  using SessionLib for SessionLib.Constraint;\n  using SessionLib for SessionLib.UsageLimit;\n  using LibBytes for bytes;\n\n  /// @notice We do not permit opening multiple identical sessions (even after one is closed, e.g.).\n  /// For each session key, its session status can only be changed\n  /// from NotInitialized to Active, and from Active to Closed.\n  enum Status {\n    NotInitialized,\n    Active,\n    Closed\n  }\n\n  /// @notice This struct is used to track usage information for each session.\n  /// Along with `status`, this is considered the session state.\n  /// While everything else is considered the session spec, and is stored offchain.\n  /// @dev Storage layout of this struct is unusual to conform to ERC-7562 storage access restrictions during validation.\n  /// Each innermost mapping is always mapping(address account => ...).\n  struct SessionStorage {\n    mapping(address => Status) status;\n    UsageTracker fee;\n    // (target) => transfer value tracker\n    mapping(address => UsageTracker) transferValue;\n    // (target, selector) => call value tracker\n    mapping(address => mapping(bytes4 => UsageTracker)) callValue;\n    // (target, selector, index) => call parameter tracker\n    // index is the constraint index in callPolicy, not the parameter index\n    mapping(address => mapping(bytes4 => mapping(uint256 => UsageTracker))) params;\n  }\n\n  struct Constraint {\n    Condition condition;\n    uint64 index;\n    bytes32 refValue;\n    UsageLimit limit;\n  }\n\n  struct UsageTracker {\n    // Used for LimitType.Lifetime\n    mapping(address => uint256) lifetimeUsage;\n    // Used for LimitType.Allowance\n    // period => used that period\n    mapping(uint64 => mapping(address => uint256)) allowanceUsage;\n  }\n\n  struct UsageLimit {\n    LimitType limitType;\n    uint256 limit; // ignored if limitType == Unlimited\n    uint256 period; // ignored if limitType != Allowance\n  }\n\n  enum LimitType {\n    Unlimited,\n    Lifetime,\n    Allowance\n  }\n\n  enum Condition {\n    Unconstrained,\n    Equal,\n    Greater,\n    Less,\n    GreaterOrEqual,\n    LessOrEqual,\n    NotEqual\n  }\n\n  /// @notice This struct is provided by the account to create a session.\n  /// It is used to define the session's policies, limits and constraints.\n  /// Only its hash is stored onchain, and the full struct is provided with\n  /// each transaction in calldata via `validatorData`, encoded in the signature.\n  struct SessionSpec {\n    address signer;\n    uint256 expiresAt;\n    UsageLimit feeLimit;\n    CallSpec[] callPolicies;\n    TransferSpec[] transferPolicies;\n  }\n\n  struct CallSpec {\n    address target;\n    bytes4 selector;\n    uint256 maxValuePerUse;\n    UsageLimit valueLimit;\n    Constraint[] constraints;\n    // add max data length restriction?\n    // add max number of calls restriction?\n  }\n\n  struct TransferSpec {\n    address target;\n    uint256 maxValuePerUse;\n    UsageLimit valueLimit;\n  }\n\n  struct LimitState {\n    // this might also be limited by a constraint or `maxValuePerUse`,\n    // which is not reflected here\n    uint256 remaining;\n    address target;\n    // ignored for transfer value\n    bytes4 selector;\n    // ignored for transfer and call value\n    uint256 index;\n  }\n\n  // Info about remaining session limits and its status\n  struct SessionState {\n    Status status;\n    uint256 feesRemaining;\n    LimitState[] transferValue;\n    LimitState[] callValue;\n    LimitState[] callParams;\n  }\n\n  /// @notice Checks if the limit is exceeded and updates the usage tracker.\n  /// @param limit The limit to check.\n  /// @param tracker The usage tracker to update.\n  /// @param value The tracked value to check the limit against.\n  /// @param period The period ID to check the limit against. Ignored if the limit is not of type Allowance.\n  /// @dev Reverts if the limit is exceeded or the period is invalid.\n  function checkAndUpdate(\n    UsageLimit memory limit,\n    UsageTracker storage tracker,\n    uint256 value,\n    uint64 period\n  ) internal {\n    if (limit.limitType == LimitType.Lifetime) {\n      require(tracker.lifetimeUsage[msg.sender] + value <= limit.limit, \"Lifetime limit exceeded\");\n      tracker.lifetimeUsage[msg.sender] += value;\n    } else if (limit.limitType == LimitType.Allowance) {\n      TimestampAsserterLocator.locate().assertTimestampInRange(period * limit.period, (period + 1) * limit.period - 1);\n      require(tracker.allowanceUsage[period][msg.sender] + value <= limit.limit, \"Allowance limit exceeded\");\n      tracker.allowanceUsage[period][msg.sender] += value;\n    }\n  }\n\n  /// @notice Checks if the constraint is met and update the usage tracker.\n  /// @param constraint The constraint to check.\n  /// @param tracker The usage tracker to update.\n  /// @param data The transaction data to check the constraint against.\n  /// @param period The period ID to check the allowances against.\n  /// @dev Reverts if the constraint is not met.\n  /// @dev Forwards the call to `checkAndUpdate(limit, ...)` on the limit of the constraint.\n  function checkAndUpdate(\n    Constraint memory constraint,\n    UsageTracker storage tracker,\n    bytes memory data,\n    uint64 period\n  ) internal {\n    require(data.length >= 4 + constraint.index * 32 + 32, \"Invalid data length\");\n    bytes32 param = data.load(4 + constraint.index * 32);\n    Condition condition = constraint.condition;\n    bytes32 refValue = constraint.refValue;\n\n    if (condition == Condition.Equal) {\n      require(param == refValue, \"EQUAL constraint not met\");\n    } else if (condition == Condition.Greater) {\n      require(param > refValue, \"GREATER constraint not met\");\n    } else if (condition == Condition.Less) {\n      require(param < refValue, \"LESS constraint not met\");\n    } else if (condition == Condition.GreaterOrEqual) {\n      require(param >= refValue, \"GREATER_OR_EQUAL constraint not met\");\n    } else if (condition == Condition.LessOrEqual) {\n      require(param <= refValue, \"LESS_OR_EQUAL constraint not met\");\n    } else if (condition == Condition.NotEqual) {\n      require(param != refValue, \"NOT_EQUAL constraint not met\");\n    }\n\n    constraint.limit.checkAndUpdate(tracker, uint256(param), period);\n  }\n\n  /// @notice Finds the call policy, checks if it is violated and updates the usage trackers.\n  /// @param state The session storage to update.\n  /// @param data The transaction data to check the call policy against.\n  /// @param target The target address of the call.\n  /// @param selector The 4-byte selector of the call.\n  /// @param callPolicies The call policies to search through.\n  /// @param periodIds The period IDs to check the allowances against. The length has to be at least `periodIdsOffset + callPolicies.length`.\n  /// @param periodIdsOffset The offset in the `periodIds` array to start checking the constraints.\n  /// @return The call policy that was found, reverts if not found or if the call is not allowed.\n  function checkCallPolicy(\n    SessionStorage storage state,\n    bytes memory data,\n    address target,\n    bytes4 selector,\n    CallSpec[] memory callPolicies,\n    uint64[] memory periodIds,\n    uint256 periodIdsOffset\n  ) internal returns (CallSpec memory) {\n    CallSpec memory callPolicy;\n    bool found = false;\n\n    for (uint256 i = 0; i < callPolicies.length; i++) {\n      if (callPolicies[i].target == target && callPolicies[i].selector == selector) {\n        callPolicy = callPolicies[i];\n        found = true;\n        break;\n      }\n    }\n\n    require(found, \"Call to this contract is not allowed\");\n\n    for (uint256 i = 0; i < callPolicy.constraints.length; i++) {\n      callPolicy.constraints[i].checkAndUpdate(state.params[target][selector][i], data, periodIds[periodIdsOffset + i]);\n    }\n\n    return callPolicy;\n  }\n\n  /// @notice Validates the fee limit of the session and updates the tracker.\n  /// Only performs the checks if the transaction is not using a paymaster.\n  /// @param state The session storage to update.\n  /// @param transaction The transaction to check the fee of.\n  /// @param spec The session spec to check the fee limit against.\n  /// @param periodId The period ID to check the fee limit against. Ignored if the limit is not of type Allowance.\n  /// @dev Reverts if the fee limit is exceeded.\n  /// @dev This is split from `validate` to prevent gas estimation failures.\n  /// When this check was part of `validate`, gas estimation could fail due to\n  /// fee limit being smaller than the upper bound of the gas estimation binary search.\n  /// By splitting this check, we can now have this order of operations in `validateTransaction`:\n  /// 1. session.validate()\n  /// 2. ECDSA.tryRecover()\n  /// 3. session.validateFeeLimit()\n  /// This way, gas estimation will exit on step 2 instead of failing, but will still run through\n  /// most of the computation needed to validate the session.\n  function validateFeeLimit(\n    SessionStorage storage state,\n    Transaction calldata transaction,\n    SessionSpec memory spec,\n    uint64 periodId\n  ) internal {\n    // TODO: update fee allowance with the gasleft/refund at the end of execution\n    // If a paymaster is paying the fee, we don't need to check the fee limit\n    if (transaction.paymaster == 0) {\n      uint256 fee = transaction.maxFeePerGas * transaction.gasLimit;\n      spec.feeLimit.checkAndUpdate(state.fee, fee, periodId);\n    }\n  }\n\n  /// @notice Validates the transaction against the session spec and updates the usage trackers.\n  /// @param state The session storage to update.\n  /// @param transaction The transaction to validate.\n  /// @param spec The session spec to validate against.\n  /// @param periodIds The period IDs to check the allowances against.\n  /// @dev periodId is defined as block.timestamp / limit.period if limitType == Allowance, and 0 otherwise (which will be ignored).\n  /// periodIds[0] is for fee limit (not used in this function),\n  /// periodIds[1] is for value limit,\n  /// peroidIds[2:2+n] are for `ERC20.approve()` constraints, where `n` is the number of constraints in the `ERC20.approve()` policy\n  ///   if an approval-based paymaster is used, 0 otherwise.\n  /// periodIds[2+n:] are for call constraints, if there are any.\n  /// It is required to pass them in (instead of computing via block.timestamp) since during validation\n  /// we can only assert the range of the timestamp, but not access its value.\n  function validate(\n    SessionStorage storage state,\n    Transaction calldata transaction,\n    SessionSpec memory spec,\n    uint64[] memory periodIds\n  ) internal {\n    require(state.status[msg.sender] == Status.Active, \"Session is not active\");\n    TimestampAsserterLocator.locate().assertTimestampInRange(0, spec.expiresAt);\n\n    require(transaction.to <= type(uint160).max, \"Overflow\");\n    address target = address(uint160(transaction.to));\n\n    // Validate paymaster input\n    uint256 periodIdsOffset = 2;\n    if (transaction.paymasterInput.length >= 4) {\n      bytes4 paymasterInputSelector = bytes4(transaction.paymasterInput[:4]);\n      // SsoAccount will automatically `approve()` a token for an approval-based paymaster in `prepareForPaymaster()` call.\n      // We need to make sure that the session spec allows this.\n      if (paymasterInputSelector == IPaymasterFlow.approvalBased.selector) {\n        require(transaction.paymasterInput.length >= 68, \"Invalid paymaster input length\");\n        (address token, uint256 amount, ) = abi.decode(transaction.paymasterInput[4:], (address, uint256, bytes));\n        bytes memory data = abi.encodeWithSelector(IERC20.approve.selector, transaction.paymaster, amount);\n\n        // check that session allows .approve() for this token\n        CallSpec memory approvePolicy = checkCallPolicy(\n          state,\n          data,\n          token,\n          IERC20.approve.selector,\n          spec.callPolicies,\n          periodIds,\n          periodIdsOffset\n        );\n        periodIdsOffset += approvePolicy.constraints.length;\n      }\n    }\n\n    if (transaction.data.length >= 4) {\n      bytes4 selector = bytes4(transaction.data[:4]);\n      CallSpec memory callPolicy = checkCallPolicy(\n        state,\n        transaction.data,\n        target,\n        selector,\n        spec.callPolicies,\n        periodIds,\n        periodIdsOffset\n      );\n      require(transaction.value <= callPolicy.maxValuePerUse, \"Value exceeds limit\");\n      callPolicy.valueLimit.checkAndUpdate(state.callValue[target][selector], transaction.value, periodIds[1]);\n    } else {\n      TransferSpec memory transferPolicy;\n      bool found = false;\n\n      for (uint256 i = 0; i < spec.transferPolicies.length; i++) {\n        if (spec.transferPolicies[i].target == target) {\n          transferPolicy = spec.transferPolicies[i];\n          found = true;\n          break;\n        }\n      }\n\n      require(found, \"Transfer to this address is not allowed\");\n      require(transaction.value <= transferPolicy.maxValuePerUse, \"Value exceeds limit\");\n      transferPolicy.valueLimit.checkAndUpdate(state.transferValue[target], transaction.value, periodIds[1]);\n    }\n  }\n\n  /// @notice Getter for the remainder of a usage limit.\n  /// @param limit The limit to check.\n  /// @param tracker The corresponding usage tracker to get the usage from.\n  /// @param account The account to get the usage for.\n  /// @return The remaining limit. If unlimited, returns `type(uint256).max`.\n  function remainingLimit(\n    UsageLimit memory limit,\n    UsageTracker storage tracker,\n    address account\n  ) internal view returns (uint256) {\n    if (limit.limitType == LimitType.Unlimited) {\n      // this might be still limited by `maxValuePerUse` or a constraint\n      return type(uint256).max;\n    }\n    if (limit.limitType == LimitType.Lifetime) {\n      return limit.limit - tracker.lifetimeUsage[account];\n    }\n    if (limit.limitType == LimitType.Allowance) {\n      // this is not used during validation, so it's fine to use block.timestamp\n      uint64 period = uint64(block.timestamp / limit.period);\n      return limit.limit - tracker.allowanceUsage[period][account];\n    }\n  }\n\n  /// @notice Getter for the session state.\n  /// @param session The session storage to get the state from.\n  /// @param account The account to get the state for.\n  /// @param spec The session spec to get the state for.\n  /// @return The session state: status, remaining fee limit, transfer limits, call value and call parameter limits.\n  function getState(\n    SessionStorage storage session,\n    address account,\n    SessionSpec calldata spec\n  ) internal view returns (SessionState memory) {\n    uint256 totalConstraints = 0;\n    for (uint256 i = 0; i < spec.callPolicies.length; i++) {\n      totalConstraints += spec.callPolicies[i].constraints.length;\n    }\n\n    LimitState[] memory transferValue = new LimitState[](spec.transferPolicies.length);\n    LimitState[] memory callValue = new LimitState[](spec.callPolicies.length);\n    LimitState[] memory callParams = new LimitState[](totalConstraints); // there will be empty ones at the end\n    uint256 paramLimitIndex = 0;\n\n    for (uint256 i = 0; i < transferValue.length; i++) {\n      TransferSpec memory transferSpec = spec.transferPolicies[i];\n      transferValue[i] = LimitState({\n        remaining: remainingLimit(transferSpec.valueLimit, session.transferValue[transferSpec.target], account),\n        target: transferSpec.target,\n        selector: bytes4(0),\n        index: 0\n      });\n    }\n\n    for (uint256 i = 0; i < callValue.length; i++) {\n      CallSpec memory callSpec = spec.callPolicies[i];\n      callValue[i] = LimitState({\n        remaining: remainingLimit(callSpec.valueLimit, session.callValue[callSpec.target][callSpec.selector], account),\n        target: callSpec.target,\n        selector: callSpec.selector,\n        index: 0\n      });\n\n      for (uint256 j = 0; j < callSpec.constraints.length; j++) {\n        if (callSpec.constraints[j].limit.limitType != LimitType.Unlimited) {\n          callParams[paramLimitIndex++] = LimitState({\n            remaining: remainingLimit(\n              callSpec.constraints[j].limit,\n              session.params[callSpec.target][callSpec.selector][j],\n              account\n            ),\n            target: callSpec.target,\n            selector: callSpec.selector,\n            index: callSpec.constraints[j].index\n          });\n        }\n      }\n    }\n\n    // shrink array to actual size\n    assembly {\n      mstore(callParams, paramLimitIndex)\n    }\n\n    return\n      SessionState({\n        status: session.status[account],\n        feesRemaining: remainingLimit(spec.feeLimit, session.fee, account),\n        transferValue: transferValue,\n        callValue: callValue,\n        callParams: callParams\n      });\n  }\n}\n",
        "ValidatorManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { ExcessivelySafeCall } from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\nimport { Auth } from \"../auth/Auth.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { IValidatorManager } from \"../interfaces/IValidatorManager.sol\";\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\n\n/**\n * @title Manager contract for validators\n * @notice Abstract contract for managing the validators of the account\n * @dev Validators are stored in an enumerable set\n * @author https://getclave.io\n */\nabstract contract ValidatorManager is IValidatorManager, Auth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  // Interface helper library\n  using ERC165Checker for address;\n  // Low level calls helper library\n  using ExcessivelySafeCall for address;\n\n  ///@inheritdoc IValidatorManager\n  function addModuleValidator(address validator, bytes calldata initData) external onlySelf {\n    _addModuleValidator(validator, initData);\n  }\n\n  ///@inheritdoc IValidatorManager\n  function removeModuleValidator(address validator, bytes calldata deinitData) external onlySelf {\n    _removeModuleValidator(validator);\n    IModule(validator).onUninstall(deinitData);\n  }\n\n  ///@inheritdoc IValidatorManager\n  function unlinkModuleValidator(address validator, bytes calldata deinitData) external onlySelf {\n    _removeModuleValidator(validator);\n    validator.excessivelySafeCall(gasleft(), 0, abi.encodeWithSelector(IModule.onUninstall.selector, deinitData));\n  }\n\n  /// @inheritdoc IValidatorManager\n  function isModuleValidator(address validator) external view override returns (bool) {\n    return _isModuleValidator(validator);\n  }\n\n  /// @inheritdoc IValidatorManager\n  function listModuleValidators() external view override returns (address[] memory validatorList) {\n    validatorList = _moduleValidators().values();\n  }\n\n  function _addModuleValidator(address validator, bytes memory initData) internal {\n    if (!_supportsModuleValidator(validator)) {\n      revert Errors.VALIDATOR_ERC165_FAIL(validator);\n    }\n\n    _moduleValidators().add(validator);\n    IModule(validator).onInstall(initData);\n\n    emit ValidatorAdded(validator);\n  }\n\n  function _removeModuleValidator(address validator) internal {\n    _moduleValidators().remove(validator);\n\n    emit ValidatorRemoved(validator);\n  }\n\n  function _isModuleValidator(address validator) internal view returns (bool) {\n    return _moduleValidators().contains(validator);\n  }\n\n  function _supportsModuleValidator(address validator) private view returns (bool) {\n    return\n      validator.supportsInterface(type(IModuleValidator).interfaceId) &&\n      validator.supportsInterface(type(IModule).interfaceId);\n  }\n\n  function _moduleValidators() private view returns (EnumerableSet.AddressSet storage moduleValidators) {\n    moduleValidators = SsoStorage.layout().moduleValidators;\n  }\n}\n",
        "SessionKeyValidator.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport { IModuleValidator } from \"../interfaces/IModuleValidator.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\nimport { IValidatorManager } from \"../interfaces/IValidatorManager.sol\";\nimport { SessionLib } from \"../libraries/SessionLib.sol\";\nimport { SignatureDecoder } from \"../libraries/SignatureDecoder.sol\";\nimport { TimestampAsserterLocator } from \"../helpers/TimestampAsserterLocator.sol\";\n\n/// @title SessionKeyValidator\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice This contract is used to manage sessions for a smart account.\ncontract SessionKeyValidator is IModuleValidator {\n  using SessionLib for SessionLib.SessionStorage;\n\n  event SessionCreated(address indexed account, bytes32 indexed sessionHash, SessionLib.SessionSpec sessionSpec);\n  event SessionRevoked(address indexed account, bytes32 indexed sessionHash);\n\n  // account => number of open sessions\n  // NOTE: expired sessions are still counted if not explicitly revoked\n  mapping(address => uint256) private sessionCounter;\n  // session hash => session state\n  mapping(bytes32 => SessionLib.SessionStorage) private sessions;\n\n  /// @notice Get the session state for an account\n  /// @param account The account to fetch the session state for\n  /// @param spec The session specification to get the state of\n  /// @return The session state: status, remaining fee limit, transfer limits, call value and call parameter limits\n  function sessionState(\n    address account,\n    SessionLib.SessionSpec calldata spec\n  ) external view returns (SessionLib.SessionState memory) {\n    return sessions[keccak256(abi.encode(spec))].getState(account, spec);\n  }\n\n  /// @notice Get the status of a session\n  /// @param account The account to fetch the session status for\n  /// @param sessionHash The session hash to fetch the status of\n  /// @return The status of the session: NotInitialized, Active or Closed\n  function sessionStatus(address account, bytes32 sessionHash) external view returns (SessionLib.Status) {\n    return sessions[sessionHash].status[account];\n  }\n\n  /// @notice Runs on module install\n  /// @param data ABI-encoded session specification to immediately create a session, or empty if not needed\n  function onInstall(bytes calldata data) external override {\n    if (data.length > 0) {\n      require(_addValidationKey(data), \"SessionKeyValidator: failed to add key\");\n    }\n  }\n\n  /// @notice Runs on module uninstall\n  /// @param data ABI-encoded array of session hashes to revoke\n  /// @dev Revokes provided sessions before uninstalling,\n  /// reverts if any session is still active after that.\n  function onUninstall(bytes calldata data) external override {\n    // Revoke keys before uninstalling\n    bytes32[] memory sessionHashes = abi.decode(data, (bytes32[]));\n    for (uint256 i = 0; i < sessionHashes.length; i++) {\n      revokeKey(sessionHashes[i]);\n    }\n    // Here we have make sure that all keys are revoked, so that if the module\n    // is installed again later, there will be no active sessions from the past.\n    require(sessionCounter[msg.sender] == 0, \"Revoke all keys first\");\n  }\n\n  /// @notice This module should not be used to validate signatures\n  /// @return false\n  function validateSignature(bytes32, bytes memory) external pure returns (bool) {\n    return false;\n  }\n\n  /// @notice Create a new session for an account\n  /// @param sessionSpec The session specification to create a session with\n  function createSession(SessionLib.SessionSpec memory sessionSpec) public {\n    bytes32 sessionHash = keccak256(abi.encode(sessionSpec));\n    require(isInitialized(msg.sender), \"Account not initialized\");\n    require(sessionSpec.signer != address(0), \"Invalid signer (create)\");\n    require(sessions[sessionHash].status[msg.sender] == SessionLib.Status.NotInitialized, \"Session already exists\");\n    require(sessionSpec.feeLimit.limitType != SessionLib.LimitType.Unlimited, \"Unlimited fee allowance is not safe\");\n    // Sessions should expire in no less than 60 seconds.\n    uint256 minuteBeforeExpiration = sessionSpec.expiresAt <= 60 ? 0 : sessionSpec.expiresAt - 60;\n    TimestampAsserterLocator.locate().assertTimestampInRange(0, minuteBeforeExpiration);\n\n    sessionCounter[msg.sender]++;\n    sessions[sessionHash].status[msg.sender] = SessionLib.Status.Active;\n    emit SessionCreated(msg.sender, sessionHash, sessionSpec);\n  }\n\n  /// @notice creates a new session for an account, called by onInstall\n  /// @param sessionData ABI-encoded session specification\n  function _addValidationKey(bytes calldata sessionData) internal returns (bool) {\n    SessionLib.SessionSpec memory sessionSpec = abi.decode(sessionData, (SessionLib.SessionSpec));\n    createSession(sessionSpec);\n    return true;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\n    return\n      interfaceId == type(IERC165).interfaceId ||\n      interfaceId == type(IModuleValidator).interfaceId ||\n      interfaceId == type(IModule).interfaceId;\n  }\n\n  /// @notice Revoke a session for an account\n  /// @param sessionHash The hash of a session to revoke\n  /// @dev Decreases the session counter for the account\n  function revokeKey(bytes32 sessionHash) public {\n    require(sessions[sessionHash].status[msg.sender] == SessionLib.Status.Active, \"Nothing to revoke\");\n    sessions[sessionHash].status[msg.sender] = SessionLib.Status.Closed;\n    sessionCounter[msg.sender]--;\n    emit SessionRevoked(msg.sender, sessionHash);\n  }\n\n  /// @notice Revoke multiple sessions for an account\n  /// @param sessionHashes An array of session hashes to revoke\n  function revokeKeys(bytes32[] calldata sessionHashes) external {\n    for (uint256 i = 0; i < sessionHashes.length; i++) {\n      revokeKey(sessionHashes[i]);\n    }\n  }\n\n  /// @notice Check if the validator is registered for the smart account\n  /// @param smartAccount The smart account to check\n  /// @return true if validator is registered for the account, false otherwise\n  function isInitialized(address smartAccount) public view returns (bool) {\n    return IValidatorManager(smartAccount).isModuleValidator(address(this));\n  }\n\n  /// @notice Validate a session transaction for an account\n  /// @param signedHash The hash of the transaction\n  /// @param transaction The transaction to validate\n  /// @return true if the transaction is valid\n  /// @dev Session spec and period IDs must be provided as validator data\n  function validateTransaction(\n    bytes32 signedHash,\n    bytes calldata,\n    Transaction calldata transaction\n  ) external returns (bool) {\n    (bytes memory transactionSignature, address _validator, bytes memory validatorData) = SignatureDecoder\n      .decodeSignature(transaction.signature);\n    (SessionLib.SessionSpec memory spec, uint64[] memory periodIds) = abi.decode(\n      validatorData, // this is passed by the signature builder\n      (SessionLib.SessionSpec, uint64[])\n    );\n    require(spec.signer != address(0), \"Invalid signer (empty)\");\n    bytes32 sessionHash = keccak256(abi.encode(spec));\n    // this generally throws instead of returning false\n    sessions[sessionHash].validate(transaction, spec, periodIds);\n    (address recoveredAddress, ECDSA.RecoverError recoverError) = ECDSA.tryRecover(signedHash, transactionSignature);\n    if (recoverError != ECDSA.RecoverError.NoError || recoveredAddress == address(0)) {\n      return false;\n    }\n    require(recoveredAddress == spec.signer, \"Invalid signer (mismatch)\");\n    // This check is separate and performed last to prevent gas estimation failures\n    sessions[sessionHash].validateFeeLimit(transaction, spec, periodIds[0]);\n    return true;\n  }\n}\n",
        "IOwnerManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\n/**\n * @title Interface of the manager contract for owners\n * @author https://getclave.io\n */\ninterface IOwnerManager {\n  /**\n   * @notice Event emitted when a k1 owner is added\n   * @param addr address - k1 owner that has been added\n   */\n  event K1AddOwner(address indexed addr);\n\n  /**\n   * @notice Event emitted when a k1 owner is removed\n   * @param addr address - k1 owner that has been removed\n   */\n  event K1RemoveOwner(address indexed addr);\n\n  /**\n   * @notice Adds a k1 owner to the list of k1 owners\n   * @dev Can only be called by self or a whitelisted module\n   * @dev Address can not be the zero address\n   * @param addr address - Address to add to the list of k1 owners\n   */\n  function k1AddOwner(address addr) external;\n\n  /**\n   * @notice Removes a k1 owner from the list of k1 owners\n   * @dev Can only be called by self or a whitelisted module\n   * @param addr address - Address to remove from the list of k1 owners\n   */\n  function k1RemoveOwner(address addr) external;\n\n  /**\n   * @notice Checks if an address is in the list of k1 owners\n   * @param addr address - Address to check\n   * @return bool - True if the address is in the list, false otherwise\n   */\n  function k1IsOwner(address addr) external view returns (bool);\n\n  /**\n   * @notice Returns the list of k1 owners\n   * @return k1OwnerList address[] memory - Array of k1 owner addresses\n   */\n  function k1ListOwners() external view returns (address[] memory k1OwnerList);\n}\n",
        "Auth.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { BootloaderAuth } from \"./BootloaderAuth.sol\";\nimport { SelfAuth } from \"./SelfAuth.sol\";\nimport { HookAuth } from \"./HookAuth.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/**\n * @title Auth\n * @notice Abstract contract that organizes authentication logic for the contract\n * @author https://getclave.io\n */\nabstract contract Auth is BootloaderAuth, SelfAuth, HookAuth {}\n",
        "BatchCaller.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { SystemContractsCaller } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/SystemContractsCaller.sol\";\nimport { EfficientCall } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/EfficientCall.sol\";\nimport { DEPLOYER_SYSTEM_CONTRACT } from \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { SelfAuth } from \"../auth/SelfAuth.sol\";\n\n/// @dev Represents an external call data.\n/// @param target The address to which the call will be made.\n/// @param allowFailure Flag that represents whether to revert the whole batch if the call fails.\n/// @param value The amount of Ether (in wei) to be sent along with the call.\n/// @param callData The calldata to be executed on the `target` address.\nstruct Call {\n  address target;\n  bool allowFailure;\n  uint256 value;\n  bytes callData;\n}\n\n/// @title SSO Account\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Make multiple calls from Account in a single transaction.\n/// @notice The implementation is inspired by Clave wallet.\nabstract contract BatchCaller is SelfAuth {\n  /// @notice Make multiple calls, ensure success if required.\n  /// @dev The total Ether sent across all calls must be equal to `msg.value` to maintain the invariant\n  /// that `msg.value` + `tx.fee` is the maximum amount of Ether that can be spent on the transaction.\n  /// @param _calls Array of Call structs, each representing an individual external call to be made.\n  function batchCall(Call[] calldata _calls) external payable onlySelf {\n    uint256 totalValue;\n    uint256 len = _calls.length;\n    for (uint256 i = 0; i < len; ++i) {\n      totalValue += _calls[i].value;\n      bool success;\n      if (_calls[i].target == address(DEPLOYER_SYSTEM_CONTRACT)) {\n        // Note, that the deployer contract can only be called with a \"systemCall\" flag.\n        success = SystemContractsCaller.systemCall(\n          uint32(gasleft()),\n          _calls[i].target,\n          _calls[i].value,\n          _calls[i].callData\n        );\n      } else {\n        success = EfficientCall.rawCall(gasleft(), _calls[i].target, _calls[i].value, _calls[i].callData, false);\n      }\n\n      if (!_calls[i].allowFailure && !success) {\n        revert Errors.CALL_FAILED(i);\n      }\n    }\n\n    if (totalValue != msg.value) {\n      revert Errors.MSG_VALUE_MISMATCH(msg.value, totalValue);\n    }\n  }\n}\n",
        "OwnerManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Auth } from \"../auth/Auth.sol\";\nimport { IOwnerManager } from \"../interfaces/IOwnerManager.sol\";\n\n/**\n * @title Manager contract for owners\n * @notice Abstract contract for managing the owners of the account\n * @dev K1 Owners are secp256k1 addresses\n * @dev Owners are stored in a linked list\n * @author https://getclave.io\n */\nabstract contract OwnerManager is IOwnerManager, Auth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @inheritdoc IOwnerManager\n  function k1AddOwner(address addr) external override onlySelf {\n    _k1AddOwner(addr);\n  }\n\n  /// @inheritdoc IOwnerManager\n  function k1RemoveOwner(address addr) external override onlySelf {\n    _k1RemoveOwner(addr);\n  }\n\n  /// @inheritdoc IOwnerManager\n  function k1IsOwner(address addr) external view override returns (bool) {\n    return _k1IsOwner(addr);\n  }\n\n  /// @inheritdoc IOwnerManager\n  function k1ListOwners() external view override returns (address[] memory k1OwnerList) {\n    k1OwnerList = _k1Owners().values();\n  }\n\n  function _k1AddOwner(address addr) internal {\n    _k1Owners().add(addr);\n\n    emit K1AddOwner(addr);\n  }\n\n  function _k1RemoveOwner(address addr) internal {\n    _k1Owners().remove(addr);\n\n    emit K1RemoveOwner(addr);\n  }\n\n  function _k1IsOwner(address addr) internal view returns (bool) {\n    return _k1Owners().contains(addr);\n  }\n\n  function _k1Owners() private view returns (EnumerableSet.AddressSet storage k1Owners) {\n    k1Owners = SsoStorage.layout().k1Owners;\n  }\n}\n"
    }
}