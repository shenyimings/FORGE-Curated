{
    "vfp_id": "vfp_00003",
    "project_name": "Zenith - SSI Protocol Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "cancelSwapRequest() old orderInfo using new swap causing failure to cancel",
            "description": "1. **Description:** The cancelSwapRequest function uses outdated orderInfo after a new swap has been processed, leading to a mismatch and failure in cancellation.\n2. **Cause:** The function does not validate the state or version of the orderInfo against the current swap data.\n3. **Exploitation:** A user attempting to cancel a swap may be unable to do so if the orderInfo is outdated, allowing the swap to proceed undesired.\n4. **Impact:** Users may suffer unintended transactions, leading to potential loss of funds or incorrect asset transfers.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ssi-protocol/src/Swap.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "setIssuer() Missing change issuers[assetID] to newest",
            "description": "1. **Description:** The setIssuer function does not update the issuers mapping to the newest issuer for a given assetID.\n2. **Cause:** The function logic fails to assign the new issuer value to the storage variable.\n3. **Exploitation:** An old or unauthorized issuer may retain control over asset issuance.\n4. **Impact:** This could allow unauthorized minting or management of assets, compromising the integrity of the system.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetFactory.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Fee will be temporarily uncollectable when all assetTokens are burnt",
            "description": "1. **Description:** If all assetTokens are burnt, the fee collection mechanism becomes inoperable until new tokens are minted.\n2. **Cause:** The fee logic depends on the existence of assetTokens to calculate or collect fees.\n3. **Exploitation:** An attacker could force a state where fees cannot be collected by burning all tokens.\n4. **Impact:** Revenue loss for the protocol due to inability to collect fees during the zero-token state.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetToken.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Lack of duplicate check in rebalance will cause baskets to be filled with duplicate tokens",
            "description": "1. **Description:** The rebalance function does not check for duplicate tokens, allowing the same token to be added multiple times to a basket.\n2. **Cause:** Absence of deduplication logic in the rebalance process.\n3. **Exploitation:** An attacker could manipulate basket composition by inserting duplicate tokens.\n4. **Impact:** Distorted basket valuation and potential financial loss due to incorrect asset representation.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetToken.sol",
                "ssi-protocol/src/AssetRebalancer.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of requester check for `orderHash` allows DoS of swap request",
            "description": "1. **Description:** The system does not verify that the requester of a swap is the rightful owner of the orderHash, enabling third parties to disrupt requests.\n2. **Cause:** Missing authorization check on orderHash usage.\n3. **Exploitation:** An attacker can submit conflicting or invalid requests using known orderHashes.\n4. **Impact:** Legitimate swap requests may be blocked or fail, leading to denial of service.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetRebalancer.sol",
                "ssi-protocol/src/Swap.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Missing check for `chainId` in signature for `Order` and `HedgeOrder`",
            "description": "1. **Description:** The signature validation for Order and HedgeOrder does not include chainId, making signatures replayable across chains.\n2. **Cause:** Chain ID is not included in the signed message hash.\n3. **Exploitation:** A valid signature on one chain can be reused on another chain to execute unauthorized actions.\n4. **Impact:** Cross-chain replay attacks could lead to unauthorized swaps or asset transfers.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/Swap.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "setFeeManager() does not restrict burningFee() == false, which may cause the fee manager to not work properly",
            "description": "1. **Description:** The setFeeManager function allows setting a fee manager even when burningFee is false, potentially breaking fee collection logic.\n2. **Cause:** Inconsistent state management between fee manager and burningFee flag.\n3. **Exploitation:** A misconfigured fee manager could be set, leading to failed fee operations.\n4. **Impact:** Fee collection may fail, affecting protocol revenue and functionality.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetFactory.sol",
                "ssi-protocol/src/AssetToken.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Restrictions on outByContract can't rollback, which may result in the request not being closed properly",
            "description": "1. **Description:** The outByContract restriction cannot be rolled back, which may prevent proper closure of requests.\n2. **Cause:** Immutable enforcement of outByContract without a revert or update mechanism.\n3. **Exploitation:** A misconfigured restriction could permanently block request closure.\n4. **Impact:** Requests may remain open indefinitely, affecting system state and user experience.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/Swap.sol"
            ]
        }
    ],
    "affected_files": {
        "AssetRebalancer.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport \"./Interface.sol\";\nimport {AssetController} from \"./AssetController.sol\";\nimport {Utils} from './Utils.sol';\n\nimport \"forge-std/console.sol\";\n\ncontract AssetRebalancer is AssetController, IAssetRebalancer {\n    Request[] rebalanceRequests;\n\n    event AddRebalanceRequest(uint nonce);\n    event RejectRebalanceRequest(uint nonce);\n    event ConfirmRebalanceRequest(uint nonce);\n\n    constructor(address owner, address factoryAddress_)\n        AssetController(owner, factoryAddress_) {\n\n    }\n\n    // rebalance\n\n    function getRebalanceRequestLength() external view returns (uint256) {\n        return rebalanceRequests.length;\n    }\n\n    function getRebalanceRequest(uint256 nonce) external view returns (Request memory) {\n        return rebalanceRequests[nonce];\n    }\n\n    function addRebalanceRequest(uint256 assetID, Token[] memory basket, OrderInfo memory orderInfo) external onlyOwner returns (uint256) {\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        address assetTokenAddress = factory.assetTokens(assetID);\n        IAssetToken assetToken = IAssetToken(assetTokenAddress);\n        address swapAddress = factory.swap();\n        ISwap swap = ISwap(swapAddress);\n        require(assetToken.totalSupply() > 0, \"zero supply\");\n        require(assetToken.feeCollected(), \"has fee not collect\");\n        require(assetToken.hasRole(assetToken.REBALANCER_ROLE(), address(this)), \"not a rebalancer\");\n        require(assetToken.rebalancing() == false, \"is rebalancing\");\n        require(assetToken.issuing() == false, \"is issuing\");\n        require(swap.checkOrderInfo(orderInfo) == 0, \"order not valid\");\n        require(keccak256(abi.encode(assetToken.getBasket())) == keccak256(abi.encode(basket)), \"underlying basket not match\");\n        Token[] memory inBasket = Utils.muldivTokenset(orderInfo.order.outTokenset, orderInfo.order.outAmount, 10**8);\n        Token[] memory outBasket = Utils.muldivTokenset(orderInfo.order.inTokenset, orderInfo.order.inAmount, 10**8);\n        require(Utils.containTokenset(basket, outBasket), \"not enough balance to sell\");\n        Token[] memory newBasket = Utils.addTokenset(Utils.subTokenset(basket, outBasket), inBasket);\n        Token[] memory newTokenset = Utils.muldivTokenset(newBasket, 10**assetToken.decimals(), assetToken.totalSupply());\n        for (uint i = 0; i < newTokenset.length; i++) {\n            require(newTokenset[i].amount > 0, \"too little left in new basket\");\n        }\n        swap.addSwapRequest(orderInfo, false, false);\n        rebalanceRequests.push(Request({\n            nonce: rebalanceRequests.length,\n            requester: msg.sender,\n            assetTokenAddress: assetTokenAddress,\n            amount: 0,\n            swapAddress: swapAddress,\n            orderHash: orderInfo.orderHash,\n            status: RequestStatus.PENDING,\n            requestTimestamp: block.timestamp,\n            issueFee: 0\n        }));\n        assetToken.lockRebalance();\n        emit AddRebalanceRequest(rebalanceRequests.length - 1);\n        return rebalanceRequests.length - 1;\n    }\n\n    function rejectRebalanceRequest(uint nonce) external onlyOwner {\n        require(nonce < rebalanceRequests.length);\n        Request memory rebalanceRequest = rebalanceRequests[nonce];\n        require(rebalanceRequest.status == RequestStatus.PENDING);\n        ISwap swap = ISwap(rebalanceRequest.swapAddress);\n        SwapRequest memory swapRequest = swap.getSwapRequest(rebalanceRequest.orderHash);\n        require(swapRequest.status == SwapRequestStatus.REJECTED || swapRequest.status == SwapRequestStatus.CANCEL);\n        IAssetToken assetToken = IAssetToken(rebalanceRequest.assetTokenAddress);\n        assetToken.unlockRebalance();\n        rebalanceRequests[nonce].status = RequestStatus.REJECTED;\n        emit RejectRebalanceRequest(nonce);\n    }\n\n    function confirmRebalanceRequest(uint nonce, OrderInfo memory orderInfo, bytes[] memory inTxHashs) external onlyOwner {\n        require(nonce < rebalanceRequests.length);\n        Request memory rebalanceRequest = rebalanceRequests[nonce];\n        checkRequestOrderInfo(rebalanceRequest, orderInfo);\n        require(rebalanceRequest.status == RequestStatus.PENDING);\n        ISwap swap = ISwap(rebalanceRequest.swapAddress);\n        SwapRequest memory swapRequest = swap.getSwapRequest(rebalanceRequest.orderHash);\n        require(swapRequest.status == SwapRequestStatus.MAKER_CONFIRMED);\n        swap.confirmSwapRequest(orderInfo, inTxHashs);\n        Order memory order = orderInfo.order;\n        Token[] memory inBasket = Utils.muldivTokenset(order.outTokenset, order.outAmount, 10**8);\n        Token[] memory outBasket = Utils.muldivTokenset(order.inTokenset, order.inAmount, 10**8);\n        IAssetToken assetToken = IAssetToken(rebalanceRequest.assetTokenAddress);\n        assetToken.rebalance(inBasket, outBasket);\n        rebalanceRequests[nonce].status = RequestStatus.CONFIRMED;\n        assetToken.unlockRebalance();\n        emit ConfirmRebalanceRequest(nonce);\n    }\n}",
        "AssetFactory.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport \"./Interface.sol\";\nimport \"./AssetToken.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"forge-std/console.sol\";\n\ncontract AssetFactory is Initializable, OwnableUpgradeable, UUPSUpgradeable, IAssetFactory {\n    using EnumerableSet for EnumerableSet.UintSet;\n    EnumerableSet.UintSet assetIDs;\n    mapping(uint => address) public assetTokens;\n\n    mapping(uint => address) public issuers;\n    mapping(uint => address) public rebalancers;\n    mapping(uint => address) public feeManagers;\n\n    address public swap;\n    address public vault;\n    string public chain;\n    address public tokenImpl;\n\n    event AssetTokenCreated(address assetTokenAddress);\n    event SetVault(address vault);\n    event SetSwap(address swap);\n    event SetTokenImpl(address tokenImpl);\n    event UpgradeAssetToken(uint256 assetID, address tokenImpl);\n    event SetIssuer(uint256 assetID, address oldIssuer, address issuer);\n    event SetRebalancer(uint256 assetID, address oldRebalancer, address rebalancer);\n    event SetFeeManager(uint256 assetID, address oldFeeManager, address feeManager);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address owner, address swap_, address vault_, string memory chain_, address tokenImpl_) public initializer {\n        __Ownable_init(owner);\n        __UUPSUpgradeable_init();\n        require(swap_ != address(0), \"swap address is zero\");\n        require(vault_ != address(0), \"vault address is zero\");\n        require(tokenImpl_ != address(0), \"token impl address is zero\");\n        swap = swap_;\n        vault = vault_;\n        chain = chain_;\n        tokenImpl = tokenImpl_;\n        emit SetVault(vault);\n        emit SetSwap(swap);\n        emit SetTokenImpl(tokenImpl);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function setSwap(address swap_) external onlyOwner {\n        require(swap_ != address(0), \"swap address is zero\");\n        swap = swap_;\n        emit SetSwap(swap);\n    }\n\n    function setVault(address vault_) external onlyOwner {\n        require(vault_ != address(0), \"vault address is zero\");\n        vault = vault_;\n        emit SetVault(vault);\n    }\n\n    function setTokenImpl(address tokenImpl_) external onlyOwner {\n        require(tokenImpl_ != address(0), \"token impl address is zero\");\n        require(tokenImpl_ != tokenImpl, \"token impl is not change\");\n        tokenImpl = tokenImpl_;\n        emit SetTokenImpl(tokenImpl);\n        for (uint i = 0; i < assetIDs.length(); i++) {\n            address assetToken = assetTokens[assetIDs.at(i)];\n            UUPSUpgradeable(assetToken).upgradeToAndCall(tokenImpl, new bytes(0));\n            emit UpgradeAssetToken(assetIDs.at(i), tokenImpl);\n        }\n    }\n\n    function createAssetToken(Asset memory asset, uint maxFee, address issuer, address rebalancer, address feeManager) external onlyOwner returns (address) {\n        require(issuer != address(0) && rebalancer != address(0) && feeManager != address(0), \"controllers not set\");\n        require(!assetIDs.contains(asset.id), \"asset exists\");\n        address assetTokenAddress = address(new ERC1967Proxy(\n            tokenImpl,\n            abi.encodeCall(AssetToken.initialize, (asset.id, asset.name, asset.symbol, maxFee, address(this)))\n        ));\n        IAssetToken assetToken = IAssetToken(assetTokenAddress);\n        assetToken.grantRole(assetToken.ISSUER_ROLE(), issuer);\n        assetToken.grantRole(assetToken.REBALANCER_ROLE(), rebalancer);\n        assetToken.grantRole(assetToken.FEEMANAGER_ROLE(), feeManager);\n        assetToken.initTokenset(asset.tokenset);\n        assetTokens[asset.id] = address(assetToken);\n        issuers[asset.id] = issuer;\n        rebalancers[asset.id] = rebalancer;\n        feeManagers[asset.id] = feeManager;\n        assetIDs.add(asset.id);\n        emit AssetTokenCreated(address(assetToken));\n        return address(assetToken);\n    }\n\n    function setIssuer(uint256 assetID, address issuer) external onlyOwner {\n        require(issuer != address(0), \"issuer is zero address\");\n        require(assetIDs.contains(assetID), \"assetID not exists\");\n        IAssetToken assetToken = IAssetToken(assetTokens[assetID]);\n        require(!assetToken.issuing(), \"is issuing\");\n        address oldIssuer = issuers[assetID];\n        assetToken.revokeRole(assetToken.ISSUER_ROLE(), oldIssuer);\n        assetToken.grantRole(assetToken.ISSUER_ROLE(), issuer);\n        emit SetIssuer(assetID, oldIssuer, issuer);\n    }\n\n    function setRebalancer(uint256 assetID, address rebalancer) external onlyOwner {\n        require(rebalancer != address(0), \"rebalancer is zero address\");\n        require(assetIDs.contains(assetID), \"assetID not exists\");\n        IAssetToken assetToken = IAssetToken(assetTokens[assetID]);\n        require(!assetToken.rebalancing(), \"is rebalancing\");\n        address oldRebalancer = rebalancers[assetID];\n        assetToken.revokeRole(assetToken.REBALANCER_ROLE(), oldRebalancer);\n        assetToken.grantRole(assetToken.REBALANCER_ROLE(), rebalancer);\n        emit SetRebalancer(assetID, oldRebalancer, rebalancer);\n    }\n\n    function setFeeManager(uint256 assetID, address feeManager) external onlyOwner {\n        require(feeManager != address(0), \"feeManager is zero address\");\n        require(assetIDs.contains(assetID), \"assetID not exists\");\n        IAssetToken assetToken = IAssetToken(assetTokens[assetID]);\n        address oldFeeManager = feeManagers[assetID];\n        assetToken.revokeRole(assetToken.FEEMANAGER_ROLE(), oldFeeManager);\n        assetToken.grantRole(assetToken.FEEMANAGER_ROLE(), feeManager);\n        emit SetFeeManager(assetID, oldFeeManager, feeManager);\n    }\n\n    function hasAssetID(uint assetID) external view returns (bool) {\n        return assetIDs.contains(assetID);\n    }\n\n    function getAssetIDs() external view returns (uint[] memory) {\n        return assetIDs.values();\n    }\n}",
        "Swap.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport './Interface.sol';\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {Utils} from './Utils.sol';\n\ncontract Swap is AccessControl, Pausable, ISwap {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    string public chain;\n    EnumerableSet.Bytes32Set orderHashs;\n    mapping(bytes32 => SwapRequest) swapRequests;\n\n    bytes32 public constant TAKER_ROLE = keccak256(\"TAKER_ROLE\");\n    bytes32 public constant MAKER_ROLE = keccak256(\"MAKER_ROLE\");\n\n    mapping(string => bool) outWhiteAddresses;\n    string[] public takerReceivers;\n    string[] public takerSenders;\n\n    uint256 public constant MAX_MARKER_CONFIRM_DELAY = 1 hours;\n\n    event AddSwapRequest(address indexed taker, bool inByContract, bool outByContract, OrderInfo orderInfo);\n    event MakerConfirmSwapRequest(address indexed maker, bytes32 orderHash);\n    event ConfirmSwapRequest(address indexed taker, bytes32 orderHash);\n    event MakerRejectSwapRequest(address indexed maker, bytes32 orderHash);\n    event RollbackSwapRequest(address indexed taker, bytes32 orderHash);\n    event SetTakerAddresses(string[] receivers, string[] senders);\n    event CancelSwapRequest(address indexed taker, bytes32 orderHash);\n\n    constructor(address owner, string memory chain_) {\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n        chain = chain_;\n    }\n\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function checkOrderInfo(OrderInfo memory orderInfo) public view returns (uint) {\n        if (block.timestamp >= orderInfo.order.deadline) {\n            return 1;\n        }\n        bytes32 orderHash = keccak256(abi.encode(orderInfo.order));\n        if (orderHash != orderInfo.orderHash) {\n            return 2;\n        }\n        if (!SignatureChecker.isValidSignatureNow(orderInfo.order.maker, orderHash, orderInfo.orderSign)) {\n            return 3;\n        }\n        if (orderHashs.contains(orderHash)) {\n            return 4;\n        }\n        if (orderInfo.order.inAddressList.length != orderInfo.order.inTokenset.length) {\n            return 5;\n        }\n        if (orderInfo.order.outAddressList.length != orderInfo.order.outTokenset.length) {\n            return 6;\n        }\n        if (!hasRole(MAKER_ROLE, orderInfo.order.maker)) {\n            return 7;\n        }\n        for (uint i = 0; i < orderInfo.order.outAddressList.length; i++) {\n            if (!outWhiteAddresses[orderInfo.order.outAddressList[i]]) {\n                return 8;\n            }\n        }\n        return 0;\n    }\n\n    function validateOrderInfo(OrderInfo memory orderInfo) internal view {\n        require(orderHashs.contains(orderInfo.orderHash), \"order hash not exists\");\n        require(orderInfo.orderHash == keccak256(abi.encode(orderInfo.order)), \"order hash invalid\");\n    }\n\n    function getOrderHashs() external view returns (bytes32[] memory) {\n        return orderHashs.values();\n    }\n\n    function getOrderHashLength() external view returns (uint256) {\n        return orderHashs.length();\n    }\n\n    function getOrderHash(uint256 idx) external view returns (bytes32) {\n        require(idx < orderHashs.length(), \"out of range\");\n        return orderHashs.at(idx);\n    }\n\n    function checkTokenset(Token[] memory tokenset, string[] memory addressList) internal view {\n        require(tokenset.length == addressList.length, \"tokenset length not maatch addressList length\");\n        for (uint i = 0; i < tokenset.length; i++) {\n            require(bytes32(bytes(tokenset[i].chain)) == bytes32(bytes(chain)), \"chain not match\");\n            address tokenAddress = Utils.stringToAddress(tokenset[i].addr);\n            require(tokenAddress != address(0), \"zero token address\");\n            address receiveAddress = Utils.stringToAddress(addressList[i]);\n            require(receiveAddress != address(0), \"zero receive address\");\n        }\n    }\n\n    function addSwapRequest(OrderInfo memory orderInfo, bool inByContract, bool outByContract) external onlyRole(TAKER_ROLE) whenNotPaused {\n        uint code = checkOrderInfo(orderInfo);\n        require(code == 0, \"order not valid\");\n        swapRequests[orderInfo.orderHash].status = SwapRequestStatus.PENDING;\n        swapRequests[orderInfo.orderHash].requester = msg.sender;\n        orderHashs.add(orderInfo.orderHash);\n        if (inByContract) {\n            checkTokenset(orderInfo.order.inTokenset, orderInfo.order.inAddressList);\n        }\n        if (outByContract) {\n            checkTokenset(orderInfo.order.outTokenset, orderInfo.order.outAddressList);\n        }\n        swapRequests[orderInfo.orderHash].inByContract = inByContract;\n        swapRequests[orderInfo.orderHash].outByContract = outByContract;\n        swapRequests[orderInfo.orderHash].blocknumber = block.number;\n        swapRequests[orderInfo.orderHash].requestTimestamp = block.timestamp;\n        emit AddSwapRequest(msg.sender, inByContract, outByContract, orderInfo);\n    }\n\n    function getSwapRequest(bytes32 orderHash) external view returns (SwapRequest memory) {\n        return swapRequests[orderHash];\n    }\n\n    function cancelSwapRequest(OrderInfo memory orderInfo) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].requester == msg.sender, \"not order taker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING, \"swap request status is not pending\");\n        require(swapRequests[orderHash].requestTimestamp + MAX_MARKER_CONFIRM_DELAY <= block.timestamp, \"swap request not timeout\");\n        swapRequests[orderHash].status = SwapRequestStatus.CANCEL;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit CancelSwapRequest(msg.sender, orderHash);\n    }\n\n    function makerRejectSwapRequest(OrderInfo memory orderInfo) external onlyRole(MAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(orderInfo.order.maker == msg.sender, \"not order maker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.PENDING, \"swap request status is not pending\");\n        swapRequests[orderHash].status = SwapRequestStatus.REJECTED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit MakerRejectSwapRequest(msg.sender, orderHash);\n    }\n\n    function transferTokenset(address from, Token[] memory tokenset, uint256 amount, string[] memory toAddressList) internal {\n        for (uint i = 0; i < tokenset.length; i++) {\n            address tokenAddress = Utils.stringToAddress(tokenset[i].addr);\n            address to = Utils.stringToAddress(toAddressList[i]);\n            IERC20 token = IERC20(tokenAddress);\n            uint tokenAmount = tokenset[i].amount * amount / 10**8;\n            require(token.balanceOf(from) >= tokenAmount, \"not enough balance\");\n            require(token.allowance(from, address(this)) >= tokenAmount, \"not enough allowance\");\n            token.safeTransferFrom(from, to, tokenAmount);\n        }\n    }\n\n    function makerConfirmSwapRequest(OrderInfo memory orderInfo, bytes[] memory outTxHashs) external onlyRole(MAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        SwapRequest memory swapRequest = swapRequests[orderHash];\n        require(orderInfo.order.maker == msg.sender, \"not order maker\");\n        require(swapRequest.status == SwapRequestStatus.PENDING, \"status error\");\n        if (swapRequest.outByContract) {\n            transferTokenset(msg.sender, orderInfo.order.outTokenset, orderInfo.order.outAmount, orderInfo.order.outAddressList);\n        } else {\n            require(orderInfo.order.outTokenset.length == outTxHashs.length, \"wrong outTxHashs length\");\n            swapRequests[orderHash].outTxHashs = outTxHashs;\n        }\n        swapRequests[orderHash].status = SwapRequestStatus.MAKER_CONFIRMED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit MakerConfirmSwapRequest(msg.sender, orderHash);\n    }\n\n    function rollbackSwapRequest(OrderInfo memory orderInfo) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        require(swapRequests[orderHash].requester == msg.sender, \"not order taker\");\n        require(swapRequests[orderHash].status == SwapRequestStatus.MAKER_CONFIRMED, \"swap request status is not maker_confirmed\");\n        require(!swapRequests[orderHash].outByContract, \"out by contract cannot rollback\");\n        swapRequests[orderHash].status = SwapRequestStatus.PENDING;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit RollbackSwapRequest(msg.sender, orderHash);\n    }\n\n    function confirmSwapRequest(OrderInfo memory orderInfo, bytes[] memory inTxHashs) external onlyRole(TAKER_ROLE) whenNotPaused {\n        validateOrderInfo(orderInfo);\n        bytes32 orderHash = orderInfo.orderHash;\n        SwapRequest memory swapRequest = swapRequests[orderHash];\n        require(swapRequest.requester == msg.sender, \"not order taker\");\n        require(swapRequest.status == SwapRequestStatus.MAKER_CONFIRMED, \"status error\");\n         if (swapRequest.inByContract) {\n            transferTokenset(msg.sender, orderInfo.order.inTokenset, orderInfo.order.inAmount, orderInfo.order.inAddressList);\n        } else {\n            require(orderInfo.order.inTokenset.length == inTxHashs.length, \"wrong inTxHashs length\");\n            swapRequests[orderHash].inTxHashs = inTxHashs;\n        }\n        swapRequests[orderHash].status = SwapRequestStatus.CONFIRMED;\n        swapRequests[orderHash].blocknumber = block.number;\n        emit ConfirmSwapRequest(msg.sender, orderHash);\n    }\n\n    function setTakerAddresses(string[] memory takerReceivers_, string[] memory takerSenders_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < takerReceivers.length; i++) {\n            outWhiteAddresses[takerReceivers[i]] = false;\n        }\n        delete takerReceivers;\n        for (uint i = 0; i < takerReceivers_.length; i++) {\n            takerReceivers.push(takerReceivers_[i]);\n            outWhiteAddresses[takerReceivers[i]] = true;\n        }\n        delete takerSenders;\n        for (uint i = 0; i < takerSenders_.length; i++) {\n            takerSenders.push(takerSenders_[i]);\n        }\n        emit SetTakerAddresses(takerReceivers, takerSenders);\n    }\n\n    function getTakerAddresses() external view returns (string[] memory receivers, string[] memory senders) {\n        return (takerReceivers, takerSenders);\n    }\n}\n",
        "AssetToken.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport \"./Interface.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Utils} from './Utils.sol';\n\nimport \"forge-std/console.sol\";\n\ncontract AssetToken is Initializable, ERC20Upgradeable, AccessControlUpgradeable, UUPSUpgradeable, IAssetToken {\n    // tokenset\n    Token[] tokenset_;\n    Token[] basket_;\n    Token[] feeTokenset_;\n    // issue\n    uint issueCnt;\n    // rebalance\n    bool public rebalancing;\n    // fee\n    uint public constant feeDecimals = 8;\n    uint public id;\n    uint public maxFee;\n    uint public fee;\n    uint public lastCollectTimestamp;\n    bool public burningFee;\n    // roles\n    bytes32 public constant ISSUER_ROLE = keccak256(\"ISSUER_ROLE\");\n    bytes32 public constant REBALANCER_ROLE = keccak256(\"REBALANCER_ROLE\");\n    bytes32 public constant FEEMANAGER_ROLE = keccak256(\"FEEMANAGER_ROLE\");\n    // event\n    event SetFee(uint fee);\n    event SetTokenset(Token[] tokenset);\n    event SetBasket(Token[] basket);\n    event SetFeeTokenset(Token[] feeTokenset);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize (\n        uint256 id_,\n        string memory name_,\n        string memory symbol_,\n        uint maxFee_,\n        address owner\n    ) public initializer {\n        __ERC20_init(name_, symbol_);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        require(maxFee_ < 10**feeDecimals, \"maxFee should less than 1\");\n        id = id_;\n        maxFee = maxFee_;\n        fee = maxFee;\n        lastCollectTimestamp = block.timestamp;\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    function decimals() public pure override(ERC20Upgradeable, IAssetToken) returns (uint8) {\n        return 8;\n    }\n\n    // tokenset\n\n    function getTokenset() public view returns (Token[] memory) {\n        return tokenset_;\n    }\n\n    function initTokenset(Token[] memory tokenset) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(tokenset_.length == 0, \"already inited\");\n        setTokenset(tokenset);\n    }\n\n    function setTokenset(Token[] memory tokenset) internal {\n        delete tokenset_;\n        for (uint i = 0; i < tokenset.length; i++) {\n            require(tokenset[i].amount > 0, \"token amount == 0\");\n            tokenset_.push(tokenset[i]);\n        }\n        emit SetTokenset(tokenset_);\n    }\n\n    function getBasket() public view returns (Token[] memory) {\n        return basket_;\n    }\n\n    function setBasket(Token[] memory basket) internal {\n        delete basket_;\n        for (uint i = 0; i < basket.length; i++) {\n            require(basket[i].amount > 0, \"token amount == 0\");\n            basket_.push(basket[i]);\n        }\n        emit SetBasket(basket_);\n    }\n\n    // issue\n\n    function lockIssue() external onlyRole(ISSUER_ROLE) {\n        require(rebalancing == false, \"is rebalancing\");\n        issueCnt += 1;\n    }\n\n    function issuing() external view returns (bool) {\n        return issueCnt > 0;\n    }\n\n    function unlockIssue() external onlyRole(ISSUER_ROLE) {\n        if (issueCnt > 0) {\n            issueCnt -= 1;\n        }\n    }\n\n    function mint(address account, uint amount) external onlyRole(ISSUER_ROLE) {\n        _mint(account, amount);\n        Token[] memory newBasket = Utils.addTokenset(basket_, Utils.muldivTokenset(tokenset_, amount, 10 ** decimals()));\n        setBasket(newBasket);\n    }\n\n    function burn(uint amount) external onlyRole(ISSUER_ROLE) {\n        _update(msg.sender, address(0), amount);\n        Token[] memory newBasket = Utils.subTokenset(basket_, Utils.muldivTokenset(tokenset_, amount, 10 ** decimals()));\n        setBasket(newBasket);\n    }\n\n    // rebalance\n\n    function lockRebalance() external onlyRole(REBALANCER_ROLE) {\n        require(issueCnt == 0, \"is issuing\");\n        require(rebalancing == false, \"is rebalancing\");\n        rebalancing = true;\n    }\n\n    function unlockRebalance() external onlyRole(REBALANCER_ROLE) {\n        rebalancing = false;\n    }\n\n    function rebalance(Token[] memory inBasket, Token[] memory outBasket) external onlyRole(REBALANCER_ROLE) {\n        require(rebalancing, \"lock rebalance first\");\n        require(totalSupply() > 0, \"zero supply\");\n        Token[] memory newBasket = Utils.addTokenset(Utils.subTokenset(basket_, outBasket), inBasket);\n        Token[] memory newTokenset = Utils.muldivTokenset(newBasket, 10**decimals(), totalSupply());\n        setBasket(newBasket);\n        setTokenset(newTokenset);\n    }\n\n    // fee\n\n    function setFee(uint fee_) external onlyRole(FEEMANAGER_ROLE) {\n        require(fee_ <= maxFee, \"new fee exceeds maxFee\");\n        fee = fee_;\n        emit SetFee(fee_);\n    }\n\n    function getFeeTokenset() external view returns (Token[] memory) {\n        return feeTokenset_;\n    }\n\n    function feeCollected() external view returns (bool) {\n        return block.timestamp - lastCollectTimestamp < 1 days;\n    }\n\n    // warning: fee manager should collect fee daily\n    function collectFeeTokenset() external onlyRole(FEEMANAGER_ROLE) {\n        if (block.timestamp - lastCollectTimestamp >= 1 days) {\n            if (totalSupply() > 0) {\n                require(rebalancing == false, \"is rebalancing\");\n                require(issueCnt == 0, \"is issuing\");\n                Token[] memory newBasket = basket_;\n                uint256 feeDays = (block.timestamp - lastCollectTimestamp) / 1 days;\n                for (uint i = 0; i < newBasket.length; i++) {\n                    for (uint j = 0; j < feeDays; j++) {\n                        newBasket[i].amount -= newBasket[i].amount * fee / (10 ** feeDecimals);\n                    }\n                }\n                Token[] memory newFeeTokenset = Utils.addTokenset(feeTokenset_, Utils.subTokenset(basket_, newBasket));\n                Token[] memory newTokenset = Utils.muldivTokenset(newBasket, 10**decimals(), totalSupply());\n                setBasket(newBasket);\n                setFeeTokenset(newFeeTokenset);\n                setTokenset(newTokenset);\n            }\n            lastCollectTimestamp += (block.timestamp - lastCollectTimestamp) / 1 days * 1 days;\n        }\n    }\n\n    function lockBurnFee() external onlyRole(FEEMANAGER_ROLE) {\n        require(burningFee == false, \"is burning fee\");\n        burningFee = true;\n    }\n\n    function unlockBurnFee() external onlyRole(FEEMANAGER_ROLE) {\n        burningFee = false;\n    }\n\n    function burnFeeTokenset(Token[] memory feeTokenset) external onlyRole(FEEMANAGER_ROLE) {\n        require(Utils.containTokenset(feeTokenset_, feeTokenset), \"burn amount too large\");\n        setFeeTokenset(Utils.subTokenset(feeTokenset_, feeTokenset));\n    }\n\n    function setFeeTokenset(Token[] memory feeTokenset) internal {\n        delete feeTokenset_;\n        for (uint i = 0; i < feeTokenset.length; i++) {\n            feeTokenset_.push(feeTokenset[i]);\n        }\n        emit SetFeeTokenset(feeTokenset_);\n    }\n}\n"
    }
}