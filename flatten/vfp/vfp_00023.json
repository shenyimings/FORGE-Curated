{
    "vfp_id": "vfp_00023",
    "project_name": "Matter Labs Guardian Recovery Validator Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-770"
                ]
            },
            "title": "Potential Denial-of-Service While Iterating Hooks",
            "description": "The `runExecutionHooks` modifier and `runValidationHooks` function iterate over all elements in a set without any gas cost limitations. This design allows the number of hooks to grow unbounded, leading to excessive gas consumption during transaction execution or validation. The root cause is the use of `EnumerableSet.values()` and direct iteration over large sets in state-changing functions, which does not account for block gas limits. An attacker could exploit this by registering a large number of hooks, causing transactions to fail due to gas exhaustion. The impact is a potential denial-of-service, where legitimate users are unable to execute or validate transactions if the hook set becomes too large.\n",
            "severity": "Medium",
            "location": [
                "HookManager.sol::runExecutionHooks#79",
                "HookManager.sol::runValidationHooks#63"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/managers/HookManager.sol"
            ]
        }
    ],
    "affected_files": {
        "HookManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.24;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Transaction } from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\nimport { ExcessivelySafeCall } from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\nimport { SelfAuth } from \"../auth/SelfAuth.sol\";\nimport { SsoStorage } from \"../libraries/SsoStorage.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { IExecutionHook, IValidationHook } from \"../interfaces/IHook.sol\";\nimport { IHookManager } from \"../interfaces/IHookManager.sol\";\nimport { IModule } from \"../interfaces/IModule.sol\";\n\n/**\n * @title Manager contract for hooks\n * @notice Abstract contract for managing the enabled hooks of the account\n * @dev Hook addresses are stored in an enumerable set\n * @author Initially https://getclave.io, then updated by Matter Labs\n */\nabstract contract HookManager is IHookManager, SelfAuth {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  // Interface helper library\n  using ERC165Checker for address;\n  // Low level calls helper library\n  using ExcessivelySafeCall for address;\n\n  /// @inheritdoc IHookManager\n  function addHook(address hook, bool isValidation, bytes calldata initData) external override onlySelf {\n    _addHook(hook, isValidation, initData);\n  }\n\n  /// @inheritdoc IHookManager\n  function removeHook(address hook, bool isValidation, bytes calldata deinitData) external override onlySelf {\n    _removeHook(hook, isValidation);\n    IModule(hook).onUninstall(deinitData);\n  }\n\n  /// @inheritdoc IHookManager\n  function unlinkHook(address hook, bool isValidation, bytes calldata deinitData) external onlySelf {\n    _removeHook(hook, isValidation);\n    // Allow-listing slither finding as we donÂ´t want reverting calls to prevent unlinking\n    // slither-disable-next-line unused-return\n    hook.excessivelySafeCall(gasleft(), 0, abi.encodeCall(IModule.onUninstall, (deinitData)));\n  }\n\n  /// @inheritdoc IHookManager\n  function isHook(address addr) external view override returns (bool) {\n    return _isHook(addr);\n  }\n\n  /// @inheritdoc IHookManager\n  function listHooks(bool isValidation) external view override returns (address[] memory hookList) {\n    if (isValidation) {\n      hookList = SsoStorage.validationHooks().values();\n    } else {\n      hookList = SsoStorage.executionHooks().values();\n    }\n  }\n\n  // Runs the validation hooks that are enabled by the account and returns true if none reverts\n  function runValidationHooks(bytes32 signedHash, Transaction calldata transaction) internal returns (bool) {\n    EnumerableSet.AddressSet storage hookList = SsoStorage.validationHooks();\n    uint256 totalHooks = hookList.length();\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      bool success = _call(hookList.at(i), abi.encodeCall(IValidationHook.validationHook, (signedHash, transaction)));\n\n      if (!success) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Runs the execution hooks that are enabled by the account before and after _executeTransaction\n  modifier runExecutionHooks(Transaction calldata transaction) {\n    address[] memory hookList = SsoStorage.executionHooks().values();\n    uint256 totalHooks = hookList.length;\n    bytes[] memory context = new bytes[](totalHooks);\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      context[i] = IExecutionHook(hookList[i]).preExecutionHook(transaction);\n    }\n\n    _;\n\n    EnumerableSet.AddressSet storage newHookList = SsoStorage.executionHooks();\n\n    for (uint256 i = 0; i < totalHooks; i++) {\n      // Only execute hooks which are both in the old `hookList` and the `newHookList`,\n      // and we don't want to execute hooks that were removed and/or added during this transaction.\n      if (newHookList.contains(hookList[i])) {\n        IExecutionHook(hookList[i]).postExecutionHook(context[i]);\n      }\n    }\n  }\n\n  function _addHook(address hook, bool isValidation, bytes calldata initData) private {\n    if (!_supportsHook(hook, isValidation)) {\n      revert Errors.HOOK_ERC165_FAIL(hook, isValidation);\n    }\n\n    // Regardless of whether or not it is a validation or an execution hook,\n    // if the module is already installed, it cannot be installed again (even as another type).\n    if (SsoStorage.validationHooks().contains(hook)) {\n      revert Errors.HOOK_ALREADY_EXISTS(hook, true);\n    }\n    if (SsoStorage.executionHooks().contains(hook)) {\n      revert Errors.HOOK_ALREADY_EXISTS(hook, false);\n    }\n    if (SsoStorage.validators().contains(hook)) {\n      revert Errors.VALIDATOR_ALREADY_EXISTS(hook);\n    }\n\n    // No need to check the return value of .add() as we just checked that it is not already present.\n    if (isValidation) {\n      bool _result = SsoStorage.validationHooks().add(hook);\n    } else {\n      bool _result = SsoStorage.executionHooks().add(hook);\n    }\n\n    IModule(hook).onInstall(initData);\n\n    emit HookAdded(hook);\n  }\n\n  function _removeHook(address hook, bool isValidation) private {\n    if (isValidation) {\n      if (!SsoStorage.validationHooks().remove(hook)) {\n        revert Errors.HOOK_NOT_FOUND(hook, isValidation);\n      }\n    } else {\n      if (!SsoStorage.executionHooks().remove(hook)) {\n        revert Errors.HOOK_NOT_FOUND(hook, isValidation);\n      }\n    }\n\n    emit HookRemoved(hook);\n  }\n\n  function _isHook(address addr) internal view returns (bool) {\n    return SsoStorage.validationHooks().contains(addr) || SsoStorage.executionHooks().contains(addr);\n  }\n\n  function _call(address target, bytes memory data) private returns (bool success) {\n    assembly (\"memory-safe\") {\n      success := call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  function _supportsHook(address hook, bool isValidation) private view returns (bool) {\n    return\n      hook.supportsInterface(type(IModule).interfaceId) &&\n      (\n        isValidation\n          ? hook.supportsInterface(type(IValidationHook).interfaceId)\n          : hook.supportsInterface(type(IExecutionHook).interfaceId)\n      );\n  }\n}\n"
    }
}