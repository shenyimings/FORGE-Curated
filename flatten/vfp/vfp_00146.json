{
    "vfp_id": "vfp_00146",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect revert offset in LiquidityMath.sol",
            "description": "The LiquidityMath library contains assembly code in the addDelta() and addInvestment() functions that reverts with an empty error message. These functions use mstore to store error codes at memory offset 0x1c (28 bytes), but the revert instruction uses revert(0, 4), which reads from offset 0 instead of 0x1c. As a result, the error message is not correctly retrieved, and an empty revert is triggered. The root cause is incorrect memory offset usage in low-level EVM assembly. An attacker or user cannot directly exploit this, but it reduces transparency during failures by hiding meaningful error messages. The impact is reduced debuggability and user experience due to missing error details, though functionality remains intact.\n",
            "severity": "Low",
            "location": [
                "LiquidityMath.sol"
            ],
            "files": [
                "likwid-margin/src/libraries/LiquidityMath.sol"
            ]
        }
    ],
    "affected_files": {
        "LiquidityMath.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := add(and(x, 0xffffffffffffffffffffffffffffffff), signextend(15, y))\n            if shr(128, z) {\n                // revert SafeCastOverflow()\n                mstore(0, 0x93dafdf1)\n                revert(0, 4)\n            }\n        }\n    }\n\n    function addInvestment(uint256 prev, int128 amount0, int128 amount1) internal pure returns (uint256 current) {\n        assembly (\"memory-safe\") {\n            // Unpack prev into two 128-bit values\n            let prevAmount0 := shr(128, prev)\n            let prevAmount1 := and(prev, 0xffffffffffffffffffffffffffffffff)\n\n            // Add deltas, checking for int128 overflow\n            let currentAmount0 := add(signextend(15, prevAmount0), signextend(15, amount0))\n            if iszero(eq(signextend(15, currentAmount0), currentAmount0)) {\n                // revert SafeCastOverflow()\n                mstore(0, 0x93dafdf1)\n                revert(0, 4)\n            }\n\n            let currentAmount1 := add(signextend(15, prevAmount1), signextend(15, amount1))\n            if iszero(eq(signextend(15, currentAmount1), currentAmount1)) {\n                // revert SafeCastOverflow()\n                mstore(0, 0x93dafdf1)\n                revert(0, 4)\n            }\n\n            // Pack the results back into a uint256\n            current := or(\n                shl(128, and(currentAmount0, 0xffffffffffffffffffffffffffffffff)),\n                and(currentAmount1, 0xffffffffffffffffffffffffffffffff)\n            )\n        }\n    }\n}"
    }
}