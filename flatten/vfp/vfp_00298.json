{
    "vfp_id": "vfp_00298",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Payable Modifier",
            "description": "The function `WETHZapper.adjustZombieTroveWithRawETH` lacks the `payable` modifier despite being designed to receive Ether for conversion to WETH, causing transactions that send Ether to revert.\n\nThe cause is the `payable` modifier was omitted during implementation, making the function unable to accept Ether even though its internal logic expects it.\n\nAny attempt to call this function with Ether will fail, preventing the adjustment of zombie troves via the zapper. This disrupts a legitimate use case for trove recovery.\n\nUsers cannot use the zapper to fix zombie troves unless the function is redeployed with the `payable` modifier, limiting functionality and potentially leading to full redemption of affected troves.\n",
            "severity": "Low",
            "location": [
                "WETHZapper.adjustZombieTroveWithRawETH"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 52,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Possible Attacks Against Zapper Users",
            "description": "Zapper users are vulnerable to two types of attacks if trove state changes between transaction submission and execution:\n1. **Extracting Redistribution Profits**: After a redistribution makes a trove redeemable, an attacker can redeem just enough to pass minExpectedCollateral and capture the profit via slippage.\n2. **Extracting Redemption Fees**: After a high-fee redemption, an attacker can donate collateral to pass minExpectedCollateral and extract the fee via slippage.\nThese attacks exploit the fact that zapper functions use slippage buffers that absorb newly accrued value.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper.closeTroveFromCollateral",
                "_flashLoanAmount"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 53,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Sending NFTs Does Not Reset Delegation",
            "description": "Troves are NFTs and can be transferred. However, delegation settings (e.g., removeManager, receiver) are not reset on transfer. A seller could set themselves as removeManager at the last moment and later remove collateral. Buyers should ensure delegation is reset during purchase. Additionally, zappers have their own delegation settings, which must also be reviewed.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/TroveNFT.sol",
                "bold/contracts/src/Zappers/BaseZapper.sol",
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ],
                "4": [
                    "CWE-226"
                ]
            },
            "title": "Zapper Delegation Is Not Reset When a Trove Is Closed",
            "description": "When a trove is closed, delegation settings in the zapper are not reset, allowing reuse of old delegations if a new trove with the same ID is created.\n\nThe cause is that the system allows trove ID reuse and does not clear zapper delegation upon trove closure.\n\nAn attacker could create and close a trove to set malicious delegations, which persist and affect future troves with the same ID, potentially leading to loss of control.\n\nUsers may unknowingly grant control to unauthorized addresses if they reuse trove IDs, leading to potential fund loss or unauthorized actions.\n",
            "severity": "Low",
            "location": [
                "Zapper"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "CEI Pattern Violated in Adjust Trove",
            "description": "The `WETHZapper._adjustTrovePost` function sends ETH before BOLD tokens, violating the Checks-Effects-Interactions (CEI) pattern and exposing the contract to reentrancy risks.\n\nThe cause is that the order of external calls is incorrect; ETH is sent first, allowing a malicious receiver to reenter the contract.\n\nA malicious contract receiving ETH could reenter the system before state changes are finalized, potentially manipulating logic.\n\nRisk of reentrancy attacks, though mitigated by the non-reentrant nature of the BOLD token.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePost"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Inconsistent Input Validation by Zappers",
            "description": "Zapper contracts have inconsistent input validation; for example, `WETHZapper` enforces non-zero debt increases while `GasCompZapper` does not.\n\nThe cause is lack of shared validation logic across zapper implementations.\n\nWhile harmless in practice, inconsistent checks reduce code reliability and maintainability.\n\nPotential for future bugs if validation logic diverges further.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePre",
                "GasCompZapper._adjustTrovePre"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol",
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Misleading Function Names in Zapper",
            "description": "Functions in `GasCompZapper` use names like `adjustTroveWithRawETH` that imply ETH handling, but the contract does not operate with raw ETH.\n\nThe cause is inconsistent naming across zapper implementations.\n\nMisleading names could cause developers to misuse the functions or misunderstand their behavior.\n\nIncreased risk of integration errors and developer confusion.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.adjustTroveWithRawETH"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Unimplemented Function Can Be Called",
            "description": "The contracts GasCompZapper and WETHZapper define functions `receiveFlashLoanOnOpenLeveragedTrove`, `receiveFlashLoanOnLeverUpTrove`, and `receiveFlashLoanOnLeverDownTrove` with empty function bodies. These functions are not marked as virtual or intended to be overridden in derived contracts, yet they can still be called externally. Since the functions perform no operations, calling them results in silent success without any side effects. This could mislead callers into believing the functions perform meaningful actions. If these functions are not meant to be called, they should revert to prevent misuse and clarify intent.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.sol",
                "WETHZapper.sol"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol",
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        }
    ],
    "affected_files": {
        "TroveNFT.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./Interfaces/ITroveNFT.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\n\nimport {IMetadataNFT} from \"./NFTMetadata/MetadataNFT.sol\";\nimport {ITroveManager} from \"./Interfaces/ITroveManager.sol\";\n\ncontract TroveNFT is ERC721, ITroveNFT {\n    ITroveManager public immutable troveManager;\n    IERC20Metadata internal immutable collToken;\n    IBoldToken internal immutable boldToken;\n\n    IMetadataNFT public immutable metadataNFT;\n\n    constructor(IAddressesRegistry _addressesRegistry)\n        ERC721(\n            string.concat(\"Liquity V2 - \", _addressesRegistry.collToken().name()),\n            string.concat(\"LV2_\", _addressesRegistry.collToken().symbol())\n        )\n    {\n        troveManager = _addressesRegistry.troveManager();\n        collToken = _addressesRegistry.collToken();\n        metadataNFT = _addressesRegistry.metadataNFT();\n        boldToken = _addressesRegistry.boldToken();\n    }\n\n    function tokenURI(uint256 _tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {\n        LatestTroveData memory latestTroveData = troveManager.getLatestTroveData(_tokenId);\n\n        IMetadataNFT.TroveData memory troveData = IMetadataNFT.TroveData({\n            _tokenId: _tokenId,\n            _owner: ownerOf(_tokenId),\n            _collToken: address(collToken),\n            _boldToken: address(boldToken),\n            _collAmount: latestTroveData.entireColl,\n            _debtAmount: latestTroveData.entireDebt,\n            _interestRate: latestTroveData.annualInterestRate,\n            _status: troveManager.getTroveStatus(_tokenId)\n        });\n\n        return metadataNFT.uri(troveData);\n    }\n\n    function mint(address _owner, uint256 _troveId) external override {\n        _requireCallerIsTroveManager();\n        _mint(_owner, _troveId);\n    }\n\n    function burn(uint256 _troveId) external override {\n        _requireCallerIsTroveManager();\n        _burn(_troveId);\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"TroveNFT: Caller is not the TroveManager contract\");\n    }\n}\n",
        "GasCompZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./BaseZapper.sol\";\nimport \"../Dependencies/Constants.sol\";\n\ncontract GasCompZapper is BaseZapper {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n\n    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)\n        BaseZapper(_addressesRegistry, _flashLoanProvider, _exchange)\n    {\n        collToken = _addressesRegistry.collToken();\n        require(address(WETH) != address(collToken), \"GCZ: Wrong coll branch\");\n\n        // Approve WETH to BorrowerOperations\n        WETH.approve(address(borrowerOperations), type(uint256).max);\n        // Approve coll to BorrowerOperations\n        collToken.approve(address(borrowerOperations), type(uint256).max);\n        // Approve Coll to exchange module (for closeTroveFromCollateral)\n        collToken.approve(address(_exchange), type(uint256).max);\n    }\n\n    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256) {\n        require(msg.value == ETH_GAS_COMPENSATION, \"GCZ: Wrong ETH\");\n        require(\n            _params.batchManager == address(0) || _params.annualInterestRate == 0,\n            \"GCZ: Cannot choose interest if joining a batch\"\n        );\n\n        // Convert ETH to WETH\n        WETH.deposit{value: msg.value}();\n\n        // Pull coll\n        collToken.safeTransferFrom(msg.sender, address(this), _params.collAmount);\n\n        uint256 troveId;\n        // Include sender in index\n        uint256 index = _getTroveIndex(_params.ownerIndex);\n        if (_params.batchManager == address(0)) {\n            troveId = borrowerOperations.openTrove(\n                _params.owner,\n                index,\n                _params.collAmount,\n                _params.boldAmount,\n                _params.upperHint,\n                _params.lowerHint,\n                _params.annualInterestRate,\n                _params.maxUpfrontFee,\n                // Add this contract as add/receive manager to be able to fully adjust trove,\n                // while keeping the same management functionality\n                address(this), // add manager\n                address(this), // remove manager\n                address(this) // receiver for remove manager\n            );\n        } else {\n            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory\n                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations\n                    .OpenTroveAndJoinInterestBatchManagerParams({\n                    owner: _params.owner,\n                    ownerIndex: index,\n                    collAmount: _params.collAmount,\n                    boldAmount: _params.boldAmount,\n                    upperHint: _params.upperHint,\n                    lowerHint: _params.lowerHint,\n                    interestBatchManager: _params.batchManager,\n                    maxUpfrontFee: _params.maxUpfrontFee,\n                    // Add this contract as add/receive manager to be able to fully adjust trove,\n                    // while keeping the same management functionality\n                    addManager: address(this), // add manager\n                    removeManager: address(this), // remove manager\n                    receiver: address(this) // receiver for remove manager\n                });\n            troveId =\n                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);\n        }\n\n        boldToken.transfer(msg.sender, _params.boldAmount);\n\n        // Set add/remove managers\n        _setAddManager(troveId, _params.addManager);\n        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);\n\n        return troveId;\n    }\n\n    function addColl(uint256 _troveId, uint256 _amount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n\n        IBorrowerOperations borrowerOperationsCached = borrowerOperations;\n\n        // Pull coll\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        borrowerOperationsCached.addColl(_troveId, _amount);\n    }\n\n    function withdrawColl(uint256 _troveId, uint256 _amount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawColl(_troveId, _amount);\n\n        // Send coll left\n        collToken.safeTransfer(receiver, _amount);\n    }\n\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);\n\n        // Send Bold\n        boldToken.transfer(receiver, _boldAmount);\n    }\n\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);\n\n        // Pull Bold\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n\n        borrowerOperations.repayBold(_troveId, _boldAmount);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external {\n        InitialBalances memory initialBalances;\n        address receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function adjustZombieTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        InitialBalances memory initialBalances;\n        address receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustZombieTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _upperHint, _lowerHint, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function _adjustTrovePre(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        InitialBalances memory _initialBalances\n    ) internal returns (address) {\n        address receiver = _checkAdjustTroveManagers(_troveId, _collChange, _isCollIncrease, _isDebtIncrease);\n\n        // Set initial balances to make sure there are not lefovers\n        _setInitialTokensAndBalances(collToken, boldToken, _initialBalances);\n\n        // Pull coll\n        if (_isCollIncrease) {\n            collToken.safeTransferFrom(msg.sender, address(this), _collChange);\n        }\n\n        // Pull Bold\n        if (!_isDebtIncrease) {\n            boldToken.transferFrom(msg.sender, address(this), _boldChange);\n        }\n\n        return receiver;\n    }\n\n    function _adjustTrovePost(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        address _receiver,\n        InitialBalances memory _initialBalances\n    ) internal {\n        // Send coll left\n        if (!_isCollIncrease) {\n            collToken.safeTransfer(_receiver, _collChange);\n        }\n\n        // Send Bold\n        if (_isDebtIncrease) {\n            boldToken.transfer(_receiver, _boldChange);\n        }\n\n        // return leftovers to user\n        _returnLeftovers(_initialBalances);\n    }\n\n    function closeTroveToRawETH(uint256 _troveId) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        // pull Bold for repayment\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        boldToken.transferFrom(msg.sender, address(this), trove.entireDebt);\n\n        borrowerOperations.closeTrove(_troveId);\n\n        // Send coll left\n        collToken.safeTransfer(receiver, trove.entireColl);\n\n        // Send gas compensation\n        WETH.withdraw(ETH_GAS_COMPENSATION);\n        (bool success,) = receiver.call{value: ETH_GAS_COMPENSATION}(\"\");\n        require(success, \"GCZ: Sending ETH failed\");\n    }\n\n    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount, uint256 _minExpectedCollateral)\n        external\n        override\n    {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        CloseTroveParams memory params = CloseTroveParams({\n            troveId: _troveId,\n            flashLoanAmount: _flashLoanAmount,\n            minExpectedCollateral: _minExpectedCollateral,\n            receiver: receiver\n        });\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        initialBalances.tokens[0] = collToken;\n        initialBalances.tokens[1] = boldToken;\n        _setInitialBalancesAndReceiver(initialBalances, receiver);\n\n        // Flash loan coll\n        flashLoanProvider.makeFlashLoan(\n            collToken, _flashLoanAmount, IFlashLoanProvider.Operation.CloseTrove, abi.encode(params)\n        );\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function receiveFlashLoanOnCloseTroveFromCollateral(\n        CloseTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external {\n        require(msg.sender == address(flashLoanProvider), \"GCZ: Caller not FlashLoan provider\");\n\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_params.troveId);\n        uint256 collLeft = trove.entireColl - _params.flashLoanAmount;\n        require(collLeft >= _params.minExpectedCollateral, \"GCZ: Not enough collateral received\");\n\n        // Swap Coll from flash loan to Bold, so we can repay and close trove\n        // We swap the flash loan minus the flash loan fee\n        exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n\n        // We asked for a min of entireDebt in swapToBold call above, so we don’t check again here:\n        //uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n        //require(receivedBoldAmount >= trove.entireDebt, \"GCZ: Not enough BOLD obtained to repay\");\n\n        borrowerOperations.closeTrove(_params.troveId);\n\n        // Send coll back to return flash loan\n        collToken.safeTransfer(address(flashLoanProvider), _params.flashLoanAmount);\n\n        // Send coll left\n        collToken.safeTransfer(_params.receiver, collLeft);\n\n        // Send gas compensation\n        WETH.withdraw(ETH_GAS_COMPENSATION);\n        (bool success,) = _params.receiver.call{value: ETH_GAS_COMPENSATION}(\"\");\n        require(success, \"GCZ: Sending ETH failed\");\n    }\n\n    receive() external payable {}\n\n    // Unimplemented flash loan receive functions for leverage\n    function receiveFlashLoanOnOpenLeveragedTrove(\n        ILeverageZapper.OpenLeveragedTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverUpTrove(\n        ILeverageZapper.LeverUpTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverDownTrove(\n        ILeverageZapper.LeverDownTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n}\n",
        "BaseZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"../Interfaces/IWETH.sol\";\nimport \"../Interfaces/IAddressesRegistry.sol\";\nimport \"../Interfaces/IBorrowerOperations.sol\";\nimport \"../Dependencies/AddRemoveManagers.sol\";\nimport \"./LeftoversSweep.sol\";\nimport \"./Interfaces/IFlashLoanProvider.sol\";\nimport \"./Interfaces/IFlashLoanReceiver.sol\";\nimport \"./Interfaces/IExchange.sol\";\nimport \"./Interfaces/IZapper.sol\";\n\nabstract contract BaseZapper is AddRemoveManagers, LeftoversSweep, IFlashLoanReceiver, IZapper {\n    IBorrowerOperations public immutable borrowerOperations; // LST branch (i.e., not WETH as collateral)\n    ITroveManager public immutable troveManager;\n    IWETH public immutable WETH;\n    IBoldToken public immutable boldToken;\n\n    IFlashLoanProvider public immutable flashLoanProvider;\n    IExchange public immutable exchange;\n\n    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)\n        AddRemoveManagers(_addressesRegistry)\n    {\n        borrowerOperations = _addressesRegistry.borrowerOperations();\n        troveManager = _addressesRegistry.troveManager();\n        boldToken = _addressesRegistry.boldToken();\n        WETH = _addressesRegistry.WETH();\n\n        flashLoanProvider = _flashLoanProvider;\n        exchange = _exchange;\n    }\n\n    function _getTroveIndex(address _sender, uint256 _ownerIndex) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(_sender, _ownerIndex)));\n    }\n\n    function _getTroveIndex(uint256 _ownerIndex) internal view returns (uint256) {\n        return _getTroveIndex(msg.sender, _ownerIndex);\n    }\n\n    function _requireZapperIsReceiver(uint256 _troveId) internal view {\n        (, address receiver) = borrowerOperations.removeManagerReceiverOf(_troveId);\n        require(receiver == address(this), \"BZ: Zapper is not receiver for this trove\");\n    }\n\n    function _checkAdjustTroveManagers(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        bool _isDebtIncrease\n    ) internal view returns (address) {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = owner;\n\n        if ((!_isCollIncrease && _collChange > 0) || _isDebtIncrease) {\n            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n            _requireZapperIsReceiver(_troveId);\n        } else {\n            // RemoveManager assumes AddManager, so if the former is set, there's no need to check the latter\n            _requireSenderIsOwnerOrAddManager(_troveId, owner);\n            // No need to check the type of trove change for two reasons:\n            // - If the check above fails, it means sender is not owner, nor AddManager, nor RemoveManager.\n            //   An independent 3rd party should not be allowed here.\n            // - If it's not collIncrease or debtDecrease, _requireNonZeroAdjustment would revert\n        }\n\n        return receiver;\n    }\n}\n",
        "WETHZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"./BaseZapper.sol\";\nimport \"../Dependencies/Constants.sol\";\n\ncontract WETHZapper is BaseZapper {\n    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)\n        BaseZapper(_addressesRegistry, _flashLoanProvider, _exchange)\n    {\n        require(address(WETH) == address(_addressesRegistry.collToken()), \"WZ: Wrong coll branch\");\n\n        // Approve coll to BorrowerOperations\n        WETH.approve(address(borrowerOperations), type(uint256).max);\n        // Approve Coll to exchange module (for closeTroveFromCollateral)\n        WETH.approve(address(_exchange), type(uint256).max);\n    }\n\n    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256) {\n        require(msg.value > ETH_GAS_COMPENSATION, \"WZ: Insufficient ETH\");\n        require(\n            _params.batchManager == address(0) || _params.annualInterestRate == 0,\n            \"WZ: Cannot choose interest if joining a batch\"\n        );\n\n        // Convert ETH to WETH\n        WETH.deposit{value: msg.value}();\n\n        uint256 troveId;\n        // Include sender in index\n        uint256 index = _getTroveIndex(_params.ownerIndex);\n        if (_params.batchManager == address(0)) {\n            troveId = borrowerOperations.openTrove(\n                _params.owner,\n                index,\n                msg.value - ETH_GAS_COMPENSATION,\n                _params.boldAmount,\n                _params.upperHint,\n                _params.lowerHint,\n                _params.annualInterestRate,\n                _params.maxUpfrontFee,\n                // Add this contract as add/receive manager to be able to fully adjust trove,\n                // while keeping the same management functionality\n                address(this), // add manager\n                address(this), // remove manager\n                address(this) // receiver for remove manager\n            );\n        } else {\n            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory\n                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations\n                    .OpenTroveAndJoinInterestBatchManagerParams({\n                    owner: _params.owner,\n                    ownerIndex: index,\n                    collAmount: msg.value - ETH_GAS_COMPENSATION,\n                    boldAmount: _params.boldAmount,\n                    upperHint: _params.upperHint,\n                    lowerHint: _params.lowerHint,\n                    interestBatchManager: _params.batchManager,\n                    maxUpfrontFee: _params.maxUpfrontFee,\n                    // Add this contract as add/receive manager to be able to fully adjust trove,\n                    // while keeping the same management functionality\n                    addManager: address(this), // add manager\n                    removeManager: address(this), // remove manager\n                    receiver: address(this) // receiver for remove manager\n                });\n            troveId =\n                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);\n        }\n\n        boldToken.transfer(msg.sender, _params.boldAmount);\n\n        // Set add/remove managers\n        _setAddManager(troveId, _params.addManager);\n        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);\n\n        return troveId;\n    }\n\n    function addCollWithRawETH(uint256 _troveId) external payable {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n        // Convert ETH to WETH\n        WETH.deposit{value: msg.value}();\n\n        borrowerOperations.addColl(_troveId, msg.value);\n    }\n\n    function withdrawCollToRawETH(uint256 _troveId, uint256 _amount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawColl(_troveId, _amount);\n\n        // Convert WETH to ETH\n        WETH.withdraw(_amount);\n        (bool success,) = receiver.call{value: _amount}(\"\");\n        require(success, \"WZ: Sending ETH failed\");\n    }\n\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);\n\n        // Send Bold\n        boldToken.transfer(receiver, _boldAmount);\n    }\n\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(WETH, boldToken, initialBalances);\n\n        // Pull Bold\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n\n        borrowerOperations.repayBold(_troveId, _boldAmount);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function adjustTroveWithRawETH(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external payable {\n        InitialBalances memory initialBalances;\n        address payable receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function adjustZombieTroveWithRawETH(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external payable {\n        InitialBalances memory initialBalances;\n        address payable receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustZombieTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _upperHint, _lowerHint, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function _adjustTrovePre(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        InitialBalances memory _initialBalances\n    ) internal returns (address payable) {\n        if (_isCollIncrease) {\n            require(_collChange == msg.value, \"WZ: Wrong coll amount\");\n        } else {\n            require(msg.value == 0, \"WZ: Not adding coll, no ETH should be received\");\n        }\n\n        address payable receiver =\n            payable(_checkAdjustTroveManagers(_troveId, _collChange, _isCollIncrease, _isDebtIncrease));\n\n        // Set initial balances to make sure there are not lefovers\n        _setInitialTokensAndBalances(WETH, boldToken, _initialBalances);\n\n        // ETH -> WETH\n        if (_isCollIncrease) {\n            WETH.deposit{value: _collChange}();\n        }\n\n        // Pull Bold\n        if (!_isDebtIncrease) {\n            boldToken.transferFrom(msg.sender, address(this), _boldChange);\n        }\n\n        return receiver;\n    }\n\n    function _adjustTrovePost(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        address payable _receiver,\n        InitialBalances memory _initialBalances\n    ) internal {\n        // Send Bold\n        if (_isDebtIncrease) {\n            boldToken.transfer(_receiver, _boldChange);\n        }\n\n        // return BOLD leftovers to user (trying to repay more than possible)\n        uint256 currentBoldBalance = boldToken.balanceOf(address(this));\n        if (currentBoldBalance > _initialBalances.balances[1]) {\n            boldToken.transfer(_initialBalances.receiver, currentBoldBalance - _initialBalances.balances[1]);\n        }\n        // There shouldn’t be Collateral leftovers, everything sent should end up in the trove\n        // But ETH and WETH balance can be non-zero if someone accidentally send it to this contract\n\n        // WETH -> ETH\n        if (!_isCollIncrease && _collChange > 0) {\n            WETH.withdraw(_collChange);\n            (bool success,) = _receiver.call{value: _collChange}(\"\");\n            require(success, \"WZ: Sending ETH failed\");\n        }\n    }\n\n    function closeTroveToRawETH(uint256 _troveId) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        // pull Bold for repayment\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        boldToken.transferFrom(msg.sender, address(this), trove.entireDebt);\n\n        borrowerOperations.closeTrove(_troveId);\n\n        WETH.withdraw(trove.entireColl + ETH_GAS_COMPENSATION);\n        (bool success,) = receiver.call{value: trove.entireColl + ETH_GAS_COMPENSATION}(\"\");\n        require(success, \"WZ: Sending ETH failed\");\n    }\n\n    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount, uint256 _minExpectedCollateral)\n        external\n        override\n    {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        CloseTroveParams memory params = CloseTroveParams({\n            troveId: _troveId,\n            flashLoanAmount: _flashLoanAmount,\n            minExpectedCollateral: _minExpectedCollateral,\n            receiver: receiver\n        });\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        initialBalances.tokens[0] = WETH;\n        initialBalances.tokens[1] = boldToken;\n        _setInitialBalancesAndReceiver(initialBalances, receiver);\n\n        // Flash loan coll\n        flashLoanProvider.makeFlashLoan(\n            WETH, _flashLoanAmount, IFlashLoanProvider.Operation.CloseTrove, abi.encode(params)\n        );\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function receiveFlashLoanOnCloseTroveFromCollateral(\n        CloseTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external {\n        require(msg.sender == address(flashLoanProvider), \"WZ: Caller not FlashLoan provider\");\n\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_params.troveId);\n        uint256 collLeft = trove.entireColl - _params.flashLoanAmount;\n        require(collLeft >= _params.minExpectedCollateral, \"WZ: Not enough collateral received\");\n\n        // Swap Coll from flash loan to Bold, so we can repay and close trove\n        // We swap the flash loan minus the flash loan fee\n        exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n\n        // We asked for a min of entireDebt in swapToBold call above, so we don’t check again here:\n        // uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n        //require(receivedBoldAmount >= trove.entireDebt, \"WZ: Not enough BOLD obtained to repay\");\n\n        borrowerOperations.closeTrove(_params.troveId);\n\n        // Send coll back to return flash loan\n        WETH.transfer(address(flashLoanProvider), _params.flashLoanAmount);\n\n        uint256 ethToSendBack = collLeft + ETH_GAS_COMPENSATION;\n        // Send coll left and gas compensation\n        WETH.withdraw(ethToSendBack);\n        (bool success,) = _params.receiver.call{value: ethToSendBack}(\"\");\n        require(success, \"WZ: Sending ETH failed\");\n    }\n\n    receive() external payable {}\n\n    // Unimplemented flash loan receive functions for leverage\n    function receiveFlashLoanOnOpenLeveragedTrove(\n        ILeverageZapper.OpenLeveragedTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverUpTrove(\n        ILeverageZapper.LeverUpTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverDownTrove(\n        ILeverageZapper.LeverDownTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n}\n"
    }
}