{
    "vfp_id": "vfp_00244",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-274"
                ]
            },
            "title": "Enough Admins Check",
            "description": "The Governor contract does not enforce that at least one admin remains when ownership is renounced or when permissionless execution is disabled.\nCause: Missing safeguards during admin removal or ownership renouncement.\nExploitation: All admins could be removed or ownership renounced without ensuring at least one execution admin remains.\nImpact: The governor could become permanently locked, rendering the protocol unupgradable and governance inoperable.\n",
            "severity": "Low",
            "location": [
                "Governor"
            ],
            "files": [
                "permissionless/contracts/market/Governor.sol"
            ]
        }
    ],
    "affected_files": {
        "Governor.sol": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IGovernor} from \"../interfaces/IGovernor.sol\";\nimport {ITimeLock} from \"../interfaces/ITimeLock.sol\";\nimport {AP_GOVERNOR} from \"../libraries/ContractLiterals.sol\";\nimport {TimeLock} from \"./TimeLock.sol\";\n\n/// @title Governor\n/// @notice Extends Uniswap's timelock contract with batch queueing/execution and reworked permissions model where,\n///         instead of a single admin to perform all actions, there are multiple queue admins, a single veto admin,\n///         and permissionless execution (which can optionally be restricted to non-contract accounts to prevent\n///         unintended execution of governance proposals inside protocol functions)\ncontract Governor is Ownable2Step, IGovernor {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Contract version\n    uint256 public constant override version = 3_10;\n\n    /// @notice Contract type\n    bytes32 public constant override contractType = AP_GOVERNOR;\n\n    /// @inheritdoc IGovernor\n    address public immutable override timeLock;\n\n    /// @dev Set of queue admins\n    EnumerableSet.AddressSet internal _queueAdminsSet;\n\n    /// @dev Set of execution admins\n    EnumerableSet.AddressSet internal _executionAdminsSet;\n\n    /// @inheritdoc IGovernor\n    address public override vetoAdmin;\n\n    /// @inheritdoc IGovernor\n    bool public override isPermissionlessExecutionAllowed;\n\n    /// @inheritdoc IGovernor\n    mapping(uint256 => BatchInfo) public override batchInfo;\n\n    /// @inheritdoc IGovernor\n    mapping(bytes32 => BatchedTxInfo) public override batchedTxInfo;\n\n    /// @dev Ensures that function can only be called by the timelock contract\n    modifier timeLockOnly() {\n        if (msg.sender != timeLock) revert CallerNotTimelockException();\n        _;\n    }\n\n    /// @dev Ensures that function is called by one of queue admins\n    modifier queueAdminOnly() {\n        if (msg.sender != owner() && !_queueAdminsSet.contains(msg.sender)) revert CallerNotQueueAdminException();\n        _;\n    }\n\n    /// @dev Ensures that function is called by one of execution admins, unless permissionless execution is allowed\n    modifier executionAdminOnly() {\n        if (!isPermissionlessExecutionAllowed && msg.sender != owner() && !_executionAdminsSet.contains(msg.sender)) {\n            revert CallerNotExecutionAdminException();\n        }\n        _;\n    }\n\n    /// @dev Ensures that function is called by the veto admin\n    modifier vetoAdminOnly() {\n        if (msg.sender != vetoAdmin) revert CallerNotVetoAdminException();\n        _;\n    }\n\n    /// @notice Constructs a new governor contract\n    /// @param _owner Contract owner, automatically becomes the queue and execution admin\n    /// @param _vetoAdmin Address to set as the veto admin, can't be `address(0)`\n    /// @param _delay Delay of the timelock\n    /// @param _allowPermissionlessExecution Whether to allow permissionless execution\n    constructor(address _owner, address _vetoAdmin, uint256 _delay, bool _allowPermissionlessExecution) {\n        timeLock = address(new TimeLock(address(this), _delay));\n\n        _transferOwnership(_owner);\n        _updateVetoAdmin(_vetoAdmin);\n\n        if (_allowPermissionlessExecution) {\n            isPermissionlessExecutionAllowed = true;\n            emit AllowPermissionlessExecution();\n        } else {\n            emit ForbidPermissionlessExecution();\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function queueAdmins() external view override returns (address[] memory) {\n        return _queueAdminsSet.values();\n    }\n\n    /// @inheritdoc IGovernor\n    function executionAdmins() external view override returns (address[] memory) {\n        return _executionAdminsSet.values();\n    }\n\n    // ------- //\n    // ACTIONS //\n    // ------- //\n\n    /// @inheritdoc IGovernor\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external override queueAdminOnly returns (bytes32 txHash) {\n        txHash = _getTxHash(target, value, signature, data, eta);\n        if (ITimeLock(timeLock).queuedTransactions(txHash)) revert TransactionAlreadyQueuedException();\n\n        BatchInfo memory info = batchInfo[block.number];\n        if (info.initiator != address(0)) {\n            if (msg.sender != info.initiator) revert CallerNotBatchInitiatorException();\n            if (eta != info.eta) revert ETAMistmatchException();\n\n            batchedTxInfo[txHash] = BatchedTxInfo({batchBlock: uint64(block.number), index: info.length});\n            batchInfo[block.number].length = info.length + 1;\n        }\n\n        ITimeLock(timeLock).queueTransaction(target, value, signature, data, eta);\n    }\n\n    /// @inheritdoc IGovernor\n    function startBatch(uint80 eta) external override queueAdminOnly {\n        if (batchInfo[block.number].initiator != address(0)) revert BatchAlreadyStartedException();\n        batchInfo[block.number] = BatchInfo({initiator: msg.sender, length: 0, eta: eta});\n        emit QueueBatch(msg.sender, block.number);\n    }\n\n    /// @inheritdoc IGovernor\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable override executionAdminOnly returns (bytes memory) {\n        return _transactionAction(target, value, signature, data, eta, TxAction.Execute);\n    }\n\n    /// @inheritdoc IGovernor\n    function executeBatch(TxParams[] calldata txs) external payable override executionAdminOnly {\n        uint256 batchBlock = _batchAction(txs, TxAction.Execute);\n        emit ExecuteBatch(msg.sender, batchBlock);\n    }\n\n    /// @inheritdoc IGovernor\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external override vetoAdminOnly {\n        _transactionAction(target, value, signature, data, eta, TxAction.Cancel);\n    }\n\n    /// @inheritdoc IGovernor\n    function cancelBatch(TxParams[] calldata txs) external override vetoAdminOnly {\n        uint256 batchBlock = _batchAction(txs, TxAction.Cancel);\n        emit CancelBatch(msg.sender, batchBlock);\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    /// @inheritdoc IGovernor\n    function addQueueAdmin(address admin) external override timeLockOnly {\n        if (admin == address(0)) revert AdminCantBeZeroAddressException();\n        if (_queueAdminsSet.add(admin)) emit AddQueueAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function removeQueueAdmin(address admin) external override timeLockOnly {\n        if (_queueAdminsSet.remove(admin)) emit RemoveQueueAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function addExecutionAdmin(address admin) external override timeLockOnly {\n        if (admin == address(0)) revert AdminCantBeZeroAddressException();\n        if (_executionAdminsSet.add(admin)) emit AddExecutionAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function removeExecutionAdmin(address admin) external override timeLockOnly {\n        if (_executionAdminsSet.remove(admin)) emit RemoveExecutionAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function updateVetoAdmin(address admin) external override timeLockOnly {\n        _updateVetoAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function allowPermissionlessExecution() external override timeLockOnly {\n        if (!isPermissionlessExecutionAllowed) {\n            isPermissionlessExecutionAllowed = true;\n            emit AllowPermissionlessExecution();\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function forbidPermissionlessExecution() external override timeLockOnly {\n        if (isPermissionlessExecutionAllowed) {\n            isPermissionlessExecutionAllowed = false;\n            emit ForbidPermissionlessExecution();\n        }\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    /// @dev Executes or cancels a transaction, ensures that it is not part of any batch\n    function _transactionAction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta,\n        TxAction action\n    ) internal returns (bytes memory result) {\n        bytes32 txHash = _getTxHash(target, value, signature, data, eta);\n        if (batchedTxInfo[txHash].batchBlock != 0) revert CantPerformActionOutsideBatchException();\n        return _performAction(target, value, signature, data, eta, action);\n    }\n\n    /// @dev Executes or cancels a batch of transactions, ensures that all transactions are processed in the correct order\n    function _batchAction(TxParams[] calldata txs, TxAction action) internal returns (uint256 batchBlock) {\n        uint256 len = txs.length;\n        if (len == 0) revert IncorrectBatchException();\n\n        batchBlock = batchedTxInfo[_getTxHash(txs[0])].batchBlock;\n        if (batchBlock == 0) revert IncorrectBatchException();\n\n        if (len != batchInfo[batchBlock].length) revert IncorrectBatchException();\n\n        for (uint256 i; i < len; ++i) {\n            TxParams calldata tx_ = txs[i];\n            bytes32 txHash = _getTxHash(tx_);\n\n            BatchedTxInfo memory info = batchedTxInfo[txHash];\n            if (info.batchBlock != batchBlock || info.index != i) revert UnexpectedTransactionException(txHash);\n\n            _performAction(tx_.target, tx_.value, tx_.signature, tx_.data, tx_.eta, action);\n            delete batchedTxInfo[txHash];\n        }\n\n        delete batchInfo[batchBlock];\n    }\n\n    /// @dev Executes or cancels a transaction\n    function _performAction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta,\n        TxAction action\n    ) internal returns (bytes memory result) {\n        if (action == TxAction.Execute) {\n            result = ITimeLock(timeLock).executeTransaction{value: value}(target, value, signature, data, eta);\n        } else {\n            ITimeLock(timeLock).cancelTransaction(target, value, signature, data, eta);\n        }\n    }\n\n    /// @dev `updateVetoAdmin` implementation\n    function _updateVetoAdmin(address admin) internal {\n        if (admin == address(0)) revert AdminCantBeZeroAddressException();\n        if (vetoAdmin != admin) {\n            vetoAdmin = admin;\n            emit UpdateVetoAdmin(admin);\n        }\n    }\n\n    /// @dev Computes transaction hash\n    function _getTxHash(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(target, value, signature, data, eta));\n    }\n\n    /// @dev Computes transaction hash\n    function _getTxHash(TxParams calldata tx_) internal pure returns (bytes32) {\n        return _getTxHash(tx_.target, tx_.value, tx_.signature, tx_.data, tx_.eta);\n    }\n}\n"
    }
}