{
    "vfp_id": "vfp_00079",
    "project_name": "Very Liquid Vaults Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Incorrect Order of Operations Causes Permanent Reduction in Protocol Fees",
            "description": "The vulnerability arises in the `_mintPerformanceFee` function of the `PerformanceVault` contract, where the high-water-mark (HWM) is updated before minting fee shares. This order of operations causes a dilution of the price per share (PPS) after the fee shares are minted, which reduces the PPS below the newly set HWM. Since the HWM is only updated when the current PPS exceeds it, the protocol will not charge performance fees again until the PPS surpasses this inflated HWM. The root cause is the incorrect sequence of updating the HWM prior to minting, which breaks the economic model. An attacker is not required to exploit this; normal operation after a fee minting event will result in permanent loss of fee revenue. The impact is a long-term reduction in protocol income, undermining the sustainability of the fee mechanism.\n",
            "severity": "Medium",
            "location": [
                "PerformanceVault.sol::L105-L112"
            ],
            "files": [
                "very-liquid-vaults/src/utils/PerformanceVault.sol"
            ]
        }
    ],
    "affected_files": {
        "PerformanceVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {ERC4626Upgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {BaseVault} from \"@src/utils/BaseVault.sol\";\n\n/// @title PerformanceVault\n/// @custom:security-contact security@size.credit\n/// @author Size (https://size.credit/)\n/// @notice Vault that collects performance fees\n/// @dev Reference https://docs.dhedge.org/dhedge-protocol/vault-fees/performance-fees\nabstract contract PerformanceVault is BaseVault {\n  uint256 public constant PERCENT = 1e18;\n  uint256 public constant MAXIMUM_PERFORMANCE_FEE_PERCENT = 0.5e18;\n\n  // STORAGE\n  /// @custom:storage-location erc7201:size.storage.PerformanceVault\n  struct PerformanceVaultStorage {\n    uint256 _highWaterMark;\n    uint256 _performanceFeePercent;\n    address _feeRecipient;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"size.storage.PerformanceVault\")) - 1)) & ~bytes32(uint256(0xff));\n  bytes32 private constant PerformanceVaultStorageLocation = 0x804999a460baf311df4304e76bf097cd616ad3bef609b825c3e42a145296b200;\n\n  function _getPerformanceVaultStorage() private pure returns (PerformanceVaultStorage storage $) {\n    assembly {\n      $.slot := PerformanceVaultStorageLocation\n    }\n  }\n\n  // ERRORS\n  error PerformanceFeePercentTooHigh(uint256 performanceFeePercent, uint256 maximumPerformanceFeePercent);\n\n  // EVENTS\n  event PerformanceFeePercentSet(uint256 indexed performanceFeePercentBefore, uint256 indexed performanceFeePercentAfter);\n  event FeeRecipientSet(address indexed feeRecipientBefore, address indexed feeRecipientAfter);\n  event HighWaterMarkUpdated(uint256 highWaterMarkBefore, uint256 highWaterMarkAfter);\n  event PerformanceFeeMinted(address indexed to, uint256 shares, uint256 assets);\n\n  // INITIALIZER\n  /// @notice Initializes the PerformanceVault with a fee recipient and performance fee percent\n  // solhint-disable-next-line func-name-mixedcase\n  function __PerformanceVault_init(address feeRecipient_, uint256 performanceFeePercent_) internal onlyInitializing {\n    _setFeeRecipient(feeRecipient_);\n    _setPerformanceFeePercent(performanceFeePercent_);\n  }\n\n  // MODIFIERS\n  /// @notice Modifier to ensure the performance fee is minted before the function is executed\n  modifier mintPerformanceFee() {\n    _mintPerformanceFee();\n    _;\n  }\n\n  // INTERNAL/PRIVATE\n  /// @notice Sets the performance fee percent\n  /// @dev Reverts if the performance fee percent is greater than the maximum performance fee percent\n  function _setPerformanceFeePercent(uint256 performanceFeePercent_) internal {\n    if (performanceFeePercent_ > MAXIMUM_PERFORMANCE_FEE_PERCENT) revert PerformanceFeePercentTooHigh(performanceFeePercent_, MAXIMUM_PERFORMANCE_FEE_PERCENT);\n\n    PerformanceVaultStorage storage $ = _getPerformanceVaultStorage();\n    uint256 performanceFeePercentBefore = $._performanceFeePercent;\n    uint256 highWaterMarkBefore = $._highWaterMark;\n    uint256 currentPPS = _pps();\n    // slither-disable-next-line incorrect-equality\n    if (performanceFeePercentBefore == 0 && performanceFeePercent_ > 0 && highWaterMarkBefore < currentPPS) _setHighWaterMark(currentPPS);\n\n    $._performanceFeePercent = performanceFeePercent_;\n    emit PerformanceFeePercentSet(performanceFeePercentBefore, performanceFeePercent_);\n  }\n\n  /// @notice Sets the fee recipient\n  function _setFeeRecipient(address feeRecipient_) internal {\n    if (feeRecipient_ == address(0)) revert NullAddress();\n\n    PerformanceVaultStorage storage $ = _getPerformanceVaultStorage();\n    address feeRecipientBefore = $._feeRecipient;\n    $._feeRecipient = feeRecipient_;\n    emit FeeRecipientSet(feeRecipientBefore, feeRecipient_);\n  }\n\n  /// @notice Returns the price per share\n  function _pps() internal view returns (uint256) {\n    uint256 totalAssets_ = totalAssets();\n    uint256 totalSupply_ = totalSupply();\n    return totalSupply_ > 0 ? Math.mulDiv(totalAssets_, PERCENT, totalSupply_) : PERCENT;\n  }\n\n  /// @notice Mints performance fees if applicable\n  /// @dev Using `convertToShares(feeShares)` would not be correct because once those shares are minted, the PPS changes,\n  ///        and the asset value of the minted shares is different to feeAssets.\n  ///        We solve the equation: feeAssets = feeShares * (totalAssets + 1) / (totalSupply + 1 + feeShares)\n  ///        Basically feeAssets = convertToAssets(feeShares), but adding feeShares to the totalSupply part during the calculation\n  function _mintPerformanceFee() private {\n    PerformanceVaultStorage storage $ = _getPerformanceVaultStorage();\n    if ($._performanceFeePercent == 0) return;\n\n    uint256 currentPPS = _pps();\n    uint256 highWaterMarkBefore = $._highWaterMark;\n    if (currentPPS > highWaterMarkBefore) {\n      uint256 profitPerSharePercent = currentPPS - highWaterMarkBefore;\n      uint256 totalProfitAssets = Math.mulDiv(profitPerSharePercent, totalSupply(), PERCENT);\n      uint256 feeAssets = Math.mulDiv(totalProfitAssets, $._performanceFeePercent, PERCENT);\n      uint256 feeShares = Math.mulDiv(feeAssets, totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1 - feeAssets);\n\n      if (feeShares > 0) {\n        _setHighWaterMark(currentPPS);\n        _mint($._feeRecipient, feeShares);\n        emit PerformanceFeeMinted($._feeRecipient, feeShares, feeAssets);\n      }\n    }\n  }\n\n  /// @notice Sets the high water mark\n  function _setHighWaterMark(uint256 highWaterMark_) internal {\n    PerformanceVaultStorage storage $ = _getPerformanceVaultStorage();\n    uint256 highWaterMarkBefore = $._highWaterMark;\n    $._highWaterMark = highWaterMark_;\n    emit HighWaterMarkUpdated(highWaterMarkBefore, highWaterMark_);\n  }\n\n  // ERC4626 OVERRIDES\n  function deposit(uint256 assets, address receiver) public override(ERC4626Upgradeable, IERC4626) nonReentrant mintPerformanceFee emitVaultStatus returns (uint256) {\n    return super.deposit(assets, receiver);\n  }\n\n  function mint(uint256 shares, address receiver) public override(ERC4626Upgradeable, IERC4626) nonReentrant mintPerformanceFee emitVaultStatus returns (uint256) {\n    return super.mint(shares, receiver);\n  }\n\n  function withdraw(uint256 assets, address receiver, address owner) public override(ERC4626Upgradeable, IERC4626) nonReentrant mintPerformanceFee emitVaultStatus returns (uint256) {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  function redeem(uint256 shares, address receiver, address owner) public override(ERC4626Upgradeable, IERC4626) nonReentrant mintPerformanceFee emitVaultStatus returns (uint256) {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  // VIEW FUNCTIONS\n  /// @notice Returns the high water mark\n  function highWaterMark() public view returns (uint256) {\n    return _getPerformanceVaultStorage()._highWaterMark;\n  }\n\n  /// @notice Returns the performance fee percent\n  function performanceFeePercent() public view returns (uint256) {\n    return _getPerformanceVaultStorage()._performanceFeePercent;\n  }\n\n  /// @notice Returns the fee recipient\n  function feeRecipient() public view returns (address) {\n    return _getPerformanceVaultStorage()._feeRecipient;\n  }\n}\n"
    }
}