{
    "vfp_id": "vfp_00081",
    "project_name": "Very Liquid Vaults Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Malicious or Faulty Strategies Cannot Be Removed",
            "description": "The `removeStrategy` function in `SizeMetaVault` calls `convertToAssets` on the strategy being removed, even when the rebalance amount is zero (e.g., during a guardian-initiated asset forfeiture). A malicious or malfunctioning strategy can revert on `convertToAssets`, preventing its own removal. The root cause is the unconditional external call to the strategy contract without checking if rebalancing is necessary. This creates a denial-of-service vector where a compromised strategy can permanently block its removal, potentially bricking the entire meta vault if it also disrupts core operations. The impact is severe operational disruption, as the protocol cannot recover from a faulty strategy, leading to a complete freeze of user funds and functionality.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::removeStrategy#L215"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Missing, Incomplete, and Misleading Documentation",
            "description": "Multiple instances of incorrect, missing, or misleading NatSpec and inline comments were found throughout the codebase. For example, `removeStrategy`'s NatSpec incorrectly states `VAULT_MANAGER_ROLE` can call it, while the code uses `GUARDIAN_ROLE`. Similarly, `setTotalAssetsCap`'s comment claims only the `Auth` contract can call it, but the code allows any `VAULT_MANAGER_ROLE` holder. Additionally, numerous functions lack any documentation, including critical ones like `initialize`, `maxDeposit`, and events. The root cause is inconsistent and incomplete documentation practices. While this does not directly lead to fund loss, it increases the risk of operator error, misconfiguration, and integration bugs by third parties. The impact is reduced code maintainability, auditability, and increased likelihood of human error in governance or integration.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::removeStrategy#L210",
                "BaseVault.sol::setTotalAssetsCap#L127",
                "Auth.sol::initialize",
                "IVault.sol::auth",
                "IVault.sol::totalAssetsCap",
                "SizeMetaVault.sol::initialize",
                "SizeMetaVault.sol::maxDeposit",
                "SizeMetaVault.sol::maxMint",
                "SizeMetaVault.sol::maxWithdraw",
                "SizeMetaVault.sol::maxRedeem",
                "SizeMetaVault.sol::totalAssets",
                "SizeMetaVault.sol::setPerformanceFeePercent",
                "SizeMetaVault.sol::setFeeRecipient",
                "SizeMetaVault.sol::setRebalanceMaxSlippagePercent",
                "SizeMetaVault.sol::addStrategy",
                "SizeMetaVault.sol::removeStrategy",
                "SizeMetaVault.sol::reorderStrategies",
                "SizeMetaVault.sol::rebalance",
                "SizeMetaVault.sol::strategies",
                "SizeMetaVault.sol::strategies (index)",
                "SizeMetaVault.sol::strategiesCount",
                "SizeMetaVault.sol::rebalanceMaxSlippagePercent",
                "SizeMetaVault.sol::isStrategy",
                "SizeMetaVault.sol::MAX_STRATEGIES",
                "AaveStrategyVault.sol::initialize",
                "AaveStrategyVault.sol::maxDeposit",
                "AaveStrategyVault.sol::maxMint",
                "AaveStrategyVault.sol::maxWithdraw",
                "AaveStrategyVault.sol::maxRedeem",
                "AaveStrategyVault.sol::totalAssets",
                "AaveStrategyVault.sol::pool",
                "AaveStrategyVault.sol::aToken",
                "ERC4626StrategyVault.sol::initialize",
                "ERC4626StrategyVault.sol::maxDeposit",
                "ERC4626StrategyVault.sol::maxMint",
                "ERC4626StrategyVault.sol::maxWithdraw",
                "ERC4626StrategyVault.sol::maxRedeem",
                "ERC4626StrategyVault.sol::vault",
                "ERC4626StrategyVault.sol::VaultSet",
                "BaseVault.sol::initialize",
                "BaseVault.sol::setTotalAssetsCap",
                "BaseVault.sol::decimals",
                "BaseVault.sol::maxDeposit",
                "BaseVault.sol::maxMint",
                "BaseVault.sol::maxWithdraw",
                "BaseVault.sol::maxRedeem",
                "BaseVault.sol::auth",
                "BaseVault.sol::totalAssetsCap",
                "NonReentrantVault.sol::deposit",
                "NonReentrantVault.sol::mint",
                "NonReentrantVault.sol::withdraw",
                "NonReentrantVault.sol::redeem",
                "PerformanceVault.sol::deposit",
                "PerformanceVault.sol::mint",
                "PerformanceVault.sol::withdraw",
                "PerformanceVault.sol::redeem",
                "PerformanceVault.sol::highWaterMark",
                "PerformanceVault.sol::performanceFeePercent",
                "PerformanceVault.sol::feeRecipient",
                "PerformanceVault.sol::State Variables",
                "PerformanceVault.sol::Events"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Return Values for Nested Meta Vaults Sharing the Same Strategy",
            "description": "The `_maxWithdrawFromStrategies` and `_maxDepositToStrategies` functions in `SizeMetaVault` can return inflated values when nested meta vaults share the same underlying strategy. For example, if a top-level meta vault has both a direct ERC-4626 strategy and a nested meta vault that uses the same strategy, the available capacity is double-counted. The root cause is the lack of deduplication or tracking of shared strategies in the calculation logic. An attacker could exploit this by structuring nested vaults to misrepresent available liquidity, leading to failed deposit attempts despite reported headroom. The impact is degraded user experience and potential integration failures in systems relying on accurate `maxDeposit`/`maxWithdraw` values, though no direct fund loss occurs.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::_maxWithdrawFromStrategies",
                "SizeMetaVault.sol::_maxDepositToStrategies"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Incomplete Reentrancy Protection",
            "description": "The `SizeMetaVault` contract lacks the `nonReentrant` modifier on the `setRebalanceMaxSlippagePercent` function, which is callable without a timelock. Additionally, the `NonReentrantVault` and `PerformanceVault` contracts do not apply the `nonReentrant` modifier to inherited ERC-20 functions like `transfer` and `transferFrom`. The root cause is incomplete application of reentrancy guards across all state-changing entry points. While many functions are protected by timelocks, the absence of guards on `setRebalanceMaxSlippagePercent` exposes it to reentrancy. Furthermore, read-only reentrancy remains possible via `view` functions during state changes, which could affect third-party integrations. The impact includes potential manipulation of slippage settings and vulnerability in external contracts that rely on consistent state during calls.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::setRebalanceMaxSlippagePercent#L192",
                "NonReentrantVault.sol::transfer",
                "NonReentrantVault.sol::transferFrom",
                "PerformanceVault.sol::transfer",
                "PerformanceVault.sol::transferFrom"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect Return Value in `maxRedeem` and `maxMint` Functions",
            "description": "The `maxRedeem` and `maxMint` functions in `SizeMetaVault` and `ERC4626StrategyVault` derive their values from `maxWithdraw` and `maxDeposit`, respectively, which involves converting shares to assets and back. Due to the use of floor division in both conversions, a precision loss of up to 1 Wei occurs, causing the returned share amount to be slightly less than the actual balance. The root cause is the double conversion without rounding up or compensating for precision loss. While not exploitable for direct fund theft, this can lead to user frustration and integration issues where dependent contracts assume the full balance is withdrawable or mintable. The impact is a denial-of-service-like experience for users attempting to move their entire balance, potentially breaking automated strategies or yield aggregators.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::maxRedeem#L102-L104",
                "SizeMetaVault.sol::maxMint",
                "ERC4626StrategyVault.sol::maxRedeem",
                "ERC4626StrategyVault.sol::maxMint"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol",
                "very-liquid-vaults/src/strategies/ERC4626StrategyVault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "reorderStrategies Function is Unnecessarily Expensive",
            "description": "The `reorderStrategies` function in the `SizeMetaVault` contract inefficiently removes and re-adds all strategies when reordering, leading to excessive gas consumption. The root cause is the unnecessary use of `_removeStrategy` and `_addStrategy` internal functions, which perform redundant validation and array shifting despite the input already being validated. An attacker cannot directly exploit this for profit, but users and the system are impacted through higher transaction costs. The impact includes increased gas fees, redundant event emissions, and a larger reversion surface without security benefit.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::reorderStrategies#239-244",
                "SizeMetaVault.sol::reorderStrategies#229-236",
                "SizeMetaVault.sol#238-244"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Opportunity to Break Loops Early",
            "description": "The `_deposit` and `_withdraw` functions in the `SizeMetaVault` contract continue looping through all strategies even after the required `assetsToDeposit` or `assetsToWithdraw` have been fully allocated or withdrawn. The cause is the absence of an early break condition when the target amount is fully processed. This leads to unnecessary iterations, increasing gas costs. An attacker could potentially exploit this by forcing the system to process many strategies, increasing transaction costs for users. The impact is limited to gas inefficiency and higher operational costs, with no direct security compromise.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::_deposit#141",
                "SizeMetaVault.sol::_withdraw#167"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        }
    ],
    "affected_files": {
        "SizeMetaVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {ERC4626Upgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IVault} from \"@src//IVault.sol\";\nimport {Auth, DEFAULT_ADMIN_ROLE, GUARDIAN_ROLE, STRATEGIST_ROLE, VAULT_MANAGER_ROLE} from \"@src/Auth.sol\";\nimport {BaseVault} from \"@src/utils/BaseVault.sol\";\nimport {PerformanceVault} from \"@src/utils/PerformanceVault.sol\";\n\n/// @title SizeMetaVault\n/// @custom:security-contact security@size.credit\n/// @author Size (https://size.credit/)\n/// @notice Meta vault that distributes assets across multiple strategies\n/// @dev Extends PerformanceVault to manage multiple strategy vaults for asset allocation. By default, the performance fee is 0.\ncontract SizeMetaVault is PerformanceVault {\n  using SafeERC20 for IERC20;\n\n  uint256 public constant MAX_STRATEGIES = 10;\n\n  // STORAGE\n  /// @custom:storage-location erc7201:size.storage.SizeMetaVault\n  struct SizeMetaVaultStorage {\n    IVault[] _strategies;\n    uint256 _rebalanceMaxSlippagePercent;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"size.storage.SizeMetaVault\")) - 1)) & ~bytes32(uint256(0xff));\n  bytes32 private constant SizeMetaVaultStorageLocation = 0x147748455d2ea6ff81c5c3f61eeea0b95acd3c4525df2bf45d2d538784d4f400;\n\n  function _getSizeMetaVaultStorage() private pure returns (SizeMetaVaultStorage storage $) {\n    assembly {\n      $.slot := SizeMetaVaultStorageLocation\n    }\n  }\n\n  // EVENTS\n  event StrategyAdded(address indexed strategy);\n  event StrategyRemoved(address indexed strategy);\n  event Rebalanced(address indexed strategyFrom, address indexed strategyTo, uint256 rebalancedAmount, uint256 maxSlippagePercent);\n  event RebalanceMaxSlippagePercentSet(uint256 oldRebalanceMaxSlippagePercent, uint256 newRebalanceMaxSlippagePercent);\n  event DepositFailed(address indexed strategy, uint256 amount);\n  event WithdrawFailed(address indexed strategy, uint256 amount);\n\n  // ERRORS\n  error InvalidStrategy(address strategy);\n  error CannotDepositToStrategies(uint256 assets, uint256 shares, uint256 remainingAssets);\n  error CannotWithdrawFromStrategies(uint256 assets, uint256 shares, uint256 missingAssets);\n  error TransferredAmountLessThanMin(uint256 assetsBefore, uint256 assetsAfter, uint256 slippage, uint256 amount, uint256 maxSlippagePercent);\n  error MaxStrategiesExceeded(uint256 strategiesCount, uint256 maxStrategies);\n  error ArrayLengthMismatch(uint256 expectedLength, uint256 actualLength);\n  error InvalidMaxSlippagePercent(uint256 maxSlippagePercent);\n\n  // CONSTRUCTOR / INITIALIZER\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the SizeMetaVault with strategies\n  /// @dev Adds all provided strategies and calls parent initialization\n  function initialize(Auth auth_, IERC20 asset_, string memory name_, string memory symbol_, address fundingAccount, uint256 firstDepositAmount, IVault[] memory strategies_)\n    public\n    virtual\n    initializer\n  {\n    __PerformanceVault_init(auth_.getRoleMember(DEFAULT_ADMIN_ROLE, 0), 0);\n\n    for (uint256 i = 0; i < strategies_.length; ++i) {\n      _addStrategy(strategies_[i], address(asset_), address(auth_));\n    }\n    _setRebalanceMaxSlippagePercent(0.01e18);\n\n    super.initialize(auth_, asset_, name_, symbol_, fundingAccount, firstDepositAmount);\n  }\n\n  // ERC4626 OVERRIDES\n  /// @notice Returns the maximum amount that can be deposited\n  function maxDeposit(address receiver) public view override(BaseVault) returns (uint256) {\n    return Math.min(_maxDepositToStrategies(), super.maxDeposit(receiver));\n  }\n\n  /// @notice Returns the maximum number of shares that can be minted\n  function maxMint(address receiver) public view override(BaseVault) returns (uint256) {\n    uint256 maxDepositReceiver = maxDeposit(receiver);\n    // slither-disable-next-line incorrect-equality\n    uint256 maxDepositInShares = maxDepositReceiver == type(uint256).max ? type(uint256).max : _convertToShares(maxDepositReceiver, Math.Rounding.Floor);\n    return Math.min(maxDepositInShares, super.maxMint(receiver));\n  }\n\n  /// @notice Returns the maximum amount that can be withdrawn by an owner\n  function maxWithdraw(address owner) public view override(BaseVault) returns (uint256) {\n    return Math.min(_maxWithdrawFromStrategies(), super.maxWithdraw(owner));\n  }\n\n  /// @notice Returns the maximum number of shares that can be redeemed\n  function maxRedeem(address owner) public view override(BaseVault) returns (uint256) {\n    uint256 maxWithdrawOwner = maxWithdraw(owner);\n    // slither-disable-next-line incorrect-equality\n    uint256 maxWithdrawInShares = maxWithdrawOwner == type(uint256).max ? type(uint256).max : _convertToShares(maxWithdrawOwner, Math.Rounding.Floor);\n    return Math.min(maxWithdrawInShares, super.maxRedeem(owner));\n  }\n\n  /// @notice Returns the total assets managed by the vault\n  // slither-disable-next-line calls-loop\n  function totalAssets() public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256 total) {\n    uint256 length = strategies().length;\n    for (uint256 i = 0; i < length; ++i) {\n      IVault strategy = strategies(i);\n      total += strategy.convertToAssets(strategy.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Deposits assets to strategies in order\n  /// @dev Tries to deposit to strategies sequentially, reverts if not all assets can be deposited\n  // slither-disable-next-line calls-loop\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {\n    if (_isInitializing()) {\n      // first deposit\n      shares = assets;\n    }\n\n    super._deposit(caller, receiver, assets, shares);\n\n    uint256 assetsToDeposit = assets;\n\n    uint256 length = strategies().length;\n    for (uint256 i = 0; i < length; ++i) {\n      IVault strategy = strategies(i);\n      uint256 strategyMaxDeposit = strategy.maxDeposit(address(this));\n      uint256 depositAmount = Math.min(assetsToDeposit, strategyMaxDeposit);\n\n      if (depositAmount > 0) {\n        IERC20(asset()).forceApprove(address(strategy), depositAmount);\n        // slither-disable-next-line unused-return\n        try strategy.deposit(depositAmount, address(this)) {\n          assetsToDeposit -= depositAmount;\n        } catch {\n          emit DepositFailed(address(strategy), depositAmount);\n          IERC20(asset()).forceApprove(address(strategy), 0);\n        }\n      }\n    }\n    if (assetsToDeposit > 0) revert CannotDepositToStrategies(assets, shares, assetsToDeposit);\n  }\n\n  /// @notice Withdraws assets from strategies in order\n  /// @dev Tries to withdraw from strategies sequentially, reverts if not enough assets available\n  // slither-disable-next-line calls-loop\n  function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n    uint256 assetsToWithdraw = assets;\n\n    uint256 length = strategies().length;\n    for (uint256 i = 0; i < length; ++i) {\n      IVault strategy = strategies(i);\n\n      uint256 strategyMaxWithdraw = strategy.maxWithdraw(address(this));\n      uint256 withdrawAmount = Math.min(assetsToWithdraw, strategyMaxWithdraw);\n\n      if (withdrawAmount > 0) {\n        // slither-disable-next-line unused-return\n        try strategy.withdraw(withdrawAmount, address(this), address(this)) {\n          assetsToWithdraw -= withdrawAmount;\n        } catch {\n          emit WithdrawFailed(address(strategy), withdrawAmount);\n        }\n      }\n    }\n    if (assetsToWithdraw > 0) revert CannotWithdrawFromStrategies(assets, shares, assetsToWithdraw);\n\n    super._withdraw(caller, receiver, owner, assets, shares);\n  }\n\n  // ADMIN FUNCTIONS\n  /// @notice Sets the performance fee percent\n  function setPerformanceFeePercent(uint256 performanceFeePercent_) external notPaused onlyAuth(DEFAULT_ADMIN_ROLE) {\n    _setPerformanceFeePercent(performanceFeePercent_);\n  }\n\n  /// @notice Sets the fee recipient\n  function setFeeRecipient(address feeRecipient_) external notPaused onlyAuth(DEFAULT_ADMIN_ROLE) {\n    _setFeeRecipient(feeRecipient_);\n  }\n\n  // VAULT MANAGER FUNCTIONS\n  /// @notice Sets the rebalance max slippage percent\n  /// @dev Only callable by addresses with VAULT_MANAGER_ROLE\n  function setRebalanceMaxSlippagePercent(uint256 rebalanceMaxSlippagePercent_) external notPaused onlyAuth(VAULT_MANAGER_ROLE) {\n    _setRebalanceMaxSlippagePercent(rebalanceMaxSlippagePercent_);\n  }\n\n  /// @notice Adds a new strategy to the vault\n  /// @dev Only callable by addresses with VAULT_MANAGER_ROLE\n  function addStrategy(IVault strategy_) external nonReentrant notPaused emitVaultStatus onlyAuth(VAULT_MANAGER_ROLE) {\n    _addStrategy(strategy_, asset(), address(auth()));\n  }\n\n  // GUARDIAN FUNCTIONS\n  /// @notice Removes a strategy from the vault and transfers all assets, if any, to another strategy\n  /// @dev Only callable by addresses with VAULT_MANAGER_ROLE\n  /// @dev Using `amount` = 0 will forfeit all assets from `strategyToRemove`\n  /// @dev Using `amount` = type(uint256).max will attempt to transfer the entire balance from `strategyToRemove`\n  /// @dev If `convertToAssets(balanceOf)` > `maxWithdraw`, e.g. due to pause/withdraw limits, the _rebalance step will revert, so an appropriate `amount` should be used\n  /// @dev Reverts if totalAssets() == 0 at the end of the operation, which can happen if the call is performed with 100% slippage\n  // slither-disable-next-line reentrancy-no-eth\n  function removeStrategy(IVault strategyToRemove, IVault strategyToReceiveAssets, uint256 amount, uint256 maxSlippagePercent) external nonReentrant notPaused emitVaultStatus onlyAuth(GUARDIAN_ROLE) {\n    if (!isStrategy(strategyToRemove)) revert InvalidStrategy(address(strategyToRemove));\n    if (!isStrategy(strategyToReceiveAssets)) revert InvalidStrategy(address(strategyToReceiveAssets));\n    if (strategyToRemove == strategyToReceiveAssets) revert InvalidStrategy(address(strategyToReceiveAssets));\n\n    uint256 assetsToRemove = strategyToRemove.convertToAssets(strategyToRemove.balanceOf(address(this)));\n    amount = Math.min(amount, assetsToRemove);\n    _rebalance(strategyToRemove, strategyToReceiveAssets, amount, maxSlippagePercent);\n    _removeStrategy(strategyToRemove);\n\n    // slither-disable-next-line incorrect-equality\n    if (totalAssets() == 0) revert NullAmount();\n  }\n\n  // STRATEGIST FUNCTIONS\n  /// @notice Reorders the strategies\n  /// @dev Verifies that the new strategies order is valid and that there are no duplicates\n  /// @dev Clears current strategies and adds them in the new order\n  function reorderStrategies(IVault[] calldata newStrategiesOrder) external notPaused onlyAuth(STRATEGIST_ROLE) {\n    if (strategies().length != newStrategiesOrder.length) revert ArrayLengthMismatch(strategies().length, newStrategiesOrder.length);\n\n    for (uint256 i = 0; i < newStrategiesOrder.length; ++i) {\n      if (!isStrategy(newStrategiesOrder[i])) revert InvalidStrategy(address(newStrategiesOrder[i]));\n      for (uint256 j = i + 1; j < newStrategiesOrder.length; ++j) {\n        if (newStrategiesOrder[i] == newStrategiesOrder[j]) revert InvalidStrategy(address(newStrategiesOrder[i]));\n      }\n    }\n\n    IVault[] memory oldStrategiesOrder = strategies();\n    for (uint256 i = 0; i < oldStrategiesOrder.length; ++i) {\n      _removeStrategy(oldStrategiesOrder[i]);\n    }\n    for (uint256 i = 0; i < newStrategiesOrder.length; ++i) {\n      _addStrategy(newStrategiesOrder[i], asset(), address(auth()));\n    }\n  }\n\n  /// @notice Rebalances assets between two strategies\n  /// @dev Transfers assets from one strategy to another\n  /// @dev We have maxSlippagePercent <= PERCENT since rebalanceMaxSlippagePercent has already been checked in setRebalanceMaxSlippagePercent\n  function rebalance(IVault strategyFrom, IVault strategyTo, uint256 amount, uint256 maxSlippagePercent) external nonReentrant notPaused emitVaultStatus onlyAuth(STRATEGIST_ROLE) {\n    maxSlippagePercent = Math.min(maxSlippagePercent, rebalanceMaxSlippagePercent());\n\n    if (!isStrategy(strategyFrom)) revert InvalidStrategy(address(strategyFrom));\n    if (!isStrategy(strategyTo)) revert InvalidStrategy(address(strategyTo));\n    if (strategyFrom == strategyTo) revert InvalidStrategy(address(strategyTo));\n    if (amount == 0) revert NullAmount();\n\n    _rebalance(strategyFrom, strategyTo, amount, maxSlippagePercent);\n  }\n\n  // PRIVATE FUNCTIONS\n  /// @notice Internal function to add a strategy\n  /// @dev Strategy configuration is assumed to be correct (non-malicious, no circular dependencies, etc.)\n  // slither-disable-next-line calls-loop\n  function _addStrategy(IVault strategy_, address asset_, address auth_) private {\n    if (address(strategy_) == address(0)) revert NullAddress();\n    if (isStrategy(strategy_)) revert InvalidStrategy(address(strategy_));\n    if (strategy_.asset() != asset_ || address(strategy_.auth()) != auth_) revert InvalidStrategy(address(strategy_));\n\n    SizeMetaVaultStorage storage $ = _getSizeMetaVaultStorage();\n    $._strategies.push(strategy_);\n    emit StrategyAdded(address(strategy_));\n    if ($._strategies.length > MAX_STRATEGIES) revert MaxStrategiesExceeded($._strategies.length, MAX_STRATEGIES);\n  }\n\n  /// @notice Internal function to remove a strategy\n  /// @dev No NullAddress check is needed because only whitelisted strategies can be removed, and it is checked in _addStrategy\n  /// @dev Removes the strategy in-place to keep the order\n  function _removeStrategy(IVault strategy) private {\n    SizeMetaVaultStorage storage $ = _getSizeMetaVaultStorage();\n    for (uint256 i = 0; i < $._strategies.length; ++i) {\n      if ($._strategies[i] == strategy) {\n        for (uint256 j = i; j < $._strategies.length - 1; ++j) {\n          $._strategies[j] = $._strategies[j + 1];\n        }\n        $._strategies.pop();\n        emit StrategyRemoved(address(strategy));\n        break;\n      }\n    }\n  }\n\n  /// @notice Internal function to set the default max slippage percent\n  function _setRebalanceMaxSlippagePercent(uint256 rebalanceMaxSlippagePercent_) private {\n    if (rebalanceMaxSlippagePercent_ > PERCENT) revert InvalidMaxSlippagePercent(rebalanceMaxSlippagePercent_);\n\n    SizeMetaVaultStorage storage $ = _getSizeMetaVaultStorage();\n    uint256 oldRebalanceMaxSlippagePercent = $._rebalanceMaxSlippagePercent;\n    $._rebalanceMaxSlippagePercent = rebalanceMaxSlippagePercent_;\n    emit RebalanceMaxSlippagePercentSet(oldRebalanceMaxSlippagePercent, rebalanceMaxSlippagePercent_);\n  }\n\n  /// @notice Internal function to calculate maximum depositable amount in all strategies\n  // slither-disable-next-line calls-loop\n  function _maxDepositToStrategies() private view returns (uint256 maxAssets) {\n    uint256 length = strategies().length;\n    for (uint256 i = 0; i < length; ++i) {\n      maxAssets = Math.saturatingAdd(maxAssets, strategies(i).maxDeposit(address(this)));\n    }\n  }\n\n  /// @notice Internal function to calculate maximum withdrawable amount from all strategies\n  // slither-disable-next-line calls-loop\n  function _maxWithdrawFromStrategies() private view returns (uint256 maxAssets) {\n    uint256 length = strategies().length;\n    for (uint256 i = 0; i < length; ++i) {\n      maxAssets = Math.saturatingAdd(maxAssets, strategies(i).maxWithdraw(address(this)));\n    }\n  }\n\n  /// @notice Internal function to rebalance assets between two strategies\n  /// @dev If before - after > maxSlippagePercent * amount, the _rebalance operation reverts\n  /// @dev Assumes input is validated by caller functions\n  function _rebalance(IVault strategyFrom, IVault strategyTo, uint256 amount, uint256 maxSlippagePercent) private {\n    uint256 assetsBefore = strategyFrom.convertToAssets(strategyFrom.balanceOf(address(this))) + strategyTo.convertToAssets(strategyTo.balanceOf(address(this)));\n\n    uint256 balanceBefore = IERC20(asset()).balanceOf(address(this));\n    if (amount > 0) {\n      // slither-disable-next-line unused-return\n      strategyFrom.withdraw(amount, address(this), address(this));\n    }\n    uint256 balanceAfter = IERC20(asset()).balanceOf(address(this));\n    uint256 assets = balanceAfter - balanceBefore;\n\n    if (assets > 0) {\n      IERC20(asset()).forceApprove(address(strategyTo), assets);\n      // slither-disable-next-line unused-return\n      strategyTo.deposit(assets, address(this));\n    }\n\n    uint256 assetsAfter = strategyFrom.convertToAssets(strategyFrom.balanceOf(address(this))) + strategyTo.convertToAssets(strategyTo.balanceOf(address(this)));\n\n    uint256 slippage = Math.mulDiv(maxSlippagePercent, amount, PERCENT);\n    if (assetsBefore > slippage + assetsAfter) revert TransferredAmountLessThanMin(assetsBefore, assetsAfter, slippage, amount, maxSlippagePercent);\n\n    emit Rebalanced(address(strategyFrom), address(strategyTo), assets, maxSlippagePercent);\n  }\n\n  // VIEW FUNCTIONS\n  /// @notice Returns the strategies in the vault\n  function strategies() public view returns (IVault[] memory) {\n    return _getSizeMetaVaultStorage()._strategies;\n  }\n\n  /// @notice Returns the strategy at the given index\n  function strategies(uint256 index) public view returns (IVault) {\n    return _getSizeMetaVaultStorage()._strategies[index];\n  }\n\n  /// @notice Returns the number of strategies in the vault\n  function strategiesCount() public view returns (uint256) {\n    return strategies().length;\n  }\n\n  /// @notice Returns the rebalance max slippage percent\n  function rebalanceMaxSlippagePercent() public view returns (uint256) {\n    return _getSizeMetaVaultStorage()._rebalanceMaxSlippagePercent;\n  }\n\n  /// @notice Returns true if the strategy is in the vault\n  function isStrategy(IVault strategy) public view returns (bool) {\n    uint256 length = strategies().length;\n    for (uint256 i = 0; i < length; ++i) {\n      if (strategies(i) == strategy) return true;\n    }\n    return false;\n  }\n}\n",
        "ERC4626StrategyVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {ERC4626Upgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Auth} from \"@src/Auth.sol\";\nimport {BaseVault} from \"@src/utils/BaseVault.sol\";\nimport {NonReentrantVault} from \"@src/utils/NonReentrantVault.sol\";\n\n/// @title ERC4626StrategyVault\n/// @custom:security-contact security@size.credit\n/// @author Size (https://size.credit/)\n/// @notice A strategy that invests assets in an external ERC4626-compliant vault\n/// @dev Wraps an external ERC4626 vault to provide strategy functionality for the Size Meta Vault\ncontract ERC4626StrategyVault is NonReentrantVault {\n  using SafeERC20 for IERC20;\n\n  // STORAGE\n  /// @custom:storage-location erc7201:size.storage.ERC4626StrategyVault\n  struct ERC4626StrategyVaultStorage {\n    IERC4626 _vault;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"size.storage.ERC4626StrategyVault\")) - 1)) & ~bytes32(uint256(0xff));\n  bytes32 private constant ERC4626StrategyVaultStorageLocation = 0x38a1b2a83634e21b8a768b344dddb96ad68dbc29f8128301f8422f40aee65000;\n\n  function _getERC4626StrategyVaultStorage() private pure returns (ERC4626StrategyVaultStorage storage $) {\n    assembly {\n      $.slot := ERC4626StrategyVaultStorageLocation\n    }\n  }\n\n  // EVENTS\n  event VaultSet(address indexed vault);\n\n  // INITIALIZER\n  /// @notice Initializes the ERC4626StrategyVault with an external vault\n  /// @dev Sets the external vault and calls parent initialization\n  function initialize(Auth auth_, string memory name_, string memory symbol_, address fundingAccount, uint256 firstDepositAmount, IERC4626 vault_) public virtual initializer {\n    if (address(vault_) == address(0)) revert NullAddress();\n\n    ERC4626StrategyVaultStorage storage $ = _getERC4626StrategyVaultStorage();\n    $._vault = vault_;\n    emit VaultSet(address(vault_));\n\n    super.initialize(auth_, IERC20(address(vault_.asset())), name_, symbol_, fundingAccount, firstDepositAmount);\n  }\n\n  // ERC4626 OVERRIDES\n  /// @notice Returns the maximum amount that can be deposited\n  function maxDeposit(address receiver) public view override(BaseVault) returns (uint256) {\n    return Math.min(vault().maxDeposit(address(this)), super.maxDeposit(receiver));\n  }\n\n  /// @notice Returns the maximum number of shares that can be minted\n  function maxMint(address receiver) public view override(BaseVault) returns (uint256) {\n    uint256 maxDepositReceiver = maxDeposit(receiver);\n    // slither-disable-next-line incorrect-equality\n    uint256 maxDepositInShares = maxDepositReceiver == type(uint256).max ? type(uint256).max : _convertToShares(maxDepositReceiver, Math.Rounding.Floor);\n    return Math.min(maxDepositInShares, super.maxMint(receiver));\n  }\n\n  /// @notice Returns the maximum amount that can be withdrawn by an owner\n  function maxWithdraw(address owner) public view override(BaseVault) returns (uint256) {\n    return Math.min(vault().maxWithdraw(address(this)), super.maxWithdraw(owner));\n  }\n\n  /// @notice Returns the maximum number of shares that can be redeemed\n  function maxRedeem(address owner) public view override(BaseVault) returns (uint256) {\n    uint256 maxWithdrawOwner = maxWithdraw(owner);\n    // slither-disable-next-line incorrect-equality\n    uint256 maxWithdrawInShares = maxWithdrawOwner == type(uint256).max ? type(uint256).max : _convertToShares(maxWithdrawOwner, Math.Rounding.Floor);\n    return Math.min(maxWithdrawInShares, super.maxRedeem(owner));\n  }\n\n  /// @notice Returns the total assets managed by this strategy\n  /// @dev Converts the external vault shares held by this contract to asset value\n  /// @return The total assets under management\n  function totalAssets() public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256) {\n    return vault().convertToAssets(vault().balanceOf(address(this)));\n  }\n\n  /// @notice Internal deposit function that invests in the external vault\n  /// @dev Calls parent deposit then invests the assets in the external vault\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {\n    super._deposit(caller, receiver, assets, shares);\n    IERC20(asset()).forceApprove(address(vault()), assets);\n    // slither-disable-next-line unused-return\n    vault().deposit(assets, address(this));\n  }\n\n  /// @notice Internal withdraw function that redeems from the external vault\n  /// @dev Withdraws from the external vault then calls parent withdraw\n  function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n    // slither-disable-next-line unused-return\n    vault().withdraw(assets, address(this), address(this));\n    super._withdraw(caller, receiver, owner, assets, shares);\n  }\n\n  // VIEW FUNCTIONS\n  /// @notice Returns the external vault\n  function vault() public view returns (IERC4626) {\n    return _getERC4626StrategyVaultStorage()._vault;\n  }\n}\n"
    }
}