{
    "vfp_id": "vfp_00190",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused surcharge mask constants",
            "description": "1. **Description:** The constants _ATLAS_SURCHARGE_MASK and _BUNDLER_SURCHARGE_MASK in AtlasConstants.sol are defined but not used anywhere in the codebase.\n2. **Cause:** These constants were likely left over from earlier versions or unused features.\n3. **Exploitation:** No direct exploit, but increases code bloat and confusion.\n4. **Impact:** Unnecessary complexity and potential confusion for developers reading the code.\n",
            "severity": "Informational",
            "location": [
                "AtlasConstants.sol#L49-L52"
            ],
            "files": [
                "atlas/src/contracts/types/AtlasConstants.sol"
            ]
        }
    ],
    "affected_files": {
        "AtlasConstants.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport \"./ValidCalls.sol\";\n\nimport { GasAccLib } from \"../libraries/GasAccLib.sol\";\n\n// NOTE: Internal constants that are defined but not used in the logic of a smart contract, will NOT be included in the\n// bytecode of the smart contract when compiled. However, public constants will be included in every inheriting contract\n// as they are part of the ABI. As such, only internal constants are defined in this shared contract.\n\ncontract AtlasConstants {\n    // ------------------------------------------------------- //\n    //                      ATLAS CONSTANTS                    //\n    // ------------------------------------------------------- //\n\n    // Atlas constants\n    uint256 internal constant _GAS_VALUE_DECIMALS_TO_DROP = 1e9; // measured in gwei\n    uint256 internal constant _UNLOCKED = 0;\n\n    // Atlas constants used in `_bidFindingIteration()`\n    uint256 internal constant _BITS_FOR_INDEX = 16;\n    uint256 internal constant _FIRST_16_BITS_TRUE_MASK = uint256(0xFFFF);\n\n    // Escrow constants\n    uint256 internal constant _VALIDATION_GAS_LIMIT = 500_000;\n    uint256 internal constant _GRACEFUL_RETURN_GAS_OFFSET = 40_000;\n\n    // Gas Accounting constants\n    uint256 internal constant _CALLDATA_LENGTH_PREMIUM_HALVED = GasAccLib._CALLDATA_LENGTH_PREMIUM_HALVED;\n    // Half of the upper gas cost per byte of calldata (16 gas). Multiplied by msg.data.length. Equivalent to\n    // `msg.data.length / 2 * 16` because 2 hex chars per byte.\n    uint256 internal constant _BASE_TX_GAS_USED = 21_000;\n    uint256 internal constant _SOLVER_OP_BASE_CALLDATA = GasAccLib._SOLVER_OP_BASE_CALLDATA; // SolverOperation calldata\n        // length excluding solverOp.data\n    uint256 internal constant _BUNDLER_FAULT_OFFSET = 4500; // Extra gas to write off if solverOp failure is bundler\n        // fault in `_handleSolverFailAccounting()`. Value is worst-case gas measured for bundler fault.\n    uint256 internal constant _SOLVER_FAULT_OFFSET = 28_800; // Extra gas to charge solver if solverOp failure is solver\n        // fault in `_handleSolverFailAccounting()`. Value is worst-case gas measured for solver fault.\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 238; // incl. gasRefundBeneficiary address and dynamic offset\n        // calldata\n\n    // First 160 bits of _solverLock are the address of the current solver.\n    // The 161st bit represents whether the solver has called back via `reconcile`.\n    // The 162nd bit represents whether the solver's outstanding debt has been repaid via `reconcile`.\n    uint256 internal constant _SOLVER_CALLED_BACK_MASK = 1 << 161;\n    uint256 internal constant _SOLVER_FULFILLED_MASK = 1 << 162;\n\n    // Used to set Lock phase without changing the activeEnvironment or callConfig.\n    uint256 internal constant _LOCK_PHASE_MASK =\n        uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00);\n\n    // ValidCalls error threshold before which the metacall reverts, and after which it returns gracefully to store\n    // nonces as used.\n    uint8 internal constant _GRACEFUL_RETURN_THRESHOLD = uint8(ValidCallsResult.InvertBidValueCannotBeExPostBids) + 1;\n\n    // ------------------------------------------------------- //\n    //               ATLAS VERIFICATION CONSTANTS              //\n    // ------------------------------------------------------- //\n\n    uint8 internal constant _MAX_SOLVERS = type(uint8).max - 1;\n    uint256 internal constant _BID_FIND_OVERHEAD = 5000; // Overhead gas for the logic required to execute and sort each\n        // solverOp in `_bidFindingIteration()`\n\n    // Params below are used to calculate the tolerated max diff between actual gasleft and expected gasleft, in the\n    // `_getAndVerifyGasLimits()` function. This tolerance is mostly for calldata gas cost differences.\n    uint256 internal constant _UPPER_BASE_EXEC_GAS_TOLERANCE = 20_000;\n    uint256 internal constant _LOWER_BASE_EXEC_GAS_TOLERANCE = 60_000;\n    uint256 internal constant _TOLERANCE_PER_SOLVER = 33_000;\n}\n"
    }
}