{
    "vfp_id": "vfp_00346",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "AgentDAO proposal calldata necessary to mint ServiceNFT is not enforced to be correct",
            "description": "The AgentDAO::propose() function does not validate that the attached calldata correctly calls ServiceNft::mint() with the right parameters. A proposer could use an incorrect descHash or duplicate calls, leading to incorrect proposalID calculation or unintended NFT minting. This could block legitimate proposals if their IDs collide. The cause is lack of on-chain validation of calldata structure. While governance voting mitigates risk, a malicious proposal could still cause state inconsistencies.\n",
            "severity": "Informational",
            "location": [
                "AgentDAO.sol",
                "ServiceNf.solt"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentDAO.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Vote can be cast on AgentDAO proposal before the relative contributionNFT is minted",
            "description": "Users can cast votes on AgentDAO proposals before the proposer mints the associated contributionNFT. The _castVote function checks for the NFT's existence and returns early if it doesn't exist, resulting in the vote not updating the proposal's maturity. The root cause is the non-atomic minting of the contributionNFT, which is done off-chain by the proposer rather than in the propose function. This can lead to votes being effectively ignored, reducing the accuracy of governance outcomes. While the impact is low, it introduces inconsistency in vote processing and could be exploited to manipulate voting dynamics.\n",
            "severity": "Low",
            "location": [
                "AgentDAO.sol"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentDAO.sol"
            ]
        }
    ],
    "affected_files": {
        "AgentDAO.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport \"./IAgentDAO.sol\";\nimport \"./GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../contribution/IContributionNft.sol\";\nimport \"./IEloCalculator.sol\";\nimport \"../contribution/IServiceNft.sol\";\nimport \"./IAgentNft.sol\";\n\ncontract AgentDAO is\n    IAgentDAO,\n    GovernorSettingsUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorStorageUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable\n{\n    using Checkpoints for Checkpoints.Trace208;\n\n    mapping(address => Checkpoints.Trace208) private _scores;\n    mapping(uint256 => uint256) private _proposalMaturities;\n\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    uint256 private _totalScore;\n\n    address private _agentNft;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        string memory name,\n        IVotes token,\n        address agentNft,\n        uint256 threshold,\n        uint32 votingPeriod_\n    ) external initializer {\n        __Governor_init(name);\n        __GovernorSettings_init(0, votingPeriod_, threshold);\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(token);\n        __GovernorVotesQuorumFraction_init(5100);\n        __GovernorStorage_init();\n\n        _agentNft = agentNft;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function votingDelay()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingDelay();\n    }\n\n    function votingPeriod()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingPeriod();\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(GovernorUpgradeable) returns (uint256) {\n        address proposer = _msgSender();\n\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        uint256 proposerVotes = getVotes(proposer, clock() - 1);\n        uint256 votesThreshold = proposalThreshold();\n        address contributionNft = IAgentNft(_agentNft).getContributionNft();\n        if (\n            proposerVotes < votesThreshold &&\n            proposer != IContributionNft(contributionNft).getAdmin()\n        ) {\n            revert GovernorInsufficientProposerVotes(\n                proposer,\n                proposerVotes,\n                votesThreshold\n            );\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }\n\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    )\n        internal\n        override(GovernorUpgradeable, GovernorStorageUpgradeable)\n        returns (uint256)\n    {\n        return\n            super._propose(targets, values, calldatas, description, proposer);\n    }\n\n    function proposalCount()\n        public\n        view\n        override(IAgentDAO, GovernorStorageUpgradeable)\n        returns (uint256)\n    {\n        return super.proposalCount();\n    }\n\n    function scoreOf(address account) public view returns (uint256) {\n        return _scores[account].latest();\n    }\n\n    function getPastScore(\n        address account,\n        uint256 timepoint\n    ) external view returns (uint256) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return _scores[account].upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal override returns (uint256) {\n        bool votedPreviously = hasVoted(proposalId, account);\n\n        uint256 weight = super._castVote(\n            proposalId,\n            account,\n            support,\n            reason,\n            params\n        );\n\n        if (!votedPreviously && hasVoted(proposalId, account)) {\n            ++_totalScore;\n            _scores[account].push(\n                SafeCast.toUint48(block.number),\n                SafeCast.toUint208(scoreOf(account)) + 1\n            );\n            if (params.length > 0 && support == 1) {\n                _updateMaturity(account, proposalId, weight, params);\n            }\n        }\n\n        if (support == 1) {\n            _tryAutoExecute(proposalId);\n        }\n\n        return weight;\n    }\n\n    // Auto execute when forVotes == totalSupply\n    function _tryAutoExecute(uint256 proposalId) internal {\n        (, uint256 forVotes, ) = proposalVotes(proposalId);\n        if (\n            forVotes == token().getPastTotalSupply(proposalSnapshot(proposalId))\n        ) {\n            execute(proposalId);\n        }\n    }\n\n    function _updateMaturity(\n        address account,\n        uint256 proposalId,\n        uint256 weight,\n        bytes memory params\n    ) internal {\n        // Check is this a contribution proposal\n        address contributionNft = IAgentNft(_agentNft).getContributionNft();\n        address owner = IERC721(contributionNft).ownerOf(proposalId);\n        if (owner == address(0)) {\n            return;\n        }\n\n        bool isModel = IContributionNft(contributionNft).isModel(proposalId);\n        if (!isModel) {\n            return;\n        }\n\n        uint8[] memory votes = abi.decode(params, (uint8[]));\n        uint256 maturity = _calcMaturity(proposalId, votes);\n\n        _proposalMaturities[proposalId] += (maturity * weight);\n\n        emit ValidatorEloRating(proposalId, account, maturity, votes);\n    }\n\n    function _calcMaturity(\n        uint256 proposalId,\n        uint8[] memory votes\n    ) internal view returns (uint256) {\n        address contributionNft = IAgentNft(_agentNft).getContributionNft();\n        address serviceNft = IAgentNft(_agentNft).getServiceNft();\n        uint256 virtualId = IContributionNft(contributionNft).tokenVirtualId(\n            proposalId\n        );\n        uint8 core = IContributionNft(contributionNft).getCore(proposalId);\n        uint256 coreService = IServiceNft(serviceNft).getCoreService(\n            virtualId,\n            core\n        );\n        // All services start with 100 maturity\n        uint256 maturity = 100;\n        if (coreService > 0) {\n            maturity = IServiceNft(serviceNft).getMaturity(coreService);\n            maturity = IEloCalculator(IAgentNft(_agentNft).getEloCalculator())\n                .battleElo(maturity, votes);\n        }\n\n        return maturity;\n    }\n\n    function getMaturity(uint256 proposalId) public view returns (uint256) {\n        (, uint256 forVotes, ) = proposalVotes(proposalId);\n        return Math.min(10000, _proposalMaturities[proposalId] / forVotes);\n    }\n\n    function quorum(\n        uint256 blockNumber\n    )\n        public\n        view\n        override(GovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function quorumDenominator() public pure override returns (uint256) {\n        return 10000;\n    }\n\n    function state(\n        uint256 proposalId\n    ) public view override(GovernorUpgradeable) returns (ProposalState) {\n        // Allow early execution when reached 100% for votes\n        ProposalState currentState = super.state(proposalId);\n        if (currentState == ProposalState.Active) {\n            (, uint256 forVotes, ) = proposalVotes(proposalId);\n            if (\n                forVotes ==\n                token().getPastTotalSupply(proposalSnapshot(proposalId))\n            ) {\n                return ProposalState.Succeeded;\n            }\n        }\n        return currentState;\n    }\n\n    function totalScore() public view override returns (uint256) {\n        return _totalScore;\n    }\n}\n"
    }
}