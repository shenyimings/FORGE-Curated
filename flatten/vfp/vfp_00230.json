{
    "vfp_id": "vfp_00230",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Anyone can brick other users from performing claim in ReclaimQueue",
            "description": "This vulnerability allows any user to prevent other users from successfully claiming their assets in the ReclaimQueue. The root cause is that the `request` function allows zero-share requests for arbitrary receivers without validating that the computed assets are non-zero. As a result, an attacker can submit multiple zero-asset requests to a victim's claim queue. When the victim attempts to claim, the `claim` function reverts because it requires `res.totalAssetsClaimed > 0`, and if the first MAX_CLAIM_SIZE entries are zero-asset, the claim will always revert, permanently blocking the victim from progressing their claims. This leads to a denial-of-service condition for affected users.\n",
            "severity": "Critical",
            "location": [
                "ReclaimQueue.sol#L257",
                "ReclaimQueue.sol#L486"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Overclaim in ReclaimQueue due to incorrect share delta when first item is not equal to reqId 0",
            "description": "This vulnerability arises from incorrect calculation of share deltas in the `_execClaim` function of ReclaimQueue. The code uses the recipient-local index `i` instead of the global `reqId` to determine whether to use cumulative shares or compute a delta. This causes the first claimed entry to incorrectly use the full `sharesAcc` value when the user's first request is not at global `reqId 0`, leading to an overstatement of shares. As a result, the calculated assets during claim can exceed the intended amount, allowing users to withdraw more assets than they are entitled to. This can lead to a loss of funds for the protocol when users exploit this miscalculation during claim execution.\n",
            "severity": "High",
            "location": [
                "ReclaimQueue.sol#L400",
                "ReclaimQueue.sol#L447"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "ReclaimQueue._sync() may fail due to insufficient balance",
            "description": "The `_sync` function in ReclaimQueue may fail when transferring excess shares to the ReclaimQueueCollector due to an insufficient balance. The issue occurs because `previewWithdraw` rounds up the number of shares needed to withdraw a given amount of assets, but the actual balance of the contract may be less than this calculated amount after a prior withdrawal. For example, after withdrawing part of the assets, the remaining shares may be insufficient to cover the `sharesCollected` value computed via `previewWithdraw`, causing the transfer to revert. This can prevent the completion of sync operations and disrupt the normal functioning of the protocol, especially when asset prices fluctuate between request and sync.\n",
            "severity": "Medium",
            "location": [
                "ReclaimQueue.sol#L555-L562"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Minor issue in ReclaimQueue._convertToAssets()",
            "description": "The _convertToAssets function in ReclaimQueue.sol differs from the standard ERC4626 convertToAssets implementation by not adding 1 to totalAssets in the calculation. This deviation may lead to slight discrepancies in asset conversion calculations, particularly in edge cases involving small amounts or specific rounding behaviors. The cause is an inconsistency in the mathematical formula used, which omits the +1 adjustment present in the standard. While this does not lead to exploitable vulnerabilities or fund loss, it may result in minor inaccuracies in asset valuation during user claims. The impact is limited to potential deviation from expected behavior as defined by the ERC4626 standard, which could affect user trust or integration compatibility.\n",
            "severity": "Informational",
            "location": [
                "ReclaimQueue.sol#L311-L319"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        }
    ],
    "affected_files": {
        "ReclaimQueue.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { IERC20Metadata } from '@oz/interfaces/IERC20Metadata.sol';\nimport { IERC4626 } from '@oz/interfaces/IERC4626.sol';\nimport { SafeERC20 } from '@oz/token/ERC20/utils/SafeERC20.sol';\nimport { Math } from '@oz/utils/math/Math.sol';\nimport { SafeCast } from '@oz/utils/math/SafeCast.sol';\nimport { ReentrancyGuard } from '@oz/utils/ReentrancyGuard.sol';\nimport { Time } from '@oz/utils/types/Time.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { IReclaimQueue } from '../interfaces/hub/IReclaimQueue.sol';\nimport { IReclaimQueueCollector } from '../interfaces/hub/IReclaimQueueCollector.sol';\nimport { ERC7201Utils } from '../lib/ERC7201Utils.sol';\nimport { LibQueue } from '../lib/LibQueue.sol';\nimport { Pausable } from '../lib/Pausable.sol';\nimport { StdError } from '../lib/StdError.sol';\nimport { Versioned } from '../lib/Versioned.sol';\n\ncontract ReclaimQueue is IReclaimQueue, Pausable, Ownable2StepUpgradeable, UUPSUpgradeable, ReentrancyGuard, Versioned {\n  using SafeERC20 for IERC4626;\n  using SafeERC20 for IERC20Metadata;\n  using SafeCast for uint256;\n  using ERC7201Utils for string;\n  using Math for uint256;\n  using LibQueue for LibQueue.UintOffsetQueue;\n\n  struct QueueState {\n    // configs\n    bool isEnabled;\n    uint48 reclaimPeriod;\n    uint168 _reserved; // reserved for future usage\n    // main\n    uint32 offset;\n    SyncLog[] logs;\n    Request[] items;\n    mapping(address recipient => LibQueue.UintOffsetQueue) indexes;\n  }\n\n  struct VaultState {\n    // vault\n    uint8 decimalsOffset;\n    uint8 underlyingDecimals;\n    // reserved for future usage\n    uint240 _reserved;\n  }\n\n  struct StorageV1 {\n    address resolver;\n    address collector;\n    mapping(address vault => QueueState) queues;\n    mapping(address vault => VaultState) vaults;\n  }\n\n  string private constant _NAMESPACE = 'mitosis.storage.ReclaimQueue.v1';\n  bytes32 private immutable _slot = _NAMESPACE.storageSlot();\n\n  function _getStorageV1() internal view returns (StorageV1 storage $) {\n    bytes32 slot = _slot;\n    // slither-disable-next-line assembly\n    assembly {\n      $.slot := slot\n    }\n  }\n\n  // =========================== NOTE: CONSTANTS =========================== //\n\n  uint32 public constant MAX_CLAIM_SIZE = 100;\n\n  // =========================== NOTE: INITIALIZATION =========================== //\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address owner_, address resolver_, address collector_) public virtual initializer {\n    __Pausable_init();\n    __Ownable2Step_init();\n    __Ownable_init(owner_);\n    __UUPSUpgradeable_init();\n\n    StorageV1 storage $ = _getStorageV1();\n\n    _setResolver($, resolver_);\n    _setCollector($, collector_);\n  }\n\n  // =========================== NOTE: QUERY FUNCTIONS =========================== //\n\n  function resolver() external view returns (address) {\n    return address(_getStorageV1().resolver);\n  }\n\n  function collector() external view returns (address) {\n    return address(_getStorageV1().collector);\n  }\n\n  function reclaimPeriod(address vault) external view returns (uint256) {\n    return _getStorageV1().queues[vault].reclaimPeriod;\n  }\n\n  function isEnabled(address vault) external view returns (bool) {\n    return _getStorageV1().queues[vault].isEnabled;\n  }\n\n  function queueInfo(address vault) external view returns (QueueInfo memory) {\n    QueueState storage q$ = _getStorageV1().queues[vault];\n\n    return QueueInfo({\n      isEnabled: q$.isEnabled,\n      reclaimPeriod: q$.reclaimPeriod,\n      offset: q$.offset,\n      itemsLen: q$.items.length.toUint32(),\n      syncLogsLen: q$.logs.length.toUint32()\n    });\n  }\n\n  function queueItem(address vault, uint256 index) external view returns (Request memory) {\n    QueueState storage q$ = _getStorageV1().queues[vault];\n    _validateIndex(index, q$.items.length);\n    return q$.items[index];\n  }\n\n  function queueIndex(address vault, address recipient) external view returns (QueueIndexInfo memory) {\n    QueueState storage q$ = _getStorageV1().queues[vault];\n    LibQueue.UintOffsetQueue storage i$ = q$.indexes[recipient];\n    return QueueIndexInfo({ offset: i$.offset(), size: i$.size() });\n  }\n\n  function queueIndexItem(address vault, address recipient, uint32 index) external view returns (Request memory) {\n    QueueState storage q$ = _getStorageV1().queues[vault];\n    LibQueue.UintOffsetQueue storage i$ = q$.indexes[recipient];\n    _validateIndex(index, i$.size());\n    return q$.items[i$.itemAt(index)];\n  }\n\n  function queueSyncLog(address vault, uint256 index) external view returns (SyncLog memory) {\n    QueueState storage q$ = _getStorageV1().queues[vault];\n    _validateIndex(index, q$.logs.length);\n    return q$.logs[index];\n  }\n\n  function pendingRequests(address vault, address recipient, uint256 offset, uint256 limit)\n    external\n    view\n    returns (Request[] memory requests)\n  {\n    StorageV1 storage $ = _getStorageV1();\n    QueueState storage q$ = $.queues[vault];\n    LibQueue.UintOffsetQueue storage index = q$.indexes[recipient];\n\n    uint32 reqIdFrom = index.offset() + offset.toUint32();\n    uint32 reqIdTo = Math.min(reqIdFrom + limit.toUint32(), index.size()).toUint32();\n    if (reqIdFrom >= reqIdTo) return new Request[](0);\n\n    requests = new Request[](reqIdTo - reqIdFrom);\n    for (uint32 i = reqIdFrom; i < reqIdTo; i++) {\n      requests[i - reqIdFrom] = q$.items[index.itemAt(i)];\n    }\n  }\n\n  function previewClaim(address receiver, address vault) external view returns (ClaimResult memory) {\n    return _previewClaimPagination(_getStorageV1(), receiver, vault, 0, MAX_CLAIM_SIZE);\n  }\n\n  function previewClaimPagination(address receiver, address vault, uint256 offset, uint256 limit)\n    external\n    view\n    returns (ClaimResult memory)\n  {\n    return _previewClaimPagination(_getStorageV1(), receiver, vault, offset, limit);\n  }\n\n  function previewSync(address vault, uint256 requestCount) external view returns (uint256, uint256) {\n    StorageV1 storage $ = _getStorageV1();\n    SyncResult memory res = _calcSync($.queues[vault], vault, requestCount);\n    return (res.totalSharesSynced, Math.min(res.totalAssetsOnRequest, res.totalAssetsOnReserve));\n  }\n\n  function previewSyncWithBudget(address vault, uint256 budget)\n    external\n    view\n    returns (uint256 totalSharesSynced, uint256 totalAssetsSynced, uint256 totalSyncedRequestsCount)\n  {\n    StorageV1 storage $ = _getStorageV1();\n    QueueState storage q$ = $.queues[vault];\n\n    uint32 reqIdFrom = q$.offset;\n    uint32 reqIdTo = q$.items.length.toUint32();\n\n    for (uint32 i = reqIdFrom; i < reqIdTo;) {\n      Request memory req = q$.items[i];\n\n      uint256 shares = i == 0 ? req.sharesAcc : req.sharesAcc - q$.items[i - 1].sharesAcc;\n      uint256 assets = Math.min(req.assets, IERC4626(vault).previewRedeem(shares));\n\n      if (budget < assets) break;\n      budget -= assets;\n\n      totalSharesSynced += shares;\n      totalAssetsSynced += assets;\n      totalSyncedRequestsCount++;\n\n      unchecked {\n        ++i;\n      } // Use unchecked for gas savings\n    }\n  }\n\n  // =========================== NOTE: QUEUE FUNCTIONS =========================== //\n\n  function request(uint256 shares, address receiver, address vault) public whenNotPaused returns (uint256) {\n    QueueState storage q$ = _getStorageV1().queues[vault];\n\n    require(q$.isEnabled, IReclaimQueue__QueueNotEnabled(vault));\n\n    IERC4626(vault).safeTransferFrom(_msgSender(), address(this), shares);\n\n    uint256 assets = IERC4626(vault).previewRedeem(shares);\n\n    uint48 now_ = Time.timestamp();\n\n    uint256 reqId = q$.items.length;\n\n    {\n      uint208 assets208 = assets.toUint208();\n      uint208 shares208 = shares.toUint208();\n\n      if (reqId == 0) q$.items.push(Request(now_, assets208, shares208));\n      else q$.items.push(Request(now_, assets208, q$.items[reqId - 1].sharesAcc + shares208));\n    }\n\n    q$.indexes[receiver].append(reqId);\n\n    emit Requested(receiver, vault, reqId, shares, assets);\n\n    return reqId;\n  }\n\n  function claim(address receiver, address vault) external nonReentrant whenNotPaused returns (ClaimResult memory) {\n    StorageV1 storage $ = _getStorageV1();\n    {\n      QueueState storage q$ = $.queues[vault];\n      LibQueue.UintOffsetQueue storage index = q$.indexes[receiver];\n\n      uint32 indexSize = index.size();\n\n      require(q$.isEnabled, IReclaimQueue__QueueNotEnabled(vault));\n      require(indexSize != 0, IReclaimQueue__NothingToClaim());\n      require(index.offset() < indexSize, IReclaimQueue__NothingToClaim());\n    }\n\n    // run actual claim logic\n    ClaimResult memory res = _claim($, receiver, vault);\n    require(res.totalAssetsClaimed > 0, IReclaimQueue__NothingToClaim());\n\n    emit ClaimSucceeded(receiver, vault, res);\n\n    // send total claim amount to receiver\n    IERC20Metadata(IERC4626(vault).asset()).safeTransfer(receiver, res.totalAssetsClaimed);\n\n    return res;\n  }\n\n  function sync(address executor, address vault, uint256 requestCount)\n    external\n    whenNotPaused\n    returns (uint256, uint256)\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(_msgSender() == $.resolver, StdError.Unauthorized());\n    require($.queues[vault].isEnabled, IReclaimQueue__QueueNotEnabled(vault));\n\n    SyncResult memory res = _sync($, vault, requestCount);\n    emit Synced(executor, vault, res);\n\n    return (res.totalSharesSynced, Math.min(res.totalAssetsOnRequest, res.totalAssetsOnReserve));\n  }\n\n  // =========================== NOTE: OWNABLE FUNCTIONS =========================== //\n\n  function _authorizeUpgrade(address) internal override onlyOwner { }\n\n  function _authorizePause(address) internal view override onlyOwner { }\n\n  function enableQueue(address vault) external onlyOwner {\n    _enableQueue(_getStorageV1(), vault);\n  }\n\n  function disableQueue(address vault) external onlyOwner {\n    _disableQueue(_getStorageV1(), vault);\n  }\n\n  function setResolver(address resolver_) external onlyOwner {\n    _setResolver(_getStorageV1(), resolver_);\n  }\n\n  function setCollector(address collector_) external onlyOwner {\n    _setCollector(_getStorageV1(), collector_);\n  }\n\n  function setReclaimPeriod(address vault, uint256 reclaimPeriod_) external onlyOwner {\n    _setReclaimPeriod(_getStorageV1(), vault, reclaimPeriod_);\n  }\n\n  // =========================== NOTE: INTERNAL FUNCTIONS =========================== //\n\n  function _convertToAssets(\n    uint256 shares,\n    uint8 decimalsOffset,\n    uint256 totalAssets,\n    uint256 totalSupply,\n    Math.Rounding rounding\n  ) private pure returns (uint256) {\n    return shares.mulDiv(totalAssets, totalSupply + 10 ** decimalsOffset, rounding);\n  }\n\n  struct CalcClaimState {\n    uint256 cachedLogPos;\n    SyncLog cached;\n    uint32 queueOffset;\n    uint48 reqTimeBoundary;\n  }\n\n  function _fetchInitialCalcClaimState(QueueState storage q$) internal view returns (CalcClaimState memory state) {\n    if (q$.logs.length == 0) {\n      return state;\n    }\n\n    uint256 cachedLogPos = q$.logs.length - 1;\n    SyncLog memory cached = _unsafeAccess(q$.logs, cachedLogPos);\n\n    state = CalcClaimState({\n      cachedLogPos: cachedLogPos,\n      cached: cached,\n      queueOffset: q$.offset,\n      reqTimeBoundary: Time.timestamp() - q$.reclaimPeriod\n    });\n  }\n\n  function _fetchSyncLogByReqId(QueueState storage q$, uint256 reqId) internal view returns (SyncLog memory, uint256) {\n    SyncLog[] storage syncLogs = q$.logs;\n    uint256 syncLogsLen = syncLogs.length;\n\n    uint256 pos = _lowerBinaryLookup(syncLogs, reqId, 0, syncLogsLen);\n    SyncLog memory log = _unsafeAccess(syncLogs, pos);\n\n    return (log, pos);\n  }\n\n  function _previewClaimPagination(StorageV1 storage $, address receiver, address vault, uint256 offset, uint256 limit)\n    internal\n    view\n    returns (ClaimResult memory res)\n  {\n    LibQueue.UintOffsetQueue storage index = $.queues[vault].indexes[receiver];\n\n    uint32 reqIdFrom = index.offset() + offset.toUint32();\n    uint32 reqIdTo = Math.min(reqIdFrom + limit.toUint32(), index.size()).toUint32();\n    if (reqIdFrom >= reqIdTo) return res;\n\n    res = _calcClaim(\n      $.queues[vault],\n      ClaimResult({\n        reqIdFrom: reqIdFrom, //\n        reqIdTo: reqIdTo,\n        totalSharesClaimed: 0,\n        totalAssetsClaimed: 0\n      }),\n      receiver,\n      $.vaults[vault].decimalsOffset\n    );\n  }\n\n  function _calcClaim(QueueState storage q$, ClaimResult memory res, address receiver, uint8 decimalsOffset)\n    internal\n    view\n    returns (ClaimResult memory)\n  {\n    CalcClaimState memory state = _fetchInitialCalcClaimState(q$);\n    LibQueue.UintOffsetQueue storage index = q$.indexes[receiver];\n\n    for (uint32 i = res.reqIdFrom; i < res.reqIdTo;) {\n      uint256 reqId = index.itemAt(i);\n      Request memory req = q$.items[reqId];\n\n      // if the request didn't pass the reclaim period or before the sync, stop the loop\n      if (state.queueOffset <= reqId || state.reqTimeBoundary < req.timestamp) {\n        res.reqIdTo = i;\n        break;\n      }\n\n      if (reqId < state.cached.reqIdFrom || state.cached.reqIdTo <= reqId) {\n        (state.cached, state.cachedLogPos) = _fetchSyncLogByReqId(q$, reqId);\n      }\n\n      uint256 shares = i == 0 ? req.sharesAcc : req.sharesAcc - q$.items[reqId - 1].sharesAcc;\n      uint256 assets = Math.min(\n        req.assets,\n        _convertToAssets(\n          shares, //\n          decimalsOffset,\n          state.cached.totalAssets,\n          state.cached.totalSupply,\n          Math.Rounding.Floor\n        )\n      );\n\n      res.totalSharesClaimed += shares;\n      res.totalAssetsClaimed += assets;\n\n      unchecked {\n        ++i;\n      } // Use unchecked for gas savings\n    }\n\n    return res;\n  }\n\n  function _execClaim(\n    QueueState storage q$,\n    ClaimResult memory res,\n    address vault,\n    address receiver,\n    uint8 decimalsOffset\n  ) internal returns (ClaimResult memory) {\n    CalcClaimState memory state = _fetchInitialCalcClaimState(q$);\n    LibQueue.UintOffsetQueue storage index = q$.indexes[receiver];\n\n    for (uint32 i = res.reqIdFrom; i < res.reqIdTo;) {\n      uint256 reqId = index.itemAt(i);\n      Request memory req = q$.items[reqId];\n\n      // if the request didn't pass the reclaim period or before the sync, stop the loop\n      if (state.queueOffset <= reqId || state.reqTimeBoundary < req.timestamp) {\n        res.reqIdTo = i;\n        break;\n      }\n\n      if (reqId < state.cached.reqIdFrom || state.cached.reqIdTo <= reqId) {\n        (state.cached, state.cachedLogPos) = _fetchSyncLogByReqId(q$, reqId);\n      }\n\n      uint256 shares = i == 0 ? req.sharesAcc : req.sharesAcc - q$.items[reqId - 1].sharesAcc;\n      uint256 assets = Math.min(\n        req.assets,\n        _convertToAssets(\n          shares, //\n          decimalsOffset,\n          state.cached.totalAssets,\n          state.cached.totalSupply,\n          Math.Rounding.Floor\n        )\n      );\n\n      emit Claimed(\n        receiver, //\n        vault,\n        reqId,\n        shares,\n        assets,\n        state.cached.totalSupply,\n        state.cached.totalAssets,\n        state.cachedLogPos\n      );\n\n      res.totalSharesClaimed += shares;\n      res.totalAssetsClaimed += assets;\n\n      unchecked {\n        ++i;\n      } // Use unchecked for gas savings\n    }\n\n    return res;\n  }\n\n  function _claim(StorageV1 storage $, address receiver, address vault) internal returns (ClaimResult memory) {\n    QueueState storage q$ = $.queues[vault];\n    LibQueue.UintOffsetQueue storage index = q$.indexes[receiver];\n\n    uint32 reqIdFrom = index.offset();\n    uint32 reqIdTo = Math.min(reqIdFrom + MAX_CLAIM_SIZE, index.size()).toUint32();\n\n    ClaimResult memory res = _execClaim(\n      q$,\n      ClaimResult({\n        reqIdFrom: reqIdFrom, //\n        reqIdTo: reqIdTo,\n        totalSharesClaimed: 0,\n        totalAssetsClaimed: 0\n      }),\n      vault,\n      receiver,\n      $.vaults[vault].decimalsOffset\n    );\n\n    // update index offset if there's at least one request to be claimed\n    if (res.reqIdFrom < res.reqIdTo) index._offset = res.reqIdTo;\n\n    return res;\n  }\n\n  function _calcSync(QueueState storage q$, address vault, uint256 requestCount)\n    internal\n    view\n    returns (SyncResult memory)\n  {\n    // reuse to avoid duplicate SLOAD\n    uint256 itemsLen = q$.items.length;\n    uint32 reqIdFrom = q$.offset;\n    uint32 reqIdTo = Math.min(reqIdFrom + requestCount, itemsLen).toUint32();\n\n    SyncResult memory res = SyncResult({\n      logIndex: q$.logs.length,\n      reqIdFrom: reqIdFrom,\n      reqIdTo: reqIdTo,\n      totalSupply: IERC4626(vault).totalSupply(),\n      totalAssets: IERC4626(vault).totalAssets(),\n      totalSharesSynced: 0,\n      totalAssetsOnReserve: 0,\n      totalAssetsOnRequest: 0\n    });\n\n    for (uint32 i = res.reqIdFrom; i < res.reqIdTo;) {\n      Request memory req = q$.items[i];\n\n      uint256 shares = i == 0 ? req.sharesAcc : req.sharesAcc - q$.items[i - 1].sharesAcc;\n\n      res.totalSharesSynced += shares;\n      res.totalAssetsOnRequest += req.assets;\n      res.totalAssetsOnReserve += IERC4626(vault).previewRedeem(shares);\n\n      unchecked {\n        ++i;\n      } // Use unchecked for gas savings\n    }\n\n    return res;\n  }\n\n  function _sync(StorageV1 storage $, address vault, uint256 requestCount) internal returns (SyncResult memory) {\n    QueueState storage q$ = $.queues[vault];\n    require(q$.items.length != 0, IReclaimQueue__NothingToSync());\n\n    SyncResult memory res = _calcSync(q$, vault, requestCount);\n    require(res.reqIdTo > q$.offset, IReclaimQueue__NothingToSync());\n\n    uint256 withdrawAmount = Math.min(res.totalAssetsOnRequest, res.totalAssetsOnReserve);\n    IERC4626(vault).withdraw(withdrawAmount, address(this), address(this));\n\n    if (res.totalAssetsOnRequest < res.totalAssetsOnReserve) {\n      uint256 assetsCollected = res.totalAssetsOnReserve - res.totalAssetsOnRequest;\n      uint256 sharesCollected = IERC4626(vault).previewWithdraw(assetsCollected);\n\n      IERC20Metadata(vault).forceApprove($.collector, sharesCollected);\n      IReclaimQueueCollector($.collector).collect(vault, vault, sharesCollected);\n      IERC20Metadata(vault).forceApprove($.collector, 0);\n    }\n\n    {\n      SyncLog[] storage syncLogs = q$.logs;\n\n      uint256 syncLogsLen = syncLogs.length;\n      uint256 nextSharesAcc =\n        syncLogsLen == 0 ? res.totalSharesSynced : syncLogs[syncLogsLen - 1].sharesAcc + res.totalSharesSynced;\n\n      res.logIndex = syncLogs.length;\n\n      syncLogs.push(\n        SyncLog({\n          timestamp: Time.timestamp(),\n          reqIdFrom: res.reqIdFrom,\n          reqIdTo: res.reqIdTo,\n          sharesAcc: nextSharesAcc.toUint144(),\n          totalSupply: res.totalSupply.toUint128(),\n          totalAssets: res.totalAssets.toUint128()\n        })\n      );\n    }\n\n    q$.offset = res.reqIdTo;\n\n    return res;\n  }\n\n  function _enableQueue(StorageV1 storage $, address vault) internal {\n    $.queues[vault].isEnabled = true;\n\n    uint8 underlyingDecimals = IERC20Metadata(IERC4626(vault).asset()).decimals();\n    $.vaults[vault].underlyingDecimals = underlyingDecimals;\n    $.vaults[vault].decimalsOffset = IERC4626(vault).decimals() - underlyingDecimals;\n\n    emit QueueEnabled(vault);\n  }\n\n  function _disableQueue(StorageV1 storage $, address vault) internal {\n    $.queues[vault].isEnabled = false;\n\n    emit QueueDisabled(vault);\n  }\n\n  function _setResolver(StorageV1 storage $, address resolver_) internal {\n    $.resolver = resolver_;\n    emit ResolverSet(resolver_);\n  }\n\n  function _setCollector(StorageV1 storage $, address collector_) internal {\n    $.collector = collector_;\n    emit CollectorSet(collector_);\n  }\n\n  function _setReclaimPeriod(StorageV1 storage $, address vault, uint256 reclaimPeriod_) internal {\n    require($.queues[vault].isEnabled, IReclaimQueue__QueueNotEnabled(vault));\n\n    $.queues[vault].reclaimPeriod = reclaimPeriod_.toUint48();\n\n    emit ReclaimPeriodSet(vault, reclaimPeriod_);\n  }\n\n  function _lowerBinaryLookup(SyncLog[] storage self, uint256 reqId, uint256 low, uint256 high)\n    private\n    view\n    returns (uint256)\n  {\n    while (low < high) {\n      uint256 mid = Math.average(low, high);\n      if (_unsafeAccess(self, mid).reqIdTo <= reqId) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return high;\n  }\n\n  function _unsafeAccess(SyncLog[] storage self, uint256 pos) private pure returns (SyncLog storage result) {\n    assembly {\n      // Get the array's storage slot\n      mstore(0, self.slot)\n      // Multiply position by 2 (since each element takes 2 storage slots)\n      let slotOffset := shl(1, pos)\n      // Add the offset to the base storage location\n      result.slot := add(keccak256(0, 0x20), slotOffset)\n    }\n  }\n\n  function _validateIndex(uint256 index, uint256 length) private pure {\n    require(length != 0, IReclaimQueue__Empty());\n    require(length - 1 >= index, IReclaimQueue__OutOfBounds(length - 1, index));\n  }\n}\n"
    }
}