{
    "vfp_id": "vfp_00230",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Zero amount transfers in claim may revert",
            "description": "The vulnerability exists in the _claim function of MerkleRewardDistributor.sol, where zero-amount reward transfers are performed unconditionally. Some non-standard ERC20 tokens revert when a zero-value transfer is attempted, which would cause the entire claim transaction to revert, even if other rewards have non-zero amounts. This behavior stems from the lack of a check for zero amounts before executing transfers. An attacker or user attempting to claim multiple rewards, including zero-amount entries, could experience a failed transaction due to the reversion on zero transfers. The impact is limited to transaction failure for valid claims, potentially leading to user frustration or gas loss, but does not result in fund loss or critical system compromise.\n",
            "severity": "Informational",
            "location": [
                "MerkleRewardDistributor.sol#L331"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/reward/MerkleRewardDistributor.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Flawed encoding with dynamic types allows potentially passing data with incorrect values",
            "description": "The `_leaf` function in `MerkleRewardDistributor` uses `abi.encodePacked` on dynamic arrays (`rewards` and `amounts`), which can lead to ambiguous encodings. Because `encodePacked` concatenates values without separators, different input combinations can produce the same output (e.g., [0x123, 0x456] vs [0x123456]). This enables second-preimage attacks where an invalid proof could be constructed to match a valid leaf hash. As a result, users might be able to claim rewards they are not entitled to, or valid claims could be disputed due to hash collisions.\n",
            "severity": "Low",
            "location": [
                "MerkleRewardDistributor.sol#L341-L349"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/reward/MerkleRewardDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "MerkleRewardDistributor.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { IERC20 } from '@oz/interfaces/IERC20.sol';\nimport { SafeERC20 } from '@oz/token/ERC20/utils/SafeERC20.sol';\nimport { MerkleProof } from '@oz/utils/cryptography/MerkleProof.sol';\nimport { AccessControlEnumerableUpgradeable } from '@ozu/access/extensions/AccessControlEnumerableUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { IMerkleRewardDistributor } from '../../interfaces/hub/reward/IMerkleRewardDistributor.sol';\nimport { ITreasury } from '../../interfaces/hub/reward/ITreasury.sol';\nimport { StdError } from '../../lib/StdError.sol';\nimport { Versioned } from '../../lib/Versioned.sol';\nimport { MerkleRewardDistributorStorageV1 } from './MerkleRewardDistributorStorageV1.sol';\n\ncontract MerkleRewardDistributor is\n  IMerkleRewardDistributor,\n  AccessControlEnumerableUpgradeable,\n  UUPSUpgradeable,\n  MerkleRewardDistributorStorageV1,\n  Versioned\n{\n  using SafeERC20 for IERC20;\n  using MerkleProof for bytes32[];\n\n  /// @notice Role for manager (keccak256(\"MANAGER_ROLE\"))\n  bytes32 public constant MANAGER_ROLE = 0x241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08;\n\n  /// @notice Maximum number of rewards that can be claimed in a single call.\n  uint256 public constant MAX_CLAIM_VAULT_SIZE = 100;\n\n  /// @notice Maximum number of batch claims that can be made in a single call.\n  uint256 public constant MAX_CLAIM_STAGES_SIZE = 10;\n\n  //=========== NOTE: INITIALIZATION FUNCTIONS ===========//\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address admin, address treasury_) public initializer {\n    require(admin != address(0), StdError.ZeroAddress('admin'));\n\n    __AccessControlEnumerable_init();\n    __UUPSUpgradeable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _setRoleAdmin(MANAGER_ROLE, DEFAULT_ADMIN_ROLE);\n\n    StorageV1 storage $ = _getStorageV1();\n    $.lastStage = 0; // note: currentStage starts from 1\n    _setTreasury($, treasury_);\n  }\n\n  // ============================ NOTE: VIEW FUNCTIONS ============================ //\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function lastStage() external view returns (uint256) {\n    return _getStorageV1().lastStage;\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function root(uint256 stage_) external view returns (bytes32) {\n    return _stage(_getStorageV1(), stage_).root;\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function rewardInfo(uint256 stage_) external view returns (address[] memory, uint256[] memory) {\n    Stage storage s = _stage(_getStorageV1(), stage_);\n    return (s.rewards, s.amounts);\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function treasury() external view returns (ITreasury) {\n    return _getStorageV1().treasury;\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function encodeLeaf(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external pure returns (bytes32 leaf) {\n    return _leaf(receiver, stage, vault, rewards, amounts);\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claimable(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) external view returns (bool) {\n    return _claimable(receiver, stage, vault, rewards, amounts, proof);\n  }\n\n  // ============================ NOTE: MUTATIVE FUNCTIONS ============================ //\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claim(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) public {\n    _claim(receiver, stage, vault, rewards, amounts, proof);\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claimMultiple(\n    address receiver,\n    uint256 stage,\n    address[] calldata vaults,\n    address[][] calldata rewards,\n    uint256[][] calldata amounts,\n    bytes32[][] calldata proofs\n  ) public {\n    require(vaults.length == rewards.length, StdError.InvalidParameter('rewards.length'));\n    require(vaults.length == amounts.length, StdError.InvalidParameter('amounts.length'));\n    require(vaults.length == proofs.length, StdError.InvalidParameter('proofs.length'));\n    require(vaults.length <= MAX_CLAIM_VAULT_SIZE, StdError.InvalidParameter('vaults.length'));\n\n    for (uint256 i = 0; i < vaults.length; i++) {\n      claim(receiver, stage, vaults[i], rewards[i], amounts[i], proofs[i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claimBatch(\n    address receiver,\n    uint256[] calldata stages,\n    address[][] calldata vaults,\n    address[][][] calldata rewards,\n    uint256[][][] calldata amounts,\n    bytes32[][][] calldata proofs\n  ) public {\n    require(stages.length == vaults.length, StdError.InvalidParameter('vaults.length'));\n    require(stages.length == rewards.length, StdError.InvalidParameter('rewards.length'));\n    require(stages.length == amounts.length, StdError.InvalidParameter('amounts.length'));\n    require(stages.length == proofs.length, StdError.InvalidParameter('proofs.length'));\n    require(stages.length <= MAX_CLAIM_STAGES_SIZE, StdError.InvalidParameter('stages.length'));\n\n    for (uint256 i = 0; i < stages.length; i++) {\n      claimMultiple(receiver, stages[i], vaults[i], rewards[i], amounts[i], proofs[i]);\n    }\n  }\n\n  // ============================ NOTE: ADMIN FUNCTIONS ============================ //\n\n  function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }\n\n  // ============================ NOTE: MANAGER FUNCTIONS ============================ //\n\n  function fetchRewards(uint256 stage, uint256 nonce, address vault, address reward, uint256 amount)\n    external\n    onlyRole(MANAGER_ROLE)\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(stage == $.lastStage + 1, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == _stage($, stage).nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n\n    _fetchRewards($, stage, vault, reward, amount);\n  }\n\n  function fetchRewardsMultiple(\n    uint256 stage,\n    uint256 nonce,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external onlyRole(MANAGER_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(stage == $.lastStage + 1, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == _stage($, stage).nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n\n    for (uint256 i = 0; i < rewards.length; i++) {\n      _fetchRewards($, stage, vault, rewards[i], amounts[i]);\n    }\n  }\n\n  function fetchRewardsBatch(\n    uint256 stage,\n    uint256 nonce,\n    address[] calldata vaults,\n    address[][] calldata rewards,\n    uint256[][] calldata amounts\n  ) external onlyRole(MANAGER_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(stage == $.lastStage + 1, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == _stage($, stage).nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n    require(vaults.length == rewards.length, StdError.InvalidParameter('rewards.length'));\n\n    for (uint256 i = 0; i < vaults.length; i++) {\n      for (uint256 j = 0; j < rewards[i].length; j++) {\n        _fetchRewards($, stage, vaults[i], rewards[i][j], amounts[i][j]);\n      }\n    }\n  }\n\n  function addStage(\n    bytes32 merkleRoot,\n    uint256 stage,\n    uint256 nonce,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external onlyRole(MANAGER_ROLE) returns (uint256) {\n    StorageV1 storage $ = _getStorageV1();\n    Stage storage s = _stage($, stage);\n\n    require(rewards.length == amounts.length, StdError.InvalidParameter('amounts.length'));\n    require(nonce == s.nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n\n    _addStage($, stage, merkleRoot, rewards, amounts);\n\n    for (uint256 i = 0; i < rewards.length; i++) {\n      address reward = rewards[i];\n      uint256 amount = amounts[i];\n      require(_availableRewardAmount($, reward) >= amount, IMerkleRewardDistributor__InvalidAmount());\n      $.reservedRewardAmounts[reward] += amount;\n    }\n\n    return stage;\n  }\n\n  // ============================ NOTE: INTERNAL FUNCTIONS ============================ //\n\n  function _setTreasury(StorageV1 storage $, address treasury_) internal {\n    require(treasury_.code.length > 0, StdError.InvalidAddress('treasury'));\n\n    ITreasury oldTreasury = $.treasury;\n    $.treasury = ITreasury(treasury_);\n\n    emit TreasuryUpdated(address(oldTreasury), treasury_);\n  }\n\n  function _fetchRewards(StorageV1 storage $, uint256 stage, address vault, address reward, uint256 amount) internal {\n    Stage storage s = _stage($, stage);\n    uint256 nonce = s.nonce++;\n\n    $.treasury.dispatch(vault, reward, amount, address(this));\n\n    emit RewardsFetched(stage, nonce, vault, reward, amount);\n  }\n\n  function _addStage(\n    StorageV1 storage $,\n    uint256 stage_,\n    bytes32 root_,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) internal {\n    require(stage_ == $.lastStage + 1, IMerkleRewardDistributor__NotCurrentStage(stage_));\n    Stage storage s = _stage($, stage_);\n    s.root = root_;\n    s.rewards = rewards;\n    s.amounts = amounts;\n    $.lastStage = stage_;\n    emit StageAdded(stage_, root_, rewards, amounts);\n  }\n\n  function _stage(StorageV1 storage $, uint256 stage) internal view returns (Stage storage) {\n    return $.stages[stage];\n  }\n\n  function _claimable(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) internal view returns (bool) {\n    StorageV1 storage $ = _getStorageV1();\n    Stage storage s = _stage($, stage);\n\n    bytes32 leaf = _leaf(receiver, stage, vault, rewards, amounts);\n\n    return !s.claimed[receiver][vault] && proof.verify(s.root, leaf);\n  }\n\n  function _claim(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) internal {\n    StorageV1 storage $ = _getStorageV1();\n    Stage storage s = _stage($, stage);\n    require(!s.claimed[receiver][vault], IMerkleRewardDistributor__AlreadyClaimed());\n\n    uint256 rewardsLen = rewards.length;\n    bytes32 leaf = _leaf(receiver, stage, vault, rewards, amounts);\n    require(proof.verify(s.root, leaf), IMerkleRewardDistributor__InvalidProof());\n    require(rewardsLen == amounts.length, StdError.InvalidParameter('amounts.length'));\n\n    s.claimed[receiver][vault] = true;\n    for (uint256 i = 0; i < rewardsLen; i++) {\n      $.reservedRewardAmounts[rewards[i]] -= amounts[i];\n    }\n\n    for (uint256 i = 0; i < rewardsLen; i++) {\n      IERC20(rewards[i]).safeTransfer(receiver, amounts[i]);\n    }\n\n    emit Claimed(receiver, stage, vault, rewards, amounts);\n  }\n\n  function _availableRewardAmount(StorageV1 storage $, address reward) internal view returns (uint256) {\n    return IERC20(reward).balanceOf(address(this)) - $.reservedRewardAmounts[reward];\n  }\n\n  function _leaf(address receiver, uint256 stage, address vault, address[] calldata rewards, uint256[] calldata amounts)\n    internal\n    pure\n    returns (bytes32 leaf)\n  {\n    // double-hashing to prevent second preimage attacks:\n    // https://flawed.net.nz/2018/02/21/attacking-merkle-trees-with-a-second-preimage-attack/\n    return keccak256(bytes.concat(keccak256(abi.encodePacked(receiver, stage, vault, rewards, amounts))));\n  }\n}\n"
    }
}