{
    "vfp_id": "vfp_00596",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused Named Return Variables",
            "description": "Functions declare named return variables that are never assigned or used, which can mislead developers into thinking they are part of the return logic. The cause is leftover variable declarations from prior implementations. This harms code clarity and may lead to bugs if developers assume the variables are used. The impact is reduced readability and potential for logic errors.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol::getOpenRatio#135",
                "PositionLogic.sol::getPositionDebtRatio#46"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Constants",
            "description": "Constants are defined but never used in the code, adding unnecessary complexity. The cause is leftover definitions from prior development. This reduces code clarity and may mislead developers about their purpose. The impact is reduced readability and maintainability.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol::INTEREST_RATE_OFFSET#33",
                "AaveFundingPool.sol::TIMESTAMP_OFFSET#36",
                "PoolConstant.sol::X60#31",
                "PoolConstant.sol::X96#32"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-547"
                ]
            },
            "title": "Literal Number Safety",
            "description": "Large literal numbers are used directly in the code without suffixes or scientific notation, making them hard to read and prone to errors. The cause is the use of raw numbers instead of Ether or time units. This can lead to mistakes in value interpretation (e.g., mistaking wei for ether). The impact is reduced readability and potential for incorrect value usage.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol#120",
                "BasePool.sol#64",
                "PegKeeper.sol#105"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "Magic Numbers",
            "description": "The `initialize` function in `AaveFundingPool` uses a literal value `1e9` without explanation, making its purpose unclear. The cause is the absence of a named constant to document the value's meaning. This reduces code readability and makes future maintenance harder. The impact is potential confusion and errors during updates or audits.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol#125"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Missing Docstrings",
            "description": "Numerous contracts, functions, and state variables lack NatSpec documentation, including critical initialization functions and public interfaces. The cause is insufficient code documentation practices. This reduces code readability, maintainability, and auditability, making it harder for developers and auditors to understand the intended behavior. While there is no direct security exploit, the lack of documentation increases the risk of incorrect usage, integration errors, and missed vulnerabilities during audits. Off-chain tools relying on NatSpec for UI generation or analysis will also be impaired.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol#13",
                "AaveFundingPool.sol::initialize#101-126",
                "AaveV3Strategy.sol::POOL#16",
                "AaveV3Strategy.sol::INCENTIVE#18",
                "AaveV3Strategy.sol::ASSET#20",
                "AaveV3Strategy.sol::ATOKEN#22",
                "AaveV3Strategy.sol::principal#24",
                "AaveV3Strategy.sol::totalSupply#42-44",
                "AaveV3Strategy.sol::deposit#46-51",
                "AaveV3Strategy.sol::withdraw#53-60",
                "AaveV3Strategy.sol::kill#62-67",
                "AssetManagement.sol::ASSET_MANAGER_ROLE#15",
                "AssetManagement.sol::allocations#22",
                "AssetManagement.sol::kill#30-38",
                "AssetManagement.sol::alloc#40-44",
                "AssetManagement.sol::manage#46-52",
                "FxUSDBasePool.sol::initialize#196-219",
                "FxUSDBasePool.sol::updateInstantRedeemFeeRatio#535-537",
                "FxUSDRegeneracy.sol::initialize#150-158",
                "FxUSDRegeneracy.sol::initializeV2#160-163",
                "IStrategy.sol::totalSupply#6",
                "IStrategy.sol::deposit#8",
                "IStrategy.sol::withdraw#10",
                "IStrategy.sol::kill#12",
                "IStrategy.sol::harvest#14",
                "PegKeeper.sol::initialize#96-108",
                "PoolManager.sol::initialize#184-204",
                "PoolManager.sol::initializeV2#206-219",
                "ReservePool.sol::receive#69",
                "SavingFxUSD.sol::execute#34-48",
                "SavingFxUSD.sol::initialize#125-142",
                "StrategyBase.sol::HARVESTER_ROLE#8",
                "StrategyBase.sol::operator#10",
                "StrategyBase.sol::harvest#29-31",
                "StrategyBase.sol::execute#33-39"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Use `calldata` Instead of `memory`",
            "description": "Using `memory` for external function parameters results in higher gas costs compared to `calldata`, which is a read-only and cheaper memory region for function arguments. The cause is the unnecessary copying of data from calldata to memory in external functions. An attacker cannot directly exploit this, but users will pay higher gas fees for transactions. The impact is increased transaction costs and reduced efficiency, though there is no direct security risk.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol::name_#103",
                "AaveFundingPool.sol::symbol_#104",
                "BTCDerivativeOracleBase.sol::encodings#108",
                "ETHPriceOracle.sol::encodings#99",
                "FxUSDBasePool.sol::_name#198",
                "FxUSDBasePool.sol::_symbol#199",
                "FxUSDRegeneracy.sol::_name#150",
                "FxUSDRegeneracy.sol::_symbol#150",
                "FxUSDRegeneracy.sol::_minOuts#324",
                "LSDPriceOracleBase.sol::encodings#125",
                "ProtocolFees.sol::pools#197",
                "SavingFxUSD.sol::params#125"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Inconsistent Order Within Contracts",
            "description": "The ordering of functions within multiple contracts does not follow a consistent pattern, reducing code readability and maintainability. The cause is the lack of adherence to the Solidity Style Guide's recommended function ordering. This is not a security issue, but inconsistent structure can lead to confusion and increase the risk of missing logic during audits or updates. The impact is reduced code clarity and potential for human error during development.\n",
            "severity": null,
            "location": [
                "AaveFundingPool.sol",
                "AaveV3Strategy.sol",
                "AssetManagement.sol",
                "BTCDerivativeOracleBase.sol",
                "BasePool.sol",
                "ETHPriceOracle.sol",
                "FlashLoans.sol",
                "FxUSDBasePool.sol",
                "FxUSDRegeneracy.sol",
                "LSDPriceOracleBase.sol",
                "PegKeeper.sol",
                "PoolManager.sol",
                "PoolStorage.sol",
                "PositionLogic.sol",
                "ProtocolFees.sol",
                "ReservePool.sol",
                "SavingFxUSD.sol",
                "SpotPriceOracleBase.sol",
                "StrategyBase.sol",
                "WBTCPriceOracle.sol"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/AaveFundingPool.sol"
            ]
        }
    ],
    "affected_files": {
        "AaveFundingPool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { IAaveV3Pool } from \"../../interfaces/Aave/IAaveV3Pool.sol\";\nimport { IAaveFundingPool } from \"../../interfaces/IAaveFundingPool.sol\";\nimport { IPegKeeper } from \"../../interfaces/IPegKeeper.sol\";\n\nimport { WordCodec } from \"../../common/codec/WordCodec.sol\";\nimport { Math } from \"../../libraries/Math.sol\";\nimport { BasePool } from \"./BasePool.sol\";\n\ncontract AaveFundingPool is BasePool, IAaveFundingPool {\n  using WordCodec for bytes32;\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The offset of *open ratio* in `fundingMiscData`.\n  uint256 private constant OPEN_RATIO_OFFSET = 0;\n\n  /// @dev The offset of *open ratio step* in `fundingMiscData`.\n  uint256 private constant OPEN_RATIO_STEP_OFFSET = 30;\n\n  /// @dev The offset of *close fee ratio* in `fundingMiscData`.\n  uint256 private constant CLOSE_FEE_RATIO_OFFSET = 90;\n\n  /// @dev The offset of *funding ratio* in `fundingMiscData`.\n  uint256 private constant FUNDING_RATIO_OFFSET = 120;\n\n  /// @dev The offset of *interest rate* in `fundingMiscData`.\n  uint256 private constant INTEREST_RATE_OFFSET = 152;\n\n  /// @dev The offset of *timestamp* in `fundingMiscData`.\n  uint256 private constant TIMESTAMP_OFFSET = 220;\n\n  /// @dev The maximum value of *funding ratio*.\n  uint256 private constant MAX_FUNDING_RATIO = 4294967295;\n\n  /// @dev The minimum Aave borrow index snapshot delay.\n  uint256 private constant MIN_SNAPSHOT_DELAY = 30 minutes;\n\n  /***********************\n   * Immutable Variables *\n   ***********************/\n\n  /// @dev The address of Aave V3 `LendingPool` contract.\n  address private immutable lendingPool;\n\n  /// @dev The address of asset used for interest calculation.\n  address private immutable baseAsset;\n\n  /***********\n   * Structs *\n   ***********/\n\n  /// @dev The struct for AAVE borrow rate snapshot.\n  /// @param borrowIndex The current borrow index of AAVE, multiplied by 1e27.\n  /// @param lastInterestRate The last recorded interest rate, multiplied by 1e18.\n  /// @param timestamp The timestamp when the snapshot is taken.\n  struct BorrowRateSnapshot {\n    // The initial value of `borrowIndex` is `10^27`, it is very unlikely this value will exceed `2^128`.\n    uint128 borrowIndex;\n    uint80 lastInterestRate;\n    uint48 timestamp;\n  }\n\n  /*********************\n   * Storage Variables *\n   *********************/\n\n  /// @dev `fundingMiscData` is a storage slot that can be used to store unrelated pieces of information.\n  ///\n  /// - The *open ratio* is the fee ratio for opening position, multiplied by 1e9.\n  /// - The *open ratio step* is the fee ratio step for opening position, multiplied by 1e18.\n  /// - The *close fee ratio* is the fee ratio for closing position, multiplied by 1e9.\n  /// - The *funding ratio* is the scalar for funding rate, multiplied by 1e9.\n  ///   The maximum value is `4.294967296`.\n  ///\n  /// [ open ratio | open ratio step | close fee ratio | funding ratio | reserved ]\n  /// [  30  bits  |     60 bits     |     30 bits     |    32 bits    | 104 bits ]\n  /// [ MSB                                                                   LSB ]\n  bytes32 private fundingMiscData;\n\n  /// @notice The snapshot for AAVE borrow rate.\n  BorrowRateSnapshot public borrowRateSnapshot;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address _poolManager, address _lendingPool, address _baseAsset) BasePool(_poolManager) {\n    _checkAddressNotZero(_lendingPool);\n    _checkAddressNotZero(_baseAsset);\n\n    lendingPool = _lendingPool;\n    baseAsset = _baseAsset;\n  }\n\n  function initialize(\n    address admin,\n    string memory name_,\n    string memory symbol_,\n    address _collateralToken,\n    address _priceOracle\n  ) external initializer {\n    __Context_init();\n    __ERC165_init();\n    __ERC721_init(name_, symbol_);\n    __AccessControl_init();\n\n    __PoolStorage_init(_collateralToken, _priceOracle);\n    __TickLogic_init();\n    __PositionLogic_init();\n    __BasePool_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n    _updateOpenRatio(1000000, 50000000000000000); // 0.1% and 5%\n    _updateCloseFeeRatio(1000000); // 0.1%\n\n    uint256 borrowIndex = IAaveV3Pool(lendingPool).getReserveNormalizedVariableDebt(baseAsset);\n    IAaveV3Pool.ReserveDataLegacy memory reserveData = IAaveV3Pool(lendingPool).getReserveData(baseAsset);\n    _updateInterestRate(borrowIndex, reserveData.currentVariableBorrowRate / 1e9);\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Get open fee ratio related parameters.\n  /// @return ratio The value of open ratio, multiplied by 1e9.\n  /// @return step The value of open ratio step, multiplied by 1e18.\n  function getOpenRatio() external view returns (uint256 ratio, uint256 step) {\n    return _getOpenRatio();\n  }\n\n  /// @notice Return the value of funding ratio, multiplied by 1e9.\n  function getFundingRatio() external view returns (uint256) {\n    return _getFundingRatio();\n  }\n\n  /// @notice Return the fee ratio for opening position, multiplied by 1e9.\n  function getOpenFeeRatio() public view returns (uint256) {\n    (uint256 openRatio, uint256 openRatioStep) = _getOpenRatio();\n    (, uint256 rate) = _getAverageInterestRate(borrowRateSnapshot);\n    unchecked {\n      uint256 aaveRatio = rate <= openRatioStep ? 1 : (rate - 1) / openRatioStep;\n      return aaveRatio * openRatio;\n    }\n  }\n\n  /// @notice Return the fee ratio for closing position, multiplied by 1e9.\n  function getCloseFeeRatio() external view returns (uint256) {\n    return _getCloseFeeRatio();\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the fee ratio for opening position.\n  /// @param ratio The open ratio value, multiplied by 1e9.\n  /// @param step The open ratio step value, multiplied by 1e18.\n  function updateOpenRatio(uint256 ratio, uint256 step) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateOpenRatio(ratio, step);\n  }\n\n  /// @notice Update the fee ratio for closing position.\n  /// @param ratio The close ratio value, multiplied by 1e9.\n  function updateCloseFeeRatio(uint256 ratio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateCloseFeeRatio(ratio);\n  }\n\n  /// @notice Update the funding ratio.\n  /// @param ratio The funding ratio value, multiplied by 1e9.\n  function updateFundingRatio(uint256 ratio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateFundingRatio(ratio);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to get open ratio and open ratio step.\n  /// @return ratio The value of open ratio, multiplied by 1e9.\n  /// @return step The value of open ratio step, multiplied by 1e18.\n  function _getOpenRatio() internal view returns (uint256 ratio, uint256 step) {\n    bytes32 data = fundingMiscData;\n    ratio = data.decodeUint(OPEN_RATIO_OFFSET, 30);\n    step = data.decodeUint(OPEN_RATIO_STEP_OFFSET, 60);\n  }\n\n  /// @dev Internal function to update the fee ratio for opening position.\n  /// @param ratio The open ratio value, multiplied by 1e9.\n  /// @param step The open ratio step value, multiplied by 1e18.\n  function _updateOpenRatio(uint256 ratio, uint256 step) internal {\n    _checkValueTooLarge(ratio, FEE_PRECISION);\n    _checkValueTooLarge(step, PRECISION);\n\n    bytes32 data = fundingMiscData;\n    data = data.insertUint(ratio, OPEN_RATIO_OFFSET, 30);\n    fundingMiscData = data.insertUint(step, OPEN_RATIO_STEP_OFFSET, 60);\n\n    emit UpdateOpenRatio(ratio, step);\n  }\n\n  /// @dev Internal function to get the value of close ratio, multiplied by 1e9.\n  function _getCloseFeeRatio() internal view returns (uint256) {\n    return fundingMiscData.decodeUint(CLOSE_FEE_RATIO_OFFSET, 30);\n  }\n\n  /// @dev Internal function to update the fee ratio for closing position.\n  /// @param newRatio The close fee ratio value, multiplied by 1e9.\n  function _updateCloseFeeRatio(uint256 newRatio) internal {\n    _checkValueTooLarge(newRatio, FEE_PRECISION);\n\n    bytes32 data = fundingMiscData;\n    uint256 oldRatio = data.decodeUint(CLOSE_FEE_RATIO_OFFSET, 30);\n    fundingMiscData = data.insertUint(newRatio, CLOSE_FEE_RATIO_OFFSET, 30);\n\n    emit UpdateCloseFeeRatio(oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to get the value of funding ratio, multiplied by 1e9.\n  function _getFundingRatio() internal view returns (uint256) {\n    return fundingMiscData.decodeUint(FUNDING_RATIO_OFFSET, 32);\n  }\n\n  /// @dev Internal function to update the funding ratio.\n  /// @param newRatio The funding ratio value, multiplied by 1e9.\n  function _updateFundingRatio(uint256 newRatio) internal {\n    _checkValueTooLarge(newRatio, MAX_FUNDING_RATIO);\n\n    bytes32 data = fundingMiscData;\n    uint256 oldRatio = data.decodeUint(FUNDING_RATIO_OFFSET, 32);\n    fundingMiscData = data.insertUint(newRatio, FUNDING_RATIO_OFFSET, 32);\n\n    emit UpdateFundingRatio(oldRatio, newRatio);\n  }\n\n  /// @dev Internal function to return interest rate snapshot.\n  /// @param snapshot The previous borrow index snapshot.\n  /// @return newBorrowIndex The current borrow index, multiplied by 1e27.\n  /// @return rate The annual interest rate, multiplied by 1e18.\n  function _getAverageInterestRate(\n    BorrowRateSnapshot memory snapshot\n  ) internal view returns (uint256 newBorrowIndex, uint256 rate) {\n    uint256 prevBorrowIndex = snapshot.borrowIndex;\n    newBorrowIndex = IAaveV3Pool(lendingPool).getReserveNormalizedVariableDebt(baseAsset);\n    // absolute rate change is (new - prev) / prev\n    // annual interest rate is (new - prev) / prev / duration * 365 days\n    uint256 duration = block.timestamp - snapshot.timestamp;\n    // @note Users can trigger this every `MIN_SNAPSHOT_DELAY` seconds and make the interest rate never change.\n    // We allow users to do so, since the risk is not very high. And if we remove this if, the computed interest\n    // rate may not correct due to small `duration`.\n    if (duration < MIN_SNAPSHOT_DELAY) {\n      rate = snapshot.lastInterestRate;\n    } else {\n      rate = ((newBorrowIndex - prevBorrowIndex) * 365 days * PRECISION) / (prevBorrowIndex * duration);\n      if (rate == 0) rate = snapshot.lastInterestRate;\n    }\n  }\n\n  /// @dev Internal function to update interest rate snapshot.\n  function _updateInterestRate(uint256 newBorrowIndex, uint256 lastInterestRate) internal {\n    BorrowRateSnapshot memory snapshot = borrowRateSnapshot;\n    snapshot.borrowIndex = uint128(newBorrowIndex);\n    snapshot.lastInterestRate = uint80(lastInterestRate);\n    snapshot.timestamp = uint48(block.timestamp);\n    borrowRateSnapshot = snapshot;\n\n    emit SnapshotAaveBorrowIndex(newBorrowIndex, block.timestamp);\n  }\n\n  /// @inheritdoc BasePool\n  function _updateCollAndDebtIndex() internal virtual override returns (uint256 newCollIndex, uint256 newDebtIndex) {\n    (newDebtIndex, newCollIndex) = _getDebtAndCollateralIndex();\n\n    BorrowRateSnapshot memory snapshot = borrowRateSnapshot;\n    uint256 duration = block.timestamp - snapshot.timestamp;\n    if (duration > 0) {\n      (uint256 borrowIndex, uint256 interestRate) = _getAverageInterestRate(snapshot);\n      if (IPegKeeper(pegKeeper).isFundingEnabled()) {\n        (, uint256 totalColls) = _getDebtAndCollateralShares();\n        uint256 totalRawColls = _convertToRawColl(totalColls, newCollIndex, Math.Rounding.Down);\n        uint256 funding = (totalRawColls * interestRate * duration) / (365 days * PRECISION);\n        funding = ((funding * _getFundingRatio()) / FEE_PRECISION);\n\n        // update collateral index with funding costs\n        newCollIndex = (newCollIndex * totalRawColls) / (totalRawColls - funding);\n        _updateCollateralIndex(newCollIndex);\n      }\n\n      // update interest snapshot\n      _updateInterestRate(borrowIndex, interestRate);\n    }\n  }\n\n  /// @inheritdoc BasePool\n  function _deductProtocolFees(int256 rawColl) internal view virtual override returns (uint256) {\n    if (rawColl > 0) {\n      // open position or add collateral\n      uint256 feeRatio = getOpenFeeRatio();\n      if (feeRatio > FEE_PRECISION) feeRatio = FEE_PRECISION;\n      return (uint256(rawColl) * feeRatio) / FEE_PRECISION;\n    } else {\n      // close position or remove collateral\n      return (uint256(-rawColl) * _getCloseFeeRatio()) / FEE_PRECISION;\n    }\n  }\n}\n"
    }
}