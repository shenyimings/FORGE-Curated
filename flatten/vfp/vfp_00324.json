{
    "vfp_id": "vfp_00324",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Malicious node operators can add validators with reused pubkeys to drain user capital",
            "description": "The vulnerability allows malicious node operators to add new validators using public keys (pubkeys) that are already associated with staking validators. This occurs because the protocol does not enforce global uniqueness of validator pubkeys when adding new validators via RocketNodeDeposit.sol.\n\nThe root cause is the absence of a check to ensure that a validator's pubkey is unique across all protocol megapools before registration. As a result, a malicious node operator can reuse a pubkey from an already staking validator when depositing additional funds.\n\nAn attacker can exploit this by depositing additional ETH toward a validator they already control using a reused pubkey. When the validator's actual balance exceeds the MAX_EFFECTIVE_BALANCE of 32 ETH on the beacon chain, the excess is treated as rewards and periodically skimmed via partial withdrawals to the validatorâ€™s withdrawal credentials, which are controlled by the node operator.\n\nThe impact is a direct loss of user deposit pool capital, as the skimmed amounts are effectively stolen from the protocol. This can be repeated across multiple validators, leading to a significant drain of funds and potentially causing a depeg of rETH.\n",
            "severity": "Critical",
            "location": [
                "RocketNodeDeposit.sol::deposit#184-185",
                "RocketNodeDeposit.sol::depositMulti#223-224"
            ],
            "files": [
                "rocketpool/contracts/contract/node/RocketNodeDeposit.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketNodeDeposit.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketVaultInterface} from \"../../interface/RocketVaultInterface.sol\";\nimport {RocketVaultWithdrawerInterface} from \"../../interface/RocketVaultWithdrawerInterface.sol\";\nimport {RocketDAOProtocolSettingsNodeInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport {RocketDepositPoolInterface} from \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport {RocketMegapoolFactoryInterface} from \"../../interface/megapool/RocketMegapoolFactoryInterface.sol\";\nimport {RocketMegapoolInterface} from \"../../interface/megapool/RocketMegapoolInterface.sol\";\nimport {RocketMegapoolManagerInterface} from \"../../interface/megapool/RocketMegapoolManagerInterface.sol\";\nimport {RocketNodeDepositInterface} from \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\n\n/// @notice Entry point for node operators to perform deposits for the creation of new validators on the network\ncontract RocketNodeDeposit is RocketBase, RocketNodeDepositInterface, RocketVaultWithdrawerInterface {\n    // Constants\n    uint256 constant internal pubKeyLength = 48;\n    uint256 constant internal signatureLength = 96;\n\n    // Events\n    event DepositReceived(address indexed from, uint256 amount, uint256 time);\n    event MultiDepositReceived(address indexed from, uint256 numberOfValidators, uint256 totalBond, uint256 time);\n    event DepositFor(address indexed nodeAddress, address indexed from, uint256 amount, uint256 time);\n    event Withdrawal(address indexed nodeAddress, address indexed to, uint256 amount, uint256 time);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 5;\n    }\n\n    /// @notice Accept incoming ETH from the deposit pool\n    receive() external payable onlyLatestContract(\"rocketDepositPool\", msg.sender) {}\n\n    /// @notice Accept incoming ETH from the vault\n    function receiveVaultWithdrawalETH() external payable {}\n\n    /// @notice Returns the bond requirement for the given number of validators\n    /// @param _numValidators The number of validator to calculate the bond requirement for\n    function getBondRequirement(uint256 _numValidators) override public view returns (uint256) {\n        if (_numValidators == 0) {\n            return 0;\n        }\n        // Get contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Calculate bond requirement (per RPIP-42)\n        uint256[] memory baseBondArray = rocketDAOProtocolSettingsNode.getBaseBondArray();\n        if (_numValidators - 1 < baseBondArray.length) {\n            return baseBondArray[_numValidators - 1];\n        }\n        uint256 reducedBond = rocketDAOProtocolSettingsNode.getReducedBond();\n        return baseBondArray[baseBondArray.length - 1] + (_numValidators - baseBondArray.length) * reducedBond;\n    }\n\n    /// @notice Returns a node operator's credit balance in ETH\n    /// @param _nodeAddress Address of the node operator to query for\n    function getNodeDepositCredit(address _nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", _nodeAddress)));\n    }\n\n    /// @notice Returns the current ETH balance for the given node operator\n    /// @param _nodeAddress Address of the node operator to query for\n    function getNodeEthBalance(address _nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.eth.balance\", _nodeAddress)));\n    }\n\n    /// @notice Returns the sum of the credit balance of a given node operator and their balance\n    /// @param _nodeAddress Address of the node operator to query for\n    function getNodeCreditAndBalance(address _nodeAddress) override external view returns (uint256) {\n        return getNodeDepositCredit(_nodeAddress) + getNodeEthBalance(_nodeAddress);\n    }\n\n    /// @notice Returns the sum of the amount of ETH credit currently usable by a given node operator and their balance\n    /// @param _nodeAddress Address of the node operator to query for\n    function getNodeUsableCreditAndBalance(address _nodeAddress) override external view returns (uint256) {\n        return getNodeUsableCredit(_nodeAddress) + getNodeEthBalance(_nodeAddress);\n    }\n\n    /// @notice Returns the amount of ETH credit currently usable by a given node operator\n    /// @param _nodeAddress Address of the node operator to query for\n    function getNodeUsableCredit(address _nodeAddress) override public view returns (uint256) {\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        uint256 depositPoolBalance = rocketDepositPool.getBalance();\n        uint256 usableCredit = getNodeDepositCredit(_nodeAddress);\n        if (usableCredit > depositPoolBalance) {\n            usableCredit = depositPoolBalance;\n        }\n        return usableCredit;\n    }\n\n    /// @dev Increases a node operators deposit credit balance\n    /// @param _nodeAddress Address of the node operator to increase deposit balance for\n    /// @param _amount Amount to increase deposit credit balance by\n    function increaseDepositCreditBalance(address _nodeAddress, uint256 _amount) override external onlyLatestContract(\"rocketNodeDeposit\", address(this)) {\n        // Accept calls from network contracts or registered minipools\n        require(\n            (\n                getBool(keccak256(abi.encodePacked(\"minipool.exists\", msg.sender))) ||\n                getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender)))\n            ),\n            \"Invalid or outdated network contract\"\n        );\n        // Increase credit balance\n        addUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", _nodeAddress)), _amount);\n    }\n\n    /// @notice Deposits ETH for the given node operator\n    /// @param _nodeAddress The address of the node operator to deposit ETH for\n    function depositEthFor(address _nodeAddress) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(_nodeAddress) {\n        // Send the ETH to vault\n        uint256 amount = msg.value;\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.depositEther{value: amount}();\n        // Increment balance\n        addUint(keccak256(abi.encodePacked(\"node.eth.balance\", _nodeAddress)), amount);\n        // Log it\n        emit DepositFor(_nodeAddress, msg.sender, amount, block.timestamp);\n    }\n\n    /// @notice Withdraws ETH from a node operator's balance. Must be called from withdrawal address.\n    /// @param _nodeAddress Address of the node operator to withdraw from\n    /// @param _amount Amount of ETH to withdraw\n    function withdrawEth(address _nodeAddress, uint256 _amount) external onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(_nodeAddress) {\n        // Check valid caller\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        require(msg.sender == withdrawalAddress, \"Only withdrawal address can withdraw ETH\");\n        // Check balance and update\n        uint256 balance = getNodeEthBalance(_nodeAddress);\n        require(balance >= _amount, \"Insufficient balance\");\n        setUint(keccak256(abi.encodePacked(\"node.eth.balance\", _nodeAddress)), balance - _amount);\n        // Withdraw the funds\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.withdrawEther(_amount);\n        // Send funds to withdrawalAddress\n        (bool success,) = withdrawalAddress.call{value: _amount}(\"\");\n        require(success, \"Failed to withdraw ETH\");\n        // Log it\n        emit Withdrawal(_nodeAddress, withdrawalAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Accept a node deposit and create a new validator under the node. Only accepts calls from registered nodes\n    /// @param _bondAmount The amount of capital the node operator wants to put up as his bond\n    /// @param _useExpressTicket If the express queue should be used \n    /// @param _validatorPubkey Pubkey of the validator the node operator wishes to migrate\n    /// @param _validatorSignature Signature from the validator over the deposit data\n    /// @param _depositDataRoot The hash tree root of the deposit data (passed onto the deposit contract on pre stake)\n    function deposit(uint256 _bondAmount, bool _useExpressTicket, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Check amount\n        require(msg.value == _bondAmount, \"Invalid value\");\n        // Process the deposit\n        _deposit(_bondAmount, _useExpressTicket, _validatorPubkey, _validatorSignature, _depositDataRoot, msg.value);\n    }\n\n    /// @notice Accept a node deposit and create a new validator under the node. Only accepts calls from registered nodes\n    /// @param _bondAmount The amount of capital the node operator wants to put up as his bond\n    /// @param _useExpressTicket If the express queue should be used \n    /// @param _validatorPubkey Pubkey of the validator the node operator wishes to migrate\n    /// @param _validatorSignature Signature from the validator over the deposit data\n    /// @param _depositDataRoot The hash tree root of the deposit data (passed onto the deposit contract on pre stake)\n    function depositWithCredit(uint256 _bondAmount, bool _useExpressTicket, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Process the deposit\n        uint256 balanceToUse = useCreditOrBalanceIfRequired(_bondAmount);\n        _deposit(_bondAmount, _useExpressTicket, _validatorPubkey, _validatorSignature, _depositDataRoot, msg.value + balanceToUse);\n    }\n\n    /// @notice Processes multiple node deposits in one call\n    /// @param _deposits Array of deposits to process\n    function depositMulti(NodeDeposit[] calldata _deposits) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Check pre-conditions\n        require(_deposits.length > 0, \"Must perform at least 1 deposit\");\n        checkDepositsEnabled();\n        // Get or deploy a megapool for the caller\n        RocketMegapoolFactoryInterface rocketMegapoolFactory = RocketMegapoolFactoryInterface(getContractAddress(\"rocketMegapoolFactory\"));\n        RocketMegapoolInterface megapool = RocketMegapoolInterface(rocketMegapoolFactory.getOrDeployContract(msg.sender));\n        RocketMegapoolManagerInterface rocketMegapoolManager = RocketMegapoolManagerInterface(getContractAddress(\"rocketMegapoolManager\"));\n        // Iterate deposits and execute\n        uint256 totalBond = 0;\n        for (uint256 i = 0; i < _deposits.length; ++i) {\n            NodeDeposit calldata deposit = _deposits[i];\n            // Validate arguments\n            validateBytes(deposit.validatorPubkey, pubKeyLength);\n            validateBytes(deposit.validatorSignature, signatureLength);\n            // Request a new validator from the megapool\n            rocketMegapoolManager.addValidator(address(megapool), megapool.getValidatorCount());\n            megapool.newValidator(deposit.bondAmount, deposit.useExpressTicket, deposit.validatorPubkey, deposit.validatorSignature, deposit.depositDataRoot);\n            // Sum bond total\n            totalBond += deposit.bondAmount;\n        }\n        // Check if node sent full bond amount of if we need to use credit/balance\n        uint256 balanceToUse = 0;\n        if (msg.value < totalBond) {\n            balanceToUse = useCreditOrBalanceIfRequired(totalBond);\n        }\n        // Emit deposit received event\n        emit MultiDepositReceived(msg.sender, _deposits.length, totalBond, block.timestamp);\n        // Send node operator's bond to the deposit pool\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        rocketDepositPool.nodeDeposit{value: msg.value + balanceToUse}(totalBond);\n        // Attempt to assign 1 minipool/megapool for each deposit\n        rocketDepositPool.maybeAssignDeposits(_deposits.length);\n    }\n\n    /// @dev Internal logic to process a deposit\n    /// @param _bondAmount The amount of capital the node operator wants to put up as his bond\n    /// @param _useExpressTicket If the express queue should be used\n    /// @param _validatorPubkey Pubkey of the validator the node operator wishes to migrate\n    /// @param _validatorSignature Signature from the validator over the deposit data\n    /// @param _depositDataRoot The hash tree root of the deposit data (passed onto the deposit contract on pre stake)\n    /// @param _value Total value of the deposit including any credit balance used\n    function _deposit(uint256 _bondAmount, bool _useExpressTicket, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _value) private {\n        // Validate arguments\n        validateBytes(_validatorPubkey, pubKeyLength);\n        validateBytes(_validatorSignature, signatureLength);\n        // Check pre-conditions\n        checkDepositsEnabled();\n        // Emit deposit received event\n        emit DepositReceived(msg.sender, _value, block.timestamp);\n        // Get or deploy a megapool for the caller\n        RocketMegapoolFactoryInterface rocketMegapoolFactory = RocketMegapoolFactoryInterface(getContractAddress(\"rocketMegapoolFactory\"));\n        RocketMegapoolInterface megapool = RocketMegapoolInterface(rocketMegapoolFactory.getOrDeployContract(msg.sender));\n        RocketMegapoolManagerInterface rocketMegapoolManager = RocketMegapoolManagerInterface(getContractAddress(\"rocketMegapoolManager\"));\n        // Request a new validator from the megapool\n        rocketMegapoolManager.addValidator(address(megapool), megapool.getValidatorCount());\n        megapool.newValidator(_bondAmount, _useExpressTicket, _validatorPubkey, _validatorSignature, _depositDataRoot);\n        // Send node operator's bond to the deposit pool\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        rocketDepositPool.nodeDeposit{value: _value}(_bondAmount);\n        // Attempt to assign 1 minipool/megapool\n        rocketDepositPool.maybeAssignDeposits(1);\n    }\n\n    /// @dev Reverts if deposits are not enabled\n    function checkDepositsEnabled() private {\n        // Get contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Check node settings\n        require(rocketDAOProtocolSettingsNode.getDepositEnabled(), \"Node deposits are currently disabled\");\n    }\n\n    /// @notice Validates that a byte array has the expected length\n    /// @param _data the byte array being validated\n    /// @param _length the expected length\n    function validateBytes(bytes memory _data, uint256 _length) pure internal {\n        require(_data.length == _length, \"Invalid bytes length\");\n    }\n\n    /// @dev If msg.value does not cover the bond amount, take from node's credit / balance to make up the difference\n    ///      Reverts if node does not have enough credit or ETH balance to cover the shortfall\n    /// @return Returns the amount of ETH withdrawn from the vault from the node's ETH balance\n    function useCreditOrBalanceIfRequired(uint256 _bondAmount) private returns (uint256) {\n        uint256 balanceToUse = 0;\n        uint256 creditToUse = 0;\n        uint256 shortFall = _bondAmount - msg.value;\n        uint256 credit = getNodeUsableCredit(msg.sender);\n        uint256 balance = getNodeEthBalance(msg.sender);\n        // Check credit\n        require(credit + balance >= shortFall, \"Insufficient credit\");\n        // Calculate amounts to use\n        creditToUse = shortFall;\n        if (credit < shortFall) {\n            balanceToUse = shortFall - credit;\n            creditToUse = credit;\n        }\n        // Update balances\n        if (balanceToUse > 0) {\n            subUint(keccak256(abi.encodePacked(\"node.eth.balance\", msg.sender)), balanceToUse);\n            // Withdraw the funds\n            RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n            rocketVault.withdrawEther(balanceToUse);\n        }\n        if (creditToUse > 0) {\n            subUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", msg.sender)), creditToUse);\n        }\n        return balanceToUse;\n    }\n}\n"
    }
}