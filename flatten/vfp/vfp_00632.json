{
    "vfp_id": "vfp_00632",
    "project_name": "cantina_teaxyz_nov2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-460"
                ]
            },
            "title": "Incorrect recovered address when signer's fallback function is triggered",
            "description": "1. **Description:** When a signer has a fallback function and the `isValidSignature` function is not present, the contract attempts ECDSA recovery, which may return arbitrary data instead of the expected magic value. Although the function correctly returns `false`, the `recovered` address variable retains an incorrect value from the ECDSA recovery process.\n2. **Cause:** The vulnerability arises because the code does not explicitly reset the `recovered` address to `address(0)` when the `isValidSignature` call fails or reverts. This leaves the recovered address in an undefined and potentially misleading state.\n3. **Exploitation:** An attacker could craft a malicious contract with a fallback function that returns arbitrary data, leading to incorrect state assumptions in the calling contract if the `recovered` address is used post-validation.\n4. **Impact:** While the function ultimately returns `false`, the incorrect `recovered` address could lead to logic errors or misattribution in higher-level systems relying on this value, though direct fund loss or critical control is unlikely.\n",
            "severity": "Low",
            "location": [
                "ERC20PermitWithERC1271.sol#L154-L157"
            ],
            "files": [
                "tea-token/src/TeaToken/ERC20PermitWithERC1271.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-477"
                ]
            },
            "title": "Increase & decrease allowance can be removed",
            "description": "1. **Description:** The contract includes `increaseAllowance` and `decreaseAllowance` functions that were previously part of OpenZeppelin's ERC20 implementation but have since been removed due to security concerns and best practice updates.\n2. **Cause:** These functions are no longer considered secure or necessary in modern ERC20 implementations, as they can lead to race conditions or confusion in allowance management if not handled carefully by frontends.\n3. **Exploitation:** While not directly exploitable in this context, their presence increases attack surface and may encourage unsafe usage patterns by integrators or users.\n4. **Impact:** The primary impact is a deviation from current security standards, increasing maintenance burden and potential for misuse, though no direct exploit path is identified.\n",
            "severity": "Low",
            "location": [
                "Tea.sol#L127-L135"
            ],
            "files": [
                "tea-token/src/TeaToken/Tea.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused structs, variables & imports",
            "description": "1. **Description:** Several structs, variables, and imports are declared but never used in the codebase, including in EIP3009.sol, ERC20PermitWithERC1271.sol, and Tea.sol.\n2. **Cause:** These unused elements were likely left over from earlier development stages or copied from templates without subsequent cleanup.\n3. **Exploitation:** These cannot be directly exploited but contribute to code bloat and reduce readability and auditability.\n4. **Impact:** The impact is purely on code maintainability and clarity, with no direct security risk. However, they may distract auditors or developers and increase the cost of future reviews.\n",
            "severity": "Informational",
            "location": [
                "EIP3009.sol#L30-L77",
                "ERC20PermitWithERC1271.sol#L13-L43",
                "Tea.sol#L19",
                "Tea.sol#L36-L38"
            ],
            "files": [
                "tea-token/src/TeaToken/EIP3009.sol",
                "tea-token/src/TeaToken/ERC20PermitWithERC1271.sol",
                "tea-token/src/TeaToken/Tea.sol"
            ]
        }
    ],
    "affected_files": {
        "EIP3009.sol": "/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npragma solidity 0.8.26;\n\nimport { ERC20Permit } from \"./ERC20PermitWithERC1271.sol\";\nimport { IERC1271 } from \"@openzeppelin/interfaces/IERC1271.sol\";\n\n/**\n * `TransferWithAuthorization` is the struct identifier name.\n * - `address` is the atomic type of named `the sender`.\n * - `address` is the atomic type of named `the receiver`.\n * - `uint256` is the atomic type of named `value`.\n * - `uint256` is the atomic type of named `validAfter`\n * - `uint256` is the atomic type of named `validBefore`\n * - `uint256` is the atomic type of the randomly \n *    generated value during the signing process named `nonce`.\n */\nstruct TransferWithAuthorization {\n    address from;\n    address to;\n    uint256 value;\n    uint256 validAfter;\n    uint256 validBefore;\n    uint256 nonce;\n}\n\n/**\n * `ReceiveWithAuthorization` is the struct identifier name.\n * - `address` is the atomic type of named `the sender`.\n * - `address` is the atomic type of named `the receiver`.\n * - `uint256` is the atomic type of named `value`.\n * - `uint256` is the atomic type of named `validAfter`\n * - `uint256` is the atomic type of named `validBefore`\n * - `uint256` is the atomic type of the randomly \n *    generated value during the signing process named `nonce`.\n */\nstruct ReceiveWithAuthorization {\n    address from;\n    address to;\n    uint256 value;\n    uint256 validAfter;\n    uint256 validBefore;\n    uint256 nonce;\n}\n\n/**\n * `CancelWithAuthorization` is the struct identifier name.\n * - `address` is the atomic type of named `the authorizaer`.\n * - `uint256` is the atomic type of the randomly \n *    generated value during the signing process named `nonce`.\n */\nstruct CancelAuthorization {\n    address authorizer;\n    uint256 nonce;\n}\n\n\nabstract contract EIP3009 is ERC20Permit {\n    // keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    // keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n    // keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n    bytes32\n        public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n    /**\n     * @dev authorizer address => nonce => state (true = used / false = unused)\n     */\n    mapping(address => mapping(bytes32 => bool)) internal _authorizationStates;\n\n    /**\n     * @dev Invalid signature for authorization.\n     */\n    error EIP3009InvalidSignature();\n\n    /**\n     * @dev Authorization has already been used.\n     */\n    error EIP3009AuthorizationAlreadyUsed(address authorizer, bytes32 nonce);\n\n    /**\n     * @dev Authorization is not yet valid.\n     */\n    error EIP3009AuthorizationNotYetValid(uint256 validAfter, uint256 currentTime);\n\n    /**\n     * @dev Authorization has expired.\n     */\n    error EIP3009AuthorizationExpired(uint256 validBefore, uint256 currentTime);\n\n    /**\n     * @dev Caller is not the payee.\n     */\n    error EIP3009CallerMustBePayee(address caller, address payee);\n\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event AuthorizationCanceled(\n        address indexed authorizer,\n        bytes32 indexed nonce\n    );\n\n    /**\n     * @notice Returns the state of an authorization\n     * @dev Nonces are randomly generated 32-byte data unique to the authorizer's\n     * address\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @return True if the nonce is used\n     */\n    function authorizationState(address authorizer, bytes32 nonce)\n        external\n        virtual\n        view\n        returns (bool)\n    {\n        return _authorizationStates[authorizer][nonce];\n    }\n\n    /**\n     * @notice Execute a transfer with a signed authorization\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        bytes memory signature = rsvToSig(r, s, v);\n        transferWithAuthorization(from, to, value, validAfter, validBefore, nonce, signature);\n    }\n\n    /**\n     * @notice Execute a transfer with a signed authorization (bytes signature for 7702/passkey)\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param signature     Signature bytes\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes memory signature\n    ) public virtual {\n        _transferWithAuthorizationBytes(\n            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            signature\n        );\n    }\n\n    /**\n     * @notice Receive a transfer with a signed authorization from the payer\n     * @dev This has an additional check to ensure that the payee's address matches\n     * the caller of this function to prevent front-running attacks. (See security\n     * considerations)\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function receiveWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        bytes memory signature = rsvToSig(r, s, v);\n        receiveWithAuthorization(from, to, value, validAfter, validBefore, nonce, signature);\n    }\n\n    /**\n     * @notice Receive a transfer with a signed authorization (bytes signature for 7702/passkey)\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param signature     Signature bytes\n     */\n    function receiveWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes memory signature\n    ) public virtual {\n        if (to != msg.sender) {\n            revert EIP3009CallerMustBePayee(msg.sender, to);\n        }\n\n        _transferWithAuthorizationBytes(\n            RECEIVE_WITH_AUTHORIZATION_TYPEHASH,\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            signature\n        );\n    }\n\n    /**\n     * @notice Attempt to cancel an authorization\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        bytes memory signature = rsvToSig(r, s, v);\n        cancelAuthorization(authorizer, nonce, signature);\n    }\n\n    /**\n     * @notice Cancel an authorization (bytes signature for 7702/passkey)\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param signature     Signature bytes\n     */\n    function cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        bytes memory signature\n    ) public virtual {\n        if (_authorizationStates[authorizer][nonce]) {\n            revert EIP3009AuthorizationAlreadyUsed(authorizer, nonce);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(\n            CANCEL_AUTHORIZATION_TYPEHASH,\n            authorizer,\n            nonce\n        ));\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _domainSeparatorV4(),\n                structHash\n            )\n        );\n        \n        if (!_verifySig(authorizer, digest, signature)) {\n            revert EIP3009InvalidSignature();\n        }\n\n        _authorizationStates[authorizer][nonce] = true;\n        emit AuthorizationCanceled(authorizer, nonce);\n    }\n\n    function _transferWithAuthorization(\n        bytes32 typeHash,\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal virtual {\n        bytes memory signature = rsvToSig(r, s, v);\n        _transferWithAuthorizationBytes(typeHash, from, to, value, validAfter, validBefore, nonce, signature);\n    }\n\n    function _transferWithAuthorizationBytes(\n        bytes32 typeHash,\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes memory signature\n    ) internal virtual {\n        if (block.timestamp <= validAfter) {\n            revert EIP3009AuthorizationNotYetValid(validAfter, block.timestamp);\n        }\n        if (block.timestamp >= validBefore) {\n            revert EIP3009AuthorizationExpired(validBefore, block.timestamp);\n        }\n        if (_authorizationStates[from][nonce]) {\n            revert EIP3009AuthorizationAlreadyUsed(from, nonce);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(\n            typeHash,\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce\n        ));\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _domainSeparatorV4(),\n                structHash\n            )\n        );\n        \n        if (!_verifySig(from, digest, signature)) {\n            revert EIP3009InvalidSignature();\n        }\n\n        _authorizationStates[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transfer(from, to, value);\n    }\n}",
        "ERC20PermitWithERC1271.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"@openzeppelin/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20} from \"@openzeppelin/token/ERC20/ERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"@openzeppelin/utils/Nonces.sol\";\nimport {IERC1271} from \"@openzeppelin/interfaces/IERC1271.sol\";\n\n/**\n * `Permit` is the struct identifier name.\n * - `address` is the atomic type of named `owner`.\n * - `address` is the atomic type of named `spender`.\n * - `uint256` is the atomic type of named `value`.\n * - `uint256` is the atomic type of the randomly \n *    generated value during the signing process named `nonce`.\n * - `uint256` is the atomic type of named `deadline`\n */\nstruct Permit {\n    address owner;\n    address spender;\n    uint256 value;\n    uint256 nonce;\n    uint256 deadline;\n}\n\n/**\n * `Permit` is the struct identifier name.\n * - `address` is the atomic type of named `owner`.\n * - `uint256` is the atomic type of named `amount`.\n * - `uint256` is the atomic type of the randomly \n *    generated value during the signing process named `nonce`.\n * - `uint256` is the atomic type of named `deadline`\n */\nstruct PermitBurn {\n    address owner;\n    uint256 amount;\n    uint256 nonce;\n    uint256 deadline;\n}\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // PermitBurn typehash: owner authorizes burning `amount` with a nonce and deadline\n    bytes32 public constant PERMIT_BURN_TYPEHASH =\n        keccak256(\"PermitBurn(address owner,uint256 amount,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        bytes memory signature = rsvToSig(r, s, v);\n        permit(owner, spender, value, deadline, signature);\n    }\n\n    /**\n     * @notice Permit with bytes signature (for 7702/passkey/ERC-1271 compatibility)\n     * @param owner         Token owner's address\n     * @param spender       Spender's address\n     * @param value         Amount to approve\n     * @param deadline      Signature expiry timestamp\n     * @param signature     Signature bytes (can be 65-byte ECDSA or arbitrary ERC-1271)\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes memory signature\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        // SECURITY: Read nonce WITHOUT consuming it yet (prevent griefing attack)\n        // If we consume nonce before verification, attacker can grief by submitting invalid signatures\n        uint256 currentNonce = nonces(owner);\n        \n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        \n        // Verify signature BEFORE consuming nonce\n        (bool valid, address recovered) = _verifySignature(owner, digest, signature);\n        if (!valid) {\n            revert ERC2612InvalidSigner(recovered, owner);\n        }\n\n        // ONLY consume nonce after successful verification\n        _useNonce(owner);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Internal signature verification with ERC-1271 support\n     * @param signer        Expected signer address\n     * @param digest        EIP-712 digest to verify\n     * @param signature     Signature bytes\n     * @return valid        True if signature is valid\n     * @return recovered    Recovered address (if ECDSA) or zero address (if ERC-1271)\n     */\n    function _verifySignature(\n        address signer,\n        bytes32 digest,\n        bytes memory signature\n    ) internal view returns (bool valid, address recovered) {\n        // Try ECDSA recovery for EOAs\n        ECDSA.RecoverError err;\n        (recovered, err,) = ECDSA.tryRecover(digest, signature);\n        if (err == ECDSA.RecoverError.NoError && recovered == signer) {\n            return (true, recovered);\n        }\n        \n        // Try ERC-1271 for smart contract wallets\n        if (signer.code.length > 0) {\n            try IERC1271(signer).isValidSignature(digest, signature) returns (bytes4 magicValue) {\n                if (magicValue == IERC1271.isValidSignature.selector) {\n                    return (true, address(0));\n                }\n            } catch {\n                return (false, recovered);\n            }\n        }\n        \n        return (false, recovered);\n    }\n\n    /**\n     * @notice Internal signature verification (bool-only return for internal use)\n     */\n    function _verifySig(\n        address signer,\n        bytes32 digest,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool valid,) = _verifySignature(signer, digest, signature);\n        return valid;\n    }\n\n    /**\n     * @notice Internal helper to convert r,s,v to 65-byte signature\n     */\n    function rsvToSig(bytes32 _a, bytes32 _b, uint8 _c) internal pure returns (bytes memory) {\n        bytes memory bytesArray = new bytes(65);\n        for (uint256 i; i < 32; i++) {\n            bytesArray[i] = _a[i];\n        }\n        for (uint256 i = 32; i < 64; i++) {\n            bytesArray[i] = _b[i-32];\n        }\n        bytesArray[64] = bytes1(_c);\n        return bytesArray;\n    }\n\n    /**\n     * @notice Permit-based burn using v,r,s\n     * @dev Mirrors the permit flow but burns `amount` from `owner` after signature verification\n     */\n    function permitBurn(\n        address owner,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        bytes memory signature = rsvToSig(r, s, v);\n        permitBurn(owner, amount, deadline, signature);\n    }\n\n    /**\n     * @notice Permit-based burn using bytes signature (supports ERC-1271 and passkey formats)\n     */\n    function permitBurn(\n        address owner,\n        uint256 amount,\n        uint256 deadline,\n        bytes memory signature\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        uint256 currentNonce = nonces(owner);\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_BURN_TYPEHASH, owner, amount, currentNonce, deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n\n        (bool valid, address recovered) = _verifySignature(owner, digest, signature);\n        if (!valid) {\n            revert ERC2612InvalidSigner(recovered, owner);\n        }\n\n        // Consume nonce only after successful verification\n        _useNonce(owner);\n\n        // Perform the burn\n        _burn(owner, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n",
        "Tea.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.26;\n\n/*                                      _@@                                       \n _@                @_              _@@@@@                                       \n @@   @@@@@    _@@ #@\\           @@@@@@@@@@      @@@--@@@         @@@@--@@@_    \n/@% @@@   @@@@@@@   @@   @@       @@@@@@@     @@@@#    @@@@     @@@@@    @@@@@  \n@@                  @@   @@       @@@@@@@    @@@@@     @@@@@    @@@@~    @@@@@@ \n@@                  @@            @@@@@@@   @@@@@@@@@@@@@@@@@           @@@@@@@ \nt@@                 @@   @@       @@@@@@@   @@@@@@                  @@@@#@@@@@@ \n @@                @@@  @@@       @@@@@@@   @@@@@@@             @@@@@+   @@@@@@ \n t@@              j@@   @@        @@@@@@@   #@@@@@@@          _@@@@@     @@@@@@ \n  \\@@            @@@    @         @@@@@@@    @@@@@@@@_        @@@@@@@   _@@@@@@ \n    @%  @@@@@@@  @                 @@@@@@@@    @@@@@@@@@@@@   +@@@@@@@@@#@@@@@@ \n         t@@@/                      t@@@@+       t@@@@@@        @@@@@@+    t@@@@\n*/\n\n/* solhint-disable no-unused-import */\nimport { EIP712 } from \"@openzeppelin/utils/cryptography/EIP712.sol\";\nimport { ERC20 } from \"@openzeppelin/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/interfaces/IERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/interfaces/IERC721.sol\";\nimport { Ownable } from \"@openzeppelin/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/utils/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n/* solhint-enable no-unused-import */\nimport { Ownable2Step } from \"@openzeppelin/access/Ownable2Step.sol\";\nimport { ERC20Permit } from \"./ERC20PermitWithERC1271.sol\";\nimport { EIP3009 } from \"./EIP3009.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract Tea is Ownable2Step, EIP3009, ERC20Burnable, ReentrancyGuard {\n    // Add using directive (at contract level)\n    using SafeERC20 for IERC20;\n\n    bytes4 public constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n\n    bytes4 constant ERC1271_INVALID_SIGNATURE = 0xffffffff;\n\n    address public timelock;\n    address public constant TREASURY_SAFE = 0xcDb68686290310dD8623371E1db53157dB6b8cA1;\n\n    /* -------------------------------- Constants ------------------------------- */\n\n    uint256 public constant INITIAL_SUPPLY = 100_000_000_000 ether;\n\n    /**\n     * @dev Invalid signature for authorization.\n     */\n    error CannotRecoverOwnTokens();\n\n    /**\n     * @dev Invalid owner for timelock transactions\n     */\n    error CallerIsNotTimelock();\n\n    /**\n     * @dev Recover native failed\n     */\n    error RecoverNativeFailed(address to, uint256 amount);\n\n    event RecoveredToken(address indexed token, address indexed to, uint256 amount);\n    event RecoveredNFT(address indexed token, address indexed to, uint256 tokenId);\n    event RecoveredNative(address indexed to, uint256 amount);\n\n    /* --------------------------------- Globals -------------------------------- */\n\n    /// @notice Total number of tokens minted, including burned tokens\n    uint256 public totalMinted;\n\n    /* ------------------------------- Constructor ------------------------------ */\n\n    constructor(address initialGovernor_, address timelock_)\n        ERC20(\"TEA\", \"TEA\")\n        ERC20Permit(\"TEA\")\n        Ownable(initialGovernor_)\n    {\n        timelock = timelock_;\n        totalMinted = INITIAL_SUPPLY;\n\n        _mint(initialGovernor_, INITIAL_SUPPLY);\n    }\n\n    /* ------------------------------- Mint / Burn ------------------------------ */\n\n    /// @notice Mints new tokens to `account` (only callable by the owner).\n    /// @dev Increments `totalMinted`.\n    /// @param account The address to receive minted tokens.\n    /// @param value   The amount of tokens to be minted.\n    function mintTo(address account, uint256 value) external onlyOwner {\n        totalMinted = totalMinted + value;\n\n        _mint(account, value);\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, allowance(_msgSender(), spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = allowance(_msgSender(), spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    modifier onlyTimelock() {\n        require(msg.sender == timelock, CallerIsNotTimelock());\n        _;\n    }\n\n    /**\n     * @dev transfers timelocked functions to a different timelock\n     * @param newTimelock The address of the new timelock\n     */\n    function transferTimelock(address newTimelock) onlyTimelock external virtual {\n        timelock = newTimelock;\n    }\n\n    /**\n     * @dev Allows the contract owner to recover any ERC-20 tokens\n     * that were accidentally sent to this contract.\n     * @param tokenAddress The address of the ERC-20 token to recover.\n     * @param amount The amount of the ERC-20 token to recover\n     */\n    function recoverToken(address tokenAddress, uint256 amount) external virtual onlyTimelock nonReentrant {\n        // Require that the token address is not the contract's own token.\n        require(tokenAddress != address(this), CannotRecoverOwnTokens());\n\n        IERC20 token = IERC20(tokenAddress);\n\n        // Transfer the tokens from this contract to the specified address.\n        token.safeTransfer(TREASURY_SAFE, amount);\n        \n        emit RecoveredToken(tokenAddress, TREASURY_SAFE, amount);\n    }\n    \n    /**\n     * @dev Allows the contract owner to recover any ERC-20 tokens\n     * that were accidentally sent to this contract.\n     * @param tokenAddress The address of the ERC-20 token to recover.\n     * @param tokenId The address to which the recoverd tokens will be sent.\n     */\n    function recoverNFT(\n        address tokenAddress,\n        uint256 tokenId\n    ) external virtual onlyTimelock nonReentrant {\n        // Use the IERC721 interface to safely transfer the NFT from this contract\n        IERC721 nft = IERC721(tokenAddress);\n        \n        // This line attempts the safe transfer of the NFT\n        nft.safeTransferFrom(address(this), TREASURY_SAFE, tokenId);\n\n        emit RecoveredNFT(tokenAddress, TREASURY_SAFE, tokenId);\n    }\n\n    /**\n     * @dev Allow the contract owner to recover Tea tokens\n     * @param amount amount of token to sweep\n     */\n    function sweepSelf(uint256 amount) external virtual onlyTimelock nonReentrant {\n        _transfer(address(this), TREASURY_SAFE, amount);\n    }\n\n    /**\n     * @dev Allows the contract owner to recover any ETH\n     * that was accidentally sent to this contract via self destruct.\n     */\n    function recoverNative(uint256 amount) external virtual onlyTimelock nonReentrant {\n        (bool ok, ) = TREASURY_SAFE.call{value: amount}(\"\");\n        if (!ok) revert RecoverNativeFailed(TREASURY_SAFE, amount);\n\n        emit RecoveredNative(TREASURY_SAFE, amount);\n    }\n\n    error NativeNotAccepted();\n    receive() external payable { revert NativeNotAccepted(); }\n    fallback() external payable { revert NativeNotAccepted(); }\n}\n"
    }
}