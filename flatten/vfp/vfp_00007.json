{
    "vfp_id": "vfp_00007",
    "project_name": "ackee-blockchain-cow-flash-loan-router-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "W1: Missing events",
            "description": "1. **Description:** The FlashLoanRouter contract does not emit an event to track which solver initiated a settlement, resulting in loss of off-chain traceability. While the CoW Settlement contract emits a Settlement event, when invoked via FlashLoanRouter, the msg.sender becomes the router contract itself, obscuring the original solver identity.\n\n2. **Cause:** The absence of an explicit event emission in the FlashLoanRouter contract for settlements initiated through it. This design omits critical off-chain monitoring capabilities.\n\n3. **Exploitation:** This issue cannot be exploited maliciously, but it hampers the ability of off-chain services (e.g., analytics, monitoring, or indexing systems) to correctly attribute settlement actions to the original solver.\n\n4. **Impact:** The impact is limited to operational transparency and observability. Without proper event logging, it becomes difficult to debug, monitor, or attribute actions in the system, potentially affecting trust and auditability.\n",
            "severity": "Informational",
            "location": [
                "FlashLoanRouter.sol::flashLoanAndSettle"
            ],
            "files": [
                "flash-loan-router/src/FlashLoanRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "FlashLoanRouter.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IBorrower} from \"./interface/IBorrower.sol\";\nimport {ICowSettlement} from \"./interface/ICowSettlement.sol\";\nimport {IFlashLoanRouter} from \"./interface/IFlashLoanRouter.sol\";\nimport {Loan} from \"./library/Loan.sol\";\nimport {LoansWithSettlement} from \"./library/LoansWithSettlement.sol\";\nimport {ICowAuthentication} from \"./vendored/ICowAuthentication.sol\";\nimport {IERC20} from \"./vendored/IERC20.sol\";\n\n/// @title Flash-loan Router\n/// @author CoW DAO developers\n/// @notice Solver contract for CoW Protocol that requests flash loans before\n/// executing a settlement. Every CoW Protocol solver can call this\n/// contract to borrow the funds needed for executing a settlement.\ncontract FlashLoanRouter is IFlashLoanRouter {\n    using LoansWithSettlement for bytes;\n\n    /// @notice Flag address signalling that the router is not currently\n    /// preparing or executing a settlement. This is the case at the start or\n    /// at the end of the call to `flashLoanAndSettle`.\n    IBorrower internal constant READY = IBorrower(address(0));\n    /// @notice Flag address signalling that the router is currently in the\n    /// process of executing a settlement.\n    IBorrower internal constant SETTLING = IBorrower(address(bytes20(keccak256(\"FlashLoanRouter: settling\"))));\n\n    /// @inheritdoc IFlashLoanRouter\n    ICowSettlement public immutable settlementContract;\n    /// @inheritdoc IFlashLoanRouter\n    ICowAuthentication public immutable settlementAuthentication;\n\n    /// @notice This variable has the following possible values:\n    /// - `READY` (default), before or after a (successful) settlement\n    /// - `SETTLING`, if the flash-loan collection phase terminated and the last\n    ///   phase of the settlement with flash loan has started.\n    /// - The address of the borrower that is expected to call this contract\n    /// Â  back.\n    /// This variable it the main actor responsible for controlling the\n    /// execution order of flash loan and final settlement.\n    IBorrower internal transient pendingBorrower;\n    /// @notice The router expects the borrower to send back some data verbatim.\n    /// The hash of the data is stored in this variable for validation.\n    bytes32 internal transient pendingDataHash;\n\n    /// @notice Only a solver of CoW Protocol can call this function.\n    modifier onlySolver() {\n        require(settlementAuthentication.isSolver(msg.sender), \"Not a solver\");\n        _;\n    }\n\n    /// @notice The router is waiting for a call back from a specific borrower,\n    /// no other addresses should be calling this function.\n    modifier onlyPendingBorrower() {\n        require(msg.sender == address(pendingBorrower), \"Not the pending borrower\");\n        _;\n    }\n\n    /// @param _settlementContract The settlement contract that this router will\n    /// be supporting.\n    constructor(ICowSettlement _settlementContract) {\n        settlementContract = _settlementContract;\n        settlementAuthentication = ICowAuthentication(_settlementContract.authenticator());\n    }\n\n    /// @inheritdoc IFlashLoanRouter\n    /// @dev Despite this contract being expected to be a solver, there is no\n    /// way for this contract to call itself at `flashLoanAndSettle`.\n    function flashLoanAndSettle(Loan.Data[] calldata loans, bytes calldata settlement) external onlySolver {\n        require(pendingBorrower == READY, \"Another settlement in progress\");\n        bytes memory loansWithSettlement = LoansWithSettlement.encode(loans, settlement);\n        borrowNextLoan(loansWithSettlement);\n        // The following parameter is expected to be set before the final call\n        // to `settle()` is executed. This flag being set means that no more\n        // calls to `borrowerCallBack` are pending nor possible.\n        require(pendingBorrower == SETTLING, \"Terminated without settling\");\n        // We reset the borrower to make it possible to call this function again\n        // in the same transaction.\n        pendingBorrower = READY;\n    }\n\n    /// @inheritdoc IFlashLoanRouter\n    /// @dev Note that the contract cannot call itself as a borrower because it\n    /// doesnt implement the expected interface.\n    function borrowerCallBack(bytes memory loansWithSettlement) external onlyPendingBorrower {\n        // When the borrower is called, it's given some extra data that is\n        // expected to be passed back here without changes.\n        require(loansWithSettlement.hash() == pendingDataHash, \"Data from borrower not matching\");\n        borrowNextLoan(loansWithSettlement);\n    }\n\n    /// @notice Takes the input loans with settlements; if none is available, it\n    /// calls settle; otherwise, it requests the next loan from the borrower.\n    /// @param loansWithSettlement List of loans with settlement to process.\n    function borrowNextLoan(bytes memory loansWithSettlement) private {\n        if (loansWithSettlement.loanCount() == 0) {\n            // We set the borrower to some value different from `READY` or any\n            // intermediate borrower address to prevent reentrancy.\n            pendingBorrower = SETTLING;\n            settle(loansWithSettlement.destroyToSettlement());\n        } else {\n            (uint256 amount, IBorrower borrower, address lender, IERC20 token) = loansWithSettlement.popLoan();\n            pendingBorrower = borrower;\n            pendingDataHash = loansWithSettlement.hash();\n            borrower.flashLoanAndCallBack(lender, token, amount, loansWithSettlement);\n        }\n    }\n\n    /// @notice Execute a CoW Protocol settlement.\n    /// @param settlement The ABI-encoded call data for a call to `settle()` (as\n    /// in `abi.encodeCall`).\n    function settle(bytes memory settlement) private {\n        require(selector(settlement) == ICowSettlement.settle.selector, \"Only settle() is allowed\");\n        (bool result,) = address(settlementContract).call(settlement);\n        require(result, \"Settlement reverted\");\n    }\n\n    /// @notice Extracts the Solidity ABI selector for the specified ABI-encode\n    /// call data.\n    /// @dev We assume that the input array is a valid bytes array as stored in\n    /// memory by Solidity and its content can be read.\n    /// @param callData ABI-encoded call data as per `abi.encodeCall`.\n    /// @return result The 4 byte function selector of the call encoded in\n    /// this interaction (or zero bytes if the data is shorter).\n    function selector(bytes memory callData) internal pure returns (bytes4 result) {\n        if (callData.length >= 4) {\n            // NOTE: Read the first 32 bytes in the array. The value does not\n            // need to be shifted since `bytesN` values are left aligned, and\n            // the value does not need to be masked since masking occurs when\n            // the value is accessed and not stored. The first word of the\n            // memory data is the call data length, the content starts in the\n            // next word.\n            // <https://docs.soliditylang.org/en/v0.8.28/internals/layout_in_memory.html>\n            // <https://docs.soliditylang.org/en/v0.8.28/assembly.html#access-to-external-variables-functions-and-libraries>\n            // solhint-disable-next-line no-inline-assembly\n            // Addition overflow can only happen if the input bytes point to a\n            // memory address close to (`type(uint256).max`), which would not be\n            // accessible in Solidity without the call running out of gas.\n            assembly {\n                result := mload(add(callData, 32))\n            }\n        }\n    }\n}\n"
    }
}